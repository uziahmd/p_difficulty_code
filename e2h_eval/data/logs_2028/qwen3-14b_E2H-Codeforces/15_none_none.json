{
    "start": 1757842783.0066276,
    "end": 1757842795.3844965,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 15,
    "thought": "",
    "response": "```python\nimport sys\nimport threading\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n\n    # We need to assign directions to edges such that:\n    # 1. Flow conservation at intermediate nodes\n    # 2. Source (node 1) has no incoming edges\n    # 3. The directed graph is acyclic\n\n    # We can use a DFS-based approach to assign directions\n    # We will build a directed tree rooted at node 1, and assign directions accordingly\n\n    parent = [0] * (n + 1)\n    direction = [0] * m  # 0 means ai -> bi, 1 means bi -> ai\n    visited = [False] * (n + 1)\n\n    def dfs(u):\n        visited[u] = True\n        for v, idx in graph[u]:\n            if not visited[v]:\n                parent[v] = u\n                # Assign direction from u to v\n                if edges[idx][0] == u and edges[idx][1] == v:\n                    direction[idx] = 0\n                else:\n                    direction[idx] = 1\n                dfs(v)\n\n    dfs(1)\n\n    # Now we need to make sure that the directed graph is acyclic\n    # Since we built it as a tree, it's acyclic by definition\n    # Also, flow conservation is ensured because we're building a tree from the source\n\n    for d in direction:\n        print(d)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n\n    # We need to assign directions to edges such that:\n    # 1. Flow conservation at intermediate nodes\n    # 2. Source (node 1) has no incoming edges\n    # 3. The directed graph is acyclic\n\n    # We can use a DFS-based approach to assign directions\n    # We will build a directed tree rooted at node 1, and assign directions accordingly\n\n    parent = [0] * (n + 1)\n    direction = [0] * m  # 0 means ai -> bi, 1 means bi -> ai\n    visited = [False] * (n + 1)\n\n    def dfs(u):\n        visited[u] = True\n        for v, idx in graph[u]:\n            if not visited[v]:\n                parent[v] = u\n                # Assign direction from u to v\n                if edges[idx][0] == u and edges[idx][1] == v:\n                    direction[idx] = 0\n                else:\n                    direction[idx] = 1\n                dfs(v)\n\n    dfs(1)\n\n    # Now we need to make sure that the directed graph is acyclic\n    # Since we built it as a tree, it's acyclic by definition\n    # Also, flow conservation is ensured because we're building a tree from the source\n\n    for d in direction:\n        print(d)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 689,
        "completion_token_count": 398,
        "thoughts_token_count": 0
    }
}