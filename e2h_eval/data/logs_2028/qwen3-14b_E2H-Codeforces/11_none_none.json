{
    "start": 1757842723.1735919,
    "end": 1757842744.0564978,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 11,
    "thought": "",
    "response": "```python\nimport sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    index = 2\n    \n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        cost = int(data[index + 2])\n        vouchers.append((l, r, cost))\n        index += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: For each voucher, store the minimum cost for each duration\n    # We'll use two arrays:\n    # - left_min: for vouchers ending at or before a certain day\n    # - right_min: for vouchers starting at or after a certain day\n    \n    # First, build left_min: min cost for vouchers ending at or before day d\n    left_min = {}\n    for l, r, cost in vouchers:\n        if r not in left_min or cost < left_min[r]:\n            left_min[r] = cost\n    \n    # Convert to list for binary search\n    sorted_days_left = sorted(left_min.keys())\n    min_costs_left = [left_min[d] for d in sorted_days_left]\n    \n    # Now build right_min: min cost for vouchers starting at or after day d\n    right_min = {}\n    for l, r, cost in vouchers:\n        if l not in right_min or cost < right_min[l]:\n            right_min[l] = cost\n    \n    sorted_days_right = sorted(right_min.keys())\n    min_costs_right = [right_min[d] for d in sorted_days_right]\n    \n    result = -1\n    \n    # Iterate over each voucher and try to find a matching one\n    for l1, r1, cost1 in vouchers:\n        duration1 = r1 - l1 + 1\n        duration2 = x - duration1\n        \n        if duration2 <= 0:\n            continue\n        \n        # Find all vouchers with duration2 that start after r1\n        # These are valid since they don't overlap\n        # Use right_min to find min cost of vouchers starting >= r1 + 1\n        idx = bisect.bisect_left(sorted_days_right, r1 + 1)\n        if idx < len(sorted_days_right):\n            min_cost2 = min_costs_right[idx]\n            total_cost = cost1 + min_cost2\n            if result == -1 or total_cost < result:\n                result = total_cost\n        \n        # Find all vouchers with duration2 that end before l1\n        # These are valid since they don't overlap\n        # Use left_min to find min cost of vouchers ending <= l1 - 1\n        idx = bisect.bisect_right(sorted_days_left, l1 - 1)\n        if idx > 0:\n            min_cost2 = min_costs_left[idx - 1]\n            total_cost = cost1 + min_cost2\n            if result == -1 or total_cost < result:\n                result = total_cost\n    \n    print(result if result != -1 else -1)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    index = 2\n    \n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        cost = int(data[index + 2])\n        vouchers.append((l, r, cost))\n        index += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: For each voucher, store the minimum cost for each duration\n    # We'll use two arrays:\n    # - left_min: for vouchers ending at or before a certain day\n    # - right_min: for vouchers starting at or after a certain day\n    \n    # First, build left_min: min cost for vouchers ending at or before day d\n    left_min = {}\n    for l, r, cost in vouchers:\n        if r not in left_min or cost < left_min[r]:\n            left_min[r] = cost\n    \n    # Convert to list for binary search\n    sorted_days_left = sorted(left_min.keys())\n    min_costs_left = [left_min[d] for d in sorted_days_left]\n    \n    # Now build right_min: min cost for vouchers starting at or after day d\n    right_min = {}\n    for l, r, cost in vouchers:\n        if l not in right_min or cost < right_min[l]:\n            right_min[l] = cost\n    \n    sorted_days_right = sorted(right_min.keys())\n    min_costs_right = [right_min[d] for d in sorted_days_right]\n    \n    result = -1\n    \n    # Iterate over each voucher and try to find a matching one\n    for l1, r1, cost1 in vouchers:\n        duration1 = r1 - l1 + 1\n        duration2 = x - duration1\n        \n        if duration2 <= 0:\n            continue\n        \n        # Find all vouchers with duration2 that start after r1\n        # These are valid since they don't overlap\n        # Use right_min to find min cost of vouchers starting >= r1 + 1\n        idx = bisect.bisect_left(sorted_days_right, r1 + 1)\n        if idx < len(sorted_days_right):\n            min_cost2 = min_costs_right[idx]\n            total_cost = cost1 + min_cost2\n            if result == -1 or total_cost < result:\n                result = total_cost\n        \n        # Find all vouchers with duration2 that end before l1\n        # These are valid since they don't overlap\n        # Use left_min to find min cost of vouchers ending <= l1 - 1\n        idx = bisect.bisect_right(sorted_days_left, l1 - 1)\n        if idx > 0:\n            min_cost2 = min_costs_left[idx - 1]\n            total_cost = cost1 + min_cost2\n            if result == -1 or total_cost < result:\n                result = total_cost\n    \n    print(result if result != -1 else -1)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 644,
        "completion_token_count": 659,
        "thoughts_token_count": 0
    }
}