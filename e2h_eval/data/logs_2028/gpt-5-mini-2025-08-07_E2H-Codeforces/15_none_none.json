{
    "start": 1757842754.7794821,
    "end": 1757842765.2476559,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 15,
    "thought": "Could not extract thought.",
    "response": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    a = [0]*m\n    b = [0]*m\n    c = [0]*m\n    adj = [[] for _ in range(n+1)]\n    deg = [0]*(n+1)\n    for i in range(m):\n        ai = int(next(it)); bi = int(next(it)); ci = int(next(it))\n        a[i]=ai; b[i]=bi; c[i]=ci\n        adj[ai].append((bi, ci, i))\n        adj[bi].append((ai, ci, i))\n        deg[ai]+=ci\n        deg[bi]+=ci\n    need = [0]*(n+1)\n    for v in range(1,n+1):\n        if v==1 or v==n:\n            need[v]=0\n        else:\n            need[v]=deg[v]//2\n    used = [False]*m\n    ans = [0]*m\n    q = deque()\n    for v in range(1,n+1):\n        if v!=1 and v!=n and need[v]==0:\n            q.append(v)\n    while q:\n        v = q.popleft()\n        for to, w, idx in adj[v]:\n            if used[idx]:\n                continue\n            used[idx]=True\n            # edge between v and to. We need send flow from to->v to satisfy v (since need[v]==0 now)\n            if a[idx]==v and b[idx]==to:\n                # direction a->b would be v->to, but we want to reduce need[v] so flow must be to->v => direction 1\n                ans[idx]=1\n            else:\n                # a=to, b=v ; setting direction a->b means to->v which is desired => ans=0\n                ans[idx]=0\n            # subtract from need[to]\n            if to!=1 and to!=n:\n                need[to]-=w\n                if need[to]==0:\n                    q.append(to)\n    # For any remaining unused edges, direct from 1 outwards or towards n appropriately.\n    # For safety, direct remaining edges so that edges incident to 1 are outgoing (ans 0 if a==1->b).\n    for idx in range(m):\n        if not used[idx]:\n            used[idx]=True\n            ai=a[idx]; bi=b[idx]\n            # prefer edge directed away from 1. If ai==1 -> 0, if bi==1 ->1, else direct towards n if possible\n            if ai==1:\n                ans[idx]=0\n            elif bi==1:\n                ans[idx]=1\n            elif ai==n:\n                ans[idx]=1\n            elif bi==n:\n                ans[idx]=0\n            else:\n                ans[idx]=0\n    out = '\\n'.join(str(x) for x in ans)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    a = [0]*m\n    b = [0]*m\n    c = [0]*m\n    adj = [[] for _ in range(n+1)]\n    deg = [0]*(n+1)\n    for i in range(m):\n        ai = int(next(it)); bi = int(next(it)); ci = int(next(it))\n        a[i]=ai; b[i]=bi; c[i]=ci\n        adj[ai].append((bi, ci, i))\n        adj[bi].append((ai, ci, i))\n        deg[ai]+=ci\n        deg[bi]+=ci\n    need = [0]*(n+1)\n    for v in range(1,n+1):\n        if v==1 or v==n:\n            need[v]=0\n        else:\n            need[v]=deg[v]//2\n    used = [False]*m\n    ans = [0]*m\n    q = deque()\n    for v in range(1,n+1):\n        if v!=1 and v!=n and need[v]==0:\n            q.append(v)\n    while q:\n        v = q.popleft()\n        for to, w, idx in adj[v]:\n            if used[idx]:\n                continue\n            used[idx]=True\n            # edge between v and to. We need send flow from to->v to satisfy v (since need[v]==0 now)\n            if a[idx]==v and b[idx]==to:\n                # direction a->b would be v->to, but we want to reduce need[v] so flow must be to->v => direction 1\n                ans[idx]=1\n            else:\n                # a=to, b=v ; setting direction a->b means to->v which is desired => ans=0\n                ans[idx]=0\n            # subtract from need[to]\n            if to!=1 and to!=n:\n                need[to]-=w\n                if need[to]==0:\n                    q.append(to)\n    # For any remaining unused edges, direct from 1 outwards or towards n appropriately.\n    # For safety, direct remaining edges so that edges incident to 1 are outgoing (ans 0 if a==1->b).\n    for idx in range(m):\n        if not used[idx]:\n            used[idx]=True\n            ai=a[idx]; bi=b[idx]\n            # prefer edge directed away from 1. If ai==1 -> 0, if bi==1 ->1, else direct towards n if possible\n            if ai==1:\n                ans[idx]=0\n            elif bi==1:\n                ans[idx]=1\n            elif ai==n:\n                ans[idx]=1\n            elif bi==n:\n                ans[idx]=0\n            else:\n                ans[idx]=0\n    out = '\\n'.join(str(x) for x in ans)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 643,
        "completion_token_count": 655,
        "thoughts_token_count": 0
    }
}