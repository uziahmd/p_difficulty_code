{
    "start": 1757842722.635635,
    "end": 1757842732.132166,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:38 KST",
    "gpu": 2,
    "pid": 17,
    "thought": "Could not extract thought.",
    "response": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        wi = int(next(it)); ci = int(next(it))\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    # Precompute best using only weights 1 and 2 for any capacity up to m\n    # dp_cap[c] = max value using only w1 and w2 with total weight <= c\n    # But we can compute array best12 where best12[cap] is max cost.\n    best12 = [0] * (m + 1)\n    # consider taking k twos (weight 2*k) and fill remainder with ones\n    max_twos = min(len(w2), m // 2)\n    for k in range(0, max_twos + 1):\n        weight_twos = 2 * k\n        value_twos = pref2[k]\n        rem = m - weight_twos\n        take1 = min(len(w1), rem)\n        value1 = pref1[take1]\n        total = value_twos + value1\n        cap = weight_twos + take1  # actual weight used\n        if best12[cap] < total:\n            best12[cap] = total\n    # Also consider taking different number of ones alone (when no twos chosen)\n    # Already covered with k=0 above, but ensure other capacities filled: we want for any cap<=m best achievable.\n    # Now propagate maxima to fill capacities: for increasing cap, best12[cap] = max(best12[cap], best12[cap-1])\n    for i in range(1, m + 1):\n        if best12[i] < best12[i-1]:\n            best12[i] = best12[i-1]\n    # Now iterate over number of threes\n    ans = 0\n    max_threes = min(len(w3), m // 3)\n    for t in range(0, max_threes + 1):\n        weight3 = 3 * t\n        value3 = pref3[t]\n        rem = m - weight3\n        total = value3 + best12[rem]\n        if total > ans:\n            ans = total\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        wi = int(next(it)); ci = int(next(it))\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    # Precompute best using only weights 1 and 2 for any capacity up to m\n    # dp_cap[c] = max value using only w1 and w2 with total weight <= c\n    # But we can compute array best12 where best12[cap] is max cost.\n    best12 = [0] * (m + 1)\n    # consider taking k twos (weight 2*k) and fill remainder with ones\n    max_twos = min(len(w2), m // 2)\n    for k in range(0, max_twos + 1):\n        weight_twos = 2 * k\n        value_twos = pref2[k]\n        rem = m - weight_twos\n        take1 = min(len(w1), rem)\n        value1 = pref1[take1]\n        total = value_twos + value1\n        cap = weight_twos + take1  # actual weight used\n        if best12[cap] < total:\n            best12[cap] = total\n    # Also consider taking different number of ones alone (when no twos chosen)\n    # Already covered with k=0 above, but ensure other capacities filled: we want for any cap<=m best achievable.\n    # Now propagate maxima to fill capacities: for increasing cap, best12[cap] = max(best12[cap], best12[cap-1])\n    for i in range(1, m + 1):\n        if best12[i] < best12[i-1]:\n            best12[i] = best12[i-1]\n    # Now iterate over number of threes\n    ans = 0\n    max_threes = min(len(w3), m // 3)\n    for t in range(0, max_threes + 1):\n        weight3 = 3 * t\n        value3 = pref3[t]\n        rem = m - weight3\n        total = value3 + best12[rem]\n        if total > ans:\n            ans = total\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 444,
        "completion_token_count": 662,
        "thoughts_token_count": 0
    }
}