{
    "start": 1758294610.477986,
    "end": 1758294639.5201044,
    "start-formatted": "2025-09-20 00:10 KST",
    "end-formatted": "2025-09-20 00:10 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Could not extract thought.",
    "response": "```unknown\n#!/usr/bin/env python3\nimport sys\nfrom math import gcd\nsys.setrecursionlimit(1000000)\n\ndef lcm(a,b):\n    if a==0 or b==0: return 0\n    return a//gcd(a,b)*b\n\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\nit = iter(data)\nn = int(next(it)); m = int(next(it))\nadj = [[] for _ in range(n)]\nedges = []\nfor _ in range(m):\n    u = int(next(it))-1; v = int(next(it))-1\n    g = int(next(it)); l = int(next(it))\n    edges.append((u,v,g,l))\n    adj[u].append((v,g,l))\n    adj[v].append((u,g,l))\n\nval = [0]*n\nvis = [False]*n\n\nfrom collections import deque\n\nfor i in range(n):\n    if vis[i]: continue\n    if not adj[i]:\n        val[i]=1\n        vis[i]=True\n        continue\n    # we will assign by BFS with propagation of ratios via prime-free approach:\n    # represent as value = base * multiplier where base chosen to satisfy gcd/lcm constraints\n    # Approach: For a component, try to set starting node to each divisor of its incident LCMs GCD constraints -> but that may be heavy.\n    # Instead propagate via setting starting value = 1*product of (l/g) factors where needed using rational. Use fractions via integers by maintaining value up to lcm scaling.\n    # We'll attempt to propagate using rational represented as numerator/denominator then scale to integers at end.\n    from fractions import Fraction\n    frac = [None]*n\n    q = deque()\n    frac[i]=Fraction(1,1)\n    q.append(i)\n    vis_local = []\n    ok = True\n    while q and ok:\n        u = q.popleft()\n        vis_local.append(u)\n        for v,g,l in adj[u]:\n            # We need numbers a,b such that gcd(a,b)=g and lcm(a,b)=l\n            # Hence a*b = g*l\n            if l % g != 0:\n                ok = False; break\n            prod = g*l\n            # If frac[u] = x representing scaling factor so that actual a = x * A where A is integer unknown.\n            # Relationship between a and b: a/b = ? we can deduce ratio from prod and gcd? Not enough.\n            # But we can impose that a = g * s, b = g * t where gcd(s,t)=1 and s*t = l/g\n            k = l//g\n            # So s and t are coprime factors of k. For any assignment, ratio b/a = t/s.\n            # We can set frac[v] = frac[u] * (t/s). But unknown s,t. However s and t must be integers.\n            # To ensure existence, we can force that frac[v] = frac[u] * (k) because choose s=1,t=k? That may violate gcd(s,t)=1 unless k coprime to 1 (always).\n            # But choosing s=1,t=k yields a=g*1, b=g*k which satisfy gcd(s,t)=1. So it's valid decomposition.\n            # So we can pick direction: when moving from u to v, set ratio b = a * k.\n            # However symmetric choice might conflict later; but any consistent choices that satisfy all edges possible? Known solution: assign using multiplicative factors along edges: multiply by k or divide by k depending direction, start with node value = product of some ks to fit all lcms/gcds. Use Fraction to detect contradictions.\n            # We'll set frac[v] = frac[u] * k\n            if frac[v] is None:\n                frac[v] = frac[u]*k\n                q.append(v)\n            else:\n                if frac[v] != frac[u]*k:\n                    ok = False; break\n    if not ok:\n        print(\"NO\")\n        sys.exit(0)\n    # Now we have fractions up to multiplicative constant per component. Need to find integer scaling s.t. all node values integers and edges satisfy gcd/lcm.\n    # Let base values b_i = frac[i] for visited nodes. We need to find positive integer multiplier T so that a_i = b_i * T are integers and satisfy for each edge gcd(a,b)=g lcm = l.\n    comp = vis_local\n    # find minimal T to make all integers\n    T = 1\n    for u in comp:\n        f = frac[u]\n        T = (T * f.denominator) // gcd(T, f.denominator)\n    # compute provisional integers\n    arr = {}\n    for u in comp:\n        arr[u] = frac[u].numerator * (T // frac[u].denominator)\n    # Now arr may be scaled further by integer factor c; check gcd/lcm consistency: For edge (u,v,g,l), we need gcd(arr[u]*c, arr[v]*c)=g and lcm(...)=l.\n    # gcd scales by c, lcm scales by c. So we need c such that gcd(arr[u],arr[v])*c == g and lcm(arr[u],arr[v])*c == l\n    # So for each edge, g must be divisible by gcd(arr[u],arr[v]) and l divisible by lcm(arr[u],arr[v]), and the required c must be same: c = g / gcd(arr[u],arr[v]) = l / lcm(arr[u],arr[v])\n    needed_c = None\n    for u in comp:\n        for v,g,l in adj[u]:\n            if u>v: continue\n            au = arr[u]; bv = arr[v]\n            gg = gcd(au,bv)\n            ll = lcm(au,bv)\n            if gg==0 or ll==0:\n                print(\"NO\"); sys.exit(0)\n            if g % gg != 0 or l % ll != 0:\n                print(\"NO\"); sys.exit(0)\n            c1 = g//gg\n            c2 = l//ll\n            if c1 != c2:\n                print(\"NO\"); sys.exit(0)\n            if needed_c is None:\n                needed_c = c1\n            else:\n                if needed_c != c1:\n                    print(\"NO\"); sys.exit(0)\n    if needed_c is None:\n        needed_c = 1\n    # apply\n    for u in comp:\n        val[u] = arr[u]*needed_c\n        if val[u] <= 0 or val[u] > 10**18:\n            print(\"NO\"); sys.exit(0)\n        vis[u]=True\n\n# final verify all edges\nfor u,v,g,l in edges:\n    a=val[u]; b=val[v]\n    if gcd(a,b)!=g or lcm(a,b)!=l:\n        print(\"NO\")\n        sys.exit(0)\n\nprint(\"YES\")\nprint(\" \".join(str(x) for x in val))\n```",
    "ground_truth": "N/A",
    "extracted_answer": "unknown\n#!/usr/bin/env python3\nimport sys\nfrom math import gcd\nsys.setrecursionlimit(1000000)\n\ndef lcm(a,b):\n    if a==0 or b==0: return 0\n    return a//gcd(a,b)*b\n\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\nit = iter(data)\nn = int(next(it)); m = int(next(it))\nadj = [[] for _ in range(n)]\nedges = []\nfor _ in range(m):\n    u = int(next(it))-1; v = int(next(it))-1\n    g = int(next(it)); l = int(next(it))\n    edges.append((u,v,g,l))\n    adj[u].append((v,g,l))\n    adj[v].append((u,g,l))\n\nval = [0]*n\nvis = [False]*n\n\nfrom collections import deque\n\nfor i in range(n):\n    if vis[i]: continue\n    if not adj[i]:\n        val[i]=1\n        vis[i]=True\n        continue\n    # we will assign by BFS with propagation of ratios via prime-free approach:\n    # represent as value = base * multiplier where base chosen to satisfy gcd/lcm constraints\n    # Approach: For a component, try to set starting node to each divisor of its incident LCMs GCD constraints -> but that may be heavy.\n    # Instead propagate via setting starting value = 1*product of (l/g) factors where needed using rational. Use fractions via integers by maintaining value up to lcm scaling.\n    # We'll attempt to propagate using rational represented as numerator/denominator then scale to integers at end.\n    from fractions import Fraction\n    frac = [None]*n\n    q = deque()\n    frac[i]=Fraction(1,1)\n    q.append(i)\n    vis_local = []\n    ok = True\n    while q and ok:\n        u = q.popleft()\n        vis_local.append(u)\n        for v,g,l in adj[u]:\n            # We need numbers a,b such that gcd(a,b)=g and lcm(a,b)=l\n            # Hence a*b = g*l\n            if l % g != 0:\n                ok = False; break\n            prod = g*l\n            # If frac[u] = x representing scaling factor so that actual a = x * A where A is integer unknown.\n            # Relationship between a and b: a/b = ? we can deduce ratio from prod and gcd? Not enough.\n            # But we can impose that a = g * s, b = g * t where gcd(s,t)=1 and s*t = l/g\n            k = l//g\n            # So s and t are coprime factors of k. For any assignment, ratio b/a = t/s.\n            # We can set frac[v] = frac[u] * (t/s). But unknown s,t. However s and t must be integers.\n            # To ensure existence, we can force that frac[v] = frac[u] * (k) because choose s=1,t=k? That may violate gcd(s,t)=1 unless k coprime to 1 (always).\n            # But choosing s=1,t=k yields a=g*1, b=g*k which satisfy gcd(s,t)=1. So it's valid decomposition.\n            # So we can pick direction: when moving from u to v, set ratio b = a * k.\n            # However symmetric choice might conflict later; but any consistent choices that satisfy all edges possible? Known solution: assign using multiplicative factors along edges: multiply by k or divide by k depending direction, start with node value = product of some ks to fit all lcms/gcds. Use Fraction to detect contradictions.\n            # We'll set frac[v] = frac[u] * k\n            if frac[v] is None:\n                frac[v] = frac[u]*k\n                q.append(v)\n            else:\n                if frac[v] != frac[u]*k:\n                    ok = False; break\n    if not ok:\n        print(\"NO\")\n        sys.exit(0)\n    # Now we have fractions up to multiplicative constant per component. Need to find integer scaling s.t. all node values integers and edges satisfy gcd/lcm.\n    # Let base values b_i = frac[i] for visited nodes. We need to find positive integer multiplier T so that a_i = b_i * T are integers and satisfy for each edge gcd(a,b)=g lcm = l.\n    comp = vis_local\n    # find minimal T to make all integers\n    T = 1\n    for u in comp:\n        f = frac[u]\n        T = (T * f.denominator) // gcd(T, f.denominator)\n    # compute provisional integers\n    arr = {}\n    for u in comp:\n        arr[u] = frac[u].numerator * (T // frac[u].denominator)\n    # Now arr may be scaled further by integer factor c; check gcd/lcm consistency: For edge (u,v,g,l), we need gcd(arr[u]*c, arr[v]*c)=g and lcm(...)=l.\n    # gcd scales by c, lcm scales by c. So we need c such that gcd(arr[u],arr[v])*c == g and lcm(arr[u],arr[v])*c == l\n    # So for each edge, g must be divisible by gcd(arr[u],arr[v]) and l divisible by lcm(arr[u],arr[v]), and the required c must be same: c = g / gcd(arr[u],arr[v]) = l / lcm(arr[u],arr[v])\n    needed_c = None\n    for u in comp:\n        for v,g,l in adj[u]:\n            if u>v: continue\n            au = arr[u]; bv = arr[v]\n            gg = gcd(au,bv)\n            ll = lcm(au,bv)\n            if gg==0 or ll==0:\n                print(\"NO\"); sys.exit(0)\n            if g % gg != 0 or l % ll != 0:\n                print(\"NO\"); sys.exit(0)\n            c1 = g//gg\n            c2 = l//ll\n            if c1 != c2:\n                print(\"NO\"); sys.exit(0)\n            if needed_c is None:\n                needed_c = c1\n            else:\n                if needed_c != c1:\n                    print(\"NO\"); sys.exit(0)\n    if needed_c is None:\n        needed_c = 1\n    # apply\n    for u in comp:\n        val[u] = arr[u]*needed_c\n        if val[u] <= 0 or val[u] > 10**18:\n            print(\"NO\"); sys.exit(0)\n        vis[u]=True\n\n# final verify all edges\nfor u,v,g,l in edges:\n    a=val[u]; b=val[v]\n    if gcd(a,b)!=g or lcm(a,b)!=l:\n        print(\"NO\")\n        sys.exit(0)\n\nprint(\"YES\")\nprint(\" \".join(str(x) for x in val))",
    "score": -1,
    "metadata": {
        "prompt_token_count": 537,
        "completion_token_count": 1497,
        "thoughts_token_count": 0
    }
}