{
    "start": 1758294620.5889256,
    "end": 1758294647.8818188,
    "start-formatted": "2025-09-20 00:10 KST",
    "end-formatted": "2025-09-20 00:10 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Could not extract thought.",
    "response": "```python\nimport sys\nfrom collections import deque, defaultdict\n\ndef bipartite_components(n, adj):\n    color = [-1]*n\n    comp_id = [-1]*n\n    comps = []\n    cid = 0\n    for i in range(n):\n        if color[i]!=-1: continue\n        q = deque([i])\n        color[i]=0\n        comp_nodes=[i]\n        is_bip=True\n        while q:\n            u=q.popleft()\n            for v in adj[u]:\n                if color[v]==-1:\n                    color[v]=color[u]^1\n                    comp_id[v]=cid\n                    q.append(v)\n                    comp_nodes.append(v)\n                elif color[v]==color[u]:\n                    is_bip=False\n        comp_id[i]=cid\n        # ensure comp_id set for all nodes in comp\n        for v in comp_nodes:\n            comp_id[v]=cid\n        comps.append((comp_nodes,is_bip))\n        cid+=1\n    return comps, color, comp_id\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    adj=[set() for _ in range(n)]\n    for _ in range(m):\n        a=int(next(it))-1; b=int(next(it))-1\n        adj[a].add(b); adj[b].add(a)\n    # If any edge creates odd cycle already? Check by BFS coloring per component\n    comps = []\n    color=[-1]*n\n    comp_id=[-1]*n\n    cid=0\n    is_any_nonbip=False\n    comp_nodes_list=[]\n    for i in range(n):\n        if color[i]!=-1: continue\n        q=deque([i]); color[i]=0; comp_nodes=[i]; comp_id[i]=cid; is_bip=True\n        while q:\n            u=q.popleft()\n            for v in adj[u]:\n                if color[v]==-1:\n                    color[v]=color[u]^1\n                    comp_id[v]=cid\n                    q.append(v); comp_nodes.append(v)\n                elif color[v]==color[u]:\n                    is_bip=False\n        if not is_bip:\n            is_any_nonbip=True\n        comp_nodes_list.append((comp_nodes,is_bip))\n        cid+=1\n    if is_any_nonbip:\n        print(\"0 1\")\n        return\n    # Graph is bipartite. Need minimal edges to add to create odd cycle >1 vertex.\n    # Consider adding one edge inside same color in same component -> creates odd cycle.\n    # Count such missing edges: for each component, for each color side, number of pairs not connected.\n    total_ways_one = 0\n    for comp_nodes,is_bip in comp_nodes_list:\n        if not is_bip:\n            continue\n        part0=[]; part1=[]\n        for v in comp_nodes:\n            if color[v]==0: part0.append(v)\n            else: part1.append(v)\n        # For each part, missing edges count = C(k,2) - existing edges inside part (which are zero in bipartite)\n        # But existing edges inside part are zero since graph bipartite, so missing edges = C(k,2)\n        k0=len(part0); k1=len(part1)\n        total_ways_one += k0*(k0-1)//2 + k1*(k1-1)//2\n    if total_ways_one>0:\n        print(\"1 {}\".format(total_ways_one))\n        return\n    # No way with one edge. Try two edges: options include connecting two vertices across different components to create odd cycle.\n    # Known CF solution: if no edges and n>=3 answer is 3 choose? But general approach:\n    # If no edges in graph (m==0): need 3 edges to form triangle: choose any triple of vertices -> C(n,3)\n    if m==0:\n        if n<3:\n            print(\"-1 0\")\n        else:\n            ways = n*(n-1)*(n-2)//6\n            print(\"3 {}\".format(ways))\n        return\n    # Otherwise minimal is 2 edges. Count ways to add 2 edges to create odd cycle.\n    # Two-edge additions can create an odd cycle by connecting two vertices in different components that are in same color relative to their component roots after considering bipartition parity.\n    # Approach: Contract components; each component is bipartite tree-like. Adding one edge between two different components may or may not create odd cycle; need parity sum.\n    comp_count = len(comp_nodes_list)\n    # For each component, count sizes of both colors\n    sizes = []\n    for comp_nodes,is_bip in comp_nodes_list:\n        cnt0=cnt1=0\n        for v in comp_nodes:\n            if color[v]==0: cnt0+=1\n            else: cnt1+=1\n        sizes.append((cnt0,cnt1))\n    # Ways to create odd cycle with two edges: choose two components A and B and add two edges between them that connect vertices of same color (relative) producing odd cycle of length >=3.\n    # For two components, number of pairs of edges that make odd cycle equals cnt0A*cnt0B + cnt1A*cnt1B (for one connecting same color) times (total possible second edge choices?) Actually adding two edges between same pair of components: we need to add two edges between them that are between vertices of same colors (both edges connect 0-0 or 1-1) to create odd cycle. Number of unordered sets of two edges between A and B without parallel edges is (#possible edges between same-color groups choose 2 + cross?). Simpler: count number of unordered pairs of vertices (u1 in A, v1 in B) and (u2 in A, v2 in B) such that edges distinct and set forms odd cycle. That requires u1 and u2 in same part of A and v1 and v2 in same corresponding part of B, and edges not identical.\n    # For same-color connections: count = C(cnt0A*cnt0B,2) + C(cnt1A*cnt1B,2)\n    total_two = 0\n    for i in range(comp_count):\n        for j in range(i+1,comp_count):\n            a0,a1 = sizes[i]; b0,b1 = sizes[j]\n            x = a0*b0\n            y = a1*b1\n            total_two += x*(x-1)//2 + y*(y-1)//2\n    if total_two>0:\n        print(\"2 {}\".format(total_two))\n        return\n    # Else minimal is 3. Count ways to add 3 edges. Known cases: need triangle across three components or within components? For simplicity, count triples of vertices forming triangle missing all three edges.\n    # Count number of unordered triples (i<j<k) of vertices that currently have 0 edges among them (an independent triple). Adding 3 edges makes triangle.\n    # Compute complement: for each vertex, adjacency set. Count total triples minus triples with at least one existing edge. Simpler brute force O(n^2) may be large. But constraints unspecified. We'll implement O(n^2) with adjacency bitsets using sets; n up to? CF problem n up to 100? Let's implement using adjacency sets with iteration over pairs.\n    nverts = n\n    # Count triples that currently have 0 edges among them\n    # total triples C(n,3)\n    total_triples = nverts*(nverts-1)*(nverts-2)//6\n    # subtract triples with at least one edge: count triples where at least one pair connected.\n    # Count triples with at least one edge = sum over edges of (n-2) - number of triples counted twice (with two edges) + triples with three edges\n    # Better compute number of triples that are not independent: For each vertex v, count pairs (u,w) where u adjacent to v or w adjacent etc complicated.\n    # We'll compute number of independent triples directly by iterating pairs (u<v) and counting vertices w>v not adjacent to u and not adjacent to v.\n    adj_list = [set(nei) for nei in adj]\n    independent_triples = 0\n    for u in range(nverts):\n        for v in range(u+1,nverts):\n            if v in adj_list[u]:\n                continue\n            # count w>v not connected to u and not to v\n            # iterate w\n            cnt = 0\n            # optimize by iterating over all and subtracting neighbors\n            # but for simplicity:\n            for w in range(v+1,nverts):\n                if w in adj_list[u] or w in adj_list[v]:\n                    continue\n                cnt += 1\n            independent_triples += cnt\n    if independent_triples>0:\n        print(\"3 {}\".format(independent_triples))\n    else:\n        print(\"-1 0\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque, defaultdict\n\ndef bipartite_components(n, adj):\n    color = [-1]*n\n    comp_id = [-1]*n\n    comps = []\n    cid = 0\n    for i in range(n):\n        if color[i]!=-1: continue\n        q = deque([i])\n        color[i]=0\n        comp_nodes=[i]\n        is_bip=True\n        while q:\n            u=q.popleft()\n            for v in adj[u]:\n                if color[v]==-1:\n                    color[v]=color[u]^1\n                    comp_id[v]=cid\n                    q.append(v)\n                    comp_nodes.append(v)\n                elif color[v]==color[u]:\n                    is_bip=False\n        comp_id[i]=cid\n        # ensure comp_id set for all nodes in comp\n        for v in comp_nodes:\n            comp_id[v]=cid\n        comps.append((comp_nodes,is_bip))\n        cid+=1\n    return comps, color, comp_id\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    adj=[set() for _ in range(n)]\n    for _ in range(m):\n        a=int(next(it))-1; b=int(next(it))-1\n        adj[a].add(b); adj[b].add(a)\n    # If any edge creates odd cycle already? Check by BFS coloring per component\n    comps = []\n    color=[-1]*n\n    comp_id=[-1]*n\n    cid=0\n    is_any_nonbip=False\n    comp_nodes_list=[]\n    for i in range(n):\n        if color[i]!=-1: continue\n        q=deque([i]); color[i]=0; comp_nodes=[i]; comp_id[i]=cid; is_bip=True\n        while q:\n            u=q.popleft()\n            for v in adj[u]:\n                if color[v]==-1:\n                    color[v]=color[u]^1\n                    comp_id[v]=cid\n                    q.append(v); comp_nodes.append(v)\n                elif color[v]==color[u]:\n                    is_bip=False\n        if not is_bip:\n            is_any_nonbip=True\n        comp_nodes_list.append((comp_nodes,is_bip))\n        cid+=1\n    if is_any_nonbip:\n        print(\"0 1\")\n        return\n    # Graph is bipartite. Need minimal edges to add to create odd cycle >1 vertex.\n    # Consider adding one edge inside same color in same component -> creates odd cycle.\n    # Count such missing edges: for each component, for each color side, number of pairs not connected.\n    total_ways_one = 0\n    for comp_nodes,is_bip in comp_nodes_list:\n        if not is_bip:\n            continue\n        part0=[]; part1=[]\n        for v in comp_nodes:\n            if color[v]==0: part0.append(v)\n            else: part1.append(v)\n        # For each part, missing edges count = C(k,2) - existing edges inside part (which are zero in bipartite)\n        # But existing edges inside part are zero since graph bipartite, so missing edges = C(k,2)\n        k0=len(part0); k1=len(part1)\n        total_ways_one += k0*(k0-1)//2 + k1*(k1-1)//2\n    if total_ways_one>0:\n        print(\"1 {}\".format(total_ways_one))\n        return\n    # No way with one edge. Try two edges: options include connecting two vertices across different components to create odd cycle.\n    # Known CF solution: if no edges and n>=3 answer is 3 choose? But general approach:\n    # If no edges in graph (m==0): need 3 edges to form triangle: choose any triple of vertices -> C(n,3)\n    if m==0:\n        if n<3:\n            print(\"-1 0\")\n        else:\n            ways = n*(n-1)*(n-2)//6\n            print(\"3 {}\".format(ways))\n        return\n    # Otherwise minimal is 2 edges. Count ways to add 2 edges to create odd cycle.\n    # Two-edge additions can create an odd cycle by connecting two vertices in different components that are in same color relative to their component roots after considering bipartition parity.\n    # Approach: Contract components; each component is bipartite tree-like. Adding one edge between two different components may or may not create odd cycle; need parity sum.\n    comp_count = len(comp_nodes_list)\n    # For each component, count sizes of both colors\n    sizes = []\n    for comp_nodes,is_bip in comp_nodes_list:\n        cnt0=cnt1=0\n        for v in comp_nodes:\n            if color[v]==0: cnt0+=1\n            else: cnt1+=1\n        sizes.append((cnt0,cnt1))\n    # Ways to create odd cycle with two edges: choose two components A and B and add two edges between them that connect vertices of same color (relative) producing odd cycle of length >=3.\n    # For two components, number of pairs of edges that make odd cycle equals cnt0A*cnt0B + cnt1A*cnt1B (for one connecting same color) times (total possible second edge choices?) Actually adding two edges between same pair of components: we need to add two edges between them that are between vertices of same colors (both edges connect 0-0 or 1-1) to create odd cycle. Number of unordered sets of two edges between A and B without parallel edges is (#possible edges between same-color groups choose 2 + cross?). Simpler: count number of unordered pairs of vertices (u1 in A, v1 in B) and (u2 in A, v2 in B) such that edges distinct and set forms odd cycle. That requires u1 and u2 in same part of A and v1 and v2 in same corresponding part of B, and edges not identical.\n    # For same-color connections: count = C(cnt0A*cnt0B,2) + C(cnt1A*cnt1B,2)\n    total_two = 0\n    for i in range(comp_count):\n        for j in range(i+1,comp_count):\n            a0,a1 = sizes[i]; b0,b1 = sizes[j]\n            x = a0*b0\n            y = a1*b1\n            total_two += x*(x-1)//2 + y*(y-1)//2\n    if total_two>0:\n        print(\"2 {}\".format(total_two))\n        return\n    # Else minimal is 3. Count ways to add 3 edges. Known cases: need triangle across three components or within components? For simplicity, count triples of vertices forming triangle missing all three edges.\n    # Count number of unordered triples (i<j<k) of vertices that currently have 0 edges among them (an independent triple). Adding 3 edges makes triangle.\n    # Compute complement: for each vertex, adjacency set. Count total triples minus triples with at least one existing edge. Simpler brute force O(n^2) may be large. But constraints unspecified. We'll implement O(n^2) with adjacency bitsets using sets; n up to? CF problem n up to 100? Let's implement using adjacency sets with iteration over pairs.\n    nverts = n\n    # Count triples that currently have 0 edges among them\n    # total triples C(n,3)\n    total_triples = nverts*(nverts-1)*(nverts-2)//6\n    # subtract triples with at least one edge: count triples where at least one pair connected.\n    # Count triples with at least one edge = sum over edges of (n-2) - number of triples counted twice (with two edges) + triples with three edges\n    # Better compute number of triples that are not independent: For each vertex v, count pairs (u,w) where u adjacent to v or w adjacent etc complicated.\n    # We'll compute number of independent triples directly by iterating pairs (u<v) and counting vertices w>v not adjacent to u and not adjacent to v.\n    adj_list = [set(nei) for nei in adj]\n    independent_triples = 0\n    for u in range(nverts):\n        for v in range(u+1,nverts):\n            if v in adj_list[u]:\n                continue\n            # count w>v not connected to u and not to v\n            # iterate w\n            cnt = 0\n            # optimize by iterating over all and subtracting neighbors\n            # but for simplicity:\n            for w in range(v+1,nverts):\n                if w in adj_list[u] or w in adj_list[v]:\n                    continue\n                cnt += 1\n            independent_triples += cnt\n    if independent_triples>0:\n        print(\"3 {}\".format(independent_triples))\n    else:\n        print(\"-1 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 1932,
        "thoughts_token_count": 0
    }
}