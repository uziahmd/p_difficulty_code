{
    "start": 1758016191.8162444,
    "end": 1758017601.8953543,
    "start-formatted": "2025-09-16 18:49 KST",
    "end-formatted": "2025-09-16 19:13 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If there's no such pair, output -1.\n\nFirst, let's understand the constraints. The vouchers are given with li, ri, costi. The duration of voucher i is ri - li + 1. We need two vouchers i and j (i≠j) where their durations sum to x, and they don't overlap. Also, the sum of their costs should be as small as possible.\n\nThe key points here are:\n\n1. Find two vouchers whose durations add up to x.\n2. They must not overlap. Which means either the first ends before the second starts, or vice versa.\n3. Find the minimum cost sum for such pairs.\n\nNow, how to approach this efficiently?\n\nLet me think about the steps.\n\nFirst, for each voucher, compute its duration. Then, for each voucher, check if there exists another voucher with duration (x - duration_i), and that they don't overlap.\n\nBut checking all pairs would be O(n²), which is not feasible for n up to 2e5. That's way too slow.\n\nSo we need a smarter approach.\n\nLet me think about grouping vouchers by their duration. For example, for each possible duration d, we can store all vouchers with that duration. Then, for each voucher with duration d, we look for vouchers with duration (x - d), and check if any of them don't overlap with it.\n\nBut even then, for each voucher, checking all vouchers in the other group might be O(n) per voucher, leading to O(n²) again. So that's not good.\n\nWait, but maybe we can pre-process for each duration, the minimal cost for vouchers that end before a certain day, or start after a certain day. Because for a voucher A with duration d, we need to find a voucher B with duration (x - d) that ends before A's start, or starts after A's end.\n\nSo for each voucher A, we can check two possibilities:\n\nCase 1: Find a voucher B with duration (x - d_A) that ends before A's li (so that B's ri < A's li). Then, B can be before A.\n\nCase 2: Find a voucher B with duration (x - d_A) that starts after A's ri (so that A's ri < B's li). Then, B comes after A.\n\nFor each of these cases, we need to find the minimal cost of such B's.\n\nSo the idea is, for each duration d, we can pre-process two structures:\n\n- For all vouchers with duration d, sorted by their end time (ri), and for each position, have the minimum cost up to that point. This allows us to quickly query the minimum cost of vouchers with duration d that end before a certain day.\n\nSimilarly, for vouchers with duration d, sorted by their start time (li), and for each position, have the minimum cost from that point onwards. This allows us to quickly query the minimum cost of vouchers with duration d that start after a certain day.\n\nWait, maybe for each duration d, we can have two sorted lists:\n\n- One sorted by ri (end time), and for each entry, track the minimum cost up to that index. So when we want to find the minimum cost of vouchers with duration d that end before a certain value (say, L), we can binary search in the sorted ri list for the largest ri less than L, and then take the min cost up to that index.\n\nSimilarly, another list sorted by li (start time), and for each entry, track the minimum cost from that index onwards. So for a given R, we can find the earliest li that is greater than R, and get the minimum cost from that index.\n\nThis way, for each voucher A with duration d_A, we can check if there's a voucher B with duration (x - d_A) that ends before A's li, or starts after A's ri. And for each case, find the minimal cost.\n\nSo here's the plan:\n\n1. Preprocess all vouchers by their duration. For each duration d, we have two sorted lists:\n\n   a. A list of vouchers sorted by ri, along with a prefix minimum array. This helps in finding the minimum cost of vouchers with duration d that end before a certain day.\n\n   b. A list of vouchers sorted by li, along with a suffix minimum array. This helps in finding the minimum cost of vouchers with duration d that start after a certain day.\n\n2. For each voucher A (with duration d_A), compute target_d = x - d_A. If target_d is not present in our duration map, skip.\n\n3. For target_d, check if there are any vouchers with that duration. If not, skip.\n\n4. For voucher A, check two possibilities:\n\n   a. Find the minimal cost of vouchers with duration target_d that end before A's li. So, for that, we look into the sorted ri list for target_d. We perform a binary search for the maximum ri that is less than A's li. Then, if such entries exist, take the prefix minimum up to that index.\n\n   b. Find the minimal cost of vouchers with duration target_d that start after A's ri. For this, we look into the sorted li list for target_d. We perform a binary search for the first li that is greater than A's ri. Then, take the suffix minimum from that index.\n\n5. For each of these possibilities, if found, add the cost of voucher A and the found minimal cost, and keep track of the global minimum.\n\nWe need to do this for all vouchers, and then take the overall minimum.\n\nBut how do we handle the sorted lists and their prefix/suffix minima?\n\nLet's think about building for each duration d:\n\n- For the first part (sorted by ri):\n\n   Sort all vouchers with duration d in increasing order of ri. Then create an array min_prefix where min_prefix[i] is the minimum cost among the first i+1 vouchers. So, when we find the latest ri that is less than some L, we can get the min cost up to that index.\n\n- For the second part (sorted by li):\n\n   Sort all vouchers with duration d in increasing order of li. Then create an array min_suffix where min_suffix[i] is the minimum cost from i-th element to the end. So, when we find the first li that is larger than R, we can get the min cost from that index onwards.\n\nBut how to build these arrays.\n\nFor example, for the sorted ri list:\n\nsorted_ri = sorted(vouchers_with_d, key=lambda v: v.ri)\n\nThen, min_prefix is computed as follows:\n\nmin_prefix[0] = sorted_ri[0].cost\n\nfor i in 1 to len(sorted_ri)-1:\n\n   min_prefix[i] = min( min_prefix[i-1], sorted_ri[i].cost )\n\nSimilarly for the sorted li list:\n\nsorted_li = sorted(vouchers_with_d, key=lambda v: v.li)\n\nmin_suffix is computed as:\n\nmin_suffix[-1] = sorted_li[-1].cost\n\nfor i from len(sorted_li)-2 downto 0:\n\n   min_suffix[i] = min( min_suffix[i+1], sorted_li[i].cost )\n\nOnce these structures are built, for each query, we can perform binary searches.\n\nNow, for each voucher A, we need to check both cases (B before A, and B after A).\n\nBut how to handle the binary search part.\n\nLet's take the first case: looking for vouchers with target_d that end before A's li.\n\nSo, for the sorted_ri list of target_d, we want the maximum ri that is less than A's li. Let's say that sorted_ri is a list of ri's in ascending order. We can use bisect_left to find the insertion point of A's li. The index would be the number of elements less than A's li. If that index is 0, then there are none. Otherwise, the min_prefix up to index-1 is the minimal cost.\n\nFor example, if the insertion point is k, then the elements before k are all <= A's li. But since we need ri < li_A, we can use bisect_left to find the first element >= li_A, then the elements before that index are those with ri < li_A. So the maximum possible is index-1. If index is 0, then no elements.\n\nSo the code would be something like:\n\nk = bisect.bisect_left(sorted_ri_ri, li_A)\n\nif k > 0:\n\n   min_cost = min_prefix[k-1]\n\nSimilarly for the other case.\n\nFor the second case, looking for vouchers with target_d that start after A's ri. So in the sorted_li list (sorted by li), we need to find the first li that is > ri_A. Then, the min_suffix from that index onwards.\n\nFor example, using bisect_right to find the insertion point of ri_A in the sorted_li's li. Let's say the sorted_li is sorted in ascending order of li. So, the first li that is larger than ri_A is at index k. Then, if k is within the array length, the min_suffix[k] is the minimal cost from that index onwards.\n\nWait, for example, sorted_li is [1, 3, 5, 7], and ri_A is 4. Then, the first li larger than 4 is 5, at index 2. So the min from index 2 onwards is the min of 5,7.\n\nSo to find the first li that is > ri_A, we can use bisect_right on the list of li's. For example:\n\nIn Python, bisect.bisect_right returns the insertion point after any existing entries of ri_A. So for the sorted list, all elements before the insertion point are <= ri_A, and elements from insertion point onwards are > ri_A.\n\nThus, for the sorted_li list, we can extract the list of li's, then perform bisect_right on that list with ri_A. The index gives us the first element in sorted_li where li > ri_A. Then, if that index is less than len(sorted_li), then the min_suffix from that index is the minimal cost.\n\nSo, for the sorted_li list, we can have a list of li's, and a corresponding min_suffix array.\n\nPutting this together, here's the plan for the code:\n\nFirst, process all vouchers, group them by their duration. For each duration d, we have two sorted lists:\n\n- sorted_by_ri: sorted by ri, with prefix minima.\n\n- sorted_by_li: sorted by li, with suffix minima.\n\nOnce that's done, for each voucher in the original list, we check if there exists a voucher with duration (x - d_A). If yes, then check both possibilities (before and after).\n\nNow, let's think about the steps in code:\n\nRead n and x.\n\nThen read n vouchers, storing li, ri, cost. Also, compute duration for each voucher as (ri - li + 1).\n\nGroup the vouchers by duration. For example, a dictionary where keys are durations, and values are lists of vouchers with that duration.\n\nThen, for each duration d in the dictionary, process the two sorted lists and their min arrays.\n\nOnce that's done, for each voucher A in the original list:\n\n   d_A = duration of A.\n\n   target_d = x - d_A.\n\n   if target_d not in the duration map, continue.\n\n   else:\n\n      check for vouchers with target_d that are before A (end before A's li) and after A (start after A's ri).\n\n      For the before case:\n\n         get the list of vouchers with target_d sorted by ri (sorted_ri_list), and their prefix min array.\n\n         find the maximum ri in sorted_ri_list that is < A's li.\n\n         if exists, take the min cost from that prefix.\n\n      For the after case:\n\n         get the list of vouchers with target_d sorted by li (sorted_li_list), and their suffix min array.\n\n         find the first li in sorted_li_list that is > A's ri.\n\n         if exists, take the min cost from that suffix.\n\n      For each of these two cases, if found, add the current voucher's cost to the found min cost, and update the global minimum.\n\nBut wait, we need to make sure that the voucher B is not the same as voucher A. However, since the problem says i≠j, but when we process all vouchers, even if a voucher has duration d_A, and target_d is also d_A (i.e., x = 2*d_A), then when considering voucher A, we may look for another voucher with the same duration. But in that case, the code would include all vouchers except itself? Or not?\n\nWait, for example, if there are two vouchers with same duration, and they are non-overlapping. Then, when processing voucher A, the code would check for vouchers with duration target_d (same as d_A) and find others. However, the code as described would include all vouchers in the target_d group, including voucher A itself. But since the problem requires i≠j, we need to ensure that when we check for the voucher B, it's not the same as A.\n\nBut how to handle this?\n\nHmm, this is a problem. Because when we have a voucher A, and target_d is same as d_A, then when looking for vouchers in the target_d group, we could include voucher A itself. However, in that case, the voucher B (A) would be same as voucher A, but the code would check if they are non-overlapping. However, since voucher A's duration is d_A, and target_d is x - d_A, which would be same as d_A only if x = 2d_A. Then, the code would check if there's a voucher B in the target_d group (which includes A) that is non-overlapping with A. But since voucher A's own ri is >= li, and for B to be non-overlapping, it must end before A's li or start after A's ri. But if B is A itself, then it's impossible, because A's ri >= A's li. So for B being A, the condition would not hold. Therefore, even if the code includes voucher A in the group, the check for non-overlapping would automatically exclude it.\n\nWait, let's think: when we are processing voucher A, and looking for B's in the target_d group. Suppose target_d is same as d_A, and there are multiple vouchers with that duration. For example, if voucher A is in the group. When we check for B's that end before A's li, then if B is A, then ri of B is A's ri. But A's li is the start of A. So ri of B is A's ri, which is >= A's li. So the condition ri < A's li would not be satisfied. Hence, even if B is A, it will not be considered. Similarly for the other case.\n\nTherefore, even if the code includes voucher A in the target_d group, it will not be considered as a valid B. Therefore, there's no need to exclude it. Because when we look for B's that are non-overlapping with A, the B can't be A itself. Hence, the code can proceed as is.\n\nThat's good. So we don't have to worry about the same voucher being considered twice. Because even if it's in the group, it won't satisfy the non-overlapping condition.\n\nSo, the code can proceed as described.\n\nNow, the next step is to implement this.\n\nNow, let's think about how to structure the data structures.\n\nIn Python, for each duration d, we can have two entries in a dictionary:\n\n- For sorted_ri, which is a list of vouchers sorted by ri, and a prefix_min array.\n\n- For sorted_li, which is a list of vouchers sorted by li, and a suffix_min array.\n\nSo, for example, we can have a dictionary called duration_data, where each key is a duration d, and the value is a tuple of (sorted_ri_list, prefix_min_ri, sorted_li_list, suffix_min_li).\n\nBut how to build these.\n\nLet me think about code steps.\n\nOnce we have grouped all vouchers by duration, for each duration d in the group:\n\n   vouchers = list of vouchers with duration d.\n\n   sorted_ri = sorted(vouchers, key=lambda v: v.ri)\n\n   sorted_li = sorted(vouchers, key=lambda v: v.li)\n\n   then compute prefix_min_ri:\n\n   prefix_min = [0] * len(sorted_ri)\n\n   prefix_min[0] = sorted_ri[0].cost\n\n   for i in 1 to len(sorted_ri)-1:\n\n       prefix_min[i] = min(prefix_min[i-1], sorted_ri[i].cost)\n\n   similarly for suffix_min_li:\n\n   suffix_min = [0] * len(sorted_li)\n\n   suffix_min[-1] = sorted_li[-1].cost\n\n   for i in len(sorted_li)-2 downto 0:\n\n       suffix_min[i] = min(suffix_min[i+1], sorted_li[i].cost)\n\n   then, store in duration_data[d] the sorted_ri, prefix_min_ri, sorted_li, suffix_min_li.\n\nBut how to get the list of ri's for the sorted_ri list? Well, perhaps for the binary search, we can extract the ri's from the sorted_ri list. For example, for the sorted_ri list, we can have a separate list of ri's, say ri_list = [v.ri for v in sorted_ri]. Similarly for the sorted_li list, li_list = [v.li for v in sorted_li].\n\nSo during the binary search steps, we can use these lists.\n\nNow, for each voucher A in the original list:\n\n   d_A = duration of A.\n\n   target_d = x - d_A.\n\n   if target_d not in duration_data: continue.\n\n   else:\n\n      process the two cases.\n\nFor case 1: B ends before A's li.\n\n   get the sorted_ri list and prefix_min for target_d.\n\n   ri_list = [v.ri for v in sorted_ri_list]\n\n   li_A = A's li.\n\n   using bisect_left on ri_list to find the insertion point of li_A.\n\n   k = bisect.bisect_left(ri_list, li_A)\n\n   if k > 0:\n\n       min_cost_before = prefix_min[k-1]\n\n       total = A.cost + min_cost_before\n\n       update the global minimum.\n\nFor case 2: B starts after A's ri.\n\n   get the sorted_li list and suffix_min for target_d.\n\n   li_list = [v.li for v in sorted_li_list]\n\n   ri_A = A's ri.\n\n   using bisect_right on li_list to find the insertion point of ri_A.\n\n   k = bisect.bisect_right(li_list, ri_A)\n\n   if k < len(li_list):\n\n       min_cost_after = suffix_min[k]\n\n       total = A.cost + min_cost_after\n\n       update the global minimum.\n\nSo, that's the plan.\n\nNow, what about the edge cases?\n\nFor example, when x is 0? Well, according to the input constraints, x is at least 2. Wait, no: the input says x is between 2 and 2e5. Wait, the first line says:\n\nInput:\n\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105)\n\nSo x is at least 2.\n\nBut for each voucher's duration, it's ri - li + 1. Which is at least 1 (since li <= ri). So, for x to be achievable, there must be two durations that sum to x. For example, if x is 2, then two vouchers each of duration 1.\n\nBut the code handles that.\n\nNow, for the case where target_d is zero? No, since x is at least 2, and d_A is at least 1, so target_d = x - d_A would be at least 2-1=1. So no problem.\n\nAnother edge case: when there are multiple vouchers with the same duration and overlapping times. But the code would find the minimal ones.\n\nNow, what about when the same voucher is considered in both cases? Like, when voucher A is checked against voucher B, and then voucher B is checked against voucher A. But since the code checks all vouchers, it's possible that both pairs are considered. However, since we are tracking the global minimum, it's okay. For example, when voucher A and B are valid, the code would find the pair once when processing A and once when processing B. But since the total cost is same, it doesn't affect the result.\n\nNow, let's think about the example given.\n\nFirst example input:\n\n4 5\n\nVouchers:\n\n1 3 4 → duration 3 (3-1+1=3)\n\n1 2 5 → duration 2\n\n5 6 1 → duration 2 (6-5+1=2)\n\n1 2 4 → duration 2.\n\nSo x is 5. So for each voucher, we check for target_d = 5 - duration.\n\nFor the first voucher (duration 3), target_d is 2. So check for vouchers with duration 2 that are before (end before 1) or after (start after 3).\n\nLooking for vouchers with duration 2.\n\nThe vouchers with duration 2 are:\n\nvoucher 2: l=1, r=2, cost 5\n\nvoucher 3: l=5, r=6, cost 1\n\nvoucher 4: l=1, r=2, cost 4.\n\nSo for the first voucher, li is 1. So for case 1: find vouchers with duration 2 that end before 1. Their ri must be < 1. But all vouchers with duration 2 have ri >= 2 (voucher 2 and 4 have ri=2, voucher 3 has ri=6). So no such vouchers. So case 1 gives nothing.\n\nFor case 2: find vouchers with duration 2 that start after 3 (the ri of first voucher is 3). So looking for li > 3. The vouchers with duration 2 have li's 1, 5, 1. So the sorted_li_list for duration 2 is sorted by li. So sorted_li would be [1, 1, 5]. The li_list is [1, 1, 5]. For ri_A=3, bisect_right finds the insertion point in [1,1,5] for 3. The bisect_right returns 2 (since 3 is between 1 and 5). So k=2. The suffix_min from index 2 is the min of [5], which is 1. So adding the first voucher's cost (4) + 1 = 5. Which is the correct answer.\n\nSo that's how it works.\n\nAnother example is when the voucher is in the target_d group. For example, suppose a voucher A has duration d, and target_d is d. Then, when checking for vouchers with duration d, the code would check if there's another voucher that doesn't overlap with it.\n\nNow, the code for the first case would check for vouchers with duration d that end before A's li. Which would be possible if there are other vouchers with duration d that end before A's li.\n\nNow, the code structure in Python:\n\nImplementing the steps:\n\nFirst, read n and x.\n\nThen read n vouchers. For each, compute duration.\n\nGroup them by duration. For example, using a defaultdict(list).\n\nThen, for each duration in the group, process the sorted_ri and sorted_li lists, and their min arrays.\n\nNow, in Python, to handle the sorted lists and their min arrays, we can create for each duration d, a structure. For example, a dictionary called duration_info, which maps each duration to a tuple (sorted_ri_list, prefix_min_ri, sorted_li_list, suffix_min_li).\n\nBut how to create the sorted_ri_list and the prefix_min_ri.\n\nOnce the vouchers are grouped, for each duration d:\n\nsorted_ri = sorted(vouchers, key=lambda v: v.ri)\n\nri_values = [v.ri for v in sorted_ri]\n\nprefix_min = [ ... ]\n\nSimilarly for sorted_li.\n\nBut in Python, we can generate the prefix_min and suffix_min arrays.\n\nOnce that is done, for each voucher in the original list, check for target_d.\n\nNow, let's think about the code.\n\nImplementing in Python:\n\nBut first, we need to represent vouchers. Let's create a list of vouchers. Each voucher can be represented as a tuple (li, ri, cost, duration). Or perhaps, during processing, compute duration as needed.\n\nBut for grouping, we can compute duration for each voucher.\n\nSo:\n\nimport sys\n\nfrom bisect import bisect_left, bisect_right\n\nfrom collections import defaultdict\n\nn, x = map(int, sys.stdin.readline().split())\n\nvouchers = []\n\nfor _ in range(n):\n\n    l, r, cost = map(int, sys.stdin.readline().split())\n\n    duration = r - l + 1\n\n    vouchers.append( (l, r, cost, duration) )\n\nThen, group by duration:\n\nduration_dict = defaultdict(list)\n\nfor l, r, cost, dur in vouchers:\n\n    duration_dict[dur].append( (l, r, cost) )\n\nThen, for each duration in duration_dict, process sorted_ri, prefix_min, sorted_li, suffix_min.\n\nWe can create another dictionary, say, info = defaultdict( ... )\n\nBut perhaps, for each duration, we can precompute the sorted_ri list and prefix_min, and sorted_li list and suffix_min.\n\nSo:\n\ninfo = {}\n\nfor dur in duration_dict:\n\n    # process sorted_ri and prefix_min\n\n    sorted_ri = sorted( duration_dict[dur], key=lambda x: x[1] )  # sort by ri\n\n    ri_list = [v[1] for v in sorted_ri]\n\n    # compute prefix_min\n\n    prefix_min = [0]*len(sorted_ri)\n\n    prefix_min[0] = sorted_ri[0][2]\n\n    for i in range(1, len(sorted_ri)):\n\n        prefix_min[i] = min( prefix_min[i-1], sorted_ri[i][2] )\n\n    # process sorted_li and suffix_min\n\n    sorted_li = sorted( duration_dict[dur], key=lambda x: x[0] )  # sort by li\n\n    li_list = [v[0] for v in sorted_li]\n\n    # compute suffix_min\n\n    suffix_min = [0]*len(sorted_li)\n\n    suffix_min[-1] = sorted_li[-1][2]\n\n    for i in range(len(sorted_li)-2, -1, -1):\n\n        suffix_min[i] = min( suffix_min[i+1], sorted_li[i][2] )\n\n    # store in info\n\n    info[dur] = (sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min )\n\nOnce that is done, for each voucher in the original list:\n\nglobal_min = infinity\n\nfor l_a, r_a, cost_a, dur_a in vouchers:\n\n    target_d = x - dur_a\n\n    if target_d not in info:\n\n        continue\n\n    # process case 1: find vouchers in target_d that end before l_a\n\n    # get the sorted_ri, ri_list, prefix_min\n\n    sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min = info[target_d]\n\n    # case 1: find in ri_list the max ri < l_a\n\n    k = bisect_left(ri_list, l_a)\n\n    if k > 0:\n\n        current_min = prefix_min[k-1]\n\n        total = cost_a + current_min\n\n        if total < global_min:\n\n            global_min = total\n\n    # case 2: find in li_list the first li > r_a\n\n    k = bisect_right(li_list, r_a)\n\n    if k < len(li_list):\n\n        current_min = suffix_min[k]\n\n        total = cost_a + current_min\n\n        if total < global_min:\n\n            global_min = total\n\nAfter processing all vouchers, if global_min is still infinity, output -1 else output global_min.\n\nWait, but the code for info is stored as (sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min). So for each target_d, we get the sorted_ri, ri_list, etc.\n\nBut in the code above, the 'info' is built for each duration. So for the target_d, we check if it's in the info (which is built from duration_dict, which has all the durations present in the vouchers). So that's okay.\n\nBut in the code, when building the info, the 'duration_dict' is built from the vouchers, and the info is built for each duration in duration_dict. So, if target_d is not in duration_dict, then it's not in info. So the code proceeds correctly.\n\nBut in the code above, the 'info' is built for each duration in duration_dict. So for each dur in duration_dict, the info is stored. So for target_d not in info, we skip.\n\nBut what if target_d is zero? Well, since x is at least 2, and dur_a is at least 1, target_d would be x - dur_a. Since x >= 2, and dur_a >=1, target_d >= 1. So no problem.\n\nNow, let's test this code with the first sample input.\n\nSample Input 1:\n\n4 5\n\nVouchers:\n\n1 3 4 → duration 3\n\n1 2 5 → duration 2\n\n5 6 1 → duration 2\n\n1 2 4 → duration 2.\n\nSo duration_dict has keys 3 and 2.\n\nFor duration 3:\n\nsorted_ri is [(1,3,4)] (since only one voucher). ri_list is [3]. prefix_min is [4].\n\nsorted_li is [(1,3,4)], li_list is [1]. suffix_min is [4].\n\nFor duration 2:\n\nsorted_ri is sorted by ri. The vouchers are (1,2,5), (1,2,4), (5,6,1). Their ri's are 2, 2, 6. So sorted_ri would be [(1,2,5), (1,2,4), (5,6,1)]? Wait no, when sorted by ri, the ri is 2, 2, 6. So the sorted_ri would have those three vouchers. But when sorted by ri, if two have same ri, their order depends on other fields. But since we are only interested in the ri, the order between same ri's doesn't matter for the prefix_min. The prefix_min would take the minimum cost.\n\nThe prefix_min for sorted_ri would be:\n\nsorted_ri[0] is (1,2,5) → cost 5.\n\nsorted_ri[1] is (1,2,4) → cost 4. prefix_min[1] = min(5,4) =4.\n\nsorted_ri[2] is (5,6,1) → cost 1. prefix_min[2] = min(4, 1) =1.\n\nSo ri_list is [2, 2, 6].\n\nFor case 1: when processing the first voucher (dur_a=3, target_d=2), we check for vouchers in target_d (2) that end before l_a=1. The ri_list is [2,2,6]. bisect_left(ri_list, 1) → returns 0. So k is 0, which is not >0. So no contribution.\n\nFor case 2: check for vouchers with target_d=2 that start after r_a=3. The sorted_li for duration 2 is sorted by li. The vouchers are (1,2,5), (1,2,4), (5,6,1). So sorted_li is sorted by li. The li's are 1,1,5. li_list is [1,1,5]. bisect_right(li_list, 3) → 3 is inserted after 1s. The bisect_right returns 2. Since len(li_list) is 3, k=2 is <3. So suffix_min[2] is 1. So total is 4+1=5. Which is correct.\n\nSo the code would find that.\n\nAnother voucher in the list is the third voucher (5,6,1, duration 2). For this voucher, target_d is 5-2=3. So check if 3 is in info. Yes.\n\nFor case 1: find vouchers with duration 3 (sorted_ri is [(1,3,4)]), ri_list is [3]. Check if ri < l_a of this voucher (5). l_a is 5. So bisect_left(ri_list, 5) is 1 (since 3 <5). k is 1>0. So prefix_min[0] is 4. So total is 1 +4 =5. Which is same as before.\n\nCase 2: find vouchers with duration 3 that start after 6 (r_a of this voucher is 6). The sorted_li for duration 3 is [(1,3,4)], li_list is [1]. bisect_right([1], 6) returns 1. Which is equal to len(li_list) (1), so no contribution. So case 2 gives nothing. But case 1 gives 5.\n\nSo the code would capture that.\n\nSo the code would find the correct minimum.\n\nNow, what about the second sample input?\n\nSample Input 2:\n\n3 2\n\n4 6 3 → duration 3 (6-4+1=3)\n\n2 4 1 → duration 3 (4-2+1=3)\n\n3 5 4 → duration 3 (5-3+1=3)\n\nx is 2. So for each voucher, target_d is 2 -3 = -1. Which is not present. So no possible pairs. Hence output is -1.\n\nWhich matches the sample.\n\nSo the code seems to handle that.\n\nNow, what about when there are multiple vouchers with same duration and overlapping?\n\nAnother test case: n=2, x=2. Each voucher has duration 1. So two vouchers. They need to be non-overlapping.\n\nFor example:\n\nvoucher 1: l=1, r=1, cost 1.\n\nvoucher 2: l=2, r=2, cost 1.\n\nThen, for voucher 1, target_d is 1. Check for vouchers with duration 1.\n\nCase 1: find vouchers with duration 1 that end before l_a=1. So ri <1. None. Case 2: find vouchers with duration 1 that start after r_a=1. The voucher 2 has li=2>1. So the code would find it. The suffix_min would be 1. So total is 1+1=2.\n\nSimilarly for voucher 2, same thing. So the code would return 2.\n\nAnother case where vouchers are overlapping but there's a non-overlapping pair.\n\nNow, what about when there are multiple options, and the code picks the minimal.\n\nNow, the code seems to handle that.\n\nPotential issues:\n\n- The code uses the same voucher twice? No, as discussed earlier.\n\n- What if there are multiple vouchers in the target_d group, and some of them are non-overlapping with A?\n\nYes, the code finds the minimal cost.\n\nNow, let's think about the time complexity.\n\nGrouping the vouchers by duration: O(n).\n\nFor each duration d, sorting the vouchers for sorted_ri and sorted_li: O(m log m) for each group of size m. The total across all groups is O(n log n).\n\nFor each voucher, processing two binary searches and checking two cases: O(log m) per voucher. Since each voucher is processed once, total is O(n log n).\n\nSo overall, the time complexity is acceptable for n up to 2e5.\n\nNow, code implementation in Python.\n\nBut in Python, for the info dictionary, we need to store for each duration the sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min.\n\nBut how to store that. For example, for each duration, we can have a tuple of (sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min).\n\nNow, code:\n\nImplementing the above steps.\n\nBut in Python, for the duration_dict, we have:\n\nduration_dict = defaultdict(list)\n\nfor l, r, cost, dur in vouchers:\n\n    duration_dict[dur].append( (l, r, cost) )\n\nThen, for each dur in duration_dict, we process the data.\n\nBut in the code, the vouchers are stored as tuples (l, r, cost).\n\nNow, in the code, the info is built as follows:\n\ninfo = {}\n\nfor dur in duration_dict:\n\n    # process sorted_ri and prefix_min\n\n    sorted_ri = sorted( duration_dict[dur], key=lambda x: x[1] )  # sort by ri\n\n    ri_list = [v[1] for v in sorted_ri]\n\n    prefix_min = [0]*len(sorted_ri)\n\n    prefix_min[0] = sorted_ri[0][2]\n\n    for i in range(1, len(sorted_ri)):\n\n        prefix_min[i] = min( prefix_min[i-1], sorted_ri[i][2] )\n\n    # process sorted_li and suffix_min\n\n    sorted_li = sorted( duration_dict[dur], key=lambda x: x[0] )  # sort by li\n\n    li_list = [v[0] for v in sorted_li]\n\n    suffix_min = [0]*len(sorted_li)\n\n    suffix_min[-1] = sorted_li[-1][2]\n\n    for i in range(len(sorted_li)-2, -1, -1):\n\n        suffix_min[i] = min( suffix_min[i+1], sorted_li[i][2] )\n\n    # store in info\n\n    info[dur] = (sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min )\n\nOnce that is done, for each voucher in the original list:\n\nglobal_min = infinity (like float('inf'))\n\nfor l_a, r_a, cost_a, dur_a in vouchers:\n\n   ",
    "response": "\n\nTo solve this problem, we need to help Leha choose two non-overlapping travel vouchers such that their combined duration exactly matches his vacation length, and the total cost is minimized. \n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This helps in efficiently checking pairs of vouchers whose durations sum up to the required vacation length.\n2. **Preprocess for Efficient Querying**: For each duration, preprocess the vouchers into two sorted lists:\n   - One sorted by the end date (ri) with prefix minimum costs.\n   - Another sorted by the start date (li) with suffix minimum costs.\n3. **Check for Valid Pairs**: For each voucher, check if there exists another voucher with a complementary duration such that they do not overlap. Use binary search to efficiently find valid non-overlapping vouchers and compute the minimum cost.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    duration_dict = defaultdict(list)\n    for l, r, cost, dur in vouchers:\n        duration_dict[dur].append((l, r, cost))\n    \n    info = {}\n    for dur in duration_dict:\n        # Process sorted_ri and prefix_min\n        sorted_ri = sorted(duration_dict[dur], key=lambda x: x[1])\n        ri_list = [v[1] for v in sorted_ri]\n        prefix_min = [0] * len(sorted_ri)\n        prefix_min[0] = sorted_ri[0][2]\n        for i in range(1, len(sorted_ri)):\n            prefix_min[i] = min(prefix_min[i-1], sorted_ri[i][2])\n        \n        # Process sorted_li and suffix_min\n        sorted_li = sorted(duration_dict[dur], key=lambda x: x[0])\n        li_list = [v[0] for v in sorted_li]\n        suffix_min = [0] * len(sorted_li)\n        suffix_min[-1] = sorted_li[-1][2]\n        for i in range(len(sorted_li)-2, -1, -1):\n            suffix_min[i] = min(suffix_min[i+1], sorted_li[i][2])\n        \n        info[dur] = (sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min)\n    \n    min_total = float('inf')\n    for l_a, r_a, cost_a, dur_a in vouchers:\n        target_d = x - dur_a\n        if target_d not in info:\n            continue\n        \n        sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min = info[target_d]\n        \n        # Case 1: B ends before A's start (l_a)\n        k = bisect_left(ri_list, l_a)\n        if k > 0:\n            current_min = prefix_min[k-1]\n            min_total = min(min_total, cost_a + current_min)\n        \n        # Case 2: B starts after A's end (r_a)\n        k = bisect_right(li_list, r_a)\n        if k < len(li_list):\n            current_min = suffix_min[k]\n            min_total = min(min_total, cost_a + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and stored along with each voucher's duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient access.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end and start dates. Prefix and suffix minimum cost arrays are created to quickly determine the minimum cost for valid non-overlapping intervals.\n4. **Binary Search for Valid Pairs**: For each voucher, binary search is used to check for valid non-overlapping vouchers with the required complementary duration, ensuring efficient querying and minimizing the total cost.\n\nThis approach ensures that we efficiently check all possible valid pairs while maintaining a time complexity of O(n log n), making it suitable for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    duration_dict = defaultdict(list)\n    for l, r, cost, dur in vouchers:\n        duration_dict[dur].append((l, r, cost))\n    \n    info = {}\n    for dur in duration_dict:\n        # Process sorted_ri and prefix_min\n        sorted_ri = sorted(duration_dict[dur], key=lambda x: x[1])\n        ri_list = [v[1] for v in sorted_ri]\n        prefix_min = [0] * len(sorted_ri)\n        prefix_min[0] = sorted_ri[0][2]\n        for i in range(1, len(sorted_ri)):\n            prefix_min[i] = min(prefix_min[i-1], sorted_ri[i][2])\n        \n        # Process sorted_li and suffix_min\n        sorted_li = sorted(duration_dict[dur], key=lambda x: x[0])\n        li_list = [v[0] for v in sorted_li]\n        suffix_min = [0] * len(sorted_li)\n        suffix_min[-1] = sorted_li[-1][2]\n        for i in range(len(sorted_li)-2, -1, -1):\n            suffix_min[i] = min(suffix_min[i+1], sorted_li[i][2])\n        \n        info[dur] = (sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min)\n    \n    min_total = float('inf')\n    for l_a, r_a, cost_a, dur_a in vouchers:\n        target_d = x - dur_a\n        if target_d not in info:\n            continue\n        \n        sorted_ri, ri_list, prefix_min, sorted_li, li_list, suffix_min = info[target_d]\n        \n        # Case 1: B ends before A's start (l_a)\n        k = bisect_left(ri_list, l_a)\n        if k > 0:\n            current_min = prefix_min[k-1]\n            min_total = min(min_total, cost_a + current_min)\n        \n        # Case 2: B starts after A's end (r_a)\n        k = bisect_right(li_list, r_a)\n        if k < len(li_list):\n            current_min = suffix_min[k]\n            min_total = min(min_total, cost_a + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 938,
        "thoughts_token_count": 8191
    }
}