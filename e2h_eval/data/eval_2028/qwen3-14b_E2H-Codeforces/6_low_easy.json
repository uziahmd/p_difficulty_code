{
    "start": 1758313552.2088501,
    "end": 1758313938.3905876,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:32 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and the sum of their costs is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the input. Each voucher has li (start day), ri (end day), and cost. The duration is ri - li + 1. We need two vouchers i and j where either ri < lj or rj < li (so they don't overlap). Also, the sum of their durations is exactly x. And find the minimal total cost.\n\nConstraints: n can be up to 2e5, which is 200,000. So any O(n^2) approach is definitely out of the question. Need an efficient solution.\n\nLet me think about how to approach this.\n\nThe key points are:\n\n- For each voucher, check if there exists another voucher that doesn't overlap with it, and their durations sum to x.\n\nBut checking all pairs is O(n^2), which is not feasible for n=2e5.\n\nAlternative idea: For each voucher, determine what duration it has. Suppose a voucher has duration d. Then we need another voucher with duration x - d. And these two vouchers must not overlap.\n\nSo, for each voucher, we can check if there exists a voucher with duration (x - d) that ends before the current voucher starts, or starts after the current voucher ends.\n\nBut how to efficiently find such vouchers?\n\nLet me think. Let's pre-process vouchers grouped by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, we look into the group of vouchers with duration (x - d). For each such voucher in that group, check if they don't overlap with the current voucher.\n\nBut even this approach could be O(n^2) in worst case. For example, if all vouchers have duration d, and x is 2d. Then for each voucher, we check all others in the same group. Which would be O(n^2) again.\n\nHmm. So need a way to find, for a given voucher (say, with duration d, and start and end times), the minimal cost voucher in the other group (duration x-d) that ends before the current voucher's start, or starts after the current voucher's end.\n\nWait, but how can we find that quickly?\n\nFor example, suppose we have a voucher A with duration d. We want to find vouchers B with duration (x -d) that end before A's start (so B's end < A's start), or start after A's end (B's start > A's end). For each such B, we can take the minimal cost.\n\nSo for each voucher, we can check two possibilities:\n\n1. Find the minimal cost voucher in the group (x -d) that ends before the current voucher's start.\n\n2. Find the minimal cost voucher in the group (x -d) that starts after the current voucher's end.\n\nIf we can do this efficiently, then for each voucher, we can check these two possibilities and keep track of the minimal sum.\n\nBut how to do this?\n\nLet me think about the data structures. For each duration, say, k, we can have two sorted lists:\n\n- One sorted by end time (so that for a given start time, we can find all vouchers ending before that start time).\n\n- Another sorted by start time (so that for a given end time, we can find all vouchers starting after that end time).\n\nBut perhaps for each duration k, we can pre-process the vouchers with that duration, sorted by their end time, and also sorted by their start time.\n\nThen, for a voucher A with duration d, and looking for vouchers B with duration (x -d):\n\nCase 1: B ends before A starts. So B's end < A's start.\n\nIn this case, for all vouchers B in the (x-d) group, we need to find the ones with end < A's start. Among those, we want the one with minimal cost.\n\nSimilarly for case 2: B's start > A's end. So among vouchers B in the (x-d) group, find those with start > A's end, and find the minimal cost.\n\nSo, for each duration k, we can have two structures:\n\n- A sorted list of end times, along with the minimal cost up to that end time. So for example, if we have vouchers sorted by end time, and for each position in the sorted list, we have the minimum cost from the beginning up to that position. Then, given a target start (A's start), we can perform a binary search to find the largest end time less than A's start. Then, the minimal cost up to that point would be the minimum",
    "response": "To solve this problem, we need to find two non-overlapping vouchers from a list such that their combined duration equals a given value `x` and their total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently checking for pairs of vouchers whose durations sum up to `x`.\n2. **Preprocess Data Structures**: For each duration, we maintain two sorted lists:\n   - One sorted by the end day of the voucher.\n   - Another sorted by the start day of the voucher.\n3. **Efficient Querying**: For each voucher, we check if there exists another voucher with the complementary duration (i.e., `x - duration`) that does not overlap. We use binary search on the preprocessed lists to quickly find the minimum cost of such non-overlapping vouchers.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers_by_duration = defaultdict(list)\n    \n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers_by_duration[duration].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end and start, and prefix min for end, suffix min for start\n    duration_info = dict()\n    for d in vouchers_by_duration:\n        lst = vouchers_by_duration[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost for sorted_by_end\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost for sorted_by_start\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        duration_info[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for d in vouchers_by_duration:\n        target_d = x - d\n        if target_d not in duration_info:\n            continue\n        current_vouchers = vouchers_by_duration[d]\n        # For each voucher in current_vouchers, check against target_d's vouchers\n        # Get the info for target_d\n        target_sorted_end, target_prefix_min, target_sorted_start, target_suffix_min = duration_info[target_d]\n        # For each voucher in current_vouchers, check two cases\n        for l1, r1, cost1 in current_vouchers:\n            # Case 1: find vouchers in target_d that end before l1\n            # Binary search on target_sorted_end's end times\n            ends = [v[1] for v in target_sorted_end]\n            idx_end = bisect.bisect_left(ends, l1) - 1\n            if idx_end >= 0:\n                min_cost = target_prefix_min[idx_end]\n                total = cost1 + min_cost\n                if total < min_total:\n                    min_total = total\n            # Case 2: find vouchers in target_d that start after r1\n            starts = [v[0] for v in target_sorted_start]\n            idx_start = bisect.bisect_right(starts, r1)\n            if idx_start < len(starts):\n                min_cost = target_suffix_min[idx_start]\n                total = cost1 + min_cost\n                if total < min_total:\n                    min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: Vouchers are grouped by their duration to efficiently check for pairs that sum up to `x`.\n2. **Preprocessing**: For each duration, vouchers are sorted by their end and start times. This allows efficient binary search operations to find non-overlapping vouchers.\n3. **Binary Search**: For each voucher, we use binary search to find the minimum cost of vouchers that end before the current voucher starts or start after the current voucher ends. This ensures efficient querying and minimizes the total cost.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n^2) solution, making it feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers_by_duration = defaultdict(list)\n    \n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers_by_duration[duration].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end and start, and prefix min for end, suffix min for start\n    duration_info = dict()\n    for d in vouchers_by_duration:\n        lst = vouchers_by_duration[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost for sorted_by_end\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost for sorted_by_start\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        duration_info[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for d in vouchers_by_duration:\n        target_d = x - d\n        if target_d not in duration_info:\n            continue\n        current_vouchers = vouchers_by_duration[d]\n        # For each voucher in current_vouchers, check against target_d's vouchers\n        # Get the info for target_d\n        target_sorted_end, target_prefix_min, target_sorted_start, target_suffix_min = duration_info[target_d]\n        # For each voucher in current_vouchers, check two cases\n        for l1, r1, cost1 in current_vouchers:\n            # Case 1: find vouchers in target_d that end before l1\n            # Binary search on target_sorted_end's end times\n            ends = [v[1] for v in target_sorted_end]\n            idx_end = bisect.bisect_left(ends, l1) - 1\n            if idx_end >= 0:\n                min_cost = target_prefix_min[idx_end]\n                total = cost1 + min_cost\n                if total < min_total:\n                    min_total = total\n            # Case 2: find vouchers in target_d that start after r1\n            starts = [v[0] for v in target_sorted_start]\n            idx_start = bisect.bisect_right(starts, r1)\n            if idx_start < len(starts):\n                min_cost = target_suffix_min[idx_start]\n                total = cost1 + min_cost\n                if total < min_total:\n                    min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1081,
        "thoughts_token_count": 1024
    }
}