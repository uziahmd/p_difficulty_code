{
    "start": 1758008330.3104484,
    "end": 1758008514.134874,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs of vouchers that satisfy these conditions and find the minimum sum of their costs.\n\nConstraints are n up to 2e5, which is 200,000. So O(n^2) approaches are definitely out of the question. We need something more efficient.\n\nLet me think about how to approach this.\n\nFirst, for each voucher, we can compute its duration. Let's say for voucher i, duration is d_i = ri - li + 1. Then, for each voucher, we need to find another voucher j where d_j = x - d_i, and the two vouchers do not overlap.\n\nSo the plan is:\n\n- For each voucher i, check if there exists a voucher j with duration x - d_i. And then check if they don't overlap. Then track the minimum cost.\n\nBut how to efficiently find those j's?\n\nLet me think about grouping vouchers by their duration. So create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher i with duration d, we can look up in the dictionary for duration (x - d). For each such voucher j in that group, check if they don't overlap. But even then, for each voucher i, checking all vouchers in the (x - d) group could be O(n) in worst case, leading to O(n^2) time again.\n\nBut perhaps we can pre-process for each duration, the vouchers sorted by their end time, and for each voucher i, find the earliest possible voucher j that starts after the end of i, or the earliest that ends before the start of i. Wait, but how to find the minimal cost?\n\nAlternatively, for each duration d, we can precompute for each voucher with duration d, the minimal cost of vouchers that end before a certain time, or start after a certain time.\n\nWait, here's an idea:\n\nFor each possible duration d, we can have two structures:\n\n- A sorted list of vouchers with duration d, sorted by their end time (ri). For each such voucher, we can keep track of the minimal cost up to that point. So when we have a voucher i with duration d, and we need to find vouchers with duration (x - d) that end before li (so that they don't overlap with i). So for that, if we have a list of vouchers with duration (x - d) sorted by their end time, we can perform a binary search to find the earliest ones that end before li. Then, among those, we can take the minimal cost.\n\nSimilarly, for vouchers with duration (x - d) that start after ri of voucher i. Because then, voucher i ends before voucher j starts. So for that, we can have another sorted list (sorted by start time) and find the minimal cost for those that start after ri.\n\nBut how to pre-process this?\n\nLet me think. For each duration d, we can have two sorted lists:\n\n- Sorted by end time (ri) and for each position, keep the minimum cost up to that index. So that when we want to find all vouchers with duration d that end before a certain time, we can binary search for the latest end time <= that time, and then get the minimum cost in that prefix.\n\nSimilarly, sorted by start time (li), and for each position, keep the minimum cost from that index onwards. So that when we want to find vouchers that start after a certain time, we can binary search for the earliest start time >= that time, and get the minimum cost in the suffix.\n\nBut how to implement this?\n\nAlternatively, for each duration d, we can have two arrays:\n\n- One array sorted by ri (end time). For this array, we can precompute a prefix minimum array. So for any query of \"find the minimum cost of vouchers with duration d that end before a certain time\", we can find the largest ri <= that time, and then take the prefix min up to that index.\n\n- Another array sorted by li (start time). For this array, precompute a suffix minimum array. So for a query of \"find the minimum cost of vouchers with duration d that start after a certain time\", we can find the first li >= that time, and take the suffix min from",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, while minimizing the total cost. The solution involves efficiently searching for valid voucher pairs using preprocessing and binary search techniques.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly finding vouchers that could potentially form a valid pair with another voucher.\n2. **Preprocessing for Efficient Search**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date (`ri`) to facilitate finding vouchers that end before a given start date.\n   - Another sorted by the start date (`li`) to facilitate finding vouchers that start after a given end date.\n3. **Prefix and Suffix Minimum Arrays**: For each sorted list, we precompute prefix minimum arrays (for end date sorted list) and suffix minimum arrays (for start date sorted list). These arrays allow us to quickly determine the minimum cost of valid vouchers during binary search operations.\n4. **Binary Search for Valid Pairs**: For each voucher, we check if there exists a voucher with the complementary duration such that they do not overlap. We use binary search on the preprocessed lists to find the minimum cost efficiently.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess each duration's data\n    # For each duration d, we have two sorted lists:\n    # 1. sorted by end time (r), with prefix min cost\n    # 2. sorted by start time (l), with suffix min cost\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d not in processed:\n            continue\n        \n        # Check for vouchers with duration target_d that end before l\n        sorted_by_end, prefix_min, _, _ = processed[target_d]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, current_min + cost)\n        \n        # Check for vouchers with duration target_d that start after r\n        _, _, sorted_by_start, suffix_min = processed[target_d]\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(starts, r + 1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by their start date, end date, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for quick lookup.\n3. **Preprocessing**: For each duration, we sort vouchers by their end and start times, and compute prefix and suffix minimum cost arrays to facilitate efficient range minimum queries.\n4. **Binary Search for Valid Pairs**: For each voucher, we use binary search on the preprocessed lists to find valid non-overlapping vouchers with the complementary duration, ensuring the total duration matches `x` and minimizing the total cost.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n^2) brute-force method, making it suitable for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess each duration's data\n    # For each duration d, we have two sorted lists:\n    # 1. sorted by end time (r), with prefix min cost\n    # 2. sorted by start time (l), with suffix min cost\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d not in processed:\n            continue\n        \n        # Check for vouchers with duration target_d that end before l\n        sorted_by_end, prefix_min, _, _ = processed[target_d]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, current_min + cost)\n        \n        # Check for vouchers with duration target_d that start after r\n        _, _, sorted_by_start, suffix_min = processed[target_d]\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(starts, r + 1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1121,
        "thoughts_token_count": 1023
    }
}