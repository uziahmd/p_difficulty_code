{
    "start": 1758309277.985802,
    "end": 1758309516.8812492,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about assigning R Rebel spaceships to B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. But there's an additional condition: any two straight paths (from a base to its assigned spaceship) must not intersect in the 2D plane. So, the question is whether such a perfect matching exists.\n\nFirst, the input gives R and B. Then R points for spaceships, then B points for bases. The output is \"Yes\" or \"No\" depending on whether such a matching exists.\n\nConstraints: R and B are up to 10, so maybe we can check all possible permutations. But how do we check if a particular matching has non-crossing paths?\n\nHmm. The key is to find a perfect matching between the two sets where no two edges cross each other.\n\nSo the problem reduces to checking if there exists a perfect matching between the two sets of points (spaceships and bases) such that no two edges in the matching cross each other.\n\nNow, how do I check if two line segments cross? Well, given two line segments (p1, q1) and (p2, q2), we can check if they intersect. But since the problem says that no three points are colinear, maybe that simplifies things. Wait, the note says that no three points are on the same line. So any two line segments can't have overlapping parts except at endpoints. So, for two line segments, they either cross each other (properly intersect) or not. Because if they share an endpoint, but since all points are unique, that would be only if one segment connects a spaceship to a base, and another connects to the same point. But since each spaceship is assigned to exactly one base, and vice versa, in a perfect matching, each point is used once. So, two line segments in the matching can't share an endpoint. Therefore, any two line segments in the matching are between distinct pairs of points. So, for two line segments (s1, b1) and (s2, b2), they can either cross or not.\n\nSo for a given permutation (matching), we need to check that all pairs of edges in the matching don't cross each other.\n\nBut how do I check if two line segments cross?\n\nI remember that there's a computational geometry approach for checking if two line segments intersect. Let me recall the steps.\n\nFirst, check if the two segments (p1, q1) and (p2, q2) intersect. The standard method is to use orientation checks. The steps are:\n\n- Check if the two segments intersect properly (i.e., not just touching at endpoints). But in our case, since all points are unique and no three are colinear, if two segments cross, they must do so in their interiors. So, the check for intersection would involve checking if the orientations of the points are such that they cross.\n\nAlternatively, perhaps using the cross product approach. For two line segments AB and CD, they intersect if and only if:\n\n- The orientation of A, B, C is different from the orientation of A, B, D, and the orientation of C, D, A is different from the orientation of C, D, B. Also, we need to handle cases where points are colinear, but the problem says that no three points are colinear. Wait, the problem statement says that no three points are on the same line. So, for any two line segments in the matching, their endpoints are all distinct and no three are colinear. Therefore, if two segments cross, they must cross properly, and the orientation conditions will capture that.\n\nSo the algorithm for checking if two segments AB and CD intersect is:\n\nCheck if the orientations of (A, B, C) and (A, B, D) are different, and the orientations of (C, D, A) and (C, D, B) are different.\n\nSo, first, I need a helper function to compute the orientation of three points. The orientation is determined by the cross product. For three points p, q, r:\n\nThe value (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x) gives the cross product. If it's positive, the turn is counter-clockwise; if zero, colinear; if negative, clockwise.\n\nBut since the problem states that no three points are colinear, we don't have to worry about zero in this case.\n\nSo, for two segments AB and CD, we can compute the orientations of (A,B,C), (A,B,D), (C,D,A), (C,D,B). If (orientation(A,B,C) != orientation(A,B,D)) and (orientation(C,D,A) != orientation(C,D,B)), then the segments AB and CD intersect.\n\nSo, for each possible matching,",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two line segments connecting a spaceship to its assigned base intersect each other. This involves checking all possible permutations of assignments and verifying the non-intersection condition for each permutation.\n\n### Approach\n1. **Input Parsing**: Read the number of spaceships (R) and bases (B), followed by their respective coordinates.\n2. **Permutations Check**: Since R and B are small (up to 10), we can generate all permutations of bases and check each permutation for valid non-intersecting paths.\n3. **Intersection Check**: For each permutation, check if any two line segments (from spaceship to base) intersect using orientation checks based on cross products.\n4. **Orientation Calculation**: Use cross product to determine the orientation of three points, which helps in checking if two line segments intersect.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    inputs = []\n    i = 0\n    while i < len(data):\n        if not data[i].strip():\n            i += 1\n            continue\n        parts = data[i].split()\n        R, B = int(parts[0]), int(parts[1])\n        rebels = []\n        i += 1\n        for _ in range(R):\n            while i < len(data) and not data[i].strip():\n                i += 1\n            x, y = map(int, data[i].split())\n            rebels.append((x, y))\n            i += 1\n        bases = []\n        for _ in range(B):\n            while i < len(data) and not data[i].strip():\n                i += 1\n            x, y = map(int, data[i].split())\n            bases.append((x, y))\n            i += 1\n        inputs.append((R, B, rebels, bases))\n    return inputs\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef is_valid_matching(rebels, bases, perm):\n    for i in range(len(perm)):\n        for j in range(i + 1, len(perm)):\n            a = rebels[i]\n            b = rebels[j]\n            c = bases[perm[i]]\n            d = bases[perm[j]]\n            if segments_intersect(a, b, c, d):\n                return False\n    return True\n\ndef solve():\n    inputs = read_input()\n    for case in inputs:\n        R, B, rebels, bases = case\n        if R != B:\n            print(\"No\")\n            continue\n        found = False\n        for perm in itertools.permutations(range(B)):\n            if is_valid_matching(rebels, bases, perm):\n                found = True\n                break\n        print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into lists of coordinates for spaceships and bases.\n2. **Generating Permutations**: Using `itertools.permutations`, all possible assignments of bases to spaceships are generated.\n3. **Checking Intersections**: For each permutation, we check if any pair of line segments (spaceship to base) intersect using the orientation method based on cross products.\n4. **Output Result**: If any valid permutation is found where no segments intersect, the result is \"Yes\"; otherwise, it is \"No\".\n\nThis approach ensures that we efficiently check all possible assignments given the constraints, leveraging computational geometry to verify the non-intersection condition.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    inputs = []\n    i = 0\n    while i < len(data):\n        if not data[i].strip():\n            i += 1\n            continue\n        parts = data[i].split()\n        R, B = int(parts[0]), int(parts[1])\n        rebels = []\n        i += 1\n        for _ in range(R):\n            while i < len(data) and not data[i].strip():\n                i += 1\n            x, y = map(int, data[i].split())\n            rebels.append((x, y))\n            i += 1\n        bases = []\n        for _ in range(B):\n            while i < len(data) and not data[i].strip():\n                i += 1\n            x, y = map(int, data[i].split())\n            bases.append((x, y))\n            i += 1\n        inputs.append((R, B, rebels, bases))\n    return inputs\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef is_valid_matching(rebels, bases, perm):\n    for i in range(len(perm)):\n        for j in range(i + 1, len(perm)):\n            a = rebels[i]\n            b = rebels[j]\n            c = bases[perm[i]]\n            d = bases[perm[j]]\n            if segments_intersect(a, b, c, d):\n                return False\n    return True\n\ndef solve():\n    inputs = read_input()\n    for case in inputs:\n        R, B, rebels, bases = case\n        if R != B:\n            print(\"No\")\n            continue\n        found = False\n        for perm in itertools.permutations(range(B)):\n            if is_valid_matching(rebels, bases, perm):\n                found = True\n                break\n        print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 899,
        "thoughts_token_count": 1024
    }
}