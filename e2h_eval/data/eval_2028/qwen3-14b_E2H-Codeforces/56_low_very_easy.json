{
    "start": 1758309273.4301226,
    "end": 1758309510.5348475,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about assigning R Rebel spaceships to B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. But there's a catch: any two straight paths (from a base to its assigned spaceship) must not intersect in the 2D plane. Also, the input ensures that no two points are the same and no three points are colinear. So, the task is to determine if such a perfect matching exists.\n\nFirst, since R and B are up to 10, the numbers are small. So maybe we can check all possible perfect matchings and see if any of them satisfies the non-intersecting condition.\n\nBut how do I check if two line segments intersect? Wait, but the problem says that any two paths (i.e., line segments between a spaceship and a base) must not intersect. So for a given matching, all pairs of line segments must not cross each other.\n\nSo the approach would be:\n\n1. Generate all possible perfect matchings between the R spaceships and B bases. Since R must equal B for a perfect matching, but the input says that R and B are given. Wait, the first line says R and B. Wait, the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\". So that implies that R must equal B. But the input constraints say that R and B can be between 1 and 10. However, the problem says that it's possible to assign R spaceships to B bases as a perfect matching. So for the input, R must equal B. Wait, but the problem says that the input may have R and B not equal? Or is there a guarantee that R equals B?\n\nLooking back at the problem statement: The input says R and B. But the problem says that the assignment is a perfect matching, which requires that R equals B. Otherwise, there's no perfect matching. But the problem says that the input is such that it's possible to assign, but perhaps the code needs to check if R equals B first. Because if R != B, then the answer is automatically No.\n\nWait, the problem says that the input is given with R and B. But for a perfect matching to exist, R must equal B. So the first thing the code should check is whether R equals B. If not, output No.\n\nBut looking at the sample input:\n\nIn the first example, the input is 3 3. So R and B are equal. In the second example, input is 2 1. So R is 2, B is 1. So the answer is No because there's no perfect matching. So the code must first check if R equals B. If not, output No.\n\nSo that's the first step. So the code starts by checking if R != B, then output No.\n\nOtherwise, when R = B, we need to check all possible permutations of assignments between spaceships and bases, and see if any permutation has the property that all line segments between matched pairs don't intersect.\n\nBut how to check for line segment intersections?\n\nBut since the problem says that no three points are colinear, so any two line segments that share a common point (like if two line segments are from the same spaceship to two different bases) would not be considered as intersecting except at their endpoints. But the problem says that the paths must not intersect. So two line segments can't cross each other except at their endpoints.\n\nSo for a given matching, for every pair of line segments (each connecting a spaceship to a base), they must not cross each other. So for all pairs of line segments (s1, b1) and (s2, b2), where s1 and s2 are different spaceships, and b1 and b2 are different bases, the line segments must not cross.\n\nBut how to check if two line segments intersect?\n\nI need a function that takes two line segments and returns True if they intersect, False otherwise. But since the problem states that no three points are colinear, that might help in handling some edge cases.\n\nLet me recall the standard method for checking if two line segments AB and CD intersect.\n\nThe standard approach is to use the orientation method. The steps are:\n\n- Check if the two segments AB and CD intersect by checking if the orientations of (A, B, C), (A, B, D), (C, D, A), (C, D, B) are such that the points C and D lie on opposite sides of AB, and A and B lie on opposite sides of CD. Also, handle cases where one of the segments is collinear with the other, but since the problem states that no three points are colinear, that case can't happen here. Wait, but the problem says that no three points are colinear. So for any two line segments (s1, b1) and (s",
    "response": "To solve this problem, we need to determine if we can assign Rebel spaceships to bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base, with the constraint that no two paths (straight lines from a spaceship to its assigned base) intersect.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) equals the number of bases (B). If not, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate Permutations**: For each possible permutation of assignments between spaceships and bases, check if any of these permutations satisfy the non-intersecting paths condition.\n3. **Check Line Segment Intersections**: For each permutation, check all pairs of line segments (paths) to ensure they do not intersect. This is done using a helper function that determines if two line segments intersect by checking their orientations.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(a, c, b):\n        return True\n    if o2 == 0 and on_segment(a, d, b):\n        return True\n    if o3 == 0 and on_segment(c, a, d):\n        return True\n    if o4 == 0 and on_segment(c, b, d):\n        return True\n\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(range(B)):\n        # Check all pairs of segments\n        intersect = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                a = rebels[i]\n                b = rebels[j]\n                c = bases[perm[i]]\n                d = bases[perm[j]]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Orientation Check**: The `orientation` function helps determine the relative orientation of three points, which is crucial for checking if line segments intersect.\n3. **Segment Intersection Check**: The `segments_intersect` function uses the orientation method to determine if two line segments intersect.\n4. **Permutations Check**: We generate all permutations of base assignments for spaceships and check each permutation for intersecting paths. If any permutation is found without intersections, we print \"Yes\"; otherwise, \"No\".\n\nThis approach ensures that we efficiently check all possible assignments while leveraging geometric properties to determine valid non-intersecting paths.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(a, c, b):\n        return True\n    if o2 == 0 and on_segment(a, d, b):\n        return True\n    if o3 == 0 and on_segment(c, a, d):\n        return True\n    if o4 == 0 and on_segment(c, b, d):\n        return True\n\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(range(B)):\n        # Check all pairs of segments\n        intersect = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                a = rebels[i]\n                b = rebels[j]\n                c = bases[perm[i]]\n                d = bases[perm[j]]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 944,
        "thoughts_token_count": 1024
    }
}