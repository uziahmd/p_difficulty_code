{
    "start": 1758008332.6502357,
    "end": 1758008521.0930707,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:42 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs of vouchers that satisfy these conditions and find the minimum sum of their costs.\n\nConstraints are n up to 2e5, which is 200,000. So O(n^2) approaches are definitely out of the question. We need something more efficient.\n\nLet me think about how to approach this.\n\nFirst, for each voucher, we can compute its duration. Let's say for voucher i, duration is d_i = ri - li + 1. Then, for each voucher, we need to find another voucher j such that d_i + d_j = x, and they don't overlap.\n\nSo, for each voucher i, we can check if there exists a voucher j with duration x - d_i. Then, among those j's, find the ones that don't overlap with i, and take the minimum cost.\n\nBut how do we efficiently find those j's?\n\nLet me think about grouping vouchers by their duration. For example, create a dictionary where key is duration, and value is a list of vouchers with that duration. Then, for each voucher with duration d, we can look up in the dictionary for duration (x - d). But then, for each such voucher in that group, we need to check if they don't overlap with the current voucher.\n\nBut even that could be O(n) per voucher, leading to O(n^2) time in worst case. Which is not acceptable.\n\nAlternative idea: For each duration d, pre-process the vouchers so that for any given voucher, we can quickly find the minimum cost of a voucher with duration (x - d) that doesn't overlap with it.\n\nBut how to do that?\n\nLet's consider that for each voucher i with duration d, we need to find a voucher j with duration (x - d) that ends before li (so that j's ri < li) or starts after ri (so lj > ri). So, for each voucher i, we can look for vouchers of duration (x - d) that end before li, or start after ri.\n\nBut how to find the minimum cost among those vouchers?\n\nHmm. Let's think about the vouchers with duration (x - d). For each such voucher, we can pre-process them in a way that allows us to query the minimum cost for vouchers that end before a certain day, or start after a certain day.\n\nFor example, suppose we have all vouchers of duration k. Let's sort them by their end day (ri). Then, for a given li, we can find all vouchers in this group with ri < li. Since they are sorted, we can perform a binary search to find the largest ri that is less than li. Then, among all those vouchers up to that point, we can have the minimum cost. Similarly, for the other condition (start after ri), we can sort the vouchers by their start day (li), and find the earliest li that is greater than ri, and then find the minimum cost among those.\n\nBut how to pre-process this?\n\nFor each duration k, we can have two structures:\n\n- A sorted list of end days (ri) along with the minimum cost up to that point. So for the first part (vouchers ending before li), we can binary search the maximum end day less than li, and then get the minimum cost in that prefix.\n\nSimilarly, for the second part (vouchers starting after ri), we can have a sorted list of start days (li) and for each position, the minimum cost from that position onwards. So for a given ri, we can find the first start day that is larger than ri, and then get the minimum cost in the suffix.\n\nWait, but how to precompute these minima?\n\nFor example, for the end days sorted in ascending order, we can precompute a prefix minimum array. So for each index i in the sorted list, prefix_min[i] = min(cost of vouchers[0..i]). Then, when we find the maximum end day less than li, say at index j, then the minimum cost in the prefix up to j is prefix_min[j].\n\nSimilarly, for the start days sorted in ascending order, we can precompute a suffix minimum array. So for each index i, suffix_min[i] = min(cost of vouchers[i..n-1]). Then, when",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches the given vacation duration `x`, and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently finding pairs of vouchers that sum up to the required duration `x`.\n2. **Preprocessing for Efficient Queries**: For each duration, we maintain two sorted lists:\n   - One sorted by the end day (`ri`) with a prefix minimum cost array.\n   - Another sorted by the start day (`li`) with a suffix minimum cost array.\n3. **Binary Search for Efficient Lookup**: For each voucher, we check if there exists another voucher with the complementary duration (`x - duration`). Using binary search, we efficiently find the minimum cost of non-overlapping vouchers from the preprocessed lists.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess each duration group\n    # For each duration k, we have:\n    # - sorted_end: list of (r, cost), sorted by r\n    #   and prefix_min: min cost up to each index\n    # - sorted_start: list of (l, cost), sorted by l\n    #   and suffix_min: min cost from each index to end\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Prepare sorted_end and prefix_min\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Prepare sorted_start and suffix_min\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min[i] = min_cost\n        preprocessed[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in preprocessed:\n            continue\n        # Get the preprocessed data for target_d\n        sorted_end, prefix_min, sorted_start, suffix_min = preprocessed[target_d]\n        \n        # Case 1: voucher j ends before l1\n        # Find the largest rj <= l1 - 1\n        # Use bisect_right on sorted_end's r values\n        end_list = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(end_list, l1 - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost1)\n        \n        # Case 2: voucher j starts after r1\n        # Find the first lj >= r1 + 1\n        # Use bisect_left on sorted_start's l values\n        start_list = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(start_list, r1 + 1)\n        if pos < len(start_list):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with their start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient lookup.\n3. **Preprocessing**: For each duration, we preprocess the vouchers to create sorted lists of end days and start days, along with prefix and suffix minimum cost arrays to allow efficient minimum cost queries.\n4. **Binary Search for Non-overlapping Vouchers**: For each voucher, we check for possible complementary durations and use binary search to find the minimum cost of non-overlapping vouchers efficiently.\n5. **Result Calculation**: The minimum total cost from all valid pairs is computed and printed, or -1 if no valid pairs exist.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess each duration group\n    # For each duration k, we have:\n    # - sorted_end: list of (r, cost), sorted by r\n    #   and prefix_min: min cost up to each index\n    # - sorted_start: list of (l, cost), sorted by l\n    #   and suffix_min: min cost from each index to end\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Prepare sorted_end and prefix_min\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Prepare sorted_start and suffix_min\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min[i] = min_cost\n        preprocessed[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in preprocessed:\n            continue\n        # Get the preprocessed data for target_d\n        sorted_end, prefix_min, sorted_start, suffix_min = preprocessed[target_d]\n        \n        # Case 1: voucher j ends before l1\n        # Find the largest rj <= l1 - 1\n        # Use bisect_right on sorted_end's r values\n        end_list = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(end_list, l1 - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost1)\n        \n        # Case 2: voucher j starts after r1\n        # Find the first lj >= r1 + 1\n        # Use bisect_left on sorted_start's l values\n        start_list = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(start_list, r1 + 1)\n        if pos < len(start_list):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1121,
        "thoughts_token_count": 1023
    }
}