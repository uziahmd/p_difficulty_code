{
    "start": 1758313506.899292,
    "end": 1758313711.6386747,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:28 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let me read the problem statement carefully.\n\nSo, the problem is about Leha wanting to choose two vouchers such that their durations add up exactly to x days, and they don't overlap. And we need to find the minimal total cost of such a pair. If there's no such pair, return -1.\n\nLet me think about how to approach this.\n\nFirst, each voucher has a duration of ri - li + 1. Let's denote this as d_i for voucher i. So, for two vouchers i and j, we need d_i + d_j = x. Also, their time intervals must not overlap. That means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs (i,j) where their durations sum to x and they are non-overlapping, then find the minimum cost among those pairs.\n\nBut with n up to 2e5, checking all possible pairs would be O(n^2), which is way too slow. So we need an efficient approach.\n\nLet me think: For each voucher, if we can find another voucher that has duration (x - d_i), and is non-overlapping with it. Then, for each voucher, we can look for such vouchers in the other part of the timeline.\n\nBut how do we efficiently find the minimum cost for vouchers of duration (x - d_i) that don't overlap with the current voucher?\n\nLet me break it down. For each voucher, say voucher A with duration d, we need to find vouchers B with duration (x - d) that end before A starts, or start after A ends.\n\nSo, for each voucher, we can check for vouchers of the required duration that are before it (i.e., their ri < lA) or after it (their lB > rA). Then, among those, take the minimum cost.\n\nBut how to do this efficiently?\n\nPerhaps we can pre-process vouchers by their duration. So, we can have a dictionary that maps duration values to a sorted list of vouchers (sorted by their end time or start time?), along with their costs. Then, for a given voucher A with duration d, we can check if x - d is present in the dictionary. If so, we can look for vouchers in that duration group that end before A's start, or start after A's end.\n\nWait, but how to find the minimum cost for vouchers of duration (x - d) that are before A, or after A?\n\nFor example, let's say we have a group of vouchers with duration t = x - d. For each voucher A, we need to find the minimum cost in this group where their ri < lA (so they end before A starts), or lB > rA (they start after A ends).\n\nSo, for each such group, perhaps we can have two structures:\n\n- A sorted list of end times (ri) and for each end time, track the minimum cost up to that point. Then, for a given lA, we can find all vouchers in the group with ri < lA and find the minimum cost among them.\n\nSimilarly, for the other condition, we can have a sorted list of start times (li) and track the minimum cost from that point onwards. For a given rA, find all vouchers in the group with li > rA and find the minimum cost among them.\n\nBut how to structure this data?\n\nLet me think. For each duration t, we can have two sorted lists:\n\n- One sorted by ri (end time), and for each position in this list, we can have the minimum cost up to that index. This allows us to perform a binary search for the maximum ri that is less than lA. Then, the minimum cost in the prefix up to that index.\n\n- Another sorted by li (start time), and for each position, have the minimum cost from that index onwards. Then, for a given rA, we can find the first li that is greater than rA, and get the minimum cost from that index to the end.\n\nBut building these structures for each duration might be feasible.\n\nAlternatively, for each duration t, we can have two sorted lists:\n\n- A list of vouchers sorted by ri. For each such list, we can precompute a prefix minimum array. So, when we want to find the minimum cost among all vouchers in this list with ri < lA, we can binary search for the largest ri that is less than lA, then get the prefix minimum up to that index.\n\nSimilarly, for the other case, we can sort the vouchers in the same duration group by li. Then, for a given rA, we can binary search for the smallest li that is larger than rA. Then, we need the minimum cost in the suffix starting from that index.\n\nThis seems manageable.\n\nSo here's the plan:\n\n- Preprocess all vouchers into groups based on their duration. For each duration t, we have two sorted lists",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, while minimizing the total cost. If no such pair exists, we should return -1.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. This helps in efficiently finding pairs of vouchers that sum up to the required duration `x`.\n2. **Binary Search for Efficient Lookup**: For each voucher, check if there exists another voucher with the complementary duration (i.e., `x - duration`). Use binary search on sorted lists to quickly find the minimum cost of valid non-overlapping vouchers.\n3. **Prefix and Suffix Minimum Arrays**: For each group of vouchers with the same duration, maintain two sorted lists:\n   - One sorted by the end time (`ri`) with prefix minimum costs.\n   - Another sorted by the start time (`li`) with suffix minimum costs.\n\nThis approach ensures efficient querying and minimizes the time complexity by leveraging sorting and binary search.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Preprocess: group vouchers by their duration\n    duration_map = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, sort the vouchers by ri and create prefix min array\n    # Also sort by li and create suffix min array\n    duration_data = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by ri\n        sorted_by_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_ri:\n            min_so_far = min(min_so_far, cost)\n            prefix_min.append(min_so_far)\n        # Sort by li\n        sorted_by_li = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_li)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_li))):\n            min_so_far = min(min_so_far, sorted_by_li[i][2])\n            suffix_min[i] = min_so_far\n        duration_data[d] = (sorted_by_ri, prefix_min, sorted_by_li, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 <= 0:\n            continue\n        if d2 not in duration_data:\n            continue\n        \n        # Check vouchers with duration d2 that end before l1\n        sorted_by_ri, prefix_min, sorted_by_li, suffix_min = duration_data[d2]\n        # Find the largest ri < l1\n        left = 0\n        right = len(sorted_by_ri) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_ri[mid][1] < l1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min[best_idx]\n            min_total = min(min_total, min_total, cost1 + min_cost)\n        \n        # Check vouchers with duration d2 that start after r1\n        sorted_by_li = duration_data[d2][2]\n        suffix_min = duration_data[d2][3]\n        # Find the first li > r1\n        left = 0\n        right = len(sorted_by_li) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_li[mid][0] > r1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary. Each group is processed to create sorted lists and corresponding minimum cost arrays.\n3. **Binary Search for Valid Pairs**: For each voucher, we check for valid pairs with the complementary duration using binary search on the preprocessed sorted lists. This allows efficient lookup of the minimum cost for non-overlapping vouchers.\n4. **Result Calculation**: The minimum total cost from all valid pairs is computed and printed. If no valid pairs are found, -1 is printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Preprocess: group vouchers by their duration\n    duration_map = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, sort the vouchers by ri and create prefix min array\n    # Also sort by li and create suffix min array\n    duration_data = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by ri\n        sorted_by_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_ri:\n            min_so_far = min(min_so_far, cost)\n            prefix_min.append(min_so_far)\n        # Sort by li\n        sorted_by_li = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_li)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_li))):\n            min_so_far = min(min_so_far, sorted_by_li[i][2])\n            suffix_min[i] = min_so_far\n        duration_data[d] = (sorted_by_ri, prefix_min, sorted_by_li, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 <= 0:\n            continue\n        if d2 not in duration_data:\n            continue\n        \n        # Check vouchers with duration d2 that end before l1\n        sorted_by_ri, prefix_min, sorted_by_li, suffix_min = duration_data[d2]\n        # Find the largest ri < l1\n        left = 0\n        right = len(sorted_by_ri) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_ri[mid][1] < l1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min[best_idx]\n            min_total = min(min_total, min_total, cost1 + min_cost)\n        \n        # Check vouchers with duration d2 that start after r1\n        sorted_by_li = duration_data[d2][2]\n        suffix_min = duration_data[d2][3]\n        # Find the first li > r1\n        left = 0\n        right = len(sorted_by_li) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_li[mid][0] > r1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1167,
        "thoughts_token_count": 1024
    }
}