{
    "start": 1758308741.3109586,
    "end": 1758308963.8283145,
    "start-formatted": "2025-09-20 04:05 KST",
    "end-formatted": "2025-09-20 04:09 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine the number of mushrooms on each lawn based on the GCD and LCM values given for each road. The input gives me a graph with nodes (lawns) and edges (roads), each edge having a GCD and LCM of the two nodes it connects. My job is to assign numbers to each node such that all these conditions are satisfied, or determine it's impossible.\n\nFirst, I need to think about how to model this. Each edge between nodes u and v has a GCD of g and LCM of l. Let me recall that for two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So, if the GCD is g and LCM is l, then a*b = g*l. Also, since GCD(a,b) is g, both a and b must be multiples of g. Let me denote a = g * x and b = g * y. Then, the LCM of a and b would be g * LCM(x,y). But since LCM(a,b) is given as l, we have g * LCM(x,y) = l. Which implies that LCM(x,y) = l/g. Also, since x and y are co-prime (because any common divisor would have been included in the GCD), because when you factor out the GCD, the remaining parts must be coprime.\n\nWait, right. Because if a = g*x and b = g*y, then GCD(a,b) = g * GCD(x,y). But since the original GCD is g, then GCD(x,y) must be 1. Therefore, x and y are coprime. And the LCM of a and b is g * x * y (since LCM(a,b) = (a*b)/GCD(a,b) = (g^2 x y)/g = g x y). So, given that the LCM is l, we have g * x * y = l. Therefore, x*y = l/g. And since x and y are coprime, this means that x and y must be divisors of l/g, and their product is exactly l/g, and they are coprime. So for each edge, the two nodes connected by it must be multiples of the GCD, and their ratio (when divided by the GCD) must be coprime and multiply to l/g.\n\nBut how do I model this for the entire graph? It seems like a problem where each node's value is determined by constraints from multiple edges. This feels like a graph problem where each node's value must be consistent across all edges connected to it.\n\nSo perhaps I can model this as a graph where each edge imposes a relationship between two nodes. For example, for each edge between u and v with GCD g and LCM l, we can say that the values of u and v must be g * x and g * y, where x and y are coprime and x*y = l/g. However, since x and y are coprime, this gives us that one of them must be a divisor of l/g, and the other must be the corresponding co-divisor.\n\nBut how do I assign x and y for each edge? Because for each edge, there are two possibilities: either u is g * x and v is g * y, or vice versa. However, once we assign values to nodes, they must be consistent across all edges connected to them. For example, if node u is connected to node v via one edge and to node w via another, the value of u must satisfy both edges' constraints.\n\nThis sounds like a problem that can be modeled using a union-find structure with some constraints, but perhaps more straightforwardly, it's similar to building a graph where each node's value is determined relative to others. Maybe we can model this as a graph where each node's value is a multiple of some base value, and the relationships between nodes are multiplicative factors.\n\nAlternatively, think of the problem as building equations for each node. Let me think of the variables as the mushroom counts for each node. For each edge u-v with GCD g and LCM l, we have:\n\ngcd(a_u, a_v) = g\n\nlcm(a_u, a_v) = l\n\nWhich implies that a_u * a_v = g * l.\n\nAlso, since gcd(a_u, a_v) = g, then both a_u and a_v must be multiples of g. Let me write a_u = g * x and a_v = g * y. Then, x and y must be coprime, and x*y = (l/g).\n\nSo, for each edge, the pair (x, y) must be coprime and their product is (l/g). But since x and y are coprime, this implies that x must be a divisor of (l/g), and y must be (l/g)/x. Also, since x and y are coprime, x and (l/g)/x must be coprime, which implies that x must be a divisor of l/g and that x divides l/g, and that x and l/g/x are coprime. Which is only possible if x is a divisor of l/g and that x and l/g/x are coprime. But since x and y are coprime, this is automatically true.\n\nSo, for each edge, the product of x and y is fixed. But how do I choose x and y for each edge?\n\nThe key is that for each edge, the two nodes must be assigned values that are multiples of g, and their ratio (when divided by g) must be coprime and multiply to l/g.\n\nBut how to assign these values across the entire graph?\n\nThis seems like a problem where we can model the nodes as variables, and for each edge, we can relate the variables. However, the relations are multiplicative and involve coprimality. How can I model this?\n\nLet me think of the problem as building a graph where each node's value is determined relative to another. For example, suppose I have a connected component. If I can assign a value to one node in the component, then the rest can be determined based on the edges. But how?\n\nLet me take an example. Suppose I have an edge between u and v with GCD g and LCM l. Then, a_u and a_v must be g * x and g * y, where x * y = l/g and gcd(x, y) = 1. So, for this edge, once I fix the value of x, y is determined. However, the choice of x and y depends on the direction. For example, if I assign x to u, then y is assigned to v. But if I assign y to u, then x is assigned to v. However, since x and y are coprime, and their product is fixed, this choice might affect the rest of the graph.\n\nWait, but maybe the way to model this is to treat the variables as products of certain factors. For example, for each connected component, I can assign a base value, and then for each node, its value is the base multiplied by some product of factors from the edges. However, I'm not sure how to proceed.\n\nAnother approach: since for each edge, a_u and a_v must be multiples of g, and their ratio (when divided by g) is coprime. Let me consider that for each edge, the ratio between a_u and a_v must be x/y, where x and y are coprime and x*y = l/g. Wait, no. Because a_u = gx and a_v = gy. So, the ratio a_u/a_v = x/y. Since x and y are coprime, this ratio is in reduced form. So, for each edge, the ratio between the two nodes is x/y, where x and y are coprime and x*y = l/g. Therefore, x = (l/g)/y. So, the ratio is (l/g)/y²? No, that's not helpful.\n\nAlternatively, since x * y = (l/g), and x and y are coprime, then x must be a divisor of (l/g), and y must be (l/g)/x. So, for each edge, the pair (x, y) is determined up to swapping. Therefore, for each edge, there's a possible assignment of x and y. But how to choose which one to take so that the entire graph is consistent?\n\nThis seems like a problem that can be modeled as a graph where each node has a value, and for each edge, the values of the two nodes must satisfy certain multiplicative constraints. For example, for the edge between u and v, we have a_u = g * x and a_v = g * y. But also, for any other edges connected to u, their constraints must be satisfied.\n\nBut how can I model this? Let's think of the variables as being in a system of equations. However, since the equations are multiplicative and involve coprimality, solving them directly might be challenging.\n\nAnother idea: For each connected component of the graph, we can assign a value to one of the nodes, and then propagate the constraints through the edges. However, during propagation, we have to ensure that all constraints are met.\n\nFor example, suppose we have a connected component. Let's pick a starting node, say node u, and assign it a value. Then, for each edge connected to u, we can determine the value of the adjacent node. However, the problem is that for each edge, there are two possibilities (the x and y could be swapped). So, during the traversal, we need to make sure that the assignments are consistent.\n\nWait, but how can we choose which possibility to take? Let's think of the problem as building a graph where each edge imposes a ratio between the two nodes. For example, for each edge between u and v, the ratio a_u/a_v must be x/y, where x and y are coprime and x*y = k (where k = l/g). But since x and y are coprime, the ratio x/y is in lowest terms. However, the actual ratio can be either x/y or y/x, depending on which node is considered first.\n\nSo, for each edge, the ratio between u and v is either x/y or y/x, where x*y = k and gcd(x,y)=1. However, this ratio must be consistent with all other edges connected to u and v.\n\nThis seems similar to a problem where we have to assign values to nodes such that for each edge, the ratio between the two nodes is known. But in this case, the ratio is not fixed, but has two possibilities. However, once we choose one possibility for an edge, the rest of the graph must follow accordingly.\n\nThis sounds like a problem that can be modeled with a union-find data structure with some additional information. But I'm not sure.\n\nAlternatively, think of this as a graph where each node's value is determined relative to another. For example, if we have a tree structure, we can assign values starting from the root. For each edge in the tree, we can determine the value of the child node based on the parent's value.\n\nLet me try to formalize this. Suppose I have an edge between u and v with GCD g and LCM l. Let's compute k = l/g. Then, since a_u and a_v must be multiples of g, and their product is g*l (since a_u * a_v = GCD * LCM = g*l). Also, since a_u and a_v are multiples of g, let me write a_u = g * x and a_v = g * y. Then, x * y = (g*l) / (g^2) ) = l/g = k. Also, since GCD(a_u, a_v) = g, which is equivalent to GCD(gx, gy) = g * GCD(x, y) = g. Therefore, GCD(x, y) must be 1. So, x and y are coprime and x*y = k.\n\nTherefore, for this edge, the pair (x, y) must be two coprime integers whose product is k. Now, since x and y are coprime and their product is k, x must be a divisor of k, and y = k/x. Also, since x and y are coprime, x must be a divisor of k and x must be coprime with k/x. Which is only possible if x is a divisor of k and that x and k/x are coprime. Which implies that x must be a divisor of k and that x is square-free? Or not necessarily. For example, if k is 6, then x can be 2 and y=3. They are coprime. But if k is 4, then possible x is 1 and 4. 1 and 4 are coprime. But 2 and 2 are not coprime, so they can't be used. So for each k, the possible pairs (x, y) are those where x divides k, y = k/x, and gcd(x,y) = 1.\n\nSo, for each edge, the possible pairs (x, y) are determined. However, once we assign x and y to the nodes, this affects the rest of the graph.\n\nNow, the problem is that for each edge, there are two possibilities for the assignment of x and y. For example, if the edge is between u and v, we can assign u's value as g*x and v's as g*y, or u's as g*y and v's as g*x. Choosing one or the other will affect the rest of the assignments.\n\nThis seems like a problem that can be modeled with a graph traversal, such as BFS or DFS, where for each node, we assign a value based on the previous assignments. However, during the traversal, we need to ensure that the assignments are consistent with all edges.\n\nLet me think of an example. Suppose I have a connected component. I can start with a node, assign it some value, then for each edge, determine the value of the adjacent node. However, the problem is that the initial value may not be correct, but how do I choose it?\n\nWait, but the initial value can be arbitrary? No, because the value is determined by the constraints. For example, suppose I have a single node with no edges. Then, the number of mushrooms can be any value, but according to the problem statement, the answer must be any valid one. However, in the input, if there are zero edges, then each node's value can be any positive integer. But the problem says that the original map had numbers no less than 1 and no more than 1e6. However, the output requires that we find any valid arrangement. But for the case of zero edges, the answer is YES, and any numbers (like 1 for all nodes) would work.\n\nBut for the general case, when the graph is connected, perhaps the values are determined up to a multiple of some base. Wait, but for the connected component, the values are determined up to a certain factor. Let's think again.\n\nSuppose I have a connected component. Let me take one node, say u, and assign it a value. Then, for each edge connected to u, I can determine the value of the adjacent node. Then, for each of those adjacent nodes, their connected edges can be processed similarly. However, the problem is that the initial value of u may not be compatible with the constraints of the edges.\n\nWait, but how can that be? Because for each edge, the value of u and v are linked. For example, suppose I have an edge between u and v with GCD g and LCM l. Then, the product of a_u and a_v is g*l. If I assign a value to u, then a_v is determined as (g*l)/a_u. However, this requires that a_u divides g*l, and that the GCD of a_u and a_v is indeed g and the LCM is l. But how to ensure that?\n\nWait, but the process of assigning a_u and then computing a_v based on the edge's constraints may not work. Because even if a_u is chosen such that a_u divides g*l, the GCD and LCM may not match. So this approach may not work.\n\nAlternatively, perhaps the correct way is to model the values as multiples of the GCD of the edge. For example, for each edge between u and v, a_u = g * x, a_v = g * y, with x and y coprime and x*y = k (k = l/g). Therefore, for each edge, the product of x and y is fixed. But how to assign x and y across the graph?\n\nLet me think of the problem as building a graph where each node's value is a product of some factors. Let me consider that for each node, its value is determined by the product of the GCDs and the x/y ratios along the path from the root node.\n\nAlternatively, perhaps for each connected component, the values can be determined up to a certain multiple. For example, suppose we have a tree structure. We can assign a value to the root node, and then for each edge, determine the value of the adjacent node based on the constraints. However, the problem is that the root's value must be chosen such that all constraints are satisfied.\n\nBut how to choose the root's value? Let me think. Suppose I have a tree. Let's say I choose the root node u. Then, for each edge connected to u, I can assign the adjacent node's value based on the constraints. However, the root's value must be such that for each edge, the GCD and LCM conditions are satisfied. But how?\n\nLet me take an example. Suppose there's an edge between u and v with GCD g and LCM l. Then, the product of a_u and a_v is g*l. Suppose I choose a_u to be some value, then a_v is determined as (g*l)/a_u. However, this must also satisfy that the GCD of a_u and a_v is exactly g, and the LCM is exactly l. How can I ensure that?\n\nWell, since a_u = g * x and a_v = g * y, then x and y must be coprime and x*y = k = l/g. Therefore, if I assign a_u = g * x, then a_v = g * y = g * (k/x). So, for this to be valid, x must be a divisor of k, and y must be k/x. So, during the traversal, for each edge, when processing from a parent node to a child node, I can choose x and y accordingly.\n\nBut how do I choose which x to take? Because for each edge, there are two possibilities for x and y. For example, if the edge is between u and v, and I'm processing from u to v, then I can choose x as a divisor of k, and set a_v = g * (k/x). However, during traversal, the choice of x depends on the current state.\n\nWait, but perhaps the key is that for each connected component, once we choose the value of one node (say, the root), the rest of the values are determined uniquely. However, the root's value must be chosen such that all constraints are satisfied. But how can that be done?\n\nAlternatively, perhaps the root's value can be determined by the constraints. Let me think again. Suppose the connected component is a tree. Then, the root can be assigned a value, and the rest of the nodes' values are determined based on the edges. However, the root's value must be a multiple of the GCDs of all edges connected to it. Wait, but that's not necessarily true. Let me think.\n\nTake an example. Suppose there's a single edge between u and v with GCD 2 and LCM 6. Then, k = 6/2 = 3. So x * y = 3. Since x and y are coprime, possible pairs are (1,3) and (3,1). So, a_u can be 2*1=2 and a_v 2*3=6. Or a_u can be 6 and a_v 2. Either way, the GCD is 2 and LCM is 6. So, the root can be assigned either 2 or 6, and the other node's value is determined. But how do I choose between them?\n\nIn this case, the problem allows any valid assignment. So, during traversal, I can choose one of the possibilities. However, when the graph is more complex, choosing the wrong possibility may lead to inconsistency in other edges.\n\nSo, the approach would be:\n\n- For each connected component in the graph, perform a BFS or DFS traversal, assigning values to nodes based on the edges.\n\n- During traversal, for each edge, determine the value of the adjacent node based on the current node's value.\n\n- However, during this process, we need to check that the assigned value is compatible with all constraints.\n\nBut how to handle the choice between x and y for each edge? For example, when processing an edge between u and v, if u has already been assigned a value, then v's value is determined. But how?\n\nLet me formalize this. Suppose during traversal, I have a node u with value a_u. When I process an edge between u and v, which hasn't been processed yet. The edge has GCD g and LCM l. Then, k = l/g. The product of a_u and a_v must be g*l. Therefore, a_v = (g*l)/a_u. However, this must also satisfy that the GCD(a_u, a_v) is equal to g and the LCM is l.\n\nBut wait, if a_u and a_v are such that their product is g*l, then their GCD and LCM can be computed. However, the problem says that the given GCD and LCM are the ones that must be satisfied. Therefore, when I compute a_v as (g*l)/a_u, I must verify that the GCD(a_u, a_v) equals the given g and the LCM equals the given l. However, this seems redundant because the edge's data is supposed to be correct. But perhaps during the traversal, due to previous assignments, the computed a_v may not satisfy the constraints. So, how to avoid that?\n\nAlternatively, perhaps the way to assign a_v is by ensuring that a_u and a_v are multiples of g, and that their ratio (when divided by g) is coprime and their product is k. Let me think again. Given that a_u is already assigned, and the edge has GCD g and LCM l, then:\n\nWe have a_u must be divisible by g. Let me check that. Because the GCD of a_u and a_v is g. So, both a_u and a_v must be multiples of g. Therefore, if during the traversal, a_u is not a multiple of g, then the assignment is invalid.\n\nSo, during the traversal, when we assign a value to a node, we must ensure that all edges connected to it are compatible with the current value.\n\nBut how?\n\nLet me think of the algorithm steps:\n\n1. For each connected component in the graph:\n\n   a. Choose a starting node, assign it a value. But what value?\n\n   b. Perform BFS/DFS to assign values to all nodes in the component.\n\nBut the problem is step 1a. How to choose the starting value?\n\nAn alternative approach: For each connected component, during the traversal, we can assign the value of the starting node as g * x, where x is some divisor of k for the first edge. But this seems vague.\n\nAlternatively, perhaps the value of the starting node can be determined based on the first edge. Let's take an example. Suppose the first edge is between u and v, with GCD g and LCM l. Then, the product of their values is g*l. Let's assign u's value as g * x, and v's value as g * y, where x * y = k = l/g, and x and y are coprime. However, since the graph is connected, the rest of the nodes' values will depend on this choice. But how to choose x and y?\n\nBut perhaps, for the starting node, we can assign it a value of g * x, where x is 1. Then, the adjacent node will be assigned g * k. However, this may not work for all cases.\n\nWait, let's take the example where the first edge is between u and v, with GCD 2 and LCM 6. Then, k = 6/2 = 3. So x * y = 3. Choosing x=1, then y=3. Assigning u's value as 2 * 1 = 2, and v's as 2 * 3 = 6. This works. Alternatively, if I choose x=3, then u's value is 6 and v's is 2. Either way, the GCD is 2 and LCM is 6. So, during traversal, the choice between x and y can be arbitrary. However, for larger graphs, this choice may affect the consistency of other edges.\n\nBut how can I choose between the options? Well, during the traversal, when I process an edge, I can choose one of the two possibilities, and then proceed. However, if during traversal I encounter a contradiction (e.g., trying to assign a value to a node that conflicts with a previously assigned value), then the configuration is invalid.\n\nThis suggests that the problem can be modeled as a graph where each node's value is determined based on the edges, and during traversal, we need to assign values and check for consistency.\n\nSo, here's an outline of the algorithm:\n\nFor each connected component:\n\n   - Start with a node (say, u), and assign it a value. How?\n\n   - For the first edge connected to u, we can assign u's value as g * x, and the adjacent node's value as g * y. But how to choose x and y?\n\n   - However, the problem is that without knowing the value of u, how can we choose x and y?\n\nWait, perhaps the first edge's constraints can be used to assign u's value. For example, if the first edge is between u and v, with GCD g and LCM l. Then, the product of a_u and a_v is g*l. However, since we don't know either a_u or a_v, we need to assign them in a way that satisfies the constraints.\n\nBut since the graph is connected, perhaps the values are determined up to a multiplicative factor. For example, if I assign a_u as g * x, then a_v is determined as (g*l)/(g*x) = l/(x). But since a_v must be a multiple of g, then l/x must be a multiple of g. Which implies that x must divide l/g. Because l/g is k, which is the same as earlier.\n\nWait, this is getting complicated. Let me think again.\n\nLet me take the first edge between u and v with GCD g and LCM l. Then, for this edge, the product of a_u and a_v is g*l. Also, a_u and a_v must be multiples of g. Let me write a_u = g * x and a_v = g * y. Then x * y = k = l/g, and x and y are coprime.\n\nSo, for the first edge, the possible (x, y) pairs are coprime pairs whose product is k. But how to choose x and y?\n\nIf I can choose x as any divisor of k, then y is k/x. However, since the rest of the graph depends on this choice, perhaps I can choose x=1 and y=k, which would give a_u = g*1 = g and a_v = g*k. But then, during traversal, I can proceed with this.\n\nBut what if there are other edges connected to u? For example, if u is connected to another node w via another edge. Then, the value of u (which is g) must satisfy the constraints of that edge. However, if that edge's GCD and LCM are such that the required product is different, then this may not be possible.\n\nBut how can I know what value to assign to u in the beginning?\n\nThis seems like a dead end. Perhaps another approach is needed.\n\nAlternative Idea:\n\nLet me consider that for each node, its value must be a multiple of the GCD of every edge connected to it. Wait, no. For example, if a node is connected to multiple edges, each with different GCDs. The value of the node must be a multiple of all those GCDs. Because, for each edge connected to the node, the node's value must be a multiple of the GCD of that edge.\n\nTherefore, the value of each node must be a multiple of the LCM of all the GCDs of its incident edges. Because if the node is connected to edges with GCDs g1, g2, etc., then the node's value must be a multiple of each of these, hence the LCM of them.\n\nBut how to compute that? For example, if a node is connected to edges with GCDs 2 and 3, then the node's value must be a multiple of LCM(2,3) = 6.\n\nBut this may not be possible. For example, if a node is connected to two edges with GCDs 2 and 3, and in one edge the LCM is 6 (so the product is 2*6 = 12), and in another edge the LCM is 9 (product 3*9=27). Then, the node's value must be a multiple of 6 and 3, which is 6. But then, for the first edge, the node's value is 6, and the other node's value is 12 / 6 = 2. For the second edge, the node's value is 6, and the other node's value is 27 / 6 = 4.5, which is not an integer. Hence, this would be impossible. So, this shows that the initial assumption is that the node's value must be a multiple of the LCM of the GCDs of its edges. But in this case, the node's value is 6, which is a multiple of both 2 and 3. However, the other node's value in the second edge would not be an integer, leading to a contradiction.\n\nSo, this suggests that during the traversal, after assigning the initial value to a node, we must ensure that for all edges connected to it, the other node's value is an integer and satisfies the GCD and LCM constraints.\n\nBut how to ensure this during the traversal?\n\nPerhaps the following approach:\n\nFor each connected component:\n\n   - Select a starting node. Assign it a value that is a multiple of the LCM of all GCDs of its incident edges. But how to determine this value?\n\nAlternatively, perhaps during BFS/DFS traversal, for each edge, we can derive the value of the adjacent node based on the current node's value. But during this process, we need to check that the derived value is valid.\n\nLet me think of the following steps:\n\nInitialize all nodes with no value.\n\nFor each connected component:\n\n   - Pick a starting node u. Assign it a tentative value. But how?\n\n   - For the first edge connected to u, say between u and v with GCD g and LCM l. Then, the product of a_u and a_v is g*l. Since a_u is currently unknown, perhaps we can assign a_u to be g * x, and a_v to be g * y, where x*y = k = l/g and x and y are coprime. However, without knowing x and y, this is not helpful.\n\nBut this seems like a chicken-and-egg problem. How to choose the initial value?\n\nMaybe the key insight is that the value of a node is determined by the product of the GCDs and the LCMs along the path. However, I'm not seeing it clearly.\n\nAlternative Idea:\n\nLet me think about the problem in terms of building equations. For each edge between u and v, we have:\n\na_u = g * x\n\na_v = g * y\n\nwith x * y = k = l/g and gcd(x, y) = 1.\n\nNow, if I can express the value of each node as a product of the GCD of the edge and some factors derived from the edges.\n\nBut how to model this?\n\nLet me think of the values as follows: For each node u, let me define a value that is the product of the GCD of the edge and some factor. However, this seems too vague.\n\nAnother Idea:\n\nLet me consider that for each edge between u and v, the ratio between a_u and a_v is either x/y or y/x, where x and y are coprime and x*y = k. So, the ratio between a_u and a_v is a rational number in reduced form. This is similar to a problem where we have to assign values to nodes such that the ratio between connected nodes is fixed. This is similar to a bipartition problem, but with ratios.\n\nIn such cases, we can model the problem using a union-find data structure that tracks the ratio between nodes. However, this is more complex than standard union-find. For example, each node can have a value relative to its parent in the DSU structure.\n\nLet me try to think of this as a system of equations. For example, if I have a node u with value a, and a node v connected to u via an edge with ratio r = a_u/a_v, then a_v = a_u / r. However, since the ratio is rational, this can be represented as a fraction.\n\nBut how to manage this during traversal?\n\nPerhaps during BFS or DFS, for each node, we can store its value as a fraction relative to some base. However, since all values must be integers, this might complicate things.\n\nBut given that the problem requires the values to be integers, perhaps during traversal, the ratios must be such that the derived values are integers.\n\nLet me try to think of this as a graph where each edge imposes a ratio between two nodes. For example, for the edge between u and v, the ratio between u and v is x/y or y/x, where x and y are coprime and x*y = k. Let's call this ratio r = x/y. Then, a_v = a_u / r. But since a_v must be an integer, a_u must be divisible by r's denominator.\n\nBut this seems complex. However, during traversal, if I can represent the ratio between nodes as fractions, and ensure that all divisions result in integers, then it might work.\n\nLet me take an example. Suppose I have a single edge between u and v with GCD 2, LCM 6. Then, k = 6/2 = 3. Possible x and y are 1 and 3. The ratio between a_u and a_v can be 1/3 or 3/1. Let's say we choose a_u / a_v = 1/3. Then, a_v = 3*a_u. But since a_u must be a multiple of 2, let's say a_u = 2. Then, a_v = 6. This is valid. Alternatively, if we choose the ratio to be 3/1, then a_u = 3*a_v. If a_v is 2, then a_u is 6. Both are valid.\n\nSo during traversal, for each edge, we can choose one of the two possible ratios and proceed. However, this choice must be made in such a way that all subsequent ratios are consistent.\n\nBut how to implement this?\n\nPerhaps during BFS/DFS, when visiting a node, we can store the value of that node. For each edge, we can calculate the required value of the adjacent node based on the current node's value and the edge's constraints.\n\nFor example, let's say during traversal, I visit node u with value a_u. For each adjacent edge (u, v) with GCD g and LCM l, I compute k = l/g. Then, the product of a_u and a_v must be g*l. So, a_v = (g*l) / a_u. But since a_v must be an integer, this division must result in an integer. If it doesn't, then it's impossible.\n\nOnce a_v is computed, we must check whether the GCD of a_u and a_v is equal to g, and the LCM is equal to l. If not, then it's impossible.\n\nSo, the algorithm would be:\n\nFor each connected component:\n\n   - Initialize a queue with a starting node. Assign it an initial value. But what value?\n\n   - The initial value for the starting node can be chosen as g * x, where x is a divisor of k for the first edge. However, since we don't know the value of the starting node, this seems tricky.\n\nWait, but for the starting node, we can assign it any value that satisfies the constraints of its first edge. But how?\n\nLet me think of the first edge as connecting u and v. Let's say we choose to assign u a value of g * x, and v a value of g * y, where x*y = k and gcd(x,y)=1. But since we're starting with u, perhaps we can choose x as 1, making a_u = g, and a_v = g * k. This would work as long as k is an integer, which it is since l >= g and l/g is integer.\n\nSo, for the starting node, assign it a value of g, and the adjacent node gets g * k. Then, proceed with BFS/DFS.\n\nBut what if the starting node has multiple edges? For example, suppose the starting node u has two edges: one with GCD g1 and LCM l1, and another with GCD g2 and LCM l2. Then, the value of u must be a multiple of both g1 and g2. So, the initial assignment of u as g1 may not be sufficient. It needs to be a multiple of LCM(g1, g2).\n\nAh! This is a critical point. For the starting node, its value must be a multiple of the GCD of every edge connected to it. Because for each edge, the node's value must be a multiple of the GCD of that edge. Therefore, the value of the",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on given GCD and LCM values for roads connecting pairs of lawns. The solution involves checking if a valid configuration exists and, if so, reconstructing it.\n\n### Approach\n1. **Graph Representation**: Represent the lawns and roads as a graph where nodes represent lawns and edges represent roads with associated GCD and LCM values.\n2. **Component Analysis**: Each connected component of the graph is processed separately since constraints within a component are independent of other components.\n3. **BFS/DFS Traversal**: Use BFS or DFS to traverse the graph starting from an arbitrary node in each component. During traversal, assign values to nodes ensuring that all constraints (GCD and LCM) are satisfied.\n4. **Validation**: For each edge, validate that the assigned values meet the given GCD and LCM conditions. If any inconsistency is found during traversal, the configuration is impossible.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    result = [0] * n\n    visited = [False] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        result[start] = 1  # arbitrary initial value; will be adjusted later\n\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if visited[v]:\n                    continue\n                k = l // g\n                if k * g != l:\n                    return False\n                if result[u] == 0:\n                    # This should not happen since we start with result[start] = 1\n                    return False\n                a_u = result[u]\n                a_v = (g * l) // a_u\n                # Check if a_v is integer\n                if (g * l) % a_u != 0:\n                    return False\n                # Check gcd(a_u, a_v) == g and lcm(a_u, a_v) == l\n                current_gcd = math.gcd(a_u, a_v)\n                current_lcm = a_u * a_v // current_gcd\n                if current_gcd != g or current_lcm != l:\n                    return False\n                result[v] = a_v\n                visited[v] = True\n                queue.append(v)\n        return True\n\n    for i in range(n):\n        if not visited[i]:\n            # Need to assign initial value properly\n            # Find the first edge connected to i\n            found = False\n            for (v, g, l) in graph[i]:\n                if not found:\n                    k = l // g\n                    result[i] = g\n                    found = True\n                    break\n            if not found:\n                # isolated node, assign 1\n                result[i] = 1\n                continue\n            # Now perform BFS\n            if not bfs(i):\n                print(\"NO\")\n                return\n    # After processing all components, check all edges\n    for u, v, g, l in edges:\n        a_u = result[u]\n        a_v = result[v]\n        current_gcd = math.gcd(a_u, a_v)\n        current_lcm = a_u * a_v // current_gcd\n        if current_gcd != g or current_lcm != l:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Graph Construction**: The input is read and stored in an adjacency list representation of the graph.\n2. **BFS Traversal**: For each unvisited node, initiate a BFS to assign mushroom counts. The initial value for the starting node is set based on the first encountered edge.\n3. **Validation During Traversal**: For each edge, ensure that the product of the values of the two nodes equals the product of the given GCD and LCM. Additionally, verify that the computed GCD and LCM match the given values.\n4. **Post-Processing Check**: After assigning values to all nodes, recheck all edges to ensure all constraints are satisfied, confirming the validity of the solution.\n\nThis approach ensures that all constraints are checked systematically, and any inconsistency during traversal or post-processing results in an immediate determination of impossibility.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    result = [0] * n\n    visited = [False] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        result[start] = 1  # arbitrary initial value; will be adjusted later\n\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if visited[v]:\n                    continue\n                k = l // g\n                if k * g != l:\n                    return False\n                if result[u] == 0:\n                    # This should not happen since we start with result[start] = 1\n                    return False\n                a_u = result[u]\n                a_v = (g * l) // a_u\n                # Check if a_v is integer\n                if (g * l) % a_u != 0:\n                    return False\n                # Check gcd(a_u, a_v) == g and lcm(a_u, a_v) == l\n                current_gcd = math.gcd(a_u, a_v)\n                current_lcm = a_u * a_v // current_gcd\n                if current_gcd != g or current_lcm != l:\n                    return False\n                result[v] = a_v\n                visited[v] = True\n                queue.append(v)\n        return True\n\n    for i in range(n):\n        if not visited[i]:\n            # Need to assign initial value properly\n            # Find the first edge connected to i\n            found = False\n            for (v, g, l) in graph[i]:\n                if not found:\n                    k = l // g\n                    result[i] = g\n                    found = True\n                    break\n            if not found:\n                # isolated node, assign 1\n                result[i] = 1\n                continue\n            # Now perform BFS\n            if not bfs(i):\n                print(\"NO\")\n                return\n    # After processing all components, check all edges\n    for u, v, g, l in edges:\n        a_u = result[u]\n        a_v = result[v]\n        current_gcd = math.gcd(a_u, a_v)\n        current_lcm = a_u * a_v // current_gcd\n        if current_gcd != g or current_lcm != l:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 1077,
        "thoughts_token_count": 8192
    }
}