{
    "start": 1758309395.8433654,
    "end": 1758309444.314022,
    "start-formatted": "2025-09-20 04:16 KST",
    "end-formatted": "2025-09-20 04:17 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about restoring the number of mushrooms on each lawn based on some given GCD and LCM values on the roads. Each road connects two lawns and has the GCD and LCM of their mushroom counts. Our task is to find any valid assignment of mushroom numbers to each lawn or determine that it's impossible.\n\nFirst, let's think about the constraints. For each edge between two nodes u and v, we have that:\n\ngcd(a_u, a_v) = g (given)\nlcm(a_u, a_v) = l (given)\n\nBut there's a relationship between GCD and LCM: a * b = gcd(a,b) * lcm(a,b). So for any two numbers, their product equals the product of their GCD and LCM. Therefore, for each edge, the product of the two mushroom counts must be equal to g*l. \n\nBut also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: Let's say a_u = g * x, a_v = g * y. Then, their GCD is g * gcd(x,y), but the given GCD is g. Therefore, gcd(x,y) must be 1. And their LCM is g * lcm(x,y) which equals l. So, since the LCM of a_u and a_v is l, then g * lcm(x,y) = l. Which implies that lcm(x,y) = l/g. But since x and y are coprime, their LCM is x*y. Therefore, x * y = l/g. \n\nSo for each edge, the two numbers a_u and a_v must be multiples of g, and when divided by g, they are coprime numbers whose product is l/g. \n\nTherefore, for each edge, we can check if l is divisible by g. Because l/g must be an integer. If not, then it's impossible. For example, if the given GCD is 2 and LCM is 3, then l/g is 1.5, which isn't integer. So that's invalid. Therefore, the first check for each edge is whether l % g == 0. If any edge fails this, output NO.\n\nSo step one: For all edges, check if LCM is divisible by GCD. If not, immediately return NO.\n\nOnce that is done, for each edge, we can model the relationships between the nodes. Since each node's value is connected via these constraints, perhaps we can model this as a graph where each edge imposes certain constraints on the nodes.\n\nBut how do we assign values to the nodes? Let's think about building a graph where each node's value is determined in terms of other nodes. However, since each edge gives us a relation between two nodes, perhaps we can model this with a union-find structure or some kind of graph traversal where we assign values based on constraints.\n\nWait, but the problem is that each edge gives us two possible options for the pair (a_u, a_v). For example, if the edge between u and v has GCD g and LCM l, then a_u and a_v are g*x and g*y, with x and y coprime and x*y = l/g. So, possible pairs are (g*x, g*y) where x and y are coprime factors of l/g. However, since x and y are coprime, the possible pairs are such that one is a factor of l/g, and the other is the corresponding co-factor. For example, if l/g is 6, then possible (x,y) pairs are (1,6), (2,3), (3,2), (6,1). But since x and y are coprime, those are the only possibilities.\n\nBut how do we choose which pair to assign to each edge? This seems complicated, especially because the same node can be part of multiple edges, leading to conflicting constraints.\n\nThis suggests that the problem can be modeled as a graph where each node's value is determined relative to others. For example, if we have a connected component, we can assign a base value to one node, and then derive the others based on the edges. However, this requires that the constraints are consistent across the entire connected component.\n\nLet me think of this as a graph where each node's value is determined by a certain relation. For example, suppose we have a tree structure. We can assign a value to the root node, and then compute the others based on the edges. However, in a general graph, cycles may impose constraints that must be checked for consistency.\n\nSo here's an approach:\n\n- Treat each connected component separately.\n- For each connected component, pick a starting node and assign a value to it. Then, traverse the graph (like BFS or DFS), assigning values to adjacent nodes based on the",
    "response": "To solve the Mushroom Strife problem, we need to determine if it's possible to restore the number of mushrooms on each lawn based on given GCD and LCM values for the roads connecting them. The solution involves checking constraints and using a graph traversal approach to assign values consistently across connected components.\n\n### Approach\n1. **Check Validity of Input**: For each road, ensure that the LCM is divisible by the GCD. If not, the configuration is impossible.\n2. **Graph Traversal**: Use BFS or DFS to traverse each connected component of the graph. Assign values to nodes starting from an arbitrary node and propagate these values through the graph based on the constraints provided by the roads.\n3. **Consistency Check**: During traversal, ensure that the values assigned to nodes are consistent with the GCD and LCM constraints of the roads.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    # Check if any edge has LCM not divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    # Now try to assign values\n    visited = [False] * n\n    values = [0] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = 1  # We can choose any value as long as it satisfies constraints\n\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if not visited[v]:\n                    # Compute the product of the two numbers: a_u * a_v = g * l\n                    # Since a_u = g * x, a_v = g * y, x*y = l/g and gcd(x,y) = 1\n                    # So, a_v = (g*l) / a_u\n                    # But since a_u is known, compute a_v\n                    if values[u] == 0:\n                        # This shouldn't happen since we start with 1\n                        return False\n                    product = g * l\n                    if product % values[u] != 0:\n                        return False\n                    a_v = product // values[u]\n                    # Now check if gcd(a_u, a_v) == g and lcm(a_u, a_v) == l\n                    # But since product = a_u * a_v = g*l, and we have that gcd(a_u, a_v) is g\n                    # So we need to check that gcd(a_u, a_v) is g and lcm is l\n                    current_gcd = math.gcd(values[u], a_v)\n                    if current_gcd != g:\n                        return False\n                    current_lcm = (values[u] * a_v) // current_gcd\n                    if current_lcm != l:\n                        return False\n                    values[v] = a_v\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # Check consistency\n                    if values[u] == 0 or values[v] == 0:\n                        continue\n                    product = values[u] * values[v]\n                    if product != g * l:\n                        return False\n                    current_gcd = math.gcd(values[u], values[v])\n                    if current_gcd != g:\n                        return False\n                    current_lcm = (values[u] * values[v]) // current_gcd\n                    if current_lcm != l:\n                        return False\n        return True\n\n    for i in range(n):\n        if not visited[i]:\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initialization**: The input is read and parsed into nodes and edges. Each edge is stored in a graph structure for traversal.\n2. **Validity Check**: Before any assignment, each edge is checked to ensure the LCM is divisible by the GCD. If not, the answer is immediately \"NO\".\n3. **BFS Traversal**: For each unvisited node, a BFS is initiated. Starting with an initial value (chosen arbitrarily as 1), values are propagated through the graph ensuring consistency with the GCD and LCM constraints.\n4. **Consistency Checks**: During BFS traversal, each assignment is verified against the constraints to ensure correctness. If any inconsistency is found, the answer is \"NO\".\n\nThis approach ensures that all constraints are checked and values are propagated correctly through the graph, providing an efficient solution to the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    # Check if any edge has LCM not divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    # Now try to assign values\n    visited = [False] * n\n    values = [0] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = 1  # We can choose any value as long as it satisfies constraints\n\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if not visited[v]:\n                    # Compute the product of the two numbers: a_u * a_v = g * l\n                    # Since a_u = g * x, a_v = g * y, x*y = l/g and gcd(x,y) = 1\n                    # So, a_v = (g*l) / a_u\n                    # But since a_u is known, compute a_v\n                    if values[u] == 0:\n                        # This shouldn't happen since we start with 1\n                        return False\n                    product = g * l\n                    if product % values[u] != 0:\n                        return False\n                    a_v = product // values[u]\n                    # Now check if gcd(a_u, a_v) == g and lcm(a_u, a_v) == l\n                    # But since product = a_u * a_v = g*l, and we have that gcd(a_u, a_v) is g\n                    # So we need to check that gcd(a_u, a_v) is g and lcm is l\n                    current_gcd = math.gcd(values[u], a_v)\n                    if current_gcd != g:\n                        return False\n                    current_lcm = (values[u] * a_v) // current_gcd\n                    if current_lcm != l:\n                        return False\n                    values[v] = a_v\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # Check consistency\n                    if values[u] == 0 or values[v] == 0:\n                        continue\n                    product = values[u] * values[v]\n                    if product != g * l:\n                        return False\n                    current_gcd = math.gcd(values[u], values[v])\n                    if current_gcd != g:\n                        return False\n                    current_lcm = (values[u] * values[v]) // current_gcd\n                    if current_lcm != l:\n                        return False\n        return True\n\n    for i in range(n):\n        if not visited[i]:\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 550,
        "completion_token_count": 1126,
        "thoughts_token_count": 1024
    }
}