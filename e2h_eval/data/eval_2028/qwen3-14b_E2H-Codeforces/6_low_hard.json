{
    "start": 1758313552.1148562,
    "end": 1758313796.8523493,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about finding two vouchers that don't overlap, their durations sum up to exactly x, and their total cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand what the duration is. For a voucher i, duration is ri - li + 1. So, for each voucher, we can precompute this duration. Then, we need two vouchers where duration1 + duration2 = x, and they don't overlap. And find the minimum sum of their costs.\n\nThe constraints are n up to 2e5, which is big. So any O(n²) approach is definitely out of the question. We need an efficient way.\n\nLet me think about possible approaches.\n\nThe key points here are:\n\n- The two vouchers must not overlap. So, either the first ends before the second starts, or vice versa.\n- Their durations sum to x. So, for each voucher with duration d, we need another voucher with duration (x - d), and they must not overlap.\n\nSo, perhaps the plan is:\n\nFor each voucher, check if there exists another voucher with duration (x - d), and that they don't overlap. But how to do this efficiently?\n\nBut considering that for each voucher, we need to find the minimal cost of vouchers with duration (x - d) that don't overlap with it. However, how to handle this efficiently.\n\nAlternative idea: group vouchers by their duration. So, create a dictionary where the key is duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, check if there is a duration (x - d) in the dictionary. If yes, then look for vouchers in that group that don't overlap with the current voucher.\n\nBut even then, for each voucher, checking all vouchers in the other group might be O(n²) in worst case.\n\nBut maybe we can pre-process for each duration, the vouchers sorted by their start and end times, so that for a given voucher, we can quickly find the minimal cost voucher in the other group that doesn't overlap.\n\nFor example, suppose we have a voucher A with duration d, and we need vouchers B with duration (x - d). For B to not overlap with A, either B's end < A's start, or B's start > A's end.\n\nSo, for each voucher A, we can look into the group of vouchers with duration (x - d). For those vouchers, find the minimum cost where either they end before A's start, or start after A's end.\n\nBut how to find that quickly?\n\nLet's think for each duration, we can have two sorted lists:\n\n- Sorted by their end time (so that for a given start, we can find all vouchers ending before that start)\n- Sorted by their start time (so that for a given end, we can find all vouchers starting after that end)\n\nWait, but for each duration, we can pre-process the vouchers in that duration. For example, for duration t, we can have a list of vouchers sorted by their end time, and also a list sorted by their start time. Then, for a given voucher A with duration d, and looking for vouchers of duration (x-d), we can:\n\nCase 1: B ends before A starts. So B's end <= A's start - 1. So among all vouchers in duration (x -d), find the minimum cost where end <= (A's start - 1).\n\nCase 2: B starts after A ends. So B's start >= A's end + 1. Among all vouchers in duration (x -d), find the minimum cost where start >= (A's end + 1).\n\nSo for each of these cases, we need to find the minimum cost in those subsets.\n\nIf we can find that, then for each voucher, we can check both cases and take the minimum.\n\nBut how to do this quickly?\n\nFor case 1, if we have the vouchers in the target duration sorted by their end time, then for a given value (A's start - 1), we can perform a binary search to find all vouchers whose end is <= that value. Among those, we need the minimum cost. Similarly for case 2, if the vouchers are sorted by their start time, we can binary search for the earliest start that is >= (A's end + 1), and then find the minimum cost in that subset.\n\nBut how to pre-process for the minimum cost in these ranges?\n\nAh, for each duration group, we can have two structures:\n\n- For vouchers sorted by end time, along with a prefix minimum array. So when we find the last voucher in the sorted list with end <= target, the prefix minimum up to that index gives the minimum cost in that range.\n\nSimilarly, for vouchers sorted by start time, we can have a suffix minimum array. So when we find",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, and whose total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly finding vouchers that can potentially form the required total duration when paired with another voucher.\n2. **Preprocessing for Efficient Queries**: For each duration group, we maintain two sorted lists:\n   - One sorted by the end time of the vouchers.\n   - Another sorted by the start time of the vouchers.\n3. **Prefix and Suffix Minimum Arrays**: For each sorted list (by end time and start time), we precompute prefix and suffix minimum arrays to quickly determine the minimum cost of vouchers that meet specific criteria (e.g., ending before a certain date or starting after a certain date).\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, prepare sorted lists and min arrays\n    # For each duration d, we have:\n    # sorted_by_end: list of (end, start, cost) sorted by end\n    # sorted_by_start: list of (start, end, cost) sorted by start\n    # Also, prefix_min_end and suffix_min_start arrays\n    duration_data = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Prepare prefix min array for sorted_end\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Prepare suffix min array for sorted_start\n        suffix_min_start = [0]*len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min_start[i] = min_cost\n        duration_data[d] = (sorted_end, prefix_min_end, sorted_start, suffix_min_start)\n    \n    min_total = float('inf')\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n        # Check for vouchers with duration target_d\n        sorted_end, prefix_min_end, sorted_start, suffix_min_start = duration_data[target_d]\n        # Case 1: voucher ends before l1\n        # Find the largest end <= l1 - 1\n        # sorted_end is sorted by end (r)\n        # We can binary search for l1 - 1\n        end_list = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(end_list, l1 - 1) - 1\n        if pos >= 0:\n            min_cost_case1 = prefix_min_end[pos]\n            min_total = min(min_total, min_total, cost1 + min_cost_case1)\n        # Case 2: voucher starts after r1\n        # Find the first start >= r1 + 1\n        # sorted_start is sorted by start (l)\n        start_list = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(start_list, r1 + 1)\n        if pos < len(start_list):\n            min_cost_case2 = suffix_min_start[pos]\n            min_total = min(min_total, cost1 + min_cost_case2)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: Vouchers are grouped by their duration to efficiently find pairs that sum up to the required duration `x`.\n2. **Sorting and Preprocessing**: For each duration group, vouchers are sorted by their end and start times. Prefix and suffix minimum arrays are used to quickly find the minimum cost of vouchers meeting specific conditions (ending before a certain date or starting after a certain date).\n3. **Binary Search for Efficient Lookup**: For each voucher, we use binary search to find potential non-overlapping vouchers in the required duration group, ensuring efficient query processing.\n\nThis approach ensures that we efficiently check all possible valid pairs of vouchers while maintaining a time complexity that is feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, prepare sorted lists and min arrays\n    # For each duration d, we have:\n    # sorted_by_end: list of (end, start, cost) sorted by end\n    # sorted_by_start: list of (start, end, cost) sorted by start\n    # Also, prefix_min_end and suffix_min_start arrays\n    duration_data = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Prepare prefix min array for sorted_end\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Prepare suffix min array for sorted_start\n        suffix_min_start = [0]*len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min_start[i] = min_cost\n        duration_data[d] = (sorted_end, prefix_min_end, sorted_start, suffix_min_start)\n    \n    min_total = float('inf')\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n        # Check for vouchers with duration target_d\n        sorted_end, prefix_min_end, sorted_start, suffix_min_start = duration_data[target_d]\n        # Case 1: voucher ends before l1\n        # Find the largest end <= l1 - 1\n        # sorted_end is sorted by end (r)\n        # We can binary search for l1 - 1\n        end_list = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(end_list, l1 - 1) - 1\n        if pos >= 0:\n            min_cost_case1 = prefix_min_end[pos]\n            min_total = min(min_total, min_total, cost1 + min_cost_case1)\n        # Case 2: voucher starts after r1\n        # Find the first start >= r1 + 1\n        # sorted_start is sorted by start (l)\n        start_list = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(start_list, r1 + 1)\n        if pos < len(start_list):\n            min_cost_case2 = suffix_min_start[pos]\n            min_total = min(min_total, cost1 + min_cost_case2)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1146,
        "thoughts_token_count": 1024
    }
}