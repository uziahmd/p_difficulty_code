{
    "start": 1758308840.426303,
    "end": 1758309039.4140258,
    "start-formatted": "2025-09-20 04:07 KST",
    "end-formatted": "2025-09-20 04:10 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. Each takes turns, and each makes exactly n moves. The goal is to maximize the sum of their numbers S1 and S2. We need to find the sequence of H and M moves that gives the maximum total.\n\nHmm. The key here is that each move, the current player takes the leftmost digit. So the order in which they take the digits affects their numbers. Since the total is the sum of S1 and S2, we need to maximize that sum. But how?\n\nWait, the sum of S1 and S2 is the sum of all digits taken by both players. Wait, no. Because each digit is taken once. So the total sum would be the sum of all digits in A, right? Because each digit is added to either S1 or S2. So regardless of the order, the total sum would be fixed. Oh wait! That can't be right. Because S1 and S2 are numbers. For example, if a digit is taken earlier, it contributes more to the number's value. Like, taking a 9 first gives it a higher place value. Oh right! So the actual sum of S1 and S2 depends on the order in which digits are taken. Because the digits are added to the front of their respective numbers. So for example, if Homer takes a digit 1 first, then another 2, his number is 12. If he took 2 first then 1, it's 21. So the sum of S1 and S2 depends on the order of digits taken by each player.\n\nSo the problem is not just about choosing which digits go to whom, but also the order in which they take them. Because the order determines the place value of each digit in their numbers.\n\nBut how do we model this? Since the players take turns, the sequence of moves determines which digits are taken by whom, and in what order. For example, the first move is taken by one of the players, then the next move by the other, etc. Wait, no. The problem says that before each turn, they decide who will make the next move. So each turn, the players choose who takes the next digit. However, the problem states that each player must make exactly n moves. So the sequence of H and M must have exactly n H's and n M's.\n\nBut how do we choose the sequence to maximize the sum of S1 and S2?\n\nLet me think: the sum of S1 and S2 is equal to the sum of all digits multiplied by their respective place values. For example, the first digit taken by Homer contributes 10^{n-1} times that digit to S1. Then the next digit taken by him contributes 10^{n-2}, etc. Similarly for Marge.\n\nBut since the total sum is the sum of all digits multiplied by their place values (depending on when they were taken and by whom), the problem becomes selecting which player takes which digits and in what order to maximize this sum.\n\nBut since the digits are taken from the front of A, the order in which they are taken is determined by the sequence of moves. For example, the first move takes the first digit of A, then the second move takes the next digit, etc. So the sequence of moves determines which digits are assigned to which player, but the order in which the digits are assigned to each player depends on when they were taken.\n\nSo the problem reduces to assigning each of the 2n digits to either Homer or Marge, such that exactly n are assigned to each, and the sum of their numbers is maximized.\n\nBut how do we model this? Because the position of the digit in the sequence of moves determines its place value in the player's number.\n\nFor example, if a digit is taken as the k-th move of Homer, then it contributes digit * 10^{n - k} to his number. Similarly for Marge.\n\nWait, let's think. Suppose Homer has n moves. The first time he takes a digit, it's the first digit of his number. Then, each subsequent time he takes a digit, it's added to the front of his number. Wait, no. Wait, the problem says that on each turn, the player takes the leftmost digit of A and appends it to his number. Then that digit is erased from A. So for example, if Homer takes a digit first, that digit is the first digit of his number. Then, if he takes another digit later, that digit is appended to his number. Wait, no. Let me re-read the problem statement.\n\n\"On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A.\"\n\nOh, so for example, if Homer takes a digit first, that digit is the first digit of his number. Then, when he takes another digit (say, on his second move), he appends it to his number. So his number would be the first digit followed by the second digit. So the first digit is the most significant, and each subsequent digit is added to the end. Therefore, the order in which Homer takes digits determines the order of the digits in his number. For example, if he takes digits in the order d1, d2, d3, then his number is d1d2d3. So the place values are d1*10^{n-1} + d2*10^{n-2} + ... + dn * 10^0.\n\nSimilarly for Marge.\n\nSo the problem is to assign each of the digits to either Homer or Marge, with exactly n digits each, and the order in which they take them (i.e., the order in which the digits are taken by each) determines their place values.\n\nBut how can we model this optimally?\n\nThe key observation here is that the order of the digits in the sequence of moves determines the place values. For example, the first time a player takes a digit, it contributes the highest possible place value (like 10^{n-1} for Homer's first digit). The second time, 10^{n-2}, etc.\n\nThus, the problem reduces to selecting for each player which digits they take, and in which order (so that the higher digits are assigned to the higher place values).\n\nBut since the players take turns, the sequence of moves determines which digits are taken by whom and when.\n\nBut how can we model this? For example, the first move can be H or M. Then the next move depends on which player is chosen, etc.\n\nBut with n up to 18, the total number of moves is 36. Trying all possibilities would be O(2^36), which is way too big.\n\nSo we need a dynamic programming approach. Let's think about the state.\n\nAt any point, the state can be represented by:\n\n- How many digits have been taken by Homer (h) and Marge (m). Since each must take exactly n digits, h can range from 0 to n, m can range from 0 to n. Also, h + m = k, where k is the number of digits taken so far (from 0 to 2n).\n\nBut since the players alternate turns, perhaps the state needs to track whose turn it is next. Wait, no. The problem says that before each turn, the players decide who will make the next move. So the choice is made each time. However, the problem requires that the total number of moves for each is n. So, for example, if currently h is the number of moves Homer has made, and m is the number of moves Marge has made, then the next move can be H only if h < n, and M only if m < n.\n\nBut the choice of who takes the next move depends on which option gives a better total sum.\n\nBut how can we model the optimal choice here?\n\nThe key is to model the DP state as (h, m), representing the number of moves Homer and Marge have made so far. At each state, the next move can be H or M, provided that h < n and m < n respectively.\n\nBut the problem is that the digits taken so far affect the remaining digits. For example, the current state depends on which digits have been taken. However, since the digits are taken from the front of A, the order of taking is determined by the sequence of moves. So, the current position in the original A string is determined by the number of digits taken so far. For example, after k moves, the next digit to take is the (k+1)-th digit of A.\n\nAh! That's an important point. Because the order of taking digits is determined by the sequence of moves. The first move takes the first digit of A. The second move takes the second digit, etc. So, the digits available to take at step k is the (k+1)-th digit of A. So, the current position in the string is determined by the number of digits already taken, which is h + m. So, for a given state (h, m), the next digit to take is the (h + m + 1)th digit of A.\n\nTherefore, the DP state can be represented by (h, m), and the value stored is the maximum total sum achievable from this state onward. Then, for each state, we can consider the two options (if allowed):\n\nOption 1: Take H as the next move. This is allowed only if h < n. Then, the current digit is A[h + m] (since after h + m moves, the next is h+m+1-th digit, which is index h + m in zero-based). Then, the contribution to the total sum is digit * 10^{n - h - 1} (since this is the (h+1)th move for Homer, so the place value is 10^{n - (h+1)} ? Wait, let's think:\n\nHomer's number is built by appending digits. So, the first digit he takes is the first digit of his number. The second digit he takes is the second digit of his number, etc. So, if Homer has taken h digits so far, and now takes another (the (h+1)th), then this digit is placed in the (h+1)th position of his number. The place value for this digit is 10^{n - (h+1)} ?\n\nWait, suppose n is 2. Homer takes two digits. The first digit is the most significant (10^1), the second is 10^0. So for the first move, h was 0, and the digit contributes 10^(n - h - 1) ? Let's see:\n\nn=2, h=0. The first digit is taken, which is the first digit of Homer's number. The place value is 10^(2-0-1) = 10^1 = 10. Correct. Then, when h becomes 1, the next digit contributes 10^(2-1-1) = 10^0. Correct. So yes, the formula is correct.\n\nSimilarly for Marge. If she takes a digit when she has m digits already, then this new digit is the (m+1)th digit of her number. Its place value is 10^{n - m - 1}.\n\nSo, for each state (h, m), the next digit is A[k], where k = h + m. Then, if we choose H as the next move, the contribution is digit * 10^{n - h - 1}. Then, the new state is (h+1, m). If we choose M, the contribution is digit * 10^{n - m - 1}, and the new state is (h, m+1).\n\nSo, the DP recurrence would be:\n\ndp[h][m] = max( (current digit's value for H) + dp[h+1][m], (current digit's value for M) + dp[h][m+1] )\n\nBut since the digits are taken from the original A string, the current digit is fixed based on h and m.\n\nNow, the base case is when h = n and m = n. Then, there are no more moves, so the contribution is 0.\n\nThis seems manageable. However, the problem is that n can be up to 18, so h and m can be up to 18. The number of states is (n+1) * (n+1) = 19*19=361 for n=18, which is very manageable.\n\nBut wait, the value of the digits can be up to 9, multiplied by 10^{n - ...}, which for n=18 could be up to 9 * 10^17. However, since Python handles big integers, this is manageable. But for memoization, we need to compute these values.\n\nBut how to compute the exponents? Precompute them.\n\nYes. For each possible h and m, when considering the next move, the exponent for Homer would be (n - h - 1) if he takes the next move. Similarly for Marge.\n\nSo, for example, for each state (h, m), the current digit is A[h + m], and the next move can be H or M, depending on whether h < n or m < n.\n\nSo, the DP approach is feasible.\n\nBut how to implement it?\n\nWe can use memoization with recursion, or iterative DP.\n\nBut for Python, memoization with lru_cache may be possible. However, since n is up to 18, and the states are (h, m), which is 19*19 = 361 states, even with recursion, it's manageable.\n\nBut we also need to track the path (the sequence of H and M moves) that leads to the maximum sum. So, the DP needs to track not only the maximum sum but also the choices made.\n\nSo, the plan is:\n\n- Precompute the digits of A as a list of integers.\n\n- For each state (h, m), compute the maximum total sum possible from that state onwards.\n\n- Also, for each state, record the choice (H or M) that leads to the maximum sum.\n\nOnce the DP is filled, we can start from (0, 0) and follow the choices to build the sequence.\n\nBut how to handle the memoization and the path reconstruction.\n\nLet's think of implementing this with memoization. Let's write a recursive function that returns the maximum sum and the best choice (H or M) for each state.\n\nAlternatively, we can use memoization for the maximum sum, and then reconstruct the path by checking for each state which choice (H or M) gives the maximum value.\n\nSo, for the DP:\n\nDefine memo[h][m] as the maximum total sum achievable from state (h, m).\n\nThen, for each (h, m), we can compute memo[h][m] as follows:\n\nif h + m == 2n: return 0\n\nelse:\n\ndigit = A[h + m]\n\nif h < n and m < n:\n\n   option1 = digit * 10^{n - h - 1} + memo[h+1][m]\n\n   option2 = digit * 10^{n - m - 1} + memo[h][m+1]\n\n   memo[h][m] = max(option1, option2)\n\n   choose H if option1 >= option2 else M\n\nBut if only one of the options is possible (e.g., h == n, so next move must be M, or m == n, so next move must be H).\n\nSo, the base case is when h == n and m == n, return 0.\n\nBut how to compute the exponents? For example, for a given h and m, the current digit is A[k], where k = h + m. When we choose H, the exponent is (n - h - 1) because Homer's next move is his (h+1)th move. For example, if he has already made h moves, then the next move is his (h+1)th, and the place value is 10^{n - (h+1)}.\n\nWait, the number of digits Homer has is h. The next move adds one more, making it h+1. The place value of that digit is 10^{n - (h+1)}? Because the first digit he takes is the first digit, which is 10^{n-1} (since n is the total number of digits he takes). So for the (h+1)th digit he takes, the exponent is (n - (h+1)).\n\nYes.\n\nSo, for the current state (h, m), when taking the next digit as H, the contribution is digit * 10^{n - h - 1}.\n\nSimilarly for M, the contribution is digit * 10^{n - m - 1}.\n\nSo, precomputing the powers of 10 up to n would be useful.\n\nBut since n can be up to 18, 10^18 is manageable as a Python integer.\n\nSo, precompute a power table, pow10[i] = 10^i.\n\nBut for exponents up to n-1, since for h=0, the exponent is n - 0 - 1 = n-1.\n\nSo, for each state, when the next move is H, the exponent is (n - h - 1), and for M, (n - m - 1).\n\nNow, the problem is to compute the memo table.\n\nBut how to handle the memoization. Let's think of using memoization via a 2D array.\n\nBut for Python, perhaps using memoization with lru_cache is easier. However, since n can be up to 18, the maximum h and m are 18, so the parameters are small.\n\nSo, let's proceed with memoization.\n\nBut first, the code steps:\n\nRead n and A. For example, input is n, then a string of 2n digits.\n\nConvert A into a list of integers, say digits = [int(c) for c in A].\n\nThen, precompute pow10 up to n. For example, pow10 = [10**i for i in range(0, n)].\n\nWait, but exponents can be up to n-1. For example, when h=0, the exponent is n - 0 - 1 = n-1. So, pow10 needs to be up to n-1. So for exponents from 0 to n-1.\n\nBut for n up to 18, 10^18 is manageable.\n\nOnce that's done, implement the DP.\n\nBut how to implement the DP with memoization. Let's think recursively.\n\nWe can write a function that takes h and m, and returns the maximum sum from that state. And for each state, we can check which option (H or M) is better.\n\nBut for memoization, perhaps using lru_cache with parameters h and m.\n\nBut since in Python, for mutable parameters, it's better to use immutable ones. So, h and m are integers, so it's okay.\n\nBut the digits are fixed, so the function can refer to them.\n\nSo, code outline:\n\nimport sys\n\nfrom functools import lru_cache\n\nn = int(input())\nA = input().strip()\ndigits = [int(c) for c in A]\n\npow10 = [10**i for i in range(n)]  # pow10[k] = 10^k, for k up to n-1.\n\nBut wait, for exponents like (n - h - 1), which can be up to n-1 when h=0.\n\nBut pow10 needs to be up to (n-1). So, for example, pow10 = [10**i for i in range(n)] would have pow10[0] = 1, ..., pow10[n-1] = 10^{n-1}.\n\nBut when we need to compute 10^{exponent}, where exponent is (n - h - 1), then we can get pow10[exponent] if exponent is between 0 and n-1.\n\nWait, for example, when h is 0, exponent is n - 0 -1 = n-1. Which is the maximum exponent. So pow10 needs to be precomputed for exponents up to n-1.\n\nBut the pow10 list can be generated as follows:\n\npow10 = [1] * n\nfor i in range(1, n):\n    pow10[i] = pow10[i-1] * 10\n\nBut perhaps it's easier to compute 10 ** (exponent) on the fly. However, for n up to 18, it's manageable.\n\nBut perhaps precomputing is better.\n\nBut in the code, for each call, when the next move is H, the contribution is digit * (10 ** (n - h - 1)), and similarly for M.\n\nBut for n up to 18, 10^18 is manageable as an integer.\n\nSo, perhaps precomputing is not necessary, but we can compute it on the fly.\n\nBut in Python, exponents are easy.\n\nSo, the code can proceed.\n\nNow, the DP function:\n\n@lru_cache(maxsize=None)\ndef dp(h, m):\n    if h + m == 2 * n:\n        return 0\n    current_digit = digits[h + m]\n    # determine possible options\n    options = []\n    if h < n:\n        # choose H\n        exponent = n - h - 1\n        val = current_digit * (10 ** exponent)\n        next_val = dp(h + 1, m)\n        total = val + next_val\n        options.append( (total, 'H') )\n    if m < n:\n        # choose M\n        exponent = n - m - 1\n        val = current_digit * (10 ** exponent)\n        next_val = dp(h, m + 1)\n        total = val + next_val\n        options.append( (total, 'M') )\n    # choose the maximum option\n    # if there are two options, pick the one with higher total\n    # if only one option, pick that\n    # return the maximum value and the choice\n    # but how to track the choice? Well, the function can return the maximum value, and then during the path reconstruction, we can check which choice gives the maximum value.\n    # but for the DP function, we can return the maximum value, and then for path reconstruction, we can check which choice gives that value.\n\n    # So, for the DP function, return the maximum value. Then, during path reconstruction, for each state, check which choice (H or M) gives the maximum value.\n\nBut the problem is that the DP function returns the maximum value, but during path reconstruction, we need to know which choice (H or M) was taken at each step.\n\nSo, perhaps the DP function should return both the maximum value and the best choice (H or M) for that state.\n\nBut with memoization, that's possible. However, the @lru_cache decorator can only memoize the return value if it's a single value. So, perhaps we can split into two functions: one for the maximum value, and another for the path.\n\nAlternatively, we can first compute the memo table for the maximum values, then reconstruct the path by checking for each state which choice (H or M) gives the maximum value.\n\nSo, first compute the memo table, then reconstruct the path.\n\nLet me think. Let's proceed with the DP function returning the maximum value. Then, during path reconstruction, for each state (h, m), we check if choosing H gives a value equal to the memo value, or if choosing M does. But how to compute that?\n\nBut how can we compute the maximum value for each state?\n\nLet me think again. For each state (h, m), the maximum value is:\n\nmax_val = max( (digit * 10^{...} + dp(h+1, m)), (digit * 10^{...} + dp(h, m+1)) )\n\nSo, during the DP computation, for each state, we can compute this max_val.\n\nOnce the DP table is filled, we can reconstruct the path by starting at (0, 0) and for each state, check whether choosing H or M gives the max_val.\n\nSo, the code steps:\n\nImplement the DP function with memoization that returns the maximum value.\n\nOnce that's done, reconstruct the path by starting from (0, 0) and for each step, decide whether to choose H or M based on which option gives the maximum value.\n\nBut how to compute that?\n\nLet's code the DP function first.\n\nNow, the code:\n\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == 2 * n:\n            return 0\n        current_pos = h + m\n        current_digit = digits[current_pos]\n        options = []\n        if h < n:\n            # choose H\n            exponent = n - h - 1\n            val = current_digit * (10 ** exponent)\n            next_val = dp(h + 1, m)\n            total = val + next_val\n            options.append(total)\n        if m < n:\n            # choose M\n            exponent = n - m - 1\n            val = current_digit * (10 ** exponent)\n            next_val = dp(h, m + 1)\n            total = val + next_val\n            options.append(total)\n        # return the maximum of the options\n        return max(options)\n\n    # Now, reconstruct the path\n    res = []\n    h, m = 0, 0\n    while h + m < 2 * n:\n        current_pos = h + m\n        current_digit = digits[current_pos]\n        options = []\n        if h < n:\n            # choose H\n            exponent_h = n - h - 1\n            val_h = current_digit * (10 ** exponent_h)\n            next_val_h = dp(h + 1, m)\n            total_h = val_h + next_val_h\n            options.append( (total_h, 'H') )\n        else:\n            # can't choose H\n            options.append( (0, 'M') )\n        if m < n:\n            # choose M\n            exponent_m = n - m - 1\n            val_m = current_digit * (10 ** exponent_m)\n            next_val_m = dp(h, m + 1)\n            total_m = val_m + next_val_m\n            options.append( (total_m, 'M') )\n        else:\n            # can't choose M\n            options.append( (0, 'H') )\n        # select the option with maximum total\n        # if there are multiple, choose any (but the problem says output any)\n        max_total = max([t for t, c in options])\n        for t, c in options:\n            if t == max_total:\n                res.append(c)\n                if c == 'H':\n                    h += 1\n                else:\n                    m += 1\n                break\n\n    print(''.join(res))\n\nBut wait, in the code above, during path reconstruction, when checking options, we have to consider which options are allowed. For example, if h is already n, then the only option is M. Similarly for m.\n\nBut in the code, the options list is built by checking if h < n and m < n. However, in the code for reconstruction, the code checks if h < n and adds the H option, else adds a dummy option. Similarly for M.\n\nBut in the code, for the reconstruction part, the code may have multiple options, but the code selects the one with the maximum total. However, the code for the reconstruction uses the same dp function, which is already memoized.\n\nBut this approach may work. However, there's a problem here. Let me think: during the reconstruction phase, when evaluating the options, the code calls dp(h+1, m) and dp(h, m+1), but those are already computed during the initial DP calculation. So this is okay.\n\nBut there's a problem here. Let me think: the code for the reconstruction part is using the same dp function, which is memoized. So during the reconstruction phase, the code is recomputing the same values again. But since the dp function is memoized, it's just retrieving the stored values. So that's acceptable.\n\nBut what about the code in the reconstruction phase? Let's take an example. Suppose during the reconstruction, we have state (h, m). The code checks the possible options (H and/or M), and for each, calculates the total (val + next_val). But during the initial DP computation, the max of these options is already stored in dp(h, m). However, during reconstruction, the code is recomputing the same values. But since the dp function is memoized, it's just retrieving the stored value. So this is redundant but correct.\n\nBut perhaps there's a more efficient way. However, for the purposes of this problem, it's acceptable.\n\nNow, testing this code against the sample input.\n\nSample Input 1:\n\n2\n\n1234\n\nSample Output: HHMM\n\nLet's see.\n\nn = 2, A = '1234'.\n\ndigits = [1, 2, 3, 4].\n\nThe dp function for (0, 0) would compute the maximum between choosing H or M.\n\nLet's compute the DP manually for this case.\n\nLet's think of the possible paths.\n\nThe maximum sum is achieved by taking the largest digits as early as possible for the players. But since the sum depends on the place values, we need to assign the digits to the players in a way that higher digits are assigned to higher place values.\n\nBut perhaps the optimal strategy is for each player to take the next digit if it's better for the sum. For example, when it's their turn, they take the digit if it gives a higher contribution.\n\nBut let's see for the sample input.\n\nThe digits are [1,2,3,4]. The optimal sequence is HHMM.\n\nIn this case:\n\nH takes 1, then 2. His number is 12. M takes 3, then 4. Her number is 34. Total sum is 12 + 34 = 46.\n\nAnother option is HMHM. Let's see:\n\nH takes 1, then M takes 2, then H takes 3, then M takes 4. H's number is 13, M's is 24. Sum is 37. Less than 46.\n\nAnother option is HMMH. H takes 1, M takes 2, M takes 3, H takes 4. H's number is 14, M's is 23. Sum 37.\n\nAnother option is HHMM as in the sample. So the code should return that.\n\nNow, according to the DP approach:\n\nAt state (0,0), the current digit is 1 (position 0). The options are:\n\nChoose H: contribution is 1 * 10^(2-0-1) = 1 * 10^1 = 10. Then, next state is (1, 0).\n\nChoose M: contribution is 1 * 10^(2-0-1) = 10. Next state (0, 1).\n\nSo both options give same contribution. But the code would choose either. But the sample output is HHMM, which implies that the code chooses H first.\n\nBut in this case, the code may have to choose between H and M. How does the code decide when there's a tie?\n\nIn the code during reconstruction, when multiple options have the same total, the code appends the first one found. For example, in the code:\n\nfor t, c in options:\n    if t == max_total:\n        res.append(c)\n        ... break\n\nBut the options list is built as follows. For the initial state (0,0), options would be [(total_h, 'H'), (total_m, 'M')]. But since total_h and total_m are equal, the code would pick the first one (H), leading to 'H' being chosen. Thus, the code would generate HHMM.\n\nBut what if the code for the DP function returns the same value for both options, and during reconstruction, the code picks the first option (H), leading to the sample output.\n\nBut how does the code handle this?\n\nIn the code during the reconstruction phase, the options list is built as:\n\nif h < n: add (total_h, 'H'), else add (0, 'M')\n\nif m < n: add (total_m, 'M'), else add (0, 'H')\n\nBut in the case of (0, 0), both options are allowed, and the code would collect both (total_h, 'H') and (total_m, 'M'). Then, the code finds the max_total (which is same for both) and appends the first one in the options list. Since options are added in the order H then M, the first option is H, so the code chooses H. So the sample output is generated.\n\nSo the code works for this case.\n\nAnother sample input is:\n\nInput:\n\n2\n\n9911\n\nOutput: HMHM\n\nLet's see.\n\ndigits are [9,9,1,1].\n\nThe optimal sequence is HMHM.\n\nLet's see:\n\nH takes first digit (9), M takes second (9), H takes third (1), M takes fourth (1). So H's number is 91, M's is 91. Sum is 182.\n\nAlternative sequences:\n\nIf the sequence is HHHM, but that's invalid since n=2, so H can take only 2 times. So the sequence must have exactly 2 H and 2 M.\n\nAnother possible sequence: HHMM. H takes 9 and 9, M takes 1 and 1. H's number is 99, M's is 11. Sum is 110. Which is worse than 182.\n\nSo the code should choose HMHM.\n\nNow, during the DP process, for state (0,0), current digit is 9. Choosing H would contribute 9 * 10^(2-0-1) = 9 * 10^1 = 90. Then, next state (1,0). Choosing M would contribute 9 * 10^(2-0-1) = 90. Then next state (0,1).\n\nSo the code would choose between H and M. But which option gives higher total?\n\nLet's compute the DP for (0,0).\n\nAssuming that in the code, when both options are same, the code chooses H first.\n\nBut in reality, the total for choosing H first would be 90 + ... ?\n\nLet's compute the entire DP for this case.\n\nBut perhaps it's easier to trust the code. However, in the sample input, the code returns HMHM, which suggests that during the reconstruction phase, when there is a tie, the code may choose M first. Or maybe not. Wait, the code for the reconstruction phase appends the first option with max_total. So for the first step, the code would choose H if the options are ordered as H then M. But in the sample input, the code outputs HMHM, which implies that in some steps, the code chose M over H even when the totals were same.\n\nSo why is that?\n\nLet me think through the code's path reconstruction for the sample input 9911.\n\nn=2, digits are [9,9,1,1].\n\nLet's simulate the DP for (0,0):\n\ncurrent_pos is 0, current_digit is 9.\n\noptions are:\n\nH: val_h = 9 * 10^(2-0-1) = 9*10^1 = 90. Then next state (1,0).\n\ndp(1,0) ?\n\nLet's compute dp(1,0):\n\nh=1, m=0. current_pos is 1 (h + m = 1). current digit is 9.\n\nOptions:\n\nh is 1 < 2, so can choose H.\n\nexponent for H is 2 - 1 -1 = 0. val_h = 9 * 10^0 = 9. next state (2,0). dp(2,0) ?\n\ndp(2,0): h=2, m=0. current_pos = 2. current digit is 1.\n\nh is 2 == n=2, so cannot choose H. So must choose M.\n\nexponent for M is 2 - 0 -1 = 1. val_m = 1 * 10^1 = 10. next state (2,1).\n\ndp(2,1): h=2, m=1. current_pos = 3. current digit is 1.\n\nh is 2, m is 1 < 2. So must choose M. exponent is 2 - 1 -1 = 0. val_m = 1 * 1 = 1. next state (2,2). dp(2,2) returns 0. So total is 1 + 0 = 1. So dp(2,1) returns 1.\n\nSo back to dp(2,0): returns 10 + 1 = 11.\n\nSo dp(1,0) when choosing H: 9 + 11 = 20.\n\nAlternatively, for dp(1,0), can choose M. Let's see:\n\nm is 0 < 2. So option is M. exponent for M is 2 - 0 -1 = 1. val_m = 9 * 10^1 = 90. next state (1,1).\n\ndp(1,1): current_pos is 2 (h + m = 2). current digit is 1.\n\nh is 1 < 2, m is 1 < 2. options are H and M.\n\nFor",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The key insight is to use dynamic programming (DP) with memoization to efficiently explore all possible sequences of moves while keeping track of the maximum total prize.\n\n### Approach\n1. **Dynamic Programming with Memoization**: We use a DP approach where each state is defined by the number of moves Homer (h) and Marge (m) have made so far. The goal is to maximize the total prize from the current state onwards.\n2. **Digit Contribution Calculation**: For each move, the contribution of the digit to the total prize depends on its position in the respective player's number. This contribution is calculated using powers of 10 based on the number of moves each player has already made.\n3. **Path Reconstruction**: After computing the DP table, we reconstruct the optimal sequence of moves by checking which choice (Homer or Marge taking the next move) leads to the maximum total prize.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == 2 * n:\n            return 0\n        current_pos = h + m\n        current_digit = digits[current_pos]\n        options = []\n        if h < n:\n            exponent = n - h - 1\n            val = current_digit * (10 ** exponent)\n            next_val = dp(h + 1, m)\n            options.append(val + next_val)\n        if m < n:\n            exponent = n - m - 1\n            val = current_digit * (10 ** exponent)\n            next_val = dp(h, m + 1)\n            options.append(val + next_val)\n        return max(options)\n\n    res = []\n    h, m = 0, 0\n    while h + m < 2 * n:\n        current_pos = h + m\n        current_digit = digits[current_pos]\n        options = []\n        if h < n:\n            exponent_h = n - h - 1\n            val_h = current_digit * (10 ** exponent_h)\n            next_val_h = dp(h + 1, m)\n            total_h = val_h + next_val_h\n            options.append((total_h, 'H'))\n        else:\n            options.append((0, 'M'))\n        if m < n:\n            exponent_m = n - m - 1\n            val_m = current_digit * (10 ** exponent_m)\n            next_val_m = dp(h, m + 1)\n            total_m = val_m + next_val_m\n            options.append((total_m, 'M'))\n        else:\n            options.append((0, 'H'))\n        max_total = max([t for t, c in options])\n        for t, c in options:\n            if t == max_total:\n                res.append(c)\n                if c == 'H':\n                    h += 1\n                else:\n                    m += 1\n                break\n\n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Dynamic Programming Function (dp)**: This function computes the maximum total prize starting from the state where Homer has made `h` moves and Marge has made `m` moves. It uses memoization to avoid redundant calculations.\n3. **Path Reconstruction**: After computing the DP table, we reconstruct the optimal sequence by checking at each step whether Homer or Marge should take the next move based on which choice leads to the maximum total prize.\n\nThis approach ensures that we efficiently explore all possible move sequences while maximizing the total prize, leveraging dynamic programming to handle the constraints effectively.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == 2 * n:\n            return 0\n        current_pos = h + m\n        current_digit = digits[current_pos]\n        options = []\n        if h < n:\n            exponent = n - h - 1\n            val = current_digit * (10 ** exponent)\n            next_val = dp(h + 1, m)\n            options.append(val + next_val)\n        if m < n:\n            exponent = n - m - 1\n            val = current_digit * (10 ** exponent)\n            next_val = dp(h, m + 1)\n            options.append(val + next_val)\n        return max(options)\n\n    res = []\n    h, m = 0, 0\n    while h + m < 2 * n:\n        current_pos = h + m\n        current_digit = digits[current_pos]\n        options = []\n        if h < n:\n            exponent_h = n - h - 1\n            val_h = current_digit * (10 ** exponent_h)\n            next_val_h = dp(h + 1, m)\n            total_h = val_h + next_val_h\n            options.append((total_h, 'H'))\n        else:\n            options.append((0, 'M'))\n        if m < n:\n            exponent_m = n - m - 1\n            val_m = current_digit * (10 ** exponent_m)\n            next_val_m = dp(h, m + 1)\n            total_m = val_m + next_val_m\n            options.append((total_m, 'M'))\n        else:\n            options.append((0, 'H'))\n        max_total = max([t for t, c in options])\n        for t, c in options:\n            if t == max_total:\n                res.append(c)\n                if c == 'H':\n                    h += 1\n                else:\n                    m += 1\n                break\n\n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 425,
        "completion_token_count": 848,
        "thoughts_token_count": 8192
    }
}