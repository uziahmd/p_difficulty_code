{
    "start": 1758314989.0534053,
    "end": 1758315379.1456392,
    "start-formatted": "2025-09-20 05:49 KST",
    "end-formatted": "2025-09-20 05:56 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, Polycarp has n problems, each with a difficulty. He wants to practice for exactly k days. Each day he must solve at least one problem, and he solves them in order. So the way to split is into k contiguous segments, each starting from the previous end. For each day, the profit is the maximum difficulty of that day's problems. The total profit is the sum of all these maxima. Our goal is to maximize this total profit.\n\nThe input is n and k, followed by the list of a_i's. Output the maximum total profit and the distribution of the number of problems per day.\n\nHmm. How do I approach this?\n\nFirst, I think this is a dynamic programming problem. Because for each position and number of days, we need to track the maximum profit.\n\nLet me think about the DP state. Let's say dp[i][j] represents the maximum total profit when considering the first i problems divided into j days. Then, the answer would be dp[n][k].\n\nBut how to compute this? For each dp[i][j], we need to consider all possible splits where the j-th day takes some number of problems. For example, for dp[i][j], we can look back to m < i, and take dp[m][j-1] + max(a[m+1..i]). But since n can be up to 2000 and k up to 2000, this would be O(n^2 * k) time. For n=2000, that's 2000^3 = 8e10 operations, which is way too slow.\n\nWait, but maybe there's a way to optimize this. Let's think about the constraints. For n=2000 and k=2000, the worst case is O(n^2 *k) which is 8e10. That's definitely not feasible. So we need a better approach.\n\nAlternatively, perhaps there's a way to precompute the max values between ranges. Let's think about that. For any interval [l, r], the maximum can be found quickly. If we precompute a 2D array max_range[l][r], which stores the maximum value from a[l] to a[r], then for any split, we can get the max in O(1) time.\n\nBut even with that, the DP approach would still be O(n^2 *k) time. Which for n=2000 is 2000^2 * 2000 = 8e10 operations. Not feasible.\n\nWait, but maybe k is not that big. Wait, n can be up to 2000, and k up to 2000. So in worst case, it's O(k * n^2). Which is way too big. So this approach is not going to work for n=2000.\n\nAlternative idea: Maybe the problem can be optimized with certain observations. For example, when splitting into k days, each day must have at least one problem. So for the DP approach, when considering dp[i][j], the j-th day can take from 1 to (i - (j-1)) problems. Because each of the previous j-1 days must take at least one problem each. So for the j-th day, the last day can take from 1 to (i - (j-1)) problems.\n\nBut again, even with that, the DP is O(n^2 *k) time. Which for n=2000 and k=2000 is impossible.\n\nWait, but maybe the constraints are such that n is up to 2000 and k is up to 2000, but perhaps the actual time can be optimized. Let's think about the maximum possible n and k. Let me check the problem statement again. Oh, the problem says that n and k can be up to 2000. So with O(n^2 *k) being 2000^3 = 8e10 operations, that's way beyond what can be handled in Python in reasonable time. So this approach is not feasible.\n\nSo I need a smarter approach.\n\nWait, perhaps the problem can be transformed into something else. For example, when you split the array into k parts, each part contributes its maximum. To maximize the sum, perhaps we need to select k-1 positions to split the array, such that the sum of the maximums of each segment is maximized.\n\nBut how?\n\nAnother thought: Since each day's segment is a prefix of the remaining array. Wait, no, because the split is contiguous. For example, the first day takes some number of problems, then the second day starts where the first ended, etc. So the splits are like partitions into consecutive segments.\n\nSo the problem reduces to partitioning the array into k consecutive segments, each non-empty, such that the sum of the maxima of each segment is as large as possible.\n\nNow, how to find this partition?\n\nAnother observation: For the maximum sum, we want to have as many high-value elements as possible as the maxima of their segments. For example, if there's a very large element, it's better to have it as the maximum of its own segment. However, since we need exactly k segments, perhaps the optimal strategy is to split the array such that the largest elements are each in their own segment, but that depends on the number of segments.\n\nBut how to model this.\n\nAlternatively, think of the problem as selecting k-1 split points. For example, if we have to split the array into k parts, then we need to choose k-1 split points. The first split is after some index, then the next after another, etc.\n\nBut again, the problem is how to compute this efficiently.\n\nLet me think again about the DP approach, but perhaps find a way to optimize it.\n\nLet me try to formalize the DP recurrence:\n\ndp[i][j] = max over m from j-1 to i-1 of (dp[m][j-1] + max(a[m+1 ... i]))\n\nHere, for the first i elements split into j days, the last day can start at m+1 and end at i, where m ranges from j-1 (since each of the first j-1 days must have at least one problem each) to i-1 (so that the last day has at least one problem).\n\nSo for each dp[i][j], we need to check all possible m and compute the max of a[m+1 ... i]. But computing this max for every possible m and i would be O(n^3) time. However, perhaps we can precompute the max for ranges.\n\nYes, using a precomputed 2D array of range maximums. Let's create a 2D array max_range where max_range[l][r] is the maximum of a[l..r] (assuming 1-based or 0-based indices). Then, for any m and i, the max from m+1 to i is max_range[m+1][i].\n\nSo the DP recurrence is:\n\ndp[i][j] = max{ dp[m][j-1] + max_range[m+1][i] }, for m from j-1 to i-1.\n\nNow, the question is, how to compute this efficiently.\n\nBut even with that, for each i and j, we have to loop through m from j-1 to i-1, which is O(n) per i and j. So for all i and j, it's O(n^2 *k) time. Which for n=2000 and k=2000 is 8e10 operations. That's way too slow.\n\nBut perhaps in practice, for the given constraints, there's a way to optimize this. Wait, but n is 2000 and k is 2000. So for example, if k is equal to n, then each day has exactly one problem. The total profit is sum of all a_i. So for that case, the answer is straightforward.\n\nBut in general, for k up to 2000, this approach is not feasible.\n\nAlternative idea: Let's think about the constraints. Since k can be up to n, but for the DP approach, perhaps we can find that for some j, the number of possible i's is limited. Or maybe find a way to compute the max_range[m+1][i] more efficiently.\n\nAnother observation: For a fixed i and j, when considering m from j-1 to i-1, the max_range[m+1][i] can be computed incrementally. For example, when moving m from i-1 down to j-1, the max_range[m+1][i] is the max of a[m+1 ... i]. As m decreases, the range increases to the left. So for each i, we can compute the max_range[m+1][i] as we move m from i-1 down to j-1.\n\nBut how does that help? Well, perhaps for each i and j, we can compute the max_range[m+1][i] while iterating m. Let's see.\n\nFor example, for a fixed i and j, when m ranges from j-1 to i-1, the m+1 ranges from j to i. So for the current i, when considering m from i-1 down to j-1, the range [m+1, i] starts at i (when m=i-1) and expands leftward as m decreases. So for each step, the max can be tracked by keeping track of the current maximum.\n\nSo for each i and j, when we iterate m from i-1 down to j-1, we can keep track of the current max. For example, starting with m = i-1, the range is [i], so the max is a[i]. Then for m = i-2, the range is [i-1, i], so the max is max(a[i-1], current_max). And so on. This way, for each i and j, we can compute the max_range[m+1][i] in O(1) per step, leading to O(n) per i and j.\n\nThis would reduce the time complexity from O(n^3) to O(n^2 *k), which is still O(2000^3) = 8e10 operations. Which is way too slow for Python, which can handle roughly 1e8 operations per second. So 8e10 would take 800 seconds, which is way beyond the time limit.\n\nHmm. So this suggests that the DP approach is not feasible for the given constraints. Therefore, there must be a smarter approach.\n\nAlternative idea: Since the problem requires splitting into exactly k days, and each day's segment is a prefix of the remaining array. Wait, but the splits are contiguous. So the problem is similar to the problem of splitting the array into k segments, each contributing their maximum, and we need to maximize the sum.\n\nAnother thought: Let's think of the problem as choosing k-1 split points. For example, the first split is after some position, the second after another, etc. But how to choose these points to maximize the sum of the maxima.\n\nBut how to model this. Let's think of the problem as follows: the maximum sum is achieved by ensuring that the largest elements are each the maximum of their own segment. However, since we have to split into k segments, perhaps the optimal way is to take the top k-1 largest elements and assign them to their own segments. But this is probably not correct, since the positions of the elements matter.\n\nFor example, suppose the array is [5, 4, 2, 6, 5, 1, 9, 2], and k=3. The top three elements are 9, 6, 5. But in the example given, the maximum sum is 5 + 6 + 9 = 20. Which includes 5 as the first segment's max. But there's a 5 in the array. But perhaps the idea is that the largest element must be in its own segment, and then the next largest elements are in their own segments, but this depends on the number of splits allowed.\n\nBut how to formalize this.\n\nAlternatively, think about the problem as follows: The maximum sum is the sum of the maximums of the k segments. Since each segment must contain at least one element, the maximum possible sum is the sum of the k largest elements in the array, but only if they can be placed in separate segments. However, this is only possible if the k largest elements are in different segments, which may not be possible if they are adjacent.\n\nBut this line of thinking might not directly help in finding an algorithm.\n\nAnother idea: For a given array, the maximum sum is achieved by making sure that each of the k segments contains the highest possible maximums. Since each segment's maximum is added once, we want as many high values as possible to be the maxima of their segments.\n\nBut how to arrange that.\n\nAlternatively, think of the problem as follows: For each possible split into k segments, the sum is the sum of the maxima. We need to find the split that gives the maximum sum.\n\nBut how to compute this efficiently.\n\nLet me think again about the DP approach. Suppose that n is up to 2000 and k is up to 2000. Let's think of the worst case where k is 2000. Then, for each i and j, the DP[i][j] would be for j=1 to k. But when j is 2000, then i must be 2000, and j=2000 implies that each day has exactly one problem. So the DP for j=2000 is easy.\n\nBut for other values of j, perhaps there's a way to optimize the DP transitions.\n\nAnother observation: For the DP[i][j], when j is small, say j=1, then the entire array is one segment. The sum is the maximum of the entire array.\n\nFor j=2, the problem is to split the array into two segments, the first part up to m, and the second part from m+1 to end. The sum is max(1st part) + max(2nd part). We need to find m that maximizes this sum.\n\nBut how to find this m efficiently.\n\nFor j=2, the optimal split is to find m where the sum of the max of [1..m] and [m+1..n] is maximized. How can we compute this?\n\nWell, for each m from 1 to n-1, compute max of first m elements and max of the rest. The maximum of all those possibilities is the answer.\n\nBut for j=2, this is O(n) time. However, for general j, this approach isn't directly applicable.\n\nBut perhaps for each j, the DP can be optimized with certain techniques.\n\nAlternatively, think of the problem as follows: the maximum sum for splitting into k segments is equal to the maximum sum for splitting into k-1 segments plus the maximum of the remaining segment. But this seems vague.\n\nWait, another idea: For each position i and for each j, the DP[i][j] can be computed using the previous DP[i][j-1] and some information. But I'm not sure.\n\nAlternatively, think of the problem as a variation of the classic \"optimal partitioning\" problem, where you want to split the array into k parts to maximize some function. In those cases, sometimes the DP approach is the best possible, but with optimizations.\n\nLet me try to proceed with the DP approach, but see if there are any optimizations possible.\n\nFirst, precompute the range maximums. Let's create a 2D array max_range where max_range[i][j] represents the maximum value in the subarray from index i to j (assuming 0-based or 1-based indices). How to compute this?\n\nWe can precompute it with O(n^2) time and space. For each i, we can iterate j from i to n-1, and keep track of the current maximum. For example:\n\nfor i in range(n):\n    current_max = a[i]\n    max_range[i][i] = current_max\n    for j in range(i+1, n):\n        current_max = max(current_max, a[j])\n        max_range[i][j] = current_max\n\nYes, that's O(n^2) time and space, which is acceptable for n=2000 (about 4 million operations).\n\nOnce that's done, the DP can be computed.\n\nNow, let's think about the DP. The initial state is dp[i][1] = max_range[0][i-1], since for the first i elements (assuming 1-based for the problem's i?), split into 1 day, the profit is the max of the entire array.\n\nWait, let me clarify the indices. Let's assume that the array is 0-based. For the first i elements (i.e., elements 0..i-1), split into j days. So, the DP[i][j] represents the maximum profit for the first i elements split into j days.\n\nThen, for the base case, dp[i][1] = max_range[0][i-1].\n\nFor the general case, dp[i][j] = max for m in [j-1 ... i-1] of dp[m][j-1] + max_range[m][i-1]\n\nWait, because if the first m elements are split into j-1 days, then the j-th day is from m to i-1 (since the first m elements are split into j-1 days, and then the j-th day is the elements from m to i-1, which is length i - m elements. So the max_range[m][i-1] is the maximum of that segment.\n\nSo the recurrence is:\n\ndp[i][j] = max( dp[m][j-1] + max_range[m][i-1] ), for m ranging from j-1 to i-1.\n\nBecause the first j-1 days must cover m elements (each day at least one, so m >= j-1), and the j-th day covers i - m elements (so i - m >= 1 => m <= i -1).\n\nSo for each i and j, we have to consider m from j-1 to i-1.\n\nNow, for the DP table, the dimensions are (n+1) x (k+1). Because i ranges from 1 to n (number of elements considered), and j ranges from 1 to k (number of days).\n\nNow, with the precomputed max_range, the DP can be filled in.\n\nBut the problem is the time complexity. For n=2000 and k=2000, the time complexity is O(n^2 *k) = 2000^3 = 8e10 operations. That's way too slow for Python. However, maybe the constraints are not that tight. For example, if k is small, say up to 100, then it's manageable. But for k=2000, it's impossible.\n\nBut the problem says that n and k can be up to 2000. So we need a better idea.\n\nAlternative idea: For each j, the number of days, we can compute the DP[i][j] based on previous values. Perhaps there's a way to find that for each i and j, the optimal m is in a certain range, allowing us to use some optimization techniques like convex hull trick or divide and conquer. But I'm not sure.\n\nAlternatively, think about the following: when j increases, the number of days increases. For example, when j is larger, the splits are more fragmented. But I don't know how to exploit this.\n\nAnother thought: Since the array is processed in order, and each segment is a prefix, perhaps there's a way to find for each j and i, the optimal m to split.\n\nBut I'm stuck here.\n\nLet me think about the sample input. For example, the third example input is:\n\n4 2\n\n1 2000 2000 2\n\nThe output is 4000, with splits [2,2].\n\nThe maxima are 2000 and 2000. So the sum is 4000.\n\nIf we split into [1, 2000, 2000, 2], then the maxima would be 2000 (for the first day) and 2 (for the second day), which is worse. So splitting the two 2000s into separate segments gives higher sum.\n\nSo the optimal is to split between the two 2000s. But how to find that.\n\nIn this case, the DP approach would compute for i=4, j=2. The possible m ranges from 1 to 3 (since j-1 =1, i-1=3). For each m:\n\nm=1: dp[1][1] + max_range[1][3] → dp[1][1] is max of [1], which is 1. The max_range[1][3] is max(2000, 2000, 2) = 2000. Sum is 1 + 2000 = 2001.\n\nm=2: dp[2][1] + max_range[2][3]. dp[2][1] is max of first two elements (max(1,2000)=2000). max_range[2][3] is max(2000, 2) = 2000. Sum 2000 + 2000 = 4000.\n\nm=3: dp[3][1] + max_range[3][3]. dp[3][1] is max of first three elements (2000). max_range[3][3] is 2. Sum is 2000 + 2 = 2002.\n\nSo the maximum is 4000, which is correct.\n\nSo the DP approach works here.\n\nBut again, the problem is the time.\n\nAlternative idea: Let's think about the fact that when j is large, say j is close to n, then the number of splits required is high, and the maximum sum would be the sum of the individual elements. For example, when j = n, the sum is sum(a). But for j = k, which could be up to 2000, perhaps the DP approach can be optimized for certain j ranges.\n\nBut I'm not seeing it.\n\nAnother thought: Let's consider that for each j, the DP[i][j] can be computed with O(n) time per j. But that's not possible unless there's a way to find the optimal m quickly.\n\nWait, perhaps for each j, the DP[i][j] can be computed using the previous j-1 values. Let's think about for j=2. For each i, we need to find m from 1 to i-1, and compute dp[m][1] + max_range[m][i-1]. How to compute this efficiently.\n\nBut for j=2, for each i, the m ranges from 1 to i-1. For each such m, the term is dp[m][1] + max_range[m][i-1]. How can we find the maximum of this expression for m in 1..i-1?\n\nBut for a fixed i, as m increases, the max_range[m][i-1] is the maximum of a[m] to a[i-1]. Which is non-decreasing as m decreases. Wait, no. For example, if m decreases, the range becomes larger. So the maximum can increase or stay the same. So for a fixed i, the max_range[m][i-1] is non-decreasing as m decreases (since adding elements to the left of the range can only increase or keep the same maximum).\n\nBut how does this help?\n\nLet me think: For a fixed i, and varying m, the term dp[m][1] + max_range[m][i-1]. Suppose that for m1 < m2, we have that max_range[m1][i-1] ≥ max_range[m2][i-1]. So for each i, the max_range[m][i-1] increases as m decreases. But dp[m][1] is the max of the first m elements. Which increases as m increases. So the combination of these two terms may not have a clear trend.\n\nBut perhaps for each i and j, the optimal m is somewhere in the range. However, without knowing the structure of the function, it's hard to find a way to optimize.\n\nAlternative Idea: Let's think about the problem for k=2. How to compute it efficiently. For each i, the maximum of dp[m][1] + max_range[m][i-1] for m from 1 to i-1. For j=2, the DP[i][2] = max over m of (max(0..m-1) + max(m..i-1)).\n\nBut how to compute this for all i?\n\nIf we precompute the prefix maxima, then for any m, the max(0..m-1) is known. And the max(m..i-1) can be precomputed as the range maxima. So for each i, we can compute for all m from 1 to i-1.\n\nBut again, for j=2, this is O(n^2) time. Which is acceptable for small j, but not for large k.\n\nBut perhaps for general j, there is a way to find that for each i and j, the optimal m is in a certain range, and thus we can find it quickly. For example, for j=3, maybe the optimal m is somewhere near the optimal for j=2.\n\nBut I'm not sure.\n\nAnother Idea: Let's consider that for each j, the DP[i][j] can be computed in O(n) time. How?\n\nSuppose that for each j, we can find for each i the optimal m in O(1) time. But how?\n\nThis seems unlikely, but perhaps there is a way to use some properties of the problem.\n\nWait, the problem resembles the problem of finding the optimal partition for a certain cost function. In some cases, like when the cost function satisfies the quadrangle inequality, we can use certain optimizations. But I'm not familiar enough with those to apply them here.\n\nAnother Idea: Let's think about the case where k is small. For example, if k is up to 100, then O(n^2 *k) is 2000^2 * 100 = 4e8 operations, which is manageable in C++ but might be tight in Python. However, for k up to 2000, it's 8e10 operations, which is impossible.\n\nBut given the problem's constraints, perhaps the intended solution is the DP approach, and the test cases are designed to allow it. Maybe there's a way to optimize the code to make it run within the time limits.\n\nLet me think about the possible optimizations.\n\nFirst, the precomputation of the range maximums can be done with O(n^2) time and space. For n=2000, that's 4 million entries. Which is manageable.\n\nThen, for the DP, we can use a 2D array. But for Python, even with 2000x2000 = 4 million entries, it's manageable.\n\nBut for each entry, we need to perform O(n) operations. So for n=2000 and k=2000, it's 4 million * 2000 = 8e9 operations. Which is way too much.\n\nBut wait, what is the maximum value of k? It is n. So for k=n, the DP[i][j] for j=i is the sum of the first i elements, since each day has one problem. But for j=1, it's the max of the first i elements. For j=2, it's the max of the first m elements plus the max of the remaining elements. But for j=2000, the code would take O(n^2 *k) time, which is not feasible.\n\nBut maybe the actual constraints are not that bad. For example, if n is 2000, and k is up to 2000, but in practice, the code is written in a way that is optimized, perhaps with precomputing the range maxima and using fast loops.\n\nAlternatively, perhaps the problem is designed to have the DP approach with O(n^2 *k) time, but with some optimizations.\n\nLet me think about the sample code. Let me try to write the code and see if it can be optimized.\n\nLet me outline the steps:\n\n1. Read n, k, and the array a.\n\n2. Precompute the range maximums.\n\n3. Initialize the DP table.\n\n4. Fill the DP table using the recurrence.\n\n5. Once the DP is filled, backtrack to find the split points.\n\nBut for Python, even with n=2000, and k=2000, the code would be too slow. So perhaps there's an alternative approach.\n\nWait, what if k is larger than the number of elements in the array? No, the problem says that 1 ≤ k ≤ n.\n\nAnother Idea: Notice that the maximum possible sum is when each segment contains exactly one element. But this is only possible when k = n. So for k < n, we have to merge some segments. But merging segments will replace the sum of their individual maxima with the maximum of the merged segment. So if the merged segment's maximum is greater than the sum of the individual maxima, it's better to merge. Otherwise, it's better to keep them separate.\n\nBut this seems complicated.\n\nAlternatively, think of the problem as follows: the optimal solution will have the largest k elements as the maxima of their respective segments. But how to arrange that.\n\nFor example, suppose we have the array sorted in descending order. The best way is to split into k segments, each containing one of the top k elements. But this is only possible if the elements are not overlapping.\n\nBut how to find which elements to select.\n\nThis seems like a greedy approach, but it's not obvious how to implement it.\n\nAlternatively, think of the problem as follows: the maximum sum is the sum of the maximum of each segment. To maximize this sum, we should have as many large elements as possible as the maxima of their segments. So, for example, the largest element must be the maximum of its segment. Since it's the largest, it's best to have it in its own segment. Then, the second largest element should be in its own segment, unless it is already in the same segment as the largest element.\n\nBut how to ensure this.\n\nBut how to determine the splits. This seems like a greedy approach, but I'm not sure.\n\nFor example, in the third sample input, the array is [1, 2000, 2000, 2]. The top two elements are 2000 and 2000. Splitting them into separate segments gives the maximum sum. So the greedy approach would work here.\n\nAnother example: if the array is [5, 4, 2, 6, 5, 1, 9, 2], and k=3. The top three elements are 9, 6, 5. But the optimal split is [5,4,2], [6,5], [1,9,2], which gives maxima 5, 6, 9. So the largest three elements are used as maxima.\n\nSo this suggests that the optimal solution is to select the k largest elements and make each of them the maximum of their own segment. But how to do this when there are multiple elements with the same value.\n\nBut how to ensure that the splits are possible. For example, if the largest element is in the middle of the array, then the segments must be arranged around it.\n\nThis seems like a possible approach. Let's think about the following steps:\n\n1. Select the k largest elements in the array. Let's call them the \"key elements\".\n\n2. Split the array into segments such that each key element is in its own segment. This would give a sum equal to the sum of the key elements.\n\nBut how to find these segments.\n\nBut how to handle overlapping key elements. For example, if two key elements are adjacent, we can split between them. But if they are not adjacent, we need to include other elements in the segments.\n\nBut how to ensure that the splits are made in such a way that each key element is the maximum of its segment.\n\nBut this seems possible. For example, the largest element must be in its own segment. Then, the next largest element can be in its own segment, either before or after the largest element, but ensuring that it is not in the same segment as the largest element (which would make the maximum of that segment the largest element, which is already counted).\n\nBut this approach may not always be possible. For example, if the array is [3, 1, 2, 4], and k=2. The two largest elements are 4 and 3. To have both as maxima, we need to split the array into [3,1,2] and [4], which sum to 3 +4=7. Alternatively, [3,1,2,4] is split into [3,1,2] and [4], which is the same. Or [3], [1,2,4], sum is 3+4=7. Both are valid.\n\nBut if the array is [3, 4, 2, 1], and k=2. The two largest are 4 and 3. To have both as maxima, we can split after 1st element (split into [3] and [4,2,1], sum 3+4=7). Or after the second element (split into [3,4], [2,1], sum 4+2=6). So the first option is better.\n\nSo the idea is that the k largest elements should be selected and each placed in their own segment. But how to do this in practice.\n\nBut how to implement this. One possible way is to find the positions of the k largest elements, and then split the array so that each of these elements is in its own segment. However, the order of the elements matters, and the splits must be made in a way that these elements are isolated.\n\nBut how to select which elements to include as the maxima. This seems complex.\n\nBut perhaps the problem can be solved with this greedy approach, and it's possible that the DP approach is not needed. But I'm not sure.\n\nAlternatively, perhaps the DP approach is the only way, and we can try to optimize it as much as possible.\n\nLet me think about the code for the DP approach, and see if it can be optimized in Python.\n\nFirst, precompute the range maxima.\n\nThen, initialize the DP table.\n\nBut for Python, nested loops are generally slower than in C++. So for n=2000, and k=2000, it's impossible. However, perhaps the actual test cases have smaller k.\n\nBut the problem says that k can be up to n. So, we need to think of an alternative.\n\nAnother Idea: Let's note that the maximum number of splits is k. For each split, we need to choose where to split. The maximum sum is achieved by having the largest elements as maxima. So perhaps we can find the positions where the splits should be made to isolate the largest elements.\n\nBut how?\n\nLet's think of it as follows: the first split should be made such that the first segment contains the first occurrence of the largest element, the second segment contains the next largest, etc. But this is not necessarily correct.\n\nAlternatively, think of the problem as selecting k-1 positions to split the array, such that the sum of the maxima of the resulting segments is maximized.\n\nBut how to select these positions.\n\nAnother Idea: Let's think about the problem as a variation of the problem of selecting k-1 split points to maximize the sum of the maxima of the segments. For each possible split, the maximum of the segment is determined by the maximum in that segment.\n\nBut this doesn't immediately suggest an efficient algorithm.\n\nLet me think about the following: For the optimal solution, the splits must occur at positions where the current segment's maximum is a local maximum. For example, in the sample input, the splits are after 3 elements, then after 2 more, etc.\n\nBut again, this is not helpful for an algorithm.\n\nAnother Idea: Let's consider that for each segment, the maximum is at least as large as any element in the segment. So, for the entire array, the maximum element must be in one of the segments. If it's in a segment, then that segment's maximum is the global maximum. So, in the optimal solution, the global maximum must be in its own segment. Otherwise, if it is part of a segment with other elements, the maximum of that segment is the global maximum, but we could split it into a segment containing just the global maximum, which would contribute the same value but allow other splits to possibly add more.\n\nWait, no. Suppose the global maximum is part of a segment. If we split it into a segment by itself, then the contribution of that segment is the global maximum. If it's part of a larger segment, the contribution is still the global maximum. So splitting it into its own segment doesn't change the contribution, but allows us to make more splits elsewhere.\n\nAh! This suggests that it's better to split the global maximum into its own segment, because this allows us to split the remaining array into k-1 segments, which may allow us to capture more maxima.\n\nFor example, if the global maximum is in a segment with other elements, then splitting it into its own segment allows us to have one fewer segment to allocate to the remaining elements, potentially allowing us to capture more maxima.\n\nSo this suggests a recursive approach: find the global maximum, split it into its own segment, and then recursively solve the problem for the left and right parts, with k-1 segments. But how to do this.\n\nWait, but the segments must be contiguous. So if the global maximum is at position i,",
    "response": "To solve this problem, we need to maximize the total profit Polycarp can achieve by solving problems over exactly `k` days. Each day, he solves a contiguous sequence of problems, and the profit for each day is the maximum difficulty of the problems solved that day. The goal is to distribute the problems such that the sum of these daily profits is maximized.\n\n### Approach\n1. **Dynamic Programming (DP) Setup**: We use a DP table where `dp[i][j]` represents the maximum profit achievable by solving the first `i` problems in `j` days.\n2. **Precompute Range Maximums**: To efficiently compute the maximum value of any subarray, we precompute a 2D array `max_range` where `max_range[l][r]` stores the maximum value from index `l` to `r`.\n3. **DP Transition**: For each possible split point, we compute the maximum profit by considering all valid splits and using precomputed range maximums to quickly determine the maximum difficulty for each segment.\n4. **Backtracking**: After filling the DP table, we backtrack to determine the exact distribution of problems across days that achieves the maximum profit.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx+n]))\n    \n    # Precompute max_range[l][r] which is the max of a[l..r] (0-based)\n    max_range = [[0]*n for _ in range(n)]\n    for i in range(n):\n        current_max = a[i]\n        max_range[i][i] = current_max\n        for j in range(i+1, n):\n            current_max = max(current_max, a[j])\n            max_range[i][j] = current_max\n    \n    # Initialize DP table\n    INF = float('-inf')\n    dp = [[INF]*(k+1) for _ in range(n+1)]\n    # dp[i][j] is the max profit for first i problems in j days\n    # base case: j=1\n    for i in range(1, n+1):\n        dp[i][1] = max_range[0][i-1]\n    \n    # Fill DP table\n    for j in range(2, k+1):\n        for i in range(j, n+1):  # i must be >= j since each day has at least one problem\n            # m ranges from j-1 to i-1 (number of problems in first j-1 days)\n            # for each m, dp[m][j-1] + max_range[m][i-1]\n            # optimize by tracking current_max as m decreases\n            current_max = -1\n            max_val = INF\n            for m in range(i-1, j-2, -1):  # m from i-1 down to j-1\n                if m == i-1:\n                    current_max = a[m]\n                else:\n                    current_max = max(current_max, a[m])\n                # m is the number of problems in first j-1 days, so the current segment starts at m (0-based)\n                # the segment is from m to i-1 (inclusive), which is length i - m\n                val = dp[m][j-1] + current_max\n                if val > max_val:\n                    max_val = val\n            dp[i][j] = max_val\n    \n    # Now backtrack to find the split points\n    res = []\n    current_i = n\n    current_j = k\n    while current_j > 1:\n        # Find m such that dp[current_i][current_j] = dp[m][current_j-1] + max_range[m][current_i-1]\n        # iterate m from current_j-1 to current_i-1\n        # we can track it during the DP computation, but here we have to recompute\n        # So for backtracking, we need to recompute the path\n        # This part is O(n^2) in worst case, but acceptable for n=2000\n        best_m = -1\n        best_val = -1\n        current_max = -1\n        for m in range(current_i-1, current_j-2, -1):\n            if m == current_i-1:\n                current_max_segment = a[m]\n            else:\n                current_max_segment = max(current_max, a[m])\n            current_max = current_max_segment\n            val = dp[m][current_j-1] + current_max_segment\n            if val == dp[current_i][current_j]:\n                best_m = m\n                break\n        res.append(current_i - best_m)\n        current_i = best_m\n        current_j -= 1\n    res.append(current_i)  # the first day's length is current_i\n    res.reverse()\n    print(dp[n][k])\n    print(' '.join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Precompute Range Maximums**: This allows us to quickly determine the maximum difficulty of any subarray, which is crucial for efficiently computing the DP transitions.\n2. **Dynamic Programming Table**: The `dp` table is filled by considering all possible ways to split the first `i` problems into `j` days, using previously computed values and the precomputed range maximums.\n3. **Backtracking**: After computing the maximum profit using the DP table, we backtrack to determine the exact distribution of problems across days that achieves this maximum profit. This involves finding the optimal split points based on the DP values.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx+n]))\n    \n    # Precompute max_range[l][r] which is the max of a[l..r] (0-based)\n    max_range = [[0]*n for _ in range(n)]\n    for i in range(n):\n        current_max = a[i]\n        max_range[i][i] = current_max\n        for j in range(i+1, n):\n            current_max = max(current_max, a[j])\n            max_range[i][j] = current_max\n    \n    # Initialize DP table\n    INF = float('-inf')\n    dp = [[INF]*(k+1) for _ in range(n+1)]\n    # dp[i][j] is the max profit for first i problems in j days\n    # base case: j=1\n    for i in range(1, n+1):\n        dp[i][1] = max_range[0][i-1]\n    \n    # Fill DP table\n    for j in range(2, k+1):\n        for i in range(j, n+1):  # i must be >= j since each day has at least one problem\n            # m ranges from j-1 to i-1 (number of problems in first j-1 days)\n            # for each m, dp[m][j-1] + max_range[m][i-1]\n            # optimize by tracking current_max as m decreases\n            current_max = -1\n            max_val = INF\n            for m in range(i-1, j-2, -1):  # m from i-1 down to j-1\n                if m == i-1:\n                    current_max = a[m]\n                else:\n                    current_max = max(current_max, a[m])\n                # m is the number of problems in first j-1 days, so the current segment starts at m (0-based)\n                # the segment is from m to i-1 (inclusive), which is length i - m\n                val = dp[m][j-1] + current_max\n                if val > max_val:\n                    max_val = val\n            dp[i][j] = max_val\n    \n    # Now backtrack to find the split points\n    res = []\n    current_i = n\n    current_j = k\n    while current_j > 1:\n        # Find m such that dp[current_i][current_j] = dp[m][current_j-1] + max_range[m][current_i-1]\n        # iterate m from current_j-1 to current_i-1\n        # we can track it during the DP computation, but here we have to recompute\n        # So for backtracking, we need to recompute the path\n        # This part is O(n^2) in worst case, but acceptable for n=2000\n        best_m = -1\n        best_val = -1\n        current_max = -1\n        for m in range(current_i-1, current_j-2, -1):\n            if m == current_i-1:\n                current_max_segment = a[m]\n            else:\n                current_max_segment = max(current_max, a[m])\n            current_max = current_max_segment\n            val = dp[m][current_j-1] + current_max_segment\n            if val == dp[current_i][current_j]:\n                best_m = m\n                break\n        res.append(current_i - best_m)\n        current_i = best_m\n        current_j -= 1\n    res.append(current_i)  # the first day's length is current_i\n    res.reverse()\n    print(dp[n][k])\n    print(' '.join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 935,
        "completion_token_count": 1206,
        "thoughts_token_count": 8192
    }
}