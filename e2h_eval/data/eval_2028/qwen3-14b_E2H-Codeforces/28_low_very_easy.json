{
    "start": 1758309835.3832629,
    "end": 1758309879.081475,
    "start-formatted": "2025-09-20 04:23 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to understand this problem. So, the task is to count the number of beautiful strings based on given n, m, and g. The beautiful string has exactly n zeros and m ones. But there's a catch: we need to be able to obtain the character g from the string through some modifications. \n\nFirst, I need to figure out what these modifications do. The modification operation replaces the last two characters with one. For example, if the last two are '00', they become '1'; if they are '01' or '10' or '11', then they become '0'? Wait, no. Wait the description says: \"replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero.\" Oh right! So whenever you replace two characters, the new character is 1 if both were 0, else 0. \n\nSo each modification reduces the length of the string by 1. And you can perform this operation as many times as needed, as long as the string's length is at least two. \n\nThe key here is that the final string must be reducible to a single character g through these operations. Wait, no. Wait the problem says: \"We can obtain character g from string s with some (possibly, zero) number of modifications.\" So the string s must be such that after applying some number of modifications, you end up with the character g. \n\nBut how does that work? Let's think about what the process of applying modifications does. Each modification reduces the length by one. So, for example, starting with a string of length L, after k modifications, the length is L - k. To end up with a single character, we need to apply exactly (L - 1) modifications. Because the initial length is (n + m), since the string has exactly n zeros and m ones. So, the total length is L = n + m. \n\nBut to reach a single character, we have to perform (L - 1) operations. But each operation depends on the last two characters. However, the order in which we perform the operations might affect the final result. But maybe there's a way to model this as a parity problem or something else. \n\nWait, but perhaps the final result after all possible reductions depends only on the number of zeros and ones in the original string. Let me think. Let's take some examples. \n\nFor instance, consider the first sample input: n=1, m=1. So the string is length 2. To get to one character, you perform one modification. The original string is either \"01\" or \"10\". The last two characters are either 0 and 1, which would be replaced by 0. So the resulting character is 0. Which matches the first sample's g=0. Hence, those two strings are valid. But if the sample had g=1, then there would be zero valid strings. \n\nAnother example: if the original string is \"00\", then the first modification would replace the two zeros with 1. So the result is 1. If the original string is \"000\", then the first step would replace the last two zeros with 1, giving \"01\". Then, the next step would replace the two characters (0 and 1) with 0. So the result is 0. \n\nHmm. So the final result after reducing the string to a single character depends on the number of 0s and 1s in the original string. But how?\n\nLet me think recursively. Suppose we have a string S. Let's think about the parity of the number of 0s. Because each operation replaces two characters with another. Let's see:\n\nEach operation reduces the total count of 0s and 1s in a certain way. For example, replacing two 0s with 1: the count of 0s decreases by 2, and 1 increases by 1. Replacing any other pair (like 0 and 1, or 1 and 0, or 1 and 1) with 0: the count of 0s increases by 1, and the count of 1s decreases by 1 (if the pair was two 1s) or changes by 0 (if the pair was 0 and 1). \n\nBut this seems complicated. However, perhaps the final result depends on the parity of the number of zeros. Let me think about the example above where the original string has two zeros. The final result is 1. If the original string has three zeros, the final result is 0. Let's see:\n\nOriginal string: \"000\". First, replace last two zeros with 1 → \"01\". Now, replace the two characters (0 and 1) with 0 → \"0\". So the",
    "response": "To solve this problem, we need to determine the number of beautiful strings that can be reduced to a specific character `g` using a series of allowed modifications. The key insight is understanding how the modifications affect the final result based on the parity of the number of zeros in the string.\n\n### Approach\n1. **Understanding Modifications**: Each modification reduces the string length by replacing the last two characters with one character. If the two characters are both '0', they become '1'; otherwise, they become '0'.\n2. **Reduction to Single Character**: The process of reducing the string to a single character depends on the parity (even or odd) of the number of zeros in the original string.\n3. **Key Observations**:\n   - If the number of zeros `n` is even, the final character after all possible reductions will be `1` if `g` is `1`, and `0` otherwise.\n   - If the number of zeros `n` is odd, the final character will be `0` if `g` is `0`, and `1` otherwise.\n4. **Combinatorial Counting**: Calculate the number of ways to arrange `n` zeros and `m` ones in the string, considering the constraints imposed by the parity of `n`.\n\n### Solution Code\n```python\nMOD = 10**9 + 7\n\ndef comb(n, k, fact, inv_fact):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    cases = []\n    while idx < len(input):\n        n = int(input[idx])\n        m = int(input[idx+1])\n        g = int(input[idx+2])\n        cases.append((n, m, g))\n        idx += 3\n    \n    max_nm = 10**5 + 10\n    fact = [1] * (max_nm)\n    inv_fact = [1] * (max_nm)\n    \n    for i in range(1, max_nm):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_nm-1] = pow(fact[max_nm-1], MOD-2, MOD)\n    for i in range(max_nm-2, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    results = []\n    for n, m, g in cases:\n        total = n + m\n        if total == 0:\n            results.append(0)\n            continue\n        \n        # Determine the required parity\n        if g == 0:\n            required_parity = 1  # number of 0s must be odd\n        else:\n            required_parity = 0  # number of 0s must be even\n        \n        if (n % 2) != required_parity:\n            results.append(0)\n            continue\n        \n        # Compute C(n + m, n)\n        res = comb(n + m, n, fact, inv_fact)\n        results.append(res)\n    \n    for r in results:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Precompute Factorials and Inverses**: Factorials and their modular inverses are precomputed up to the maximum possible value of `n + m` to efficiently compute combinations using modular arithmetic.\n2. **Combination Calculation**: The function `comb` calculates combinations using precomputed factorials and inverse factorials to ensure efficiency and correctness under modulo operations.\n3. **Parity Check**: For each test case, check if the number of zeros `n` has the required parity (even or odd) based on the target character `g`.\n4. **Result Calculation**: If the parity condition is met, compute the number of valid permutations of zeros and ones using combinations, otherwise return 0.\n\nThis approach ensures that we efficiently count valid strings while adhering to the constraints and properties of the allowed modifications.",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 10**9 + 7\n\ndef comb(n, k, fact, inv_fact):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    cases = []\n    while idx < len(input):\n        n = int(input[idx])\n        m = int(input[idx+1])\n        g = int(input[idx+2])\n        cases.append((n, m, g))\n        idx += 3\n    \n    max_nm = 10**5 + 10\n    fact = [1] * (max_nm)\n    inv_fact = [1] * (max_nm)\n    \n    for i in range(1, max_nm):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_nm-1] = pow(fact[max_nm-1], MOD-2, MOD)\n    for i in range(max_nm-2, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    results = []\n    for n, m, g in cases:\n        total = n + m\n        if total == 0:\n            results.append(0)\n            continue\n        \n        # Determine the required parity\n        if g == 0:\n            required_parity = 1  # number of 0s must be odd\n        else:\n            required_parity = 0  # number of 0s must be even\n        \n        if (n % 2) != required_parity:\n            results.append(0)\n            continue\n        \n        # Compute C(n + m, n)\n        res = comb(n + m, n, fact, inv_fact)\n        results.append(res)\n    \n    for r in results:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 547,
        "completion_token_count": 863,
        "thoughts_token_count": 1024
    }
}