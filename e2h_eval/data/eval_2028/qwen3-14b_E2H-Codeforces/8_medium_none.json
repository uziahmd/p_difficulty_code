{
    "start": 1758019633.6163437,
    "end": 1758021896.017,
    "start-formatted": "2025-09-16 19:47 KST",
    "end-formatted": "2025-09-16 20:24 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to assign directions to edges in an undirected graph such that the flow conditions are satisfied. The main points are:\n\n- The flow must be a maximum flow, so the sum of outgoing flows from the source (vertex 1) equals the total capacity, and similarly for the sink (vertex n). Also, all intermediate vertices must have equal incoming and outgoing flow.\n\n- Additionally, the directed graph shouldn't have cycles. Hmm, how do I ensure that?\n\nWait, the problem says that the resulting directed graph must not have cycles. Oh right, but how can that be possible? Because if there's a cycle, then the flow could circulate around it, but maybe that's not allowed here. So the directed graph must be acyclic. That suggests that we need to assign directions in such a way that the graph is a DAG.\n\nBut how to approach this? Let me think about the constraints again.\n\nFirst, the flow conditions: For each vertex except 1 and n, the inflow equals outflow. For vertex 1, all edges must be outgoing (since no incoming edges). For vertex n, all edges must be incoming (since otherwise, if there's an outgoing edge, that would contribute to the outflow, which isn't allowed unless it's part of the sink's inflow).\n\nBut how to model this? Maybe think of this as building a directed graph where the flow conservation holds, and then ensuring it's acyclic.\n\nWait, the problem says that the given graph is connected and a solution exists. So I don't have to worry about that.\n\nLet me think of the steps needed.\n\nFirst, the flow values are already given for each edge. The problem is to assign directions to these edges such that the flow conservation is met and the graph is acyclic.\n\nSo perhaps the approach is to model this as a directed graph where the flow conservation holds, and then find a topological order that allows us to assign directions in a way that avoids cycles.\n\nAlternatively, maybe we can model this as a directed acyclic graph (DAG) with a topological order, where each edge is directed from a lower-ranked node to a higher-ranked one in the topological order. Then, the flow conservation can be handled by ensuring that for each node except the source and sink, the sum of flows from incoming edges equals the sum of flows from outgoing edges.\n\nBut how to determine the direction of edges based on such a topological order?\n\nAnother thought: since the directed graph must be acyclic, it must have a topological ordering. So if we can assign a topological order to the nodes, then direct each edge from the node that comes earlier in the order to the one that comes later. But how to choose such an order that also satisfies the flow conservation?\n\nAlternatively, perhaps we can construct a directed graph that is a DAG, and for each node (except source and sink), the inflow equals outflow. How can we model this?\n\nLet me think about the flow conservation. For each node v (not source or sink), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. Which implies that the net flow (outflow minus inflow) is zero. But since the graph is undirected, the flow on each edge is fixed. So the direction of each edge determines whether it contributes to inflow or outflow for the nodes.\n\nThis seems similar to building a directed graph where each node (except source and sink) has zero net flow. Which is exactly what a flow network requires. But the problem is that the flow values are already given, and we need to assign directions accordingly.\n\nWait, but in a standard flow problem, the flow through an edge is determined by the direction. However, here, the flow is given for each edge, and we need to assign the direction such that the flow is valid.\n\nSo perhaps the problem reduces to finding a directed graph where the flow is valid and the graph is acyclic.\n\nBut how?\n\nAn alternative approach: think of the problem as building a directed graph that is a DAG, and for each node (except source and sink) the sum of flows going into it equals the sum of flows going out. Also, the source has no incoming edges, and the sink has no outgoing edges.\n\nLet me consider the flow conservation. For each node v (excluding source and sink), the sum of flows on edges directed into v equals the sum of flows on edges directed out of v. Let me denote this as:\n\nsum_{e directed into v} c_e = sum_{e directed out of v} c_e.\n\nWhich implies that sum_{e incident to v} c_e * (direction factor) = 0, where direction factor is +1 if the edge is directed away from v, -1 if directed towards v. Wait, maybe not. Let me rephrase.\n\nEach edge contributes to the inflow or outflow of the nodes. For example, if an edge between u and v is directed from u to v, then for u, this contributes to its outflow (so subtracted from the inflow), and for v, it contributes to inflow (so added to the inflow). For the node v, the total inflow must equal the total outflow.\n\nBut how can we model this? It's similar to assigning a direction to each edge such that the net flow for each node (except source and sink) is zero.\n\nThis seems like a problem of finding an orientation of the edges such that the flow conservation holds, and the directed graph is acyclic.\n\nBut how to find such an orientation?\n\nAnother idea: Since the graph is connected and the flow values are fixed, perhaps we can model this as an Euler tour or something similar. Wait, but I'm not sure.\n\nAlternatively, think of the problem as a directed graph where each edge has a certain capacity (given by ci), and the direction is to be chosen such that the flow is valid. However, since the flow is already fixed, perhaps the direction is determined by the flow's direction.\n\nWait, but the problem states that the flow is already given (the ci's are the flow values). So the flow is fixed, and we need to assign directions so that the flow is valid.\n\nIn standard flow terms, the flow conservation for each node (except source and sink) is that the inflow equals the outflow. So for each node, the sum of flows on edges directed into the node must equal the sum of flows on edges directed out of the node.\n\nSo the problem reduces to assigning directions to edges so that this condition holds, and the directed graph is acyclic.\n\nNow, how to model this?\n\nLet me think of this as a system of equations. For each node v (not source or sink), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. Let me denote for each edge (u, v), the direction as either u→v or v→u. Let me think of variables for each edge's direction.\n\nBut solving such a system directly would be computationally expensive, especially with m up to 2e5.\n\nSo perhaps there's a smarter way. Let's think about the flow conservation for each node. Let's denote that for each node v, the sum of flows on edges incident to v, where the direction is away from v, must equal the sum of flows on edges incident to v where the direction is towards v. Because the inflow equals outflow.\n\nBut the sum of flows on edges incident to v is fixed. Let me call this S_v. Then, for the node v, the sum of flows on edges directed away from v is equal to half of S_v, because the total sum of flows on edges incident to v is S_v. Since for each edge, the flow is counted once in the inflow or once in the outflow. So the total outflow from v is equal to the inflow into v. Therefore, the total outflow from v is (S_v)/2. Wait, but only if the node is not the source or sink.\n\nBut for the source (node 1), the outflow is equal to the total flow value (the maximum flow). Similarly, for the sink (node n), the inflow is equal to the maximum flow.\n\nSo, for the source, the sum of flows on edges directed away from it is equal to the total flow (which is the sum of all flows on edges incident to the source, since the source can't have any inflow). Similarly, for the sink, the sum of flows on edges directed towards it is equal to the total flow.\n\nBut how can we use this information to assign directions to the edges?\n\nPerhaps, we can model this as a directed graph where each node (except source and sink) has a balance of zero. Then, the problem becomes finding a directed acyclic graph with such balance.\n\nBut how?\n\nLet me think of the problem as a directed graph where each edge has a direction, and for each node except source and sink, the net outflow is zero. Then, the directed graph must be acyclic.\n\nOne approach is to model this as a directed graph with a topological order, and assign directions according to that order. For example, if we can assign a topological order where the source is first and the sink is last, then all edges are directed from earlier nodes to later ones. This ensures that there are no cycles.\n\nBut how to ensure that the flow conservation is satisfied with such a direction?\n\nAlternatively, perhaps we can perform a DFS traversal and assign directions based on the traversal order. For example, during a DFS, when we visit a node, we can direct the edges from the parent to the child, and then process the children. But how would that help with the flow conservation?\n\nAlternatively, think of the problem as building a directed tree structure, but with multiple edges. However, since the graph can be arbitrary, this might not be feasible.\n\nAnother idea: For each node, compute the required net outflow. For the source, it's the total flow (sum of all edges incident to it). For the sink, it's negative of the total flow. For other nodes, it's zero. Then, the problem reduces to finding an orientation of the edges such that for each node, the sum of the flows on edges directed away from the node minus the sum of flows on edges directed towards the node equals the required net outflow.\n\nBut how to find such an orientation?\n\nThis seems like a problem of finding an orientation of the edges to satisfy certain constraints. For example, this is similar to the problem of orienting edges in a graph to make it Eulerian, but here the constraints are more complex.\n\nBut perhaps we can model this as a flow problem again. Wait, but the problem is that the flow is already given. So maybe we can model this as a directed graph with certain constraints.\n\nAlternatively, think of this as a directed graph where each edge's direction is chosen such that the net outflow for each node is as required. For example, for node v, the net outflow is (sum of flows on edges directed away from v) minus (sum of flows on edges directed towards v) equals the required value.\n\nBut how to compute that?\n\nLet me think of this as a system of equations. For each node v, the net outflow is:\n\nnet_outflow(v) = sum_{edges directed away} c_e - sum_{edges directed towards} c_e = required_outflow(v).\n\nBut for each edge, the direction affects two nodes. For example, if an edge between u and v is directed from u to v, then for u, it contributes +c_e to net_outflow, and for v, it contributes -c_e to net_outflow.\n\nSo, for each edge, the choice of direction contributes +c_e to one node and -c_e to another.\n\nThis looks like a system of equations where each equation corresponds to a node's net outflow. However, solving such a system directly might be challenging.\n\nBut note that the sum of all required_outflow(v) over all nodes must be zero. Because for the entire graph, the total net outflow must be zero. For example, the source has required_outflow equal to total_flow, the sink has -total_flow, and others have zero. Summing them gives zero. So the system is consistent.\n\nBut how to find such an orientation?\n\nThis seems like a problem of finding an assignment of directions to edges such that the net outflow for each node is as required. How can this be done?\n\nThis is equivalent to finding a directed graph where the net outflow for each node is known. Such a problem can be modeled as a flow problem. But how?\n\nAlternatively, think of this as a directed graph where each edge can be traversed in either direction, and the goal is to assign directions to edges so that the net outflow for each node is correct.\n\nThis is similar to the problem of finding an Eulerian orientation. But in that case, the net outflow for each node must be even, etc. Not sure.\n\nWait, here's an idea. Let's imagine that for each node v, we have a value d(v), which is the required net outflow. For the source, d(1) = total_flow. For the sink, d(n) = -total_flow. For other nodes, d(v) = 0.\n\nThen, for each edge between u and v, the direction of the edge will contribute +c to one node and -c to the other. So, the problem is to assign directions to edges such that for each node v, the sum of the contributions from all edges incident to v is equal to d(v).\n\nThis is similar to the problem of finding an assignment of variables (directions) such that the sum over edges' contributions equals d(v) for each node.\n\nBut how to find such an assignment?\n\nThis seems like a problem that can be modeled as a directed graph with potentials. Let me think of it as follows: For each node v, let's define a variable p(v), which represents the potential. Then, for each edge between u and v, if we direct it from u to v, then the contribution to the net outflow of u is +c, and to v is -c. Alternatively, directing it from v to u would contribute -c to u and +c to v.\n\nSo, the net outflow for node u is sum over edges incident to u of (direction_contribution). Which can be represented as sum (if edge is directed away from u, then +c, else -c).\n\nBut how to model this with potentials? Maybe think of it as the difference between potentials. Suppose that the net outflow for node u is equal to the sum of (p(u) - p(v)) * c for each edge between u and v. Wait, no, that's not directly applicable.\n\nAlternatively, think of the net outflow for each node as the sum over edges of (direction) * c, where direction is +1 if the edge is directed away from the node, -1 if directed towards.\n\nBut how to find such directions.\n\nAlternatively, think of the problem as a directed graph where each edge has a capacity, and we need to find a flow that satisfies certain conditions. But this seems circular.\n\nAnother approach: Let's consider that the problem is to find an orientation of the edges such that the net outflow for each node is d(v). This is equivalent to finding a directed graph where the net outflow is d(v) for each node. This can be achieved by solving a system of equations, but how?\n\nLet me think of the problem as follows: For each edge (u, v), we can assign a variable x_uv which is +1 if the edge is directed from u to v, and -1 if it's directed from v to u. Then, for each node v, the sum over all edges incident to v of (x_uv * c_uv) equals d(v). Here, for each edge between u and v, the contribution to u is x_uv * c_uv, and to v is -x_uv * c_uv. So for each node v, the sum of contributions from all edges incident to v is equal to d(v).\n\nSo, the system of equations is:\n\nFor each node v:\nsum_{edges incident to v} (x_uv * c_uv) = d(v)\n\nBut for each edge (u, v), the variable x_uv is either +1 or -1. However, this seems like a system with variables that are constrained to be ±1, which is difficult to solve directly.\n\nBut perhaps there's a way to model this as a graph problem. Let me think of it as a directed graph where each edge has a weight. The problem is to assign directions to the edges such that the net outflow for each node is d(v).\n\nThis seems similar to finding a directed graph with certain flow properties. But how?\n\nAnother idea: The problem is equivalent to finding a directed graph where for each node, the sum of the flows on edges directed away from the node minus the sum of flows on edges directed towards the node equals d(v). This is exactly the same as the flow conservation equations in a flow network, except that the flow values are fixed and the direction is to be determined.\n\nBut in this case, the flow is not being computed; it's given. So the direction must be chosen such that the flow conservation is satisfied.\n\nBut how?\n\nLet me think of the problem in terms of the flow conservation. Suppose that for each node v (excluding source and sink), the sum of flows on edges directed into v is equal to the sum directed out. For the source, all edges are directed out (so the sum of flows on edges directed out is the total flow). For the sink, all edges are directed in (so the sum of flows directed in is the total flow).\n\nBut how to model this?\n\nLet me think about the following approach: \n\nWe can model this as a directed graph where the source is the root, and we assign directions based on a spanning tree. But I'm not sure.\n\nAlternatively, think of the graph as a directed graph with edges directed in a way that forms a DAG. Since the DAG has no cycles, we can arrange the nodes in a topological order. For each node, the direction of the edges can be determined based on their position in the topological order.\n\nBut how to ensure that the flow conservation is satisfied?\n\nLet me think about the following: If we can assign a topological order where the source is the first node and the sink is the last node, then all edges are directed from earlier nodes to later nodes. This ensures that the graph is acyclic. Now, how to assign directions such that the flow conservation is satisfied.\n\nBut how to find such a topological order that also satisfies the flow conservation?\n\nAlternatively, perhaps we can perform a BFS or DFS traversal starting from the source, and assign directions based on the traversal. For example, when visiting a node, direct the edges towards unvisited nodes. This would create a tree structure, and the rest of the edges can be directed in some way. However, this might not ensure flow conservation.\n\nAnother idea: Since the flow conservation for each node (except source and sink) requires that the sum of flows on incoming edges equals the sum on outgoing edges, perhaps we can model this as a directed graph where each node's in-degree (weighted by flow) equals its out-degree (weighted by flow). This is similar to an Eulerian trail, but again, I'm not sure.\n\nWait, for the flow conservation, the sum of flows on incoming edges equals the sum on outgoing edges. Which means that the total flow entering the node is equal to the total flow leaving it. So, for the entire graph, the total flow from the source must equal the total flow to the sink.\n\nBut how to assign directions to edges to achieve this?\n\nMaybe think of the problem as building a directed graph where the flow conservation holds, and then ensuring that it's acyclic. Once the flow conservation is satisfied, we can find a topological order and adjust the directions to eliminate cycles.\n\nBut how to build the directed graph with flow conservation?\n\nLet me think of the following approach:\n\nFor each node v (excluding source and sink), the sum of flows on edges incident to v must be even? No, not necessarily. Because the sum of flows on incoming edges equals the sum on outgoing edges. So the total sum of flows on edges incident to v is twice the sum of outgoing flows. Hence, the sum must be even. Wait, no. Let me see: sum_in = sum_out. Total sum for the node is sum_in + sum_out = 2*sum_in. So the total sum of flows on edges incident to v must be even. But the problem states that a solution exists, so this must hold.\n\nSo for each node v (excluding source and sink), the sum of flows on edges incident to v must be even. But the input may not guarantee this. However, the problem says that a solution exists, so the input must satisfy this condition.\n\nBut how does this help me?\n\nWell, perhaps I can model this as a directed graph where for each node v (excluding source and sink), the sum of flows on edges directed away from v equals half the total sum of flows on edges incident to v.\n\nBut again, how to find such directions?\n\nLet me think of the following approach: For each node, compute the required outflow (for non-source/sink nodes, it's half the sum of flows on incident edges). Then, this becomes a problem of finding an orientation of the edges such that each node's outflow matches the required value.\n\nThis seems like a problem that can be solved using a greedy approach. For example, we can model this as a directed graph and perform a DFS or BFS traversal, adjusting the directions of edges as we go.\n\nAlternatively, think of the problem as a directed graph where we have to assign directions such that the outflow for each node is correct. This is similar to a flow problem where we have to find a flow that satisfies certain constraints.\n\nBut how?\n\nLet me try to think of the problem in terms of building a directed graph where each node has a certain required outflow. For example, for the source, the outflow is the total flow. For the sink, it's zero (since all edges are incoming). For other nodes, it's half the sum of their incident edges.\n\nBut how to model this?\n\nMaybe this can be viewed as a directed graph where the outflow for each node is known, and the edges are to be directed to meet these outflow requirements.\n\nThis sounds like a problem that can be modeled with a directed graph and then solving for the directions. However, I'm not sure how to proceed.\n\nWait, here's an idea inspired by the standard flow algorithms. Let's imagine that the graph is a directed graph where we have to assign directions to edges so that for each node, the outflow is as required. We can model this as a flow problem where we have to find a flow that satisfies the outflow constraints. But since the flow values are fixed, perhaps we can model this as follows:\n\nEach edge has a capacity of c_i, and we need to assign a direction (either from u to v or v to u) such that the flow through the edge is c_i. This is a bit abstract.\n\nAlternatively, think of this as a flow problem where each edge has a fixed flow value, and we have to assign the direction such that the flow conservation is satisfied. However, since the flow values are fixed, this is not a standard flow problem.\n\nAnother approach: Since the directed graph must be acyclic, perhaps we can assign directions based on a topological order. For example, assign a topological order to the nodes, and direct all edges from earlier nodes to later ones. Then, for each node (except source and sink), the sum of flows on incoming edges must equal the sum on outgoing edges. How to find such a topological order?\n\nBut how to ensure that the flow conservation is satisfied with this order?\n\nLet me think about the following: For each node in the topological order, after the source and before the sink, the sum of flows on edges coming into the node from earlier nodes must be equal to the sum of flows on edges going out to later nodes. But how to compute this?\n\nThis seems like a dynamic programming problem. For example, when processing a node in the topological order, we can compute the required outflow and direct edges accordingly. But I'm not sure.\n\nAlternatively, think of the problem as building a directed graph with a topological order, and for each node, the net outflow is determined by the edges directed to later nodes and from earlier nodes.\n\nLet me try to think of this as follows:\n\nAssume that we have a topological order of the nodes, say, v_1, v_2, ..., v_n, where v_1 is the source and v_n is the sink. For each node v_i (i not 1 or n), the sum of flows on edges directed from v_i to later nodes must equal the sum of flows on edges directed from earlier nodes to v_i.\n\nBut how to ensure this?\n\nThis seems like a system of equations that depends on the topological order. But without knowing the topological order, it's hard to proceed.\n\nMaybe the key is to find a topological order that allows for this. For example, start with the source, and then for each node, direct edges to nodes that come after it in the order.\n\nBut how to determine the order?\n\nPerhaps the solution lies in constructing a directed graph that is a DAG and satisfies the flow conservation, and then using a topological sort to assign directions. But how?\n\nLet me think of the following algorithm:\n\n1. Compute for each node v (excluding source and sink) the required outflow, which is half of the sum of flows on edges incident to v. Let's call this value req_out[v].\n\n2. For the source, req_out[1] is the total flow (sum of flows on edges incident to it). For the sink, req_out[n] is zero (since all edges are incoming).\n\n3. Now, we need to assign directions to edges such that for each node v, the sum of flows on edges directed away from v equals req_out[v].\n\nThis is similar to finding a directed graph where each node has a certain outflow requirement.\n\nBut how to model this? Perhaps this can be modeled as a flow problem where we have to find a flow that satisfies these outflow requirements. However, since the flow values are fixed, it's unclear.\n\nAnother idea: Treat this as a directed graph where each edge can carry flow in either direction, and we need to find a way to assign directions to edges so that the outflow requirements are met. This sounds like a problem that can be modeled with a flow network, but I'm not sure how.\n\nAlternatively, think of this as a directed graph where each edge is directed from u to v if the flow is going from u to v. Then, for each node v, the sum of flows on outgoing edges minus the sum of flows on incoming edges is equal to req_out[v]. \n\nBut how to find such directions?\n\nLet me think of this as a system of equations. For each node v, the sum over all edges incident to v of (direction_uv * c_uv) = req_out[v], where direction_uv is +1 if the edge is directed away from v, -1 otherwise.\n\nBut solving this system is challenging.\n\nBut perhaps we can model this as a directed graph with potentials. For example, assign to each node a potential p[v], and for each edge between u and v, if p[u] > p[v], then the edge is directed from u to v. This would ensure that the graph is acyclic (as long as potentials are assigned in a way that forms a DAG). \n\nBut how to assign the potentials so that the flow conservation is satisfied?\n\nThe idea is that for each edge between u and v, the direction is determined by the potential difference. Then, the flow conservation equations would involve the potentials. Let's explore this.\n\nSuppose that for each edge between u and v, we direct it from u to v if p[u] > p[v], and from v to u otherwise. Then, the net outflow for a node v is sum_{edges incident to v} c_e * (direction_uv). \n\nBut how to relate this to the potentials?\n\nIf we assume that the potential differences determine the direction, then for each edge between u and v, the contribution to the net outflow of u is c_e if p[u] > p[v], and -c_e if p[v] > p[u]. If p[u] = p[v], then we can choose the direction arbitrarily. However, to avoid cycles, the potentials must be such that there are no ties, and the graph is a DAG.\n\nBut how to choose the potentials such that the net outflow for each node is req_out[v]?\n\nLet me think of the net outflow for node v as the sum over all edges incident to v of c_e * (sign(p[v] - p[u])), where u is the other endpoint of the edge. Wait, no. For each edge between u and v, if p[u] > p[v], then the edge is directed from u to v, contributing +c_e to u's net outflow and -c_e to v's net outflow. If p[v] > p[u], then it's directed from v to u, contributing -c_e to u and +c_e to v. If p[u] == p[v], then the direction is arbitrary.\n\nSo the net outflow for node v is:\n\nsum_{edges incident to v} [c_e * (if p[v] < p[u], then -1 else if p[v] > p[u], then +1 else 0)] ?\n\nWait, no. Let me rephrase:\n\nFor each edge between u and v, if it's directed from u to v, then it contributes +c_e to u's outflow and -c_e to v's outflow. So for the net outflow of v, this edge contributes -c_e if directed from u to v, and +c_e if directed from v to u.\n\nSo for each edge between u and v, the contribution to v's net outflow is:\n\nif p[v] > p[u], then +c_e (edge directed from u to v?), wait no.\n\nLet me think again. Suppose p[u] > p[v]. Then the edge is directed from u to v. This contributes +c_e to u's outflow and -c_e to v's outflow. So for v's net outflow, this edge contributes -c_e.\n\nIf p[v] > p[u], then the edge is directed from v to u, contributing +c_e to v's outflow and -c_e to u's outflow. So for v's net outflow, this contributes +c_e.\n\nIf p[u] == p[v], then the direction is arbitrary, and we can choose it to contribute whatever is needed.\n\nSo, for each edge between u and v, the contribution to v's net outflow is:\n\nc_e * (sign(p[v] - p[u])) if p[u] != p[v], else arbitrary.\n\nBut how to choose the potentials p such that for each node v, the sum of these contributions equals req_out[v].\n\nThis seems complicated, but perhaps we can model it as a system of equations involving the potentials.\n\nLet me denote that for each node v, the net outflow is:\n\nsum_{edges incident to v} c_e * (sign(p[v] - p[u])) = req_out[v]\n\nBut this is a non-linear system, which is hard to solve.\n\nHowever, if we assume that all potentials are distinct and ordered in a certain way, then the sign is determined by the order. For example, if we assign potentials such that p[1] < p[2] < ... < p[n], then all edges are directed from lower-numbered nodes to higher-numbered ones. But this would make the graph a DAG, but how to ensure that the flow conservation is satisfied?\n\nLet me try to think of this as follows: Assign potentials in a way that the net outflow for each node v is req_out[v]. How?\n\nMaybe this can be modeled as a directed graph where the potentials are determined by the required outflows. But I'm not seeing the connection.\n\nAlternatively, think of this as a directed graph where the potentials are determined by the required outflows. For example, for each node v, the potential p[v] is set to the cumulative sum of req_out for nodes up to v. But this is just a guess.\n\nAlternatively, consider the following approach:\n\nStart with the source node (1) and assign it a potential of 0. Then, for each other node, assign a potential based on the flow conservation. For example, for each node v, the potential p[v] is determined by the sum of flows on edges directed into it from earlier nodes. But I'm not sure.\n\nAnother idea: Think of the problem as a directed graph with potentials, and the net outflow for a node v is related to the difference between its potential and its neighbors. For example, if we have a directed graph where the net outflow for each node v is proportional to the difference between its potential and the potentials of its neighbors.\n\nBut I'm not sure.\n\nAt this point, I'm stuck on finding a way to model the problem. Let's look at the sample input and output to see if there's a pattern.\n\nSample Input 1:\n3 3\n3 2 10\n1 2 10\n3 1 5\n\nSample Output: 1, 0, 1.\n\nSo the edges are directed as follows:\nEdge 3-2 is directed from 2 to 3 (since output is 1, meaning original ai=3, bi=2, so direction is bi→ai, which is 2→3).\nEdge 1-2 is directed from 1 to 2 (output 0).\nEdge 3-1 is directed from 1 to 3 (output 1, which means original ai=3, bi=1, so direction is bi→ai, which is 1→3).\n\nSo the directed edges are 1→2, 1→3, 2→3.\n\nNow, for the flow conservation:\n\nNode 2: incoming edges are 1→2 (10), outgoing edges are 2→3 (10). So inflow equals outflow (10=10). Correct.\n\nNode 1: no incoming edges. Outgoing edges sum to 10+5=15, which is the maximum flow.\n\nNode 3: incoming edges are 1→3 (5) and 2→3 (10), total 15. No outgoing edges. So it's the sink.\n\nThe directed graph is a DAG with topological order 1, 2, 3.\n\nSo, the direction of the edges is determined by the topological order. All edges are directed from earlier nodes to later ones.\n\nSo, in this case, the topological order is [1, 2, 3], and all edges are directed from earlier to later. This ensures acyclicity.\n\nSo, perhaps the general approach is to find a topological order of the nodes, and direct each edge from the node that appears earlier in the order to the one that appears later. This would ensure that the graph is acyclic.\n\nBut how to find such a topological order that also satisfies the flow conservation conditions?\n\nLet me think about the flow conservation. For each node v (not source or sink), the sum of flows on edges directed into it must equal the sum on edges directed out of it. In the topological order, all edges directed into v come from earlier nodes, and edges directed out of v go to later nodes.\n\nSo, for node v, the sum of flows on edges directed into v (from earlier nodes) must equal the sum of flows on edges directed out of v (to later nodes).\n\nBut how to ensure this?\n\nThis seems like a problem where, during the construction of the topological order, we need to ensure that for each node v, the sum of flows on edges from earlier nodes to v equals the sum of flows on edges from v to later nodes.\n\nBut how to do this?\n\nLet me think of this as a dynamic programming problem. Suppose we have built a topological order up to some node v, and we want to add v to the order. How can we ensure that the flow conservation is satisfied for v?\n\nFor example, when adding v to the topological order, the edges between v and already added nodes are directed from those nodes to v (since they are earlier in the order). The edges between v and future nodes are directed from v to those nodes. So, the sum of flows on edges directed into v (from earlier nodes) plus the sum of flows on edges directed out of v (to later nodes) must equal the total sum of flows on edges incident to v. And for flow conservation, the sum of flows directed into v must equal the sum directed out of v. Hence, the total sum of flows on edges incident to v must be even, which it is (as per the problem statement).\n\nBut how to ensure that the sum of flows directed into v equals the sum directed out of v?\n\nLet me denote that for node v, the total sum of flows on edges incident to v is S_v. Then, the sum of flows directed into v from earlier nodes is A, and the sum of flows directed out of v to later nodes is B. We need A = B, and since A + B = S_v, this implies that A = B = S_v / 2.\n\nSo, for each node v, during the topological ordering, when it is added to the order, the sum of flows on edges from already added nodes to v must be exactly S_v / 2.\n\nBut how to ensure this?\n\nThis seems like a problem that can be solved with a greedy approach. For example, we can build the topological order incrementally, choosing the next node to add based on some criteria that ensures that the sum of flows from already added nodes to it is exactly S_v / 2.\n\nBut how to implement this?\n\nLet me think of the following algorithm:\n\n- Compute for each node v, S_v = sum of flows on edges incident to v.\n\n- For the source node (1), S_1 is the total flow. Since it has no incoming edges, all edges must be directed out of it. So, when adding the source to the topological order, it's the first node.\n\n- For other nodes, we need to ensure that when they are added to the topological order, the sum of flows on edges from already added nodes to it is exactly S_v / 2.\n\nBut how to choose which node to add next?\n\nThis seems like a problem that can be solved with a priority queue or a queue of nodes that have the required sum of flows from already added nodes.\n\nLet me elaborate:\n\nInitially, the source is added to the topological order. For each node v adjacent to the source, the edges between them are directed from source to v. So, for these nodes, the sum of flows from",
    "response": "\n\nTo solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph satisfies specific flow conservation conditions and is acyclic. The key steps involve ensuring that each intermediate vertex has equal incoming and outgoing flow, the source has no incoming edges, the sink has no outgoing edges, and the graph remains acyclic.\n\n### Approach\n1. **Flow Conservation**: For each intermediate vertex (excluding the source and sink), the sum of flows on incoming edges must equal the sum of flows on outgoing edges.\n2. **Acyclic Graph**: The directed graph must be acyclic, which can be achieved by constructing a topological order where edges are directed from earlier nodes to later nodes in the order.\n3. **Topological Order Construction**: We use a modified BFS approach starting from the source node. Nodes are processed in such a way that when a node is added to the topological order, the sum of flows from already processed nodes to it meets the required flow conservation conditions.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n\n    # Compute S_v for each node\n    S = [0] * (n + 1)\n    for a, b, c in edges:\n        S[a] += c\n        S[b] += c\n\n    # For each node, we need to track the sum of flows from already processed nodes\n    # We'll use a queue for nodes that can be processed next\n    # Initially, the source (node 1) is added\n    topo_order = []\n    in_degree = [0] * (n + 1)\n    processed = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    processed[1] = True\n    topo_order.append(1)\n\n    # For each node, track how much flow has been contributed by already processed nodes\n    flow_contrib = [0] * (n + 1)\n\n    while q:\n        u = q.popleft()\n        for v, c, i in graph[u]:\n            if not processed[v]:\n                # Check if we can add v now\n                # The flow from u to v is c, so flow_contrib[v] increases by c\n                flow_contrib[v] += c\n                # Check if flow_contrib[v] == S[v]/2\n                if flow_contrib[v] * 2 == S[v]:\n                    # We can add v to the topological order\n                    processed[v] = True\n                    topo_order.append(v)\n                    q.append(v)\n                    # Now, for all neighbors of v, update their flow_contrib\n                    for w, cc, j in graph[v]:\n                        if not processed[w]:\n                            flow_contrib[w] += cc\n                            if flow_contrib[w] * 2 == S[w]:\n                                processed[w] = True\n                                topo_order.append(w)\n                                q.append(w)\n    # Now, assign directions based on the topological order\n    result = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if topo_order.index(a) < topo_order.index(b):\n            result[i] = 0\n        else:\n            result[i] = 1\n\n    for d in result:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into edges and an adjacency list representation of the graph.\n2. **Flow Calculation**: For each node, the total sum of flows on incident edges is computed.\n3. **Topological Order Construction**: Using a BFS-like approach starting from the source node, nodes are added to the topological order ensuring that each node's flow contribution from previously processed nodes meets the required half of its total incident flow.\n4. **Direction Assignment**: Based on the topological order, edges are directed from earlier nodes to later nodes, ensuring acyclicity and satisfying flow conservation conditions.\n\nThis approach ensures that the resulting directed graph is acyclic and meets all flow conservation requirements efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n\n    # Compute S_v for each node\n    S = [0] * (n + 1)\n    for a, b, c in edges:\n        S[a] += c\n        S[b] += c\n\n    # For each node, we need to track the sum of flows from already processed nodes\n    # We'll use a queue for nodes that can be processed next\n    # Initially, the source (node 1) is added\n    topo_order = []\n    in_degree = [0] * (n + 1)\n    processed = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    processed[1] = True\n    topo_order.append(1)\n\n    # For each node, track how much flow has been contributed by already processed nodes\n    flow_contrib = [0] * (n + 1)\n\n    while q:\n        u = q.popleft()\n        for v, c, i in graph[u]:\n            if not processed[v]:\n                # Check if we can add v now\n                # The flow from u to v is c, so flow_contrib[v] increases by c\n                flow_contrib[v] += c\n                # Check if flow_contrib[v] == S[v]/2\n                if flow_contrib[v] * 2 == S[v]:\n                    # We can add v to the topological order\n                    processed[v] = True\n                    topo_order.append(v)\n                    q.append(v)\n                    # Now, for all neighbors of v, update their flow_contrib\n                    for w, cc, j in graph[v]:\n                        if not processed[w]:\n                            flow_contrib[w] += cc\n                            if flow_contrib[w] * 2 == S[w]:\n                                processed[w] = True\n                                topo_order.append(w)\n                                q.append(w)\n    # Now, assign directions based on the topological order\n    result = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if topo_order.index(a) < topo_order.index(b):\n            result[i] = 0\n        else:\n            result[i] = 1\n\n    for d in result:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 692,
        "completion_token_count": 982,
        "thoughts_token_count": 8191
    }
}