{
    "start": 1758309945.977521,
    "end": 1758309985.0348783,
    "start-formatted": "2025-09-20 04:25 KST",
    "end-formatted": "2025-09-20 04:26 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. The goal is to maximize their total prize, which is the sum of S1 and S2. Each of them takes exactly n moves, and each move they take the leftmost digit of A and append it to their own number. The challenge is to find the sequence of H and M moves that gives the maximum total sum.\n\nHmm. So the key here is to decide for each step whether Homer or Marge should take the next digit. But since both have to take exactly n digits each, we need to make sure that the choices are balanced in terms of counts.\n\nWait, but how do we model this? Because for each decision, the choice affects the remaining steps. For example, if there are k digits left, and Homer has taken h moves so far, then Marge has taken (total moves so far) - h moves. Wait, the total number of moves is 2n. So for each state, we can track how many H and M moves have been made so far. But since the total number of moves is fixed, perhaps we can model the state as the current position in the string (i.e., how many digits have been taken already) and the number of H moves made so far. Because once we know how many H moves have been made, the number of M moves is (current steps) - h. But since the total steps is 2n, and each step is one move, the current position is equal to the number of steps taken so far. Let me think: for example, after taking k digits, the current position is k digits into the string. So, for the state, we can represent it as (k, h), where k is the number of digits taken so far (so the next digit is at index k of the original string), and h is the number of H moves taken so far. Then, since the total number of H moves must be exactly n, and the same for M, the constraints are that h can't exceed n, and (k - h) can't exceed n (since M's moves are k - h, and that must be <=n).\n\nSo for each state (k, h), we can decide whether to take H or M next, provided that there are enough moves left. For example, when choosing H, we need to ensure that h+1 <=n. Similarly, choosing M requires that (k - h) +1 <=n (since M's count is (k - h) +1 if we choose M now). Wait, because the current number of steps is k. So if we take another step, it becomes k+1. So after taking the next step, the number of H moves is h+1 (if we choose H) or h (if we choose M). The number of M moves would be (k+1) - (h+1) = k - h (if we choose H) or (k+1) - h = k -h +1 (if we choose M). So for the M case, the M moves would be (k+1) - h, which must be <=n. But since the total steps after this move is k+1, and the total steps needed is 2n, we have to make sure that the remaining steps can be filled with the required counts.\n\nBut for dynamic programming, the idea is to find the best choice (H or M) at each step that leads to the maximum total sum. However, how do we compute the total sum? Because the sum is the sum of S1 and S2, which are the numbers formed by the digits chosen by H and M respectively. But since each digit is added to the end of their respective numbers, the value of the digits depends on their position. For example, the first digit taken by H is the most significant digit of S1, and the next one is next, etc. So the value of S1 is the sum of digits[i] * 10^{n - 1 - pos}, where pos is the order in which the digit was taken. Wait, but for each digit that H takes, its contribution to the total sum is multiplied by 10^something. But since the total sum is S1 + S2, each digit's contribution is multiplied by 10^{(number of digits taken after it)}.\n\nBut considering that for each digit, when it is taken, it's added to either H or M's number. The position in their respective numbers determines its weight. For example, if H takes a digit at step i (the i-th move), then the digit is the (i-th) digit in his number, which is the (n - i + 1)-th digit in the number. Wait, no. Suppose H takes n digits. The first digit he takes is the first digit of his number,",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize (sum of their numbers) is maximized. Each player must make exactly `n` moves, and the sequence of moves should be chosen to maximize the sum of the numbers formed by their respective digits.\n\n### Approach\n1. **Dynamic Programming with Memoization**: We use a recursive approach with memoization to explore all possible sequences of moves efficiently. The state of our recursion is defined by the number of digits taken so far (`k`) and the number of moves Homer has made so far (`h`).\n2. **Greedy Choice with Backtracking**: At each step, we decide whether Homer or Marge should take the next digit based on which choice leads to a higher total sum. This decision is made by recursively evaluating both possibilities and choosing the one with the maximum sum.\n3. **Memoization**: To avoid redundant calculations, we store results of subproblems using memoization. This significantly reduces the time complexity by ensuring each state is computed only once.\n\n### Solution Code\n```python\nimport sys\nimport functools\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    total_length = 2 * n\n\n    @functools.lru_cache(maxsize=None)\n    def dp(k, h):\n        if k == total_length:\n            return (0, \"\")\n        # Current digit is A[k]\n        current_digit = int(A[k])\n        # Possible choices: H or M\n        max_sum = -1\n        best_choice = \"\"\n        # Try choosing H\n        if h < n:\n            new_h = h + 1\n            remaining_m = (k + 1) - new_h\n            if remaining_m <= n:\n                next_sum, next_choice = dp(k + 1, new_h)\n                total = current_digit * (10 ** (n - new_h)) + next_sum\n                if total > max_sum:\n                    max_sum = total\n                    best_choice = \"H\" + next_choice\n        # Try choosing M\n        m_count = (k + 1) - h\n        if m_count < n:\n            new_m = m_count + 1\n            next_sum, next_choice = dp(k + 1, h)\n            total = current_digit * (10 ** (n - (k + 1 - h))) + next_sum\n            if total > max_sum:\n                max_sum = total\n                best_choice = \"M\" + next_choice\n        return (max_sum, best_choice)\n\n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Recursive Function with Memoization**: The function `dp(k, h)` computes the maximum total sum achievable from the `k`-th digit onwards, with `h` being the number of moves Homer has made so far.\n3. **Digit Contribution Calculation**: When a digit is chosen by Homer or Marge, its contribution to the total sum is calculated based on its position in their respective numbers. This is done using powers of 10 to account for the positional value.\n4. **Memoization**: The `lru_cache` decorator is used to memoize the results of subproblems, ensuring efficient reuse of computed states and avoiding redundant calculations.\n\nThis approach ensures that we explore all possible move sequences efficiently, leveraging dynamic programming and memoization to handle the constraints effectively.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport functools\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    total_length = 2 * n\n\n    @functools.lru_cache(maxsize=None)\n    def dp(k, h):\n        if k == total_length:\n            return (0, \"\")\n        # Current digit is A[k]\n        current_digit = int(A[k])\n        # Possible choices: H or M\n        max_sum = -1\n        best_choice = \"\"\n        # Try choosing H\n        if h < n:\n            new_h = h + 1\n            remaining_m = (k + 1) - new_h\n            if remaining_m <= n:\n                next_sum, next_choice = dp(k + 1, new_h)\n                total = current_digit * (10 ** (n - new_h)) + next_sum\n                if total > max_sum:\n                    max_sum = total\n                    best_choice = \"H\" + next_choice\n        # Try choosing M\n        m_count = (k + 1) - h\n        if m_count < n:\n            new_m = m_count + 1\n            next_sum, next_choice = dp(k + 1, h)\n            total = current_digit * (10 ** (n - (k + 1 - h))) + next_sum\n            if total > max_sum:\n                max_sum = total\n                best_choice = \"M\" + next_choice\n        return (max_sum, best_choice)\n\n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 426,
        "completion_token_count": 756,
        "thoughts_token_count": 1024
    }
}