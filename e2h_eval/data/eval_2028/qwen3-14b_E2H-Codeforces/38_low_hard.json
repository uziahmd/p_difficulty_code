{
    "start": 1758309358.7567852,
    "end": 1758309396.5875998,
    "start-formatted": "2025-09-20 04:15 KST",
    "end-formatted": "2025-09-20 04:16 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to tackle this problem. Hmm, the problem is about finding the minimum number of nodes required for a p-reachable directed graph and then determining the maximum number of unidirectional pairs in such graphs. \n\nFirst, let's understand what a p-reachable graph is. The definition says that it has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So, for each such pair, both directions must be reachable. Wait no, wait: the problem says \"u and v are reachable from each other.\" So that implies that there's a path from u to v and from v to u. Therefore, each such pair contributes one to the count of p. And the problem wants exactly p such pairs.\n\nThe first part is to find the minimal number of nodes needed to have exactly p such pairs. Then, among all such graphs with that minimal number of nodes, find the maximum number of unidirectional pairs. \n\nLet me think about how to model this. \n\nLet's think about the structure of the graph. For the minimal number of nodes, we probably need to maximize the number of such mutual reachability pairs per node. \n\nWait, but how do we count the mutual pairs? Let's consider that if we have a set of nodes where all are mutually reachable (like a strongly connected component), then every pair (u, v) where u < v in that component contributes to the p count. So, for a component of size k, the number of such pairs is C(k, 2) = k*(k-1)/2. \n\nSo, perhaps the minimal number of nodes is achieved by combining several such components. Because if we have multiple strongly connected components (SCCs), then the mutual reachability pairs are only within each component. \n\nBut the problem requires that the total number of mutual pairs is exactly p. So, the idea is to split p into sums of C(k_i, 2), where each k_i is the size of a component, and the sum of all k_i is the total number of nodes. We need to minimize the sum of k_i, given that the sum of C(k_i, 2) equals p. \n\nAh, right! So the problem reduces to decomposing p into a sum of combinations C(k_i, 2), such that the sum of k_i is minimized. Because each component contributes C(k_i, 2) mutual pairs. \n\nSo, for example, if p is 3, then C(3, 2) is 3, which gives us exactly 3 pairs with 3 nodes. Hence the minimal number of nodes is 3. \n\nBut if p is 4, then C(3, 2) is 3, and we need one more. How can we get that? Well, maybe we have two components: one of size 3 (contributing 3) and another of size 2 (contributing 1). Total sum is 3 + 2 = 5 nodes. But is there a better way? Let's see: C(4, 2) is 6, which is larger than 4. So maybe using a component of size 3 (3) and a component of size 2 (1) gives total 4. So the minimal number of nodes is 3+2=5. Which matches the sample input where for p=4, the output is 5. \n\nSo the first part of the problem is to find the minimal number of nodes by splitting p into a sum of C(k_i, 2), and choosing the decomposition that minimizes the sum of k_i. \n\nNow, how to find that decomposition?\n\nThe optimal way to minimize the sum of k_i for a given sum of C(k_i, 2) is to use as large components as possible. Because for a given value of C(k, 2), the larger k is, the smaller the sum of k_i. Wait, no. Let me think. For example, if I have two components contributing to the same total. Suppose I have two components of size 3 and 3. Their sum is 6, and their contribution is 3 + 3 = 6. Alternatively, if I have one component of size 4, which contributes C(4, 2) = 6. The sum of k_i is 4, which is smaller than 6. Therefore, to minimize the sum of k_i, we should use as large components as possible. \n\nThus, the strategy is to find the largest possible k such that C(k, 2) ≤ remaining p, subtract it, and proceed recursively. But wait, perhaps there's a better way. For example, if we have p=4, the best decomposition is 3 + 1 (C(3,2)=3, C(1,2)=0, but that would give 3+1=4",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This can be modeled using strongly connected components (SCCs), where each component contributes a certain number of mutual reachability pairs.\n2. **Decomposition Strategy**: The key insight is to decompose `p` into sums of combinations of the form C(k, 2) (which is k*(k-1)/2) to minimize the total number of nodes. Larger components contribute more mutual pairs with fewer nodes, so we use the largest possible components first.\n3. **Unidirectional Pairs Calculation**: Once the minimum number of nodes is determined, we calculate the maximum number of unidirectional pairs by considering the structure of the graph formed by the components.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find minimal number of nodes\n    nodes = 0\n    remaining = p\n    while remaining > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining\n        k = 1\n        while k*(k-1)//2 <= remaining:\n            k += 1\n        k -= 1\n        nodes += k\n        remaining -= k*(k-1)//2\n    \n    # Now compute the maximum number of unidirectional pairs\n    # We need to consider the structure of the components\n    # Let's collect the sizes of the components used in the decomposition\n    components = []\n    remaining = p\n    while remaining > 0:\n        k = 1\n        while k*(k-1)//2 <= remaining:\n            k += 1\n        k -= 1\n        components.append(k)\n        remaining -= k*(k-1)//2\n    \n    # Now, the maximum number of unidirectional pairs is computed as follows:\n    # For each pair of components (a, b), if a is before b in the decomposition, then all pairs (u, v) where u is in a and v is in b contribute 1 unidirectional pair if there is a directed edge from a to b.\n    # To maximize the number of unidirectional pairs, we should arrange the components in a linear chain, where each component points to all subsequent components.\n    # The total number of such pairs is sum_{i < j} (size_i * size_j)\n    # Because for each pair of components, all nodes in the earlier component can reach all nodes in the later component, but not vice versa.\n    \n    # So, we need to compute the sum of products of sizes of all pairs of components\n    total_unidirectional = 0\n    sum_so_far = 0\n    for comp in components:\n        total_unidirectional += comp * sum_so_far\n        sum_so_far += comp\n    \n    print(f\"{nodes} {total_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Minimum Nodes Calculation**: The code decomposes `p` into the sum of combinations C(k, 2) using the largest possible values of `k` to minimize the total number of nodes. This is done iteratively by finding the largest `k` such that C(k, 2) does not exceed the remaining value of `p`.\n2. **Unidirectional Pairs Calculation**: After determining the component sizes, the code calculates the maximum number of unidirectional pairs by considering the sum of products of sizes of all pairs of components. This is achieved by arranging components in a linear chain where each component points to all subsequent components, maximizing the unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find minimal number of nodes\n    nodes = 0\n    remaining = p\n    while remaining > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining\n        k = 1\n        while k*(k-1)//2 <= remaining:\n            k += 1\n        k -= 1\n        nodes += k\n        remaining -= k*(k-1)//2\n    \n    # Now compute the maximum number of unidirectional pairs\n    # We need to consider the structure of the components\n    # Let's collect the sizes of the components used in the decomposition\n    components = []\n    remaining = p\n    while remaining > 0:\n        k = 1\n        while k*(k-1)//2 <= remaining:\n            k += 1\n        k -= 1\n        components.append(k)\n        remaining -= k*(k-1)//2\n    \n    # Now, the maximum number of unidirectional pairs is computed as follows:\n    # For each pair of components (a, b), if a is before b in the decomposition, then all pairs (u, v) where u is in a and v is in b contribute 1 unidirectional pair if there is a directed edge from a to b.\n    # To maximize the number of unidirectional pairs, we should arrange the components in a linear chain, where each component points to all subsequent components.\n    # The total number of such pairs is sum_{i < j} (size_i * size_j)\n    # Because for each pair of components, all nodes in the earlier component can reach all nodes in the later component, but not vice versa.\n    \n    # So, we need to compute the sum of products of sizes of all pairs of components\n    total_unidirectional = 0\n    sum_so_far = 0\n    for comp in components:\n        total_unidirectional += comp * sum_so_far\n        sum_so_far += comp\n    \n    print(f\"{nodes} {total_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 843,
        "thoughts_token_count": 1024
    }
}