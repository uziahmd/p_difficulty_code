{
    "start": 1758309735.3404348,
    "end": 1758309778.0687718,
    "start-formatted": "2025-09-20 04:22 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if there's a way to assign mushroom counts to each lawn such that for every given edge (road), the GCD and LCM of the two connected lawns match the given values. If possible, output one such assignment; else, output NO.\n\nFirst, let's understand the problem. Each road connects two lawns, say u and v. For that road, we have a GCD value g and an LCM value l. The mushroom counts on u and v must satisfy gcd(a_u, a_v) = g and lcm(a_u, a_v) = l. \n\nBut how do I relate a_u and a_v with these values? Well, I remember that for two numbers, the product of their GCD and LCM is equal to the product of the numbers themselves. So, a_u * a_v = g * l. Also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: Let's denote a_u = g * x and a_v = g * y. Then, the GCD of a_u and a_v is g * gcd(x, y). But since the given GCD is g, that implies that gcd(x, y) must be 1. Also, the LCM of a_u and a_v is g * lcm(x, y). But since the given LCM is l, then g * lcm(x, y) = l. Which implies that lcm(x, y) = l / g. However, since x and y are coprime, their LCM is x * y. Therefore, x * y = l / g. \n\nSo putting it all together: For each edge between u and v with GCD g and LCM l, we must have that a_u = g * x, a_v = g * y, where x and y are coprime and x*y = l/g. \n\nBut wait, l must be a multiple of g, right? Because LCM(a_u, a_v) is a multiple of GCD(a_u, a_v). So if the input has a case where l is not a multiple of g, then it's impossible. So first thing to check: for each edge, check if l % g != 0. If that's the case, output NO.\n\nSo that's the first check. For example, if in the input, there's a road with GCD 3 and LCM 7, then since 7 isn't divisible by 3, it's invalid. So in that case, the answer is NO.\n\nOnce that's checked, for each edge, we can compute the product x*y = (l/g). And since x and y are coprime, we can assign x and y as factors of (l/g) that are coprime. However, for the problem, we don't need to find x and y explicitly. Instead, we need to model the relationships between the nodes.\n\nNow, the problem becomes similar to building a graph where each node's value is determined by the edges. But how?\n\nLet me think of each node's value as being a multiple of some base value. For example, if two nodes are connected by an edge with GCD g and LCM l, then their values are g*x and g*y, with x and y coprime and x*y = l/g. So for each edge, we can model the relationship between u and v as requiring that their values are multiples of g, and that their ratio (in terms of x and y) satisfies the conditions.\n\nBut how to model this across the entire graph? It seems like a constraint satisfaction problem. Maybe we can model this as a graph where each node's value is determined by a product of certain factors, and we need to assign values such that all constraints are satisfied.\n\nAlternatively, considering that for each edge, the two nodes must have values that are multiples of the GCD. So, perhaps we can model this as a graph where each node's value is determined relative to others. For example, if we have a connected component, then all nodes in that component must have their values as multiples of some base value. But how to find that?\n\nWait, here's an idea. For each connected component in the graph, we can assign a value to one node and then derive the values of others based on the edges. But how?\n\nLet me consider that for any two connected nodes u and v, their values a_u and a_v must satisfy that a_u / g and a_v / g are coprime and their product is l/g. Let me denote k = l/g. Then x*y = k, and gcd(x,y) = 1. Therefore, x and y are coprime factors of k. So, for each edge, the pair (x, y) must be such that x divides k and y divides k",
    "response": "```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    values = [-1] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        values[start] = 1\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if values[v] == -1:\n                    k = l // g\n                    # Since a_u = g * x, a_v = g * y, x*y = k, gcd(x,y)=1\n                    # We can assign x and y as any pair with x*y=k and coprime\n                    # For simplicity, we can assign x=1 and y=k, but need to check if it's compatible\n                    # However, since we have to assign values based on the connected component, we need to find a way\n                    # Let's use the current value of u to determine v's value\n                    # a_u = g * x, a_v = g * y, where x*y = k and gcd(x,y)=1\n                    # So, a_v must be g * y, and since a_u is known, we can compute y = (a_u / g) * y' ?\n                    # Wait, let's think again:\n                    # We have a_u = g * x, a_v = g * y\n                    # x * y = k\n                    # Also, gcd(x, y) = 1\n                    # So from a_u, we can get x = a_u / g\n                    # Then y = k / x\n                    # So a_v = g * (k / x) = g * (l/g / x) = l / x\n                    # But x is a_u / g\n                    # Therefore, a_v = l / (a_u / g) = (g * l) / a_u\n                    # So, a_v = (g * l) / a_u\n                    # But this only works if a_u divides g*l\n                    # Wait, but since a_u is g*x, then g*l = g * (g * x * y) = g^2 * x * y. Hmm, maybe not.\n                    # Let me re-derive:\n                    # a_u * a_v = g * l\n                    # So, a_v = (g * l) / a_u\n                    # So, given a_u, we can compute a_v as (g*l)/a_u\n                    # But we need to ensure that this value is integer, which it should be because a_u and a_v are multiples of g\n                    # So, for the BFS approach, once we have a_u, we can compute a_v as (g*l) / a_u\n                    # But this requires that a_u divides g*l\n                    # Which it should, since a_u is g*x, and g*l = g*(g*x*y) = g^2 x y. So a_u divides g*l?\n                    # Wait, a_u is g*x, and g*l = g * (g * x * y) = g^2 x y. So yes, a_u divides g*l.\n                    # Because (g^2 x y) / (g x) = g y, which is integer.\n                    # So this formula is valid.\n                    a_u_val = values[u]\n                    a_v_val = (g * l) // a_u_val\n                    values[v] = a_v_val\n                    queue.append(v)\n                else:\n                    # Check consistency\n                    a_u_val = values[u]\n                    a_v_val = values[v]\n                    if math.gcd(a_u_val, a_v_val) != g or (a_u_val * a_v_val) != g * l:\n                        return False\n        return True\n\n    for i in range(n):\n        if values[i] == -1:\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    values = [-1] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        values[start] = 1\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if values[v] == -1:\n                    k = l // g\n                    # Since a_u = g * x, a_v = g * y, x*y = k, gcd(x,y)=1\n                    # We can assign x and y as any pair with x*y=k and coprime\n                    # For simplicity, we can assign x=1 and y=k, but need to check if it's compatible\n                    # However, since we have to assign values based on the connected component, we need to find a way\n                    # Let's use the current value of u to determine v's value\n                    # a_u = g * x, a_v = g * y, where x*y = k and gcd(x,y)=1\n                    # So, a_v must be g * y, and since a_u is known, we can compute y = (a_u / g) * y' ?\n                    # Wait, let's think again:\n                    # We have a_u = g * x, a_v = g * y\n                    # x * y = k\n                    # Also, gcd(x, y) = 1\n                    # So from a_u, we can get x = a_u / g\n                    # Then y = k / x\n                    # So a_v = g * (k / x) = g * (l/g / x) = l / x\n                    # But x is a_u / g\n                    # Therefore, a_v = l / (a_u / g) = (g * l) / a_u\n                    # So, a_v = (g * l) / a_u\n                    # But this only works if a_u divides g*l\n                    # Wait, but since a_u is g*x, then g*l = g * (g * x * y) = g^2 * x * y. Hmm, maybe not.\n                    # Let me re-derive:\n                    # a_u * a_v = g * l\n                    # So, a_v = (g * l) / a_u\n                    # So, given a_u, we can compute a_v as (g*l)/a_u\n                    # But we need to ensure that this value is integer, which it should be because a_u and a_v are multiples of g\n                    # So, for the BFS approach, once we have a_u, we can compute a_v as (g*l) / a_u\n                    # But this requires that a_u divides g*l\n                    # Which it should, since a_u is g*x, and g*l = g*(g*x*y) = g^2 x y. So a_u divides g*l?\n                    # Wait, a_u is g*x, and g*l = g * (g * x * y) = g^2 x y. So yes, a_u divides g*l.\n                    # Because (g^2 x y) / (g x) = g y, which is integer.\n                    # So this formula is valid.\n                    a_u_val = values[u]\n                    a_v_val = (g * l) // a_u_val\n                    values[v] = a_v_val\n                    queue.append(v)\n                else:\n                    # Check consistency\n                    a_u_val = values[u]\n                    a_v_val = values[v]\n                    if math.gcd(a_u_val, a_v_val) != g or (a_u_val * a_v_val) != g * l:\n                        return False\n        return True\n\n    for i in range(n):\n        if values[i] == -1:\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 1029,
        "thoughts_token_count": 1024
    }
}