{
    "start": 1758308363.0308657,
    "end": 1758308538.0150757,
    "start-formatted": "2025-09-20 03:59 KST",
    "end-formatted": "2025-09-20 04:02 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about how to approach this. Let's first understand what's happening here. Since both a and b are being added to k, the two numbers we're considering are x = a +k and y = b +k. But since k is the same for both, the difference between x and y is fixed. Let me compute that difference. Let's say a and b are given. Let's assume a < b for example. Then, when we add k to both, the difference between x and y is (b - a). So, the difference between the two numbers is fixed as (b - a) if a < b. Wait, no. Wait, if a and b are given, then the difference between (a +k) and (b +k) is (a -b) or (b -a) depending on which is bigger. So, the difference between the two numbers is fixed as |a - b|. Because adding the same k to both doesn't change their difference.\n\nSo, the problem reduces to finding two numbers x and y, where x and y differ by d = |a - b|, and their LCM is minimized. And then find the k that leads to this x and y. Because x = a +k, y = b +k. So, if we can find x and y with minimal LCM, then k would be x -a (since x = a +k => k = x -a). But since x and y differ by d, we can model this as x and x +d (assuming d is positive, say a < b, then d = b -a, and y = x +d). Or if a > b, then it's x = a +k, y = b +k, and x - y = a -b = d. So in any case, the two numbers are x and x +d, where d is the absolute difference between a and b. Wait, no. Wait, if a is 6 and b is 10, then d is 4. So x = 6 +k, y = 10 +k. Then y -x is 4. So the two numbers are x and x +d, where d is the difference between a and b. So, the problem becomes: find x such that LCM(x, x +d) is minimized, and then find the corresponding k.\n\nSo the key here is to find x such that LCM(x, x +d) is as small as possible. Then, once x is found, k is x - a (if a is smaller than b, but need to check).\n\nBut how do we find x?\n\nLet me think about the LCM of x and x +d. The LCM of two numbers can be written as (x * (x +d)) / GCD(x, x +d). Now, since GCD(x, x +d) is the same as GCD(x, d). Because GCD(x, x +d) = GCD(x, d). So, the LCM is (x*(x+d))/GCD(x, d).\n\nSo, our problem reduces to minimizing (x*(x +d))/g, where g is GCD(x, d). Let me denote d as the absolute difference between a and b. Let me call d = |a - b|. So, the problem is to find x such that the above expression is minimized. Then, once we find x, k is x - a if a < b, or x - b if a > b? Wait, no. Let me think again. Suppose a is 6 and b is 10. Then d is 4. For x = 8 (so k = 2), then x is a +k = 8, and y = 10 + 2 = 12. So x is 8, and y is x + d (since d = 4). So yes, in this case, the two numbers are x and x +d. So, the problem becomes finding x such that LCM(x, x +d) is minimized. Once we find x, then k is x - a. Because a +k = x => k = x -a. But if a is larger than b, then d = a -b, and the numbers would be x and x -d? No, because in that case, if a is larger than b, then the difference is d = a -b. Then, when you add k to both, you have (a +k) and (b +k). So the difference between them is (a -b) = d. So, if a is larger than b, then (a +k) is larger than (b +k) by d. So, the two numbers are x and x -d, where x is (a +k). Wait, no. Let me take an example. Suppose a is 10 and b is 6. Then d is 4. Then (a +k) = 10 +k, (b +k) = 6 +k. The difference is 4. So the two numbers are (b +k) +d = 6 +k +4 = 10 +k. So, the two numbers are (b +k) and (b +k) +d. So regardless of which is larger between a and b, the two numbers can be considered as x and x +d, where x is the smaller of the two numbers. So, in all cases, the problem reduces to finding x such that LCM(x, x +d) is minimized, where d is the absolute difference between a and b.\n\nTherefore, the problem is now: find x ≥ 0 (since k is non-negative, so x must be ≥ a if a is the original value, but wait, no. Because if a is 6 and b is 10, then x is (a +k) which can be any number ≥ a (since k ≥0). But if a is larger than b, then x is (b +k) which could be smaller than a. Wait, no. Let me think again. Let me suppose that d = |a -b|. Let me assume that a ≤ b. Then, d = b -a. Then, the two numbers are (a +k) and (b +k) = (a +k) +d. So, x = a +k. So x can be any value ≥ a (since k ≥0). So, the problem is to find x ≥ a (if a ≤b) such that LCM(x, x +d) is minimized. Similarly, if a >b, then d = a -b, and the two numbers are (b +k) and (b +k) +d. So x = b +k ≥b. So in general, x is the smaller of the two numbers, and x can be any value ≥ min(a, b). Wait, but if a and b are equal, then d is zero. Then, the two numbers are x and x. So their LCM is x. So to minimize that, x should be as small as possible. Which would be x = min(a, b) + 0 = a (since a =b). So k =0. That's the case when a =b. So the answer is 0.\n\nSo, for the general case, assuming d is not zero. Let's proceed.\n\nSo the problem is to find x ≥ m (where m is min(a, b)) such that LCM(x, x +d) is minimized. Then, the corresponding k is x - m. Because m is min(a, b). For example, if a=6, b=10, m=6. x is 6 +k. So k =x -6. So, the problem is to find x ≥ m such that LCM(x, x +d) is minimized.\n\nNow, how to find such x?\n\nLet me think about the LCM formula again. LCM(x, x +d) = x*(x +d)/gcd(x, x +d) = x*(x +d)/g, where g = gcd(x, x +d) = gcd(x, d). So, the LCM depends on the gcd of x and d.\n\nLet me denote g = gcd(x, d). Then, since x and x +d have the same gcd as x and d. So, for each possible divisor of d, perhaps we can find x such that the gcd is maximized, which would minimize the LCM.\n\nBecause, for fixed x and d, the LCM is x*(x +d)/g. So, the larger the g, the smaller the LCM. Therefore, to minimize the LCM, we want to maximize the value of g, which is gcd(x, d).\n\nSo, perhaps the optimal x is such that x is a multiple of some divisor of d. Let me think.\n\nLet me consider that d is fixed. Let's say d is fixed. Then, for each divisor g of d, we can find x such that gcd(x, d) = g. Then, x must be a multiple of g, and x/g must be coprime with d/g. Because if x = g * m, then d = g * n, where n is d/g. Then, gcd(g*m, g*n) = g * gcd(m, n). So, to have this equal to g, we need that gcd(m, n) = 1. So, m and n must be coprime.\n\nIn that case, the LCM(x, x +d) would be (g*m * (g*m + g*n )) / g = g*m * (g(m +n )) /g = g*m * g(m +n) /g = g*m * (m +n) ?\n\nWait, let's re-calculate:\n\nx = g*m\n\nx +d = g*m + g*n = g*(m +n)\n\nSo, LCM(x, x +d) = LCM(gm, g(m +n)) = g * LCM(m, m +n) \n\nBut since m and m +n are consecutive terms, their gcd is gcd(m, m +n) = gcd(m, n). But since m and n are coprime (because earlier we had that m and n are coprime?), wait, no. Wait, in the case where x = g*m, and d = g*n, then the gcd(x, d) is g * gcd(m, n). We wanted that to be equal to g, so that implies that gcd(m, n) must be 1. Therefore, m and n are coprime.\n\nSo, since m and n are coprime, then m and m +n are coprime? Well, let's see. Let me think of m and m +n. Let me take a common divisor of m and m +n. Let it be k. Then k divides m and m +n. So, it divides (m +n) - m = n. So, k divides m and n. But since m and n are coprime, the only possible k is 1. Therefore, m and m +n are coprime. Thus, LCM(m, m +n) = m*(m +n). Therefore, the overall LCM is g * m * (m +n). \n\nBut since d = g *n, then n = d/g. So, substituting, the LCM is g * m * (m + d/g). \n\nBut x = g*m. Also, since x must be ≥ m (the minimum of a and b). So, m is chosen such that x = g*m ≥ m_min. \n\nSo, for each possible divisor g of d, we can find the minimal possible value of LCM, which is g * m * (m + (d/g)), where m is chosen such that m is coprime with (d/g), and x = g*m ≥ m_min.\n\nBut how to find the optimal m for each g?\n\nWait, for a given g (divisor of d), the minimal value of the LCM would be achieved when m is as small as possible. Because the LCM is g * m * (m + (d/g)). Let me denote t = d/g. So, the expression becomes g * m * (m + t) = g * (m^2 + t m). To minimize this, for fixed t, we need to choose the minimal possible m that satisfies the conditions.\n\nWhat are the conditions for m? m must be ≥ ceil( m_min / g ), since x = g*m ≥ m_min. Also, m must be coprime with t (since t = d/g, and m must be coprime with t to ensure that the gcd(x, d) = g).\n\nWait, earlier steps said that for x = g*m, and d = g*t, then m and t must be coprime. So, for each divisor g of d, we can look at t = d/g. Then, m must be coprime with t, and m ≥ m_min/g (rounded up, since x = g*m must be ≥ m_min).\n\nSo, for each such g, the minimal m is the minimal integer ≥ (m_min / g) that is coprime with t.\n\nOnce we find that m, we can compute the LCM for this case and compare it with others.\n\nBut how do we find all possible divisors of d? Well, d can be up to 1e9 (since a and b are up to 1e9, their difference can be up to 1e9). So, the number of divisors is manageable, as even for 1e9, the maximum number of divisors is around 100 (for numbers like 735134400 which has 1344 divisors, but in practice, for most numbers, it's much less).\n\nSo, the plan is:\n\n- Compute d = abs(a -b). If d is zero, then the answer is 0, since LCM(a +k, b +k) = a +k, which is minimized when k=0.\n\n- Else, for all possible divisors g of d, compute the minimal possible LCM for that g, then choose the overall minimal LCM among all possibilities.\n\nBut how to generate all the divisors of d?\n\nWell, first, find all the divisors of d. Then, for each divisor g of d, compute t = d/g. Then, find the minimal m ≥ m_min/g (ceiling division?) that is coprime with t. Then compute the LCM for this case.\n\nWait, but m must be such that x = g*m ≥ m_min. So m ≥ ceil(m_min / g) ?\n\nWait, m_min is the minimum of a and b. Let's call m_min = min(a, b). So, x = g*m must be ≥ m_min. So m ≥ ceil( m_min / g ) ?\n\nNo, because m can be a real number. But since m must be integer, m ≥ ceil( m_min / g ) ?\n\nFor example, if m_min is 6, and g is 2, then x must be ≥6. So g*m ≥6 → m ≥ 3. So m ≥3. So yes, m is ≥ ceil( m_min / g ). Wait, 6/2 is exactly 3. So ceil is 3.\n\nAnother example: m_min is 7, g is 2. Then 7/2 is 3.5, so m must be ≥4. So m starts at 4.\n\nSo, m is the minimal integer ≥ ceil(m_min / g) that is coprime with t.\n\nOnce that m is found, then the LCM for this case is g * m * (m + t) = g * m * (m + d/g). \n\nOnce we have all these possible LCMs for each divisor g of d, we can find the minimal one, and then among those, select the minimal k.\n\nBut wait, there's another case. What if the minimal LCM is achieved when x is such that x and x +d are coprime? Then, the LCM is x*(x +d). But that's covered by the case where g is 1, since g is a divisor of d. So, if d is 4, then 1 is a divisor. So, for g=1, t =4/1=4. Then, m must be coprime with 4. So, m is the minimal integer ≥ m_min /1 that is coprime with 4. Which is the first m ≥ m_min that is coprime with 4.\n\nSo, the plan seems feasible.\n\nSo, the steps are:\n\n1. Compute d = abs(a -b). If d is zero, return 0.\n\n2. Else, compute m_min = min(a, b).\n\n3. Find all divisors of d.\n\n4. For each divisor g of d:\n\n   a. Compute t = d / g.\n\n   b. Find the minimal m ≥ m_min / g (ceil) such that gcd(m, t) = 1.\n\n   c. Compute candidate x = g * m.\n\n   d. Compute the LCM for this x: LCM(x, x +d) = g*m*(m + t) ?\n\n   Wait, earlier calculation said that LCM(x, x +d) = g * m * (m + t) ?\n\nYes, since x = gm, x +d = gm + g t = g (m + t). And since m and t are coprime, then LCM(x, x +d) is g * m * (m +t).\n\nSo, for each such candidate, compute this value.\n\n5. After considering all divisors, find the candidate x (and thus k) that gives the minimal LCM. If multiple candidates have the same LCM, choose the one with the smallest k.\n\nBut how to find the minimal m for each g and t?\n\nFor example, given t and a lower bound for m (let's call it m_low = ceil(m_min /g)), find the smallest m ≥ m_low such that gcd(m, t) = 1.\n\nHow can we compute this efficiently?\n\nWell, for a given t and m_low, we can check m starting from m_low upwards until we find one that is coprime with t. Since t can be up to d/g, and d can be up to 1e9, but for each case, the number of checks is small. Because for example, if t is even, then m_low could be even, but m_low +1 may be odd. So, the first m that is coprime with t is within m_low, m_low +1, m_low +2, etc. Since the worst case is when t is 1, which is coprime with all m. So, the minimal m is m_low.\n\nSo, for each g, the process is:\n\nCompute m_low = ceil(m_min / g). But how to compute ceil(m_min /g)?\n\nIn Python, ceil can be done as (m_min + g -1) // g.\n\nOnce m_low is computed, iterate m starting from m_low upwards, and check if gcd(m, t) ==1. The first such m is the minimal one for this g.\n\nOnce that m is found, the candidate x is g*m. Then, the k is x - m_min, since x = a +k if a was the m_min, or x = b +k if b was the m_min. Wait, m_min is min(a, b). So, for example, if a is 6 and b is 10, m_min is 6. So x = a +k = 6 +k. So k = x -6. So, once we find x, the k is x - m_min.\n\nBut what if m_min is a and the x is a +k. So yes, k = x - m_min.\n\nSo, once we find x, the k is x - m_min.\n\nNow, after generating all possible candidates for each divisor, we can collect all (k_candidate, lcm_candidate) pairs, and select the one with the minimal lcm_candidate. If there are multiple, choose the smallest k_candidate.\n\nBut there's also another possibility: maybe the optimal x is not generated by any of the divisors. Wait, but according to our previous reasoning, the optimal x must be such that g is a divisor of d, because we are trying to maximize the gcd(x, d) which is g. So, for each possible g (divisor of d), we are checking the best possible x for that g. Hence, the minimal LCM must be among these candidates.\n\nBut why? Because for any x, the g = gcd(x, d) is a divisor of d. So, for every x, there exists a divisor of d (namely g) for which the x is part of the case considered in the above steps. Therefore, considering all divisors of d covers all possibilities.\n\nThus, the approach is correct.\n\nNow, the next step is to implement this.\n\nBut first, how to find all the divisors of d?\n\nWe can find all the divisors of d by factorizing d, but for numbers up to 1e9, trial division is feasible.\n\nAlternatively, we can generate all divisors by checking up to sqrt(d). Let me write a function to generate all divisors of d.\n\nOnce we have all divisors, for each divisor g, we process it as described.\n\nBut wait, the divisors can be generated in any order. However, for each divisor g, we need to process it. Also, note that for each divisor g of d, the same t can be generated for different g's.\n\nBut for the code, we can generate all the divisors of d, including all possible ones.\n\nNow, let's think about the example given in the problem.\n\nFirst example input: 6 10. d = 4. m_min is 6.\n\nDivisors of 4 are 1, 2, 4.\n\nProcessing each:\n\nFor g =1:\n\nt =4/1 =4.\n\nm_low = ceil(6/1) =6.\n\nCheck m starting from 6. Check if gcd(6,4) is 1? 6 and 4 have gcd 2. Not 1. Next m=7. gcd(7,4)=1. So m=7. x =1*7=7. k =7 -6 =1. LCM is 7*(7+4) / gcd(7,4) = 7*11 / 1 =77. But the sample answer is k=2, which gives x=8, y=12. LCM is 24.\n\nSo why is this case not considered?\n\nAh, because for g=4, which is a divisor of 4.\n\nLet's check for g=4.\n\nt =4/4 =1. m_low = ceil(6/4) = 2. Because 6/4 is 1.5, ceil is 2. Now, check m starting at 2. Check if gcd(2, 1) is 1. Since 1 is coprime with all numbers. So m=2. x =4*2=8. k =8-6=2. Which is the correct case. The LCM is 8*12 /4 = 24.\n\nSo, this case is considered. So, for the divisors, the code would generate this candidate.\n\nSimilarly, for g=2. t =4/2=2. m_low = ceil(6/2) =3. Check m starting from 3. Check gcd(3,2)=1. Yes. So m=3. x=2*3=6. k=6-6=0. Then, the LCM is 6 * (6 + 4) / gcd(6,4) = 6 * 10 / 2 = 30. Which is higher than 24. So the minimal LCM is 24, achieved by the case of g=4.\n\nSo, the code would find the minimal LCM.\n\nSo, the approach works.\n\nAnother example is when a=5 and b=10. Then d=5. m_min=5. Divisors of 5 are 1,5.\n\nFor g=5, t=5/5=1. m_low=ceil(5/5)=1. m=1. x=5*1=5. k=5-5=0. LCM(5, 5+5=10) is 10. Which is the correct answer.\n\nSo, the code would output 0, which matches the sample.\n\nAnother sample input is 21 and 31. d=10. m_min=21. Divisors of 10 are 1,2,5,10.\n\nFor each divisor:\n\ng=1:\n\nt=10. m_low=21. Check if 21 and 10 are coprime. gcd(21,10)=1. So m=21. x=21. k=0. LCM(21, 21+10=31) is 21*31=651.\n\ng=2:\n\nt=5. m_low=ceil(21/2)=11. Check m=11. gcd(11,5)=1. x=2*11=22. k=22-21=1. LCM(22, 32) = 22*32 / 2 = 352. Which is better than 651.\n\ng=5:\n\nt=2. m_low=ceil(21/5) =5. Check m=5. gcd(5,2) is 1. x=5*5=25. k=25-21=4. LCM(25, 25+10=35) is 25*35 /5 = 175. Which is better.\n\ng=10:\n\nt=1. m_low=ceil(21/10)=3. Check m=3. gcd(3,1)=1. x=10*3=30. k=30-21=9. LCM(30,40) is 120. Which is better than 175.\n\nSo the minimal LCM is 120, achieved with k=9, which matches the sample.\n\nSo, the approach works.\n\nNow, the code steps.\n\nImplementing this in Python.\n\nFirst, handle the case when a ==b. Then output 0.\n\nElse, compute d = abs(a -b), m_min = min(a, b).\n\nGenerate all the divisors of d.\n\nFor each divisor g of d:\n\n   t = d //g\n\n   m_low = ceil(m_min /g) → (m_min + g -1) //g\n\n   find the minimal m ≥ m_low such that gcd(m, t) ==1.\n\n   once found, compute x =g*m.\n\n   compute k_candidate = x - m_min.\n\n   compute the LCM_candidate = (x * (x +d)) // gcd(x, x +d). But since x and x +d have gcd equal to g, which is the same as gcd(x, d) =g. So, LCM_candidate = x*(x +d)/g.\n\nBut since x =g*m, x +d =g*m +d =g*m +g*t =g*(m +t). So LCM_candidate = (g*m * g*(m +t)) / g = g*m*(m +t). Which is same as g*m*(m + t).\n\nBut for code, perhaps it's easier to compute it as (x * (x +d)) // gcd(x, x +d). But since we already know that the gcd is g, perhaps we can use that formula.\n\nBut for code, perhaps it's easier to compute the LCM_candidate as (x * (x +d)) // math.gcd(x, x +d).\n\nBut for code, perhaps it's better to compute it as (g * m * (m + t)).\n\nEither way, but for code, perhaps the first approach is easier.\n\nBut for the code, once we find x and d, we can compute the LCM.\n\nBut since in the code, for each candidate, we can compute the LCM_candidate, and then compare all of them.\n\nOnce all candidates are generated, select the one with the minimal LCM_candidate. If there are multiple, select the one with the minimal k_candidate.\n\nSo, the code steps:\n\nImplement a function to get all divisors of d.\n\nBut how to generate all divisors of d?\n\nLet me think. For example, for d=4, the divisors are 1, 2, 4.\n\nThe way to generate all divisors is:\n\nInitialize a list. For i from 1 to sqrt(d), check if i divides d. If yes, add i and d//i to the list. Then, after that, remove duplicates and sort.\n\nBut in code, perhaps:\n\ndef get_divisors(d):\n\n    divisors = set()\n\n    for i in range(1, int(math.isqrt(d)) +1):\n\n        if d %i ==0:\n\n            divisors.add(i)\n\n            divisors.add(d//i)\n\n    return sorted(divisors)\n\nBut for d=0? But in the code, when a and b are equal, we return 0. So this case is handled before.\n\nOnce we have all divisors, process each.\n\nNow, for each divisor, generate the candidate k.\n\nOnce all candidates are generated, select the best one.\n\nNow, the code.\n\nBut what about when m_low is 0? Well, m_min is min(a, b) which is ≥1. So, m_low is (m_min +g -1) //g. Since m_min ≥1 and g is a divisor of d, which is ≥1. So m_low is ≥1//g, but since m_min ≥1, and g ≥1, m_low is ≥1.\n\nBut for example, if m_min is 1, and g is 1, then m_low is 1.\n\nSo, the code for finding m is:\n\ndef find_min_m(t, m_low):\n\n    m = m_low\n\n    while True:\n\n        if math.gcd(m, t) ==1:\n\n            return m\n\n        m +=1\n\nBut for large t, this could take time. However, since t can be up to d/g. For example, if d is 1e9, and g is 1, then t is 1e9. Then, m_low could be 1e9. So, checking m=1e9, which may have gcd with t=1e9. Well, for example, if m_low is 1e9 and t is 1e9, then m starts at 1e9. gcd(1e9, 1e9) is 1e9, not 1. Then m increases by 1. So m=1e9+1. gcd(1e9+1, 1e9) is 1. So returns m=1e9+1. So, in this case, the code would take 1 iteration. So, in practice, for each case, the loop will run a few times. So, it's acceptable.\n\nNow, putting it all together.\n\nNow, code steps:\n\nRead a and b.\n\nif a ==b:\n\n    print(0)\n\nelse:\n\n    d = abs(a -b)\n\n    m_min = min(a, b)\n\n    divisors = get_divisors(d)\n\n    candidates = []\n\n    for g in divisors:\n\n        t = d // g\n\n        m_low = (m_min + g -1) // g\n\n        # find minimal m >= m_low with gcd(m, t) ==1\n\n        m = m_low\n\n        while True:\n\n            if math.gcd(m, t) ==1:\n\n                break\n\n            m +=1\n\n        x = g * m\n\n        k_candidate = x - m_min\n\n        lcm_candidate = (x * (x +d)) // math.gcd(x, x +d)\n\n        candidates.append( (lcm_candidate, k_candidate) )\n\n    # find the candidate with minimal lcm, and then minimal k.\n\n    # sort the candidates by lcm, then by k.\n\n    candidates.sort(key=lambda x: (x[0], x[1]))\n\n    print(candidates[0][1])\n\nBut wait, what if there are multiple divisors leading to the same LCM? For example, in some cases, different g's could generate same LCM but different k's. So, the code sorts by lcm and then k, and picks the first.\n\nBut let's test the first example:\n\nFor the first example, the candidates generated would be:\n\nFor g=1:\n\nm_low=6. m=7. x=7. k_candidate=1. lcm_candidate=7*11 /1 =77.\n\nFor g=2:\n\nt=2. m_low=3. m=3. x=6. k_candidate=0. LCM is 6*10 / 2 =30.\n\nFor g=4:\n\nt=1. m_low=2. m=2. x=8. k_candidate=2. LCM is 8*12 /4=24.\n\nSo, the candidates are (77, 1), (30, 0), (24, 2). After sorting, the first is (24, 2), which is correct.\n\nAnother example is the second sample input (21,31) with d=10. The candidates would include for g=10, the (120, 9), which is the correct answer.\n\nSo, the code seems correct.\n\nBut what about the case when there are multiple divisors leading to same LCM?\n\nFor example, let's imagine d=6, m_min=3.\n\nSuppose divisors are 1, 2, 3, 6.\n\nFor g=1: t=6. m_low=3. Check m=3. gcd(3,6)=3 !=1. m=4. gcd(4,6)=2. m=5. gcd(5,6)=1. So x=5*1=5. k_candidate=5-3=2. LCM is 5*11 /1=55.\n\nFor g=2: t=3. m_low=ceil(3/2) =2. Check m=2. gcd(2,3)=1. So x=2*2=4. k_candidate=4-3=1. LCM is 4 * (4+6) / gcd(4, 10) = 4*10 / 2 = 20.\n\nFor g=3: t=2. m_low=ceil(3/3)=1. Check m=1. gcd(1,2)=1. x=3*1=3. k_candidate=0. LCM is 3 * 9 / 3 =9.\n\nFor g=6: t=1. m_low=ceil(3/6)=1. m=1. x=6*1=6. k_candidate=6-3=3. LCM is 6*12 /6 = 12.\n\nSo the candidates are (55, 2), (20,1), (9,0), (12,3). The minimal is 9, which is achieved by k=0. So the code would select that.\n\nBut what if there are two different divisors leading to the same LCM?\n\nFor example, suppose d=4, m_min=2. Let's say a=2, b=6. Then d=4, m_min=2.\n\ndivisors are 1, 2, 4.\n\nFor g=1: t=4. m_low=2. Check m=2. gcd(2,4)=2≠1. m=3. gcd(3,4)=1. x=3*1=3. k_candidate=3-2=1. LCM is 3*7 /1 =21.\n\nFor g=2: t=2. m_low=ceil(2/2)=1. m=1. gcd(1,2)=1. x=2*1=2. k_candidate=0. LCM is 2*6 / 2 =6.\n\nFor g=4: t=1. m_low=ceil(2/4)=1. m=1. x=4*1=4. k_candidate=4-2=2. LCM is 4*8 /4=8.\n\nSo the minimal is 6 (k=0). So code returns 0.\n\nSo, the code works.\n\nNow, code implementation.\n\nBut what about when the divisors are not generated properly? For example, when d=0, but that's handled earlier.\n\nNow, code:\n\nImport math.\n\nBut for the case when d is zero, we return 0.\n\nNow, code:\n\nimport math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) +1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    d = abs(a - b)\n    m_min = min(a, b)\n    divisors = get_divisors(d)\n    candidates = []\n    for g in divisors:\n        t = d // g\n        m_low = (m_min + g -1) // g\n        # find minimal m >= m_low with gcd(m,",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we choose the smallest $ k $.\n\n### Approach\n1. **Special Case Handling**: If $ a $ equals $ b $, the answer is immediately 0 because the LCM of $ a + k $ and $ b + k $ will be $ a + k $, which is minimized when $ k = 0 $.\n\n2. **Difference Calculation**: Calculate the absolute difference $ d $ between $ a $ and $ b $. This difference remains constant for any $ k $, and helps in reducing the problem to finding optimal values based on this difference.\n\n3. **Divisors of Difference**: Generate all divisors of $ d $. These divisors help in determining potential values of $ k $ that might minimize the LCM.\n\n4. **Candidate Evaluation**: For each divisor $ g $ of $ d $, compute the minimum value $ m $ such that $ m $ is coprime with $ \\frac{d}{g} $ and starts from a lower bound derived from $ m_{\\text{min}} $ (the minimum of $ a $ and $ b $). This ensures that the values considered are valid candidates for minimizing the LCM.\n\n5. **Optimal Selection**: Among all candidate values of $ k $, select the one that results in the smallest LCM. If there are ties, choose the smallest $ k $.\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    d = abs(a - b)\n    m_min = min(a, b)\n    divisors = get_divisors(d)\n    candidates = []\n    for g in divisors:\n        t = d // g\n        m_low = (m_min + g - 1) // g\n        m = m_low\n        while True:\n            if math.gcd(m, t) == 1:\n                break\n            m += 1\n        x = g * m\n        k_candidate = x - m_min\n        lcm_candidate = (x * (x + d)) // math.gcd(x, x + d)\n        candidates.append((lcm_candidate, k_candidate))\n    # Sort by LCM, then by k\n    candidates.sort(key=lambda x: (x[0], x[1]))\n    print(candidates[0][1])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Divisors Calculation**: The function `get_divisors` generates all divisors of $ d $, which helps in exploring potential values of $ k $.\n- **Candidate Evaluation**: For each divisor $ g $, we determine the smallest $ m $ such that $ m $ is coprime with $ \\frac{d}{g} $. This ensures that the LCM calculation is optimized.\n- **Optimal Selection**: By evaluating all possible candidates derived from the divisors of $ d $, we ensure that we consider all potential values of $ k $ that could minimize the LCM. The final selection is made based on the smallest LCM and, in case of ties, the smallest $ k $.\n\nThis approach efficiently narrows down the search space using mathematical properties of divisors and GCD, ensuring both correctness and performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    d = abs(a - b)\n    m_min = min(a, b)\n    divisors = get_divisors(d)\n    candidates = []\n    for g in divisors:\n        t = d // g\n        m_low = (m_min + g - 1) // g\n        m = m_low\n        while True:\n            if math.gcd(m, t) == 1:\n                break\n            m += 1\n        x = g * m\n        k_candidate = x - m_min\n        lcm_candidate = (x * (x + d)) // math.gcd(x, x + d)\n        candidates.append((lcm_candidate, k_candidate))\n    # Sort by LCM, then by k\n    candidates.sort(key=lambda x: (x[0], x[1]))\n    print(candidates[0][1])\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 796,
        "thoughts_token_count": 8192
    }
}