{
    "start": 1758346047.1327767,
    "end": 1758346369.965539,
    "start-formatted": "2025-09-20 14:27 KST",
    "end-formatted": "2025-09-20 14:32 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm, the task is to assign directions to each edge in an undirected graph such that the flow conditions are satisfied. The flow must be a maximum flow, and the directed graph should have no cycles. Also, the source (vertex 1) has no incoming edges, and for all other vertices except the sink (vertex n), the inflow equals outflow.\n\nSo, first, I need to understand the constraints. The main thing is that after directing the edges, the flow conservation holds for all intermediate nodes. Also, the directed graph must be acyclic. Oh right, and the flow values are given for each edge, so we just have to assign directions.\n\nLet me think about how to model this. Since the flow is already fixed (the ci values are given), we need to direct the edges such that the flow conservation holds. But how?\n\nWait, the problem says that the flow is a maximum flow. But maybe the actual maximum flow isn't required here, since the ci values are already given as the flow through each edge. So our job is to assign directions to the edges so that the flow is valid and meets the conditions.\n\nBut how do we ensure that the flow is valid? For each node except source and sink, the sum of flows entering equals the sum leaving. Also, the source has no incoming edges, which means all edges connected to it must be directed away from it. Similarly, the sink has all edges directed towards it, but not necessarily. Wait, no. The sink can have outgoing edges, but in the flow, the total outflow from the sink would be zero, but since it's the sink, maybe the flow conservation doesn't apply here.\n\nWait, the problem states that for each vertex v (1 < v < n), the sum of incoming equals sum of outgoing. The source (vertex 1) has no incoming edges, so all edges connected to it must be directed away. The sink (vertex n) has no such restriction, except that the flow must be valid.\n\nSo, the approach is to find a way to direct the edges such that:\n\n- For each node except 1 and n, inflow = outflow.\n- Source 1 has no incoming edges.\n- The directed graph is acyclic.\n\nNow, how to model this. One idea is to model this as a directed acyclic graph (DAG) with certain flow properties. Since the graph must be acyclic, perhaps we can arrange the nodes in a topological order. Then, direct the edges according to this order.\n\nBut how to find such a topological order that also satisfies the flow conservation.\n\nAlternatively, think about the problem as building a DAG where each node (except source and sink) has equal in-flow and out-flow. Let's consider the flow conservation. For each node v (not source or sink), the sum of flows on edges directed into v equals the sum of flows on edges directed out of v. Which implies that the net flow (outflow - inflow) is zero for those nodes. For the source, the net outflow is equal to the total flow (since it has no inflow). For the sink, the net inflow is equal to the total flow.\n\nBut how can we model this? Maybe we can model it as a flow network where each edge's direction is determined based on some potential function. Like, if we assign a potential to each node, then the direction of the edge between u and v is from the node with higher potential to the lower one. But how does this relate to the flow conservation?\n\nAlternatively, think of the flow as a circulation, except for the source and sink. But since the source has no inflow, and the sink has no outflow, perhaps we can model this as a flow problem where the source has a supply of total_flow, and the sink has a demand of total_flow, and other nodes have zero.\n\nWait, but the problem says that the given ci's are part of a maximum flow. So the sum of all flows leaving the source (which is the total flow) must equal the sum of flows entering the sink. However, since the problem gives us the ci's, perhaps we can compute the total flow as the sum of flows from the source's edges. But how?\n\nAlternatively, think of the problem as a directed graph where each edge's direction is chosen such that for each node (other than 1 and n), the sum of ci's on edges going into the node equals the sum of ci's on edges going out. Also, the source has no incoming edges.\n\nThis seems like a problem that can be modeled as a directed graph with certain constraints. But how to find such a direction.\n\nAnother thought: since the graph must be acyclic, perhaps we can construct a DAG where each node except the source has a parent in the DAG. Then, we can assign directions based on the parent relationships.\n\nBut how to ensure flow conservation. Maybe we can model this as a flow network and find a way to assign directions based on the flow.\n\nAlternatively, think of the problem as building a directed tree structure. For example, if we can arrange the nodes in a tree where each node (except the root) has exactly one parent, and the flow is directed from parent to child. But with multiple edges, this might not be possible.\n\nWait, but the graph is connected. So perhaps we can build a DAG by arranging the nodes in a topological order, and for each edge, direct it from the node that comes earlier in the order to the one that comes later. But how to choose the order so that the flow conservation is satisfied.\n\nAlternatively, think of the flow conservation as a system of equations. For each node v (not 1 or n), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. Let me denote for each edge (u, v) with flow c, if it's directed from u to v, then it contributes +c to u's outflow and +c to v's inflow. Otherwise, it contributes +c to v's outflow and +c to u's inflow.\n\nBut for each node v (not 1 or n), the total inflow equals the total outflow. Which implies that the sum of all flows on edges incident to v, where the direction is towards v, equals the sum of flows on edges incident to v directed away from v. Which implies that the net flow (outflow - inflow) is zero for these nodes.\n\nSo, for each such node, the net flow is zero. For the source, the net outflow is equal to the total flow. For the sink, the net inflow is equal to the total flow.\n\nBut how can we model this. Maybe we can model this as a directed graph where the edges are directed in such a way that the flow conservation holds.\n\nAnother approach: since the graph must be acyclic, we can arrange the nodes in a topological order. Let's imagine that the nodes are ordered in such a way that all edges go from earlier nodes to later nodes. Then, for each node except the first (source), the inflow must equal the outflow. Wait, but the source has no incoming edges, so in this case, the source would be the first node in the topological order.\n\nSo, suppose we arrange the nodes in a topological order where the source is first, the sink is last, and all other nodes are in between. Then, for each node except the source and sink, the sum of flows from edges coming into it (from earlier nodes) must equal the sum of flows going out (to later nodes). How can we ensure that?\n\nThis sounds like a problem that can be solved with a greedy approach. Let me think: for each node, the sum of flows on edges that are directed into it from earlier nodes must equal the sum of flows on edges directed out of it to later nodes. But how to determine which edges are directed into or out of the node.\n\nAlternatively, for each node (except the source and sink), the sum of flows on edges that are directed towards it must equal the sum of flows on edges directed away from it. Which can be rewritten as: the sum of flows on edges incident to the node, multiplied by their direction (either +1 or -1) equals zero. But how to find such a direction assignment.\n\nThis feels like a problem that can be modeled using a directed graph where each node (except source and sink) has a balance of zero. But how to find such directions.\n\nAnother idea: think of the problem as a directed graph where the edges are directed in such a way that for each node (except source and sink), the net flow is zero. This is similar to finding a flow decomposition where each edge's direction is chosen accordingly.\n\nWait, but the flow is already given. So the direction of each edge determines whether it contributes to the inflow or outflow of the nodes. For example, if an edge between u and v is directed from u to v, then it contributes +c to u's outflow and +c to v's inflow.\n\nSo, for each node v (not 1 or n), the sum of all c_i for edges directed into v must equal the sum of all c_i for edges directed out of v. Which implies that the sum of (direction * c_i) over all edges incident to v is zero. Here, direction is +1 if the edge is directed away from v, and -1 if directed towards v. Wait, maybe I should think of the net flow as outflow minus inflow. For a node v, the net flow is (sum of outflow) - (sum of inflow) = 0. Which can be written as the sum over all edges incident to v of (direction * c_i) = 0, where direction is +1 if the edge is directed away from v, and -1 if directed towards v. But how to find such directions.\n\nAlternatively, for each node v (excluding source and sink), the sum of flows on edges directed away from v must equal the sum of flows directed towards v. Which can be written as:\n\nsum_{edges directed away from v} c_i = sum_{edges directed towards v} c_i.\n\nBut since each edge is either directed away or towards, the sum over all edges incident to v of c_i * (direction) = 0. Where direction is +1 for edges directed away, -1 for edges directed towards.\n\nBut how to model this. It's a system of equations. However, solving such a system for large n and m (up to 2e5) is not feasible directly.\n\nBut perhaps there's a way to model this as a graph problem. For example, if we can assign potentials to the nodes such that for each edge between u and v, the direction is from the node with higher potential to the lower. Then, the flow conservation could be satisfied. But how?\n\nAlternatively, think of the problem as building a directed graph where the flow conservation is satisfied, and the graph is acyclic. Since the graph is acyclic, we can process the nodes in topological order.\n\nLet me think again. Suppose we arrange the nodes in a topological order, where the source is first, the sink is last, and others are in between. For each node in the order, we can direct edges from earlier nodes to later nodes. Then, for each node (except source and sink), the sum of flows from incoming edges (from earlier nodes) must equal the sum of flows from outgoing edges (to later nodes). How can we ensure that?\n\nFor example, take the source first. All edges connected to the source must be directed away from it. Then, for each subsequent node, we can compute the difference between the total flow that needs to be sent out and the flow that is already incoming. But how?\n\nThis sounds like a problem where we can model the flow as a directed graph with a certain structure, and use a BFS or DFS approach to assign directions.\n\nAnother approach: since the graph must be acyclic, it's a DAG. So, we can perform a topological sort. Once we have a topological order, we can assign directions based on the order. But how to ensure that the flow conservation holds.\n\nLet me think of the following idea: for each node except the source, the net flow (outflow - inflow) must be zero. But in the DAG, the inflow comes from nodes earlier in the topological order, and outflow goes to nodes later in the order. So, for each node v (not source or sink), the sum of flows on edges from earlier nodes to v (inflow) must equal the sum of flows on edges from v to later nodes (outflow). \n\nSo, for each node v (excluding source and sink), the sum of flows on edges that are directed into v (from earlier nodes) must equal the sum of flows on edges directed out of v (to later nodes). How can we compute this?\n\nLet me think of this as follows. Suppose we have a topological order where the source is first. Then, for each node v (other than the source), we need to determine the direction of edges between v and other nodes. For example, if there's an edge between v and u, where u is before v in the topological order, then the edge must be directed from u to v. If u is after v, then the edge is directed from v to u. But how does this affect the flow conservation.\n\nBut how to choose the topological order such that for each node v (not source or sink), the sum of flows on edges from earlier nodes to v equals the sum of flows on edges from v to later nodes.\n\nAlternatively, for each node v (not source or sink), the sum of flows on edges incident to v, directed into v (from earlier nodes) plus the flows on edges directed out of v (to later nodes) must satisfy that the inflow equals the outflow. But how to compute this.\n\nWait, the inflow into v is the sum of flows on edges from earlier nodes to v. The outflow from v is the sum of flows on edges from v to later nodes. The inflow must equal the outflow. So, the sum of flows from earlier nodes to v must equal the sum of flows from v to later nodes. But the sum of flows from earlier nodes to v plus the sum of flows from v to later nodes is equal to the total flow on edges incident to v. So, for each node v, the sum of flows from earlier nodes to v must be exactly half of the total flow on edges incident to v. But this is only possible if the total flow on edges incident to v is even, which is not necessarily the case.\n\nWait, no. Because for each edge incident to v, if the other end is before v, then it contributes to the inflow. If the other end is after v, then it contributes to the outflow. But the sum of inflow and outflow is the total flow on edges incident to v. And the inflow must equal the outflow, so the sum must be even. But this may not be the case. However, the problem says that a solution exists, so this must be possible.\n\nBut how to find such a topological order.\n\nAlternatively, think of the problem as a directed graph where each node (except source and sink) has a balance of zero. So, the sum of flows on edges directed into the node equals the sum of flows on edges directed out of it.\n\nLet me think of the following approach: construct a directed graph where each node (except source and sink) has a balance of zero. To achieve this, perhaps we can model this as a directed graph where each node (except source and sink) has a net flow of zero, and the graph is acyclic.\n\nThis seems similar to building a directed tree structure. For example, imagine that the graph is a directed tree rooted at the source, with edges directed away from the root. However, since the graph may have cycles, this isn't directly applicable. But since the final graph must be acyclic, perhaps we can find a way to direct the edges in such a way.\n\nAnother idea: since the graph is connected and acyclic after direction, it's a DAG. So, we can perform a topological sort. Now, for each node, during the topological sort, we can compute the required flow that must be passed through it.\n\nLet me try to think of the following algorithm:\n\n1. Choose a topological order of the nodes. The first node is the source (1), the last is the sink (n).\n\n2. For each node in the topological order (excluding the source and sink), calculate the required outflow. For example, the source has a certain outflow (which is the total flow of the maximum flow). Each node in the middle must pass along the same amount of flow that it receives. So, the inflow to the node must equal the outflow from it.\n\nBut how to compute this. Let's say that for each node v, we have a value 'balance' which represents the amount of flow that must be passed through it. For the source, the balance is the total flow. For the sink, the balance is negative of that. For other nodes, the balance is zero. But how to model this.\n\nAlternatively, think of the problem as a flow network where the edges are directed, and the flow is fixed. We need to assign directions to edges such that the flow conservation is satisfied. This is similar to finding a directed version of the flow network where each edge's direction is chosen to satisfy the flow constraints.\n\nBut how to find such a direction.\n\nWait, here's a different approach. Since the problem requires that the directed graph has no cycles, perhaps we can model it as a directed acyclic graph (DAG) with the source as the only node with no incoming edges, and the sink as the only node with no outgoing edges (but not necessarily). Then, for each node (except source and sink), the inflow equals outflow.\n\nThis seems like a problem that can be solved by constructing a directed spanning tree. For example, imagine that the graph is a directed tree rooted at the source. Each node (except the source) has exactly one parent, and the edges are directed from parent to child. Then, the flow conservation for each node would require that the sum of flows from its children equals the flow from its parent. But how to handle this for general graphs with multiple edges.\n\nAlternatively, think of the problem as building a directed graph where each node (except source and sink) has an equal amount of inflow and outflow. This is equivalent to saying that the net flow for each node is zero. So, the problem reduces to finding a directed graph where each edge's direction is chosen so that the net flow for each node (except source and sink) is zero, and the graph is acyclic.\n\nBut how to find such directions.\n\nLet me think of the following idea: For each node v (except source and sink), the sum of flows on edges directed into v must equal the sum of flows directed out of v. So, for each such node, the sum of flows on edges incident to v must be even. Wait, no. Because sum_in = sum_out → sum_in + sum_out = 2*sum_in. But sum_in + sum_out is the sum of flows on all edges incident to v. Which is fixed. Therefore, the sum of flows on edges incident to v must be even. But the problem says that a solution exists, so this must be true for all such nodes.\n\nBut how to find the directions.\n\nAnother approach: Since the graph is connected and undirected, and the solution exists, perhaps we can model this as a directed graph where we assign directions based on a DFS traversal. For example, during a DFS, when we visit a node, we direct the edges from the parent to the child, and back edges are directed in a way that doesn't create cycles. But I'm not sure how this would ensure flow conservation.\n\nAlternatively, think of this as a problem where we can assign directions based on a spanning tree. Let me think: build a spanning tree of the graph. For each edge in the spanning tree, direct it away from the root (source). For non-tree edges, direct them in a way that doesn't create cycles. But again, how to ensure flow conservation.\n\nAlternatively, think of the problem as a directed graph where each node (except source and sink) has zero net flow. This is similar to a circulation. But since the source and sink have non-zero net flows, perhaps we can model this as a flow network with the source having a supply and the sink a demand.\n\nBut how to translate this into directions.\n\nLet me think about the following. For each node v (not source or sink), the net flow is zero. The source has a net outflow equal to the total flow, and the sink has a net inflow equal to the total flow.\n\nNow, imagine that we have a directed graph where the flow is fixed. For each edge, the direction is chosen so that the flow is directed in such a way that the net flows are as required.\n\nBut how to find such directions.\n\nPerhaps we can model this as a directed graph where the edges are directed such that the flow forms a valid flow. This is similar to finding a flow decomposition tree, but I'm not sure.\n\nAnother idea: Since the graph must be acyclic, we can assign directions based on a topological order. For example, arrange the nodes in a topological order where the source is first, the sink is last. For each edge between u and v, if u comes before v in the topological order, direct it from u to v. Otherwise, direct it from v to u. But this would not ensure flow conservation. However, perhaps we can find a topological order where the flow conservation is satisfied.\n\nBut how to find such an order.\n\nLet me think of the following steps:\n\n1. Compute the total flow. The total flow is the sum of flows from the source's edges. Because the source has no incoming edges, all its edges must be directed away from it. So, the total flow is the sum of ci for edges connected to the source, directed away from it.\n\nBut wait, how to compute that. Suppose the source is connected to several nodes. The sum of all flows on edges incident to the source would be the total flow. But since the source has no incoming edges, all edges connected to it are directed away. Therefore, the total flow is the sum of ci for edges incident to the source. But how to ensure that this is consistent with the rest of the graph.\n\nBut perhaps the total flow is fixed, and the sum of flows into the sink must be equal to this total flow.\n\nBut how to proceed.\n\nLet me think of the following approach inspired by the problem's requirement of the graph being acyclic. Since the graph must be acyclic, we can arrange the nodes in a topological order. Let's say the order is v_1, v_2, ..., v_n, where v_1 is the source (1) and v_n is the sink (n). For each node v_i (i from 2 to n-1), the sum of flows on edges directed into v_i (from earlier nodes) must equal the sum of flows directed out of v_i (to later nodes).\n\nSo, for each node v_i (not source or sink), the inflow from earlier nodes must be equal to the outflow to later nodes. This suggests that for each such node, the inflow from earlier nodes is known, and the outflow to later nodes must be the same. How can we ensure this?\n\nThis seems like a dynamic programming problem. For example, for each node in the topological order, we can track the required outflow. But how to determine the topological order.\n\nAlternatively, think of this as a problem where we can perform a BFS starting from the source. For each node, we can track the amount of flow that must be passed through it. For example:\n\n- The source has a certain amount of flow to distribute. For each edge from the source to another node, we direct it away from the source, and assign the flow accordingly. Then, for each neighbor, we need to ensure that the flow received from the source is passed on.\n\nBut how to handle multiple edges and other nodes.\n\nLet me try to think of a concrete example. Take the first sample input:\n\n3 nodes, edges between 3-2 (10), 1-2 (10), 3-1 (5). The output directions are 1, 0, 1. Which corresponds to:\n\nEdge 3-2 is directed from 2 to 3 (so di=1, meaning original ai=3, bi=2, so direction is bi→ai?), wait no. The output di is 0 if the direction is ai→bi, else 1. So for the first edge (3,2,10), output is 1, meaning direction is bi→ai, i.e., 2→3. The second edge (1,2,10) is directed as 1→2 (di=0). Third edge (3,1,5) is directed as 1→3 (di=1, which means direction is bi→ai, which is 1→3).\n\nIn this case, the source (1) has edges directed away. The flow from 1 to 2 is 10, and from 1 to 3 is 5. The total flow is 15. The sink is node 3. The flow into node 3 is 10 (from 2) and 5 (from 1), totaling 15. Node 2 has inflow of 10 from node 1, and outflow of 10 to node 3. So flow conservation is satisfied.\n\nNow, how to model this. The idea is that for node 2, which is not the source or sink, the inflow (from node 1) equals the outflow (to node 3). So, during the process, when processing node 2, the inflow is 10, so the outflow must also be 10.\n\nThis suggests that for each node, the amount of flow that must be passed on is fixed. So, for each node, we can calculate the required outflow, and direct the edges accordingly.\n\nThis sounds like a problem that can be solved with a BFS or DFS approach, where for each node, we calculate the required outflow, and then for each adjacent edge, decide the direction based on the current node's required outflow.\n\nLet me formalize this idea. Suppose we have a graph where each node (except the source and sink) has a required outflow. The source has an outflow equal to the total flow, and the sink has an inflow equal to the total flow.\n\nWe can model this as follows:\n\n- Start with the source. For each edge connected to the source, direct it away from the source. The source's outflow is the sum of all flows on these edges.\n\n- For each neighbor of the source, we calculate how much flow they need to pass on. For example, if the source sends 10 units to node 2, then node 2 must send 10 units to other nodes. This becomes the required outflow for node 2.\n\n- Then, for each node, we process its edges, directing them to nodes that haven't been processed yet, ensuring that the required outflow is satisfied.\n\nBut how to implement this.\n\nThis seems like a problem that can be solved with a priority queue or a BFS-like approach. For example, we can use a queue to process nodes whose required outflow is known. When processing a node, we look at all its edges, and for each edge that hasn't been directed yet, we decide the direction based on the required outflow.\n\nLet me think of the steps in more detail:\n\n1. For each node, maintain a variable called 'required_outflow'. For the source, this is the sum of all flows on edges connected to it. For other nodes, initially it's unknown. For the sink, it's zero (since it's the destination of the flow, and no outflow is needed).\n\nWait, no. The sink (node n) can have outflow, but in the flow conservation, it's not required. So, for the sink, the required_outflow is whatever is needed to make the flow conservation hold for other nodes. However, the sink's inflow must equal the total flow.\n\nBut how to proceed. Perhaps the required_outflow for each node (except source and sink) is the amount of flow that must be passed on through its outgoing edges.\n\nLet's think of this as a system where, for each node v (not source or sink), the required_outflow is equal to the sum of flows on edges directed out of v. This required_outflow must be equal to the sum of flows on edges directed into v. Which is the same as the required_inflow for v.\n\nBut how to compute this.\n\nLet me think of the following algorithm:\n\n- Initialize a queue with the source node.\n\n- For the source node, required_outflow is the sum of all flows on edges connected to it. These edges are directed away from the source.\n\n- For each neighbor of the source, we add to their required_inflow the flow of the edge. For example, if the source has an edge with flow c to node u, then node u's required_inflow increases by c. Since for node u (not sink), the required_inflow must equal required_outflow. So, required_outflow for u is equal to required_inflow.\n\n- Then, when processing node u, we look at all edges connected to u that are not yet directed. For each such edge, we can direct it away from u (to a node that hasn't been processed yet) and subtract the flow from u's required_outflow. Or, if the other end of the edge has already been processed, then we direct it towards that node.\n\nWait, this seems a bit vague. Let me think of it as a BFS-like process. Each time we process a node, we know the amount of flow that must leave it. For example, when we process node u, we have a required_outflow value. For each edge connected to u, if the other end is not processed yet, we direct the edge away from u to that node, and subtract the flow from u's required_outflow. This way, the other node will receive this flow and must pass it on.\n\nBut how to ensure that this process works.\n\nLet me take the first sample:\n\nNodes 1 (source), 2, 3 (sink).\n\nEdges:\n\n3-2 (10)\n\n1-2 (10)\n\n3-1 (5)\n\nInitially, the source (1) has edges to 2 and 3. The required_outflow for 1 is 10+5=15. These edges are directed away from 1. For node 2, the required_inflow is 10 (from edge 1-2). For node 3, required_inflow is 5 (from edge 1-3).\n\nBut node 3 is the sink. So, for node 2, required_outflow is 10. Now, process node 2. It has edges to 1 (already processed), to 3 (unprocessed). So, we direct the edge from 2 to 3. The flow is 10. This contributes to node 3's required_inflow (now 5 + 10 = 15). Since node 3 is the sink, we don't need to process it further.\n\nThis matches the sample.\n\nAnother example: suppose node u has required_outflow of x. For each edge connected to u, if the other end is unprocessed, direct it away from u, subtract the flow from x. Repeat until x is zero.\n\nThis seems like a viable approach. The key is to process nodes in such a way that when we process them, their required_outflow is known, and we can direct edges away from them to unprocessed nodes.\n\nSo, the steps would be:\n\n1. For each node, keep track of the required_outflow. Initially, for the source, it's the sum of flows on edges connected to it. For others, it's zero.\n\n2. For each edge connected to the source, direct it away from the source, and add the flow to the required_inflow of the other node.\n\n3. For each node, once their required_inflow is known (and they are not the sink), their required_outflow is set to that value. Then, they are added to a queue for processing.\n\n4. When processing a node u from the queue, for each edge connected to u that hasn't been directed yet:\n\n   a. If the other end v is not processed yet, direct the edge from u to v. Subtract the flow from u's required_outflow, and add the flow to v's required_inflow. If v is not the sink, then set v's required_outflow to its required_inflow and add it to the queue.\n\n   b. If the other end v is already processed, then direct the edge from v to u. But this would mean that the flow is coming from v to u, which may conflict with the required_outflow of v. Wait, this seems problematic.\n\nWait, this suggests that during processing, the other end of the edge must not be processed yet. Otherwise, how to handle it.\n\nBut how can we ensure that. For example, if we have an edge between u and v, and both are processed. But since the graph is acyclic, this is impossible. Because if u is processed before v, then the edge would have been directed from u to v, and v would not have been processed yet. So during processing, the other end of the edge must be unprocessed.\n\nTherefore, during the processing of u, all edges connected to u that are not yet directed must be directed to unprocessed nodes. Thus, the algorithm proceeds as follows:\n\n- For each edge, once it's directed, it's processed and not considered again.\n\nSo, the algorithm can be implemented with a BFS approach:\n\nInitialize:\n\n- For each node, required_outflow = 0.\n\n- For the source node, required_outflow is sum of flows of edges connected to it. For each such edge, direct it away from the source, and add the flow to the required_inflow of the other node. If the other node is not the sink, then set its required_outflow to the required_inflow, and add it to the queue.\n\nThen, while the queue is not empty:\n\n   Take a node u from the queue.\n\n   For each edge connected to u that hasn't been directed yet:\n\n      Let v be the other end of the edge.\n\n      Direct the edge from u to v.\n\n      Subtract the flow from u's required_outflow.\n\n      Add the flow to v's required_inflow.\n\n      If v is not the sink:\n\n          if v's required_outflow was not set before, set it to required_inflow, and add to the queue.\n\nThis way, we ensure that the required_outflow of u is fully satisfied by directing edges away from u to unprocessed nodes.\n\nBut why does this work? Because when we process u, we have already determined that its required_outflow is equal to the sum of flows that must be passed on. By directing edges away from u to unprocessed nodes, we transfer that required_outflow to those nodes, which then become processed and added to the queue.\n\nBut what if there's an edge between u and a node v that has already been processed? That shouldn't happen, because once v is processed, it would have been added to the queue, and the edge between u and v would have been directed in the earlier step when v was processed.\n\nWait, but how can that happen? Let's think. Suppose u is processed, and there's an edge between u and v. If v has already been processed, then during the processing of v, this edge would have been directed from v to u. But since u is now being processed, that would imply that v was processed before u. However, in that case, when v was processed, the edge between v and u would have been directed away from v to u. Then, when processing u, this edge would have already been directed, and thus not considered again.\n\nThus, during the processing of u, all edges connected to u that are not yet directed must be to unprocessed nodes. Hence, the algorithm can proceed.\n\nNow, the question is: How to represent the edges and track which ones have been directed.\n\nImplementation Steps:\n\n- For each edge, store the two endpoints and the flow. Also, track for each edge whether it's been directed or not.\n\n- For each node, maintain a list of adjacent edges.\n\n- For each node, track the required_outflow.\n\n- For each node, when it's processed, iterate through its adjacent edges that are not yet directed.\n\nBut how to efficiently track which edges have been directed. One approach is to have for each edge, a flag indicating whether it's been processed. Alternatively, since each edge is processed once, we can track for each edge whether it's been assigned a direction.\n\nNow, let's think about how to implement this in Python.\n\nBut considering the size of n and m (up to 2e5), we need an efficient implementation.\n\nThe steps for the code:\n\nRead n and m.\n\nRead m edges, storing for each the ai, bi, ci, and their index (to output the directions in the correct order).\n\nWe need to build an adjacency list. For each node, a list of edges (each represented as a tuple of (other_node, ci, index)).\n\nWe also need to track for each edge whether it has been directed yet. However, since each edge is processed once, we can track this with a visited array of size m.\n\nBut since the edges are bidirectional, when we process an edge between u and v, we need to check if it's already been directed. For example, when processing u, we look at all edges connected to u. For each such edge, if not directed, we direct it from u to v, and mark it as directed.\n\nNow, the algorithm:\n\nInitialize:\n\nrequired_outflow = [0] * (n+1)\n\nvisited_edges = [False] * m\n\nqueue = deque()\n\nsource = 1\n\nsink = n\n\n# Compute the initial required_outflow for the source.\n\nfor each edge connected to source:\n\n   if the edge is between source and another node v:\n\n       direct it from source to v (so di is 0 if the original edge is (source, v), else 1)\n\n       add the flow to v's required_inflow.\n\n       mark the edge as directed.\n\nBut how to compute the initial required_outflow for the source. The required_outflow for the source is the sum of all flows on edges connected to it. Because all edges connected to the source must be directed away from it.\n\nSo, for the source:\n\nsum_flows = sum(ci for edges connected to source)\n\nrequired_outflow[source] = sum_flows\n\n",
    "response": "To solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph satisfies specific flow conservation conditions and is acyclic. The source node (vertex 1) must have no incoming edges, and all intermediate nodes must have equal inflow and outflow. The sink node (vertex n) can have any inflow or outflow.\n\n### Approach\n1. **Graph Representation**: Use an adjacency list to represent the graph for efficient traversal.\n2. **Flow Conservation**: Track the required outflow for each node using a queue-based approach. Start from the source node, which has all its edges directed away from it.\n3. **BFS Traversal**: Use a BFS-like approach to process each node, ensuring that the required outflow is satisfied by directing edges appropriately. For each node processed, direct its edges to unprocessed nodes, adjusting their required outflow accordingly.\n4. **Edge Direction Tracking**: Maintain an array to track the direction of each edge once processed to ensure each edge is directed only once.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c, i))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    required_outflow = [0] * (n + 1)\n    direction = [0] * m  # 0 means a->b, 1 means b->a\n    visited = [False] * m\n\n    q = deque()\n\n    # Initialize the source (node 1)\n    source = 1\n    sink = n\n    total_outflow = 0\n\n    for neighbor, c, edge_idx in adj[source]:\n        if not visited[edge_idx]:\n            # Direct the edge from source to neighbor\n            direction[edge_idx] = 0 if edges[edge_idx][0] == source else 1\n            visited[edge_idx] = True\n            total_outflow += c\n            required_outflow[neighbor] += c\n\n    required_outflow[source] = total_outflow\n    q.append(source)\n\n    while q:\n        u = q.popleft()\n        for v, c, edge_idx in adj[u]:\n            if not visited[edge_idx]:\n                # This edge hasn't been directed yet\n                # Direct from u to v\n                direction[edge_idx] = 0 if edges[edge_idx][0] == u else 1\n                visited[edge_idx] = True\n                required_outflow[u] -= c\n                required_outflow[v] += c\n                if v != sink:\n                    q.append(v)\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n- **Graph Representation**: The graph is represented using an adjacency list where each node points to its neighbors along with the edge's flow value and index.\n- **Initialization**: The source node (vertex 1) is initialized with all its edges directed away from it. The required outflow for the source is calculated as the sum of flows on these edges.\n- **BFS Traversal**: Using a queue, nodes are processed starting from the source. For each node, edges are directed to unprocessed nodes, adjusting their required outflow values. This ensures that each node's inflow equals its outflow, maintaining flow conservation.\n- **Edge Direction**: Each edge is directed once, either from the current node to an unprocessed neighbor or vice versa, ensuring the graph remains acyclic and meets flow conservation requirements.\n\nThis approach efficiently processes each edge exactly once, ensuring the constraints are met and the solution is optimal.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c, i))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    required_outflow = [0] * (n + 1)\n    direction = [0] * m  # 0 means a->b, 1 means b->a\n    visited = [False] * m\n\n    q = deque()\n\n    # Initialize the source (node 1)\n    source = 1\n    sink = n\n    total_outflow = 0\n\n    for neighbor, c, edge_idx in adj[source]:\n        if not visited[edge_idx]:\n            # Direct the edge from source to neighbor\n            direction[edge_idx] = 0 if edges[edge_idx][0] == source else 1\n            visited[edge_idx] = True\n            total_outflow += c\n            required_outflow[neighbor] += c\n\n    required_outflow[source] = total_outflow\n    q.append(source)\n\n    while q:\n        u = q.popleft()\n        for v, c, edge_idx in adj[u]:\n            if not visited[edge_idx]:\n                # This edge hasn't been directed yet\n                # Direct from u to v\n                direction[edge_idx] = 0 if edges[edge_idx][0] == u else 1\n                visited[edge_idx] = True\n                required_outflow[u] -= c\n                required_outflow[v] += c\n                if v != sink:\n                    q.append(v)\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 702,
        "completion_token_count": 859,
        "thoughts_token_count": 8192
    }
}