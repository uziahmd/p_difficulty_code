{
    "start": 1758344762.7720137,
    "end": 1758344896.8778367,
    "start-formatted": "2025-09-20 14:06 KST",
    "end-formatted": "2025-09-20 14:08 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to maximize the total cost of souvenirs he can carry, given that each souvenir has a weight (1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm.\n\nSo the problem is similar to the classic knapsack problem, but with the twist that the weights are limited to 1, 2, or 3. That probably means there's a way to optimize it better than the standard DP approach, which would be O(nm) and might not work here since n and m are up to 1e5 and 3e5 respectively. For example, 1e5 * 3e5 is 3e10 operations, which is way too slow.\n\nWait, but since the weights are small (only 1, 2, 3), maybe we can group the items by their weight and then find an optimal way to select them. Let's think about that.\n\nLet me break down the problem. Let's say I have three groups: items of weight 1, weight 2, and weight 3. For each group, I can sort them in descending order of cost. Then, for each group, I can precompute the prefix sums so that for any number of items taken from that group, I can quickly calculate the total cost.\n\nOnce I have these prefix sums, the problem becomes how to choose how many items to take from each group such that the total weight doesn't exceed m, and the total cost is maximized.\n\nBut how do I combine these choices efficiently?\n\nLet me think. Let's denote:\n\n- For weight 1: sorted list, with prefix sums. Let's say there are a items. So taking k items of weight 1 contributes k*1 weight and sum_1[k] cost.\n- Similarly for weight 2: sorted, prefix sums. Let's say b items. Taking l items gives l*2 weight and sum_2[l] cost.\n- For weight 3: sorted, prefix sums. c items. Taking p items gives p*3 weight and sum_3[p] cost.\n\nThe total weight is k + 2l + 3p ≤ m. We need to maximize sum_1[k] + sum_2[l] + sum_3[p].\n\nBut how do I find the optimal k, l, p?\n\nThe brute-force approach would be to iterate over all possible combinations of k, l, p, but that's not feasible for large numbers.\n\nAlternative idea: since the weight of each item is small, perhaps we can iterate over the possible number of weight 3 items, and then for each such choice, compute the optimal combination between weight 1 and 2.\n\nBut even that could be expensive if done naively. Let's think.\n\nLet me think about the maximum possible number of weight 3 items. Since each takes 3 weight, the maximum possible is floor(m / 3). But since m can be up to 3e5, that's 1e5. So if I loop through all possible p (number of weight 3 items taken), that's O(1e5) steps. For each p, the remaining weight is m' = m - 3*p. Then, for that m', I need to find the optimal combination of weight 1 and 2 items.\n\nBut how to compute that optimally?\n\nFor each m', the problem reduces to selecting some number of weight 1 and 2 items, with total weight ≤ m'. How to find the maximum cost here?\n\nLet's consider that for weight 1 and 2, we can precompute their prefix sums. Let's say we have sorted lists for weight 1 and 2.\n\nFor each possible number of weight 2 items (say l), the maximum number of weight 1 items is (m' - 2*l). But since l can be up to min(b, m'//2), this would be O(m') steps per p. Which for m' up to 3e5 would be O(3e5) steps per p. Which would be O(1e5 * 3e5) steps overall, which is 3e10 again. That's way too slow.\n\nSo that approach isn't feasible. Need a smarter way.\n\nAlternative idea: For the weight 1 and 2 items, given a certain total capacity, how to choose the best combination. Since each weight 2 item is worth some value, and each weight 1 is worth some value. But since they are sorted, perhaps we can find the optimal combination by considering that for a given capacity, we can take as many as possible of the higher value items.\n\nWait, but how? Let me think. Let's say we have two arrays:\n\nsum1: prefix sums of weight 1 items (sorted descending)\nsum2: prefix sums of weight 2 items (sorted descending)\n\nFor a given capacity m', what's the best way to choose x items of weight 1 and y items of weight 2, such that x + 2y ≤ m'.\n\nWe can think of this as a problem where for each possible y (number of weight 2 items), the maximum x is (m' - 2y), and then take the minimum between that and the number of available weight 1 items.\n\nBut again, trying all possible y is O(m') steps. However, perhaps we can find a way to compute this more efficiently.\n\nAlternatively, for each possible y, the maximum number of weight 1 items is (m' - 2y). However, since the weight 1 items are sorted in descending order, taking as many as possible (up to the available count) is optimal. So for each possible y, we can compute the sum as sum2[y] + sum1[min( (m' - 2y), len1 )], where len1 is the number of weight 1 items.\n\nBut again, trying all possible y for each p is O(m') steps. Which is not feasible.\n\nWait, but what's the maximum number of weight 2 items possible? It's up to min(b, m'//2). Let's say m' is up to 3e5. So for each p, this could be O(3e5) steps again. Not helpful.\n\nAlternative approach: for the weight 1 and 2 items, we can precompute for each possible total weight (up to m) the maximum value. But how?\n\nBut even that would be O(m) time. But since the weight 1 and 2 items are sorted, perhaps there's a way to compute this efficiently.\n\nAnother idea: for each possible number of weight 2 items, we can compute the maximum possible weight 1 items that can fit. Since the weight 1 items are sorted, taking the first x items gives the maximum value for x items. So for a given y (number of weight 2 items), the maximum x is min( (m' - 2y), len1 ). But how can we find the optimal y?\n\nBut this seems like a problem that can be optimized using two pointers. Let me think.\n\nSuppose I have a total capacity of m'. Let me try to find the best combination of weight 2 and 1 items.\n\nLet me assume that I take as many weight 2 items as possible. But sometimes, replacing a weight 2 item with two weight 1 items may be better. So perhaps the optimal solution is to take some number of weight 2 items and fill the rest with weight 1 items.\n\nBut since the weight 2 items are sorted in descending order of cost, and same for weight 1, perhaps the optimal is to take as many as possible of the higher value items.\n\nBut how?\n\nLet me think of the following approach:\n\nFor the weight 1 and 2 items, for a given capacity m', the best way is to take some number of weight 2 items (y) and then fill the remaining weight with weight 1 items. However, since the weight 2 items are sorted, and the weight 1 items are sorted, perhaps for each possible y, the optimal is to take y items of weight 2, and then as many weight 1 items as possible.\n\nBut how to find the best y?\n\nThe maximum possible y is min( (m') // 2, len2 ). But even if we loop through all possible y from 0 to this maximum, it's O(m') steps. Which again is not feasible.\n\nBut perhaps for each possible y, we can find the corresponding x in O(1) time, and find the maximum over all possible y. However, with m' up to 3e5, and for each p (up to 1e5), that's O(3e5 * 1e5) = 3e10 operations, which is way too slow.\n\nThis suggests that this approach isn't feasible. So I need another idea.\n\nAlternative idea: Since the weight 1 and 2 items are sorted, perhaps we can precompute for each possible total weight (up to m) the maximum value for the combination of 1 and 2 items. But how?\n\nBut the total possible weight is up to 3e5. Let's say that for each possible weight w, we can compute the maximum value for weight 1 and 2 items with total weight exactly w. Then, for each possible p (number of weight 3 items), the remaining weight is m' = m - 3*p. Then, the maximum value for weight 1 and 2 is the maximum over all w <= m' of the precomputed value for w.\n\nBut how to compute this precomputed array?\n\nLet me think of it as a dynamic programming problem. Let's create a DP array for the 1 and 2 items. Let dp[w] be the maximum value achievable with total weight exactly w using items of weight 1 and 2.\n\nBut how to compute this efficiently.\n\nWait, but the items are of weight 1 and 2. Let's think of the standard unbounded knapsack problem, but in this case, it's 0-1 knapsack because each item can be taken once.\n\nBut for the weight 1 and 2 items, since they are sorted, perhaps we can compute the maximum for each possible weight.\n\nBut for n up to 1e5 and m up to 3e5, this might be feasible.\n\nWait, but the standard 0-1 knapsack approach is O(nm) which would be 1e5 * 3e5 = 3e10 again. Not feasible.\n\nSo that's not going to work.\n\nAlternative Idea: Since all the items are of weight 1 or 2, and we have sorted them, perhaps we can compute for each possible weight the best possible selection.\n\nFor example, for weight 1 items, since they are sorted, taking the top k items gives the maximum value for k weight 1 items. Similarly for weight 2 items.\n\nNow, for a given capacity m', the optimal selection is to choose some number of weight 2 items and fill the rest with weight 1 items. However, since the weight 2 items can be taken in any number up to their count, but the weight 1 items are filled in the remaining capacity.\n\nBut how to find the best combination.\n\nLet me think of it as follows. Let's suppose we have a total capacity of m'. Let me take l items of weight 2. Each such item takes 2 units. The remaining weight is m' - 2*l. The maximum number of weight 1 items we can take is min( (m' - 2*l), a ), where a is the number of weight 1 items. The total cost is sum2[l] + sum1[ min( (m' - 2*l), a ) ].\n\nThe question is, for l in 0 to min( (m')//2, len2 ), what is the maximum of this value?\n\nBut again, iterating over all l for each p is expensive.\n\nBut perhaps we can find the optimal l for each m' in O(1) or O(1) per m'.\n\nWait, here's an idea. For the given m', the optimal number of weight 2 items is either floor( (m') / 2 ), or floor( (m') / 2 ) - 1, etc., but perhaps there's a way to find the best l in a small range.\n\nAlternatively, since the sum2 is a prefix sum of sorted items, and sum1 is also a prefix sum of sorted items, perhaps the optimal l is around (m' - x)/2 for some x.\n\nAlternatively, for each m', the optimal number of weight 2 items is such that 2*l is as close as possible to m' minus the number of weight 1 items. But I'm not sure.\n\nAnother approach: For each possible m', the optimal l can be determined by considering that for each weight 2 item taken, we can compare its value with two weight 1 items. So for example, if we have a weight 2 item with value c2, and two weight 1 items with total value c1_1 + c1_2, then taking the one with higher value is better.\n\nBut since the items are sorted, the best weight 2 items are the ones with highest value, and the best weight 1 items are the ones with highest value.\n\nSo perhaps, for each m', the optimal is to take as many weight 2 items as possible, then fill with weight 1 items. But sometimes, replacing one weight 2 item with two weight 1 items can be better. So the optimal number of weight 2 items is somewhere around floor(m' / 2), but we need to check nearby values.\n\nBut how to find this efficiently.\n\nLet me think of the following approach:\n\nFor the current m', the maximum possible number of weight 2 items is l_max = min( len2, m' // 2 )\n\nThen, the optimal l is somewhere between max(0, l_max - k) and l_max, for a small k (like 1 or 2). Because replacing one weight 2 item with two weight 1 items may be better.\n\nSo for each m', we can check l_max, l_max - 1, and maybe l_max - 2, etc., and compute the corresponding value. Since the number of checks is small, this would be efficient.\n\nBut how to determine how far to check. For example, in the worst case, for each m', we check all possible l in a small window around l_max.\n\nBut why would this work? Because the optimal l is likely near l_max, since taking more weight 2 items gives more weight coverage. However, if the sum of two weight 1 items is higher than the sum of one weight 2 item, then it's better to replace.\n\nBut since the items are sorted, the first few items in the weight 2 list are the most valuable. So for example, if the l_max-th weight 2 item is not better than two weight 1 items, then perhaps we should take l_max-1 weight 2 items and add as many weight 1 as possible.\n\nBut how to find this without checking all possibilities.\n\nAlternatively, for each m', we can compute the optimal l in O(1) time by considering two possibilities:\n\nCase 1: Take as many weight 2 items as possible (l_max), and fill the rest with weight 1 items.\n\nCase 2: Take l_max - 1 weight 2 items, and fill the rest with weight 1 items, but possibly adding two more weight 1 items (since 2*l_max - 2 + 2 = 2*l_max, but m' could be larger than that).\n\nWait, perhaps for each m', the optimal l is either floor(m' / 2) or floor(m' / 2) - 1. Because if you take l = floor(m' / 2), then the remaining weight is m' - 2*l. If that is 0, then that's the best. If it's 1, then you can take one weight 1 item. If you take l = floor(m' / 2) - 1, then the remaining weight is m' - 2*(l) = m' - 2*(floor(m'/2) - 1) = m' - 2*floor(m'/2) + 2. Which is 2 + (m' - 2*floor(m'/2)) = 2 + (m' mod 2). So for example, if m' is even, then m' mod 2 is 0, so remaining weight is 2. Which can be filled with two weight 1 items. So comparing the sum of l_max weight 2 items and (m' - 2*l_max) weight 1 items, versus (l_max - 1) weight 2 items and (m' - 2*(l_max - 1)) weight 1 items.\n\nIn this case, for each m', we can check these two possibilities and take the maximum. This would be O(1) per m'.\n\nBut why would this cover all possibilities? Well, for example, maybe there's a scenario where taking l_max - 2 gives a better result. However, given that the weight 1 items are sorted, taking as many as possible is optimal. So if the l_max - 2 case allows taking more weight 1 items, but the sum is better, perhaps it's possible.\n\nBut how to know? Let's think of an example.\n\nSuppose m' is 5. Then l_max is 2 (since 2*2=4 ≤5). The remaining weight is 5-4=1. So take 1 weight 1 item. Alternatively, taking l=1 (2*1=2), remaining weight 3. Take 3 weight 1 items. So which is better depends on the sum2[2] + sum1[1] vs sum2[1] + sum1[3]. But if sum2[2] is the sum of two high-value weight 2 items, and sum1[3] is the sum of three high-value weight 1 items, which could be better. So in this case, checking l_max and l_max-1 is sufficient.\n\nAnother example: m'=4. l_max=2. Remaining 0. Or l=1, remaining 2. So compare sum2[2] vs sum2[1] + sum1[2].\n\nSo by checking l_max and l_max-1, we can find the optimal.\n\nSimilarly, if m'=3. l_max is 1 (since 2*1=2 ≤3). Remaining 1. Or l=0, remaining 3. So compare sum2[1]+sum1[1] vs sum2[0]+sum1[3].\n\nThus, checking these two cases (l_max and l_max -1) would cover the optimal choice.\n\nSo for any m', the optimal number of weight 2 items is either l_max or l_max-1. Thus, for each m', we can compute the maximum between these two options.\n\nBut wait, what about when m' is very small? Like m'=1. Then l_max is 0, so we can only take l=0, and then take 1 weight 1 item. So that's covered.\n\nSo this approach seems promising. Let me formalize it.\n\nFor a given m', compute l_max = min( len2, m' // 2 )\n\nThen, the candidates for l are l_max and l_max - 1 (if l_max -1 >=0).\n\nFor each candidate l in [l_max, l_max -1], compute the corresponding value:\n\nvalue = sum2[l] + sum1[ min( (m' - 2*l), len1 ) ]\n\nTake the maximum between these candidates.\n\nBut wait, what about cases where l_max is not the best? For example, suppose m'=5, and l_max is 2. Suppose that taking l=2 gives sum2[2] + sum1[1], but taking l=0 gives sum2[0] + sum1[5], which is better. But according to our approach, we check l=2 and l=1. So in this case, the approach would miss the l=0 case. But how?\n\nAh, right. So this approach would not consider all possible l. So this idea is flawed.\n\nHmm. So what's the problem here? The approach of checking only l_max and l_max -1 is not sufficient. So how else can I find the optimal l?\n\nAlternative Idea: For the weight 1 and 2 items, the optimal selection is to take as many of the highest value items as possible. So for each possible l (number of weight 2 items taken), the best is to take the first l weight 2 items (since they are sorted), and then take as many weight 1 items as possible. But how to find the optimal l.\n\nBut since the sum of weight 2 items increases with l, but the remaining weight decreases, there's a trade-off. However, since the weight 2 items are sorted, each additional weight 2 item adds a certain value. However, the weight 1 items are also sorted, so each additional weight 1 item adds a certain value.\n\nBut how can I find the optimal l?\n\nPerhaps the optimal l is such that the next weight 2 item is not better than two weight 1 items. So for example, if the next weight 2 item has a value less than the sum of the next two weight 1 items, then it's better to take those two weight 1 items instead.\n\nBut how to model this.\n\nLet me think of the following approach:\n\nWe can iterate through the weight 2 items and for each, compare with the weight 1 items.\n\nBut again, this seems complicated.\n\nAlternative Idea: Since the weight 1 and 2 items are sorted, the optimal selection is to take as many weight 2 items as possible, but possibly replace some with weight 1 items if it's better.\n\nFor example, take all weight 2 items (up to l_max), and then take as many weight 1 as possible. Then, check if replacing some weight 2 items with weight 1 items gives a better value.\n\nBut how to find how many to replace.\n\nLet me think of this as follows: For the initial selection (all weight 2 items possible), the remaining weight is r = m' - 2*l_max. We can take r weight 1 items. Now, for each weight 2 item in the selection, if that item's value is less than the sum of two weight 1 items (which are not yet taken), then we should replace that weight 2 item with those two weight 1 items.\n\nBut since the weight 1 items are sorted, the first r items are the best. However, if there are more weight 1 items available than r, then the next ones are not taken.\n\nBut this seems complicated.\n\nAlternatively, since the weight 2 items are sorted in descending order, and weight 1 items are also sorted, the optimal selection is to take as many weight 2 items as possible, and then fill the remaining with weight 1 items, and also check whether replacing one weight 2 item with two weight 1 items gives a better result.\n\nBut this seems to suggest that for the initial l_max, we can check replacing up to one weight 2 item with two weight 1 items, but this might not cover all possibilities.\n\nBut given the time constraints, perhaps the best way to proceed is to implement the following approach:\n\nFor the weight 1 and 2 items, for a given capacity m', compute the maximum between:\n\n- Taking l_max weight 2 items and filling the rest with weight 1 items.\n\n- Taking l_max - 1 weight 2 items and filling the rest with weight 1 items.\n\n- Taking l_max + 1 weight 2 items? No, because l_max is already the maximum possible.\n\nWait, no. l_max is the maximum possible number of weight 2 items for m'.\n\nBut what if there are more weight 2 items than l_max? No, l_max is min( len2, m' // 2 ). So l_max is the maximum possible.\n\nSo, the idea is to check l_max and l_max - 1, but also possibly other nearby values. However, given that the previous example with m'=5 and l_max=2, but taking l=0 could be better, how do we ensure that?\n\nWell, perhaps in practice, for the given problem, the optimal l is either l_max, l_max-1, or l_max - k where k is small, and checking up to a few possibilities would cover it.\n\nAlternatively, perhaps the optimal l is such that 2*l is as close as possible to m' minus some value. But I'm not sure.\n\nAnother Idea: For each possible m', the maximum value is the maximum between:\n\n- Taking all possible weight 2 items and filling with weight 1.\n\n- Taking all possible weight 1 items and filling with weight 2.\n\nBut again, this may not capture all possibilities.\n\nAlternatively, for the given m', the maximum value is the maximum of:\n\nsum2[l] + sum1[ min( (m' - 2*l), len1 ) ] for l in 0 to l_max.\n\nBut how to find this maximum quickly.\n\nSince the sum2 is a non-decreasing function (because adding more items increases the sum), and the sum1 part is also non-decreasing as l decreases (because m' - 2*l increases as l decreases, allowing more weight 1 items to be taken).\n\nWait, for l decreasing, 2*l decreases, m' - 2*l increases. So the sum1 part increases. So sum2[l] decreases as l decreases, but the sum1 part increases. So the total could be increasing or decreasing.\n\nSo the function is not monotonic, which makes finding the maximum difficult.\n\nBut since the weight 2 items are sorted in descending order, the sum2[l] is strictly increasing with l. And the sum1 part is also increasing with decreasing l. So the total is a function that first increases, then decreases? Or vice versa?\n\nNot sure. But this makes it hard to find the maximum.\n\nAlternative Idea: Since the weight 1 and 2 items are sorted, for each possible number of weight 2 items taken, we can find the best possible number of weight 1 items. But how to find the optimal l.\n\nLet me think of it as follows: For the weight 2 items, we can take up to l_max items. Let's say we take l items. Then the remaining weight is rem = m' - 2*l. The number of weight 1 items taken is min(rem, a), where a is the number of weight 1 items available.\n\nThe total value is sum2[l] + sum1[ min(rem, a) ].\n\nNow, the question is to find the l in [0, l_max] that maximizes this.\n\nLet's imagine that we can find for each l, the value, but we need to find the maximum efficiently.\n\nBut how?\n\nLet me think of this as a function f(l) = sum2[l] + sum1[ min( m' - 2*l, a ) ].\n\nNow, since sum2 is increasing and sum1 is increasing with rem, which is m' - 2*l. So rem decreases as l increases.\n\nSo for f(l), when l increases, sum2 increases but sum1 decreases.\n\nThus, the function f(l) is not necessarily monotonic. It might have a single peak, which would allow us to use ternary search.\n\nBut since l is an integer, ternary search might be applicable here. However, I'm not sure if the function is unimodal.\n\nLet me think of an example.\n\nExample 1:\n\nsum2 = [0, 5, 8, 9] (for l=0,1,2,3)\n\nsum1 = [0, 3, 6, 7, 8] (for k=0,1,2,3,4)\n\nm' = 5.\n\nFor l=0: rem =5 → sum1[5] is 8. Total 0+8=8.\n\nl=1: rem=5-2=3 → sum1[3]=7. Total 5+7=12.\n\nl=2: rem=5-4=1 → sum1[1]=3. Total 8+3=11.\n\nl=3: rem=5-6=-1 → sum1[0]=0. Total 9+0=9.\n\nSo the function f(l) increases from l=0 to l=1, then decreases. So it's unimodal.\n\nAnother example:\n\nsum2 = [0, 5, 10]\n\nsum1 = [0, 3, 6, 7, 8]\n\nm'=6.\n\nl can be 0,1,2,3 (but l_max is 3 since 2*3=6).\n\nl=0: rem=6 → sum1[6] is 8. Total 0+8=8.\n\nl=1: rem=6-2=4 → sum1[4]=8. Total 5+8=13.\n\nl=2: rem=6-4=2 → sum1[2]=6. Total 10+6=16.\n\nl=3: rem=0 → sum1[0]=0. Total 10+0=10.\n\nSo the function increases from l=0 to l=2, then decreases. Again unimodal.\n\nAnother example where it might have multiple peaks?\n\nLet me think:\n\nsum2 = [0, 5, 10, 12]\n\nsum1 = [0, 3, 6, 7, 8, 9]\n\nm'=5.\n\nl can be 0, 1, 2 (since 2*2=4 ≤5).\n\nl=0: rem=5 → sum1[5]=9 → total 0+9=9.\n\nl=1: rem=3 → sum1[3]=7 → total 5+7=12.\n\nl=2: rem=1 → sum1[1]=3 → total 10+3=13.\n\nSo function increases from l=0 to l=2.\n\nIf m'=6, and sum2 is [0, 5, 10, 12], sum1 is [0, 3, 6, 7, 8, 9, 10].\n\nl_max = 3 (since 2*3=6).\n\nl=0: rem=6 → sum1[6]=10 → total 0+10=10.\n\nl=1: rem=4 → sum1[4]=8 → 5+8=13.\n\nl=2: rem=2 → sum1[2]=6 → 10+6=16.\n\nl=3: rem=0 → sum1[0]=0 → 12+0=12.\n\nSo again, function increases to l=2, then decreases.\n\nSo it seems that the function f(l) is unimodal. If that's the case, then we can perform ternary search on l in the range [0, l_max] to find the maximum.\n\nBut how to confirm this. Well, for the function to be unimodal, it must first increase and then decrease. If this holds, then ternary search is applicable.\n\nAssuming that it is unimodal, then for each m', we can perform a ternary search on l in [0, l_max] to find the maximum value of f(l).\n\nBut what's the complexity? For each p (number of weight 3 items), we perform a ternary search over l in O(log l_max) steps, and for each step, we compute f(l) in O(1) time. Since l_max can be up to m'//2, which is up to 3e5/2 = 1.5e5. So log(1.5e5) is around 18 steps. And for each p, which can be up to m//3 = 1e5, this gives 1e5 * 18 = 1.8e6 steps, which is acceptable.\n\nSo this seems like a viable approach.\n\nBut how to implement ternary search for integers.\n\nTernary search on the interval [low, high] for the maximum. For each step, we divide the interval into two parts and compare the middle points.\n\nBut since the function is unimodal, the maximum is at the point where f(mid) > f(mid+1), or something like that.\n\nAlternatively, we can use a while loop to narrow down the range until low <= high, and keep track of the maximum found.\n\nBut for the purpose of code, perhaps it's easier to implement a loop that iterates until the range is small enough, and then check all possible values in the final range.\n\nBut for now, assuming that the function is unimodal, and ternary search works, let's proceed.\n\nSo, putting it all together:\n\nSteps:\n\n1. Separate the items into three groups based on their weight (1, 2, 3).\n\n2. Sort each group in descending order of cost. This way, the prefix sums will be maximized for any number of items taken.\n\n3. Compute the prefix sums for each group.\n\n   For example, for weight 1 items, sum1[k] = sum of the first k items.\n\n   Similarly for sum2 and sum3.\n\n4. Iterate over the possible number of weight 3 items (p) that can be taken. For each p, compute the remaining capacity m' = m - 3*p. If m' < 0, skip this p.\n\n5. For each m', compute the maximum value achievable by combining weight 1 and 2 items. This is done by performing a ternary search on l (number of weight 2 items) in the range [0, l_max], where l_max = min( len2, m' // 2 ), and finding the maximum value of sum2[l] + sum1[ min( m' - 2*l, len1 ) ].\n\n6. The total value for this p is sum3[p] + the value computed in step 5.\n\n7. Keep track of the maximum total value across all p.\n\nNow, the code needs to implement this.\n\nBut first, how to handle the prefix sums.\n\nFor example, for the weight 1 items:\n\nsorted in descending order.\n\nprefix_sum1[0] = 0\n\nprefix_sum1[1] = cost of first item\n\nprefix_sum1[2] = cost of first + second, etc.\n\nSimilarly for weight 2 and 3.\n\nNow, for the ternary search part, how to implement it.\n\nLet me think of a function that, given m', returns the maximum value for weight 1 and 2 items.\n\ndef max_1_2(m_prime):\n\n    l_max = min(len2, m_prime // 2)\n\n    low = 0\n\n    high = l_max\n\n    best = 0\n\n    while low <= high:\n\n        mid = (low + high) // 2\n\n        # compute value for mid and mid+1 ?\n\n        # or perform ternary search steps\n\n        # but for now, perhaps just iterate all possible l in the range [0, l_max], but that would be O(l_max) steps, which is not feasible.\n\nWait, but earlier analysis said that ternary search is possible. So how to implement it.\n\nAlternatively, since the range for l is small (up to 3e5 / 2 = 1.5e5), and for each p, the ternary search would take O(log(1.5e5)) steps, which is acceptable.\n\nBut how to implement the ternary search for the maximum.\n\nAnother Idea: Since the function is unimodal, the maximum occurs at the point where f(l) is greater than both f(l-1) and f(l+1). So we can use a loop to find this point.\n\nBut perhaps it's easier to iterate over all possible l in a small window around the l_max, given that the function is unimodal.\n\nBut I'm not sure.\n\nAlternatively, since the function is unimodal, we can perform binary search to find the maximum.\n\nBut I think that for practical purposes, given that the maximum l is up to 1.5e5, and for each p it's acceptable to iterate through all possible l in 0 to l_max, but that would be O(1.5e5) per p, leading to O(1.5e5 * 1e5) = 1.5e10 operations, which is way too slow.\n\nThus, the ternary search approach is necessary.\n\nSo, how to implement ternary search for this function.\n\nHere's a standard approach for ternary search on a unimodal function:\n\nWhile the search space is large enough, evaluate the function at two points, mid1 and mid2, and decide which half to keep.\n\nBut since the function is unimodal (first increasing then decreasing), the maximum is at the point where the function starts to decrease.\n\nSo, during the ternary search, for a given range [low, high], we can choose mid1 = low + (high - low) // 3, mid2 = high - (high - low) // 3.\n\nCompare f(mid1) and f(mid2). If f(mid1) < f(mid2), then the maximum is in the right half. Else, it's in the left half.\n\nRepeat until the range is small, and then check all values in the remaining range.\n\nAlternatively, use a loop that continues until low < high, and adjust low and high accordingly.\n\nBut implementing this requires writing code that correctly handles the comparisons.\n\nAlternatively, since the function is unimodal, we can find the maximum by moving in the direction where the function increases.\n\nBut for the purpose of coding, perhaps it's easier to use a loop that runs for a fixed number of steps (say 100 times) and converges to the maximum.\n\nBut for the sake of time, perhaps I can find a way to compute the best l in the range [0, l_max] by checking all possible l in the vicinity of l_max and l_max - 1, etc.\n\nBut given that earlier examples show that checking l_max and l_max - 1 may not be sufficient, but checking a few more values",
    "response": "To solve this problem, we need to maximize the total cost of souvenirs Petya can carry given a weight constraint. Each souvenir has a weight of 1, 2, or 3, and we need to efficiently determine the optimal combination of these items.\n\n### Approach\n1. **Group Items by Weight**: Separate the items into three groups based on their weights (1, 2, and 3).\n2. **Sort and Compute Prefix Sums**: For each group, sort the items in descending order of their cost and compute prefix sums to quickly calculate the total cost for any number of items taken from that group.\n3. **Iterate Over Possible Weight 3 Items**: For each possible number of weight 3 items that can be taken, compute the remaining weight capacity and determine the optimal combination of weight 1 and weight 2 items using a ternary search approach to find the maximum value efficiently.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums for each group\n    sum1 = [0]\n    for c in w1:\n        sum1.append(sum1[-1] + c)\n    \n    sum2 = [0]\n    for c in w2:\n        sum2.append(sum2[-1] + c)\n    \n    sum3 = [0]\n    for c in w3:\n        sum3.append(sum3[-1] + c)\n    \n    len1 = len(w1)\n    len2 = len(w2)\n    len3 = len(w3)\n    \n    max_total = 0\n    \n    # Iterate over possible number of weight 3 items\n    max_p = min(len3, m // 3)\n    for p in range(0, max_p + 1):\n        remaining = m - 3 * p\n        if remaining < 0:\n            continue\n        \n        # Now compute max value for weight 1 and 2 with capacity remaining\n        # Use ternary search on l (number of weight 2 items)\n        def get_value(l):\n            rem_weight = remaining - 2 * l\n            if rem_weight < 0:\n                return 0\n            k = min(rem_weight, len1)\n            return sum2[l] + sum1[k]\n        \n        low = 0\n        high = min(len2, remaining // 2)\n        best = 0\n        # Ternary search\n        for _ in range(100):\n            if high - low <= 3:\n                break\n            m1 = low + (high - low) // 3\n            m2 = high - (high - low) // 3\n            v1 = get_value(m1)\n            v2 = get_value(m2)\n            if v1 < v2:\n                low = m1 + 1\n            else:\n                high = m2 - 1\n        \n        # Check all values in the final range\n        for l in range(max(0, low - 2), min(high + 2, len2) + 1):\n            if l > min(len2, remaining // 2):\n                continue\n            current = get_value(l)\n            if current > best:\n                best = current\n        \n        total = sum3[p] + best\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: The items are grouped by their weights and sorted in descending order of their costs to prioritize higher value items.\n2. **Prefix Sums**: Prefix sums are computed for each group to quickly determine the total cost for any number of items taken from that group.\n3. **Ternary Search**: For each possible number of weight 3 items, the remaining capacity is used to determine the optimal combination of weight 1 and 2 items using a ternary search to efficiently find the maximum value within the constraints.\n\nThis approach ensures that we efficiently explore the possible combinations of items while leveraging sorting and prefix sums to quickly compute costs, leading to an optimal solution within the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums for each group\n    sum1 = [0]\n    for c in w1:\n        sum1.append(sum1[-1] + c)\n    \n    sum2 = [0]\n    for c in w2:\n        sum2.append(sum2[-1] + c)\n    \n    sum3 = [0]\n    for c in w3:\n        sum3.append(sum3[-1] + c)\n    \n    len1 = len(w1)\n    len2 = len(w2)\n    len3 = len(w3)\n    \n    max_total = 0\n    \n    # Iterate over possible number of weight 3 items\n    max_p = min(len3, m // 3)\n    for p in range(0, max_p + 1):\n        remaining = m - 3 * p\n        if remaining < 0:\n            continue\n        \n        # Now compute max value for weight 1 and 2 with capacity remaining\n        # Use ternary search on l (number of weight 2 items)\n        def get_value(l):\n            rem_weight = remaining - 2 * l\n            if rem_weight < 0:\n                return 0\n            k = min(rem_weight, len1)\n            return sum2[l] + sum1[k]\n        \n        low = 0\n        high = min(len2, remaining // 2)\n        best = 0\n        # Ternary search\n        for _ in range(100):\n            if high - low <= 3:\n                break\n            m1 = low + (high - low) // 3\n            m2 = high - (high - low) // 3\n            v1 = get_value(m1)\n            v2 = get_value(m2)\n            if v1 < v2:\n                low = m1 + 1\n            else:\n                high = m2 - 1\n        \n        # Check all values in the final range\n        for l in range(max(0, low - 2), min(high + 2, len2) + 1):\n            if l > min(len2, remaining // 2):\n                continue\n            current = get_value(l)\n            if current > best:\n                best = current\n        \n        total = sum3[p] + best\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 1016,
        "thoughts_token_count": 8192
    }
}