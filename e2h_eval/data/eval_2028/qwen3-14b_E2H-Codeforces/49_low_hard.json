{
    "start": 1758309774.5733235,
    "end": 1758309893.922146,
    "start-formatted": "2025-09-20 04:22 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road (edge) between two lawns (vertices). \n\nSo, the input gives us a graph where each edge has a GCD and LCM of the two nodes it connects. We need to assign numbers to each node such that for every edge, the GCD and LCM of the two nodes match the given values. If there's no possible assignment, we return \"NO\".\n\nFirst, I need to think about the constraints between the nodes. For any edge between u and v, let's say the GCD is g and LCM is l. Then, we know that for the numbers a (on u) and b (on v), the following must hold:\n\ngcd(a, b) = g\nlcm(a, b) = l\n\nBut there's a relationship between GCD and LCM: gcd(a,b) * lcm(a,b) = a*b. So, for each edge, we can derive that a*b = g*l. Also, since the GCD is g, both a and b must be multiples of g. Let me think: Let a = g * x, b = g * y. Then, gcd(x,y) must be 1, because if they had a common divisor, then the GCD of a and b would be higher than g. And the LCM of a and b would be g * x * y. Therefore, the LCM is equal to g * x * y. But according to the problem, the LCM is given as l. Therefore, we have:\n\ng * x * y = l => x*y = l/g.\n\nBut since x and y are coprime, this implies that x and y must be divisors of l/g, and their product is exactly l/g. Also, since x and y are coprime, each of them must be a factor of l/g, and they must divide into it such that their product equals l/g. \n\nSo for each edge, the product of x and y must be l/g, and they are coprime. Therefore, for each edge, the possible pairs (x, y) are coprime pairs whose product is l/g. However, since the problem allows any valid assignment, perhaps we can assign x and y in a way that allows the rest of the graph to be consistent.\n\nBut how do we model this for the entire graph? It seems like a graph problem where each node's value is determined by the edges connected to it. However, since each edge imposes constraints on the pair of nodes, we need to find a way to assign values to nodes such that all these constraints are satisfied.\n\nThis feels like a graph problem that can be modeled with a union-find structure or some kind of constraints propagation. But since the constraints are multiplicative and involve coprimality, maybe we can model this as a graph where each node's value is determined relative to others.\n\nLet me think again. Each node's value must be a multiple of the GCD of each edge it's part of. Wait, but for a node connected to multiple edges, each with different GCDs. How can that be handled?\n\nFor example, suppose node u is connected to two edges. The first edge has GCD g1, and the second has GCD g2. Then, the value of u must be a multiple of both g1 and g2. Therefore, the value of u must be a multiple of the LCM(g1, g2). But wait, that's only if those edges are connected to u. So, for each node, the value must be a multiple of all the GCDs of the edges connected to it. However, this might not be directly applicable. Because each edge's GCD is the GCD of the two nodes connected by that edge. For example, if node u is connected to node v with GCD g, then the value of u must be a multiple of g, and the value of v must also be a multiple of g. But if u is connected to another node w with GCD h, then u must be a multiple of h as well. Therefore, the value of u must be a multiple of the LCM of all the GCDs of its incident edges. Or maybe not? Wait, no. Suppose u is connected to v with GCD g, and to w with GCD h. Then, the GCD of u and v is g, so u must be a multiple of g, and v must be a multiple of g. Similarly, u must be a multiple of h, and w must be a multiple of h. Therefore, u must be a multiple of both g and h, so LCM(g, h) divides u. But what if the GCDs of different edges are not compatible? For example, if u",
    "response": "```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    # Check if LCM is divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    # Assign values to nodes\n    value = [-1] * n\n    visited = [False] * n\n\n    def dfs(u, val):\n        if visited[u]:\n            return val == value[u]\n        visited[u] = True\n        value[u] = val\n        for v, g, l in graph[u]:\n            if value[v] == -1:\n                # Compute the product x*y = l/g\n                prod = l // g\n                # We need to find x and y such that x*y = prod, gcd(x,y) = 1\n                # Since val = g * x, then y = prod / x\n                # So the value of v should be g * y = g * (prod / x) = (g * prod) / x = l / x\n                # But since val = g * x => x = val / g\n                x = val // g\n                if val % g != 0:\n                    return False\n                if x * x > prod:\n                    return False\n                # Find y such that x*y = prod and gcd(x,y) = 1\n                y = prod // x\n                if math.gcd(x, y) != 1:\n                    return False\n                if not dfs(v, g * y):\n                    return False\n            else:\n                # Check if current value of v is compatible with u's value\n                a = value[u]\n                b = value[v]\n                if math.gcd(a, b) != g or (a * b) // math.gcd(a, b) != l:\n                    return False\n        return True\n\n    for i in range(n):\n        if not visited[i] and value[i] == -1:\n            # Try to assign a value starting from this node\n            # We can choose any valid value for the first node in the component\n            # However, we need to ensure that all constraints are satisfied\n            # So we need to build a system where values are determined relative to each other\n            # Let's use BFS to assign values\n            queue = deque()\n            queue.append(i)\n            visited[i] = True\n            value[i] = 1  # Start with 1, but need to adjust based on constraints\n            # Wait, but how do we know what to assign? Maybe we need to assign based on the edges\n            # This approach might not work. Let's think again.\n\n            # Instead, we can model this as a graph where each node's value is determined relative to others\n            # Each edge imposes that the product of the two nodes is g*l, and their GCD is g.\n            # So for each connected component, we can pick a starting node and assign a value, then propagate through the graph.\n\n            # For example, start with node i, assign it a value of g * x, where x is a divisor of (l/g), and then propagate accordingly.\n            # But how to choose x? It depends on the constraints from other edges.\n\n            # Let's try BFS approach again, but with proper assignment.\n            # We need to assign value to i, then for each neighbor, determine possible value based on the edge constraints.\n            # But since the value is not known yet, we have to assign it in a way that satisfies all constraints.\n\n            # Let's try to build equations for the connected component.\n            # For each connected component, we can treat it as a graph where each edge (u, v) has a relation: value[u] * value[v] = g*l, and gcd(value[u], value[v]) = g.\n            # Let me think: value[u] = g * x, value[v] = g * y, where x and y are coprime, and x*y = l/g.\n\n            # So, for each edge, we have value[u] = g * x, value[v] = g * y, with x*y = l/g and gcd(x,y)=1.\n            # Thus, the ratio between value[u] and value[v] is x/y, which must be rational and satisfy the coprimality condition.\n\n            # So, for a connected component, we can assign a base value to one node and derive others based on that.\n\n            # However, this seems complicated. Another idea: for each connected component, build a graph where each node's value is determined relative to others.\n            # Let's consider building a graph where each edge (u, v) has a relation value[u] = k * value[v], where k is a rational number derived from the edge's GCD and LCM.\n\n            # But how to handle this? Let's take an example. Suppose we have an edge between u and v with GCD g and LCM l. Then value[u] * value[v] = g*l. Also, value[u] and value[v] must be multiples of g.\n\n            # Let me define value[u] = g * a, value[v] = g * b. Then a*b = l/g, and gcd(a,b) = 1. So, a and b are coprime factors of l/g.\n\n            # Therefore, for each edge, the pair (a, b) must be coprime and multiply to l/g. But since the problem allows any valid assignment, we can choose either (a, b) or (b, a) for each edge.\n\n            # This suggests that the graph can be modeled with constraints on ratios between nodes. However, since the values are integers, this might not be straightforward.\n\n            # Another approach: For each connected component, we can assign a value to one node, then use the edges to propagate the values. However, if during propagation we encounter a contradiction, we return \"NO\".\n\n            # Let's try this approach again, using BFS with proper assignments.\n\n            # Start by assigning value[i] as g * x, where x is a factor of l/g. However, since we don't know which x to choose, perhaps we can assign value[i] as the GCD of its edges. Wait, but that may not be sufficient.\n\n            # Let's consider the following: For each node, the value must be a multiple of all GCDs of edges incident to it. So, the minimal possible value for a node is the LCM of the GCDs of its incident edges. However, this may not be sufficient because of the LCM constraints.\n\n            # Alternatively, we can model the problem as a graph where each edge defines a relationship between the two nodes. For example, if u and v are connected with GCD g and LCM l, then value[u] = g * x, value[v] = g * y, with x * y = l/g and gcd(x, y) = 1. So, for each edge, the ratio between value[u] and value[v] is x/y, which is a rational number. But since x and y are coprime, this ratio is reduced.\n\n            # So, the problem reduces to checking if the graph is bipartite with respect to these ratios. However, I'm not sure.\n\n            # Given the time constraints, let's look for a solution approach that uses BFS to assign values and check for consistency.\n\n            # Here's a plan:\n\n            # 1. For each connected component, pick a starting node and assign it a value (we'll need to choose this value carefully).\n            # 2. Use BFS to assign values to other nodes based on the edges.\n            # 3. During BFS, for each edge, check if the current value of the node is compatible with the neighbor's value. If not, return \"NO\".\n            # 4. If all checks pass, return the values.\n\n            # The challenge is choosing the initial value for the starting node. How?\n\n            # Let's assume that for the starting node, we can assign it a value of g * x, where x is a factor of l/g. However, since the value is unknown, maybe we can set it to g * 1 (i.e., the GCD of the edge), but that may not work for all cases.\n\n            # Alternatively, for the starting node, we can set its value to the GCD of all edges incident to it. But this may not be possible if there are multiple edges with different GCDs.\n\n            # This seems tricky. Let's think of a different approach.\n\n            # For each edge (u, v, g, l), we have value[u] = g * x, value[v] = g * y, x * y = l/g, gcd(x, y) = 1.\n\n            # So, for each edge, we can express the relationship between x and y. Since x and y are coprime, they must be factors of l/g.\n\n            # So, for each edge, we can represent it as a constraint between u and v, where the value of u is g * x, and the value of v is g * y, with x * y = l/g and gcd(x, y) = 1.\n\n            # Now, considering that for the entire graph, the values must be consistent across all edges, we can model this as a graph where each edge defines a ratio between the values of the two nodes.\n\n            # For example, if we have an edge (u, v) with g and l, then value[u]/value[v] = x/y = (x/y) where x*y = l/g and gcd(x, y) = 1. But this ratio is not fixed unless we fix x and y.\n\n            # To avoid dealing with fractions, perhaps we can represent the relationships as multiplicative factors. However, this is getting complex.\n\n            # Given the time, I'll refer to a standard approach used in similar problems, such as building a graph with constraints and using BFS/DFS to assign values.\n\n            # Let's proceed with the following steps:\n\n            # - For each connected component, perform a BFS/DFS to assign values.\n            # - For the starting node, assign a value that is compatible with its edges. For example, if the starting node is part of an edge, we can assign it a value based on that edge.\n            # - For each neighbor, calculate the required value based on the edge's GCD and LCM.\n\n            # Let's implement this with BFS.\n\n            # Initialize the queue with node i, and assign it a value. But what value?\n            # For example, suppose node i is connected to node j via an edge with GCD g and LCM l. Then, the value of node i must be a multiple of g. Let's say we assign it g * a, and node j gets g * b, with a * b = l/g and gcd(a, b) = 1.\n\n            # However, without knowing a and b, how can we proceed? Perhaps for the starting node, we can assign it any value that is compatible with its edges. But since the starting node may be part of multiple edges, this could be complex.\n\n            # Another idea: For each edge (u, v, g, l), we can derive that the product of the values of u and v is g*l. So, if we know the value of u, we can compute the value of v as (g*l) / value[u]. But this only works if value[u] divides g*l.\n\n            # This suggests that we can use this relationship to propagate values through the graph. For example, in BFS:\n\n            # 1. Start with node i, assign it a value. Let's choose 1 initially, but that may not work. Wait, but the value must be a multiple of the GCD of all edges incident to it. So, perhaps the initial value should be the GCD of the edges' GCDs. Or not?\n\n            # This is getting too vague. Let's try to implement the BFS approach with the following logic:\n\n            # When visiting a node u, for each neighbor v, if v hasn't been assigned a value, compute the required value for v based on u's value and the edge's GCD and LCM.\n\n            # For example, suppose u has value a, and the edge between u and v has GCD g and LCM l. Then, the product a * b = g * l, where b is the value of v. So, b = (g * l) / a. But for this to be valid, a must divide g*l. Also, the GCD of a and b must be g.\n\n            # So, during BFS:\n\n            # - For each edge (u, v, g, l), when u's value is known, v's value is determined as (g*l) // a, provided that a divides g*l and the GCD of a and b is g.\n\n            # But how to choose the initial value for the starting node?\n\n            # For the starting node, since it has no value, we can choose any value that is compatible with its edges. But how?\n\n            # For example, if the starting node is connected to another node via an edge with GCD g and LCM l, then the value of the starting node must be a divisor of g*l, and the value of the other node would be (g*l)/a. Also, the GCD of a and (g*l)/a must be g.\n\n            # This seems like a system of equations. However, solving it for arbitrary graphs is difficult.\n\n            # Given the time, I'll proceed with the following approach:\n\n            # For each connected component, pick a starting node and assign it a value. Let's say the starting node is connected to some edges. We can assign it a value that is compatible with those edges. For example, for the first edge connected to the starting node, we can set its value to g * x, where x is a divisor of l/g, and then set the neighbor's value accordingly.\n\n            # However, without knowing x, this is challenging. So, perhaps for the first edge, we can set the starting node's value to g, and the neighbor's value to l. Let's see:\n\n            # If the edge has GCD g and LCM l, then a * b = g * l. If we set a = g, then b = l. Then, GCD(g, l) must be g. Which implies that g divides l. Which is true, since LCM is a multiple of GCD.\n\n            # Yes! Because the LCM is always a multiple of the GCD. So, for any edge, l is divisible by g. So, setting the value of u to g and the value of v to l would satisfy a * b = g * l. However, we also need to ensure that the GCD of a and b is g. Let's check:\n\n            # GCD(g, l) = g? Well, since l is the LCM of a and b, and a = g, b = l. But the LCM of g and l is l. So, the GCD of g and l must be g. Which is true only if g divides l. Which it does, since l is a multiple of g.\n\n            # So, for any edge, setting one node's value to g and the other to l will satisfy the product condition and the GCD condition.\n\n            # However, this may not work for the rest of the graph. For example, if the same node is connected to multiple edges, the value assigned based on one edge may conflict with another.\n\n            # But this gives us a starting point. So, here's a revised plan:\n\n            # For each connected component:\n            # 1. Pick a starting node and assign it a value. For the first edge connected to it, assign it to g (the GCD of that edge) and the neighbor to l (the LCM of that edge).\n            # 2. Use BFS to propagate values to other nodes based on the edge constraints.\n            # 3. During propagation, for each edge, compute the required value of the neighbor based on the current node's value and the edge's g and l.\n            # 4. If during this process, a contradiction is found (e.g., the computed value doesn't satisfy the GCD and LCM conditions), return \"NO\".\n            # 5. If all checks pass, return \"YES\" and the values.\n\n            # Let's try to implement this.\n\n            # For the starting node, we need to select an edge to initialize its value. Let's pick the first edge in the graph for the component.\n\n            # Let's implement this:\n\n            # For the current component, pick the first node i, and find its first edge. Assume it's connected to node j with g and l. Assign value[i] = g, value[j] = l. Then, proceed with BFS.\n\n            # However, what if the node i has no edges? That's possible if m=0. In that case, the value can be any positive integer, but since the problem requires to output any valid configuration, we can set it to 1.\n\n            # Let's code this.\n\n            # First, handle the case when the component has no edges (m=0). In this case, all nodes can have any value (but since the problem says to output any valid configuration, we can set them to 1).\n\n            # But in our case, the input may have m=0 and n>1. For example, in the first sample input, the first case is n=1, m=0. Output is 1.\n\n            # So, for each node in a component with no edges, we can assign it any value. For simplicity, assign 1.\n\n            # Now, implement this:\n\n            # For each unvisited node i:\n            if not visited[i]:\n                # Initialize the component\n                queue = deque()\n                queue.append(i)\n                visited[i] = True\n                # If there are no edges, assign 1\n                if not graph[i]:\n                    value[i] = 1\n                    continue\n                # Else, pick the first edge to assign values\n                # Take the first edge from i\n                u, v, g, l = graph[i][0]\n                # Assign value[i] = g, value[v] = l\n                value[i] = g\n                value[v] = l\n                queue.append(v)\n                visited[v] = True\n\n                while queue:\n                    curr = queue.popleft()\n                    for neighbor, edge_g, edge_l in graph[curr]:\n                        if not visited[neighbor]:\n                            # Compute the required value for neighbor\n                            # curr_val * neighbor_val = edge_g * edge_l\n                            # neighbor_val = (edge_g * edge_l) // curr_val\n                            curr_val = value[curr]\n                            neighbor_val = (edge_g * edge_l) // curr_val\n                            # Check if curr_val divides edge_g * edge_l\n                            if (edge_g * edge_l) % curr_val != 0:\n                                print(\"NO\")\n                                return\n                            # Check if GCD(curr_val, neighbor_val) == edge_g\n                            if math.gcd(curr_val, neighbor_val) != edge_g:\n                                print(\"NO\")\n                                return\n                            value[neighbor] = neighbor_val\n                            visited[neighbor] = True\n                            queue.append(neighbor)\n                        else:\n                            # Check if the current value of neighbor is compatible with curr's value\n                            curr_val = value[curr]\n                            neigh_val = value[neighbor]\n                            if curr_val * neigh_val != edge_g * edge_l or math.gcd(curr_val, neigh_val) != edge_g:\n                                print(\"NO\")\n                                return\n\n    # After processing all components, check all edges to ensure consistency\n    for u, v, g, l in edges:\n        a = value[u]\n        b = value[v]\n        if a * b != g * l or math.gcd(a, b) != g:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, value)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n\n    # Check if LCM is divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    # Assign values to nodes\n    value = [-1] * n\n    visited = [False] * n\n\n    def dfs(u, val):\n        if visited[u]:\n            return val == value[u]\n        visited[u] = True\n        value[u] = val\n        for v, g, l in graph[u]:\n            if value[v] == -1:\n                # Compute the product x*y = l/g\n                prod = l // g\n                # We need to find x and y such that x*y = prod, gcd(x,y) = 1\n                # Since val = g * x, then y = prod / x\n                # So the value of v should be g * y = g * (prod / x) = (g * prod) / x = l / x\n                # But since val = g * x => x = val / g\n                x = val // g\n                if val % g != 0:\n                    return False\n                if x * x > prod:\n                    return False\n                # Find y such that x*y = prod and gcd(x,y) = 1\n                y = prod // x\n                if math.gcd(x, y) != 1:\n                    return False\n                if not dfs(v, g * y):\n                    return False\n            else:\n                # Check if current value of v is compatible with u's value\n                a = value[u]\n                b = value[v]\n                if math.gcd(a, b) != g or (a * b) // math.gcd(a, b) != l:\n                    return False\n        return True\n\n    for i in range(n):\n        if not visited[i] and value[i] == -1:\n            # Try to assign a value starting from this node\n            # We can choose any valid value for the first node in the component\n            # However, we need to ensure that all constraints are satisfied\n            # So we need to build a system where values are determined relative to each other\n            # Let's use BFS to assign values\n            queue = deque()\n            queue.append(i)\n            visited[i] = True\n            value[i] = 1  # Start with 1, but need to adjust based on constraints\n            # Wait, but how do we know what to assign? Maybe we need to assign based on the edges\n            # This approach might not work. Let's think again.\n\n            # Instead, we can model this as a graph where each node's value is determined relative to others\n            # Each edge imposes that the product of the two nodes is g*l, and their GCD is g.\n            # So for each connected component, we can pick a starting node and assign a value, then propagate through the graph.\n\n            # For example, start with node i, assign it a value of g * x, where x is a divisor of (l/g), and then propagate accordingly.\n            # But how to choose x? It depends on the constraints from other edges.\n\n            # Let's try BFS approach again, but with proper assignment.\n            # We need to assign value to i, then for each neighbor, determine possible value based on the edge constraints.\n            # But since the value is not known yet, we have to assign it in a way that satisfies all constraints.\n\n            # Let's try to build equations for the connected component.\n            # For each connected component, we can treat it as a graph where each edge (u, v) has a relation: value[u] * value[v] = g*l, and gcd(value[u], value[v]) = g.\n            # Let me think: value[u] = g * x, value[v] = g * y, where x and y are coprime, and x*y = l/g.\n\n            # So, for each edge, we have value[u] = g * x, value[v] = g * y, with x*y = l/g and gcd(x,y)=1.\n            # Thus, the ratio between value[u] and value[v] is x/y, which must be rational and satisfy the coprimality condition.\n\n            # So, for a connected component, we can assign a base value to one node and derive others based on that.\n\n            # However, this seems complicated. Another idea: for each connected component, build a graph where each node's value is determined relative to others.\n            # Let's consider building a graph where each edge (u, v) has a relation value[u] = k * value[v], where k is a rational number derived from the edge's GCD and LCM.\n\n            # But how to handle this? Let's take an example. Suppose we have an edge between u and v with GCD g and LCM l. Then value[u] * value[v] = g*l. Also, value[u] and value[v] must be multiples of g.\n\n            # Let me define value[u] = g * a, value[v] = g * b. Then a*b = l/g, and gcd(a,b) = 1. So, a and b are coprime factors of l/g.\n\n            # Therefore, for each edge, the pair (a, b) must be coprime and multiply to l/g. But since the problem allows any valid assignment, we can choose either (a, b) or (b, a) for each edge.\n\n            # This suggests that the graph can be modeled with constraints on ratios between nodes. However, since the values are integers, this might not be straightforward.\n\n            # Another approach: For each connected component, we can assign a value to one node, then use the edges to propagate the values. However, if during propagation we encounter a contradiction, we return \"NO\".\n\n            # Let's try this approach again, using BFS with proper assignments.\n\n            # Start by assigning value[i] as g * x, where x is a factor of l/g. However, since we don't know which x to choose, perhaps we can assign value[i] as the GCD of its edges. Wait, but that may not be sufficient.\n\n            # Let's consider the following: For each node, the value must be a multiple of all GCDs of edges incident to it. So, the minimal possible value for a node is the LCM of the GCDs of its incident edges. However, this may not be sufficient because of the LCM constraints.\n\n            # Alternatively, we can model the problem as a graph where each edge defines a relationship between the two nodes. For example, if u and v are connected with GCD g and LCM l, then value[u] = g * x, value[v] = g * y, with x * y = l/g and gcd(x, y) = 1. So, for each edge, the ratio between value[u] and value[v] is x/y, which is a rational number. But since x and y are coprime, this ratio is reduced.\n\n            # So, the problem reduces to checking if the graph is bipartite with respect to these ratios. However, I'm not sure.\n\n            # Given the time constraints, let's look for a solution approach that uses BFS to assign values and check for consistency.\n\n            # Here's a plan:\n\n            # 1. For each connected component, pick a starting node and assign it a value (we'll need to choose this value carefully).\n            # 2. Use BFS to assign values to other nodes based on the edges.\n            # 3. During BFS, for each edge, check if the current value of the node is compatible with the neighbor's value. If not, return \"NO\".\n            # 4. If all checks pass, return the values.\n\n            # The challenge is choosing the initial value for the starting node. How?\n\n            # Let's assume that for the starting node, we can assign it a value of g * x, where x is a factor of l/g. However, since the value is unknown, maybe we can set it to g * 1 (i.e., the GCD of the edge), but that may not work for all cases.\n\n            # Alternatively, for the starting node, we can set its value to the GCD of all edges incident to it. But this may not be possible if there are multiple edges with different GCDs.\n\n            # This seems tricky. Let's think of a different approach.\n\n            # For each edge (u, v, g, l), we have value[u] = g * x, value[v] = g * y, x * y = l/g, gcd(x, y) = 1.\n\n            # So, for each edge, we can express the relationship between x and y. Since x and y are coprime, they must be factors of l/g.\n\n            # So, for each edge, we can represent it as a constraint between u and v, where the value of u is g * x, and the value of v is g * y, with x * y = l/g and gcd(x, y) = 1.\n\n            # Now, considering that for the entire graph, the values must be consistent across all edges, we can model this as a graph where each edge defines a ratio between the values of the two nodes.\n\n            # For example, if we have an edge (u, v) with g and l, then value[u]/value[v] = x/y = (x/y) where x*y = l/g and gcd(x, y) = 1. But this ratio is not fixed unless we fix x and y.\n\n            # To avoid dealing with fractions, perhaps we can represent the relationships as multiplicative factors. However, this is getting complex.\n\n            # Given the time, I'll refer to a standard approach used in similar problems, such as building a graph with constraints and using BFS/DFS to assign values.\n\n            # Let's proceed with the following steps:\n\n            # - For each connected component, perform a BFS/DFS to assign values.\n            # - For the starting node, assign a value that is compatible with its edges. For example, if the starting node is part of an edge, we can assign it a value based on that edge.\n            # - For each neighbor, calculate the required value based on the edge's GCD and LCM.\n\n            # Let's implement this with BFS.\n\n            # Initialize the queue with node i, and assign it a value. But what value?\n            # For example, suppose node i is connected to node j via an edge with GCD g and LCM l. Then, the value of node i must be a multiple of g. Let's say we assign it g * a, and node j gets g * b, with a * b = l/g and gcd(a, b) = 1.\n\n            # However, without knowing a and b, how can we proceed? Perhaps for the starting node, we can assign it any value that is compatible with its edges. But since the starting node may be part of multiple edges, this could be complex.\n\n            # Another idea: For each edge (u, v, g, l), we can derive that the product of the values of u and v is g*l. So, if we know the value of u, we can compute the value of v as (g*l) / value[u]. But this only works if value[u] divides g*l.\n\n            # This suggests that we can use this relationship to propagate values through the graph. For example, in BFS:\n\n            # 1. Start with node i, assign it a value. Let's choose 1 initially, but that may not work. Wait, but the value must be a multiple of the GCD of all edges incident to it. So, perhaps the initial value should be the GCD of the edges' GCDs. Or not?\n\n            # This is getting too vague. Let's try to implement the BFS approach with the following logic:\n\n            # When visiting a node u, for each neighbor v, if v hasn't been assigned a value, compute the required value for v based on u's value and the edge's GCD and LCM.\n\n            # For example, suppose u has value a, and the edge between u and v has GCD g and LCM l. Then, the product a * b = g * l, where b is the value of v. So, b = (g * l) / a. But for this to be valid, a must divide g*l. Also, the GCD of a and b must be g.\n\n            # So, during BFS:\n\n            # - For each edge (u, v, g, l), when u's value is known, v's value is determined as (g*l) // a, provided that a divides g*l and the GCD of a and b is g.\n\n            # But how to choose the initial value for the starting node?\n\n            # For the starting node, since it has no value, we can choose any value that is compatible with its edges. But how?\n\n            # For example, if the starting node is connected to another node via an edge with GCD g and LCM l, then the value of the starting node must be a divisor of g*l, and the value of the other node would be (g*l)/a. Also, the GCD of a and (g*l)/a must be g.\n\n            # This seems like a system of equations. However, solving it for arbitrary graphs is difficult.\n\n            # Given the time, I'll proceed with the following approach:\n\n            # For each connected component, pick a starting node and assign it a value. Let's say the starting node is connected to some edges. We can assign it a value that is compatible with those edges. For example, for the first edge connected to the starting node, we can set its value to g * x, where x is a divisor of l/g, and then set the neighbor's value accordingly.\n\n            # However, without knowing x, this is challenging. So, perhaps for the first edge, we can set the starting node's value to g, and the neighbor's value to l. Let's see:\n\n            # If the edge has GCD g and LCM l, then a * b = g * l. If we set a = g, then b = l. Then, GCD(g, l) must be g. Which implies that g divides l. Which is true, since LCM is a multiple of GCD.\n\n            # Yes! Because the LCM is always a multiple of the GCD. So, for any edge, l is divisible by g. So, setting the value of u to g and the value of v to l would satisfy a * b = g * l. However, we also need to ensure that the GCD of a and b is g. Let's check:\n\n            # GCD(g, l) = g? Well, since l is the LCM of a and b, and a = g, b = l. But the LCM of g and l is l. So, the GCD of g and l must be g. Which is true only if g divides l. Which it does, since l is a multiple of g.\n\n            # So, for any edge, setting one node's value to g and the other to l will satisfy the product condition and the GCD condition.\n\n            # However, this may not work for the rest of the graph. For example, if the same node is connected to multiple edges, the value assigned based on one edge may conflict with another.\n\n            # But this gives us a starting point. So, here's a revised plan:\n\n            # For each connected component:\n            # 1. Pick a starting node and assign it a value. For the first edge connected to it, assign it to g (the GCD of that edge) and the neighbor to l (the LCM of that edge).\n            # 2. Use BFS to propagate values to other nodes based on the edge constraints.\n            # 3. During propagation, for each edge, compute the required value of the neighbor based on the current node's value and the edge's g and l.\n            # 4. If during this process, a contradiction is found (e.g., the computed value doesn't satisfy the GCD and LCM conditions), return \"NO\".\n            # 5. If all checks pass, return \"YES\" and the values.\n\n            # Let's try to implement this.\n\n            # For the starting node, we need to select an edge to initialize its value. Let's pick the first edge in the graph for the component.\n\n            # Let's implement this:\n\n            # For the current component, pick the first node i, and find its first edge. Assume it's connected to node j with g and l. Assign value[i] = g, value[j] = l. Then, proceed with BFS.\n\n            # However, what if the node i has no edges? That's possible if m=0. In that case, the value can be any positive integer, but since the problem requires to output any valid configuration, we can set it to 1.\n\n            # Let's code this.\n\n            # First, handle the case when the component has no edges (m=0). In this case, all nodes can have any value (but since the problem says to output any valid configuration, we can set them to 1).\n\n            # But in our case, the input may have m=0 and n>1. For example, in the first sample input, the first case is n=1, m=0. Output is 1.\n\n            # So, for each node in a component with no edges, we can assign it any value. For simplicity, assign 1.\n\n            # Now, implement this:\n\n            # For each unvisited node i:\n            if not visited[i]:\n                # Initialize the component\n                queue = deque()\n                queue.append(i)\n                visited[i] = True\n                # If there are no edges, assign 1\n                if not graph[i]:\n                    value[i] = 1\n                    continue\n                # Else, pick the first edge to assign values\n                # Take the first edge from i\n                u, v, g, l = graph[i][0]\n                # Assign value[i] = g, value[v] = l\n                value[i] = g\n                value[v] = l\n                queue.append(v)\n                visited[v] = True\n\n                while queue:\n                    curr = queue.popleft()\n                    for neighbor, edge_g, edge_l in graph[curr]:\n                        if not visited[neighbor]:\n                            # Compute the required value for neighbor\n                            # curr_val * neighbor_val = edge_g * edge_l\n                            # neighbor_val = (edge_g * edge_l) // curr_val\n                            curr_val = value[curr]\n                            neighbor_val = (edge_g * edge_l) // curr_val\n                            # Check if curr_val divides edge_g * edge_l\n                            if (edge_g * edge_l) % curr_val != 0:\n                                print(\"NO\")\n                                return\n                            # Check if GCD(curr_val, neighbor_val) == edge_g\n                            if math.gcd(curr_val, neighbor_val) != edge_g:\n                                print(\"NO\")\n                                return\n                            value[neighbor] = neighbor_val\n                            visited[neighbor] = True\n                            queue.append(neighbor)\n                        else:\n                            # Check if the current value of neighbor is compatible with curr's value\n                            curr_val = value[curr]\n                            neigh_val = value[neighbor]\n                            if curr_val * neigh_val != edge_g * edge_l or math.gcd(curr_val, neigh_val) != edge_g:\n                                print(\"NO\")\n                                return\n\n    # After processing all components, check all edges to ensure consistency\n    for u, v, g, l in edges:\n        a = value[u]\n        b = value[v]\n        if a * b != g * l or math.gcd(a, b) != g:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, value)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 4418,
        "thoughts_token_count": 1024
    }
}