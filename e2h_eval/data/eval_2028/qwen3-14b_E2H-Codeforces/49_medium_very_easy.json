{
    "start": 1758307737.6098845,
    "end": 1758307986.0456142,
    "start-formatted": "2025-09-20 03:48 KST",
    "end-formatted": "2025-09-20 03:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine the number of mushrooms on each lawn based on the GCD and LCM values given for each road. The input gives me a graph where each edge has a GCD and LCM of the two connected nodes. My task is to assign numbers to each node such that for every edge, the GCD and LCM match the given values. If it's not possible, output NO.\n\nFirst, I should think about the constraints. For each edge between u and v, let's say the GCD is g and LCM is l. Then, we know that the numbers on u and v must satisfy:\n\n- GCD(a_u, a_v) = g\n- LCM(a_u, a_v) = l\n\nBut there's a relationship between GCD and LCM. Remember that for any two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So, if we have the GCD and LCM, then a * b = g * l. But since the GCD is g, both a and b must be multiples of g. Let me think: Let's say a = g * x, and b = g * y. Then GCD(a,b) = g * GCD(x,y). But since the GCD is given as g, that implies that GCD(x,y) must be 1. Also, the LCM of a and b would be g * x * y (since LCM(a,b) = (a*b)/GCD(a,b) = (g^2 x y)/(g * GCD(x,y)) ) = g * x y / GCD(x,y). But since GCD(x,y) is 1, LCM(a,b) is g * x * y. And this is supposed to equal l. Therefore, g * x * y = l. So x*y = l/g. But since x and y are coprime, this means that x and y must be divisors of l/g and their product is exactly l/g. Also, since x and y are coprime, they must be factors of l/g such that they are coprime.\n\nSo for each edge, the product of x and y is l/g. But since x and y are coprime, that implies that x and y are pairs of coprime factors of (l/g). However, since the problem allows any valid assignment, perhaps we can choose x and y in such a way that they are coprime and their product is l/g.\n\nBut how does this help us assign values to the nodes?\n\nThe key is that for each edge, the two nodes must be multiples of the GCD. So, for example, if an edge between u and v has GCD g and LCM l, then the values for u and v must be multiples of g, and their product must be g*l. Also, since GCD(a_u, a_v) is g, then a_u = g * x, a_v = g * y, where GCD(x,y) = 1 and x * y = l/g. So for each edge, we can model this as a constraint between u and v.\n\nNow, the problem reduces to assigning values to each node such that for each edge, the above conditions hold.\n\nThis seems like a graph problem where each node's value is determined by some constraints. But how do we model this?\n\nAn idea is to model this as a graph where each node's value is determined relative to others. For example, if we can assign a value to one node, then the others can be determined based on the edges. However, since the graph may not be connected, each connected component can be handled separately.\n\nBut how do we handle the constraints? For example, if two nodes are connected by an edge, then their values are related. But if there's a path between them, then their values must be consistent with all edges along the path.\n\nLet me think of this as building a graph where each node's value is determined by the GCD and LCM constraints. For example, suppose we have a tree structure. We can pick a root node and assign a value, then propagate the constraints through the tree. However, if the graph has cycles, we need to check for consistency.\n\nWait, but the constraints for each edge must be compatible. For example, if there's a cycle, the product of the constraints around the cycle must be consistent.\n\nAlternatively, think of each node's value as being a multiple of some base value. Let's consider that for each edge between u and v, the GCD is g. Then, the values of u and v must be multiples of g. But how can we model this?\n\nAnother approach: For each node, the value is determined up to a multiple of the GCD of its connected edges. But this seems vague.\n\nLet me think again. For each edge u-v with GCD g and LCM l. Then, the product of the two node values must be g*l. Also, since the GCD is g, then the two node values must be multiples of g. Let's denote a_u = g * x, a_v = g * y. Then, x and y must be coprime, and x*y = l/g.\n\nSo for each edge, the product x*y must be l/g. Also, x and y are coprime.\n\nBut how to assign x and y for each edge. For example, if we have a connected component, perhaps we can assign variables to each node and set up equations based on the edges.\n\nBut this might be complex. Let's think of the problem as a graph where each node's value is determined by a base value multiplied by some factors. For example, if we can assign a base value for each node, such that for each edge, the base values satisfy the required conditions.\n\nAlternatively, considering that each edge's GCD and LCM must satisfy that l must be divisible by g. Because LCM(a, b) is always a multiple of GCD(a, b). So if l is not divisible by g, then the answer is impossible. Wait, that's a crucial check. For example, if for any edge, the LCM is not a multiple of the GCD, then it's impossible. Because LCM(a, b) must be a multiple of GCD(a, b). So for each edge, we can first check if l % g != 0. If that's the case, output NO.\n\nSo that's a necessary condition. So first, for each edge, check that l is divisible by g. If not, then output NO.\n\nAnother check is that for the same edge, the product of the GCD and LCM must be equal to the product of the two node values. Which is already handled by the above.\n\nOnce that is checked, for each edge, we can compute k = l / g. Then, x * y = k, and x and y are coprime.\n\nSo, for each edge, the two nodes must have values that are multiples of g, and their ratio (divided by g) must be coprime factors of k.\n\nNow, the problem becomes assigning values to each node such that for every edge, the two nodes' values are multiples of g, and their quotient (after dividing by g) are coprime factors of k.\n\nBut how to model this across the entire graph.\n\nLet me think of the graph as a collection of connected components. For each connected component, we can assign values to the nodes.\n\nLet me take an example. Suppose there's a single edge between u and v. GCD is g, LCM is l. Then, the values of u and v must be g*x and g*y, where x*y = l/g, and x and y are coprime. So for example, if l/g is 3, then x and y can be 1 and 3. So possible assignments are u= g*1, v= g*3 or vice versa. So there are two possibilities here. But since the problem allows any valid assignment, we can choose either.\n\nBut when there are multiple edges, the assignments must be consistent.\n\nFor example, consider a chain of three nodes u-v-w. Suppose the edge u-v has GCD g1 and LCM l1. The edge v-w has GCD g2 and LCM l2. Then, the value of v must satisfy the constraints from both edges.\n\nSo, perhaps we can model this as a graph where each node has a value, and for each edge, we can express the value of one node in terms of the other. However, since the relationships are multiplicative and involve coprime factors, this may be complex.\n\nAnother approach is to model the problem as a graph where each node's value is determined by a base value multiplied by some factors. For example, if we can assign a base value to each node, and then for each edge, the base values must satisfy certain conditions.\n\nWait, but how?\n\nLet me think again. Let's take the example of a connected component. Let's pick a starting node and assign a value to it. Then, for each adjacent node, based on the edge constraints, assign their value accordingly. However, during this process, we must ensure that the constraints are satisfied and that there are no contradictions when we traverse the graph.\n\nThis sounds like a BFS or DFS approach. For example, we can build a graph and assign values as we traverse, ensuring that each step meets the constraints. However, during traversal, we need to check for consistency.\n\nLet me think of the steps:\n\nFor each connected component:\n\n- Pick a starting node. Assign it a value. But what value?\n\nBut the problem is that the value can be any multiple of the GCDs of its edges. Wait, but how can we choose a value that is consistent with all edges?\n\nAlternatively, for each node, the value must be a multiple of the GCDs of all edges connected to it. Wait, no. Because for each edge, the node's value must be a multiple of the GCD of that edge. However, different edges connected to the same node may have different GCDs. For example, if a node u is connected to v via an edge with GCD g1, and to w via an edge with GCD g2, then the value of u must be a multiple of both g1 and g2. Therefore, the value of u must be a multiple of the LCM of all the GCDs of the edges connected to it. Wait, but that's not necessarily true. Because for example, if u is connected to v with GCD g1, then u's value must be a multiple of g1. Similarly, if u is connected to w with GCD g2, then u's value must be a multiple of g2. Therefore, the value of u must be a multiple of LCM(g1, g2). So for each node, the value must be a multiple of the LCM of the GCDs of all edges connected to it.\n\nBut how can we find such a value?\n\nAlternatively, for each node, the value can be expressed as the GCD of its edges multiplied by some factors. However, this seems too vague.\n\nLet me try to model this with variables. Let's think about the connected component. Suppose we have a tree structure. Let's pick a root node and assign a value to it. Then, for each child, based on the edge constraints, assign the value.\n\nBut how?\n\nLet's take an example. Suppose we have an edge between u and v with GCD g and LCM l. Then, as before, a_u = g * x, a_v = g * y, where x and y are coprime, and x*y = l/g. Now, if we assign a value to u, then v's value is determined as g * ( (l/g) / x ), but x must be chosen such that it divides (l/g) and is coprime with y. However, since x*y = l/g, once x is chosen, y is fixed. But how do we choose x?\n\nWait, but if we fix the value of u, then we can compute the value of v. Let me think. Suppose we have a_u = a. Then, since GCD(a, a_v) = g, and LCM(a, a_v) = l. Then, a must be a multiple of g, and a_v must be a multiple of g. Let me compute a_v.\n\nWe know that a * a_v = g * l. So a_v = (g * l) / a. But also, GCD(a, a_v) must be g. Let me check:\n\nSuppose a is a multiple of g. Let me write a = g * x. Then, a_v must be g * y, with x and y coprime, and x*y = l/g.\n\nSo, substituting into a_v = (g*l)/a = (g*l) / (g x) ) = l/(x) = (g * (l/g)) / x = (g * k)/x, where k = l/g.\n\nBut since x * y = k, then y = k/x. So a_v = g * (k/x) = g * y. Which is correct.\n\nSo, given that a is known (for u), then a_v is determined as (g*l)/a. But for this to be valid, (g*l) must be divisible by a. Also, GCD(a, a_v) must be g.\n\nBut how can we ensure that?\n\nWell, since a is a multiple of g, let me write a = g * x. Then a_v = (g*l) / (g x) ) = l/(x). But since l = g * k, where k = l/g, then a_v = (g * k)/x. But x * y = k, so y = k/x. Thus, a_v = g * y. Which is correct.\n\nBut for this to work, x must divide k. Since k = l/g, and x is part of the decomposition of k into coprime factors. However, how do we know that x divides k?\n\nBecause x * y = k. So yes, x must divide k. So, if we have a = g * x, then a_v = g * y, and x and y are coprime.\n\nBut how do we choose x? Well, if we have a connected graph, perhaps the way to proceed is to assign a value to a starting node, then for each neighbor, compute the value based on the edge's GCD and LCM. However, the problem is that during traversal, the computed value for a node may conflict with previous assignments.\n\nFor example, suppose we have a cycle. Let's say we start at node A, assign it a value, then compute the value of B based on the edge AB. Then compute the value of C based on the edge BC. Then, when we get back to A via another edge, the computed value must match the original value of A. Otherwise, it's impossible.\n\nSo, the approach could be:\n\n- For each connected component, perform a BFS or DFS, assigning values to nodes based on edges. If during traversal, a contradiction is found (e.g., a node's value is already assigned, but the computed value based on the current edge doesn't match), then the answer is NO.\n\nBut how do we choose the initial value for the starting node?\n\nAh! The starting node's value is not arbitrary. Because for the first edge, the value of the starting node must be a multiple of the GCD of that edge. But since we can choose any multiple, perhaps we can set the starting node's value as the GCD of the first edge multiplied by some factor. However, this seems ambiguous.\n\nWait, but maybe the starting node's value can be set to the GCD of the first edge multiplied by x, where x is a divisor of (l/g) for that edge. However, since we can choose x and y (coprime) such that x*y = (l/g), but how do we choose x?\n\nThis seems like a problem. Because without knowing x, we can't assign the value. But perhaps during traversal, the choice of x is forced by the constraints of the graph.\n\nAlternatively, perhaps the value of the starting node can be set to the GCD of the first edge, and then the other node's value is determined. But that may not be sufficient. Let me think.\n\nTake the example of a single edge between u and v with GCD g and LCM l. If we set u's value to g, then v's value must be (g*l)/u = (g*l)/g = l. Then, check if GCD(g, l) is equal to g. Well, since l is a multiple of g (as per earlier check), then GCD(g, l) is g. So that's correct. Also, the LCM(g, l) is l. Which is correct. So this works. Therefore, choosing the initial value as the GCD of the first edge is valid.\n\nBut wait, what if there are multiple edges connected to the starting node? For example, suppose the starting node is connected to multiple edges. Then, setting it to the GCD of the first edge may not be compatible with other edges. However, perhaps the starting node's value must be a multiple of all the GCDs of the edges connected to it. Therefore, the minimal possible value is the LCM of those GCDs. But how can we compute that?\n\nAlternatively, during traversal, when we assign the value to a node, we can set it to the GCD of the edge multiplied by some factor, but this seems unclear.\n\nWait, but perhaps the initial value can be set to the GCD of the edge, and during traversal, the other nodes are determined based on that. However, if there's a cycle, this may lead to a contradiction.\n\nLet me try to formalize this approach:\n\nFor each connected component:\n\n- Choose a starting node. Assign it a value of g (the GCD of the first edge connected to it). Then, for each adjacent node, compute the value based on the edge's GCD and LCM. For example, if the edge between u and v has GCD g_uv and LCM l_uv, then the value of v is (g_uv * l_uv) / value_of_u. Then, we check if the GCD of value_of_u and value_of_v is indeed g_uv. Also, check that the LCM is l_uv.\n\nBut wait, the value of u was set to g_uv. Then, value of v would be (g_uv * l_uv) / value_of_u = (g_uv * l_uv) / g_uv = l_uv. Then, GCD(g_uv, l_uv) must be g_uv, which is true because l_uv is a multiple of g_uv. So that's okay. But what about other edges connected to u?\n\nSuppose u is connected to another node w via an edge with GCD g_uw and LCM l_uw. Then, the value of u must be a multiple of g_uw. But if we set the initial value of u to g_uv (from the first edge), then it's only a multiple of g_uv. But not necessarily of g_uw. Which would be a problem.\n\nAh, right! So this approach would fail if the starting node has multiple edges with different GCDs. Because the initial value of the node is set to the GCD of the first edge, which may not be a multiple of the GCD of another edge connected to the same node.\n\nTherefore, the initial value of the node must be a multiple of all the GCDs of the edges connected to it. Therefore, the minimal possible value is the LCM of all the GCDs of the edges connected to the node. However, how can we compute that?\n\nBut how do we know the GCDs of all edges connected to the node before even starting? Because the edges are part of the input. For example, for a node u, we can collect all the GCDs of edges connected to it, compute their LCM, and set the initial value to that. But then, how do we ensure that this value satisfies the constraints of the edges?\n\nAlternatively, perhaps the initial value can be set to the product of all the GCDs of the edges connected to the node. But that seems computationally heavy and possibly unnecessary.\n\nHmm, this seems complicated. Maybe there's another way to model this.\n\nLet me think again. For each edge between u and v with GCD g and LCM l. We have:\n\na_u = g * x, a_v = g * y, with x and y coprime, x * y = l/g.\n\nWhich implies that a_u / g = x, a_v / g = y, and x and y are coprime.\n\nSo, for each node u, if we define b_u = a_u / g_uv for each edge connected to u. Wait, but this depends on the edge. That's not helpful.\n\nAlternatively, think of the entire graph. For each node u, the value a_u must be such that for every edge connected to u, a_u is a multiple of the GCD of that edge. Therefore, a_u must be a multiple of the LCM of all the GCDs of the edges connected to u.\n\nLet me call this value for node u as G. So, G is the LCM of all the GCDs of edges connected to u. Then, a_u must be a multiple of G.\n\nBut how do I compute this for each node?\n\nFor example, for a node u connected to edges with GCDs g1, g2, ..., then G = LCM(g1, g2, ...).\n\nOnce I compute this G for each node, then a_u must be a multiple of G.\n\nBut how can I use this in my approach?\n\nLet me try to think of the problem as building a graph where each node's value is a multiple of its G (the LCM of the GCDs of its edges). Then, for each edge between u and v, the GCD of a_u and a_v must be equal to the given GCD of the edge. Also, the LCM must be equal to the given LCM.\n\nBut how can I assign these values?\n\nAnother idea: Since for each edge, a_u and a_v are multiples of their respective GCDs. But the GCD of a_u and a_v is given. So, perhaps the GCD of a_u and a_v must be exactly the given GCD. Which implies that the given GCD must divide both a_u and a_v. Which it does, since a_u and a_v are multiples of their respective edge's GCDs. But how do I ensure that the GCD is exactly the given value?\n\nThis seems tricky. Let me think again of the earlier approach of using BFS/DFS and propagating values. Let's say that for each node, once we assign a value, we can compute the value of the adjacent nodes based on the edge's GCD and LCM. However, the problem is that the initial value must be a multiple of all the GCDs of the edges connected to it.\n\nBut how can I choose such a value?\n\nPerhaps, during the traversal, when I visit a node for the first time, I can assign it a value that is the LCM of the GCDs of all edges connected to it. Then, for each adjacent node, compute their value based on the edge's GCD and LCM.\n\nBut how to compute that?\n\nLet me take an example. Suppose node u has edges with GCDs g1, g2, etc. Let's assign a_u as LCM(g1, g2, ...). Then, for each edge between u and v with GCD g and LCM l, the value of v is (g*l)/a_u. But since a_u is a multiple of g (because LCM(g1, g2, ...) includes g as one of the GCDs?), no, not necessarily. Because the LCM of the GCDs of edges connected to u may not include the GCD of the current edge. Wait, for example, if u is connected to v via an edge with GCD g, and to another node w via an edge with GCD h. Then, the LCM of g and h is the value assigned to a_u. Then, for the edge between u and v, a_u is a multiple of g, so (g*l)/a_u would be (g*l) divided by a multiple of g, which is l divided by (a_u/g). But since a_u is the LCM of g and h, a_u/g is LCM(g, h)/g = h / GCD(g, h). Which may not be a divisor of l/g. But this seems problematic.\n\nHmm. This approach may not work.\n\nAlternative Idea:\n\nLet me think of the problem in terms of variables. For each node u, let’s define a_u as the value we need to assign. For each edge between u and v, with GCD g and LCM l, we have:\n\na_u = g * x\n\na_v = g * y\n\nwith x and y coprime, and x*y = l/g.\n\nSo, x and y are coprime factors of (l/g). Now, for this to be possible, l/g must be an integer, which we already checked earlier.\n\nBut how do we assign x and y for each edge?\n\nBut since the same node u may be part of multiple edges, the x values for each edge must be compatible. For example, if u is connected to v via edge with parameters g1, l1, and to w via edge with parameters g2, l2, then the x for the first edge (x1) and the x for the second edge (x2) must be such that a_u = g1 * x1 = g2 * x2. Which implies that g1 * x1 = g2 * x2. Which implies that x1/x2 = g2/g1. But since x1 and x2 are factors of l1/g1 and l2/g2 respectively, this may not be possible unless certain conditions are met.\n\nThis seems very complex. Perhaps there's a better way.\n\nLet me think about the problem again. For each edge, the product of a_u and a_v is g * l. Also, since GCD(a_u, a_v) = g, then a_u and a_v must be multiples of g, and their quotient (after dividing by g) must be coprime.\n\nSo, for each edge, we can model the relation between a_u and a_v as a_u * a_v = g * l, and GCD(a_u, a_v) = g.\n\nThis seems like a system of equations. How can I model this?\n\nIf I can assign values to the nodes such that for every edge, the product of the two nodes is fixed, and their GCD is fixed.\n\nBut solving this system seems challenging.\n\nAnother Idea: Since a_u * a_v = g * l, and the GCD(a_u, a_v) = g, then the LCM(a_u, a_v) = (a_u * a_v) / GCD(a_u, a_v) = (g*l)/g = l. Which matches the given LCM. So, the product and the GCD are enough to ensure the LCM is correct. So, the main constraints are:\n\nFor each edge between u and v:\n\na_u * a_v = g * l\n\nand\n\nGCD(a_u, a_v) = g.\n\nBut how to ensure that?\n\nBut if we can ensure that a_u and a_v are multiples of g, and that their product is g*l, then the GCD will automatically be g. Is that true?\n\nLet me think. Let's say a_u = g * x, a_v = g * y. Then, their product is g^2 x y. For this to equal g*l, we need g^2 x y = g*l → g x y = l → x y = l/g. Which is what we had before.\n\nNow, the GCD(a_u, a_v) is g * GCD(x, y). We want this to be equal to g. So, GCD(x, y) must be 1. Hence, x and y must be coprime.\n\nSo, the problem reduces to ensuring that for each edge, the product of the two node values is g*l, and that the x and y (after dividing by g) are coprime.\n\nBut how to assign the node values such that this holds for all edges?\n\nLet me think of this as a graph where each node's value is determined by the product with its neighbors. For example, if we have a tree, we can assign a value to the root, then for each child, compute the value based on the edge's product. But during this process, we need to ensure that the x and y are coprime.\n\nBut how to ensure that? For example, suppose I have a root node u with value a_u. For each edge between u and v, the value of v is (g*l) / a_u. But then, for this to be valid, the GCD of a_u and a_v must be g. Which depends on the choice of a_u.\n\nBut if I choose a_u to be g * x, then a_v = (g*l) / (g*x) = l/(x) = g * (l/g) /x = g * y, where y = (l/g)/x. And since x*y = l/g, then if x and y are coprime, the GCD(a_u, a_v) will be g * GCD(x, y) = g * 1 = g. So, the key is to choose x and y such that they are coprime.\n\nBut how to ensure that during the traversal?\n\nAh! For each edge, when we assign the value to a node, we can choose x and y such that they are coprime. For example, if we have an edge between u and v with GCD g and LCM l, and we have already assigned a value to u, then the value of v is determined as (g*l)/a_u. Then, we can check whether the GCD of a_u and a_v is equal to g. If not, then it's invalid.\n\nBut how can we ensure that this is true? Let's see:\n\nAssume that a_u is chosen as g * x. Then, a_v = (g*l)/a_u = (g*l) / (g*x) = l/(x). But l = g * k, where k = l/g. So a_v = g*k / x. Since x * y = k, then y = k/x. So a_v = g*y. Now, GCD(x, y) must be 1. So, the GCD(a_u, a_v) = g * GCD(x, y) = g * 1 = g, which is correct.\n\nBut how do we know that GCD(x, y) is 1? Because x and y are factors of k = l/g, and x*y = k. So, if we choose x and y to be coprime factors of k, then this holds. But how do we ensure that during traversal?\n\nThe problem is that during traversal, when we assign the value to a node, we have to choose x and y such that they are coprime. However, if the value of the node is determined by the previous assignments, then x is fixed, and y is determined as k/x. But we need to ensure that x and y are coprime.\n\nBut how can we ensure that? For example, suppose during traversal, we assign a value to u, and then compute a_v as (g*l)/a_u. Then, we need to check that GCD(a_u, a_v) equals g. If not, then it's invalid.\n\nSo, during the BFS/DFS traversal, whenever we compute a value for a node, we have to verify that it satisfies the GCD constraint with its neighbor.\n\nLet me outline the steps:\n\nFor each connected component:\n\n- Pick a starting node. Assign it a value. How?\n\nInitially, for the starting node, there's no constraints except that it must be a multiple of the GCDs of its connected edges. But how to choose this value?\n\nWait, but for the first edge connected to the starting node, the value of the starting node must be a multiple of the GCD of that edge. So, perhaps the simplest way is to assign the value of the starting node as the GCD of the first edge. Then, for the neighboring node, compute its value as (g*l)/value_of_starting_node. Then, check if the GCD of the two values is equal to g. If not, it's invalid.\n\nBut why would that happen? Let's see:\n\nStarting node u has value g. The neighboring node v has value (g*l)/g = l. Now, GCD(g, l) must be g. Which is true because l is a multiple of g. So this is valid.\n\nSo, for the first edge, this works. But what about other edges connected to u?\n\nSuppose u is connected to another node w via an edge with GCD g2 and LCM l2. Then, the value of u must be a multiple of g2. But currently, u's value is g (from the first edge). If g is not a multiple of g2, then this is invalid. So, this suggests that the initial choice of the starting node's value may not be compatible with other edges connected to it.\n\nThus, this approach may not work for graphs where the starting node has multiple edges with different GCDs.\n\nThis indicates that the initial value assignment for the starting node must be a multiple of all GCDs of its connected edges. So, the minimal value is the LCM of all those GCDs.\n\nBut how can I compute this?\n\nLet me think: For the starting node u, collect all the GCDs of its edges. Compute their LCM, say, G. Assign the starting node's value to be G. Then, for each edge connected to u, the value of u is a multiple of the GCD of that edge, which is required.\n\nThen, for each edge between u and v, the value of v is (g * l) / G, where g is the GCD of that edge, l is the LCM. Now, we need to check if this value of v is compatible with the other edges connected to v.\n\nBut how to compute G?\n\nFor example, if u is connected to edges with GCDs g1, g2, etc., then G is LCM(g1, g2, ...).\n\nSo, during preprocessing, for each node, compute the LCM of all the GCDs of its connected edges. Then, assign that as the starting value.\n\nBut how to compute this for each node?\n\nYes. For each node u, we can precompute the LCM of the GCDs of all edges connected to it. Let's call this value G_u. Then, when we assign the starting node's value as G_u, it ensures that it is a multiple of all the GCDs of its edges.\n\nSo, the steps would be:\n\nFor each node u:\n\n   collect all the GCDs of its edges.\n\n   compute G_u as LCM of those GCDs.\n\nThen, during traversal, for the starting node, assign it the value G_u. Then, for each adjacent node, compute the value based on the edge's GCD and LCM.\n\nBut how to handle cases where the same node is part of multiple edges with varying GCDs?\n\nLet me take an example. Suppose node u is connected to v with GCD 2, LCM 6, and to w with GCD 3, LCM 9. Then, the GCDs for u are 2 and 3. The LCM of these is 6. So, the starting value for u is 6. Then, for the edge between u and v (GCD 2, LCM 6):\n\nvalue of v is (2 * 6) / 6 = 2. Check GCD(6, 2) = 2, which is correct.\n\nFor the edge between u and w (GCD 3, LCM 9):\n\nvalue of w is (3 * 9) / 6 = 27/6 = 4.5. Which is not an integer. That's a problem.\n\nWait, this indicates that the approach is flawed. Because the value of w would not be an integer in this case. So what's wrong here?\n\nAh, because the product of the GCD and LCM for the edge between u and w is 3 * 9 = 27. The value of u is 6, so the value of w would be 27 / 6 = 4.5, which is not an integer. This is invalid.\n\nBut why did this happen?\n\nBecause the value of u is 6, which is the LCM of the GCDs of its edges (2 and 3). But for the edge between u and w, the product of the GCD and LCM is 3 * 9 = 27. And the value of u must be a divisor of 27, because the product of u and w must be 3*9 = 27. So 6 divides 27? No, 27 divided by 6 is 4.5, which is not an integer. Therefore, this scenario is impossible. Hence, the answer is NO.\n\nBut how can we detect this during our algorithm?\n\nThis suggests that the initial assignment of the starting node's value (G_u) may not be compatible with the edges. Hence, during the traversal, we need to check whether the computed value of the adjacent node is an integer, and also that the GCD of the two nodes equals the edge's GCD.\n\nSo, the steps would be:\n\nFor each connected component:\n\n   For each node in the component, compute G_u as LCM of GCDs of its edges.\n\n   Choose a starting node, assign it value G_u.\n\n   Perform BFS/DFS:\n\n      For each node, when visiting its neighbor via an edge, compute the neighbor's value as (g * l) / current node's value.\n\n      Check if this value is integer, and that GCD(current value, new value) == g.\n\n      If any of these checks fail, return NO.\n\n      If the neighbor hasn't been visited yet, assign the computed value and continue.\n\n      If",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on the given GCD and LCM values for each road connecting two lawns. The solution involves checking for consistency in the constraints provided by the roads and using a graph traversal approach to assign valid mushroom counts to each lawn.\n\n### Approach\n1. **Input Validation**: First, ensure that each edge's LCM is a multiple of its GCD. If not, it's impossible to satisfy the constraints, and we immediately return \"NO\".\n2. **Graph Construction**: Represent the graph using an adjacency list where each node (lawn) keeps track of its connected edges along with their respective GCD and LCM values.\n3. **LCM Calculation for Nodes**: For each node, compute the Least Common Multiple (LCM) of all GCDs of its connected edges. This ensures that the initial value assigned to a node is a multiple of all required GCDs for its edges.\n4. **BFS/DFS Traversal**: Use BFS or DFS to traverse the graph starting from each unvisited node. During traversal, propagate the mushroom counts based on the constraints from the edges. Ensure that each computed value is an integer and that the GCD constraint is satisfied for each edge.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef input():\n    return sys.stdin.read()\n\ndef compute_lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    # Precompute for each node the LCM of GCDs of its edges\n    node_gcd_lcms = [1] * n\n    for i in range(n):\n        g_list = []\n        for (neighbor, g, l) in adj[i]:\n            g_list.append(g)\n        if not g_list:\n            node_gcd_lcms[i] = 1\n        else:\n            current_lcm = g_list[0]\n            for g in g_list[1:]:\n                current_lcm = compute_lcm(current_lcm, g)\n            node_gcd_lcms[i] = current_lcm\n    \n    visited = [False] * n\n    result = [0] * n\n    \n    for i in range(n):\n        if not visited[i]:\n            # Start BFS\n            queue = deque()\n            queue.append(i)\n            visited[i] = True\n            result[i] = node_gcd_lcms[i]\n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        # Compute value for v\n                        product = g * l\n                        a_u = result[u]\n                        if a_u == 0:\n                            # Should not happen as node_gcd_lcms is at least 1\n                            print(\"NO\")\n                            return\n                        if product % a_u != 0:\n                            print(\"NO\")\n                            return\n                        a_v = product // a_u\n                        # Check GCD(a_u, a_v) == g\n                        if math.gcd(a_u, a_v) != g:\n                            print(\"NO\")\n                            return\n                        result[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check consistency\n                        a_u = result[u]\n                        a_v = result[v]\n                        if a_u * a_v != g * l or math.gcd(a_u, a_v) != g:\n                            print(\"NO\")\n                            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of nodes, edges, and the respective GCD and LCM values for each edge.\n2. **Validation Check**: Each edge's LCM must be a multiple of its GCD. If not, the answer is immediately \"NO\".\n3. **LCM Calculation**: For each node, compute the LCM of all GCDs of its connected edges to determine an initial valid value for that node.\n4. **Graph Traversal**: Using BFS, propagate the mushroom counts from each starting node, ensuring that each computed value meets the GCD and LCM constraints for the edges. If any inconsistency is found during traversal, the answer is \"NO\"; otherwise, the valid mushroom counts are printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef input():\n    return sys.stdin.read()\n\ndef compute_lcm(a, b):\n    return a * b // math.gcd(a, b)\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    # Precompute for each node the LCM of GCDs of its edges\n    node_gcd_lcms = [1] * n\n    for i in range(n):\n        g_list = []\n        for (neighbor, g, l) in adj[i]:\n            g_list.append(g)\n        if not g_list:\n            node_gcd_lcms[i] = 1\n        else:\n            current_lcm = g_list[0]\n            for g in g_list[1:]:\n                current_lcm = compute_lcm(current_lcm, g)\n            node_gcd_lcms[i] = current_lcm\n    \n    visited = [False] * n\n    result = [0] * n\n    \n    for i in range(n):\n        if not visited[i]:\n            # Start BFS\n            queue = deque()\n            queue.append(i)\n            visited[i] = True\n            result[i] = node_gcd_lcms[i]\n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        # Compute value for v\n                        product = g * l\n                        a_u = result[u]\n                        if a_u == 0:\n                            # Should not happen as node_gcd_lcms is at least 1\n                            print(\"NO\")\n                            return\n                        if product % a_u != 0:\n                            print(\"NO\")\n                            return\n                        a_v = product // a_u\n                        # Check GCD(a_u, a_v) == g\n                        if math.gcd(a_u, a_v) != g:\n                            print(\"NO\")\n                            return\n                        result[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check consistency\n                        a_u = result[u]\n                        a_v = result[v]\n                        if a_u * a_v != g * l or math.gcd(a_u, a_v) != g:\n                            print(\"NO\")\n                            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 1088,
        "thoughts_token_count": 8192
    }
}