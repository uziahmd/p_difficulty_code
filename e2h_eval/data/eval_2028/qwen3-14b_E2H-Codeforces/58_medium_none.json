{
    "start": 1758339500.5714164,
    "end": 1758339610.301798,
    "start-formatted": "2025-09-20 12:38 KST",
    "end-formatted": "2025-09-20 12:40 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to find the minimum number of edges to add to a graph to create an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I need to understand what's required. A simple cycle of odd length. Oh right, and each vertex occurs once. So it's a cycle where the number of vertices is odd. Wait, because the cycle's length (number of edges) is equal to the number of vertices in the cycle. So for example, a triangle is a 3-length cycle, which is odd.\n\nThe problem says that the original graph may not have such a cycle. So we need to find the minimal t edges to add to make such a cycle exist, and count how many ways there are to add exactly t edges to achieve this.\n\nSo first, I need to check if the graph already has an odd-length cycle. If it does, then t is 0 and w is 1? Or wait, maybe there are multiple ways to form such a cycle. But no, the problem says that w is the number of ways to add t edges to form a cycle. Wait, but if the graph already has such a cycle, then adding zero edges would be the way. But how many such ways are there? Well, the question says that the answer is the number of ways to add t edges to form a cycle. But if the graph already contains at least one odd-length cycle, then t is zero, and the number of ways is 1? Or maybe more?\n\nWait, no. Because the problem says that the answer is the number of ways to add exactly t edges. So if the graph already has an odd cycle, then t is zero, and the number of ways is 1? Because adding zero edges is the only way. But maybe there are multiple existing cycles. However, the problem says that the answer counts the number of ways to add edges. But since the existing cycles don't require adding any edges, then the count is 1? Or maybe it's the number of possible ways to choose edges (but since you add zero edges, it's only one way). So in that case, the output is t=0 and w=1.\n\nBut how do we check if the original graph has an odd cycle?\n\nAh, right! A bipartite graph cannot have odd-length cycles. So if the graph is bipartite, then it doesn't have any odd cycles. Otherwise, it has at least one. So the first thing to do is check whether the graph is bipartite. If it's not bipartite, then t is 0 and w is 1. Because the existing graph already has an odd cycle. But wait, the problem says that the answer must be the minimum number of edges to add. So if the graph already has an odd cycle, then t is 0 and w is 1. But how about if there are multiple existing odd cycles? The count w is still 1 because adding zero edges is the only way. Because the problem says that the way is considered as the set of edges added. Since adding zero edges is one way, regardless of how many existing cycles there are.\n\nBut the problem says that the answer for the sample input where the graph is a triangle (the second example) gives output 0 1. That matches this idea. So that's correct.\n\nSo first, we need to check if the graph is bipartite. If it's not bipartite, then output t=0 and w=1. But if it is bipartite, then we need to find the minimal t and the number of ways.\n\nSo the problem reduces to: if the graph is bipartite, then find the minimal number of edges to add to create an odd cycle. Otherwise, output 0 and 1.\n\nNow, when the graph is bipartite, how can we create an odd cycle? Well, adding an edge between two nodes in the same partition of a bipartition would create an odd cycle. Because in a bipartite graph, all cycles are even-length. Adding an edge between two nodes in the same partition would create a cycle of length (distance between them +1). For example, suppose two nodes u and v are in the same partition. The distance between them is even (since in bipartite graphs, the distance between nodes in the same partition is even). Adding an edge between them would create a cycle of length (even + 1) = odd.\n\nSo the minimal t is 1. Because adding one edge between two nodes in the same partition would create an odd cycle. But how to compute the number of ways?\n\nSo, for each connected component, which is bipartite, we can compute the number of pairs of nodes in the same partition. Then, the total number of ways is the sum over all components of (count of pairs in partition A) + (count of pairs in partition B) for each component. But wait, no. Because each component is bipartitioned into two parts. Let's say for a component, the two partitions have sizes a and b. Then, the number of possible edges that can be added within the same partition is C(a,2) + C(b,2). Because adding any of those edges would create an odd cycle. But for each such edge, adding it would create an odd cycle. So the minimal t is 1, and the number of ways is the sum over all components of (C(a,2) + C(b,2)).\n\nBut wait, what if there are multiple components? For example, if there are two separate components, each of which is bipartitioned. Then, adding an edge in either component would create an odd cycle. So the total number of ways is the sum of (C(a_i, 2) + C(b_i, 2)) for each component i. Because each such edge addition would create an odd cycle. So the minimal t is 1, and the number of ways is the sum of those values.\n\nSo the problem becomes:\n\n- Check if the graph is bipartite. If not, output 0 1.\n- Else, compute for each connected component the number of possible edges that can be added within the same partition (i.e., for each component, compute (a*(a-1)/2 + b*(b-1)/2), where a and b are the sizes of the two partitions of that component). Sum these across all components. That sum is the value of w. And t is 1.\n\nWait, but why can't there be a case where adding two edges would create an odd cycle? Because if the graph is bipartite, then adding one edge would create an odd cycle. So the minimal t is 1, not 2. Therefore, the answer is t=1 and w is the sum of the possible edges per component.\n\nBut let's look at the sample inputs.\n\nFirst sample input:\n\n4 4\n\nEdges:\n\n1-2, 1-3, 4-2, 4-3.\n\nLet me draw this graph. Let's see:\n\nVertices 1, 2, 3, 4.\n\nEdges between 1-2, 1-3, 2-4, 3-4. So the graph has two connected components? No, it's connected. Let me check. 1 is connected to 2 and 3. 2 is connected to 4. 3 is connected to 4. So all nodes are connected. So the connected component is the entire graph.\n\nIs this graph bipartite? Let's try to color it. Let's assign color 0 to node 1. Then node 2 and 3 must be color 1. Node 4 is connected to 2 and 3. So if node 2 is color 1, then node 4 must be color 0. But node 3 is color 1, so node 4 is color 0. Then node 4 is color 0. Now, node 4 is connected to 2 (color 1) and 3 (color 1). That's okay. So the coloring is possible. So the graph is bipartite. So the answer is t=1 and w is the sum of (C(a,2)+C(b,2)) for each component. Here, the component has two partitions. Let's see: the partitions are size a and b. Let's see, for example, the color counts. Suppose the partitions are {1,4} and {2,3}. Then a=2, b=2. So C(2,2) + C(2,2) = 1 + 1 = 2. Which matches the first sample output of 1 2. So yes.\n\nAnother sample input is the second one: 3 nodes, 3 edges forming a triangle. That's a cycle of length 3, which is odd. So the graph is not bipartite. Hence, output is 0 1.\n\nThird sample input: 3 nodes, 0 edges. The graph is bipartite (since it's three disconnected nodes). Each component is a single node. For each component, the partitions are (1, 0). So for each component, (C(1,2) + C(0, 2)) is 0. But wait, for each component, the bipartition is (size 1 and 0). So the sum for each component is 0 + 0 = 0. But the total sum is 0. But according to the third sample input, the output is 3 1. Wait, that's conflicting. What's wrong here?\n\nWait, the third sample input is n=3, m=0. So the graph has three separate nodes. Each is a connected component. For each component, since it's a single node, the bipartition is (1, 0). So the number of possible edges to add within the same partition is C(1,2) + C(0,2) = 0 + 0 = 0. So the sum is 0. But according to the sample output, the answer is 3 1. Which suggests that t is 3 and w is 1. But according to our previous logic, if the graph is bipartite, then t is 1 and w is the sum. But here, the sum is zero. So something's wrong with our reasoning.\n\nWait, this indicates that our previous approach is incorrect. So what's the problem here?\n\nIn the third sample input, the graph is three isolated nodes. Since each component is bipartitioned (each being a single node), but adding any edge between two nodes would create a cycle? No. Wait, adding an edge between two nodes would create a cycle? No, because a cycle requires at least three nodes. Wait, adding a single edge between two nodes creates a path of two nodes, but no cycle. To form a cycle, you need to have a closed loop. So for example, adding two edges would form a cycle. Like, adding edges between 1-2 and 2-3. Then, there's no cycle. But if you add edges between 1-2, 2-3, and 3-1, then you have a cycle. But that's three edges. But the problem requires the minimal number of edges to add to form a cycle of odd length.\n\nSo in the case where the graph is bipartite, but all components are single nodes, how can we form an odd cycle?\n\nWell, for example, in the third sample input, the graph has three nodes with no edges. So to form a cycle of odd length, we need to add edges. Let's think: the minimal number of edges to add. For example, adding three edges to form a triangle (cycle of length 3). So t is 3. But according to our previous approach, we thought that t is 1. But that's not correct. So there's a mistake in the previous reasoning.\n\nSo what's wrong with the earlier logic?\n\nEarlier, I thought that adding an edge between two nodes in the same partition would create an odd cycle. But that's only true if there's a path between them. For example, in a connected bipartite graph, adding an edge between two nodes in the same partition creates a cycle. But if the graph is disconnected, and the component is a single node, then adding an edge between two nodes in the same component (but in that case, the component is just one node, and adding an edge between two nodes in the same partition would not be possible, since the component is a single node. Wait, perhaps I need to re-examine the bipartitioning of each component.\n\nSo, for each connected component, the bipartition is such that each component is bipartitioned into two sets. For example, a single node component has one set with 1 node and another with 0. So when considering adding edges between nodes in the same partition, but in a component with only one node, there are no possible edges (since you can't have two nodes in the same partition).\n\nSo, for a component that's a single node, the number of possible edges to add within the same partition is zero. Therefore, the sum over all components would be zero. Which would imply that the minimal t is not 1. But in the third sample input, the answer is t=3 and w=1. Which suggests that the initial approach is wrong.\n\nSo the problem is that the initial approach only works for connected bipartite graphs. But when the graph is bipartite, but has multiple components, and some components are not connected, then adding an edge between two components may not create a cycle. Wait, but how to create a cycle?\n\nTo form a cycle, you need to have a closed path. For example, adding edges between three separate nodes would require adding three edges to form a triangle. So, in that case, the minimal number of edges to add is 3. But according to our previous approach, the sum of possible edges to add within the same partition is zero, leading to t=1. Which is wrong.\n\nSo there's a flaw in the initial reasoning. Let me re-examine the problem.\n\nThe original idea was that if the graph is bipartite, then adding an edge between two nodes in the same partition of a connected component will create an odd-length cycle. But that is only true if the two nodes are in the same connected component. Because otherwise, adding an edge between two nodes from different components would create a new connected component. But that would not create a cycle.\n\nSo, for the case of multiple components, how can we create an odd-length cycle?\n\nFor example, if the graph is bipartite and consists of two separate components. Suppose each component is a bipartitioned graph. Then, adding an edge between a node in one component and a node in another component. But that would not create a cycle. However, if we add edges between two nodes in the same component's same partition, then that creates a cycle. But if the component is a single node, then there's no way to do that.\n\nSo the problem is that the initial approach only considers the cases where the graph is connected and bipartite. But when the graph is disconnected and bipartite, the approach needs to be adjusted.\n\nSo, how to handle all cases?\n\nLet me think again. The key is that the graph is bipartite. So, there are no odd-length cycles. Therefore, any cycle in the graph after adding edges must be created by adding edges in such a way that an odd-length cycle exists.\n\nBut how?\n\nCase 1: The graph is connected and bipartite. Then adding any edge between two nodes in the same partition creates a cycle. The length of that cycle is the distance between the two nodes (which is even, since they are in the same partition) plus 1. So the cycle length is odd. So that's a valid way. So for this case, the minimal t is 1.\n\nCase 2: The graph is disconnected and bipartite. Then, adding an edge between two nodes in the same partition of the same component will create a cycle. But if there are multiple components, perhaps adding edges between components can help? Like, for example, if you have two separate components, each with two nodes. Each component is a bipartition (say, {A, B} and {C, D}). Then, adding edges between A and C, B and D, and then adding an edge between A and B would create a cycle? Not sure. Alternatively, perhaps the minimal way is to create a component that has an odd-length cycle. So for example, if there are two components, each with two nodes. Then, adding edges between A and B (same partition) creates a cycle of length 1? No. Wait, if the component is two nodes connected by an edge. Then, the bipartition is {A}, {B}. Adding an edge between A and B would create a cycle of length 1? No, that's a loop. But loops are not allowed. Wait, but the original graph has no loops or parallel edges. So adding an edge between two nodes in the same partition of a connected component would create a cycle. For example, in a component that is a tree (so bipartite), adding an edge between two nodes in the same partition creates a cycle. The length of that cycle is (distance between them) + 1. Which is even + 1 = odd.\n\nBut if the component is a single node (no edges), then adding an edge between two nodes in the same component is impossible. So, in that case, how can we create an odd-length cycle?\n\nSo, for example, if the graph has three components, each with one node. Then, adding three edges to form a triangle would create a cycle of length 3, which is odd. So in that case, the minimal number of edges to add is 3, and there's exactly one way to do it (adding all three edges). But according to our previous approach, the sum of (C(a, 2) + C(b, 2)) for all components is zero, which would suggest that the minimal t is 1. Which is wrong.\n\nSo the initial approach is incomplete. We need to consider two possibilities:\n\nIf the graph is bipartite, then there are two scenarios:\n\nA. There exists at least one connected component with at least two nodes. Then, the minimal t is 1, and the number of ways is the sum over all components of (C(a_i, 2) + C(b_i, 2)), where a_i and b_i are the sizes of the two partitions in component i.\n\nB. All connected components are single-node. Then, the minimal t is 3, and the number of ways is C(n, 3), since we need to choose three nodes and connect them into a triangle. But wait, the problem says that the added edges must form a cycle. So, for example, adding three edges between three nodes forms a cycle. However, the problem requires that the added edges are such that the graph contains an odd-length cycle. So in this case, the minimal number of edges to add is 3 (to form a triangle). How many ways are there? It's the number of possible triangles, which is C(n, 3), since each triangle is formed by selecting three nodes and adding all three edges. But wait, the problem says that the added edges should form a cycle. However, when adding edges, the way to add edges could be any set of edges that creates at least one odd-length cycle. However, in this scenario, the minimal t is 3, and the only way to achieve that is to add exactly three edges forming a triangle.\n\nBut the problem says that the added edges must form a cycle. So, for example, adding three edges to form a triangle would be one way. But if there are multiple ways to add three edges to form a cycle (like, adding edges between 1-2, 2-3, 3-1, or between 1-2, 2-4, 4-1, etc.), then the number of ways is the number of possible triangles.\n\nSo, in this case, the answer is t=3 and w=C(n,3). However, the third sample input has n=3, m=0. So the number of ways is C(3,3)=1. Which matches the sample output of '3 1'.\n\nSo, the problem is that when the graph is bipartite and all components are single-node, then the minimal t is 3, and the number of ways is C(n,3).\n\nSo, how can we combine these two scenarios?\n\nSo, the overall approach is:\n\nCheck if the graph is bipartite. If not, output t=0 and w=1.\n\nElse:\n\nCheck if there exists at least one connected component with size ≥ 2. If yes, then the minimal t is 1, and the number of ways is the sum over all components of (C(a_i, 2) + C(b_i, 2)).\n\nIf not (i.e., all components are single-node), then the minimal t is 3, and the number of ways is C(n, 3).\n\nSo, the algorithm steps are:\n\n1. Check if the graph is bipartite. If not, output 0 1.\n\n2. Else:\n\n   a. For each connected component, check if it has size ≥ 2.\n\n   b. If there's at least one such component, then t is 1, and w is the sum over all components of (C(a_i, 2) + C(b_i, 2)).\n\n   c. Else (all components are single nodes), then t is 3, and w is C(n, 3).\n\nSo, how to implement this?\n\nFirst, we need to check if the graph is bipartite. But since the graph may have multiple connected components, we need to check each component.\n\nBut how to check if the graph is bipartite. For each connected component, perform BFS or DFS to check bipartition. If any component is not bipartite, then the entire graph is not bipartite.\n\nOnce we know that the graph is bipartite, then proceed.\n\nThen, for each connected component, compute the sizes of the two partitions (a_i and b_i). For each component, if it has at least two nodes, then compute C(a_i, 2) + C(b_i, 2). Sum all these values.\n\nBut if all components are single nodes, then sum is zero. So, in that case, we need to check if there are at least two components with size ≥ 2? No, in this case, all components are single nodes. So, the code needs to check if there exists at least one component with size ≥ 2.\n\nSo, during processing the components, we can track whether there is any component with size ≥ 2.\n\nSo, in code:\n\nAfter checking the graph is bipartite, we can:\n\n- For each component, store the sizes of the two partitions (a and b), and also track if the component has size ≥ 2.\n\nIf any component has size ≥ 2, then:\n\nt = 1\n\nw = sum over all components (a * (a-1) // 2 + b * (b-1) // 2 )\n\nElse:\n\nt = 3\n\nw = n * (n-1) * (n-2) // 6\n\nBut wait, in the case where all components are single nodes, then the number of ways is C(n,3) ?\n\nYes. Because to form a triangle, you need to select three nodes and add all three edges between them. Since there are no existing edges, the number of ways is exactly the number of possible triplets of nodes.\n\nSo, for example, in the third sample input, n=3. So C(3,3) = 1. Which matches the sample output.\n\nAnother example: if n=4, and all components are single nodes. Then, the number of ways is C(4,3) = 4. So, adding three edges to form a triangle. But there are four possible ways (each triplet of nodes).\n\nSo, the code needs to handle this.\n\nNow, the problem is to implement this.\n\nNow, the steps for the code:\n\nRead n and m.\n\nRead the m edges.\n\nBuild adjacency list.\n\nCheck if the graph is bipartite. For this, for each connected component, perform BFS/DFS to check bipartition.\n\nIf during this process, any component is not bipartite, then the graph is not bipartite. So output 0 1.\n\nElse, proceed.\n\nNow, for each connected component, we need to know the sizes of the two partitions (a and b). Also, check if the component has size ≥ 2.\n\nSo, for each component, during BFS/DFS, we can track the color of each node (0 or 1). Then, count the number of nodes in color 0 and color 1.\n\nOnce we have all components' a and b, then:\n\nCheck if any component has size ≥ 2 (i.e., a + b ≥ 2).\n\nIf yes:\n\nsum_w = sum for each component (a_i * (a_i - 1) // 2 + b_i * (b_i - 1) // 2 )\n\nt = 1, w = sum_w.\n\nElse:\n\nt = 3, w = n * (n-1) * (n-2) // 6.\n\nBut wait, if all components are single nodes, then n must be equal to the number of components, and each component has size 1. So, the code needs to check if all components have size 1. Which can be done by checking if for all components, a_i + b_i == 1.\n\nBut in code, during processing components, we can track whether there is any component with size ≥ 2.\n\nSo, during processing components, for each component, we can compute its size (a + b). If any component has size ≥ 2, then set a flag (has_large_component) to True.\n\nOnce all components are processed, if has_large_component is True, then proceed with sum_w as before. Else, compute t=3 and w=C(n,3).\n\nNow, the code can be structured as follows.\n\nImplement Bipartition check:\n\nWe can use BFS for each component. For each unvisited node, start BFS, assign colors, check if bipartition is possible.\n\nNow, code steps:\n\nImplement a function to check bipartition, and collect the a and b counts for each component.\n\nLet me think about code structure.\n\nIn Python:\n\nWe can represent the graph as an adjacency list.\n\nWe have a visited array, and for each node, if not visited, we perform BFS.\n\nFor each component, during BFS, we assign colors (0 or 1). For each node, we track its color. If during BFS, we find an adjacent node with same color, then the graph is not bipartite.\n\nOnce all components are checked, if the graph is bipartite, then proceed.\n\nNow, for each component, collect the counts of color 0 and color 1.\n\nOnce that is done, check if any component has size >=2.\n\nIf yes:\n\nsum_w = sum (a_i*(a_i-1)//2 + b_i*(b_i-1)//2 for each component)\n\nt = 1\n\nw = sum_w\n\nElse:\n\nt=3\n\nw = n*(n-1)*(n-2)//6 if n >=3 else 0 ?\n\nWait, but in the case where n <3, like n=2, then the answer would be impossible. But according to the problem statement, the graph must have a cycle of more than one vertex. For example, if n=2, and the graph is bipartite (two nodes with no edges), then adding 3 edges is impossible. But the problem says that the graph is given with n and m. So, for n=2, and m=0, then the minimal t is 1 (adding one edge between the two nodes would form a cycle of length 2? No, a cycle of length 2 is not allowed. Because a cycle must have at least three nodes. Wait, no. Wait, a cycle must have at least three nodes. Because a cycle is a closed path where each vertex occurs once. So, a cycle of length 2 would be two nodes connected by two edges, but the graph has no parallel edges. So, for two nodes, there's no way to form a cycle. So, in the case where n=2 and the graph is bipartite (two nodes with no edges), then to create a cycle of odd length, you need to add edges. But since the minimal cycle length is 3, you need to add at least three edges. However, with two nodes, you can't form a cycle of length 3. So, this case is impossible. But according to the problem statement, the input is given with n and m. So, how to handle such cases?\n\nBut according to the problem statement, the graph is given with n vertices and m edges. So, for example, if n=2 and m=0, then the answer would be t=3, but it's impossible. However, according to the problem's note, the sample input includes a case with n=3, m=0, which outputs 3 1.\n\nSo, in the code, when all components are single nodes (i.e., n is the number of components, each with size 1), then:\n\nif n < 3: then it's impossible to form a cycle. But according to the problem statement, the answer must exist. But the problem says that the graph can be modified by adding edges. So, for example, when n=2, to form a cycle of odd length, you need to add at least 3 edges. However, with two nodes, you can't form a cycle. Because a cycle requires at least three nodes. So, for example, adding edges between the two nodes (say, adding one edge) gives a path, not a cycle. Adding two edges would be parallel edges, which are not allowed. So, it's impossible. But according to the problem statement, the input is such that the answer exists. But the problem says nothing about that. So, perhaps the code needs to handle such cases.\n\nBut according to the problem statement, the input is such that the answer exists. Because the problem says that you need to find t and w. So, perhaps the code can assume that n is at least 3 in such cases. However, in the code, when all components are single nodes, and n is less than 3, then the code would compute w as C(n, 3) which is zero. But in such cases, the answer is impossible. However, the problem says that the input is valid, so perhaps the code can proceed under the assumption that when all components are single nodes, then n >= 3.\n\nBut the problem says that the input can be anything. So, for example, if n=2, and the graph is bipartite (which it is, since it's two nodes with no edges), then according to the code, the code would compute t=3 and w= C(2,3) = 0. Which would be incorrect. However, in reality, there's no way to form a cycle. So, perhaps the problem guarantees that n is at least 3 in such cases. But the problem statement doesn't say that.\n\nBut looking back at the problem statement's sample input, the third sample is n=3, m=0, which outputs 3 1. So, the code for that case is handled correctly.\n\nSo, in code, when all components are single nodes, then:\n\nif n >= 3: t=3, w = C(n,3).\n\nelse: ?\n\nBut according to the problem statement, the answer must exist. So, perhaps the code can assume that when all components are single nodes, then n >=3.\n\nBut the problem says nothing about that. So, perhaps the code should handle that case.\n\nBut for the purposes of this problem, perhaps the code can proceed as follows:\n\nIn the case where all components are single nodes (so, n_components = n), then:\n\nif n < 3: then there's no way to form a cycle. But according to the problem statement, the answer must exist. However, the problem says that the graph can be modified by adding edges. But with n < 3, it's impossible to form a cycle. So, perhaps the code should return t=3 and w=0. But in practice, the code would compute w as C(n,3), which is zero. So, for example, if n=2, then the code would return t=3 and w=0. But according to the problem's requirements, the output must be t and w. However, the problem says that the answer exists, so perhaps such cases are not present in the test data.\n\nBut for the code, perhaps we can proceed with the calculation, and let the code compute it as per the formula.\n\nSo, in code:\n\nif all components are single nodes:\n\nthen:\n\nif n >=3:\n\nt=3, w = n*(n-1)*(n-2)//6\n\nelse:\n\nt=3, w=0 ?\n\nBut the problem says that the answer must exist. So perhaps the code can proceed with this.\n\nNow, putting it all together.\n\nNow, the code steps:\n\nRead n and m.\n\nBuild adjacency list.\n\nInitialize color array (say, -1 for uncolored).\n\nCheck bipartition.\n\nIf not bipartition, output 0 1.\n\nElse:\n\nCollect for each component the a and b counts.\n\nCheck if any component has size >=2.\n\nIf yes:\n\nsum_w = sum over all components (a_i * (a_i -1) //2 + b_i * (b_i -1) //2 )\n\noutput t=1 and sum_w.\n\nElse:\n\nif n >=3:\n\nt=3, w = n*(n-1)*(n-2)//6\n\nelse:\n\nt=3, w=0 ?\n\nBut in the case where n=2, the code would output t=3 and w=0, which is correct because there is no way to form a cycle.\n\nBut according to the problem statement, the answer must exist, so perhaps the test cases ensure that n is at least 3 in such cases.\n\nNow, let's test the third sample input:\n\nSample input 3: n=3, m=0.\n\nEach component is single node. So, all components are size 1. So, code proceeds to compute t=3 and w=3*2*1/(6) = 1. Which matches the sample output.\n\nAnother test case: n=2, m=0. Then, the code would output t=3 and w=0.\n\nBut according to the problem statement, the output is required. However, the problem says that the graph may not be connected, but it's guaranteed that the answer exists. So, perhaps the code is correct.\n\nNow, code implementation.\n\nImplementing Bipartition check:\n\nWe can use BFS. For each unvisited node, assign color 0. Then, for each neighbor, if not colored, assign opposite color. If already colored, check if it's opposite. If not, then graph is not bipartition.\n\nNow, code:\n\nImplementing this in Python.\n\nWe need to track for each component, the count of color 0 and color 1.\n\nSo, during BFS, for each component, we can collect the counts.\n\nNow, code steps:\n\nRead n, m.\n\nadj = [[] for _ in range(n+1)] # assuming nodes are numbered from 1 to n.\n\nfor _ in range(m):\n\n    u, v = map(int, input().split())\n\n    adj[u].append(v)\n\n    adj[v].append(u)\n\ncolor = [-1]*(n+1)\n\nis_bipartite = True\n\ncomponents = [] # list of tuples (a, b) for each component\n\nfor u in range(1, n+1):\n\n    if color[u] == -1:\n\n        # start BFS\n\n        queue = deque()\n\n        queue.append(u)\n\n        color[u] = 0\n\n        cnt0 = 1\n\n        cnt1 = 0\n\n        while queue:\n\n            current = queue.popleft()\n\n            for neighbor in adj[current]:\n\n                if color[neighbor] == -1:\n\n                    color[neighbor] = 1 - color[current]\n\n                    if color[neighbor] == 0:\n\n                        cnt0 +=1\n\n                    else:\n\n                        cnt1 +=1\n\n                    queue.append(neighbor)\n\n                else:\n\n                    if color[neighbor] == color[current]:\n\n                        is_bipartite = False\n\n        # after BFS, add (cnt0, cnt1) to components?\n\nWait, no. Because the initial node is colored 0, and cnt0 starts at 1. But for the rest of the nodes, when they are added, their color is checked. However, the code above may not correctly count the number of nodes in each color.\n\nWait, the initial code is wrong. Because when you add a neighbor, you check if it's colored. But the initial code starts with u colored 0, and cnt0 is 1. Then, for each neighbor, if uncolored, assign color and increment cnt0 or cnt1 accordingly. However, this code will not count all nodes in the component. Because the code only increments cnt0 and cnt1 when the neighbor is colored. But the initial node is counted as cnt0=1. However, the code may miss the initial node's color. For example, when the component has only one node, the code would have cnt0=1, cnt1=0. Which is correct.\n\nBut for other cases, the code may not track the counts correctly. Because the initial node is added to the queue. Then, for each neighbor, when colored, they are added to the queue. But the code's cnt0 and cnt1 counts may not include all nodes.\n\nWait, the code starts with u, color 0. cnt0 is 1. Then, for each neighbor, when it is colored, the code increments cnt0 or cnt1. But what about the current node? For example, when the current node is processed, and its neighbors are added, but the current node's color is already accounted for.\n\nBut the code is not tracking the counts properly. Because the initial code starts with u's color as 0, and cnt0 is 1. Then, for each neighbor, when they are colored, their count is added. However, the code may miss the current node's color. For example, if the current node is processed, and then the neighbor is added, but the code doesn't",
    "response": "To solve this problem, we need to determine the minimum number of edges required to form an odd-length cycle in an undirected graph and count the number of ways to achieve this. The solution involves checking if the graph is bipartite and then handling different cases based on the structure of the graph.\n\n### Approach\n1. **Check Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent nodes share the same color. If a graph is not bipartite, it already contains an odd-length cycle, so the answer is `0 1`.\n2. **Component Analysis**: If the graph is bipartite, analyze each connected component to determine the number of ways to add edges to form an odd-length cycle:\n   - For components with at least two nodes, calculate the number of ways to add edges within the same partition.\n   - If all components are single-node, the minimum number of edges required to form a cycle is 3, and the number of ways is the number of ways to choose 3 nodes out of `n`.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        if color[neighbor] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large = False\n    sum_w = 0\n    for a, b in components:\n        size = a + b\n        if size >= 2:\n            has_large = True\n            sum_w += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n    \n    if has_large:\n        print(f\"1 {sum_w}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness. If any component is not bipartite, the graph contains an odd-length cycle, and the result is `0 1`.\n2. **Component Analysis**: For each component, we track the sizes of the two partitions (colors). If any component has at least two nodes, we calculate the number of ways to add edges within the same partition to form an odd-length cycle.\n3. **Single-Node Components**: If all components are single-node, the minimum number of edges needed to form a triangle (odd-length cycle) is 3, and the number of ways is calculated using combinations of 3 nodes from `n`.\n\nThis approach efficiently handles both connected and disconnected graphs, ensuring the correct minimum number of edges and their respective counts are determined.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        if color[neighbor] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large = False\n    sum_w = 0\n    for a, b in components:\n        size = a + b\n        if size >= 2:\n            has_large = True\n            sum_w += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n    \n    if has_large:\n        print(f\"1 {sum_w}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 879,
        "thoughts_token_count": 8192
    }
}