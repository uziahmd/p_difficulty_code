{
    "start": 1758313067.875772,
    "end": 1758313294.2831852,
    "start-formatted": "2025-09-20 05:17 KST",
    "end-formatted": "2025-09-20 05:21 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. So the task is to find the minimum number of edges to add to a graph to create an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I remember that a graph is bipartite if and only if it contains no odd-length cycles. So if the graph is already bipartite, then adding edges to create an odd cycle would require some changes. But if the graph isn't bipartite, then it already has an odd cycle, so the answer would be t=0 and w=1? Wait, but maybe there are multiple existing odd cycles. Oh, but the problem says that we need to find the minimal t. So if the graph already has an odd cycle, then t is 0, and w is the number of ways to add zero edges (which is 1?), but maybe not. Wait, the problem says that the answer is the number of ways to add t edges to form such a cycle. If the graph already has an odd cycle, then adding zero edges would count as one way, but perhaps there are multiple existing odd cycles. But the problem says that the answer for w is the number of ways to add t edges to form a cycle. So if the graph already has an odd cycle, then t is 0, and w is 1? Because adding zero edges would mean that there's already at least one such cycle. But maybe the question is about the number of possible ways to add exactly t edges to form such a cycle. So for example, if there are multiple existing odd cycles, but the minimal t is 0, then w would be 1? Or is it the number of possible ways to select edges that form such a cycle?\n\nWait, the problem says that when t is zero, the number of ways is the number of ways to choose zero edges (i.e., 1) but only if there's already an odd cycle. But how does that work? Because the question is about the number of ways to add t edges in order to form a cycle. So if the graph already has an odd cycle, then adding zero edges is one way. However, perhaps there are multiple existing odd cycles. But the problem says that the answer is the number of ways to add exactly t edges (so zero edges here) such that the resulting graph contains an odd cycle. However, since the original graph already has at least one, the number of ways is 1? Or maybe the problem counts all possible ways to select edges (but since t is zero, you have to select none). So regardless of how many existing cycles there are, the answer for w is 1. Because adding zero edges is one way. So in that case, if the graph already has an odd cycle, then t is 0 and w is 1.\n\nSo first, the approach is: check if the graph already has an odd cycle. If yes, then output t=0 and w=1. Otherwise, we need to find the minimal t and the number of ways to add edges to create an odd cycle.\n\nBut how to determine if the graph has an odd cycle? Well, for each connected component, check if it's bipartite. If any component is not bipartite, then the graph has an odd cycle. So if the graph is not bipartite, then t is 0 and w is 1.\n\nSo the first step is to check if the graph is bipartite. If it's not, then output 0 and 1. Otherwise, we need to find the minimal t and the number of ways.\n\nNow, if the graph is bipartite, then adding edges to create an odd cycle. How can we do that?\n\nAn odd cycle can be formed by connecting two nodes in the same bipartition. Because in a bipartite graph, all cycles are even-length. Adding an edge between two nodes in the same partition would create an odd-length cycle. For example, if you have a bipartition A and B, and you connect two nodes in A, then the cycle would be of length (distance from u to v via existing edges) + 1. Since the original distance between u and v is even (since the graph is bipartite), adding an edge between them makes the cycle length odd.\n\nSo the minimal t is 1. Because adding a single edge between two nodes in the same bipartition of a connected component would create an odd cycle.\n\nBut wait, what if the graph is bipartite and consists of multiple connected components. Then, each connected component is bipartite. So to create an odd cycle, we need to add an edge within a single component, which is bipartite. So the minimal t is 1.\n\nBut how to compute the number of ways w? It depends on the number of possible edges that can be added between nodes in the same partition of each connected component. Then, for each connected component, compute the number of possible edges that can be added between the two partitions (but wait, no. Wait, for a bipartition (A,B), adding an edge between two nodes in A would create an odd cycle. Similarly for two nodes in B. So for each connected component, the number of possible edges that can be added between nodes in the same partition is (count_A choose 2) + (count_B choose 2). But since the graph is bipartite, all existing edges are between A and B. So any pair of nodes in A that is not already connected by an edge can be connected. So the total number of possible edges that can be added to create an odd cycle is (count_A * (count_A - 1)/2 + count_B * (count_B -1)/2) minus the existing edges between same partitions? Wait no, because the existing edges are between A and B. So the existing edges don't include same-partition edges. Therefore, the number of possible edges that can be added between same partitions is (count_A choose 2) + (count_B choose 2) minus the existing edges between same partitions? No, because the graph is bipartite and has no same-partition edges. So the number of possible edges that can be added between same partitions is (count_A choose 2) + (count_B choose 2). But adding any of those edges would create an odd cycle. So the total number of ways is the sum over all connected components of ( (a_i choose 2) + (b_i choose 2) ), where a_i and b_i are the sizes of the two partitions in component i.\n\nWait, but if the graph is bipartitioned into A and B, then adding any edge between two nodes in A will create an odd cycle. So the number of such edges is (a_i choose 2) + (b_i choose 2). But for each connected component, since the component is bipartitioned into A and B, adding any edge between two nodes in A or two nodes in B would create an odd cycle. So the total number of possible edges that can be added to create an odd cycle is the sum over all connected components of ( (a_i choose 2) + (b_i choose 2) ). However, adding any of these edges would create an odd cycle, and since the minimal t is 1, the answer for w is the total number of such possible edges.\n\nWait, but if there are multiple connected components, then adding an edge in any of them would create an odd cycle. So the minimal number of edges to add is 1, and the number of ways is the total number of such edges across all components.\n\nWait, but the problem says that the answer is the number of ways to add t edges. So for t=1, the number of ways is the sum over all connected components of ( (a_i choose 2) + (b_i choose 2) ), because each such edge addition would create an odd cycle.\n\nBut wait, if the graph is bipartite, and we add an edge between two nodes in the same partition, then the new graph will have an odd cycle. So the minimal t is 1. And the number of ways is the sum of (a_i choose 2) + (b_i choose 2) for each connected component.\n\nSo the steps are:\n\nCheck if the graph has any odd cycle. If yes, output t=0 and w=1.\n\nElse:\n\nFor each connected component, compute the size of the two partitions (a_i, b_i). For each component, compute (a_i choose 2) + (b_i choose 2). Sum all these values across all components. That's the value of w, and t is 1.\n\nBut wait, in the sample input:\n\nLooking at the first example:\n\nInput is 4 nodes and 4 edges.\n\nEdges are:\n\n1-2\n\n1-3\n\n4-2\n\n4-3\n\nThe graph is connected. Let's check if it's bipartite.\n\nLet me try to color it. Let's say node 1 is color 0. Then its neighbors (2 and 3) must be color 1. Then node 4 is connected to 2 and 3. So node 4's neighbors are 2 (color 1) and 3 (color 1). So node 4 must be color 0. Now, check for conflicts. The edges between 2 and 4: 2 is color 1, 4 is color 0. Okay. Between 3 and 4: same. So the graph is bipartitioned into {1,4} and {2,3}.\n\nSo a_i = 2, b_i = 2. Then (2 choose 2) + (2 choose 2) = 1 + 1 = 2. Which matches the sample output's first case where t is 1 and w is 2.\n\nAnother sample input is the second case: 3 nodes with 3 edges forming a triangle. That's an odd cycle. So the output is 0 1.\n\nThird sample input is 3 nodes and 0 edges. So the graph is bipartitioned into each component. Each component is a single node. But for a single node, the bipartition is (1,0). So for each component, (1 choose 2) + (0 choose 2) is 0 + 0 = 0. Wait, but that would give sum 0, but the sample output is 3 1. Wait, that seems conflicting.\n\nWait, let's think again. The third sample input is n=3, m=0. So the graph is three isolated nodes. So each connected component is a single node. For each component, the bipartition is (1, 0). So (a_i choose 2) + (b_i choose 2) for each component is 0 + 0 = 0. So the total sum is 0. But according to the sample output, it's 3 1. So that suggests that my previous reasoning is incorrect.\n\nWait, what's happening here. Because the graph is bipartite, but adding an edge between two nodes in the same component. Wait, but the component is a single node. How can you add an edge between two nodes in the same partition? Well, the component is a single node, so the bipartition is {1}, {0}. So adding an edge between two nodes in the same partition would require two nodes. But in this case, the component has only one node. So how can you add an edge to create an odd cycle?\n\nAh, here's the mistake. When the connected component is a single node, the bipartition is (1, 0). So the number of possible edges to add between same partitions is (1 choose 2) + (0 choose 2) = 0. But in reality, to create an odd cycle, you need to add at least two edges. Because a cycle requires at least two edges (for two nodes). Wait, but the problem says that the cycle must consist of more than one vertex. So for example, a cycle of two nodes would be impossible (since it's undirected, it's just a single edge, not a cycle). So the minimal cycle is three nodes.\n\nSo in the third sample, the graph has three disconnected nodes. To form a cycle of odd length, you need to add edges to form a triangle. How many edges to add? Let's see. The minimal number of edges to add is 3 - (number of existing edges) = 3 edges. Wait, but the original graph has no edges. So to create a triangle, you need to add 3 edges. But according to the sample output, the answer is 3 1. Which aligns with that.\n\nBut according to the previous logic, for each component, the sum is (a_i choose 2) + (b_i choose 2). But for a component with one node, that sum is zero. So the total sum is zero, but the correct answer is 1 way. So clearly, the previous reasoning is missing something.\n\nSo what's wrong here?\n\nAh! The mistake is that for connected components with only one node, adding an edge between two nodes in the same component (but which are not in the same partition?) Wait, but for a single node, the bipartition is {1}, {0}. So adding an edge between two nodes in the same partition would require two nodes. But in this case, the component is a single node. So perhaps the earlier approach of checking for each connected component's bipartition is not sufficient for components with size 1 or 2?\n\nSo the problem arises when a connected component is a single node. Because adding an edge between two nodes in the same component (but in different components) would require connecting them. But in this case, how?\n\nWait, the initial approach was that for a bipartitioned graph, adding an edge between two nodes in the same partition creates an odd cycle. However, this only works for connected components with at least two nodes. For example, a component with one node can't have any edges added within it. So, perhaps the correct approach is to consider that for each connected component, if the component has at least two nodes, then the number of possible edges that can be added to create an odd cycle is (a_i choose 2) + (b_i choose 2). However, for a component with one node, this is zero. But in such cases, to create an odd cycle, we need to add edges between nodes in different components.\n\nWait, but how?\n\nLet me think again. The original graph is bipartite, so it has no odd cycles. To create an odd cycle, we need to add edges in such a way that there's an odd-length cycle.\n\nSuppose we have two separate components. Each is a single node. Then adding an edge between them (say between node A and node B) would not create a cycle. To create a cycle, you need to add at least two edges. For example, adding edges between A-B and B-C (assuming C is another node). Then you can't form a cycle. Wait, but if you add edges between A-B and A-C, then again no cycle. Only when you have a triangle, like adding edges between A-B, B-C, and C-A. So that's three edges. Which would create a cycle of length 3.\n\nBut how can we get that by adding edges?\n\nIn this case, the original graph has three components. To create an odd cycle, you need to add three edges. But according to the sample input, the third case has output t=3 and w=1. So how?\n\nSo, the previous approach of considering adding edges within a single component is not sufficient. Because in this case, the components are single-node. So the minimal t is 3, and the number of ways is 1 (only one possible way to add three edges forming a triangle).\n\nBut how to model this in our code?\n\nHmm. So the problem is that for components that are single nodes, adding edges between them would require adding multiple edges to form a cycle. So how to handle that?\n\nThis suggests that the initial approach is incomplete. The previous reasoning only considered adding a single edge within a connected component. But for certain cases, you need to add multiple edges.\n\nSo what's the minimal t?\n\nIf the graph is bipartite, then the minimal t is either 1 or 2 or something else?\n\nLet me think again. For a bipartite graph, the minimal number of edges to add to create an odd cycle.\n\nCase 1: There exists a connected component with at least two nodes. Then adding a single edge between two nodes in the same partition of that component creates an odd cycle. So t is 1.\n\nCase 2: All connected components are single-node. Then, to create a cycle, you need to add at least three edges. For example, connect three nodes into a triangle. So t is 3.\n\nSo the minimal t is 1 if there is at least one connected component with two or more nodes. Otherwise, it's 3.\n\nBut how to find that?\n\nSo first, check if the graph has any connected component with size ≥2. If yes, then t is 1. Else, t is 3.\n\nBut how to compute the number of ways w in each case.\n\nCase 1: t is 1. Then, the number of ways is the sum over all connected components (with size ≥2) of (a_i choose 2 + b_i choose 2) plus the number of ways to connect two components (each of size 1) with edges. Wait, no. Because if there are components with size 1, adding an edge between them would not create an odd cycle. Because that would be a single edge, not a cycle. So only adding edges within a component (if that component has size ≥2) would create an odd cycle.\n\nSo in the case where the graph has some components with size ≥2, then the minimal t is 1, and the number of ways is the sum over all components of (a_i choose 2 + b_i choose 2). However, for components that are single nodes, they contribute nothing. So in the third sample input, the graph has three components, each of size 1. So there are no components with size ≥2. Hence, t is 3, and w is 1.\n\nSo the steps are:\n\nCheck if the graph has any odd cycle. If not, proceed.\n\nCheck if there exists at least one connected component with size ≥2. If yes, then t is 1, and w is the sum over all connected components (with size ≥2) of (a_i choose 2 + b_i choose 2). If not, then all components are single nodes. Then t is 3, and w is 1 (since there is only one way to connect three nodes into a triangle).\n\nSo how to implement this?\n\nSo the plan is:\n\n- Check if the graph is bipartite. If not, output 0 1.\n\n- Else:\n\n   - Check if there's at least one connected component with size ≥2. \n\n      - If yes: then t is 1, and w is the sum for each connected component (with size ≥2) of (a_i choose 2 + b_i choose 2). \n\n      - If no: then t is 3, and w is 1.\n\nBut how to check if the graph is bipartite. Also, for each connected component, we need to find the sizes of the two partitions (a_i and b_i) for bipartition.\n\nSo the steps for the code:\n\nImplement BFS or DFS to check bipartition for each connected component. For each component, track the size of each partition.\n\nOnce we have that, proceed.\n\nNow, let's test this against the sample inputs.\n\nSample input 3: n=3, m=0. All components are size 1. So t is 3, w is 1. Which matches the sample output.\n\nSample input 2: n=3, m=3. The graph is a triangle. So it's not bipartite. So output 0 1. Which matches the sample.\n\nSample input 1: the graph is connected, with size 4. The component is bipartitioned into 2 and 2. So sum is (2C2 + 2C2) = 1+1=2. So output 1 2. Which matches.\n\nAnother example: suppose a graph has two components. One is a single node, another is a component with two nodes. Then, the sum for the second component is (1C2 + 1C2) = 0 + 0 = 0. Wait, no. Wait, for a component with two nodes connected by an edge. The bipartition is (1,1). So a_i = 1, b_i = 1. Then (1 choose 2) is 0, same for b_i. So sum is 0. But adding an edge between the two nodes in the same partition? Wait, but the two nodes are in different partitions. So adding an edge between them would not create a cycle. Wait, the component is two nodes connected by an edge. The bipartition is {A, B} with A and B being the two nodes. Adding an edge between A and B would create a cycle of length 2 (but that's not allowed, since the cycle must have more than one vertex. Wait, no, a cycle of two nodes would require two edges. So the original edge is between A and B. Adding another edge between A and B would create a parallel edge, which is not allowed. So in this case, the component is a single edge. So to create an odd cycle, you need to add an edge between two nodes in the same partition. But the component has two nodes in different partitions. So how can you add such an edge? There are no other nodes. So the sum for this component is (1 choose 2) + (1 choose 2) = 0. So the total sum is zero. But that's a problem. Because adding an edge between the two nodes would not create an odd cycle. Wait, but the existing component is bipartitioned. Adding an edge between the two nodes would create a cycle of length 2 (the original edge and the new edge), but since it's a multiedge, which is not allowed. So the code is correct here. So the sum is zero. But that component has size 2. So according to the code, the t is 1. But how?\n\nWait, in this case, the component is a single edge between two nodes. So the bipartition is (1,1). To create an odd cycle, we need to add an edge between two nodes in the same partition. But there are no such pairs. So the sum is zero. But according to the code, the t is 1. Which is wrong. Because in this case, adding any edge would not create an odd cycle. So what's the problem here?\n\nAh, this is a contradiction. So the previous reasoning is wrong. How can this happen?\n\nWait, the component is a single edge. So the bipartition is (A, B) with sizes 1 and 1. Adding an edge between A and B would not create a cycle (since there's only one edge between them). Adding an edge between A and A (loop) is not allowed. Same for B. So there's no way to add an edge to create an odd cycle. But according to the code's logic, since there's a component of size ≥2, the t is 1. But that's impossible. So what's wrong here?\n\nThis suggests that the previous logic is missing a condition. Not all connected components with size ≥2 can contribute to the sum. Only those components where at least one of the partitions has size ≥2. Because for a component with a_i and b_i both equal to 1, adding an edge between them (which is not allowed, since it's already present) or between same partitions (which is impossible) can't create an odd cycle.\n\nSo the problem is that for a connected component that is a tree (like a single edge), the sum (a_i choose 2 + b_i choose 2) is zero, but the component has size ≥2. So according to the code, the minimal t is 1, but in reality, adding any edge would not create an odd cycle.\n\nSo what's wrong here?\n\nAh! The mistake is that the component is bipartite, but adding an edge between two nodes in the same partition would create an odd cycle. But in this case, the component is a single edge. The bipartition is (A, B) with size 1 and 1. Adding an edge between A and B is not possible (already exists). Adding an edge between A and A is not allowed. So no way to add an edge to create an odd cycle. But according to the code's logic, the component contributes zero to the sum, but the code would still output t=1. But that's impossible.\n\nSo this indicates that the code's logic is incorrect. So how to fix this?\n\nSo the problem is that for a component to allow creating an odd cycle by adding one edge, the component must have at least two nodes in one of the partitions. Because adding an edge between two nodes in the same partition would create an odd cycle.\n\nSo for example, if the component has a bipartition (a, b) with a ≥2, then there are a*(a-1)/2 possible edges to add between nodes in the same partition. Similarly for b ≥2.\n\nBut if the component is a bipartition (1, 1), then there are zero such edges. So adding any edge would not create an odd cycle.\n\nSo the code needs to check, for each component with size ≥2, whether at least one of the partitions has size ≥2. If yes, then the component contributes (a_i choose 2 + b_i choose 2) to the sum. If not, then the component cannot contribute any edges, and thus, the minimal t is not 1.\n\nWait, but this complicates things. So how to find the minimal t?\n\nLet me re-express the problem. If the graph is bipartite, then:\n\nCase 1: There exists a connected component that has at least two nodes in one of the partitions. Then, adding an edge between two nodes in that partition creates an odd cycle. So the minimal t is 1.\n\nCase 2: All connected components have partitions of size 1 and 1 (i.e., each component is a single edge, or a bipartition with sizes 1 and 1). Then, adding an edge between two nodes in the same partition is not possible (because each component has only one node in each partition). So, to create an odd cycle, you need to add two edges. For example, take two components, each being a single edge (two nodes). Connect the two components by adding edges between nodes in the same partition. But how?\n\nAlternatively, perhaps in this case, the minimal t is 2. For example, take two components, each with two nodes. Connect them by adding two edges between nodes in the same partition.\n\nBut this is getting complicated.\n\nLet me think of specific examples.\n\nExample 1: Component is a single edge (nodes A and B). Bipartition is (A, B) with sizes 1 and 1. How to create an odd cycle? Impossible with adding one edge. So the minimal t is 2. For example, add an edge between A and another node C (from another component), and between B and C. Then, the cycle A-B-C-A is of length 3, which is odd. But in this case, the component was originally two separate components. So, the graph is bipartitioned. Adding two edges between A and C, and B and C. But how does that affect the bipartition?\n\nWait, the original components are bipartitioned. Suppose we have two components. The first is A and B (connected). The second is C and D (connected). Now, adding edges A-C and B-D. Then, the new graph would have a cycle A-B-D-C-A, which is length 4 (even). Not helpful. Alternatively, adding edges A-C and B-C. Then, the cycle A-B-C-A is length 3. Which is odd. So that would require adding two edges. So the minimal t is 2.\n\nBut in this case, the original graph is bipartite. So the minimal t is 2.\n\nBut according to the previous logic, since there are components of size ≥2, the minimal t is 1. Which is wrong.\n\nSo the previous logic is incorrect.\n\nSo the problem is that the previous approach assumed that any component with size ≥2 can contribute to the sum, but that's only true if the component has at least two nodes in one partition.\n\nSo the correct approach is:\n\nIf there exists any connected component that has at least two nodes in one of its partitions (i.e., a_i ≥ 2 or b_i ≥ 2), then the minimal t is 1, and the number of ways is the sum of (a_i choose 2 + b_i choose 2) over all such components.\n\nOtherwise, if all components have a_i = 1 and b_i = 1 (i.e., each component is a single edge), then the minimal t is 2. And the number of ways is the number of pairs of components multiplied by ... ?\n\nWait, how to calculate the number of ways in that case.\n\nLet me think. For example, if there are k components, each being a single edge (so two nodes per component). Then, to create an odd cycle, you need to connect three of them. For example, take three components and add edges between their nodes. But this seems complex.\n\nAlternatively, the minimal number of edges to add is 2. For example, take two components. Take one node from the first component (say A) and one node from the second component (say C). Add an edge between A and C. Then, add an edge between A and another node from the second component (say D). This creates a cycle A-C-D-A, which is length 3. Wait, no. The cycle would be A-C-D-A, which is length 3. Yes. So that requires adding two edges.\n\nBut how many ways are there to do that?\n\nIn this case, for two components, each with two nodes (A-B and C-D). The number of ways to choose two edges to add that create a cycle of length 3.\n\nFor example, add edge A-C and A-D. Or A-C and B-C. Or B-C and B-D, etc. But how to count all possibilities.\n\nBut this seems complicated. However, the problem states that the minimal t is 2 in this scenario. But how to compute w.\n\nBut given the time constraints, perhaps the problem expects that when all connected components are of size 1 or 2 (and for size 2, the partitions are 1 and 1), then the minimal t is 2, and the number of ways is the number of ways to choose two edges that form a triangle between three nodes from different components.\n\nBut this seems very complex. How to handle all cases?\n\nAlternatively, perhaps the problem can be divided into several cases:\n\nIf the graph is bipartite:\n\nCase A: There exists a connected component with at least two nodes in one of the partitions. Then t=1, and w is the sum of (a_i choose 2 + b_i choose 2) for all components with a_i ≥ 2 or b_i ≥ 2.\n\nCase B: All connected components are of size 1 (single nodes) → t=3, w=1.\n\nCase C: All connected components are of size 2 (each is a single edge) → t=2, w= (k choose 2) * 2, where k is the number of components. Or some other formula.\n\nBut how to handle case C?\n\nLet's take an example. Suppose there are two components, each being a single edge. So four nodes total.\n\nFor case C: to create an odd cycle, you need to add two edges. For example, add an edge between node A (from first component) and node C (from second component), and between node A and node D (from second component). This forms a triangle A-C-D-A. Another possibility is to add an edge between A and C, and between B and C. That forms a triangle A-B-C-A. Or between B and C and B and D, etc.\n\nSo for each pair of components, there are 2 * 2 = 4 possible ways to choose two edges that form a triangle. For example, for two components, each with two nodes, the number of ways to connect them with two edges to form a triangle is 2 * 2 * 2 = ? Let me think.\n\nEach component has two nodes. Let's say the first component has nodes A and B, the second has C and D.\n\nTo form a triangle, you need three nodes. So you need to select two components, and take one node from one component and two from another. Or take two nodes from one component and one from another.\n\nWait, but the original components are single edges. So each has two nodes.\n\nFor example, to form a triangle, you need to connect three nodes. So you can take two nodes from one component and one from another. But how?\n\nIf you take two nodes from the same component (say A and B), and one from another component (say C), then adding edges A-C and B-C forms a triangle. That requires adding two edges. So for each pair of components, you can choose one component to provide two nodes, and the other to provide one node. But since the components are two in number, for each pair of components, there are 2 options (which component provides two nodes).\n\nWait, but for two components, component1 (A, B) and component2 (C, D). To form a triangle, you can:\n\n- Choose A and B from component1, and C from component2. Add edges AC and BC → triangle ABC.\n\n- Choose A and B from component1, and D from component2. Add edges AD and BD → triangle ABD.\n\n- Choose C and D from component2, and A from component1. Add edges CA and DA → triangle CAD.\n\n- Choose C and D from component2, and B from component1. Add edges CB and DB → triangle CBD.\n\n- Choose A from component1, and C and D from component2. Add edges AC and AD → triangle ACD.\n\n- Choose B from component1, and C and D from component2. Add edges BC and BD → triangle BCD.\n\n- Choose A from component1 and C from component2, and D from component2. Add edges AC and AD → same as above.\n\nWait, no. For two components, there are 2 * 2 = 4 ways to choose the nodes. Or maybe I'm getting confused.\n\nAlternatively, for each pair of components, there are 2 * 2 * 2 = 8 ways to add two edges that form a triangle.\n\nBut this seems complex. However, in this case, for two components, the number of ways to add two edges that form a triangle is 2 (ways to choose which component provides two nodes) * [ (number of ways to choose two nodes from that component) * (number of ways to choose one node from the other component) * (number of ways to add two edges between them)].\n\nFor example, if we choose component1 to provide two nodes (A and B), and component2 to provide one node (C or D). For each choice of component2 node, there are two ways (C or D). For each, there are two ways to connect the two nodes from component1 to the one from component2: adding edges between A and C, and B and C. Or A and D, and B and D. So for each pair of components, the number of ways is 2 (which component provides two nodes) * 2 (number of nodes in the other component) * 1 (ways to connect). Wait, I'm not sure.\n\nBut for two components, the number of ways would be 2 * 2 * 2 = 8. Because:\n\nFor each pair of components, there are two choices for which component provides two nodes (component1 or component2). For each choice, the component providing two nodes has only one way to choose its nodes (since it has two nodes). The other component has two nodes to choose from. For each of those, there are two ways to connect (e.g., if the other component has node C and D, and we choose C, then connect both nodes from the first component to C).\n\nSo for component1 and component2, the number of ways is 2 * 2 * 1 = 4 (since for each of the two choices of which component provides two nodes, there are 2 nodes in the other component, and one way to connect). So 2 * 2 = 4.\n\nBut for two components, the total number of ways is 4.\n\nSo for k components, the number of ways would be k choose 2 multiplied by 4.\n\nWait, for k=2, it's 1 * 4 = 4.\n\nBut in the example of two components, the sample input would have w=4. But what if the problem's sample input is something like this?\n\nBut this seems complicated to handle. However, in the third sample input, where all components are single nodes, the minimal t is 3. So how to generalize this?\n\nThis suggests that the problem is more complex than previously thought. Given the time constraints, perhaps I should look for an alternative approach.\n\nLet me refer back to the original problem statement. The problem requires finding the minimum number of edges to add to form an odd cycle, and the number of ways.\n\nLet me think about the following:\n\nThe minimal number of edges to add to create an odd cycle in a bipartite graph.\n\nIf the graph is bipartite, then:\n\n- If there exists at least one connected component with at least three nodes, then t=1. Because you can add an edge between two nodes in the same partition of that component.\n\n- If all components have size 1 or 2:\n\n   - If there is at least one component with size 2 (i.e., a single edge), then t=2. Because you can connect two components by adding two edges to form a triangle.\n\n   - If all components are size 1 (n >= 3), then t=3. Because you need to connect three nodes with three edges to form a triangle.\n\nSo the steps are:\n\nAfter confirming the graph is bipart",
    "response": "To solve this problem, we need to determine the minimum number of edges required to form an odd-length cycle in a given undirected graph and the number of ways to achieve this. The solution involves checking if the graph is bipartite and then analyzing its components to find the necessary edges.\n\n### Approach\n1. **Check for Odd Cycles**: If the graph already contains an odd-length cycle, the answer is `0 1` because no additional edges are needed.\n2. **Bipartite Graph Analysis**: If the graph is bipartite, we analyze each connected component:\n   - **Component with Size ≥ 3**: Adding one edge within the same partition of a component with at least three nodes can create an odd cycle.\n   - **Components with Size 2**: If all components have size 2 (each being a single edge), we need two edges to form an odd cycle.\n   - **Components with Size 1**: If all components are isolated nodes, we need three edges to form a triangle.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    color = [-1] * n\n    is_bipartite = True\n    component_info = []\n\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            while queue:\n                u = queue.popleft()\n                for v in graph[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        count[color[v]] += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            component_info.append(count)\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    has_large_component = False\n    sum_ways = 0\n    num_components_size_2 = 0\n    num_single_nodes = 0\n\n    for a, b in component_info:\n        if a + b >= 3:\n            has_large_component = True\n            sum_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n        elif a + b == 2:\n            num_components_size_2 += 1\n        else:\n            num_single_nodes += 1\n\n    if has_large_component:\n        print(f\"1 {sum_ways}\")\n    else:\n        if num_single_nodes == n:\n            print(\"3 1\")\n        else:\n            # All components are of size 2\n            k = num_components_size_2\n            ways = k * (k - 1) * 2\n            print(f\"2 {ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The graph is checked for bipartiteness using BFS. If any component is not bipartite, it already contains an odd cycle.\n2. **Component Analysis**: For each connected component, we determine its bipartition sizes. If a component has at least three nodes, it contributes to the number of ways to form an odd cycle by adding one edge within the same partition.\n3. **Special Cases**:\n   - If all components are isolated nodes, forming a triangle requires three edges.\n   - If all components are pairs of nodes (edges), forming a triangle requires two edges between nodes from different components.\n\nThis approach efficiently determines the minimum edges needed and the number of ways to achieve the desired odd-length cycle.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    color = [-1] * n\n    is_bipartite = True\n    component_info = []\n\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            count = [0, 0]\n            count[0] += 1\n            while queue:\n                u = queue.popleft()\n                for v in graph[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        count[color[v]] += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            component_info.append(count)\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    has_large_component = False\n    sum_ways = 0\n    num_components_size_2 = 0\n    num_single_nodes = 0\n\n    for a, b in component_info:\n        if a + b >= 3:\n            has_large_component = True\n            sum_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n        elif a + b == 2:\n            num_components_size_2 += 1\n        else:\n            num_single_nodes += 1\n\n    if has_large_component:\n        print(f\"1 {sum_ways}\")\n    else:\n        if num_single_nodes == n:\n            print(\"3 1\")\n        else:\n            # All components are of size 2\n            k = num_components_size_2\n            ways = k * (k - 1) * 2\n            print(f\"2 {ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 578,
        "completion_token_count": 878,
        "thoughts_token_count": 8192
    }
}