{
    "start": 1758313593.2127254,
    "end": 1758313630.5382864,
    "start-formatted": "2025-09-20 05:26 KST",
    "end-formatted": "2025-09-20 05:27 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the construction rules again.\n\nSo the snowflake starts with one vertex. Then, we add k new vertices connected to the initial one. Then, each vertex that has only one connection (so those added in the first step) must have k new vertices connected to them. And this process must be done at least once. Wait, so the initial step is adding k children to the root. Then, each of those k nodes must have k children added. So the process is like building layers. But how does that translate into the total number of vertices?\n\nLet me think about the structure. The snowflake is a tree. Because each step adds new vertices connected to existing ones. Let's model the number of vertices.\n\nLet me think recursively. Let's consider the construction steps. The first step is the root node. Then, in step 1, we add k children. Now, the total number of nodes is 1 + k. Then, each of those k nodes must have k children. So for each of them, we add k new nodes. So the next step adds k * k nodes. Now total is 1 + k + k^2. But wait, the problem says that this step (adding k children to each leaf) should be done at least once. So the minimal snowflake would be when we do this once. So for example, for k=4, the minimal snowflake would have 1 + 4 + 4*4 = 1 +4 +16 = 21? Wait but the example given in the problem says that for n=6, the answer is NO. Let's check the sample input and output.\n\nLooking at the sample input:\n\nSample Input:\n9\n1\n2\n3\n6\n13\n15\n255\n10101\n1000000000000000000\n\nSample Output:\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES\nNO\n\nFor example, when n=13, the answer is YES. Let's think why. Let's see: For example, if k=3, then the structure could be:\n\nInitial node (1), then add 3 children (total 4). Then each of those 3 nodes adds 3 children. So that's 3*3=9 more nodes. Total is 1+3+9=13. So yes, that's valid. So that's why 13 is a yes.\n\nSimilarly, for n=15, maybe k=2. Let's see: initial node (1), then add 2 children (total 3). Then each of those two nodes adds 2 children. That's 2*2=4, total 3+4=7. Then, the next step would be adding another layer. But according to the problem statement, the step of adding k children to each leaf must be done at least once. So for the minimal case, we need to do it once. So for k=2, the minimal is 1+2 + 2^2 = 7. But maybe there's another way. Wait, but what if we have more layers?\n\nWait, the problem says that the process of adding k new vertices to each leaf (those with only one connection) is done at least once. So after the initial step (adding the first k children), you have to do that step once. So the minimal structure is when you do it once. But perhaps there are other possibilities where you do it multiple times. So for example, for k=2, the structure could be built as:\n\nLayer 0: 1 node (root)\nLayer 1: 2 nodes (children of root)\nLayer 2: 2*2 =4 nodes (each of layer 1 has 2 children)\nThen, for layer 3: each of the layer 2 nodes (which are leaves) get 2 children each. So that's 4*2 =8. Total nodes would be 1+2+4+8=15. Which matches n=15. So yes, that's allowed. So for n=15, possible.\n\nSo the snowflake can have multiple layers. The key is that the construction must proceed in such a way that each time we add a layer, which is k times the previous layer. But the initial step is adding the first layer (k nodes). Then, each subsequent step adds a new layer. However, the problem says that the step of adding k children to each leaf must be done at least once. So the minimal case is when we have two layers (the initial step plus one more step). But",
    "response": "To solve this problem, we need to determine if a given number of vertices `n` can form a valid snowflake graph as defined. A snowflake graph is constructed in layers starting from a root node, where each node added in a layer has exactly `k` new nodes connected to it in the next layer, with `k > 1`.\n\n---\n\n### Key Observations:\n\n- The snowflake structure forms a tree.\n- The total number of vertices for a snowflake with `m` layers and a branching factor `k` is:\n  $$\n  n = 1 + k + k^2 + \\ldots + k^{m}\n  $$\n  This is a geometric series sum: \n  $$\n  n = \\frac{k^{m+1} - 1}{k - 1}\n  $$\n- For `n` to be valid, there must exist some integer `k > 1` and integer `m ≥ 1` such that the above equation holds.\n\n---\n\n### Strategy:\n\nWe need to check for all possible values of `k` whether `n` can be expressed in the form of the geometric sum above. However, since `n` can be as large as $10^{18}$, brute-force checking all `k` is not feasible.\n\nInstead, we can use the following approach:\n- For each test case `n`, iterate over possible values of `k` (starting from 2 up to a reasonable upper bound).\n- For each `k`, compute the geometric sum until it exceeds `n`. If the sum equals `n`, return \"YES\".\n- If no such `k` exists, return \"NO\".\n\nSince the sum grows exponentially, the number of iterations per test case is limited, making this approach efficient even for large `n`.\n\n---\n\n### Implementation Details:\n\n- We loop `k` from 2 to `sqrt(n)` (since for larger `k`, the sum will exceed `n` quickly).\n- For each `k`, simulate the geometric sum incrementally and stop if it exceeds `n`.\n\n---\n\n### Python Code:\n\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    max_k = int(math.isqrt(n)) + 2\n    for k in range(2, max_k + 1):\n        total = 1  # Start with root\n        current = 1\n        while True:\n            total += current\n            if total == n:\n                return True\n            if total > n:\n                break\n            current *= k\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### Explanation of the Code:\n\n- The function `is_snowflake(n)` checks if `n` can be represented as the sum of a geometric series with base `k > 1` and at least one additional layer (i.e., the process described in the problem).\n- The outer loop iterates over possible `k` values.\n- For each `k`, we simulate the construction of the snowflake by building the geometric sum step by step.\n- If at any point the sum equals `n`, we return `True`.\n- If no such configuration is found, we return `False`.\n\nThis solution is efficient and handles the large constraints up to $10^{18}$ due to the exponential growth of the geometric sum limiting the number of iterations per test case.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    max_k = int(math.isqrt(n)) + 2\n    for k in range(2, max_k + 1):\n        total = 1  # Start with root\n        current = 1\n        while True:\n            total += current\n            if total == n:\n                return True\n            if total > n:\n                break\n            current *= k\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 554,
        "completion_token_count": 792,
        "thoughts_token_count": 1024
    }
}