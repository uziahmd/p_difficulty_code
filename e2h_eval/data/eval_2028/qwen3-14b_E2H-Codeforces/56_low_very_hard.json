{
    "start": 1758309277.4262383,
    "end": 1758309332.226497,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if there's a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. Hmm.\n\nFirst, the problem says that each spaceship is assigned to exactly one base, and every base has exactly one guardian. So it's a bipartite matching problem. But the twist is that the edges (the lines connecting the pairs) must not cross each other. So even if there's a perfect matching in terms of numbers (like R equals B), we need to check if there's a way to pair them without any intersecting lines.\n\nWait, but how do I check for that? Because for each possible perfect matching, I have to make sure that none of the line segments between the pairs cross each other. But with R and B up to 10, the number of possible perfect matchings could be up to 10! which is manageable for small sizes. But even so, for each possible permutation (since R=B), I need to check if all the line segments are non-intersecting.\n\nBut how do I check if two line segments intersect? Oh right, there's computational geometry algorithms for that. So first, I need to generate all possible perfect matchings (if R=B) and for each, check if all the line segments between the pairs are non-crossing. If any of them satisfies this condition, output \"Yes\", else \"No\".\n\nBut wait, what if R != B? Then obviously, it's impossible. So the first check is whether R equals B. If not, output \"No\". Otherwise, proceed.\n\nSo the steps are:\n\n1. Check if R and B are equal. If not, output No.\n2. Generate all possible perfect matchings between the R spaceships and B bases. Since R=B, each is a permutation of the bases.\n3. For each such permutation, check if all the line segments between the spaceship and the base in the permutation do not intersect with each other.\n4. If any permutation passes the check, output Yes. Else, No.\n\nBut how to generate all permutations? Well, since R can be up to 10, the number of permutations is 10! = 3,628,800. For each permutation, we need to check O(R^2) line segment intersections. Let's see: for R=10, each permutation requires checking 10*10/2 pairs? Wait, no. For each permutation, there are R line segments. For each pair of line segments, check if they cross. So for R=10, there are C(10,2) = 45 pairs of line segments. For each pair, check if they intersect. So for each permutation, 45 checks. Multiply by 3.6 million permutations: 3.6e6 * 45 = 162 million operations. That's acceptable for Python? Maybe. But perhaps there's a smarter way.\n\nAlternatively, maybe there's a way to model this as a bipartite graph where edges are allowed only if they don't cross with others. But that's not straightforward because the choice of edges affects each other.\n\nBut given the constraints of R and B being up to 10, the brute-force approach might be feasible.\n\nSo first, the plan is:\n\n- Check R == B. If not, output No.\n- Generate all permutations of the bases (since each permutation represents a possible assignment of spaceships to bases).\n- For each permutation, check that all line segments between the i-th spaceship and the i-th base in the permutation do not cross each other.\n- If any permutation passes, output Yes. Else, No.\n\nNow, the key part is implementing the line segment intersection check.\n\nHow to check if two line segments AB and CD intersect?\n\nThe standard approach is to use the orientation method. The steps are:\n\n1. Check if the two line segments AB and CD intersect by checking if the orientations of (A, B, C), (A, B, D), (C, D, A), (C, D, B) are such that the points C and D are on opposite sides of AB, and A and B are on opposite sides of CD. Also, need to handle the case where the segments are colinear and overlapping.\n\nBut since the problem states that no three points are on the same line, so colinear segments cannot have overlapping points. Wait, the note says that no three points are on the same line. So any two line segments (from different pairs) cannot be colinear. Because if two line segments were colinear, then their endpoints would lie on the same line, which would imply that three points are colinear. But the input ensures that no three points are colinear. Therefore, two line segments can't be colinear. So, for two line segments AB and CD, if they intersect, they must do so at",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. This involves checking all possible permutations of assignments and verifying if any permutation meets the non-intersecting condition.\n\n### Approach\n1. **Check for Equal Numbers**: First, ensure the number of spaceships (R) is equal to the number of bases (B). If not, output \"No\".\n2. **Generate Permutations**: For each permutation of the bases, consider it as a potential assignment of bases to spaceships.\n3. **Check Line Intersections**: For each permutation, check if any pair of line segments (connecting a spaceship to its assigned base) intersect. This is done using computational geometry to determine if two line segments intersect.\n4. **Output Result**: If any permutation satisfies the non-intersecting condition, output \"Yes\"; otherwise, output \"No\".\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    R_B = lines[0].split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, lines[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, lines[i].split())\n        bases.append((x, y))\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(a, c, b):\n        return True\n    if o2 == 0 and on_segment(a, d, b):\n        return True\n    if o3 == 0 and on_segment(c, a, d):\n        return True\n    if o4 == 0 and on_segment(c, b, d):\n        return True\n\n    return False\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    R_B = input_lines[0].split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    if R != B:\n        print(\"No\")\n        return\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, input_lines[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, input_lines[i].split())\n        bases.append((x, y))\n    \n    from itertools import permutations\n    \n    for perm in permutations(bases):\n        intersect = False\n        for i in range(R):\n            for j in range(i+1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Orientation Check**: This helper function determines the orientation of three points, which is crucial for checking line segment intersections.\n- **Segment Intersection Check**: This function uses the orientation check to determine if two line segments intersect.\n- **Permutations Check**: By generating all permutations of base assignments, we check each potential perfect matching for intersecting lines. If any permutation is valid, the answer is \"Yes\"; otherwise, it's \"No\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    R_B = lines[0].split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, lines[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, lines[i].split())\n        bases.append((x, y))\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(a, c, b):\n        return True\n    if o2 == 0 and on_segment(a, d, b):\n        return True\n    if o3 == 0 and on_segment(c, a, d):\n        return True\n    if o4 == 0 and on_segment(c, b, d):\n        return True\n\n    return False\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    R_B = input_lines[0].split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    if R != B:\n        print(\"No\")\n        return\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, input_lines[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, input_lines[i].split())\n        bases.append((x, y))\n    \n    from itertools import permutations\n    \n    for perm in permutations(bases):\n        intersect = False\n        for i in range(R):\n            for j in range(i+1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 1020,
        "thoughts_token_count": 1024
    }
}