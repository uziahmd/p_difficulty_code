{
    "start": 1758313879.6964033,
    "end": 1758314237.5487607,
    "start-formatted": "2025-09-20 05:31 KST",
    "end-formatted": "2025-09-20 05:37 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Homer and Marge are playing a game with a number A of 2n digits. They take turns picking the leftmost digit, and each makes exactly n moves. The goal is to maximize the sum of their numbers S1 and S2. And I have to output the sequence of H and M moves that achieves this maximum.\n\nHmm. The challenge is to find the optimal sequence of choices for Homer and Marge. Since each move affects the remaining digits, it's a decision problem where each choice leads to different possibilities. But since n can be up to 18, the total number of digits is 36. So the total possible sequences would be combinations of choosing n positions for Homer (and the rest for Marge), which is C(36, 18) — that's way too big for brute force. For example, even 36 choose 18 is around 9e10, which is impossible to check exhaustively.\n\nSo we need a dynamic programming approach here. Let's think about the state. At any step, the state depends on how many digits have been taken by Homer and Marge. Let's say that after some steps, Homer has taken h moves and Marge has taken m moves. Since each move takes one digit, the total digits taken so far is h + m. The current state can be represented by h and m, and the current A (but since the digits are taken from the front, the current A is the original A with the first (h+m) digits removed). Wait, but the original A is fixed. So for a given h and m, the current position in the string is h + m digits into the original A. Because each time a digit is taken from the front. So for example, if we have taken k digits, then the next digit to take is the (k)th index (assuming 0-based or 1-based? Well, the original A is given as a string, say, for example, \"1234\" when n=2. Then the first move takes the first digit, then the next takes the next, etc.)\n\nSo the state can be represented by the number of digits taken by Homer (h) and Marge (m). Since each player must take exactly n moves, h can range from 0 to n, and m can range from 0 to n. But since the total digits taken is h + m, and the maximum is 2n, we can model the state as (h, m). For each state, we can decide whether the next move is Homer's or Marge's, depending on which is allowed (i.e., h < n and m < n, respectively).\n\nBut how do we track the maximum total sum? Let's think: for each state (h, m), the current position in the string is h + m digits into the original A. So the next digit to take is at position (h + m) in the original A. Now, the decision is whether the next move is H or M. However, the choice is constrained by the number of moves they have already made. For example, if h < n, then Homer can take the next move. Similarly for Marge.\n\nBut since the players alternate, but the order isn't fixed. Wait no, the players choose who takes the next move each turn. So, for example, if Homer has already taken h moves and Marge has taken m moves, then the next move can be either H or M, provided that they haven't reached their limit. However, the problem says that each player must make exactly n moves. So during the process, the choice of H or M is possible only if h < n (for H) or m < n (for M). \n\nBut the key is that for each state (h, m), the next move can be H or M (if allowed), and the choice affects the future states. The goal is to maximize the total sum of S1 and S2. \n\nBut how do we model the DP transitions? Let's think. Let's denote dp[h][m] as the maximum total sum achievable from the state where Homer has taken h moves and Marge has taken m moves. Then, the value of dp[h][m] is the maximum between two possibilities:\n\n- If Homer takes the next move (possible only if h < n), then the current digit is added to his number. The contribution to the total sum is the digit's value multiplied by 10^{n - h - 1} (since each digit added to Homer's number contributes to the value of S1. For example, if Homer takes the first digit, it's the first digit of his number, which is multiplied by 10^{n-1}, then the next digit is multiplied by 10^{n-2}, etc. Similarly for Marge. Wait, but the digits are added to the end of their numbers. So when Homer takes a digit, it's the first digit of his number, then the second, etc. So the value of S1 is the sum of digit_i * 10^{n - i - 1} for i from 0 to n-1. Wait, for example, if n=2, and Homer takes digits in order 1 then 2, then his number is 12, which is 1*10^1 + 2*10^0. So when he takes the k-th digit (k-th move), the digit is placed in the (k)th position of his number. So the exponent is (n - k)th power. Wait, for the first move (k=0?), the exponent is 10^{n-1}? So for each move, when a player takes a digit, the digit's contribution to their total is digit * 10^{(remaining moves)}. Because, for example, when Homer has h moves already, taking the next digit will be his (h+1)th move. The total number of digits he will have is n. So the position of this digit in his number is the (h+1)th digit. The value of that digit is digit * 10^{n - (h+1)} }.\n\nWait, for example, n=2. Homer takes two digits. The first digit is multiplied by 10^(2-1) = 10, the second by 10^(2-2) = 1. So yes. So for a state (h, m), when Homer takes a digit, the contribution to the total sum is digit * 10^{n - h - 1} (because h is the number of moves he has already made; adding this new one makes it h+1, so the exponent is (n - (h+1)) = n - h - 1. Similarly for Marge, when she takes a digit, her contribution is digit * 10^{n - m - 1}.\n\nSo the DP recurrence is:\n\ndp[h][m] = max( \n\n   (if h < n) [digit * 10^{n - h - 1} + dp[h+1][m]], \n\n   (if m < n) [digit * 10^{n - m - 1} + dp[h][m+1]] \n\n)\n\nBut wait, the digit here is the next available digit. Which is the (h + m)th digit of the original string. Because, when h + m digits have been taken, the next digit is the (h + m)th index (assuming zero-based). For example, if h=0, m=0, the next digit is A[0]. Then, after taking it, the next digit is A[1], etc.\n\nSo the DP needs to track the current position, which is h + m. But since h and m are known, the position is determined. Therefore, the DP state can be represented as (h, m), and for each state, the current digit is A[h + m].\n\nThe base case is when h == n and m == n. Then, there are no more digits to take, so the total sum is 0.\n\nBut for the DP, we need to compute the maximum sum possible from state (h, m). So the DP can be memoized, and we can compute it recursively with memoization.\n\nNow, considering that n can be up to 18, the number of possible states is (n+1) * (n+1) = 19 * 19 = 361 for n=18. That's very manageable. So the DP approach is feasible here.\n\nBut wait, the problem is that for each state, the digit's contribution depends on the current h and m. So for each state, the next digit is known. So the DP can be computed with memoization.\n\nBut how to compute the 10^{exponent} terms? For exponents up to n-1. Since n can be up to 18, 10^18 is a big number, but Python handles big integers well. However, precomputing the powers of 10 would be better for efficiency.\n\nSo, let's precompute a list of powers of 10. For example, pow10[k] = 10^k. Then, for Homer's contribution when he takes a digit at a state where he has h moves already, the exponent is (n - h - 1). So, pow10[n - h - 1]. Similarly for Marge.\n\nBut let's think about the steps:\n\nFirst, read n and the string A.\n\nThen, precompute the pow10 array. For exponents from 0 to n-1. Because for Homer, when he takes his k-th move (from 0 to n-1), the exponent is (n - (k+1)) = n - k - 1. So the maximum exponent is n - 1 (when k=0).\n\nBut for n up to 18, 10^18 is manageable as an integer.\n\nNow, the DP function. Let's implement memoization using lru_cache, but since n is small, even recursion is manageable.\n\nBut since the state is (h, m), and the parameters are small, memoization is feasible.\n\nBut how to track the actual path (the sequence of H and M moves) that gives the maximum sum? Because the DP only gives the maximum sum, but we need to reconstruct the path.\n\nSo, for that, we need to not only track the maximum sum, but also the choice (H or M) that was made at each step.\n\nSo, perhaps, we can use memoization for both the maximum sum and the best choice. Alternatively, once the DP table is filled, we can backtrack through the choices.\n\nSo, the plan is:\n\n1. Precompute the pow10 array.\n\n2. Implement a DP with memoization that returns the maximum total sum for state (h, m).\n\n3. For each state, during the DP computation, track which choice (H or M) leads to the maximum sum. Then, once the DP is filled, we can reconstruct the path by starting from (0, 0) and choosing the best option at each step.\n\nBut how to handle the memoization for the DP. Let's think about the steps.\n\nLet me think of the DP as a memoization table. For each (h, m), we can compute the maximum sum.\n\nSo, for the DP function, we can write something like:\n\ndef dp(h, m):\n\n    if h == n and m == n:\n\n        return 0\n\n    if memo has (h, m):\n\n        return memo[(h, m)]\n\n    current_pos = h + m\n\n    current_digit = int(A[current_pos])\n\n    options = []\n\n    if h < n:\n\n        # Homer takes the next move\n\n        contribution = current_digit * pow10[n - h - 1]\n\n        total = contribution + dp(h+1, m)\n\n        options.append(total)\n\n    if m < n:\n\n        # Marge takes the next move\n\n        contribution = current_digit * pow10[n - m - 1]\n\n        total = contribution + dp(h, m+1)\n\n        options.append(total)\n\n    max_total = max(options)\n\n    memo[(h, m)] = max_total\n\n    return max_total\n\nBut this is a simplified version. However, in reality, when both options are possible, we have to choose between them. However, the problem is that when there are multiple options with the same maximum value, we need to choose the one that leads to the correct path (like preferring H over M or vice versa, but the problem says that any correct path is acceptable).\n\nBut for the purpose of reconstructing the path, we need to know which choice (H or M) was made at each step. So, perhaps, we can create another memoization table that stores for each (h, m) the choice (H or M) that was made. Or, during the DP computation, we can track the choices.\n\nAlternatively, after computing the DP table, we can reconstruct the path by checking for each state (h, m) which choice (H or M) gives the maximum value.\n\nSo, the steps would be:\n\n- Compute the DP table for all (h, m) states.\n\n- Then, start from (0, 0), and for each step, decide whether to choose H or M based on which option gives the maximum value.\n\nBut how to compute the DP table? Let's think of it as a memoization-based recursive approach.\n\nBut in Python, for memoization, using lru_cache is convenient. However, since the input is up to 18, the number of states is (18+1)^2 = 361, which is manageable.\n\nBut the problem is that the DP function depends on the current digit, which is determined by h and m. So the code can be written with memoization.\n\nOnce the DP is computed, the path can be reconstructed by backtracking.\n\nSo, let's outline the code structure.\n\nFirst, read n and A. For example, input is:\n\nn = int(input())\n\nA = input().strip()\n\nThen, precompute pow10. For example, pow10 = [10**i for i in range(n)] ?\n\nWait, for Homer's contribution when he takes a digit when he has h moves already. The exponent is n - h - 1. For example, when h = 0, the exponent is n-1. So for n=2, h=0, the exponent is 1. So pow10[1] is 10^1.\n\nSo pow10 needs to be precomputed up to n-1. So pow10 = [10**i for i in range(n)] ?\n\nYes. Because the exponents go from 0 to n-1.\n\nBut for example, when h is 0, the exponent is n-1 - 0? Wait:\n\nWait, when Homer takes his (h+1)th move. The total number of digits he will have is n. So the digit's place is the (h+1)th digit in his number. So the value is digit * 10^{n - (h+1)} }.\n\nWhich is digit * 10^{n - h - 1}.\n\nSo for exponents, the maximum is n-1 (when h=0, n - h - 1 = n-1 - 0? No, n - 0 -1 = n-1. Yes.\n\nThus, pow10 should be 10^0 up to 10^{n-1}.\n\nSo pow10 = [10**i for i in range(n)] ?\n\nYes. But for n=18, the pow10 array would have 18 elements, from 10^0 to 10^17.\n\nNow, the DP function. Let's think of implementing it with memoization. But in Python, for memoization, using lru_cache with a function that takes h and m as parameters.\n\nBut since the A is fixed, the DP function can refer to it.\n\nSo, the code could look like this:\n\nfrom functools import lru_cache\n\nn = int(input())\nA = input().strip()\n\npow10 = [10**i for i in range(n)]\n\n@lru_cache(maxsize=None)\ndef dp(h, m):\n    if h + m == 2*n:\n        return 0\n    current_pos = h + m\n    current_digit = int(A[current_pos])\n    options = []\n    if h < n:\n        # Homer takes the digit\n        contribution = current_digit * pow10[n - h - 1]\n        total = contribution + dp(h+1, m)\n        options.append(total)\n    if m < n:\n        # Marge takes the digit\n        contribution = current_digit * pow10[n - m - 1]\n        total = contribution + dp(h, m+1)\n        options.append(total)\n    return max(options)\n\nBut wait, this code would compute the maximum sum. However, for the case where both options are possible, it would choose the maximum. But how to reconstruct the path?\n\nOnce the DP table is filled, we can backtrack through the choices. So for each state (h, m), we can check which choice (H or M) gives the maximum value.\n\nSo, during the backtracking phase, starting from (0, 0), for each step:\n\ncurrent_h, current_m = initial state.\n\nresult = []\n\nwhile current_h + current_m < 2*n:\n\n    current_pos = current_h + current_m\n\n    current_digit = int(A[current_pos])\n\n    options = []\n\n    if current_h < n:\n\n        contribution_h = current_digit * pow10[n - current_h - 1]\n\n        total_h = contribution_h + dp(current_h + 1, current_m)\n\n    else:\n\n        total_h = -infinity\n\n    if current_m < n:\n\n        contribution_m = current_digit * pow10[n - current_m - 1]\n\n        total_m = contribution_m + dp(current_h, current_m + 1)\n\n    else:\n\n        total_m = -infinity\n\n    if total_h > total_m:\n\n        result.append('H')\n\n        current_h += 1\n\n    elif total_m > total_h:\n\n        result.append('M')\n\n        current_m += 1\n\n    else:\n\n        # choose either, but the problem allows any\n\n        # perhaps prefer H or M based on some criteria?\n\n        # for example, choose H first\n\n        result.append('H')\n\n        current_h += 1\n\nBut this approach would require recomputing the dp values again. However, since the dp function is memoized, it's possible. But this may not be efficient. However, since the number of steps is 2n, which is up to 36, it's manageable.\n\nBut wait, the dp function is already memoized. So when we call dp(h, m), it returns the maximum value. So during backtracking, for each state, we can check which choice (H or M) gives the maximum value.\n\nBut how to check that? Let me think. For the current state (h, m), the maximum value is max_val = dp(h, m). Then, for the possible options:\n\nif h < n:\n\n    option_h = contribution_h + dp(h+1, m)\n\nelse:\n\n    option_h = -infinity\n\nSimilarly for option_m.\n\nIf option_h is equal to max_val, then the choice was H. Otherwise, it's M.\n\nBut how to compute that during backtracking?\n\nBut in the code above, during backtracking, we can compute the two possible options (H and M) and compare them. However, this would involve recomputing the dp values again. But since the dp is memoized, it's okay.\n\nBut in the code, the dp function is called during backtracking, which would have already been computed during the initial call. So it's safe.\n\nBut how to implement this?\n\nSo, after computing the dp table (which is done via the dp function), we can start backtracking from (0, 0) and for each step, decide whether to take H or M based on which option gives the maximum value.\n\nBut in the code, the dp function returns the maximum value for (h, m). So during backtracking, for each (h, m), we can check which of the possible options (H or M) gives the maximum value.\n\nBut how to do that?\n\nFor example, in the code during backtracking:\n\ncurrent_h, current_m = 0, 0\n\npath = []\n\nwhile current_h + current_m < 2*n:\n\n    current_pos = current_h + current_m\n\n    current_digit = int(A[current_pos])\n\n    option_h = -infinity\n\n    if current_h < n:\n\n        contribution_h = current_digit * pow10[n - current_h - 1]\n\n        option_h = contribution_h + dp(current_h + 1, current_m)\n\n    option_m = -infinity\n\n    if current_m < n:\n\n        contribution_m = current_digit * pow10[n - current_m - 1]\n\n        option_m = contribution_m + dp(current_h, current_m + 1)\n\n    if option_h > option_m:\n\n        path.append('H')\n\n        current_h += 1\n\n    elif option_m > option_h:\n\n        path.append('M')\n\n        current_m += 1\n\n    else:\n\n        # choose either, let's say 'H' first\n\n        path.append('H')\n\n        current_h += 1\n\nBut this would work. However, this approach requires that during backtracking, we call the dp function again. But since the dp function is memoized, it's okay. However, the problem is that the initial dp function computes the maximum value, which is exactly the same as the sum of the contribution and the dp of the next state. So during backtracking, the code would correctly check which option gives the maximum.\n\nBut in the code above, the dp function is called again. However, since the dp function is memoized, it's just a lookup. So the code is acceptable.\n\nBut what about when there are multiple options with the same maximum value? The problem allows any of them. So in that case, we can choose either, perhaps preferring H first.\n\nSo, putting it all together, the code would be:\n\nRead n and A.\n\nCompute pow10.\n\nImplement the dp function with memoization.\n\nThen, backtrack to find the path.\n\nBut there's a problem. The code as written for the dp function would not work because the pow10 array is for exponents up to n-1. However, when n is 18, and the current_h is 0, the exponent is 18-0-1 = 17, which is 10^17. Which is in the pow10 array (since pow10 has indexes 0 to n-1, which is 18 elements for n=18).\n\nYes, because pow10 is [10^0, 10^1, ..., 10^{n-1}].\n\nSo for example, when n=2, pow10 has 2 elements: 1, 10. For Homer taking his first move (h=0), the exponent is 2-0-1=1, so 10^1 = 10, which is pow10[1].\n\nYes, that's correct.\n\nBut in Python, the pow10 list is built as [10**i for i in range(n)]. So for n=2, range(2) is 0,1. So pow10[1] is 10^1. Correct.\n\nSo that part is okay.\n\nNow, testing the sample input.\n\nSample Input 1:\n\n2\n\n1234\n\nSample Output: HHMM\n\nLet's see.\n\nThe digits are 1, 2, 3, 4.\n\nHomer takes two digits, Marge takes two.\n\nThe optimal sequence is HHMM.\n\nLet's compute the sum:\n\nHomer's digits are 1 and 2 → 12 → 12 dollars.\n\nMarge's digits are 3 and 4 → 34 → 34. Total is 46.\n\nAnother option is HMHM: H takes 1, M takes 2, H takes 3, M takes 4. Homer has 13, Marge has 24. Sum is 37. Which is less than 46. So the sample output is correct.\n\nAnother possible option is HMMH: H takes 1, M takes 2, M takes 3, H takes 4. Homer has 14, Marge has 23. Sum is 37. Also less.\n\nSo the code should generate the correct path.\n\nNow, let's think about the DP steps for this case.\n\nLet me try to compute the dp(0, 0) value.\n\nAt (0, 0), current_pos is 0, digit is 1.\n\nOptions:\n\nHomer takes it. Contribution is 1 * 10^(2-0-1) = 1 * 10^1 = 10. Then dp(1, 0).\n\nMarge takes it. Contribution is 1 * 10^(2-0-1) = 1 * 10^1 = 10. Then dp(0, 1).\n\nSo which of dp(1,0) and dp(0,1) is larger?\n\nLet's compute dp(1, 0):\n\nAt (1, 0), current_pos is 1 (h + m = 1). Digit is 2.\n\nHomer can take it (h=1 < 2). Contribution is 2 * 10^(2 - 1 -1) = 2 * 10^0 = 2. Then dp(2, 0). Which is when h=2, m=0. Now, current_pos is 2 + 0 = 2. The digit is 3. But since h=2 (max) and m=0, next move must be Marge's.\n\nSo, dp(2, 0) would have:\n\ncurrent_pos is 2, digit 3. Marge takes it. Contribution is 3 * 10^(2 - 0 -1) = 3 * 10^1 = 30. Then dp(2, 1). \n\nIn dp(2, 1): current_pos is 3. digit is 4. Marge takes it (m=1 < 2). Contribution is 4 * 10^(2 -1 -1) = 4 * 10^0 =4. Then dp(2,2) which returns 0. So total for dp(2,1) is 4. So dp(2,0) is 30 + 4 = 34. So dp(1,0) is 2 + 34 = 36.\n\nNow, dp(0, 1):\n\nAt (0, 1), current_pos is 1. digit is 2.\n\nOptions:\n\nHomer can take it (h=0 < 2). Contribution is 2 * 10^(2-0-1) = 2 * 10^1 = 20. Then dp(1, 1).\n\nOr Marge can take it (m=1 < 2). Contribution is 2 * 10^(2 -1 -1) = 2 * 10^0 = 2. Then dp(0, 2).\n\nLet's compute dp(1,1):\n\ncurrent_pos is 2, digit is 3. Both h and m are 1. So options are H or M.\n\nHomer takes it: contribution is 3 * 10^(2-1-1) = 3 * 1 = 3. Then dp(2,1) which we know is 4. So total 3 + 4 = 7.\n\nMarge takes it: contribution is 3 * 10^(2-1-1) = 3 * 1 = 3. Then dp(1,2). \n\ndp(1,2): current_pos is 3. digit is 4. Only Homer can take it (h=1 < 2). Contribution is 4 * 10^(2-1-1) = 4 * 1 = 4. Then dp(2,2) which is 0. So total 4. So dp(1,2) is 4. So for dp(1,1), the options are 7 (H) and 3 + 4 = 7 (M). So the max is 7. So dp(1,1) is 7.\n\nSo dp(1,1) is 7.\n\nSo for dp(0,1) when Homer takes the digit, the total is 20 + 7 = 27.\n\nNow, what about Marge taking the digit? dp(0,2):\n\ncurrent_pos is 0 + 2 = 2. digit is 3. m is 2, which is equal to n=2. So Marge can't take. So only Homer can take.\n\nSo current_pos is 2, digit 3. h is 0, m is 2. So h < 2. So Homer takes it. Contribution is 3 * 10^(2-0-1) = 3*10^1 = 30. Then dp(1, 2) which is 4. So total is 30 +4=34. So dp(0,2) is 34.\n\nSo for dp(0,1) when Marge takes the digit, the contribution is 2 + 34 = 36. \n\nSo comparing the options for dp(0,1): 27 (H) vs 36 (M). So the max is 36. So dp(0,1) is 36.\n\nSo back to the initial options for dp(0,0): the H option gives 10 + 36 = 46. The M option gives 10 + 36 = 46. So both options are equal. Then, according to the code, we choose H first, leading to the path H followed by ... ?\n\nWait, but in the sample input, the output is HHMM, which would be the case when the first choice is H. But the code would choose H in this case. However, in the sample input, the output is HHMM, which is one of the possible options.\n\nBut in the sample input, the other option would be MMHH, which would also give the same sum. However, the code would choose H first, leading to HHMM.\n\nSo the code would generate the correct path.\n\nBut how does the backtracking code handle this?\n\nIn the case of a tie, the code would choose H. So in this case, the first step would choose H, leading to the path H.\n\nSo the code seems correct.\n\nNow, the code for the DP and backtracking.\n\nBut there's a problem: the pow10 array is built for exponents up to n-1. However, for Marge's contribution, when she takes a digit, the exponent is n - m - 1. So for example, when m is 0, the exponent is n-1, which is covered by pow10.\n\nYes.\n\nNow, the code for the backtracking:\n\nOnce the dp function is computed, the code starts with h=0 and m=0, and builds the path.\n\nBut in Python, the code would need to implement this.\n\nNow, the code:\n\nBut first, the dp function uses the pow10 array. However, in the code, the pow10 is a list in the global scope, which is accessible inside the dp function.\n\nBut in Python, the code would be:\n\nimport sys\nfrom functools import lru_cache\n\nn = int(sys.stdin.readline())\nA = sys.stdin.readline().strip()\n\npow10 = [10**i for i in range(n)]\n\n@lru_cache(maxsize=None)\ndef dp(h, m):\n    if h + m == 2 * n:\n        return 0\n    current_pos = h + m\n    current_digit = int(A[current_pos])\n    options = []\n    if h < n:\n        contribution = current_digit * pow10[n - h - 1]\n        total = contribution + dp(h+1, m)\n        options.append(total)\n    if m < n:\n        contribution = current_digit * pow10[n - m - 1]\n        total = contribution + dp(h, m+1)\n        options.append(total)\n    return max(options)\n\n# Now backtrack to find the path\n\ncurrent_h = 0\ncurrent_m = 0\npath = []\n\nwhile current_h + current_m < 2 * n:\n    current_pos = current_h + current_m\n    current_digit = int(A[current_pos])\n    option_h = -float('inf')\n    if current_h < n:\n        contribution_h = current_digit * pow10[n - current_h - 1]\n        option_h = contribution_h + dp(current_h + 1, current_m)\n    option_m = -float('inf')\n    if current_m < n:\n        contribution_m = current_digit * pow10[n - current_m - 1]\n        option_m = contribution_m + dp(current_h, current_m + 1)\n    if option_h > option_m:\n        path.append('H')\n        current_h += 1\n    elif option_m > option_h:\n        path.append('M')\n        current_m += 1\n    else:\n        # choose H\n        path.append('H')\n        current_h += 1\n\nprint(''.join(path))\n\nWait, but what about when both options are equal? For example, in the first step of the sample input, both options give the same value. The code chooses H, which gives the path HHMM.\n\nBut the sample output for the first case is 'HHMM', which is correct.\n\nAnother test case is the second example in the input:\n\nInput: 2\\n9911\n\nOutput: HMHM.\n\nLet's see. The number is '9911'.\n\nn=2. The digits are 9,9,1,1.\n\nThe optimal path is HMHM.\n\nLet's see:\n\nH takes first digit (9), M takes second (9), H takes third (1), M takes fourth (1).\n\nHomer's number is 91, Marge's is 91. Sum is 182.\n\nAnother option: H takes first, H takes second, M takes third, M takes fourth. Homer has 99, Marge has 11. Sum is 110. Which is worse.\n\nAnother option: HMHM gives 91 + 91 = 182.\n\nAnother option: MHMH would be same sum. But the code would choose H first in case of tie. So for the first step, the code would choose H or M?\n\nLet me compute the dp(0,0) for this case.\n\nAt (0,0), current digit is 9. Options:\n\nH takes it: contribution is 9 * 10^(2-0-1) = 9 * 10^1 = 90. Then dp(1, 0).\n\nM takes it: contribution is 9 * 10^(2-0-1) = 90. Then dp(0, 1).\n\nSo which is better?\n\nLet's compute dp(1, 0) and dp(0, 1).\n\ndp(1, 0):\n\ncurrent_pos = 1 (h=1, m=0). digit is 9.\n\nH can take (h=1 < 2). Contribution is 9 * 10^(2-1-1) = 9 * 1 = 9. Then dp(2, 0). \n\ndp(2, 0): current_pos is 2 (h=2, m=0). digit is 1. M can take. Contribution is 1 * 10^(2-0-1) = 1 * 10^1 = 10. Then dp(2, 1).\n\ndp(2, 1): current_pos is 3. digit is 1. M takes it. Contribution is 1 * 10^(2-1-1) = 1 * 1 = 1. Then dp(2, 2) which is 0. Total for dp(2, 1) is 1. So dp(2,0) is 10 + 1 = 11. So dp(1,0) is 9 + 11 = 20.\n\nNow dp(0, 1):\n\ncurrent_pos is 1. digit is 9. h=0, m=1.\n\nOptions:\n\nH takes: contribution is 9 * 10^(2-0-1) = 9 * 10^1 = 90. Then dp(1, 1).\n\nM takes: contribution is 9 * 10^(2-1-1) = 9 * 1 = 9. Then dp(0, 2).\n\nLet's compute dp(1,1):\n\ncurrent_pos is 2. digit is 1. h=1, m=1.\n\nOptions:\n\nH takes: contribution is 1 * 10^(2-1-1) = 1*1 = 1. Then dp(2,1) which is 1. So total 1 + 1 = 2.\n\nM takes: contribution is 1 * 10^(2-1-1) = 1. Then dp(1,2). \n\ndp(1,2): current_pos is 3. digit is 1. h=1 < 2. Contribution is 1 * 10^(2-1-1) = 1. Then dp(2,2) which is 0. So total is 1. So dp(1,2) is 1. So dp(1,1) has options 2 and 1+1=2. So max is 2.\n\nSo dp(1,1) is 2. Thus, option H for dp(0,1) is 90 + 2 = 92.\n\nNow, option M for dp(0,1): contribution is 9,",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The game involves taking turns to pick digits from a given number, with each player making exactly n moves. The challenge lies in efficiently determining the best sequence of moves given the constraints.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a DP approach to explore all possible sequences of moves while keeping track of the maximum total prize money achievable from each state. The state is defined by the number of moves each player has made so far.\n2. **Precompute Powers of 10**: To efficiently calculate the contribution of each digit to the final number, we precompute powers of 10 up to the maximum required exponent.\n3. **Backtracking to Determine the Path**: After computing the maximum total prize money using DP, we backtrack through the states to reconstruct the sequence of moves that leads to this maximum value.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    \n    pow10 = [10**i for i in range(n)]\n    \n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == 2 * n:\n            return 0\n        current_pos = h + m\n        current_digit = int(A[current_pos])\n        options = []\n        if h < n:\n            contribution = current_digit * pow10[n - h - 1]\n            total = contribution + dp(h + 1, m)\n            options.append(total)\n        if m < n:\n            contribution = current_digit * pow10[n - m - 1]\n            total = contribution + dp(h, m + 1)\n            options.append(total)\n        return max(options)\n    \n    current_h = 0\n    current_m = 0\n    path = []\n    \n    while current_h + current_m < 2 * n:\n        current_pos = current_h + current_m\n        current_digit = int(A[current_pos])\n        option_h = -float('inf')\n        if current_h < n:\n            contribution_h = current_digit * pow10[n - current_h - 1]\n            option_h = contribution_h + dp(current_h + 1, current_m)\n        option_m = -float('inf')\n        if current_m < n:\n            contribution_m = current_digit * pow10[n - current_m - 1]\n            option_m = contribution_m + dp(current_h, current_m + 1)\n        \n        if option_h > option_m:\n            path.append('H')\n            current_h += 1\n        elif option_m > option_h:\n            path.append('M')\n            current_m += 1\n        else:\n            # Prefer 'H' in case of tie\n            path.append('H')\n            current_h += 1\n    \n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Precompute Powers of 10**: This helps in quickly calculating the positional value of each digit when constructing the numbers for Homer and Marge.\n3. **Dynamic Programming Function**: The `dp` function recursively computes the maximum total prize money from a given state `(h, m)` where `h` and `m` are the number of moves made by Homer and Marge respectively.\n4. **Backtracking to Construct Path**: After computing the DP table, we backtrack from the initial state `(0, 0)` to determine the sequence of moves that leads to the maximum total prize money. In case of ties, we prefer Homer's move ('H') to ensure consistency.\n\nThis approach efficiently explores all possible move sequences using dynamic programming and ensures the optimal solution is found with memoization to avoid redundant calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    \n    pow10 = [10**i for i in range(n)]\n    \n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == 2 * n:\n            return 0\n        current_pos = h + m\n        current_digit = int(A[current_pos])\n        options = []\n        if h < n:\n            contribution = current_digit * pow10[n - h - 1]\n            total = contribution + dp(h + 1, m)\n            options.append(total)\n        if m < n:\n            contribution = current_digit * pow10[n - m - 1]\n            total = contribution + dp(h, m + 1)\n            options.append(total)\n        return max(options)\n    \n    current_h = 0\n    current_m = 0\n    path = []\n    \n    while current_h + current_m < 2 * n:\n        current_pos = current_h + current_m\n        current_digit = int(A[current_pos])\n        option_h = -float('inf')\n        if current_h < n:\n            contribution_h = current_digit * pow10[n - current_h - 1]\n            option_h = contribution_h + dp(current_h + 1, current_m)\n        option_m = -float('inf')\n        if current_m < n:\n            contribution_m = current_digit * pow10[n - current_m - 1]\n            option_m = contribution_m + dp(current_h, current_m + 1)\n        \n        if option_h > option_m:\n            path.append('H')\n            current_h += 1\n        elif option_m > option_h:\n            path.append('M')\n            current_m += 1\n        else:\n            # Prefer 'H' in case of tie\n            path.append('H')\n            current_h += 1\n    \n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 426,
        "completion_token_count": 833,
        "thoughts_token_count": 8192
    }
}