{
    "start": 1758023500.3921483,
    "end": 1758026546.3833885,
    "start-formatted": "2025-09-16 20:51 KST",
    "end-formatted": "2025-09-16 21:42 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ â€” the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this Colored Boots problem. Let's read the problem carefully.\n\nSo, there are n left boots and n right boots. Each has a color which can be a lowercase letter or a question mark. The goal is to find the maximum number of pairs where each pair consists of a left and a right boot with compatible colors. Also, I have to output the pairs themselves.\n\nCompatibility rules: two specific colors are compatible if they are the same. A question mark can match any color, including another question mark. So, for example, a '?' on left and 'a' on right is okay. Also, two '?'s are okay.\n\nThe challenge is to maximize the number of such pairs. And then output the pairs.\n\nHmm. How to approach this?\n\nFirst, think about how to pair the boots optimally. Since each boot can be used once, we need to find a way to assign left boots to right boots such that their colors are compatible, and the total is maximized.\n\nLet me think about the steps:\n\nAn initial idea is to first pair the specific colors that match exactly. Then handle the question marks.\n\nBut perhaps there's a better way. Let's think about the following approach:\n\n1. For each color (excluding '?'), count how many left boots have that color and how many right boots have that color. For each color, the number of possible pairs is the minimum of the left count and right count. But since each boot can be used once, we need to track which ones are used.\n\nWait, but that's not enough. Because some boots may be matched in different ways. For example, if a left boot with color 'a' can be matched with a right boot with 'a', but maybe there are more left 'a's than right 'a's. So the maximum number for that color is min(left_a, right_a). But then, after that, the remaining left and right boots with '?' can be matched with each other, but also with the leftover from other colors?\n\nAlternatively, perhaps we can first pair as many exact matches as possible, and then pair the question marks with the remaining ones.\n\nBut how to do that?\n\nAnother approach: Let's consider that each left boot can be matched with a right boot if either:\n\n- Both are specific and same color.\n\nOR\n\n- One is a question mark, and the other is any.\n\nSo, the problem is similar to matching between two sets with certain constraints.\n\nBut how to model this optimally?\n\nLet me think about the following steps:\n\nFirst, process all the exact matches. For example, for each color c (not '?'), count the number of left boots with c, and right boots with c. The number of pairs possible here is min(left_c, right_c). However, we can't just take all of them because maybe some of those could be better paired with question marks. Wait, no. Because if we have a left boot with color 'a' and a right boot with color 'a', that's a direct match. It's better to pair them than to use the question marks for that. Because otherwise, if we leave them unpaired, we might not get the maximum possible pairs.\n\nBut perhaps the optimal strategy is to first pair as many exact matches as possible, and then use the question marks to pair with the remaining.\n\nAlternatively, maybe we should first pair the question marks with the non-question marks, and then pair the remaining question marks. But which approach gives a better total?\n\nLet me think with an example.\n\nSuppose there are 2 left boots: 'a' and '?'\n\nRight boots: 'a' and '?'\n\nIf we pair the 'a's first, then the question marks can be paired. Total 2 pairs.\n\nIf we instead pair the left '?' with the right 'a', and the left 'a' with the right '?', that's also 2 pairs. Same result.\n\nBut if there's a case where pairing a '?' with a non-? would allow more pairs overall.\n\nBut maybe the best way is to first pair all exact matches, then pair the remaining with '?'s.\n\nSo here's a plan:\n\nStep 1: Pair all exact matches (same color, not '?'). For each color c, we can pair as many as possible between left and right.\n\nBut how to do that? We need to collect the indices of left and right boots for each color.\n\nBut perhaps for each color c (excluding '?'), we can take the left boots with color c and the right boots with color c, and pair them up. For example, if there are 3 left 'a's and 5 right 'a's, we can pair 3 of them. Then, the remaining right 'a's can be paired with '?'s later.\n\nOnce that's done, we can process the question marks.\n\nBut how?\n\nAfter handling exact matches, the remaining left and right boots have either '?' or some color that doesn't have a matching in the other side.\n\nNow, for the question marks, we can pair them with any remaining boots (either '?' or specific colors).\n\nSo, for example, if there are some left '?' and right '?', we can pair them. Also, if there are left '?' and right boots with specific colors (that weren't paired yet), we can pair them.\n\nBut how to maximize the number of pairs here?\n\nThe idea is that the remaining left and right boots (after exact matches) can be paired as follows:\n\nWe can pair left '?' with right non-? (if possible), and then pair left ? with right ?, or right ? with left non-?.\n\nBut how to do this optimally?\n\nLet me think about the counts.\n\nLet's say after step 1:\n\nWe have LQ left '?'s, and RQ right '?'s.\n\nAlso, for each color c, there are some left and right boots that couldn't be paired (because they were not matched in step 1). For example, suppose there are left 'b's and right 'b's, but there were more left 'b's than right 'b's. Then, the excess left 'b's can be paired with right '?'s.\n\nSo, the approach is:\n\nFor the remaining left and right boots (after exact matches), collect all the left boots that are not yet paired (they could be '?' or specific colors), and same for right.\n\nThen, for each left boot (specific color) that hasn't been paired, we can pair it with a right '?' if possible. Similarly for right boots that are specific colors and pair with left '?'.\n\nThen, after that, pair the remaining '?'s between left and right.\n\nBut how to implement this efficiently?\n\nLet me outline the steps again:\n\n1. For each color c (excluding '?'), pair as many left and right boots as possible. For example, for color 'a', take the left 'a's and right 'a's and pair them. We can do this by creating a list of left and right indices for each color. Then, pair them in order.\n\nBut how to track which boots have been used already? Because once a boot is paired, it can't be used again.\n\nSo, perhaps we need to track for each left and right boot whether they are already used.\n\nSo, here's the plan:\n\nInitialize two arrays, left_used and right_used, of size n, initialized to False.\n\nThen, for each color c in 'a' to 'z' (excluding '?'):\n\n   collect all left indices where l[i] == c and not used.\n\n   collect all right indices where r[i] == c and not used.\n\n   the number of pairs for this color is min(len(left_list), len(right_list)).\n\n   for each pair, pair the left and right indices, mark them as used.\n\nOnce that's done, we have the exact matches.\n\nNow, for the remaining left and right boots (those not used yet), we need to pair them using the '?'.\n\nSo, for the remaining left boots, some are '?', and some are specific colors (but their corresponding right boots didn't have enough of that color).\n\nSimilarly for the right.\n\nNow, the next step is to pair the remaining left '?' with right boots that are not used and not '?', and vice versa.\n\nBut how?\n\nLet me think: for each left '?' that is not used, we can pair it with any right boot that is not used (could be '?', or any specific color). Similarly for right '?'.\n\nBut how to maximize the pairs here?\n\nThe idea is that the '?' can be used to pair with any non-? boots that are left. So, for example, if there are some left '?' and some right 'b's (unpaired), then we can pair them. Similarly for right '?' and left 'c's.\n\nSo, let's process the remaining left and right boots.\n\nLet me think about the following steps:\n\n- Collect all left boots that are not used and are not '?'. Let's call these left_non_q.\n\n- Collect all right boots that are not used and are not '?'. Call these right_non_q.\n\nNow, for each left_non_q (color c), we can pair it with a right '?' (if available). Similarly, for each right_non_q (color d), pair it with a left '?'.\n\nBut how to do this?\n\nAlternatively, we can pair left_non_q with right_non_q if they have the same color? But no, because they were not paired in the first step. Wait, no. Because in step 1, we already paired all the exact matches. So, any left_non_q and right_non_q that have the same color would have been processed in step 1. Therefore, after step 1, for any color c, the number of left_non_q and right_non_q for that color must be zero? No, that's not correct. Wait, suppose there are 3 left 'a's and 2 right 'a's. Then step 1 pairs 2 left 'a's with 2 right 'a's. The remaining left 'a's (1) will be in left_non_q (since they are not used and not '?'). The right_non_q for 'a's is zero. So, after step 1, for each color c, the left_non_q and right_non_q can have some numbers, but they are not paired because one side had more than the other.\n\nSo, for the remaining left_non_q and right_non_q, their colors don't match (since if they did, they would have been paired in step 1). Wait, no. For example, if a left 'a' and a right 'a' are not paired in step 1 because there were more left 'a's than right 'a's. Then, after step 1, there are some left 'a's left (non-?), and right 'a's are all used. So, the left_non_q has some 'a's, but the right_non_q has none. So, they can't be paired. Hence, these left 'a's can't be paired with any right boots except '?'s.\n\nTherefore, the remaining left_non_q can only be paired with right '?'s, and the remaining right_non_q can be paired with left '?'s.\n\nSo, the next step is:\n\nFor each left boot not used and with color not '?', try to pair it with a right '?'.\n\nSimilarly, for each right boot not used and with color not '?', try to pair it with a left '?'.\n\nOnce that is done, the remaining '?'s can be paired with each other.\n\nSo, how to implement this?\n\nLet me think about the steps:\n\nAfter step 1, we have:\n\n- left_used and right_used arrays.\n\nWe can collect all the left '?' that are not used. Let's call them left_q = [i for i in range(n) if not left_used[i] and l[i] == '?'].\n\nSimilarly, right_q = [i for i in range(n) if not right_used[i] and r[i] == '?'].\n\nThen, collect all the left_non_q (not used and not '?'):\n\nleft_non_q = [i for i in range(n) if not left_used[i] and l[i] != '?']\n\nSimilarly for right_non_q.\n\nNow, for each element in left_non_q, we can pair it with a right '?' if possible.\n\nSimilarly for right_non_q with left '?'.\n\nSo, for example, for each left in left_non_q:\n\n   if there is a right in right_q not yet used, pair them.\n\nOnce we pair as many as possible between left_non_q and right_q, and between right_non_q and left_q, then the remaining left and right '?' can be paired with each other.\n\nBut how to do this?\n\nLet me think of code steps.\n\nWe can create a list of left_non_q and right_non_q.\n\nFor the left_non_q, we can iterate through them and try to pair each with a right '?'.\n\nSimilarly for right_non_q and left '?'.\n\nBut how to track which right '?' are available.\n\nLet me think:\n\nLet's have a pointer for the right_q list. For example, for the left_non_q, we can iterate through each left index, and for each, take the first available right_q index. Similarly for the right_non_q.\n\nBut how to manage that.\n\nAlternatively, for the left_non_q and right_q:\n\nWe can take the minimum of len(left_non_q) and len(right_q) and pair them. Similarly for the right_non_q and left_q.\n\nBut how to do that? For example, for each left in left_non_q, we can pair with a right from right_q.\n\nSo, for the first part:\n\ncount = min(len(left_non_q), len(right_q))\n\nfor i in range(count):\n\n   pair left_non_q[i] with right_q[i]\n\nSimilarly for the other direction.\n\nWait, but maybe it's better to pair the left_non_q with right_q first, then the right_non_q with left_q.\n\nBut what if pairing in one direction uses up some of the '?'s, which could have been used in the other direction?\n\nBut perhaps the order doesn't matter. Because the total number of pairs here is the sum of the min(len(left_non_q), len(right_q)) + min(len(right_non_q), len(left_q)), but after that, the remaining '?'s can be paired.\n\nBut perhaps this is not the case. Let me think of an example.\n\nSuppose there are 2 left_non_q (color 'a') and 3 right_q. Pairing them would use 2 right_q. Then, there is 1 right_q left. Now, suppose there are 0 right_non_q and 1 left_q. Then, the remaining right_q can be paired with left_q.\n\nBut if we first pair right_non_q with left_q, but there are none, then proceed to pair left_non_q with right_q.\n\nIn any case, the order of processing may affect the number of pairs, but perhaps not. Because the total number of pairs that can be made here is (number of left_non_q + number of right_non_q) + (number of left_q + number of right_q) - ... ?\n\nNo, perhaps not. Let me think of an example where the order affects the outcome.\n\nSuppose:\n\nleft_non_q has 1 element (color 'a').\n\nright_non_q has 1 element (color 'b').\n\nleft_q has 1 element.\n\nright_q has 1 element.\n\nIf we pair left_non_q with right_q (1 pair), and right_non_q with left_q (another pair), total 2 pairs.\n\nAlternatively, if we pair left_non_q with right_non_q (which is not possible because their colors are different), so no. So the order here doesn't affect the result.\n\nBut in this case, the first approach works.\n\nAnother example: left_non_q has 1 element (color 'a'), right_q has 1 element. right_non_q has 1 element (color 'b'), left_q has 1 element.\n\nPairing left_non_q with right_q (1 pair), and right_non_q with left_q (another pair): total 2.\n\nAlternatively, if we first pair right_non_q with left_q (1 pair), then left_non_q with right_q (another pair): same result.\n\nSo the order doesn't matter here.\n\nSo perhaps the approach is:\n\nPair left_non_q with right_q as much as possible.\n\nThen pair right_non_q with left_q as much as possible.\n\nThen, pair the remaining left_q and right_q.\n\nBut how?\n\nSo, let's code this step.\n\nFirst, collect left_non_q and right_non_q.\n\nThen, for each left in left_non_q, pair with a right_q (if available).\n\nSimilarly, for each right in right_non_q, pair with a left_q (if available).\n\nThen, for the remaining left_q and right_q, pair them as much as possible.\n\nBut how to implement this?\n\nLet me think of code steps.\n\nAfter step 1:\n\nWe have left_used and right_used.\n\nCollect left_non_q = [i for i in range(n) if not left_used[i] and l[i] != '?'].\n\nCollect right_non_q = [i for i in range(n) if not right_used[i] and r[i] != '?'].\n\nCollect left_q = [i for i in range(n) if not left_used[i] and l[i] == '?'].\n\nCollect right_q = [i for i in range(n) if not right_used[i] and r[i] == '?'].\n\nThen, for the first part:\n\nWe can iterate over left_non_q and pair with right_q.\n\nFor example, for i in range(len(left_non_q)):\n\n   if there are any elements in right_q, take the first one, pair them, and mark them as used.\n\nSimilarly for the right_non_q and left_q.\n\nBut how to track which ones are used. Because the left_q and right_q lists are built before this step, and during this step, the elements are being marked as used.\n\nWait, but the left_q and right_q lists are built from the not-used elements. So during this step, when we pair a left_non_q with a right_q, we need to mark both as used. But since the right_q list is built from not-used elements, we can process them in order.\n\nSo, for example:\n\nTake the left_non_q list and the right_q list.\n\nWe can pair the first m elements, where m is the minimum of len(left_non_q) and len(right_q).\n\nSo:\n\nm = min(len(left_non_q), len(right_q))\n\nfor i in range(m):\n\n   pair left_non_q[i] with right_q[i]\n\nmark both as used.\n\nThen, for the right_non_q and left_q:\n\nm = min(len(right_non_q), len(left_q))\n\nfor i in range(m):\n\n   pair right_non_q[i] with left_q[i]\n\nmark both as used.\n\nThen, the remaining left_q and right_q can be paired between themselves. The number of pairs is min(len(left_q), len(right_q)).\n\nBut how to pair them? For example, take the first k elements of left_q and first k elements of right_q, where k is the minimum.\n\nSo, the total number of pairs is:\n\npairs from step 1 (exact matches) +\n\npairs from left_non_q and right_q +\n\npairs from right_non_q and left_q +\n\npairs from left_q and right_q.\n\nSo, the code steps would be:\n\nCollect all the pairs in step 1, then in step 2, step 3, step 4.\n\nNow, the problem is how to collect all these pairs, and track which boots are used.\n\nBut how to implement this efficiently, given that n can be up to 150,000?\n\nThe approach of building lists for left_non_q, etc., would be O(n) time, which is acceptable.\n\nNow, the problem is to generate the actual pairs.\n\nSo, the steps:\n\nInitialize left_used and right_used as arrays of False.\n\nCollect the exact matches.\n\nFor each color in a-z:\n\n   collect left indices where l[i] == color and not used.\n\n   collect right indices where r[i] == color and not used.\n\n   pair them as min(len(left), len(right)).\n\n   for each pair, add to the result list, and mark as used.\n\nThen, collect the left_non_q, right_non_q, left_q, right_q.\n\nThen, pair left_non_q with right_q as much as possible.\n\nThen, pair right_non_q with left_q as much as possible.\n\nThen, pair left_q with right_q as much as possible.\n\nBut how to collect the pairs?\n\nLet me think of code structure.\n\nIn Python:\n\nn = int(input())\n\nl = input().strip()\n\nr = input().strip()\n\nBut wait, the input is multiple test cases? Wait, looking back at the problem statement, the sample input seems to have multiple test cases. Wait, the original problem says that the input is given as per the problem. Wait, the sample input shows something like:\n\nInput:\n\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\nBut that's probably not the actual input format. Wait, the problem says:\n\nInput:\n\nThe first line contains n.\n\nSecond line contains l.\n\nThird line contains r.\n\nBut the sample input shows multiple test cases. Wait, perhaps the sample input is given as a list of test cases, but the actual problem expects to read a single test case per run. Wait, looking back:\n\nThe original problem says:\n\nInput:\n\nThe first line contains n.\n\nSecond line contains l.\n\nThird line contains r.\n\nBut the sample input shows multiple test cases, but that's probably a mistake in the formatting. For example, the sample output shows multiple outputs, which suggests that the problem may have multiple test cases. However, the problem says \"the following is a competitive programming problem\" and the input is given as per the standard input. So perhaps the user made a mistake in the sample input formatting.\n\nBut according to the problem statement, the input is:\n\nThe first line contains n.\n\nSecond line contains l.\n\nThird line contains r.\n\nSo, for each test case, we read n, l, r.\n\nBut the sample input shows four test cases. But perhaps that's a mistake in the problem statement. However, the user's note says that this is an easy question, and the sample input is given as a list of inputs, but the actual code is supposed to read from stdin.\n\nBut perhaps the user made a mistake in the sample input. Let me recheck.\n\nThe problem says:\n\nSample Input:\n\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\nSample Output:\n\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nBut this seems like the sample input is four separate test cases. However, the problem statement's input description says that the input is for one test case. So perhaps the sample input is written incorrectly, and the actual code should process a single test case.\n\nBut the problem says that the code should read from stdin. So, the code should read n, then l, then r. So, the code should read three lines: first line n, second line l, third line r.\n\nSo, the code needs to process one test case.\n\nBut the sample input shows multiple test cases, perhaps the user made a mistake. But regardless, the code should process a single test case.\n\nAssuming that, proceeding.\n\nNow, the code structure:\n\nRead n, l, r.\n\nInitialize left_used and right_used as lists of False.\n\nCollect the pairs from exact matches.\n\nThen, process the remaining.\n\nNow, for the exact matches:\n\nWe can loop through each color from 'a' to 'z'.\n\nFor each color c:\n\n   collect all left indices where l[i] == c and not used.\n\n   collect all right indices where r[i] == c and not used.\n\n   pair them as min(len(left_list), len(right_list)).\n\nBut how to collect these lists.\n\nBut for efficiency, perhaps we can pre-process for each color, the list of indices.\n\nBut for n up to 1.5e5, and 26 letters, this is manageable.\n\nBut in code, perhaps for each color in 'a' to 'z':\n\n   left_list = [i for i in range(n) if l[i] == c and not left_used[i]]\n\n   right_list = [i for i in range(n) if r[i] == c and not right_used[i]]\n\n   min_len = min(len(left_list), len(right_list))\n\n   for j in range(min_len):\n\n       add (left_list[j], right_list[j]) to the result.\n\n       mark left_used[left_list[j]] = True\n\n       mark right_used[right_list[j]] = True\n\nBut this approach would be O(26 * n) time, which for 1.5e5 is acceptable.\n\nBut building the lists for each color each time would be O(n) per color, leading to O(26n) time.\n\nBut perhaps there's a better way. However, for Python, even with 1.5e5 * 26, that's 3.9e6 operations, which is acceptable.\n\nOnce that's done, we collect the left_non_q, right_non_q, left_q, right_q.\n\nBut how to collect them:\n\nleft_non_q = [i for i in range(n) if not left_used[i] and l[i] != '?']\n\nright_non_q = [i for i in range(n) if not right_used[i] and r[i] != '?']\n\nleft_q = [i for i in range(n) if not left_used[i] and l[i] == '?']\n\nright_q = [i for i in range(n) if not right_used[i] and r[i] == '?']\n\nThen, process the left_non_q and right_q:\n\nTake the first min(len(left_non_q), len(right_q)) pairs.\n\nFor i in range(min(len(left_non_q), len(right_q))):\n\n   pair left_non_q[i] with right_q[i]\n\n   mark them as used.\n\nThen, process the right_non_q and left_q:\n\nTake the first min(len(right_non_q), len(left_q)) pairs.\n\nSimilarly.\n\nThen, for the remaining left_q and right_q, pair them as much as possible.\n\nBut how to pair them? For example, for the remaining left_q and right_q, pair them in any way.\n\nSo, for i in range(min(len(left_q), len(right_q))):\n\n   pair left_q[i] with right_q[i]\n\n   mark as used.\n\nBut how to collect all these pairs.\n\nOnce all these steps are done, collect all the pairs and output them.\n\nNow, the problem is to implement this in code, making sure that the indices are correctly stored and the used flags are updated.\n\nNow, code steps:\n\nRead n, l, r.\n\nInitialize left_used = [False]*n\n\nright_used = [False]*n\n\nresult_pairs = []\n\nThen, process exact matches:\n\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n\n   left_list = []\n\n   for i in range(n):\n\n       if not left_used[i] and l[i] == c:\n\n           left_list.append(i)\n\n   right_list = []\n\n   for i in range(n):\n\n       if not right_used[i] and r[i] == c:\n\n           right_list.append(i)\n\n   min_len = min(len(left_list), len(right_list))\n\n   for j in range(min_len):\n\n       result_pairs.append( (left_list[j]+1, right_list[j]+1) )\n\n       left_used[left_list[j]] = True\n\n       right_used[right_list[j]] = True\n\nWait, but this is O(26n) time, which for n=1.5e5 is 3.9e6 operations. Should be okay.\n\nBut in Python, for loops over 1.5e5 elements can be slow. But perhaps for the problem constraints, this is acceptable.\n\nAlternatively, perhaps we can precompute for each color, the list of indices once, and then process them.\n\nBut for code clarity, proceed with the above approach.\n\nOnce that is done, collect the left_non_q, right_non_q, left_q, right_q.\n\nleft_non_q = [i for i in range(n) if not left_used[i] and l[i] != '?']\n\nright_non_q = [i for i in range(n) if not right_used[i] and r[i] != '?']\n\nleft_q = [i for i in range(n) if not left_used[i] and l[i] == '?']\n\nright_q = [i for i in range(n) if not right_used[i] and r[i] == '?']\n\nThen, pair left_non_q with right_q:\n\nm = min(len(left_non_q), len(right_q))\n\nfor i in range(m):\n\n   l_idx = left_non_q[i]\n\n   r_idx = right_q[i]\n\n   result_pairs.append( (l_idx+1, r_idx+1) )\n\n   left_used[l_idx] = True\n\n   right_used[r_idx] = True\n\nThen, pair right_non_q with left_q:\n\nm = min(len(right_non_q), len(left_q))\n\nfor i in range(m):\n\n   r_idx = right_non_q[i]\n\n   l_idx = left_q[i]\n\n   result_pairs.append( (l_idx+1, r_idx+1) )\n\n   left_used[l_idx] = True\n\n   right_used[r_idx] = True\n\nThen, pair the remaining left_q and right_q:\n\nm = min(len(left_q), len(right_q))\n\nfor i in range(m):\n\n   l_idx = left_q[i]\n\n   r_idx = right_q[i]\n\n   result_pairs.append( (l_idx+1, r_idx+1) )\n\n   left_used[l_idx] = True\n\n   right_used[r_idx] = True\n\nWait, but after the previous steps, the left_q and right_q lists may have been modified. Because when we pair left_non_q with right_q, we are modifying the right_q entries. But in the code above, the left_q and right_q are lists built before these steps. So, the code is incorrect here.\n\nBecause, for example, after pairing left_non_q with right_q, the right_q list is not updated. So, the code as written would pair the first m elements of left_non_q with the first m elements of right_q. But after that, the right_q list still contains all the elements, but some of them are already used.\n\nBut the code for the left_q and right_q lists was built before any of these steps. Therefore, the code is wrong here.\n\nAh, right! Because the left_q and right_q lists are built once, before any pairing. So, when we pair elements from them, we need to track which elements are used. However, the code as written is not doing that. Because, for example, when we pair left_non_q with right_q, the code uses the first m elements of the right_q list, but after that, the remaining elements in the right_q list are still present, but some of them are already used.\n\nBut the code for the left_q and right_q lists was built before the pairing steps. So, when we pair elements from them, we need to mark them as used, and then when processing the rest, we need to avoid using them again.\n\nBut in the code as written, the left_q and right_q lists are built once, and then during the pairing steps, we are modifying the left_used and right_used arrays. However, when we process the left_q and right_q lists in the next steps, we have to make sure that the elements in the list are not already used. But since the lists were built before any of these steps, they include elements that may have been used in previous steps.\n\nWait, no. Because the left_non_q and right_q lists are built from elements that are not used. Then, when we pair them, we mark them as used. So, the left_q and right_q lists are built from elements that are not used. So, when we process left_non_q and right_q, the elements in the left_non_q and right_q lists are not used. After pairing them, they are marked as used. So, when we process the next steps (pairing right_non_q with left_q), the left_q list is built from elements that are not used. But when we process the left_q list, the elements in it are not used. However, during the pairing of left_non_q and right_q, some elements of right_q may have been used, but the left_q list is separate.\n\nBut the code for the left_q and right_q lists are built before any of the pairing steps. So, for example, during the pairing of left_non_q with right_q, the code pairs elements from the right_q list, but after that, those elements are marked as used. However, the left_q list is built from elements not used, and during the next steps, when we pair right_non_q with left_q, we take elements from the left_q list (which are not used), and pair them with elements from the right_non_q list (also not used). But after that, those elements are marked as used.\n\nBut when we process the left_q and right_q lists again (for the final pairing), the code would have elements that are already used. So, the code is incorrect here.\n\nAh, the problem is that the left_q and right_q lists are built once, and during the pairing steps, the code uses them as if they are all available, but in reality, some elements may have been used in previous steps.\n\nFor example, the code builds the left_q list as all indices where l[i] is '?' and not used. Then, during the pairing of left_non_q with right_q, some elements of the right_q list are marked as used. But the left_q list is not modified. So, when we process the right_non_q and left_q steps, the left_q list includes elements that are not used. However, during the pairing of left_non_q with right_q, some elements of the right_q list are used. But the code for the right_non_q and left_q steps would not account for that.\n\nWait, but the left_q and right_q lists are built once. Then, during the pairing steps, the code uses the elements from the lists, and marks them as used. So, for example, the code for pairing left_non_q with right_q:\n\nfor i in range(m):\n\n   l_idx = left_non_q[i]\n\n   r_idx = right_q[i]\n\n   result_pairs.append(...)\n\n   mark them as used.\n\nBut the left_non_q and right_q lists are built before this step. So, the right_q[i] is an index that was not used before. But after marking it as used, it's not used anymore.\n\nBut when we later process the left_q and right_q lists, they are built once. However, when we process the left_q and right_q lists again, the elements in them are not used (since they were built before any of the pairing steps). So, for example, the code for pairing left_non_q with right_q uses some elements from right_q, but the left_q list is built from elements not used. So, when we process the right_non_q and left_q steps, the left_q list is still valid (all elements are not used).\n\nBut when we process the right_non_q and left_q steps, the code takes elements from the right_non_q list (which are not used) and left_q list (also not used). So, after pairing, those elements are marked as used.\n\nFinally, for the last step, the code takes the left_q and right_q lists (built before any of the steps), but during the previous steps, some elements may have been used. However, the code for the final step uses the entire left_q and right_q lists again, which may contain elements that have been used in previous steps.\n\nWait, no. Because the left_q list is built from elements that are not used. So, during the pairing of left_non_q with right_q, the code uses elements from right_q (which are not used), and marks them as used. However, the left_q list is built from elements that are not used. So, during the pairing of right_non_q and left_q steps, the code uses elements from left_q (not used) and right_non_q (not used). Then, those elements are marked as used.\n\nAt the final step, the code takes the left_q and right_q lists, which were built before any of the steps. However, during the previous steps, some elements from left_q and right_q may have been used. So, when we process them again, we have to check whether they are used or not. But the code as written assumes that all elements in the left_q and right_q lists are not used, which is not the case.\n\nThus, the code as written would have errors here.\n\nThis is a critical problem.\n\nHow to fix this?\n\nAlternative approach: After the exact matches, collect all the left and right boots that are not used, and then process them in a way that tracks which are used.\n\nBut how?\n\nPerhaps, after the exact matches, we can collect all the left and right boots that are not used, and for each, track their color.\n\nBut then, for the remaining steps, we need to process them in a way that ensures that each boot is used at most once.\n\nAlternative approach:\n\nInstead of building lists of indices for left_non_q, etc., and then processing them, perhaps we can use queues or pointers.\n\nBut how?\n\nLet me think again.\n\nOnce the exact matches are done, we have:\n\nleft_used and right_used arrays.\n\nWe need to process the remaining boots.\n\nLet me think of the following steps:\n\nProcess all left boots that are not used and have color not '?', trying to pair them with right '?'.\n\nSimilarly for right boots not used and color not '?', trying to pair with left '?'.\n\nThen, pair the remaining '?'s.\n\nBut how to implement this without building lists.\n\nFor example:\n\nFor each left boot not used:\n\n   if it's not '?', then try to find a right '?' not used and pair them.\n\nBut this would be O(n^2) time in worst case.\n\nWhich is not acceptable for n=1.5e5.\n\nAlternative idea: collect all the left_non_q and right_q, and pair them.\n\nBut how to collect them.\n\nLet me think again.\n\nAfter step 1, the left_used and right_used are set.\n\nWe can collect all the left_non_q as a list, and all the right_q as a list.\n\nThese lists contain indices that are not used.\n\nThen, pair them as follows:\n\nfor each index in left",
    "response": "\n\nTo solve this problem, we need to maximize the number of compatible pairs between left and right boots. Each boot can be either a specific color or an indefinite color represented by a question mark ('?'). The compatibility rules are such that specific colors must match exactly, while question marks can match any color.\n\n### Approach\n1. **Exact Matches**: First, we pair all left boots with specific colors that have corresponding right boots with the same color. This is done by iterating through each possible color (from 'a' to 'z') and matching available left and right boots of that color.\n2. **Indefinite Matches**: After handling exact matches, we handle the remaining boots. Specifically, we pair left boots with specific colors with right boots that are indefinite (question marks) and vice versa. This ensures that we use as many specific color boots as possible with indefinite ones.\n3. **Remaining Indefinite Matches**: Finally, we pair the remaining indefinite boots (question marks) from both left and right sides.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    l = input[idx]\n    idx += 1\n    r = input[idx]\n    idx += 1\n    \n    left_used = [False] * n\n    right_used = [False] * n\n    result = []\n    \n    # Step 1: Pair exact matches\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_list = []\n        for i in range(n):\n            if not left_used[i] and l[i] == c:\n                left_list.append(i)\n        right_list = []\n        for i in range(n):\n            if not right_used[i] and r[i] == c:\n                right_list.append(i)\n        min_len = min(len(left_list), len(right_list))\n        for j in range(min_len):\n            result.append((left_list[j] + 1, right_list[j] + 1))\n            left_used[left_list[j]] = True\n            right_used[right_list[j]] = True\n    \n    # Collect remaining non-question marks and question marks\n    left_non_q = []\n    right_non_q = []\n    left_q = []\n    right_q = []\n    for i in range(n):\n        if not left_used[i]:\n            if l[i] != '?':\n                left_non_q.append(i)\n            else:\n                left_q.append(i)\n    for i in range(n):\n        if not right_used[i]:\n            if r[i] != '?':\n                right_non_q.append(i)\n            else:\n                right_q.append(i)\n    \n    # Step 2: Pair left_non_q with right_q\n    m = min(len(left_non_q), len(right_q))\n    for i in range(m):\n        l_idx = left_non_q[i]\n        r_idx = right_q[i]\n        result.append((l_idx + 1, r_idx + 1))\n        left_used[l_idx] = True\n        right_used[r_idx] = True\n    \n    # Step 3: Pair right_non_q with left_q\n    m = min(len(right_non_q), len(left_q))\n    for i in range(m):\n        r_idx = right_non_q[i]\n        l_idx = left_q[i]\n        result.append((l_idx + 1, r_idx + 1))\n        left_used[l_idx] = True\n        right_used[r_idx] = True\n    \n    # Step 4: Pair remaining left_q with right_q\n    # Need to collect again because previous steps may have used some\n    new_left_q = []\n    new_right_q = []\n    for i in range(n):\n        if not left_used[i] and l[i] == '?':\n            new_left_q.append(i)\n    for i in range(n):\n        if not right_used[i] and r[i] == '?':\n            new_right_q.append(i)\n    m = min(len(new_left_q), len(new_right_q))\n    for i in range(m):\n        l_idx = new_left_q[i]\n        r_idx = new_right_q[i]\n        result.append((l_idx + 1, r_idx + 1))\n        left_used[l_idx] = True\n        right_used[r_idx] = True\n    \n    print(len(result))\n    for pair in result:\n        print(pair[0], pair[1])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of boots `n`, and the strings representing the colors of left and right boots.\n2. **Exact Matches**: For each color from 'a' to 'z', we collect indices of unused left and right boots and pair them if they match.\n3. **Handling Indefinite Colors**: After exact matches, we handle remaining specific color boots by pairing them with indefinite color boots. This is done by collecting indices of unused specific color boots and indefinite color boots, then pairing them.\n4. **Final Pairing**: Finally, we pair any remaining indefinite color boots from both left and right sides.\n\nThis approach ensures that we maximize the number of compatible pairs efficiently, adhering to the constraints and compatibility rules.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    l = input[idx]\n    idx += 1\n    r = input[idx]\n    idx += 1\n    \n    left_used = [False] * n\n    right_used = [False] * n\n    result = []\n    \n    # Step 1: Pair exact matches\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_list = []\n        for i in range(n):\n            if not left_used[i] and l[i] == c:\n                left_list.append(i)\n        right_list = []\n        for i in range(n):\n            if not right_used[i] and r[i] == c:\n                right_list.append(i)\n        min_len = min(len(left_list), len(right_list))\n        for j in range(min_len):\n            result.append((left_list[j] + 1, right_list[j] + 1))\n            left_used[left_list[j]] = True\n            right_used[right_list[j]] = True\n    \n    # Collect remaining non-question marks and question marks\n    left_non_q = []\n    right_non_q = []\n    left_q = []\n    right_q = []\n    for i in range(n):\n        if not left_used[i]:\n            if l[i] != '?':\n                left_non_q.append(i)\n            else:\n                left_q.append(i)\n    for i in range(n):\n        if not right_used[i]:\n            if r[i] != '?':\n                right_non_q.append(i)\n            else:\n                right_q.append(i)\n    \n    # Step 2: Pair left_non_q with right_q\n    m = min(len(left_non_q), len(right_q))\n    for i in range(m):\n        l_idx = left_non_q[i]\n        r_idx = right_q[i]\n        result.append((l_idx + 1, r_idx + 1))\n        left_used[l_idx] = True\n        right_used[r_idx] = True\n    \n    # Step 3: Pair right_non_q with left_q\n    m = min(len(right_non_q), len(left_q))\n    for i in range(m):\n        r_idx = right_non_q[i]\n        l_idx = left_q[i]\n        result.append((l_idx + 1, r_idx + 1))\n        left_used[l_idx] = True\n        right_used[r_idx] = True\n    \n    # Step 4: Pair remaining left_q with right_q\n    # Need to collect again because previous steps may have used some\n    new_left_q = []\n    new_right_q = []\n    for i in range(n):\n        if not left_used[i] and l[i] == '?':\n            new_left_q.append(i)\n    for i in range(n):\n        if not right_used[i] and r[i] == '?':\n            new_right_q.append(i)\n    m = min(len(new_left_q), len(new_right_q))\n    for i in range(m):\n        l_idx = new_left_q[i]\n        r_idx = new_right_q[i]\n        result.append((l_idx + 1, r_idx + 1))\n        left_used[l_idx] = True\n        right_used[r_idx] = True\n    \n    print(len(result))\n    for pair in result:\n        print(pair[0], pair[1])\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 1083,
        "thoughts_token_count": 8191
    }
}