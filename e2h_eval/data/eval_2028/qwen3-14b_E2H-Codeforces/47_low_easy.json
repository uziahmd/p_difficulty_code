{
    "start": 1758309454.2005138,
    "end": 1758309646.6419806,
    "start-formatted": "2025-09-20 04:17 KST",
    "end-formatted": "2025-09-20 04:20 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is as small as possible. And if there are multiple k's with the same minimal LCM, pick the smallest k.\n\nHmm. Let me think about how to approach this. The LCM of two numbers x and y is (x*y)/gcd(x,y). So, for x = a +k and y = b +k. Since adding k to both, maybe I can express this in terms of their difference.\n\nLet me consider that the difference between the two numbers is (b +k) - (a +k) = b - a. Let's assume that a and b are such that a < b. Wait, but maybe I should first make sure that a and b are ordered. Like, without loss of generality, let me assume that a ≤ b. Because if a is larger than b, swapping them would not change the problem. Because the LCM of (a +k) and (b +k) is same as the LCM of (b +k) and (a +k). So maybe I can first swap a and b so that a ≤ b. That might help.\n\nSo let me first set a and b such that a ≤ b. Then, the two numbers after adding k are x = a +k and y = b +k. The difference between them is (b - a), which is fixed. Let's denote d = b - a. So y = x + d.\n\nSo the problem becomes: find x ≥ a (since k ≥ 0 implies x = a +k ≥ a) such that LCM(x, x +d) is minimized. And then find the minimal x (since k is x -a, so the minimal x gives the minimal k).\n\nBut how to find x that minimizes LCM(x, x +d). Let's think about LCM(x, x +d). Since x and x +d have a difference of d, their GCD must divide d. Let me think. Let's denote g = gcd(x, x +d) = gcd(x, d). Because gcd(x, x +d) = gcd(x, d). So the LCM is (x*(x +d))/g. Which equals (x*(x +d))/gcd(x, d).\n\nSo to minimize this, perhaps we need to maximize the gcd(x, d). Because the larger the gcd, the smaller the LCM. So for a fixed d, the LCM is minimized when the gcd(x, d) is as large as possible.\n\nSo the idea is: for d = b -a, find x ≥ a such that x is as small as possible, and gcd(x, d) is as large as possible. Because that would minimize the LCM.\n\nBut how to find such x?\n\nLet me think. Let's take d as fixed. Let me think of possible values of g that divide d. For each possible divisor g of d, we can try to find x such that x is a multiple of g, and x is as small as possible. Because then, the LCM would be (x*(x +d))/g. But since x is a multiple of g, let's say x = g * m. Then x +d = g*m +d. But since g divides d, let me write d = g * k. So x +d = g*m + g*k = g*(m +k). Therefore, the LCM is (g*m * g*(m +k)) / g = g*m*(m +k) = g*m*(m + (d/g)).\n\nWait, but since d = g * k, then k = d/g. So the LCM becomes g * m (m + d/g). Now, since m can be any positive integer (as long as x = g*m >= a). But to minimize the LCM, we need to find the minimal possible value of m*(m + d/g). Because g is fixed here.\n\nBut for each possible divisor g of d, we can compute the minimal m such that x = g*m >= a, and then compute the corresponding LCM. Then compare across all possible divisors g of d.\n\nSo the plan is:\n\n- Compute d = b -a. If d is zero, then a = b. Then, the LCM of a +k and a +k is a +k. So the minimal is achieved when k=0, so output 0.\n\nBut if d is not zero, then proceed.\n\nSo for d = b -a, find all possible divisors of d. For each divisor g of d, we can try to find x = g*m, where m is a positive integer, such that x >= a. Then, the LCM would be g * m * (m + (d/g)). We need",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The approach involves leveraging the properties of divisors and greatest common divisors (GCD) to efficiently determine the optimal $ k $.\n\n### Approach\n1. **Problem Analysis**: The LCM of two numbers $ x $ and $ y $ can be expressed as $ \\text{LCM}(x, y) = \\frac{x \\cdot y}{\\text{GCD}(x, y)} $. For $ x = a + k $ and $ y = b + k $, the difference between them is fixed as $ d = b - a $. This allows us to express $ y $ as $ x + d $.\n\n2. **Key Insight**: The LCM of $ x $ and $ x + d $ is minimized when the GCD of $ x $ and $ d $ is maximized. This leads us to consider all divisors of $ d $ and find the optimal $ x $ for each divisor.\n\n3. **Algorithm**:\n   - If $ a $ and $ b $ are equal, the optimal $ k $ is 0.\n   - Otherwise, compute $ d = b - a $ and find all divisors of $ d $.\n   - For each divisor $ g $ of $ d $, determine the smallest $ x $ such that $ x $ is a multiple of $ g $ and $ x \\geq a $. Compute the corresponding $ k $ and check if it minimizes the LCM.\n\n### Solution Code\n```python\nimport math\n\ndef compute_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = b - a\n    divisors = compute_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    \n    for g in divisors:\n        # We need x = g * m >= a\n        # m must be at least ceil(a / g)\n        m = (a + g - 1) // g\n        x = g * m\n        y = x + d\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        k = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    return best_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Divisors Calculation**: The function `compute_divisors` calculates all divisors of a number $ d $, which helps in checking potential values for maximizing the GCD.\n- **Optimal $ k $ Calculation**: For each divisor $ g $ of $ d $, the smallest $ x $ that is a multiple of $ g $ and greater than or equal to $ a $ is determined. This $ x $ is used to compute the corresponding $ k $ and the LCM of the resulting values.\n- **Efficiency**: By focusing on divisors of $ d $, the solution efficiently narrows down potential candidates for $ k $, ensuring minimal computation even for large values of $ a $ and $ b $.\n\nThis approach ensures that we find the smallest $ k $ that minimizes the LCM efficiently by leveraging mathematical properties of divisors and GCD.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef compute_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = b - a\n    divisors = compute_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    \n    for g in divisors:\n        # We need x = g * m >= a\n        # m must be at least ceil(a / g)\n        m = (a + g - 1) // g\n        x = g * m\n        y = x + d\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        k = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    return best_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 842,
        "thoughts_token_count": 1024
    }
}