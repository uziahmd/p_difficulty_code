{
    "start": 1758313545.481667,
    "end": 1758313593.2124128,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the task is to find two vouchers that don't overlap, their durations add up exactly to x, and their total cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a duration of ri - li + 1. We need two vouchers i and j such that:\n\n- The duration of i plus duration of j equals x.\n- They don't overlap. Which means either ri < lj or rj < li.\n- Find the minimal sum of their costs.\n\nConstraints are n up to 2e5, which suggests that O(n^2) approaches are out of the question. So we need an efficient way.\n\nLet me think about possible approaches.\n\nFor each voucher, we can check if there exists another voucher that has duration (x - current duration) and doesn't overlap with it. But how do we efficiently find those?\n\nFirst, let's precompute for each voucher, what is its duration. Then, for each voucher, we can look for vouchers with duration d = x - duration_i. Then, among those vouchers, find one that doesn't overlap with the current voucher and has the minimal cost.\n\nBut how to efficiently find the minimal cost for vouchers of duration d that are non-overlapping with the current voucher?\n\nLet me think. For each possible duration d, we can pre-process the vouchers. For example, group vouchers by their duration. Then, for a given voucher with duration d1, we need to find vouchers with duration d2 = x - d1, and check if they are non-overlapping.\n\nBut even that, for each voucher, checking all vouchers of duration d2 would be O(n) in the worst case. Which would be O(n^2) again.\n\nHmm. So we need a way to quickly find the minimum cost voucher of duration d2 that ends before the current voucher starts, or starts after the current voucher ends.\n\nWait, here's an idea: For each duration d, we can have two sorted lists:\n\n- One sorted by the end time (ri), and for each end time, track the minimum cost up to that point. So that for a given start time, we can find all vouchers of duration d that end before a certain time, and get the minimum cost.\n\nSimilarly, another sorted list sorted by start time (li), and track the minimum cost from that point onwards. Wait, maybe not. Let's think.\n\nSuppose we have a voucher A with duration d1, and we need to find vouchers of duration d2 = x - d1. For these vouchers, they must not overlap with A. So, either their end time is less than A's start time (so they end before A starts), or their start time is greater than A's end time (so they start after A ends).\n\nSo for each voucher A, we need to find the minimum cost voucher of duration d2 that ends before A's start time (li_A?), or starts after A's end time (ri_A?).\n\nSo, for each duration d, we can pre-process two structures:\n\n- A sorted list of vouchers' end times, along with their costs. Then, for a given start time s, we can find all vouchers of duration d that end before s, and find the minimum cost among them.\n\nSimilarly, a sorted list of vouchers' start times, along with their costs. For a given end time e, find all vouchers of duration d that start after e, and find the minimum cost among them.\n\nBut how do we do that efficiently?\n\nFor the first part, for vouchers of duration d, sorted by end time. For each voucher A, when looking for vouchers ending before A's start time (say, s), we can perform a binary search on the sorted list of end times to find the largest end time that is less than s. Then, we need the minimum cost among all vouchers up to that point. To do this, we can pre-process for each duration d, a list of end times sorted, and a corresponding prefix minimum array.\n\nSimilarly, for the second part, vouchers of duration d sorted by their start time. For a given end time e, we want to find vouchers with start time > e. So, we can binary search for the first start time greater than e, and then take the minimum cost in the suffix starting from that index.\n\nSo the plan is:\n\n- Preprocess for each duration d, two structures:\n   1. A sorted list of end times (ri) of vouchers with duration d. Along with a prefix minimum cost array. This allows us to find the minimum cost of vouchers with duration d that end before a certain time.\n   2. A sorted list of start times (li) of vouchers with duration d. Along with a suffix minimum cost array. This allows us to find the minimum cost of vouchers with duration d that start after a certain time.\n\nThen",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration exactly matches a given value `x` and their total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. For each duration, maintain two sorted lists:\n   - One sorted by the end time (`ri`) of vouchers.\n   - Another sorted by the start time (`li`) of vouchers.\n\n2. **Prefix and Suffix Minimum Arrays**: For each duration group, create prefix minimum arrays for the sorted end times and suffix minimum arrays for the sorted start times. These arrays help quickly determine the minimum cost of vouchers that end before a certain time or start after a certain time.\n\n3. **Check for Valid Pairs**: For each voucher, calculate the required complementary duration (`x - duration`). Use the preprocessed data to check if there are valid vouchers with this complementary duration that do not overlap with the current voucher. This involves checking both possible non-overlapping conditions (one voucher ends before the other starts, and vice versa).\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Preprocess: group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, prepare sorted end times with prefix min cost\n    # and sorted start times with suffix min cost\n    duration_data = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time (r)\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        end_times = [x[1] for x in sorted_by_end]\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time (l)\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        start_times = [x[0] for x in sorted_by_start]\n        suffix_min = [0]*len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        duration_data[d] = (sorted_by_end, end_times, prefix_min, sorted_by_start, start_times, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n        \n        # Check for vouchers with target_d that end before l\n        sorted_by_end, end_times, prefix_min = duration_data[target_d][0], duration_data[target_d][1], duration_data[target_d][2]\n        # Find the largest end time <= l-1\n        pos = bisect.bisect_right(end_times, l-1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, current_min + cost)\n        \n        # Check for vouchers with target_d that start after r\n        sorted_by_start, start_times, suffix_min = duration_data[target_d][3], duration_data[target_d][4], duration_data[target_d][5]\n        pos = bisect.bisect_right(start_times, r)\n        if pos < len(start_times):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Preprocessing**: Vouchers are grouped by their duration. For each duration, we sort vouchers by their end times and start times, and compute prefix/suffix minimum cost arrays to quickly find the minimum cost of valid non-overlapping vouchers.\n- **Binary Search**: For each voucher, we use binary search to efficiently find valid vouchers of the required complementary duration that either end before the current voucher starts or start after the current voucher ends.\n- **Efficiency**: The approach ensures that we efficiently check all possible pairs using preprocessed data, leading to an overall time complexity of O(n log n), which is suitable for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Preprocess: group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, prepare sorted end times with prefix min cost\n    # and sorted start times with suffix min cost\n    duration_data = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time (r)\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        end_times = [x[1] for x in sorted_by_end]\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time (l)\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        start_times = [x[0] for x in sorted_by_start]\n        suffix_min = [0]*len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        duration_data[d] = (sorted_by_end, end_times, prefix_min, sorted_by_start, start_times, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n        \n        # Check for vouchers with target_d that end before l\n        sorted_by_end, end_times, prefix_min = duration_data[target_d][0], duration_data[target_d][1], duration_data[target_d][2]\n        # Find the largest end time <= l-1\n        pos = bisect.bisect_right(end_times, l-1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, current_min + cost)\n        \n        # Check for vouchers with target_d that start after r\n        sorted_by_start, start_times, suffix_min = duration_data[target_d][3], duration_data[target_d][4], duration_data[target_d][5]\n        pos = bisect.bisect_right(start_times, r)\n        if pos < len(start_times):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 732,
        "completion_token_count": 1078,
        "thoughts_token_count": 1024
    }
}