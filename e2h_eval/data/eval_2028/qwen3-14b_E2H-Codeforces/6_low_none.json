{
    "start": 1758008328.0462103,
    "end": 1758008507.5050461,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs of vouchers that satisfy these conditions and find the minimum sum of their costs.\n\nConstraints are n up to 2e5, which is big. So O(n^2) approaches will not work. We need an efficient way, probably O(n log n) or O(n) with some preprocessing.\n\nLet me think about how to approach this.\n\nFor each voucher, we can check if there exists another voucher that starts after this one ends, or ends before this one starts. But how do we efficiently find the other voucher with the required duration?\n\nLet me think about the durations. For each voucher, let's compute its duration d. Then, for a voucher with duration d, we need another voucher with duration x - d. So for each voucher, we can look for vouchers with duration (x - d), and check if they don't overlap.\n\nBut how do we find those vouchers quickly?\n\nMaybe we can group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, we look into the list of vouchers with duration (x - d), and check if any of them don't overlap with it.\n\nBut even then, for each voucher, checking all vouchers in the other duration group could be O(n) per voucher, leading to O(n^2) time in worst case. That's not feasible.\n\nWe need a way to find, for each voucher, the minimal cost voucher in the other duration group that doesn't overlap with it.\n\nSo perhaps for each duration, we can pre-process the vouchers in a way that allows us to query the minimal cost voucher that ends before a certain day, or starts after a certain day.\n\nFor example, suppose we have a voucher A with duration d, and we want to find a voucher B with duration (x - d) that ends before A's start day (so that B is before A). Or starts after A's end day (so that A is before B).\n\nSo for each voucher, we can consider two possibilities:\n\n1. Find a voucher B with duration (x - d) that ends before li (so that B ends before A starts). Then, the earliest possible B would be any such voucher, but we need the minimal cost.\n\n2. Find a voucher B with duration (x - d) that starts after ri (so that A ends before B starts). Again, find the minimal cost.\n\nIf we can find the minimal cost for each of these cases, then we can take the minimum between them for each voucher.\n\nSo the plan is:\n\n- Preprocess vouchers grouped by duration. For each duration, have a sorted list of vouchers sorted by their start time (or end time?), and also have some data structures that allow querying the minimal cost for vouchers ending before a certain day, or starting after a certain day.\n\nBut how to structure this?\n\nLet me think: For each duration k, let's collect all vouchers of that duration. For each such group, we can sort the vouchers by their end time. Then, for a given voucher A (with duration d), when looking for vouchers of duration (x-d) that end before A's start time (li), we can perform a binary search on the sorted end times of the (x-d) group. For all vouchers in that group with end time <= li-1, we can find the minimal cost among them.\n\nSimilarly, for vouchers that start after A's end time (ri), we can sort the vouchers in the (x-d) group by their start time, and find the minimal cost among those with start time >= ri+1.\n\nBut how to pre-process the vouchers for quick queries?\n\nFor each duration k, we can have two sorted lists:\n\n- Sorted by end time, and for each position, keep track of the minimum cost up to that point. This allows us to query the minimal cost for vouchers with end time <= some value.\n\n- Sorted by start time, and for each position, keep track of the minimum cost from that position onwards. This allows us to query the minimal cost for vouchers with start time >= some value.\n\nAlternatively, for each duration k, we can have two sorted lists:\n\n1. A list of vouchers sorted by their end time. Along with a prefix",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches the given vacation duration `x`, and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently finding pairs of vouchers that sum up to the required duration `x`.\n2. **Preprocessing for Efficient Queries**: For each duration, we maintain two sorted lists:\n   - One sorted by the end time of the vouchers, allowing us to quickly find the minimum cost of vouchers ending before a certain day.\n   - Another sorted by the start time of the vouchers, allowing us to quickly find the minimum cost of vouchers starting after a certain day.\n3. **Binary Search for Efficient Lookup**: Using binary search on the preprocessed lists, we can efficiently determine the minimum cost of valid vouchers that do not overlap with the current voucher.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers_by_duration = defaultdict(list)\n\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers_by_duration[duration].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration, we have:\n    # - sorted_end: list of (end_time, cost), sorted by end_time\n    #   and a prefix min array\n    # - sorted_start: list of (start_time, cost), sorted by start_time\n    #   and a suffix min array\n\n    duration_info = {}\n\n    for d in vouchers_by_duration:\n        lst = vouchers_by_duration[d]\n        # Prepare sorted_end\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Prepare sorted_start\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_start[i][2])\n            suffix_min[i] = min_so_far\n        duration_info[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n\n    min_total = float('inf')\n\n    for d in vouchers_by_duration:\n        target_d = x - d\n        if target_d not in duration_info:\n            continue\n        current_vouchers = vouchers_by_duration[d]\n        # For each voucher in current_vouchers, check if there's a voucher in target_d that doesn't overlap\n        for (l, r, cost) in current_vouchers:\n            # Check for vouchers in target_d that end before l\n            sorted_end_target, prefix_min_end, _, _ = duration_info[target_d]\n            # Find the largest end <= l-1\n            end_list = [item[1] for item in sorted_end_target]\n            pos = bisect.bisect_right(end_list, l-1)\n            if pos > 0:\n                min_cost = prefix_min_end[pos-1]\n                min_total = min(min_total, cost + min_cost)\n            # Check for vouchers in target_d that start after r\n            _, _, sorted_start_target, suffix_min_start = duration_info[target_d]\n            start_list = [item[0] for item in sorted_start_target]\n            pos = bisect.bisect_left(start_list, r+1)\n            if pos < len(start_list):\n                min_cost = suffix_min_start[pos]\n                min_total = min(min_total, cost + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: We first group all vouchers by their duration to efficiently look up potential pairs.\n2. **Preprocessing**: For each duration, we sort vouchers by their end and start times, and compute prefix and suffix minimum cost arrays to quickly answer range minimum queries.\n3. **Binary Search**: For each voucher, we use binary search to find valid non-overlapping vouchers in the target duration group, ensuring efficient lookup and minimal cost calculation.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n^2) solution, making it feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers_by_duration = defaultdict(list)\n\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers_by_duration[duration].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration, we have:\n    # - sorted_end: list of (end_time, cost), sorted by end_time\n    #   and a prefix min array\n    # - sorted_start: list of (start_time, cost), sorted by start_time\n    #   and a suffix min array\n\n    duration_info = {}\n\n    for d in vouchers_by_duration:\n        lst = vouchers_by_duration[d]\n        # Prepare sorted_end\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Prepare sorted_start\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_start[i][2])\n            suffix_min[i] = min_so_far\n        duration_info[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n\n    min_total = float('inf')\n\n    for d in vouchers_by_duration:\n        target_d = x - d\n        if target_d not in duration_info:\n            continue\n        current_vouchers = vouchers_by_duration[d]\n        # For each voucher in current_vouchers, check if there's a voucher in target_d that doesn't overlap\n        for (l, r, cost) in current_vouchers:\n            # Check for vouchers in target_d that end before l\n            sorted_end_target, prefix_min_end, _, _ = duration_info[target_d]\n            # Find the largest end <= l-1\n            end_list = [item[1] for item in sorted_end_target]\n            pos = bisect.bisect_right(end_list, l-1)\n            if pos > 0:\n                min_cost = prefix_min_end[pos-1]\n                min_total = min(min_total, cost + min_cost)\n            # Check for vouchers in target_d that start after r\n            _, _, sorted_start_target, suffix_min_start = duration_info[target_d]\n            start_list = [item[0] for item in sorted_start_target]\n            pos = bisect.bisect_left(start_list, r+1)\n            if pos < len(start_list):\n                min_cost = suffix_min_start[pos]\n                min_total = min(min_total, cost + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 731,
        "completion_token_count": 1045,
        "thoughts_token_count": 1023
    }
}