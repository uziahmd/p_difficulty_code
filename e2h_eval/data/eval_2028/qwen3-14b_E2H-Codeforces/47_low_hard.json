{
    "start": 1758309518.300941,
    "end": 1758309585.7065659,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:19 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about the problem. Let's denote x = a +k and y = b +k. Then, since k is non-negative, x and y are at least a and b respectively, but since k can be added, they can be larger. But wait, since a and b are given, maybe we can express the difference between x and y. Let's see: since x = a +k and y = b +k, then y -x = b -a. So the difference between the two numbers is fixed. Let me call d = |a - b|. Without loss of generality, let's assume that a ≤ b. So, if a is less than b, then b -a is positive, and y -x is positive. So, for example, in the first sample input, a=6, b=10. So the difference is 4. So when k is 2, x is 8, y is 12. Their difference is 4. The LCM of 8 and 12 is 24.\n\nBut how do I find the minimal LCM?\n\nThe LCM of two numbers x and y is (x*y)/gcd(x,y). Since x and y differ by a fixed value (d), maybe there's a way to find the optimal k based on this.\n\nLet me think: Let's say that a ≤ b. Then, the difference between y and x is d = b -a. So y = x + d. So the LCM of x and x +d. So the problem reduces to finding x such that x ≥ a (since x = a +k, and k ≥0) and x +d ≥ b (which is automatically true since x ≥a and d = b -a, so x +d ≥ a +d = a + (b -a) = b). So the problem becomes finding x ≥ a such that LCM(x, x+d) is minimized. Then, once x is found, k is x -a.\n\nSo the problem is now to find x ≥ a where x is such that LCM(x, x +d) is minimized. Then, k = x -a.\n\nBut how to find this x?\n\nLet me think about the LCM of x and x +d. Let me denote that as LCM(x, x +d) = x*(x +d)/gcd(x, x+d). But since gcd(x, x+d) = gcd(x, d). Because gcd(x, x +d) = gcd(x, d). So that simplifies things. Therefore, the LCM is x*(x +d)/g, where g is gcd(x, d).\n\nSo the problem is to minimize x*(x +d)/g, where g is gcd(x, d). But since d is fixed (as the difference between a and b), perhaps we can find x that minimizes this expression.\n\nBut how? Let's consider that d is fixed. Let's take d as the absolute difference between a and b. So first, compute d = abs(a -b). Then, let's assume that a ≤ b, so d = b -a. Then, we need to find x ≥ a such that the LCM of x and x +d is minimized.\n\nWait, but x can be any number ≥ a. However, since x +d = (a +k) +d = (a +k) + (b -a) = b +k. Which is correct.\n\nSo, the key is to find x ≥ a such that LCM(x, x +d) is as small as possible.\n\nNow, how to find this x?\n\nLet me think about possible candidates for x. Since the LCM is minimized when x and x +d have a large GCD. Because the LCM is (x*(x +d))/g, where g is their GCD. So if g is large, then the LCM is smaller.\n\nSo, for example, if x and x +d share a common divisor g, then that would help. But since x and x +d differ by d, their GCD is the same as GCD(x, d). So, the GCD of x and d.\n\nSo, the LCM is x*(x +d)/g, where g = GCD(x, d). So, to minimize this, perhaps we can find x such that GCD(x, d) is as large as possible, and x is as small as possible.\n\nBut how to find such x?\n\nAlternatively, perhaps we can find all possible divisors of d and find the optimal x.\n\nWait, here's an idea. Let",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The approach involves leveraging mathematical properties of LCM and greatest common divisor (GCD).\n\n### Approach\n1. **Understanding the Problem**: The LCM of two numbers $ x $ and $ y $ can be expressed as $ \\text{LCM}(x, y) = \\frac{x \\cdot y}{\\text{GCD}(x, y)} $. Given two integers $ a $ and $ b $, we need to find the smallest $ k $ such that the LCM of $ a + k $ and $ b + k $ is minimized.\n\n2. **Difference Insight**: Let $ d = |a - b| $. The difference between $ a + k $ and $ b + k $ remains constant as $ d $. This allows us to focus on minimizing the LCM of two numbers that differ by $ d $.\n\n3. **Divisors of Difference**: To minimize the LCM, we consider the divisors of $ d $. For each divisor $ g $ of $ d $, we check values of $ x $ such that $ x $ is a multiple of $ g $ and $ x \\geq \\min(a, b) $. This helps in finding the optimal $ k $ efficiently.\n\n4. **Optimal Check**: For each candidate divisor $ g $ of $ d $, compute the minimum $ k $ that aligns with the conditions and check the corresponding LCM values.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef compute_min_k(a, b):\n    d = abs(a - b)\n    min_k = 0\n    min_lcm = float('inf')\n    \n    # If a == b, then k=0 gives LCM(a, a) = a which is minimal\n    if d == 0:\n        return 0\n    \n    # We need to find x >= a (assuming a <= b) such that LCM(x, x + d) is minimal\n    # So, let's consider all possible divisors of d\n    # Generate all divisors of d\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(math.isqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    \n    divisors = get_divisors(d)\n    \n    # For each divisor g of d, find the minimal x such that x >= min(a, b) and x mod g == 0\n    # Then compute the corresponding k and LCM\n    for g in divisors:\n        # We want x such that x mod g == 0, and x >= a (assuming a <= b)\n        # Let's assume a <= b\n        if a > b:\n            a, b = b, a\n        # Now a <= b, d = b - a\n        # Find x such that x >= a, x mod g == 0\n        # x = m * g, m >= ceil(a / g)\n        m = (a + g - 1) // g\n        x = m * g\n        y = x + d\n        current_lcm = (x * y) // math.gcd(x, y)\n        k_candidate = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < min_k):\n            min_lcm = current_lcm\n            min_k = k_candidate\n    \n    # Also check the case where we take x = max(a, b) - d, but that might not be necessary\n    # But since we have already considered all divisors of d, perhaps it's covered\n    # Additionally, check the case where k = 0 (i.e., x = a, y = b)\n    x = a\n    y = b\n    current_lcm = (x * y) // math.gcd(x, y)\n    if current_lcm < min_lcm or (current_lcm == min_lcm and 0 < min_k):\n        min_k = 0\n    \n    return min_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(compute_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read from standard input, handling multiple test cases.\n- **Divisors Calculation**: For the absolute difference $ d $ between $ a $ and $ b $, we calculate all possible divisors.\n- **Optimal $ k $ Calculation**: For each divisor of $ d $, we determine the smallest $ x $ (starting from $ a $) such that $ x $ is a multiple of the divisor. This helps in minimizing the LCM by maximizing the GCD.\n- **LCM Check**: For each candidate $ x $, we compute the corresponding LCM and track the minimum value, adjusting $ k $ accordingly.\n\nThis approach efficiently narrows down potential candidates for $ k $ using mathematical properties of divisors and LCM, ensuring an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef compute_min_k(a, b):\n    d = abs(a - b)\n    min_k = 0\n    min_lcm = float('inf')\n    \n    # If a == b, then k=0 gives LCM(a, a) = a which is minimal\n    if d == 0:\n        return 0\n    \n    # We need to find x >= a (assuming a <= b) such that LCM(x, x + d) is minimal\n    # So, let's consider all possible divisors of d\n    # Generate all divisors of d\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(math.isqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    \n    divisors = get_divisors(d)\n    \n    # For each divisor g of d, find the minimal x such that x >= min(a, b) and x mod g == 0\n    # Then compute the corresponding k and LCM\n    for g in divisors:\n        # We want x such that x mod g == 0, and x >= a (assuming a <= b)\n        # Let's assume a <= b\n        if a > b:\n            a, b = b, a\n        # Now a <= b, d = b - a\n        # Find x such that x >= a, x mod g == 0\n        # x = m * g, m >= ceil(a / g)\n        m = (a + g - 1) // g\n        x = m * g\n        y = x + d\n        current_lcm = (x * y) // math.gcd(x, y)\n        k_candidate = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < min_k):\n            min_lcm = current_lcm\n            min_k = k_candidate\n    \n    # Also check the case where we take x = max(a, b) - d, but that might not be necessary\n    # But since we have already considered all divisors of d, perhaps it's covered\n    # Additionally, check the case where k = 0 (i.e., x = a, y = b)\n    x = a\n    y = b\n    current_lcm = (x * y) // math.gcd(x, y)\n    if current_lcm < min_lcm or (current_lcm == min_lcm and 0 < min_k):\n        min_k = 0\n    \n    return min_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(compute_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 1130,
        "thoughts_token_count": 1024
    }
}