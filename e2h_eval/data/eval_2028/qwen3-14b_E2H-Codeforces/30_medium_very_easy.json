{
    "start": 1758308263.4870324,
    "end": 1758308735.2187495,
    "start-formatted": "2025-09-20 03:57 KST",
    "end-formatted": "2025-09-20 04:05 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the optimal sequence of moves for Homer and Marge such that their total prize (the sum of S1 and S2) is maximized. Both players take turns taking digits from the front of A, and each makes exactly n moves. The challenge is to decide, at each step, whether Homer or Marge should take the next digit to maximize the total.\n\nFirst, I need to understand how the choices affect the total. Let's think about each move. At any point, the current player takes the leftmost digit, adds it to their own number, and removes it from A. The total prize is the sum of the numbers S1 and S2. But since each of these numbers is formed by concatenating digits, the actual value depends on the order of digits. For example, taking a higher digit earlier gives a higher contribution to the number. \n\nBut since the total is S1 + S2, perhaps we can model this as choosing which player takes each digit in a way that maximizes the sum. However, since each player takes exactly n digits, the problem is about selecting which positions are taken by Homer and which by Marge, such that the sum of their numbers is maximum.\n\nWait, but the order of taking digits affects the numbers. For example, if Homer takes a digit first, that digit is the most significant digit in his number. So, the problem is similar to choosing for each digit whether Homer or Marge takes it, but with the constraint that exactly n digits are assigned to each. And the order in which they take the digits matters because each time a player takes a digit, it's added to their number as the next digit (so the first digit taken is the most significant, then next, etc.)\n\nBut how do we model this? Since the digits are taken from the front of A, the order of selection is sequential. For example, the first move takes the first digit of A, then the second move takes the new first digit of the remaining A, and so on. So the problem is about choosing, at each step, whether Homer or Marge takes the current leftmost digit, with the constraint that each ends up with exactly n digits.\n\nThe key here is that each choice affects the future possibilities. However, since n can be up to 18, the total number of steps is 2*18=36. So a brute-force approach would be O(2^36), which is way too big. Therefore, we need a dynamic programming approach.\n\nLet me think about the state. The state depends on how many digits each player has taken so far. Let's say, after some steps, Homer has taken h digits, and Marge has taken m digits. The current state can be represented by h and m. Since each step increases either h or m by 1, and the total steps is h + m. Also, since each player must take exactly n digits, the state transitions would be such that h can range from 0 to n, and m similarly. However, since h + m can't exceed 2n, and for each state, the next step is determined by whether Homer or Marge takes the next digit.\n\nBut how to model the maximum total sum for each state. Let's consider that for a given state (h, m), the current A is the original A with the first (h + m) digits removed. Wait, no. Because the order of taking digits is fixed. For example, the first digit taken is the first digit of A, then the next is the second digit of A, etc. Wait, no. Because each time a player takes the leftmost digit. So the order of digits being taken is the same as the original order. For example, the first digit taken is the first digit of A, then the next is the second digit of A, regardless of who takes it. Because when you take the leftmost digit, you remove it, so the next leftmost is the next digit. So the order in which the digits are taken is fixed: the first digit is the first one of A, then the second, etc. So the problem is about assigning each of the 2n digits to either Homer or Marge, with exactly n digits for each, and the sum of their numbers is maximized.\n\nBut how to compute the sum based on the assignment. Let's think: Each digit is assigned to Homer or Marge. For Homer's digits, their positions in his number are determined by the order in which he took them. For example, if Homer takes the first and third digits, then his number is (digit1 followed by digit3). Similarly for Marge. But since the digits are taken in order, the first time Homer takes a digit, it's the first digit of his number, the next time he takes a digit, it's the second, etc. Similarly for Marge.\n\nSo for each digit, depending on when it is taken (i.e., the step number), and which player takes it, it contributes to the player's number. The contribution of a digit to the total sum depends on its position in the player's number. For example, if a digit d is taken by Homer as his k-th digit (so it's the k-th digit in his number), then its contribution to S1 is d * 10^{n - k} (since the number has n digits, and the first digit is multiplied by 10^{n-1}, etc.). Similarly for Marge.\n\nBut how to calculate this efficiently. Let's think: for each digit in the original A, the position in the original string is fixed. Let's say the original A has digits D_0, D_1, ..., D_{2n-1}. For each digit D_i, which is the (i+1)-th digit in the original string. Now, when this digit is taken by a player, it is added to their number. Suppose that this digit is the k-th digit taken by the player. Then, its contribution to the sum is D_i * 10^{n - k} if it's Homer's digit, or same for Marge. But since the total sum is S1 + S2, the contribution of each digit is D_i * 10^{a} where a depends on the player's position.\n\nWait, but since both players have n digits, each digit is part of either Homer's or Marge's number. For example, suppose Homer takes the first digit (position 0 in A) as his first digit. Then, this contributes D_0 * 10^{n-1} to S1. If he takes the second digit (position 1 in A) as his second digit, then it contributes D_1 * 10^{n-2} to S1, etc. Similarly for Marge.\n\nBut how to model this? The problem is that the position of the digit in the player's number depends on the order in which the player took digits. For example, if Homer takes the first digit (step 1) and then the third digit (step 3), then in his number, the first digit is the first one, and the second is the third one. So the contribution of the first digit is D_0 * 10^{n-1}, and the third digit is D_2 * 10^{n-2}.\n\nSo the challenge is to assign each digit to a player, ensuring that each has exactly n digits, and that the sum of all their contributions is maximized.\n\nBut how can we model this? It seems that the problem can be transformed into choosing for each digit (in order) whether it's taken by Homer or Marge, with the constraint that exactly n are assigned to each. However, the decision at each step affects the contribution of that digit based on the number of times the player has already taken digits.\n\nBut since the digits are taken in order, the choice for each step is whether to assign the current digit to Homer or Marge, given that the number of assignments so far for each is h and m.\n\nLet me think of dynamic programming. The state can be represented by (h, m), which is the number of digits Homer and Marge have taken so far. The total steps taken is h + m, and the next digit to be considered is the (h + m)-th digit of A (assuming zero-based index). For example, when h=0 and m=0, the first digit (index 0) is considered. Then, for each state (h, m), we can choose to assign the current digit to Homer (if h < n) or to Marge (if m < n). The transition would be to (h+1, m) or (h, m+1).\n\nThe key is to calculate the maximum possible total sum from the current state onwards. For each state (h, m), we can compute the best possible value, considering the choices available.\n\nBut how to compute the value of choosing Homer or Marge at this step. Let's see:\n\nAt state (h, m), the current digit is A[h + m]. If we assign this digit to Homer, then it's his (h+1)-th digit. Since Homer's number has n digits, the position of this digit in his number is (h+1). So the contribution to the total sum is digit * 10^{n - (h+1)}. Similarly, if assigned to Marge, the contribution is digit * 10^{n - (m+1)}.\n\nWait, but wait. For example, if Homer has taken h digits so far, and now takes another, making it h+1. The new digit is his (h+1)th digit. Since his number has n digits, the weight of this digit is 10^{n - (h+1)}. For example, if he takes the first digit (h=0, then h becomes 1), the weight is 10^{n-1}.\n\nYes. So for each choice, the contribution of the current digit can be calculated based on the current h and m.\n\nTherefore, the DP recurrence can be:\n\ndp[h][m] = max(\n   (current_digit * 10^{n - h - 1}) + dp[h+1][m], \n   (current_digit * 10^{n - m - 1}) + dp[h][m+1]\n)\n\nBut wait, the current digit is the (h + m)th digit of A (assuming 0-based). So for each state (h, m), the next digit is A[h + m].\n\nBut the problem is that for n up to 18, the maximum h and m can be up to 18. So the DP table will have (n+1) x (n+1) states. For each state, we need to calculate the maximum sum possible from that state onward.\n\nBut what about the base case? When h = n and m = n, the sum is 0 (no more digits to take). Also, when h + m = 2n, which is the same as h = n and m = n.\n\nSo the DP approach seems feasible. The problem is that for n=18, the DP table is 19x19 = 361 states. For each state, we have to compute the maximum between two options. So the total number of operations is manageable.\n\nBut how to precompute the powers of 10? For each possible position in the player's number, we need 10^{n - k}, where k is the number of digits the player has taken before this step.\n\nBut since n can be up to 18, the maximum exponent needed is 18 (for when k=0, n - k = 18). So precomputing 10^0 to 10^18 would be helpful. But since the digits can be up to 9, and multiplied by 10^something, but since we're dealing with sums, we can compute these values as integers.\n\nWait, but for n=18, the numbers can be up to 9 * 10^18 * 18 digits. Wait, but the sum of S1 and S2 can be very large. However, since Python handles big integers well, we don't have to worry about overflows.\n\nSo the plan is:\n\n- Precompute the powers of 10 up to 10^18 (for n up to 18).\n\nBut wait, for each digit, when assigned to a player, the contribution depends on the player's current count of digits. For example, when Homer has taken h digits, and this is his (h+1)th digit, then the exponent is n - (h+1). So for h ranging from 0 to n-1.\n\nSo for each state (h, m), the current digit is A[h + m], and the value of choosing Homer is digit * 10^{n - (h+1)} plus the DP value of (h+1, m). Similarly for Marge.\n\nBut how to compute this?\n\nWe can memoize the DP function. Let's think recursively. For each (h, m), we can compute the maximum total sum possible from this state.\n\nNow, the problem is that for each state, we need to know which choice (H or M) gives a higher total. Also, we need to track the path (the sequence of H and M choices) to reconstruct the answer.\n\nBut for the DP approach, we can use memoization with recursion. However, for Python, memoization with lru_cache might be feasible for small n.\n\nBut for n=18, the maximum number of states is 19*19 = 361. So even with recursion, it's manageable.\n\nBut how to handle the memoization. Let's proceed.\n\nFirst, we need to precompute the digits of A. Let's say A is a string. Then, for the state (h, m), the current digit is A[h + m].\n\nNow, for each state (h, m), we can compute the maximum sum possible from that state onwards. Let's define dp(h, m) as the maximum sum achievable from this state.\n\nThe base case is when h == n and m == n, then dp is 0.\n\nFor other cases, we have to choose between Homer and Marge, provided that their counts haven't reached n yet.\n\nSo for the recursive function:\n\ndef dp(h, m):\n\n    if h + m == 2n:\n\n        return 0\n\n    if memo contains (h, m):\n\n        return memo[(h, m)]\n\n    current_digit = A[h + m]\n\n    option_h = 0\n\n    if h < n:\n\n        # choose Homer\n\n        contribution = int(current_digit) * (10 ** (n - h - 1))\n\n        option_h = contribution + dp(h + 1, m)\n\n    option_m = 0\n\n    if m < n:\n\n        contribution = int(current_digit) * (10 ** (n - m - 1))\n\n        option_m = contribution + dp(h, m + 1)\n\n    memo[(h, m)] = max(option_h, option_m)\n\n    return memo[(h, m)]\n\nWait, but what if both options are possible? Like, when h < n and m < n. Then, we take the maximum between option_h and option_m.\n\nBut how to handle the case when only one option is possible. For example, when h == n, then only m can be incremented.\n\nBut this seems correct.\n\nOnce we compute the DP table, we can then reconstruct the path by choosing, for each state (h, m), which choice (H or M) was taken to reach the maximum sum.\n\nSo, during the DP computation, we can also track the choice made at each state. For example, we can have a memoization table that stores not only the maximum value but also the choice (H or M) that was made. Alternatively, after computing the DP table, we can retrace the steps by checking for each state which choice (H or M) gives the maximum value.\n\nBut for the purpose of generating the sequence, during the DP computation, we can track the choices. Alternatively, once the DP table is filled, we can simulate the process again, making the optimal choice at each step.\n\nLet me think about the steps for building the solution:\n\n1. Precompute the digits of A as a list.\n\n2. Compute the DP table using memoization, storing the maximum sum for each (h, m) state.\n\n3. Reconstruct the path by starting from (0, 0) and, for each state, choosing whether to take H or M based on which option gives the maximum value.\n\nBut how to do this reconstruction.\n\nLet me think. Starting with h=0, m=0. For each step, we look at the current digit (h + m) and check which choice (H or M) gives the maximum value. For example, for the state (h, m), we compare the value of choosing H (if possible) and choosing M (if possible). The choice that gives the higher value is selected. If both options are equal, we can choose either (the problem says to output any of them).\n\nSo during reconstruction, for each state (h, m), we check if choosing H gives a higher value than choosing M. If yes, we append 'H' to the result and move to (h+1, m). Else, append 'M' and move to (h, m+1).\n\nBut how to compute the value of choosing H or M for each state. Since during the DP calculation, we stored the maximum value, but not the individual contributions of each choice. Therefore, during the reconstruction, we need to recompute the options again. However, that's possible.\n\nAlternatively, during the DP computation, we can store for each state (h, m) which choice was made (H or M) to reach the maximum. But for that, during the DP calculation, we can track the choice.\n\nBut for the sake of code simplicity, perhaps during reconstruction, for each state, we can recompute the options and choose accordingly.\n\nBut for that, we need to have access to the DP function again. However, since the DP function is memoized, we can re-use it.\n\nBut in Python, with memoization via lru_cache, it's possible.\n\nSo the plan is:\n\nImplement the DP with memoization, then, for the path reconstruction, start from (0, 0), and for each step, check whether choosing H gives a higher value than choosing M. For that, we can compute for the current state (h, m) the value of choosing H (if possible) and choosing M (if possible), and pick the one with higher value.\n\nBut how to compute the value of choosing H or M again? Well, since the DP function returns the maximum value from that state onwards, but during reconstruction, we can compute the value of each option. For example:\n\nAt state (h, m):\n\ncurrent_digit = A[h + m]\n\nif h < n:\n\n    option_h_val = contribution_h + dp(h+1, m)\n\nelse:\n\n    option_h_val = -infinity\n\nSimilarly for option_m_val.\n\nThen, compare option_h_val and option_m_val.\n\nBut since the DP function already returns the maximum value, perhaps during reconstruction, we can compute the two options again.\n\nBut this may be computationally feasible since the number of steps is 2n, which is 36 steps for n=18.\n\nBut how to implement this in code.\n\nNow, considering that the DP is memoized, and during the reconstruction phase, we can call the DP function again. But that would be redundant. However, since the DP is already computed, perhaps it's better to precompute for each state (h, m) which option was chosen.\n\nAlternatively, during the initial DP computation, we can track the choice made for each state. For example, during the DP function, when we compute the maximum between option_h and option_m, we can store which choice was made.\n\nSo, perhaps we can have a 2D array called 'choice', where choice[h][m] is 'H' or 'M' indicating which choice was taken at this state.\n\nBut how to implement this. Let's think about modifying the DP function to not only return the maximum value but also record the choice made. However, in practice, during the DP calculation, for each state (h, m), once we compute the options, we can store which choice (H or M) gives the maximum value.\n\nSo during the DP calculation, for each state (h, m), we can compute the option_h_val and option_m_val, and then decide which one is better, and record that choice in a separate table.\n\nThis approach would allow us to reconstruct the path without recomputing the options during reconstruction.\n\nBut how to implement this in code.\n\nIn Python, perhaps using memoization with recursion, but also maintaining a separate memo for the choices.\n\nBut perhaps it's easier to compute the DP table first, and then during the path reconstruction, for each state, recompute the options and choose accordingly.\n\nLet me think of code structure.\n\nFirst, read n and A. Then, precompute the digits of A as a list of integers.\n\nThen, implement the DP with memoization. For example, using memoization via lru_cache, but since n can be up to 18, and the parameters h and m are up to 18, the recursion depth is acceptable.\n\nBut in Python, for memoization, the function can be decorated with @lru_cache(maxsize=None). However, since the digits are part of the input, the DP function must have access to them. Therefore, the DP function must be inside a function that has access to the digits of A.\n\nBut perhaps, the DP function can take the current h and m, and use the global A string.\n\nBut in code, perhaps the following steps:\n\nRead n and A.\n\ndigits = [int(c) for c in A]\n\nThen, implement a memoized DP function.\n\nBut for the DP function, we can use memoization via lru_cache.\n\nBut for the code, here's an outline:\n\nimport sys\nfrom functools import lru_cache\n\nn = int(sys.stdin.readline())\nA = sys.stdin.readline().strip()\n\ndigits = [int(c) for c in A]\n\n@lru_cache(maxsize=None)\ndef dp(h, m):\n    if h + m == 2 * n:\n        return 0\n    current_digit = digits[h + m]\n    option_h = 0\n    if h < n:\n        contribution = current_digit * (10 ** (n - h - 1))\n        option_h = contribution + dp(h + 1, m)\n    option_m = 0\n    if m < n:\n        contribution = current_digit * (10 ** (n - m - 1))\n        option_m = contribution + dp(h, m + 1)\n    return max(option_h, option_m)\n\nBut wait, the problem here is that for the case when both options are possible, the code would take the max. However, in the case when one of the options is not possible (like h == n, so only option_m is possible), then the code would take that.\n\nBut then, how to reconstruct the path. Because the dp function returns the maximum value, but not which choice was taken.\n\nSo, during the reconstruction phase, for each state (h, m), we need to check which choice (H or M) gives the maximum value. To do that, we can compute both options again, and compare.\n\nSo, the code for reconstruction:\n\nres = []\nh = 0\nm = 0\nfor _ in range(2 * n):\n    current_digit = digits[h + m]\n    # Check which choice is better\n    option_h_val = 0\n    if h < n:\n        contribution = current_digit * (10 ** (n - h - 1))\n        option_h_val = contribution + dp(h + 1, m)\n    else:\n        option_h_val = -float('inf')\n    option_m_val = 0\n    if m < n:\n        contribution = current_digit * (10 ** (n - m - 1))\n        option_m_val = contribution + dp(h, m + 1)\n    else:\n        option_m_val = -float('inf')\n    if option_h_val > option_m_val:\n        res.append('H')\n        h += 1\n    elif option_m_val > option_h_val:\n        res.append('M')\n        m += 1\n    else:\n        # choose arbitrarily, e.g., prefer H\n        res.append('H')\n        h += 1\n\nBut this approach would work, but during the reconstruction phase, we are recomputing the dp for each state again. However, since the dp function is memoized, this should not be a problem. However, for each state (h, m), the dp function is called twice during the reconstruction phase (once for option_h and once for option_m). But since the dp is memoized, these calls would be O(1) after the initial computation.\n\nBut this seems feasible.\n\nBut wait, during the initial dp computation, the function is called for all possible (h, m) states. Then, during the reconstruction phase, for each state, we call dp(h + 1, m) and dp(h, m + 1), which are already computed. So the code should work.\n\nHowever, there's a problem here. The dp function returns the maximum value for the state (h, m). But when we compute option_h_val, it's the contribution of taking H now plus the dp of (h+1, m). However, during the reconstruction phase, the code is trying to compute what the value would be if we take H now, which is exactly what the dp function returns. But since the dp function returns the maximum value from (h, m), which is the maximum between taking H or M, how does that help us in the reconstruction?\n\nWait, no. The option_h_val is the value of taking H now, which is the contribution of this digit to the sum, plus the maximum value from the next state (h+1, m). Similarly for option_m_val. So, during the reconstruction phase, the code is comparing the two options, which is exactly what the dp function does. Thus, the code should correctly choose the path.\n\nBut in the code above, during the reconstruction phase, we are recomputing the options for each state. However, since the dp function is already memoized, the code is correct.\n\nBut there's a problem here. Let me think: the dp function returns the maximum value for (h, m). However, when we compute option_h_val, it's the value of taking H now, which is contribution_h + dp(h+1, m). But the dp function for (h, m) returns the maximum between option_h and option_m. Therefore, during reconstruction, comparing option_h_val and option_m_val is the same as comparing the two options that were used to compute the dp value. Therefore, this approach is correct.\n\nBut in the code above, during the reconstruction phase, for each step, the code is recomputing the options. However, this would require that the dp function is already computed, which it is.\n\nSo, this approach should work.\n\nNow, the problem is to implement this in Python, with memoization and handling of the exponents.\n\nBut for exponents, 10 ** (n - h - 1) can be precomputed. However, for n up to 18, and exponents up to 18, this is manageable.\n\nBut in Python, exponentiation is straightforward.\n\nNow, let's test this approach with the sample input.\n\nSample Input 1:\n\n2\n\n1234\n\nSample Output: HHMM\n\nLet's see.\n\nn=2, A is '1234'.\n\ndigits = [1, 2, 3, 4]\n\nThe optimal sequence is HHMM.\n\nLet's compute the sum:\n\nHomer takes 1, 2. His number is 12. Marge takes 3, 4. Her number is 34. Total sum is 12 + 34 = 46.\n\nAlternative sequence HMHM: H takes 1, M takes 2, H takes 3, M takes 4. Homer's number is 13, Marge's is 24. Sum 37. Which is less than 46.\n\nAnother option: HHHM is invalid, since Homer can take only 2 digits.\n\nSo the code should generate the correct choice.\n\nLet's see how the DP works.\n\nFor the initial state (0, 0):\n\ncurrent digit is 1 (digits[0]).\n\noption_h is 1 * 10^(2 - 0 - 1) = 1 * 10^1 = 10, plus dp(1, 0).\n\noption_m is 1 * 10^(2 - 0 - 1) = 10, plus dp(0, 1).\n\nWhich is better?\n\nWe need to compute dp(1, 0) and dp(0, 1).\n\nLet's compute dp(1, 0):\n\nh=1, m=0. current digit is digits[1+0] = digits[1] = 2.\n\noption_h: h is 1 < 2. contribution is 2 * 10^(2 - 1 - 1) = 2 * 10^0 = 2. plus dp(2, 0).\n\ndp(2, 0): h=2, m=0. current digit is digits[2 + 0] = digits[2] = 3. Now, h is 2 (n=2), so can't take H. So option_m is 3 * 10^(2 - 0 -1) = 3 * 10^1 = 30, plus dp(2, 1).\n\ndp(2, 1): h=2, m=1. current digit is digits[3] = 4. m is 1 < 2. contribution is 4 * 10^(2 - 1 -1) = 4 * 1 = 4. plus dp(2, 2) which is 0. So total is 4. So dp(2, 1) = 4. So dp(2, 0) is 30 + 4 = 34. So back to dp(1, 0) option_h: 2 + 34 = 36.\n\noption_m: for dp(1, 0), m is 0 < 2. contribution is 2 * 10^(2 - 0 -1) = 2 * 10^1 = 20. plus dp(1, 1). Let's compute dp(1, 1).\n\ndp(1, 1): current digit is digits[2] = 3. h=1, m=1. Can choose H or M.\n\noption_h: 3 * 10^(2 - 1 -1) = 3 * 1 = 3. plus dp(2, 1) which is 4. total 3 + 4 = 7.\n\noption_m: 3 * 10^(2 - 1 -1) = 3 * 1 = 3. plus dp(1, 2). dp(1, 2) is when h=1, m=2. current digit is digits[3] = 4. h can take it (h=1 < 2). contribution is 4 * 10^(2 - 1 -1) = 4*1 = 4. plus dp(2, 2) = 0. So dp(1, 2) is 4. So option_m is 3 + 4 = 7. So dp(1, 1) is max(7,7) = 7.\n\nSo back to option_m for dp(1, 0) is 20 + 7 = 27. So comparing option_h (36) and option_m (27), so dp(1, 0) is 36.\n\nNow, back to the initial state (0,0) option_h is 10 + 36 = 46.\n\nNow, option_m for (0, 0) is 10 + dp(0, 1). Let's compute dp(0, 1):\n\nh=0, m=1. current digit is digits[0 + 1] = 2. option_h: 2 * 10^(2 - 0 -1) = 2 * 10^1 = 20 + dp(1, 1) = 20 +7 = 27. option_m: 2 * 10^(2 - 1 -1) = 2 * 1 = 2 + dp(0, 2). dp(0, 2) is when h=0, m=2. current digit is digits[2] = 3. h can take it. contribution is 3 * 10^(2 - 0 -1) = 3*10^1=30 + dp(1, 2) = 30 +4=34. So option_m for dp(0, 1) is 2 + 34 = 36. So max(27, 36) is 36. So dp(0, 1) is 36. So option_m for (0,0) is 10 + 36 = 46. So the initial state's dp(0, 0) is max(46, 46) = 46. So during reconstruction, when both options are equal, the code chooses 'H' (as per the code's else clause). Hence, the first character is 'H', then the next steps would proceed accordingly.\n\nBut in the sample input, the correct answer is 'HHMM' which gives sum 46. However, the code would choose 'H' first, then for the next step, let's see.\n\nBut during reconstruction, when the code is at (0, 0), and both options give 46, it appends 'H' and moves to (1, 0). Then, for (1, 0), the code would again check which option is better. Let's see.\n\nAt (1, 0), current digit is digits[1] = 2. option_h is 2 * 10^(2 - 1 -1) = 2 * 1 = 2 + dp(2, 0) = 2 + 34 = 36. option_m is 2 * 10^(2 - 0 -1) = 2 * 10^1 = 20 + dp(1, 1) = 20 +7=27. So option_h is better. So append 'H', moving to (2, 0). Now, h=2, m=0. Next digit is digits[2] = 3. Only option is to take M. So append 'M', m becomes 1. Then, next digit is digits[3] = 4. Again, only option is M. So the sequence is HHMM, which matches the sample.\n\nThus, the code seems correct.\n\nNow, let's think about the second sample input:\n\nInput:\n\n2\n\n9911\n\nOutput: HMHM\n\nLet's see. The digits are [9,9,1,1]. The optimal sequence is HMHM.\n\nLet's compute the sum:\n\nH takes first digit (9) and third (1). His number is 91. M takes second (9) and fourth (1). Her number is 91. Total sum 91 + 91 = 182.\n\nAlternative sequences:\n\nIf the sequence is HHHM, but it's invalid. Or HHMM: H takes 9 and 9, M takes 1 and 1. Sum 99 + 11 = 110, which is worse.\n\nAnother option is HMHM: H takes 9, M takes 9, H takes 1, M takes 1. Sum 91 + 91 = 182.\n\nAnother option: MHMH: same sum. But the code can choose any.\n\nSo during reconstruction, the code would choose between options when they are equal.\n\nNow, let's see how the code would handle this.\n\nAt (0, 0), the current digit is 9. option_h is 9 * 10^(2-0-1) = 9*10^1 = 90 + dp(1, 0). option_m is 9 * 10^(2-0-1) = 90 + dp(0, 1). So which is better?\n\nWe need to compute dp(1, 0) and dp(0, 1).\n\nBut in this case, perhaps both options are equal, leading to the code choosing 'H' or 'M' arbitrarily. However, the sample output is HMHM, which implies that in the first step, the code chose 'H' or 'M'? Let's see.\n\nWait, the sample output for this input is HMHM. So the first step is H, then M, then H, then M.\n\nBut according to the code, when both options are equal, it chooses 'H'. So perhaps in this case, the code would choose 'H' first, but the sample output has 'H' as the first character.\n\nBut in this case, the code would generate HMHM or MHMH, depending on the choices made when options are equal.\n\nBut the problem allows any correct sequence.\n\nSo the code would generate a correct sequence.\n\nNow, the code needs to be implemented.\n\nBut in Python, for memoization, the function dp(h, m) can be memoized using lru_cache. However, since the digits are part of the global variables, the function can access them.\n\nBut the code must be written with care.\n\nAnother thing to note is that for the exponents, 10 ** (n - h - 1). For example, when h is 0, and n is 2, the exponent is 2 - 0 -1 = 1. Which is correct.\n\nNow, let's proceed to write the code.\n\nBut first, the code must read the input. For example, the first line is n, then the second line",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize (the sum of their numbers) is maximized. Each player must take exactly `n` digits from the given number `A`, which consists of `2n` digits. The solution involves dynamic programming (DP) with memoization to efficiently explore all possible sequences of moves and choose the one that maximizes the total prize.\n\n### Approach\n1. **Dynamic Programming with Memoization**: We use a DP approach where each state is defined by the number of digits taken by Homer (`h`) and Marge (`m`). The goal is to compute the maximum total prize from each state.\n2. **State Transition**: For each state `(h, m)`, we consider both possible moves: Homer taking the next digit or Marge taking the next digit. The contribution of each digit to the total prize depends on its position in the respective player's number.\n3. **Reconstruction of Path**: After computing the maximum total prize using DP, we reconstruct the sequence of moves by choosing at each step whether Homer or Marge should take the next digit based on which choice leads to the higher total prize.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == total_length:\n            return 0\n        current_digit = digits[h + m]\n        option_h = 0\n        if h < n:\n            contribution = current_digit * (10 ** (n - h - 1))\n            option_h = contribution + dp(h + 1, m)\n        option_m = 0\n        if m < n:\n            contribution = current_digit * (10 ** (n - m - 1))\n            option_m = contribution + dp(h, m + 1)\n        return max(option_h, option_m)\n\n    res = []\n    h, m = 0, 0\n    for _ in range(total_length):\n        current_digit = digits[h + m]\n        option_h_val = -float('inf')\n        if h < n:\n            contribution = current_digit * (10 ** (n - h - 1))\n            option_h_val = contribution + dp(h + 1, m)\n        option_m_val = -float('inf')\n        if m < n:\n            contribution = current_digit * (10 ** (n - m - 1))\n            option_m_val = contribution + dp(h, m + 1)\n        if option_h_val > option_m_val:\n            res.append('H')\n            h += 1\n        elif option_m_val > option_h_val:\n            res.append('M')\n            m += 1\n        else:\n            # Choose arbitrarily, prefer 'H'\n            res.append('H')\n            h += 1\n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Dynamic Programming Function**: The `dp` function computes the maximum total prize starting from the state where Homer has taken `h` digits and Marge has taken `m` digits. It uses memoization to avoid redundant calculations.\n3. **Path Reconstruction**: After computing the DP table, we reconstruct the sequence of moves by checking at each step whether Homer or Marge taking the next digit results in a higher total prize. If both options yield the same result, we arbitrarily choose Homer's move.\n\nThis approach ensures that we efficiently explore all possible sequences of moves and determine the optimal one using dynamic programming, leading to an optimal solution with a time complexity of O(n²) due to the memoization of states.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == total_length:\n            return 0\n        current_digit = digits[h + m]\n        option_h = 0\n        if h < n:\n            contribution = current_digit * (10 ** (n - h - 1))\n            option_h = contribution + dp(h + 1, m)\n        option_m = 0\n        if m < n:\n            contribution = current_digit * (10 ** (n - m - 1))\n            option_m = contribution + dp(h, m + 1)\n        return max(option_h, option_m)\n\n    res = []\n    h, m = 0, 0\n    for _ in range(total_length):\n        current_digit = digits[h + m]\n        option_h_val = -float('inf')\n        if h < n:\n            contribution = current_digit * (10 ** (n - h - 1))\n            option_h_val = contribution + dp(h + 1, m)\n        option_m_val = -float('inf')\n        if m < n:\n            contribution = current_digit * (10 ** (n - m - 1))\n            option_m_val = contribution + dp(h, m + 1)\n        if option_h_val > option_m_val:\n            res.append('H')\n            h += 1\n        elif option_m_val > option_h_val:\n            res.append('M')\n            m += 1\n        else:\n            # Choose arbitrarily, prefer 'H'\n            res.append('H')\n            h += 1\n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 426,
        "completion_token_count": 835,
        "thoughts_token_count": 8192
    }
}