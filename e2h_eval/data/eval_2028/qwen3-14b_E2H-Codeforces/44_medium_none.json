{
    "start": 1758310214.6715026,
    "end": 1758310415.252779,
    "start-formatted": "2025-09-20 04:30 KST",
    "end-formatted": "2025-09-20 04:33 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, Polycarp has n problems with difficulties a_1 to a_n. He needs to practice for exactly k days. Each day he solves a contiguous block of problems starting from the beginning. So, the first day's problems are a prefix of the array, then the next day's is another prefix, etc. The total profit is the sum of the maximum difficulty each day. We need to maximize this total profit and output the distribution of the number of problems per day.\n\nHmm. The key is to split the array into k contiguous parts, each part being a consecutive sequence starting from the beginning. For example, if k=3 and n=8, the splits would be like [first x problems], [next y problems], [remaining z problems], where x + y + z = 8, and each is at least 1.\n\nThe challenge is to find the optimal way to split into k parts so that the sum of the maxima of each part is maximized.\n\nLet me think about dynamic programming here. Because for each position and number of days, we can track the maximum profit.\n\nLet me consider the DP approach. Let's define dp[i][j] as the maximum profit for the first i problems split into j days.\n\nThe base case would be dp[0][0] = 0. But since each day must have at least one problem, for j=1, dp[i][1] would be the maximum of the first i elements. For other cases, we need to consider splitting the first i problems into j days, which means that on the j-th day, we take some m problems (from m to i) and the previous j-1 days cover the first m-1 problems.\n\nSo for dp[i][j], we can look for all possible m (from j-1 to i-1) such that the j-th day takes m+1 to i problems. Wait, no. Let me think: For the j-th day, the last day's problems are from some m to i, but since the first j-1 days must cover m problems, then m must be at least j-1 (since each of the j-1 days must have at least one problem). So for dp[i][j], we can iterate m from j-1 to i-1, and then take dp[m][j-1] + max(a[m+1..i]).\n\nBut how do we compute that efficiently?\n\nThe problem is that for each i and j, checking all possible m would take O(n^2k) time. Considering that n can be up to 2000 and k up to 2000, this might be O(2000^3) which is 8e10 operations. That's way too slow.\n\nWait, but n and k are up to 2000. Let's see: 2000^3 is 8e10. That's way beyond what can be handled in Python in reasonable time. So we need to optimize.\n\nAlternatively, perhaps there's a way to precompute the max values for ranges. Let's think about precomputing a 2D array max_range[i][j], which represents the maximum value from a[i] to a[j]. Then, when considering splitting the first i problems into j days, for each possible m (the end of the previous j-1 days), we can get the max of a[m+1 ... i] quickly.\n\nBut even with that, the DP approach would be O(n^2k) time. Let's calculate the numbers. For n=2000 and k=2000, it's 2000*2000*2000 = 8e10 operations. That's way too big. However, note that k can't be larger than n, but even so, for n=2000 and k=2000, the answer is each day has exactly one problem, so the sum is the sum of all elements. But in that case, the DP would have to handle it.\n\nBut maybe there's a way to optimize this. Let's think: for each j, when computing dp[i][j], we can find the best m for splitting. However, perhaps for each j, the transitions can be optimized.\n\nAlternatively, maybe the constraints are manageable. Let me check:\n\nIf n is 2000 and k is 2000, then for each j from 1 to k, and i from j to n, but for j=2000, i can only be 2000. So for j=2000, it's O(1) steps. For j=1, it's O(n) steps. For j=2, O(n^2) steps? No, for each j, the i ranges from j to n. For each i and j, the m ranges from j-1 to i-1. So for j=2, i can be from 2 to n, and for each i, m ranges from 1 to i-1. So for j=2, the total steps would be sum_{i=2}^n (i-1) steps. Which is O(n^2) steps. For j up to k, the total steps would be O(k * n^2). For k=2000, that's O(2000 * 2000^2) = O(8e10), which is way too slow.\n\nThis suggests that the straightforward DP approach is not feasible for n=2000. So we need a smarter approach.\n\nWait, but let's think again. What's the maximum possible value of k? It's n. So for n=2000, k can be 2000. So the DP approach is not feasible unless we can find a way to optimize it.\n\nAlternative idea: Since each day must take at least one problem, and the splits are contiguous, perhaps the optimal way is to make sure that each day's maximum is as large as possible. However, since the splits are sequential, the later days can't affect the earlier ones. But how to balance this?\n\nAnother observation: The maximum possible total profit is achieved by making each day's maximum as high as possible. However, since the days are split in order, the earliest days can't take advantage of later higher values. For example, if there's a very high value towards the end, it's better to have it in a later day. But since each day is a prefix, the splits are forced to have the first day take some number of problems, then the second day takes some more, etc. So the last day's maximum is the maximum of the last segment, which could be the maximum of the entire array if the split ends there.\n\nWait, but in the example given, the maximum of the array is 9, which is in the third day. So that's part of the optimal solution.\n\nBut how to model this.\n\nAlternative approach: Let's think of the problem as splitting the array into k segments. The total profit is the sum of the maxima of each segment. How can we split into k segments to maximize this sum?\n\nNow, the key is that each segment's maximum contributes to the sum. So, for example, if there is a peak in the array, it's better to have that as a separate segment, so that its maximum is counted once. However, if there are multiple peaks, perhaps we can split them into different days.\n\nBut how to model this in code.\n\nLet me think again about the DP approach. Let me try to find a way to compute it efficiently.\n\nFirst, precompute the max_range[i][j], which is the maximum of a[i...j]. This can be done with O(n^2) time and space.\n\nThen, for the DP, the recurrence is:\n\ndp[i][j] = max for m in [j-1 ... i-1] of (dp[m][j-1] + max_range[m+1][i])\n\nBut for each i and j, we need to find the best m.\n\nBut with n up to 2000 and k up to 2000, even with O(n^2k) time, it's 2000^3 = 8e10 operations. That's way too slow for Python, which can handle around 1e8 operations per second.\n\nBut perhaps there's a way to optimize the DP transitions.\n\nWait, but for the problem constraints, n and k are both up to 2000. Let me think: if n is 2000 and k is 2000, then the answer is to split into each day one problem. So the DP for that case would be O(n^2k) steps. But that's impossible. However, in reality, for j=1, the DP[i][1] is the maximum of the first i elements. For j=2, we need to split into two parts. For each i >=2, the DP[i][2] is the maximum of (max of first m elements + max of m+1 to i elements) for m from 1 to i-1. But even for j=2, that's O(n^2) steps. For j=2000, it's O(n) steps. So the total steps would be O(k*n^2) which is O(2000 * 2000^2) = 8e10 steps. Which is way too slow.\n\nSo, we need to find a better way. Let's think about the constraints again. Wait, the problem says that k can be up to n. But for some cases, maybe there's a way to find a better approach.\n\nAnother observation: The maximum sum is achieved by making each day's maximum as high as possible. However, since the segments are contiguous, the maximum for each segment is determined by the maximum in that segment. So, if we have a segment that includes a certain maximum, it's better to have that maximum in a separate segment. For example, if there's a peak, it's better to split before it so that it's a separate segment. However, this is not necessarily always the case, because splitting early may allow for higher sums in other segments.\n\nBut perhaps for the DP approach, there's a way to optimize the transition.\n\nWait, but maybe the number of days k is not too big. For example, if k is small, say up to 100, then O(n^2k) is manageable. But for k up to 2000, it's not. However, the problem allows n and k up to 2000, so we need a better approach.\n\nAlternative idea: For each j, the number of days, the DP[i][j] can be computed using some optimization. Let's think about for fixed j, how to compute DP[i][j].\n\nFor example, for j=2, DP[i][2] is the maximum over m from 1 to i-1 of (DP[m][1] + max(a[m+1..i])). Since DP[m][1] is the max of the first m elements, which can be precomputed.\n\nBut even then, for each i, we need to check all m from 1 to i-1, which is O(n^2) steps for j=2.\n\nAnother thought: For the DP[i][j], the max_range[m+1][i] can be considered. But for a fixed i and j, how can we find m such that DP[m][j-1] + max_range[m+1][i] is maximized?\n\nLet's think about the max_range[m+1][i]. For a fixed i, the max_range[m+1][i] is the maximum of a[m+1 ... i]. As m increases, m+1 increases, so the range [m+1, i] becomes smaller. The maximum of this range can be found using a sliding window approach?\n\nAlternatively, for each i, and for varying m, we can precompute the max_range[m+1][i]. But how?\n\nAnother idea: For each i, and for each j, we can precompute the maximums for ranges ending at i.\n\nBut I'm not sure.\n\nAlternatively, think about when you split the first i elements into j days. The last day must consist of some number of elements. Let's say the last day starts at position m+1 and ends at i. Then, the maximum of that day is max(a[m+1 ... i]). The previous j-1 days cover the first m elements. So, for each i and j, we want to choose m to maximize dp[m][j-1] + max(a[m+1 ... i]).\n\nNow, for a fixed i and j, how can we compute this efficiently?\n\nSuppose we can find for each m, the value of dp[m][j-1] + max(a[m+1 ... i]). But how to find the maximum over m.\n\nLet me think about the max(a[m+1 ... i]) part. For each i, the max from m+1 to i is equal to the maximum of a[m+1], a[m+2], ..., a[i]. Now, if we fix i, and vary m from j-1-1 to i-1 (since m must be at least j-1 - 1?), no. Wait, m must be such that the first j-1 days can split m elements. So m must be at least j-1, since each of the j-1 days must have at least one problem. So m ranges from j-1 to i-1.\n\nSo for each i and j, m ranges from (j-1) to (i-1).\n\nNow, for each m in that range, we have to compute dp[m][j-1] + max(a[m+1 ... i]).\n\nBut how to compute this efficiently.\n\nLet me think of for a fixed i and j, and varying m. The max(a[m+1 ... i]) can be rewritten as the maximum from position m+1 to i. Let's denote this as max_i(m). So for each m, max_i(m) is the maximum of a[m+1 ... i].\n\nNow, the problem is to find m in [j-1, i-1] that maximizes dp[m][j-1] + max_i(m).\n\nBut how to compute this quickly.\n\nLet me think about the max_i(m). For fixed i, as m increases from 0 to i-1, the range [m+1, i] becomes smaller. The maximum of this range can be found by keeping track of the maximum as we move m from i-1 down to 0.\n\nFor example, for m = i-1, the range is [i, i], which is a[i]. For m = i-2, the range is [i-1, i], which is max(a[i-1], a[i]), etc.\n\nSo, for each i, we can precompute an array of max_i(m) for m from 0 to i-1. This can be done in O(n^2) time overall.\n\nOnce we have this, for each i and j, and for varying m, we can get the max_i(m) quickly.\n\nBut even then, the problem remains of finding the maximum of dp[m][j-1] + max_i(m) for m in [j-1, i-1].\n\nBut perhaps for each i and j, we can compute this maximum in O(1) or O(log n) time using some data structure or optimization.\n\nAlternatively, can we find that for a fixed i and j, the optimal m is somewhere specific?\n\nLet me think about the function f(m) = dp[m][j-1] + max_i(m). How does this function behave as m increases?\n\nNot sure. But perhaps for each i and j, we can compute this maximum in O(1) time by maintaining some information.\n\nAnother idea: For each j, and for each i, we can compute the maximum of dp[m][j-1] + max_i(m) for m from j-1 to i-1.\n\nBut how?\n\nLet me think about the following. For a fixed i and j, the max_i(m) is the maximum of a[m+1 ... i]. Let's think of this as the maximum of the suffix starting at m+1. So, if I can precompute for each position l, the maximum from l to i. Let me call this suffix_max[l], which is the maximum of a[l ... i]. Then, for m, the max_i(m) is suffix_max[m+1].\n\nSo, for each i, we can precompute the suffix_max array. Then, for each m, the term is dp[m][j-1] + suffix_max[m+1].\n\nNow, the problem is to find m in [j-1, i-1] that maximizes dp[m][j-1] + suffix_max[m+1].\n\nBut how to compute this quickly.\n\nLet me consider that for each i and j, we can precompute the suffix_max array. Then, for the current i and j, and for varying m, the suffix_max[m+1] is known. But the question is how to find the maximum of dp[m][j-1] + suffix_max[m+1].\n\nBut for this, perhaps we can precompute for each j and i, the maximum value.\n\nBut I don't see a way to do that quickly.\n\nAlternative Idea:\n\nLet's think about the following. When j increases, the DP[i][j] depends on DP[m][j-1]. So, for each j, we can compute DP[i][j] based on the previous j-1 layer.\n\nBut even then, for each i and j, the inner loop over m is O(i) steps.\n\nBut for n=2000 and k=2000, this is not feasible.\n\nBut wait, perhaps in practice, the constraints are not that bad. For example, in the worst case, for each j from 1 to k, and for each i from j to n, we have O(n) steps. So total steps would be O(k * n^2). But with n=2000 and k=2000, this is 2000^3 = 8e10 steps, which is way too much.\n\nBut maybe there's a way to reduce the complexity. For example, if k is small, say up to 100, then it's manageable. However, the problem requires handling all cases up to k=2000.\n\nAlternative Idea:\n\nLet me think about the fact that the optimal way to split into k days must include the k largest elements of the array. Because each day contributes its maximum. So, if we can assign each of the top k elements to be the maximum of their respective days, that would give the maximum sum. But how to arrange that.\n\nFor example, in the sample input, the top three elements are 9, 6, 5. But the maximum sum is 5 +6 +9 = 20. Which matches. However, the third day's maximum is 9, the second day's is 6, the first day's is 5. So each of the top three elements is used as a maximum once.\n\nBut this is only possible if the top k elements can be placed in different days. However, if there are duplicates, this may not be possible. For example, if the array is [5,5,5], and k=2, then the best is to split into [5], [5,5], giving sum 5+5=10, which uses the two largest elements (but they are same).\n\nBut how can we use this idea to find the optimal splits?\n\nThe idea is to select k positions where the elements are as large as possible, and split the array such that each of those positions is the maximum of their respective day.\n\nBut how to do that.\n\nAlternatively, think of the problem as follows: Each day's maximum is a certain element. To maximize the sum, we need to select k elements (possibly with duplicates) such that each is the maximum of their day, and the days are non-overlapping and cover the entire array.\n\nBut how to select those elements optimally.\n\nThis seems similar to selecting k peaks in the array, but ensuring that they are in order and that the splits between them are correct.\n\nBut I'm not sure how to translate this into an algorithm.\n\nAnother Idea: Since each day's maximum is the maximum of a contiguous segment, and the segments are prefixes, the maximum for the first day is the maximum of the first x elements, the second day's maximum is the maximum of the next y elements, etc. So, the overall maximum sum is the sum of the maxima of the k segments.\n\nBut the problem is how to split into k segments to maximize this sum.\n\nLet me think of the following greedy approach: For each day, choose the earliest possible maximum that allows for enough days remaining. For example, for the first day, choose the maximum in the first m elements, such that there are enough elements left for the remaining days. But this might not work. For example, in the sample input, if the first day's maximum is 5 (the first element), then the rest can be split into two days. But if the first day's maximum is 6, then the rest may not have enough days.\n\nBut this seems like a possible approach. However, it's unclear whether a greedy approach would work here.\n\nAlternatively, perhaps we can model the problem as choosing the positions where the splits happen. For example, we need to choose k-1 split points between the elements. The splits must be after the first element, after the second, etc., such that each split divides the array into k parts.\n\nBut again, how to find these splits optimally.\n\nBack to DP. Maybe we can find a way to optimize the DP transitions. Let me think about the recurrence again:\n\ndp[i][j] = max_{m} (dp[m][j-1] + max(a[m+1..i])) for m from j-1 to i-1.\n\nLet me think about the max(a[m+1..i]) term. For a fixed i and varying m, this is the maximum of the subarray starting at m+1 and ending at i. So for m from 0 to i-1, this is the maximum from m+1 to i. So for each i, we can precompute the maximums for all possible ranges ending at i. Let's call this max_suffix[i][m], which is the maximum from m+1 to i. But perhaps we can compute this as follows:\n\nFor each i, we can compute a suffix maximum array. For example, for i, create an array suffix_max where suffix_max[m] = max(a[m], suffix_max[m+1]). Wait, no. Let me think again. For a given i, the suffix_max array for m from 0 to i would be the maximum of a[m ... i]. So for m = i, it's a[i], for m = i-1, it's max(a[i-1], a[i]), etc.\n\nThis can be computed for each i in O(n) time. For example, for each i, we can compute the suffix_max array from i down to 0:\n\nsuffix_max[i] = a[i]\nfor m in range(i-1, -1, -1):\n    suffix_max[m] = max(a[m], suffix_max[m+1])\n\nBut this would take O(n^2) time for all i, which is acceptable for n=2000 (about 4 million operations).\n\nOnce we have this suffix_max array for each i, then for any m, the max(a[m+1..i]) is suffix_max[m+1] (assuming that the suffix_max array for i is built as described).\n\nSo, with this, we can compute the max for any m and i in O(1) time.\n\nNow, the DP recurrence becomes:\n\ndp[i][j] = max over m in [j-1 ... i-1] of (dp[m][j-1] + suffix_max[m+1])\n\nNow, the question is, for each i and j, how to compute this maximum efficiently.\n\nLet me think for each j and i, and for varying m, how to find the maximum of dp[m][j-1] + suffix_max[m+1].\n\nBut even with this, it's O(n^2k) time.\n\nBut maybe for each j, we can compute the dp[i][j] in a way that uses some properties of the suffix_max.\n\nLet me consider that for j=1, dp[i][1] is the maximum of the first i elements, which is suffix_max[0] for i.\n\nFor j=2, dp[i][2] is the maximum over m from 1 to i-1 of (dp[m][1] + suffix_max[m+1]).\n\nNow, for each i, and for j=2, the suffix_max[m+1] is the maximum of a[m+1 ... i]. And dp[m][1] is the maximum of a[0 ... m].\n\nBut how can we find the maximum of these terms?\n\nLet me think of for j=2, and for each i, we can precompute the maximum of (max_prefix[m] + max_suffix[m+1][i]) for m from 1 to i-1.\n\nBut even then, it's O(n^2) for j=2.\n\nBut perhaps for each j, we can find a way to compute dp[i][j] more efficiently.\n\nAnother Idea: For each j, and for each i, we can keep track of the maximum value of dp[m][j-1] + max_suffix[m+1][i], where max_suffix[m+1][i] is the maximum from m+1 to i. But since i is fixed, and m varies, perhaps we can find that for a fixed i, the max_suffix[m+1][i] is non-decreasing as m decreases. Or something similar.\n\nLet me think about how max_suffix[m+1][i] changes as m increases. For example, when m increases, m+1 increases, so the range [m+1, i] becomes smaller. The maximum can either stay the same or decrease. For example, if the previous maximum was in the part that is now excluded, then the new maximum is lower. Otherwise, it remains the same.\n\nSo, for a fixed i, as m increases, the max_suffix[m+1][i] is non-increasing. Because when m increases, the range [m+1, i] becomes smaller, and thus the maximum can't increase.\n\nSo, for a fixed i, the max_suffix[m+1][i] is non-increasing as m increases.\n\nNow, dp[m][j-1] is the value for the first m elements split into j-1 days. How does this change with m? Well, it's possible that it increases or decreases as m increases. But without knowing the specifics, it's hard to tell.\n\nBut combining the two: the term dp[m][j-1] + max_suffix[m+1][i] is the sum of something that could be increasing or decreasing and something that is non-increasing.\n\nBut perhaps we can find that for each i and j, the optimal m is somewhere in a certain range.\n\nAlternatively, since the max_suffix is non-increasing, and dp[m][j-1] is likely to be increasing (since adding more elements to the first m elements may allow higher maxima), perhaps the sum is unimodal, and we can use ternary search to find the maximum. However, I'm not sure if that's the case.\n\nBut even if it were, ternary search would require O(log n) steps per i and j, which would bring the total time down to O(n^2k log n), which is still too slow for n=2000.\n\nAlternative Idea: Let's think about the problem differently. Since the splits are contiguous and must start from the beginning, the splits are determined by the positions where we split. For example, for k days, we need to choose k-1 split points. Let's say the split points are s_1, s_2, ..., s_{k-1}, where s_1 is the number of problems on day 1, s_2 is the number of problems on day 1 plus day 2, etc. So the split points are positions after which the next day starts.\n\nBut how to choose these split points to maximize the sum of the maxima of each segment.\n\nLet me think about the following: The maximum sum is the sum of the maxima of each of the k segments. Each segment is a prefix of the remaining array.\n\nLet me think recursively. For the first day, we can choose to take m problems (from 1 to n - (k-1)), since we need to leave at least (k-1) problems for the remaining days. Then, the profit for the first day is the maximum of the first m problems, and the remaining problem is to split the rest into k-1 days. So, this is a recursive approach, which can be memoized.\n\nBut again, this is the same as the DP approach discussed earlier.\n\nBut perhaps with memoization and precomputed max ranges, we can proceed.\n\nBut again, the time complexity is O(n^2k), which is too slow for n=2000 and k=2000.\n\nSo, what's the alternative?\n\nMaybe the constraints are not that bad. For example, if n is 2000 and k is 2000, then each day has exactly one problem, and the sum is the sum of all elements. So, the DP would be O(n^2k) steps, but in reality, for j=2000, the only possible i is 2000, and m must be 1999. So for j=2000, the steps are negligible. Similarly, for j=1999, i can be from 1999 to 2000, and so on.\n\nBut in general, for larger j, the number of i's that can be processed is small. So perhaps the actual number of operations is manageable.\n\nLet me try to estimate the total number of operations. For each j from 1 to k, and for each i from j to n, the number of m's is i-j. So the total number of operations is sum_{j=1}^k sum_{i=j}^n (i-j) = sum_{j=1}^k sum_{d=0}^{n-j} d } = sum_{j=1}^k ( (n-j)(n-j+1)/2 )\n\nBut for j from 1 to k, and n=2000, this is roughly O(k * n^2) steps. However, for k=2000 and n=2000, this becomes O(2000 * 2000^2) = 8e10 steps. Which is way too big for Python to handle in reasonable time.\n\nThus, this suggests that the DP approach is not feasible for the worst case.\n\nAlternative Idea: Perhaps there's a way to find that for certain j and i, the optimal m is i-1, or some other position. For example, for j=2, the best split is to take the first m elements, and the rest as the second day. The maximum for the second day is the maximum of the remaining elements. So, for j=2, the optimal split would be to choose m such that the sum of the max of the first m elements plus the max of the remaining elements is maximized.\n\nBut how to find that m quickly.\n\nLet me think for j=2. For each i, we have to find m from 1 to i-1, and compute dp[m][1] + max(a[m+1 ... i]). Since dp[m][1] is the maximum of the first m elements, which is precomputed as prefix_max[m].\n\nSo, for j=2 and i, the value is max_{m=1 to i-1} (prefix_max[m] + max_suffix[m+1][i]).\n\nBut how to compute this efficiently.\n\nLet me think about the max_suffix[m+1][i] for varying m. As mentioned before, for a fixed i, this is non-increasing as m increases.\n\nSo, for m from 1 to i-1, the max_suffix[m+1][i] decreases as m increases.\n\nMeanwhile, prefix_max[m] is the maximum of the first m elements. This is non-decreasing as m increases.\n\nSo, the function f(m) = prefix_max[m] + max_suffix[m+1][i] is the sum of a non-decreasing function and a non-increasing function. It's possible that this function has a single maximum point, which can be found with binary search.\n\nIf that's the case, then for each i and j=2, we can perform a binary search on m to find the optimal value.\n\nBut I'm not sure if this function is unimodal. For example, it could have multiple peaks. However, even if it's not strictly unimodal, binary search might still help in practice.\n\nBut how to verify this.\n\nLet's take an example. Suppose the array is [5, 4, 2, 6, 5, 1, 9, 2], as in the sample. For i=8 (the full array), j=2. We need to split into two days. The optimal split is m=3 (first 3 elements, then the rest). The max of the first part is 5, the max of the second part is 9. Total is 14. If we choose m=2, the first part's max is 5, the second part's max is max([2,6,5,1,9,2])=9. Same total. Choosing m=4, first part's max is 6, the second part's max is 9. Total 15. Which is better. So in this case, the optimal m is 4. So for this case, the function f(m) increases up to m=4 and then decreases.\n\nAnother example: Let's say the array is [1, 3, 2, 4]. For j=2, i=4. The possible m are 1, 2, 3.\n\nFor m=1: prefix_max is 1, max_suffix is max([3,2,4])=4 → total 5.\n\nm=2: prefix_max is 3, max_suffix is max([2,4])=4 → total 7.\n\nm=3: prefix_max is 3, max_suffix is 4 → total 7.\n\nSo the function f(m) increases from m=1 to m=2, then remains the same. So it's not strictly unimodal, but it's non-decreasing until a certain point.\n\nIn this case, the maximum is achieved at m=2 or m=3.\n\nSo, if we can find the maximum in O(log n) time per i and j, it could help.\n\nBut how to implement this.\n\nAlternatively, for each i and j, we can precompute the best m for that i and j. But I'm not sure.\n\nAnother Idea: Since the max_suffix[m+1][i] is non-increasing with m, and prefix_max[m] is non-decreasing with m, the sum f(m) is the sum of a non-decreasing and a non-increasing function. This sum could have a single maximum, which can be found with ternary search.\n\nIf this is true, then for each i and j, we can perform a ternary search on m in the range [j-1, i-1], and find the optimal m in O(log n) steps.\n\nThis would reduce the time complexity to O(n^2k log n), which for n=2000 and k=2000 would be 2000^2 * 2000 * log(2000) = which is still way too big. For example, 2000^2 is 4e6, multiplied by 2000 gives 8e9, multiplied by log(2000) (~11) gives ~8.8e10 operations. Still way too slow.\n\nBut perhaps there's another way to find that for each i and j, the optimal m is the one where the max_suffix[m+1][i] is as large as possible, given that dp[m][j-1] is also large.\n\nBut I'm not seeing it.\n\nAlternative Idea: Let's think about the fact that the maximum for a segment is determined by the maximum in that segment. So, if we have to split into k segments, the best way is to ensure that each segment contains at least one of the top k elements. But how to arrange that.\n\nFor example, if we have the top k elements in the array, then each of these elements should be the maximum of their respective segments. This would maximize the sum.\n\nBut how to ensure that.\n\nLet me think about the sample input. The top 3 elements are 9, 6, 5. The optimal split is to have 5 in the first segment, 6 in the second, and 9 in the third. So yes, each of the top 3 elements is used as the maximum of their segment.\n\nSo, perhaps the optimal strategy is to select the k largest elements, and split the array so that each of these elements is the maximum of their own segment.\n\nBut how to do this.\n\nLet me think: We can sort the array's elements and take the top k. Then, we need to split the array into k segments, each containing exactly one of these top elements, and ensuring that each segment's maximum is that element.\n\nBut how to do this.\n\nFor example, suppose the top k elements are at positions p_1, p_2, ..., p_k. We need to split the array such that each segment contains exactly one of these elements, and the segment's maximum is that element. This would ensure that the sum is the sum of the top k elements.\n\nBut how to find these positions.\n\nHowever, this approach may not work if there are duplicate elements. For example, if the array is [5,5,5], and k=2, the top two elements are both 5",
    "response": "To solve this problem, we need to distribute `n` problems into `k` days such that the total profit, defined as the sum of the maximum difficulty of each day's problems, is maximized. Each day must consist of a contiguous sequence of problems starting from the beginning of the list.\n\n### Approach\n1. **Dynamic Programming (DP) Setup**: Use a DP table where `dp[i][j]` represents the maximum profit for the first `i` problems split into `j` days.\n2. **Precompute Maximum Ranges**: Precompute a 2D array `max_range` where `max_range[l][r]` stores the maximum value in the subarray from index `l` to `r`.\n3. **DP Transition**: For each possible split point `m`, compute the profit by considering the maximum value of the subarray from `m+1` to `i` and adding it to the DP value of the previous segment.\n4. **Reconstruct the Solution**: After computing the DP table, backtrack from `dp[n][k]` to determine the number of problems solved each day.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Precompute max_range\n    max_range = [[0] * n for _ in range(n)]\n    for i in range(n):\n        current_max = a[i]\n        max_range[i][i] = current_max\n        for j in range(i + 1, n):\n            current_max = max(current_max, a[j])\n            max_range[i][j] = current_max\n\n    # Initialize DP table\n    INF = float('-inf')\n    dp = [[INF] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j > i:\n                continue\n            for m in range(j - 1, i):\n                if dp[m][j - 1] != INF:\n                    current_max = max_range[m][i - 1]\n                    dp[i][j] = max(dp[i][j], dp[m][j - 1] + current_max)\n\n    # Reconstruct the solution\n    result = []\n    current_i = n\n    current_j = k\n    while current_j > 0:\n        for m in range(current_j - 1, current_i):\n            if dp[current_i][current_j] == dp[m][current_j - 1] + max_range[m][current_i - 1]:\n                result.append(current_i - m)\n                current_i = m\n                current_j -= 1\n                break\n\n    result.reverse()\n    print(dp[n][k])\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Precompute Maximum Ranges**: The `max_range` array is precomputed to quickly access the maximum value of any subarray, which helps in efficiently calculating the profit for each segment during the DP transitions.\n2. **Dynamic Programming Table**: The `dp` table is filled by iterating through all possible numbers of problems and days. For each entry `dp[i][j]`, we consider all possible previous splits `m` and calculate the maximum profit by combining the DP value of the previous segment with the maximum value of the current segment.\n3. **Reconstructing the Solution**: After filling the DP table, we backtrack from `dp[n][k]` to determine the exact number of problems assigned to each day, ensuring the maximum profit is achieved.\n\nThis approach ensures that we efficiently compute the optimal distribution of problems across days using dynamic programming and precomputed maximum values, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Precompute max_range\n    max_range = [[0] * n for _ in range(n)]\n    for i in range(n):\n        current_max = a[i]\n        max_range[i][i] = current_max\n        for j in range(i + 1, n):\n            current_max = max(current_max, a[j])\n            max_range[i][j] = current_max\n\n    # Initialize DP table\n    INF = float('-inf')\n    dp = [[INF] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j > i:\n                continue\n            for m in range(j - 1, i):\n                if dp[m][j - 1] != INF:\n                    current_max = max_range[m][i - 1]\n                    dp[i][j] = max(dp[i][j], dp[m][j - 1] + current_max)\n\n    # Reconstruct the solution\n    result = []\n    current_i = n\n    current_j = k\n    while current_j > 0:\n        for m in range(current_j - 1, current_i):\n            if dp[current_i][current_j] == dp[m][current_j - 1] + max_range[m][current_i - 1]:\n                result.append(current_i - m)\n                current_i = m\n                current_j -= 1\n                break\n\n    result.reverse()\n    print(dp[n][k])\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 927,
        "completion_token_count": 852,
        "thoughts_token_count": 8192
    }
}