{
    "start": 1758309547.7694576,
    "end": 1758310002.4188144,
    "start-formatted": "2025-09-20 04:19 KST",
    "end-formatted": "2025-09-20 04:26 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The problem is about finding the minimum number of nodes required to create a p-reachable directed graph, and then among those graphs, find the maximum number of unidirectional pairs.\n\nFirst, I need to understand what exactly p-reachable means. The definition says that a directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So for each such pair, both directions must have paths. Wait, no. Wait, reachability is mutual here. Because if u and v are reachable from each other, then they form a strongly connected component. So the problem counts all unordered pairs (u, v) with u < v that are in the same strongly connected component (SCC), and the total count of these is p.\n\nSo the first part of the problem is to find the minimal number of nodes needed so that there exists a directed graph with exactly p such pairs. Then, among all such minimal node graphs, find the maximum number of unidirectional pairs.\n\nNow, the unidirectional pairs are ordered pairs (u, v) where u != v, there's a path from u to v, but not vice versa. So for each such pair, it's a one-way reachability.\n\nThe first step is to find the minimal number of nodes. Let's think about how to model this.\n\nLet me think: the number of pairs (u, v) with u < v and mutually reachable is equal to the sum over all SCCs of C(k, 2), where k is the size of the SCC. Because in an SCC of size k, there are k*(k-1)/2 ordered pairs (u, v) with u < v. Because for each pair of distinct nodes in the same SCC, they are mutually reachable. So the total p is the sum of combinations of sizes of each SCC.\n\nSo our task is to find the minimal number of nodes n, such that there exists a set of integers (k_1, k_2, ..., k_m) where sum_{i} C(k_i, 2) = p, and sum k_i = n. And we need the minimal possible n.\n\nWait, but how do we choose the k_i? Because for the minimal n, given that sum C(k_i, 2) = p, we need to choose the k_i's such that their sum is as small as possible.\n\nBut how? For example, if we have p=3, then C(3, 2) = 3, so sum is 3. So the minimal n is 3. Which matches the first sample input.\n\nAnother example: for p=4. How can we get sum C(k_i, 2) =4?\n\nPossible options:\n\n- One component of size 4: C(4,2) =6, which is more than 4. Not good.\n\n- Two components. Let's see:\n\nSuppose one component of size 3 (C(3,2)=3) and another of size 2 (C(2,2)=1). Sum is 4. Total nodes is 3+2=5. Alternatively, can we have a component of size 4 and some other? Well, maybe not. So the minimal n is 5. Which matches the second sample input's output of 5 for p=4.\n\nSo the problem reduces to finding the minimal n such that there exists a set of integers (k_1, k_2,...k_m) with sum C(k_i, 2) = p and sum k_i =n. And we need to find the minimal n.\n\nSo how do we find this minimal n?\n\nThe key idea here is that to minimize the sum of k_i given that the sum of C(k_i, 2) is fixed. Because C(k, 2) is k*(k-1)/2. For a fixed value of sum C(k_i, 2) = p, the minimal sum of k_i is achieved by making the k_i's as large as possible. Because for example, if you have two components of size a and b, then sum C(a,2) + C(b,2) = ... If instead you merge them into a single component of size a + b, then C(a + b, 2) = C(a,2) + C(b,2) + ab. Which is larger. So merging components increases the sum of combinations. Therefore, to get the minimal sum of k_i for a given p, we need to split p into as few terms as possible, but with each term being as large as possible.\n\nWait, perhaps not. Let me think again. Suppose we have a fixed sum of C(k_i, 2) = p. We want to minimize sum k_i. How can we do that? Because C(k, 2) is convex",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to construct a directed graph that is p-reachable, and then find the maximum number of unidirectional pairs in such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This translates to summing combinations of sizes of strongly connected components (SCCs) in the graph.\n\n2. **Minimizing Nodes**: The goal is to find the minimum number of nodes `n` such that the sum of combinations of sizes of SCCs equals `p`. The optimal approach involves using the largest possible components to minimize the total number of nodes.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimum number of nodes is determined, the maximum number of unidirectional pairs can be derived by considering the structure of the graph with the given components.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find the minimal number of nodes\n    # We need to find the minimal n such that sum C(k_i, 2) = p\n    # To minimize n, we want as large as possible k_i's.\n    # So we try to find the largest k such that C(k, 2) <= p\n    # Then subtract and repeat.\n    \n    n = 0\n    remaining_p = p\n    while remaining_p > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining_p\n        low = 1\n        high = 2 * 10**5 + 10  # arbitrary large number\n        best_k = 0\n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= remaining_p:\n                best_k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        n += best_k\n        remaining_p -= best_k * (best_k - 1) // 2\n    \n    # Now calculate the maximum number of unidirectional pairs\n    # The maximum unidirectional pairs is the total possible ordered pairs (u, v), u != v, minus twice the p (since each mutual pair is counted once in p)\n    # But wait, the total number of ordered pairs (u, v) with u != v is n*(n-1)\n    # However, for each mutual pair (u, v) with u < v, there are two ordered pairs: (u, v) and (v, u). So the total mutual pairs count in terms of ordered pairs is 2*p.\n    # The number of unidirectional pairs is total_ordered_pairs - 2*p\n    # But the problem defines unidirectional pairs as (u, v) where u != v, there's a path from u to v but not vice versa.\n    # However, the total number of ordered pairs (u, v) with u != v is n*(n-1)\n    # The number of mutual pairs is 2*p (each unordered pair contributes two ordered pairs)\n    # So the number of unidirectional pairs is total_ordered_pairs - 2*p\n    # But wait, no. Because for each mutual pair (u, v), both directions exist. So the number of ordered pairs that are mutual is 2*p. The rest are either unidirectional or not.\n    # However, the problem says that unidirectional pairs are those where there is a path from u to v but not from v to u. So for each such ordered pair, it's counted once.\n    # Therefore, the total number of unidirectional pairs is (total_ordered_pairs - mutual_pairs) / 1, since mutual pairs are excluded.\n    # Wait, the total number of ordered pairs (u, v) where u != v is n*(n-1). The mutual pairs are those where u and v are in the same SCC. For each such pair, both (u, v) and (v, u) are present. So the number of mutual ordered pairs is 2*p. Thus, the number of unidirectional pairs is total_ordered_pairs - 2*p.\n    # But in our case, the mutual pairs are exactly p unordered pairs, which contribute 2p ordered pairs. So the unidirectional pairs would be total_ordered_pairs - 2p.\n    \n    # However, in our setup, the graph may have multiple SCCs. So the maximum number of unidirectional pairs occurs when the graph is structured such that between different SCCs, there are as many one-way edges as possible.\n    # However, the problem requires that among all minimal node graphs, we choose the one with maximum unidirectional pairs.\n    # To maximize the unidirectional pairs, we should have the SCCs arranged in a DAG where each edge between components is one-way. For example, arrange the components in a linear order, with edges from earlier components to later ones.\n    # In such a case, the number of unidirectional pairs between components is the product of their sizes, multiplied by 2 (since for each pair of nodes u in component A and v in component B, there's a path from u to v if A is before B, and vice versa if B is before A. But if arranged in a DAG, we can have only one direction between components.)\n    # However, this part is more complex. But according to the sample input, when p=3, n=3. The maximum unidirectional pairs is 0, which makes sense because all nodes are in one SCC. So the total ordered pairs is 3*2=6. Mutual pairs are 3*2=6 (since p=3, 2p=6). Thus, unidirectional pairs is 6-6=0.\n    # Similarly, for p=4, n=5. The total ordered pairs is 5*4=20. 2p=8. 20-8=12. But the sample output says 6. Wait, that contradicts. So my previous reasoning is wrong.\n    # So I must re-examine the sample input.\n    # For the second sample input, p=4, output is 5 6.\n    # Let's see: n=5. How is the maximum unidirectional pairs 6?\n    # According to the note, for p=4, the minimal n is 5. The graph could consist of two components: one of size 3 (C(3,2)=3) and one of size 2 (C(2,2)=1). Total p=4.\n    # Now, the total ordered pairs (u, v), u != v is 5*4=20.\n    # The mutual pairs are 3*2=6 (from the first component) + 2*1=2 (from the second component) = 8. But p is 4, which is the count of unordered pairs. So 2p=8. Thus, total unidirectional pairs is 20 - 8 = 12. But the sample output says 6. So clearly, my previous reasoning is incorrect.\n    # Therefore, I must think again.\n    # Wait, the definition of unidirectional pairs is ordered pairs (u, v) where u != v, there's a path from u to v, and no path from v to u. So for each such pair, it's counted once.\n    # The total number of ordered pairs (u, v) where u != v is n*(n-1).\n    # The number of pairs where u and v are mutually reachable is exactly 2*p (since each unordered pair contributes two ordered pairs).\n    # The number of ordered pairs where there's a path from u to v but not vice versa is equal to the total ordered pairs (n*(n-1)) minus the number of mutual pairs (2p) minus the number of pairs where there is no path in either direction. But how do we account for that?\n    # This seems complicated. However, in the sample input where p=4 and n=5, the output is 6. So let's compute that.\n    # Let me consider the scenario where the graph is made of two components: one of size 3 and one of size 2. Suppose there's an edge from the component of size 3 to the component of size 2. Then, for any u in the first component and v in the second, there's a path from u to v, but not vice versa. So the number of such pairs is 3*2 = 6. Additionally, within the components, there are mutual pairs. So the total unidirectional pairs is 6. Which matches the sample output.\n    # Therefore, the maximum number of unidirectional pairs is the sum over all pairs of components (A, B), where A comes before B in the DAG, of |A| * |B|. So to maximize this sum, we should arrange the components in a linear order, so that each component points to all subsequent components.\n    # Thus, the maximum number of unidirectional pairs is the sum_{i < j} (size_i * size_j), where the sizes are sorted in non-decreasing order.\n    # So the problem reduces to finding the sizes of the components (k_1, k_2, ..., k_m) that sum to n, and sum C(k_i, 2) = p, and then arrange them in a linear order to maximize the sum_{i < j} (k_i * k_j).\n    # Now, the sum_{i < j} k_i * k_j can be computed as [(sum k_i)^2 - sum k_i^2] / 2. Since sum k_i = n, this becomes [n^2 - sum k_i^2]/2.\n    # Therefore, the maximum number of unidirectional pairs is (n^2 - sum_k (k_i^2)) // 2.\n    # But how to compute sum_k (k_i^2) given that the sum C(k_i, 2) = p and sum k_i = n.\n    # Let me think about the way we split p into the k_i's. For example, in the first case where p=3, the k_i is [3]. Then sum k_i^2 is 9. n=3. So (3^2 - 9)/2 = 0/2 = 0, which matches the sample.\n    # For the second sample, p=4, the k_i's are [3, 2]. sum k_i^2 = 9 + 4 = 13. n=5. (25 - 13)/2 = 12/2 = 6, which matches the sample.\n    # So the formula holds. Therefore, the maximum number of unidirectional pairs is (n^2 - sum_k (k_i^2)) // 2.\n    # Therefore, the problem now becomes, after finding the minimal n and the decomposition of p into k_i's, compute sum_k (k_i^2) and use this formula.\n\n    # So how to compute sum_k (k_i^2)? During the process of finding the minimal n, we can track the sum of squares.\n\n    # Re-do the process of finding minimal n, but also track the sum of squares of the k_i's.\n\n    # Let's re-implement the code with tracking the sum of squares.\n\n    # Reset variables\n    n = 0\n    sum_squares = 0\n    remaining_p = p\n    while remaining_p > 0:\n        low = 1\n        high = 2 * 10**5 + 10\n        best_k = 0\n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= remaining_p:\n                best_k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        n += best_k\n        sum_squares += best_k * best_k\n        remaining_p -= best_k * (best_k - 1) // 2\n\n    max_unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`.\n2. **Finding Minimum Nodes**: We determine the minimum number of nodes `n` by decomposing `p` into the sum of combinations of component sizes. This is done using binary search to find the largest possible component size that fits within the remaining value of `p`.\n3. **Calculating Maximum Unidirectional Pairs**: Using the formula derived from the sum of squares of component sizes, we compute the maximum number of unidirectional pairs as `(n^2 - sum_of_squares) // 2`.\n\nThis approach efficiently determines the minimal number of nodes and the maximum number of unidirectional pairs using mathematical insights and binary search.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find the minimal number of nodes\n    # We need to find the minimal n such that sum C(k_i, 2) = p\n    # To minimize n, we want as large as possible k_i's.\n    # So we try to find the largest k such that C(k, 2) <= p\n    # Then subtract and repeat.\n    \n    n = 0\n    remaining_p = p\n    while remaining_p > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining_p\n        low = 1\n        high = 2 * 10**5 + 10  # arbitrary large number\n        best_k = 0\n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= remaining_p:\n                best_k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        n += best_k\n        remaining_p -= best_k * (best_k - 1) // 2\n    \n    # Now calculate the maximum number of unidirectional pairs\n    # The maximum unidirectional pairs is the total possible ordered pairs (u, v), u != v, minus twice the p (since each mutual pair is counted once in p)\n    # But wait, the total number of ordered pairs (u, v) with u != v is n*(n-1)\n    # However, for each mutual pair (u, v) with u < v, there are two ordered pairs: (u, v) and (v, u). So the total mutual pairs count in terms of ordered pairs is 2*p.\n    # The number of unidirectional pairs is total_ordered_pairs - 2*p\n    # But the problem defines unidirectional pairs as (u, v) where u != v, there's a path from u to v but not vice versa.\n    # However, the total number of ordered pairs (u, v) with u != v is n*(n-1)\n    # The number of mutual pairs is 2*p (each unordered pair contributes two ordered pairs)\n    # So the number of unidirectional pairs is total_ordered_pairs - 2*p\n    # But wait, no. Because for each mutual pair (u, v), both directions exist. So the number of ordered pairs that are mutual is 2*p. The rest are either unidirectional or not.\n    # However, the problem says that unidirectional pairs are those where there is a path from u to v but not from v to u. So for each such ordered pair, it's counted once.\n    # Therefore, the total number of unidirectional pairs is (total_ordered_pairs - mutual_pairs) / 1, since mutual pairs are excluded.\n    # Wait, the total number of ordered pairs (u, v) where u != v is n*(n-1). The mutual pairs are those where u and v are in the same SCC. For each such pair, both (u, v) and (v, u) are present. So the number of mutual ordered pairs is 2*p. Thus, the number of unidirectional pairs is total_ordered_pairs - 2*p.\n    # But in our case, the mutual pairs are exactly p unordered pairs, which contribute 2p ordered pairs. So the unidirectional pairs would be total_ordered_pairs - 2p.\n    \n    # However, in our setup, the graph may have multiple SCCs. So the maximum number of unidirectional pairs occurs when the graph is structured such that between different SCCs, there are as many one-way edges as possible.\n    # However, the problem requires that among all minimal node graphs, we choose the one with maximum unidirectional pairs.\n    # To maximize the unidirectional pairs, we should have the SCCs arranged in a DAG where each edge between components is one-way. For example, arrange the components in a linear order, with edges from earlier components to later ones.\n    # In such a case, the number of unidirectional pairs between components is the product of their sizes, multiplied by 2 (since for each pair of nodes u in component A and v in component B, there's a path from u to v if A is before B, and vice versa if B is before A. But if arranged in a DAG, we can have only one direction between components.)\n    # However, this part is more complex. But according to the sample input, when p=3, n=3. The maximum unidirectional pairs is 0, which makes sense because all nodes are in one SCC. So the total ordered pairs is 3*2=6. Mutual pairs are 3*2=6 (since p=3, 2p=6). Thus, unidirectional pairs is 6-6=0.\n    # Similarly, for p=4, n=5. The total ordered pairs is 5*4=20. 2p=8. 20-8=12. But the sample output says 6. Wait, that contradicts. So my previous reasoning is wrong.\n    # So I must re-examine the sample input.\n    # For the second sample input, p=4, output is 5 6.\n    # Let's see: n=5. How is the maximum unidirectional pairs 6?\n    # According to the note, for p=4, the minimal n is 5. The graph could consist of two components: one of size 3 (C(3,2)=3) and one of size 2 (C(2,2)=1). Total p=4.\n    # Now, the total ordered pairs (u, v), u != v is 5*4=20.\n    # The mutual pairs are 3*2=6 (from the first component) + 2*1=2 (from the second component) = 8. But p is 4, which is the count of unordered pairs. So 2p=8. Thus, total unidirectional pairs is 20 - 8 = 12. But the sample output says 6. So clearly, my previous reasoning is incorrect.\n    # Therefore, I must think again.\n    # Wait, the definition of unidirectional pairs is ordered pairs (u, v) where u != v, there's a path from u to v, and no path from v to u. So for each such pair, it's counted once.\n    # The total number of ordered pairs (u, v) where u != v is n*(n-1).\n    # The number of pairs where u and v are mutually reachable is exactly 2*p (since each unordered pair contributes two ordered pairs).\n    # The number of ordered pairs where there's a path from u to v but not vice versa is equal to the total ordered pairs (n*(n-1)) minus the number of mutual pairs (2p) minus the number of pairs where there is no path in either direction. But how do we account for that?\n    # This seems complicated. However, in the sample input where p=4 and n=5, the output is 6. So let's compute that.\n    # Let me consider the scenario where the graph is made of two components: one of size 3 and one of size 2. Suppose there's an edge from the component of size 3 to the component of size 2. Then, for any u in the first component and v in the second, there's a path from u to v, but not vice versa. So the number of such pairs is 3*2 = 6. Additionally, within the components, there are mutual pairs. So the total unidirectional pairs is 6. Which matches the sample output.\n    # Therefore, the maximum number of unidirectional pairs is the sum over all pairs of components (A, B), where A comes before B in the DAG, of |A| * |B|. So to maximize this sum, we should arrange the components in a linear order, so that each component points to all subsequent components.\n    # Thus, the maximum number of unidirectional pairs is the sum_{i < j} (size_i * size_j), where the sizes are sorted in non-decreasing order.\n    # So the problem reduces to finding the sizes of the components (k_1, k_2, ..., k_m) that sum to n, and sum C(k_i, 2) = p, and then arrange them in a linear order to maximize the sum_{i < j} (k_i * k_j).\n    # Now, the sum_{i < j} k_i * k_j can be computed as [(sum k_i)^2 - sum k_i^2] / 2. Since sum k_i = n, this becomes [n^2 - sum k_i^2]/2.\n    # Therefore, the maximum number of unidirectional pairs is (n^2 - sum_k (k_i^2)) // 2.\n    # But how to compute sum_k (k_i^2) given that the sum C(k_i, 2) = p and sum k_i = n.\n    # Let me think about the way we split p into the k_i's. For example, in the first case where p=3, the k_i is [3]. Then sum k_i^2 is 9. n=3. So (3^2 - 9)/2 = 0/2 = 0, which matches the sample.\n    # For the second sample, p=4, the k_i's are [3, 2]. sum k_i^2 = 9 + 4 = 13. n=5. (25 - 13)/2 = 12/2 = 6, which matches the sample.\n    # So the formula holds. Therefore, the maximum number of unidirectional pairs is (n^2 - sum_k (k_i^2)) // 2.\n    # Therefore, the problem now becomes, after finding the minimal n and the decomposition of p into k_i's, compute sum_k (k_i^2) and use this formula.\n\n    # So how to compute sum_k (k_i^2)? During the process of finding the minimal n, we can track the sum of squares.\n\n    # Re-do the process of finding minimal n, but also track the sum of squares of the k_i's.\n\n    # Let's re-implement the code with tracking the sum of squares.\n\n    # Reset variables\n    n = 0\n    sum_squares = 0\n    remaining_p = p\n    while remaining_p > 0:\n        low = 1\n        high = 2 * 10**5 + 10\n        best_k = 0\n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= remaining_p:\n                best_k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        n += best_k\n        sum_squares += best_k * best_k\n        remaining_p -= best_k * (best_k - 1) // 2\n\n    max_unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 2839,
        "thoughts_token_count": 1024
    }
}