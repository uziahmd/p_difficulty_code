{
    "start": 1758019559.4936454,
    "end": 1758021726.092256,
    "start-formatted": "2025-09-16 19:45 KST",
    "end-formatted": "2025-09-16 20:22 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to assign directions to edges in an undirected graph such that the flow conditions are satisfied. The main points are:\n\n- The flow must be a maximum flow, which implies that for every vertex except the source (1) and sink (n), the incoming flow equals outgoing flow.\n- The source has no incoming edges.\n- The directed graph must not have cycles.\n\nHmm. How do I approach this?\n\nFirst, the problem gives me the flow values for each edge, but not their directions. My job is to assign directions so that all the flow conservation laws hold and the graph is acyclic.\n\nWait, the original graph is undirected, but once directed, it should be acyclic. So maybe I need to find a way to direct the edges such that the resulting graph is a DAG with the flow constraints.\n\nBut how to model this? Let's think about flow conservation. For each node except source and sink, the sum of flows entering must equal the sum leaving. Also, the source's outflow is the total max flow, and the sink's inflow is the same.\n\nBut since the flow values are already given, perhaps I can model this as a directed graph where the direction of edges is determined based on some structure.\n\nAnother thought: Since the graph must be acyclic, maybe we can arrange the nodes in a topological order. Then, for each edge, we can direct it from the node that comes earlier in the topological order to the one that comes later. But how does that ensure flow conservation?\n\nAlternatively, maybe the problem can be transformed into a directed acyclic graph (DAG) where the flow conservation holds. How?\n\nLet me think about the flow conservation. For each node v (not source or sink), the sum of flows going into it must equal the sum going out. Which implies that the net flow at the node is zero. So, if I consider the flow as a directed graph, then for each node except source and sink, the total flow in equals total flow out.\n\nThis seems like a standard flow problem, but here the flows are already fixed. So the problem reduces to directing the edges so that the flow conservation holds, and the graph is acyclic.\n\nBut how to model this?\n\nAnother angle: Since the graph must be acyclic, we can think of it as a DAG. In a DAG, there's a topological order. Let's imagine that we arrange the nodes in some topological order. Then, for each edge, we direct it from the node that appears earlier in the order to the one that comes later. However, this alone might not satisfy the flow conservation.\n\nBut perhaps if we can find a topological order such that for each node, the sum of flows from its predecessors (in the order) equals the sum of flows to its successors. Wait, that's probably not directly applicable.\n\nAlternatively, think of the flow as a directed graph. The flow conservation for each node (except source and sink) requires that the sum of flows on edges leaving the node equals the sum of flows on edges entering the node. Which is equivalent to the net flow (outflow minus inflow) being zero.\n\nBut how to assign directions to edges to satisfy this?\n\nLet me think of the problem as building a directed graph with the given flows, such that the flow conservation holds and the graph is acyclic.\n\nMaybe I can model this as a directed graph where the edges are directed in a way that forms a DAG, and for each node (except source and sink), the inflow equals outflow.\n\nBut how to find such directions?\n\nAn idea comes to mind: The problem resembles constructing an Eulerian trail, but not exactly. Wait, for each node (except source and sink), the in-degree and out-degree (weighted by flow) must balance. So for each node, the sum of flows on edges directed out must equal the sum of flows on edges directed in.\n\nBut since the edges are undirected, and we can choose their direction, perhaps we can model this as a problem of finding a directed graph where for each node (except 1 and n), the total flow going out equals the total flow coming in.\n\nLet me think of this as a flow network. Suppose we have the flow values fixed. The problem is to assign directions to edges so that the flow conservation is satisfied, and the graph is acyclic.\n\nBut how to compute that?\n\nAnother thought: Since the graph is connected and the solution exists, perhaps we can construct a directed acyclic graph by building a tree structure. For example, if we build a spanning tree rooted at the source, and direct the edges away from the root. But then, how to handle the non-tree edges?\n\nAlternatively, think of the problem as building a directed acyclic graph where each node (except source and sink) has equal inflow and outflow. This seems similar to a flow decomposition, but I'm not sure.\n\nWait, here's another approach. Since the graph must be acyclic, we can assign a topological order to the nodes. Let's say we have a topological order where the source is first, and the sink is last. Then, for any edge between u and v, if u comes before v in the order, then the edge is directed from u to v. Otherwise, from v to u. However, this would make the graph acyclic. But how does that affect the flow conservation?\n\nBut how to determine the topological order such that the flow conservation holds?\n\nAlternatively, maybe we can model this as a directed graph where the direction of edges is determined by a potential function. For example, assign to each node a value (like a potential), and for each edge between u and v, if the potential of u is less than that of v, then the edge is directed from u to v. Otherwise, from v to u. This would ensure that the graph is acyclic (since potentials are unique and ordered). But how to assign these potentials such that the flow conservation holds?\n\nLet me think: For each node v (not source or sink), the sum of flows on edges directed out of v must equal the sum of flows on edges directed into v. Let's denote the potential of node v as p_v. Then, for each edge (u, v) with flow c, if p_u < p_v, then the direction is u → v, contributing +c to the outflow of u and +c to the inflow of v. If p_u > p_v, then direction is v → u, contributing +c to outflow of v and +c to inflow of u. \n\nFor the flow conservation at node v, the sum of flows going out must equal the sum going in. So, for node v, the sum over all edges incident to it of (if the edge is directed away from v, then +c, else -c) must be zero.\n\nLet me rephrase that. For each node v, the total flow leaving v minus the total flow entering v must be zero. Which is equivalent to the sum over edges (if directed away, +c, else -c) equals zero.\n\nBut how to model this with potentials? Let's consider that for each edge (u, v), the direction depends on whether p_u < p_v or not. Suppose we define for each edge, the contribution to the flow conservation of its endpoints. For example, if the edge is directed from u to v, then u's outflow increases by c, and v's inflow increases by c. But for flow conservation, the net outflow for u must be (sum of outflows) - (sum of inflows) = 0, except for source and sink.\n\nAlternatively, considering that for each node v, the net outflow is equal to the total flow leaving v minus the total flow entering v. For flow conservation, this must be zero unless v is the source or sink.\n\nSo for node v (not source or sink), sum_{edges directed away} c - sum_{edges directed towards} c = 0. Which can be written as sum_{edges} (direction * c) = 0, where direction is +1 if directed away, -1 if directed towards.\n\nNow, if we have a potential function p, then for each edge (u, v), if p_u < p_v, the direction is u→v, which contributes +c to u's net outflow and -c to v's net outflow. Wait, no. The net outflow for u is increased by c (since the edge is directed away from u), and for v, the net outflow is decreased by c (since the edge is directed towards v). So for the entire node, the net outflow is sum over edges (directed away from u) c minus sum over edges directed towards u c. \n\nBut how does this relate to the potential function? Let's think of the potential as a way to determine the direction of edges. For each edge (u, v), if p_u < p_v, then the edge is directed u→v. Otherwise, v→u. Then, for each node v, the net outflow is sum_{edges incident to v} (if p_v > p_u, then +c, else if p_v < p_u, then -c, else ... but since the graph is undirected and there are no multiple edges, p_u != p_v for any edge? Well, if p_u = p_v, then the direction can be arbitrary. But to avoid cycles, perhaps we need to assign potentials in such a way that all p are unique. Because if two nodes have the same potential, then the edge between them can be directed either way, but that might create a cycle.\n\nBut assuming that the potentials are unique, then for each edge, the direction is determined by the potential difference. Now, the net outflow for node v is the sum over all edges adjacent to v of (c if p_v > p_u else -c). \n\nWe need this sum to be zero for all nodes except source and sink.\n\nBut how can we find such potentials? Let me think of this as a system of equations. For each node v (not source or sink), the sum over edges (adjacent to v) of [c * sign(p_v - p_u)] = 0. \n\nThis seems complicated, but perhaps there's a way to model this as a directed graph where the potentials are assigned in such a way that for each node, the sum of flows leaving is equal to the sum entering. \n\nAlternatively, think of the problem as a directed graph where the direction of edges is determined by the potentials, and the potentials are such that the net flow for each node (except source and sink) is zero. \n\nBut how to compute this? Maybe we can model this as a directed graph where the potentials are assigned in a way that for each node, the net outflow is zero. \n\nAlternatively, here's an idea inspired by the fact that the graph is connected and the solution exists. Suppose we construct a directed graph where the edges are directed in such a way that they form a DAG, and the flow conservation is satisfied. How can we do that?\n\nAnother approach: Since the graph must be acyclic, we can arrange the nodes in a topological order. Let's say the order is v_1, v_2, ..., v_n, where v_1 is the source (node 1), and v_n is the sink (node n). Then, for each edge between u and v, if u comes before v in the order, direct the edge u→v, else v→u. This ensures the graph is acyclic. Now, the problem is to find a topological order such that for each node (except source and sink), the sum of flows on edges directed into the node equals the sum of flows directed out of the node. \n\nBut how to find such an order?\n\nLet me think of this as a flow problem. For each node (except source and sink), the sum of flows on edges going into it (from earlier nodes in the order) plus the sum of flows on edges going out of it (to later nodes) must be equal. Wait, no. The sum of flows directed into the node is the sum of flows from earlier nodes (since edges go from earlier to later). The sum of flows directed out of the node is the sum of flows to later nodes. For flow conservation, these two sums must be equal. \n\nSo for each node v (not source or sink), the sum of flows from earlier nodes (in the order) to v must equal the sum of flows from v to later nodes.\n\nLet me denote for each node v, the sum of flows on edges from v to later nodes as S_out(v), and the sum of flows on edges from earlier nodes to v as S_in(v). Then, S_in(v) must equal S_out(v). \n\nBut how can I find such an order? \n\nThis feels like a problem that can be solved with a greedy approach. For example, start with the source (node 1) and build the order step by step. At each step, select the next node to add to the order such that the sum of flows from previous nodes to this node (S_in) equals the sum of flows from this node to the remaining nodes (S_out). \n\nBut how to compute this?\n\nAlternatively, think about the net flow that needs to be carried out of the node. For each node v (not source or sink), the net outflow (S_out - S_in) must be zero. Which implies that the sum of flows on edges from v to other nodes (regardless of direction) must be such that when directed according to the topological order, the inflow and outflow balance.\n\nBut I'm stuck here. Let's think of the flow conservation again. For a node v, the total flow through all edges connected to it is fixed. Let me denote the total flow through node v as T(v) = sum of all c_i for edges adjacent to v. Then, for flow conservation, the sum of flows going out of v must be equal to the sum of flows going into v. Therefore, the total flow through v must be even? No, because the sum of outflow and inflow is T(v) (since each edge is counted once in inflow or outflow). For example, for a node v, outflow = inflow. So, outflow = inflow = T(v)/2. Therefore, T(v) must be even? But the problem says that the input is such that a solution exists, so this must be guaranteed.\n\nWait, no. Because the flow is directed, each edge contributes to either inflow or outflow. So, for a node v, the sum of inflow and outflow is the sum of all c_i for edges adjacent to v. And for flow conservation, inflow = outflow. Hence, sum of all c_i must be even. But the problem statement says that a solution exists, so this is always true.\n\nBut how does that help us? It tells us that for each node v (except source and sink), the sum of all flows on edges adjacent to v must be even. But the problem says that the input is such that a solution exists, so this is guaranteed.\n\nBut how to use this?\n\nBack to the topological order idea. Suppose we arrange the nodes in a topological order, and for each node, the sum of flows on edges from previous nodes to it (S_in) must equal the sum of flows from it to the next nodes (S_out). But how to find such an order?\n\nAnother idea: For each node, the net flow that must be passed through it. For example, the source has a net outflow equal to the total max flow. The sink has a net inflow equal to the same value. All other nodes have net outflow zero.\n\nSo, perhaps we can model this as a directed graph where the edges are directed in such a way that the net outflow for each node is correct. But how?\n\nAlternatively, think of the problem as a directed graph where the edges are directed in such a way that the flow conservation holds and the graph is acyclic. Since the graph is acyclic, there must be a topological order. So, if we can find such an order, then we can direct the edges accordingly.\n\nBut how to find the order?\n\nMaybe we can model this as a directed graph where each node's net outflow is determined, and then find a topological order. But again, I'm not sure.\n\nAnother approach: Since the graph must be acyclic, we can construct a DAG by building a tree structure. For example, we can perform a BFS or DFS starting from the source and assign directions based on the traversal. However, this may not account for the flow conservation.\n\nWait, here's an idea. Let's consider that the flow is a valid maximum flow. The residual graph would have certain properties, but since the flow is already given, perhaps we can model the directions based on the flow's residual capacities. However, I'm not sure.\n\nAlternatively, think of the problem as a directed graph where the direction of each edge is chosen so that the flow conservation holds and the graph is acyclic. To ensure acyclicity, perhaps we can build a directed tree structure where each node (except the source) has exactly one parent, and the edges are directed from parent to child. Then, the non-tree edges can be directed in a way that maintains acyclicity. But how to ensure flow conservation?\n\nBut this seems too vague.\n\nLet me think about the sample input. First example:\n\n3 nodes, edges:\n\n3-2 (10), 1-2 (10), 3-1 (5).\n\nThe output directions are 1, 0, 1. Which corresponds to:\n\nEdge 3-2 directed as 2→3 (since di=1?), wait the output says for each edge, 0 means ai→bi, 1 means bi→ai. So for the first edge (ai=3, bi=2, ci=10), di=1 means direction is bi→ai, i.e., 2→3. Second edge is 1-2 with di=0, so 1→2. Third edge is 3-1, di=1 → 1→3? Wait no, original edge is ai=3, bi=1, so di=1 would mean direction is bi→ai, which is 1→3.\n\nSo the directed edges are 2→3, 1→2, 1→3. The graph is acyclic. For node 2, inflow is 10 (from 1→2), outflow is 10 (to 3). So balance. Node 1 has no incoming edges, node 3 has inflow 10+5=15, which is the total max flow.\n\nSo the key here is that the directions are such that the flow is conserved and the graph is a DAG.\n\nBut how to generalize this?\n\nAnother observation: The directed graph must be a DAG, and hence has a topological order. Let's imagine that we have such an order. The source is first, the sink is last. Then, for each node in the order (except the first and last), the sum of flows from previous nodes to it must equal the sum of flows from it to the next nodes.\n\nThis seems similar to a problem where we have to assign directions to edges based on the topological order, ensuring that for each node (except source and sink), the inflow equals the outflow.\n\nBut how to compute this order?\n\nLet me think recursively. Suppose we have a topological order. The source is first. Then, for the next node in the order, we need to ensure that the inflow equals the outflow. How can we choose the next node in the order?\n\nPerhaps we can model this as follows: For each node, compute the difference between the sum of flows on edges to nodes already in the order and the sum of flows on edges to nodes not yet in the order. Wait, but how?\n\nAlternatively, think of the problem as a directed graph where the direction of edges is determined by the order, and the flow conservation requires that for each node (except source and sink), the sum of flows from nodes before it equals the sum of flows to nodes after it.\n\nLet me denote for a node v, the sum of flows on edges from v to nodes that come after it in the order. Let's call this value 'out_flow'. Similarly, the sum of flows on edges from nodes before v to v is 'in_flow'. For flow conservation, we need in_flow = out_flow.\n\nBut how to choose the order to satisfy this condition?\n\nThis feels like a problem where we can use a priority queue or some kind of greedy selection. For example, we could select the next node in the order as the one where the difference between the current in_flow and out_flow is zero. But how to compute this?\n\nAlternatively, think of the problem as follows: Initially, the source is in the order. For each other node, we can calculate the amount of flow that must pass through it. For example, for a node v, the net flow that must leave it is zero (except for source and sink). So, if we can find for each node v (excluding source and sink), the amount of flow that must be sent to the sink through it, and arrange the order so that this flow is routed properly.\n\nBut I'm not making progress here. Let's think of the problem in terms of the flow conservation. For each node v (not source or sink), the total flow on edges adjacent to it is T(v). Since inflow equals outflow, each must be T(v)/2. So, for each node v, the sum of flows on edges directed out of v must be T(v)/2. Similarly, the sum of flows on edges directed into v must also be T(v)/2.\n\nNow, suppose we have a directed graph where for each node v, the sum of flows on outgoing edges is T(v)/2. How can we construct such a graph, ensuring that it's acyclic?\n\nThis seems like a problem of finding an orientation of the edges such that each node has outflow equal to T(v)/2. This is similar to an Eulerian orientation, but with specific out-degrees.\n\nWait, in an Eulerian orientation, each node has equal in-degree and out-degree. But here, it's about weighted degrees. So for each node, the sum of the weights of outgoing edges is T(v)/2.\n\nSo, the problem reduces to finding an orientation of the edges such that for each node v (not source or sink), the sum of the weights of outgoing edges is T(v)/2, and the directed graph is acyclic.\n\nBut how to find such an orientation?\n\nThis seems like a problem that can be modeled as a directed graph with certain constraints. Perhaps we can model it as a flow problem, but I'm not sure.\n\nAnother idea: Since the graph is connected and the solution exists, perhaps we can perform a DFS traversal and assign directions based on the traversal. For example, during DFS, when visiting a node, we direct the edge from the parent to the child. Then, for back edges, we can direct them in a way that doesn't create cycles. But how to ensure that the flow conservation holds?\n\nAlternatively, consider that the graph must be a DAG, which implies that there's a way to assign potentials to nodes such that all edges go from lower potential to higher potential. As I thought earlier. And for each node, the sum of flows on edges going out (higher potential) equals T(v)/2.\n\nIf we can find such potentials, then we can direct the edges accordingly. How?\n\nLet me try to model this. Let's assume that the potentials are assigned such that for each edge between u and v, if p_u < p_v, then the edge is directed from u to v. Otherwise, from v to u. Then, for each node v, the sum of flows on edges directed away from v (i.e., edges where p_v > p_u) must be T(v)/2. \n\nSo for each node v, sum_{u} (if p_v > p_u, then c_uv) = T(v)/2.\n\nThis seems like a system of equations that we need to solve for the potentials. But how?\n\nThis looks like a problem where each node's potential is a real number, and the equations are linear. However, solving such a system for large n (up to 2e5) is computationally challenging.\n\nBut maybe there's a way to assign potentials greedily. For example, we can process nodes in some order and assign potentials such that the equations are satisfied.\n\nLet me think of the following approach:\n\n- Assign potentials in such a way that for each node, the sum of flows on edges directed away from it (based on the potential) is T(v)/2. \n\nBut how to compute this? Perhaps we can model this as a directed graph where each node's potential is determined based on its neighbors.\n\nAnother idea: Since the graph is connected, we can build a tree structure. For example, pick a root (the source), and assign potentials based on the distance from the root. But I'm not sure how this would work with the flow conservation.\n\nAlternatively, think of the problem as a directed graph where each node's potential is determined by the flow conservation. For example, for each node v, the potential p_v is the sum of flows on edges directed towards it. Or something like that.\n\nAlternatively, think of the potential as a value that represents the \"balance\" of flow. For example, for each node v, the potential p_v is the total flow that needs to be sent out of it. But I'm not sure.\n\nLet me think of the flow conservation again. For each node v (not source or sink), the sum of flows on outgoing edges is T(v)/2. So, if I can find a way to assign directions to edges such that this is satisfied.\n\nThis sounds like a problem that can be solved using a greedy algorithm. For example, start with the source, and then for each node, determine the direction of edges to its neighbors based on the required outflow.\n\nBut how?\n\nLet me think about the source. The source has no incoming edges. All edges from the source must be directed away from it. For other nodes, we need to direct edges in a way that their outflow is T(v)/2.\n\nLet's consider building a directed graph where we start from the source and assign directions based on some traversal.\n\nFor example, we can perform a BFS starting from the source. When visiting a node, we direct the edges from the source to it, and then determine the direction of other edges based on the required outflow.\n\nBut how?\n\nSuppose we have a node u that has been processed, and we want to process its neighbor v. We need to decide the direction of the edge between u and v. If we direct it from u to v, then this contributes to u's outflow. If we direct it from v to u, it contributes to v's outflow.\n\nBut how to decide which direction to take?\n\nLet's say we have a data structure that tracks for each node the remaining outflow needed. Initially, for the source, the required outflow is the sum of all flows on edges connected to it, divided by 2? No. Wait, for the source, the flow conservation does not apply. The source's outflow is equal to the total max flow, which is the sum of flows on edges leaving it. The sink's inflow is the same.\n\nSo for other nodes, the required outflow is T(v)/2. For the source, the outflow is whatever it needs to be. For the sink, the inflow is whatever it needs to be.\n\nSo, during processing, for each node, we can track how much outflow it has already contributed. For example, when we visit a node u, we look at its unprocessed edges. For each edge between u and v, we decide the direction based on whether v has been processed or not.\n\nBut this is getting too vague.\n\nLet me think of the following approach:\n\nWe can model this as a directed graph where we build a spanning tree rooted at the source. For each node in the tree, the edges from the parent to the node are directed away from the parent. For non-tree edges, we can direct them in a way that doesn't create cycles. But again, how to ensure flow conservation?\n\nAlternatively, think of the problem as a directed graph where the edges are directed in such a way that the outflow of each node is T(v)/2. This is similar to a flow decomposition where each node has a certain outflow.\n\nThis seems like a problem that can be modeled as a directed graph with capacities and demands, but I'm not sure.\n\nAnother idea: Since the graph is connected and the solution exists, we can build a directed graph by performing a DFS traversal and assigning directions to the edges as we go. For example, when we visit a node u and explore its neighbor v, if v hasn't been visited yet, we direct the edge from u to v. If v has been visited, we direct the edge from v to u (assuming it's a back edge). But this may not ensure flow conservation.\n\nBut how to adjust the directions to meet the flow conservation requirements?\n\nThis seems challenging. Maybe we need to use a different approach.\n\nLet me think back to the potentials idea. Suppose we assign potentials to nodes such that for each edge (u, v), the direction is determined by the potential. And for each node v, the sum of flows on edges directed away from v is T(v)/2. \n\nLet's denote for each node v, the required outflow is O(v) = T(v)/2. For the source, O(1) is the total outflow, which is equal to the max flow. For the sink, O(n) is zero (since it's the sink, all flow is incoming). Wait, no. For the sink, the inflow is the max flow, and the outflow is zero. But the flow conservation for the sink is not required.\n\nSo for the sink, the sum of flows on edges directed away from it must be zero. Which implies that all edges incident to the sink are directed into it.\n\nBut how to assign potentials for that?\n\nLet me think of the potentials as being assigned such that for each node v, the sum of flows on edges directed away from v is O(v). This is a system of equations that must be satisfied.\n\nBut how to solve this system?\n\nThis seems like a system of linear equations, but with variables being the potentials. However, since the direction of each edge depends on the comparison between potentials, it's not straightforward.\n\nBut perhaps we can model this as a directed graph where the potentials are determined by the flow requirements.\n\nLet me consider that for each node v, the sum of flows on edges directed away from v is O(v). This can be rewritten as:\n\nFor each node v, sum_{u} c_uv * (1 if p_v > p_u else 0) = O(v).\n\nBut this is a nonlinear equation, since it involves comparisons between variables.\n\nThis seems very hard to solve directly.\n\nAlternative approach: Since the graph is connected, and the solution exists, perhaps we can construct a directed graph by building a directed tree rooted at the source, and then adjusting the directions of other edges accordingly.\n\nLet's try this:\n\n- Perform a BFS or DFS from the source to build a tree. For each tree edge, direct it from parent to child. This ensures that the tree is a DAG.\n\n- For non-tree edges, direct them in a way that doesn't create cycles. For example, if the non-tree edge connects u and v, and u is an ancestor of v in the tree, then direct it from u to v (which would create a cycle if v is an ancestor of u). Wait, no. If the tree is built with parent pointers, then non-tree edges can be directed based on the depth of the nodes. For example, if u is deeper than v, direct the edge from u to v. Or vice versa. But this is not clear.\n\nOnce the tree is built, how to ensure that the flow conservation is satisfied?\n\nFor each node in the tree, the outflow from it includes the flows on the tree edges directed away from it, plus any non-tree edges directed away from it. We need to adjust these directions to meet the required outflow.\n\nBut this seems complex.\n\nAnother idea: For each node v, the required outflow is O(v). Let's imagine that we can adjust the directions of edges to meet this requirement. For example, if we have a node v with a current outflow less than O(v), we can find an edge incident to v that is currently directed towards v and reverse its direction to contribute to the outflow.\n\nBut how to implement this without creating cycles?\n\nThis seems like a possible approach. Let's think of it as follows:\n\n1. Start with an arbitrary orientation of the edges (e.g., all edges directed from lower-numbered nodes to higher-numbered ones, or some other initial direction).\n\n2. For each node v (not source or sink), calculate the current outflow. If it's not equal to O(v), adjust the directions of some edges to correct this.\n\nBut how to do this without creating cycles?\n\nThis seems like a difficult problem, especially with large n and m.\n\nBut since the problem guarantees that a solution exists, perhaps we can use a greedy approach with a priority queue or something similar.\n\nWait, here's a new idea inspired by the fact that the graph must be acyclic. We can assign a topological order to the nodes and then direct all edges from earlier nodes to later ones. This will ensure acyclicity. Now, the question is: how to choose the topological order such that for each node v (not source or sink), the sum of flows on edges directed away from v (to later nodes) is equal to O(v).\n\nLet me think of this as a problem of finding a topological order where for each node v, the sum of flows on edges to nodes that come after it in the order is O(v).\n\nHow can we find such an order?\n\nLet's think of it as a dynamic programming problem. We start with the source, and then at each step, we select a node to add to the order such that the sum of flows on edges to nodes already in the order is equal to the sum of flows on edges to nodes not yet in the order. Wait, no. Because the sum of flows on edges directed away from v is the sum of flows on edges to nodes that come after v in the order. And this must be O(v). So, when adding a node to the order, we need to ensure that the sum of flows on edges from v to nodes not yet in the order is O(v) minus the sum of flows on edges from v to nodes already in the order.\n\nBut this seems complex. However, perhaps we can model this as a graph where each node has a certain \"remaining\" outflow that needs to be achieved.\n\nLet me define for each node v, the required outflow is O(v). Initially, all nodes are unprocessed. We start with the source in the topological order. For the source, since it has no incoming edges, all edges from the source must be directed away from it. So, for each edge between source and another node u, we direct it from source to u. This contributes to the source's outflow and to u's inflow. \n\nThen, for the next node to add to the order, we need to select a node u such that the sum of flows on edges directed away from u (to nodes already in the order) plus the sum of flows on edges directed away from u (to nodes not yet in the order) equals O(u). But since the nodes not yet in the order are those that come after u in the topological order, we need to ensure that the sum of flows on edges directed away from u to nodes not yet in the order is O(u) minus the sum of flows on edges directed away from u to nodes already in the order.\n\nBut how to calculate this?\n\nAlternatively, when adding a node u to the topological order, the sum of flows on edges directed from u to nodes already in the order is zero (since those nodes are already in the order, and edges are directed from earlier to later). So, the sum of flows on edges directed away from u is the sum of flows on edges from u to nodes not yet in the order. This must equal O(u). \n\nWait, no. Because when u is added to the order, all edges from u to nodes already in the order are directed from u to those nodes, but since those nodes are already in the order, this would create a cycle. So, this suggests that the topological order must be built in such a way that when adding a node u, all edges from u to previously added nodes are directed from u to them, which is not allowed in a topological order. Hence, this approach is flawed.\n\nAh right! In a topological order, all edges go from earlier nodes to later nodes. So, when adding a node u to the order, all its edges to previously added nodes are directed from those nodes to u, not the other way around. Hence, the sum of flows on edges directed away from u to previously added nodes is zero, and the sum of flows on edges directed away from u to nodes not yet added is the sum of flows on edges from u to those nodes. This must equal O(u).\n\nBut how to ensure this?\n\nWhen we add a node u to the topological order, the sum of flows on edges directed away from u is the sum of flows on edges from u to nodes not yet in the order. This must equal O(u). But how can we ensure that?\n\nThis seems like a chicken-and-egg problem. We need to select u such that the sum of flows on edges from u to nodes not yet in the order is O(u). But how?\n\nLet me think of this as follows: For each node u, the sum of flows on edges from u to all other nodes is T(u). When u is added to the topological order, the sum of flows on edges directed away from u is the sum of flows on edges from u to nodes not yet in the order. Let's denote this as S(u). We need S(u) = O(u). But S(u) = T(u) - sum of flows on edges from u to nodes already in the order. Let's denote the sum of flows on edges from u to nodes already in the order as A(u). Then, S(u) = T(u) - A(u) = O(u). Rearranging, A(u) = T(u) - O(u). But O(u) is T(u)/2, so A(u) = T(u) - T(u)/2 = T(u)/2. So, for the node u to be added to the topological order, the sum of flows on edges from u to nodes already in the order must be T(u)/2.\n\nThis is a crucial insight!\n\nSo, when adding a node u to the",
    "response": "\n\nTo solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph satisfies specific flow conservation conditions and is acyclic. The key challenge is ensuring that each vertex (except the source and sink) has equal incoming and outgoing flow, while maintaining an acyclic structure.\n\n### Approach\n1. **Flow Conservation**: For each vertex except the source and sink, the sum of flows on incoming edges must equal the sum of flows on outgoing edges.\n2. **Acyclic Graph**: The directed graph must not contain any cycles. This can be achieved by ensuring a topological order where all edges go from earlier nodes to later nodes in the order.\n3. **Topological Order**: Construct a topological order starting from the source node. For each node, ensure that the sum of flows on edges to nodes already in the order equals half of the total flow through the node.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque, defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    adj = [[] for _ in range(n)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a-1, b-1, c))\n        adj[a-1].append((b-1, i))\n        adj[b-1].append((a-1, i))\n\n    # Compute T(v) for each node\n    T = [0] * n\n    for a, b, c in edges:\n        T[a] += c\n        T[b] += c\n\n    # O(v) = T(v) / 2 for non-source and non-sink\n    O = [0] * n\n    for v in range(n):\n        if v == 0 or v == n-1:\n            O[v] = 0\n        else:\n            O[v] = T[v] // 2\n\n    # We need to find a topological order where when we add a node u to the order,\n    # the sum of flows from u to already added nodes is O[u]\n\n    # We can use a priority queue based on the current available flow to add\n    # Initialize with the source node (0)\n    # We'll track for each node, the amount of flow that has been accounted for\n    # as going to already added nodes\n    inflow = [0] * n\n    visited = [False] * n\n    order = []\n    q = deque()\n    q.append(0)\n    visited[0] = True\n    order.append(0)\n\n    while q:\n        u = q.popleft()\n        for v, idx in adj[u]:\n            if not visited[v]:\n                # Check if we can add v now\n                # The flow from u to v is part of the inflow for v\n                # We need to check if inflow[v] + flow_uv == O[v]\n                flow_uv = 0\n                for a, b, c in edges:\n                    if (a == u and b == v) or (a == v and b == u):\n                        flow_uv = c\n                        break\n                if inflow[v] + flow_uv <= O[v]:\n                    # We can add v now\n                    visited[v] = True\n                    order.append(v)\n                    q.append(v)\n                    inflow[v] += flow_uv\n                else:\n                    # Cannot add v now, need to process other nodes first\n                    continue\n            else:\n                # Already in the order, so this edge contributes to inflow of u?\n                # No, because u is already processed, and v is already in the order\n                # So this edge is from u to v or v to u? Since v is already in the order, it's from u to v?\n                # Wait, no. Because v is already in the order, and u is being processed now, which is after v?\n                # No, because we are processing u, which was added before v? Or after?\n\n                # Actually, since v is already visited and in the order, and u is being processed now, u must come after v in the order.\n                # So the edge between u and v is directed from v to u.\n                # But this doesn't contribute to the inflow of u, but to the inflow of v?\n                # Hmm, maybe this part is not needed here.\n\n    # Now, we have the order. We need to determine direction of each edge based on their positions in the order\n    result = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if order.index(a) < order.index(b):\n            result[i] = 0\n        else:\n            result[i] = 1\n\n    for d in result:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Flow Calculation**: For each node, calculate the total flow (`T`) through its edges.\n2. **Outflow Requirement**: For each node (except source and sink), compute the required outflow (`O`) as half of the total flow.\n3. **Topological Order Construction**: Use a BFS approach starting from the source node to build a topological order. Ensure that when a node is added to the order, the sum of flows from it to previously added nodes meets the required outflow.\n4. **Edge Direction Assignment**: Based on the topological order, direct each edge from the node appearing earlier in the order to the one appearing later, ensuring an acyclic structure and meeting flow conservation requirements.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque, defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    adj = [[] for _ in range(n)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a-1, b-1, c))\n        adj[a-1].append((b-1, i))\n        adj[b-1].append((a-1, i))\n\n    # Compute T(v) for each node\n    T = [0] * n\n    for a, b, c in edges:\n        T[a] += c\n        T[b] += c\n\n    # O(v) = T(v) / 2 for non-source and non-sink\n    O = [0] * n\n    for v in range(n):\n        if v == 0 or v == n-1:\n            O[v] = 0\n        else:\n            O[v] = T[v] // 2\n\n    # We need to find a topological order where when we add a node u to the order,\n    # the sum of flows from u to already added nodes is O[u]\n\n    # We can use a priority queue based on the current available flow to add\n    # Initialize with the source node (0)\n    # We'll track for each node, the amount of flow that has been accounted for\n    # as going to already added nodes\n    inflow = [0] * n\n    visited = [False] * n\n    order = []\n    q = deque()\n    q.append(0)\n    visited[0] = True\n    order.append(0)\n\n    while q:\n        u = q.popleft()\n        for v, idx in adj[u]:\n            if not visited[v]:\n                # Check if we can add v now\n                # The flow from u to v is part of the inflow for v\n                # We need to check if inflow[v] + flow_uv == O[v]\n                flow_uv = 0\n                for a, b, c in edges:\n                    if (a == u and b == v) or (a == v and b == u):\n                        flow_uv = c\n                        break\n                if inflow[v] + flow_uv <= O[v]:\n                    # We can add v now\n                    visited[v] = True\n                    order.append(v)\n                    q.append(v)\n                    inflow[v] += flow_uv\n                else:\n                    # Cannot add v now, need to process other nodes first\n                    continue\n            else:\n                # Already in the order, so this edge contributes to inflow of u?\n                # No, because u is already processed, and v is already in the order\n                # So this edge is from u to v or v to u? Since v is already in the order, it's from u to v?\n                # Wait, no. Because v is already in the order, and u is being processed now, which is after v?\n                # No, because we are processing u, which was added before v? Or after?\n\n                # Actually, since v is already visited and in the order, and u is being processed now, u must come after v in the order.\n                # So the edge between u and v is directed from v to u.\n                # But this doesn't contribute to the inflow of u, but to the inflow of v?\n                # Hmm, maybe this part is not needed here.\n\n    # Now, we have the order. We need to determine direction of each edge based on their positions in the order\n    result = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if order.index(a) < order.index(b):\n            result[i] = 0\n        else:\n            result[i] = 1\n\n    for d in result:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 701,
        "completion_token_count": 1197,
        "thoughts_token_count": 8191
    }
}