{
    "start": 1758309292.4315956,
    "end": 1758309351.4771006,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about the problem. Let's denote x = a +k and y = b +k. Then, since k is non-negative, x and y are at least a and b respectively, but since k can be added, they can be larger. But wait, since a and b are given, maybe we can find a relation between x and y. Let's see: since x = a +k and y = b +k, subtracting gives y - x = b - a. So, the difference between y and x is fixed. Let's say d = b - a. If a and b are equal, then x and y are equal, so their LCM is x (since LCM(x,x) = x). So in that case, k=0 is the answer.\n\nBut when a and b are different, let's assume without loss of generality that a < b. Then, d = b -a is positive. So, y = x + d. So the problem becomes finding x such that x >= a (since k >=0 implies x = a +k >=a) and y = x +d, and the LCM of x and x+d is minimized.\n\nSo the problem reduces to finding x >= a, such that LCM(x, x +d) is minimized. Then, once x is found, k is x -a (since x = a +k => k = x -a).\n\nBut how do I find this x?\n\nThe LCM of two numbers x and y is (x*y)/gcd(x,y). So for x and x +d, their LCM is x*(x +d)/gcd(x, x +d). Since gcd(x, x +d) = gcd(x, d). Because gcd(x, x +d) = gcd(x, d).\n\nSo the LCM is x*(x +d)/g, where g = gcd(x, d).\n\nSo our goal is to minimize x*(x +d)/g, where g is gcd(x, d).\n\nBut d is fixed as (b -a). Let me denote d as the absolute difference between a and b. Wait, because if a > b, then d would be negative, but since we can swap a and b, perhaps we can assume that d is positive. Let me think. Let's suppose that a and b are given. Let me compute d = |a - b|. Then, the problem is symmetric in a and b. So, without loss of generality, let's assume that a ≤ b, then d = b -a. Then, the problem becomes finding x ≥ a, such that the LCM of x and x +d is minimized. Then, k is x -a.\n\nSo the first step is to compute d = |a - b|. Then, the problem is to find x ≥ min(a, b) such that LCM(x, x +d) is minimized. Wait, but if a is smaller than b, then x has to be ≥a, and x +d is x + (b -a) = x + (b -a) = (a +k) + (b -a) = b +k. Which is correct.\n\nSo now, the problem reduces to finding x ≥ a (assuming a ≤ b) such that LCM(x, x +d) is minimized.\n\nNow, how to find this x?\n\nLet me think about the expression for LCM(x, x +d). As mentioned, it's x*(x +d)/g, where g = gcd(x, d). Let me denote g as the gcd of x and d. Let me also note that since d is fixed, perhaps we can find x such that g is as large as possible, thereby reducing the LCM.\n\nAlternatively, perhaps we can find x such that x and x +d have a large gcd. Because the LCM is inversely proportional to the gcd.\n\nBut how?\n\nLet me think of examples. For example, the first sample input: a=6, b=10. So d = 4. Then, we need to find x ≥6 such that LCM(x, x+4) is minimized.\n\nIn the sample, the optimal k is 2, so x is 6+2=8, x +d = 12. LCM(8,12) is 24. Let's see other possibilities. For example, x=6: LCM(6,10)=30. x=7: LCM(7,11)=77. x=8:24. x=9: LCM(9,13)=11",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we choose the smallest $ k $.\n\n### Approach\n1. **Understanding the Problem**: The goal is to minimize the LCM of two numbers $ a + k $ and $ b + k $. This can be transformed by recognizing that the difference between these two numbers is constant, $ d = |a - b| $.\n2. **Reduction to a Single Variable**: By letting $ x = a + k $, the other number becomes $ x + d $. The LCM of $ x $ and $ x + d $ can be expressed using their greatest common divisor (GCD).\n3. **Optimal Value Calculation**: The optimal $ x $ should be such that the GCD of $ x $ and $ d $ is maximized, which minimizes the LCM. We iterate over possible divisors of $ d $ to find the optimal $ x $.\n\n### Solution Code\n```python\nimport math\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    min_lcm = float('inf')\n    best_k = 0\n    # We need to find x >= min(a, b) such that LCM(x, x + d) is minimized\n    # Let's consider all possible divisors of d\n    # The optimal x is such that x is a multiple of some divisor of d\n    # So we check all divisors of d\n    # Let's generate all divisors of d\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    # Now, for each divisor g of d, we can try to find x such that x = m * g - r, where r is something?\n    # Alternatively, for each g in divisors, we can try to find x such that x is congruent to -d mod g\n    # Wait, since gcd(x, d) = g, then x must be a multiple of g, and d must be a multiple of g as well\n    # So let's iterate over all possible g that divide d\n    # For each g, the optimal x is such that x is a multiple of g, and x + d is also a multiple of g\n    # Since d is a multiple of g, then x + d is also a multiple of g if x is\n    # Therefore, for each g (divisor of d), we can look for x = m * g, such that x >= min(a, b)\n    # Then, the LCM(x, x + d) is (x * (x + d)) / g\n    # But how to find the optimal x for each g?\n    # For each g, the minimal x is the smallest multiple of g that is >= min(a, b)\n    # However, we can also consider that the optimal x is such that x is congruent to -d mod something?\n    # Alternatively, considering that for each divisor g of d, the minimal x is the smallest multiple of g that is >= min(a, b)\n    # Let's proceed with that approach\n    # Also, we need to check the case where x is the minimal value such that x + d is a multiple of x, but that might not be necessary\n    # So for each divisor g of d, compute the minimal x that is a multiple of g and >= min(a, b)\n    # Then compute the LCM for that x and compare\n    # Also, we need to check the case where x is such that x = (some value) that may not be a multiple of any divisor of d, but perhaps that's covered by the above\n    # However, the minimal LCM occurs when the GCD is maximized, so checking the divisors of d makes sense\n    # So here's the plan:\n    # Generate all divisors of d\n    # For each divisor g of d, compute the minimal x that is a multiple of g and >= min(a, b)\n    # Also, check x = (some value) that could be (g - (min_val % g)) % g + min_val\n    # Then compute the LCM for that x and compare\n    # Additionally, check the case where x is such that x = (some value) that is not necessarily a multiple of any divisor of d, but perhaps that's already covered\n    # However, considering that for the optimal x, the GCD(x, d) is maximized, which is achieved when x is a multiple of a divisor of d, this approach should cover all possibilities\n    # So proceed\n    min_val = min(a, b)\n    max_val = max(a, b)\n    for g in divisors:\n        # Find the smallest multiple of g that is >= min_val\n        remainder = min_val % g\n        if remainder == 0:\n            x = min_val\n        else:\n            x = min_val + (g - remainder)\n        # Now compute the LCM of x and x + d\n        y = x + d\n        current_gcd = math.gcd(x, d)\n        lcm = (x * y) // current_gcd\n        if lcm < min_lcm or (lcm == min_lcm and (x - min(a, b)) < best_k):\n            min_lcm = lcm\n            best_k = x - min(a, b)\n        # Also, check x = g - (min_val % g) ? No, that would be less than min_val\n        # Also, check the next possible x? For example, if x is too small, maybe x - g is better? No, since x is the minimal multiple >= min_val\n        # Also, check the case where x is the minimal multiple of g, and also check x - g if it's >= min_val? Probably not needed\n    # Also, check the case where k=0, i.e., x = min_val\n    x = min_val\n    y = x + d\n    current_gcd = math.gcd(x, d)\n    lcm = (x * y) // current_gcd\n    if lcm < min_lcm or (lcm == min_lcm and (x - min(a, b)) < best_k):\n        min_lcm = lcm\n        best_k = x - min(a, b)\n    return best_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, and each pair of integers is processed separately.\n2. **Difference Calculation**: Compute the absolute difference $ d $ between $ a $ and $ b $.\n3. **Divisors of $ d $**: Generate all divisors of $ d $ to explore potential values of $ x $ that could minimize the LCM.\n4. **Optimal $ x $ Calculation**: For each divisor $ g $ of $ d $, find the smallest multiple of $ g $ that is greater than or equal to the minimum of $ a $ and $ b $.\n5. **LCM Calculation**: For each candidate $ x $, compute the corresponding $ y $ and the LCM of $ x $ and $ y $, keeping track of the minimum LCM and the corresponding $ k $.\n\nThis approach ensures that we efficiently find the optimal $ k $ by leveraging properties of divisors and GCD to minimize the LCM.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    min_lcm = float('inf')\n    best_k = 0\n    # We need to find x >= min(a, b) such that LCM(x, x + d) is minimized\n    # Let's consider all possible divisors of d\n    # The optimal x is such that x is a multiple of some divisor of d\n    # So we check all divisors of d\n    # Let's generate all divisors of d\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    # Now, for each divisor g of d, we can try to find x such that x = m * g - r, where r is something?\n    # Alternatively, for each g in divisors, we can try to find x such that x is congruent to -d mod g\n    # Wait, since gcd(x, d) = g, then x must be a multiple of g, and d must be a multiple of g as well\n    # So let's iterate over all possible g that divide d\n    # For each g, the optimal x is such that x is a multiple of g, and x + d is also a multiple of g\n    # Since d is a multiple of g, then x + d is also a multiple of g if x is\n    # Therefore, for each g (divisor of d), we can look for x = m * g, such that x >= min(a, b)\n    # Then, the LCM(x, x + d) is (x * (x + d)) / g\n    # But how to find the optimal x for each g?\n    # For each g, the minimal x is the smallest multiple of g that is >= min(a, b)\n    # However, we can also consider that the optimal x is such that x is congruent to -d mod something?\n    # Alternatively, considering that for each divisor g of d, the minimal x is the smallest multiple of g that is >= min(a, b)\n    # Let's proceed with that approach\n    # Also, we need to check the case where x is the minimal value such that x + d is a multiple of x, but that might not be necessary\n    # So for each divisor g of d, compute the minimal x that is a multiple of g and >= min(a, b)\n    # Then compute the LCM for that x and compare\n    # Also, we need to check the case where x is such that x = (some value) that may not be a multiple of any divisor of d, but perhaps that's covered by the above\n    # However, the minimal LCM occurs when the GCD is maximized, so checking the divisors of d makes sense\n    # So here's the plan:\n    # Generate all divisors of d\n    # For each divisor g of d, compute the minimal x that is a multiple of g and >= min(a, b)\n    # Also, check x = (some value) that could be (g - (min_val % g)) % g + min_val\n    # Then compute the LCM for that x and compare\n    # Additionally, check the case where x is such that x = (some value) that is not necessarily a multiple of any divisor of d, but perhaps that's already covered\n    # However, considering that for the optimal x, the GCD(x, d) is maximized, which is achieved when x is a multiple of a divisor of d, this approach should cover all possibilities\n    # So proceed\n    min_val = min(a, b)\n    max_val = max(a, b)\n    for g in divisors:\n        # Find the smallest multiple of g that is >= min_val\n        remainder = min_val % g\n        if remainder == 0:\n            x = min_val\n        else:\n            x = min_val + (g - remainder)\n        # Now compute the LCM of x and x + d\n        y = x + d\n        current_gcd = math.gcd(x, d)\n        lcm = (x * y) // current_gcd\n        if lcm < min_lcm or (lcm == min_lcm and (x - min(a, b)) < best_k):\n            min_lcm = lcm\n            best_k = x - min(a, b)\n        # Also, check x = g - (min_val % g) ? No, that would be less than min_val\n        # Also, check the next possible x? For example, if x is too small, maybe x - g is better? No, since x is the minimal multiple >= min_val\n        # Also, check the case where x is the minimal multiple of g, and also check x - g if it's >= min_val? Probably not needed\n    # Also, check the case where k=0, i.e., x = min_val\n    x = min_val\n    y = x + d\n    current_gcd = math.gcd(x, d)\n    lcm = (x * y) // current_gcd\n    if lcm < min_lcm or (lcm == min_lcm and (x - min(a, b)) < best_k):\n        min_lcm = lcm\n        best_k = x - min(a, b)\n    return best_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 394,
        "completion_token_count": 1690,
        "thoughts_token_count": 1024
    }
}