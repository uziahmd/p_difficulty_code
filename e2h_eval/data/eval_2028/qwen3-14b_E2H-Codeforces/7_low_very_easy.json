{
    "start": 1758008515.207684,
    "end": 1758008698.3726254,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:44 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure.\n\nThe construction rules are:\n\nStart with one vertex. Then, add k new vertices connected to it. Then, each vertex that has only one connection (so the leaves) get connected to k new vertices. This process must be done at least once. So, the snowflake is built in layers. Each step adds new layers of nodes.\n\nLet me think about how the number of vertices grows with each step.\n\nLet me think of the example given. For k=4, the smallest snowflake. Let's see:\n\nInitially, there's 1 node. Then, we add k=4 nodes connected to it. Now total is 5. Then, each of those 4 nodes (which are leaves) must be connected to k=4 new nodes. So each of the 4 leaves adds 4 new nodes. So adding 4*4=16 nodes. Total becomes 1 + 4 + 16 = 21? Wait, but the example says that for n=13, the answer is YES. Hmm, maybe I need to re-examine the steps.\n\nWait, maybe the process is done in steps where each step adds layers. Let's think of the construction as layers. The initial node is layer 0. Then, layer 1 has k nodes connected to it. Then, each node in layer 1 (which are all leaves) gets k children in layer 2. Then, each node in layer 2 (which are leaves) get k children in layer 3, etc. But the process requires that this step (adding new children to leaves) is done at least once. So the minimum is when we have two layers: initial node (layer 0), then layer 1 (k nodes), then layer 2 (each of the k nodes in layer 1 adds k nodes). But the problem says that this step (the adding of children to leaves) should be done at least once. So the initial step (adding layer 1) is required, and then adding layer 2 is also required. So the minimal snowflake would have 1 + k + k*k = 1 + k + k² nodes. Wait, but for the example given, when n=13, the answer is YES. Let's see: 1 + k + k² = 13. Let's solve for k. k² +k +1 =13 → k² +k -12 =0. The solutions are k = [-1 ± sqrt(1+48)]/2 → sqrt(49)=7 → ( -1 +7)/2 = 3. So k=3. Then 1+3+9=13. So yes, that works. So for n=13, the answer is YES. Which matches the sample input.\n\nBut what about other possibilities? For example, maybe there are more layers. Suppose we have more steps. Like, after adding layer 2, we add another layer. So the total number of nodes would be 1 +k +k² +k³. But for that, the process of adding children to leaves must be done at least once. So in this case, the first step (adding layer 1) is done once, then adding layer 2 is done once, then adding layer 3 is done again. So the process is done twice. But the problem says that the step must be done at least once. So the minimal is that after the initial step (adding layer 1), we do the step once (adding layer 2). So the total nodes can be 1 +k +k^2. Or if we do more steps, like adding layers 3, then it's 1 +k +k^2 +k^3, etc. But the problem is to check if there exists some k>1 and some number of layers m ≥2 (since the step must be done at least once, which implies that after the initial step, we add at least one more layer). Wait, maybe the process is: the initial step is adding the first layer (k nodes), then the step of adding new nodes to leaves is done once. So for the minimal case, the total is 1 +k +k*k. But if you do more steps, you can have more layers.\n\nSo the general formula for the number of nodes is:\n\nn = 1 + k*( (k^m - 1)/(k-1) )) ?\n\nWait, let's think. Let me model the layers. Let's say the snowflake has m layers. Wait, perhaps the structure is a tree. The root is layer 0. Then, each node in layer i has k children in layer i+1.",
    "response": "\n\nTo solve this problem, we need to determine if a snowflake graph with exactly `n` vertices can be constructed based on specific rules. The snowflake graph is built in layers, starting from one vertex and adding layers of nodes such that each node added in a previous layer is connected to `k` new nodes in the next layer. This process must be repeated at least once after the initial layer.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph starts with one vertex (root). Then, it adds `k` children to this root. Each subsequent layer adds `k` children to every leaf node from the previous layer. The minimum number of vertices required for a valid snowflake is when there are two layers: the root and its `k` children, followed by each of those `k` children having `k` children. This results in the formula: `n = 1 + k + k^2`.\n\n2. **Iterative Check**: For each test case, we need to check if there exists a value of `k > 1` such that `n` can be expressed as the sum of vertices in such a layered structure. We iterate over possible values of `k` and check if `n` fits the structure for any number of layers.\n\n3. **Efficient Calculation**: Given the constraints where `n` can be as large as `10^18`, we need an efficient approach. For each possible `k` (starting from 2 up to a reasonable limit), we compute the cumulative number of vertices for increasing layers until the total exceeds `n`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Check for possible k and m layers\n    max_k = int(math.isqrt(n)) + 2\n    for k in range(2, max_k + 1):\n        total = 1  # root\n        current = 1  # number of nodes in current layer\n        layers = 1  # number of layers (initial layer is 1)\n        while True:\n            next_layer = current * k\n            if total + next_layer > n:\n                break\n            total += next_layer\n            current = next_layer\n            layers += 1\n            if layers >= 2:  # since step must be done at least once\n                if total == n:\n                    return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read all at once for efficiency, especially given the large constraints.\n2. **Checking Validity**: For each number `n`, the function `is_snowflake` checks if it can be represented as a valid snowflake graph. It iterates through possible values of `k` starting from 2.\n3. **Layer Calculation**: For each `k`, the function simulates adding layers of nodes, accumulating the total number of vertices. If at any point the total matches `n`, it returns `True`.\n4. **Efficiency**: The loop for `k` runs up to the square root of `n` plus a small buffer, ensuring that even very large values of `n` are checked efficiently.\n\nThis approach ensures that we efficiently check all possible configurations of the snowflake graph without exceeding time limits, even for very large values of `n`.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Check for possible k and m layers\n    max_k = int(math.isqrt(n)) + 2\n    for k in range(2, max_k + 1):\n        total = 1  # root\n        current = 1  # number of nodes in current layer\n        layers = 1  # number of layers (initial layer is 1)\n        while True:\n            next_layer = current * k\n            if total + next_layer > n:\n                break\n            total += next_layer\n            current = next_layer\n            layers += 1\n            if layers >= 2:  # since step must be done at least once\n                if total == n:\n                    return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 774,
        "thoughts_token_count": 1023
    }
}