{
    "start": 1758016189.9315104,
    "end": 1758017448.843303,
    "start-formatted": "2025-09-16 18:49 KST",
    "end-formatted": "2025-09-16 19:10 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If there's no such pair, output -1.\n\nFirst, let's understand the constraints. The vouchers are given with li, ri, costi. The duration of voucher i is ri - li + 1. We need two vouchers i and j (i≠j) where their durations sum to x, and they don't overlap. Also, the sum of their costs should be as small as possible.\n\nThe key points here are:\n\n1. Find two vouchers whose durations add up to x.\n2. They must not overlap. Which means either the first ends before the second starts, or vice versa.\n3. Find the minimum sum of their costs.\n\nSo the approach needs to efficiently check for all possible pairs that satisfy these conditions.\n\nBut with n up to 2e5, checking all pairs O(n²) is impossible. So we need a smarter way.\n\nLet me think about how to approach this.\n\nFirst, for each voucher, compute its duration. Let's call it d_i = ri - li + 1.\n\nWe need two vouchers with d_i + d_j = x. So for each voucher with duration d, we can look for another voucher with duration x - d. But also, they need to not overlap.\n\nSo maybe we can group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, check if there's a voucher with duration x-d, and then find the ones that don't overlap with it.\n\nBut even this approach might not be efficient enough if we have to check all combinations for each pair of durations. However, since x can be up to 2e5, and for each voucher, we can process it once.\n\nWait, but for each voucher, if we have a duration d, then we need to find vouchers with duration x - d. So for each voucher, we can check if x - d exists in our duration map. Then, for those vouchers with duration x - d, find the ones that don't overlap with the current voucher.\n\nBut how do we find the minimal cost for such pairs?\n\nLet's think. Suppose we have a voucher A with duration d, and we want to find vouchers B with duration x - d. For each such B, we need to check if they don't overlap with A. But how to efficiently find the minimal cost B for each A?\n\nAlternatively, perhaps for each duration d, we can pre-process the vouchers of that duration, sorted by their end time (ri) or start time (li), so that for a given voucher A, we can quickly find the minimal cost voucher B that starts after A ends, or ends before A starts.\n\nBut how?\n\nLet's consider that for a voucher A with duration d, and looking for vouchers B with duration x-d. Let's say that x-d is some value, let's call it k.\n\nSo for each voucher A with duration d, we need to find vouchers B with duration k, such that B's interval does not overlap with A's interval.\n\nSo for each voucher A, we need to find the minimal cost among all B's with duration k that are completely before A's start, or completely after A's end.\n\nSo for each duration k, we can pre-process the vouchers with that duration. For example, for vouchers with duration k, we can sort them by their end time. Then, for a voucher A that ends at some time, we can find all vouchers B that end before A's start. Similarly, for vouchers B that start after A's end.\n\nBut how to find the minimal cost in those cases.\n\nLet me think about the following approach:\n\nFor each duration d, we can have two structures:\n\n- A sorted list of vouchers by their end time (ri), and for each such list, we can have a prefix minimum cost array. So that for a given start time (say, A's li), we can find all vouchers B with end time < A's li, and get the minimal cost among them.\n\nSimilarly, for vouchers sorted by their start time (li), we can have a suffix minimum array. For example, for a given end time (A's ri), we can find all vouchers B with start time > A's ri, and get the minimal cost among them.\n\nBut how to structure this.\n\nLet me think again. Suppose we have for each duration k, two sorted lists:\n\n1. All vouchers with duration k, sorted by their end time (ri). For each such list, we can precompute a prefix minimum cost array. So for any query of \"find the minimal cost among vouchers with end time <= t\", we can perform a binary search on the sorted end times to find the latest end time <= t, and then take the corresponding prefix min.\n\n2. All vouchers with duration k, sorted by their start time (li). For each such list, we can precompute a suffix minimum cost array. So for any query of \"find the minimal cost among vouchers with start time >= t\", we can perform a binary search on the sorted start times to find the earliest start time >= t, and then take the corresponding suffix min.\n\nThis way, for a voucher A with duration d, and looking for vouchers B with duration k = x -d, we can check both possibilities: B ends before A starts, or B starts after A ends.\n\nSo for each voucher A, we can:\n\n- Check if there exists vouchers with duration k = x -d. If not, skip.\n\n- For those vouchers with duration k, check the minimal cost of B that ends before A's li (so that B is completely before A). Also check the minimal cost of B that starts after A's ri (so that B is completely after A).\n\nThen, take the minimal between these two possibilities (if any exist) and combine with A's cost.\n\nSo the overall plan is:\n\n1. Preprocess all vouchers by their duration. For each duration, store two sorted lists (sorted by end time and start time), along with prefix/suffix min arrays.\n\nBut how to build these structures.\n\nLet me outline steps:\n\n- Create a dictionary, say duration_dict, where keys are durations, and values are tuples of two sorted lists and their respective min arrays.\n\nFor each duration d in duration_dict:\n\n   - list_end_sorted: list of vouchers with duration d, sorted by ri (end time). For each entry, we can have (ri, cost). Then, create a prefix_min array where prefix_min[i] is the minimum cost from 0 to i.\n\n   - list_start_sorted: list of vouchers with duration d, sorted by li (start time). For each entry, (li, cost). Then, create a suffix_min array where suffix_min[i] is the minimum cost from i to end.\n\nOnce these structures are built, for any voucher A (with duration d), we can check if there's a duration k = x -d. If yes, then for each such k, we can check the two possibilities.\n\nBut how to handle when there are multiple vouchers with the same duration. For example, if there are multiple vouchers with duration k, we need to find the minimal cost for B that ends before A's li, or starts after A's ri.\n\nSo for each voucher A with duration d:\n\n   k = x -d.\n\n   if k is not present in duration_dict, continue.\n\n   else:\n\n      for the vouchers with duration k:\n\n         find the minimal cost of B that ends before A's li. How?\n\n         In the list_end_sorted for duration k, which is sorted by ri. We can perform a binary search to find the largest ri that is <= (A's li -1). Because if B ends before A's start, then B's ri < A's li. So the maximum ri allowed is A's li -1.\n\n         Once we find the index in the list_end_sorted, the prefix_min up to that index gives the minimal cost.\n\n         Similarly, for the vouchers with duration k, find the minimal cost of B that starts after A's ri. So B's li must be > A's ri. So in the list_start_sorted (sorted by li), find the first li that is > A's ri. All elements from that index onwards have li > A's ri. The suffix_min for that index gives the minimal cost.\n\nSo for each voucher A, we can check both possibilities (before and after) and take the minimal possible, then combine with A's cost.\n\nOnce we have all possible candidates, we take the overall minimal sum.\n\nNow, the question is: How to implement this efficiently.\n\nBut first, what about overlapping? For example, if a voucher B has duration k, and it's in the same duration group as another voucher. But the code above ensures that B is either before A or after A.\n\nNow, considering that for each voucher A, we check for vouchers B with duration k = x -d. Then, for each such B, we can find the minimal cost for the two cases (B before A, or B after A). Then, for each voucher A, we can calculate possible candidates and keep track of the global minimum.\n\nBut how to handle the case where there are multiple vouchers with the same duration. For example, if there are multiple B's that meet the criteria, we need to find the minimal one.\n\nSo the steps would be:\n\n- Preprocess all vouchers into duration_dict, with for each duration d, the sorted lists and min arrays.\n\nThen, for each voucher A in the list:\n\n   d = duration of A.\n\n   k = x -d.\n\n   if k is not in duration_dict, continue.\n\n   else:\n\n      check for B's that end before A's li:\n\n         in duration_dict[k], list_end_sorted is sorted by ri.\n\n         find the maximum ri <= A.li - 1.\n\n         if such entries exist, get the minimal cost from prefix_min.\n\n         then, the candidate is A.cost + that minimal cost.\n\n      check for B's that start after A's ri:\n\n         in duration_dict[k], list_start_sorted is sorted by li.\n\n         find the first li > A.ri.\n\n         if such entries exist, get the minimal cost from suffix_min.\n\n         candidate is A.cost + that minimal cost.\n\n      compare these candidates with the current global minimum.\n\nBut wait, for the first case, when we check B's that end before A's start, the B's could be any of those. Similarly for the second case.\n\nBut how do we handle the fact that the voucher B cannot be the same as A? Well, because the problem says i≠j. However, if the voucher A has duration d, and k = x -d, then if d + k = x, and if d = k (so x is even), then we need to make sure that when checking B's, we don't pick the same voucher as A. However, in that case, the code would check for B's with duration k, which is same as d. But when we check for B's that end before A's li, or start after A's ri, the same voucher can't be in both positions. Because if B is same as A, then B's ri is equal to A's ri, which is >= A's li. So for B to end before A's li, it's required that B's ri < A's li. But since A's ri >= A's li, then B can't be A. Similarly for the other case. So even if there's a voucher with same duration, the code will not select the same voucher.\n\nWait, but suppose that A has duration d, and k = x -d = d. So x is 2d. Then, when processing voucher A, we look for vouchers B with duration d. For example, if A is in the list for duration d, then when we check for B's that end before A's li, but if there's a voucher B that is same as A, but that would require that B's ri < A's li. But since A's ri is >= A's li, this is only possible if B's ri < A's li. But since B is same as A, then B's ri = A's ri, which is >= A's li. So no. Therefore, the same voucher is not considered in either of the two cases. Thus, the code is safe.\n\nTherefore, we don't have to worry about i=j in this approach.\n\nNow, the next step is to implement this logic.\n\nBut how to preprocess the duration_dict.\n\nFor each duration d, we need:\n\n- list_end_sorted: sorted by ri, and for each position, the prefix min cost.\n\nSimilarly, list_start_sorted: sorted by li, and suffix min cost.\n\nLet me think about how to build these.\n\nFor example, for a duration d, collect all vouchers with that duration. Then:\n\nSort them by ri. For each element in the sorted list, we can create a prefix_min array where prefix_min[i] = min(prefix_min[i-1], cost_i). So the first element is cost_0, then min of first two, etc.\n\nSimilarly, for the list sorted by li, sort them by li, and then create a suffix_min array where suffix_min[i] = min(suffix_min[i+1], cost_i). So the last element is cost_n-1, and moving backwards.\n\nOnce these structures are built, for any query, we can perform a binary search.\n\nNow, the problem is to implement this in Python.\n\nBut let's think about the data structures.\n\nIn Python, for each duration, we can have:\n\n- For list_end_sorted: a list of tuples (ri, cost). Sorted by ri.\n\n- For the prefix_min array: a list of integers, where prefix_min[i] is the minimum cost from the first element to the i-th element.\n\nSimilarly, for list_start_sorted: list of tuples (li, cost), sorted by li.\n\nAnd suffix_min array: for each index i, the minimum cost from i to the end of the list.\n\nOnce these are built, for a given voucher A, with li_A, ri_A, cost_A, and duration d, and looking for k = x -d:\n\nCase 1: find B's with duration k, ending before li_A.\n\nSo in the list_end_sorted of duration k, find the largest ri that is <= li_A -1.\n\nIf such an ri exists, then the minimal cost is the prefix_min up to that index.\n\nCase 2: find B's with duration k, starting after ri_A.\n\nIn the list_start_sorted of duration k, find the first li that is > ri_A. All elements from that index onwards are candidates. The minimal cost is the suffix_min at that index.\n\nNow, how to perform the binary search.\n\nFor case 1:\n\nThe list_end_sorted is sorted by ri. So we can use bisect_right to find the insertion point of li_A -1. The index would be the number of elements <= li_A -1. If the index is 0, then no such elements. Else, the prefix_min[index-1] is the minimal cost.\n\nFor example, using the bisect module.\n\nSimilarly, for case 2:\n\nlist_start_sorted is sorted by li. We need to find the first li that is > ri_A. Using bisect_right for ri_A. The index is the insertion point. If index is equal to the length of the list, then no such elements. Else, the suffix_min[index] is the minimal cost.\n\nSo, for example, in code:\n\nimport bisect\n\nfor case 1:\n\ntarget = A.li - 1\n\nindices = [voucher[0] for voucher in list_end_sorted]\n\npos = bisect.bisect_right(indices, target)\n\nif pos > 0:\n\n   min_cost_before = prefix_min[pos-1]\n\nelse:\n\n   no such voucher.\n\nSimilarly for case 2:\n\ntarget = A.ri\n\nindices = [voucher[0] for voucher in list_start_sorted]\n\npos = bisect.bisect_right(indices, target)\n\nif pos < len(list_start_sorted):\n\n   min_cost_after = suffix_min[pos]\n\nelse:\n\n   no such voucher.\n\nBut building the list of indices for each duration may be time-consuming. However, since the list_end_sorted is already sorted by ri, we can just use the list of (ri, cost) and during the binary search, extract the ri values as needed.\n\nBut in Python, using bisect on a list of tuples is not straightforward. Wait, no. The bisect module works on a list, and compares elements based on their natural ordering. However, if the list is a list of tuples, then comparing the tuples would compare the first element, then the second, etc. However, in our case, list_end_sorted is sorted by ri. So the first element of the tuple is ri. So, for the list_end_sorted, which is sorted by ri, we can use bisect.bisect_right on the list, passing the target (li_A -1) as the value. But how?\n\nWait, no. Because the list is made of tuples (ri, cost). So if we do bisect.bisect_right(list_end_sorted, (target, ...)), but since the second element is arbitrary, this may not work. So instead, perhaps we can create a separate list of the ri's for each duration, to use for binary search.\n\nAlternatively, we can create a list of ri's for each duration's list_end_sorted. For example, for each duration d, we can have a list called end_times, which is the list of ri's sorted. Then, when doing the bisect, we can use this list.\n\nYes. That's probably better. So during preprocessing, for each duration d, for the list_end_sorted, we can store a list of (ri, cost), sorted by ri. And also, a list end_times that is [ri for (ri, cost) in list_end_sorted]. Similarly for the list_start_sorted, we can have a list start_times which is [li for (li, cost) in list_start_sorted].\n\nSo during preprocessing, for each duration d:\n\n   list_end_sorted = sorted(vouchers with duration d, key=lambda x: x[0])  # x[0] is ri?\n\nWait, no. Wait, the vouchers are stored as (li, ri, cost). Wait, no. Wait, for the list_end_sorted, we need to sort by ri. So for each voucher, we can have (ri, li, cost) ?\n\nNo. For the list_end_sorted, we need to sort the vouchers by their ri. So for each voucher, we can store (ri, li, cost). But when we do the binary search, we need to compare the ri's. So for the end_times list, it's just the ri's of the vouchers sorted.\n\nSo during preprocessing:\n\nfor each duration d:\n\n   vouchers_with_d = list of vouchers (li, ri, cost) where duration is d.\n\n   sorted by ri: sorted_vouchers_end = sorted(vouchers_with_d, key=lambda x: x[1])\n\n   end_times = [v[1] for v in sorted_vouchers_end]\n\n   prefix_min = [ ... ]\n\nSimilarly, sorted_vouchers_start = sorted(vouchers_with_d, key=lambda x: x[0])\n\nstart_times = [v[0] for v in sorted_vouchers_start]\n\nsuffix_min = [ ... ]\n\nSo for each duration d, we can store:\n\n- sorted_vouchers_end, end_times, prefix_min.\n\n- sorted_vouchers_start, start_times, suffix_min.\n\nOnce that is done, during the processing of each voucher A, we can check for k = x -d.\n\nNow, the problem is to implement this in Python, handling all the steps.\n\nNow, let's think about the steps in code:\n\nRead n and x.\n\nThen read n vouchers, each with li, ri, cost.\n\nCompute for each voucher, its duration: d = ri - li + 1.\n\nThen, group all vouchers by their duration. For each duration, collect the vouchers.\n\nOnce grouped, for each duration d, process the vouchers to create the sorted lists and min arrays.\n\nOnce that's done, iterate through each voucher A in the original list. For each voucher A:\n\n   d = duration of A.\n\n   k = x -d.\n\n   if k not in duration_dict, continue.\n\n   else:\n\n      process for B's with duration k.\n\n      check case 1: B ends before A starts.\n\n         get the list_end_sorted for duration k, end_times, prefix_min.\n\n         target = A's li -1.\n\n         pos = bisect.bisect_right(end_times, target)\n\n         if pos > 0:\n\n             min_cost_b = prefix_min[pos-1]\n\n             total = A.cost + min_cost_b\n\n             update the global minimum.\n\n      check case 2: B starts after A ends.\n\n         get the list_start_sorted for duration k, start_times, suffix_min.\n\n         target = A's ri.\n\n         pos = bisect.bisect_right(start_times, target)\n\n         if pos < len(start_times):\n\n             min_cost_b = suffix_min[pos]\n\n             total = A.cost + min_cost_b\n\n             update the global minimum.\n\nSo, the code would need to handle all these steps.\n\nNow, the question is how to build the prefix_min and suffix_min arrays.\n\nFor prefix_min:\n\nsorted_vouchers_end is sorted by ri. So for each voucher in this list, we can compute prefix_min as follows:\n\nprefix_min = [0] * len(sorted_vouchers_end)\n\nprefix_min[0] = sorted_vouchers_end[0][2] (the cost)\n\nfor i in 1 to len-1:\n\n   prefix_min[i] = min(prefix_min[i-1], sorted_vouchers_end[i][2])\n\nSimilarly, for suffix_min:\n\nsorted_vouchers_start is sorted by li. So for each voucher in this list, we can compute suffix_min as follows:\n\nsuffix_min = [0] * len(sorted_vouchers_start)\n\nsuffix_min[-1] = sorted_vouchers_start[-1][2]\n\nfor i in range(len-2, -1, -1):\n\n   suffix_min[i] = min(suffix_min[i+1], sorted_vouchers_start[i][2])\n\nOnce these are precomputed, during the query steps, we can get the minimal cost.\n\nNow, for the code, the main steps are:\n\nImplementing the grouping, building the data structures, then processing each voucher.\n\nNow, considering that n can be up to 2e5, and for each duration, the processing is O(m log m) where m is the number of vouchers for that duration. Overall, the total time is acceptable.\n\nBut in Python, for large n, the code must be efficient.\n\nNow, let's think about the edge cases.\n\nFor example, when x is 0? No, because x is given as ≥2? Wait, no. The input says x can be as low as 2? Wait, the input constraints say 2 ≤ n, x ≤ 2e5. So x is at least 2.\n\nAnother case: when a voucher has duration d, and x -d is negative. But since x ≥ 2 and d is at least 1 (since li ≤ ri, so ri - li +1 ≥ 1). So x -d can be negative only if d >x. So in that case, k would be negative, and we can skip.\n\nSo during processing, for each voucher A, we check if k is positive. Because if k is zero or negative, no vouchers can have that duration. So, for example, if x=5, and a voucher has duration 6, then k =5-6=-1. So we skip.\n\nSo in code, during processing of each voucher A:\n\nk = x -d.\n\nif k <=0, then skip.\n\nElse, check if k is in the duration_dict.\n\nSo that's important.\n\nNow, let's think about the sample input.\n\nFirst sample input:\n\n4 5\n\nVouchers:\n\n1 3 4 → duration 3-1+1=3.\n\n1 2 5 → duration 2.\n\n5 6 1 → duration 2.\n\n1 2 4 → duration 2.\n\nSo for each voucher:\n\nFor the first voucher (d=3), k=5-3=2. So check if there are vouchers with duration 2.\n\nYes. For case 1: B ends before A's li (which is 1). So target is 1-1=0. So looking for vouchers with ri ≤ 0. None. So no case 1.\n\nCase 2: B starts after A's ri (3). So B's li must be >3. Looking at vouchers with duration 2. The vouchers are:\n\nvoucher 2: li=1, ri=2 → duration 2.\n\nvoucher 3: li=5, ri=6 → duration 2.\n\nvoucher 4: li=1, ri=2 → duration 2.\n\nSo sorted_start_times for duration 2 is [1,1,5]. The start_times list is [1,1,5]. For target =3, bisect_right([1,1,5], 3) returns 2. So pos=2. The suffix_min for pos=2 is the min of the elements from index 2 onwards. The suffix_min for index 2 is the cost of voucher 3, which is 1. So adding to A's cost (4) gives 5. Which is the correct answer.\n\nSo during the processing of voucher 1, this case is found.\n\nAnother voucher that may contribute is voucher 3 (duration 2). For k=5-2=3. So looking for vouchers with duration 3. There is voucher 1 (duration 3). So for voucher 3, check if there are vouchers with duration 3.\n\nYes. So case 1: B ends before voucher 3's li (5). So B's ri must be <5. Voucher 1 has ri=3, which is <5. So in the list_end_sorted for duration 3, which is [ (3, 4) ].\n\ntarget is 5-1=4? Wait, voucher 3's li is 5. So target is 5-1=4? Wait, no. For case 1, B ends before A's li. A's li is 5. So B's ri must be ≤ 5-1 =4. So the target is 4. So in the end_times of duration 3, which is [3], bisect_right finds 1 (since 3 <=4). So pos=1. prefix_min[0] is 4. So adding to voucher 3's cost (1) gives 5. Which is the same as before.\n\nSo the code would capture this.\n\nSo the code seems correct.\n\nNow, for the code implementation.\n\nFirst, let's think about how to group the vouchers by duration.\n\nIn Python, we can use a defaultdict to map durations to lists of vouchers.\n\nThen, for each duration d in the defaultdict, process the vouchers to create the sorted lists and min arrays.\n\nNow, for each duration d, we need to:\n\n- collect all vouchers with that duration.\n\n- sort them by ri (for end_sorted) and by li (for start_sorted).\n\n- build the end_times list, prefix_min array.\n\n- build the start_times list, suffix_min array.\n\nOnce that is done, during the processing of each voucher, we can check for the k = x -d.\n\nNow, code steps:\n\nimport sys\n\nfrom bisect import bisect_right\n\nfrom collections import defaultdict\n\nn, x = map(int, sys.stdin.readline().split())\n\nvouchers = []\n\nfor _ in range(n):\n\n    l, r, cost = map(int, sys.stdin.readline().split())\n\n    vouchers.append( (l, r, cost) )\n\nduration_dict = defaultdict( list )\n\nfor l, r, cost in vouchers:\n\n    d = r - l + 1\n\n    duration_dict[d].append( (l, r, cost) )\n\n# Now, pre-process each duration in duration_dict.\n\nprocessed = dict()  # key: duration, value: (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min )\n\nfor d in duration_dict:\n\n    # process end_sorted (sorted by ri)\n\n    end_sorted = sorted( duration_dict[d], key=lambda x: x[1] )\n\n    end_times = [v[1] for v in end_sorted]\n\n    # compute prefix_min\n\n    prefix_min = [0]*len(end_sorted)\n\n    prefix_min[0] = end_sorted[0][2]\n\n    for i in range(1, len(end_sorted)):\n\n        prefix_min[i] = min( prefix_min[i-1], end_sorted[i][2] )\n\n    # process start_sorted (sorted by li)\n\n    start_sorted = sorted( duration_dict[d], key=lambda x: x[0] )\n\n    start_times = [v[0] for v in start_sorted]\n\n    # compute suffix_min\n\n    suffix_min = [0]*len(start_sorted)\n\n    suffix_min[-1] = start_sorted[-1][2]\n\n    for i in range(len(start_sorted)-2, -1, -1):\n\n        suffix_min[i] = min( suffix_min[i+1], start_sorted[i][2] )\n\n    # store in processed\n\n    processed[d] = (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min )\n\n# Now, iterate over all vouchers and check\n\nmin_total = float('inf')\n\nfor l_a, r_a, cost_a in vouchers:\n\n    d_a = r_a - l_a + 1\n\n    k = x - d_a\n\n    if k <=0:\n\n        continue\n\n    if k not in processed:\n\n        continue\n\n    # get the processed data for k\n\n    end_sorted_k, end_times_k, prefix_min_k, start_sorted_k, start_times_k, suffix_min_k = processed[k]\n\n    # case 1: B ends before A starts (B's ri < l_a)\n\n    target = l_a -1\n\n    pos = bisect_right(end_times_k, target)\n\n    if pos >0:\n\n        min_b = prefix_min_k[pos-1]\n\n        total = cost_a + min_b\n\n        if total < min_total:\n\n            min_total = total\n\n    # case 2: B starts after A ends (B's li > r_a)\n\n    target = r_a\n\n    pos = bisect_right(start_times_k, target)\n\n    if pos < len(start_times_k):\n\n        min_b = suffix_min_k[pos]\n\n        total = cost_a + min_b\n\n        if total < min_total:\n\n            min_total = total\n\nif min_total == float('inf'):\n\n    print(-1)\n\nelse:\n\n    print(min_total)\n\nWait, but what about when there are multiple vouchers with the same duration and the same k?\n\nBut the code handles that, because for each voucher A, it checks all possible B's with duration k, via the preprocessed min arrays.\n\nTesting the first sample input:\n\nSample input 1:\n\n4 5\n\nvouchers:\n\n(1,3,4) → duration 3\n\n(1,2,5) → duration 2\n\n(5,6,1) → duration 2\n\n(1,2,4) → duration 2\n\nprocessed for duration 3:\n\nend_sorted is [(1,3,4)] → end_times [3], prefix_min [4]\n\nstart_sorted is [(1,3,4)] → start_times [1], suffix_min [4]\n\nprocessed for duration 2:\n\nend_sorted is sorted by ri. The vouchers with duration 2 are:\n\nvoucher (1,2,5) → ri=2\n\nvoucher (5,6,1) → ri=6\n\nvoucher (1,2,4) → ri=2\n\nsorted by ri: [(1,2,5), (1,2,4), (5,6,1)]? Or wait, when sorted by ri, the vouchers with ri=2 come first, then 6. So the end_sorted for duration 2 would be sorted by ri. So the three vouchers have ri 2, 2, 6. So the end_sorted is [(1,2,5), (1,2,4), (5,6,1)]? Or perhaps sorted by ri, and if same ri, then order is arbitrary. But in any case, the end_times would be [2, 2, 6], and the prefix_min would be [5, min(5,4)=4, min(4, 1)=1]. So prefix_min is [5,4,1].\n\nSimilarly, the start_sorted for duration 2 is sorted by li. The vouchers have li 1, 1,5. So start_sorted is [(1,2,5), (1,2,4), (5,6,1)]. start_times is [1,1,5]. suffix_min would be [ min(5,4,1) =1, min(4,1)=1, 1 ].\n\nSo when voucher A is (1,3,4) (duration 3), k=5-3=2. So check for duration 2.\n\ncase 1: target = l_a -1 = 1-1=0. bisect_right(end_times_k, 0) → end_times_k is [2, 2, 6]. bisect_right finds 0, since 0 < 2. So pos=0 → no.\n\ncase 2: target is r_a =3. start_times_k is [1,1,5]. bisect_right([1,1,5], 3) → returns 2. pos=2 <3 → suffix_min[2] is 1. So total is 4+1=5.\n\nWhich is correct.\n\nAnother voucher is (5,6,1) (duration 2). k=5-2=3. So check if duration 3 is present. Yes.\n\nFor case 1: B ends before A's li (5). So target is 5-1=4. end_times_k is [3]. bisect_right([3],4) returns 1. pos=1>0 → prefix_min[0] is 4. So total is 1 +4=5.\n\nWhich is the same as before.\n\nThus, the code would find this.\n\nThus, the code seems correct.\n\nNow, let's test the second sample input:\n\nSample input 2:\n\n3 2\n\nvouchers:\n\n4 6 3 → duration 6-4+1=3\n\n2 4 1 → duration 3\n\n3 5 4 → duration 3.\n\nSo x is 2. For each voucher, duration is 3. So k = x -d = 2-3 = -1. So all vouchers are skipped. Hence, output is -1. Which matches the sample.\n\nAnother test case: when x is exactly 2*d, and there are two vouchers with duration d, non-overlapping.\n\nFor example, n=2, x=4. vouchers:\n\nvoucher1: 1-2 (duration 2)\n\nvoucher2: 3-4 (duration 2).\n\nSo for voucher1, k=4-2=2. Check vouchers with duration 2. For case 1: B ends before 1. No. case2: B starts after 2. voucher2 starts at 3>2. So the suffix_min is 4. So total is 3+4=7. Similarly for voucher2, k=2, check vouchers with duration 2. case1: B ends before 3. voucher1 ends at 2 <3. So prefix_min is 3. total is 4+3=7. So the minimal is 7.\n\nSo code would return 7.\n\nAnother case: when two vouchers have same duration and overlapping, but there exists another voucher with same duration that doesn't overlap.\n\nBut the code should handle it.\n\nNow, possible edge cases:\n\n- All vouchers have same duration, but no two can be non-overlapping. For example, n=2, vouchers are [1-2, 1-2], x=4. Then, their durations are 2 each. So x=4. But they overlap. So answer is -1.\n\nAnother case: when there are multiple vouchers with same duration and some non-overlapping.\n\nNow, code seems to handle that.\n\nNow, considering the code's time complexity.\n\nGrouping the vouchers takes O(n) time.\n\nFor each duration, sorting the vouchers takes O(m log m) for m vouchers in that duration. Summing over all durations, O(n log n) total.\n\nBuilding the prefix and suffix min arrays is O(m) per duration, which is O(n) total.\n\nThen, for each voucher (O(n)), we perform two binary searches (O(log m)), which is O(n log n) total.\n\nThus, the overall time is acceptable for n up to 2e5.\n\nNow, code in Python.\n\nBut in Python, for the 'processed' dictionary, we need to store for each duration d, the end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min.\n\nBut for each duration, during the preprocessing, we can generate those.\n\nPotential issues:\n\n- When a duration has zero vouchers? No, because the duration_dict is built from the vouchers, so each d in duration_dict has at least one voucher.\n\nAnother thing: when k equals to d, but the voucher is the same as A. But the code handles that, as explained earlier.\n\nNow, code:\n\nBut in the code, when building the processed dictionary, for each duration d, we process the vouchers in duration_dict[d]. So that's correct.\n\nNow, code:\n\nBut in Python, for the 'processed' dictionary, perhaps using a defaultdict is not necessary, but we can use a normal dict.\n\nNow, let's write the code.\n\nBut note that in the code, the 'processed' is built for each duration in duration_dict. Then, during the processing of each voucher, we check for k=x -d.\n\nBut in the code, the 'processed' is built for each duration in duration_dict. However, the code uses 'processed[k]' where k is x -d. So if k is in duration_dict, then it's in processed.\n\nYes.\n\nNow, code:\n\nBut in the code, when building the processed, for each duration d in duration_dict, which is a list of vouchers. So that's correct.\n\nNow, code:\n\nNow, let's code this.\n\nBut in the code, the 'processed' is stored as a dictionary, where each key is a duration, and the value is a tuple of (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix",
    "response": "\n\nTo solve this problem, we need to help Leha choose two non-overlapping travel vouchers such that their combined duration exactly matches his vacation length, while minimizing the total cost. The solution involves efficiently searching for valid voucher pairs using preprocessing and binary search techniques.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly finding vouchers that could potentially form a valid pair with another voucher.\n2. **Preprocess Data Structures**: For each duration, we preprocess the vouchers into sorted lists by their end time and start time. We also compute prefix minimum cost arrays for the end-sorted list and suffix minimum cost arrays for the start-sorted list. These arrays help in quickly determining the minimum cost of valid vouchers during the search phase.\n3. **Check Valid Pairs**: For each voucher, we check if there exists another voucher with a duration such that their combined duration equals the required vacation length. Using binary search on the preprocessed data structures, we efficiently find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_right\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n    \n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    processed = dict()\n    for d in duration_dict:\n        # Process end_sorted (sorted by ri)\n        end_sorted = sorted(duration_dict[d], key=lambda x: x[1])\n        end_times = [v[1] for v in end_sorted]\n        prefix_min = [0] * len(end_sorted)\n        prefix_min[0] = end_sorted[0][2]\n        for i in range(1, len(end_sorted)):\n            prefix_min[i] = min(prefix_min[i-1], end_sorted[i][2])\n        \n        # Process start_sorted (sorted by li)\n        start_sorted = sorted(duration_dict[d], key=lambda x: x[0])\n        start_times = [v[0] for v in start_sorted]\n        suffix_min = [0] * len(start_sorted)\n        suffix_min[-1] = start_sorted[-1][2]\n        for i in range(len(start_sorted)-2, -1, -1):\n            suffix_min[i] = min(suffix_min[i+1], start_sorted[i][2])\n        \n        processed[d] = (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min)\n    \n    min_total = float('inf')\n    for l_a, r_a, cost_a in vouchers:\n        d_a = r_a - l_a + 1\n        k = x - d_a\n        if k <= 0:\n            continue\n        if k not in processed:\n            continue\n        \n        end_sorted_k, end_times_k, prefix_min_k, start_sorted_k, start_times_k, suffix_min_k = processed[k]\n        \n        # Case 1: B ends before A starts\n        target = l_a - 1\n        pos = bisect_right(end_times_k, target)\n        if pos > 0:\n            min_b = prefix_min_k[pos-1]\n            total = cost_a + min_b\n            if total < min_total:\n                min_total = total\n        \n        # Case 2: B starts after A ends\n        target = r_a\n        pos = bisect_right(start_times_k, target)\n        if pos < len(start_times_k):\n            min_b = suffix_min_k[pos]\n            total = cost_a + min_b\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for valid pairs.\n2. **Preprocessing**: For each duration, vouchers are sorted by their end time and start time. Prefix and suffix minimum cost arrays are built to quickly determine the minimum cost of valid vouchers during the search phase.\n3. **Binary Search for Valid Pairs**: For each voucher, we use binary search on the preprocessed data structures to efficiently find the minimum cost of non-overlapping vouchers that can form a valid pair with the current voucher, ensuring the combined duration matches the required vacation length.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n²) brute force method, making the solution feasible even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_right\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n    \n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    processed = dict()\n    for d in duration_dict:\n        # Process end_sorted (sorted by ri)\n        end_sorted = sorted(duration_dict[d], key=lambda x: x[1])\n        end_times = [v[1] for v in end_sorted]\n        prefix_min = [0] * len(end_sorted)\n        prefix_min[0] = end_sorted[0][2]\n        for i in range(1, len(end_sorted)):\n            prefix_min[i] = min(prefix_min[i-1], end_sorted[i][2])\n        \n        # Process start_sorted (sorted by li)\n        start_sorted = sorted(duration_dict[d], key=lambda x: x[0])\n        start_times = [v[0] for v in start_sorted]\n        suffix_min = [0] * len(start_sorted)\n        suffix_min[-1] = start_sorted[-1][2]\n        for i in range(len(start_sorted)-2, -1, -1):\n            suffix_min[i] = min(suffix_min[i+1], start_sorted[i][2])\n        \n        processed[d] = (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min)\n    \n    min_total = float('inf')\n    for l_a, r_a, cost_a in vouchers:\n        d_a = r_a - l_a + 1\n        k = x - d_a\n        if k <= 0:\n            continue\n        if k not in processed:\n            continue\n        \n        end_sorted_k, end_times_k, prefix_min_k, start_sorted_k, start_times_k, suffix_min_k = processed[k]\n        \n        # Case 1: B ends before A starts\n        target = l_a - 1\n        pos = bisect_right(end_times_k, target)\n        if pos > 0:\n            min_b = prefix_min_k[pos-1]\n            total = cost_a + min_b\n            if total < min_total:\n                min_total = total\n        \n        # Case 2: B starts after A ends\n        target = r_a\n        pos = bisect_right(start_times_k, target)\n        if pos < len(start_times_k):\n            min_b = suffix_min_k[pos]\n            total = cost_a + min_b\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1010,
        "thoughts_token_count": 8191
    }
}