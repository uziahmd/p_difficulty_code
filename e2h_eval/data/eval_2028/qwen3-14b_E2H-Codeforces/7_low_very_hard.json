{
    "start": 1758346046.1733706,
    "end": 1758346097.9028945,
    "start-formatted": "2025-09-20 14:27 KST",
    "end-formatted": "2025-09-20 14:28 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure of such a graph.\n\nSo, according to the problem statement:\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that has only one connection (i.e., the leaves) are each connected to k new vertices. This process must be done at least once. So, the construction has multiple layers.\n\nLet me think about how the number of vertices grows with each step. Let's consider the example given. For k=4, the smallest snowflake has 1 + 4 + 4*4 = 1 + 4 + 16 = 21? Wait, maybe not. Let me re-examine the steps.\n\nThe initial step: one vertex. Then, we add k vertices connected to it. So after first step, total vertices is 1 + k. Then, each of those k vertices (which are leaves) are connected to k new vertices. So for each of those k vertices, we add k new ones. So that's k * k more vertices. So total vertices now is 1 + k + k^2. But wait, the problem says that this step (adding k new vertices to each leaf) must be done at least once. So the minimal case is when we do this once. So the minimal snowflake for k=4 would have 1 + 4 + 4*4 = 21 vertices. But according to the example input, when n=13, the answer is YES. Let me check that.\n\nWait the sample input includes n=13, which outputs YES. Let me see. How can 13 be formed?\n\nLet me think of possible k and steps. Suppose k=3. Let's see:\n\nInitial step: 1.\n\nFirst expansion (connect initial node to k=3): total 1+3=4.\n\nThen, each of the 3 leaves gets connected to 3 new nodes. That adds 3*3=9, so total 4+9=13. Yes! So that's the case for n=13. So that's valid. So the snowflake here has two layers. So the structure is that the initial node has k children, and each of those children has k children. So the total is 1 + k + k^2. But wait, for that to be allowed, the step of adding the second layer (the leaves getting connected to k new nodes) must be done at least once. Which in this case, it was done once. So that's acceptable.\n\nSo the general formula for the snowflake's total number of vertices depends on how many layers are added. Let's think recursively.\n\nLet me model the construction steps. The initial step is level 0: 1 node. Then, each time we add a new layer, each leaf from the previous step is expanded into k new nodes. So the number of nodes added in each step is based on the number of leaves in the previous step.\n\nBut the problem says that the step of expanding the leaves must be done at least once. So the minimal case is when there are two layers: initial node, then first expansion (k children), then each of those children is expanded once (so each of the k children gets k children). So total nodes is 1 + k + k^2.\n\nBut what if there are more layers? Like, after expanding once, you expand again. So for example, after the initial expansion (level 1: k nodes), then expanding each of them (level 2: k^2 nodes), then expanding each of those (level 3: k^3 nodes). So the total would be 1 + k + k^2 + k^3. But according to the problem's rules, the step of expanding the leaves must be done at least once. So the initial expansion (the first step) is required. Wait, no. Let me read the problem statement again.\n\nThe initial step is: start with one node. Then, add k new nodes connected to it. Then, each vertex that is connected to only one other (i.e., the leaves) are connected to k new nodes. This step should be done at least once. So the first expansion (the initial step) is part of the construction. Then, the step of expanding the leaves (which is the second step) must be done at least once. So the minimal case is that after the initial step, you perform the expansion step once.\n\nWait, the initial step is adding the first layer. Then, the expansion step is adding the next layers. So the initial step is mandatory. The expansion step (adding layers) must be done at least once. So the minimal",
    "response": "To solve this problem, we need to determine if a given number of vertices `n` can form a valid snowflake graph as defined in the problem. The snowflake graph is constructed in layers starting from a single node and expanding outward in a specific pattern.\n\n### Approach\n1. **Understanding the Structure**: A snowflake graph starts with one node. This node is connected to `k` new nodes (where `k > 1`). Each of these new nodes (which are leaves) is then connected to `k` more new nodes, and this process must be repeated at least once.\n2. **Formulating the Pattern**: The total number of nodes for a snowflake graph can be represented as a sum of a geometric series. For `m` layers, the total number of nodes is `1 + k + k^2 + ... + k^m`. However, since the expansion step must be done at least once, the minimum structure has 3 layers: `1 + k + k^2`.\n3. **Checking Validity**: For each test case, we need to check if `n` can be expressed in the form of `1 + k + k^2 + ... + k^m` where `k > 1` and the number of terms is at least 3. This involves checking all possible values of `k` and verifying if the sum of the geometric series equals `n`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Check for the case where it's 1 + k + k^2\n    # So n = 1 + k + k^2 => k^2 + k + 1 = n\n    # Solve for k: k^2 + k + 1 - n = 0\n    # Using quadratic formula\n    # Discriminant D = 1 - 4*(1 - n) = 4n - 3\n    # k must be integer >1\n    for m in range(2, 65):  # since k >=2, and k^m can be very large\n        # Check for sum 1 + k + k^2 + ... + k^m\n        # which is (k^(m+1) - 1) / (k - 1)\n        # We need to find k such that this equals n\n        # Try different k values\n        # For each possible m (number of layers), iterate k\n        # But since k can be large, we need to bound the search\n        # Let's try for each m from 2 up to log2(n) + 1\n        # Since k >= 2, the maximum possible m is log2(n) because 2^m <= n\n        # So for each m, we can find if there exists k such that (k^(m+1) - 1)/(k-1) == n\n        # But how?\n        # For each m, we can perform a binary search on k\n        # But since m can be up to 60, and t is 1e4, we need an efficient way\n        # Let's proceed\n        # For m layers, the total is S = (k^(m+1) - 1) / (k - 1)\n        # We need to find k such that S = n\n        # For each m from 2 to 60:\n        #   Binary search k from 2 to upper bound\n        #   Compute S for k and see if it equals n\n        # But for m=2, S = 1 + k + k^2 = n\n        # So let's handle m=2 first\n        if m == 2:\n            # Solve k^2 + k + 1 = n\n            # k^2 +k + (1 -n) = 0\n            # discriminant D = 1 - 4*(1-n) = 4n -3\n            D = 4 * n - 3\n            if D < 0:\n                continue\n            sqrtD = int(math.isqrt(D))\n            if sqrtD * sqrtD != D:\n                continue\n            k1 = (-1 + sqrtD) // 2\n            k2 = (-1 - sqrtD) // 2\n            if k1 > 1 and (k1 * k1 + k1 + 1) == n:\n                return True\n            if k2 > 1 and (k2 * k2 + k2 + 1) == n:\n                return True\n        else:\n            # For m >= 3, the sum is 1 + k + ... + k^m = (k^(m+1) - 1)/(k - 1)\n            # We can binary search k for each m\n            # Let's try binary search for k in 2 to some upper limit\n            low = 2\n            high = 2\n            while (high ** (m + 1)) // (high - 1) < n:\n                high *= 2\n            # Now binary search between low and high\n            while low <= high:\n                mid = (low + high) // 2\n                # compute S = (mid^(m+1) - 1) // (mid - 1)\n                # To avoid overflow, use logarithms or iterative multiplication\n                try:\n                    numerator = pow(mid, m + 1) - 1\n                    denominator = mid - 1\n                    if denominator == 0:\n                        continue\n                    s = numerator // denominator\n                except:\n                    s = float('inf')\n                if s == n:\n                    return True\n                elif s < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read in one go for efficiency, especially given the constraints.\n2. **Checking Validity**: The function `is_snowflake` checks if a number `n` can be formed by any valid snowflake structure. It uses mathematical properties of geometric series and binary search to efficiently check possible values of `k` for different numbers of layers `m`.\n3. **Geometric Series Check**: For each possible number of layers `m`, the function checks if there exists an integer `k > 1` such that the sum of the geometric series equals `n`.\n\nThis approach ensures that we efficiently check all possible configurations without exceeding computational limits, even for very large values of `n`.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Check for the case where it's 1 + k + k^2\n    # So n = 1 + k + k^2 => k^2 + k + 1 = n\n    # Solve for k: k^2 + k + 1 - n = 0\n    # Using quadratic formula\n    # Discriminant D = 1 - 4*(1 - n) = 4n - 3\n    # k must be integer >1\n    for m in range(2, 65):  # since k >=2, and k^m can be very large\n        # Check for sum 1 + k + k^2 + ... + k^m\n        # which is (k^(m+1) - 1) / (k - 1)\n        # We need to find k such that this equals n\n        # Try different k values\n        # For each possible m (number of layers), iterate k\n        # But since k can be large, we need to bound the search\n        # Let's try for each m from 2 up to log2(n) + 1\n        # Since k >= 2, the maximum possible m is log2(n) because 2^m <= n\n        # So for each m, we can find if there exists k such that (k^(m+1) - 1)/(k-1) == n\n        # But how?\n        # For each m, we can perform a binary search on k\n        # But since m can be up to 60, and t is 1e4, we need an efficient way\n        # Let's proceed\n        # For m layers, the total is S = (k^(m+1) - 1) / (k - 1)\n        # We need to find k such that S = n\n        # For each m from 2 to 60:\n        #   Binary search k from 2 to upper bound\n        #   Compute S for k and see if it equals n\n        # But for m=2, S = 1 + k + k^2 = n\n        # So let's handle m=2 first\n        if m == 2:\n            # Solve k^2 + k + 1 = n\n            # k^2 +k + (1 -n) = 0\n            # discriminant D = 1 - 4*(1-n) = 4n -3\n            D = 4 * n - 3\n            if D < 0:\n                continue\n            sqrtD = int(math.isqrt(D))\n            if sqrtD * sqrtD != D:\n                continue\n            k1 = (-1 + sqrtD) // 2\n            k2 = (-1 - sqrtD) // 2\n            if k1 > 1 and (k1 * k1 + k1 + 1) == n:\n                return True\n            if k2 > 1 and (k2 * k2 + k2 + 1) == n:\n                return True\n        else:\n            # For m >= 3, the sum is 1 + k + ... + k^m = (k^(m+1) - 1)/(k - 1)\n            # We can binary search k for each m\n            # Let's try binary search for k in 2 to some upper limit\n            low = 2\n            high = 2\n            while (high ** (m + 1)) // (high - 1) < n:\n                high *= 2\n            # Now binary search between low and high\n            while low <= high:\n                mid = (low + high) // 2\n                # compute S = (mid^(m+1) - 1) // (mid - 1)\n                # To avoid overflow, use logarithms or iterative multiplication\n                try:\n                    numerator = pow(mid, m + 1) - 1\n                    denominator = mid - 1\n                    if denominator == 0:\n                        continue\n                    s = numerator // denominator\n                except:\n                    s = float('inf')\n                if s == n:\n                    return True\n                elif s < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 563,
        "completion_token_count": 1466,
        "thoughts_token_count": 1024
    }
}