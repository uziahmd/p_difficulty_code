{
    "start": 1758315429.8647616,
    "end": 1758315597.1123748,
    "start-formatted": "2025-09-20 05:57 KST",
    "end-formatted": "2025-09-20 05:59 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this problem where I have to determine if there's a way to assign mushroom counts to each lawn such that for every given edge (road), the GCD and LCM of the two connected lawns match the given values. If possible, output one such assignment; otherwise, output NO.\n\nLet me think about the approach here.\n\nFirst, let's understand the constraints. For each edge between two nodes u and v, we have that GCD(a_u, a_v) = g and LCM(a_u, a_v) = l. Now, I remember that for any two numbers, GCD * LCM = product of the numbers. So, a_u * a_v = g * l. Also, since GCD is g, both a_u and a_v must be multiples of g. Let me denote a_u = g * x and a_v = g * y. Then, GCD(x, y) must be 1 because we've factored out the GCD. The LCM of a_u and a_v would be g * x * y, since LCM(a_u, a_v) = (a_u * a_v)/GCD(a_u, a_v) = (g^2 x y)/g = g x y. But according to the problem, this LCM is given as l. Therefore, we have:\n\ng * x * y = l → x * y = l / g.\n\nBut since l must be divisible by g, otherwise it's impossible. Wait, right! Because LCM(a_u, a_v) must be a multiple of GCD(a_u, a_v). Because LCM is a multiple of both numbers, and GCD divides both numbers. So for each edge, if l % g != 0, then it's impossible. So first check: for each edge, check if l is divisible by g. If not, answer is NO.\n\nSo the first step is to check for all edges whether l is divisible by g. If any edge fails this, output NO.\n\nOnce that's done, for each edge, we can model the problem as building a graph where each node's value is determined by the relations between connected nodes. However, since the relations are between pairs, we need to model this as a graph where each edge imposes constraints on the values of the two nodes.\n\nBut how to model this? Since each edge gives us that a_u and a_v are multiples of g, and their product is g*l. Also, since x and y are coprime, and x*y = l/g.\n\nSo for each edge, we can represent that a_u and a_v must be multiples of g, and that their ratio (when divided by g) must be coprime, and their product is l/g.\n\nBut how do we assign values to each node?\n\nThis feels like a graph problem where each node has some value, and edges impose constraints between pairs of nodes. However, the constraints are multiplicative and involve coprimality.\n\nAlternatively, perhaps we can model this as a graph where each node's value is determined relative to others. For example, if we have a connected component, we can assign a value to one node, and derive the rest based on the edges. But how?\n\nLet me think. Suppose we have a connected component. Let's pick a root node and assign it some value. Then, for each edge, we can derive the value of the adjacent node. However, this might not be straightforward due to multiple paths leading to the same node, which could result in conflicting constraints.\n\nFor example, suppose we have two edges connecting u-v and u-w. Assigning a value to u and then deriving v and w based on their edges. Then, if there's another edge between v and w, that would impose a constraint that must be satisfied.\n\nTherefore, the problem reduces to checking if the constraints are consistent across the entire graph, and then assigning values accordingly.\n\nBut how can we model the constraints?\n\nLet me consider that for each edge between u and v, with GCD g and LCM l. Let me denote that a_u = g * x, a_v = g * y. As before, x and y are coprime, and x * y = l/g.\n\nSo, for each edge, the pair (x, y) must be such that x and y are coprime and their product is (l/g). However, there are multiple possibilities for x and y. For example, if l/g is 6, then x could be 1 and y 6, or 2 and 3, etc., as long as they are coprime.\n\nBut the problem is that for each edge, we have to choose x and y such that they are coprime and their product is fixed. However, the choice of x and y affects the possible assignments of the nodes. So, how can we model this?\n\nThis seems like a problem where we need to assign variables to each node, such that for each edge, the variables satisfy the constraints. However, the variables are not independent, and there's a dependency between them.\n\nAn alternative approach is to model this as a graph where each node's value is determined up to a certain factor. For example, for each connected component, we can assign a base value to a node, and then for each edge, determine the value of the other node based on the edge's constraints. However, since multiple edges can lead to the same node, we need to ensure that all constraints are satisfied.\n\nLet me think of the following approach:\n\nFor each connected component in the graph (since the graph may be disconnected), we can assign a value to one node (say, the root of the component), and then perform a BFS or DFS to assign values to other nodes based on the edges. However, during this process, we must ensure that the constraints are satisfied, and that when we reach a node that's already been assigned a value, the new value matches the existing one.\n\nBut how to compute the value of a node once we have an edge between it and another node?\n\nLet me take an example. Suppose we have an edge between u and v with GCD g and LCM l. Let's say that during traversal, we have already assigned a value to u, say a_u. Then, we can compute a_v based on the edge's constraints.\n\nFrom earlier, we know that a_u * a_v = g * l. So, a_v = (g * l) / a_u. However, this requires that a_u divides (g*l), which is true if the initial assignment is correct. Also, we need to ensure that GCD(a_u, a_v) = g and LCM(a_u, a_v) = l. But since a_u * a_v = g*l, and the GCD is g, then LCM(a_u, a_v) is (a_u * a_v)/g = (g*l)/g = l, which satisfies the LCM condition. So, if we can ensure that GCD(a_u, a_v) is indeed g, then the conditions are satisfied.\n\nWait, but how can we ensure that? Because when we compute a_v = (g*l)/a_u, then the GCD of a_u and a_v must be equal to g. Let's check this.\n\nLet me take a_u and a_v = (g*l)/a_u. Let me compute GCD(a_u, a_v). Let's denote that a_u = g * x, a_v = g * y. Then, x * y = l/g. And GCD(x, y) = 1. So, GCD(gx, gy) = g * GCD(x, y) = g * 1 = g. So yes, this holds. Therefore, as long as a_u and a_v are set as (g*l)/a_u, and a_u is set correctly, then the GCD and LCM conditions will be satisfied.\n\nBut how do we ensure that a_u is set correctly?\n\nThe problem comes when there are multiple edges leading to the same node. For example, suppose we have a cycle in the graph. If during BFS/DFS, we assign a value to a node via one path, but then another path gives a conflicting value, then it's impossible.\n\nSo, the approach is:\n\n- For each connected component, assign a value to a starting node (say, 1), then propagate the values through the edges. However, the value of the starting node must be chosen such that all constraints are satisfied.\n\nWait, but how can we choose the starting node's value? Because for the starting node, there's no constraints except those from its edges. But if the starting node is part of multiple edges, then the value must be compatible with all of them.\n\nWait, but if we start with a node that has no constraints (like in a component with only one node and zero edges), then the value can be anything. But according to the problem statement, the initial map had roads with numbers ≥1, but in the input, for example, when m=0, the answer is possible (as in the first sample input where n=1 and m=0, output is 1).\n\nBut in our case, for a component with no edges, each node can have any value. However, the problem says that the original map had numbers ≥1, but since the problem allows any valid arrangement, perhaps we can assign any value to the nodes in such components. However, since the problem requires us to output any valid arrangement, perhaps we can assign 1 to all nodes in such components.\n\nBut wait, in the first sample input, the first case is n=1, m=0. The output is 1. Which makes sense.\n\nSo, the idea is:\n\nFor each connected component in the graph, perform a BFS or DFS. Assign a value to the starting node (say, 1), and then for each adjacent node, compute the required value based on the edge's GCD and LCM. However, if during traversal, we find that the computed value conflicts with an existing value, then the answer is NO.\n\nBut wait, what if the starting node's value is not compatible with the edges? For example, suppose there is an edge between u and v with GCD g and LCM l. Suppose we assign a_u as some value, then a_v must be (g*l)/a_u. However, if there's another edge involving u, say between u and w, then a_w is determined based on that edge. But if there's a cycle, then the assignments must be consistent.\n\nBut how do we choose the initial value for the starting node?\n\nBecause the initial value can be any value that is compatible with the constraints of the edges. However, the problem is that for a connected component, the initial value is not arbitrary. Let me think.\n\nSuppose we have a connected component. Let's take an edge between u and v with GCD g and LCM l. Then, a_u * a_v = g*l. Also, the GCD(a_u, a_v) is g. So, a_u must be a multiple of g, and a_v must be a multiple of g. So, for any node in the component, its value must be a multiple of the GCDs along the paths to the root.\n\nBut how can we model this?\n\nAlternatively, maybe the starting node's value can be chosen as g multiplied by some value, but how to determine that?\n\nWait, perhaps the problem is that for each connected component, the values of the nodes are determined up to a multiplicative factor. However, this seems complicated.\n\nWait, but if we start with a node and assign a value, then all other nodes' values are determined by the edges. However, for the component to be valid, the assignments must be consistent. For example, if during BFS, we reach a node that was already assigned a value, then the new value computed from the current edge must match the existing value.\n\nBut what if the initial assignment is wrong? For example, suppose the component is a single edge between u and v. Then, a_u * a_v = g*l. However, the initial assignment of a_u could be any value that divides g*l, and then a_v would be determined. However, there's no way to know which value to choose for a_u.\n\nBut here's the problem: the value of a_u is determined by the constraints of the edges. However, when the component is connected, the constraints may not allow any choice. For example, in the case of a cycle.\n\nLet me take an example. Suppose there is a triangle of three nodes u, v, w. Each edge between u-v has GCD 1 and LCM 6. Between v-w, same. Between w-u, same. Let's see.\n\nEach edge implies that the product of the two nodes is 1*6=6. So for u and v, a_u * a_v =6. Similarly for v*w and w*u.\n\nSo, a_u * a_v =6, a_v * a_w =6, a_w * a_u =6. Multiplying all three equations: (a_u a_v a_w)^2 = 6^3 → a_u a_v a_w = 6^(3/2). Which is impossible, since the product must be integer. Hence, no solution exists. So the answer is NO.\n\nBut how does this fit into our approach? If during BFS, we assign a_u as 1, then a_v would be 6. Then, moving to v's neighbor w, we compute a_w = 6 / a_v = 6/6 =1. Then, moving to w's neighbor u, we compute a_u = 6 / a_w =6/1=6. But the initial a_u was 1. Contradiction. Hence, the answer is NO.\n\nSo, the approach of assigning a starting value and propagating through the edges works, but if during the traversal, a conflict is found, the answer is NO.\n\nBut the problem is that the initial value of the starting node may be arbitrary. How can we choose it?\n\nWait, but in the example above, even if we choose a different starting value, say a_u = 2, then a_v would be 3. Then, a_w would be 6/3 = 2. Then, a_u would be 6/2 =3. But initial a_u was 2. Conflict again. So regardless of the initial value, there's a contradiction.\n\nHence, the problem is that the constraints in the component are such that the product of the nodes around the cycle leads to a contradiction. Therefore, the approach of choosing an arbitrary starting value and propagating is correct, but the initial value may not be arbitrary. Wait, but how?\n\nWait, but in this example, the initial value is arbitrary. However, the constraints of the edges force the value to be something else. Hence, regardless of the initial value, the propagation leads to a contradiction. Therefore, the answer is NO.\n\nBut how do we choose the initial value? Because for some cases, the initial value can be any value that is compatible with the edges.\n\nWait, but in the case of a single edge between u and v, with GCD g and LCM l. Let's say the edge is between u and v. Then, a_u * a_v = g*l. However, the GCD(a_u, a_v) must be g. So, a_u = g * x, a_v = g * y, where x and y are coprime, x*y = l/g. So, for example, if l/g is 6, then x and y can be 1 and 6, or 2 and 3. Therefore, there are multiple possibilities for the values of a_u and a_v. But in our approach, when we assign a value to u, say a_u = g * x, then a_v is determined as (g*l)/a_u = g*l/(g x) = l/x. Which equals g y, since x y = l/g → y = (l/g)/x → g y = g * (l/g)/x = l/x. So, this is correct.\n\nBut how can we choose x? Well, during the BFS/DFS, the initial value of u can be any multiple of g, but how do we know which one to choose?\n\nAh, but in this case, the initial value can be any value that is compatible with the edges. However, since we don't have any other constraints, we can choose any value for u, then compute v accordingly. But how to choose that value?\n\nWait, but in this case, the problem allows any valid assignment. So, perhaps for the starting node, we can assign a value of g multiplied by one of the factors of l/g. However, since we don't know which one, how can we proceed?\n\nBut in the case of a connected component with no cycles, the initial value can be chosen arbitrarily, as long as it's compatible with the edges. But how to choose it?\n\nWait, perhaps the initial value can be set to g * x, where x is a factor of (l/g) such that x and (l/g)/x are coprime. However, since x and (l/g)/x must be coprime, x must be a divisor of (l/g) and co-prime with (l/g)/x. Which is equivalent to x being a divisor of (l/g) and x and (l/g)/x are coprime. Which implies that x is a square-free divisor of (l/g) and that x is a product of distinct primes in the prime factorization of (l/g). But this seems complicated.\n\nAlternatively, perhaps the initial value can be set to g * x, where x is any divisor of (l/g) that is coprime with (l/g)/x. But how to choose x?\n\nBut in the BFS approach, when we assign a value to the starting node, perhaps we can choose any possible value that meets the constraints of the edges connected to it. However, since the graph is connected, the initial value may affect the rest of the assignments, and if there's a cycle, the constraints may require that the initial value is chosen in a certain way.\n\nBut how can we handle this?\n\nThis seems tricky. Maybe there's another way. Let's think again about the relation between the nodes. For any two nodes connected by an edge, their product is fixed. So, if the graph is connected, then all the nodes' values are determined up to a multiplicative constant. Wait, no. Let me think.\n\nSuppose we have a connected component. Let's assume that for any edge between u and v, a_u * a_v = k_uv, where k_uv is fixed for that edge. Then, the product of all the a_i's around a cycle must be consistent. For example, in a triangle u-v-w-u, the product a_u * a_v = k1, a_v * a_w = k2, a_w * a_u = k3. Multiplying all three equations gives (a_u a_v a_w)^2 = k1 k2 k3. Therefore, the product of the three k's must be a perfect square. Otherwise, no solution exists. So, this suggests that for the component to be valid, all cycles must satisfy such conditions.\n\nBut how can we check this during BFS/DFS?\n\nAlternatively, perhaps the approach is to assign a value to the starting node, and then propagate the values. However, the problem is that the initial value may not be compatible with the constraints. So, how can we choose the initial value?\n\nWait, perhaps the initial value can be set to the GCD of the component. But I'm not sure.\n\nAlternatively, perhaps the initial value can be set to any value that is a multiple of the GCDs of the edges connected to the starting node. For example, if the starting node is connected to multiple edges, each with their own GCDs. But how?\n\nAlternatively, perhaps the initial value can be set to the GCD of all the edges' GCDs in the component. But again, not sure.\n\nAlternatively, perhaps we can model the problem as follows: for each node, the value must be a multiple of the GCDs of all edges connected to it. However, this is not necessarily true. For example, consider a node u connected to v with GCD g. Then, a_u must be a multiple of g, and a_v must be a multiple of g. But if u is connected to another node w with GCD h, then a_u must be a multiple of h as well. Therefore, a_u must be a multiple of the LCM of all the GCDs of edges connected to u. But how can we compute that?\n\nBut this seems complicated. Let's think again of the BFS approach. Let's assume that the starting node's value can be set to any value that is compatible with the constraints. However, since the problem allows any valid assignment, perhaps we can choose the value of the starting node as the GCD of the component. Or perhaps set it to the GCD of the edges connected to it.\n\nBut how can we know?\n\nAlternatively, perhaps the initial value can be set to the GCD of the component's edges. But this is unclear.\n\nAnother thought: For any connected component, the values of the nodes are determined up to a multiplicative factor. For example, if you have a tree structure, you can assign the root any value, and then compute the rest. However, if there's a cycle, the multiplicative factors must be consistent.\n\nBut how?\n\nLet me take an example. Suppose we have a tree with nodes u connected to v, and v connected to w. The edges are u-v with GCD g1 and LCM l1, and v-w with GCD g2 and LCM l2. Then, the product of u and v is g1*l1. The product of v and w is g2*l2. Suppose we assign u's value as a. Then, v's value is (g1*l1)/a. Then, w's value is (g2*l2) / [(g1*l1)/a] ] = (g2*l2 * a) / (g1*l1). \n\nBut this depends on a. However, there are no constraints on a except that a must be compatible with the edges. For example, a must be a multiple of g1 (since u and v's GCD is g1). Also, since v's value is (g1*l1)/a, and v's value must be a multiple of g1 (from the edge u-v) and also a multiple of g2 (from the edge v-w). Wait, no. The GCD for the edge v-w is g2. So, the GCD of v's value and w's value is g2. Therefore, v's value must be a multiple of g2, and w's value must be a multiple of g2. But how?\n\nLet me re-express. Let's take the edge between u and v. The GCD of a_u and a_v is g1. Therefore, a_u = g1 * x, a_v = g1 * y, where x and y are coprime, and x*y = l1/g1. Similarly, for the edge between v and w, a_v = g2 * p, a_w = g2 * q, with p and q coprime, and p*q = l2/g2. \n\nBut from the previous calculation, a_v = g1 * y = g2 * p. Therefore, g1 * y must be divisible by g2. Which implies that g2 divides g1 * y. Since y is coprime with x (which is a_u/g1), but not sure how that helps.\n\nThis seems complex. However, during BFS, if we assign a value to u, then compute v's value, then compute w's value, and so on, but during this process, we must ensure that the constraints are satisfied. However, if there's a cycle, then the BFS will detect a conflict.\n\nSo, perhaps the approach is to:\n\n- For each connected component:\n\n   - Choose a starting node.\n\n   - Assign a value to it (but how?).\n\n   - Then perform BFS/DFS, assigning values to adjacent nodes based on the edge constraints.\n\n   - If during BFS/DFS, a conflict is found (i.e., a node is already assigned a value that doesn't match the computed value), return NO.\n\nBut how to choose the starting node's value?\n\nAh! Here's an insight: the value of the starting node must be a multiple of the GCD of all edges connected to it. However, since the edges are not yet processed, perhaps the starting node's value can be set to the GCD of the first edge connected to it. But this might not work for multiple edges.\n\nAlternatively, perhaps the starting node's value can be set to the GCD of the component. But again, not sure.\n\nAlternatively, perhaps the starting node's value can be set to the GCD of the first edge's GCD. For example, if the first edge is between u and v with GCD g, then assign a_u = g. Then, a_v = (g * l) / a_u = l. Then, check if GCD(g, l) is indeed g. Since l is a multiple of g (as per the earlier check), then GCD(g, l) is g. So this would satisfy the condition.\n\nBut why can't we choose a_u = g * k, where k is any integer? Because then a_v would be (g*l)/(g*k) = l/k. However, for this to be valid, l must be divisible by k, and the GCD of a_u and a_v must be g. But since a_u is g*k and a_v is l/k, then GCD(gk, l/k) must be g. This may not hold unless k divides l/g and l/k is such that GCD(k, l/(g*k)) is 1. Hmm, this seems complicated.\n\nBut if we choose a_u = g, then a_v = l. Then, since l is a multiple of g (from earlier check), then GCD(g, l) is g. Which is correct. Also, LCM(g, l) is l, which is correct. So this assignment is valid.\n\nTherefore, for the starting node, we can assign it the GCD of the first edge connected to it. Then, proceed with the BFS/DFS. This ensures that the initial assignment is valid.\n\nSo, the steps are:\n\nFor each connected component:\n\n   - If the component has no edges (i.e., isolated nodes), assign each node a value of 1 (or any value, but 1 is safe).\n\n   - Else, pick a starting node (say, the first node in the component), and for the first edge connected to it, assign the starting node's value as the GCD of that edge. Then proceed with BFS/DFS.\n\nBut how to handle cases where the starting node has multiple edges?\n\nFor example, suppose the starting node u is connected to v and w. The edges u-v and u-w have different GCDs. Then, assigning u's value as the GCD of the first edge may not be compatible with the second edge.\n\nBut how?\n\nWait, for example, suppose u is connected to v with GCD g1 and LCM l1, and to w with GCD g2 and LCM l2. Assigning a_u = g1. Then, a_v = (g1*l1)/a_u = l1. Then, for the edge u-w, the GCD of a_u and a_w must be g2. Since a_u is g1, then a_w must be a multiple of g2, and GCD(g1, a_w) = g2. But this implies that g2 divides g1. Otherwise, the GCD(g1, a_w) can't be g2. For example, if g1 is 2, and g2 is 3, then the GCD of 2 and a_w must be 3, which is impossible. Hence, this would be invalid.\n\nBut according to the problem statement, the original map was valid, but after tearing, the current map may be invalid. However, during processing, we need to check for validity.\n\nSo, in this case, if during BFS, after assigning a_u = g1, and then trying to process the edge between u and w, we find that the required GCD is g2, but the current a_u (g1) and the computed a_w (which would be (g2 * l2)/a_u) must have a GCD of g2. However, how can we ensure that?\n\nThis suggests that the initial assignment of a_u = g1 may not be compatible with other edges connected to u. Hence, the approach of setting a_u to the GCD of the first edge may not work.\n\nThis is a problem. How can we choose the initial value for the starting node to satisfy all edges connected to it?\n\nThis seems like a dead end. Let's think again.\n\nAlternative approach:\n\nEach edge between u and v requires that a_u and a_v are multiples of g (the GCD of the edge). Let's denote that a_u = g * x, a_v = g * y. Then, x and y are coprime, and x*y = l/g. Therefore, for each edge, the product of x and y is fixed, and they are coprime.\n\nNow, considering that, the problem can be transformed into a graph where each node has a value that is a product of some factors, but the relations between nodes are multiplicative. However, this is still abstract.\n\nAnother idea: For each node, the value is determined by the product of the GCDs of the edges along the path from the root to the node. But I'm not sure.\n\nAlternatively, since the product of a_u and a_v is fixed for each edge, the value of a node can be determined relative to another node. For example, if u and v are connected by an edge, then a_u = (g * l) / a_v. So, the value of a_u is uniquely determined once a_v is known. Thus, the entire component can be treated as a system of equations where each equation is a_u * a_v = k (for some k). Therefore, if the component is a tree, we can assign a value to the root and compute the rest. However, for cycles, the equations must be consistent.\n\nThus, the key idea is to perform BFS/DFS and assign values based on the edges, but during this process, check for consistency. However, the initial value of the root can be arbitrary as long as it satisfies the constraints of the edges connected to it. However, how to choose it?\n\nWait, but if the component is a tree, then the initial value can be chosen arbitrarily. However, for the root's edges, the initial value must be compatible with the constraints. For example, if the root is connected to a node v, then the product of the root's value and v's value must be equal to g * l. Therefore, if the root's value is chosen as a_u, then v's value is (g*l)/a_u. However, since the root's value must be a multiple of the GCD of the edge (g), then a_u must be a multiple of g. So, for the root's value, we can choose a_u = g * x, where x is any positive integer. However, this choice affects the rest of the assignments.\n\nBut since the problem allows any valid assignment, perhaps we can choose x = 1. That is, assign the root's value as g (the GCD of the edge). Then, proceed with the BFS/DFS. However, this may not be compatible with other edges connected to the root. For example, if the root is connected to two edges with different GCDs, then the initial assignment of the root's value may not satisfy both.\n\nLet me think of an example. Suppose the root u is connected to v via an edge with GCD 2 and LCM 6. Also, connected to w via an edge with GCD 3 and LCM 9. Then, the product for u and v is 2*6=12, and for u and w is 3*9=27. Assigning u's value as 2 (the GCD of the first edge), then v's value is 12/2 = 6. Then, for the edge between u and w, the product must be 27. But u's value is 2, so w's value must be 27/2, which is not an integer. Hence, invalid. So this assignment fails.\n\nBut the problem is that the initial assignment of u's value is not compatible with the other edges connected to it. So, how can we choose the initial value?\n\nIn this case, there is no solution. Because for the root u, the value must satisfy that 2 divides a_u (from the first edge), and 3 divides a_u (from the second edge). Hence, a_u must be a multiple of LCM(2,3)=6. Let's say a_u = 6. Then, for the first edge, v's value is 12/6 = 2. Check GCD(6,2)=2, which is correct. For the second edge, w's value is 27/6 = 4.5, which is not an integer. Hence, invalid. So no solution exists.\n\nBut how can we detect this during BFS/DFS?\n\nIf we choose a_u = 6 (the LCM of the GCDs of the edges connected to u), then during BFS, when processing the edge between u and w, we get a non-integer value for w. Hence, the answer is NO.\n\nBut how can we choose a_u to be 6 in the first place? Because during BFS, we can't know that.\n\nThis suggests that the initial assignment of the root's value is critical and must be chosen in a way that satisfies all edges connected to it. However, how to determine this value?\n\nIt seems that the problem is more complex than I initially thought. Perhaps the correct approach is to model this as a graph where each node's value is determined relative to others, and during BFS, whenever we encounter a new node, we assign it a value based on the current edge. However, for the starting node, we need to assign a value that satisfies all edges connected to it. This seems impossible unless we can find a common value that satisfies all these edges.\n\nBut how?\n\nLet me think about the starting node u. Suppose it has multiple edges. For each edge, say between u and v_i, the product of a_u and a_v_i is k_i = g_i * l_i. Also, since a_u must be a multiple of g_i for each edge. Therefore, a_u must be a multiple of the LCM of all the g_i's of the edges connected to u.\n\nLet me denote that the LCM of the GCDs of all edges connected to u as G. Then, a_u must be a multiple of G. Let's choose a_u = G. Then, for each edge between u and v_i, a_v_i = k_i / a_u. Since a_u is a multiple of g_i, k_i is divisible by g_i, and since a_u is a multiple of g_i, then k_i / a_u is (g_i * l_i) / a_u. Since a_u is a multiple of g_i, this is (l_i) / (a_u/g_i). However, this must be an integer. \n\nBut how can we ensure that?\n\nWell, for example, if a_u is set to G (the LCM of the g_i's), then for each edge, since G is a multiple of g_i, then a_u = G = g_i * m_i, where m_i is an integer. Then, a_v_i = (g_i * l_i) / (g_i * m_i) ) = l_i / m_i. For this to be an integer, m_i must divide l_i. \n\nBut how do we know that m_i divides l_i?\n\nThis depends on the specific values of g_i and l_i. However, since the original problem states that the input data is derived from a valid original map, but after tearing, it may be invalid. So, during processing, we need to check for these conditions.\n\nBut how can we choose a_u = G and then check whether for each edge, l_i is divisible by m_i?\n\nBut m_i is G / g_i. So, for each edge between u and v_i, we need to check that l_i is divisible by (G / g_i).\n\nIf this is not the case, then the assignment is invalid, and the answer is NO.\n\nSo, the approach for the starting node is:\n\n- Compute the LCM of all the GCDs of edges connected to it. Let's call this G.\n\n- Set a_u = G.\n\n- For each edge connected to u, compute a_v_i = (g_i * l_i) / a_u.\n\n- Check that a_v_i is an integer. If not, return NO.\n\n- Proceed with BFS/DFS, assigning the values.\n\nBut how do I compute G, the LCM of the GCDs of edges connected to the starting node?\n\nThis seems feasible. For example, during the BFS, when we first visit the starting node, we can look at all edges connected to it, collect their GCDs, compute their LCM, and set the starting node's value as that LCM.\n\nBut what if the starting node has no edges (i.e., it's an isolated node)? Then, we can assign it 1.\n\nSo, putting it all together, the steps for solving the problem are:\n\n1. Check for each edge whether l is divisible by g. If not, output NO.\n\n2. Build the graph.\n\n3. For each connected component:\n\n   a. If the component has no edges (all nodes are isolated):\n\n      i. Assign each node a value of 1.\n\n   b. Else:\n\n      i. Select a starting node (e.g., the first node in the component).\n\n      ii. Collect all edges connected to the starting node. For each edge, take the GCD (g_i) of that edge.\n\n      iii. Compute G = LCM of all g_i's.\n\n      iv. Assign the starting node's value as G.\n\n      v. For each edge connected to the starting node, compute the adjacent node's value as (g_i * l_i) / G. Check if this is an integer. If not, output NO.\n\n      vi. Perform BFS/DFS from the starting node, assigning values to other nodes based on the edges.",
    "response": "To solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn such that the given GCD and LCM values for each road between lawns are satisfied. If possible, we should output one valid configuration; otherwise, we should output \"NO\".\n\n### Approach\n1. **Check Validity of Input**: For each edge, ensure that the LCM is divisible by the GCD. If not, the answer is immediately \"NO\".\n2. **Graph Construction**: Represent the lawns and roads as a graph where each node is a lawn and each edge contains the GCD and LCM values.\n3. **Component-wise Processing**: Process each connected component of the graph separately.\n4. **BFS/DFS Traversal**: For each connected component, use BFS or DFS to assign mushroom counts starting from an arbitrary node. The initial value for the starting node is determined based on the LCM of the GCDs of its connected edges.\n5. **Consistency Check**: During traversal, ensure that each assignment is consistent with the given constraints. If any inconsistency is found, output \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    visited = [False] * n\n    result = [0] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            # Check if this component has any edges\n            has_edges = False\n            for neighbor, _, _ in graph[start]:\n                if neighbor != start:\n                    has_edges = True\n                    break\n            if not has_edges:\n                # All nodes in this component are isolated\n                for i in range(n):\n                    if not visited[i]:\n                        result[i] = 1\n                        visited[i] = True\n                continue\n            \n            # Find all edges connected to start\n            connected_gcds = []\n            for neighbor, g, l in graph[start]:\n                connected_gcds.append(g)\n            \n            # Compute LCM of connected_gcds\n            def lcm(a, b):\n                return a * b // math.gcd(a, b)\n            \n            current_lcm = 1\n            for g in connected_gcds:\n                current_lcm = lcm(current_lcm, g)\n            \n            # Assign start's value as current_lcm\n            result[start] = current_lcm\n            visited[start] = True\n            \n            # Check all edges from start\n            for neighbor, g, l in graph[start]:\n                val = (g * l) // result[start]\n                if (g * l) % result[start] != 0:\n                    print(\"NO\")\n                    return\n                # Proceed to process the neighbor\n                queue = deque()\n                queue.append((neighbor, val))\n                visited[neighbor] = True\n                result[neighbor] = val\n                \n                while queue:\n                    curr, curr_val = queue.popleft()\n                    for next_node, g_edge, l_edge in graph[curr]:\n                        if not visited[next_node]:\n                            new_val = (g_edge * l_edge) // curr_val\n                            if (g_edge * l_edge) % curr_val != 0:\n                                print(\"NO\")\n                                return\n                            result[next_node] = new_val\n                            visited[next_node] = True\n                            queue.append((next_node, new_val))\n                        else:\n                            expected = (g_edge * l_edge) // curr_val\n                            if (g_edge * l_edge) % curr_val != 0:\n                                print(\"NO\")\n                                return\n                            if result[next_node] != expected:\n                                print(\"NO\")\n                                return\n    \n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Validation**: Each edge is checked to ensure the LCM is divisible by the GCD. If not, the answer is immediately \"NO\".\n2. **Graph Construction**: The graph is built using adjacency lists to represent the connections between lawns.\n3. **Component Processing**: Each connected component is processed separately. For components with no edges, each node is assigned a default value of 1.\n4. **BFS Traversal**: Starting from an arbitrary node, the BFS ensures that each node's value is derived from its neighbors using the given GCD and LCM constraints. Consistency checks during traversal ensure that the derived values meet the required conditions.\n5. **Output**: If all constraints are satisfied, the configuration is printed; otherwise, \"NO\" is printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    visited = [False] * n\n    result = [0] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            # Check if this component has any edges\n            has_edges = False\n            for neighbor, _, _ in graph[start]:\n                if neighbor != start:\n                    has_edges = True\n                    break\n            if not has_edges:\n                # All nodes in this component are isolated\n                for i in range(n):\n                    if not visited[i]:\n                        result[i] = 1\n                        visited[i] = True\n                continue\n            \n            # Find all edges connected to start\n            connected_gcds = []\n            for neighbor, g, l in graph[start]:\n                connected_gcds.append(g)\n            \n            # Compute LCM of connected_gcds\n            def lcm(a, b):\n                return a * b // math.gcd(a, b)\n            \n            current_lcm = 1\n            for g in connected_gcds:\n                current_lcm = lcm(current_lcm, g)\n            \n            # Assign start's value as current_lcm\n            result[start] = current_lcm\n            visited[start] = True\n            \n            # Check all edges from start\n            for neighbor, g, l in graph[start]:\n                val = (g * l) // result[start]\n                if (g * l) % result[start] != 0:\n                    print(\"NO\")\n                    return\n                # Proceed to process the neighbor\n                queue = deque()\n                queue.append((neighbor, val))\n                visited[neighbor] = True\n                result[neighbor] = val\n                \n                while queue:\n                    curr, curr_val = queue.popleft()\n                    for next_node, g_edge, l_edge in graph[curr]:\n                        if not visited[next_node]:\n                            new_val = (g_edge * l_edge) // curr_val\n                            if (g_edge * l_edge) % curr_val != 0:\n                                print(\"NO\")\n                                return\n                            result[next_node] = new_val\n                            visited[next_node] = True\n                            queue.append((next_node, new_val))\n                        else:\n                            expected = (g_edge * l_edge) // curr_val\n                            if (g_edge * l_edge) % curr_val != 0:\n                                print(\"NO\")\n                                return\n                            if result[next_node] != expected:\n                                print(\"NO\")\n                                return\n    \n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 1121,
        "thoughts_token_count": 8192
    }
}