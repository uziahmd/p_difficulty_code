{
    "start": 1758008327.6860065,
    "end": 1758008514.1917334,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs of vouchers that satisfy these conditions and find the minimum sum of their costs.\n\nConstraints are n up to 2e5, which is big. So O(n^2) approaches are definitely out of the question. Need an efficient way.\n\nLet me think about how to approach this.\n\nFirst, for each voucher, we can calculate its duration. Let's say duration is d. Then, for each voucher with duration d, we need another voucher with duration x - d. And those two vouchers must not overlap.\n\nSo the idea is: for each voucher, check if there exists another voucher with duration (x - d), and that they don't overlap. Then take the minimum cost for such pairs.\n\nBut how to efficiently find the minimum cost for the other voucher?\n\nLet me think about grouping vouchers by their duration. For example, create a dictionary where key is the duration, and value is a list of vouchers with that duration, sorted by their li and ri.\n\nBut even then, for each voucher with duration d, we need to find vouchers with duration (x - d) that do not overlap with it.\n\nBut how to find the minimal cost for such vouchers?\n\nFor example, suppose we have a voucher A with duration d, and we need to find vouchers B with duration (x - d) that end before A starts, or start after A ends.\n\nSo for each voucher A, we can look into the group of vouchers with duration (x - d). For each such group, we can find the minimum cost of vouchers that end before A's li, or start after A's ri.\n\nBut how to do that efficiently?\n\nLet me think. For each duration, we can pre-process the vouchers in that duration. For example, for vouchers of duration k, we can sort them by their ri (end time), and also by their li (start time). Then, for a given voucher A, which has li and ri, when looking for vouchers B with duration k = x - d, we can:\n\n- Find all vouchers B where ri_B < li_A. Since they end before A starts. For these, the earliest possible B would be any, but we need the minimal cost. So for all B in the k group with ri < li_A, find the minimal cost.\n\nSimilarly, find all B where li_B > ri_A. For those, find the minimal cost.\n\nSo for each duration k, we can pre-process two structures:\n\n1. A sorted list of ri values, along with the minimum cost up to that point. So for example, for the k group, sorted by ri, we can have a prefix min array. Then, for a given li_A, we can binary search the largest ri_B that is less than li_A. Then, the prefix min array up to that index gives the minimal cost among all vouchers B that end before li_A.\n\nSimilarly, for the li_B, sorted in ascending order, and for a given ri_A, find the first li_B that is greater than ri_A, and then find the minimal cost from that point onwards.\n\nWait, but how to handle both cases?\n\nAlternatively, for each duration k, we can have two sorted lists:\n\n- One sorted by ri (end time), and for each position, we have the minimum cost up to that point. This allows us to query for vouchers ending before a certain time.\n\n- Another sorted by li (start time), and for each position, the minimum cost from that point onwards. This allows us to query for vouchers starting after a certain time.\n\nSo for example, for vouchers with duration k, sorted by ri, and a prefix min array. Then, given a target li_A, we can find the maximum ri_B that is less than li_A. Then, the min cost up to that index is the minimal possible for vouchers ending before li_A.\n\nSimilarly, for vouchers with duration k sorted by li, and a suffix min array. Given a target ri_A, find the first li_B that is larger than ri_A, and then the suffix min array gives the minimal cost from that index onwards.\n\nThis seems feasible.\n\nSo the plan is:\n\n- Preprocess all vouchers, group them by their duration. For each duration, store two sorted lists:\n\n   a. Sorted by ri, with a prefix min array (so for any",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, while minimizing the total cost. The solution involves efficiently searching for such pairs using preprocessing and binary search techniques.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This allows us to quickly access all vouchers of a specific duration when needed.\n2. **Preprocessing for Efficient Search**: For each duration, maintain two sorted lists:\n   - One sorted by the end date (`ri`) with a prefix minimum cost array to quickly find the minimum cost of vouchers ending before a specific date.\n   - Another sorted by the start date (`li`) with a suffix minimum cost array to quickly find the minimum cost of vouchers starting after a specific date.\n3. **Binary Search for Non-overlapping Vouchers**: For each voucher, check if there exists another voucher with the complementary duration (i.e., `x - duration`). Use binary search on the preprocessed lists to find valid non-overlapping vouchers efficiently.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration, we have:\n    # - sorted by ri, with prefix min cost\n    # - sorted by li, with suffix min cost\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by ri\n        sorted_by_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_ri:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        # Sort by li\n        sorted_by_li = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_li)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_li))):\n            l, r, cost = sorted_by_li[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        processed[d] = (sorted_by_ri, prefix_min, sorted_by_li, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Get the processed data for target_d\n        sorted_by_ri, prefix_min, sorted_by_li, suffix_min = processed[target_d]\n        # Check for vouchers that end before l1\n        # Find the largest ri in sorted_by_ri that is < l1\n        # Use bisect to find insertion point\n        ri_list = [r for (l, r, c) in sorted_by_ri]\n        pos = bisect.bisect_left(ri_list, l1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n        # Check for vouchers that start after r1\n        # Find the first li in sorted_by_li that is > r1\n        li_list = [l for (l, r, c) in sorted_by_li]\n        pos = bisect.bisect_right(li_list, r1)\n        if pos < len(li_list):\n            min_cost = suffix_min[pos]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with their start date, end date, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for complementary durations.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end date and start date, with corresponding prefix and suffix minimum cost arrays to allow efficient range minimum queries.\n4. **Binary Search for Non-overlapping Pairs**: For each voucher, we check for valid non-overlapping vouchers of the complementary duration using binary search on the preprocessed lists, ensuring efficient query times.\n\nThis approach ensures that we efficiently find the minimum cost pairs of vouchers meeting the problem's constraints, leveraging sorting, binary search, and preprocessing for optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration, we have:\n    # - sorted by ri, with prefix min cost\n    # - sorted by li, with suffix min cost\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by ri\n        sorted_by_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_ri:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        # Sort by li\n        sorted_by_li = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_li)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_li))):\n            l, r, cost = sorted_by_li[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        processed[d] = (sorted_by_ri, prefix_min, sorted_by_li, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Get the processed data for target_d\n        sorted_by_ri, prefix_min, sorted_by_li, suffix_min = processed[target_d]\n        # Check for vouchers that end before l1\n        # Find the largest ri in sorted_by_ri that is < l1\n        # Use bisect to find insertion point\n        ri_list = [r for (l, r, c) in sorted_by_ri]\n        pos = bisect.bisect_left(ri_list, l1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n        # Check for vouchers that start after r1\n        # Find the first li in sorted_by_li that is > r1\n        li_list = [l for (l, r, c) in sorted_by_li]\n        pos = bisect.bisect_right(li_list, r1)\n        if pos < len(li_list):\n            min_cost = suffix_min[pos]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1142,
        "thoughts_token_count": 1023
    }
}