{
    "start": 1758313552.7757554,
    "end": 1758313607.4858475,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, Leha wants to choose exactly two vouchers that don't overlap. The sum of their durations must be exactly x. And we need to find the minimal total cost of such a pair. If there's no such pair, output -1.\n\nFirst, understanding the voucher durations. Each voucher's duration is ri - li + 1. So for each voucher, I can precompute that. Then, for two vouchers i and j, their durations must add up to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs of vouchers where their durations sum to x, and they don't overlap, then find the minimum cost among those pairs.\n\nBut with n up to 2e5, checking all possible pairs would be O(n²), which is way too slow. So we need an efficient approach.\n\nLet me think about how to approach this.\n\nLet me think: For each voucher, if I can find another voucher that has duration (x - duration_i) and doesn't overlap with it. Then, for each voucher, check for such vouchers.\n\nBut how to do this efficiently?\n\nMaybe group vouchers by their duration. So for each duration d, have a list of vouchers with that duration. Then, for each voucher with duration d, we look for vouchers with duration (x - d). But even that might not be enough, since for each such pair, we need to check if they are non-overlapping.\n\nBut how to find the minimal cost for each possible pair?\n\nLet me think. Suppose we have a voucher A with duration d, and another voucher B with duration x-d. For them to not overlap, either A ends before B starts, or B ends before A starts.\n\nSo for each voucher, say voucher A, which has duration d, we can look for vouchers of duration (x-d) that start after A ends, or end before A starts.\n\nBut how do we find the minimal cost vouchers in those regions?\n\nHmm. Let's think about preprocessing. For each possible duration, maybe we can precompute some data structures that allow us to quickly query the minimum cost of vouchers that end before a certain day, or start after a certain day.\n\nFor example, suppose we have all vouchers of duration (x - d). For voucher A, which ends at day r, we need to find vouchers in the (x - d) group that start at day >= r + 1. Similarly, for vouchers that end before A's start day (l - 1).\n\nWait, but for each voucher A, the required vouchers for the pair would be:\n\nEither:\n\n- voucher B ends before A starts (rj < li). So for voucher B, its ri < li. So voucher B's end is before A's start.\n\nOR\n\n- voucher A ends before voucher B starts (ri < lj). So voucher B's start is after A's end.\n\nSo, for a given voucher A with duration d, we need to find vouchers of duration (x - d) that are completely before A, or completely after A.\n\nSo for each voucher A, we can split into two cases:\n\nCase 1: Find vouchers B with duration (x - d) that end before A's start (so B's ri < A's li). Then, the minimal cost of such B's.\n\nCase 2: Find vouchers B with duration (x - d) that start after A's end (so B's lj > A's ri). Then, the minimal cost of such B's.\n\nIf we can find the minimum cost in each case, then for voucher A, the best possible pair is min(case1, case2), if any exists.\n\nThen, overall, we take the minimum over all vouchers.\n\nBut how to compute these minima quickly?\n\nLet me think about the data structures.\n\nFor each duration, say k, we can have two sorted lists:\n\n- sorted by start time (li), and for each start time, have the minimal cost up to that point? Or perhaps for each duration k, we can have a list of vouchers sorted by their end time (ri), and also a list sorted by their start time (li). Then, for a given query, like \"find the minimal cost of vouchers with duration k where ri < X\", we can perform a binary search on the sorted list of end times to find all vouchers with ri < X and find the minimal cost among them.\n\nAlternatively, for each duration k, we can pre-process:\n\n- a list of vouchers sorted by their end time. Then, for each end time, we can keep track of the minimum cost up to that point. So, for example, if we sort the vouchers of duration k by their end time, then for any X, we can find the largest end time less than X, and get the minimum cost in the prefix up to that",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly `x` and whose total cost is minimized. The solution involves efficiently checking for valid pairs of vouchers using preprocessing and binary search techniques.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. This helps in quickly finding vouchers that can complement a given voucher to meet the required total duration `x`.\n2. **Sorting and Prefix Minimums**: For each duration, sort vouchers by their end time and maintain a prefix minimum array of costs. This allows efficient querying of the minimum cost for vouchers ending before a specific day.\n3. **Binary Search**: Use binary search to quickly determine valid vouchers that end before or start after a given voucher, ensuring they do not overlap.\n\n### Solution Code\n```python\nimport bisect\nimport sys\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # For each duration, pre-process sorted lists and prefix minima\n    # For each duration k, we have:\n    # - sorted by end time (r), and for each position, the min cost up to that point\n    # - sorted by start time (l), and for each position, the min cost up to that point\n    # But for our problem, we need for a given end time, find min cost of vouchers with end < X\n    # So for each duration k, we will sort the list by end time, and create a list of min costs up to each index\n\n    # Also, for the case where we need vouchers starting after a certain day, we can sort by start time and use similar approach\n\n    # Preprocess data structures\n    duration_info = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        min_cost_end = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_so_far:\n                min_so_far = cost\n            min_cost_end.append(min_so_far)\n        # Also sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix min array\n        min_cost_start = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_start:\n            if cost < min_so_far:\n                min_so_far = cost\n            min_cost_start.append(min_so_far)\n        # Store these in duration_info\n        duration_info[d] = {\n            'sorted_by_end': sorted_by_end,\n            'min_cost_end': min_cost_end,\n            'sorted_by_start': sorted_by_start,\n            'min_cost_start': min_cost_start\n        }\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in duration_info:\n            continue\n        info = duration_info[target_d]\n        # Case 1: Find vouchers with duration target_d that end before l\n        # We need to find in info['sorted_by_end'] the largest rj < l\n        # Then get the min cost from min_cost_end up to that index\n        sorted_end_list = info['sorted_by_end']\n        end_times = [item[1] for item in sorted_end_list]\n        pos = bisect.bisect_left(end_times, l) - 1\n        if pos >= 0:\n            min_case1 = info['min_cost_end'][pos]\n            min_total = min(min_total, min_case1 + cost)\n        # Case 2: Find vouchers with duration target_d that start after r\n        # Need to find in info['sorted_by_start'] the first l_j > r\n        # All elements from that index onwards can be considered, get the min cost\n        sorted_start_list = info['sorted_by_start']\n        start_times = [item[0] for item in sorted_start_list]\n        pos = bisect.bisect_right(start_times, r)\n        if pos < len(sorted_start_list):\n            min_case2 = info['min_cost_start'][pos]\n            min_total = min(min_total, min_case2 + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vouchers with their respective durations.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n3. **Sorting and Prefix Minima**: For each duration, vouchers are sorted by their end and start times, and prefix minimum arrays are created to quickly determine the minimum cost for valid ranges.\n4. **Binary Search**: For each voucher, binary search is used to find valid non-overlapping vouchers of the required complementary duration, ensuring efficient querying and minimizing the total cost.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n²) brute force method, making the solution feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # For each duration, pre-process sorted lists and prefix minima\n    # For each duration k, we have:\n    # - sorted by end time (r), and for each position, the min cost up to that point\n    # - sorted by start time (l), and for each position, the min cost up to that point\n    # But for our problem, we need for a given end time, find min cost of vouchers with end < X\n    # So for each duration k, we will sort the list by end time, and create a list of min costs up to each index\n\n    # Also, for the case where we need vouchers starting after a certain day, we can sort by start time and use similar approach\n\n    # Preprocess data structures\n    duration_info = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        min_cost_end = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_so_far:\n                min_so_far = cost\n            min_cost_end.append(min_so_far)\n        # Also sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix min array\n        min_cost_start = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_start:\n            if cost < min_so_far:\n                min_so_far = cost\n            min_cost_start.append(min_so_far)\n        # Store these in duration_info\n        duration_info[d] = {\n            'sorted_by_end': sorted_by_end,\n            'min_cost_end': min_cost_end,\n            'sorted_by_start': sorted_by_start,\n            'min_cost_start': min_cost_start\n        }\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in duration_info:\n            continue\n        info = duration_info[target_d]\n        # Case 1: Find vouchers with duration target_d that end before l\n        # We need to find in info['sorted_by_end'] the largest rj < l\n        # Then get the min cost from min_cost_end up to that index\n        sorted_end_list = info['sorted_by_end']\n        end_times = [item[1] for item in sorted_end_list]\n        pos = bisect.bisect_left(end_times, l) - 1\n        if pos >= 0:\n            min_case1 = info['min_cost_end'][pos]\n            min_total = min(min_total, min_case1 + cost)\n        # Case 2: Find vouchers with duration target_d that start after r\n        # Need to find in info['sorted_by_start'] the first l_j > r\n        # All elements from that index onwards can be considered, get the min cost\n        sorted_start_list = info['sorted_by_start']\n        start_times = [item[0] for item in sorted_start_list]\n        pos = bisect.bisect_right(start_times, r)\n        if pos < len(sorted_start_list):\n            min_case2 = info['min_cost_start'][pos]\n            min_total = min(min_total, min_case2 + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1242,
        "thoughts_token_count": 1024
    }
}