{
    "start": 1758309517.3488348,
    "end": 1758309740.6658971,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about how to approach this. \n\nFirst, let's note that a and b are given. Let me think about the LCM of two numbers. The LCM of x and y is (x*y)/gcd(x,y). So, for the two numbers (a +k) and (b +k), their LCM depends on their product and their GCD.\n\nBut since both numbers are increased by the same k, maybe there's a way to simplify this. Let me think: Let's denote x = a +k and y = b +k. Then, y - x = (b +k) - (a +k) = b - a. So the difference between the two numbers is fixed, regardless of k. Let's call this difference d. So d = b -a. But wait, if a and b are swapped, then d would be negative. But since the problem allows a and b to be in any order, perhaps we can assume without loss of generality that a ≤ b? Because if a > b, then swapping them would not change the problem, since the LCM is symmetric. So maybe first I should handle the case where a and b are ordered.\n\nWait, but the problem says that a and b can be any integers. So let's first compute d = |a - b|. Let me think. Let me suppose that a < b. Then, the difference between the two numbers is (b -a) = d. So, when you add k to both, the difference remains d. So, the two numbers are x and x +d, where x = a +k. Then, the LCM of x and x +d is (x*(x +d))/gcd(x, x +d). But gcd(x, x +d) is the same as gcd(x, d). Because gcd(x, x +d) = gcd(x, d). So, the LCM becomes x*(x +d)/g, where g is gcd(x, d).\n\nSo, the problem reduces to finding x such that x*(x +d)/g is minimized, where d is fixed as |a -b|, and x is a +k (so x ≥ a, since k ≥0). Also, since k can be zero, x can be as low as a.\n\nBut how do we find x that minimizes this expression?\n\nAlternatively, since d is fixed, perhaps we can find x such that x and x +d have a large GCD. Because the LCM is (x*(x +d))/gcd(x, x+d) = (x*(x +d))/g. So, larger g would lead to smaller LCM.\n\nSo, the optimal scenario would be when x and x +d share as large a GCD as possible. Since x +d = x + (b -a) if a < b. So, for example, if d is zero, then a = b, so adding any k gives x and x, so their LCM is x. So the minimal is achieved when x is as small as possible, i.e., k=0.\n\nBut when d is not zero, then we need to find x such that the GCD of x and d is as large as possible. Because that would minimize the LCM. So, perhaps the optimal x is such that x is a multiple of some divisor of d. Let me think.\n\nLet me consider that d is fixed. Let me take the case where a < b, so d = b -a. Then, x = a +k, and the other number is x +d = b +k. So, the LCM of x and x +d is LCM(x, x +d) = LCM(x, x +d). Which depends on the GCD of x and d. Because as earlier, GCD(x, x +d) = GCD(x, d).\n\nSo, for each divisor g of d, we can try to find x such that GCD(x, d) = g. Then, the LCM would be (x * (x +d)) / g. But since x and x +d are multiples of g, let me write x = g * m, and d = g * t. Then, since d = g * t, then x +d = g*m + g*t = g(m +t). Therefore, the LCM is (g*m * g(m + t)) / g = g*m*(m +t). Which is g*m*(m + t). So, the LCM is g * m (m + t). Since t = d/g. So, the problem",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The key insight is to leverage the properties of the greatest common divisor (GCD) and the difference between the two given integers.\n\n### Approach\n1. **Difference Calculation**: Calculate the absolute difference $ d $ between the two integers $ a $ and $ b $. This difference remains constant regardless of the value of $ k $.\n2. **Divisors of Difference**: Identify all divisors of $ d $, as these divisors will help in determining potential values of $ k $ that could minimize the LCM.\n3. **Optimal k Calculation**: For each divisor $ g $ of $ d $, compute the smallest $ k $ such that both $ a + k $ and $ b + k $ are multiples of $ g $. This ensures that the GCD of the two numbers is maximized, thus minimizing their LCM.\n4. **Check Validity**: Ensure that the computed $ k $ is non-negative and valid for the given constraints.\n\n### Solution Code\n```python\nimport math\n\ndef compute_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    divisors = get_divisors(d)\n    min_k = float('inf')\n    for g in divisors:\n        # We want x = a + k to be a multiple of g, and x + d = b + k also multiple of g\n        # Since d = g * t, then x must be congruent to -d mod g? Wait, let's think differently.\n        # Let x = a + k. We need x ≡ 0 mod g, and x + d ≡ 0 mod g. But since d is a multiple of g, x + d ≡ x mod g. So if x is a multiple of g, then x + d is also a multiple of g. So the condition is simply x ≡ 0 mod g.\n        # So x must be a multiple of g. So a + k ≡ 0 mod g => k ≡ -a mod g. But since k must be non-negative, the minimal k is (g - a % g) % g\n        # However, if a % g == 0, then k can be 0.\n        remainder = a % g\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = g - remainder\n        # Now check if b + k_candidate is also a multiple of g. Since d = (b - a), and g divides d, then if a + k_candidate is multiple of g, then b + k_candidate = a + k_candidate + d is also multiple of g.\n        # So no need to check again.\n        if k_candidate < min_k:\n            min_k = k_candidate\n    return min_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Difference Calculation**: The absolute difference $ d $ between $ a $ and $ b $ is calculated to determine the fixed gap between the two numbers when adjusted by $ k $.\n2. **Divisors of Difference**: By finding all divisors of $ d $, we identify potential values for the GCD of $ a + k $ and $ b + k $, which helps in minimizing the LCM.\n3. **Optimal k Calculation**: For each divisor $ g $, the smallest $ k $ is calculated such that both $ a + k $ and $ b + k $ are multiples of $ g $, ensuring the GCD is maximized. This is done using modular arithmetic to find the smallest non-negative $ k $.\n4. **Check Validity**: The solution ensures that the calculated $ k $ is valid and minimizes the LCM by leveraging the properties of divisors and modular arithmetic.\n\nThis approach efficiently narrows down potential values of $ k $ using mathematical insights, ensuring optimal performance even for large input values.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef compute_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    divisors = get_divisors(d)\n    min_k = float('inf')\n    for g in divisors:\n        # We want x = a + k to be a multiple of g, and x + d = b + k also multiple of g\n        # Since d = g * t, then x must be congruent to -d mod g? Wait, let's think differently.\n        # Let x = a + k. We need x ≡ 0 mod g, and x + d ≡ 0 mod g. But since d is a multiple of g, x + d ≡ x mod g. So if x is a multiple of g, then x + d is also a multiple of g. So the condition is simply x ≡ 0 mod g.\n        # So x must be a multiple of g. So a + k ≡ 0 mod g => k ≡ -a mod g. But since k must be non-negative, the minimal k is (g - a % g) % g\n        # However, if a % g == 0, then k can be 0.\n        remainder = a % g\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = g - remainder\n        # Now check if b + k_candidate is also a multiple of g. Since d = (b - a), and g divides d, then if a + k_candidate is multiple of g, then b + k_candidate = a + k_candidate + d is also multiple of g.\n        # So no need to check again.\n        if k_candidate < min_k:\n            min_k = k_candidate\n    return min_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 994,
        "thoughts_token_count": 1024
    }
}