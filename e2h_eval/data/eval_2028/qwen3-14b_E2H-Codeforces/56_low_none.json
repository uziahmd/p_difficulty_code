{
    "start": 1758309275.2367232,
    "end": 1758309327.21998,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if there's a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. Hmm.\n\nSo the problem says that each base must be assigned exactly one spaceship, and vice versa. And the key constraint is that any two line segments (from a spaceship to its base) don't cross each other. Oh right, and the input ensures that no three points are colinear, which might help avoid some edge cases.\n\nFirst, the approach: Since R and B are up to 10, maybe we can check all possible perfect matchings. For each possible permutation of assignments, check if all the lines are non-crossing.\n\nBut how do I check if two line segments cross? Oh right, there's a computational geometry method to determine if two line segments intersect. But since the problem says that no three points are colinear, maybe we can use that to simplify the checks.\n\nWait, but for the problem, we need that all pairs of line segments in the matching do not cross. So for a given matching, for every pair of edges (spaceship1 to base1, spaceship2 to base2), we need to check if those two segments intersect. If any pair does, then this matching is invalid.\n\nSo the steps would be:\n\n1. Generate all possible perfect matchings between the R spaceships and B bases. Wait, but R and B must be equal. Oh the first line says R and B. Wait the problem says that the assignment is a perfect matching, which requires that R = B. Wait, looking back at the problem statement: \"every base has exactly one guardian and each spaceship has exactly one assigned base\". So R must equal B. But the input allows R and B to be different? Wait the input constraints say 1 ≤ R, B ≤ 10. But the problem says that it's possible to assign R spaceships to B bases with a perfect matching. So that implies that R must equal B. But the input may have R != B, but in that case, the answer is automatically No. So first thing, if R != B, output No. Otherwise, proceed.\n\nSo first check if R != B, then output No. Otherwise, proceed.\n\nThen, generate all possible permutations of assigning the spaceships to the bases. For example, if there are R spaceships and R bases, then there are R! possible matchings. For each of these, check if all the line segments between the assigned pairs are non-intersecting.\n\nIf any of these permutations satisfies the condition, output Yes. Otherwise, No.\n\nBut how to check if two line segments intersect?\n\nLet me recall the computational geometry approach. For two line segments AB and CD, they intersect if:\n\n- The orientation of A, B, C is different from the orientation of A, B, D, and the orientation of C, D, A is different from that of C, D, B. Or, if one of the endpoints lies on the other segment (but the problem says no three points are colinear, so this case can't happen? Because if two segments share an endpoint, then that's allowed? Or wait, the problem says that no three points are colinear. Wait, the problem says that no two points coincide, and no three are colinear. So for example, if two segments share an endpoint, that's allowed. But for two segments AB and AC, since they share A, but since no three points are colinear, then AB and AC can't be colinear. But in this case, the two segments would meet at a point, but not cross. So the problem says that the paths shouldn't intersect. So if two segments share an endpoint, that's allowed? Because they meet at a point, but not cross. So the problem says that the paths should not intersect. So the definition of intersection here is whether the two line segments cross each other, not just touching at endpoints.\n\nBut how to check that. So the standard line segment intersection check.\n\nBut given that no three points are colinear, then for two segments AB and CD, if they intersect, then they must cross each other in their interiors, not just touch at endpoints. Because if they share an endpoint, then that's allowed as per the problem's note. Wait, the note says that in the first example, connecting in order works. Let's think about that. Suppose the first example has three spaceships and three bases. For example, maybe the first spaceship is at (0,0), and the first base is at (-2,1). Then the line from (0,0) to (-2,1) is one segment. Then another line from (2,0) to (0,3), etc. Are those lines crossing? Well, perhaps not. But how to check.\n\nSo the problem says that the paths shouldn't intersect. So even if two segments share a common point (like if",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting line segments intersect. The solution involves checking all possible permutations of assignments and verifying the intersection condition for each permutation.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) and bases (B) are equal. If not, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate Permutations**: For valid input (R = B), generate all permutations of bases to check every possible assignment of spaceships to bases.\n3. **Check Line Segment Intersections**: For each permutation, check if any pair of line segments (from spaceship to base) intersect. This is done using computational geometry techniques to determine if two line segments intersect.\n4. **Output Result**: If any permutation satisfies the non-intersecting condition, output \"Yes\". Otherwise, output \"No\".\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().splitlines()\n    R_B = data[0].split()\n    R, B = int(R_B[0]), int(R_B[1])\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, data[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, data[i].split())\n        bases.append((x, y))\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef main():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    for perm in itertools.permutations(bases):\n        all_segments = []\n        for i in range(R):\n            all_segments.append((rebels[i], perm[i]))\n        valid = True\n        for i in range(len(all_segments)):\n            for j in range(i+1, len(all_segments)):\n                if segments_intersect(all_segments[i], all_segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Orientation Check**: The `orientation` function determines the relative orientation of three points, which helps in checking if line segments intersect.\n- **Segment Intersection Check**: The `segments_intersect` function uses the orientation check to determine if two line segments intersect.\n- **Permutations Check**: All permutations of base assignments are checked. For each permutation, all pairs of line segments are checked for intersections. If any permutation is found where no intersections occur, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().splitlines()\n    R_B = data[0].split()\n    R, B = int(R_B[0]), int(R_B[1])\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, data[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, data[i].split())\n        bases.append((x, y))\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef main():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    for perm in itertools.permutations(bases):\n        all_segments = []\n        for i in range(R):\n            all_segments.append((rebels[i], perm[i]))\n        valid = True\n        for i in range(len(all_segments)):\n            for j in range(i+1, len(all_segments)):\n                if segments_intersect(all_segments[i], all_segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 967,
        "thoughts_token_count": 1024
    }
}