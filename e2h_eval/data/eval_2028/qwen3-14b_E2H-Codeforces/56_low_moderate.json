{
    "start": 1758309278.6026516,
    "end": 1758309439.2947164,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:17 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about determining if there's a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. So, the key here is to check for each possible perfect matching whether all the line segments between matched pairs are non-intersecting.\n\nFirst, I need to understand the constraints. The input gives R spaceships and B bases. But since it's a perfect matching, R must equal B. Oh wait, the first line has R and B. Wait, the problem says that every base has exactly one guardian and each spaceship has exactly one assigned base. So that implies that R must equal B. Otherwise, there can't be a perfect matching. Wait, but the input may have R and B not equal? Wait the problem says \"it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian...\" So that implies that R must equal B. Because otherwise, if R is not equal to B, there can't be a perfect matching. So the first thing to check is if R != B, then output No. But looking at the input examples, in the first example, R is 3 and B is 3. In the second example, R is 2 and B is 1. So that's why the answer is No. So the first check is: if R != B, output No.\n\nBut the problem says that the input is given with R and B. So the code should first check if R and B are equal. If not, output No. Otherwise, proceed.\n\nNow, assuming R = B, we need to check if there exists a perfect matching between the R spaceships and B bases such that all the connecting lines are non-intersecting.\n\nThe challenge is to find such a matching. How can we approach this?\n\nThe problem is similar to finding a bipartite matching where each edge represents a possible connection between a spaceship and a base, and the edges are allowed only if their line segments don't cross any other line segments in the matching. But since the matching is a set of edges (each spaceship connected to exactly one base), the problem requires that for any two pairs (s1, b1) and (s2, b2) in the matching, the line segments s1-b1 and s2-b2 do not intersect.\n\nBut how to check all possible perfect matchings? Since R and B can be up to 10, the number of possible perfect matchings is R! which for 10 is 3.6 million. Wait 10! is 3,628,800. That's manageable for small R and B. So for R=10, it's about 3.6 million possibilities. For each possible permutation (since each spaceship is matched to exactly one base), we can check if all the line segments in the matching are non-intersecting.\n\nSo the approach would be:\n\n1. Check if R != B. If so, output No.\n2. Else, generate all possible permutations of the bases (since each spaceship is matched to exactly one base, and each base is matched to exactly one spaceship). For each permutation, check if all the line segments between the i-th spaceship and the permuted base (i-th position) do not intersect with each other.\n3. If any permutation satisfies this condition, output Yes. Otherwise, No.\n\nBut how to check if two line segments intersect?\n\nWe need a function that takes two line segments (each defined by two points) and returns True if they intersect, False otherwise.\n\nBut note that the problem says that no three points are colinear. So, any two line segments can't have overlapping parts (since that would require three points on the same line). Therefore, when checking for intersection between two line segments, we can check if they cross each other (properly intersect) or if they share an endpoint. However, in our case, since all points are unique and no three are colinear, two line segments can't share an endpoint unless they are part of the same pair. Wait, but in the matching, each line segment connects a spaceship to a base. So, in the permutation, each line segment is between a spaceship and a base. So, two different line segments in the same matching would be between different pairs. So, their endpoints are distinct. Therefore, two line segments can't share an endpoint. Therefore, when checking for intersections between two line segments, we can ignore the case where they share an endpoint. Because in the problem statement, all points are distinct, and no three are colinear. So, two line segments can't share an endpoint (since each line segment is from a spaceship to a base, and each spaceship and base is used once). Therefore, two line segments in the matching can't share an endpoint. Therefore, the only way they can intersect is if they cross each other properly.\n\nTherefore, the function to check if two line segments intersect can be based",
    "response": "```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().splitlines()\n    R, B = map(int, data[0].split())\n    ships = []\n    for i in range(1, R+1):\n        x, y = map(int, data[i].split())\n        ships.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, data[i].split())\n        bases.append((x, y))\n    return R, B, ships, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    R, B, ships, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n\n    for perm in itertools.permutations(bases):\n        all_segments = []\n        for i in range(R):\n            s = ships[i]\n            b = perm[i]\n            all_segments.append((s, b))\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                if segments_intersect(all_segments[i], all_segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().splitlines()\n    R, B = map(int, data[0].split())\n    ships = []\n    for i in range(1, R+1):\n        x, y = map(int, data[i].split())\n        ships.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, data[i].split())\n        bases.append((x, y))\n    return R, B, ships, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    R, B, ships, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n\n    for perm in itertools.permutations(bases):\n        all_segments = []\n        for i in range(R):\n            s = ships[i]\n            b = perm[i]\n            all_segments.append((s, b))\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                if segments_intersect(all_segments[i], all_segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 629,
        "thoughts_token_count": 1024
    }
}