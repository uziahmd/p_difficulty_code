{
    "start": 1758307658.8416712,
    "end": 1758307958.693533,
    "start-formatted": "2025-09-20 03:47 KST",
    "end-formatted": "2025-09-20 03:52 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. So the task is to find the minimum number of edges to add to a graph to form an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I remember that a graph is bipartite if and only if it doesn't contain any odd-length cycles. So if the graph is already bipartite, then adding edges to create an odd cycle would require some changes. Wait, but the problem says that we need to form a simple cycle of odd length. So maybe the key here is to check if the graph is bipartite. Because if the graph is bipartite, then any cycle in it is even-length. Therefore, to create an odd-length cycle, we need to make sure that the graph is not bipartite. But how?\n\nWait, the problem is to find the minimum number of edges to add to create such a cycle. Let me think. If the original graph already has an odd-length cycle, then t is 0. Because no edges need to be added. So the first thing we need to check is whether the graph contains any odd-length cycles. If yes, then t is 0, and w is the number of ways to add zero edges (which is 1 if there's at least one existing cycle, but maybe not? Wait, no. Because the problem says that the answer is the number of ways to add t edges. For t=0, it's the number of ways that adding zero edges would result in having such a cycle. But if the graph already has an odd cycle, then adding zero edges would satisfy the condition. However, the question is about forming a cycle of odd length. So if the graph already has such a cycle, then the answer for t is 0 and w is 1? Or maybe more?\n\nWait, no. The problem says that the output w is the number of ways to add t edges to form a cycle of odd length. So when t is 0, it's the number of such existing cycles? Or is it 1 because the existence of any such cycle would allow us to have that by adding zero edges? Wait, the problem says that the answer is the number of ways to add t edges. For example, in the second sample input, the graph is a triangle (3 nodes connected in a cycle). So the output is 0 1. That's because adding zero edges gives exactly one way (the existing cycle). But perhaps the problem counts the number of possible ways to choose edges to add. But if t is zero, then the way is just to not add any edges. However, the problem says that the answer is the number of ways to add t edges in order to form a cycle of odd length. So if the graph already contains such a cycle, then the answer is 1? Or the number of such cycles?\n\nBut looking at the sample input. The second case is 3 nodes with 3 edges forming a triangle. The output is 0 1. Which suggests that when the graph already contains an odd cycle, then w is 1. So regardless of how many existing cycles there are, the answer is 1? Or maybe not. Wait, maybe the problem counts the number of ways to add edges (so adding zero edges) such that the graph has at least one odd cycle. But since the graph already has one, then the number of ways is 1 (since you don't add any edges). But why in the sample input where the graph is a triangle, the answer is 0 1. So that's correct.\n\nSo the first step is to check whether the graph already has an odd-length cycle. If yes, then t=0 and w=1. But wait, what if there are multiple existing odd cycles? Then, adding zero edges would still be considered as one way, since the problem says that two ways are equal if they have the same set of added edges. So for t=0, there's only one way (adding nothing), regardless of how many existing cycles there are. So in that case, the answer is 0 1.\n\nSo the first case: if the graph already has an odd cycle, then t is 0 and w is 1.\n\nIf the graph does not have an odd cycle, then it's bipartite. Because a graph is bipartite if and only if it has no odd-length cycles. So in that case, we need to add edges to create an odd-length cycle.\n\nNow, how to do that with minimal edges?\n\nIn a bipartite graph, all cycles are even-length. So to create an odd-length cycle, we need to add edges such that there's a cycle that is odd.\n\nWhat's the minimal number of edges to add?\n\nLet me think. Suppose the graph is bipartite. Let's consider each connected component. Since the graph is bipartite, each connected component is bipartite. So each component can be divided into two parts, say A and B.\n\nIf a connected component has a bipartition (A, B), then adding an edge between two nodes in the same partition would create an odd-length cycle. Because in a bipartite graph, any path between two nodes in the same partition has even length. Adding an edge between them would create a cycle of odd length (even + 1).\n\nSo, for each connected component, if we can add an edge within the same partition (say, between two nodes in A), then that creates an odd-length cycle.\n\nBut how many edges do we need to add? Well, for a single connected component, if it's bipartite, then to create an odd cycle, we need to add at least one edge between two nodes in the same partition. So the minimal number of edges is 1. But how many ways are there?\n\nSo, for the case where the graph is bipartite, then the minimal t is 1. But wait, what if the connected component has only one node? No, since the graph has no loops. So each connected component has at least one edge. Wait, no. For example, if a connected component is a single node, but the problem says that the graph has no loops. So for a connected component with one node, there are no edges. But in that case, the component is trivially bipartite. But adding an edge would create a loop, which is not allowed. So for such components, how can we create a cycle?\n\nWait, the problem requires that the cycle consists of more than one vertex. So for a component with only one node, there's no way to form a cycle. So, in that case, we need to add edges to create a cycle. But how?\n\nBut the problem says that the graph can have multiple connected components. So, suppose the graph is bipartite and consists of multiple connected components. For example, if there's a connected component that is a single node, then to form a cycle, you need to connect it with other nodes. But perhaps the minimal number of edges depends on the structure of the graph.\n\nBut let's think again. If the graph is bipartite, then the minimal number of edges to add to create an odd-length cycle is 1. But how?\n\nOnly if there exists a connected component that is bipartite and has at least two nodes. Because adding an edge between two nodes in the same partition of that component would create an odd-length cycle. But if all connected components are single nodes, then you can't form a cycle. But in that case, the graph has no edges. So, for example, n=3, m=0. How to create a cycle? Well, you need to add edges. For example, adding three edges to form a triangle. But that would require adding 3 edges. But according to the third sample input, when n=3 and m=0, the output is 3 1. Which suggests that in that case, the minimal t is 3. So how?\n\nSo the approach must be:\n\nIf the graph is bipartite, then:\n\n- For each connected component, check if it's possible to add an edge within the same partition. If there's at least one connected component with more than one node, then the minimal t is 1. Otherwise, if all connected components are single nodes, then you need to add 3 edges (to form a triangle). But how?\n\nWait, let's think again. The graph is bipartite. So, if the graph has at least one connected component with more than one node, then adding one edge between two nodes in the same partition will create an odd cycle. So the minimal t is 1. But if all connected components are single nodes, then you need to create a cycle. Since each component is a single node, you need to connect three of them. So adding three edges (like a triangle) would form a cycle of length 3. So the minimal t is 3.\n\nSo the steps are:\n\nCheck if the graph already contains an odd cycle. If yes, then t=0 and w=1.\n\nElse, check if the graph is bipartite. Then, for each connected component, check if it's possible to add an edge within the same partition (i.e., the component has at least two nodes). If there exists at least one such component, then t=1. Otherwise (all components are single nodes), t=3.\n\nNow, for the number of ways w.\n\nIn the case where t=0, w is 1.\n\nIn the case where t=1, the number of ways is the number of possible edges that can be added between two nodes in the same partition of any connected component. But how to compute that?\n\nFor each connected component, which is bipartite, we can split into two partitions A and B. The number of possible edges that can be added between nodes in A is C(|A|, 2), and similarly for B. So for each component, the number of possible edges that can be added to create an odd cycle is (C(a, 2) + C(b, 2)), where a is the size of partition A and b is the size of partition B. Then, the total number of ways is the sum over all components of (C(a,2) + C(b,2)).\n\nBut wait, adding any of these edges will create an odd cycle. So the total number of ways is the sum of all possible edges that can be added in this way. However, if there are multiple components, adding any such edge in any component will create an odd cycle. So the total number of ways is the sum of (C(a_i,2) + C(b_i,2)) for each connected component i.\n\nBut in the first sample input, the input is:\n\n4 4\n\nEdges are between 1-2, 1-3, 2-4, 3-4. Let's see. The graph is connected. Let's check if it's bipartite. Let's try to color it. Suppose node 1 is color 0. Then 2 and 3 are color 1. Node 4 is connected to 2 and 3. So node 4 must be color 0. Then, 4 is connected to 2 (color 1) and 3 (color 1), which is okay. So the partitions are {1,4} and {2,3}. So the sizes are 2 and 2. So the number of possible edges to add is C(2,2) + C(2,2) = 1 + 1 = 2. Which matches the first sample's output of 1 2. So the answer is t=1 and w=2.\n\nYes! So that seems correct.\n\nNow, for the case where the graph is bipartite and there are multiple components. For example, if there are two components, each being a single node. Then, adding edges would require creating a cycle. But in that case, the minimal t is 3. But how to compute w? Well, in that case, the only way is to add three edges to form a triangle. But how many ways are there? Well, if there are three nodes, the number of ways to form a triangle is 1 (since you have to connect all three pairs). But if there are more than three nodes, perhaps it's different. Wait, but in this case, the scenario is when all connected components are single nodes. So the graph has n nodes, all isolated. So to create a cycle, you need to choose a subset of k nodes (k ≥ 3) and connect them in a cycle. But the minimal number of edges required is k. For example, for a triangle, you need 3 edges. For a square (cycle of length 4), you need 4 edges. But since we want the minimal t, the minimal is 3 edges. So in this case, the minimal t is 3, and the number of ways is the number of ways to select 3 nodes and form a triangle. But how?\n\nBut in this case, the problem requires that the minimal t is 3. So the number of ways is C(n, 3), since any three nodes can be connected as a triangle. However, in this case, the original graph is all isolated nodes. So adding any three edges between three nodes (forming a triangle) would create an odd cycle. But how many such possibilities are there?\n\nFor example, if n is 3, then there's only one way (add all three edges). If n is 4, then the number of ways is C(4,3) = 4. Each way corresponds to choosing three nodes and adding all three edges between them. However, the problem says that the added edges must form a cycle of odd length. So for each such selection of three nodes, adding the three edges forms a cycle (triangle) of length 3, which is odd. So the number of ways is C(n, 3) in this case.\n\nBut wait, the problem states that the added edges must form a cycle of odd length. However, when you add three edges between three nodes, you have exactly one cycle (the triangle). So each such selection contributes one way. So the total number of ways is C(n,3).\n\nSo, putting it all together:\n\nThe algorithm should be:\n\n1. Check if the graph already has an odd-length cycle. If yes, then output t=0 and w=1.\n\n2. Else, the graph is bipartite. Now, check for each connected component whether it has at least two nodes. If there's at least one such component, then t=1, and w is the sum over all components of (a_i choose 2 + b_i choose 2), where a_i and b_i are the sizes of the two partitions of component i.\n\n3. Else, all connected components are single nodes (so n >= 3, since m=0). Then, t=3 and w is C(n,3).\n\nBut how to check if the graph has an odd-length cycle? Well, we can perform a BFS or DFS for each connected component and check if it's bipartite. If any component is not bipartite, then the graph has an odd-length cycle.\n\nSo the plan is:\n\n- For each connected component, check if it is bipartite. If any is not bipartite, then answer is t=0, w=1.\n\n- Else, proceed to calculate the t and w based on the connected components.\n\nNow, the code steps:\n\nImplement a BFS-based bipartition check for each connected component.\n\nOnce we know the graph is bipartite, then:\n\nCheck if there exists at least one component with size ≥ 2. If yes:\n\nt = 1\n\nw = sum for each component (a_i * (a_i - 1) // 2 + b_i * (b_i - 1) // 2 )\n\nElse:\n\nif n < 3: impossible? Wait, but the problem says that the cycle must have more than one vertex. So for example, if n=1, then it's impossible. But according to the problem statement, the input can be like n=1 and m=0. However, in such a case, the answer would be impossible. But according to the problem's note, the sample input includes 3 0, which outputs 3 1. So for n=3, m=0, the answer is t=3 and w=1.\n\nBut for n=1, m=0, the answer would be impossible. However, the problem says that the graph can have any number of vertices and edges. So how to handle that?\n\nWait, the problem says that the output must be t and w. So for cases where it's impossible to form a cycle of odd length (e.g., n=1, m=0), but according to the problem statement, the input is such that the graph can be modified to form such a cycle. However, in the case of n=1, it's impossible. But the problem says that the graph can have any n and m. So how to handle that?\n\nBut according to the problem statement, the graph may not be connected. However, the problem requires that after adding edges, there exists a cycle of odd length. For example, when n=1, it's impossible to form a cycle (since a cycle must have at least two vertices). So in that case, the answer would be impossible. However, according to the problem's sample input, when n=3 and m=0, the output is 3 1. Which implies that for n=3, adding three edges (forming a triangle) is possible.\n\nSo in our code, we need to handle the case where all connected components are single nodes (so n is the number of components, each with one node). In this case, if n ≥ 3, then t is 3 and w is C(n, 3). If n < 3, then it's impossible. But according to the problem statement, the input may have such cases.\n\nWait, but the problem says that the cycle must consist of more than one vertex. So for example, if n=2, m=0. Then, the minimal edges needed to form a cycle is 2 edges (connecting the two nodes with two edges, but the problem says that the graph has no parallel edges. So that's not allowed. So the minimal is impossible. But according to the problem statement, the input is such that the answer exists? Or do we have to handle such cases?\n\nBut according to the problem statement, the input may have any n and m. So in the case where n=2 and m=0, the answer would be t=2 (add two edges between the two nodes, but that's not allowed since the problem prohibits adding parallel edges. So in this case, it's impossible to form a cycle. However, the problem says that the given graph has no loops or parallel edges, but adding edges must also not create loops or parallel edges.\n\nSo in this case, for n=2 and m=0, you can't form a cycle. Because adding one edge would form a single edge (not a cycle). Adding two edges is not allowed. So the answer would be impossible. But according to the problem statement, the input is guaranteed to have a solution? Or not?\n\nBut the problem says that the answer must be output. So perhaps the problem's constraints ensure that the answer exists. For example, in the case of n=1, m=0, the answer is impossible, but according to the problem's note, the third sample input is n=3, m=0, which is possible. So perhaps the problem assumes that n ≥ 3 in such cases. But how to handle that?\n\nBut according to the problem's sample input, the third case is n=3, m=0. The output is 3 1. So for n=3, the minimal t is 3. So for the general case, when the graph is bipartite and all components are single nodes (so n_components = n), then:\n\nif n >= 3, then t is 3, and w is C(n,3).\n\nelse, if n == 1, then it's impossible. But the problem says that the output must be printed. However, the problem's note says that the answer is to find the minimal number of edges to add. So perhaps in such cases, the answer is impossible. But the problem's input may not include such cases. However, the code must handle all possible inputs.\n\nBut according to the problem's input constraints, the input is such that the graph is valid (no loops, etc.), but there's no constraints on n and m. So in code, we need to handle cases where n is 1 or 2.\n\nBut let's think again. For the case where all components are single nodes (so m=0, and n ≥ 1). Then, to form a cycle, we need to add edges. But the cycle must have at least two nodes. So for n=1, it's impossible. For n=2, you can't form a cycle. Because adding one edge between the two nodes gives a single edge, not a cycle. Adding two edges is not allowed. So for n=2, the answer would be impossible. But how to handle that?\n\nBut according to the problem statement, the output must be given. So perhaps the problem's input ensures that there's at least one way to form the cycle. However, the code must handle all possible cases.\n\nBut perhaps the problem's constraints ensure that n ≥ 3. Or maybe not. Let's look back at the problem statement. The problem says that the graph can be not connected. So for example, n=2 and m=0. How to solve that?\n\nBut according to the problem statement, the output is required. So in such cases, what is the answer? For example, for n=2, m=0. We need to find the minimal number of edges to add to form a cycle of odd length. Since a cycle requires at least 3 nodes. So in this case, it's impossible. But according to the problem's note, the third sample input is n=3, m=0. So for that case, the answer is 3 1.\n\nSo perhaps in the code, when all components are single nodes (i.e., m=0 and n ≥ 1):\n\nif n < 3: then it's impossible to form a cycle. But the problem says that the answer must be found. So perhaps the code can assume that n ≥ 3. But how?\n\nBut according to the problem statement, the sample input includes n=3, m=0. So perhaps the code can assume that for such cases, when n is 1 or 2, the answer is impossible. But how to handle that?\n\nBut the problem says that the graph is given with n and m. So for example, if n=1, m=0, then the answer would be impossible. However, the problem says that the output must be printed. So perhaps the code should return t= something and w= something.\n\nBut according to the problem statement, the answer must be found. However, the problem's note says that the answer is to find the minimal number of edges to add. So for n=2, m=0, the answer would be impossible. However, the problem may not have such test cases.\n\nBut perhaps the code can proceed under the assumption that when the graph is bipartite and all components are single nodes, then n must be ≥ 3. But how?\n\nAlternatively, during the code, when checking for the case where all components are single nodes, we need to check if n ≥ 3. If so, then t=3 and w=C(n,3). Else, if n < 3, then it's impossible. But how to handle that?\n\nBut according to the problem's sample input, the third case is n=3, m=0. Which outputs 3 1. Which is correct. So for n=3, the code returns 3 and 1.\n\nBut for n=2, m=0, what's the answer? Well, in that case, the code would have to add edges. However, even after adding edges, it's impossible to form a cycle. Because the minimal cycle is length 3, which requires three nodes. So for n=2, it's impossible. But the code would have to return something.\n\nBut according to the problem statement, the input is such that the answer exists. So perhaps the problem's input ensures that n ≥ 3 in such cases. But how to confirm?\n\nBut the problem's input allows for any n and m. So perhaps the code needs to handle all possibilities. However, given that the problem's sample input includes the third case, which is n=3, m=0, and the output is 3 1, I think that the code should handle the case where all components are single nodes (i.e., m=0) as follows:\n\nif n < 3: then t is impossible. But how to handle this? Well, perhaps in such cases, the answer is t = (n - 1) + 1? No, that doesn't make sense. Alternatively, the code may have to return something else.\n\nBut perhaps the problem guarantees that the answer exists. Let's think about the problem's constraints. The problem says that the graph is not necessarily connected, but the answer must be found. So for example, in the case where n=2 and m=0, the answer would be impossible. However, according to the problem's note, the sample input for 3 0 is handled correctly.\n\nBut perhaps the problem's constraints ensure that n ≥ 3. But looking back at the problem statement, there's no such constraint. So the code must handle all cases.\n\nBut perhaps the problem requires that the graph can be modified to form a cycle. For example, the problem says that the graph can be modified by adding edges. So for n=2, m=0, you can't form a cycle. So in that case, the answer would be impossible. But how to handle that in the code?\n\nWell, the code must return t and w. So perhaps the code can assume that in such cases, the answer is t= (something) and w=0. But that's not possible. However, according to the problem's note, the third sample input is n=3, m=0, which outputs t=3, w=1. So for that case, the code is correct.\n\nSo, perhaps the code can proceed as follows:\n\nWhen the graph is bipartite, and all connected components are single nodes (so m=0 and n components, each of size 1), then:\n\nif n >= 3:\n\nt = 3\n\nw = C(n,3)\n\nelse:\n\nt = ?\n\nBut for n < 3, how can we form a cycle? It's impossible. But the problem says that the answer exists. So perhaps the problem's input ensures that n is at least 3 in this case. But how?\n\nWell, the problem says that the graph is given with n vertices and m edges. So for example, if n=1 and m=0, then the answer would require adding edges to form a cycle. But that's impossible. However, the problem may not have such test cases. But for the purpose of solving the problem, perhaps the code can proceed under the assumption that when all components are single nodes, then n is at least 3. Because otherwise, the answer is impossible, but the problem's input may not have such cases.\n\nBut how to handle this in the code? Well, perhaps the code can proceed as follows:\n\nIn the case where all components are single nodes, then:\n\nif n < 3:\n\nthen, the answer is impossible. But according to the problem's sample input, perhaps the code can assume that this case is not present. However, the code must handle it.\n\nBut perhaps the code can proceed as follows:\n\nIn the case where all components are single nodes:\n\nif n < 3:\n\nthen, t = ... but since it's impossible, but the problem requires to output something. However, according to the problem's note, the third sample input has n=3, m=0, which is possible. So perhaps the code can assume that n >= 3 in this case.\n\nBut how?\n\nAlternatively, during the code, after checking that the graph is bipartite, and that all connected components are single nodes, then:\n\nif n < 3:\n\nthen, the answer is impossible. But how to represent that? However, the problem's output requires that the code prints t and w. So perhaps the code can return t = (some value) and w = 0, but that's not correct.\n\nBut given that the problem's sample input includes the third case, and the code must pass that, perhaps the code can proceed under the assumption that in this case, n >= 3.\n\nThus, the code can proceed with:\n\nif the graph is bipartite, and all components are single nodes, then:\n\nt = 3\n\nw = combination(n, 3)\n\nNow, the code can proceed.\n\nNow, the steps for the code:\n\nImplement BFS to check bipartition for each component.\n\nCheck if any component is not bipartite. If yes, output 0 1.\n\nElse:\n\nCheck for each component if it has size >= 2. If at least one such component exists:\n\nt = 1\n\nw is the sum over all components of (a_i choose 2 + b_i choose 2)\n\nElse:\n\nt = 3\n\nw = combination(n, 3)\n\nBut how to compute combination(n,3)?\n\nIn Python, it's n*(n-1)*(n-2)//6.\n\nNow, the code:\n\nWe need to:\n\nRead n and m.\n\nThen read m edges.\n\nThen, build the adjacency list.\n\nThen, for each component, perform BFS to check bipartition.\n\nIf during this process, any component is not bipartite, then output 0 1.\n\nElse:\n\nCheck if there's any component with size >= 2.\n\nIf yes:\n\nCompute the sum of (a_i choose 2 + b_i choose 2) for each component.\n\nOutput t=1 and w=sum.\n\nElse:\n\nif n >=3:\n\noutput t=3 and w = n*(n-1)*(n-2)//6\n\nelse:\n\nwhat? But for n=1 or 2, the code would have to output something. But according to the problem statement, the input may not have such cases.\n\nBut for the sake of code, perhaps the code can assume that when all components are single nodes, then n >= 3.\n\nBut in the code, how to check if there's any component with size >= 2.\n\nSo, during the BFS, for each component, we can track the size of the component and the sizes of the two partitions.\n\nSo, for each component, during BFS, we can track the color of each node, and count the number of nodes in each partition.\n\nOnce all components are processed, we can check if any component has size >= 2.\n\nSo, in code:\n\nWe can have a list of components, each represented by (a, b), where a and b are the sizes of the two partitions.\n\nThen, for each component, if a + b >= 2, then there's a component with size >=2.\n\nSo, in code:\n\ncomponents = list of (a, b) pairs.\n\nhas_large_component = any (a + b >= 2 for a, b in components)\n\nIf has_large_component:\n\nt = 1, w = sum for each (a, b) in components of (a*(a-1)//2 + b*(b-1)//2)\n\nElse:\n\nt = 3, w = n*(n-1)*(n-2)//6 if n >=3 else 0 ?\n\nBut for n=2, this would be zero. But that's invalid.\n\nBut perhaps the problem's input ensures that when all components are single nodes, n >=3.\n\nSo, the code can proceed.\n\nNow, implementing this in Python.\n\nSo, code steps:\n\nImplement BFS for each component.\n\nInitialize color array. For each node not visited, run BFS.\n\nIn BFS, assign colors (0 and 1) alternately. If during BFS, a conflict is found (adjacent node has same color), then the graph is not bipartite.\n\nElse, record the size of the two partitions.\n\nOnce all components are processed, check if the graph is bipartite.\n\nIf not, output 0 1.\n\nElse:\n\nCheck if any component has size >=2 (i.e., a + b >= 2). For example, if a component has a=1, b=1, then size is 2. So yes.\n\nIf yes:\n\nsum_ways = sum( (a*(a-1)//2 + b*(b-1)//2) for a, b in components )\n\noutput 1 sum_ways\n\nElse:\n\nif n >=3:\n\noutput 3 and n*(n-1)*(n-2)//6\n\nelse:\n\noutput something? But according to the problem's sample, perhaps the code can assume that this case is not present.\n\nBut for the third sample input, when n=3, m=0, the code would have components = [(1, 1, 1)? No, wait. For each component, the code tracks the two partitions. For example, when the component is a single node, the two partitions are 1 and 0. Because the component is a single node. So during BFS, the color is assigned as 0, and the other partition is 0. So for a single node component, the a and b would be 1 and 0. So the sum of a + b is 1. So the code would check if any component has a + b >= 2. Since all components are single nodes, their a + b is 1, so has_large_component is False. Thus, code proceeds to the else case.\n\nIn this case, n is 3, so output 3 and C(3,3) = 1.\n\nWhich is correct.\n\nSo, for the code:\n\nNow, code.\n\nImplementing:\n\nRead n and m.\n\nadj = [[] for _ in range(n+1)] # assuming nodes are numbered from 1 to n.\n\nfor _ in range(m):\n\n    u, v = map(int, input().split())\n\n    adj[u].append(v)\n\n    adj[v].append(u)\n\ncolor = [-1]*(n+1)\n\nis_bipartite = True\n\ncomponents = []\n\nfor each node from 1 to n:\n\n    if not visited (color is -1):\n\n        perform BFS or DFS to check bipartition.\n\n        during this process, track the count of each color (a and b).\n\n        if during BFS, a conflict is found, set is_bipartite = False.\n\n        if is_bipartite is False, break.\n\nOnce all components are processed:\n\nif not is_bipartite:\n\n    print(0 1)\n\nelse:\n\n    check if any component has size >= 2 (a + b >= 2)\n\n    for example, for each component, a and b are the counts of color 0 and 1.\n\n    has_large = any( (a + b) >= 2 for a, b in components )\n\n    if has_large:\n\n        compute sum_ways as sum( a*(a-1)//2 + b*(b-1)//2 for a, b in components )\n\n        print(1 sum_ways)\n\n    else:\n\n        if n >=3:\n\n            print(3, n*(n-1)*(n-2)//6 )\n\n        else:\n\n            # handle cases where n is 1 or 2. But according to problem's sample, this is not needed.\n\n            # but code must output something.\n\n            # for example, for n=2, m=0:\n\n            # the minimal t is impossible. But according to the problem's input, perhaps such cases are not present.\n\n            # but code must handle it.\n\n            # However, in this case, since the graph is bipartite and all components are single nodes, and n <3, then it's impossible to form a cycle. So output t=?\n\n            # but the problem requires that the answer exists. So perhaps the code can return t= something.\n\nBut for the code, let's proceed with the following:\n\nAssume that when has_large is False, then n >=3.\n\nBut how to verify that?\n\nIn this case, has_large is False implies that all components are single nodes. So the number of components is n. So for example, if n=3, then components are [(1, 0), (1, 0), (1, 0)]. So each component has a + b = 1. So has_large is False.\n\nThus, code proceeds to the else clause, and n=3 >=3, so output 3 and 1.\n\nThus, the code handles that.\n\nSo, for the code, the part for handling else is:\n\nelse:\n\n    if n >=3:\n\n        print(3, n*(n-1)*(n-2)//6 )\n\n    else:\n\n        # for example, n=1 or 2. But according to problem's input, perhaps it's not present.\n\n        # but what to do?\n\n        # for n=1, can't form a cycle. So t is impossible. But the code must output something.\n\n        # However, according to the problem's statement, the answer exists. So perhaps the code can assume that this case is not present.\n\n        # For the purpose of passing the given samples, proceed with this code.\n\nThus, proceed with that.\n\nNow, code.\n\nImplementing the BFS:\n\nfor each node in 1..n:\n\n    if color is -1:\n\n        queue = deque()\n\n        color[node] = 0\n\n        queue.append(node)\n\n        cnt0 = 1\n\n        cnt1 = 0\n\n        while queue not empty:\n\n            u = queue.popleft()\n\n            for v in adj[u]:\n\n                if color[v] == -1:\n\n                    color[v] = 1 - color[u]\n\n                    if color[v] == 0:\n\n                        cnt0 +=1\n\n                    else:\n\n                        cnt1 +=1\n\n                    queue.append(v)\n\n                else:\n\n                    if color[v] == color[u]:\n\n                        is_bipartite = False\n\n                        # break everything\n\n                        # but how to exit?\n\n                        # perhaps set a flag and break\n\n                        # but in code, once is_bipartite is set to False, we can break and return.\n\n        components.append( (cnt0, cnt1) )\n\nWait, but this code is not correct. Because for the initial node, color is set to 0. Then, for each neighbor, we assign color 1, and so on. But the counts for cnt0 and cnt1 are tracked as follows: for the initial node, cnt0 is 1, cnt1 is ",
    "response": "To solve this problem, we need to determine the minimum number of edges required to form an odd-length cycle in an undirected graph and count the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges to introduce an odd-length cycle.\n\n### Approach\n1. **Check for Odd-Length Cycles**: If the graph already contains an odd-length cycle, the answer is straightforward: 0 edges needed and 1 way.\n2. **Bipartite Graph Check**: If the graph is bipartite, we need to determine how to introduce an odd-length cycle by adding edges.\n3. **Component Analysis**: For each connected component, if it is bipartite, we calculate the number of ways to add edges within the same partition to create an odd-length cycle.\n4. **Special Cases**: If all components are single nodes, we need to form a triangle (3 nodes) which requires adding 3 edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for node in range(1, n + 1):\n        if color[node] == -1:\n            queue = deque()\n            color[node] = 0\n            queue.append(node)\n            cnt0 = 1\n            cnt1 = 0\n            valid = True\n            \n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            valid = False\n                            is_bipartite = False\n            if not valid:\n                break\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large = True\n            break\n    \n    if has_large:\n        total_ways = 0\n        for a, b in components:\n            total_ways += a * (a - 1) // 2 + b * (b - 1) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into an adjacency list representation of the graph.\n2. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness. If any component is not bipartite, the graph already contains an odd-length cycle.\n3. **Component Analysis**: For each bipartite component, the sizes of the two partitions are recorded. If there exists a component with at least two nodes, the minimum edges needed to form an odd-length cycle is 1, and the number of ways is calculated based on combinations within each partition.\n4. **Special Case Handling**: If all components are single nodes, forming a triangle (3 nodes) is required, which involves adding 3 edges. The number of ways to choose 3 nodes from `n` nodes is computed using combinations.\n\nThis approach efficiently determines the minimum edges and ways to form an odd-length cycle by leveraging graph properties and combinatorial calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for node in range(1, n + 1):\n        if color[node] == -1:\n            queue = deque()\n            color[node] = 0\n            queue.append(node)\n            cnt0 = 1\n            cnt1 = 0\n            valid = True\n            \n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            valid = False\n                            is_bipartite = False\n            if not valid:\n                break\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large = True\n            break\n    \n    if has_large:\n        total_ways = 0\n        for a, b in components:\n            total_ways += a * (a - 1) // 2 + b * (b - 1) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 894,
        "thoughts_token_count": 8192
    }
}