{
    "start": 1758309599.222307,
    "end": 1758309892.8805003,
    "start-formatted": "2025-09-20 04:19 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the optimal sequence of moves for Homer and Marge such that their total prize (S1 + S2) is maximized. Both have to make exactly n moves each, and each turn they take the leftmost digit of A and append it to their own number. The key is to decide, at each step, whether Homer or Marge should take the next digit to maximize the sum.\n\nHmm. Let's think about the approach. Since n can be up to 18, the total number of digits is 36. So the total possible sequences would be combinations of choosing n positions for H and the rest for M. But for n=18, the number of possibilities is C(36,18) which is around 9 billion. That's way too big for a brute-force approach. So we need a smarter method.\n\nWait, but what's the maximum possible value of S1 + S2? Each digit is taken by either H or M, so the sum is the sum of all digits multiplied by their respective place values. Wait, no. Because each digit is part of either S1 or S2. For example, if a digit is taken by H, it contributes to S1 as a digit in some position. Similarly for M. But the total sum S1 + S2 is the sum of all digits multiplied by 10^k for each position? No, wait: For example, if a digit d is added to S1, then it contributes d * 10^{position} to S1. Similarly for S2. But the total sum would be the sum of all digits multiplied by their respective positions in their respective numbers.\n\nBut since each digit is added to one of the two numbers, the total sum depends on the order in which they are taken. For instance, taking a higher digit earlier gives it a higher place value. So the problem is to assign each digit to H or M, with exactly n digits each, such that the sum of their numbers is maximized.\n\nBut how do we model this? The key is that the order in which the digits are taken affects the place value. For example, the first digit taken by H will be the most significant digit of S1, the second will be the next, etc. Similarly for M. So the problem becomes selecting which digits go to H and which to M, but also considering the order in which they are taken.\n\nWait, but the order of taking is determined by the sequence of H and M choices. For example, the first move is the first digit of A. If it's taken by H, then it's the first digit of S1. If it's taken by M, then it's the first digit of S2. Then the next digit is taken by whoever is next, and so on.\n\nSo the problem can be thought of as building the sequence of H and M choices, such that for each choice, the current digit is added to the respective player's number. The goal is to maximize the sum of the two numbers.\n\nBut how do we model this? It seems like a dynamic programming problem, where the state depends on how many digits have been taken by each player so far, and the current position in the original number A.\n\nLet me think. Let's say we have a state (h, m), where h is the number of digits Homer has taken so far, and m is the number of digits Marge has taken. The total number of digits taken so far is h + m. Since each move takes one digit, the next digit to take is the (h + m + 1)-th digit of A. Wait, the original A is processed from left to right. So, for example, the first digit is the first one in the string. So for a given state (h, m), the next digit to consider is the (h + m)th index? Or maybe the next digit is the (h + m)th position in the original string. Let me clarify.\n\nSuppose the original A is a string of length 2n. Initially, h = 0 and m = 0. The first digit is the 0-th index. Then, when we take a digit, the next digit is the next one. So the current position in A is h + m. Because, for example, after taking h + m digits, the next digit is the (h + m)th index.\n\nSo the state is (h, m), and the next digit is A[h + m].\n\nAt each step, we can choose to take the next digit for Homer (if h < n) or for Marge (if m < n). The decision depends on which choice leads to a higher total sum.\n\nBut how do we compute the total sum? Well, the value contributed by a digit depends on when it's taken. For example, if Homer takes a digit at step k (where",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize (the sum of their numbers) is maximized. Both players must make exactly `n` moves each, and each move involves taking the leftmost digit of the given number `A`.\n\n### Approach\n1. **Dynamic Programming with Memoization**: We use dynamic programming (DP) with memoization to efficiently explore all possible sequences of moves. The state of our DP function will be defined by the number of digits taken by Homer (`h`) and Marge (`m`), along with the current position in the number `A`.\n2. **Recursive Decision Making**: At each step, we decide whether Homer or Marge should take the next digit based on which choice leads to a higher total prize. This decision is made recursively, considering the remaining digits and the current state.\n3. **Memoization**: To avoid redundant calculations, we memoize the results of subproblems. This ensures that each state is computed only once, significantly improving efficiency.\n\n### Solution Code\n```python\nimport sys\nimport functools\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    length = 2 * n\n\n    @functools.lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == length:\n            return (0, \"\")\n        pos = h + m\n        current_digit = int(A[pos])\n        max_total = -1\n        best_choice = \"\"\n        \n        # Try Homer's turn if possible\n        if h < n:\n            next_h = h + 1\n            next_m = m\n            # Calculate the contribution of this digit to the total\n            # The digit is added as the (h+1)th digit of Homer's number\n            # Which is 10^(n - next_h) * current_digit\n            contribution = current_digit * (10 ** (n - next_h))\n            total, rest = dp(next_h, next_m)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_choice = \"H\" + rest\n        # Try Marge's turn if possible\n        if m < n:\n            next_h = h\n            next_m = m + 1\n            contribution = current_digit * (10 ** (n - next_m))\n            total, rest = dp(next_h, next_m)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_choice = \"M\" + rest\n        return (max_total, best_choice)\n    \n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Dynamic Programming Function**: The function `dp(h, m)` computes the maximum total prize starting from the state where Homer has taken `h` digits and Marge has taken `m` digits. The function returns a tuple containing the maximum total prize and the corresponding sequence of moves.\n2. **Recursive Choices**: For each state `(h, m)`, the function checks if Homer or Marge can take the next digit. It calculates the contribution of the current digit to the total prize based on its position in the respective player's number and recursively evaluates the remaining digits.\n3. **Memoization**: The `lru_cache` decorator is used to memoize the results of subproblems, ensuring efficient reuse of computed states and avoiding redundant calculations.\n\nThis approach efficiently explores all possible sequences of moves while maximizing the total prize using dynamic programming and memoization, ensuring optimal performance even for the upper constraint limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport functools\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    length = 2 * n\n\n    @functools.lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == length:\n            return (0, \"\")\n        pos = h + m\n        current_digit = int(A[pos])\n        max_total = -1\n        best_choice = \"\"\n        \n        # Try Homer's turn if possible\n        if h < n:\n            next_h = h + 1\n            next_m = m\n            # Calculate the contribution of this digit to the total\n            # The digit is added as the (h+1)th digit of Homer's number\n            # Which is 10^(n - next_h) * current_digit\n            contribution = current_digit * (10 ** (n - next_h))\n            total, rest = dp(next_h, next_m)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_choice = \"H\" + rest\n        # Try Marge's turn if possible\n        if m < n:\n            next_h = h\n            next_m = m + 1\n            contribution = current_digit * (10 ** (n - next_m))\n            total, rest = dp(next_h, next_m)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_choice = \"M\" + rest\n        return (max_total, best_choice)\n    \n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 417,
        "completion_token_count": 763,
        "thoughts_token_count": 1024
    }
}