{
    "start": 1758008331.6716068,
    "end": 1758008515.2063913,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nThe challenge is to find all pairs of vouchers that satisfy these conditions and find the minimum sum of their costs.\n\nConstraints are n up to 2e5, which is 200,000. So O(n^2) approaches are definitely out of the question. We need something more efficient.\n\nLet me think about how to approach this.\n\nFirst, for each voucher, we can compute its duration. Let's say for voucher i, duration is d_i = ri - li + 1. Then, for each voucher, we need to find another voucher j such that d_i + d_j = x, and they don't overlap.\n\nSo, for each voucher i, we can check if there exists a voucher j with duration x - d_i. Then, among those j's, find the ones that don't overlap with i, and take the minimum cost.\n\nBut how do we efficiently find those j's?\n\nLet me think about grouping vouchers by their duration. For example, create a dictionary where key is duration, and value is a list of vouchers with that duration. Then, for each voucher with duration d, we can look up in the dictionary for duration (x - d). But then, for each such voucher in that group, we need to check if they don't overlap with the current voucher.\n\nBut even that could be O(n) per voucher, leading to O(n^2) time in worst case. For example, if all vouchers have duration x/2, then for each voucher, we need to check all others. Which is O(n^2) time.\n\nThat's not feasible. So we need a smarter way.\n\nAlternative idea: For each possible duration d, pre-process the vouchers so that for a given d, we can quickly find the minimal cost of a voucher that ends before a certain day, or starts after a certain day.\n\nBecause for a voucher i with duration d_i, we need to find vouchers j with duration x - d_i, and either j's ri < li (voucher i's start) or j's li > ri (voucher i's end). Wait, no. The two vouchers must not overlap. So for voucher i and j, they must not overlap. Which means either j ends before i starts (rj < li) or i ends before j starts (ri < lj). So for each voucher i, when looking for j's with duration x - d_i, we need to find those j's that end before li, or start after ri.\n\nSo for each voucher i, we can split into two cases:\n\nCase 1: Find a voucher j with duration (x - d_i) that ends before li. Then, j's ri < li.\n\nCase 2: Find a voucher j with duration (x - d_i) that starts after ri. Then, j's lj > ri.\n\nFor each of these cases, we need to find the minimal cost of such j's.\n\nIf we can pre-process for each duration, the vouchers sorted by their end time (for case 1) and start time (for case 2), then perhaps we can use binary search to find the minimal cost.\n\nBut how?\n\nLet me think. Let's suppose we have for each duration d, a list of vouchers sorted by their end time (ri). Also, for each such list, we can have a prefix minimum array. Similarly, for the same duration d, a list of vouchers sorted by their start time (li), and a prefix minimum array.\n\nWait, but maybe for case 1, for a voucher i with li, we need to find all vouchers j with duration d = x - d_i, and ri_j < li. Among those, find the one with minimal cost. Similarly for case 2, find vouchers j with duration d, and lj > ri_i. Among those, find the minimal cost.\n\nSo for each duration d, we can have two sorted lists:\n\n- A list sorted by end time (ri), and for each position, the minimum cost up to that point. Then, for case 1, given a li, we can binary search the maximum ri_j that is less than li, and get the minimum cost in that prefix.\n\nSimilarly, for case 2, we have a list sorted by start time (lj), and for each position, the minimum",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, while minimizing the total cost. The solution must efficiently handle up to 200,000 vouchers and ensure optimal performance.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration using a dictionary. This helps in quickly finding vouchers that could potentially complement another voucher to meet the required total duration `x`.\n\n2. **Sort and Preprocess**: For each duration, maintain two sorted lists:\n   - One sorted by the end date (`ri`) of the vouchers.\n   - Another sorted by the start date (`li`) of the vouchers.\n   Additionally, for each sorted list, maintain a prefix minimum cost array to quickly determine the minimum cost of vouchers up to any given index.\n\n3. **Binary Search for Efficient Lookup**: For each voucher, check if there exists a complementary voucher with the required duration. Use binary search on the preprocessed sorted lists to efficiently find non-overlapping vouchers and determine the minimum cost.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time and start time, with prefix min cost\n    # For each duration d, we have:\n    # - sorted_end: list of (r, cost), sorted by r\n    # - prefix_min_end: list of min cost up to each index\n    # - sorted_start: list of (l, cost), sorted by l\n    # - prefix_min_start: list of min cost up to each index\n    duration_data = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time (r)\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time (l)\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append(min_cost)\n        duration_data[d] = (sorted_end, prefix_min_end, sorted_start, prefix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in duration_data:\n            continue\n        # Check for vouchers with duration d2 that end before l1\n        sorted_end, prefix_min_end, sorted_start, prefix_min_start = duration_data[d2]\n        # Find the largest r_j < l1\n        # We can use bisect to find the insertion point of l1 in the list of r's\n        r_list = [item[1] for item in sorted_end]\n        pos = bisect.bisect_left(r_list, l1)\n        if pos > 0:\n            current_min = prefix_min_end[pos - 1]\n            min_total = min(min_total, cost1 + current_min)\n        # Check for vouchers with duration d2 that start after r1\n        l_list = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(l_list, r1)\n        if pos < len(prefix_min_start):\n            current_min = prefix_min_start[pos]\n            min_total = min(min_total, cost1 + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to quickly find potential pairs that sum up to `x`.\n- **Sorting and Prefix Minimums**: For each duration, vouchers are sorted by their start and end times. Prefix minimum arrays help in quickly determining the minimum cost of vouchers up to a certain point.\n- **Binary Search**: Used to efficiently find non-overlapping vouchers by checking against the start and end times of existing vouchers, ensuring the solution runs efficiently even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time and start time, with prefix min cost\n    # For each duration d, we have:\n    # - sorted_end: list of (r, cost), sorted by r\n    # - prefix_min_end: list of min cost up to each index\n    # - sorted_start: list of (l, cost), sorted by l\n    # - prefix_min_start: list of min cost up to each index\n    duration_data = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time (r)\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time (l)\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append(min_cost)\n        duration_data[d] = (sorted_end, prefix_min_end, sorted_start, prefix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in duration_data:\n            continue\n        # Check for vouchers with duration d2 that end before l1\n        sorted_end, prefix_min_end, sorted_start, prefix_min_start = duration_data[d2]\n        # Find the largest r_j < l1\n        # We can use bisect to find the insertion point of l1 in the list of r's\n        r_list = [item[1] for item in sorted_end]\n        pos = bisect.bisect_left(r_list, l1)\n        if pos > 0:\n            current_min = prefix_min_end[pos - 1]\n            min_total = min(min_total, cost1 + current_min)\n        # Check for vouchers with duration d2 that start after r1\n        l_list = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(l_list, r1)\n        if pos < len(prefix_min_start):\n            current_min = prefix_min_start[pos]\n            min_total = min(min_total, cost1 + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1081,
        "thoughts_token_count": 1023
    }
}