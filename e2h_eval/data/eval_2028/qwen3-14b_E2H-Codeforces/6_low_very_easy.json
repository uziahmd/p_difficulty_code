{
    "start": 1758313551.7214642,
    "end": 1758313782.316308,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nThe problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and their total cost is minimized. If there's no such pair, return -1.\n\nSo the input is n vouchers, each with li, ri, costi. The duration of a voucher is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations sum to x, and they don't overlap. And find the minimal sum of their costs.\n\nFirst, I need to think about how to approach this efficiently given the constraints. Since n can be up to 2e5, an O(n²) approach would be too slow. So we need something smarter.\n\nLet me think: For each voucher, check if there exists another voucher that can pair with it such that their durations add up to x, and they don't overlap. But how to do this efficiently?\n\nLet me break down the problem:\n\nFor each voucher, let's say its duration is d. Then we need another voucher with duration (x - d). So for each voucher, we can look for vouchers with duration (x - d), and check if they are non-overlapping.\n\nBut how to find those vouchers quickly?\n\nMaybe pre-process vouchers by their duration. So create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, we can look up in the dictionary for duration (x - d), and check if any of those vouchers are non-overlapping with the current one.\n\nBut even then, for each voucher, checking all vouchers of the required duration might be O(n) per voucher, leading to O(n²) in the worst case. Which is not acceptable.\n\nSo we need a way to find for a given voucher, the minimal cost voucher of duration (x - d) that does not overlap with it.\n\nBut how?\n\nAlternatively, for each possible duration d, we can precompute the minimal cost vouchers that end before a certain time, or start after a certain time. Because for a voucher A with duration d, we need a voucher B with duration (x - d) that ends before A's start, or starts after A's end.\n\nSo perhaps for each duration, we can have some sorted data structures that allow us to query the minimal cost of vouchers that end before a certain day, or start after a certain day.\n\nLet me think more concretely.\n\nSuppose I have a voucher A with li = a, ri = b, duration d. Then, the required duration for B is x - d. Let's call this target_duration.\n\nWe need to find vouchers B with duration target_duration, such that B ends before a (so that B is before A) or B starts after b (so that B is after A).\n\nSo for each voucher A, we can check two possibilities:\n\n1. Find the minimal cost of vouchers B with duration target_duration and ri < li of A. (B ends before A starts)\n2. Find the minimal cost of vouchers B with duration target_duration and li > ri of A. (B starts after A ends)\n\nIf either of these exists, then we can take the minimal cost from those possibilities and add to the current voucher's cost.\n\nSo the plan is:\n\n- Preprocess vouchers grouped by their duration. For each duration, we have a list of vouchers. For each duration, we can sort the vouchers by their end time (for case 1) and by their start time (for case 2). Also, for each duration, we can have a sorted list of end times and start times, along with the minimal cost up to that point.\n\nWait, but how to find the minimal cost for vouchers that end before a certain value. For example, if we have a list of vouchers with target_duration, sorted by their end time. For a given a (the start of voucher A), we can find all vouchers B with end time < a. Among these, we need the minimal cost. Similarly for the other case.\n\nSo for each duration, we can pre-process two structures:\n\n- A sorted list of end times, and for each position in the list, keep track of the minimum cost up to that position. This way, when we want to find the minimal cost among all vouchers with end time < a, we can perform a binary search to find the largest end time less than a, and then get the min cost up to that index.\n\nSimilarly, for the other case, we can have a sorted list of start times, and for each position, track the minimum cost. So for vouchers B with start time > b (the end of voucher A), we can find the first start time greater than b, and then get the min cost from that index onwards.\n\nBut how to build these structures?\n\nLet me think. For each duration d, we can collect",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, while minimizing their total cost. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly finding vouchers that can potentially complement another voucher to meet the required total duration `x`.\n2. **Preprocess for Efficient Queries**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date of vouchers to efficiently find vouchers that end before a given start date.\n   - Another sorted by the start date of vouchers to efficiently find vouchers that start after a given end date.\n3. **Binary Search for Minimum Cost**: Using binary search, we can quickly find the minimum cost of vouchers that end before or start after a specific date, ensuring efficient lookups and minimizing the total cost.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    duration_map = defaultdict(list)\n    \n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n    \n    # Preprocess for each duration: sort by end time and start time, and compute prefix minima\n    # Also, for start time sorted list, compute suffix minima\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Compute prefix minima for end sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Compute suffix minima for start sorted list\n        suffix_min_start = [0]*len(sorted_by_start)\n        min_cost = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        \n        # Case 1: find vouchers with target_d that end before l1\n        sorted_by_end, prefix_min_end, _, _ = preprocessed[target_d]\n        # Find the largest end <= l1 - 1\n        # Use bisect_right on the end times\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            min_cost = prefix_min_end[pos - 1]\n            total = cost1 + min_cost\n            if total < min_total:\n                min_total = total\n        \n        # Case 2: find vouchers with target_d that start after r1\n        _, _, sorted_by_start, suffix_min_start = preprocessed[target_d]\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            min_cost = suffix_min_start[pos]\n            total = cost1 + min_cost\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vouchers, each characterized by their start date, end date, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end dates and start dates. Prefix and suffix minima arrays are computed to allow efficient minimum cost queries.\n4. **Binary Search for Efficient Lookup**: For each voucher, we check if there exists another voucher with the complementary duration that either ends before the current voucher starts or starts after the current voucher ends. Binary search is used to efficiently find these vouchers and compute the minimum cost.\n\nThis approach ensures that we efficiently check all possible pairs of vouchers while maintaining an optimal time complexity.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    duration_map = defaultdict(list)\n    \n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n    \n    # Preprocess for each duration: sort by end time and start time, and compute prefix minima\n    # Also, for start time sorted list, compute suffix minima\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Compute prefix minima for end sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Compute suffix minima for start sorted list\n        suffix_min_start = [0]*len(sorted_by_start)\n        min_cost = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        \n        # Case 1: find vouchers with target_d that end before l1\n        sorted_by_end, prefix_min_end, _, _ = preprocessed[target_d]\n        # Find the largest end <= l1 - 1\n        # Use bisect_right on the end times\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            min_cost = prefix_min_end[pos - 1]\n            total = cost1 + min_cost\n            if total < min_total:\n                min_total = total\n        \n        # Case 2: find vouchers with target_d that start after r1\n        _, _, sorted_by_start, suffix_min_start = preprocessed[target_d]\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            min_cost = suffix_min_start[pos]\n            total = cost1 + min_cost\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1086,
        "thoughts_token_count": 1024
    }
}