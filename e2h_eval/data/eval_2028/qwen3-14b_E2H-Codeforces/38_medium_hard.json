{
    "start": 1758339655.1046808,
    "end": 1758339939.940863,
    "start-formatted": "2025-09-20 12:40 KST",
    "end-formatted": "2025-09-20 12:45 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to find two things for a given p: the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, I need to understand what exactly a p-reachable graph is. From the problem statement, a p-reachable graph has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So, for each such pair, both u can reach v and v can reach u. These are mutual reachability pairs.\n\nThe first part is to find the minimal number of nodes needed. Let's think about how to model this.\n\nLet me think about the structure of the graph. For the minimal number of nodes, we need to maximize the number of mutual pairs (u, v) with u < v. Because if we have more mutual pairs per node, we can reach higher p with fewer nodes.\n\nBut wait, the problem says that the graph must have exactly p such pairs. So, how can we model the maximum possible number of mutual pairs for a given number of nodes?\n\nLet me think of a complete DAG. Wait, no. Maybe the optimal way to maximize the number of mutual pairs is to have a strongly connected component (SCC) that includes as many nodes as possible. Because in a strongly connected component, every pair of nodes is mutually reachable. However, if there are multiple SCCs, then nodes in different components may not be reachable to each other. So perhaps the optimal way to maximize mutual pairs is to have a single strongly connected component (SCC) with k nodes, which contributes C(k, 2) mutual pairs. Because each pair (u, v) where u < v is counted once. \n\nWait, but if we have a graph that's a single strongly connected component, then all pairs (u, v) where u != v are mutually reachable. But since the problem counts ordered pairs (u, v) with u < v, the number of such pairs would be C(n, 2) where n is the number of nodes. Because for each unordered pair {u, v}, exactly one of u < v or v < u holds, so the total is C(n, 2).\n\nSo, if we have a graph that's a single strongly connected component (SCC), then the number of mutual pairs is C(n, 2). So, for example, if n=3, then C(3,2)=3. Which matches the first sample input where p=3, and the minimal number of nodes is 3. And in that case, the maximum number of unidirectional pairs is 0, because all pairs are mutual.\n\nBut the problem requires that the graph is p-reachable. So, for the minimal number of nodes, we need to find the smallest n such that there exists a way to arrange the graph so that exactly p mutual pairs exist. \n\nBut how can we achieve exactly p mutual pairs with minimal n?\n\nLet me think. For the minimal n, perhaps the optimal approach is to take a complete DAG with some structure. Wait, but in a DAG, there are no cycles, so mutual reachability is only possible between nodes that are in the same strongly connected component. But in a DAG, each node is in its own SCC, so no mutual pairs. That's not helpful here.\n\nAlternatively, maybe the minimal number of nodes is determined by finding the smallest n such that C(n, 2) >= p, and then adjusting the structure to get exactly p mutual pairs. But how?\n\nWait, but for the minimal n, perhaps the best way is to have a graph that consists of a single strongly connected component (SCC) of size k, and some other nodes arranged in a way that they don't contribute any mutual pairs. But that might not be possible. Alternatively, perhaps the minimal n is such that the maximum number of mutual pairs achievable with n nodes is at least p, and then we need to find the minimal n where this is possible.\n\nBut how to model this? Let's think of the maximum number of mutual pairs for a given n. The maximum is achieved when all nodes are in a single SCC. Then the number is C(n, 2). If we can't reach p with that, then we need to consider larger n.\n\nBut if we have a graph that is a combination of an SCC and some other components. For example, suppose we have an SCC of size k and another SCC of size m. Then the mutual pairs are C(k, 2) + C(m, 2). But if we have more than one SCC, the total mutual pairs would be the sum of the C(s, 2) for each SCC of size s. So, to maximize the number of mutual pairs for a given n, the best is to have a single SCC. To minimize the number of nodes, we need to find the smallest n where C(n, 2) >= p. But if p is not exactly equal to C(n, 2), then perhaps we need to adjust.\n\nWait, but the problem says that the graph must have exactly p mutual pairs. So, for example, if p=3, then n=3 is sufficient, since C(3,2)=3. But if p=4, then C(3,2)=3 <4. So the minimal n would be 4, because C(4,2)=6 >=4. But how can we arrange the graph to have exactly 4 mutual pairs? Well, perhaps by having an SCC of size 3 (which contributes 3 mutual pairs) and another node that is not connected in any way to the others. But that would add zero mutual pairs. So total is 3. Not enough. Alternatively, perhaps we can split the SCC into two parts. For example, suppose we have two SCCs: one of size 2 and one of size 2. Then the mutual pairs would be C(2,2) + C(2,2) = 1+1=2. Still not enough. Hmm.\n\nAlternatively, maybe there's a way to have a graph where some pairs are in mutual reachability and others are not. For example, if we have a graph with three nodes in a cycle (so mutual reachability), and a fourth node that has edges pointing to one of them. But then the fourth node can't reach the others, and the others can't reach it. So the mutual pairs are still 3. Not enough.\n\nWait, but maybe there's a way to have a graph with some mutual pairs and some not. For example, if we have a graph where there are two separate strongly connected components, say of sizes a and b. Then the mutual pairs are C(a,2) + C(b, 2). So, if we want to get exactly p, maybe we can split the nodes into multiple SCCs so that the sum of their C(s, 2) equals p.\n\nBut how to find the minimal n for that?\n\nFor example, if p=4, then the minimal n is 4. Because C(4,2) is 6, which is more than 4. But can we find a way to arrange the graph to have exactly 4 mutual pairs with 4 nodes?\n\nYes. Suppose we have a graph with two SCCs: one of size 3 (contributing 3 mutual pairs) and another of size 1 (contributing 0). But that gives 3. Not enough. Another option: two SCCs of size 2 and 2. Then the mutual pairs are 1+1=2. Still not. What if we have one SCC of size 2 (contribution 1) and another of size 3 (contribution 3) but that would require 5 nodes. No.\n\nAlternatively, perhaps there's a way to have a graph with some nodes in a single SCC and some not. But the mutual pairs are only those within the SCC. So, for example, if we have an SCC of size 3 (3 mutual pairs) and another node that is connected in a way that adds one more mutual pair. How?\n\nWait, if the fourth node is part of the SCC. Then the mutual pairs would be C(4, 2)=6. But we want exactly 4. So maybe we can have a graph where there's an SCC of size 3, and another node that is connected in a way that creates one more mutual pair. But how?\n\nAlternatively, maybe the graph isn't a collection of SCCs. For example, imagine a graph with four nodes where three of them form a cycle (so mutual reachability), and the fourth node has an edge to one of them and vice versa. Then the fourth node is part of the same SCC as the others. So again, the mutual pairs would be 6.\n\nHmm, perhaps there's a way to have some pairs that are mutual and others not. But I'm not seeing it. So maybe the minimal n for p=4 is 4, but how to achieve exactly 4 mutual pairs?\n\nAlternatively, maybe the minimal n is not determined by the maximum possible mutual pairs, but by some other structure. For example, perhaps we can have a graph where some nodes are in a strongly connected component and others are arranged in a way that introduces additional mutual pairs.\n\nWait, but mutual reachability is transitive. If u can reach v and v can reach u, then they are in the same SCC. So any mutual pairs are within the same SCC. Therefore, the total number of mutual pairs in the entire graph is the sum over each SCC of C(size of SCC, 2). \n\nSo, to achieve exactly p mutual pairs, the problem reduces to finding a set of integers s_1, s_2, ..., s_k such that the sum of C(s_i, 2) equals p, and the sum of s_i is minimized.\n\nAh! That's a crucial insight. Because the sum of C(s_i, 2) for the sizes of the SCCs must be exactly p. And our goal is to find the minimal sum of s_i (i.e., the total number of nodes) such that this sum equals p.\n\nSo the problem becomes, for a given p, find the minimal n such that there exists a set of integers s_1, s_2, ..., s_k where sum_{i} C(s_i, 2) = p, and sum_{i} s_i = n. And then, among all such n, find the minimal one.\n\nOnce we have that minimal n, the second part of the problem is to compute the maximum number of unidirectional pairs in such graphs.\n\nSo, first, solving for the minimal n.\n\nHow to compute this minimal n?\n\nLet me think of this as an optimization problem. We need to find the minimal sum of s_i such that sum (s_i choose 2) = p.\n\nThe key idea here is that to minimize the sum of s_i, for a given sum of (s_i choose 2), we should make the s_i as large as possible. Because (s choose 2) grows quadratically, while the sum of s_i grows linearly. For example, using a single s_i (so one SCC) gives the minimal sum of s_i for a given (s choose 2). Because splitting into smaller s_i would increase the sum of s_i. \n\nFor example, if p is 3, then using a single s_i=3 (sum s_i=3) is better than using s_i=2 and s_i=2 (sum is 4, which is worse). \n\nSo, the minimal n is achieved when we have as few SCCs as possible, and the largest possible sizes. Hence, the minimal n is achieved by taking the largest possible s such that C(s, 2) ≤ p, and then recursively solving for the remainder p - C(s, 2) with the same logic. But wait, perhaps not. Because maybe splitting into two larger s_i's gives a better sum. For example, if p is 6, then a single s=4 (sum 4) gives C(4,2)=6. That's better than splitting into s=3 and s=2 (sum 5, which is worse). \n\nSo the optimal approach is to find the minimal n by greedily taking the largest possible s_i for each step, i.e., for the current p, find the largest s such that C(s, 2) ≤ p, subtract C(s, 2) from p, and repeat until p is zero. This would give us the minimal sum of s_i.\n\nBut wait, let's test this with an example. Let's say p=4. The largest s with C(s,2) ≤4 is 3 (C(3,2)=3). Then we have 4-3=1 left. Now, the largest s for 1 is 2 (C(2,2)=1). So the total sum is 3+2=5. However, is there a better way? For example, can we split into s=2, s=2, s=2. Then the sum of C(s_i, 2) is 1+1+1=3, which is less than 4. Not helpful. Alternatively, if we take s=3 and s=2, sum is 3+2=5, but the sum of C is 3+1=4. So that's correct. But is there a way to have sum of s_i less than 5? For example, can we have a single s=4? C(4,2) is 6>4. No. What about s=3 and s= something else. Let's see, 3+ something. Suppose we have two SCCs: one of size 3 and one of size 1. Sum of C is 3+0=3. Not enough. So no. Therefore, the minimal sum is indeed 5. But then, for p=4, the minimal n is 5. But according to the sample input, when p=4, the output is 5 6. Wait, the sample input for p=4 is output 5 6. Let's check that.\n\nWait, the sample input given in the problem is:\n\nInput:\n['3', '4', '0']\n\nOutput:\n['3 0', '5 6', '0 0']\n\nSo for p=4, the minimal number of nodes is 5. Which aligns with the above reasoning. Then, the maximum number of unidirectional pairs is 6.\n\nSo how does that happen?\n\nOnce we have the minimal number of nodes, which for p=4 is 5 (with s_i being 3 and 2, sum 5). Then, the graph is composed of two SCCs: one of size 3 and one of size 2. The mutual pairs are C(3,2) + C(2,2) = 3 + 1 =4, which is correct.\n\nNow, the second part of the problem: for such graphs (with minimal n), find the maximum number of unidirectional pairs.\n\nSo, unidirectional pairs are ordered pairs (u, v) where u !=v, there is a path from u to v, but not vice versa.\n\nSo, how do we compute this maximum?\n\nLet me think about the structure of the graph. The graph is composed of several SCCs. Between different SCCs, there can be edges in one direction or another, but not both. Because if there is a path from an SCC A to an SCC B, and vice versa, then they would be merged into a single SCC.\n\nSo, for the maximum number of unidirectional pairs, we need to arrange the SCCs in a DAG (directed acyclic graph) structure, where each edge between SCCs is directed in a way that maximizes the number of unidirectional pairs.\n\nMoreover, within each SCC, all pairs are mutual, so they contribute nothing to unidirectional pairs.\n\nSo, the unidirectional pairs come from two sources:\n\n1. Between different SCCs: for any two nodes u in SCC A and v in SCC B, if there is a path from u to v but not from v to u, then (u, v) is a unidirectional pair. Similarly for (v, u) if the path is in the other direction.\n\nBut since the SCCs are arranged in a DAG, if there is a path from A to B, then there is no path from B to A. So, for any pair of SCCs A and B, if there is a directed edge from A to B in the DAG of SCCs, then all pairs (u, v) where u is in A and v is in B will be unidirectional (since there's a path from u to v, but not vice versa). Similarly, if there's a path from B to A, then those pairs are reversed.\n\nSo, the number of such pairs between two SCCs A and B (with sizes a and b) is a*b if there is a directed edge from A to B. Or, if there's a directed edge from B to A, then it's b*a. But since the DAG can be arranged in a way to maximize the sum of a*b for all ordered pairs of SCCs where there is a directed edge from one to another.\n\nBut how to arrange the DAG of SCCs to maximize the total number of such pairs?\n\nThe maximum is achieved when the DAG of SCCs is a total order, i.e., arranged in a linear chain. For example, if there are k SCCs, then arrange them in a line: S1 → S2 → ... → Sk. Then, for each pair of SCCs Si and Sj where i < j, there is a directed path from Si to Sj. Thus, the number of unidirectional pairs between these two is |Si| * |Sj|. Summing over all i < j.\n\nBut how to compute this?\n\nLet me think. Suppose we have a set of SCC sizes s_1, s_2, ..., s_k. The maximum number of unidirectional pairs is the sum over all i < j of s_i * s_j multiplied by 1 (if there is a directed path from i to j) plus the same for j to i. But in the optimal arrangement, we arrange the DAG so that for every pair of SCCs, there's a directed path from one to the other. So, for the maximum, we can arrange the DAG as a linear order, so that for each pair of SCCs, the one earlier in the order has a directed path to the one later. Thus, the total unidirectional pairs between all pairs of SCCs is the sum_{i < j} s_i * s_j * 1 (since for each i < j, there's a path from i to j, contributing s_i * s_j unidirectional pairs). Also, note that for each such pair, the reverse is not possible, so (u, v) is counted once, and (v, u) is not counted.\n\nSo, the total number of unidirectional pairs between different SCCs is sum_{i < j} s_i * s_j. \n\nAdditionally, within each SCC, there are no unidirectional pairs (since all are mutual). So the total unidirectional pairs is sum_{i < j} s_i * s_j.\n\nBut wait, what about the unidirectional pairs within the same SCC? No, because they are all mutual. So the only unidirectional pairs are between different SCCs.\n\nSo, the problem now becomes, given the set of s_i's (the sizes of the SCCs in the minimal n configuration), arrange them in a linear order to maximize the sum of s_i * s_j for i < j. Which is the same as (sum s_i)^2 - sum s_i^2 all divided by 2.\n\nBecause sum_{i < j} s_i s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2.\n\nSo, for the example where p=4, the s_i's are 3 and 2. Then sum s_i is 5. sum s_i squared is 9 +4 =13. Then (5^2 -13)/2 = (25-13)/2 = 6. Which matches the sample output of 6.\n\nSo, the maximum number of unidirectional pairs is [ (total_nodes)^2 - sum (s_i^2) ] / 2.\n\nTherefore, the steps for solving the problem are:\n\n1. Find the minimal number of nodes n, which is the minimal sum of s_i's such that sum C(s_i, 2) = p.\n\n   To compute this, we can use a greedy approach: find the largest possible s such that C(s, 2) ≤ remaining p, subtract that from p, and repeat until p is zero. The sum of all these s's is the minimal n.\n\n   However, there's a catch. For example, if p is 6, the greedy approach would take s=4 (C(4,2)=6) and sum is 4, which is better than taking s=3 (C(3,2)=3) and then s=3 again (another 3, sum 6). So the greedy approach is correct.\n\n   But what about cases where splitting into smaller s_i's gives a smaller sum? For example, suppose p=5. The greedy approach would take s=3 (C(3,2)=3), then p=2. Then take s=2 (C(2,2)=1), leaving p=1. Then take s=2 again (another 1). So sum is 3+2+2=7. But another possibility is to take s=3 and s=2, which sum to 5. Wait, C(3,2)+C(2,2) = 3+1=4, which is less than 5. So that's not enough. So the greedy approach would take s=3 (3), then s=3 (C(3,2)=3) but that would sum to 6, but 3+3=6. But 3+3=6, sum of C is 3+3=6. So for p=5, the greedy approach would take s=3 (3), then p=2. Then take s=2 (1), p=1. Then take s=2 (another 1). Total sum is 3+2+2=7. But another way is to take s=4 (C(4,2)=6) which is larger than 5. So that's not allowed. So perhaps the minimal n is 7. But is there a better way?\n\n   Wait, for p=5, can we have two s_i's such that their C(s_i, 2) sum to 5? Let's see. For example, 3 and 2: 3+1=4. Not enough. 3 and 3: 3+3=6>5. 4 and 1: 6+0=6>5. 2 and 2 and 2: 1+1+1=3. No. 3 and 2 and 1: 3+1+0=4. No. So the minimal sum is 3+2+2=7. But perhaps there's a way to split into s_i's such that their C(s_i, 2) sum to 5. For example, if we take s=3 (C=3) and then s=2 (C=1), and then s=2 (C=1). That gives sum 3+1+1=5. So the sum of s_i is 3+2+2=7. Which is the same as the greedy approach.\n\n   So the greedy approach seems correct.\n\n   Therefore, the way to compute the minimal n is to find the sum of the s_i's where each s_i is the largest possible such that C(s_i, 2) <= remaining p. This is similar to the problem of representing a number as a sum of triangular numbers, with the goal of minimizing the sum of their bases.\n\n   So the algorithm for the first part (finding minimal n) is:\n\n   Initialize remaining_p = p.\n\n   Initialize n = 0.\n\n   While remaining_p > 0:\n\n       find the largest s such that s*(s-1)/2 <= remaining_p.\n\n       add s to n.\n\n       subtract s*(s-1)/2 from remaining_p.\n\n   So, for example, for p=4:\n\n   remaining_p starts as 4.\n\n   largest s where s(s-1)/2 <=4 is 3 (3*2/2=3). Subtract 3, remaining_p=1.\n\n   next, largest s is 2 (2*1/2=1). Subtract 1, remaining_p=0.\n\n   n=3+2=5.\n\n   Which matches the sample.\n\n   Now, for the case where p=0. Then, the minimal n is 0? Wait, but the problem says that the graph must have exactly p mutual pairs. For p=0, the graph must have zero mutual pairs. Which is possible with any graph that is a DAG (no cycles) with no mutual reachability. However, the minimal number of nodes is 0? Or 1?\n\n   Wait, the problem says \"nodes\" in the graph. So for p=0, what is the minimal n?\n\n   For example, if n=0, there are zero nodes, so zero pairs. But the problem probably requires n ≥ 1? Or maybe n can be 0?\n\n   Looking at the sample input where p=0, the output is '0 0'. So for p=0, the minimal number of nodes is 0. But that's a bit strange. However, the problem says that the ordered pairs (u, v) must satisfy u < v. So for n=0, there are no nodes, hence no pairs. So it's acceptable.\n\n   However, for n=1, there are zero pairs (since u < v implies u and v are different). So for p=0, the minimal n is 0 or 1? According to the sample input, when p=0, the output is 0 0. So the code should return 0 for n.\n\n   But let's think again. The problem says that the graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and mutual reachability. For n=0, there are no such pairs, so p=0 is satisfied. So the minimal n is 0.\n\n   However, the problem's sample input for p=0 outputs '0 0', which aligns with this. So the code must handle that.\n\n   Now, the code needs to handle p=0 correctly.\n\n   Now, moving on. Once we have the minimal n, the second part is to compute the maximum number of unidirectional pairs. As discussed, this is [n^2 - sum (s_i^2)] / 2.\n\n   So, for the example where p=4, the s_i are 3 and 2. sum s_i^2 is 9 +4=13. n=5. 5^2 is 25. 25-13=12. Divided by 2 is 6, which matches the sample.\n\n   Therefore, the steps for the code are:\n\n   For a given p:\n\n   1. If p=0, then the minimal n is 0, and the maximum unidirectional pairs is 0.\n\n   2. Else, compute the minimal n by the greedy method as described.\n\n   3. Once we have the list of s_i's, compute sum_squares = sum (s_i^2).\n\n   4. The maximum unidirectional pairs is (n^2 - sum_squares) // 2.\n\n   So, the code needs to generate the list of s_i's.\n\n   Now, the challenge is to implement the greedy selection of s_i's.\n\n   Let's think about how to compute the largest s for a given remaining_p.\n\n   For a given remaining_p, find the maximum s where s*(s-1)/2 ≤ remaining_p.\n\n   Solving for s: s^2 -s - 2*remaining_p ≤ 0.\n\n   The roots of the equation s² -s - 2r = 0 are [1 ± sqrt(1 + 8r)] / 2.\n\n   So the maximum s is floor( (sqrt(8*r +1) +1)/2 )\n\n   For example, for r=4, sqrt(33) ~5.744, (5.744 +1)/2 ~ 3.372, floor is 3. Which is correct.\n\n   So the code can compute this s for each step.\n\n   So, in code:\n\n   For the given p, we can compute the list of s_i's as follows:\n\n   def find_s_list(p):\n\n       s_list = []\n\n       while p > 0:\n\n           # find maximum s where s*(s-1)//2 <= p\n\n           s = int( ( (1 + (8*p +1)**0.5 ) ) / 2 )\n\n           # check if s*(s-1)//2 <= p. Because due to floating point inaccuracies, maybe s is too big.\n\n           while s*(s-1)//2 > p:\n\n               s -=1\n\n           s_list.append(s)\n\n           p -= s*(s-1)//2\n\n       return s_list\n\n   But for p=0, returns empty list.\n\n   Once we have the s_list, the minimal n is sum(s_list). Then, sum_squares is sum(s^2 for s in s_list).\n\n   Then, the maximum unidirectional pairs is (n^2 - sum_squares) // 2.\n\n   However, there's a special case when p=0. In this case, the minimal n is 0, and the maximum unidirectional pairs is 0. But according to the code, when p=0, the s_list is empty. Then sum_squares is 0, n is 0. So (0^2 -0)/2 =0. Which is correct.\n\n   Now, let's test for p=3. The code would compute s=3 (3*2/2=3), subtract 3, p=0. So s_list is [3], sum_squares=9. n=3. (3² -9)/2 = (9-9)/2=0. Which matches the sample.\n\n   For p=4, the s_list is [3,2], sum_squares=9+4=13. n=5. (25-13)/2=6. Which matches the sample.\n\n   For p=0, returns 0 and 0.\n\n   Now, what about when p=1? The code would compute s=2 (since 2*1/2=1). Then p=0. So sum_squares=4. n=2. (2² -4)/2= (4-4)/2=0. So the maximum unidirectional pairs is 0. But how?\n\n   For p=1, the minimal n is 2. The graph must have exactly one mutual pair. Which is the case when the two nodes are in a single SCC. So all pairs are mutual. But there's only one pair (u, v) where u < v. So the mutual pairs count is 1. Then, the unidirectional pairs would be zero. Which matches the calculation.\n\n   Another test case: p=2. The code would take s=2 (C(2,2)=1), then p=1. Take s=2 again, p=0. So s_list is [2,2]. sum_squares is 4+4=8. n=4. (4² - 8)/2 = (16-8)/2=4. So maximum unidirectional pairs is 4.\n\n   How is that possible? The graph has two SCCs of size 2. The minimal n is 4. The maximum unidirectional pairs is 4. How?\n\n   The DAG of SCCs can be arranged as one SCC pointing to the other. So for each pair between the two SCCs, there are 2*2=4 unidirectional pairs. Which matches the calculation.\n\n   So the code seems correct.\n\n   Now, the code needs to handle the case when p is zero. Also, for cases where the s_list is empty (p=0), the code returns n=0 and unidirectional pairs 0.\n\n   Now, the code can be written as follows.\n\n   First, read p. Then:\n\n   if p ==0:\n\n       print 0 0\n\n   else:\n\n       compute s_list as per the greedy approach.\n\n       n = sum(s_list)\n\n       sum_squares = sum(s*s for s in s_list)\n\n       max_uni = (n*n - sum_squares) // 2\n\n       print n, max_uni\n\n   But wait, what about when p=0? The code returns 0 0, which is correct.\n\n   Let me check the sample input:\n\n   For input p=3:\n\n   s_list is [3], n=3, sum_squares=9. (3^2 -9)/2 =0. Output is 3 0. Which matches the first sample.\n\n   For p=4, output is 5 6. Which matches the sample.\n\n   For p=0, output is 0 0. Which matches the third sample.\n\n   Now, what about when p is something like 6? Then, the code would take s=4 (C(4,2)=6), sum_squares=16. n=4. (16-16)/2=0. So the maximum unidirectional pairs is 0. Which makes sense because all nodes are in a single SCC. So no unidirectional pairs.\n\n   Now, for p=5. Let's compute:\n\n   initial p=5.\n\n   compute s: (sqrt(8*5 +1) +1)/2 = sqrt(41) is ~6.4, 6.4 +1 =7.4 /2 = 3.7. So s=3. Check 3*2/2=3 <=5. subtract 3. p=2.\n\n   Next, for p=2: sqrt(8*2+1) = sqrt(17) ~4.123. (4.123 +1)/2 ~ 2.56. So s=2. 2*1/2=1 <=2. subtract 1. p=1.\n\n   Next, s=2 again. subtract 1. p=0. So s_list is [3,2,2]. sum is 3+2+2=7. sum_squares is 9 +4 +4 =17. n=7. (7^2 -17)/2 = (49-17)/2= 32/2=16. So maximum unidirectional pairs is 16.\n\n   So for p=5, the minimal n is 7 and the maximum unidirectional pairs is 16.\n\n   Now, let's think about the code's implementation.\n\n   Edge Cases:\n\n   - p=0 → 0 0.\n\n   - p=1 → 2 0.\n\n   - p=2 → 4 4?\n\n   Wait for p=2, the code would take s=2 (C=1), then p=1. Take s=2 again. So sum_squares is 4 +4 =8. n=4. (4² -8)/2 = (16-8)/2=4. Which is correct.\n\n   Now, code-wise, the problem is to compute the s_list.\n\n   Now, for the code, the function to find s for each step can be implemented with math.sqrt.\n\n   However, for large values of p (up to 2e5), the code must be efficient.\n\n   Let's think about the time complexity. Each iteration reduces p by at least s*(s-1)/2. For example, the first s is O(sqrt(p)), then the next is O(sqrt(p')), etc. The number of iterations is O(sqrt(p)), which for p up to 2e5 is acceptable.\n\n   Now, implementing this in Python.\n\n   Now, code steps:\n\n   Read p from input.\n\n   Handle p=0 case.\n\n   Else:\n\n       Compute the list of s_i's.\n\n   Now, code:\n\n   import math\n\n   p = int(input())\n\n   if p ==0:\n\n       print(\"0 0\")\n\n   else:\n\n       s_list = []\n\n       remaining = p\n\n       while remaining >0:\n\n           # compute s\n\n           s = int( ( (1 + math.sqrt(1 + 8*remaining )) ) / 2 )\n\n           # check if s*(s-1)//2 <= remaining\n\n           while s*(s-1)//2 > remaining:\n\n               s -=1\n\n           s_list.append(s)\n\n           remaining -= s*(s-1)//2\n\n       n = sum(s_list)\n\n       sum_sq = sum( s*s for s in s_list )\n\n       uni = (n*n - sum_sq) // 2\n\n       print(f\"{n} {uni}\")\n\n   Let me test this code with the sample inputs.\n\n   Sample Input 1: 3\n\n   Code:\n\n   remaining =3.\n\n   s = (1 + sqrt(1+24))/2 = (1+sqrt(25))/2 = (1+5)/2=3. So s=3. Check 3*2/2=3 <=3. So append 3. remaining becomes 0. s_list is [3]. n=3. sum_sq=9. uni=(9-9)/2=0. Output is 3 0. Correct.\n\n   Sample Input 4:\n\n   p=4. remaining=4.\n\n   s = (1 + sqrt(33))/2 ≈ (1+5.744)/2 ≈ 3.372 → s=3. Check 3*2/2=3 ≤4. remaining becomes 1. Next iteration: remaining=1. s = (1 + sqrt(9))/2 = (1+3)/2=2. Check 2*1/2=1 ≤1. append",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both `u` and `v` are mutually reachable.\n2. **Minimum Nodes Calculation**: The minimum number of nodes is determined by finding the smallest sum of sizes of strongly connected components (SCCs) such that the sum of combinations of their sizes taken two at a time equals `p`. This is done using a greedy approach where we repeatedly find the largest possible size of an SCC that contributes to the remaining value of `p`.\n3. **Unidirectional Pairs Calculation**: Once we have the minimum number of nodes, we calculate the maximum number of unidirectional pairs by arranging these SCCs in a linear order, maximizing the number of directed paths between different SCCs.\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    import sys\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    s_list = []\n    remaining = p\n    while remaining > 0:\n        # Calculate the maximum s such that s*(s-1)/2 <= remaining\n        s = int((1 + math.sqrt(1 + 8 * remaining)) / 2)\n        # Adjust s if necessary\n        while s * (s - 1) // 2 > remaining:\n            s -= 1\n        s_list.append(s)\n        remaining -= s * (s - 1) // 2\n    \n    n = sum(s_list)\n    sum_sq = sum(s * s for s in s_list)\n    uni = (n * n - sum_sq) // 2\n    print(f\"{n} {uni}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`.\n2. **Handling Zero Case**: If `p` is zero, the output is directly set to \"0 0\" since no nodes are needed.\n3. **Greedy Calculation of SCC Sizes**: For each iteration, the largest possible size `s` of an SCC is determined such that the combination `s*(s-1)/2` does not exceed the remaining value of `p`. This value is subtracted from `p`, and the process repeats until `p` is zero.\n4. **Summing Nodes and Calculating Unidirectional Pairs**: The total number of nodes `n` is the sum of all SCC sizes. The maximum number of unidirectional pairs is calculated using the formula derived from the sum of squares of SCC sizes and the total number of nodes.\n\nThis approach ensures that we efficiently determine the minimum number of nodes and maximize the unidirectional pairs using mathematical properties and greedy algorithms.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    import sys\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    s_list = []\n    remaining = p\n    while remaining > 0:\n        # Calculate the maximum s such that s*(s-1)/2 <= remaining\n        s = int((1 + math.sqrt(1 + 8 * remaining)) / 2)\n        # Adjust s if necessary\n        while s * (s - 1) // 2 > remaining:\n            s -= 1\n        s_list.append(s)\n        remaining -= s * (s - 1) // 2\n    \n    n = sum(s_list)\n    sum_sq = sum(s * s for s in s_list)\n    uni = (n * n - sum_sq) // 2\n    print(f\"{n} {uni}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 629,
        "thoughts_token_count": 8192
    }
}