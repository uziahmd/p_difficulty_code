{
    "start": 1758312829.3005328,
    "end": 1758313019.0175273,
    "start-formatted": "2025-09-20 05:13 KST",
    "end-formatted": "2025-09-20 05:16 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about the problem. Let's denote x = a +k and y = b +k. Then, since k is non-negative, x and y are at least a and b respectively, but since k can be added, they can be larger. But wait, since a and b are given, maybe we can express the difference between x and y. Let's see: since x = a +k, y = b +k, then y -x = b -a. So the difference between the two numbers is fixed. Let me call d = |a - b|. Without loss of generality, let's assume that a ≤ b. So, if a is less than b, then d = b - a. Then, the two numbers x and y are such that y = x + d. So, their LCM is LCM(x, x +d). \n\nThe LCM of two numbers can be calculated as (x * (x +d)) / GCD(x, x +d). Since GCD(x, x +d) is the same as GCD(x, d). Because GCD(x, x +d) = GCD(x, d). So, the LCM becomes (x*(x +d))/GCD(x, d). \n\nSo our problem reduces to finding x such that x ≥ a (since k is non-negative, and x = a +k, so x >= a) and x +d = b +k. Wait, since d is b -a, then x +d = (a +k) + (b -a) = b +k. Which is correct. So, the problem is equivalent to choosing x ≥ a, and then compute the LCM of x and x +d, where d is fixed as the difference between b and a. Then, find the x that minimizes this LCM, and then find the corresponding k, which is x -a. Since x must be ≥ a, k is non-negative.\n\nBut how do we find x that minimizes this LCM? Let's think about the LCM formula again. For x and x +d, their LCM is (x*(x +d))/g, where g is GCD(x, d). So, since d is fixed, perhaps we can find x such that GCD(x, d) is as large as possible, but also x*(x +d) is as small as possible. But it's not straightforward because increasing GCD(x, d) might reduce the LCM, but x itself could be larger. \n\nAlternatively, for each possible divisor of d, perhaps we can find the optimal x. Let me think. Since GCD(x, d) is some divisor of d. Let's say that g is a divisor of d. Then, x must be a multiple of g. Let me write x = g * m. Then, since d is fixed, and x +d = g*m +d. But since d is fixed, and g divides d, then d = g * t. So, x +d = g*m + g*t = g(m + t). Therefore, the GCD(x, x +d) is GCD(gm, g(m +t)) = g * GCD(m, m + t) = g * GCD(m, t). But since t = d/g, and since g is a divisor of d, then t is an integer. However, since GCD(m, m + t) = GCD(m, t), so the overall GCD(x, x +d) is g * GCD(m, t). \n\nWait, but earlier we said that GCD(x, x +d) = GCD(x, d). Since x = g*m, and d = g*t. Then, GCD(g*m, g*t) = g * GCD(m, t). Which matches. So, the LCM of x and x +d is (x * (x +d)) / (g * GCD(m, t)). \n\nBut x = g*m, and x +d = g*(m + t). So their product is g^2 * m*(m +t). Divided by g * GCD(m, t) gives g * m * (m + t) / GCD(m, t). \n\nHmm. Not sure if that helps. Maybe another approach: for the LCM of x and x +d, since x and x +d differ by d, perhaps the optimal x is such that x is as small as possible and shares a common divisor with d. For example, in the first sample input: a=6, b=10. Then d = 4. So x can be 6 +k. We want to find x such that LCM(x, x+4) is minimized. The sample solution uses k=2, so x=8. Then x+4=12. Their LCM is 24. Let's see other possibilities. For example, if x=6, then x+4=10. LCM(6,10)=30. If x=7, LCM(7, 11) is 77. If x=8, 8 and 12 have LCM 24. If x=9, LCM(9,13)=117. If x=10, LCM(10,14)=70. So the minimal is indeed 24 when x=8. So here, x is equal to d (4) multiplied by 2, and GCD(x, d) is 4. \n\nSo perhaps the optimal x is such that x is a multiple of some divisor of d. So the idea is to consider all possible divisors of d, and for each such divisor g, find the minimal x that is a multiple of g, and then compute the LCM. Then choose the minimal among all these possibilities.\n\nBut how do I generate all possible candidates for x?\n\nLet me think again. Since d is fixed, and we need to minimize the LCM of x and x +d. Let me note that for x and x +d, their LCM is minimized when their GCD is maximized. Because LCM(x, x +d) = (x*(x +d))/gcd(x, x+d) = (x*(x +d))/g, where g is gcd(x, d). So, for fixed d, if we can maximize g, then perhaps the LCM is minimized. However, even with higher g, x could be larger, leading to a larger product. So it's a balance between the value of x and the value of g.\n\nSo, perhaps the optimal x is such that x is as small as possible and shares a large common divisor with d.\n\nAlternatively, for each possible divisor g of d, we can find the minimal x ≥ a such that x is congruent to 0 mod g. Because then, x is a multiple of g, so the GCD(x, d) is at least g. But how to find the minimal x for each g?\n\nWait, but for each divisor g of d, the minimal x that is a multiple of g and is ≥a. Then, once we find that x, compute the LCM for that x. Then, compare across all divisors and find the minimal LCM.\n\nBut why would that work? Because for each possible divisor of d, we are considering the case where the GCD(x, d) is at least g. However, the actual GCD could be a multiple of g. But perhaps considering all divisors of d and trying to find the minimal x for each would cover all possibilities.\n\nBut how to proceed?\n\nLet me think of the steps:\n\n1. Compute d = |a - b|. Let's assume a ≤ b, so d = b -a. If a > b, swap them. So we can assume that a ≤ b, and d = b -a.\n\n2. Now, the problem reduces to finding x ≥ a (since k is non-negative, x = a +k ≥ a), and then compute LCM(x, x +d). Find the x that minimizes this LCM, and then return k = x -a.\n\nBut how to find this x?\n\nLet me consider that for x and x +d, the LCM is (x*(x +d))/g, where g is GCD(x, d). Since d is fixed, and x can vary. Let me think about possible values of g. Since g divides d, and also divides x. So, for each possible divisor g of d, perhaps the minimal LCM occurs when x is chosen as the smallest possible multiple of g that is ≥a. Then, for each such x, compute the LCM and compare.\n\nBut why would that be sufficient? Because for any x, its GCD with d is some divisor of d. So, for each possible divisor g of d, there's a candidate x that is a multiple of g, and we can check those candidates.\n\nSo the approach is:\n\n- Generate all divisors of d.\n\n- For each divisor g of d, compute the minimal x ≥ a that is a multiple of g. Let's call this x_candidate. Then compute LCM(x_candidate, x_candidate +d).\n\n- Also, we need to consider the case where x is such that x is not a multiple of any divisor of d. Wait, but no. Because any x's GCD with d is a divisor of d. So, the maximum possible GCD(x, d) is some divisor of d. Therefore, considering all divisors of d and finding the best x_candidate for each should cover all possibilities.\n\nBut what about when the optimal x is not a multiple of any of the divisors of d? Well, that's impossible. Because the GCD(x, d) is a divisor of d, so for that x, the GCD is a divisor of d, say g. So, x must be a multiple of g. Therefore, considering all divisors of d and for each, the minimal x_candidate that is a multiple of g and ≥a will capture the optimal x.\n\nSo the plan is:\n\n- Generate all divisors of d.\n\n- For each divisor g, compute the minimal x_candidate that is ≥a and a multiple of g. Then compute LCM(x_candidate, x_candidate +d). Keep track of the minimal LCM and the corresponding k.\n\n- Also, there's another case: when d is zero. Wait, what if a equals b? Then d is zero. In that case, x = a +k and y = b +k = x. So their LCM is x. To minimize x, we take k=0. So the answer is 0. So we need to handle this case separately.\n\nSo first, check if a == b. If yes, then return 0.\n\nOtherwise, proceed with the steps above.\n\nNow, the next step is to generate all divisors of d. How to do that?\n\nWell, for d, we can factorize it into primes and generate all divisors. However, since d can be up to 1e9 (since a and b are up to 1e9, their difference can be up to 1e9), factorization may take O(sqrt(d)) time, which is acceptable.\n\nOnce we have all the divisors, for each of them, compute the minimal x_candidate that is a multiple of g and ≥a. Then compute LCM(x_candidate, x_candidate +d). Then compare all these possibilities.\n\nBut also, there's another possibility. Suppose that the optimal x is not the minimal multiple of g ≥a, but another multiple. For example, maybe taking a higher multiple of g could lead to a lower LCM. How can we know?\n\nWait, for example, suppose that d is 4, and a is 6. Let's take g=4. The minimal x_candidate is 8 (since 6 is not a multiple of 4, the next is 8). Then x_candidate is 8, and x_candidate +d is 12. LCM is 24. What if there's another x_candidate which is a multiple of 4, say 12? Then LCM(12, 16) is 48. Which is worse. So in this case, the minimal x_candidate is better. So perhaps for each divisor g, the minimal x_candidate (the smallest possible multiple of g ≥a) is the best candidate for that divisor. Because as x increases, the product x*(x +d) increases. So for each g, the minimal x_candidate (the first one ≥a) is the best option for that g.\n\nTherefore, considering for each divisor g of d, the minimal x_candidate ≥a that is a multiple of g, and then compute the LCM for that x_candidate, and compare all possibilities.\n\nSo the steps are:\n\nIf a == b: return 0.\n\nElse:\n\nCompute d = |a - b|.\n\nGenerate all divisors of d.\n\nFor each divisor g:\n\nCompute the minimal x_candidate ≥a that is a multiple of g. How?\n\nWell, x_candidate = ((a + g -1) // g) * g. For example, if a is 6 and g is 4, then (6 +4-1)//4 = (9)//4=2, 2*4=8.\n\nOnce x_candidate is found, compute the LCM of x_candidate and x_candidate +d. Then, compare all these possibilities.\n\nAdditionally, we should also consider the case where x_candidate is a multiple of some divisor of d, but maybe not all. But since we are generating all divisors, that's covered.\n\nOnce all possibilities are considered, select the x_candidate that gives the minimal LCM. If multiple x_candidates have the same minimal LCM, select the one with the smallest k (which is x_candidate -a). Because if two x_candidates have same LCM, the smaller x_candidate would have smaller k.\n\nBut wait, there's also the case where x_candidate is not generated from any divisor of d. But earlier reasoning says that this is not possible. Because for any x_candidate, the GCD(x_candidate, d) is a divisor of d, so there exists a divisor g of d such that x_candidate is a multiple of g. Therefore, the minimal x_candidate for that g would be considered.\n\nSo the plan is to generate all divisors of d, compute x_candidate for each, and compare.\n\nOnce we have all candidates, we can choose the one with the minimal LCM, and in case of tie, the smallest k.\n\nBut wait, there's another case. What if the optimal x is not a multiple of any of the divisors of d? No, because the GCD(x, d) is a divisor of d, so x must be a multiple of that GCD. Therefore, for that GCD, which is a divisor of d, the x_candidate is considered.\n\nThus, the approach is correct.\n\nNow, the steps to code this:\n\nFirst, handle the case where a == b. Then, output 0.\n\nElse, compute d = abs(a - b). Then generate all divisors of d.\n\nThen for each divisor g of d, compute x_candidate as the smallest multiple of g that is >= a. Then compute the LCM of x_candidate and x_candidate +d.\n\nBut how to generate all the divisors of d?\n\nTo generate all divisors of d:\n\nWe can factorize d into primes, then generate all combinations.\n\nBut for code purposes, perhaps the easiest way is to iterate from 1 to sqrt(d), check if i divides d. Then add i and d/i to the list of divisors, making sure to avoid duplicates when d is a square.\n\nBut for d=0, but in our case, when a != b, d is positive. So no problem.\n\nSo code steps for generating divisors of d:\n\ndef get_divisors(d):\n\n    divisors = set()\n\n    for i in range(1, int(math.sqrt(d)) +1):\n\n        if d % i == 0:\n\n            divisors.add(i)\n\n            divisors.add(d//i)\n\n    return sorted(divisors)\n\nBut wait, for d=0? Well, in our code, we have already handled a == b case. So d is non-zero here.\n\nOnce we have all the divisors, process each one.\n\nOnce all candidates are generated, collect all possible (LCM_value, k) pairs, and choose the one with minimal LCM, and then minimal k.\n\nBut what about the case where d is zero? Well, handled earlier.\n\nNow, let's test this approach on the sample input.\n\nSample Input 1: 6 10. So a=6, b=10. d=4. The divisors of 4 are 1, 2, 4.\n\nFor each divisor:\n\ng=1:\n\nx_candidate is the smallest multiple of 1 >=6. That is 6. Then x_candidate +d = 10. LCM(6, 10) is 30.\n\ng=2:\n\nsmallest multiple of 2 >=6 is 6. x_candidate=6. x_candidate +d=10. LCM(6, 10)=30.\n\ng=4: smallest multiple >=6 is 8. x_candidate=8, x_candidate +d=12. LCM(8, 12)=24.\n\nSo the minimal is 24. So the answer is k=8-6=2. Which matches the sample.\n\nAnother sample input: 5 10. So a=5, b=10. d=5. Divisors of 5 are 1,5.\n\nFor g=1: x_candidate is 5. x_candidate +d=10. LCM(5,10)=10.\n\nFor g=5: x_candidate is 5. x_candidate +d=10. LCM is 10. So same value. So the minimal k is 0. Which is correct.\n\nAnother sample input: 21 31. a=21, b=31. d=10. Divisors of 10 are 1,2,5,10.\n\nFor each divisor:\n\ng=1: x_candidate is 21. x_candidate +d=31. LCM(21,31)=651.\n\ng=2: x_candidate is 22 (since 21//2 is 10.5, so ceil(21/2) is 11. 11*2=22). x_candidate +d=32. LCM(22,32) is (22*32)/2 = 352.\n\ng=5: x_candidate is 25 (since 21/5 is 4.2, so 5*5=25). x_candidate +d=35. LCM(25,35) is (25*35)/5 = 175.\n\ng=10: x_candidate is 30 (since 21/10 is 2.1, so 3*10=30). x_candidate +d=40. LCM(30,40) is 120.\n\nSo the minimal is 120? But the sample output is 9. Let me check. Wait, the sample input is 21 and 31. The output is 9. Let's see:\n\nk=9. Then a +k is 21 +9 =30, b +k is 31 +9=40. LCM(30,40) is 120. Which matches the case when g=10. So that's the correct answer. But according to our approach, the minimal LCM is 120, which is the case. So the code would select that. So the answer is k=9. Which is correct.\n\nSo the approach seems to work.\n\nNow, what about other cases?\n\nAnother example: a=3, b=5. d=2. Divisors are 1, 2.\n\nFor g=1: x_candidate is 3. LCM(3,5)=15.\n\nFor g=2: x_candidate is 4. LCM(4, 6)=12. So the minimal is 12. k=1.\n\nWhich is correct.\n\nBut what if a=4, b=6. d=2. Divisors 1,2.\n\nFor g=1: x_candidate is 4. LCM(4,6) is 12.\n\nFor g=2: x_candidate is 4. LCM(4,6)=12. So same value. So the minimal k is 0. Which is correct.\n\nSo the code needs to choose the smallest k in case of ties.\n\nSo, in this case, when multiple x_candidates give same LCM, we need to select the one with the smallest k.\n\nSo, during processing, for each candidate, we collect (lcm_value, k), and then select the one with the minimal lcm_value, and if there are multiple, the minimal k.\n\nThus, the code must generate all possible candidates, collect their LCM and k, and choose the best.\n\nNow, the code steps:\n\nImplement a function to get all divisors of d.\n\nBut for d=0, but that is already handled.\n\nNow, code:\n\nRead a and b.\n\nif a == b: print 0.\n\nelse:\n\n    d = abs(a -b)\n\n    generate all divisors of d.\n\n    for each divisor g in divisors:\n\n        compute x_candidate = ((a + g -1) // g) * g\n\n        compute y_candidate = x_candidate + d\n\n        compute LCM(x_candidate, y_candidate)\n\n        collect (lcm_value, k_candidate = x_candidate -a)\n\n    then find the candidate with the minimal lcm_value, and minimal k.\n\nBut wait, what about other possibilities? For example, when the optimal x is not the minimal multiple of g, but a higher multiple? For example, suppose that d=4, a=6. For g=4, the minimal x_candidate is 8, which gives LCM 24. But if there is a higher multiple, say x_candidate=12, then LCM(12, 16) is 48. Which is worse. So the minimal x_candidate is better. Hence, considering only the minimal x_candidate per divisor is sufficient.\n\nBut what if there's a case where for a certain divisor g, taking a higher multiple gives a better LCM?\n\nLet me think. Suppose d=6, a=5. So d=6, divisors are 1,2,3,6.\n\nTake g=3. The minimal x_candidate is 6 (since 5//3 is 1.666, so 2*3=6). Then x_candidate=6, y_candidate=6+6=12. LCM(6,12)=12.\n\nBut what if x_candidate is 3? But 3 is less than a=5, so not allowed. So the minimal x_candidate is 6.\n\nBut what if a=3, and d=6. Then for g=3, x_candidate is 3. y_candidate=9. LCM(3,9)=9. But if we take x_candidate=6, LCM(6, 12) is 12. So the minimal is better. So the minimal x_candidate is better.\n\nSo, it seems that for each divisor, the minimal x_candidate is the best possible for that divisor. Hence, considering only that is sufficient.\n\nSo, the code proceeds as described.\n\nNow, how to compute LCM(x, y)?\n\nWell, LCM(x,y) = x*y // GCD(x,y).\n\nSo, in Python, we can use math.gcd, but note that math.gcd returns the absolute value, but since x and y are positive, it's okay.\n\nBut in Python 3.5+, math.gcd exists. Also, need to handle the case where one of x or y is zero. But in our case, since x is >=a >=1, and y =x +d >=x +1 (since d is positive). So x and y are positive.\n\nSo, code for LCM:\n\ndef lcm(x, y):\n\n    return x * y // math.gcd(x, y)\n\nBut in code, for each x_candidate and y_candidate, compute that.\n\nNow, the code steps.\n\nBut also, what about the case where d is 0? Well, handled earlier.\n\nNow, code:\n\nimport math\n\ndef get_divisors(n):\n\n    divisors = set()\n\n    for i in range(1, int(math.isqrt(n)) + 1):\n\n        if n % i == 0:\n\n            divisors.add(i)\n\n            divisors.add(n // i)\n\n    return divisors\n\nBut wait, math.isqrt is available in Python 3.8+. For older versions, perhaps math.sqrt, but then cast to integer. But assuming that the code is run in an environment that supports math.isqrt.\n\nOnce the divisors are generated, for each, compute x_candidate.\n\nNow, code:\n\na, b = map(int, input().split())\n\nif a == b:\n\n    print(0)\n\nelse:\n\n    d = abs(a - b)\n\n    divisors = get_divisors(d)\n\n    min_lcm = float('inf')\n\n    best_k = float('inf')\n\n    for g in divisors:\n\n        # compute x_candidate as the smallest multiple of g >=a\n\n        # compute quotient = ceil(a / g)\n\n        # x_candidate = quotient * g\n\n        quotient = (a + g -1) // g\n\n        x_candidate = quotient * g\n\n        y_candidate = x_candidate + d\n\n        current_lcm = (x_candidate * y_candidate) // math.gcd(x_candidate, y_candidate)\n\n        # compare with current min\n\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x_candidate - a) < best_k):\n\n            min_lcm = current_lcm\n\n            best_k = x_candidate - a\n\n    print(best_k)\n\nWait, but what about the case where the optimal x_candidate is not in the divisors' candidates? For example, suppose that the optimal x is such that GCD(x, d) is not a divisor of d? No, that's impossible. Because GCD(x, d) divides d, so it's one of the divisors. Hence, the code should capture all possible cases.\n\nBut let's test with the sample input where a=5 and b=10. d=5. Divisors are 1,5.\n\nFor g=1, x_candidate is 5. y_candidate is 10. LCM is 10. For g=5, x_candidate is 5. Same LCM. So best_k is 0, which is correct.\n\nAnother test case: a=6, b=10. d=4. Divisors are 1,2,4. For each, the code computes the candidates and finds the minimal.\n\nBut what about when there are multiple divisors leading to same LCM? For example, in the case where a=4, b=6. d=2. Divisors are 1, 2. For g=1, x_candidate is 4. LCM(4,6)=12. For g=2, x_candidate is 4. LCM same. So best_k is 0.\n\nSo code would select the first occurrence. But since in the code, when current_lcm is equal to min_lcm, and the new k is smaller than best_k, then it updates. But in this case, the first candidate (g=1) would set min_lcm to 12 and best_k to 0. Then for g=2, same current_lcm, but x_candidate -a is 0. So no change. Thus, the code returns 0.\n\nSo code seems correct.\n\nBut what about when there are multiple divisors leading to same LCM but different k's? For example, suppose a=3, d=4. Let's say a=3, and d=4. Then, divisors are 1,2,4.\n\nFor g=1: x_candidate is 3. y_candidate=7. LCM is 21.\n\nFor g=2: x_candidate is 4. y_candidate=8. LCM(4,8)=8.\n\nFor g=4: x_candidate is 4. same as above. So the code would pick the best_k as 1 (4-3=1).\n\nBut what if there's another candidate for a different divisor?\n\nBut the code handles that.\n\nNow, let's think about edge cases.\n\nCase 1: a=1, b=2. d=1. Divisors of 1: {1}.\n\nx_candidate is 1. y_candidate is 2. LCM is 2. k=0. Which is correct.\n\nCase 2: a=1, b=3. d=2. Divisors are 1,2.\n\nFor g=1: x_candidate is 1. LCM(1, 3) is 3.\n\nFor g=2: x_candidate is 2. LCM(2,4)=4. So the minimal is 3. So k=0. Which is correct.\n\nAnother case: a=2, b=5. d=3. Divisors are 1,3.\n\nFor g=1: x_candidate=2. LCM(2,5)=10.\n\nFor g=3: x_candidate is 3. LCM(3, 6) is 6. So best is 6, k=1. Which is better.\n\nSo code returns 1.\n\nYes.\n\nAnother case: a=7, b=15. d=8. Divisors are 1, 2, 4, 8, 8's divisors.\n\nLet's compute for each:\n\ng=1: x_candidate is 7. y_candidate=15. LCM(7,15)=105.\n\ng=2: x_candidate is 8. y_candidate=16. LCM(8,16)=16. k=1.\n\ng=4: x_candidate is 8. same as above.\n\ng=8: x_candidate is 8. same as above.\n\nSo the minimal is 16, k=1.\n\nWhich is correct.\n\nBut what if a=8 and b=15. Then d=7. Divisors are 1,7.\n\nFor g=1: x_candidate is 8. y_candidate=15. LCM(8,15)=120.\n\nFor g=7: x_candidate is 14 (since 8//7 is 1.14, so 2*7=14). y_candidate is 14+7=21. LCM(14,21) = 42. So k=14-8=6. Which is better than 120.\n\nSo code would choose that.\n\nSo code works.\n\nNow, what about when a is larger than b? For example, a=10, b=6. Then d=4. So code would swap them? Or not? Because in the code, d is computed as absolute difference, and the code proceeds. So in this case, the code would generate the same divisors as before, and for each divisor, compute x_candidate as the smallest multiple of g >=a (which is 10). For example, for g=4, x_candidate is 12. Then y_candidate is 12 +4=16. LCM(12,16)=48. Which is same as when a was 6 and b was 10, but k would be 12-10=2. Which would be same as before. But since in this case, the code would generate same result. So the code does not need to swap a and b. Because d is absolute difference, and x_candidate is based on a (the original a, which may be larger than b). But in this case, the code would still generate the correct k.\n\nBut in this case, the original a is 10, and the code computes x_candidate as the minimal multiple of g >=a. Which is correct.\n\nSo the code doesn't need to swap a and b. Because regardless of which is larger, the code processes the same d and finds the x_candidate based on the original a.\n\nSo the code is correct.\n\nNow, code:\n\nBut what about the case when the minimal LCM is achieved for a divisor that is not in the list of divisors? No, because we generate all divisors of d.\n\nNow, code:\n\nBut for the code, when generating divisors, the code uses get_divisors(d). Let me check the code for generating divisors.\n\nWait, the code for get_divisors is:\n\ndef get_divisors(n):\n\n    divisors = set()\n\n    for i in range(1, int(math.isqrt(n)) + 1):\n\n        if n % i == 0:\n\n            divisors.add(i)\n\n            divisors.add(n // i)\n\n    return divisors\n\nYes. For example, for n=4, the loop runs i from 1 to 2. For i=1, 4%1=0, add 1 and 4. For i=2, 4%2=0, add 2 and 2. So the set is {1,2,4}.\n\nYes.\n\nNow, code:\n\nBut in the code, for the initial case, when a and b are given, the code may have a > b. For example, a=10, b=6. Then d=4. The code proceeds correctly.\n\nNow, code in Python:\n\nBut in the code, the function get_divisors is called with d. So, the code is written as follows.\n\nBut in Python, the code must read from stdin. So, putting it all together.\n\nBut the code must handle multiple test cases? No, the problem says that the input is a single line with two integers. Wait, looking back at the problem statement:\n\nInput:\n\nThe only line contains two integers a and b.\n\nSo the code reads a single line, splits into a and b.\n\nBut in the sample input, the examples are given as:\n\n['6 10', '21 31', '5 10']\n\nBut that's probably for multiple test cases. However, the problem says that the input is a single line. So perhaps the sample input is for multiple test cases, but the actual code is supposed to read one line.\n\nWait, looking back:\n\nThe problem says:\n\nInput:\n\nThe only line contains two integers a and b (1 ≤ a, b ≤ 1e9).\n\nSo the code must read a single line, with two integers. The sample shows multiple test cases, but that's probably for illustration. So the code must read one line, and output one line.\n\nSo the code is for a single test case.\n\nSo the code:\n\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        # compute x_candidate\n        quotient = (a + g - 1) // g\n        x_candidate = quotient * g\n        y_candidate = x_candidate + d\n        current_gcd = math.gcd(x_candidate, y_candidate)\n        current_lcm = (x_candidate * y_candidate) // current_gcd\n        # compare\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x_candidate - a) < best_k):\n            min_lcm = current_lcm\n            best_k = x_candidate - a\n    print(best_k)\n\nWait, but what if there are multiple divisors that produce the same LCM? For example, if two different divisors generate the same LCM but with different k's, the code will select the one with the smallest k.\n\nBut in the code, the for loop iterates through all divisors. For each, it checks if the current_lcm is better than the previous min, or same lcm but smaller k. So it's correct.\n\nBut there's a problem: the code may miss some candidates. For example, what if the optimal x is not generated by any of the divisors of d? But earlier reasoning says that it's impossible. Because the GCD(x, d) must be a divisor of d. So for that x, there exists a divisor g of d, which is the GCD(x, d). Then, x is a multiple of g. So the code considers for that g, the minimal x_candidate >=a. But perhaps that x_candidate is not the same as the optimal x. For example, suppose that the optimal x is larger than the minimal x_candidate for that g. But in that case, the code would not consider it. However, earlier reasoning suggests that for that g, the minimal x_candidate is better than higher multiples. So the code is correct.\n\nBut let's think of a case where the optimal x is not the minimal x_candidate for any divisor.\n\nLet me think of an example. Suppose a=7, d=6. So d=6, divisors are 1, 2, 3, 6.\n\nSuppose that the optimal x is 9. Let's see:\n\nx_candidate for g=3 is ((7 +3-1)//3)*3 = (9//3)*3= 3*3=9. So yes, it's considered. So for g=3, the code would generate x_candidate=9. So it's considered.\n\nAnother example: suppose a=5, d=6. Then for g=3, the minimal x_candidate is 6. Which is considered.\n\nSo code covers that.\n\nBut",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we choose the smallest $ k $.\n\n### Approach\n1. **Special Case Handling**: If $ a $ and $ b $ are equal, the LCM is simply $ a $ (or $ b $), so $ k = 0 $.\n2. **Difference Calculation**: Compute the absolute difference $ d $ between $ a $ and $ b $.\n3. **Divisors of $ d $**: Generate all divisors of $ d $. This helps in finding potential values of $ k $ that could minimize the LCM.\n4. **Candidate Evaluation**: For each divisor $ g $ of $ d $, compute the smallest multiple of $ g $ that is greater than or equal to $ a $. This value, $ x $, is used to calculate the corresponding $ y = x + d $ and their LCM.\n5. **Optimal $ k $ Selection**: Track the minimum LCM found and the corresponding $ k $, ensuring that the smallest $ k $ is chosen in case of ties.\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        quotient = (a + g - 1) // g\n        x_candidate = quotient * g\n        y_candidate = x_candidate + d\n        current_gcd = math.gcd(x_candidate, y_candidate)\n        current_lcm = (x_candidate * y_candidate) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x_candidate - a) < best_k):\n            min_lcm = current_lcm\n            best_k = x_candidate - a\n    print(best_k)\n```\n\n### Explanation\n1. **Special Case Handling**: Directly check if $ a $ equals $ b $, in which case $ k = 0 $.\n2. **Divisors Calculation**: The function `get_divisors` generates all divisors of $ d $, which is the absolute difference between $ a $ and $ b $.\n3. **Candidate Evaluation**: For each divisor $ g $, compute the smallest multiple of $ g $ that is at least $ a $. This ensures we consider values of $ x $ that could potentially minimize the LCM.\n4. **LCM Calculation**: For each candidate $ x $, compute the corresponding $ y $ and their LCM. Track the minimum LCM and the corresponding $ k $, ensuring the smallest $ k $ is chosen in case of ties.\n\nThis approach efficiently narrows down potential candidates for $ k $ using properties of divisors and LCM, ensuring optimal performance even for large values of $ a $ and $ b $.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        quotient = (a + g - 1) // g\n        x_candidate = quotient * g\n        y_candidate = x_candidate + d\n        current_gcd = math.gcd(x_candidate, y_candidate)\n        current_lcm = (x_candidate * y_candidate) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x_candidate - a) < best_k):\n            min_lcm = current_lcm\n            best_k = x_candidate - a\n    print(best_k)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 713,
        "thoughts_token_count": 8192
    }
}