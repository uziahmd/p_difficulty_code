{
    "start": 1758313938.391006,
    "end": 1758314110.9240673,
    "start-formatted": "2025-09-20 05:32 KST",
    "end-formatted": "2025-09-20 05:35 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure of such a graph.\n\nSo, according to the problem statement, the snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that has only one connection (so those leaves) are each connected to k new vertices. And this step must be done at least once. So the process is like building layers.\n\nLet me think about the structure. Let's model the number of vertices after each step.\n\nInitially, there's 1 vertex. Let's call this level 0.\n\nThen, in the first step, we add k vertices connected to the root. Now total vertices is 1 + k. But each of these k vertices has degree 1 (since they are connected only to the root). Now, the next step requires that each of these leaves (the ones with only one connection) get connected to k new vertices. So for each of the k leaves, we add k new vertices. So for each such leaf, we add k vertices. So the total added here is k * k. So the total number of vertices becomes 1 + k + k^2. \n\nBut wait, this step must be done at least once. So the minimal snowflake would have two steps: the initial step (adding k children to the root), and then adding k children to each of those leaves. So the minimal number of vertices is 1 + k + k^2. For example, when k=4, the minimal is 1+4+16=21? Wait the example says for n=6 it's no. Let's check the sample input.\n\nLooking at the sample input: for n=6, output is NO. Let's see why. Let's think about possible k values.\n\nFor example, if k=2, then the minimal is 1 + 2 + 4 =7. So 6 is less than that. So for k=2, you can't have 6. What about other possibilities?\n\nWait, maybe there are other ways to build the snowflake. Because the problem says that the step of adding k new vertices to each leaf is done at least once. So maybe there are multiple steps. Like, maybe after adding the first layer, you can add more layers. For example, perhaps the snowflake can have more than two layers.\n\nLet me think again. The construction process is:\n\nStart with one node.\n\nThen, add a layer of k nodes connected to the root. Now, all these nodes have degree 1. Then, for each such node, add k new nodes. So that's the second layer. Now, each of those new nodes (second layer) has degree 1. Then, we can repeat this process again. So each time, we add a new layer where each leaf (from the previous step) gets k new children.\n\nSo the total number of vertices depends on how many layers we have. Let's model this.\n\nLet me think recursively. Let's say that the snowflake has m layers. The first layer is the root. Then, the second layer is the k children of the root. The third layer is each of those k nodes having k children. And so on. But the process requires that the step of adding new nodes to the leaves is done at least once. So the minimal number of layers is 2 (root and first layer), but then we must do the step again. Wait, the problem says that after the initial step (connecting the root to k nodes), each vertex that is connected to only one other (i.e., the leaves) is connected to k new nodes. This step should be done at least once. So that implies that the process must have at least two layers. Wait, the initial step is adding the first layer (k nodes). Then, the step of adding k nodes to each leaf is done once. So that's adding the second layer. So the minimal number of layers is two. So the minimal total vertices is 1 + k + k^2. For example, when k=2, that's 1+2+4=7. So n=7 would be possible. But for n=6, no.\n\nBut the problem allows for more layers. For example, after adding the second layer (each of the first layer's nodes gets k children), we could then do another step: take each leaf (the second layer's nodes) and add k children each. So that would be a third layer. Then the total number of vertices would be 1 + k + k^2 + k^3. But then, the process must have done the step (adding to leaves) at least once. So in this case, the step was done twice.\n\nSo the",
    "response": "To solve this problem, we need to determine whether a given number of vertices `n` can form a valid \"snowflake\" graph as defined in the problem. The snowflake graph is constructed in layers, starting with a single root node and adding layers where each leaf node from the previous layer gets exactly `k` new children (with `k > 1`). This process must be repeated at least once after the initial setup.\n\n---\n\n### Key Observations:\n\n1. **Snowflake Construction**:\n   - The graph starts with a single root node.\n   - The first layer consists of `k` nodes connected to the root.\n   - Then, for each leaf node (i.e., those with only one connection), we add `k` new nodes. This step must be done **at least once**.\n   - The total number of nodes after `m` such steps is:\n     $$\n     n = 1 + k + k^2 + \\dots + k^m\n     $$\n     which is a geometric series.\n\n2. **Geometric Series Form**:\n   - The sum of the geometric series up to `m+1` terms (starting from 0) is:\n     $$\n     n = \\frac{k^{m+1} - 1}{k - 1}\n     $$\n   - We need to check if there exists any integer `k > 1` and some `m ≥ 1` such that this equation holds for a given `n`.\n\n3. **Constraints**:\n   - Since `n` can be as large as $10^{18}$, we must ensure our solution is efficient — brute-forcing all possible `k` values is not feasible.\n\n---\n\n### Strategy:\n\n- For a given `n`, we try to find a value of `k > 1` such that:\n  $$\n  \\frac{k^{m+1} - 1}{k - 1} = n\n  $$\n  for some integer `m ≥ 1`.\n- Since `k` can be large, we iterate over possible values of `m` (starting from 1 up to around 60, since $2^{60}$ exceeds $10^{18}$).\n- For each `m`, we compute the corresponding value of `k` using binary search and verify if it satisfies the formula.\n\n---\n\n### Code Implementation:\n\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False  # At least 2 layers required, so minimum is 1 + k + k^2\n    max_m = 60  # since 2^60 is larger than 1e18\n    for m in range(1, max_m + 1):\n        # We want to find k such that (k^(m+1) - 1) / (k - 1) == n\n        # Binary search for k in [2, ...]\n        low = 2\n        high = 2\n        # Find an upper bound for binary search\n        while (high ** (m + 1) - 1) // (high - 1) < n:\n            high *= 2\n        # Binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            try:\n                total = (mid ** (m + 1) - 1) // (mid - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### Explanation:\n\n- The function `is_snowflake(n)` checks if `n` can be expressed as the sum of a geometric series for some `k > 1` and `m ≥ 1`.\n- For each possible number of layers (`m`), we use binary search to find a suitable `k`.\n- If such a `k` is found, the answer is \"YES\", otherwise \"NO\".\n\nThis approach ensures that we handle even very large values of `n` efficiently within the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False  # At least 2 layers required, so minimum is 1 + k + k^2\n    max_m = 60  # since 2^60 is larger than 1e18\n    for m in range(1, max_m + 1):\n        # We want to find k such that (k^(m+1) - 1) / (k - 1) == n\n        # Binary search for k in [2, ...]\n        low = 2\n        high = 2\n        # Find an upper bound for binary search\n        while (high ** (m + 1) - 1) // (high - 1) < n:\n            high *= 2\n        # Binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            try:\n                total = (mid ** (m + 1) - 1) // (mid - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 975,
        "thoughts_token_count": 1024
    }
}