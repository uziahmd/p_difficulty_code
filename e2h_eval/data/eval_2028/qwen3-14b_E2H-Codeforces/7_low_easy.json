{
    "start": 1758008514.1352153,
    "end": 1758008713.725407,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure.\n\nThe construction rules are:\n\nStart with one vertex. Then, add k new vertices connected to it. Then, each vertex that has only one connection (so the leaves) get connected to k new vertices. This process must be done at least once. So, the snowflake has a certain hierarchical structure.\n\nLet me think about how the number of vertices grows with each step.\n\nLet me think of the steps as levels. The initial step is level 0: 1 node. Then level 1: adding k nodes connected to the root. Then, each of those k nodes (which are leaves) get k new nodes. But wait, the problem says that each vertex connected to only one other (so the leaves) must be connected to k new vertices. And this step must be done at least once. So the minimal case would be when we do this expansion once.\n\nSo for example, for k=4, the minimal snowflake is:\n\nStart with 1 node. Then add 4 nodes (total 5). Then, each of the 4 leaves gets 4 new nodes. So the next step adds 4 * 4 = 16 nodes. Total is 1 + 4 + 16 = 21? Wait, but the example in the problem says that for n=13, the answer is YES. Wait, maybe I'm misunderstanding the steps.\n\nWait the example input includes n=13 and output is YES. Let me think about that. How can 13 be formed?\n\nLet me think of the possible structures. Let me model the number of vertices after each step.\n\nLet me think of the snowflake as being built in layers. Let's say that the initial step is level 0: 1 node. Then, level 1 is adding k children to the root. So total nodes is 1 + k. Then, each of those k nodes (which are leaves) are expanded by adding k children each. So level 2 adds k * k nodes. Now total nodes is 1 +k +k².\n\nBut according to the problem statement, the step of expanding the leaves must be done at least once. So the minimal snowflake would be when we have two expansions. For example, the initial step (level 0) and then expanding once (level 1) and then expanding again (level 2). But wait, the initial expansion (adding level 1) is the first step. Then, the second step is expanding the leaves (level 1 nodes) to add level 2. So the minimal snowflake is 1 + k + k². But for k>1. So for example, if k=2, the minimal is 1+2+4=7 nodes. So for n=7, answer is yes. But in the sample input, n=6 is output as NO. Which makes sense because 6 is not of the form 1 +k +k² for any k>1. Let's check for k=2: 1+2+4=7. For k=1, but k must be >1. So no.\n\nSo the problem is to find whether n can be written in the form 1 + k + k^2 + ... +k^m, where m ≥1 (since the expansion step must be done at least once). Wait, no. Let me re-examine the construction steps.\n\nThe initial graph has one node. Then, the first expansion adds k nodes connected to the initial node. Then, each leaf (the k nodes) must be expanded once. So that's adding k *k nodes. But the problem says that the step of expanding the leaves should be done at least once. So the minimal snowflake is when we do that expansion once. So the total number of nodes is 1 +k +k^2. But what if we do more expansions?\n\nFor example, after expanding the leaves once (so level 2), then each leaf in level 2 (which are the k^2 nodes) can be expanded again. So adding k^3 nodes. So the total is 1 +k +k^2 +k^3. But then the expansion steps are done twice. So the problem allows for any number of expansions, as long as the expansion step is done at least once. So the snowflake can have any number of layers, as long as there are at least two layers (the initial step and one expansion).\n\nSo the general formula for the number of nodes is 1 + k*(k^m -1)/(k-1) ), where m is the number of expansions. Wait, perhaps not. Let me think again.\n\nThe initial node is 1. Then, the first expansion adds",
    "response": "\n\nTo solve this problem, we need to determine if a given number of vertices `n` can form a valid snowflake graph based on specific construction rules. The snowflake graph starts with one vertex and expands in layers where each leaf node is connected to `k` new vertices, with `k > 1`.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph is constructed in layers. Starting with a single vertex, each subsequent layer adds `k` new vertices to every leaf node from the previous layer. This expansion must be done at least once.\n2. **Mathematical Formulation**: The total number of vertices after `m` expansions (with `m >= 1`) can be represented as a geometric series. For a given `k`, the total number of vertices is `1 + k + k^2 + ... + k^m`. This sum can be simplified using the formula for the sum of a geometric series.\n3. **Efficient Check**: For each test case, we need to check if there exists a `k > 1` such that `n` can be expressed as the sum of the geometric series mentioned above. We iterate over possible values of `k` and check if `n` fits the required structure.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k values\n    # The maximum k we need to check is roughly cube root of n\n    # Because 1 + k + k^2 <= n => k^2 <= n-1 => k <= sqrt(n-1)\n    # But since we can have more terms, we need to check up to log base 2 of n\n    max_k = int(n ** (1/2)) + 2\n    for k in range(2, max_k + 1):\n        total = 1\n        current = 1\n        while True:\n            next_term = current * k\n            if total + next_term > n:\n                break\n            total += next_term\n            current = next_term\n        if total == n:\n            return True\n    # Also check cases where the sum is 1 + k + ... + k^m for m >=1\n    # Another approach: for each possible m >= 1, check if n - 1 is divisible by k-1, etc.\n    # Let's try another approach for k=2 up to log2(n)\n    # Check for all possible m starting from 1\n    # For each m, check if there exists k such that 1 + k*(k^m -1)/(k-1) = n\n    # However, this might not be efficient, but the previous loop should cover it\n    # Let's also check for m=1, which gives 1 + k = n => k = n-1, which must be >1\n    if n - 1 >= 2:\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if n == 1:\n            print(\"NO\")\n            continue\n        found = False\n        # Check for k=2 up to sqrt(n)\n        max_k = int(n ** 0.5) + 2\n        for k in range(2, max_k + 1):\n            total = 1\n            current = 1\n            while True:\n                next_term = current * k\n                if total + next_term > n:\n                    break\n                total += next_term\n                current = next_term\n            if total == n:\n                found = True\n                break\n        # Also check for m=1: 1 + k = n => k = n-1\n        if not found and (n - 1) >= 2:\n            found = True\n        print(\"YES\" if found else \"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read all at once for efficiency, especially given the constraints.\n2. **Loop Through Possible Values of `k`**: For each value of `k` starting from 2 up to the square root of `n`, we simulate the construction of the snowflake graph and check if the total number of vertices matches `n`.\n3. **Special Case Check**: Additionally, we check if `n` can be formed with just two layers (i.e., `1 + k` where `k = n - 1`).\n\nThis approach ensures that we efficiently check all possible configurations of the snowflake graph within the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k values\n    # The maximum k we need to check is roughly cube root of n\n    # Because 1 + k + k^2 <= n => k^2 <= n-1 => k <= sqrt(n-1)\n    # But since we can have more terms, we need to check up to log base 2 of n\n    max_k = int(n ** (1/2)) + 2\n    for k in range(2, max_k + 1):\n        total = 1\n        current = 1\n        while True:\n            next_term = current * k\n            if total + next_term > n:\n                break\n            total += next_term\n            current = next_term\n        if total == n:\n            return True\n    # Also check cases where the sum is 1 + k + ... + k^m for m >=1\n    # Another approach: for each possible m >= 1, check if n - 1 is divisible by k-1, etc.\n    # Let's try another approach for k=2 up to log2(n)\n    # Check for all possible m starting from 1\n    # For each m, check if there exists k such that 1 + k*(k^m -1)/(k-1) = n\n    # However, this might not be efficient, but the previous loop should cover it\n    # Let's also check for m=1, which gives 1 + k = n => k = n-1, which must be >1\n    if n - 1 >= 2:\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if n == 1:\n            print(\"NO\")\n            continue\n        found = False\n        # Check for k=2 up to sqrt(n)\n        max_k = int(n ** 0.5) + 2\n        for k in range(2, max_k + 1):\n            total = 1\n            current = 1\n            while True:\n                next_term = current * k\n                if total + next_term > n:\n                    break\n                total += next_term\n                current = next_term\n            if total == n:\n                found = True\n                break\n        # Also check for m=1: 1 + k = n => k = n-1\n        if not found and (n - 1) >= 2:\n            found = True\n        print(\"YES\" if found else \"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 561,
        "completion_token_count": 1003,
        "thoughts_token_count": 1023
    }
}