{
    "start": 1758009286.1458476,
    "end": 1758009323.5344229,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through a Competitive Programming Problem**\n\nOkay, so I've got this competitive programming problem and I need to write a Python script to solve it.  The core of the problem is finding two vouchers, `i` and `j`, that don't overlap, have a combined duration of exactly `x`, and minimize their total cost.  If no such pair exists, I need to output -1.  The problem seems straightforward, but the constraints are a little tight, with `n` and `x` both up to 2 * 10^5.  This means an O(n^2) solution is going to be too slow.\n\nLet's break down these conditions: I need two *distinct* vouchers. They can't overlap, so either one ends before the other starts. Their durations have to sum to `x`, and I need to minimize the total cost.  The duration of a voucher `k` is simply `r_k - l_k + 1`.\n\nMy first instinct is to try a brute-force approach, checking every possible pair.  But as I mentioned, that would be O(n^2), which is way too slow for these constraints. So, I need to find a more efficient solution.  I need to find a way to avoid that quadratic time complexity.\n\nI'm thinking, if I fix one voucher, say `i`, then I need to find a voucher `j` that satisfies the conditions.  The key is finding `j` efficiently.  Since `d_j = x - d_i`, once I know `d_i`, I know what `d_j` *should* be.  But I still need to find a `j` that also meets the disjoint condition.\n\nThe large coordinate values and durations being bounded suggests I need to think about sorting or indexing in some way.  My mind is drawn to the disjoint condition - `r_i < l_j` or `r_j < l_i`.  This makes me think about sorting by start and end points of the vouchers.\n\nMaybe if I sort all vouchers by their start point (`l_i`) and then their end point (`r_i`) if the start points are equal. I can process each voucher and efficiently look for compatible vouchers.  If I consider each voucher in sorted order, the disjoint constraint is somewhat simplified.  For a given voucher, I am looking for another voucher with the right duration and start or end position that makes them disjoint.\n",
    "response": "The problem asks us to find two distinct vouchers `i` and `j` such that they do not intersect, the sum of their durations is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet `d_k = r_k - l_k + 1` be the duration of voucher `k`.\nThe conditions are:\n1.  `i != j`\n2.  `r_i < l_j` or `r_j < l_i` (disjoint)\n3.  `d_i + d_j = x`\n4.  Minimize `cost_i + cost_j`\n\nThe constraints are `n, x, l_k, r_k <= 2 * 10^5`. A naive `O(N^2)` approach will be too slow. We need a more efficient solution, likely `O(N log N)` or `O(N)`.\n\nLet's represent each voucher as a tuple `(l, r, cost, duration)`.\nThe maximum coordinate for `l` and `r` is `MAX_COORD = 2 * 10^5`.\nThe maximum duration is also `MAX_COORD`.\n\nWe can iterate through all vouchers and for each voucher `i`, try to find a suitable voucher `j`. The key is to efficiently find `j` that satisfies the duration and disjoint conditions with minimal cost.\n\nConsider processing vouchers in a specific order. Let's sort all vouchers by their `l_k` values. If `l_k` values are equal, sort by `r_k`.\n\nWe can maintain a data structure that stores information about vouchers encountered so far. When we process a voucher `i = (l_i, r_i, cost_i, d_i)`, we are looking for a voucher `j = (l_j, r_j, cost_j, d_j)` such that:\n1.  `d_j = x - d_i`\n2.  `r_j < l_i` (This is one of the disjoint conditions. The other `r_i < l_j` will be handled when `j` is processed later as `i`.)\n\nLet's maintain an array, say `min_cost_end_at[end_day]`, which stores the minimum cost of a voucher that ends on `end_day` and has a specific duration `D`. This would be too many dimensions.\n\nA better approach is to use an array `min_cost_for_duration[duration][end_day]`. This would still be `MAX_COORD * MAX_COORD`, too large.\n\nInstead, let's iterate through all possible `end_day` values from `1` to `MAX_COORD`.\nWe can use a `min_cost_for_duration` array, where `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that `duration` that *has already ended*.\n\nLet `min_cost_ending_at[duration]` be an array that stores the minimum cost of a voucher with a given `duration` that has ended *at or before* the current `end_day` being considered.\nInitialize `min_cost_ending_at` with infinity for all durations.\nThe maximum possible duration is `MAX_COORD`.\n\nWe can group vouchers by their `l_k` values or `r_k` values.\nLet's create two lists of vouchers:\n`vouchers_by_start[l]`: List of `(r, cost, duration)` for vouchers starting on day `l`.\n`vouchers_by_end[r]`: List of `(l, cost, duration)` for vouchers ending on day `r`.\n\nIterate `current_day` from `1` to `MAX_COORD`:\n1.  **Update `min_cost_ending_at` for vouchers that end on `current_day - 1`**:\n    For each voucher `(l, cost, duration)` in `vouchers_by_end[current_day - 1]`:\n    Update `min_cost_ending_at[duration] = min(min_cost_ending_at[duration], cost)`.\n    This step ensures that `min_cost_ending_at[D]` always stores the minimum cost of a voucher of duration `D` that has finished by `current_day - 1`.\n\n2.  **Process vouchers that start on `current_day`**:\n    For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start[current_day]`:\n    We need to find a voucher `j` such that `d_j = x - d_i` and `r_j < l_i` (which is `r_j < current_day`).\n    The minimum cost for such a `j` is already stored in `min_cost_ending_at[x - d_i]`.\n    If `x - d_i > 0` and `x - d_i <= MAX_COORD` (i.e., `d_i < x`), and `min_cost_ending_at[x - d_i]` is not infinity, then we have a potential pair.\n    Update `min_total_cost = min(min_total_cost, cost_i + min_cost_ending_at[x - d_i])`.\n\nInitialize `min_total_cost` to infinity.\n`MAX_COORD` can be up to `2 * 10^5`.\n\nThe `min_cost_ending_at` array needs to be of size `MAX_COORD + 1`.\nThe `vouchers_by_start` and `vouchers_by_end` arrays will be lists of lists, also of size `MAX_COORD + 1`.\n\nAlgorithm:\n1.  Initialize `min_total_cost = float('inf')`.\n2.  Initialize `min_cost_ending_at = [float('inf')] * (MAX_COORD + 1)`.\n3.  Initialize `vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]`.\n4.  Initialize `vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]`.\n5.  Read `n` and `x`.\n6.  For each of the `n` vouchers:\n    Read `l, r, cost`.\n    `duration = r - l + 1`.\n    `vouchers_by_start[l].append((r, cost, duration))`.\n    `vouchers_by_end[r].append((l, cost, duration))`.\n\n7.  Iterate `current_day` from `1` to `MAX_COORD`:\n    a.  **Process vouchers ending on `current_day - 1`**:\n        For each voucher `(l, cost, duration)` in `vouchers_by_end[current_day - 1]`:\n            `min_cost_ending_at[duration] = min(min_cost_ending_at[duration], cost)`.\n    b.  **Process vouchers starting on `current_day`**:\n        For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start[current_day]`:\n            `needed_duration = x - d_i`.\n            If `1 <= needed_duration <= MAX_COORD` and `min_cost_ending_at[needed_duration] != float('inf')`:\n                `min_total_cost = min(min_total_cost, cost_i + min_cost_ending_at[needed_duration])`.\n\n8.  If `min_total_cost == float('inf')`, print -1. Otherwise, print `min_total_cost`.\n\n**Example Walkthrough**:\n`n=4, x=5`\nVouchers: `(1,3,4), (1,2,5), (5,6,1), (1,2,4)`\nDurations: `(3), (2), (2), (2)`\n\n`MAX_COORD = 6` (max `r` is 6).\n`min_cost_ending_at = [inf] * 7`\n`vouchers_by_start = [[], [], ..., []]`\n`vouchers_by_end = [[], [], ..., []]`\n\nPopulate `vouchers_by_start` and `vouchers_by_end`:\n`vouchers_by_start[1] = [(3,4,3), (2,5,2), (2,4,2)]`\n`vouchers_by_start[5] = [(6,1,2)]`\n`vouchers_by_end[2] = [(1,5,2), (1,4,2)]`\n`vouchers_by_end[3] = [(1,4,3)]`\n`vouchers_by_end[6] = [(5,1,2)]`\n\n`min_total_cost = inf`\n\nLoop `current_day` from 1 to 6:\n\n`current_day = 1`:\n  End day 0: no vouchers. `min_cost_ending_at` unchanged.\n  Start day 1:\n    Voucher `(r=3, cost=4, d=3)`: `needed_duration = 5 - 3 = 2`. `min_cost_ending_at[2]` is `inf`. No update.\n    Voucher `(r=2, cost=5, d=2)`: `needed_duration = 5 - 2 = 3`. `min_cost_ending_at[3]` is `inf`. No update.\n    Voucher `(r=2, cost=4, d=2)`: `needed_duration = 5 - 2 = 3`. `min_cost_ending_at[3]` is `inf`. No update.\n\n`current_day = 2`:\n  End day 1: no vouchers. `min_cost_ending_at` unchanged.\n  Start day 2: no vouchers.\n\n`current_day = 3`:\n  End day 2:\n    Voucher `(l=1, cost=5, d=2)`: `min_cost_ending_at[2] = min(inf, 5) = 5`.\n    Voucher `(l=1, cost=4, d=2)`: `min_cost_ending_at[2] = min(5, 4) = 4`.\n    `min_cost_ending_at` is now `[inf, inf, 4, inf, inf, inf, inf]`\n  Start day 3: no vouchers.\n\n`current_day = 4`:\n  End day 3:\n    Voucher `(l=1, cost=4, d=3)`: `min_cost_ending_at[3] = min(inf, 4) = 4`.\n    `min_cost_ending_at` is now `[inf, inf, 4, 4, inf, inf, inf]`\n  Start day 4: no vouchers.\n\n`current_day = 5`:\n  End day 4: no vouchers. `min_cost_ending_at` unchanged.\n  Start day 5:\n    Voucher `(r=6, cost=1, d=2)`: `needed_duration = 5 - 2 = 3`. `min_cost_ending_at[3]` is `4`.\n    `min_total_cost = min(inf, 1 + 4) = 5`.\n\n`current_day = 6`:\n  End day 5: no vouchers. `min_cost_ending_at` unchanged.\n  Start day 6: no vouchers.\n\nFinal `min_total_cost = 5`.\n\n**Complexity Analysis**:\n*   Initialization: `O(MAX_COORD)`.\n*   Reading input and populating `vouchers_by_start` and `vouchers_by_end`: `O(N)`. Each voucher is added to two lists.\n*   Main loop (`current_day` from 1 to `MAX_COORD`):\n    *   Step `7a`: Each voucher is processed once when its `r` value matches `current_day - 1`. Total over all `current_day` is `O(N)`.\n    *   Step `7b`: Each voucher is processed once when its `l` value matches `current_day`. Total over all `current_day` is `O(N)`.\n*   Overall time complexity: `O(N + MAX_COORD)`.\n*   Space complexity: `O(N + MAX_COORD)` for storing vouchers and `min_cost_ending_at`.\n\nGiven `N, X, L, R <= 2 * 10^5`, this approach is efficient enough. `MAX_COORD` is `2 * 10^5`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start[l] stores list of (r, cost, duration) for vouchers starting on day l\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[r] stores list of (l, cost, duration) for vouchers ending on day r\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start[l].append((r, cost, duration))\n        vouchers_by_end[r].append((l, cost, duration))\n\n    # min_cost_ending_at[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended by the current_day - 1.\n    min_cost_ending_at = [float('inf')] * (MAX_COORD + 1)\n    \n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Update min_cost_ending_at for vouchers that ended on current_day - 1\n        # These vouchers are candidates for being the first voucher (j)\n        # for a second voucher (i) that starts on or after current_day.\n        if current_day > 1: # Only process if there's a previous day\n            for _, cost, duration in vouchers_by_end[current_day - 1]:\n                min_cost_ending_at[duration] = min(min_cost_ending_at[duration], cost)\n\n        # Step 2: Process vouchers that start on current_day\n        # These vouchers are candidates for being the second voucher (i)\n        for r_i, cost_i, d_i in vouchers_by_start[current_day]:\n            needed_duration_j = x - d_i\n            \n            # Check if needed_duration_j is valid (positive and within bounds)\n            if 1 <= needed_duration_j <= MAX_COORD:\n                # If we found a voucher j that ended before current_day\n                # with needed_duration_j, calculate total cost\n                if min_cost_ending_at[needed_duration_j] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_ending_at[needed_duration_j])\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start[l] stores list of (r, cost, duration) for vouchers starting on day l\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[r] stores list of (l, cost, duration) for vouchers ending on day r\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start[l].append((r, cost, duration))\n        vouchers_by_end[r].append((l, cost, duration))\n\n    # min_cost_ending_at[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended by the current_day - 1.\n    min_cost_ending_at = [float('inf')] * (MAX_COORD + 1)\n    \n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Update min_cost_ending_at for vouchers that ended on current_day - 1\n        # These vouchers are candidates for being the first voucher (j)\n        # for a second voucher (i) that starts on or after current_day.\n        if current_day > 1: # Only process if there's a previous day\n            for _, cost, duration in vouchers_by_end[current_day - 1]:\n                min_cost_ending_at[duration] = min(min_cost_ending_at[duration], cost)\n\n        # Step 2: Process vouchers that start on current_day\n        # These vouchers are candidates for being the second voucher (i)\n        for r_i, cost_i, d_i in vouchers_by_start[current_day]:\n            needed_duration_j = x - d_i\n            \n            # Check if needed_duration_j is valid (positive and within bounds)\n            if 1 <= needed_duration_j <= MAX_COORD:\n                # If we found a voucher j that ended before current_day\n                # with needed_duration_j, calculate total cost\n                if min_cost_ending_at[needed_duration_j] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_ending_at[needed_duration_j])\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 789,
        "completion_token_count": 3610,
        "thoughts_token_count": 779
    }
}