{
    "start": 1758285171.6545744,
    "end": 1758285211.4256067,
    "start-formatted": "2025-09-19 21:32 KST",
    "end-formatted": "2025-09-19 21:33 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**The TV Game: A DP Solution Strategy**\n\nOkay, I've got the \"TV Game\" problem. Two players, Homer and Marge, taking digits from a big number. The goal is to maximize the sum of their resulting numbers.  My immediate thought is that this number can be huge, up to 36 digits long!  Brute force? Forget it. `2^36` move sequences are way beyond feasible. So, I need a smarter approach.\n\nFirst, I need to understand the constraints. We're dealing with concatenated digits, so large integer arithmetic is involved. The *order* in which the digits are taken matters hugely – the leftmost digits contribute exponentially more.\n\nMy brain's buzzing, and dynamic programming is already surfacing as the key. I need to define a state that captures all the relevant information at any given decision point.  Thinking through it, the crucial bits are: how many digits are *left* in the original number (`A`) and how many moves each player has already made.\n\nI'm settling on this state: `dp[i][h_moves]`. Here's the breakdown:\n\n*   `i` represents the number of digits *already processed*. This implicitly tells me how many digits are left (`2n - i`). It also represents the turn.\n*   `h_moves` is the count of moves Homer has made. Given `i` and `h_moves`, I can deduce how many Marge has made (`i - h_moves`).\n\nThe value `dp[i][h_moves]` will represent the maximum achievable sum `S1 + S2` *from this point onwards*, given that `i` digits have been taken and Homer has used `h_moves` of them. I think this approach neatly captures all the necessary information for making optimal choices at each stage. Next, I need to formulate the transitions and the base cases.\n",
    "response": "The problem asks us to find a sequence of `2n` moves (each by Homer 'H' or Marge 'M') such that Homer makes exactly `n` moves and Marge makes exactly `n` moves, and the sum of the resulting numbers `S1` (for Homer) and `S2` (for Marge) is maximized. The number `A` consists of `2n` digits. In each turn, the leftmost digit of `A` is taken by the current player and appended to their number.\n\nSince `n` can be up to 18, `2n` can be up to 36. A brute force approach of trying all `2^(2n)` sequences is too slow (`2^36` is very large). This suggests a dynamic programming approach.\n\nLet's define a state for our DP. We need to keep track of:\n1. The current digit being considered (or how many digits have already been processed).\n2. The number of moves Homer has made so far.\n3. The number of moves Marge has made so far.\n\nLet `dp[i][h_count]` represent the maximum total sum `(S1 + S2)` that can be achieved *from this state onwards*, given that `i` digits have already been processed from the left of `A`, and Homer has made `h_count` moves. Marge must have made `i - h_count` moves.\n\nThe base case for our DP will be when all `2n` digits have been processed.\n`dp[2n][n]` will be 0, as no more digits can be taken and no more value can be added. All other `dp[2n][h_count]` states will be invalid (or negative infinity) if `h_count != n`, because both players must make exactly `n` moves.\n\nFor a general state `dp[i][h_count]`:\nThe current digit to be considered is `A[i]`.\nWe have two choices:\n\n1.  **Homer takes the digit `A[i]`:**\n    This is possible only if `h_count < n` (Homer hasn't made all his `n` moves yet).\n    If Homer takes `A[i]`, his number `S1` will be updated as `S1 * 10 + A[i]`.\n    The contribution of `A[i]` to `S1` (and thus to `S1 + S2`) depends on its position within Homer's final number. Specifically, if Homer takes `A[i]` as his `(h_count + 1)`-th digit, and he still has `n - (h_count + 1)` digits to take, then `A[i]` will be multiplied by `10^(n - (h_count + 1))` in his final number.\n    So, the value added to the total sum by `A[i]` if Homer takes it is `A[i] * 10^(n - (h_count + 1))`.\n    The total value from this choice would be `A[i] * 10^(n - (h_count + 1)) + dp[i+1][h_count+1]`.\n\n2.  **Marge takes the digit `A[i]`:**\n    This is possible only if `(i - h_count) < n` (Marge hasn't made all her `n` moves yet).\n    Similarly, if Marge takes `A[i]` as her `(i - h_count + 1)`-th digit, and she still has `n - (i - h_count + 1)` digits to take, then `A[i]` will be multiplied by `10^(n - (i - h_count + 1))` in her final number.\n    So, the value added to the total sum by `A[i]` if Marge takes it is `A[i] * 10^(n - (i - h_count + 1))`.\n    The total value from this choice would be `A[i] * 10^(n - (i - h_count + 1)) + dp[i+1][h_count]`.\n\n`dp[i][h_count]` will be the maximum of these two choices (if both are valid), or the value of the only valid choice.\n\nTo reconstruct the path, we can store `parent[i][h_count]` which indicates whether Homer ('H') or Marge ('M') made the optimal move for that state.\n\n**State Space and Transitions:**\n- `i`: from `2n-1` down to `0`. (We can compute `dp` values from `2n` down to `0`).\n- `h_count`: from `n` down to `0`.\n- Number of states: `(2n+1) * (n+1)`. For `n=18`, this is `37 * 19` which is about `700` states.\n- Each state takes `O(1)` time to compute.\n- Total time complexity: `O(n^2)`. This is very efficient for `n=18`.\n\n**Precomputing Powers of 10:**\nWe will need powers of 10. `10^0, 10^1, ..., 10^(n-1)`. We can precompute these to avoid repeated calculations.\n\n**Example Walkthrough (n=2, A=\"1234\"):**\n`2n=4`. Homer needs 2 moves, Marge needs 2 moves.\n`P10 = [1, 10, 100, 1000, ...]`\n\n`dp` table initialized with -1 (or -infinity).\n`dp[4][2] = 0` (base case: 4 digits processed, Homer made 2 moves, Marge made 2 moves).\n\n**i = 3 (digit '4')**\n- `dp[3][1]`: Homer made 1 move, Marge made 2 moves. Remaining digits: 1. Homer needs 1 more move, Marge needs 0 more.\n    - Homer takes '4': `h_count=1 < n=2`. Valid.\n        Value: `4 * P10[n - (h_count + 1)] = 4 * P10[2 - (1 + 1)] = 4 * P10[0] = 4 * 1 = 4`.\n        Next state: `dp[4][2] = 0`. Total: `4 + 0 = 4`.\n        `dp[3][1] = 4`, `parent[3][1] = 'H'`.\n- `dp[3][2]`: Homer made 2 moves, Marge made 1 move. Remaining digits: 1. Homer needs 0 more moves, Marge needs 1 more.\n    - Marge takes '4': `(i - h_count)=1 < n=2`. Valid.\n        Value: `4 * P10[n - ((i - h_count) + 1)] = 4 * P10[2 - (1 + 1)] = 4 * P10[0] = 4 * 1 = 4`.\n        Next state: `dp[4][2] = 0`. Total: `4 + 0 = 4`.\n        `dp[3][2] = 4`, `parent[3][2] = 'M'`.\n\n**i = 2 (digit '3')**\n- `dp[2][0]`: H:0, M:2.\n    - Homer takes '3': `h_count=0 < n=2`. Valid.\n        Value: `3 * P10[n - (h_count + 1)] = 3 * P10[2 - (0 + 1)] = 3 * P10[1] = 3 * 10 = 30`.\n        Next state: `dp[3][1] = 4`. Total: `30 + 4 = 34`.\n        `dp[2][0] = 34`, `parent[2][0] = 'H'`.\n- `dp[2][1]`: H:1, M:1.\n    - Homer takes '3': `h_count=1 < n=2`. Valid.\n        Value: `3 * P10[n - (h_count + 1)] = 3 * P10[2 - (1 + 1)] = 3 * P10[0] = 3 * 1 = 3`.\n        Next state: `dp[3][2] = 4`. Total: `3 + 4 = 7`.\n    - Marge takes '3': `(i - h_count)=1 < n=2`. Valid.\n        Value: `3 * P10[n - ((i - h_count) + 1)] = 3 * P10[2 - (1 + 1)] = 3 * P10[0] = 3 * 1 = 3`.\n        Next state: `dp[3][1] = 4`. Total: `3 + 4 = 7`.\n        `dp[2][1] = 7`, `parent[2][1]` can be 'H' or 'M'. Let's say 'H'.\n- `dp[2][2]`: H:2, M:0.\n    - Marge takes '3': `(i - h_count)=0 < n=2`. Valid.\n        Value: `3 * P10[n - ((i - h_count) + 1)] = 3 * P10[2 - (0 + 1)] = 3 * P10[1] = 3 * 10 = 30`.\n        Next state: `dp[3][2] = 4`. Total: `30 + 4 = 34`.\n        `dp[2][2] = 34`, `parent[2][2] = 'M'`.\n\n**i = 1 (digit '2')**\n- `dp[1][0]`: H:0, M:1.\n    - Homer takes '2': `h_count=0 < n=2`. Valid.\n        Value: `2 * P10[n - (h_count + 1)] = 2 * P10[2 - (0 + 1)] = 2 * P10[1] = 2 * 10 = 20`.\n        Next state: `dp[2][1] = 7`. Total: `20 + 7 = 27`.\n    - Marge takes '2': `(i - h_count)=1 < n=2`. Valid.\n        Value: `2 * P10[n - ((i - h_count) + 1)] = 2 * P10[2 - (1 + 1)] = 2 * P10[0] = 2 * 1 = 2`.\n        Next state: `dp[2][0] = 34`. Total: `2 + 34 = 36`.\n        `dp[1][0] = 36`, `parent[1][0] = 'M'`.\n- `dp[1][1]`: H:1, M:0.\n    - Homer takes '2': `h_count=1 < n=2`. Valid.\n        Value: `2 * P10[n - (h_count + 1)] = 2 * P10[2 - (1 + 1)] = 2 * P10[0] = 2 * 1 = 2`.\n        Next state: `dp[2][2] = 34`. Total: `2 + 34 = 36`.\n    - Marge takes '2': `(i - h_count)=0 < n=2`. Valid.\n        Value: `2 * P10[n - ((i - h_count) + 1)] = 2 * P10[2 - (0 + 1)] = 2 * P10[1] = 2 * 10 = 20`.\n        Next state: `dp[2][1] = 7`. Total: `20 + 7 = 27`.\n        `dp[1][1] = 36`, `parent[1][1] = 'H'`.\n\n**i = 0 (digit '1')**\n- `dp[0][0]`: H:0, M:0.\n    - Homer takes '1': `h_count=0 < n=2`. Valid.\n        Value: `1 * P10[n - (h_count + 1)] = 1 * P10[2 - (0 + 1)] = 1 * P10[1] = 1 * 10 = 10`.\n        Next state: `dp[1][1] = 36`. Total: `10 + 36 = 46`.\n    - Marge takes '1': `(i - h_count)=0 < n=2`. Valid.\n        Value: `1 * P10[n - ((i - h_count) + 1)] = 1 * P10[2 - (0 + 1)] = 1 * P10[1] = 1 * 10 = 10`.\n        Next state: `dp[1][0] = 36`. Total: `10 + 36 = 46`.\n        `dp[0][0] = 46`, `parent[0][0]` can be 'H' or 'M'. Let's say 'H'.\n\n**Reconstructing the path:**\nStart from `(0, 0)`.\n`curr_i = 0`, `curr_h = 0`\n1. `parent[0][0] = 'H'`. Output 'H'. `curr_i = 1`, `curr_h = 1`.\n2. `parent[1][1] = 'H'`. Output 'H'. `curr_i = 2`, `curr_h = 2`.\n3. `parent[2][2] = 'M'`. Output 'M'. `curr_i = 3`, `curr_h = 2`.\n4. `parent[3][2] = 'M'`. Output 'M'. `curr_i = 4`, `curr_h = 2`.\nSequence: `HHMM`. This matches the example output.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n    a_digits = [int(d) for d in a_str]\n\n    # Precompute powers of 10\n    # p10[k] = 10^k\n    # A digit taken as the (k+1)-th digit for a player, when total n digits are taken by that player,\n    # will be multiplied by 10^(n - (k+1)).\n    # So, if a player has already taken `h_count` digits and takes the current digit,\n    # it is their (h_count + 1)-th digit. Its multiplier will be 10^(n - (h_count + 1)).\n    # The maximum exponent needed is n-1 (when h_count=0, it's the 1st digit).\n    p10 = [1] * n\n    for i in range(1, n):\n        p10[i] = p10[i-1] * 10\n\n    # dp[i][h_count] stores the maximum total sum S1 + S2\n    # achievable from state (i, h_count) onwards.\n    # i: number of digits already processed from A (from 0 to 2*n)\n    # h_count: number of moves Homer has made so far (from 0 to n)\n    \n    # Initialize dp table with a very small number (negative infinity)\n    # and parent table to reconstruct the path.\n    # dp table size: (2*n + 1) x (n + 1)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(2 * n + 1)]\n    parent = [['' for _ in range(n + 1)] for _ in range(2 * n + 1)]\n\n    # Base case: After all 2*n digits are processed, and both players made n moves,\n    # the additional sum is 0.\n    dp[2 * n][n] = 0\n\n    # Iterate backwards from the last digit to the first\n    for i in range(2 * n - 1, -1, -1):\n        for h_count in range(n, -1, -1):\n            m_count = i - h_count # Marge's moves count\n\n            # Check if this state is valid (m_count must be within [0, n])\n            if m_count < 0 or m_count > n:\n                continue\n\n            current_digit = a_digits[i]\n            \n            max_val = -1\n            best_choice = ''\n\n            # Option 1: Homer takes the digit\n            if h_count < n: # Homer can still make a move\n                # Calculate the value this digit adds to Homer's number\n                # It's Homer's (h_count + 1)-th digit.\n                # It will be multiplied by 10^(n - (h_count + 1))\n                homer_digit_value = current_digit * p10[n - (h_count + 1)]\n                \n                # Check if the next state is reachable (dp value is not -1)\n                if dp[i + 1][h_count + 1] != -1:\n                    val_if_homer_takes = homer_digit_value + dp[i + 1][h_count + 1]\n                    if val_if_homer_takes > max_val:\n                        max_val = val_if_homer_takes\n                        best_choice = 'H'\n\n            # Option 2: Marge takes the digit\n            if m_count < n: # Marge can still make a move\n                # Calculate the value this digit adds to Marge's number\n                # It's Marge's (m_count + 1)-th digit.\n                # It will be multiplied by 10^(n - (m_count + 1))\n                marge_digit_value = current_digit * p10[n - (m_count + 1)]\n\n                # Check if the next state is reachable\n                if dp[i + 1][h_count] != -1:\n                    val_if_marge_takes = marge_digit_value + dp[i + 1][h_count]\n                    if val_if_marge_takes > max_val:\n                        max_val = val_if_marge_takes\n                        best_choice = 'M'\n            \n            dp[i][h_count] = max_val\n            parent[i][h_count] = best_choice\n\n    # Reconstruct the path\n    result_path = []\n    curr_i = 0\n    curr_h_count = 0\n\n    for _ in range(2 * n):\n        choice = parent[curr_i][curr_h_count]\n        result_path.append(choice)\n        if choice == 'H':\n            curr_h_count += 1\n        curr_i += 1\n    \n    sys.stdout.write(\"\".join(result_path) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n    a_digits = [int(d) for d in a_str]\n\n    # Precompute powers of 10\n    # p10[k] = 10^k\n    # A digit taken as the (k+1)-th digit for a player, when total n digits are taken by that player,\n    # will be multiplied by 10^(n - (k+1)).\n    # So, if a player has already taken `h_count` digits and takes the current digit,\n    # it is their (h_count + 1)-th digit. Its multiplier will be 10^(n - (h_count + 1)).\n    # The maximum exponent needed is n-1 (when h_count=0, it's the 1st digit).\n    p10 = [1] * n\n    for i in range(1, n):\n        p10[i] = p10[i-1] * 10\n\n    # dp[i][h_count] stores the maximum total sum S1 + S2\n    # achievable from state (i, h_count) onwards.\n    # i: number of digits already processed from A (from 0 to 2*n)\n    # h_count: number of moves Homer has made so far (from 0 to n)\n    \n    # Initialize dp table with a very small number (negative infinity)\n    # and parent table to reconstruct the path.\n    # dp table size: (2*n + 1) x (n + 1)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(2 * n + 1)]\n    parent = [['' for _ in range(n + 1)] for _ in range(2 * n + 1)]\n\n    # Base case: After all 2*n digits are processed, and both players made n moves,\n    # the additional sum is 0.\n    dp[2 * n][n] = 0\n\n    # Iterate backwards from the last digit to the first\n    for i in range(2 * n - 1, -1, -1):\n        for h_count in range(n, -1, -1):\n            m_count = i - h_count # Marge's moves count\n\n            # Check if this state is valid (m_count must be within [0, n])\n            if m_count < 0 or m_count > n:\n                continue\n\n            current_digit = a_digits[i]\n            \n            max_val = -1\n            best_choice = ''\n\n            # Option 1: Homer takes the digit\n            if h_count < n: # Homer can still make a move\n                # Calculate the value this digit adds to Homer's number\n                # It's Homer's (h_count + 1)-th digit.\n                # It will be multiplied by 10^(n - (h_count + 1))\n                homer_digit_value = current_digit * p10[n - (h_count + 1)]\n                \n                # Check if the next state is reachable (dp value is not -1)\n                if dp[i + 1][h_count + 1] != -1:\n                    val_if_homer_takes = homer_digit_value + dp[i + 1][h_count + 1]\n                    if val_if_homer_takes > max_val:\n                        max_val = val_if_homer_takes\n                        best_choice = 'H'\n\n            # Option 2: Marge takes the digit\n            if m_count < n: # Marge can still make a move\n                # Calculate the value this digit adds to Marge's number\n                # It's Marge's (m_count + 1)-th digit.\n                # It will be multiplied by 10^(n - (m_count + 1))\n                marge_digit_value = current_digit * p10[n - (m_count + 1)]\n\n                # Check if the next state is reachable\n                if dp[i + 1][h_count] != -1:\n                    val_if_marge_takes = marge_digit_value + dp[i + 1][h_count]\n                    if val_if_marge_takes > max_val:\n                        max_val = val_if_marge_takes\n                        best_choice = 'M'\n            \n            dp[i][h_count] = max_val\n            parent[i][h_count] = best_choice\n\n    # Reconstruct the path\n    result_path = []\n    curr_i = 0\n    curr_h_count = 0\n\n    for _ in range(2 * n):\n        choice = parent[curr_i][curr_h_count]\n        result_path.append(choice)\n        if choice == 'H':\n            curr_h_count += 1\n        curr_i += 1\n    \n    sys.stdout.write(\"\".join(result_path) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 4507,
        "thoughts_token_count": 776
    }
}