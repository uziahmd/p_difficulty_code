{
    "start": 1758009365.952938,
    "end": 1758009530.3207908,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Flawed Flow - Problem Dissection and Strategy**\n\nOkay, so I've got this \"Flawed Flow\" problem, and I need to write a Python script to solve it.  Let's break down what's happening. We're given an undirected graph with capacities on the edges, and the goal is to direct these edges to create a *valid* maximum flow.  Crucially, the resulting graph must be a Directed Acyclic Graph (DAG).\n\nFirst, I need to understand the constraints. We have a reasonable number of vertices and edges (2 * 10^5 each), and the capacities are relatively small (10^4). The graph is connected, and a solution is guaranteed to exist. This is key: I don't need to worry about edge cases where there's no possible flow. The fact it's a *maximum* flow is actually not something I need to solve, it's just a condition. I'm focusing on finding *a* valid direction that works.\n\nNow for the properties of a valid flow. Flow conservation at intermediate vertices (not the source or sink) is standard: the incoming flow must equal the outgoing flow. The source has no incoming flow, and the sink can only *receive* flow.  I don't even have to worry about calculating the max flow here.\n\nThe \"no cycles\" condition is the biggest challenge and opportunity.  If there are no cycles, I can topologically sort the graph. This implies I can assign a \"direction\" to the flow in a consistent manner.  The problem suggests the edges must be directed so I can get a topological order.  In a DAG, the flow goes in one direction.\n\nThe even flow idea is really interesting. If I sum up the capacities of all edges attached to an intermediate node, that sum *must* be even because the incoming flow is always equal to the outgoing flow. This offers a clue.  It implies I can't just pick directions at random; the total capacity around an intermediate node determines something about the way the edges are oriented, which has an effect on whether the edge will have `0` or `1` for the `d_i` values.  My strategy will almost certainly need to leverage this parity property to construct a valid flow direction that creates a DAG.  I'm betting I can build this up in some ordered manner, perhaps starting from the source or sink. I need to be careful with the source and sink nodes because they have special conditions. They're boundary conditions in the flow.\n",
    "response": "The problem asks us to direct edges of an undirected graph, given their flow volumes, such that standard flow conditions (conservation at intermediate nodes, no incoming flow at source) are met, and the resulting directed graph is acyclic. We need to output the direction for each edge.\n\nLet's analyze the conditions:\n1.  **Flow Conservation (for 1 < v < n):** Sum of incoming flow equals sum of outgoing flow.\n2.  **Source (v = 1):** No incoming edges. All flow from vertex 1 must be outgoing.\n3.  **Sink (v = n):** The problem doesn't explicitly state conditions for the sink, but in a typical max-flow setup, all flow eventually reaches the sink.\n4.  **No Cycles:** The resulting directed graph must be a Directed Acyclic Graph (DAG). This is a strong condition.\n\nConsider any intermediate vertex `v` (1 < `v` < `n`). Let `S_in(v)` be the sum of flow volumes on edges directed into `v`, and `S_out(v)` be the sum of flow volumes on edges directed out of `v`. The conservation condition states `S_in(v) = S_out(v)`.\nThe total flow associated with vertex `v` (sum of `c_i` for all edges connected to `v`) is `TotalFlow(v) = S_in(v) + S_out(v)`.\nFrom `S_in(v) = S_out(v)`, we get `TotalFlow(v) = 2 * S_in(v)`. This implies that `TotalFlow(v)` must be an even number for all `1 < v < n`. If `TotalFlow(v)` is odd, it's impossible to satisfy `S_in(v) = S_out(v)` with integer flow values.\nThe problem statement guarantees a solution exists, so `TotalFlow(v)` must indeed be even for `1 < v < n`.\n\nThe \"no cycles\" condition suggests a topological ordering. If we can assign a \"level\" or \"rank\" to each vertex such that flow always goes from a lower level to a higher level, then no cycles will be formed. This is characteristic of a topological sort.\n\nLet's try to build the flow direction greedily. The source (vertex 1) has no incoming edges. This means all edges connected to vertex 1 must be directed away from it. After directing these edges, the flow conservation property might be violated for their neighbors. For example, if `1 -> u` has flow `c`, then `u` has `c` units of incoming flow. `u` needs to output `c` units of flow (if it's an intermediate node).\n\nThis problem can be modeled as finding a topological sort or a specific type of traversal. A common technique for problems involving degrees (or sums of flows) and ensuring properties like DAGs is to use a queue-based approach, similar to Kahn's algorithm for topological sort, or a DFS-based approach.\n\nLet's consider the total flow `TotalFlow(v)` for each vertex `v`.\nFor `1 < v < n`, we need `S_in(v) = S_out(v) = TotalFlow(v) / 2`.\nFor `v = 1`, we need `S_in(1) = 0`. All flow from `1` must be `S_out(1)`.\nFor `v = n`, we expect `S_out(n) = 0` (or at least, we don't need to push flow out of `n` to satisfy conservation for `n`).\n\nLet's keep track of the current `S_in(v)` and `S_out(v)` for each vertex `v`. Initially, all are 0.\nWe want to direct edges such that for `1 < v < n`, `S_in(v)` eventually reaches `TotalFlow(v) / 2`.\nThe source `1` has no incoming edges. This is a strong starting point. All edges connected to `1` must be outgoing.\nWhat about the sink `n`? If we direct edges towards `n`, they contribute to `S_in(n)`. If we direct edges away from `n`, they contribute to `S_out(n)`. Since `n` is the sink, it's natural to assume flow goes *into* `n`.\n\nLet's use a queue to process vertices whose flow conservation can be determined.\nWe need to decide for each edge `(u, v)` with flow `c` whether it's `u -> v` or `v -> u`.\nFor each vertex `v`, let `current_out_flow[v]` be the sum of flow volumes of edges already directed *out* of `v`.\nInitially, `current_out_flow[v] = 0` for all `v`.\nWe can put vertex `1` into a queue.\nWhen we process a vertex `u` from the queue:\nFor each undirected edge `(u, v)` with flow `c` that has not yet been directed:\n  *   If `u` is the source (vertex 1), we must direct `u -> v`. This contributes `c` to `current_out_flow[u]` and `c` to `current_in_flow[v]`.\n  *   If `u` is an intermediate vertex (1 < `u` < `n`), and we have already determined `S_in(u) = TotalFlow(u) / 2`, it means all remaining undirected edges connected to `u` must be directed *out* of `u`. This is because `S_in(u)` is fixed, and `S_out(u)` must equal `S_in(u)`. So, `current_out_flow[u]` must be incremented by `c` for `u -> v`.\n  *   What if `u` is `n` (the sink)? If we direct `u -> v`, it means flow leaves the sink, which is usually not the case. It's more natural for flow to enter the sink.\n\nThe \"no cycles\" condition is key. This strongly implies that flow should generally move away from the source and towards the sink. A depth-first search (DFS) can be used to achieve this.\n\nLet's try a DFS approach. We want to direct edges such that we never go back to an already visited vertex (in the directed sense).\nWe can use a DFS starting from the source `1`.\nWhen we traverse an edge `(u, v)` from `u` to `v` during DFS:\n1.  If `v` is not yet visited, we can tentatively direct `u -> v`. Mark `v` as visited and recurse.\n2.  If `v` is already visited, we cannot direct `u -> v` if `v` is an ancestor of `u` in the DFS tree (this would form a cycle). If `v` is a fully processed vertex (finished DFS), then `u -> v` is fine.\n\nThis standard DFS approach helps build a spanning tree and detect cycles, but it doesn't directly handle the flow conservation and the \"no incoming to source\" constraint, nor does it guarantee `TotalFlow(v)/2` for intermediate nodes.\n\nA better DFS approach would be to use the `TotalFlow(v)` property.\nFor each vertex `v`, calculate `TotalFlow(v) = sum of c_i` for all edges incident to `v`.\nFor `1 < v < n`, we know `S_in(v) = S_out(v) = TotalFlow(v) / 2`.\nLet `current_sum_out[v]` be the sum of flows on edges already directed *out* of `v`.\nLet `current_sum_in[v]` be the sum of flows on edges already directed *into* `v`.\nInitially, all `current_sum_out[v]` and `current_sum_in[v]` are 0.\n\nWe can run a DFS from vertex `1`.\n`dfs(u, parent_edge_idx)`:\n  *   Mark `u` as visited.\n  *   For each edge `(u, v)` with flow `c` and original index `idx`:\n      *   If `v` is not `parent_edge_idx` (to avoid immediately going back up the DFS tree):\n          *   If `v` is not visited:\n              *   Call `dfs(v, idx)`.\n              *   After `dfs(v, idx)` returns, we need to decide the direction of `(u, v)`.\n              *   At this point, `v` and its subtree have been processed. We know how much flow `v` needs to output to satisfy its conservation.\n              *   If `v` is `n` (sink): we want flow to go into `n`. So, direct `u -> n`.\n              *   If `v` is an intermediate node (1 < `v` < `n`):\n                  *   We know `v` needs to output `TotalFlow(v) / 2`.\n                  *   If `current_sum_out[v]` (flow leaving `v` to its children in DFS tree) is less than `TotalFlow(v) / 2`, then `v` still needs to output more flow. This means the edge `(v, u)` should be directed `v -> u`. This makes `current_sum_out[v]` closer to `TotalFlow(v) / 2`.\n                  *   If `current_sum_out[v]` is already `TotalFlow(v) / 2`, then `v` cannot output any more flow. So, the edge `(u, v)` must be directed `u -> v`.\n              *   If `v` is `1` (source): This case shouldn't happen if we start DFS from `1` and don't go back to `1` unless it's the `parent_edge_idx`.\n          *   If `v` is visited (and not `parent_edge_idx`): This means `v` is an ancestor or a cross-edge.\n              *   If `v` is an ancestor, we must direct `u -> v` to avoid a cycle.\n              *   If `v` is a cross-edge, we can direct `u -> v` or `v -> u`.\n\nThis DFS approach is tricky because of the flow conservation and the \"no cycles\" rule. A simpler approach that guarantees a DAG is to use a topological sort. However, a topological sort requires knowing the directions first.\n\nLet's re-examine the property `TotalFlow(v) / 2` for intermediate nodes.\nThis means for each `v` (1 < `v` < `n`), `S_in(v)` must be `TotalFlow(v) / 2`.\nConsider a DFS from `1`. When we return from `dfs(v, u)` (meaning `v` and its subtree are processed), we know the sum of flows `v` has sent *down* its DFS tree (`current_sum_out[v]`).\nIf `v` is an intermediate node (1 < `v` < `n`):\n  *   `v` must output `TotalFlow(v) / 2` in total.\n  *   The flow `v` has sent down is `current_sum_out[v]`.\n  *   The flow `v` has received from its children is `current_sum_in[v]`.\n  *   When `dfs(v, u)` returns, we are deciding the direction of edge `(u, v)`.\n  *   The total flow that needs to be output by `v` is `TotalFlow(v) / 2`.\n  *   The sum of flows already directed *out* of `v` (to its children in the DFS tree) is `current_sum_out[v]`.\n  *   If `current_sum_out[v] < TotalFlow(v) / 2`, then `v` still needs to output `TotalFlow(v) / 2 - current_sum_out[v]` more flow. This remaining flow must go through the edge `(v, u)` (the edge connecting `v` to its parent `u` in the DFS tree). So, we direct `v -> u`. We add `c` to `current_sum_out[v]`.\n  *   If `current_sum_out[v] == TotalFlow(v) / 2`, then `v` has already output enough flow. Any remaining flow must come *into* `v` from its parent. So, we direct `u -> v`. We add `c` to `current_sum_in[v]`.\n\nThis logic works for intermediate nodes `v`. What about `u`?\nWhen we direct `v -> u`, it means `u` receives `c` flow.\nWhen we direct `u -> v`, it means `u` outputs `c` flow.\nThis DFS strategy ensures that for any intermediate node `v`, `current_sum_out[v]` will eventually become `TotalFlow(v) / 2` (or `current_sum_in[v]` will become `TotalFlow(v) / 2`).\n\nLet's refine the DFS state:\n`adj`: adjacency list, storing `(neighbor, flow_volume, original_edge_index)`.\n`ans`: array to store directions (0 for `a_i -> b_i`, 1 for `b_i -> a_i`).\n`visited`: boolean array to track visited nodes during DFS.\n`current_flow`: array to store the \"balance\" of flow for each node. `current_flow[v]` will store the net flow *out* of `v` that has been decided so far. When `dfs(v, ...)` returns, `current_flow[v]` will represent the sum of flows that `v` has sent to its children in the DFS tree minus the sum of flows `v` has received from its children.\n\n`dfs(u, p_idx)`: (`u` is current node, `p_idx` is index of edge connecting `u` to its parent in DFS tree)\n  *   `visited[u] = True`\n  *   `balance_at_u = 0` (sum of flows directed out of `u` to children - sum of flows directed into `u` from children)\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `idx == p_idx`, continue (don't go back to parent immediately).\n      *   If `visited[v]` is False:\n          *   `balance_at_v = dfs(v, idx)`\n          *   Now we decide direction for edge `(u, v)`:\n              *   If `u == 1`: The source must only output. So `u -> v`. `ans[idx] = 0`. `balance_at_u += c`.\n              *   If `u == n`: The sink must only input (for max flow). So `v -> u`. `ans[idx] = 1`. `balance_at_u -= c`.\n              *   If `1 < u < n`:\n                  *   If `balance_at_v` is positive, it means `v` has an excess of `balance_at_v` flow it wants to send *out* (to its parent `u`). So, `v -> u`. `ans[idx] = 1`. `balance_at_u -= c`.\n                  *   If `balance_at_v` is zero or negative, it means `v` needs to *receive* flow from its parent `u`. So, `u -> v`. `ans[idx] = 0`. `balance_at_u += c`.\n                  *   This logic is wrong. `balance_at_v` should be the amount of flow `v` *needs to send to its parent* to satisfy its own conservation.\n                  *   Let's use `current_excess_out[v]` which is `TotalFlow(v)/2 - current_out_flow_to_children[v]`. This is the flow `v` *must* send to its parent or receive from its parent.\n\nLet's use a simpler `dfs(u, parent)` function that returns the *net flow* `u` needs to pass to its parent `parent` to satisfy its own conservation.\n`dfs(u, parent)`:\n  *   `visited[u] = True`\n  *   `flow_to_parent = 0` (This will be the net flow that `u` needs to pass to `parent` to satisfy its own conservation and its children's conservation requirements)\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `v == parent`, continue.\n      *   If `visited[v]` is False:\n          *   `flow_from_child_to_u = dfs(v, u)`\n          *   If `flow_from_child_to_u > 0`: This means `v` needs to send `flow_from_child_to_u` to `u`. So, `v -> u`. `ans[idx] = 1`. `flow_to_parent += c`. (Here, `flow_from_child_to_u` is actually `c` if `v` sends to `u`).\n          *   This is still confusing. Let's use the `TotalFlow(v)/2` directly.\n\nRevised DFS strategy:\n`total_required_out[v]`: For `1 < v < n`, this is `TotalFlow(v) / 2`. For `v = 1`, it's `TotalFlow(1)`. For `v = n`, it's 0.\n`current_out_flow[v]`: Sum of flows on edges already directed *out* of `v`.\n`ans`: array to store directions.\n`visited`: boolean array.\n\n`dfs(u)`:\n  *   `visited[u] = True`\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `v` is not visited:\n          *   `dfs(v)`\n          *   After `dfs(v)` returns, we decide the direction of `(u, v)`.\n          *   We need to ensure `current_out_flow[u]` and `current_out_flow[v]` are correctly updated.\n          *   If `u == 1`: Direct `u -> v`. `ans[idx] = 0`. `current_out_flow[u] += c`.\n          *   If `u == n`: Direct `v -> u`. `ans[idx] = 1`. `current_out_flow[u]` is not relevant for sink, but for `v` it is `current_out_flow[v] += c`.\n          *   If `1 < u < n`:\n              *   If `current_out_flow[v] < total_required_out[v]`: `v` still needs to output more flow. This means `v` should output `c` to `u`. So `v -> u`. `ans[idx] = 1`. `current_out_flow[v] += c`.\n              *   Else (`current_out_flow[v] == total_required_out[v]`): `v` has output enough. So `u` must output `c` to `v`. `u -> v`. `ans[idx] = 0`. `current_out_flow[u] += c`.\n      *   If `v` is visited (this is a back-edge or cross-edge):\n          *   If `u == 1`: Direct `u -> v`. `ans[idx] = 0`. `current_out_flow[u] += c`.\n          *   If `u == n`: Direct `v -> u`. `ans[idx] = 1`.\n          *   If `1 < u < n`:\n              *   If `current_out_flow[u] < total_required_out[u]`: `u` needs to output more flow. So `u -> v`. `ans[idx] = 0`. `current_out_flow[u] += c`.\n              *   Else (`current_out_flow[u] == total_required_out[u]`): `u` has output enough. So `v` must output `c` to `u`. `v -> u`. `ans[idx] = 1`.\n\nThis DFS needs to be structured carefully. A standard way to manage this in DFS is to process edges *after* the recursive call returns for children.\n\nLet's use a `current_balance[v]` for each vertex `v`. This will track `S_out(v) - S_in(v)`.\nFor `1 < v < n`, we need `current_balance[v]` to be 0 at the end.\nFor `v = 1`, `current_balance[1]` should be `TotalFlow(1)`.\nFor `v = n`, `current_balance[n]` should be `-TotalFlow(n)`. (All flow into `n`).\n\n`dfs(u, p_edge_idx)`:\n  *   `visited[u] = True`\n  *   `balance_u = 0` (this will be the net flow *u* sends *up* to its parent)\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `idx == p_edge_idx`, continue.\n      *   If `visited[v]` is False:\n          *   `balance_v = dfs(v, idx)` (this is the net flow `v` sends *up* to `u`)\n          *   If `balance_v > 0`: `v` needs to send `balance_v` flow. So `v -> u`. `ans[idx] = 1`. `balance_u += c`.\n          *   Else (`balance_v <= 0`): `v` needs to receive `abs(balance_v)` flow. So `u -> v`. `ans[idx] = 0`. `balance_u -= c`.\n      *   Else (`v` is visited, and it's not the parent): This is a cross-edge or back-edge.\n          *   To avoid cycles and satisfy source/sink conditions, we usually direct away from source and towards sink.\n          *   If `u == 1`: `u -> v`. `ans[idx] = 0`. `balance_u -= c`.\n          *   If `v == n`: `u -> v`. `ans[idx] = 0`. `balance_u -= c`.\n          *   Otherwise, we need a consistent rule. A simple rule that works for DAGs is to direct from lower-indexed vertex to higher-indexed vertex, but that doesn't account for flow.\n\nThe problem states \"no cycles\". This is the strongest hint. The standard way to ensure no cycles in a flow network is to direct edges such that they always go from a node with a smaller topological order to a node with a larger topological order.\n\nConsider the total flow `TotalFlow(v)` for each vertex `v`.\nFor `1 < v < n`, we need `S_in(v) = S_out(v) = TotalFlow(v) / 2`.\nLet `current_sum_in[v]` be the current sum of incoming flow to `v`.\nLet `current_sum_out[v]` be the current sum of outgoing flow from `v`.\n\nWe can use a DFS to build a spanning tree. All edges in the spanning tree will be directed. Back-edges (edges not in the spanning tree that connect a node to an ancestor) must be directed from child to ancestor to avoid cycles. Cross-edges (edges not in the spanning tree that connect two nodes not in an ancestor-descendant relationship) can be directed according to some rule.\n\nA simpler approach:\nThe problem guarantees a solution exists and implies a max flow. Max flow can be decomposed into paths from source to sink. This implies a DAG.\nLet `needed_out_flow[v]` be the amount of flow that *must* leave `v` (for `1 < v < n`, this is `TotalFlow(v) / 2`).\nFor `v = 1`, all flow must leave `1`.\nFor `v = n`, no flow needs to leave `n` (it's the sink).\n\nLet's use a DFS that returns how much flow *u* needs to push *up* to its parent to satisfy its own `needed_out_flow` requirement.\n`dfs(u, parent_edge_idx)`:\n  *   `visited[u] = True`\n  *   `flow_pushed_out_from_children = 0` (sum of flow `v -> u` for children `v`)\n  *   `flow_pulled_in_from_children = 0` (sum of flow `u -> v` for children `v`)\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `idx == parent_edge_idx`, continue.\n      *   If `visited[v]` is False:\n          *   `flow_v_needs_to_push_up = dfs(v, idx)`\n          *   If `flow_v_needs_to_push_up > 0`: `v` needs to push `flow_v_needs_to_push_up` flow. This means `v -> u`. `ans[idx] = 1`. `flow_pushed_out_from_children += c`.\n          *   Else (`flow_v_needs_to_push_up <= 0`): `v` needs to pull `abs(flow_v_needs_to_push_up)` flow. This means `u -> v`. `ans[idx] = 0`. `flow_pulled_in_from_children += c`.\n      *   Else (`v` is visited and `v` is not `u`'s parent, i.e., a back-edge or cross-edge):\n          *   We must direct `u -> v` to avoid cycles. `ans[idx] = 0`. `flow_pulled_in_from_children += c`.\n  *   Now, `u` has processed all its children in the DFS tree.\n  *   If `u == 1`: All edges must be directed away from `1`. `flow_pulled_in_from_children` should be 0. `flow_pushed_out_from_children` is the total flow from children.\n      *   The total flow output from `1` is `TotalFlow(1)`. This `dfs` function will return `TotalFlow(1)`.\n  *   If `u == n`: All edges must be directed towards `n`. `flow_pushed_out_from_children` should be 0. `flow_pulled_in_from_children` is the total flow into `n`.\n      *   The total flow into `n` is `TotalFlow(n)`. This `dfs` function will return `-TotalFlow(n)`.\n  *   If `1 < u < n`:\n      *   `sum_incoming_from_children = flow_pushed_out_from_children`\n      *   `sum_outgoing_to_children = flow_pulled_in_from_children`\n      *   `net_out_to_children = sum_outgoing_to_children - sum_incoming_from_children`\n      *   `u` needs to output `TotalFlow(u) / 2` in total.\n      *   If `net_out_to_children < TotalFlow(u) / 2`: `u` still needs to output more flow. This remaining flow must go to its parent. Amount is `TotalFlow(u) / 2 - net_out_to_children`. This is the flow `u` pushes *up* to its parent. Return this value.\n      *   Else (`net_out_to_children >= TotalFlow(u) / 2`): `u` has output enough flow or even too much. The excess must be compensated by incoming flow from its parent. Amount is `TotalFlow(u) / 2 - net_out_to_children`. This is a negative value, meaning `u` needs to pull flow from its parent. Return this value.\n\nThis logic seems sound for intermediate nodes and children.\nThe base cases for the DFS are `1` and `n`.\nFor `u = 1`, `flow_v_needs_to_push_up` should be `TotalFlow(1)`.\nFor `u = n`, `flow_v_needs_to_push_up` should be `-TotalFlow(n)`.\n\nLet `current_flow_balance[v]` store `S_out(v) - S_in(v)` for vertex `v`.\nThe DFS function `dfs(u, p_idx)` will return `current_flow_balance[u]` after processing `u`'s subtree and deciding directions for its children.\n\n`dfs(u, p_idx)`:\n  *   `visited[u] = True`\n  *   `u_balance = 0` (temporary balance for `u` from its children)\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `idx == p_idx`, continue.\n      *   If `visited[v]` is False:\n          *   `v_balance = dfs(v, idx)`\n          *   If `v_balance > 0`: `v` wants to send `v_balance` flow out. So `v -> u`. `ans[idx] = 1`. `u_balance += c`.\n          *   Else (`v_balance <= 0`): `v` wants to receive `abs(v_balance)` flow. So `u -> v`. `ans[idx] = 0`. `u_balance -= c`.\n      *   Else (`v` is visited and `idx != p_idx`): This is a non-tree edge.\n          *   Direct `u -> v` to avoid cycles (assuming `v` was visited earlier, so `v` is \"before\" `u` in some topological sense). `ans[idx] = 0`. `u_balance -= c`.\n  *   Now `u_balance` reflects the net flow `u` has sent to its children in the DFS tree.\n  *   If `u == 1`: `u` must output `TotalFlow(1)`. So `u_balance` should be `TotalFlow(1)`. Return `TotalFlow(1)`.\n  *   If `u == n`: `u` must receive `TotalFlow(n)`. So `u_balance` should be `-TotalFlow(n)`. Return `-TotalFlow(n)`.\n  *   If `1 < u < n`: `u` must have `S_in(u) = S_out(u)`. So `u_balance` should be 0.\n      *   The flow `u` needs to send *out* is `TotalFlow(u) / 2`.\n      *   The flow `u` has *already sent out* to children (or received from children) is `u_balance`.\n      *   The flow `u` *still needs to send out* to its parent (or receive from its parent) is `TotalFlow(u) / 2 - u_balance`.\n      *   Return `TotalFlow(u) / 2 - u_balance`. (This value is positive if `u` needs to send to parent, negative if it needs to receive from parent.)\n\nLet's test this logic with an example.\n`3 3`\n`3 2 10` (edge 0)\n`1 2 10` (edge 1)\n`3 1 5` (edge 2)\n\nVertices: 1 (source), 2 (intermediate), 3 (sink)\n\nAdj list:\n1: [(2, 10, 1), (3, 5, 2)]\n2: [(3, 10, 0), (1, 10, 1)]\n3: [(2, 10, 0), (1, 5, 2)]\n\nTotalFlow:\nTotalFlow(1) = 10 + 5 = 15\nTotalFlow(2) = 10 + 10 = 20\nTotalFlow(3) = 10 + 5 = 15\n\n`dfs(1, -1)`:\n  *   `visited[1] = True`\n  *   `u_balance = 0`\n  *   Edge `(1, 2)` (flow 10, idx 1):\n      *   `visited[2]` is False.\n      *   Call `dfs(2, 1)`:\n          *   `visited[2] = True`\n          *   `u_balance = 0` (for node 2)\n          *   Edge `(2, 3)` (flow 10, idx 0):\n              *   `visited[3]` is False.\n              *   Call `dfs(3, 0)`:\n                  *   `visited[3] = True`\n                  *   `u_balance = 0` (for node 3)\n                  *   Edge `(3, 1)` (flow 5, idx 2):\n                      *   `visited[1]` is True. This is a non-tree edge.\n                      *   `ans[2] = 0` (`3 -> 1`). `u_balance -= 5`. `u_balance` is now -5.\n                  *   Edge `(3, 2)` (flow 10, idx 0): This is `p_idx`, skip.\n                  *   Node 3 is `n`. Return `-TotalFlow(3) = -15`. (Wait, `u_balance` is -5. Should return -15).\n                  *   The `u_balance` calculated here is for children. For the sink, it's just `-TotalFlow(n)`.\n                  *   So, `dfs(3, 0)` returns `-15`.\n              *   Back in `dfs(2, 1)`: `v_balance = -15` (from `dfs(3, 0)`).\n              *   `v_balance <= 0` (it's -15). So `2 -> 3`. `ans[0] = 0`. `u_balance -= 10`. `u_balance` (for node 2) is now -10.\n          *   Edge `(2, 1)` (flow 10, idx 1): This is `p_idx`, skip.\n          *   Node 2 is intermediate. `TotalFlow(2) = 20`. `TotalFlow(2) / 2 = 10`.\n          *   `u_balance` (for node 2) is -10.\n          *   Return `TotalFlow(2) / 2 - u_balance = 10 - (-10) = 20`.\n      *   Back in `dfs(1, -1)`: `v_balance = 20` (from `dfs(2, 1)`).\n      *   `v_balance > 0`. So `2 -> 1`. `ans[1] = 1`. `u_balance += 10`. `u_balance` (for node 1) is now 10.\n  *   Edge `(1, 3)` (flow 5, idx 2):\n      *   `visited[3]` is True. This is a non-tree edge.\n      *   `ans[2] = 0` (`1 -> 3`). `u_balance -= 5`. `u_balance` (for node 1) is now 5.\n  *   Node 1 is `1`. Return `TotalFlow(1) = 15`. (My `u_balance` is 5. This is incorrect).\n\nThe issue is how `u_balance` is used. It should track the net flow *u* has sent *out* to its children, *minus* what it received from children, *plus* what it received from non-tree edges, *minus* what it sent to non-tree edges. This is getting complicated.\n\nThe `TotalFlow(v)/2` property for intermediate nodes is crucial.\nLet's try a DFS that calculates for each node `u` *how much flow it needs to send up to its parent* to satisfy its own `TotalFlow(u)/2` requirement.\n\n`dfs(u, p_idx)`:\n  *   `visited[u] = True`\n  *   `net_out_flow_to_children = 0` (sum of flows `u -> v` for children `v` - sum of flows `v -> u` for children `v`)\n  *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n      *   If `idx == p_idx`, continue.\n      *   If `visited[v]` is False:\n          *   `flow_v_needs_to_push_up = dfs(v, idx)`\n          *   If `flow_v_needs_to_push_up > 0`: `v` needs to send `flow_v_needs_to_push_up` flow to `u`. So `v -> u`. `ans[idx] = 1`. `net_out_flow_to_children -= c`.\n          *   Else (`flow_v_needs_to_push_up <= 0`): `v` needs to receive `abs(flow_v_needs_to_push_up)` flow from `u`. So `u -> v`. `ans[idx] = 0`. `net_out_flow_to_children += c`.\n      *   Else (`v` is visited, non-tree edge):\n          *   Always direct `u -> v` to avoid cycles. `ans[idx] = 0`. `net_out_flow_to_children += c`.\n  *   After iterating all edges of `u`:\n  *   If `u == n`: This is the sink. All flow should come in. `net_out_flow_to_children` should effectively be `-TotalFlow(n)`. So, `n` needs to pull `TotalFlow(n)` flow from its parent. Return `-TotalFlow(n)`.\n  *   If `u == 1`: This is the source. All flow should go out. `1` needs to push `TotalFlow(1)` flow to its parent (which is null). Return `TotalFlow(1)`.\n  *   If `1 < u < n`: This is an intermediate node.\n      *   `u` needs to output `TotalFlow(u) / 2`.\n      *   `u` has already output `net_out_flow_to_children` to its children.\n      *   The remaining flow `u` needs to output (or receive) is `(TotalFlow(u) / 2) - net_out_flow_to_children`.\n      *   Return this value. A positive value means `u` needs to push this much flow to its parent. A negative value means `u` needs to pull this much flow from its parent.\n\nLet's re-run the example:\n`3 3`\n`3 2 10` (edge 0)\n`1 2 10` (edge 1)\n`3 1 5` (edge 2)\n\nTotalFlow:\nTotalFlow(1) = 15\nTotalFlow(2) = 20\nTotalFlow(3) = 15\n\n`dfs(1, -1)`:\n  *   `visited[1] = True`\n  *   `net_out_flow_to_children = 0` (for node 1)\n  *   Edge `(1, 2)` (flow 10, idx 1):\n      *   `visited[2]` is False.\n      *   Call `dfs(2, 1)`:\n          *   `visited[2] = True`\n          *   `net_out_flow_to_children = 0` (for node 2)\n          *   Edge `(2, 3)` (flow 10, idx 0):\n              *   `visited[3]` is False.\n              *   Call `dfs(3, 0)`:\n                  *   `visited[3] = True`\n                  *   `net_out_flow_to_children = 0` (for node 3)\n                  *   Edge `(3, 1)` (flow 5, idx 2):\n                      *   `visited[1]` is True. Non-tree edge.\n                      *   `ans[2] = 0` (`3 -> 1`). `net_out_flow_to_children += 5`. (This is for node 3, but this edge is NOT to a child. This rule is wrong for non-tree edges. The `net_out_flow_to_children` should only be for children in DFS tree).\n                  *   Edge `(3, 2)` (flow 10, idx 0): `p_idx`, skip.\n                  *   Node 3 is `n`. Return `-TotalFlow(3) = -15`.\n              *   Back in `dfs(2, 1)`: `flow_v_needs_to_push_up = -15` (from `dfs(3, 0)`).\n              *   `flow_v_needs_to_push_up <= 0`. So `2 -> 3`. `ans[0] = 0`. `net_out_flow_to_children += 10`. `net_out_flow_to_children` (for node 2) is now 10.\n          *   Edge `(2, 1)` (flow 10, idx 1): `p_idx`, skip.\n          *   Node 2 is intermediate. `TotalFlow(2) / 2 = 10`.\n          *   Return `(TotalFlow(2) / 2) - net_out_flow_to_children = 10 - 10 = 0`.\n      *   Back in `dfs(1, -1)`: `flow_v_needs_to_push_up = 0` (from `dfs(2, 1)`).\n      *   `flow_v_needs_to_push_up <= 0`. So `1 -> 2`. `ans[1] = 0`. `net_out_flow_to_children += 10`. `net_out_flow_to_children` (for node 1) is now 10.\n  *   Edge `(1, 3)` (flow 5, idx 2):\n      *   `visited[3]` is True. Non-tree edge.\n      *   Always direct `1 -> 3`. `ans[2] = 0`. `net_out_flow_to_children += 5`. `net_out_flow_to_children` (for node 1) is now 15.\n  *   Node 1 is `1`. Return `TotalFlow(1) = 15`.\n\nFinal `ans`:\n`ans[0]` = 0 (`2 -> 3`)\n`ans[1]` = 0 (`1 -> 2`)\n`ans[2]` = 0 (`1 -> 3`)\n\nOutput for example 1: `1\\n0\\n1`\nMy output: `0\\n0\\n0`\nThis is different! The example output suggests `3 -> 2`, `1 -> 2`, `3 -> 1`.\nLet's check example output for validity:\n`3 -> 2` (10 flow)\n`1 -> 2` (10 flow)\n`3 -> 1` (5 flow)\nThis output has `3 -> 1`, which means flow goes from sink to source. This violates \"no incoming to source\" and also max-flow principles. The problem statement says \"vertex with number 1 has no incoming edges\". `3 -> 1` is an incoming edge to 1.\nThis suggests my interpretation of \"source has no incoming edges\" and \"sink\" might be too strict, or the example output has a different interpretation.\n\"vertex with number 1 has no incoming edges\" is explicit. `3 -> 1` violates this.\nThe example output must be `1 -> 3` for edge 2 (flow 5).\nIf `ans[2]` is 1, it means `3 -> 1`. This is incoming to 1.\nIf `ans[2]` is 0, it means `1 -> 3`. This is outgoing from 1.\n\nThe example output:\n`1` (edge 0: `3 2 10` -> `2 -> 3`)\n`0` (edge 1: `1 2 10` -> `1 -> 2`)\n`1` (edge 2: `3 1 5` -> `1 -> 3` should be `0`, `3 -> 1` is `1`)\nIf `ans[2]` is 1, it means `3 -> 1`. This is explicitly forbidden.\n\nThe problem statement: \"vertex with number 1 has no incoming edges\".\nIf `a_i, b_i` is an edge with flow `c_i`:\n`d_i = 0` means `a_i -> b_i`\n`d_i = 1` means `b_i -> a_i`\n\nFor edge `3 1 5` (index 2): `a_2=3, b_2=1, c_2=5`.\nIf `d_2 = 1`, then `b_2 -> a_2`, which is `1 -> 3`. This is valid.\nIf `d_2 = 0`, then `a_2 -> b_2`, which is `3 -> 1`. This is NOT valid (incoming to source 1).\n\nSo for edge `3 1 5`, `d_2` must be 1. The example output has `1` for the third edge. This means `1 -> 3`.\nMy DFS for non-tree edges was `u -> v`. For `(3, 1)` (edge 2), `u=3, v=1`. So `3 -> 1` (`ans[2]=0`). This is wrong. It should be `1 -> 3` (`ans[2]=1`).\n\nThe rule for non-tree edges:\nIf `visited[v]` is True (non-tree edge), we need to direct it.\nIf `v` is an ancestor of `u` in the DFS tree, then `u -> v` forms a cycle. So we must direct `v -> u`.\nIf `v` is a cross-edge, we can choose.\nThe \"no cycles\" rule is hard to enforce with just `visited` status for non-tree edges. A better way is to check `u`'s `dfs_entry_time` and `dfs_exit_time` compared to `v`'s.\nIf `dfs_entry_time[v] < dfs_entry_time[u]` and `dfs_exit_time[v] > dfs_exit_time[u]`, then `v` is an ancestor of `u`. In this case, `u -> v` is a back-edge, which forms a cycle. So it must be `v -> u`.\nOtherwise, it's a cross-edge. We can direct `u -> v` or `v -> u`. A simple rule like `u -> v` if `u < v` might work.\n\nHowever, the problem statement says \"a solution always exists.\" This implies there's a simpler rule that works.\nThe rule `u -> v` for non-tree edges is usually for forward edges or cross edges. For back-edges, it's `v -> u`.\nMy DFS implicitly constructs a spanning tree. Edges not in the spanning tree are non-tree edges.\nIf `(u, v)` is a non-tree edge and `v` is already visited, `v` could be an ancestor of `u` or a node in a different part of the tree.\nTo guarantee no cycles, we must direct `v -> u` if `v` is an ancestor of `u`.\nIf `v` is not an ancestor, then `u -> v` or `v -> u` will not form a cycle with the tree edges.\n\nLet's maintain `on_stack` (or `recursion_stack`) for visited nodes that are currently in the DFS recursion path.\n`dfs(u, p_idx)`:\n  *   `visited[u] = True`\n  *   `on_stack[u] = True`\n  *   ...\n  *   For non-tree edge `(u, v)`:\n      *   If `on_stack[v]` is True: `v` is an ancestor. So `v -> u`. `ans[idx] = 1`. `net_out_flow_to_children -= c`.\n      *   Else (`on_stack[v]` is False, `v` is visited but not an ancestor): Cross-edge. Direct `u -> v`. `ans[idx] = 0`. `net_out_flow_to_children += c`.\n  *   ...\n  *   `on_stack[u] = False`\n  *   Return ...\n\nLet's re-run example 1 with this refined non-tree edge rule.\n`3 3`\n`3 2 10` (edge 0)\n`1 2 10` (edge 1)\n`3 1 5` (edge 2)\n\n`dfs(1, -1)`:\n  *   `visited[1]=T, on_stack[1]=T`\n  *   `net_out_flow_to_children = 0` (for node 1)\n  *   Edge `(1, 2)` (flow 10, idx 1): `v=2`\n      *   `visited[2]` is False. Call `dfs(2, 1)`:\n          *   `visited[2]=T, on_stack[2]=T`\n          *   `net_out_flow_to_children = 0` (for node 2)\n          *   Edge `(2, 3)` (flow 10, idx 0): `v=3`\n              *   `visited[3]` is False. Call `dfs(3, 0)`:\n                  *   `visited[3]=T, on_stack[3]=T`\n                  *   `net_out_flow_to_children = 0` (for node 3)\n                  *   Edge `(3, 1)` (flow 5, idx 2): `v=1`\n                      *   `visited[1]` is True. `on_stack[1]` is True. `1` is an ancestor of `3`.\n                      *   So `1 -> 3`. `ans[2] = 1`. `net_out_flow_to_children -= 5`. (This is for node 3. If `1 -> 3`, then `3` receives flow, so `net_out_flow_to_children` for `3` should decrease by `c`).\n                      *   Wait, `net_out_flow_to_children` is for *children*. For non-tree edges, it's just `u_balance`.\n                      *   Let's use `u_balance` as the return value.\n                      *   `u_balance` is the flow `u` needs to push to parent.\n                      *   If `v` is ancestor (`on_stack[v]=T`), then `v -> u`. `u` receives flow `c`. So `u_balance += c`.\n                      *   If `v` is cross-edge (`on_stack[v]=F`), then `u -> v`. `u` sends flow `c`. So `u_balance -= c`.\n                      *   Edge `(3, 1)` (flow 5, idx 2): `v=1`. `on_stack[1]=T`. So `1 -> 3`. `ans[2] = 1`. `u_balance -= 5`.\n                  *   Edge `(3, 2)` (flow 10, idx 0): `p_idx`, skip.\n                  *   Node 3 is `n`. Return `-TotalFlow(3) = -15`.\n                  *   `on_stack[3]=F`.\n              *   Back in `dfs(2, 1)`: `flow_v_needs_to_push_up = -15` (from `dfs(3, 0)`).\n              *   `flow_v_needs_to_push_up <= 0`. So `2 -> 3`. `ans[0] = 0`. `u_balance -= 10`. `u_balance` (for node 2) is now -10.\n          *   Edge `(2, 1)` (flow 10, idx 1): `p_idx`, skip.\n          *   Node 2 is intermediate. `TotalFlow(2) / 2 = 10`.\n          *   Return `(TotalFlow(2) / 2) - u_balance = 10 - (-10) = 20`.\n          *   `on_stack[2]=F`.\n      *   Back in `dfs(1, -1)`: `flow_v_needs_to_push_up = 20` (from `dfs(2, 1)`).\n      *   `flow_v_needs_to_push_up > 0`. So `2 -> 1`. `ans[1] = 1`. `u_balance += 10`. `u_balance` (for node 1) is now 10.\n  *   Edge `(1, 3)` (flow 5, idx 2): `v=3`\n      *   `visited[3]` is True. `on_stack[3]` is False. Cross-edge.\n      *   So `1 -> 3`. `ans[2] = 0`. `u_balance -= 5`. `u_balance` (for node 1) is now 5.\n  *   Node 1 is `1`. Return `TotalFlow(1) = 15`.\n  *   `on_stack[1]=F`.\n\nFinal `ans`:\n`ans[0]` = 0 (`2 -> 3`, flow 10)\n`ans[1]` = 1 (`2 -> 1`, flow 10)\n`ans[2]` = 0 (`1 -> 3`, flow 5)\n\nThis result is still different from the example output.\nExample output:\n`ans[0]` = 1 (`3 -> 2`, flow 10)\n`ans[1]` = 0 (`1 -> 2`, flow 10)\n`ans[2]` = 1 (`1 -> 3`, flow 5)\n\nLet's verify the example output:\nEdges:\n`3 -> 2` (10 flow)\n`1 -> 2` (10 flow)\n`1 -> 3` (5 flow)\n\nVertex 1 (source):\nOutgoing: `1 -> 2` (10), `1 -> 3` (5). Total outgoing = 15.\nIncoming: 0. (OK)\n\nVertex 2 (intermediate):\nOutgoing: `2 -> 3` (10).\nIncoming: `1 -> 2` (10).\nConservation: `10 (in) = 10 (out)`. (OK)\n\nVertex 3 (sink):\nOutgoing: 0.\nIncoming: `3 -> 2` (10) (Wait, this is an outgoing edge from 3, not incoming)\nThe example output for edge 0 (`3 2 10`) is `1`, meaning `2 -> 3`.\nSo, `3` has incoming flow: `2 -> 3` (10), `1 -> 3` (5). Total incoming = 15.\nOutgoing = 0. (OK for sink)\n\nIs it acyclic?\n`1 -> 2 -> 3`\n`1 -> 3`\nYes, it's a DAG.\n\nMy DFS must have a mistake in the non-tree edge handling or the `u_balance` calculation.\nThe `u_balance` should be what `u` needs to *return* to its parent (if positive) or *receive* from its parent (if negative) to satisfy its own conservation.\n\nLet's adjust the `u_balance` return value for `1` and `n`.\nFor `u = 1`: The source. It must output `TotalFlow(1)`. All flow to its parent is outgoing. So it needs to push `TotalFlow(1)`.\nFor `u = n`: The sink. It must receive `TotalFlow(n)`. All flow from its parent is incoming. So it needs to pull `TotalFlow(n)`. Return `-TotalFlow(n)`.\n\nThe crucial part is the non-tree edge direction.\nIf `(u, v)` is a non-tree edge.\nIf `on_stack[v]` is True: `v` is an ancestor. We must direct `v -> u` to avoid a cycle. This means `u` receives `c` flow. `u_balance += c`.\nIf `on_stack[v]` is False: `v` is a cross-edge or a fully processed node in another branch. Direct `u -> v`. This means `u` sends `c` flow. `u_balance -= c`. This is a standard rule for DFS tree to ensure DAG.\n\nLet's use `adj` list storing `(neighbor, flow_volume, original_edge_index, is_forward_edge_in_input)`.\n`is_forward_edge_in_input` is 0 if `a_i -> b_i` is desired, 1 if `b_i -> a_i` is desired.\nInitially, `ans` array is empty.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    total_flow_sum_at_node = [0] * (n + 1)\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_flow_sum_at_node[u] += c\n        total_flow_sum_at_node[v] += c\n\n    ans = [0] * m\n    visited = [False] * (n + 1)\n    on_recursion_stack = [False] * (n + 1) # To detect back-edges\n\n    # dfs(u, parent_edge_idx) returns the net flow 'u' needs to push to its parent (positive)\n    # or pull from its parent (negative) to satisfy its local flow conservation.\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        on_recursion_stack[u] = True\n        \n        net_flow_from_children = 0 # sum(flow_v_to_u) - sum(flow_u_to_v) for children v in DFS tree\n        \n        for v, c, edge_idx in adj[u]:\n            if edge_idx == p_edge_idx:\n                continue\n            \n            if not visited[v]:\n                # Tree edge\n                flow_v_needs_to_push_up = dfs(v, edge_idx)\n                \n                if flow_v_needs_to_push_up > 0:\n                    # v needs to send flow_v_needs_to_push_up to u. So v -> u.\n                    # This means u receives flow c.\n                    ans[edge_idx] = 1 if (edges_input[edge_idx][0] == v and edges_input[edge_idx][1] == u) else 0\n                    net_flow_from_children += c\n                else:\n                    # v needs to receive abs(flow_v_needs_to_push_up) flow from u. So u -> v.\n                    # This means u sends flow c.\n                    ans[edge_idx] = 0 if (edges_input[edge_idx][0] == u and edges_input[edge_idx][1] == v) else 1\n                    net_flow_from_children -= c\n            elif on_recursion_stack[v]:\n                # Back-edge (v is an ancestor of u)\n                # To avoid cycle, must direct v -> u.\n                # This means u receives flow c.\n                ans[edge_idx] = 1 if (edges_input[edge_idx][0] == v and edges_input[edge_idx][1] == u) else 0\n                net_flow_from_children += c\n            else:\n                # Cross-edge (v is visited but not an ancestor, already processed)\n                # Direct u -> v. This means u sends flow c.\n                ans[edge_idx] = 0 if (edges_input[edge_idx][0] == u and edges_input[edge_idx][1] == v) else 1\n                net_flow_from_children -= c\n        \n        on_recursion_stack[u] = False # Finished processing u's subtree\n        \n        if u == n: # Sink\n            # Sink receives all flow. It needs to pull TotalFlow(n) from its parent.\n            return -total_flow_sum_at_node[n]\n        elif u == 1: # Source\n            # Source sends all flow. It needs to push TotalFlow(1) to its parent (which is null, but conceptually it pushes).\n            return total_flow_sum_at_node[1]\n        else: # Intermediate node\n            # u needs to send TotalFlow(u) / 2 out.\n            # u has already sent net_flow_from_children to its children (positive if net out, negative if net in).\n            # The flow u needs to push to its parent is (TotalFlow(u) / 2) - (net_flow_from_children).\n            return (total_flow_sum_at_node[u] // 2) - net_flow_from_children\n\n    # Start DFS from source (vertex 1)\n    dfs(1, -1) # -1 indicates no parent edge\n\n    for d in ans:\n        sys.stdout.write(str(d) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    total_flow_sum_at_node = [0] * (n + 1)\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_flow_sum_at_node[u] += c\n        total_flow_sum_at_node[v] += c\n\n    ans = [0] * m\n    visited = [False] * (n + 1)\n    on_recursion_stack = [False] * (n + 1) # To detect back-edges\n\n    # dfs(u, parent_edge_idx) returns the net flow 'u' needs to push to its parent (positive)\n    # or pull from its parent (negative) to satisfy its local flow conservation.\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        on_recursion_stack[u] = True\n        \n        net_flow_from_children = 0 # sum(flow_v_to_u) - sum(flow_u_to_v) for children v in DFS tree\n        \n        for v, c, edge_idx in adj[u]:\n            if edge_idx == p_edge_idx:\n                continue\n            \n            if not visited[v]:\n                # Tree edge\n                flow_v_needs_to_push_up = dfs(v, edge_idx)\n                \n                if flow_v_needs_to_push_up > 0:\n                    # v needs to send flow_v_needs_to_push_up to u. So v -> u.\n                    # This means u receives flow c.\n                    ans[edge_idx] = 1 if (edges_input[edge_idx][0] == v and edges_input[edge_idx][1] == u) else 0\n                    net_flow_from_children += c\n                else:\n                    # v needs to receive abs(flow_v_needs_to_push_up) flow from u. So u -> v.\n                    # This means u sends flow c.\n                    ans[edge_idx] = 0 if (edges_input[edge_idx][0] == u and edges_input[edge_idx][1] == v) else 1\n                    net_flow_from_children -= c\n            elif on_recursion_stack[v]:\n                # Back-edge (v is an ancestor of u)\n                # To avoid cycle, must direct v -> u.\n                # This means u receives flow c.\n                ans[edge_idx] = 1 if (edges_input[edge_idx][0] == v and edges_input[edge_idx][1] == u) else 0\n                net_flow_from_children += c\n            else:\n                # Cross-edge (v is visited but not an ancestor, already processed)\n                # Direct u -> v. This means u sends flow c.\n                ans[edge_idx] = 0 if (edges_input[edge_idx][0] == u and edges_input[edge_idx][1] == v) else 1\n                net_flow_from_children -= c\n        \n        on_recursion_stack[u] = False # Finished processing u's subtree\n        \n        if u == n: # Sink\n            # Sink receives all flow. It needs to pull TotalFlow(n) from its parent.\n            return -total_flow_sum_at_node[n]\n        elif u == 1: # Source\n            # Source sends all flow. It needs to push TotalFlow(1) to its parent (which is null, but conceptually it pushes).\n            return total_flow_sum_at_node[1]\n        else: # Intermediate node\n            # u needs to send TotalFlow(u) / 2 out.\n            # u has already sent net_flow_from_children to its children (positive if net out, negative if net in).\n            # The flow u needs to push to its parent is (TotalFlow(u) / 2) - (net_flow_from_children).\n            return (total_flow_sum_at_node[u] // 2) - net_flow_from_children\n\n    # Start DFS from source (vertex 1)\n    dfs(1, -1) # -1 indicates no parent edge\n\n    for d in ans:\n        sys.stdout.write(str(d) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 14415,
        "thoughts_token_count": 785
    }
}