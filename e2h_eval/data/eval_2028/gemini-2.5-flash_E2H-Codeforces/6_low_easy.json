{
    "start": 1758009280.4011517,
    "end": 1758009365.8917851,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Problem Decomposition and Optimization Strategies**\n\nOkay, so I'm tackling a competitive programming problem. The core is to find the cheapest pair of non-overlapping vouchers that sum to a specific duration, `x`.  My input is a list of vouchers, each with a start time, end time, and cost.  I need to output the minimum cost of a valid pair or -1 if no such pair exists.\n\nThe problem breaks down like this: I have `n` vouchers, `x` is the target duration, and each voucher has a start, end, and cost. The duration is simply `end - start + 1`.  A valid pair means two distinct vouchers that don't overlap, and their durations add up to `x`.  My objective is to *minimize* the combined cost of the chosen pair.\n\nMy initial thought is a brute-force, `O(n^2)` solution, checking all possible pairs.  But given the constraints of `n` being up to 200,000, that's going to be too slow, computationally speaking.  I need to find something more efficient, aiming for `O(n log n)` or potentially even `O(n)`.\n\nSo, I need to devise a strategy.  Fixing one voucher, `i`,  I need to find another `j` to complete a valid pair. The conditions for `j` are that it doesn't overlap with `i`, and that its duration, `d_j`, is `x - d_i`. The cost of `j` should be minimized. The non-overlap condition is key: either `r_i < l_j` or `r_j < l_i`.  Also, the maximum coordinate value is `2 * 10^5`, so I need to keep that in mind.\n\nNow I am thinking about sorting. If I sort the vouchers, what's a good key? Sorting by the start time, `l_i`, might be promising.  If I iterate through them in that order, for each voucher `i`, I can search for a voucher `j` such that `d_j = x - d_i`, and it doesn't overlap. I just need to make sure the cost of this `j` is minimal. The important part is making sure that the non-intersection condition is efficiently handled during the search.\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost (`cost_i + cost_j`) is minimized. If no such pair exists, we should output -1.\n\nLet's denote a voucher by `(l, r, cost)`. Its duration is `d = r - l + 1`.\nTwo vouchers `(l_1, r_1, cost_1)` and `(l_2, r_2, cost_2)` are non-overlapping if `r_1 < l_2` or `r_2 < l_1`.\n\nThe maximum coordinate for `r` is `2 * 10^5`. Let's call this `MAX_R`.\nThe maximum duration `x` is also `2 * 10^5`.\n\nA brute-force approach of checking all `O(N^2)` pairs would be too slow given `N <= 2 * 10^5`. We need a more efficient approach, likely `O(N log N)` or `O(N)`.\n\nLet's fix one voucher `v_1 = (l_1, r_1, cost_1, d_1)`. We are looking for another voucher `v_2 = (l_2, r_2, cost_2, d_2)` such that:\n1.  `d_2 = x - d_1`.\n2.  `v_1` and `v_2` are non-overlapping.\n3.  `cost_2` is minimized.\n\nThe non-overlapping condition `r_1 < l_2` or `r_2 < l_1` suggests processing vouchers in a way that helps manage available candidates for `v_2`.\n\nWe can iterate through all vouchers `v_1`. For each `v_1`, we need to efficiently find the best `v_2`.\nLet's consider two cases for non-overlapping:\nCase 1: `v_2` ends before `v_1` starts (`r_2 < l_1`).\nCase 2: `v_2` starts after `v_1` ends (`r_1 < l_2`).\n\nTo optimize finding `v_2`, we can use a data structure that stores minimum costs for vouchers of a specific duration.\nLet `min_cost_for_duration[d]` be the minimum cost of a voucher with duration `d` that has been \"processed\" so far. Initialize all entries to infinity.\n\nWe can sort all vouchers. A good sorting order would be by `l` (start day).\nLet's store vouchers in a list `vouchers_by_l = [(l, r, cost, d), ...]`, sorted by `l`.\n\nWe can iterate through the vouchers sorted by their *start day* `l`.\nHowever, to handle the `r_2 < l_1` condition, we need to know about vouchers that *end* before `l_1`.\nTo handle the `r_1 < l_2` condition, we need to know about vouchers that *start* after `r_1`.\n\nA common technique for interval problems is to use a sweep-line approach or process events.\nConsider all `l_i` and `r_i` values as points on a timeline. The maximum coordinate is `MAX_R`.\n\nLet's maintain an array `min_cost_ending_at_day[day]` where `min_cost_ending_at_day[day]` stores the minimum cost of a voucher that *ends* on or before `day`, for each possible duration `d`. This is too complex to update for all durations.\n\nInstead, let's simplify. We want to find `v_2` such that `d_2 = x - d_1`.\nThe `min_cost_for_duration` array needs to store minimum costs for vouchers that satisfy the non-overlapping condition.\n\nLet's process vouchers sorted by their `r` (end day). This might be tricky because we need `l` for the other condition.\n\nA more effective approach:\n1.  Group vouchers by their duration. Let `vouchers_by_duration[d]` be a list of `(l, r, cost)` for vouchers with duration `d`.\n2.  For each duration `d_1` from `1` to `x-1`:\n    *   Calculate `d_2 = x - d_1`. If `d_2 <= 0`, skip.\n    *   We need to find a `v_1` from `vouchers_by_duration[d_1]` and a `v_2` from `vouchers_by_duration[d_2]` such that they don't intersect and `cost_1 + cost_2` is minimized.\n\nThis still involves iterating through all pairs of vouchers for specific durations, which can be `O(N^2)` in the worst case (e.g., all vouchers have duration 1).\n\n**Optimized Sweep-Line Approach:**\n\nLet's iterate through all possible end days `r_i` from `1` to `MAX_R`.\nWe need to efficiently find the best `v_2` for `v_1` such that `r_1 < l_2`.\nOr, for a `v_1`, we need to find the best `v_2` such that `r_2 < l_1`.\n\nLet's maintain an array `min_cost_for_duration_ending_before_or_at[duration_val]`. This array will store the minimum cost of a voucher with `duration_val` that has already *ended*.\nInitialize `min_cost_for_duration_ending_before_or_at` with infinity for all possible durations.\n\nIterate `day` from `1` to `MAX_R`:\n1.  **Update available vouchers**: For every voucher `(l, r, cost)` that *ends* on `day` (i.e., `r == day`):\n    *   Calculate its duration `d = r - l + 1`.\n    *   Update `min_cost_for_duration_ending_before_or_at[d] = min(min_cost_for_duration_ending_before_or_at[d], cost)`.\n    *   This step makes these vouchers available for the \"starts after\" condition (`r_2 < l_1`).\n    *   Wait, this is not quite right. `min_cost_for_duration_ending_before_or_at[d]` should store the minimum cost for a voucher of duration `d` that *has ended by `day`*.\n\nLet's rephrase: We want to find a pair `(v_i, v_j)` such that `r_i < l_j` and `d_i + d_j = x`.\nSort all vouchers by their `l_i` values. Let's call this `events`.\nIterate through the `events` (vouchers sorted by `l_i`).\nWhen processing a voucher `v_j = (l_j, r_j, cost_j, d_j)`:\nWe are looking for a `v_i` such that `r_i < l_j` and `d_i = x - d_j`.\nTo do this efficiently, we need to know, for each possible duration `D`, what is the minimum cost of a voucher `v_i` with duration `D` such that `r_i < l_j`.\n\nLet's create two lists of events:\n`start_events`: `[(l, r, cost, d), ...]` sorted by `l`.\n`end_events`: `[(r, l, cost, d), ...]` sorted by `r`.\n\nThis approach is better:\n1.  Create a list of all vouchers `all_vouchers = [(l, r, cost)]`.\n2.  Initialize `min_total_cost = infinity`.\n3.  Create an array `min_cost_at_duration[duration]` of size `x+1`, initialized to infinity. This array will store the minimum cost of a voucher seen so far that *could be the first voucher* in a pair, satisfying the `r_1 < l_2` condition.\n4.  Sort `all_vouchers` by their `l` values.\n5.  Iterate `day` from `1` to `MAX_R`. (This is a sweep-line approach.)\n    *   For `day`:\n        *   **Phase 1: Process vouchers that start on `day`**. These are potential `v_2` vouchers.\n            For each voucher `v_j = (l_j, r_j, cost_j)` such that `l_j == day`:\n                *   Calculate `d_j = r_j - l_j + 1`.\n                *   Calculate required duration for `v_i`: `d_i = x - d_j`.\n                *   If `d_i > 0` and `min_cost_at_duration[d_i]` is not infinity:\n                    *   This means we found a `v_i` with duration `d_i` and cost `min_cost_at_duration[d_i]` such that `r_i < l_j`.\n                    *   Update `min_total_cost = min(min_total_cost, min_cost_at_duration[d_i] + cost_j)`.\n        *   **Phase 2: Update `min_cost_at_duration` for vouchers that end on `day`**. These are potential `v_i` vouchers.\n            For each voucher `v_i = (l_i, r_i, cost_i)` such that `r_i == day`:\n                *   Calculate `d_i = r_i - l_i + 1`.\n                *   Update `min_cost_at_duration[d_i] = min(min_cost_at_duration[d_i], cost_i)`.\n\nThis sweep-line approach has a slight issue: `min_cost_at_duration[d_i]` should contain the minimum cost of a voucher that *ended strictly before* `l_j`.\nIf we update `min_cost_at_duration` at the `day` when `r_i == day`, then when we process `l_j == day`, `min_cost_at_duration` would include vouchers that end on `day`, making `r_i < l_j` false (it would be `r_i = l_j`).\n\nCorrected Sweep-Line:\n1.  Initialize `min_total_cost = infinity`.\n2.  `min_cost_ending_before_day[duration]` will store the minimum cost of a voucher with `duration` that has ended *before* the current `day`. Initialize to infinity.\n3.  Group vouchers by their `l` (start day) and `r` (end day).\n    `vouchers_by_start_day[day]` = list of `(r, cost, duration)` for vouchers starting on `day`.\n    `vouchers_by_end_day[day]` = list of `(l, cost, duration)` for vouchers ending on `day`. (We don't actually need `l` here, just `cost` and `duration`.)\n    These lists can be populated by iterating through all `N` vouchers once. Max day is `MAX_R`.\n4.  Iterate `day` from `1` to `MAX_R`:\n    *   **Phase 1: Process vouchers that start on `day` (potential `v_2`)**:\n        For each voucher `(r_j, cost_j, d_j)` in `vouchers_by_start_day[day]`:\n            *   Calculate `d_i = x - d_j`.\n            *   If `d_i > 0` and `d_i <= x` (duration must be positive and within bounds):\n                *   If `min_cost_ending_before_day[d_i]` is not infinity:\n                    *   We found a valid pair. Update `min_total_cost = min(min_total_cost, min_cost_ending_before_day[d_i] + cost_j)`.\n    *   **Phase 2: Update `min_cost_ending_before_day` for vouchers that ended on `day` (potential `v_i`)**:\n        For each voucher `(l_i, cost_i, d_i)` in `vouchers_by_end_day[day]`:\n            *   `min_cost_ending_before_day[d_i] = min(min_cost_ending_before_day[d_i], cost_i)`.\n\nThis sweep-line processes `MAX_R` days. For each day, it iterates through vouchers starting/ending on that day.\nTotal time complexity: `O(MAX_R + N)`.\n`MAX_R` is `2 * 10^5`, `N` is `2 * 10^5`. This is `O(N + MAX_R)`.\nSpace complexity: `O(MAX_R + N)` for storing `vouchers_by_start_day`, `vouchers_by_end_day`, and `min_cost_ending_before_day`.\n\nExample walk-through (First Sample):\nN=4, X=5\nVouchers:\n1: (1, 3, 4) -> d=3\n2: (1, 2, 5) -> d=2\n3: (5, 6, 1) -> d=2\n4: (1, 2, 4) -> d=2\n\nMAX_R = 6\nmin_total_cost = infinity\nmin_cost_ending_before_day = array of size X+1 (6), all infinity.\n\nvouchers_by_start_day:\n1: [(3, 4, 3), (2, 5, 2), (2, 4, 2)] (r, cost, duration)\n5: [(6, 1, 2)]\n\nvouchers_by_end_day:\n2: [(1, 5, 2), (1, 4, 2)] (l, cost, duration)\n3: [(1, 4, 3)]\n6: [(5, 1, 2)]\n\nday = 1:\n  Phase 1 (start on day 1):\n    Voucher (3, 4, 3): d_j=3. d_i=X-d_j = 5-3=2. min_cost_ending_before_day[2] is inf. No update.\n    Voucher (2, 5, 2): d_j=2. d_i=X-d_j = 5-2=3. min_cost_ending_before_day[3] is inf. No update.\n    Voucher (2, 4, 2): d_j=2. d_i=X-d_j = 5-2=3. min_cost_ending_before_day[3] is inf. No update.\n  Phase 2 (end on day 1): No vouchers.\n\nday = 2:\n  Phase 1 (start on day 2): No vouchers.\n  Phase 2 (end on day 2):\n    Voucher (1, 5, 2): d_i=2. min_cost_ending_before_day[2] = min(inf, 5) = 5.\n    Voucher (1, 4, 2): d_i=2. min_cost_ending_before_day[2] = min(5, 4) = 4.\n    `min_cost_ending_before_day` is now: [inf, inf, 4, inf, inf, inf]\n\nday = 3:\n  Phase 1 (start on day 3): No vouchers.\n  Phase 2 (end on day 3):\n    Voucher (1, 4, 3): d_i=3. min_cost_ending_before_day[3] = min(inf, 4) = 4.\n    `min_cost_ending_before_day` is now: [inf, inf, 4, 4, inf, inf]\n\nday = 4:\n  Phase 1 (start on day 4): No vouchers.\n  Phase 2 (end on day 4): No vouchers.\n\nday = 5:\n  Phase 1 (start on day 5):\n    Voucher (6, 1, 2): d_j=2. d_i=X-d_j = 5-2=3.\n      min_cost_ending_before_day[3] is 4.\n      Update min_total_cost = min(inf, 4 + 1) = 5.\n  Phase 2 (end on day 5): No vouchers.\n\nday = 6:\n  Phase 1 (start on day 6): No vouchers.\n  Phase 2 (end on day 6):\n    Voucher (5, 1, 2): d_i=2. min_cost_ending_before_day[2] = min(4, 1) = 1.\n    `min_cost_ending_before_day` is now: [inf, inf, 1, 4, inf, inf]\n\nFinal `min_total_cost` = 5. This matches the example output.\n\nIf `min_total_cost` remains infinity after the loop, print -1. Otherwise, print `min_total_cost`.\n\nThe maximum coordinate value for `l_i` and `r_i` is `2 * 10^5`.\nThe maximum duration `x` is `2 * 10^5`.\n`min_cost_ending_before_day` array size `x+1` is fine.\nLists `vouchers_by_start_day` and `vouchers_by_end_day` can store lists of tuples.\nThe `MAX_R` value is `2 * 10^5`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start_day[day] will store a list of (r, cost, duration) for vouchers starting on 'day'\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end_day[day] will store a list of (cost, duration) for vouchers ending on 'day'\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        \n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((cost, duration))\n\n    # min_cost_ending_before_day[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended *before* the current day in the sweep-line.\n    # Initialize with a value larger than any possible cost (10^9 * 2 + 1)\n    # or use float('inf')\n    min_cost_ending_before_day = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep-line from day 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers that start on 'day'\n        # These are potential second vouchers (v_j)\n        for r_j, cost_j, d_j in vouchers_by_start_day[day]:\n            d_i = x - d_j  # Required duration for the first voucher (v_i)\n            \n            # Check if d_i is a valid duration (positive and within bounds of x)\n            # and if there's a valid first voucher (v_i) found so far.\n            if 1 <= d_i <= x and min_cost_ending_before_day[d_i] != float('inf'):\n                # We found a pair (v_i, v_j) where v_i ends before day 'day' (l_j)\n                # and their durations sum to x.\n                min_total_cost = min(min_total_cost, min_cost_ending_before_day[d_i] + cost_j)\n        \n        # Phase 2: Update min_cost_ending_before_day for vouchers that end on 'day'\n        # These are potential first vouchers (v_i) for future 'v_j's\n        for cost_i, d_i in vouchers_by_end_day[day]:\n            # Update the minimum cost for a voucher of duration d_i that has ended by 'day'\n            if 1 <= d_i <= x: # Only care about durations relevant to x\n                min_cost_ending_before_day[d_i] = min(min_cost_ending_before_day[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start_day[day] will store a list of (r, cost, duration) for vouchers starting on 'day'\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end_day[day] will store a list of (cost, duration) for vouchers ending on 'day'\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        \n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((cost, duration))\n\n    # min_cost_ending_before_day[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended *before* the current day in the sweep-line.\n    # Initialize with a value larger than any possible cost (10^9 * 2 + 1)\n    # or use float('inf')\n    min_cost_ending_before_day = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep-line from day 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers that start on 'day'\n        # These are potential second vouchers (v_j)\n        for r_j, cost_j, d_j in vouchers_by_start_day[day]:\n            d_i = x - d_j  # Required duration for the first voucher (v_i)\n            \n            # Check if d_i is a valid duration (positive and within bounds of x)\n            # and if there's a valid first voucher (v_i) found so far.\n            if 1 <= d_i <= x and min_cost_ending_before_day[d_i] != float('inf'):\n                # We found a pair (v_i, v_j) where v_i ends before day 'day' (l_j)\n                # and their durations sum to x.\n                min_total_cost = min(min_total_cost, min_cost_ending_before_day[d_i] + cost_j)\n        \n        # Phase 2: Update min_cost_ending_before_day for vouchers that end on 'day'\n        # These are potential first vouchers (v_i) for future 'v_j's\n        for cost_i, d_i in vouchers_by_end_day[day]:\n            # Update the minimum cost for a voucher of duration d_i that has ended by 'day'\n            if 1 <= d_i <= x: # Only care about durations relevant to x\n                min_cost_ending_before_day[d_i] = min(min_cost_ending_before_day[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 4910,
        "thoughts_token_count": 799
    }
}