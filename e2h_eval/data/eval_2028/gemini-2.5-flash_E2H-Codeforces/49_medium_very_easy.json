{
    "start": 1758294873.294472,
    "end": 1758294965.3046072,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Mushroom Strife Problem Breakdown and Solution Strategy**\n\nOkay, so I've got this \"Mushroom Strife\" problem to tackle, and it's a doozy. It's about assigning mushroom counts to lawns connected by roads with GCD and LCM constraints. Basically, I need to come up with a Python script that takes input about lawns, roads, and mushroom-related calculations, then figures out if a valid mushroom assignment is possible.  If so, I need to print the assigned mushroom counts.\n\nThe problem seems like a graph problem. Lawns are nodes, roads are edges. Each edge has a GCD and LCM constraint based on the mushroom counts of the connected lawns. My initial thoughts are:\n\n*   **Problem Structure:** We have `n` lawns (nodes) and `m` roads (edges). Each road connects two lawns (`u`, `v`) and has a GCD (`g`) and LCM (`l`) constraint for the mushroom counts on those lawns.  I need to find a way to assign each lawn a mushroom count (`m_i`) that satisfies all the GCD/LCM constraints on the roads.\n*   **Key Property:** The core of the problem lies in the relationship `GCD(a, b) * LCM(a, b) = a * b`.  This will be crucial in relating the mushroom counts with the given `g` and `l` values.\n*   **Constraint Check:**  A quick check: If `l` is not a multiple of `g`, there's no solution.  This is because the LCM *must* be a multiple of the GCD.\n\nTo solve this, I'm thinking about a prime factorization approach.  If I break down each mushroom count into its prime factors, I can tackle each prime individually. The core idea is to express the mushroom count for each lawn `i` as `m_i = p_1^{a_{i1}} * p_2^{a_{i2}} ...`. Then, I can analyze the GCD/LCM constraints for each prime separately.\n\nFor a prime `p` and an edge connecting lawns `u` and `v`, the problem decomposes into this:\n\n*   Let  `g_p = v_p(g)` and `l_p = v_p(l)` be the exponents of `p` in the GCD and LCM, respectively.\n*   The constraint becomes:  `min(e_u, e_v) = g_p` and `max(e_u, e_v) = l_p`\n\nThe implication is that for an edge, I'll need to work with these exponents for each prime individually.  For the entire graph, this transforms into a set of 2-coloring problems, where, for each prime, `e_u` and `e_v` must take on either `g_p` or `l_p` values. The condition is that they either must be the same (when `g_p == l_p`) or they must be different (when `g_p < l_p`). This reminds me of graph coloring problems.\n\nHere's my refined algorithm:\n\n1.  **Iterate through Primes:** For each prime number `p` (up to a reasonable limit, I suspect based on the input constraints), I'll work with the edges.\n2.  **Exponents and Consistency:**\n    *   For each edge, I'll compute `g_p` and `l_p`.\n    *   If `g_p > l_p`, it's impossible (exit with \"NO\").\n    *   If `g_p == l_p`, the exponents must be equal for both connected nodes. Set those exponents.\n    *   If `g_p < l_p`,  this signifies different exponent values. This will give rise to our 2-coloring problem.\n3.  **Graph Construction and Propagation:**\n    *   Construct a graph where nodes are lawns.\n    *   For each prime `p`, and if  `g_p < l_p`, add the edge `(u,v)` to an adjacency list.\n    *   I'll need to \"propagate\" known exponent values. This involves a BFS or DFS-like traversal.\n4.  **2-Coloring:**\n    *   If the graph isn't fully colored after the propagation (some nodes are unassigned), I'll need to apply a 2-coloring algorithm to assign these remaining nodes.\n    *   This ensures the correct relative exponent relationship.\n    *   Conflict detection is critical.\n\n**Key Data Structures:**\n\n*   `final_m_values`: Array to hold the calculated mushroom counts for each lawn.\n*   `exponents_p`:  A 2D array (`n",
    "response": "The problem asks us to restore the number of mushrooms on `n` lawns given `m` roads. For each road connecting lawns `u` and `v`, we are given the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on `u` and `v`. We need to find any valid assignment of mushroom counts or report that none exists.\n\nLet `m_i` be the number of mushrooms on lawn `i`. For any two positive integers `a` and `b`, we know that `GCD(a, b) * LCM(a, b) = a * b`. This is a crucial property.\n\nLet `v_p(x)` denote the exponent of the prime `p` in the prime factorization of `x`. For an edge `(u, v)` with given `g = GCD(m_u, m_v)` and `l = LCM(m_u, m_v)`, the following must hold for every prime `p`:\n1.  `min(v_p(m_u), v_p(m_v)) = v_p(g)`\n2.  `max(v_p(m_u), v_p(m_v)) = v_p(l)`\n\nFrom these two conditions, we can deduce:\n*   `v_p(g) <= v_p(l)` must always be true. If `v_p(g) > v_p(l)` for any prime `p` (which implies `l` is not a multiple of `g`), then no solution exists.\n*   If `v_p(g) == v_p(l)`: Then `v_p(m_u)` must be `v_p(g)` AND `v_p(m_v)` must be `v_p(g)`. Both exponents are fixed.\n*   If `v_p(g) < v_p(l)`: Then `v_p(m_u)` and `v_p(m_v)` must be `v_p(g)` and `v_p(l)` in some order. They must be different.\n\nThis decomposition allows us to solve the problem independently for each prime factor. We only need to consider primes that are factors of any `g` or `l` value. Since `g, l <= 10^6`, the maximum prime factor is `10^6`.\n\n**Algorithm Steps:**\n\n1.  **Precomputation (Sieve):** Generate smallest prime factor (`spf`) for all numbers up to `10^6` using a sieve. This helps in efficiently finding prime factorizations and `v_p(x)` values.\n\n2.  **Collect Primes and Edges:**\n    *   Initialize `final_m_values = [1] * (n + 1)` (to store the mushroom counts, 1-indexed).\n    *   Create a set `all_relevant_primes` to store all distinct prime factors encountered in any `g` or `l` from the input.\n    *   Store all input edges `(u, v, g, l)` in a list `edge_list`.\n    *   For each edge `(u, v, g, l)`:\n        *   Check if `l % g != 0`. If not, print \"NO\" and exit, as `LCM` must be a multiple of `GCD`.\n        *   Find prime factors of `g` and `l` using `spf`. Add them to `all_relevant_primes`.\n\n3.  **Solve for Each Prime:** Iterate through each `p` in `all_relevant_primes`. For each `p`:\n    *   `exponents_p = [-1] * (n + 1)`: An array to store the exponent of prime `p` for each lawn. `-1` means unknown.\n    *   `adj_p = [[] for _ in range(n + 1)]`: An adjacency list to store \"ambiguous\" edges for prime `p`. An edge `(u, v)` is ambiguous if `v_p(g) < v_p(l)`, meaning `v_p(m_u)` and `v_p(m_v)` must be `v_p(g)` and `v_p(l)` in some order. `adj_p[u]` will store `(v, g_p, l_p)` where `g_p = v_p(g)` and `l_p = v_p(l)`.\n    *   `q = collections.deque()`: A queue for BFS.\n\n    *   **Phase 1: Process Fixed Exponents and Initial Propagation:**\n        *   For each edge `(u, v, g, l)` in `edge_list`:\n            *   Calculate `g_p = v_p(g)` and `l_p = v_p(l)`.\n            *   If `g_p == l_p`:\n                *   If `exponents_p[u]` is known and `exponents_p[u] != g_p`, conflict. Print \"NO\", exit.\n                *   If `exponents_p[v]` is known and `exponents_p[v] != g_p`, conflict. Print \"NO\", exit.\n                *   If `exponents_p[u]` is `-1`, set `exponents_p[u] = g_p` and add `u` to `q`.\n                *   If `exponents_p[v]` is `-1`, set `exponents_p[v] = g_p` and add `v` to `q`.\n            *   Else (`g_p < l_p`):\n                *   Add `(v, g_p, l_p)` to `adj_p[u]` and `(u, g_p, l_p)` to `adj_p[v]`.\n\n    *   **Phase 2: BFS Propagation for Fixed Values:**\n        *   While `q` is not empty:\n            *   `curr = q.popleft()`\n            *   `fixed_exp = exponents_p[curr]`\n            *   For `neighbor, g_prime, l_prime` in `adj_p[curr]`:\n                *   If `fixed_exp == g_prime`: `target_exp = l_prime`.\n                *   Else if `fixed_exp == l_prime`: `target_exp = g_prime`.\n                *   Else (`fixed_exp` is neither `g_prime` nor `l_prime`): Conflict. Print \"NO\", exit.\n                *   If `exponents_p[neighbor]` is known and `exponents_p[neighbor] != target_exp`, conflict. Print \"NO\", exit.\n                *   If `exponents_p[neighbor]` is `-1`, set `exponents_p[neighbor] = target_exp` and add `neighbor` to `q`.\n\n    *   **Phase 3: DFS for Remaining Ambiguous Components (2-coloring):**\n        *   For `i` from 1 to `n`:\n            *   If `exponents_p[i]` is still `-1`: (This node is part of an unassigned component)\n                *   If `adj_p[i]` is empty: Set `exponents_p[i] = 0` (isolated nodes can have exponent 0, meaning `m_i` is not divisible by `p`).\n                *   Else:\n                    *   Pick an arbitrary neighbor `(neighbor, g_prime, l_prime)` from `adj_p[i]`.\n                    *   Set `exponents_p[i] = g_prime`. (Arbitrarily assign one of the two possible values).\n                    *   Use a stack for iterative DFS: `stack = [i]`\n                    *   While `stack` is not empty:\n                        *   `curr = stack.pop()`\n                        *   `curr_exp = exponents_p[curr]`\n                        *   For `neighbor, g_prime, l_prime` in `adj_p[curr]`:\n                            *   `target_exp = -1`\n                            *   If `curr_exp == g_prime`: `target_exp = l_prime`.\n                            *   Else if `curr_exp == l_prime`: `target_exp = g_prime`.\n                            *   Else: Conflict. Print \"NO\", exit.\n                            *   If `exponents_p[neighbor]` is `-1`:\n                                *   `exponents_p[neighbor] = target_exp`\n                                *   `stack.append(neighbor)`\n                            *   Else if `exponents_p[neighbor] != target_exp`: Conflict. Print \"NO\", exit.\n\n    *   **Phase 4: Update Final Mushroom Counts:**\n        *   For `i` from 1 to `n`:\n            *   If `exponents_p[i]` is still `-1` (meaning it was an isolated node for this prime and was not covered by the `adj_p[i]` empty check earlier), set `exponents_p[i] = 0`.\n            *   Multiply `final_m_values[i]` by `p ** exponents_p[i]`.\n\n4.  **Output:** If all primes are processed without conflict, print \"YES\" followed by the `n` mushroom counts `final_m_values[1]` to `final_m_values[n]`.\n\n**Complexity Analysis:**\n\n*   **Sieve:** `O(MAX_VAL * log log MAX_VAL)`, where `MAX_VAL = 10^6`.\n*   **Collecting Primes and Edges:** `O(M * log MAX_VAL)` for prime factorizations. `log MAX_VAL` is small (at most 7 distinct prime factors for a number up to `10^6`).\n*   **Solving for Each Prime:**\n    *   Let `P_count` be the number of distinct primes in `all_relevant_primes`. `P_count` can be at most `pi(10^6) approx 78498`.\n    *   For each prime `p`, the BFS/DFS steps iterate through nodes and edges. Each node and edge is visited at most a constant number of times. Total for one prime: `O(N + M)`.\n    *   Total for all primes: `O(P_count * (N + M))`.\n    *   Given `N, M <= 10000`, this is `78498 * (10000 + 10000) approx 1.5 * 10^9`, which is too slow.\n\n**Refined Optimization for Prime Processing:**\n\nThe `O(P_count * (N + M))` complexity is problematic. The issue is that `adj_p` and `exponents_p` are re-initialized for each prime, and we iterate over all `M` edges for each `p`.\n\nInstead of iterating through `all_relevant_primes` and then processing all `M` edges for each prime, we can group edges by prime.\n\nLet's maintain `prime_data = {}`. For each `p`, `prime_data[p]` will store:\n`{ 'exponents': [-1]*(n+1), 'ambiguous_edges': [[] for _ in range(n+1)], 'q': collections.deque() }`.\n\n1.  **Precomputation (Sieve):** Same as before.\n\n2.  **Process Edges and Populate `prime_data`:**\n    *   `final_m_values = [1] * (n + 1)`\n    *   For each edge `(u, v, g, l)` in `edge_list`:\n        *   If `l % g != 0`, print \"NO\", exit.\n        *   Get `prime_factors_g = get_prime_factorization(g)` and `prime_factors_l = get_prime_factorization(l)`.\n        *   `all_factors_for_edge = set(prime_factors_g.keys()) | set(prime_factors_l.keys())`\n        *   For each `p` in `all_factors_for_edge`:\n            *   If `p` not in `prime_data`, initialize `prime_data[p]` structure.\n            *   `g_p = prime_factors_g.get(p, 0)`\n            *   `l_p = prime_factors_l.get(p, 0)`\n            *   If `g_p == l_p`:\n                *   If `prime_data[p]['exponents'][u]` is known and `!= g_p`, conflict. Print \"NO\", exit.\n                *   If `prime_data[p]['exponents'][v]` is known and `!= g_p`, conflict. Print \"NO\", exit.\n                *   If `prime_data[p]['exponents'][u]` is `-1`, set `exponents[u] = g_p` and add `u` to `q`.\n                *   If `prime_data[p]['exponents'][v]` is `-1`, set `exponents[v] = g_p` and add `v` to `q`.\n            *   Else (`g_p < l_p`):\n                *   Add `(v, g_p, l_p)` to `prime_data[p]['ambiguous_edges'][u]` and vice versa.\n\n3.  **Solve for Each Prime (from `prime_data`):**\n    *   For each `p` in `prime_data.keys()`:\n        *   Retrieve `exponents_p`, `adj_p`, `q` from `prime_data[p]`.\n        *   Perform Phase 2 (BFS Propagation) using `q`, `exponents_p`, `adj_p`.\n        *   Perform Phase 3 (DFS for remaining ambiguous components) using `exponents_p`, `adj_p`.\n        *   Perform Phase 4 (Update `final_m_values`).\n\n**Revised Complexity:**\n\n*   **Step 2 (Populating `prime_data`):** Each edge `(u, v, g, l)` is processed once. For each edge, we factor `g` and `l`. The number of distinct prime factors for `g, l <= 10^6` is small (max 7). So, `log MAX_VAL` operations per edge. Total: `O(M * log MAX_VAL)`. Each prime factor leads to an update in `prime_data[p]`.\n*   **Step 3 (Solving for each prime):** Each entry in `prime_data[p]['ambiguous_edges']` is processed at most twice (once for BFS, once for DFS). Each node is visited at most twice. The sum of `(N + M_p_ambiguous)` over all primes `p` is `O(N * P_count + M * log MAX_VAL)`.\n    *   The `N * P_count` part is still problematic. `N` nodes, for each prime `p`, we might need to iterate `N` times to find unvisited nodes.\n\n**Final Optimization: Connected Components within Prime Subproblems**\n\nThe `N * P_count` term comes from iterating `for i from 1 to n` for each prime to find unvisited nodes. Instead, for each prime `p`, we only need to consider nodes that are *involved* in some edge for that prime.\n\nLet `nodes_involved_in_p = set()`. When populating `prime_data[p]`, add `u` and `v` to `nodes_involved_in_p`.\nThen, in Phase 3, iterate only `for i in nodes_involved_in_p`. This can greatly reduce the `N` factor for primes that only affect a few nodes.\n\nThe maximum number of distinct prime factors for a number up to `10^6` is 7. So `log MAX_VAL` is effectively a small constant.\nThe total number of `(u, v, g_p, l_p)` entries across all `adj_p` lists is `O(M * log MAX_VAL)`.\nThe total number of nodes that are `u` or `v` for *any* prime `p` is `O(N)`.\nThe sum of `(nodes_involved_in_p + edges_involved_in_p)` over all `p` is `O(N + M * log MAX_VAL)`.\nThis makes the overall complexity: `O(MAX_VAL * log log MAX_VAL + M * log MAX_VAL + N + M * log MAX_VAL) = O(MAX_VAL * log log MAX_VAL + N + M * log MAX_VAL)`.\nThis should be efficient enough. `10^6 * log log 10^6 + 10^4 + 10^4 * 7` is feasible.\n\n```python\nimport sys\nimport collections\n\n# Max value for GCD/LCM\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(num):\n    factors = collections.defaultdict(int)\n    if num == 0: # Handle 0 case if needed, though problem constraints say 1 <= GCD, LCM\n        return factors\n    temp_num = num\n    while temp_num > 1:\n        prime = spf[temp_num]\n        count = 0\n        while temp_num % prime == 0:\n            count += 1\n            temp_num //= prime\n        factors[prime] = count\n    return factors\n\n# Precompute sieve\nsieve()\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edge_list = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edge_list.append((u, v, g, l))\n\n    final_m_values = [1] * (n + 1)\n\n    # Store data for each prime\n    # prime_data[p] = {\n    #   'exponents': [-1]*(n+1),  # exponent of prime p for each node\n    #   'adj': [[] for _ in range(n+1)], # (neighbor, g_p, l_p) for ambiguous edges\n    #   'q': collections.deque(), # queue for BFS propagation\n    #   'involved_nodes': set() # nodes that have an edge involving this prime\n    # }\n    prime_data = {}\n\n    for u, v, g, l in edge_list:\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n\n        # Combine all primes relevant to this edge\n        all_factors_for_edge = set(factors_g.keys()) | set(factors_l.keys())\n\n        for p in all_factors_for_edge:\n            if p not in prime_data:\n                prime_data[p] = {\n                    'exponents': [-1] * (n + 1),\n                    'adj': [[] for _ in range(n + 1)],\n                    'q': collections.deque(),\n                    'involved_nodes': set()\n                }\n            \n            p_data = prime_data[p]\n            p_data['involved_nodes'].add(u)\n            p_data['involved_nodes'].add(v)\n\n            g_p = factors_g.get(p, 0)\n            l_p = factors_l.get(p, 0)\n\n            # Phase 1: Process fixed exponents and initial propagation\n            if g_p == l_p:\n                if p_data['exponents'][u] != -1 and p_data['exponents'][u] != g_p:\n                    print(\"NO\")\n                    return\n                if p_data['exponents'][v] != -1 and p_data['exponents'][v] != g_p:\n                    print(\"NO\")\n                    return\n                \n                if p_data['exponents'][u] == -1:\n                    p_data['exponents'][u] = g_p\n                    p_data['q'].append(u)\n                if p_data['exponents'][v] == -1:\n                    p_data['exponents'][v] = g_p\n                    p_data['q'].append(v)\n            else: # g_p < l_p, ambiguous edge\n                p_data['adj'][u].append((v, g_p, l_p))\n                p_data['adj'][v].append((u, g_p, l_p))\n\n    # Solve for each prime independently\n    for p in prime_data:\n        p_data = prime_data[p]\n        exponents_p = p_data['exponents']\n        adj_p = p_data['adj']\n        q = p_data['q']\n        involved_nodes = p_data['involved_nodes']\n\n        # Phase 2: BFS propagation for fixed values\n        while q:\n            curr = q.popleft()\n            fixed_exp = exponents_p[curr]\n\n            # Iterate through neighbors (ambiguous edges)\n            for neighbor, g_prime, l_prime in adj_p[curr]:\n                target_exp = -1\n                if fixed_exp == g_prime:\n                    target_exp = l_prime\n                elif fixed_exp == l_prime:\n                    target_exp = g_prime\n                else: # fixed_exp is neither g_prime nor l_prime, conflict\n                    print(\"NO\")\n                    return\n                \n                if exponents_p[neighbor] != -1 and exponents_p[neighbor] != target_exp:\n                    print(\"NO\")\n                    return\n                \n                if exponents_p[neighbor] == -1:\n                    exponents_p[neighbor] = target_exp\n                    q.append(neighbor)\n\n        # Phase 3: DFS for remaining ambiguous components (2-coloring)\n        for i in involved_nodes: # Only iterate through nodes involved with this prime\n            if exponents_p[i] == -1: # Unvisited and unfixed\n                # For isolated nodes in this prime's graph, set exponent to 0\n                if not adj_p[i]:\n                    exponents_p[i] = 0\n                    continue\n                \n                # Otherwise, start a DFS. Arbitrarily assign g_prime to i\n                # and propagate.\n                # Find an arbitrary edge to get g_prime, l_prime values\n                # This ensures we pick values relevant to the component\n                arbitrary_neighbor, g_prime_initial, l_prime_initial = adj_p[i][0]\n                exponents_p[i] = g_prime_initial # Arbitrary assignment\n                \n                stack = [i]\n                while stack:\n                    curr = stack.pop()\n                    curr_exp = exponents_p[curr]\n\n                    for neighbor, g_prime, l_prime in adj_p[curr]:\n                        target_exp = -1\n                        if curr_exp == g_prime:\n                            target_exp = l_prime\n                        elif curr_exp == l_prime:\n                            target_exp = g_prime\n                        else: # Conflict: curr_exp is not one of the allowed values for this edge\n                            print(\"NO\")\n                            return\n                        \n                        if exponents_p[neighbor] == -1:\n                            exponents_p[neighbor] = target_exp\n                            stack.append(neighbor)\n                        elif exponents_p[neighbor] != target_exp:\n                            print(\"NO\")\n                            return\n        \n        # Phase 4: Multiply exponents into final values\n        for i in involved_nodes:\n            if exponents_p[i] == -1: # Node was involved but isolated for this prime\n                exponents_p[i] = 0\n            final_m_values[i] *= (p ** exponents_p[i])\n        \n        # Nodes not involved in any edge for this prime will retain their initial 1\n        # and not have p as a factor, which is equivalent to exponent 0.\n\n    print(\"YES\")\n    print(*(final_m_values[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\n# Max value for GCD/LCM\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(num):\n    factors = collections.defaultdict(int)\n    if num == 0: # Handle 0 case if needed, though problem constraints say 1 <= GCD, LCM\n        return factors\n    temp_num = num\n    while temp_num > 1:\n        prime = spf[temp_num]\n        count = 0\n        while temp_num % prime == 0:\n            count += 1\n            temp_num //= prime\n        factors[prime] = count\n    return factors\n\n# Precompute sieve\nsieve()\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edge_list = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edge_list.append((u, v, g, l))\n\n    final_m_values = [1] * (n + 1)\n\n    # Store data for each prime\n    # prime_data[p] = {\n    #   'exponents': [-1]*(n+1),  # exponent of prime p for each node\n    #   'adj': [[] for _ in range(n+1)], # (neighbor, g_p, l_p) for ambiguous edges\n    #   'q': collections.deque(), # queue for BFS propagation\n    #   'involved_nodes': set() # nodes that have an edge involving this prime\n    # }\n    prime_data = {}\n\n    for u, v, g, l in edge_list:\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n\n        # Combine all primes relevant to this edge\n        all_factors_for_edge = set(factors_g.keys()) | set(factors_l.keys())\n\n        for p in all_factors_for_edge:\n            if p not in prime_data:\n                prime_data[p] = {\n                    'exponents': [-1] * (n + 1),\n                    'adj': [[] for _ in range(n + 1)],\n                    'q': collections.deque(),\n                    'involved_nodes': set()\n                }\n            \n            p_data = prime_data[p]\n            p_data['involved_nodes'].add(u)\n            p_data['involved_nodes'].add(v)\n\n            g_p = factors_g.get(p, 0)\n            l_p = factors_l.get(p, 0)\n\n            # Phase 1: Process fixed exponents and initial propagation\n            if g_p == l_p:\n                if p_data['exponents'][u] != -1 and p_data['exponents'][u] != g_p:\n                    print(\"NO\")\n                    return\n                if p_data['exponents'][v] != -1 and p_data['exponents'][v] != g_p:\n                    print(\"NO\")\n                    return\n                \n                if p_data['exponents'][u] == -1:\n                    p_data['exponents'][u] = g_p\n                    p_data['q'].append(u)\n                if p_data['exponents'][v] == -1:\n                    p_data['exponents'][v] = g_p\n                    p_data['q'].append(v)\n            else: # g_p < l_p, ambiguous edge\n                p_data['adj'][u].append((v, g_p, l_p))\n                p_data['adj'][v].append((u, g_p, l_p))\n\n    # Solve for each prime independently\n    for p in prime_data:\n        p_data = prime_data[p]\n        exponents_p = p_data['exponents']\n        adj_p = p_data['adj']\n        q = p_data['q']\n        involved_nodes = p_data['involved_nodes']\n\n        # Phase 2: BFS propagation for fixed values\n        while q:\n            curr = q.popleft()\n            fixed_exp = exponents_p[curr]\n\n            # Iterate through neighbors (ambiguous edges)\n            for neighbor, g_prime, l_prime in adj_p[curr]:\n                target_exp = -1\n                if fixed_exp == g_prime:\n                    target_exp = l_prime\n                elif fixed_exp == l_prime:\n                    target_exp = g_prime\n                else: # fixed_exp is neither g_prime nor l_prime, conflict\n                    print(\"NO\")\n                    return\n                \n                if exponents_p[neighbor] != -1 and exponents_p[neighbor] != target_exp:\n                    print(\"NO\")\n                    return\n                \n                if exponents_p[neighbor] == -1:\n                    exponents_p[neighbor] = target_exp\n                    q.append(neighbor)\n\n        # Phase 3: DFS for remaining ambiguous components (2-coloring)\n        for i in involved_nodes: # Only iterate through nodes involved with this prime\n            if exponents_p[i] == -1: # Unvisited and unfixed\n                # For isolated nodes in this prime's graph, set exponent to 0\n                if not adj_p[i]:\n                    exponents_p[i] = 0\n                    continue\n                \n                # Otherwise, start a DFS. Arbitrarily assign g_prime to i\n                # and propagate.\n                # Find an arbitrary edge to get g_prime, l_prime values\n                # This ensures we pick values relevant to the component\n                arbitrary_neighbor, g_prime_initial, l_prime_initial = adj_p[i][0]\n                exponents_p[i] = g_prime_initial # Arbitrary assignment\n                \n                stack = [i]\n                while stack:\n                    curr = stack.pop()\n                    curr_exp = exponents_p[curr]\n\n                    for neighbor, g_prime, l_prime in adj_p[curr]:\n                        target_exp = -1\n                        if curr_exp == g_prime:\n                            target_exp = l_prime\n                        elif curr_exp == l_prime:\n                            target_exp = g_prime\n                        else: # Conflict: curr_exp is not one of the allowed values for this edge\n                            print(\"NO\")\n                            return\n                        \n                        if exponents_p[neighbor] == -1:\n                            exponents_p[neighbor] = target_exp\n                            stack.append(neighbor)\n                        elif exponents_p[neighbor] != target_exp:\n                            print(\"NO\")\n                            return\n        \n        # Phase 4: Multiply exponents into final values\n        for i in involved_nodes:\n            if exponents_p[i] == -1: # Node was involved but isolated for this prime\n                exponents_p[i] = 0\n            final_m_values[i] *= (p ** exponents_p[i])\n        \n        # Nodes not involved in any edge for this prime will retain their initial 1\n        # and not have p as a factor, which is equivalent to exponent 0.\n\n    print(\"YES\")\n    print(*(final_m_values[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 5637,
        "thoughts_token_count": 7558
    }
}