{
    "start": 1758009325.2766175,
    "end": 1758009390.7031214,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Analyzing the Snowflake Structure for the Rudolf Problem**\n\nOkay, I'm diving into this \"Rudolf and Snowflakes (hard version)\" problem, and my initial thought is, let's break down this snowflake structure. I need a Python script to solve this, but first, I need to fully understand the relationships between the parameters.\n\nIt starts with a single center vertex. Then, in the first step, this center is connected to `k` new vertices, where `k` has to be greater than 1. So, we've got `1 + k` vertices right off the bat, with those `k` new vertices as leaves.\n\nNow, the problem introduces this iterative expansion rule: each leaf gets connected to `k` more vertices.  This step must occur at least once. I immediately see this generating levels in the snowflake.\n\nLet's trace this out. After the initial setup, with the `k` leaves, the first expansion step would result in `k * k = k^2` new vertices.  This takes those initial leaves off the status of leaves, but they are no longer leaves.  We then have `1 + k + k^2` vertices.\n\nNow, if we perform the expansion step again, we have `k * k^2 = k^3` new vertices, and so on.  This forms a geometric progression.\n\nIf we perform this expansion `d` times (with `d` being at least 1), the total number of vertices is clearly going to be the sum of a geometric series: `1 + k + k^2 + ... + k^d`.  I can write this as `(k^(d+1) - 1) / (k - 1)`.\n\nSo, the core of the problem is: given `n`, can I find integers `k > 1` and `d >= 1` such that `n = (k^(d+1) - 1) / (k - 1)`?  That's the key.  I now have the model I need to start writing the Python script to search for these parameters. I will need to iterate on `k` and `d` to see if a valid solution exists for the given value of `n`.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1.  Start with 1 central vertex.\n2.  Connect the central vertex to `k` new vertices, where `k > 1`.\n3.  Then, each vertex that is currently connected to only one other vertex (i.e., a leaf node) is connected to `k` more new vertices. This step must be done at least once.\n\nLet's analyze the number of vertices:\n*   Initially, 1 vertex.\n*   After step 2, we have 1 (center) + `k` (first level leaves) = `1 + k` vertices. These `k` vertices are leaves.\n*   Now, step 3 is applied. Let `d` be the number of times this step is performed. The problem states it must be done at least once, so `d >= 1`.\n    *   If `d = 1`: Each of the `k` leaves from the first level is connected to `k` new vertices. This adds `k * k = k^2` new vertices. Total vertices: `1 + k + k^2`. These `k^2` vertices are now the leaves.\n    *   If `d = 2`: The `k^2` leaves from the previous step each get `k` new vertices. This adds `k^2 * k = k^3` new vertices. Total vertices: `1 + k + k^2 + k^3`.\n    *   In general, if step 3 is performed `d` times, the total number of vertices will be `N = 1 + k + k^2 + ... + k^d`.\n\nThis is a geometric series sum. The formula for the sum is `N = (k^(d+1) - 1) / (k - 1)`.\nWe are given `n` and need to find if there exist integers `k > 1` and `d >= 1` such that `n = 1 + k + k^2 + ... + k^d`.\n\nLet's consider the possible values for `d`:\n\n**Case 1: `d = 1`**\n`n = 1 + k + k^2`.\nThis is a quadratic equation for `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4 * (1 - n))) / 2 = (-1 ± sqrt(1 - 4 + 4n)) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be an integer greater than 1, `4n - 3` must be a perfect square, say `s^2`.\nSo, `s = sqrt(4n - 3)`. Then `k = (-1 + s) / 2`. (We take the `+` sign because `k > 1`).\nFor `k` to be an integer, `s` must be an integer, and `s` must be odd (so `-1 + s` is even).\nIf `s` is an integer, `s^2 = 4n - 3`. Since `4n` is even, `4n - 3` is odd. The square of an integer is odd if and only if the integer itself is odd. So `s` will always be odd if `4n - 3` is a perfect square.\nThus, we just need to check if `4n - 3` is a perfect square `s^2` and if `k = (-1 + s) / 2 > 1`.\n`k > 1` implies `(-1 + s) / 2 > 1` => `-1 + s > 2` => `s > 3`.\nSo, for `d=1`, we check if `4n - 3` is a perfect square `s^2` where `s > 3`.\n\n**Case 2: `d >= 2`**\nFor `d >= 2`, `n = 1 + k + k^2 + ... + k^d`.\nSince `k > 1`, we can bound `n`:\n`k^d < n = 1 + k + ... + k^d < k^d + k^d + ... + k^d` (d+1 terms)\nThe upper bound is not tight. A better upper bound is `n = (k^(d+1) - 1) / (k - 1)`.\nFor `k >= 2`:\n`n = 1 + k + ... + k^d > k^d`. So `k < n^(1/d)`.\nAlso, `n = 1 + k + ... + k^d = 1 + k(1 + k + ... + k^(d-1))`.\nSince `k >= 2` and `d >= 2`:\n`n = 1 + k + k^2 + ... + k^d >= 1 + 2 + 2^2 = 7` (for `k=2, d=2`).\n`n = 1 + k + k^2 + ... + k^d < 1 + k + k^2 + ...` (infinite geometric series sum) `= 1 + k/(1-k)` if `k<1` which is not the case.\nA better upper bound for `n` when `k >= 2`:\n`n = (k^(d+1) - 1) / (k - 1)`.\nIf `k=2`, `n = 2^(d+1) - 1`.\nIf `k >= 3`, `k - 1 >= 2`. So `n = (k^(d+1) - 1) / (k - 1) <= (k^(d+1) - 1) / 2 < k^(d+1) / 2`.\nFrom `k^d < n`, we have `k < n^(1/d)`.\nThe maximum possible value for `d` is when `k` is minimal, i.e., `k=2`.\nIf `k=2`, `n = 2^(d+1) - 1`. For `n = 10^18`, `2^(d+1) - 1 = 10^18` implies `2^(d+1) approx 10^18`.\n`d+1 approx log2(10^18) = 18 * log2(10) approx 18 * 3.32 approx 59.79`. So `d+1` can be up to `59`.\nTherefore, `d` can be up to `58`.\n\nWe can iterate `d` from `2` up to `58`. For each `d`, we need to find `k` such that `k^d < n` and `n = 1 + k + ... + k^d`.\nSince `k < n^(1/d)`, `k` can be found using binary search.\nFor a fixed `d`, we are looking for `k` in the range `[2, floor(n^(1/d))]`.\nThe function `f(k) = 1 + k + ... + k^d` is monotonically increasing with `k`.\nSo we can binary search for `k` in the range `[2, 10^9]` (since `2^58` is roughly `2.8 * 10^17`, `k` won't exceed `10^9` for `d=2`, `k^2 < 10^18` implies `k < 10^9`).\nThe maximum value of `k` is `n-1` (when `d=1`, `n = 1+k+k^2`).\nFor `d=2`, `k^2 < n`. So `k < sqrt(n)`. If `n=10^18`, `k < 10^9`.\nBinary search range for `k`: `[2, 2 * 10^9]` (a safe upper bound, `10^9` is enough for `d=2`, but `k` can be larger if `n` is small, e.g., `n=13, d=1, k=3`). Let's use `[2, 10^9 + 7]` for `k`.\n\n**Algorithm:**\n1.  Handle `n < 7`: For `n=1,2,3,4,5,6`, the answer is \"NO\".\n    *   `1+k+k^2` (for `d=1`) requires `k >= 2`, so `1+2+2^2 = 7`. Minimum `n` for `d=1` is `7`.\n    *   `1+k+k^2+...+k^d` (for `d>=2`) also requires `k >= 2`, so `1+2+2^2 = 7`. Minimum `n` for `d>=2` is `7`.\n    *   Thus, if `n < 7`, it's always \"NO\".\n2.  Check for `d=1`:\n    *   Calculate `val = 4n - 3`.\n    *   If `val < 0`, it's not possible.\n    *   Calculate `s = int(sqrt(val))`.\n    *   If `s * s == val` and `s > 3` (which ensures `k = (-1 + s) / 2 > 1`), then `n` is a snowflake. Return \"YES\".\n3.  Iterate `d` from `2` to `58`.\n    *   For each `d`, perform a binary search for `k` in the range `[2, 2 * 10^9]` (or `[2, 10^9 + 7]` as a safer upper bound for `k`).\n    *   `low = 2`, `high = 2 * 10^9`.\n    *   While `low <= high`:\n        *   `mid = (low + high) // 2`.\n        *   Calculate `current_sum = 1 + mid + mid^2 + ... + mid^d`.\n            *   Be careful with overflow: `mid^d` can exceed `10^18` if `mid` is large and `d` is small. We need to check for `current_sum > n` during calculation.\n            *   A robust way to calculate `current_sum`:\n                `current_sum = 1`\n                `power_k = 1`\n                `for _ in range(d):`\n                    `if n // mid < power_k: # Check for overflow before multiplying power_k * mid`\n                        `power_k = n + 1 # Mark as overflow`\n                        `break`\n                    `power_k *= mid`\n                    `if n - current_sum < power_k: # Check for overflow before adding`\n                        `current_sum = n + 1 # Mark as overflow`\n                        `break`\n                    `current_sum += power_k`\n        *   If `current_sum == n`: `n` is a snowflake. Return \"YES\".\n        *   If `current_sum < n`: `k` is too small, increase `low = mid + 1`.\n        *   If `current_sum > n`: `k` is too large, decrease `high = mid - 1`.\n4.  If no `k` and `d` are found after all checks, return \"NO\".\n\n**Optimization for `d >= 2` loop:**\nThe maximum value for `d` is `58`.\nThe maximum value for `k` is `n^(1/d)`.\nFor `d=2`, `k < sqrt(10^18) = 10^9`. Binary search up to `10^9`.\nFor `d=3`, `k < (10^18)^(1/3) = 10^6`. Binary search up to `10^6`.\nFor `d=4`, `k < (10^18)^(1/4) = 10^(4.5) approx 31622`. Binary search up to `31622`.\nFor `d=5`, `k < (10^18)^(1/5) = 10^(3.6) approx 3981`. Binary search up to `3981`.\nFor `d=6`, `k < (10^18)^(1/6) = 10^3 = 1000`. Binary search up to `1000`.\nFor `d=7`, `k < (10^18)^(1/7) approx 520`.\nFor `d=58`, `k < (10^18)^(1/58) approx 2.000...`. So `k` can only be `2`.\n\nThe binary search for `k` can be optimized by setting `high` to `int(n**(1/d)) + 2` (add a small margin for floating point inaccuracies). This makes the `high` value much smaller for larger `d`.\n\nExample `n=13`:\n1. `n=13 >= 7`.\n2. `d=1`: `val = 4*13 - 3 = 52 - 3 = 49`. `s = int(sqrt(49)) = 7`.\n   `s*s == 49` is true. `s=7 > 3` is true.\n   So `k = (-1 + 7) / 2 = 3`. `k=3 > 1`.\n   `n=13` is a snowflake. Output \"YES\".\n\nExample `n=255`:\n1. `n=255 >= 7`.\n2. `d=1`: `val = 4*255 - 3 = 1020 - 3 = 1017`. `s = int(sqrt(1017))`. `sqrt(1017)` is approx `31.89`. Not a perfect square.\n3. `d=2`: `low=2, high=sqrt(255)+2 approx 15+2=17`.\n   Try `k=5`: `1+5+5^2 = 1+5+25 = 31`. Too small. `low=6`.\n   Try `k=10`: `1+10+10^2 = 1+10+100 = 111`. Too small. `low=11`.\n   Try `k=15`: `1+15+15^2 = 1+15+225 = 241`. Too small. `low=16`.\n   Try `k=16`: `1+16+16^2 = 1+16+256 = 273`. Too large. `high=15`.\n   `low > high`, so no `k` for `d=2`.\n4. `d=3`: `low=2, high=(255**(1/3))+2 approx 6+2=8`.\n   Try `k=3`: `1+3+3^2+3^3 = 1+3+9+27 = 40`. Too small. `low=4`.\n   Try `k=4`: `1+4+4^2+4^3 = 1+4+16+64 = 85`. Too small. `low=5`.\n   Try `k=5`: `1+5+5^2+5^3 = 1+5+25+125 = 156`. Too small. `low=6`.\n   Try `k=6`: `1+6+6^2+6^3 = 1+6+36+216 = 259`. Too large. `high=5`.\n   `low > high`, so no `k` for `d=3`.\n5. `d=4`: `low=2, high=(255**(1/4))+2 approx 3+2=5`.\n   Try `k=3`: `1+3+3^2+3^3+3^4 = 1+3+9+27+81 = 121`. Too small. `low=4`.\n   Try `k=4`: `1+4+4^2+4^3+4^4 = 1+4+16+64+256 = 341`. Too large. `high=3`.\n   `low > high`, so no `k` for `d=4`.\n6. `d=5`: `low=2, high=(255**(1/5))+2 approx 3+2=5`.\n   Try `k=3`: `1+3+3^2+3^3+3^4+3^5 = 121 + 243 = 364`. Too large. `high=2`.\n   Try `k=2`: `1+2+2^2+2^3+2^4+2^5 = 1+2+4+8+16+32 = 63`. Too small. `low=3`.\n   `low > high`, so no `k` for `d=5`.\n7. `d=6`: `low=2, high=(255**(1/6))+2 approx 2+2=4`.\n   Try `k=2`: `1+2+...+2^6 = 2^7 - 1 = 128 - 1 = 127`. Too small. `low=3`.\n   Try `k=3`: `1+3+...+3^6 = (3^7-1)/2 = (2187-1)/2 = 1093`. Too large. `high=2`.\n   `low > high`, so no `k` for `d=6`.\n8. ...\n9. `d=7`: `low=2, high=(255**(1/7))+2 approx 2+2=4`.\n   Try `k=2`: `1+2+...+2^7 = 2^8 - 1 = 256 - 1 = 255`. Found! `k=2, d=7`.\n   Output \"YES\".\n\nFinal check on edge case `n=1`. `n<7` is true, so \"NO\". Correct.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    if n < 7: # Minimum possible snowflake is 1+2+2^2 = 7\n        print(\"NO\")\n        return\n\n    # Case d = 1: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1-n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    val_d1 = 4 * n - 3\n    s = int(math.isqrt(val_d1)) # Use math.isqrt for integer square root\n    if s * s == val_d1:\n        # For k to be an integer, s must be odd. 4n-3 is always odd, so s is always odd if it's a perfect square.\n        # We need k > 1, so (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n        if s > 3:\n            print(\"YES\")\n            return\n\n    # Case d >= 2: n = 1 + k + k^2 + ... + k^d\n    # Max d is around 58 (for k=2, 2^59 - 1 approx 10^18)\n    # Max k for d=2 is sqrt(n) approx 10^9\n    \n    # Iterate d from 2 up to a reasonable limit (e.g., 60)\n    # The upper bound for d is when k=2, 2^(d+1)-1 <= 10^18 => d+1 <= log2(10^18+1) approx 59.79, so d <= 58.\n    for d in range(2, 60):\n        # Binary search for k\n        # k must be >= 2\n        # k^d < n, so k < n^(1/d). We can set a tighter upper bound for binary search.\n        # A safe upper bound for k for n=10^18, d=2 is 10^9. For larger d, it's smaller.\n        # Let's use 2 * 10^9 as a general high for k, it's sufficient and safe.\n        low = 2\n        # Upper bound for k: n = (k^(d+1) - 1) / (k - 1) > k^d. So k < n^(1/d).\n        # For n=10^18, d=2, k < 10^9. For d=58, k < 2.\n        # A common value for high is 2 * 10^9, it covers all cases of k.\n        # A slightly tighter bound, to avoid unnecessary iterations, can be derived from k^d < n.\n        # k < n^(1/d). For n=10^18, d=2, k < 10^9. For d=3, k < 10^6. For d=58, k < 2.\n        # Let's use a dynamic high that is slightly larger than n^(1/d) to account for floating point inaccuracies.\n        # The true upper bound for k is roughly n-1 when d=1. But for d>=2, k is much smaller.\n        # max_k_for_d = int(n**(1/d)) + 2 # This might be slightly off due to float precision\n        # For n=10^18, d=2, max_k_for_d is about 10^9.\n        # For n=10^18, d=58, max_k_for_d is about 2+2=4.\n        # This dynamic high is good. Let's use 2*10^9 as a safe upper limit to avoid issues with n**(1/d) for small n.\n        # For example, if n is small, n**(1/d) might be 1, so low=2, high=1 might be an issue.\n        # The smallest n is 7. For n=7, d=2, 7**(1/2) approx 2.6. high=4. So range [2,4].\n        # For n=7, d=2, k=2: 1+2+2^2 = 7. Found.\n        high = min(2 * 10**9, n) # k cannot be larger than n itself. And k is usually much smaller.\n\n        found_k = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            power_of_k = 1 # This stores mid_k^i\n            \n            # Calculate 1 + mid_k + mid_k^2 + ... + mid_k^d\n            # Check for overflow at each step\n            overflow = False\n            for _ in range(d):\n                # Check for overflow when multiplying power_of_k by mid_k\n                # If power_of_k * mid_k > n, then power_of_k > n / mid_k\n                if mid_k == 0: # Avoid division by zero, though mid_k >= 2\n                    overflow = True\n                    break\n                if n // mid_k < power_of_k: # power_of_k * mid_k would exceed n\n                    overflow = True\n                    break\n                power_of_k *= mid_k\n                \n                # Check for overflow when adding to current_sum\n                # If current_sum + power_of_k > n, then power_of_k > n - current_sum\n                if n - current_sum < power_of_k:\n                    overflow = True\n                    break\n                current_sum += power_of_k\n            \n            if overflow: # mid_k is too large, sum exceeded n\n                high = mid_k - 1\n            elif current_sum == n:\n                found_k = True\n                break\n            elif current_sum < n: # mid_k is too small\n                low = mid_k + 1\n            else: # current_sum > n (and no overflow in calculation means it was strictly greater than n)\n                high = mid_k - 1\n        \n        if found_k:\n            print(\"YES\")\n            return\n            \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    if n < 7: # Minimum possible snowflake is 1+2+2^2 = 7\n        print(\"NO\")\n        return\n\n    # Case d = 1: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1-n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    val_d1 = 4 * n - 3\n    s = int(math.isqrt(val_d1)) # Use math.isqrt for integer square root\n    if s * s == val_d1:\n        # For k to be an integer, s must be odd. 4n-3 is always odd, so s is always odd if it's a perfect square.\n        # We need k > 1, so (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n        if s > 3:\n            print(\"YES\")\n            return\n\n    # Case d >= 2: n = 1 + k + k^2 + ... + k^d\n    # Max d is around 58 (for k=2, 2^59 - 1 approx 10^18)\n    # Max k for d=2 is sqrt(n) approx 10^9\n    \n    # Iterate d from 2 up to a reasonable limit (e.g., 60)\n    # The upper bound for d is when k=2, 2^(d+1)-1 <= 10^18 => d+1 <= log2(10^18+1) approx 59.79, so d <= 58.\n    for d in range(2, 60):\n        # Binary search for k\n        # k must be >= 2\n        # k^d < n, so k < n^(1/d). We can set a tighter upper bound for binary search.\n        # A safe upper bound for k for n=10^18, d=2 is 10^9. For larger d, it's smaller.\n        # Let's use 2 * 10^9 as a general high for k, it's sufficient and safe.\n        low = 2\n        # Upper bound for k: n = (k^(d+1) - 1) / (k - 1) > k^d. So k < n^(1/d).\n        # For n=10^18, d=2, k < 10^9. For d=58, k < 2.\n        # A common value for high is 2 * 10^9, it covers all cases of k.\n        # A slightly tighter bound, to avoid unnecessary iterations, can be derived from k^d < n.\n        # k < n^(1/d). For n=10^18, d=2, k < 10^9. For d=3, k < 10^6. For d=58, k < 2.\n        # Let's use a dynamic high that is slightly larger than n^(1/d) to account for floating point inaccuracies.\n        # The true upper bound for k is roughly n-1 when d=1. But for d>=2, k is much smaller.\n        # max_k_for_d = int(n**(1/d)) + 2 # This might be slightly off due to float precision\n        # For n=10^18, d=2, max_k_for_d is about 10^9.\n        # For n=10^18, d=58, max_k_for_d is about 2+2=4.\n        # This dynamic high is good. Let's use 2*10^9 as a safe upper limit to avoid issues with n**(1/d) for small n.\n        # For example, if n is small, n**(1/d) might be 1, so low=2, high=1 might be an issue.\n        # The smallest n is 7. For n=7, d=2, 7**(1/2) approx 2.6. high=4. So range [2,4].\n        # For n=7, d=2, k=2: 1+2+2^2 = 7. Found.\n        high = min(2 * 10**9, n) # k cannot be larger than n itself. And k is usually much smaller.\n\n        found_k = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            power_of_k = 1 # This stores mid_k^i\n            \n            # Calculate 1 + mid_k + mid_k^2 + ... + mid_k^d\n            # Check for overflow at each step\n            overflow = False\n            for _ in range(d):\n                # Check for overflow when multiplying power_of_k by mid_k\n                # If power_of_k * mid_k > n, then power_of_k > n / mid_k\n                if mid_k == 0: # Avoid division by zero, though mid_k >= 2\n                    overflow = True\n                    break\n                if n // mid_k < power_of_k: # power_of_k * mid_k would exceed n\n                    overflow = True\n                    break\n                power_of_k *= mid_k\n                \n                # Check for overflow when adding to current_sum\n                # If current_sum + power_of_k > n, then power_of_k > n - current_sum\n                if n - current_sum < power_of_k:\n                    overflow = True\n                    break\n                current_sum += power_of_k\n            \n            if overflow: # mid_k is too large, sum exceeded n\n                high = mid_k - 1\n            elif current_sum == n:\n                found_k = True\n                break\n            elif current_sum < n: # mid_k is too small\n                low = mid_k + 1\n            else: # current_sum > n (and no overflow in calculation means it was strictly greater than n)\n                high = mid_k - 1\n        \n        if found_k:\n            print(\"YES\")\n            return\n            \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 5827,
        "thoughts_token_count": 815
    }
}