{
    "start": 1758284874.5444455,
    "end": 1758284889.4788032,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Neko's Math Problem: Minimizing the LCM**\n\nOkay, so I'm tackling this \"Neko does Maths\" problem. The goal is to find the smallest non-negative integer `k` that minimizes the least common multiple (LCM) of `a+k` and `b+k`.  My initial thought is to work with the LCM formula: `lcm(x, y) = (x * y) / gcd(x, y)`. Let `x = a+k` and `y = b+k`.  This translates to minimizing `((a+k) * (b+k)) / gcd(a+k, b+k)`.\n\nThe key here, I think, lies in understanding how the greatest common divisor (GCD) changes with `k`.  I can use the property: `gcd(x, y) = gcd(x, y-x)`. Applying this, `gcd(a+k, b+k)` simplifies to `gcd(a+k, b-a)`.  Let's call `d = b-a`.  I can assume `a <= b` because the LCM is symmetric, and the `a=b` case is trivial; the smallest `k` is just 0.\n\nNow, the problem is about minimizing `((a+k) * (b+k)) / gcd(a+k, d)`.  Let `g = gcd(a+k, d)`.  This is crucial: `g` must be a divisor of `d`. Also,  `a+k` must be a multiple of `g`. So, `a+k = m * g` for some integer `m`. Which means `k = m * g - a`. Since `k >= 0`, `m * g >= a`.\n\nSince I'm trying to minimize, I'm thinking I'll need to iterate over possible `k` values, but only the ones that lead to `g` being a divisor of `d`.  The number of divisors of `d` (which can be as large as `10^9 - 1`) is the bottleneck, but it's finite.  The crucial step is iterating through the divisors of `d`. The rest is a straightforward calculation for each divisor.\n",
    "response": "```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a < b for consistent d = b - a > 0\n    if a > b:\n        a, b = b, a\n\n    d = b - a\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find all divisors of d\n    divisors = set()\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n\n    for g in divisors:\n        # We need a+k to be a multiple of g.\n        # Let a+k = m*g for some integer m.\n        # k = m*g - a.\n        # We need k >= 0, so m*g >= a.\n        # The smallest non-negative k for a given g is when m*g is the smallest multiple of g that is >= a.\n        \n        # This can be found by:\n        # If a is already a multiple of g, then a = q*g. We can choose m=q, so a+k = a, meaning k=0.\n        # If a is not a multiple of g, then a = q*g + r, where 0 < r < g.\n        # The smallest multiple of g that is >= a is (q+1)*g.\n        # So a+k = (q+1)*g.\n        # This is equivalent to: a+k must be a multiple of g.\n        # The remainder of (a+k) when divided by g must be 0.\n        # (a+k) % g == 0\n        # (a % g + k % g) % g == 0\n        # If a % g == 0, then k % g == 0. Smallest k is 0.\n        # If a % g != 0, then k % g must be (g - (a % g)). Smallest k is (g - (a % g)).\n        \n        remainder_a = a % g\n        \n        current_k = 0\n        if remainder_a != 0:\n            current_k = g - remainder_a\n        \n        # Calculate x = a+k and y = b+k\n        x = a + current_k\n        y = b + current_k\n        \n        # Since gcd(x, d) = g, and d = b-a, it implies gcd(x, y) = g.\n        # lcm(x, y) = (x * y) / gcd(x, y)\n        current_lcm = (x // g) * y # Use (x/g)*y to prevent overflow if x*y is too large.\n                                    # This is safe because x is a multiple of g.\n        \n        # Update min_lcm and best_k\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            # If multiple k values give the same minimum LCM, choose the smallest k.\n            # Our current_k calculation already ensures we find the smallest k for a given g.\n            # So if current_lcm == min_lcm, we only update if current_k is smaller.\n            # This is implicitly handled by iterating through g values.\n            # The first time we hit the min_lcm, its k will be stored.\n            # If another g gives the same min_lcm, its k might be smaller or larger.\n            # We need to explicitly check.\n            best_k = min(best_k, current_k)\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a < b for consistent d = b - a > 0\n    if a > b:\n        a, b = b, a\n\n    d = b - a\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find all divisors of d\n    divisors = set()\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n\n    for g in divisors:\n        # We need a+k to be a multiple of g.\n        # Let a+k = m*g for some integer m.\n        # k = m*g - a.\n        # We need k >= 0, so m*g >= a.\n        # The smallest non-negative k for a given g is when m*g is the smallest multiple of g that is >= a.\n        \n        # This can be found by:\n        # If a is already a multiple of g, then a = q*g. We can choose m=q, so a+k = a, meaning k=0.\n        # If a is not a multiple of g, then a = q*g + r, where 0 < r < g.\n        # The smallest multiple of g that is >= a is (q+1)*g.\n        # So a+k = (q+1)*g.\n        # This is equivalent to: a+k must be a multiple of g.\n        # The remainder of (a+k) when divided by g must be 0.\n        # (a+k) % g == 0\n        # (a % g + k % g) % g == 0\n        # If a % g == 0, then k % g == 0. Smallest k is 0.\n        # If a % g != 0, then k % g must be (g - (a % g)). Smallest k is (g - (a % g)).\n        \n        remainder_a = a % g\n        \n        current_k = 0\n        if remainder_a != 0:\n            current_k = g - remainder_a\n        \n        # Calculate x = a+k and y = b+k\n        x = a + current_k\n        y = b + current_k\n        \n        # Since gcd(x, d) = g, and d = b-a, it implies gcd(x, y) = g.\n        # lcm(x, y) = (x * y) / gcd(x, y)\n        current_lcm = (x // g) * y # Use (x/g)*y to prevent overflow if x*y is too large.\n                                    # This is safe because x is a multiple of g.\n        \n        # Update min_lcm and best_k\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            # If multiple k values give the same minimum LCM, choose the smallest k.\n            # Our current_k calculation already ensures we find the smallest k for a given g.\n            # So if current_lcm == min_lcm, we only update if current_k is smaller.\n            # This is implicitly handled by iterating through g values.\n            # The first time we hit the min_lcm, its k will be stored.\n            # If another g gives the same min_lcm, its k might be smaller or larger.\n            # We need to explicitly check.\n            best_k = min(best_k, current_k)\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 899,
        "thoughts_token_count": 702
    }
}