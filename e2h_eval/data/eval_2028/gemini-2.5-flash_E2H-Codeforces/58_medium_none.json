{
    "start": 1758294826.1506603,
    "end": 1758294947.9849527,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Solving the Competitive Programming Problem: A Detailed Thought Process**\n\nAlright, here's how I'm tackling this competitive programming challenge. The objective is to find `t`, the minimum number of edges to add, and `w`, the number of ways to add those edges, to form a simple cycle of odd length in a given graph. No loops or parallel edges are allowed.\n\nMy initial approach is to break down the problem. An odd-length cycle means the graph isn't bipartite. If the graph already has an odd cycle, `t` is 0, and `w` is 1 – the simplest case! To check for bipartiteness, I can use Breadth-First Search (BFS) or Depth-First Search (DFS) for 2-coloring. If I find an edge connecting vertices with the same color during this process, I've got my odd cycle.\n\nIf the graph *is* bipartite, `t` will be greater than 0. I need to add edges to create that odd cycle. If I add an edge between two vertices with the same color within the same connected component, that'll do the trick. `t` would then be 1. The key is that the distance between these two vertices must be at least 2 for the cycle to be considered 'odd'.\n\nWhen `t=1`, I'm looking for pairs of vertices with the same color that aren't already connected, and adding an edge between them creates an odd cycle. I can sum over the number of such pairs within each connected component to find the ways to do this (`w`).\n\nIf I find that `t` must be greater than 1, it implies that the graph is essentially disconnected, and contains at most an edge per component. I would need to find how many different triangles I can form in this scenario to determine `w`.\n\nI need to be extra cautious about handling small graphs. For instance, if `n=2` and the vertices are disconnected, adding an edge would create a cycle of length 2, not an odd cycle. It seems like the basic assumption here is that vertices within the same connected component would be connected in a graph. For `t = 2` there are three vertices A, B, and C that make a triangle and it involves finding `C` such that edges `(A,C)` and `(B,C)` do not exist, where edge `(A,B)` does exist, to connect an odd cycle of length 3. This means one of the edges is already present.\n",
    "response": "The problem asks us to find the minimum number of edges `t` that must be added to a given undirected graph to form a simple cycle of odd length (greater than one vertex), and `w`, the number of ways to add these `t` edges. Loops and parallel edges are prohibited.\n\nFirst, let's understand the properties of odd-length cycles. A graph contains an odd-length cycle if and only if it is not bipartite.\n\nWe can use a 2-coloring algorithm (like BFS or DFS) to check if the graph is bipartite. We iterate through all connected components. For each unvisited vertex, we start a traversal, assigning it color 0. Its neighbors get color 1, their neighbors get color 0, and so on.\n\nLet `adj` be the adjacency list representation of the graph.\n`colors` array stores the color of each vertex (0 or 1, or -1 if unvisited).\n`is_bipartite` flag, initially true.\n\n**Step 1: Check for existing odd cycles (t = 0)**\nIterate `i` from 1 to `n`:\n  If `colors[i]` is -1 (vertex `i` is unvisited):\n    Start a BFS/DFS from `i`.\n    `q = deque([(i, 0)])` (vertex, color)\n    `colors[i] = 0`\n    While `q` is not empty:\n      `u, c_u = q.popleft()`\n      For each neighbor `v` of `u`:\n        If `colors[v]` is -1:\n          `colors[v] = 1 - c_u`\n          `q.append((v, 1 - c_u))`\n        Else if `colors[v] == c_u`:\n          `is_bipartite = False`\n          Break (from inner loop)\n    If not `is_bipartite`: Break (from outer loop)\n\nIf `is_bipartite` is `False` after checking all components, it means the original graph already contains an odd cycle.\nIn this case, `t = 0` and `w = 1`.\n\n**Step 2: If the graph is bipartite, try t = 1**\nIf the graph is bipartite, we need to add at least one edge. The minimum number of edges to add to create an odd cycle is 1.\nAdding an edge `(u, v)` to a bipartite graph creates an odd cycle if and only if `u` and `v` have the same color.\nFor the cycle to be \"simple\" and \"consisting of more than one vertex\", its length must be at least 3.\nIf `u` and `v` are in the same connected component and have the same color, there must be a path `P` between them in the original graph. Since they have the same color, `P` must have an even length. As `u` and `v` are distinct, `length(P) >= 2`. Adding `(u, v)` forms a cycle `P + (u,v)` of length `length(P) + 1`. This length will be odd and `length(P) + 1 >= 3`. This is a valid odd cycle.\nIf `u` and `v` are in different connected components, adding `(u,v)` connects them. If they have the same color, this forms a cycle of length 2 (`u-v-u`). A cycle of length 2 is not an odd cycle. Therefore, for `t=1`, `u` and `v` must be in the same connected component.\n\nLet's calculate `w` for `t=1`:\nFor each connected component `C_i`:\n  During the 2-coloring, we count vertices of color 0 (`count0_i`) and color 1 (`count1_i`).\n  The number of ways to pick two distinct vertices of the same color within `C_i` is `count0_i * (count0_i - 1) / 2 + count1_i * (count1_i - 1) / 2`.\n  Sum these counts over all connected components. Let this sum be `w_1`.\n\nIf `w_1 > 0`, then `t = 1` and `w = w_1`.\n\n**Step 3: If t = 1 is not possible (w_1 = 0), try t = 2**\nIf `w_1 = 0`, it means for every connected component `C_i`, `count0_i < 2` AND `count1_i < 2`.\nThis implies that every connected component has at most 2 vertices.\nPossible components:\n  - An isolated vertex (`K_1`): `count0_i=1, count1_i=0` (or vice versa).\n  - An edge (`K_2`): `count0_i=1, count1_i=1`.\nIn this scenario, we need to add at least 2 edges to form an odd cycle of length at least 3. The smallest such cycle is a triangle (length 3).\nTo form a triangle `A-B-C-A` by adding `t=2` edges, one edge must already exist, say `(A,B)`. We add `(B,C)` and `(C,A)`.\nSince `(A,B)` is an existing edge in a bipartite graph, `A` and `B` must have different colors. Let `A` be color 0 and `B` be color 1.\nFor `A-B-C-A` to be an odd cycle, `C` must have the same color as `A` (color 0) or the same color as `B` (color 1). If `C` has the same color as `A` (color 0), then `(A,C)` would connect same-colored vertices (odd path length), and `(B,C)` would connect different-colored vertices (even path length). The cycle `A-C-B-A` would be `(A,C)` (added) + `(C,B)` (added) + `(B,A)` (existing). Length 3. This is an odd cycle.\nConditions for adding `(B,C)` and `(C,A)`:\n1. `A, B, C` must be distinct vertices.\n2. `(A,B)` must be an existing edge.\n3. `(B,C)` must not be an existing edge.\n4. `(C,A)` must not be an existing edge.\n\nLet's count ways for `t=2`:\nSum over all `m` existing edges `(u,v)`:\n  Assume `u` is color 0, `v` is color 1 (or vice versa, it's symmetric).\n  We need to find a third vertex `x` of color 0 such that `x \\neq u`, `x \\neq v`.\n  And `(u,x)` and `(v,x)` must not be existing edges.\n  Since `u` and `x` are both color 0, `(u,x)` cannot be an existing edge in a bipartite graph.\n  So we only need to check that `(v,x)` is not an existing edge.\n\nLet `N0` be the total count of vertices of color 0 across all components, and `N1` be the total count of vertices of color 1.\nFor each edge `(u,v)` in the graph:\n  Assume `u` is color 0 and `v` is color 1.\n  We need to choose a vertex `x` of color 0 such that `x \\neq u` and `x` is not a neighbor of `v`.\n  Number of vertices of color 0 is `N0`.\n  We exclude `u` from choices for `x`: `N0 - 1` candidates.\n  From these `N0 - 1` candidates, we must exclude neighbors of `v`. All neighbors of `v` are color 0.\n  So, the number of valid `x` vertices is `(N0 - 1) - (\\text{degree of } v \\text{ in color 0, excluding } u)`.\n  Since `u` is a neighbor of `v` and `u` is color 0, the number of color 0 neighbors of `v` other than `u` is `deg(v) - 1`.\n  So, for this edge `(u,v)`, the number of ways is `(N0 - 1) - (deg(v) - 1) = N0 - deg(v)`.\n  This calculation is symmetric for `u` color 1, `v` color 0, by using `N1` and `deg(u)`.\n\nTotal `w_2 = \\sum_{(u,v) \\in E} (N_c(u) - \\text{deg}(v))` where `N_c(u)` is the total count of vertices with the same color as `u`.\n`N_c(u)` is `N0` if `u` is color 0, `N1` if `u` is color 1.\nThis sum is `sum_{u \\text{ color 0}, v \\text{ color 1}} (N0 - deg(v)) + sum_{u \\text{ color 1}, v \\text{ color 0}} (N1 - deg(u))`.\nThis counts each pair `(u,v)` once.\nThis `w_2` is the answer for `t=2`.\n\n**Step 4: If t = 2 is not possible (w_2 = 0), try t = 3**\nIf `w_2 = 0`, it means `N0 - deg(v) <= 0` for all `v`, and `N1 - deg(u) <= 0` for all `u`.\nThis implies `N0 <= deg(v)` for all `v` of color 1, and `N1 <= deg(u)` for all `u` of color 0.\nThis is a very dense graph structure. It essentially means that every vertex `v` of color 1 is connected to almost all vertices of color 0 (except possibly `u` if `N0 = deg(v)`).\nIn this case, we need to add `t=3` edges.\nThe simplest way to form an odd cycle with 3 added edges is to pick 3 distinct vertices `A, B, C` that are not connected to each other, and add edges `(A,B), (B,C), (C,A)`.\nFor this cycle to be odd, `A, B, C` must all be of the same color.\nSuppose all three are color 0. The number of ways to pick three distinct vertices of color 0 is `N0 * (N0 - 1) * (N0 - 2) / 6`.\nSimilarly, for color 1: `N1 * (N1 - 1) * (N1 - 2) / 6`.\nTotal `w_3 = N0 * (N0 - 1) * (N0 - 2) / 6 + N1 * (N1 - 1) * (N1 - 2) / 6`.\nThis assumes `N0 >= 3` or `N1 >= 3`. If `N0 < 3` and `N1 < 3`, then `w_3=0`.\nIf `w_3 > 0`, then `t=3` and `w = w_3`.\n\nWhat if `w_3 = 0`? This means `N0 < 3` AND `N1 < 3`.\nSince `n = N0 + N1`, this implies `n < 6`.\nIf `n < 3`, no cycle of length 3 is possible.\nIf `n = 3`: `N0=2, N1=1` or `N0=1, N1=2`. `w_3=0`.\n  Example: `n=3`, `1,2,3` are isolated. `N0=3, N1=0`. `w_3 = 3*2*1/6 = 1`. Add `(1,2), (2,3), (3,1)`. `t=3, w=1`. This is valid.\n  The condition `w_3=0` for `t=3` only happens if `N0 < 3` and `N1 < 3`.\n  This means `n` is at most 4.\n  If `n=0,1,2`, no cycle of length 3 is possible.\n  If `n=3`:\n    `N0=2, N1=1`. `w_3=0`.\n    `N0=1, N1=2`. `w_3=0`.\n  If `n=4`:\n    `N0=2, N1=2`. `w_3=0`.\n    `N0=3, N1=1`. `w_3=1` (3 vertices of color 0).\n    `N0=1, N1=3`. `w_3=1` (3 vertices of color 1).\n  So, if `w_3 = 0`, it means `n <= 4` and `N0, N1` are such that no 3 vertices of the same color exist.\n  In this case, it's impossible to form a triangle by adding 3 edges.\n  However, `t=3` is the maximum possible `t` for a cycle of length 3.\n  If `n < 3`, no cycle of length 3 or more is possible. But the problem guarantees `n >= 1`.\n  The minimum cycle length is 3.\n  If `n < 3`, no cycle of odd length > 1 can be formed. The problem states \"consisting of more than one vertex\".\n  If `n=1`, `t` and `w` are undefined.\n  If `n=2`, `1-2` is an even cycle. No odd cycle.\n  If `n=0`, no cycle.\n  The problem states `n` up to `2*10^5`. So `n` can be small.\n  If `n < 3`, it's impossible to form an odd cycle of length >= 3.\n  In competitive programming, usually `n >= 3` is implicitly assumed for cycle problems, or specific output for `n < 3` is requested.\n  The example `3 0` output `3 1` means `n=3, m=0`.\n  `N0=3, N1=0` (all 3 vertices isolated, assigned color 0).\n  `t=0` fails. `t=1` fails (`w_1=0`). `t=2` fails (`w_2=0`).\n  `t=3`: `N0=3, N1=0`. `w_3 = 3*(3-1)*(3-2)/6 + 0 = 1`.\n  So `t=3, w=1` is correct for `n=3, m=0`.\n\nFinal logic:\n1.  Initialize `colors` array to -1. `is_bipartite = True`.\n2.  Perform 2-coloring for all connected components. If `is_bipartite` becomes `False`, output `0 1` and terminate.\n3.  Calculate `w_1`:\n    `w_1 = 0`.\n    For each component `C_i`:\n      `w_1 += count0_i * (count0_i - 1) // 2 + count1_i * (count1_i - 1) // 2`.\n    If `w_1 > 0`, output `1 w_1` and terminate.\n4.  Calculate `w_2`:\n    `N0 = sum(count0_i)` over all components.\n    `N1 = sum(count1_i)` over all components.\n    `w_2 = 0`.\n    For each edge `(u,v)` in the input graph:\n      If `colors[u] == 0`: `w_2 += N0 - adj[v].size()` (number of neighbors of `v`).\n      Else (`colors[u] == 1`): `w_2 += N1 - adj[u].size()` (number of neighbors of `u`).\n    This counts each pair of `(u,v)` and `(v,u)` for `w_2`. Since edges are undirected, we should divide by 2 or ensure we only iterate over unique pairs.\n    A simpler way is to iterate through all vertices `v`. If `colors[v] == 1`, count `N0 - deg(v)` ways. If `colors[v] == 0`, count `N1 - deg(v)` ways.\n    This is incorrect. The formula `sum_{(u,v) \\in E} (N_c(u) - \\text{deg}(v))` is correct.\n    `w_2 = 0`\n    For `u` from 1 to `n`:\n        For each neighbor `v` of `u`:\n            If `colors[u] == 0` and `colors[v] == 1`:  // Process each edge once, e.g., (u,v) where u is color 0\n                `w_2 += N0 - len(adj[v])` // N0 is total color 0 vertices, len(adj[v]) is degree of v\n            If `colors[u] == 1` and `colors[v] == 0`: // Process each edge once, e.g., (u,v) where u is color 1\n                `w_2 += N1 - len(adj[u])` // N1 is total color 1 vertices, len(adj[u]) is degree of u\n    This sums `(N0 - deg(v))` for `v` of color 1 and `(N1 - deg(u))` for `u` of color 0.\n    This counts `m` terms.\n    If `w_2 > 0`, output `2 w_2` and terminate.\n\n5.  Calculate `w_3`:\n    `w_3 = N0 * (N0 - 1) * (N0 - 2) // 6 + N1 * (N1 - 1) * (N1 - 2) // 6`.\n    If `w_3 > 0`, output `3 w_3` and terminate.\n    (This covers the `n=3, m=0` example).\n\n6.  If none of the above, it means `n` is too small to form an odd cycle (e.g., `n < 3` and `m=0`, or `n=4`, `m=0`, `N0=2, N1=2`).\n    In competitive programming, this usually implies `t` is very large or impossible.\n    However, the problem statement implies a solution always exists.\n    The problem constraints `n >= 1`.\n    If `n=1` or `n=2` and `m=0`, `t=3` and `w=0` (as `N0<3, N1<3`). This would be an issue.\n    For `n=1`, no cycle. For `n=2`, no odd cycle.\n    The problem statement \"consisting of more than one vertex\" means length >= 2. \"odd length\" means >= 3.\n    If `n < 3`, no cycle of length >= 3 can be formed.\n    The problem statement implies `n` is large enough for a solution to exist.\n    The example `3 0` output `3 1` confirms `t=3` is possible.\n    If `n` is small (e.g. `n=1, n=2`), then `N0 < 3` and `N1 < 3` will always be true.\n    If `n=1`, `N0=1, N1=0` or `N0=0, N1=1`. `w_3=0`.\n    If `n=2`:\n        `m=0`: `N0=2, N1=0` or `N0=0, N1=2` (if both isolated, same color). `w_3=1`. `t=3, w=1`.\n        `m=1`: `1-2`. `N0=1, N1=1`. `w_3=0`.\n    This implies my `w_3` calculation is correct for `n=2, m=0`. Add `(1,2), (2,1), (1,1)`? No, this is not a simple cycle.\n    Oh, `t=3` for `n=2, m=0` would mean adding `(1,2), (2,1), (1,1)`. But loops are forbidden.\n    A triangle `A-B-C-A` requires 3 distinct vertices. If `n < 3`, `w_3` should be 0.\n    My `N0*(N0-1)*(N0-2)//6` correctly returns 0 if `N0 < 3`.\n    So for `n=2, m=0`, `N0=2, N1=0` (say v1 color 0, v2 color 0), `w_3=0`.\n    This means if `n < 3`, it's impossible to form an odd cycle.\n    The problem statement must imply `n >= 3` for a solution to exist, or that `n=1,2` cases are not tested.\n    Assuming `n >= 3` if we reach step 5 and `w_3=0`: This implies `N0 < 3` and `N1 < 3`.\n    This means `n=3` and `(N0,N1)` is `(2,1)` or `(1,2)`.\n    Or `n=4` and `(N0,N1)` is `(2,2)`.\n    In these specific cases, it's impossible to form an odd cycle of length 3.\n    It's impossible to form ANY odd cycle, since all components are `K_1` or `K_2`.\n    If `N0=2, N1=1` (3 vertices total), we can add `(v1,v2)` (same color), and `(v2,v3)` (different color), and `(v3,v1)` (different color).\n    This forms a cycle `v1-v2-v3-v1`. Length 3.\n    Example: `n=3, m=0`. Vertices 1,2,3.\n    Color 1,2 as 0. Color 3 as 1. (`N0=2, N1=1`).\n    `t=0` fail. `t=1` fail. `t=2` fail. `w_3=0` because `N0<3` and `N1<3`.\n    But we can form a triangle! Add `(1,2), (2,3), (3,1)`.\n    `1,2` same color. `2,3` different. `3,1` different.\n    This creates an odd cycle `1-2-3-1`. Length 3.\n    How many edges added? `(1,2)` is between same-colored vertices. `(2,3)` between different. `(3,1)` between different.\n    If we add `(1,2)` (same color), `t=1` and `w=1` (for this example).\n    Wait, my `w_1` calculation: `N0=2, N1=1`. `w_1 = 2*(1)/2 + 0 = 1`.\n    The pair is `(1,2)`. Adding `(1,2)` creates cycle `1-2-1` (length 2, not odd).\n    This means my `t=1` logic is still a bit off.\n    The rule for `t=1` was: `u,v` must be in the same connected component AND have the same color.\n    If `n=3, m=0`, vertices 1,2,3 are isolated. They are in different components.\n    So `w_1` from my logic is 0.\n    In the `n=3, m=0` example, `t=3, w=1`.\n    The way to form a cycle of length 3 is by picking 3 vertices, say `1,2,3`. Add edges `(1,2), (2,3), (3,1)`.\n    This requires 3 added edges.\n    The cycle `1-2-3-1` is always an odd cycle.\n    The number of ways to pick 3 vertices from `n` is `n*(n-1)*(n-2)/6`.\n    So if `t=0, t=1, t=2` all fail, then `t=3` and `w = n*(n-1)*(n-2)/6`.\n    This is simpler and likely correct.\n\nRevised Final Logic:\n1.  Initialize `colors` array to -1. `is_bipartite = True`.\n2.  Perform 2-coloring for all connected components. Store `count0_i` and `count1_i` for each component `C_i`.\n    If `is_bipartite` becomes `False`, output `0 1` and terminate.\n3.  Calculate `w_1`:\n    `w_1 = 0`.\n    For each component `C_i`:\n      `w_1 += count0_i * (count0_i - 1) // 2 + count1_i * (count1_i - 1) // 2`.\n    If `w_1 > 0`, output `1 w_1` and terminate.\n4.  Calculate `w_2`:\n    `N0 = sum(count0_i)` over all components.\n    `N1 = sum(count1_i)` over all components.\n    `w_2 = 0`.\n    For `u` from 1 to `n`:\n        For each neighbor `v` of `u`:\n            // To avoid double counting (u,v) and (v,u), ensure u < v\n            // Or just divide total by 2 later if we iterate over all edges (u,v)\n            // Let's iterate over edges (u,v) such that u < v\n            If `u < v`:\n                If `colors[u] == 0`: // u is color 0, v must be color 1\n                    `w_2 += N0 - len(adj[v])`\n                Else: // u is color 1, v must be color 0\n                    `w_2 += N1 - len(adj[u])`\n    This sum `w_2` is the correct count for `t=2`.\n    If `w_2 > 0`, output `2 w_2` and terminate.\n5.  If none of the above, it means we need to add 3 edges.\n    `t = 3`.\n    `w = n * (n - 1) * (n - 2) // 6`.\n    Output `3 w` and terminate.\n    This covers the `n=3, m=0` example output `3 1`. `3*(2)*(1)//6 = 1`.\n    This also handles `n < 3` correctly, as `w` would be 0. (e.g., `n=2`, `w=0`).\n\nEdge case `n=1`: `m=0`.\n- `is_bipartite` is true. `colors = [-1, 0]`. `count0_1=1, count1_1=0`.\n- `w_1 = 0`.\n- `w_2 = 0`.\n- `t=3, w = 1*(0)*(-1)//6 = 0`. So `3 0`. This seems correct as no cycle can be formed.\n\nExample 1: `4 4`, `1-2, 1-3, 4-2, 4-3`\nColoring:\n1:0, 2:1, 3:1. (1-2, 1-3 edges)\n4:0. (4-2, 4-3 edges)\nCheck consistency:\n1(0)-2(1) OK\n1(0)-3(1) OK\n4(0)-2(1) OK\n4(0)-3(1) OK\nGraph is bipartite.\nComponent 1: {1,2,3,4}. `count0_1=2` ({1,4}), `count1_1=2` ({2,3}).\n`w_1 = (2*(1)//2) + (2*(1)//2) = 1 + 1 = 2`.\nOutput `1 2`. This matches example output.\n\nExample 2: `3 3`, `1-2, 2-3, 3-1`\nColoring:\n1:0, 2:1, 3:0.\nCheck consistency:\n1(0)-2(1) OK\n2(1)-3(0) OK\n3(0)-1(0) Conflict! `colors[3] == colors[1]`.\n`is_bipartite = False`.\nOutput `0 1`. This matches example output.\n\nThe logic seems solid now.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    is_bipartite = True\n    \n    # Store counts for each component\n    component_counts = [] # List of (count0, count1) for each component\n\n    # Step 1: Check for existing odd cycles (t = 0) and perform 2-coloring\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            current_component_count0 = 0\n            current_component_count1 = 0\n            \n            q = deque([(i, 0)]) # (vertex, color)\n            colors[i] = 0\n            current_component_count0 += 1\n            \n            component_vertices = [i] # To track vertices in current component\n            head = 0 # Manual queue for better performance with large N\n            \n            while head < len(q):\n                u, c_u = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c_u\n                        if colors[v] == 0:\n                            current_component_count0 += 1\n                        else:\n                            current_component_count1 += 1\n                        q.append((v, 1 - c_u))\n                        component_vertices.append(v)\n                    elif colors[v] == c_u:\n                        is_bipartite = False\n                        break\n                if not is_bipartite:\n                    break\n            \n            component_counts.append((current_component_count0, current_component_count1))\n            \n        if not is_bipartite:\n            break\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Step 2: If graph is bipartite, try t = 1\n    # We need to add an edge (u,v) where u,v are in the same component and have the same color.\n    # This forms an odd cycle of length >= 3.\n    w1 = 0\n    for count0, count1 in component_counts:\n        w1 += count0 * (count0 - 1) // 2\n        w1 += count1 * (count1 - 1) // 2\n    \n    if w1 > 0:\n        print(f\"1 {w1}\")\n        return\n\n    # Step 3: If t = 1 is not possible, try t = 2\n    # This means all components are K_1 or K_2.\n    # We need to form a triangle A-B-C-A.\n    # One edge (A,B) exists. Add (B,C) and (C,A).\n    # A,B must have different colors. C must have same color as A.\n    # (A,C) is between same-colored vertices, (B,C) between different.\n    \n    # Calculate total counts of color 0 and color 1 vertices across all components\n    total_N0 = sum(c0 for c0, _ in component_counts)\n    total_N1 = sum(c1 for _, c1 in component_counts)\n\n    w2 = 0\n    # Iterate through each edge (u,v)\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            if u < v: # Process each edge once\n                # Assume u is color 0, v is color 1 (or vice versa)\n                # We need to find a vertex x of color 0 (if u is color 0)\n                # such that x != u, x != v, (u,x) does not exist (guaranteed by bipartite property),\n                # and (v,x) does not exist.\n                # Number of candidates for x: (total_N0 - 1) - (degree of v among color 0 vertices, excluding u)\n                # This simplifies to total_N0 - deg(v) if u is color 0\n                # And total_N1 - deg(u) if u is color 1\n                if colors[u] == 0: # u is color 0, v is color 1\n                    w2 += total_N0 - len(adj[v])\n                else: # u is color 1, v is color 0\n                    w2 += total_N1 - len(adj[u])\n\n    if w2 > 0:\n        print(f\"2 {w2}\")\n        return\n\n    # Step 4: If t = 2 is not possible, try t = 3\n    # We need to add 3 edges (A,B), (B,C), (C,A) to form a triangle.\n    # This requires 3 distinct vertices A,B,C.\n    # The number of ways to pick 3 distinct vertices from n is n*(n-1)*(n-2)/6.\n    w3 = n * (n - 1) * (n - 2) // 6\n    \n    print(f\"3 {w3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    is_bipartite = True\n    \n    # Store counts for each component\n    component_counts = [] # List of (count0, count1) for each component\n\n    # Step 1: Check for existing odd cycles (t = 0) and perform 2-coloring\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            current_component_count0 = 0\n            current_component_count1 = 0\n            \n            q = deque([(i, 0)]) # (vertex, color)\n            colors[i] = 0\n            current_component_count0 += 1\n            \n            component_vertices = [i] # To track vertices in current component\n            head = 0 # Manual queue for better performance with large N\n            \n            while head < len(q):\n                u, c_u = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c_u\n                        if colors[v] == 0:\n                            current_component_count0 += 1\n                        else:\n                            current_component_count1 += 1\n                        q.append((v, 1 - c_u))\n                        component_vertices.append(v)\n                    elif colors[v] == c_u:\n                        is_bipartite = False\n                        break\n                if not is_bipartite:\n                    break\n            \n            component_counts.append((current_component_count0, current_component_count1))\n            \n        if not is_bipartite:\n            break\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Step 2: If graph is bipartite, try t = 1\n    # We need to add an edge (u,v) where u,v are in the same component and have the same color.\n    # This forms an odd cycle of length >= 3.\n    w1 = 0\n    for count0, count1 in component_counts:\n        w1 += count0 * (count0 - 1) // 2\n        w1 += count1 * (count1 - 1) // 2\n    \n    if w1 > 0:\n        print(f\"1 {w1}\")\n        return\n\n    # Step 3: If t = 1 is not possible, try t = 2\n    # This means all components are K_1 or K_2.\n    # We need to form a triangle A-B-C-A.\n    # One edge (A,B) exists. Add (B,C) and (C,A).\n    # A,B must have different colors. C must have same color as A.\n    # (A,C) is between same-colored vertices, (B,C) between different.\n    \n    # Calculate total counts of color 0 and color 1 vertices across all components\n    total_N0 = sum(c0 for c0, _ in component_counts)\n    total_N1 = sum(c1 for _, c1 in component_counts)\n\n    w2 = 0\n    # Iterate through each edge (u,v)\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            if u < v: # Process each edge once\n                # Assume u is color 0, v is color 1 (or vice versa)\n                # We need to find a vertex x of color 0 (if u is color 0)\n                # such that x != u, x != v, (u,x) does not exist (guaranteed by bipartite property),\n                # and (v,x) does not exist.\n                # Number of candidates for x: (total_N0 - 1) - (degree of v among color 0 vertices, excluding u)\n                # This simplifies to total_N0 - deg(v) if u is color 0\n                # And total_N1 - deg(u) if u is color 1\n                if colors[u] == 0: # u is color 0, v is color 1\n                    w2 += total_N0 - len(adj[v])\n                else: # u is color 1, v is color 0\n                    w2 += total_N1 - len(adj[u])\n\n    if w2 > 0:\n        print(f\"2 {w2}\")\n        return\n\n    # Step 4: If t = 2 is not possible, try t = 3\n    # We need to add 3 edges (A,B), (B,C), (C,A) to form a triangle.\n    # This requires 3 distinct vertices A,B,C.\n    # The number of ways to pick 3 distinct vertices from n is n*(n-1)*(n-2)/6.\n    w3 = n * (n - 1) * (n - 2) // 6\n    \n    print(f\"3 {w3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 594,
        "completion_token_count": 8039,
        "thoughts_token_count": 8190
    }
}