{
    "start": 1758011747.6799242,
    "end": 1758011827.6170816,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:37 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Okay, here's my plan to tackle this competitive programming problem:**\n\nI need to find two non-overlapping vouchers whose durations add up to `x`, minimizing their combined cost. I'm thinking a brute-force approach iterating all pairs is too slow, so I need something more efficient.  The input's structure, with start and end dates and durations, suggests I might be able to leverage some kind of sweep-line or grouping strategy.\n\nThe core issue is finding pairs that don't overlap. The non-overlapping condition, `ri < lj` or `rj < li`, is key. This means one voucher must finish *before* the other starts. This hints at sorting or processing events by start/end times.  I'll need to somehow consider this non-intersection constraint while simultaneously minimizing the cost and ensuring the durations sum to exactly `x`.\n\nFixing one voucher and searching for the best match looks promising.  I can group vouchers by duration and then use that to find suitable matches. For a voucher 'i', I can calculate the necessary duration 'j' needs and check if there's a non-overlapping voucher 'j' with that duration, minimizing cost. This duration checking with non-overlapping condition, could be implemented with a dictionary or by keeping a minimum cost for each duration.\n\nI'm leaning towards a sweep-line approach. Iterating through the days and keeping track of vouchers ending on each day seems like a good starting point.  I'll process vouchers either starting at a day or ending at a day. This means I can keep track of the available vouchers for a certain duration and find those that have ended before current day to meet the non-overlapping condition.\n\nI can maintain an array,  `min_cost_for_duration`, indexed by duration. This array, while sweeping from the start to the end, stores the lowest cost seen *so far* for vouchers with a given duration. When considering a voucher that *starts* at a certain point, I'll check if a voucher *ending* before that with a complementary duration exists. If so, I'll calculate and update the total cost accordingly. The non-overlapping condition is implicitly captured because the `min_cost_for_duration` array holds values for vouchers that have already ended.\n\nI need to keep the `min_cost_for_duration` for all possible duration values (up to `x`).  As I sweep, I'll update it whenever I encounter a voucher that ends.  This will let me check if a suitable preceding voucher exists when I process a voucher that starts. The starting day is more relevant for processing. I will need to iterate through vouchers sorted by end and then by starting day.\n\nI need to initialize my structures carefully. `min_cost_for_duration` will be initialized to infinity for all durations except for a 0-duration, which would be unnecessary. I'll also pre-process input into lists organized by start and end day. During my sweep, at each point, I must correctly add and update the costs, matching vouchers based on duration, and handle edge cases where no suitable pair is found, printing -1. Let's see if this works!\n",
    "response": "The problem asks us to find two distinct, non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet's define the duration of a voucher `k` as `d_k = r_k - l_k + 1`.\nTwo vouchers `i` and `j` are non-overlapping if `r_i < l_j` or `r_j < l_i`. This means one voucher must end before the other begins.\nWe need to find `i \\neq j` such that `d_i + d_j = x` and (`r_i < l_j` or `r_j < l_i`), minimizing `cost_i + cost_j`.\n\nA brute-force approach of checking all pairs of vouchers would be `O(N^2)`, which is too slow for `N = 2 \\cdot 10^5`. We need a more efficient approach, likely `O(N \\log N)` or `O(N + MaxCoord)`.\n\nWe can use a sweep-line algorithm. The maximum coordinate for `l_i` and `r_i` is `2 \\cdot 10^5`. Let's denote this `MAX_COORD`. We will iterate through each day from `1` to `MAX_COORD`.\n\nTo efficiently find non-overlapping vouchers, we can maintain information about vouchers that have already \"finished\" (i.e., their `r` value is less than the current day) and use this information to find a match for vouchers that \"start\" on the current day.\n\nHere's the detailed strategy:\n\n1.  **Data Structures for Vouchers**:\n    *   Create two lists of lists: `vouchers_by_start` and `vouchers_by_end`.\n    *   `vouchers_by_start[day]` will store `(r, cost)` for all vouchers that start on `day`.\n    *   `vouchers_by_end[day]` will store `(l, cost)` for all vouchers that end on `day`.\n    *   The maximum index for these lists will be `MAX_COORD` (2 * 10^5).\n\n2.  **Initialize**:\n    *   `min_cost_for_duration`: An array of size `x + 1`, initialized with `float('inf')`. `min_cost_for_duration[d]` will store the minimum cost of a voucher with duration `d` that has ended *before* the current sweep day.\n    *   `min_total_cost`: Initialize with `float('inf')`. This will store our final answer.\n\n3.  **Sweep Line**: Iterate `current_day` from `1` to `MAX_COORD`:\n\n    a.  **Process Vouchers that Start on `current_day`**:\n        These vouchers are potential \"second\" vouchers in a non-overlapping pair.\n        For each voucher `(r_i, cost_i)` in `vouchers_by_start[current_day]`:\n        *   Let `l_i = current_day`.\n        *   Calculate its duration `d_i = r_i - l_i + 1`.\n        *   If `d_i >= x`, this voucher alone is too long or exactly `x`, so it cannot be part of a pair summing to `x` with another positive duration voucher. Skip it.\n        *   We need a \"first\" voucher `j` with duration `d_j_target = x - d_i`.\n        *   The non-overlapping condition `r_j < l_i` means `r_j < current_day`. The `min_cost_for_duration` array stores exactly this information for vouchers ending before `current_day`.\n        *   If `d_j_target > 0` and `min_cost_for_duration[d_j_target]` is not `float('inf')`:\n            *   We found a valid pair. Update `min_total_cost = min(min_total_cost, cost_i + min_cost_for_duration[d_j_target])`.\n\n    b.  **Process Vouchers that End on `current_day`**:\n        These vouchers are potential \"first\" vouchers for future matches.\n        For each voucher `(l_k, cost_k)` in `vouchers_by_end[current_day]`:\n        *   Let `r_k = current_day`.\n        *   Calculate its duration `d_k = r_k - l_k + 1`.\n        *   If `d_k < x`: This voucher's duration is less than `x`, so it could be a component of a pair. Update the minimum cost for this duration:\n            *   `min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)`.\n\n4.  **Result**:\n    After the sweep, if `min_total_cost` is still `float('inf')`, it means no valid pair was found, so print -1. Otherwise, print `min_total_cost`.\n\n**Complexity Analysis**:\n*   **Time Complexity**:\n    *   Populating `vouchers_by_start` and `vouchers_by_end`: `O(N)`.\n    *   Initializing `min_cost_for_duration`: `O(x)`.\n    *   Sweep-line loop: The loop runs `MAX_COORD` times. Inside the loop, processing `vouchers_by_start[current_day]` and `vouchers_by_end[current_day]` takes time proportional to the number of vouchers starting/ending on `current_day`. Since each voucher is processed exactly once in step 3a and once in step 3b across the entire sweep, these operations sum up to `O(N)`.\n    *   Total time complexity: `O(N + MAX_COORD + x)`. Given `N, x, MAX_COORD \\le 2 \\cdot 10^5`, this is efficient enough.\n\n*   **Space Complexity**:\n    *   `vouchers_by_start` and `vouchers_by_end`: `O(N + MAX_COORD)` to store all vouchers and the list structures.\n    *   `min_cost_for_duration`: `O(x)`.\n    *   Total space complexity: `O(N + MAX_COORD + x)`.\n\nThis approach correctly handles the non-overlapping condition `r_j < l_i` by using `min_cost_for_duration` which only considers vouchers that ended before `current_day`. Due to symmetry, this covers all non-overlapping pairs.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # MAX_COORD is the maximum possible value for l_i or r_i.\n    # Given constraints: 1 <= l_i <= r_i <= 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start[day] will store a list of (r, cost) for vouchers starting on 'day'.\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[day] will store a list of (l, cost) for vouchers ending on 'day'.\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_start[l].append((r, cost))\n        vouchers_by_end[r].append((l, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended *before* the current_day in the sweep.\n    # Initialize with infinity as we want to find minimums.\n    # Duration can be up to x-1 (since the other voucher must have duration at least 1).\n    min_cost_for_duration = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers that start on 'current_day'.\n        # These are potential 'second' vouchers. We look for a 'first' voucher\n        # that ended before 'current_day' and has the required duration.\n        for r_i, cost_i in vouchers_by_start[current_day]:\n            l_i = current_day\n            d_i = r_i - l_i + 1 # Duration of the current voucher\n\n            # If current voucher's duration is already x or more, it cannot be paired\n            # with another voucher (which must have positive duration) to sum to x.\n            if d_i >= x:\n                continue\n            \n            # Calculate the required duration for the 'first' voucher.\n            d_j_target = x - d_i\n\n            # Check if there's a 'first' voucher with d_j_target duration\n            # that ended before current_day.\n            if d_j_target > 0 and d_j_target <= x and min_cost_for_duration[d_j_target] != float('inf'):\n                # Found a valid pair: current voucher (i) and a previously processed voucher (j).\n                # The condition r_j < l_i is satisfied because min_cost_for_duration\n                # only includes vouchers that ended before current_day.\n                current_pair_cost = cost_i + min_cost_for_duration[d_j_target]\n                min_total_cost = min(min_total_cost, current_pair_cost)\n\n        # Phase 2: Process vouchers that end on 'current_day'.\n        # These vouchers become available to be 'first' vouchers for future iterations.\n        for l_k, cost_k in vouchers_by_end[current_day]:\n            r_k = current_day\n            d_k = r_k - l_k + 1 # Duration of the current voucher\n\n            # Only consider vouchers whose duration could be part of an 'x' sum.\n            # If d_k is already x or more, it can't be a 'first' voucher for a sum of x.\n            if d_k < x:\n                min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)\n\n    # Output the result\n    if min_total_cost == float('inf'):\n        print(\"-1\")\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # MAX_COORD is the maximum possible value for l_i or r_i.\n    # Given constraints: 1 <= l_i <= r_i <= 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start[day] will store a list of (r, cost) for vouchers starting on 'day'.\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[day] will store a list of (l, cost) for vouchers ending on 'day'.\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_start[l].append((r, cost))\n        vouchers_by_end[r].append((l, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended *before* the current_day in the sweep.\n    # Initialize with infinity as we want to find minimums.\n    # Duration can be up to x-1 (since the other voucher must have duration at least 1).\n    min_cost_for_duration = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers that start on 'current_day'.\n        # These are potential 'second' vouchers. We look for a 'first' voucher\n        # that ended before 'current_day' and has the required duration.\n        for r_i, cost_i in vouchers_by_start[current_day]:\n            l_i = current_day\n            d_i = r_i - l_i + 1 # Duration of the current voucher\n\n            # If current voucher's duration is already x or more, it cannot be paired\n            # with another voucher (which must have positive duration) to sum to x.\n            if d_i >= x:\n                continue\n            \n            # Calculate the required duration for the 'first' voucher.\n            d_j_target = x - d_i\n\n            # Check if there's a 'first' voucher with d_j_target duration\n            # that ended before current_day.\n            if d_j_target > 0 and d_j_target <= x and min_cost_for_duration[d_j_target] != float('inf'):\n                # Found a valid pair: current voucher (i) and a previously processed voucher (j).\n                # The condition r_j < l_i is satisfied because min_cost_for_duration\n                # only includes vouchers that ended before current_day.\n                current_pair_cost = cost_i + min_cost_for_duration[d_j_target]\n                min_total_cost = min(min_total_cost, current_pair_cost)\n\n        # Phase 2: Process vouchers that end on 'current_day'.\n        # These vouchers become available to be 'first' vouchers for future iterations.\n        for l_k, cost_k in vouchers_by_end[current_day]:\n            r_k = current_day\n            d_k = r_k - l_k + 1 # Duration of the current voucher\n\n            # Only consider vouchers whose duration could be part of an 'x' sum.\n            # If d_k is already x or more, it can't be a 'first' voucher for a sum of x.\n            if d_k < x:\n                min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)\n\n    # Output the result\n    if min_total_cost == float('inf'):\n        print(\"-1\")\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 2490,
        "thoughts_token_count": 7493
    }
}