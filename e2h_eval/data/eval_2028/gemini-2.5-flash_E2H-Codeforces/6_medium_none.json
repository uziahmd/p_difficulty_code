{
    "start": 1758011748.8647535,
    "end": 1758011813.320771,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:36 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Reflecting on an Efficient Approach**\n\nAlright, let's break this down. The core challenge is efficiently finding two non-intersecting vouchers whose durations sum to a target value while minimizing the total cost.  Given the constraints, an O(N^2) brute-force solution is out of the question.  We need something better, and the hints point towards sorting or a sweep-line approach.\n\nMy first thought was to group vouchers by duration. However, this could still lead to quadratic time if many vouchers have the same duration. The non-intersection condition, where vouchers must either start after each other end or end before each other start, is a key hurdle.\n\nInitially, I considered sorting by start or end dates, but it became clear that a combined strategy is needed.  I then explored maintaining a data structure to store minimum costs based on duration and start/end days. The idea of using a dynamic programming table or a segment tree emerged, but I quickly realized that the memory requirements would be excessive.\n\nThen, the sweep-line approach caught my attention.  I realized that iterating through each day and tracking vouchers that start and end on that day could be a key. Maintaining an array `min_cost_for_duration` that stores the minimum cost of a voucher with a given duration that has already ended seemed like the right track. This will help with the `r_j < l_i` condition. For example, if we have a voucher starting at a day, we need to search for the voucher that should end before, which we already have.\n\nTo satisfy the `r_i < l_j` condition (two vouchers do not overlap, but could be on different side). This suggests processing the input in the chronological order. This leads to the solution by implementing a sweep line by iterating each day from 1 to 2 * 10^5. It takes O(N + MAX_COORD).\nNow, I am confident that by combining a sweep-line approach with sorting by start and end days, and using the `min_cost_for_duration` to maintain the minimum cost for each voucher, I can efficiently solve this problem.\n",
    "response": "The problem asks us to find two distinct vouchers, `i` and `j`, such that:\n1. They do not intersect. This means either `r_i < l_j` (voucher `i` ends before voucher `j` starts) or `r_j < l_i` (voucher `j` ends before voucher `i` starts).\n2. The sum of their durations is exactly `x`. The duration of voucher `k` is `d_k = r_k - l_k + 1`. So, `d_i + d_j = x`.\n3. Their total cost `cost_i + cost_j` is minimized.\n\nWe need to output this minimum total cost, or -1 if no such pair exists.\n\nThe constraints are `N, x <= 2 * 10^5` and `l_i, r_i <= 2 * 10^5`. A solution with `O(N^2)` complexity would be too slow. We need something closer to `O(N log N)` or `O(N + MAX_COORD)` where `MAX_COORD` is the maximum possible day (2 * 10^5).\n\nLet's use a sweep-line approach. We can iterate through the days from 1 to `MAX_COORD`.\nFor each day `current_day`, we process two types of events:\n1. Vouchers that *start* on `current_day`.\n2. Vouchers that *end* on `current_day`.\n\nWe want to find a pair `(v_i, v_j)` that satisfies `d_i + d_j = x` and `r_j < l_i` or `r_i < l_j`.\nLet's focus on the `r_j < l_i` condition. When we are processing a voucher `v_i = (l_i, r_i, cost_i)` where `l_i = current_day`, we need to find a voucher `v_j` such that `d_j = x - d_i` and `r_j < l_i`. This means `v_j` must have ended *before* `current_day`.\n\nWe can maintain an array, say `min_cost_for_duration`, where `min_cost_for_duration[d]` stores the minimum cost of any voucher with duration `d` that has *already ended* (i.e., its `r` value is less than `current_day`).\n\nThe algorithm would be as follows:\n1. Initialize `MAX_COORD = 2 * 10^5`.\n2. Create two lists of lists:\n   - `vouchers_starting_at_day[d]` will store `(r, duration, cost)` for all vouchers that start on day `d`.\n   - `vouchers_ending_at_day[d]` will store `(l, duration, cost)` for all vouchers that end on day `d`.\n   Populate these lists by iterating through the input vouchers.\n3. Initialize `min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)`. This array will store the minimum cost for a voucher of a given duration that has ended *before or on the current day*. (More precisely, it's the minimum cost of a voucher that has ended *strictly before* the `l_i` of the current voucher we are considering for a pair).\n4. Initialize `ans = float('inf')`. This will store the minimum total cost found.\n5. Iterate `current_day` from 1 to `MAX_COORD`:\n   a. **Process vouchers that start on `current_day`**: For each voucher `(r_i, d_i, cost_i)` in `vouchers_starting_at_day[current_day]`:\n      - Let `l_i = current_day`.\n      - Calculate the required duration for the second voucher: `d_j = x - d_i`.\n      - If `d_j > 0` and `d_j <= MAX_COORD`:\n        - Check `min_cost_for_duration[d_j]`. If it's not `float('inf')`, it means there's at least one voucher `v_j` with duration `d_j` that ended before `current_day` (i.e., `r_j < l_i`).\n        - Update `ans = min(ans, cost_i + min_cost_for_duration[d_j])`.\n   b. **Process vouchers that end on `current_day`**: For each voucher `(l_k, d_k, cost_k)` in `vouchers_ending_at_day[current_day]`:\n      - Let `r_k = current_day`.\n      - Update `min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)`. This makes `v_k` available for future vouchers that start *after* `current_day`.\n\n6. After the loop, if `ans` is still `float('inf')`, it means no valid pair was found, so print -1. Otherwise, print `ans`.\n\nThis approach correctly handles the `r_j < l_i` condition. The other condition `r_i < l_j` is symmetric. By iterating through `current_day` and considering vouchers that start on `current_day` and pairing them with vouchers that have already ended, we cover all pairs `(v_i, v_j)` where `r_j < l_i`. Since the condition is symmetric, if there's a valid pair `(v_a, v_b)` with `r_a < l_b`, this algorithm will find it when `v_b` is `v_i` and `v_a` is `v_j`.\n\n**Complexity Analysis:**\n- Initializing lists and `min_cost_for_duration`: `O(MAX_COORD)`.\n- Populating `vouchers_starting_at_day` and `vouchers_ending_at_day`: `O(N)` as each voucher is added to two lists once.\n- The sweep-line loop runs `MAX_COORD` times.\n  - Inside the loop, processing `vouchers_starting_at_day[current_day]` takes time proportional to the number of vouchers starting on `current_day`. In total, this is `O(N)` over all `current_day`s.\n  - Inside the loop, processing `vouchers_ending_at_day[current_day]` takes time proportional to the number of vouchers ending on `current_day`. In total, this is `O(N)` over all `current_day`s.\n- Total time complexity: `O(N + MAX_COORD)`.\n- Space complexity: `O(N + MAX_COORD)` for storing the vouchers and `min_cost_for_duration` array.\n\nGiven `N, MAX_COORD <= 2 * 10^5`, this complexity is efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # MAX_COORD is the maximum possible day value (2 * 10^5)\n    # We add 1 to make it 1-indexed up to MAX_COORD\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_starting_at_day[d] stores (r, duration, cost) for vouchers starting on day d\n    vouchers_starting_at_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_ending_at_day[d] stores (l, duration, cost) for vouchers ending on day d\n    vouchers_ending_at_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_at_day[l].append((r, duration, cost))\n        vouchers_ending_at_day[r].append((l, duration, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has ended on or before the current_day.\n    # We initialize with infinity to represent no such voucher found yet.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep line from day 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Phase 1: Consider vouchers that start on current_day (l_i = current_day)\n        # For each such voucher, try to find a complementary voucher (v_j)\n        # that ended *before* current_day (r_j < l_i).\n        for r_i, d_i, cost_i in vouchers_starting_at_day[current_day]:\n            d_j = x - d_i\n            # Check if d_j is a valid duration (positive and within bounds)\n            if 0 < d_j <= MAX_COORD:\n                # If a voucher with duration d_j has been found and ended before current_day\n                if min_cost_for_duration[d_j] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_for_duration[d_j])\n\n        # Phase 2: Update min_cost_for_duration with vouchers that end on current_day (r_k = current_day)\n        # These vouchers are now \"available\" to be paired with future vouchers that start after current_day.\n        for l_k, d_k, cost_k in vouchers_ending_at_day[current_day]:\n            min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # MAX_COORD is the maximum possible day value (2 * 10^5)\n    # We add 1 to make it 1-indexed up to MAX_COORD\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_starting_at_day[d] stores (r, duration, cost) for vouchers starting on day d\n    vouchers_starting_at_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_ending_at_day[d] stores (l, duration, cost) for vouchers ending on day d\n    vouchers_ending_at_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_at_day[l].append((r, duration, cost))\n        vouchers_ending_at_day[r].append((l, duration, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has ended on or before the current_day.\n    # We initialize with infinity to represent no such voucher found yet.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep line from day 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Phase 1: Consider vouchers that start on current_day (l_i = current_day)\n        # For each such voucher, try to find a complementary voucher (v_j)\n        # that ended *before* current_day (r_j < l_i).\n        for r_i, d_i, cost_i in vouchers_starting_at_day[current_day]:\n            d_j = x - d_i\n            # Check if d_j is a valid duration (positive and within bounds)\n            if 0 < d_j <= MAX_COORD:\n                # If a voucher with duration d_j has been found and ended before current_day\n                if min_cost_for_duration[d_j] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_for_duration[d_j])\n\n        # Phase 2: Update min_cost_for_duration with vouchers that end on current_day (r_k = current_day)\n        # These vouchers are now \"available\" to be paired with future vouchers that start after current_day.\n        for l_k, d_k, cost_k in vouchers_ending_at_day[current_day]:\n            min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 789,
        "completion_token_count": 2345,
        "thoughts_token_count": 6022
    }
}