{
    "start": 1758284910.6373725,
    "end": 1758284994.671757,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Analyzing the Competitive Programming Problem**\n\nOkay, so I'm tackling this competitive programming problem. The core is to figure out the fewest edges, *t*, to add to a graph to guarantee an odd-length cycle and also to determine the *number* of ways, *w*, to achieve this minimum. Let's break this down systematically.\n\nFirst, I need to grasp the key properties here. Odd cycles, bipartite graphs, and connected components. They're all interrelated. A graph containing an odd cycle is *not* bipartite, and vice-versa. And connected components are these self-contained units that make up the graph.\n\n**Immediate Case - A Simple Solution**\n\nIf the graph already has an odd cycle, the problem's trivial! I don't need to add any edges, so *t* is 0, and there's only one way to \"solve\" it: leave the graph as is, therefore *w* is 1. Checking for this is straightforward; I can use BFS or DFS for a 2-coloring. If I find a conflict—an edge connecting vertices of the same color—I've got my odd cycle.\n\n**Deeper Dive into Bipartite Graphs**\n\nNow, if the graph is bipartite, I have to *create* an odd cycle. This means I'm adding edges. A quick analysis tells me this. How can adding edges create an odd cycle? There are two scenarios.\n\nFirst, within a bipartite component, if I add an edge between two vertices on the *same* partition set, I force an odd cycle. The path between them must have an even length (since they are in the same partition) meaning adding the edge completes the odd cycle.\n\nSecond, connecting different bipartite components is also an option. Here the edge itself, along with paths within each component, will form the odd cycle. Adding a single edge might change the parity of the paths between *u* and *v*. So adding an edge might require careful planning.\n\n**Finding the Minimal Solution**\n\nMy main focus is *t*, the minimum number of edges. Is *t = 1* possible? Yes, it is. If I have two vertices within the same connected component, but in the same partition (color), adding a single edge between them forms an odd cycle, and this is the smallest *t* value I can get. Finding these cases is critical! I need to identify components and check the color of nodes, in the 2-coloring generated by my algorithm.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given graph to form a simple cycle of odd length, and `w`, the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. We can use a 2-coloring algorithm (e.g., BFS or DFS) to check for bipartiteness.\n\nLet's categorize the scenarios based on the graph's properties:\n\n**Step 1: Check for existing odd cycles.**\nWe perform a 2-coloring (bipartiteness check) on each connected component of the graph.\nInitialize `color` array for all vertices to -1 (unvisited).\nFor each unvisited vertex `i`:\n  Start a BFS/DFS from `i`, assigning `color[i] = 0`.\n  During the traversal, if we encounter an edge `(u, v)` where `u` and `v` already have the same color, then we have found an odd cycle. In this case, `t = 0` and `w = 1`. We can stop immediately.\n\nIf no odd cycle is found after checking all components, the graph is bipartite. We proceed to find the minimum `t > 0`.\n\n**Step 2: Graph is bipartite. Find minimum `t > 0`.**\nSince the graph is bipartite, all connected components can be 2-colored. Let's say we use colors 0 and 1. An edge always connects a vertex of color 0 to a vertex of color 1.\n\n*   **Case 1: `t = 1`**\n    We can form an odd cycle by adding a single edge `(u, v)` if `u` and `v` are in the same connected component and have the same color. Adding such an edge `(u, v)` would create a cycle where the path between `u` and `v` in the original component has even length (since they have the same color), and adding `(u, v)` makes the total cycle length odd.\n    To count ways `w`: For each connected component, if it's bipartite, count the number of vertices of color 0 (`cnt0`) and color 1 (`cnt1`). The number of ways to add an edge `(u, v)` within this component such that `u` and `v` have the same color is `cnt0 * (cnt0 - 1) / 2 + cnt1 * (cnt1 - 1) / 2`. We sum these counts over all components.\n    If `w > 0`, then `t = 1`.\n\n*   **Case 2: `t = 2`**\n    If `t = 1` is not possible (i.e., `w` from Case 1 is 0), it means that for every bipartite component, either `cnt0` or `cnt1` is 0 or 1. This implies that all bipartite components are paths or isolated vertices. In such a graph, any two vertices in the same component with the same color are either the same vertex or not connected by a path. This is incorrect reasoning. `cnt0*(cnt0-1)/2 + cnt1*(cnt1-1)/2` is 0 only if `cnt0 <= 1` and `cnt1 <= 1`. This would mean components are isolated vertices or single edges.\n    A simpler explanation for `t=1` not being possible: if we can't add an edge between two same-colored vertices in any component, it means all components are isolated vertices or edges. This is not true. `t=1` is possible if there are at least two same-colored vertices in *any* component. If `cnt0 >= 2` or `cnt1 >= 2` for any component, we can add an edge.\n    If `t=1` is not possible, it means for every component, `cnt0 <= 1` and `cnt1 <= 1`. This implies all components are either isolated vertices or single edges.\n\n    Let's re-evaluate `t=1`.\n    For each bipartite component, we count `cnt0` (vertices of color 0) and `cnt1` (vertices of color 1).\n    The number of pairs of vertices `(u,v)` within a component such that `u` and `v` have the same color is `cnt0 * (cnt0 - 1) / 2 + cnt1 * (cnt1 - 1) / 2`.\n    We must ensure `(u, v)` is not an existing edge. However, in a bipartite graph, an edge *always* connects vertices of different colors. So, any pair of same-colored vertices `(u, v)` is guaranteed not to be an existing edge.\n    So, if `sum(cnt0 * (cnt0 - 1) / 2 + cnt1 * (cnt1 - 1) / 2)` over all components is greater than 0, then `t = 1`, and `w` is this sum.\n\n    If `t = 1` is not possible, it means for *every* connected component, `cnt0 <= 1` and `cnt1 <= 1`. This implies that every connected component is either:\n    *   An isolated vertex (e.g., `cnt0=1, cnt1=0` or `cnt0=0, cnt1=1`)\n    *   A single edge (e.g., `cnt0=1, cnt1=1`)\n    In this scenario, all components are essentially \"small\".\n\n    If `t=1` is not possible, we need `t=2`.\n    To form an odd cycle with 2 added edges, we must connect two distinct bipartite components.\n    Let's say we have `k` connected components.\n    If we add two edges `(u, v)` and `(v, x)` where `u, v, x` are distinct.\n    A path `u - ... - v - ... - x` can be formed. Adding `(u, x)` would close a cycle.\n    This sounds like connecting three vertices.\n    Consider adding edges `(u_1, v_1)` and `(u_2, v_2)`.\n    If we connect two components, say `C_A` and `C_B`, with an edge `(a, b)` where `a \\in C_A, b \\in C_B`. The combined component `C_A \\cup C_B` is still bipartite.\n    To create an odd cycle, we need to add two edges `(u, v)` and `(v, w)` such that `u` and `w` become same-colored in the merged graph, and then add `(u, w)`. This is `t=1` for the merged graph.\n    This means we need to add one edge `(u, v)` to connect two components `C_A` and `C_B`, making a new bipartite component. Then, within this new component, `u` and `v` must have the same color. No, this logic is incorrect.\n\n    Let's simplify:\n    If `t=1` is not possible, it means all components have at most one vertex of each color.\n    This means the graph consists of isolated vertices and isolated edges.\n    In this case, we must add at least two edges to create an odd cycle.\n    For example, take two isolated vertices `u` and `v` (from two different components, or `u` is isolated and `v` is part of an edge component). We can add edges `(u, v)` and `(v, u)`. This is a loop and not allowed.\n    We need a simple cycle of length > 1.\n    If we have at least 3 vertices in the graph, we can always form an odd cycle of length 3 by adding 3 edges. For example, pick three distinct vertices `u, v, w` and add edges `(u, v), (v, w), (w, u)`. This implies `t <= 3`.\n\n    Consider adding two edges `(u, v)` and `(v, w)`. If `u, v, w` are distinct, they form a path of length 2. If `u` and `w` are not connected, we can add `(u, w)` to form a triangle, which is an odd cycle. This would be `t=3`.\n    If we have `k` components, and we need to add 2 edges.\n    Let `N_comp` be the number of connected components.\n    If `N_comp >= 2`:\n        We can pick two distinct components, say `C_1` and `C_2`.\n        Pick any vertex `u` from `C_1` and any vertex `v` from `C_2`. Add edge `(u, v)`.\n        The graph is still bipartite.\n        Now we have `N_comp - 1` components.\n        We need to add one more edge to create an odd cycle. This means we need to add an edge `(x, y)` where `x` and `y` are in the same component and have the same color.\n        This is not `t=2`. This is `t=1` for the new graph.\n        The minimum `t` is 2 if we connect two different components.\n        If we connect two components `C_A` and `C_B` with edge `(u, v)` (`u \\in C_A, v \\in C_B`).\n        Then we connect `C_A` and `C_C` with edge `(x, y)` (`x \\in C_A, y \\in C_C`).\n        This creates a path `y - C_C - x - C_A - u - C_B - v`.\n        This is getting complicated.\n\n    Let's use the property that if a graph is bipartite, adding an edge `(u, v)` creates an odd cycle if and only if `u` and `v` are in the same component and have the same color.\n    If `t=1` is not possible, it means no two vertices in the same component have the same color (unless they are the same vertex). This means all components are isolated vertices or single edges.\n    Let `N_iso` be the number of isolated vertices.\n    Let `N_edge` be the number of components that are single edges.\n    Total components `N_comp = N_iso + N_edge`.\n\n    If `t=1` is not possible, we need `t=2`.\n    Consider adding two edges `(u, v)` and `(v, w)`. This is a path of length 2.\n    If `u, v, w` are distinct, and `u` and `w` are not connected, we can add `(u, w)` to form a triangle (odd cycle). This requires 3 edges.\n    What if we add two edges to create an odd cycle?\n    This happens if we connect two components, say `C_1` and `C_2`, with two edges `(u_1, u_2)` and `(v_1, v_2)`, where `u_1, v_1 \\in C_1` and `u_2, v_2 \\in C_2`.\n    The path `u_1 - ... - v_1` in `C_1` has a certain parity. The path `u_2 - ... - v_2` in `C_2` has a certain parity.\n    If `u_1` and `v_1` have the same color in `C_1` (even path) and `u_2` and `v_2` have the same color in `C_2` (even path), then adding `(u_1, u_2)` and `(v_1, v_2)` creates a cycle `u_1 - (u_1, u_2) - u_2 - C_2 - v_2 - (v_1, v_2) - v_1 - C_1 - u_1`. The total length is `len(C_1) + 1 + len(C_2) + 1`. If `len(C_1)` and `len(C_2)` are even, then the cycle length is even.\n    We need to make it odd. This means one of `len(C_1)` or `len(C_2)` must be odd, or both are odd.\n    `len(C_1)` is even if `u_1, v_1` are same color. `len(C_1)` is odd if `u_1, v_1` are different colors.\n    If we connect `u_1` (color 0) to `u_2` (color 0) and `v_1` (color 1) to `v_2` (color 1), this creates an odd cycle.\n    Path `u_1 - C_1 - v_1` has odd length. Path `u_2 - C_2 - v_2` has odd length.\n    Cycle `u_1 - (u_1, u_2) - u_2 - C_2 - v_2 - (v_1, v_2) - v_1 - C_1 - u_1` has length `odd + 1 + odd + 1 = even`. Not an odd cycle.\n\n    Let's consider the number of components:\n    `N_iso`: number of isolated vertices (size 1 components).\n    `N_edge`: number of components that are single edges (size 2 components).\n    If `N_iso >= 2`: We can pick two isolated vertices `u, v`. Add edge `(u, v)`. Now we have a component of size 2. This is `t=1`. Still bipartite.\n    If `N_iso >= 1` and `N_edge >= 1`: Pick an isolated vertex `u` and an edge component `(v, w)`. Add `(u, v)`. Now we have a path `u-v-w`. This is `t=1`. Still bipartite.\n    If `N_edge >= 2`: Pick two edge components `(u_1, v_1)` and `(u_2, v_2)`. Add `(u_1, u_2)`. Now we have a path `v_1-u_1-u_2-v_2`. This is `t=1`. Still bipartite.\n\n    It seems `t=2` is only possible if we connect two components, `C_A` and `C_B`, with two edges `(u_A, u_B)` and `(v_A, v_B)`.\n    For this to form an odd cycle, the path `u_A - ... - v_A` in `C_A` must have different parity than the path `u_B - ... - v_B` in `C_B` (when considering parities relative to the new edges).\n    This is equivalent to: in `C_A`, `u_A` and `v_A` have different colors. In `C_B`, `u_B` and `v_B` have different colors. Adding `(u_A, u_B)` and `(v_A, v_B)` means `u_A` and `u_B` get linked, `v_A` and `v_B` get linked.\n    If `u_A` has color 0, `v_A` has color 1.\n    If `u_B` has color 0, `v_B` has color 1.\n    Then `u_A` and `u_B` are same color, `v_A` and `v_B` are same color.\n    Cycle: `u_A - (u_A, u_B) - u_B - C_B - v_B - (v_B, v_A) - v_A - C_A - u_A`.\n    Path `u_A - C_A - v_A` has odd length. Path `u_B - C_B - v_B` has odd length.\n    Total length: `odd + 1 + odd + 1 = even`. Still even.\n\n    The only way to create an odd cycle with 2 edges is to connect two vertices `u, v` such that they are in different components, and then connect `u, v` to a third vertex `w`.\n    No, this is not correct.\n    Minimum `t=2` is achieved by picking two components, say `C_i` and `C_j`.\n    Pick a vertex `u` from `C_i` and `v` from `C_j`. Add edge `(u, v)`.\n    Pick another vertex `x` from `C_i` and `y` from `C_j`. Add edge `(x, y)`.\n    This creates a cycle `u - (u,v) - v - path(v,y) - y - (y,x) - x - path(x,u) - u`.\n    The path `u - path(u,x) - x` in `C_i` has length `L_i`.\n    The path `v - path(v,y) - y` in `C_j` has length `L_j`.\n    The cycle length is `1 + L_j + 1 + L_i`.\n    For this to be odd, `L_i + L_j` must be odd.\n    This means one of `L_i` and `L_j` is odd, and the other is even.\n    `L_i` is odd if `u` and `x` have different colors in `C_i`.\n    `L_j` is even if `v` and `y` have the same color in `C_j`.\n    So, we need to pick `u, x` from `C_i` with different colors, and `v, y` from `C_j` with same colors.\n    Number of ways:\n    Pick `C_i`, `C_j` (order doesn't matter): `N_comp * (N_comp - 1) / 2`.\n    For `C_i`: pick `u` (color 0), `x` (color 1). `cnt0_i * cnt1_i` ways.\n    For `C_j`: pick `v` (color 0), `y` (color 0). `cnt0_j * (cnt0_j - 1) / 2` ways.\n    OR pick `v` (color 1), `y` (color 1). `cnt1_j * (cnt1_j - 1) / 2` ways.\n    Total ways for `C_i`, `C_j`: `cnt0_i * cnt1_i * (cnt0_j * (cnt0_j - 1) / 2 + cnt1_j * (cnt1_j - 1) / 2)`.\n    This counts ways for `(u,v), (x,y)`.\n    We also need to consider `cnt0_j * cnt1_j * (cnt0_i * (cnt0_i - 1) / 2 + cnt1_i * (cnt1_i - 1) / 2)`.\n    Sum these over all pairs of components `(C_i, C_j)`.\n\n    This is for `t=2`. This requires at least one component to have `cnt0 >= 2` or `cnt1 >= 2` (for the even path part), and at least one component to have `cnt0 >= 1` and `cnt1 >= 1` (for the odd path part).\n    If `t=1` is not possible, then all components have `cnt0 <= 1` and `cnt1 <= 1`.\n    This means `cnt0 * (cnt0 - 1) / 2 + cnt1 * (cnt1 - 1) / 2` is 0 for all components.\n    And `cnt0 * cnt1` is 0 or 1 for all components. It's 1 only for single-edge components.\n    So, if `t=1` is not possible, then `t=2` is also not possible by this method.\n\n    What if `t=2` involves adding edges that connect to the same vertex? E.g., `(u, v)` and `(u, w)`. This means we are adding a path of length 2 from `v` to `w` through `u`. If `v` and `w` are in different components, and `u` is in a third component, this is `t=2`.\n    If `v` and `w` are in the same component `C_1`, and `u` is in `C_2`.\n    We add `(u, v)` and `(u, w)`.\n    Path `v - C_1 - w` has length `L`.\n    Cycle `u - (u,v) - v - C_1 - w - (w,u) - u`. Length `1 + L + 1 = L + 2`.\n    For this to be odd, `L` must be odd.\n    `L` is odd if `v` and `w` have different colors in `C_1`.\n    So, we need to pick a component `C_1` with `cnt0_1 >= 1` and `cnt1_1 >= 1`.\n    And pick another component `C_2` with `cnt0_2 >= 1` or `cnt1_2 >= 1` (just needs a vertex).\n    Ways:\n    Pick `C_1` and `C_2`.\n    Pick `u` from `C_2`. `N_v_C2` ways.\n    Pick `v` (color 0) from `C_1`, `w` (color 1) from `C_1`. `cnt0_1 * cnt1_1` ways.\n    Total ways: `sum_{C_1, C_2 distinct} (N_v_C2 * cnt0_1 * cnt1_1)`.\n    This is `sum_{C_1} (cnt0_1 * cnt1_1) * sum_{C_2 != C_1} N_v_C2`.\n    `sum_{C_2 != C_1} N_v_C2 = N - N_v_C1`.\n    So, `sum_{C_1} (cnt0_1 * cnt1_1 * (N - N_v_C1))`.\n    This sum counts `t=2` ways.\n    If `t=1` is not possible, then `cnt0_1 * cnt1_1` is 0 or 1 for all components. It is 1 only for single-edge components.\n    So, if `t=1` is not possible, then `cnt0_1 * cnt1_1 = 1` for `N_edge` components, and 0 for `N_iso` components.\n    The sum becomes `sum_{C_1 is an edge} (1 * (N - 2)) = N_edge * (N - 2)`.\n    This is `w` for `t=2`.\n    This requires `N_edge >= 1` and `N >= 3` (so `N-2 >= 1`).\n    If `N_edge = 0`, then all components are isolated vertices. In this case, `cnt0_1 * cnt1_1 = 0` for all `C_1`. So `w=0`.\n\n*   **Case 3: `t = 3`**\n    If `t=1` and `t=2` are not possible, it means:\n    1.  No component has `cnt0 >= 2` or `cnt1 >= 2`. (eliminates `t=1`)\n    2.  No component has `cnt0 >= 1` and `cnt1 >= 1`. (eliminates `t=2` via `N_edge * (N-2)` ways).\n    Combined, this means all components are isolated vertices.\n    So, `m = 0` and `N_edge = 0`. All `N` vertices are isolated.\n    In this case, we need to add 3 edges to form a triangle (an odd cycle of length 3).\n    We need to pick 3 distinct vertices. This requires `N >= 3`.\n    If `N < 3`, it's impossible to form a cycle of length > 1. But problem states \"more than one vertex\", which means length >= 2. A cycle of length 2 is `u-v-u`, which is a parallel edge, not allowed. A cycle of length 1 is a loop, not allowed. So minimum length is 3.\n    Number of ways to pick 3 vertices: `N * (N-1) * (N-2) / 6`.\n    So `t = 3` and `w = N * (N-1) * (N-2) / 6`.\n\n**Summary of logic:**\n\n1.  **Bipartiteness Check:**\n    Perform BFS/DFS from each unvisited vertex. Maintain `color` array (0 or 1) and `visited` array.\n    If an edge `(u, v)` connects two vertices of the same color, an odd cycle exists. Print `0 1` and exit.\n    During the traversal, for each component `C_i`, count `cnt0_i` and `cnt1_i`. Store these. Also store `N_v_Ci = cnt0_i + cnt1_i`.\n    Keep track of `N_comp` (number of connected components).\n\n2.  **If graph is bipartite (no odd cycle found):**\n    a.  **Check for `t = 1`:**\n        Calculate `w1 = sum_{all components C_i} (cnt0_i * (cnt0_i - 1) // 2 + cnt1_i * (cnt1_i - 1) // 2)`.\n        If `w1 > 0`, print `1 w1` and exit.\n\n    b.  **Check for `t = 2`:**\n        This means `w1 = 0`, which implies for all components `C_i`, `cnt0_i <= 1` and `cnt1_i <= 1`.\n        Calculate `w2 = sum_{all components C_i} (cnt0_i * cnt1_i * (N - N_v_Ci))`.\n        This is the sum over components `C_i` that are single edges (`cnt0_i=1, cnt1_i=1`), of `1 * (N - 2)`.\n        So `w2 = N_edge * (N - 2)`. `N_edge` is the count of components that are a single edge.\n        If `w2 > 0`, print `2 w2` and exit.\n\n    c.  **Otherwise (`t = 3`):**\n        This means `w1 = 0` and `w2 = 0`.\n        `w1 = 0` implies all components are isolated vertices or single edges.\n        `w2 = 0` implies `N_edge = 0` (no single-edge components) or `N-2=0` (N=2).\n        If `N_edge = 0`, all components are isolated vertices.\n        If `N=2`, the graph is either `1-2` (1 edge component) or `1 2` (2 isolated vertices).\n        If `N=2` and `m=1` (`1-2`), then `N_edge=1`.\n        `w1 = 0`. `w2 = 1 * (2-2) = 0`.\n        In this case, `t=3` is not possible as we need 3 vertices.\n        So, if `N < 3`, and `t=0, t=1, t=2` are not possible, then no odd cycle can be formed. But the problem guarantees `N >= 1`.\n        The problem implies it's always possible to form an odd cycle. If `N < 3`, no odd cycle can be formed. The minimum cycle length is 3.\n        If `N=1` or `N=2`, we cannot form a cycle of length 3.\n        Let's consider `N=1`: `t` is impossible.\n        Let's consider `N=2`: `t` is impossible.\n        The problem statement should clarify this. \"consisting of more than one vertex\" for a cycle implies length >= 2. A simple cycle of length 2 is two vertices connected by two parallel edges, which are forbidden. So minimum simple cycle length is 3.\n        So if `N < 3`, `t` is undefined or effectively infinity.\n        However, the examples show `N=3, m=0` gives `3 1`. This means `N=3` is the minimum `N` for `t=3`.\n        So, if `N >= 3`:\n        Print `3 (N * (N-1) * (N-2) // 6)` and exit.\n        If `N < 3`, this case should not be reached because it would mean `t` is impossible.\n\n**Refined Logic for `t=2` and `t=3`:**\n\nLet's maintain `num_isolated_vertices` and `num_edge_components`.\n`N_comp_general`: count of components that are not isolated vertices or single edges (i.e., `cnt0 >= 2` or `cnt1 >= 2` or `cnt0 >= 1` and `cnt1 >= 1` and `cnt0+cnt1 > 2`). If `N_comp_general > 0`, then `w1 > 0`.\n\nIf `w1 == 0`:\nThis means all components are either isolated vertices (`cnt0=1, cnt1=0` or `cnt0=0, cnt1=1`) or single edges (`cnt0=1, cnt1=1`).\nLet `num_iso_v` be the number of isolated vertices.\nLet `num_edge_comp` be the number of components that are single edges.\n\nNow for `t=2`:\nWe need to add two edges `(u, v)` and `(v, w)` where `u, v, w` are distinct, and `v, w` are in the same component `C_1` with different colors, and `u` is in a different component `C_2`.\nThis forms a cycle `u - (u,v) - v - C_1 - w - (w,u) - u` of length `1 + len(v-C_1-w) + 1`.\n`len(v-C_1-w)` is odd if `v, w` have different colors.\nIf `w1=0`, then `v, w` having different colors in `C_1` means `C_1` must be a single edge.\nSo, `C_1` must be an edge component. `v` and `w` are its two endpoints. `len(v-C_1-w)=1`.\nThen the cycle length is `1 + 1 + 1 = 3`, which is odd.\n`u` must be from a different component `C_2`.\nNumber of ways:\nPick `C_1` (an edge component): `num_edge_comp` ways.\nPick `v, w` (endpoints of `C_1`): 2 ways to map `v, w` to the two ends. But `(v,w)` and `(w,v)` are same pair. So 1 way to choose the two vertices.\nPick `u` from any other component: `N - 2` choices.\nSo, `w2 = num_edge_comp * (N - 2)`.\nIf `w2 > 0`, print `2 w2` and exit.\n\nIf `w2 == 0`:\nThis means `num_edge_comp = 0` or `N-2=0`.\nIf `num_edge_comp = 0`, then all components are isolated vertices.\nIf `N-2=0` (i.e., `N=2`), and `num_edge_comp=1` (the graph is `1-2`), then `w2=0`.\nIn this case, all components are isolated vertices.\nSo `m = 0`.\nWe need `t=3`. This requires `N >= 3`.\nNumber of ways `w3 = N * (N-1) * (N-2) // 6`.\nIf `w3 > 0`, print `3 w3` and exit.\nIf `N < 3`, then `w3 = 0`. This implies no solution. The problem statement implies a solution always exists.\nSo for `N < 3`, it's an edge case.\nIf `N=1`, `m=0`: `t=inf`.\nIf `N=2, m=0`: `t=inf`.\nIf `N=2, m=1`: `t=inf`.\nThe examples don't cover `N < 3`. Let's assume `N >= 3` for `t=3` case.\n\nFinal algorithm:\n1.  Initialize `color` array to -1. `adj` list for graph. `visited` set.\n2.  `num_components_with_same_color_pairs = 0`\n3.  `num_edge_components = 0`\n4.  `total_nodes_in_graph = n`\n5.  Iterate `u` from 1 to `n`:\n    If `u` is not visited:\n        `current_component_nodes = 0`\n        `cnt0 = 0`, `cnt1 = 0`\n        Start BFS from `u`:\n            `q = deque([u])`\n            `visited.add(u)`\n            `color[u] = 0`\n            `cnt0 += 1`\n            `current_component_nodes += 1`\n            While `q`:\n                `curr = q.popleft()`\n                For `neighbor` in `adj[curr]`:\n                    If `color[neighbor] == -1`:\n                        `color[neighbor] = 1 - color[curr]`\n                        If `color[neighbor] == 0`: `cnt0 += 1`\n                        Else: `cnt1 += 1`\n                        `visited.add(neighbor)`\n                        `current_component_nodes += 1`\n                        `q.append(neighbor)`\n                    Else if `color[neighbor] == color[curr]`:\n                        // Odd cycle found\n                        Print `0 1`\n                        Return\n\n        // Component `u` is bipartite.\n        `num_components_with_same_color_pairs += (cnt0 * (cnt0 - 1) // 2 + cnt1 * (cnt1 - 1) // 2)`\n        If `cnt0 == 1` and `cnt1 == 1`: // A single edge component\n            `num_edge_components += 1`\n\n6.  If we reach here, the graph is bipartite.\n    If `num_components_with_same_color_pairs > 0`:\n        Print `1 num_components_with_same_color_pairs`\n    Else if `num_edge_components * (total_nodes_in_graph - 2) > 0`:\n        Print `2 (num_edge_components * (total_nodes_in_graph - 2))`\n    Else:\n        // All components are isolated vertices, or N < 3.\n        // If N < 3, then N * (N-1) * (N-2) // 6 will be 0.\n        // The problem's example for N=3, M=0 output 3 1.\n        // This implies for N=3, M=0, we should output 3 1.\n        // If N=1 or N=2, it's impossible to form a cycle of length 3.\n        // My logic for t=3 gives 0 ways if N < 3.\n        // Let's assume N >= 3 for this case, as per example.\n        Print `3 (total_nodes_in_graph * (total_nodes_in_graph - 1) * (total_nodes_in_graph - 2) // 6)`\n\nThis covers all cases and seems robust.\n\nExample 1:\n4 4\n1 2\n1 3\n4 2\n4 3\nAdj: 1:[2,3], 2:[1,4], 3:[1,4], 4:[2,3]\nBFS from 1:\ncolor[1]=0\ncolor[2]=1, color[3]=1\nFrom 2: neighbor 4. color[4]=0.\nFrom 3: neighbor 4. color[4]=0. But color[4] is already 0. color[3] is 1. Conflict! No, this is fine. (1,3) is edge. color[1]=0, color[3]=1.\nWait, let's trace BFS carefully.\nq=[1], color[1]=0, visited={1}, cnt0=1, cnt1=0\npop 1. neighbors 2,3.\n  color[2]=1, cnt1=1, visited={1,2}, q=[2]\n  color[3]=1, cnt1=2, visited={1,2,3}, q=[2,3]\npop 2. neighbors 1,4.\n  1 is color 0, curr 2 is color 1. OK.\n  color[4]=0, cnt0=2, visited={1,2,3,4}, q=[3,4]\npop 3. neighbors 1,4.\n  1 is color 0, curr 3 is color 1. OK.\n  4 is color 0, curr 3 is color 1. OK.\npop 4. neighbors 2,3.\n  2 is color 1, curr 4 is color 0. OK.\n  3 is color 1, curr 4 is color 0. OK.\nQueue empty. No conflict found. Graph is bipartite.\nComponent 1: cnt0=2 (1,4), cnt1=2 (2,3).\nnum_components_with_same_color_pairs = (2*(1)//2 + 2*(1)//2) = (1+1) = 2.\nSince `num_components_with_same_color_pairs > 0`, print `1 2`. Correct.\n\nExample 2:\n3 3\n1 2\n2 3\n3 1\nAdj: 1:[2,3], 2:[1,3], 3:[1,2]\nBFS from 1:\nq=[1], color[1]=0, visited={1}, cnt0=1, cnt1=0\npop 1. neighbors 2,3.\n  color[2]=1, cnt1=1, visited={1,2}, q=[2]\n  color[3]=1, cnt1=2, visited={1,2,3}, q=[2,3]\npop 2. neighbors 1,3.\n  1 is color 0, curr 2 is color 1. OK.\n  3 is color 1, curr 2 is color 1. Conflict! `color[3] == color[2]`. Odd cycle found.\nPrint `0 1`. Correct.\n\nExample 3:\n3 0\nAdj: 1:[], 2:[], 3:[]\nBFS from 1:\nq=[1], color[1]=0, visited={1}, cnt0=1, cnt1=0\nComponent 1: cnt0=1, cnt1=0.\nBFS from 2:\nq=[2], color[2]=0, visited={1,2}, cnt0=1, cnt1=0\nComponent 2: cnt0=1, cnt1=0.\nBFS from 3:\nq=[3], color[3]=0, visited={1,2,3}, cnt0=1, cnt1=0\nComponent 3: cnt0=1, cnt1=0.\nNo odd cycle found. Graph is bipartite.\nnum_components_with_same_color_pairs = (1*0//2 + 0*(-1)//2) = 0 for each component. Sum = 0.\nnum_edge_components = 0 (no component is a single edge).\nSo `num_components_with_same_color_pairs = 0`.\nThen `num_edge_components * (total_nodes_in_graph - 2) = 0 * (3-2) = 0`.\nSo print `3 (3 * (3-1) * (3-2) // 6) = 3 * 2 * 1 // 6 = 1`.\nPrint `3 1`. Correct.\n\nLooks good.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n\n    # For t=1 calculation\n    num_components_with_same_color_pairs = 0 \n    # For t=2 calculation\n    num_edge_components = 0 \n    \n    # Check for existing odd cycles and collect component info\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0\n            \n            current_component_cnt0 = 0\n            current_component_cnt1 = 0\n            \n            # Flag to detect odd cycle within current component\n            component_has_odd_cycle = False\n\n            component_nodes_queue = deque() # To count nodes for current component\n            component_nodes_queue.append(i)\n\n            while q:\n                u = q.popleft()\n                \n                if color[u] == 0:\n                    current_component_cnt0 += 1\n                else:\n                    current_component_cnt1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                        component_nodes_queue.append(v)\n                    elif color[v] == color[u]:\n                        # Found an odd cycle\n                        print(\"0 1\")\n                        return\n\n            # If we reach here, the component is bipartite.\n            # Calculate ways for t=1 within this component\n            num_components_with_same_color_pairs += (current_component_cnt0 * (current_component_cnt0 - 1) // 2)\n            num_components_with_same_color_pairs += (current_component_cnt1 * (current_component_cnt1 - 1) // 2)\n            \n            # Check if this component is a single edge for t=2 calculation\n            if current_component_cnt0 == 1 and current_component_cnt1 == 1:\n                num_edge_components += 1\n\n    # If we reached here, the entire graph is bipartite.\n    \n    # Case t = 1: Add one edge between two same-colored vertices in a component.\n    if num_components_with_same_color_pairs > 0:\n        print(f\"1 {num_components_with_same_color_pairs}\")\n        return\n\n    # Case t = 2: Add two edges (u,v) and (u,w) where v,w are different-colored in one component (must be an edge)\n    # and u is in another component. This forms a triangle.\n    # This requires at least one edge component and N >= 3 (so N-2 >= 1).\n    # If num_components_with_same_color_pairs is 0, it means all components are either isolated vertices or single edges.\n    # A component (v,w) is a single edge, so v and w have different colors.\n    # Ways = (number of edge components) * (number of choices for u from other N-2 vertices)\n    ways_t2 = num_edge_components * (n - 2)\n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t = 3: All components are isolated vertices (since t=1 and t=2 ways are 0).\n    # Need to pick 3 distinct vertices and add 3 edges to form a triangle.\n    # This requires N >= 3.\n    # The number of ways to choose 3 vertices from N is N * (N-1) * (N-2) / 6.\n    ways_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {ways_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n\n    # For t=1 calculation\n    num_components_with_same_color_pairs = 0 \n    # For t=2 calculation\n    num_edge_components = 0 \n    \n    # Check for existing odd cycles and collect component info\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0\n            \n            current_component_cnt0 = 0\n            current_component_cnt1 = 0\n            \n            # Flag to detect odd cycle within current component\n            component_has_odd_cycle = False\n\n            component_nodes_queue = deque() # To count nodes for current component\n            component_nodes_queue.append(i)\n\n            while q:\n                u = q.popleft()\n                \n                if color[u] == 0:\n                    current_component_cnt0 += 1\n                else:\n                    current_component_cnt1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                        component_nodes_queue.append(v)\n                    elif color[v] == color[u]:\n                        # Found an odd cycle\n                        print(\"0 1\")\n                        return\n\n            # If we reach here, the component is bipartite.\n            # Calculate ways for t=1 within this component\n            num_components_with_same_color_pairs += (current_component_cnt0 * (current_component_cnt0 - 1) // 2)\n            num_components_with_same_color_pairs += (current_component_cnt1 * (current_component_cnt1 - 1) // 2)\n            \n            # Check if this component is a single edge for t=2 calculation\n            if current_component_cnt0 == 1 and current_component_cnt1 == 1:\n                num_edge_components += 1\n\n    # If we reached here, the entire graph is bipartite.\n    \n    # Case t = 1: Add one edge between two same-colored vertices in a component.\n    if num_components_with_same_color_pairs > 0:\n        print(f\"1 {num_components_with_same_color_pairs}\")\n        return\n\n    # Case t = 2: Add two edges (u,v) and (u,w) where v,w are different-colored in one component (must be an edge)\n    # and u is in another component. This forms a triangle.\n    # This requires at least one edge component and N >= 3 (so N-2 >= 1).\n    # If num_components_with_same_color_pairs is 0, it means all components are either isolated vertices or single edges.\n    # A component (v,w) is a single edge, so v and w have different colors.\n    # Ways = (number of edge components) * (number of choices for u from other N-2 vertices)\n    ways_t2 = num_edge_components * (n - 2)\n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t = 3: All components are isolated vertices (since t=1 and t=2 ways are 0).\n    # Need to pick 3 distinct vertices and add 3 edges to form a triangle.\n    # This requires N >= 3.\n    # The number of ways to choose 3 vertices from N is N * (N-1) * (N-2) / 6.\n    ways_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {ways_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 10380,
        "thoughts_token_count": 736
    }
}