{
    "start": 1758284905.9859588,
    "end": 1758284964.1921875,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Polycarp's Practice: A Pythonic Approach**\n\nOkay, so I've got this \"Polycarp's Practice\" problem. It's about maximizing profit from solving problems over several days, given their difficulties. The crux of it seems to be in efficiently partitioning the problem set. I need to output the maximum profit possible and the number of problems solved each day. \n\nMy initial analysis reveals the core challenge: maximizing the sum of daily profits, where each day's profit is the maximum difficulty solved on that day. The problem's constraints are pretty straightforward: solve problems sequentially, divide into exactly 'k' days, and have at least one problem per day.\n\nThinking it through, the key insight hits me: to get the *absolute* maximum profit, I should try to make the biggest difficulties be the daily maxes. If I can ensure that the 'k' largest difficulties each become the daily maximum for exactly one day, that's the upper limit on the total profit. No way to get more than that! So, here's the game plan:\n\n1.  **Identify the Heavy Hitters:** First, I'll identify those 'k' biggest problem difficulties. Simple enough - I can create pairs of (difficulty, original index) to preserve the original ordering, then sort them in descending order of difficulty. The top 'k' entries give me those critical difficulties and their positions in the original array.\n2.  **Calculate the Ultimate Profit:** Summing those 'k' largest difficulties is the maximum total profit. I'm already halfway there!\n3.  **Create the Optimal Partition:** This is where things get interesting. I know where the 'k' largest difficulties are, thanks to the indices. Now, the real trick is to create those 'k' partitions so that the target maximums are achieved. I will take the sorted indices and build the splits. The gaps between indices are the lengths of the days. The indices will tell me precisely where to create these contiguous chunks. The maximums within each chunk will, by design, be those predetermined 'k' greatest difficulties!\n4. **Produce output**: Calculate the numbers of problems solved on each day, and make it output friendly.\n\nI'm confident this approach is going to efficiently provide both the maximum profit and the problem distribution required. It has a great chance to work well on the given problem constraints. Let's get coding!\n",
    "response": "The problem asks us to partition `n` problems, given as a list of difficulties `a_1, a_2, \\dots, a_n`, into exactly `k` contiguous segments. Each segment represents problems solved on a single day. The profit for a day is the maximum difficulty among problems solved on that day. We want to maximize the total profit (sum of daily profits) and output this maximum profit, along with the number of problems solved each day.\n\n**Key Idea:**\nTo maximize the sum of `k` daily maximums, we should choose the `k` largest problem difficulties from the entire list `a` to be these maximums. If we can ensure that each of these `k` largest values is the maximum for one of the `k` days, then their sum will be the maximum possible total profit.\n\nLet's illustrate why this works. Suppose the `k` largest difficulties are `M_1 \\ge M_2 \\ge \\dots \\ge M_k`. If we can form `k` segments such that each segment's maximum is one of these `M_i` values, the total profit will be `\\sum_{i=1}^k M_i`.\nConsider any other valid partition into `k` segments. Let the maximums for these segments be `P_1, P_2, \\dots, P_k`. Each `P_j` must be some `a_i` from the original list. Since `M_1, \\dots, M_k` are the `k` largest values in `a`, any set of `k` values chosen from `a` (including `P_1, \\dots, P_k`) will have a sum less than or equal to `\\sum_{i=1}^k M_i`. Therefore, `\\sum_{j=1}^k P_j \\le \\sum_{i=1}^k M_i`. This confirms that the maximum possible total profit is indeed the sum of the `k` largest difficulties in the array `a`.\n\n**Algorithm:**\n\n1.  **Calculate Maximum Total Profit:**\n    *   Create a list of tuples `(difficulty, original_index)` for all problems.\n    *   Sort this list in descending order based on difficulty.\n    *   Take the top `k` elements from this sorted list. These are the `k` largest difficulties.\n    *   The sum of these `k` difficulties is the maximum total profit.\n    *   Collect the original indices of these `k` largest difficulties. Let's call these `split_indices`.\n\n2.  **Determine Day Partitions:**\n    *   The `split_indices` represent the positions where we *must* make a cut (or end a segment) to ensure that each of these `k` problems becomes a daily maximum. Specifically, if `idx` is one of these `split_indices`, the problem `a[idx]` must be the last problem of some day, or it must be the first problem of some day. To make it the maximum for its day, it's easiest if it's included in a day that ends at or after its index.\n    *   A simple strategy for partitioning is to sort the `split_indices` in ascending order.\n    *   The first day will cover problems from index `0` up to the problem at the smallest `split_index`.\n    *   Subsequent days will start immediately after the previous day's end and continue up to the next `split_index`.\n    *   The last day will cover problems from the end of the `(k-1)`-th day up to the last problem (`n-1`).\n\n    Let `sorted_split_indices` be the sorted list of original indices of the `k` largest problems.\n    *   The first day ends at `sorted_split_indices[0]`. So, it solves `sorted_split_indices[0] + 1` problems.\n    *   The second day ends at `sorted_split_indices[1]`. It starts right after the first day. So, it solves `sorted_split_indices[1] - sorted_split_indices[0]` problems.\n    *   In general, for `j` from `1` to `k-1`, the `j`-th day (using 0-indexed `sorted_split_indices`) solves problems from `sorted_split_indices[j-1] + 1` to `sorted_split_indices[j]`. The number of problems is `sorted_split_indices[j] - sorted_split_indices[j-1]`.\n    *   The `k`-th day (last day) solves problems from `sorted_split_indices[k-2] + 1` to `n-1`. The number of problems is `n - 1 - (sorted_split_indices[k-2] + 1) + 1 = n - sorted_split_indices[k-2]`.\n\n    This approach ensures that each of the `k` largest problems `a[sorted_split_indices[j]]` is the last problem of its respective day, making it a strong candidate for the maximum of that day. Since we picked the `k` overall largest values, this partition strategy guarantees that these values become the daily maximums.\n\n    **Correction for partition logic:**\n    We need to make `k-1` cuts to divide `n` problems into `k` segments. The `k` largest values' indices are good candidates for where these cuts should occur.\n    Let the sorted indices of the `k` largest values be `i_1, i_2, \\dots, i_k`.\n    We make cuts *after* `k-1` of these indices.\n    For example, if `k=3` and indices are `idx_1, idx_2, idx_3`. We can make cuts after `idx_1` and `idx_2`.\n    Day 1: problems `0` to `idx_1`. Length `idx_1 + 1`.\n    Day 2: problems `idx_1 + 1` to `idx_2`. Length `idx_2 - idx_1`.\n    Day 3: problems `idx_2 + 1` to `n-1`. Length `n - (idx_2 + 1)`.\n    This ensures that `a[idx_1]` is in day 1, `a[idx_2]` in day 2, and `a[idx_3]` (which must be `\\ge a[idx_2]` and `a[idx_1]`) will be in day 3. This works because `idx_3` will be in the last segment.\n\n    So, the `k-1` cuts will be right after `sorted_split_indices[0]`, `sorted_split_indices[1]`, ..., `sorted_split_indices[k-2]`.\n    The lengths of the segments will be:\n    *   `t_1 = sorted_split_indices[0] + 1`\n    *   `t_2 = sorted_split_indices[1] - sorted_split_indices[0]`\n    *   ...\n    *   `t_{k-1} = sorted_split_indices[k-2] - sorted_split_indices[k-3]`\n    *   `t_k = n - (sorted_split_indices[k-2] + 1) + 1 = n - sorted_split_indices[k-2]`\n\n    All `t_j` values must be positive. Since `k \\le n`, and `sorted_split_indices` are distinct and sorted, `sorted_split_indices[j] > sorted_split_indices[j-1]`, so `t_j` for `j=2 \\dots k-1` are positive. `t_1 = sorted_split_indices[0] + 1` is also positive since indices are non-negative. `t_k = n - sorted_split_indices[k-2]` is positive because `sorted_split_indices[k-2]` is an index less than `n`.\n\n**Example Walkthrough:**\n`n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Problems with indices:**\n    `[(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\n2.  **Sort by difficulty (descending):**\n    `[(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)]`\n3.  **Top k=3 elements:**\n    `[(9,6), (6,3), (5,0)]`\n4.  **Maximum total profit:** `9 + 6 + 5 = 20`\n5.  **Split indices:** `[6, 3, 0]`\n6.  **Sort split indices:** `[0, 3, 6]` (These are `i_1, i_2, i_3`)\n7.  **Calculate lengths:**\n    *   `t_1 = i_1 + 1 = 0 + 1 = 1`\n    *   `t_2 = i_2 - i_1 = 3 - 0 = 3`\n    *   `t_3 = n - i_2 = 8 - 3 = 5`\n    This gives `[1, 3, 5]`.\n    The partition would be: `[5], [4,2,6], [5,1,9,2]`.\n    Profits: `5 + 6 + 9 = 20`. This is a valid solution.\n\n    However, the example output is `3 2 3`. Let's re-examine the cut logic.\n    The example output `3 2 3` means:\n    Day 1: `[5, 4, 2]` (max 5)\n    Day 2: `[6, 5]` (max 6)\n    Day 3: `[1, 9, 2]` (max 9)\n    The indices of the maximums are `0` (for 5), `3` (for 6), `6` (for 9). These are exactly the `split_indices` `[0, 3, 6]`.\n    The cuts are *after* index 2 and *after* index 4.\n    The `k-1` *cut points* are the indices `i_1, i_2, \\dots, i_{k-1}` from the sorted `split_indices`.\n    The number of problems for each day would be:\n    *   Day 1: `(sorted_split_indices[0] + 1)` problems. (Cut after `sorted_split_indices[0]`)\n    *   Day 2: `(sorted_split_indices[1] - sorted_split_indices[0])` problems. (Cut after `sorted_split_indices[1]`)\n    *   ...\n    *   Day `k-1`: `(sorted_split_indices[k-2] - sorted_split_indices[k-3])` problems. (Cut after `sorted_split_indices[k-2]`)\n    *   Day `k`: `n - (sorted_split_indices[k-2] + 1) + 1 = n - sorted_split_indices[k-2]` problems. (No cut after `sorted_split_indices[k-1]`)\n\n    This logic is correct if the `k-1` smallest indices from the `k` largest problems are chosen as the *end points* of the first `k-1` segments.\n    Let `split_indices_sorted = [0, 3, 6]` for the example. `k=3`.\n    We need `k-1 = 2` cut points. We pick the first `k-1` elements from `split_indices_sorted` as cut points.\n    Cut points: `0, 3`.\n    Day 1: ends at index `0`. Length `0 - (-1) = 1`. (`t_1 = sorted_split_indices[0] + 1` problems)\n    Day 2: ends at index `3`. Length `3 - 0 = 3`. (`t_2 = sorted_split_indices[1] - sorted_split_indices[0]` problems)\n    Day 3: ends at index `n-1`. Length `n - (3+1) = 8 - 4 = 4`. (`t_k = n - (sorted_split_indices[k-2] + 1)` problems)\n    This results in `[1, 3, 4]`. Still not `[3, 2, 3]`.\n\n    The problem states \"each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list.\" This means we are finding `k-1` split points `p_1, p_2, \\dots, p_{k-1}` such that `0 < p_1 < p_2 < \\dots < p_{k-1} < n`.\n    Day 1: problems `0` to `p_1-1`. Length `p_1`.\n    Day 2: problems `p_1` to `p_2-1`. Length `p_2 - p_1`.\n    ...\n    Day `k`: problems `p_{k-1}` to `n-1`. Length `n - p_{k-1}`.\n\n    The `k` largest values `a[i_1], a[i_2], \\dots, a[i_k]` must each be in a different segment.\n    The most flexible way to ensure this is to make cuts *after* `k-1` of these `k` indices.\n    Let `split_indices_sorted` be the sorted list of indices of the `k` largest values.\n    `split_indices_sorted = [0, 3, 6]` for the example.\n    We need to make `k-1 = 2` cuts. We can make cuts after indices `0` and `3`.\n    Cut after `0`: `[5] | [4, 2, 6, 5, 1, 9, 2]`\n    Cut after `3`: `[5] | [4, 2, 6] | [5, 1, 9, 2]`\n    Lengths: `1, 3, 4`. This is `[1,3,4]`. Still not `[3,2,3]`.\n\n    The example output `[3, 2, 3]` means cuts after index `2` and index `4`.\n    The `k` largest values are `a[0]=5`, `a[3]=6`, `a[6]=9`.\n    In `[5, 4, 2]`, `a[0]=5` is the max.\n    In `[6, 5]`, `a[3]=6` is the max.\n    In `[1, 9, 2]`, `a[6]=9` is the max.\n    This works. The crucial observation is that the *cut points* don't have to be exactly at the indices of the `k` largest values. They just need to be such that each of the `k` largest values falls into a different segment and becomes its maximum.\n\n    The simplest way to achieve this is to make cuts *immediately after* `k-1` of the `k` largest values.\n    Let `indices_of_k_largest` be the sorted list of indices of the `k` largest values.\n    `sorted_indices = [0, 3, 6]` for the example.\n    We need `k-1` cut points. We will use the first `k-1` indices from `sorted_indices` as the points *after which* we make a cut.\n    So, cuts are made after `sorted_indices[0]` and `sorted_indices[1]`.\n    Cut points are `sorted_indices[0]`, `sorted_indices[1]`, ..., `sorted_indices[k-2]`.\n    The lengths will be:\n    `t_1 = sorted_indices[0] + 1`\n    `t_2 = sorted_indices[1] - sorted_indices[0]`\n    ...\n    `t_{k-1} = sorted_indices[k-2] - sorted_indices[k-3]`\n    `t_k = n - (sorted_indices[k-2] + 1)` (This is the number of remaining problems after the last cut)\n\n    Let's re-apply this to the example: `sorted_indices = [0, 3, 6]`, `n=8, k=3`.\n    Cut points (indices to cut after): `sorted_indices[0]=0`, `sorted_indices[1]=3`.\n    `t_1 = (0) + 1 = 1`\n    `t_2 = (3) - (0) = 3`\n    `t_3 = n - (3+1) = 8 - 4 = 4`\n    Result `[1, 3, 4]`. This is *a* valid answer, but not the example's `[3, 2, 3]`. Any valid answer is fine.\n\n    Let's try the example `[3, 2, 3]` again. This means cuts after index `2` and index `4`.\n    `a[0]=5` is in the first segment `[5,4,2]`.\n    `a[3]=6` is in the second segment `[6,5]`.\n    `a[6]=9` is in the third segment `[1,9,2]`.\n    The indices of the chosen maximums are `0, 3, 6`. The cut points are `2, 4`. These cut points are not directly related to the indices of the maximums.\n    The key is that the `k` largest values *must* be in different segments.\n    My current strategy:\n    1. Find `k` largest values and their original indices.\n    2. Sum these values for total profit.\n    3. Sort these `k` indices `idx_1 < idx_2 < \\dots < idx_k`.\n    4. The cuts are made after `idx_1`, `idx_2`, ..., `idx_{k-1}`.\n    5. The segment lengths are:\n        * `idx_1 + 1`\n        * `idx_2 - idx_1`\n        * ...\n        * `idx_k - idx_{k-1}`\n        * `n - idx_k - 1` (This is wrong, this would be `k+1` segments if `idx_k < n-1`)\n\n    The correct way to use the `k-1` smallest indices from the `k` largest problems as cut points:\n    Let `split_indices` be the sorted list of indices of the `k` largest difficulties.\n    `t_lengths = []`\n    `current_start_index = 0`\n    For `j` from `0` to `k-2`:\n        The `j`-th segment ends at `split_indices[j]`.\n        Its length is `split_indices[j] - current_start_index + 1`.\n        `t_lengths.append(split_indices[j] - current_start_index + 1)`\n        `current_start_index = split_indices[j] + 1`\n    The last segment (k-th segment) goes from `current_start_index` to `n-1`.\n    Its length is `n - current_start_index`.\n    `t_lengths.append(n - current_start_index)`\n\n    Let's re-apply to example: `n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n    `k` largest values are `9, 6, 5`. Their indices are `6, 3, 0`.\n    Sorted indices: `split_indices = [0, 3, 6]`.\n    `t_lengths = []`\n    `current_start_index = 0`\n\n    `j = 0`: (first segment, ends at `split_indices[0]=0`)\n        Length: `0 - 0 + 1 = 1`. `t_lengths = [1]`.\n        `current_start_index = 0 + 1 = 1`.\n\n    `j = 1`: (second segment, ends at `split_indices[1]=3`)\n        Length: `3 - 1 + 1 = 3`. `t_lengths = [1, 3]`.\n        `current_start_index = 3 + 1 = 4`.\n\n    `j = k-1 = 2` (loop ends, process last segment):\n        Last segment length: `n - current_start_index = 8 - 4 = 4`.\n        `t_lengths = [1, 3, 4]`.\n\n    This is still `[1, 3, 4]`. The problem statement says \"If there are many possible answers, you may print any of them.\" So `[1, 3, 4]` is a perfectly valid output.\n\n    Let's consider the third example: `n=4, k=2, a=[1, 2000, 2000, 2]`\n    1.  Problems with indices: `[(1,0), (2000,1), (2000,2), (2,3)]`\n    2.  Sort by difficulty (descending): `[(2000,1), (2000,2), (2,3), (1,0)]`\n    3.  Top k=2 elements: `[(2000,1), (2000,2)]`\n    4.  Max total profit: `2000 + 2000 = 4000`\n    5.  Split indices: `[1, 2]`\n    6.  Sorted indices: `split_indices = [1, 2]`\n    7.  `t_lengths = []`, `current_start_index = 0`\n\n    `j = 0`: (first segment, ends at `split_indices[0]=1`)\n        Length: `1 - 0 + 1 = 2`. `t_lengths = [2]`.\n        `current_start_index = 1 + 1 = 2`.\n\n    `j = k-1 = 1` (loop ends, process last segment):\n        Last segment length: `n - current_start_index = 4 - 2 = 2`.\n        `t_lengths = [2, 2]`.\n\n    Output: `4000\\n2 2`. This matches the example output. So the logic for calculating `t_lengths` appears to be correct and produces a valid answer.\n\n**Implementation Details:**\n\n*   Read `n` and `k`.\n*   Read array `a`.\n*   Create `problem_data = [(a[i], i) for i in range(n)]`.\n*   Sort `problem_data` by difficulty in descending order.\n*   Extract the top `k` elements. Sum their difficulties for `max_profit`.\n*   Extract their original indices into `split_indices`.\n*   Sort `split_indices` in ascending order.\n*   Calculate `t_lengths` using the logic described above.\n*   Print `max_profit`.\n*   Print `t_lengths` joined by spaces.\n\n**Constraints Check:**\n`n, k <= 2000`.\nSorting `n` elements takes `O(N log N)`.\nExtracting and sorting `k` indices takes `O(K log K)`.\nCalculating `t_lengths` takes `O(K)`.\nOverall time complexity: `O(N log N)`, which is efficient enough for `N=2000`.\n`2000 log 2000` is roughly `2000 * 11 = 22000` operations, well within typical time limits.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Find the k largest difficulties and their original indices\n    # Store as (difficulty, original_index) tuples\n    problem_data = []\n    for i in range(n):\n        problem_data.append((a[i], i))\n\n    # Sort by difficulty in descending order\n    # If difficulties are equal, the original index doesn't matter for profit,\n    # but for consistent splitting, it's good practice to have a stable sort or\n    # a secondary sort key (e.g., by index) if required, though not strictly needed here.\n    # Python's sort is stable.\n    problem_data.sort(key=lambda x: x[0], reverse=True)\n\n    # Extract the top k difficulties and their indices\n    top_k_problems = problem_data[:k]\n\n    # Calculate maximum total profit\n    max_profit = sum(p[0] for p in top_k_problems)\n\n    # Extract the original indices of these k problems\n    # These indices will define the \"cuts\" for our segments\n    split_indices = []\n    for p in top_k_problems:\n        split_indices.append(p[1])\n\n    # Sort the split_indices in ascending order\n    # This is crucial for correctly determining segment lengths\n    split_indices.sort()\n\n    # Step 2: Determine the number of problems for each day (t_j)\n    t_lengths = []\n    current_start_index = 0\n\n    # We need k-1 cuts. The first k-1 sorted split_indices will be the end points\n    # of the first k-1 segments.\n    for j in range(k - 1):\n        # The j-th segment (0-indexed) ends at split_indices[j]\n        # Its length is (split_indices[j] - current_start_index + 1)\n        length = split_indices[j] - current_start_index + 1\n        t_lengths.append(length)\n        # The next segment starts immediately after this one\n        current_start_index = split_indices[j] + 1\n\n    # The last segment (k-th segment) covers the remaining problems\n    # from current_start_index to n-1\n    last_segment_length = n - current_start_index\n    t_lengths.append(last_segment_length)\n\n    # Output the results\n    sys.stdout.write(str(max_profit) + '\\n')\n    sys.stdout.write(' '.join(map(str, t_lengths)) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Find the k largest difficulties and their original indices\n    # Store as (difficulty, original_index) tuples\n    problem_data = []\n    for i in range(n):\n        problem_data.append((a[i], i))\n\n    # Sort by difficulty in descending order\n    # If difficulties are equal, the original index doesn't matter for profit,\n    # but for consistent splitting, it's good practice to have a stable sort or\n    # a secondary sort key (e.g., by index) if required, though not strictly needed here.\n    # Python's sort is stable.\n    problem_data.sort(key=lambda x: x[0], reverse=True)\n\n    # Extract the top k difficulties and their indices\n    top_k_problems = problem_data[:k]\n\n    # Calculate maximum total profit\n    max_profit = sum(p[0] for p in top_k_problems)\n\n    # Extract the original indices of these k problems\n    # These indices will define the \"cuts\" for our segments\n    split_indices = []\n    for p in top_k_problems:\n        split_indices.append(p[1])\n\n    # Sort the split_indices in ascending order\n    # This is crucial for correctly determining segment lengths\n    split_indices.sort()\n\n    # Step 2: Determine the number of problems for each day (t_j)\n    t_lengths = []\n    current_start_index = 0\n\n    # We need k-1 cuts. The first k-1 sorted split_indices will be the end points\n    # of the first k-1 segments.\n    for j in range(k - 1):\n        # The j-th segment (0-indexed) ends at split_indices[j]\n        # Its length is (split_indices[j] - current_start_index + 1)\n        length = split_indices[j] - current_start_index + 1\n        t_lengths.append(length)\n        # The next segment starts immediately after this one\n        current_start_index = split_indices[j] + 1\n\n    # The last segment (k-th segment) covers the remaining problems\n    # from current_start_index to n-1\n    last_segment_length = n - current_start_index\n    t_lengths.append(last_segment_length)\n\n    # Output the results\n    sys.stdout.write(str(max_profit) + '\\n')\n    sys.stdout.write(' '.join(map(str, t_lengths)) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 973,
        "completion_token_count": 6187,
        "thoughts_token_count": 850
    }
}