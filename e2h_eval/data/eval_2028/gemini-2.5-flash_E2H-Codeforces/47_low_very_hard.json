{
    "start": 1758284877.0554643,
    "end": 1758284903.3171675,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Tackling the LCM Minimization Problem**\n\nAlright, I'm diving into this competitive programming problem. The core is finding the smallest non-negative integer `k` that minimizes the least common multiple of `a+k` and `b+k`.  I'm thinking about how to frame this effectively.  Let's define `x = a+k` and `y = b+k`, and we're aiming to minimize `lcm(x, y)`. The relationship between LCM and GCD is key here: `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nMy initial thought is that the greatest common divisor, `g`, plays a crucial role.  Let `g = gcd(a+k, b+k)`.  If `g` divides both `a+k` and `b+k`, it also has to divide their difference, which is `b-a`.  This gives us a solid lead. Let's call `d = |b - a|`. So, `g` must be a divisor of `d`.\n\nThere's a special case to address: what if `a = b`? In that scenario, `d = 0`, and the GCD becomes `a+k`.  The LCM becomes simply `a+k`. To minimize this, we want the smallest `k`, which is obviously 0. So, if `a=b`, the answer is `k=0`. Easy enough.\n\nNow, let's assume `a` is not equal to `b`.  Without loss of generality, let's say `a < b`. So, `d = b - a > 0`.  This means `g` must be a divisor of `d`. We're aiming to minimize  `lcm(a+k, b+k) = ((a+k) * (b+k)) / g`. Since `g` is a divisor of `d`, the core of the problem then comes down to iterating through all possible divisors of `d`.\n\nFor each divisor `g` of `d`, I need to find a `k` that makes `a+k` and `b+k` multiples of `g`.  That means `a+k ≡ 0 (mod g)`. This also implies that `k ≡ -a (mod g)`. The smallest non-negative `k` that satisfies this is basically `(-a % g + g) % g`. Let's call that `k_0`.  Since `g` divides `d`, and also divides `a+k_0`, it will also divide `(a+k_0)+d = b+k_0`. So this `k_0` is indeed a valid solution for that `g`.\n\nNow, the plan is to compute the `lcm(a+k_0, b+k_0)` for each of these divisors `g`, and maintain a running minimum, along with the corresponding `k`. The final answer will be the `k` that yields the overall minimum LCM across all tested divisors.\n",
    "response": "The problem asks us to find a non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If there are multiple such `k`, we should choose the smallest one.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nLet `g = gcd(x, y) = gcd(a+k, b+k)`.\nA fundamental property of GCD is that `gcd(A, B) = gcd(A, B-A)`.\nApplying this, `g = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a)`.\nThis means that `g` must be a divisor of `|b-a|`.\n\nLet `d = |b-a|`.\n\n**Case 1: `a = b`**\nIf `a = b`, then `d = 0`.\n`gcd(a+k, b+k) = gcd(a+k, a+k) = a+k`.\n`lcm(a+k, b+k) = lcm(a+k, a+k) = a+k`.\nTo minimize `a+k`, we should choose the smallest non-negative `k`, which is `k=0`.\nThe minimum `lcm` is `a`.\nSo, if `a = b`, the answer is `k=0`.\n\n**Case 2: `a != b`**\nIf `a != b`, then `d = |b-a| > 0`.\n`g` must be a positive divisor of `d`.\nWe can iterate through all positive divisors `g` of `d`. For each `g`, we need to find the smallest non-negative `k` such that `gcd(a+k, b+k)` is at least `g`.\nFor `gcd(a+k, b+k)` to be `g` (or a multiple of `g`), both `a+k` and `b+k` must be multiples of `g`.\nThis means:\n`a+k \\equiv 0 \\pmod g`\n`k \\equiv -a \\pmod g`\n\nThe smallest non-negative `k` that satisfies this condition is `k_g = (-a % g + g) % g`.\nLet's verify this `k_g`:\n`a+k_g` will be a multiple of `g`.\n`b+k_g = (a+d)+k_g = (a+k_g)+d`. Since `a+k_g` is a multiple of `g` and `d` is a multiple of `g` (because `g` is a divisor of `d`), `b+k_g` will also be a multiple of `g`.\nThus, for this `k_g`, `gcd(a+k_g, b+k_g)` will be a multiple of `g`.\n\nFor each divisor `g` of `d`, we calculate `k_g = (-a % g + g) % g`.\nThen we calculate `current_lcm = lcm(a+k_g, b+k_g)`.\nWe keep track of the minimum `lcm` found so far (`min_lcm`) and the corresponding smallest `k` (`ans_k`).\nInitialize `min_lcm` to a very large value (e.g., `float('inf')`) and `ans_k` to `0`.\n\nWhen comparing `current_lcm` with `min_lcm`:\n1. If `current_lcm < min_lcm`:\n   Update `min_lcm = current_lcm` and `ans_k = k_g`.\n2. If `current_lcm == min_lcm`:\n   Update `ans_k = min(ans_k, k_g)` (since we need the smallest `k`).\n\n**Algorithm Steps:**\n1. Read `a` and `b`.\n2. If `a == b`, print `0` and exit.\n3. Calculate `d = abs(b-a)`.\n4. Find all divisors of `d`. We can do this by iterating from `1` up to `sqrt(d)`. If `i` divides `d`, then both `i` and `d/i` are divisors.\n5. Initialize `min_lcm = float('inf')` and `ans_k = 0`.\n6. For each divisor `g` of `d`:\n   a. Calculate `k_g = (-a % g + g) % g`.\n   b. Calculate `val_a = a + k_g` and `val_b = b + k_g`.\n   c. Calculate `current_gcd = gcd(val_a, val_b)`. (Using `math.gcd` is efficient)\n   d. Calculate `current_lcm = (val_a // current_gcd) * val_b`. (This avoids potential overflow from `val_a * val_b` if `val_a` and `val_b` are large, before division by `gcd`)\n   e. Compare `current_lcm` with `min_lcm`:\n      i. If `current_lcm < min_lcm`:\n         `min_lcm = current_lcm`\n         `ans_k = k_g`\n      ii. Else if `current_lcm == min_lcm`:\n         `ans_k = min(ans_k, k_g)`\n7. Print `ans_k`.\n\n**Example Walkthrough (a=6, b=10):**\n1. `a=6, b=10`. `a != b`.\n2. `d = abs(10-6) = 4`.\n3. Divisors of `4`: `1, 2, 4`.\n4. `min_lcm = inf`, `ans_k = 0`.\n\n   * **For `g = 1`:**\n     `k_1 = (-6 % 1 + 1) % 1 = 0`.\n     `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n     `current_gcd = gcd(6, 10) = 2`.\n     `current_lcm = (6 // 2) * 10 = 3 * 10 = 30`.\n     `min_lcm = 30`, `ans_k = 0`.\n\n   * **For `g = 2`:**\n     `k_2 = (-6 % 2 + 2) % 2 = 0`.\n     `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n     `current_gcd = gcd(6, 10) = 2`.\n     `current_lcm = (6 // 2) * 10 = 3 * 10 = 30`.\n     `current_lcm (30) == min_lcm (30)`, so `ans_k = min(0, 0) = 0`.\n\n   * **For `g = 4`:**\n     `k_4 = (-6 % 4 + 4) % 4 = (-2 + 4) % 4 = 2`.\n     `val_a = 6+2 = 8`, `val_b = 10+2 = 12`.\n     `current_gcd = gcd(8, 12) = 4`.\n     `current_lcm = (8 // 4) * 12 = 2 * 12 = 24`.\n     `current_lcm (24) < min_lcm (30)`, so `min_lcm = 24`, `ans_k = 2`.\n\n5. Final `ans_k = 2`.\n\n**Constraints:**\n`1 <= a, b <= 10^9`.\n`d = |b-a|` can be up to `10^9 - 1`.\nThe number of divisors for a number up to `10^9` is relatively small. The maximum number of divisors for a number less than `10^9` is for `735134400` (which has 1344 divisors) or `831600000` (which has 1280 divisors). Iterating through these divisors and performing GCD/LCM calculations is efficient enough. `sqrt(10^9)` is approximately `31622`.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    min_lcm_val = float('inf')\n    best_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    # Iterate through each divisor g\n    for g in divisors:\n        # We need a+k to be a multiple of g\n        # k = (-a % g + g) % g\n        # This k ensures a+k is a multiple of g.\n        # Since diff is a multiple of g, b+k = (a+diff)+k = (a+k)+diff will also be a multiple of g.\n        k_candidate = (g - (a % g)) % g\n        \n        val_a = a + k_candidate\n        val_b = b + k_candidate\n        \n        current_gcd = math.gcd(val_a, val_b)\n        \n        # Calculate LCM: (val_a * val_b) / current_gcd\n        # To prevent potential overflow if val_a * val_b is too large,\n        # calculate as (val_a // current_gcd) * val_b\n        current_lcm = (val_a // current_gcd) * val_b\n\n        if current_lcm < min_lcm_val:\n            min_lcm_val = current_lcm\n            best_k = k_candidate\n        elif current_lcm == min_lcm_val:\n            best_k = min(best_k, k_candidate)\n\n    print(best_k)\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    min_lcm_val = float('inf')\n    best_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    # Iterate through each divisor g\n    for g in divisors:\n        # We need a+k to be a multiple of g\n        # k = (-a % g + g) % g\n        # This k ensures a+k is a multiple of g.\n        # Since diff is a multiple of g, b+k = (a+diff)+k = (a+k)+diff will also be a multiple of g.\n        k_candidate = (g - (a % g)) % g\n        \n        val_a = a + k_candidate\n        val_b = b + k_candidate\n        \n        current_gcd = math.gcd(val_a, val_b)\n        \n        # Calculate LCM: (val_a * val_b) / current_gcd\n        # To prevent potential overflow if val_a * val_b is too large,\n        # calculate as (val_a // current_gcd) * val_b\n        current_lcm = (val_a // current_gcd) * val_b\n\n        if current_lcm < min_lcm_val:\n            min_lcm_val = current_lcm\n            best_k = k_candidate\n        elif current_lcm == min_lcm_val:\n            best_k = min(best_k, k_candidate)\n\n    print(best_k)\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 2443,
        "thoughts_token_count": 858
    }
}