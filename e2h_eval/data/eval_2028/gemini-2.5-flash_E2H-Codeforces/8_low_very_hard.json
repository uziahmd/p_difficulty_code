{
    "start": 1758009374.9347956,
    "end": 1758009549.0829387,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:59 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Okay, here's the mental breakdown of how I'm approaching this \"Flawed Flow\" problem:**\n\nRight, I need to write a Python script for this. Let's start by understanding the problem details. We're given a graph with *n* vertices and *m* undirected edges. Each edge has a capacity *c*. The goal is to direct these edges, assigning a direction (0 or 1) to each edge in the input, such that a valid flow is established. A \"valid flow\" has a few conditions, which I'll need to satisfy.\n\nFirst, there's the **flow conservation principle**. For every vertex *except* the source (vertex 1) and the sink (vertex *n*), the amount of flow *in* must equal the amount of flow *out*.  The problem guarantees that a solution always exists, so this must be possible.\n\nThe **source (vertex 1)** has no incoming edges. All the flow originating from this node goes outward. This is a crucial starting point.\n\nThe **sink (vertex *n*)** is a bit less clearly defined.  We are not given explicit information if this node will have outgoing edges, but the text on flow conservation makes me believe that this vertex *can* have outgoing edges. However, the problem also requires that the directed graph be **acyclic**.  A DAG will ensure that there are no cycles and all flow goes from an \"earlier\" vertex in the topological sort to a \"later\" vertex, meaning that a *n* will have no outgoing edges. This is also important. So, I will assume that the total flow *out* of the source must eventually reach the sink.\n\nThere is a guarantee that no two edges connect the same vertices, and the graph is connected. That's good; it simplifies things. The constraints on *n*, *m*, and *c* are also within reasonable bounds for computation.\n\nSo, here's my strategy. I need to figure out a method to direct these edges while adhering to the flow conservation, source, sink, and acyclicity rules. The fact that a solution *always* exists is a huge hint. This implies there's a specific order of direction that is valid. I'm thinking of focusing on finding a valid topological sort, and then direct edges from lower to higher vertices. I'll need to carefully consider the edge capacities to ensure flow conservation at all internal nodes. Let's start with a Python implementation based on this thought process.\n",
    "response": "The problem asks us to direct each edge of a given undirected graph, which has associated flow volumes, such that specific conditions are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  **Source (vertex 1):** Vertex 1 has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n\nWe are guaranteed that a solution always exists.\n\nLet's analyze the conditions:\n\n*   **Source (vertex 1) having no incoming edges:** This implies that all edges connected to vertex 1 must be directed *away* from it.\n*   **Acyclicity:** This is a strong condition. A directed acyclic graph (DAG) means we can find a topological ordering of vertices. If we direct edges such that flow always goes from an earlier vertex to a later vertex in some topological order, acyclicity is guaranteed.\n\nConsider the total flow. The total flow leaving vertex 1 must equal the total flow entering vertex `n`. For any other vertex `v`, the net flow is zero. This means for `v != 1, n`, `in_flow[v] = out_flow[v]`.\n\nLet `total_flow_out_of_1` be the sum of `ci` for all edges connected to vertex 1. This must be the total flow value of the max-flow.\nFor any vertex `v` (1 < `v` < `n`), we need to decide directions for its incident edges such that its `in_flow` equals its `out_flow`.\nFor vertex `n`, the total flow entering it must be `total_flow_out_of_1`.\n\nThe crucial insight often found in flow problems with acyclicity is that we can try to find a topological ordering. If we can assign a \"depth\" or \"level\" to each vertex such that flow always goes from a lower level to a higher level, then acyclicity is guaranteed.\n\nLet's think about how to satisfy the flow conservation and source conditions.\nFor vertex 1, all edges must be outgoing. This sets their direction.\nFor any other vertex `v`, we have a set of undirected edges `(v, u_1), (v, u_2), ...` with given capacities. We need to split these into incoming and outgoing edges such that `sum(incoming_ci) = sum(outgoing_ci)`.\n\nThis looks like a problem that can be solved with a traversal, such as Breadth-First Search (BFS) or Depth-First Search (DFS), starting from the source (vertex 1).\n\nConsider a DFS approach:\nWhen we perform a DFS from vertex 1, we visit vertices in a \"depth-first\" manner. If we always direct edges away from the current vertex we are visiting and towards unvisited neighbors, this naturally creates a path-like structure. However, this simple approach doesn't guarantee flow conservation for intermediate vertices or acyclicity in general.\n\nLet's refine the DFS idea. We need to keep track of the \"balance\" for each vertex. For a vertex `v`, let `balance[v]` be `in_flow[v] - out_flow[v]`. We want `balance[v] = 0` for `1 < v < n`.\nInitially, `balance[v] = 0` for all `v`.\nWhen we direct an edge `u -> v` with flow `c`, `balance[u]` decreases by `c` and `balance[v]` increases by `c`.\n\nThe condition \"vertex with number 1 has no incoming edges\" is key. This means all edges connected to vertex 1 must be directed `1 -> u`. This fixes the initial outgoing flow from vertex 1.\n\nLet's try a DFS traversal starting from vertex 1. For each vertex `u` we visit, we iterate through its neighbors `v` via an undirected edge `(u, v)` with capacity `c`.\n1.  If `v` has not been visited yet, we can tentatively direct the edge `u -> v`. This would contribute `c` to `out_flow[u]` and `in_flow[v]`. We then recursively call DFS on `v`.\n2.  After the recursive call returns (meaning `v` and its subtree have been processed), we need to ensure flow conservation for `v`. The `balance[v]` will have accumulated some value. If `balance[v]` is positive, it means more flow came into `v` than left it through edges directed away from `v` within its subtree. This excess flow must exit `v` through the edge `(v, u)` that brought us to `v` (i.e., `v -> u`). If `balance[v]` is negative, it means `v` needs more incoming flow, which cannot be satisfied by `(v, u)` as `u` is its parent.\n\nThis suggests that a DFS from vertex 1 can determine directions for edges in a specific way:\n*   When DFS explores an edge `(u, v)` where `v` is unvisited, we add `v` to the DFS tree with `u` as its parent. We provisionally assume flow `u -> v`.\n*   After visiting all children of `v` and returning from their DFS calls, `v` will have accumulated some net flow from its children. Let's say `v` has a net `current_flow_balance` from its children and other non-parent edges.\n*   If `current_flow_balance` is positive, it means `v` has an excess of flow. This excess must be sent *up* the DFS tree, towards its parent `u`. So, we direct `v -> u` for the edge `(u, v)` and add `current_flow_balance` to `u`'s incoming flow.\n*   If `current_flow_balance` is negative, it means `v` needs more flow. This deficit must be covered by flow coming *down* from its parent `u`. So, we direct `u -> v` for the edge `(u, v)` and subtract `abs(current_flow_balance)` from `u`'s outgoing flow.\n\nThis approach works because it processes vertices from leaves of the DFS tree upwards to the root (vertex 1). Each vertex `v` (except `n`) must have zero net flow.\nThe total flow out of vertex 1 must be equal to the total flow into vertex `n`.\nThe `balance[v]` variable can store `in_flow[v] - out_flow[v]`. We want `balance[v] = 0` for `1 < v < n`.\n\nLet's refine the DFS:\n`dfs(u, p, edge_id_to_p)`:\n*   `visited[u] = true`\n*   `current_balance_at_u = 0` (this will be the net flow that needs to be passed to/from `u`'s parent `p`)\n*   For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue (don't go back immediately to parent).\n    *   If `v` is *not* visited:\n        *   `child_balance = dfs(v, u, idx)`\n        *   If `child_balance > 0`: (excess flow from `v` needs to go to `u`)\n            *   `ans[idx] = 1` (direct `v -> u`)\n            *   `current_balance_at_u += child_balance`\n        *   Else (`child_balance <= 0`): (deficit at `v` needs flow from `u`)\n            *   `ans[idx] = 0` (direct `u -> v`)\n            *   `current_balance_at_u += child_balance`\n    *   Else (`v` is visited and `v != p`): This is a back-edge in the DFS tree.\n        *   To avoid cycles, flow must go from the deeper node to the shallower node. In DFS, `u` is deeper than `v`. So, we must direct `u -> v`.\n        *   `ans[idx] = 0` (direct `u -> v`)\n        *   `current_balance_at_u -= c` (flow `c` leaves `u`)\n\nWait, the back-edge handling is tricky. `u -> v` for a back-edge means `u` is sending flow to an ancestor `v`. This contributes to `out_flow[u]`.\nThe `balance` logic should be:\n`dfs(u, p)` returns the net flow that `u` needs to receive from its parent `p` (if negative) or send to its parent `p` (if positive).\n\nLet `total_flow_from_1` be the sum of all `c_i` for edges incident to vertex 1. This is the total flow in the graph.\nLet `flow_balance[v]` be the required net flow for vertex `v` from its parent. Initialize `flow_balance[v] = 0` for all `v`.\n\nRevised DFS approach:\n`dfs(u, p)`:\n1.  Mark `u` as visited.\n2.  `current_net_flow_at_u = 0` (this represents `in_flow - out_flow` for `u` excluding the edge to `p`).\n3.  For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `v` is *not* visited:\n        *   `net_flow_from_v = dfs(v, u)` (This is the net flow `v` wants to send to `u` or receive from `u`)\n        *   If `net_flow_from_v > 0`: (excess flow from `v` needs to go to `u`)\n            *   `ans[idx] = 1` (direct `v -> u`)\n            *   `current_net_flow_at_u += net_flow_from_v`\n        *   Else (`net_flow_from_v <= 0`): (deficit at `v` needs flow from `u`)\n            *   `ans[idx] = 0` (direct `u -> v`)\n            *   `current_net_flow_at_u += net_flow_from_v` (this is a negative value, so it subtracts from `u`'s net flow)\n    *   Else (`v` is visited and `v != p`): This is a back-edge. `u` is a descendant of `v`.\n        *   For acyclicity, flow must go `u -> v`.\n        *   `ans[idx] = 0` (direct `u -> v`)\n        *   `current_net_flow_at_u -= c` (flow `c` leaves `u`)\n\n4.  After processing all neighbors:\n    *   If `u == n`:\n        *   `current_net_flow_at_u` should be `total_flow_from_1`. We need to return this value to its parent.\n        *   `return current_net_flow_at_u`\n    *   If `u == 1`:\n        *   `current_net_flow_at_u` should be `total_flow_from_1`. This is the total outgoing flow from 1. We don't return anything to a parent. The initial call `dfs(1, 0)` will handle this.\n    *   If `1 < u < n`:\n        *   `current_net_flow_at_u` must be 0 for flow conservation. The problem guarantees a solution exists, so this will hold.\n        *   `return current_net_flow_at_u` (which is 0)\n\nThis logic is almost correct, but `current_net_flow_at_u` is the sum of flows on edges *other than* the parent edge. The returned value should be the flow on the parent edge.\n\nLet's use a simpler formulation: `dfs(u, p)` returns the amount of flow that *must* be directed from `p` to `u` (`+ve` value) or from `u` to `p` (`-ve` value) to satisfy flow conservation for `u` and its subtree.\n\n`dfs(u, p)`:\n1.  Mark `u` as visited.\n2.  `balance_at_u = 0` (This will track the sum of `c_i` for edges `v -> u` minus `c_i` for edges `u -> v` for all *processed* edges other than `(u, p)`).\n3.  For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `v` is *not* visited:\n        *   `flow_to_send_from_p_to_v = dfs(v, u)`\n        *   If `flow_to_send_from_p_to_v > 0`: (This means `v` needs `flow_to_send_from_p_to_v` from `u`)\n            *   `ans[idx] = 0` (direct `u -> v`)\n            *   `balance_at_u -= flow_to_send_from_p_to_v`\n        *   Else (`flow_to_send_from_p_to_v <= 0`): (This means `v` has `abs(flow_to_send_from_p_to_v)` excess flow to send to `u`)\n            *   `ans[idx] = 1` (direct `v -> u`)\n            *   `balance_at_u -= flow_to_send_from_p_to_v` (since `flow_to_send_from_p_to_v` is negative, this adds to `balance_at_u`)\n    *   Else (`v` is visited and `v != p`): This is a back-edge. `u` is a descendant of `v`.\n        *   For acyclicity, flow must go `u -> v`.\n        *   `ans[idx] = 0` (direct `u -> v`)\n        *   `balance_at_u -= c` (flow `c` leaves `u`)\n\n4.  After processing all neighbors:\n    *   If `u == n`:\n        *   The total flow entering `n` must be `total_flow_from_1`.\n        *   `balance_at_u` currently represents `in_flow - out_flow` from all edges *except* `(u, p)`.\n        *   The flow that needs to come into `n` from `p` is `total_flow_from_1 - balance_at_u`.\n        *   `return total_flow_from_1 - balance_at_u`\n    *   If `1 < u < n`:\n        *   For flow conservation, `balance_at_u` must be 0.\n        *   So, the flow on edge `(u, p)` must exactly balance `balance_at_u`.\n        *   `return -balance_at_u` (if `balance_at_u` is positive, `u` has excess flow, so `u -> p`, return negative. If `balance_at_u` is negative, `u` has deficit, so `p -> u`, return positive).\n    *   If `u == 1`:\n        *   The DFS is initiated from 1. It doesn't have a parent.\n        *   The total flow leaving 1 must be `total_flow_from_1`.\n        *   `balance_at_u` currently represents `in_flow - out_flow` for all edges connected to 1.\n        *   Since all edges connected to 1 must be outgoing, `balance_at_u` should be `-total_flow_from_1`.\n        *   The `dfs` call for 1 will manage its children's requests.\n\nLet's simplify the `balance_at_u` definition.\n`dfs(u, p)` returns the net flow *out* of `u` (positive if outgoing, negative if incoming) through the edge `(u, p)`.\n\n`dfs(u, p)`:\n1.  Mark `u` as visited.\n2.  `net_flow_from_children = 0` (This accumulates flow that `u` receives from its children or sends to its children)\n3.  For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `v` is *not* visited:\n        *   `flow_on_uv_edge = dfs(v, u)` (This is the flow `v` sends to `u` if positive, or `u` sends to `v` if negative)\n        *   If `flow_on_uv_edge > 0`: (Flow `v -> u`)\n            *   `ans[idx] = 1`\n            *   `net_flow_from_children += flow_on_uv_edge`\n        *   Else (`flow_on_uv_edge <= 0`): (Flow `u -> v`)\n            *   `ans[idx] = 0`\n            *   `net_flow_from_children += flow_on_uv_edge`\n    *   Else (`v` is visited and `v != p`): This is a back-edge. `u` is a descendant of `v`.\n        *   For acyclicity, flow must go `u -> v`.\n        *   `ans[idx] = 0`\n        *   `net_flow_from_children -= c` (flow `c` leaves `u`)\n\n4.  After processing all neighbors:\n    *   If `u == n`:\n        *   The total flow entering `n` must be `total_flow_from_1`.\n        *   The current `net_flow_from_children` is the sum of `in_flow - out_flow` for all edges *except* `(u, p)`.\n        *   So, `total_flow_from_1 = net_flow_from_children + flow_from_p_to_u_on_up_edge`.\n        *   Therefore, `flow_from_p_to_u_on_up_edge = total_flow_from_1 - net_flow_from_children`.\n        *   This is the flow that must come *into* `n` from `p`. So, it's a positive value returned.\n        *   `return total_flow_from_1 - net_flow_from_children`\n    *   If `1 < u < n`:\n        *   For flow conservation, `net_flow_from_children + flow_from_p_to_u_on_up_edge = 0`.\n        *   So, `flow_from_p_to_u_on_up_edge = -net_flow_from_children`.\n        *   `return -net_flow_from_children`\n    *   If `u == 1`:\n        *   This is the source. It has no parent.\n        *   The `net_flow_from_children` should sum up to `-total_flow_from_1` (all flow leaves 1).\n        *   The initial call `dfs(1, 0)` will just run and set `ans` for all edges. The return value is not used.\n\n**Initial setup:**\n1.  Read `n, m`.\n2.  Create adjacency list `adj` where `adj[u]` stores `(v, c, idx)`.\n3.  Store edges in a list `edges` to access `a_i, b_i, c_i` later if needed, but `adj` and `ans` array indexed by `idx` should be enough.\n4.  Initialize `ans` array of size `m` with placeholder values.\n5.  Initialize `visited` array to `False`.\n6.  Calculate `total_flow_from_1`: sum of `c_i` for all edges connected to vertex 1.\n\n**Main call:**\n`dfs(1, 0)` (0 is a dummy parent for vertex 1).\n\nThis DFS approach correctly handles flow conservation for intermediate nodes and the source/sink conditions. Acyclicity is ensured because:\n*   Tree edges are directed either `parent -> child` or `child -> parent`. Since we process children fully before deciding direction for the parent edge, and the parent's decision is based on children's needs, this effectively creates a \"topological-like\" ordering within the DFS tree.\n*   Back-edges `u -> v` (where `v` is an ancestor of `u`) are always directed `u -> v`. This also follows a topological order (descendant to ancestor).\nThis makes sure that flow generally moves from \"earlier\" (in DFS traversal order, or higher in DFS tree) to \"later\" (lower in DFS tree or back to ancestor).\n\nLet's trace the DFS with an example.\nInput:\n3 3\n3 2 10 (idx 0)\n1 2 10 (idx 1)\n3 1 5 (idx 2)\n\nGraph:\n1 --10(idx 1)-- 2 --10(idx 0)-- 3\n|              /\n|             /\n5(idx 2)     /\n|           /\n3-----------\n\n`adj`:\n1: [(2, 10, 1), (3, 5, 2)]\n2: [(3, 10, 0), (1, 10, 1)]\n3: [(2, 10, 0), (1, 5, 2)]\n\n`total_flow_from_1`: edges incident to 1 are (1,2,10) and (1,3,5). So `10+5 = 15`.\n\n`dfs(1, 0)`:\n  `u = 1`, `p = 0`\n  `visited[1] = True`\n  `net_flow_from_children = 0`\n\n  Neighbors of 1:\n  1. `(v=2, c=10, idx=1)`\n     * `v=2` is not visited.\n     * `flow_on_uv_edge = dfs(2, 1)`:\n       `u = 2`, `p = 1`\n       `visited[2] = True`\n       `net_flow_from_children = 0`\n       Neighbors of 2 (excluding 1):\n       1. `(v=3, c=10, idx=0)`\n          * `v=3` is not visited.\n          * `flow_on_uv_edge_inner = dfs(3, 2)`:\n            `u = 3`, `p = 2`\n            `visited[3] = True`\n            `net_flow_from_children = 0`\n            Neighbors of 3 (excluding 2):\n            1. `(v=1, c=5, idx=2)`\n               * `v=1` is visited (and `v != p`). This is a back-edge.\n               * `ans[2] = 0` (direct `3 -> 1`). Output: `_ _ 0`\n               * `net_flow_from_children -= 5` => `net_flow_from_children = -5`\n            After all neighbors of 3:\n            `u = 3` is `n`.\n            `return total_flow_from_1 - net_flow_from_children` = `15 - (-5)` = `20`.\n          * Back to `dfs(2, 1)`: `flow_on_uv_edge_inner = 20`.\n          * `flow_on_uv_edge_inner > 0`: (Flow `3 -> 2`)\n            * `ans[0] = 1` (direct `3 -> 2`). Output: `1 _ 0`\n            * `net_flow_from_children += 20` => `net_flow_from_children = 20`\n       After all neighbors of 2:\n       `u = 2` is `1 < u < n`.\n       `return -net_flow_from_children` = `-20`.\n     * Back to `dfs(1, 0)`: `flow_on_uv_edge = -20`.\n     * `flow_on_uv_edge <= 0`: (Flow `1 -> 2`)\n       * `ans[1] = 0` (direct `1 -> 2`). Output: `1 0 0`\n       * `net_flow_from_children += -20` => `net_flow_from_children = -20`\n\n  2. `(v=3, c=5, idx=2)`\n     * `v=3` is visited. (`v != p` is true, since `p=0`). This is a back-edge.\n     * `ans[2]` is already set to 0. (This means `3 -> 1`).\n     * `net_flow_from_children -= 5` => `net_flow_from_children = -20 - 5 = -25`.\n\n  After all neighbors of 1:\n  `u = 1`. This is the source. The `dfs` call finishes.\n\nThe `ans` array is `[1, 0, 0]`.\nLet's check the example output: `1\\n0\\n1`. My output is `1 0 0`. This is different for edge 2.\nMy `ans[2]` is 0 (3 -> 1), example output `1` (1 -> 3).\n\nWhat's wrong? The back-edge logic for `v=3` from `u=1`.\nWhen `dfs(1, 0)` processes `(1, 3, 5, idx=2)`:\n`v=3` is visited. `p=0`. So `v != p`.\nMy logic: `ans[idx] = 0` (direct `u -> v`). So `1 -> 3`.\nThis is consistent with the example output `ans[2]=1` (meaning `b_i -> a_i` which is `3 -> 1` if the original edge was `(a_i, b_i) = (1, 3)`).\nThe problem statement says: `d_i = 0` if `a_i -> b_i`, `d_i = 1` if `b_i -> a_i`.\nOriginal edges:\nidx 0: (3, 2, 10)\nidx 1: (1, 2, 10)\nidx 2: (3, 1, 5)\n\nMy output `[1, 0, 0]` means:\nidx 0: `b_0 -> a_0` => `2 -> 3` (original was 3 2 10)\nidx 1: `a_1 -> b_1` => `1 -> 2` (original was 1 2 10)\nidx 2: `a_2 -> b_2` => `3 -> 1` (original was 3 1 5)\n\nExample output `[1, 0, 1]` means:\nidx 0: `b_0 -> a_0` => `2 -> 3`\nidx 1: `a_1 -> b_1` => `1 -> 2`\nidx 2: `b_2 -> a_2` => `1 -> 3`\n\nMy logic for back-edges: `u -> v` where `v` is an ancestor.\nIn `dfs(1,0)` when considering `(1,3,5,idx=2)`:\n`u=1`, `v=3`. `v=3` was visited during `dfs(3,2)`. `3` is a child of `2`, which is a child of `1`. So `3` is a descendant of `1`.\nThis means `(1,3)` is a *forward-edge* or *cross-edge* from the perspective of `dfs(1,0)` (specifically, it's a cross-edge from `1` to a node in the subtree of `1` that has already been visited).\n\nThe acyclicity condition is key. If `v` is already visited, and `v != p`, then `v` is either an ancestor of `u` (back-edge) or `v` is in a different subtree (cross-edge).\nIn a DFS tree, a back-edge connects `u` to an ancestor `v`. A cross-edge connects `u` to a node `v` that is neither an ancestor nor a descendant, but was visited earlier.\nTo avoid cycles, flow must go from \"later\" to \"earlier\" in DFS finish times. Or simply, from node with higher DFS discovery time to node with lower DFS discovery time.\nIf `v` is visited and `v != p`:\n  If `discovery_time[u] > discovery_time[v]` (and `v` is not `u`'s parent), then `v` is an ancestor or a node in a different subtree visited earlier. Direct `u -> v`.\n  If `discovery_time[u] < discovery_time[v]`, then `v` is a descendant. This case should not happen for an unvisited edge.\n\nThe `visited` array only tells us if a node has been entered. We need to distinguish between an ancestor and a cross-edge. A simple way is to use `parent` pointers or track discovery/finish times.\nHowever, the problem statement guarantees a solution. The simplest DFS strategy for acyclicity is usually to direct edges `u -> v` if `v` is unvisited, and `u -> v` if `v` is visited and `v` is an ancestor of `u` (back-edge).\nThis means `v` is an ancestor if `visited[v]` is true and `v` is not the parent of `u` and `v` is not a child of `u` (i.e. we are not returning from `dfs(v,u)`).\n\nLet's re-examine the example with the actual DFS tree:\n`dfs(1, 0)` -> `dfs(2, 1)` -> `dfs(3, 2)`\nDFS tree edges: `(1,2)` and `(2,3)`.\nBack-edge/Cross-edge: `(1,3)`. When `dfs(3,2)` processes `(3,1)`: `1` is visited and `1 != 2`. So it's a back-edge.\n`u=3, v=1`. `1` is an ancestor of `3`. So `3 -> 1`. This direction `ans[2]=0` for original (3,1,5).\n\nThis still gives my `[1,0,0]` output. The example output is `[1,0,1]`. This means `1 -> 3` for edge (3,1,5).\nIf `1 -> 3`, then `3` receives flow from `1`.\nIf `3 -> 1`, then `1` receives flow from `3`. But the source (1) cannot have incoming edges.\nSo, `3 -> 1` is *not* allowed. The edge must be `1 -> 3`.\nThis means my back-edge logic `u -> v` for `u=3, v=1` is wrong. It should be `v -> u` if `v` is an ancestor.\nIf `v` is an ancestor of `u`, then `v` is \"earlier\" in the topological sort. Flow must go `v -> u`.\nSo for a back-edge `(u, v)` where `v` is an ancestor of `u`, we must direct `v -> u`.\nThis contradicts my earlier thought for acyclicity. Let's be precise:\nIf `v` is unvisited: `u -> v` (tree edge, `ans[idx]=0`)\nIf `v` is visited and `v != p`:\n  This is a back-edge or cross-edge.\n  To ensure acyclicity, we must direct flow from the vertex that was discovered earlier to the vertex that was discovered later.\n  If `v` is an ancestor of `u`, then `v` was discovered earlier. So `v -> u`.\n  If `v` is in a different subtree (cross-edge), then `v` was discovered earlier. So `v -> u`.\n  In both cases, if `v` is visited and `v != p`, then `v` must have been discovered *before* `u`. So the direction should be `v -> u`.\n\nLet's re-run with this back-edge logic:\nWhen `dfs(3,2)` processes `(3,1,5,idx=2)`:\n`u=3, v=1`. `v=1` is visited and `v != p`. `1` was discovered before `3`.\nSo, direct `1 -> 3`.\n`ans[2] = 1` (since original was `(3,1)`, `b_i=1, a_i=3`, `b_i -> a_i` is `1 -> 3`). Output: `_ _ 1`\n`net_flow_from_children += c` => `net_flow_from_children += 5` => `net_flow_from_children = 5`.\n\nNow, `dfs(3,2)` returns `total_flow_from_1 - net_flow_from_children` = `15 - 5` = `10`.\nBack to `dfs(2,1)`: `flow_on_uv_edge_inner = 10`.\n`flow_on_uv_edge_inner > 0`: (Flow `3 -> 2`)\n  `ans[0] = 1` (direct `3 -> 2`). Output: `1 _ 1`\n  `net_flow_from_children += 10` => `net_flow_from_children = 10`.\n`dfs(2,1)` returns `-net_flow_from_children` = `-10`.\nBack to `dfs(1,0)`: `flow_on_uv_edge = -10`.\n`flow_on_uv_edge <= 0`: (Flow `1 -> 2`)\n  `ans[1] = 0` (direct `1 -> 2`). Output: `1 0 1`\n  `net_flow_from_children += -10` => `net_flow_from_children = -10`.\n\nAfter all neighbors of 1:\n`u=1`. `net_flow_from_children = -10`.\nThis `net_flow_from_children` should be `-total_flow_from_1` = `-15`.\nSomething is still off. The sum of outgoing flows from 1 should be 15.\nFlow `1 -> 2` is 10.\nFlow `1 -> 3` is 5.\nTotal outgoing `10+5=15`.\nMy `net_flow_from_children` in `dfs(1,0)` is `-10`.\nThis `net_flow_from_children` is the sum of `flow_on_uv_edge` values.\nFor `(1,2)`: `flow_on_uv_edge = -10`. This means `1 -> 2` with 10. Correct.\nFor `(1,3)`: `flow_on_uv_edge` is not explicitly calculated, it's a back-edge.\nWhen `dfs(1,0)` processes `(1,3,5,idx=2)`: `v=3` is visited, `v!=p`.\nMy new logic: `ans[2]=1` (direct `1 -> 3`).\nThis means `1` sends 5 units of flow to `3`.\nSo `net_flow_from_children` for `u=1` should be `-10` (from `1->2`) `-5` (from `1->3`) = `-15`.\nThis matches `total_flow_from_1`.\n\nThe `net_flow_from_children` should be `sum(flow_u_to_v) - sum(flow_v_to_u)` for edges other than `(u,p)`.\nIf `ans[idx]=0` (`u -> v`), then `net_flow_from_children -= c`.\nIf `ans[idx]=1` (`v -> u`), then `net_flow_from_children += c`.\n\nLet's re-do `dfs(u, p)` with `net_flow_at_u` as `in_flow - out_flow` for non-parent edges:\n`dfs(u, p)`: returns `in_flow - out_flow` for edge `(u,p)`.\n1.  Mark `u` as visited.\n2.  `net_flow_at_u = 0` (this will be `sum(in_flows) - sum(out_flows)` for edges other than `(u,p)`).\n3.  For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `v` is *not* visited:\n        *   `flow_on_uv_edge = dfs(v, u)` (This is `in_flow - out_flow` for `(v,u)` edge)\n        *   If `flow_on_uv_edge > 0`: (Net flow into `v` from `u`)\n            *   `ans[idx] = 0` (direct `u -> v`)\n            *   `net_flow_at_u -= c` (flow `c` leaves `u`)\n        *   Else (`flow_on_uv_edge <= 0`): (Net flow out of `v` to `u`)\n            *   `ans[idx] = 1` (direct `v -> u`)\n            *   `net_flow_at_u += c` (flow `c` enters `u`)\n    *   Else (`v` is visited and `v != p`): This is a back-edge/cross-edge. `v` was discovered before `u`.\n        *   To ensure acyclicity, flow must go `v -> u`.\n        *   `ans[idx] = 1` (direct `v -> u`)\n        *   `net_flow_at_u += c` (flow `c` enters `u`)\n\n4.  After processing all neighbors:\n    *   If `u == n`:\n        *   `total_flow_from_1` must enter `n`.\n        *   `return total_flow_from_1 - net_flow_at_u` (This is the required incoming flow for `n` from `p`).\n    *   If `1 < u < n`:\n        *   For flow conservation, `net_flow_at_u` must be 0, so the flow on `(u,p)` must balance it.\n        *   `return -net_flow_at_u` (If `net_flow_at_u` is positive, `u` has excess incoming flow, needs to send `net_flow_at_u` to `p`. So `u -> p`, `in_flow - out_flow` on `(u,p)` is `-net_flow_at_u`. If `net_flow_at_u` is negative, `u` has deficit, needs to receive `abs(net_flow_at_u)` from `p`. So `p -> u`, `in_flow - out_flow` on `(u,p)` is `abs(net_flow_at_u)`.)\n    *   If `u == 1`:\n        *   The initial call `dfs(1, 0)` will just run. The return value is not used. `net_flow_at_u` for `u=1` should be `0` because all edges from 1 are outgoing.\n\nLet's re-trace example with this refined logic:\n`total_flow_from_1 = 15`.\n\n`dfs(1, 0)`:\n  `u = 1`, `p = 0`\n  `visited[1] = True`\n  `net_flow_at_u = 0`\n\n  Neighbors of 1:\n  1. `(v=2, c=10, idx=1)`\n     * `v=2` is not visited.\n     * `flow_on_uv_edge = dfs(2, 1)`:\n       `u = 2`, `p = 1`\n       `visited[2] = True`\n       `net_flow_at_u = 0`\n       Neighbors of 2 (excluding 1):\n       1. `(v=3, c=10, idx=0)`\n          * `v=3` is not visited.\n          * `flow_on_uv_edge_inner = dfs(3, 2)`:\n            `u = 3`, `p = 2`\n            `visited[3] = True`\n            `net_flow_at_u = 0`\n            Neighbors of 3 (excluding 2):\n            1. `(v=1, c=5, idx=2)`\n               * `v=1` is visited and `v != p`. `1` was discovered before `3`.\n               * `ans[2] = 1` (direct `1 -> 3`). Output: `_ _ 1`\n               * `net_flow_at_u += 5` => `net_flow_at_u = 5`\n            After all neighbors of 3:\n            `u = 3` is `n`.\n            `return total_flow_from_1 - net_flow_at_u` = `15 - 5` = `10`.\n          * Back to `dfs(2, 1)`: `flow_on_uv_edge_inner = 10`.\n          * `flow_on_uv_edge_inner > 0`: (Net flow into `3` from `2`)\n            * `ans[0] = 0` (direct `2 -> 3`). Output: `0 _ 1`\n            * `net_flow_at_u -= 10` (flow `10` leaves `2`) => `net_flow_at_u = -10`.\n       After all neighbors of 2:\n       `u = 2` is `1 < u < n`.\n       `return -net_flow_at_u` = `-(-10)` = `10`.\n     * Back to `dfs(1, 0)`: `flow_on_uv_edge = 10`.\n     * `flow_on_uv_edge > 0`: (Net flow into `2` from `1`)\n       * `ans[1] = 0` (direct `1 -> 2`). Output: `0 0 1`\n       * `net_flow_at_u -= 10` (flow `10` leaves `1`) => `net_flow_at_u = -10`.\n\n  2. `(v=3, c=5, idx=2)`\n     * `v=3` is visited. `v != p`. `3` was discovered before `1` (no, `1` was discovered first, then `2`, then `3`).\n     * This is a cross-edge. `v=3` was discovered before `u=1` is false. `u=1` was discovered first.\n     * This implies `v` is a descendant of `u` or in a different branch.\n     * In a DFS traversal, if `v` is visited and `v != p`, `v` must be an ancestor of `u` (back-edge) or `v` must be in a different subtree (cross-edge). In both cases, `v` was discovered *before* `u`. So `v -> u` is the direction for acyclicity.\n     * `ans[2]` is already `1` (from `1 -> 3`). This means `b_i -> a_i` for original `(3,1)`.\n     * `net_flow_at_u += 5` (flow `5` enters `1`) => `net_flow_at_u = -10 + 5 = -5`.\n\n  After all neighbors of 1:\n  `u = 1`. `net_flow_at_u = -5`.\n  The expected `net_flow_at_u` for `u=1` (source) should be 0 because it has no incoming edges.\n  My `net_flow_at_u` is `sum(in_flows) - sum(out_flows)`.\n  For `u=1`, `in_flows` must be 0. So `0 - sum(out_flows)`.\n  Outgoing flows are: `1 -> 2` (10), `1 -> 3` (5). Total `15`.\n  So `net_flow_at_u` should be `-15`. My value is `-5`. This is still incorrect.\n\nThe `total_flow_from_1` value is not needed in the DFS for the source condition.\nThe source condition \"vertex 1 has no incoming edges\" means that for any edge `(1, v)` with flow `c`, it *must* be directed `1 -> v`. This is a fixed direction.\n\nLet's modify the DFS slightly:\n`dfs(u, p)`: returns the net flow *out* of `u` through the edge `(u,p)` (positive means `u -> p`, negative means `p -> u`).\n1.  Mark `u` as visited.\n2.  `current_outgoing_flow_sum = 0` (this will track `sum(out_flows) - sum(in_flows)` for edges other than `(u,p)`).\n3.  For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `u == 1`: (Special rule for source)\n        *   All edges from source must be outgoing.\n        *   `ans[idx] = 0` (direct `1 -> v`)\n        *   `current_outgoing_flow_sum += c`\n        *   If `v` is not visited:\n            *   `dfs(v, u)` (we just direct the edge and call DFS, the return value is not used for `u=1`)\n        *   Else (`v` is visited and `v != p`): `v` is a visited descendant. This is not a tree edge. This is a cross-edge. But it cannot be. If `v` is visited and `u=1`, `v` must be a child of 1. So `v` must be visited. This case won't occur for `u=1` and an unvisited `v`. If `v` is visited and `v!=p`, it must be a back-edge to `u=1`. But `u=1` cannot have incoming edges. This means `v` cannot be a node that leads back to 1. This is confusing.\n\nLet's rethink the source rule more simply: all edges connected to vertex 1 are directed `1 -> v`. This means we can pre-set the directions for these edges.\nThen, `total_flow_out_of_1` is fixed.\nThe DFS can start from an arbitrary node, or from 1, and handle other nodes normally.\n\nLet's use a standard DFS for finding a topological sort, and then use the `balance` idea.\n`dfs(u, p)`: returns the net flow *out* of `u` that must pass through `(u,p)` (positive `u -> p`, negative `p -> u`).\n1.  Mark `u` as visited.\n2.  `net_flow_out_of_u = 0` (sum of `c` for `u->x` minus sum of `c` for `x->u` for non-parent edges)\n3.  For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `v` is *not* visited:\n        *   `flow_on_uv_edge = dfs(v, u)`\n        *   If `flow_on_uv_edge > 0`: (`v -> u` flow)\n            *   `ans[idx] = 1`\n            *   `net_flow_out_of_u -= c`\n        *   Else (`flow_on_uv_edge <= 0`): (`u -> v` flow)\n            *   `ans[idx] = 0`\n            *   `net_flow_out_of_u += c`\n    *   Else (`v` is visited and `v != p`): (`v` is an ancestor or cross-edge, `v` discovered before `u`)\n        *   To avoid cycles, flow must go `v -> u`.\n        *   `ans[idx] = 1`\n        *   `net_flow_out_of_u -= c` (flow from `u` to `v` would be `u -> v`, but we want `v -> u` so `c` enters `u`)\n        *   Wait, `net_flow_out_of_u` is `out - in`. If `v -> u`, `c` enters `u`, so `net_flow_out_of_u -= c`. Correct.\n\n4.  After processing all neighbors:\n    *   If `u == 1`: (Source)\n        *   All edges connected to 1 must be outgoing.\n        *   So `net_flow_out_of_u` (sum of `out-in` for non-parent edges) must be exactly the total flow `total_flow_from_1`.\n        *   The DFS call for `u=1` is `dfs(1,0)`. It has no parent. So `net_flow_out_of_u` is simply the total `out-in` for all edges connected to 1.\n        *   This `net_flow_out_of_u` should be `total_flow_from_1`.\n        *   Return 0 (as it has no parent).\n    *   If `u == n`: (Sink)\n        *   `total_flow_from_1` must enter `n`.\n        *   So `net_flow_out_of_u` (sum of `out-in` for non-parent edges) must be `-total_flow_from_1`.\n        *   The flow on `(u,p)` must be `net_flow_out_of_u - (-total_flow_from_1)`.\n        *   `return net_flow_out_of_u + total_flow_from_1`. (Positive if `u->p`, negative if `p->u`)\n    *   If `1 < u < n`: (Intermediate node)\n        *   Flow conservation: `net_flow_out_of_u` must be 0.\n        *   `return net_flow_out_of_u`. (This should be 0, if non-zero it means flow goes through `(u,p)`)\n\nLet's re-trace example with this logic:\n`total_flow_from_1 = 15`.\n\n`dfs(1, 0)`:\n  `u = 1`, `p = 0`\n  `visited[1] = True`\n  `net_flow_out_of_u = 0`\n\n  Neighbors of 1:\n  1. `(v=2, c=10, idx=1)`\n     * `v=2` is not visited.\n     * `flow_on_uv_edge = dfs(2, 1)`:\n       `u = 2`, `p = 1`\n       `visited[2] = True`\n       `net_flow_out_of_u = 0`\n       Neighbors of 2 (excluding 1):\n       1. `(v=3, c=10, idx=0)`\n          * `v=3` is not visited.\n          * `flow_on_uv_edge_inner = dfs(3, 2)`:\n            `u = 3`, `p = 2`\n            `visited[3] = True`\n            `net_flow_out_of_u = 0`\n            Neighbors of 3 (excluding 2):\n            1. `(v=1, c=5, idx=2)`\n               * `v=1` is visited and `v != p`. `1` was discovered before `3`.\n               * `ans[2] = 1` (direct `1 -> 3`). Output: `_ _ 1`\n               * `net_flow_out_of_u -= 5` (flow `5` enters `3`) => `net_flow_out_of_u = -5`.\n            After all neighbors of 3:\n            `u = 3` is `n`.\n            `return net_flow_out_of_u + total_flow_from_1` = `-5 + 15` = `10`.\n          * Back to `dfs(2, 1)`: `flow_on_uv_edge_inner = 10`.\n          * `flow_on_uv_edge_inner > 0`: (`3 -> 2` flow)\n            * `ans[0] = 1` (direct `3 -> 2`). Output: `1 _ 1`\n            * `net_flow_out_of_u -= 10` (flow `10` enters `2`) => `net_flow_out_of_u = -10`.\n       After all neighbors of 2:\n       `u = 2` is `1 < u < n`.\n       `return net_flow_out_of_u` = `-10`.\n     * Back to `dfs(1, 0)`: `flow_on_uv_edge = -10`.\n     * `flow_on_uv_edge <= 0`: (`1 -> 2` flow)\n       * `ans[1] = 0` (direct `1 -> 2`). Output: `1 0 1`\n       * `net_flow_out_of_u += 10` (flow `10` leaves `1`) => `net_flow_out_of_u = 10`.\n\n  2. `(v=3, c=5, idx=2)`\n     * `v=3` is visited and `v != p`. `1` was discovered before `3`.\n     * `ans[2]` is already `1` (direct `1 -> 3`).\n     * `net_flow_out_of_u += 5` (flow `5` leaves `1`) => `net_flow_out_of_u = 10 + 5 = 15`.\n\n  After all neighbors of 1:\n  `u = 1`. `net_flow_out_of_u = 15`.\n  This is `total_flow_from_1`, as expected for the source.\n  The `ans` array is `[1, 0, 1]`. This matches the example output!\n\nThis logic seems correct.\nThe key points:\n1.  `dfs(u, p)` returns the net flow *out* of `u` through the edge `(u,p)`.\n    *   If positive, it means `u -> p`.\n    *   If negative, it means `p -> u`.\n    *   The magnitude is the flow `c` for that edge.\n2.  `net_flow_out_of_u` variable accumulates `sum(out_flows) - sum(in_flows)` for edges of `u` *other than* `(u,p)`.\n3.  For unvisited neighbors `v`:\n    *   Call `dfs(v, u)`. Let it return `flow_on_uv_edge`.\n    *   If `flow_on_uv_edge > 0`: `v` wants to send flow to `u` (`v -> u`). Set `ans[idx]=1`. This means `c` enters `u`, so `net_flow_out_of_u -= c`.\n    *   If `flow_on_uv_edge <= 0`: `v` wants to receive flow from `u` (`u -> v`). Set `ans[idx]=0`. This means `c` leaves `u`, so `net_flow_out_of_u += c`.\n4.  For visited neighbors `v` (`v != p`):\n    *   These are back-edges or cross-edges. `v` was discovered before `u`. To maintain acyclicity, flow must go `v -> u`.\n    *   Set `ans[idx]=1`. This means `c` enters `u`, so `net_flow_out_of_u -= c`.\n5.  Base cases/Return values:\n    *   `u == 1`: Does not return a value to a parent. Its `net_flow_out_of_u` should be `total_flow_from_1`.\n    *   `u == n`: It must accumulate `total_flow_from_1` incoming flow. `net_flow_out_of_u` is `sum(out) - sum(in)` for non-parent edges. So, `total_flow_from_1` (incoming) = `sum(in_from_children) - sum(out_to_children) + flow_from_p_to_u`. This means `flow_from_p_to_u = total_flow_from_1 - (sum(in_from_children) - sum(out_to_children)) = total_flow_from_1 + net_flow_out_of_u`. This is the flow `p -> u`. So, return `-(total_flow_from_1 + net_flow_out_of_u)`. If this is positive, it means `u -> p`. If negative, `p -> u`.\n    *   `1 < u < n`: Flow conservation `sum(out) - sum(in) = 0`. So `net_flow_out_of_u + flow_on_up_edge = 0`. So `flow_on_up_edge = -net_flow_out_of_u`. Return `-net_flow_out_of_u`.\n\nThe return values for `u=n` and `1<u<n` are flows on `(u,p)` where positive means `u->p` and negative means `p->u`.\nFor `u=n`: `net_flow_out_of_u` is `out_from_children - in_from_children`. We need `in_from_p + in_from_children = total_flow_from_1`. So `in_from_p = total_flow_from_1 - in_from_children`.\n`net_flow_out_of_u = out_from_children - in_from_children`.\n`in_from_p` is `c` if `p -> u`, `-c` if `u -> p`.\nSo, `return -(total_flow_from_1 - (out_from_children - net_flow_out_of_u))`\nNo, this is getting complicated.\nThe `net_flow_out_of_u` variable represents `sum(c_out) - sum(c_in)` for all edges connected to `u` *except* the edge `(u,p)`.\nFor `1 < u < n`, we need `sum(c_out) - sum(c_in) = 0` for ALL edges. So `net_flow_out_of_u + (flow_out_on_up_edge - flow_in_on_up_edge) = 0`.\nSo `flow_out_on_up_edge - flow_in_on_up_edge = -net_flow_out_of_u`. This is the value to return.\nFor `u = n`, we need `sum(c_in) = total_flow_from_1`. So `sum(c_out) - sum(c_in) = -total_flow_from_1`.\nSo `net_flow_out_of_u + (flow_out_on_up_edge - flow_in_on_up_edge) = -total_flow_from_1`.\nSo `flow_out_on_up_edge - flow_in_on_up_edge = -total_flow_from_1 - net_flow_out_of_u`. This is the value to return.\n\nThis matches my last successful trace. The code should implement this.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Adjust recursion limit for deep DFS\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    \n    # Calculate total_flow_from_1\n    # This is the sum of capacities of all edges incident to vertex 1.\n    # It represents the total flow in the graph.\n    total_flow_from_1 = 0\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n        \n        if u == 1:\n            total_flow_from_1 += c\n        elif v == 1:\n            total_flow_from_1 += c\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n\n    # dfs(u, p) returns the net flow (out - in) through the edge (u, p).\n    # A positive value means flow u -> p. A negative value means flow p -> u.\n    def dfs(u, p):\n        visited[u] = True\n        \n        # net_flow_out_of_u accumulates sum(out_flow) - sum(in_flow) for edges\n        # connected to u, EXCLUDING the edge (u, p).\n        net_flow_out_of_u = 0\n\n        for v, c, idx in adj[u]:\n            if v == p:\n                continue\n\n            if not visited[v]:\n                # This is a tree edge. Recurse on child v.\n                # flow_on_uv_edge is the net flow (out - in) through (v, u).\n                flow_on_uv_edge = dfs(v, u)\n                \n                if flow_on_uv_edge > 0:\n                    # v wants to send flow to u (v -> u)\n                    ans[idx] = 1 if edges_input[idx][0] == v else 0 # Direct v -> u\n                    net_flow_out_of_u -= c # Flow c enters u\n                else:\n                    # v wants to receive flow from u (u -> v)\n                    ans[idx] = 0 if edges_input[idx][0] == u else 1 # Direct u -> v\n                    net_flow_out_of_u += c # Flow c leaves u\n            else:\n                # This is a back-edge or cross-edge to an already visited node v.\n                # To maintain acyclicity, flow must go from the node discovered earlier to later.\n                # In DFS, if v is visited and not parent, v was discovered before u.\n                # So, flow must be v -> u.\n                ans[idx] = 1 if edges_input[idx][0] == v else 0 # Direct v -> u\n                net_flow_out_of_u -= c # Flow c enters u\n\n        # Determine the flow on the edge (u, p) based on flow conservation for u.\n        if u == n:\n            # Sink node: Total incoming flow must be total_flow_from_1.\n            # net_flow_out_of_u is (out_from_children - in_from_children).\n            # We need (in_from_p + in_from_children) = total_flow_from_1.\n            # So, in_from_p = total_flow_from_1 - in_from_children.\n            # in_from_children = out_from_children - net_flow_out_of_u.\n            # So, in_from_p = total_flow_from_1 - (out_from_children - net_flow_out_of_u)\n            # This is the required incoming flow from p.\n            # The return value is (out_from_p - in_from_p).\n            # So, return -(total_flow_from_1 - (out_from_children - net_flow_out_of_u))\n            # = -(total_flow_from_1 + net_flow_out_of_u)\n            # Or simpler: net_flow_out_of_u (out-in from children) + (out_p - in_p) = -total_flow_from_1 (target net flow for sink)\n            # (out_p - in_p) = -total_flow_from_1 - net_flow_out_of_u\n            return -total_flow_from_1 - net_flow_out_of_u\n        elif u == 1:\n            # Source node: All edges must be outgoing.\n            # The net_flow_out_of_u (sum of out-in for all edges) should be total_flow_from_1.\n            # This value is implicitly checked by problem guarantees.\n            # It has no parent, so it doesn't return a flow value for (u,p).\n            return 0 # Dummy return value for the source.\n        else:\n            # Intermediate node (1 < u < n): Flow conservation (net flow must be 0).\n            # net_flow_out_of_u + (out_from_p - in_from_p) = 0\n            # (out_from_p - in_from_p) = -net_flow_out_of_u\n            return -net_flow_out_of_u\n\n    dfs(1, 0) # Start DFS from source (vertex 1), with dummy parent 0.\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Adjust recursion limit for deep DFS\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    \n    # Calculate total_flow_from_1\n    # This is the sum of capacities of all edges incident to vertex 1.\n    # It represents the total flow in the graph.\n    total_flow_from_1 = 0\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n        \n        if u == 1:\n            total_flow_from_1 += c\n        elif v == 1:\n            total_flow_from_1 += c\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n\n    # dfs(u, p) returns the net flow (out - in) through the edge (u, p).\n    # A positive value means flow u -> p. A negative value means flow p -> u.\n    def dfs(u, p):\n        visited[u] = True\n        \n        # net_flow_out_of_u accumulates sum(out_flow) - sum(in_flow) for edges\n        # connected to u, EXCLUDING the edge (u, p).\n        net_flow_out_of_u = 0\n\n        for v, c, idx in adj[u]:\n            if v == p:\n                continue\n\n            if not visited[v]:\n                # This is a tree edge. Recurse on child v.\n                # flow_on_uv_edge is the net flow (out - in) through (v, u).\n                flow_on_uv_edge = dfs(v, u)\n                \n                if flow_on_uv_edge > 0:\n                    # v wants to send flow to u (v -> u)\n                    ans[idx] = 1 if edges_input[idx][0] == v else 0 # Direct v -> u\n                    net_flow_out_of_u -= c # Flow c enters u\n                else:\n                    # v wants to receive flow from u (u -> v)\n                    ans[idx] = 0 if edges_input[idx][0] == u else 1 # Direct u -> v\n                    net_flow_out_of_u += c # Flow c leaves u\n            else:\n                # This is a back-edge or cross-edge to an already visited node v.\n                # To maintain acyclicity, flow must go from the node discovered earlier to later.\n                # In DFS, if v is visited and not parent, v was discovered before u.\n                # So, flow must be v -> u.\n                ans[idx] = 1 if edges_input[idx][0] == v else 0 # Direct v -> u\n                net_flow_out_of_u -= c # Flow c enters u\n\n        # Determine the flow on the edge (u, p) based on flow conservation for u.\n        if u == n:\n            # Sink node: Total incoming flow must be total_flow_from_1.\n            # net_flow_out_of_u is (out_from_children - in_from_children).\n            # We need (in_from_p + in_from_children) = total_flow_from_1.\n            # So, in_from_p = total_flow_from_1 - in_from_children.\n            # in_from_children = out_from_children - net_flow_out_of_u.\n            # So, in_from_p = total_flow_from_1 - (out_from_children - net_flow_out_of_u)\n            # This is the required incoming flow from p.\n            # The return value is (out_from_p - in_from_p).\n            # So, return -(total_flow_from_1 - (out_from_children - net_flow_out_of_u))\n            # = -(total_flow_from_1 + net_flow_out_of_u)\n            # Or simpler: net_flow_out_of_u (out-in from children) + (out_p - in_p) = -total_flow_from_1 (target net flow for sink)\n            # (out_p - in_p) = -total_flow_from_1 - net_flow_out_of_u\n            return -total_flow_from_1 - net_flow_out_of_u\n        elif u == 1:\n            # Source node: All edges must be outgoing.\n            # The net_flow_out_of_u (sum of out-in for all edges) should be total_flow_from_1.\n            # This value is implicitly checked by problem guarantees.\n            # It has no parent, so it doesn't return a flow value for (u,p).\n            return 0 # Dummy return value for the source.\n        else:\n            # Intermediate node (1 < u < n): Flow conservation (net flow must be 0).\n            # net_flow_out_of_u + (out_from_p - in_from_p) = 0\n            # (out_from_p - in_from_p) = -net_flow_out_of_u\n            return -net_flow_out_of_u\n\n    dfs(1, 0) # Start DFS from source (vertex 1), with dummy parent 0.\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 15427,
        "thoughts_token_count": 770
    }
}