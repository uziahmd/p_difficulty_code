{
    "start": 1758015865.7097526,
    "end": 1758015972.5463066,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Core Idea: A Sweep-Line Approach with Dynamic Programming**\n\nOkay, so I've been given this competitive programming problem and my immediate thought is that a straightforward `O(N^2)` brute-force solution is going to be far too slow. I need a more clever strategy. After staring at the conditions, particularly the disjoint interval requirement (`r_i < l_j` or `r_j < l_i`), I realized that sorting might be the key.  Since the durations have to add up to `x`, I can't ignore it.\n\nI'm thinking of a sweep-line algorithm, where I'll iterate through the days, processing events as I go. To do so, I need some data structures to make this efficient. The core data structure will be an array, `min_cost_for_duration`, which is indexed by the durations, up to `x`. This array will store the minimum cost I've seen so far, for a voucher with a particular duration that has *ended before my current sweep-line position*.\n\nSo, I pre-process the vouchers, storing their start and end days. During my sweep, at each day `current_day`, I'll do two things:\n\n1.  **Process vouchers that *start* on `current_day`**: This is where I look for the `j` voucher to pair with an earlier `i`. I have my `current_day` (which is `l_j`), the duration `d_j` and the cost of the `j`. I also calculate the required duration `target_d_i = x - d_j`.  I can use the `min_cost_for_duration` array and query it with `target_d_i`, giving me the minimum cost, `cost_i`, of any voucher `i` that ended *before* my current `current_day`. The total cost `cost_i + cost_j` gets me one step closer to the solution. I update my global minimum.\n\n2.  **Process vouchers that *end* on `current_day`**:  These are vouchers `i` where I have `r_i` equal to my `current_day`. I now update my `min_cost_for_duration` array. For each such `i`, I store their duration and their associated cost. This is how I maintain what I have seen so far in vouchers that have *ended* and are therefore eligible to pair with any vouchers that begin after this point.\n\nThe great thing is that this loop only takes a single sweep of the vouchers. The critical part is keeping that `min_cost_for_duration` array updated and queried correctly. The overall time complexity should be linear, which is ideal!\n",
    "response": "The problem asks us to find two distinct vouchers `i` and `j` such that:\n1.  They do not intersect. This means either `r_i < l_j` or `r_j < l_i`.\n2.  The sum of their durations is exactly `x`. The duration of voucher `k` is `r_k - l_k + 1`.\n3.  Their total cost (`cost_i + cost_j`) is minimized.\n\nIf no such pair exists, we should output -1.\nThe constraints are `n, x, l_i, r_i <= 2 * 10^5`.\n\nA brute-force approach of checking all `O(N^2)` pairs would be too slow. We need a more efficient method.\n\nLet's use a sweep-line algorithm. We will iterate through the days from `1` to `MAX_COORD` (where `MAX_COORD` is the maximum possible `r_i` or `l_i`, which is `2 * 10^5`).\n\nWe can split the \"non-intersecting\" condition `r_i < l_j` or `r_j < l_i` into two cases. Without loss of generality, let's assume `r_i < l_j`. This means voucher `i` must end strictly before voucher `j` begins. If we find the minimum cost pair for this case, and then consider the symmetric case (`r_j < l_i`), the overall minimum will be the answer. Our sweep-line approach naturally handles this by considering vouchers that have already ended as candidates for `i` and vouchers currently starting as candidates for `j`.\n\n**Algorithm:**\n\n1.  **Data Structures for Vouchers:**\n    We'll store vouchers grouped by their start day and end day.\n    *   `vouchers_starting_at_day[d]`: A list of `(duration, cost)` for all vouchers that start on day `d`.\n    *   `vouchers_ending_at_day[d]`: A list of `(duration, cost)` for all vouchers that end on day `d`.\n    Initialize these as lists of lists, where the index `d` goes from `1` to `MAX_COORD`.\n\n2.  **Minimum Cost Tracking:**\n    *   `min_cost_for_duration_so_far[d_val]`: An array that stores the minimum cost of a voucher with duration `d_val` that has *already ended* (i.e., its `r_k` is less than the `current_day` being processed). Initialize all values to infinity. The size of this array should be `x + 1`, as durations `d_i` and `d_j` cannot exceed `x`.\n\n3.  **Initialization:**\n    *   `min_total_cost = float('inf')`: This will store the minimum total cost found.\n\n4.  **Populate `vouchers_starting_at_day` and `vouchers_ending_at_day`:**\n    Read all `n` vouchers. For each voucher `(l, r, cost)`:\n    *   Calculate `duration = r - l + 1`.\n    *   Add `(duration, cost)` to `vouchers_starting_at_day[l]`.\n    *   Add `(duration, cost)` to `vouchers_ending_at_day[r]`.\n\n5.  **Sweep Line:**\n    Iterate `current_day` from `1` to `MAX_COORD`:\n\n    a.  **Process vouchers that start on `current_day`**:\n        These are potential second vouchers (`j`) in a pair `(i, j)`. For each `(d_j, cost_j)` in `vouchers_starting_at_day[current_day]`:\n        *   Calculate the required duration for the first voucher `i`: `target_d_i = x - d_j`.\n        *   If `1 <= target_d_i <= x` (a valid duration):\n            *   Look up `min_cost_for_duration_so_far[target_d_i]`. This value represents the minimum cost of a voucher `i` that has duration `target_d_i` and ended *before* `current_day`.\n            *   If `min_cost_for_duration_so_far[target_d_i]` is not infinity, it means we found a valid `i`. Update `min_total_cost = min(min_total_cost, cost_j + min_cost_for_duration_so_far[target_d_i])`.\n\n    b.  **Process vouchers that end on `current_day`**:\n        These are potential first vouchers (`i`) in a pair `(i, j)`. For each `(d_i, cost_i)` in `vouchers_ending_at_day[current_day]`:\n        *   Update `min_cost_for_duration_so_far[d_i] = min(min_cost_for_duration_so_far[d_i], cost_i)`. This makes voucher `i` available for any voucher `j` that starts on `current_day + 1` or later.\n\n6.  **Result:**\n    After iterating through all days:\n    *   If `min_total_cost` is still `float('inf')`, it means no valid pair was found. Print `-1`.\n    *   Otherwise, print `min_total_cost`.\n\n**Complexity Analysis:**\n\n*   **Time Complexity:**\n    *   Populating `vouchers_starting_at_day` and `vouchers_ending_at_day`: `O(N)` because each voucher is processed once.\n    *   Sweep line: The loop runs `MAX_COORD` times.\n        *   Inside the loop, processing `vouchers_starting_at_day[current_day]` takes `O(number_of_vouchers_starting_on_day)` time. The sum of `number_of_vouchers_starting_on_day` over all days is `N`.\n        *   Similarly, processing `vouchers_ending_at_day[current_day]` takes `O(number_of_vouchers_ending_on_day)` time. The sum of `number_of_vouchers_ending_on_day` over all days is `N`.\n    *   Total time complexity: `O(N + MAX_COORD)`. Given `N, MAX_COORD <= 2 * 10^5`, this is `O(4 * 10^5)`, which is efficient enough.\n\n*   **Space Complexity:**\n    *   `vouchers_starting_at_day` and `vouchers_ending_at_day`: `O(N + MAX_COORD)` to store the lists and the lists themselves.\n    *   `min_cost_for_duration_so_far`: `O(x)`.\n    *   Total space complexity: `O(N + MAX_COORD + x)`. Given the constraints, this is `O(2 * 10^5 + 2 * 10^5 + 2 * 10^5) = O(6 * 10^5)`, which is acceptable.\n\n**Example Walkthrough (First Sample):**\n`n=4, x=5`\nVouchers:\n1: (1, 3, 4) -> d=3\n2: (1, 2, 5) -> d=2\n3: (5, 6, 1) -> d=2\n4: (1, 2, 4) -> d=2\n\n`MAX_COORD = 6` (max `r_i` is 6)\n`min_total_cost = inf`\n`min_cost_for_duration_so_far = [inf] * (5 + 1)` (indices 0 to 5)\n\n`vouchers_starting_at_day`:\n`[1]: [(3, 4), (2, 5), (2, 4)]` (voucher 1, 2, 4)\n`[5]: [(2, 1)]` (voucher 3)\nOther days: `[]`\n\n`vouchers_ending_at_day`:\n`[2]: [(2, 5), (2, 4)]` (voucher 2, 4)\n`[3]: [(3, 4)]` (voucher 1)\n`[6]: [(2, 1)]` (voucher 3)\nOther days: `[]`\n\n**Sweep Line:**\n\n*   `current_day = 1`:\n    *   Start events (`vouchers_starting_at_day[1]`): No `min_cost_for_duration_so_far` values are available yet (all `inf`), so `min_total_cost` remains `inf`.\n    *   End events (`vouchers_ending_at_day[1]`): Empty. `min_cost_for_duration_so_far` unchanged.\n\n*   `current_day = 2`:\n    *   Start events (`vouchers_starting_at_day[2]`): Empty.\n    *   End events (`vouchers_ending_at_day[2]`):\n        *   `(d=2, cost=5)`: `min_cost_for_duration_so_far[2] = min(inf, 5) = 5`.\n        *   `(d=2, cost=4)`: `min_cost_for_duration_so_far[2] = min(5, 4) = 4`.\n        `min_cost_for_duration_so_far` is now `[inf, inf, 4, inf, inf, inf]`\n\n*   `current_day = 3`:\n    *   Start events (`vouchers_starting_at_day[3]`): Empty.\n    *   End events (`vouchers_ending_at_day[3]`):\n        *   `(d=3, cost=4)`: `min_cost_for_duration_so_far[3] = min(inf, 4) = 4`.\n        `min_cost_for_duration_so_far` is now `[inf, inf, 4, 4, inf, inf]`\n\n*   `current_day = 4`:\n    *   Start events: Empty.\n    *   End events: Empty. `min_cost_for_duration_so_far` unchanged.\n\n*   `current_day = 5`:\n    *   Start events (`vouchers_starting_at_day[5]`):\n        *   `(d_j=2, cost_j=1)` (Voucher 3: `l=5, r=6, cost=1, d=2`):\n            `target_d_i = x - d_j = 5 - 2 = 3`.\n            `min_cost_for_duration_so_far[3]` is `4`.\n            `min_total_cost = min(inf, 1 + 4) = 5`.\n    *   End events (`vouchers_ending_at_day[5]`): Empty. `min_cost_for_duration_so_far` unchanged.\n\n*   `current_day = 6`:\n    *   Start events: Empty.\n    *   End events (`vouchers_ending_at_day[6]`):\n        *   `(d=2, cost=1)` (Voucher 3: `l=5, r=6, cost=1, d=2`):\n            `min_cost_for_duration_so_far[2] = min(4, 1) = 1`.\n        `min_cost_for_duration_so_far` is now `[inf, inf, 1, 4, inf, inf]`\n\nFinal `min_total_cost = 5`. This matches the example output.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i or r_i is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_starting_at_day[d] stores (duration, cost) for vouchers starting on day d\n    vouchers_starting_at_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_ending_at_day[d] stores (duration, cost) for vouchers ending on day d\n    vouchers_ending_at_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_at_day[l].append((duration, cost))\n        vouchers_ending_at_day[r].append((duration, cost))\n\n    min_total_cost = float('inf')\n\n    # min_cost_for_duration_so_far[d_val] stores the minimum cost of a voucher\n    # with duration d_val that has already ended (r_k < current_day).\n    # Durations can be up to x.\n    min_cost_for_duration_so_far = [float('inf')] * (x + 1)\n\n    for current_day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that start on current_day\n        # These are potential second vouchers (j)\n        for d_j, cost_j in vouchers_starting_at_day[current_day]:\n            target_d_i = x - d_j\n            if 1 <= target_d_i <= x: # Check if target_d_i is a valid duration\n                if min_cost_for_duration_so_far[target_d_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_j + min_cost_for_duration_so_far[target_d_i])\n\n        # 2. Process vouchers that end on current_day\n        # These are potential first vouchers (i) that become available for future pairings\n        for d_i, cost_i in vouchers_ending_at_day[current_day]:\n            if d_i <= x: # Only care about durations that can contribute to total x\n                min_cost_for_duration_so_far[d_i] = min(min_cost_for_duration_so_far[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i or r_i is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_starting_at_day[d] stores (duration, cost) for vouchers starting on day d\n    vouchers_starting_at_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_ending_at_day[d] stores (duration, cost) for vouchers ending on day d\n    vouchers_ending_at_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_at_day[l].append((duration, cost))\n        vouchers_ending_at_day[r].append((duration, cost))\n\n    min_total_cost = float('inf')\n\n    # min_cost_for_duration_so_far[d_val] stores the minimum cost of a voucher\n    # with duration d_val that has already ended (r_k < current_day).\n    # Durations can be up to x.\n    min_cost_for_duration_so_far = [float('inf')] * (x + 1)\n\n    for current_day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that start on current_day\n        # These are potential second vouchers (j)\n        for d_j, cost_j in vouchers_starting_at_day[current_day]:\n            target_d_i = x - d_j\n            if 1 <= target_d_i <= x: # Check if target_d_i is a valid duration\n                if min_cost_for_duration_so_far[target_d_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_j + min_cost_for_duration_so_far[target_d_i])\n\n        # 2. Process vouchers that end on current_day\n        # These are potential first vouchers (i) that become available for future pairings\n        for d_i, cost_i in vouchers_ending_at_day[current_day]:\n            if d_i <= x: # Only care about durations that can contribute to total x\n                min_cost_for_duration_so_far[d_i] = min(min_cost_for_duration_so_far[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 3352,
        "thoughts_token_count": 6909
    }
}