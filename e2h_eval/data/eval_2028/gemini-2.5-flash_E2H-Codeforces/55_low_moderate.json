{
    "start": 1758284903.6974645,
    "end": 1758284939.0337827,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Analyzing Lexicographical Ordering with Swaps**\n\nOkay, so I'm presented with this interesting problem. The goal is to find the lexicographically smallest ternary string achievable through specific swaps.  My mind immediately starts dissecting the constraints. We have two allowed swap rules: '01' <-> '10' and '12' <-> '21'.  These are the only tools in my toolbox.\n\nMy first instinct is to see what these swaps *imply*. It quickly becomes apparent that a '0' can effectively move past a '1', and a '1' can move past a '2'. But what's the relationship between '0' and '2'?  I start to test some scenarios. \"012\", \"021\", etc. It's clear that a '0' and a '2' *cannot* directly swap. If I have \"0...2\", a '0' will *always* precede the '2' in any reachable string. Their relative order is fixed. It's the same for \"2...0\".\n\nThen the implications for the '1's becomes clear. Since '1's can swap with *both* '0's and '2's, it's like they're \"free\" to move around, as long as they don't jump across a '0'-'2' boundary.  Initially, it seems like a '1' could freely move, which is incorrect.\n\nIt's similar to these problems where specific types of characters cannot directly swap. It's about preserving the relative order. I start thinking about \"inversions\" within the string, and how the allowed swaps affect them. It boils down to seeing which elements can \"bubble\" through others, forming the solution.\n\nThe key insight is the preservation of the relative order of the '0's and '2's, and the \"freedom\" of the '1's, as they form the backbone for the solution. I know I can now devise an efficient algorithm to reconstruct the string.\n",
    "response": "The problem asks us to find the lexicographically smallest string achievable by repeatedly applying two types of swaps: '01' <-> '10' and '12' <-> '21'.\n\nLet's analyze the allowed swaps:\n1. '0' and '1' can swap positions if they are adjacent. This means '0's can effectively move to the left past '1's, and '1's can move to the right past '0's.\n2. '1' and '2' can swap positions if they are adjacent. This means '1's can effectively move to the left past '2's, and '2's can move to the right past '1's.\n\nNotice that '0' and '2' cannot directly swap. This is a crucial observation. If two characters cannot directly swap, their relative order is preserved. For example, if we have a '0' at index `i` and a '2' at index `j` with `i < j` in the original string, then in any string reachable by the allowed operations, that specific '0' will always appear before that specific '2'. Similarly, if `j < i`, the '2' will always appear before the '0'.\n\nSince '0's and '2's maintain their relative order, we can think of them as \"fixed\" in their relative positions. The '1's, however, can move past both '0's (by '01' <-> '10') and '2's (by '12' <-> '21'). This means '1's are \"free\" to move across any '0' or '2'.\n\nTo make the string lexicographically smallest, we want to place as many '0's as possible at the beginning, followed by '1's, and then '2's.\n\nLet's count the occurrences of each character:\n- Count of '0's: `count_0`\n- Count of '1's: `count_1`\n- Count of '2's: `count_2`\n\nSince '0's and '2's maintain their relative order, we can construct the final string by first placing all '0's that appear *before* any '1's in the original string, then all '1's, and then all '2's that appear *after* all '1's. This doesn't quite work because '1's can move.\n\nA better approach is to realize that all '1's can be grouped together. Since '1's can move past '0's and '2's, they can be collected and placed anywhere relative to the '0's and '2's.\nFor example, in \"012\", '1' can move to \"021\" or \"102\".\nIn \"010210\":\n- '0's and '2's keep their relative order. The sequence of '0's and '2's is \"0020\".\n- '1's can move. There are two '1's.\n\nTo achieve the lexicographically smallest string:\n1. We want to place all '0's as far left as possible.\n2. After the '0's, we want to place all '1's.\n3. After the '1's, we want to place all '2's.\n\nHowever, the '0'-'2' relative order constraint prevents us from simply sorting the characters.\nConsider the characters '0' and '2'. Their relative order is fixed. This means we can form a \"backbone\" string consisting only of '0's and '2's, in their original relative order.\nExample: `s = \"100210\"`\nThe '0's and '2's are at indices 1, 2, 3, 5. The characters are '0', '0', '2', '0'. Their relative order is \"0020\".\n\nNow, where do the '1's go?\nSince '1's can move past any '0' or '2', all '1's can be gathered together. To make the string lexicographically smallest, these '1's should be placed *after* all possible '0's.\nHowever, if a '2' appears before a '0' in the \"backbone\", we cannot move that '0' past that '2'.\n\nThe key insight is this:\nAll '0's that appear before the *first* '2' in the original string can be moved to the very beginning of the string.\nAll '2's that appear after the *last* '0' in the original string can be moved to the very end of the string.\nAll '1's can be moved past any '0' or '2'. This means all '1's can be collected and placed at a single contiguous block.\n\nTo achieve the lexicographically smallest string:\n1. We should try to put all '0's first.\n2. Then all '1's.\n3. Then all '2's.\n\nThe constraint is the relative order of '0's and '2's.\nThis implies that any '0' that appears before a '2' in the original string must appear before it in the final string.\nAny '2' that appears before a '0' in the original string must appear before it in the final string.\n\nLet's find the first occurrence of '2'. If there are no '2's, all '0's can go first, then all '1's.\nIf there are '2's, any '0' that appears *before* the first '2' in the input string can be moved to the very beginning.\nAll '1's can be grouped together and inserted. Where is the optimal place for them? To minimize lexicographically, they should be placed as far left as possible, but after all '0's that can be moved to the front.\nThe '0's and '2's that are not '1's form a subsequence. The '1's can be inserted anywhere into this subsequence.\n\nConsider the string `s`.\nExtract all '0's and '2's, keeping their relative order. Let this be `s_02`.\nCount all '1's. Let this be `num_1`.\n\nExample: `s = \"100210\"`\n`s_02 = \"0020\"` (characters at original indices 1, 2, 3, 5)\n`num_1 = 2` (characters at original indices 0, 4)\n\nTo make the string lexicographically smallest:\nWe want to put '0's first.\nSo, we take all '0's from `s_02` that appear before the first '2' in `s_02`.\nIn `s_02 = \"0020\"`, the first '2' is at index 2. The '0's before it are \"00\".\nThese '0's (`\"00\"`) can be moved to the very beginning of the final string.\n\nAfter these initial '0's, we must place the '1's. Why? Because any remaining '0's in `s_02` are after a '2' (like the last '0' in \"0020\"). These '0's cannot move past that '2'. So, we cannot place them before the '1's if those '1's are to be before that '2'. To be lexicographically smallest, all '1's should be placed as early as possible. The earliest they can be placed is after all '0's that can be moved to the front.\n\nSo the structure is:\n(All '0's that appear before the first '2' in the original string) + (All '1's) + (All '0's and '2's that appear from the first '2' onwards in the original string, excluding any '1's).\n\nLet's refine this.\n1. Count all '1's in the input string `s`. Let this be `ones_count`.\n2. Construct a new string `result_part_02` by taking all characters from `s` that are '0' or '2', maintaining their original relative order.\n3. Find the index of the first '2' in `result_part_02`. If no '2' is present, then `result_part_02` consists only of '0's. In this case, the final string is `result_part_02` followed by `ones_count` '1's.\n4. If '2's are present:\n   - Take all characters from `result_part_02` up to (but not including) the first '2'. These are all '0's. Append them to the result.\n   - Append `ones_count` '1's to the result.\n   - Append the rest of `result_part_02` (from the first '2' onwards) to the result.\n\nLet's try the examples:\n\nExample 1: `s = \"100210\"`\n1. `ones_count = 2`\n2. `result_part_02` (extract '0's and '2's, keep order): \"0020\"\n3. First '2' in `result_part_02` is at index 2.\n4. - Characters from `result_part_02` before first '2': \"00\"\n   - Append `ones_count` '1's: \"11\"\n   - Append rest of `result_part_02` from first '2' onwards: \"20\"\n   - Combine: \"00\" + \"11\" + \"20\" = \"001120\"\n   This matches the example output.\n\nExample 2: `s = \"11222121\"`\n1. `ones_count = 4`\n2. `result_part_02` (extract '0's and '2's, keep order): \"2222\" (no '0's)\n3. First '2' in `result_part_02` is at index 0.\n4. - Characters from `result_part_02` before first '2': \"\" (empty string)\n   - Append `ones_count` '1's: \"1111\"\n   - Append rest of `result_part_02` from first '2' onwards: \"2222\"\n   - Combine: \"\" + \"1111\" + \"2222\" = \"11112222\"\n   This matches the example output.\n\nExample 3: `s = \"20\"`\n1. `ones_count = 0`\n2. `result_part_02` (extract '0's and '2's, keep order): \"20\"\n3. First '2' in `result_part_02` is at index 0.\n4. - Characters from `result_part_02` before first '2': \"\" (empty string)\n   - Append `ones_count` '1's: \"\" (empty string)\n   - Append rest of `result_part_02` from first '2' onwards: \"20\"\n   - Combine: \"\" + \"\" + \"20\" = \"20\"\n   This matches the example output.\n\nThis algorithm seems correct and covers all cases. It leverages the fact that '0's and '2's maintain relative order, while '1's are maximally mobile. To achieve the lexicographically smallest string, all '1's are grouped together and inserted at the latest possible position that still allows all leading '0's (those not blocked by a '2') to come first. This position is right before the first '2' (or at the end if no '2's exist).\n\nThe implementation involves iterating through the string once to count '1's and build `result_part_02`, then finding the first '2' in `result_part_02`, and finally concatenating parts. This is efficient enough for string length up to $10^5$.\n\n```python\nimport sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    ones_count = 0\n    # Use a list of characters to build result_part_02 efficiently\n    # and then join at the end.\n    result_part_02_chars = [] \n\n    for char_s in s:\n        if char_s == '1':\n            ones_count += 1\n        else:\n            result_part_02_chars.append(char_s)\n    \n    # Reconstruct result_part_02 as a string for easier substring operations\n    # or find the index of '2' directly in the list.\n    # Let's find index of '2' directly in the list for efficiency.\n    \n    first_two_idx_in_02_part = -1\n    for i in range(len(result_part_02_chars)):\n        if result_part_02_chars[i] == '2':\n            first_two_idx_in_02_part = i\n            break\n            \n    result = []\n    if first_two_idx_in_02_part == -1:\n        # No '2's in the string. All '0's come first, then all '1's.\n        # result_part_02_chars contains only '0's.\n        result.extend(result_part_02_chars)\n        result.extend(['1'] * ones_count)\n    else:\n        # '2's are present.\n        # '0's before the first '2' in result_part_02_chars\n        result.extend(result_part_02_chars[:first_two_idx_in_02_part])\n        # All '1's\n        result.extend(['1'] * ones_count)\n        # Remaining '0's and '2's from result_part_02_chars (from the first '2' onwards)\n        result.extend(result_part_02_chars[first_two_idx_in_02_part:])\n        \n    sys.stdout.write(\"\".join(result) + \"\\n\")\n\n# Call the solve function to process the input\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    ones_count = 0\n    # Use a list of characters to build result_part_02 efficiently\n    # and then join at the end.\n    result_part_02_chars = [] \n\n    for char_s in s:\n        if char_s == '1':\n            ones_count += 1\n        else:\n            result_part_02_chars.append(char_s)\n    \n    # Reconstruct result_part_02 as a string for easier substring operations\n    # or find the index of '2' directly in the list.\n    # Let's find index of '2' directly in the list for efficiency.\n    \n    first_two_idx_in_02_part = -1\n    for i in range(len(result_part_02_chars)):\n        if result_part_02_chars[i] == '2':\n            first_two_idx_in_02_part = i\n            break\n            \n    result = []\n    if first_two_idx_in_02_part == -1:\n        # No '2's in the string. All '0's come first, then all '1's.\n        # result_part_02_chars contains only '0's.\n        result.extend(result_part_02_chars)\n        result.extend(['1'] * ones_count)\n    else:\n        # '2's are present.\n        # '0's before the first '2' in result_part_02_chars\n        result.extend(result_part_02_chars[:first_two_idx_in_02_part])\n        # All '1's\n        result.extend(['1'] * ones_count)\n        # Remaining '0's and '2's from result_part_02_chars (from the first '2' onwards)\n        result.extend(result_part_02_chars[first_two_idx_in_02_part:])\n        \n    sys.stdout.write(\"\".join(result) + \"\\n\")\n\n# Call the solve function to process the input\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 613,
        "completion_token_count": 3277,
        "thoughts_token_count": 828
    }
}