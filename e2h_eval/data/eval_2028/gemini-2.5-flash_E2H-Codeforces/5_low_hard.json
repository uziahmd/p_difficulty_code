{
    "start": 1758009343.6687927,
    "end": 1758009407.8084185,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ — the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Tackling the \"Colored Boots\" Problem: A Strategic Breakdown**\n\nOkay, so I'm looking at this \"Colored Boots\" competitive programming problem. The goal is to maximize the number of compatible left and right boot pairs.  The rules are straightforward: same colors match, a '?' matches anything, and different specific colors are a no-go.  Each boot can be in at most one pair, obviously.\n\nThe input gives me *n* boots each for the left and right sides, and strings of colors *l* and *r*.  The output needs to be the maximum number of pairs (*k*) and the indices of the matched pairs.\n\nMy initial thought is to recognize this as a potential bipartite matching problem.  I could theoretically model it as such, but with *n* up to 150000, standard maximum matching algorithms are going to be way too slow.  I'm thinking a greedy approach or something more specialized, perhaps a flow algorithm, is the way to go here.\n\nTo make things manageable, I need to organize the data. I'm going to use some kind of data structure, like dictionaries or lists, to store the indices of the boots by their color.  So, I'll have a `left_boots` structure and a `right_boots` structure, each keyed by color (including '?').  Colors can be represented as letters or as integers, it's pretty trivial.\n\nNow, let's think about the matching strategy. What pairs should I prioritize?  Exact matches – the ones with the same specific colors – are the key.  If I don't pair them right away, they might miss their chance later.  The '?' characters are more flexible; they can match anything.\n\nBreaking it down, there are basically these types of possible matches to consider: specific-specific, specific-question mark, question mark-specific, and question mark-question mark.  The specific-question mark and question mark-specific are essentially the same.\n\nSo, I need to devise a greedy algorithm that prioritizes the exact matches first, then efficiently handles the '?' matches, perhaps keeping track of available '?' boots to maximize the overall number of pairs.  That seems like a reasonable path to solving this one.\n",
    "response": "The problem asks us to find the maximum number of compatible pairs of left and right boots and to list these pairs. We are given `n` left boots and `n` right boots, with their colors specified as characters. A lowercase letter denotes a specific color, and '?' denotes an indefinite color.\n\nCompatibility rules:\n1. Two specific colors are compatible if they are identical (e.g., 'f' and 'f').\n2. An indefinite color '?' is compatible with any color (specific or indefinite) (e.g., '?' and 'z', 'a' and '?', '?' and '?').\n3. Two different specific colors are not compatible (e.g., 'f' and 'g').\n\nEach boot can be part of at most one pair.\n\nTo maximize the number of pairs, we should use a greedy strategy. The most restrictive matches should be prioritized.\n\nLet's categorize the types of matches:\n1. **Specific color with specific color (e.g., 'a' and 'a'):** These are the most restrictive. An 'a' boot can only match another 'a' boot or a '?' boot. If we match an 'a' with an 'a', we use up two specific boots that might not find other matches.\n2. **Specific color with '?' (e.g., 'a' and '?'):** These are less restrictive for the '?' boot, as it could match anything else.\n3. **'?' with '?' (e.g., '?' and '?'):** These are the least restrictive, as both boots are wildcards and could match any remaining boot.\n\nA common greedy strategy for such problems is to handle the most constrained items first.\n\n**Step-by-step Greedy Strategy:**\n\n1.  **Store Boot Indices by Color:**\n    First, we need to efficiently access boots of a certain color. We can use lists (or deques/queues for efficient popping) to store the 1-based indices of boots for each color.\n    `left_boots[color]` will be a list of indices of left boots with `color`.\n    `right_boots[color]` will be a list of indices of right boots with `color`.\n    We'll have 26 specific colors ('a' through 'z') and one special color '?'.\n\n2.  **Prioritize Exact Specific Matches:**\n    Iterate through all specific colors `c` from 'a' to 'z'. For each `c`:\n    While there are available left boots of color `c` AND available right boots of color `c`:\n    Take one left boot index `L_idx` from `left_boots[c]`.\n    Take one right boot index `R_idx` from `right_boots[c]`.\n    Form the pair `(L_idx, R_idx)`. Add it to our `result` list.\n\n3.  **Handle Specific Color with Wildcard Matches:**\n    After exact matches, some specific-colored boots might remain, and all '?' boots are still available.\n    Iterate through all specific colors `c` from 'a' to 'z'. For each `c`:\n    a. **Left Specific, Right Wildcard:** While there are available left boots of color `c` AND available right boots of color '?':\n       Take `L_idx` from `left_boots[c]`.\n       Take `R_idx` from `right_boots['?']`.\n       Form the pair `(L_idx, R_idx)`. Add it to `result`.\n    b. **Left Wildcard, Right Specific:** While there are available left boots of color '?' AND available right boots of color `c`:\n       Take `L_idx` from `left_boots['?']`.\n       Take `R_idx` from `right_boots[c]`.\n       Form the pair `(L_idx, R_idx)`. Add it to `result`.\n\n4.  **Handle Wildcard with Wildcard Matches:**\n    Finally, match any remaining '?' left boots with '?' right boots.\n    While there are available left boots of color '?' AND available right boots of color '?':\n    Take `L_idx` from `left_boots['?']`.\n    Take `R_idx` from `right_boots['?']`.\n    Form the pair `(L_idx, R_idx)`. Add it to `result`.\n\nThis greedy strategy works because:\n*   Matching 'c' with 'c' uses up two specific boots that have fewer matching options. If we used a '?' for one of them, that '?' would be consumed, potentially preventing a different match later.\n*   After exhausting 'c' with 'c' matches, matching 'c' with '?' is the next best. The 'c' boot still has limited options, while the '?' boot is flexible. It's better to use a '?' for a specific boot than to save it for another '?' boot if a specific boot is available.\n*   Matching '?' with '?' is done last because '?' boots are the most flexible and can fill any remaining compatibility gaps.\n\n**Example Walkthrough:**\n`n=7`, `l=\"abaca?b\"`, `r=\"zabbbcc\"`\n\nInitial storage (using lists, popping from end is efficient):\n`left_boots`:\n  'a': [5, 3, 1]\n  'b': [7, 2]\n  'c': [4]\n  '?': [6]\n`right_boots`:\n  'a': [2]\n  'b': [4, 3]\n  'c': [7, 6, 5]\n  'z': [1]\n\n1.  **Exact Specific Matches:**\n    *   `c = 'a'`:\n        `left_boots['a']` has [5, 3, 1], `right_boots['a']` has [2].\n        Pair (1, 2) (using 1 from `left_boots['a']`, 2 from `right_boots['a']`).\n        `left_boots['a']` becomes [5, 3]. `right_boots['a']` becomes [].\n        Result: `[(1, 2)]`\n    *   `c = 'b'`:\n        `left_boots['b']` has [7, 2], `right_boots['b']` has [4, 3].\n        Pair (2, 3) (using 2 from `left_boots['b']`, 3 from `right_boots['b']`).\n        `left_boots['b']` becomes [7]. `right_boots['b']` becomes [4].\n        Result: `[(1, 2), (2, 3)]`\n    *   `c = 'c'`: No matches.\n    *   ... (other specific colors) ... No matches.\n\n2.  **Specific with Wildcard Matches:**\n    *   `c = 'a'`:\n        `left_boots['a']` has [5, 3], `right_boots['?']` is empty. No matches.\n        `left_boots['?']` has [6], `right_boots['a']` is empty. No matches.\n    *   `c = 'b'`:\n        `left_boots['b']` has [7], `right_boots['?']` is empty. No matches.\n        `left_boots['?']` has [6], `right_boots['b']` has [4].\n        Pair (6, 4) (using 6 from `left_boots['?']`, 4 from `right_boots['b']`).\n        `left_boots['?']` becomes []. `right_boots['b']` becomes [].\n        Result: `[(1, 2), (2, 3), (6, 4)]`\n    *   `c = 'c'`:\n        `left_boots['c']` has [4], `right_boots['?']` is empty. No matches.\n        `left_boots['?']` is empty. No matches.\n    *   `c = 'z'`:\n        `left_boots['z']` is empty.\n        `left_boots['?']` is empty. No matches.\n\n3.  **Wildcard with Wildcard Matches:**\n    `left_boots['?']` is empty. No matches.\n\nFinal `result`: `[(1, 2), (2, 3), (6, 4)]`.\nWait, the example output for this case is `5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2`. My trace gave 3.\nWhat went wrong? My initial trace missed some specific matches.\n\nLet's re-trace carefully with the example output in mind.\n`n=7`, `l=\"abaca?b\"`, `r=\"zabbbcc\"`\n\n`left_boots`:\n  'a': [1, 3, 5]\n  'b': [2, 7]\n  'c': [4]\n  '?': [6]\n`right_boots`:\n  'a': [2]\n  'b': [3, 4]\n  'c': [5, 6, 7]\n  'z': [1]\n\n1.  **Exact Specific Matches:**\n    *   `c = 'a'`: `left_boots['a']=[1,3,5]`, `right_boots['a']=[2]`\n        Pair (1, 2). `left_boots['a']=[3,5]`, `right_boots['a']=[]`.\n        Result: `[(1, 2)]`\n    *   `c = 'b'`: `left_boots['b']=[2,7]`, `right_boots['b']=[3,4]`\n        Pair (2, 3). `left_boots['b']=[7]`, `right_boots['b']=[4]`.\n        Result: `[(1, 2), (2, 3)]`\n    *   `c = 'c'`: `left_boots['c']=[4]`, `right_boots['c']=[5,6,7]`\n        Pair (4, 5). `left_boots['c']=[]`, `right_boots['c']=[6,7]`.\n        Result: `[(1, 2), (2, 3), (4, 5)]`\n    *   ... (other specific colors) ... No matches.\n\n    At this point:\n    `left_boots`:\n      'a': [3, 5]\n      'b': [7]\n      'c': []\n      '?': [6]\n    `right_boots`:\n      'a': []\n      'b': [4]\n      'c': [6, 7]\n      'z': [1]\n    `result`: `[(1, 2), (2, 3), (4, 5)]`\n\n2.  **Specific with Wildcard Matches:**\n    *   `c = 'a'`:\n        `left_boots['a']=[3,5]`, `right_boots['?']` is empty.\n        `left_boots['?']=[6]`, `right_boots['a']` is empty.\n    *   `c = 'b'`:\n        `left_boots['b']=[7]`, `right_boots['?']` is empty.\n        `left_boots['?']=[6]`, `right_boots['b']=[4]`.\n        Pair (6, 4). `left_boots['?']=[]`, `right_boots['b']=[]`.\n        Result: `[(1, 2), (2, 3), (4, 5), (6, 4)]`\n    *   `c = 'c'`:\n        `left_boots['c']` is empty.\n        `left_boots['?']` is empty.\n    *   `c = 'z'`:\n        `left_boots['z']` is empty.\n        `left_boots['?']` is empty.\n\n    At this point:\n    `left_boots`:\n      'a': [3, 5]\n      'b': [7]\n      'c': []\n      '?': []\n    `right_boots`:\n      'a': []\n      'b': []\n      'c': [6, 7]\n      'z': [1]\n    `result`: `[(1, 2), (2, 3), (4, 5), (6, 4)]`\n\n3.  **Wildcard with Wildcard Matches:**\n    `left_boots['?']` is empty. No matches.\n\nFinal `result`: `[(1, 2), (2, 3), (4, 5), (6, 4)]`. This is 4 pairs.\nThe example output has 5 pairs. This means my greedy strategy is missing something.\n\nThe issue might be in the order of specific with wildcard matches.\nWhen matching `left_specific` with `right_?` and `left_?` with `right_specific`, it's generally better to use the `?` boot for the specific boot that has fewer other options.\nHowever, since all specific boots have been exhausted of their exact matches, any remaining specific boot `c` *must* match a `?` boot to form a pair.\nThe critical observation might be that a `?` boot can match *any* specific color. So, if we have a left 'a' boot and a right '?' boot, they can pair up. If we also have a left 'b' boot and a right '?' boot, they can pair up.\nThe `?` boots are a shared resource.\n\nThe standard greedy approach for this type of problem is:\n1. Match specific color `X` with specific color `X`.\n2. Match specific color `X` with `?`.\n3. Match `?` with `?`.\n\nThe example output `5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2` for `l=\"abaca?b\"`, `r=\"zabbbcc\"`:\n(6,5) -> (L:'?', R:'c')\n(2,3) -> (L:'b', R:'b')\n(4,6) -> (L:'c', R:'c')\n(7,4) -> (L:'b', R:'b')\n(1,2) -> (L:'a', R:'a')\n\nThis output has 3 exact specific matches ('a'-'a', 'b'-'b', 'c'-'c') and 2 specific-wildcard matches ('?' with 'c', 'b' with 'b' -- wait, (7,4) is 'b'-'b', not 'b' with '?').\n\nLet's re-list the indices and colors:\nLeft boots:\n1: a\n2: b\n3: a\n4: c\n5: a\n6: ?\n7: b\n\nRight boots:\n1: z\n2: a\n3: b\n4: b\n5: c\n6: c\n7: c\n\nIndices in lists (using `collections.defaultdict(list)`):\n`left_indices = {'a': [1, 3, 5], 'b': [2, 7], 'c': [4], '?': [6]}`\n`right_indices = {'z': [1], 'a': [2], 'b': [3, 4], 'c': [5, 6, 7]}`\n\n**Revised Greedy Strategy (from a known pattern for such problems):**\n\n1.  **Exact Matches (Specific-Specific):**\n    For each specific color `ch` from 'a' to 'z':\n    While `left_indices[ch]` and `right_indices[ch]` are not empty:\n    `res.append((left_indices[ch].pop(), right_indices[ch].pop()))`\n\n2.  **Specific with Wildcard Matches (Specific-`?` and `?`-Specific):**\n    For each specific color `ch` from 'a' to 'z':\n    a. Match remaining `left_indices[ch]` with `right_indices['?']`:\n       While `left_indices[ch]` and `right_indices['?']` are not empty:\n       `res.append((left_indices[ch].pop(), right_indices['?'].pop()))`\n    b. Match remaining `left_indices['?']` with `right_indices[ch]`:\n       While `left_indices['?']` and `right_indices[ch]` are not empty:\n       `res.append((left_indices['?'].pop(), right_indices[ch].pop()))`\n\n3.  **Wildcard-Wildcard Matches (`?`-`?`):**\n    While `left_indices['?']` and `right_indices['?']` are not empty:\n    `res.append((left_indices['?'].pop(), right_indices['?'].pop()))`\n\nLet's re-trace with this exact strategy:\n\n`left_indices = {'a': [1, 3, 5], 'b': [2, 7], 'c': [4], '?': [6]}`\n`right_indices = {'z': [1], 'a': [2], 'b': [3, 4], 'c': [5, 6, 7]}`\n`res = []`\n\n**1. Exact Matches:**\n*   `ch = 'a'`:\n    Pop (5, 2). `res = [(5, 2)]`.\n    `left_indices['a'] = [1, 3]`, `right_indices['a'] = []`.\n*   `ch = 'b'`:\n    Pop (7, 4). `res = [(5, 2), (7, 4)]`.\n    Pop (2, 3). `res = [(5, 2), (7, 4), (2, 3)]`.\n    `left_indices['b'] = []`, `right_indices['b'] = []`.\n*   `ch = 'c'`:\n    Pop (4, 7). `res = [(5, 2), (7, 4), (2, 3), (4, 7)]`.\n    `left_indices['c'] = []`, `right_indices['c'] = [5, 6]`.\n*   ... (other chars) ...\n\nAfter step 1:\n`left_indices = {'a': [1, 3], 'b': [], 'c': [], '?': [6]}`\n`right_indices = {'z': [1], 'a': [], 'b': [], 'c': [5, 6], '?': []}`\n`res = [(5, 2), (7, 4), (2, 3), (4, 7)]`\n\n**2. Specific with Wildcard Matches:**\n*   `ch = 'a'`:\n    a. `left_indices['a']=[1,3]`, `right_indices['?']=[]`. No matches.\n    b. `left_indices['?']=[6]`, `right_indices['a']=[]`. No matches.\n*   `ch = 'b'`:\n    a. `left_indices['b']=[]`. No matches.\n    b. `left_indices['?']=[6]`, `right_indices['b']=[]`. No matches.\n*   `ch = 'c'`:\n    a. `left_indices['c']=[]`. No matches.\n    b. `left_indices['?']=[6]`, `right_indices['c']=[5,6]`.\n       Pop (6, 6). `res = [(5, 2), (7, 4), (2, 3), (4, 7), (6, 6)]`.\n       `left_indices['?'] = []`, `right_indices['c'] = [5]`.\n*   `ch = 'z'`:\n    a. `left_indices['z']=[]`. No matches.\n    b. `left_indices['?']=[]`. No matches.\n\nAfter step 2:\n`left_indices = {'a': [1, 3], 'b': [], 'c': [], '?': []}`\n`right_indices = {'z': [1], 'a': [], 'b': [], 'c': [5], '?': []}`\n`res = [(5, 2), (7, 4), (2, 3), (4, 7), (6, 6)]`\n\n**3. Wildcard-Wildcard Matches:**\n`left_indices['?'] = []`, `right_indices['?'] = []`. No matches.\n\nFinal `res`: `[(5, 2), (7, 4), (2, 3), (4, 7), (6, 6)]`. This is 5 pairs.\nThis matches the count in the example. The pairs themselves are different, but the problem states \"If there are many optimal answers, print any of them.\"\n\nMy pairs:\n(5,2) -> L:'a', R:'a'\n(7,4) -> L:'b', R:'b'\n(2,3) -> L:'b', R:'b'\n(4,7) -> L:'c', R:'c'\n(6,6) -> L:'?', R:'c'\n\nExample pairs:\n(6,5) -> L:'?', R:'c'\n(2,3) -> L:'b', R:'b'\n(4,6) -> L:'c', R:'c'\n(7,4) -> L:'b', R:'b'\n(1,2) -> L:'a', R:'a'\n\nBoth solutions yield 5 pairs. The strategy seems correct.\n\n**Implementation Details:**\n*   Use `collections.defaultdict(list)` for `left_indices` and `right_indices`.\n*   Iterate `ch` from `ord('a')` to `ord('z')` and convert back to `chr(ch)`.\n*   `pop()` from the lists to get indices and remove them. This is `O(1)` for Python lists (which are dynamic arrays) if popping from the end. If popping from the beginning, it's `O(N)`. Using `collections.deque` would make `popleft()` `O(1)`. For `N=150000`, `O(N)` pops from the beginning would be `O(N^2)` overall, which is too slow. So, either use `pop()` (from end) or `deque.popleft()`. Since the order of indices within a color group doesn't matter, `pop()` from the end of a list is fine.\n\nThe maximum `N` is 150000.\nStoring indices: `2 * N` integers.\nProcessing:\n1. Exact matches: Each pop operation removes one boot. Total `O(N)` operations.\n2. Specific-wildcard matches: Each pop operation removes one boot. Total `O(N)` operations.\n3. Wildcard-wildcard matches: Each pop operation removes one boot. Total `O(N)` operations.\nOverall time complexity: `O(N + C)` where `C` is the number of distinct colors (27 in this case). This is efficient enough.\n\n```python\nimport sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    l_str = sys.stdin.readline().strip()\n    r_str = sys.stdin.readline().strip()\n\n    # Store 1-based indices of boots for each color\n    # Using lists, pop() will remove from the end, which is O(1)\n    left_indices = defaultdict(list)\n    right_indices = defaultdict(list)\n\n    for i in range(n):\n        left_indices[l_str[i]].append(i + 1)\n        right_indices[r_str[i]].append(i + 1)\n\n    result_pairs = []\n\n    # 1. Prioritize exact specific matches (e.g., 'a' with 'a')\n    for char_code in range(ord('a'), ord('z') + 1):\n        char = chr(char_code)\n        while left_indices[char] and right_indices[char]:\n            result_pairs.append((left_indices[char].pop(), right_indices[char].pop()))\n\n    # 2. Handle specific color with wildcard matches\n    # This includes (specific, '?') and ('?', specific)\n    for char_code in range(ord('a'), ord('z') + 1):\n        char = chr(char_code)\n        # Match remaining left_specific with right_wildcard\n        while left_indices[char] and right_indices['?']:\n            result_pairs.append((left_indices[char].pop(), right_indices['?'].pop()))\n        # Match remaining left_wildcard with right_specific\n        while left_indices['?'] and right_indices[char]:\n            result_pairs.append((left_indices['?'].pop(), right_indices[char].pop()))\n\n    # 3. Handle wildcard with wildcard matches (e.g., '?' with '?')\n    while left_indices['?'] and right_indices['?']:\n        result_pairs.append((left_indices['?'].pop(), right_indices['?'].pop()))\n\n    # Print the results\n    sys.stdout.write(str(len(result_pairs)) + '\\n')\n    for l_idx, r_idx in result_pairs:\n        sys.stdout.write(f\"{l_idx} {r_idx}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    l_str = sys.stdin.readline().strip()\n    r_str = sys.stdin.readline().strip()\n\n    # Store 1-based indices of boots for each color\n    # Using lists, pop() will remove from the end, which is O(1)\n    left_indices = defaultdict(list)\n    right_indices = defaultdict(list)\n\n    for i in range(n):\n        left_indices[l_str[i]].append(i + 1)\n        right_indices[r_str[i]].append(i + 1)\n\n    result_pairs = []\n\n    # 1. Prioritize exact specific matches (e.g., 'a' with 'a')\n    for char_code in range(ord('a'), ord('z') + 1):\n        char = chr(char_code)\n        while left_indices[char] and right_indices[char]:\n            result_pairs.append((left_indices[char].pop(), right_indices[char].pop()))\n\n    # 2. Handle specific color with wildcard matches\n    # This includes (specific, '?') and ('?', specific)\n    for char_code in range(ord('a'), ord('z') + 1):\n        char = chr(char_code)\n        # Match remaining left_specific with right_wildcard\n        while left_indices[char] and right_indices['?']:\n            result_pairs.append((left_indices[char].pop(), right_indices['?'].pop()))\n        # Match remaining left_wildcard with right_specific\n        while left_indices['?'] and right_indices[char]:\n            result_pairs.append((left_indices['?'].pop(), right_indices[char].pop()))\n\n    # 3. Handle wildcard with wildcard matches (e.g., '?' with '?')\n    while left_indices['?'] and right_indices['?']:\n        result_pairs.append((left_indices['?'].pop(), right_indices['?'].pop()))\n\n    # Print the results\n    sys.stdout.write(str(len(result_pairs)) + '\\n')\n    for l_idx, r_idx in result_pairs:\n        sys.stdout.write(f\"{l_idx} {r_idx}\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 846,
        "completion_token_count": 5851,
        "thoughts_token_count": 682
    }
}