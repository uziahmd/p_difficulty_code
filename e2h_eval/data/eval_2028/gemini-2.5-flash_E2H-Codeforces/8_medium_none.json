{
    "start": 1758011815.502156,
    "end": 1758011971.4579864,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:39 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Solving the Flawed Flow Problem**\n\nOkay, so I'm tackling this \"Flawed Flow\" problem, which is basically about directing flow in a graph. The setup is pretty standard: a bunch of vertices, edges with flow capacities, and a source and sink. The tricky part is the \"no cycles\" rule – the directed graph we end up with has to be acyclic. This, along with the standard flow conservation (except at the source and sink), is the crux of the challenge.\n\nMy initial thoughts are, this looks a bit like those Euler path/circuit problems, but with the added wrinkle of no cycles. The fact that a solution is *guaranteed* to exist is a huge hint. It suggests the problem is well-posed and that a constructive solution exists.\n\nThe \"no cycles\" condition is the most critical constraint here. It screams \"topological sort!\" to me. If we can order the vertices such that all flow travels \"forward\" in this order, we're golden. The source having no incoming edges just reinforces this idea – it must be one of the earliest vertices in any valid topological order.\n\nThe conservation rule for intermediate vertices is straightforward: what goes in must come out. But it also implies some restrictions on the degree of each node. I'm thinking about how the total flow \"available\" at each node (sum of capacities of its edges) must be even for an intermediate vertex to properly balance incoming and outgoing flows. This feels like an important sanity check and a potential invariant.\n\nI'm considering a greedy approach, perhaps starting at the source and trying to direct the flow outwards, avoiding cycles as we go. A DFS seems like a reasonable way to explore the graph and build a valid ordering on the fly. I'm thinking a DFS from the source could work, where for a visited node, edges are directed so there are no cycles, and all the balances are considered.\n\nMy current line of reasoning is leading me toward the need to track a \"balance\" for each vertex. This represents the amount of flow that the node either needs to send out or receive to satisfy the flow conservation rule. The goal for intermediate vertices is always to zero this balance.\n\nAs I work through some examples, I realize that maintaining `current_flow` at each vertex, to reflect its remaining capacity to balance out, might be a good way to determine the direction of each edge. I should also test with DFS.\n\nThe guarantee of a solution existing is key. It means that there's a directed acyclic graph that always works and satisfies all constraints. So I need to ensure that the solution algorithm I construct finds such a graph. So with these thoughts I go for coding the solution now!\n",
    "response": "The problem asks us to direct edges in an undirected graph, given their flow volumes, such that specific conditions are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of flow volumes of incoming edges equals the sum of flow volumes of outgoing edges.\n2.  **Source Condition:** Vertex 1 (source) has no incoming edges.\n3.  **No Cycles:** The resulting directed graph must be a Directed Acyclic Graph (DAG).\n\nWe are guaranteed that a solution always exists.\n\nLet's analyze the conditions:\n*   **Flow Conservation for Intermediate Vertices:** If `sum(incoming_flow) = sum(outgoing_flow)` for an intermediate vertex `v`, and `sum(incoming_flow) + sum(outgoing_flow)` is the total flow capacity incident to `v` (let's call this `degree_sum[v]`), then `2 * sum(incoming_flow) = degree_sum[v]`. This implies that `degree_sum[v]` must be an even number for all `1 < v < n`. Since a solution is guaranteed to exist, this property must hold.\n*   **Source (Vertex 1):** Vertex 1 has no incoming edges. All flow through edges incident to vertex 1 must be directed away from it.\n*   **Sink (Vertex n):** Although not explicitly stated, in typical max-flow problems, the sink `n` has no outgoing edges, or its outgoing flow equals its incoming flow. Combined with the \"no cycles\" and \"source has no incoming\" conditions, it's natural to assume all flow must eventually arrive at `n` and not leave it. This means all flow through edges incident to `n` must be directed towards it.\n*   **No Cycles:** This is a strong condition. It means we can assign a topological order to the vertices. If we direct edges such that flow always goes from a vertex with a smaller topological order to a vertex with a larger topological order, no cycles will be formed.\n\nWe can solve this problem using a Depth First Search (DFS) starting from the source vertex (vertex 1). The DFS will effectively build a topological ordering.\n\nLet `ans[i]` store the direction for the `i`-th edge. `ans[i] = 0` if `a_i -> b_i`, and `ans[i] = 1` if `b_i -> a_i`.\nWe also need an array, say `current_flow_balance[v]`, which will keep track of the net flow *out* of vertex `v` from edges within its DFS subtree and cross-edges to already visited nodes.\n\n**DFS Strategy:**\n`dfs(u, p)`:\n1.  Mark `u` as visited.\n2.  Initialize `net_flow_out_of_u_via_children = 0`. This variable will accumulate the flow that needs to be balanced at `u` through its children and cross-edges.\n3.  For each edge `(u, v)` with flow `c` and original index `idx`:\n    *   If `v == p`, this is the edge connecting `u` to its parent in the DFS tree; we defer its direction decision until `u` returns to `p`. Skip this edge for now.\n    *   If `v` is already `visited`: This is a back-edge or a cross-edge. To avoid cycles, flow must go from the already visited vertex `v` to `u`.\n        *   Set `ans[idx] = 1` (direction `v -> u`).\n        *   Add `c` to `net_flow_out_of_u_via_children`. (Flow `v -> u` means `u` receives flow `c`, so `u` must output this `c` to maintain balance or pass it up to its parent).\n    *   If `v` is `unvisited`: This is a tree edge. Recursively call `dfs(v, u)`.\n        *   After `dfs(v, u)` returns, `current_flow_balance[v]` holds the net flow that needs to exit `v` through the edge `(v, u)` to balance `v` and its subtree.\n        *   If `current_flow_balance[v] > 0`: `v` has an excess of outgoing flow (from its subtree and cross-edges). This excess `current_flow_balance[v]` must be sent to `u` via `(v, u)`.\n            *   Set `ans[idx] = 1` (direction `v -> u`).\n            *   Add `current_flow_balance[v]` to `net_flow_out_of_u_via_children`.\n        *   If `current_flow_balance[v] <= 0`: `v` has an excess of incoming flow (from its subtree and cross-edges), or is perfectly balanced. This deficit `abs(current_flow_balance[v])` must be supplied by `u` via `(u, v)`.\n            *   Set `ans[idx] = 0` (direction `u -> v`).\n            *   Add `current_flow_balance[v]` to `net_flow_out_of_u_via_children`. (Note: if `current_flow_balance[v]` is negative, adding it effectively subtracts its absolute value, representing flow leaving `u`).\n4.  After processing all children and cross-edges, `net_flow_out_of_u_via_children` represents the net flow that `u` has accumulated from its children and cross-edges. This flow must be passed up to `u`'s parent `p` (if `u != 1`) to maintain flow conservation. Store this in `current_flow_balance[u]`.\n    `current_flow_balance[u] = net_flow_out_of_u_via_children`.\n5.  Return `current_flow_balance[u]`.\n\n**Base Cases/Special Handling:**\n*   **Source (Vertex 1):** The `dfs(1, 0)` call (where 0 is a dummy parent) will compute `current_flow_balance[1]`, which will be the total maximum flow of the graph. This value will not be used to direct an edge, as vertex 1 has no incoming edges.\n*   **Sink (Vertex n):** When `dfs(n, p)` returns, `current_flow_balance[n]` should represent the net flow that needs to exit `n` via `(n, p)`. Since `n` is the sink, it should have no outgoing flow. Therefore, `current_flow_balance[n]` should ideally be 0. Any flow directed `x -> n` contributes to `n`'s incoming flow, and any flow directed `n -> y` contributes to `n`'s outgoing flow. The logic above ensures that `current_flow_balance[n]` will accumulate flow that must be sent *from* `n` to its parent to balance its subtree. If `n` is a leaf in the DFS tree, `current_flow_balance[n]` will be 0. If `n` has children, their flow will be directed towards `n` (if `current_flow_balance[child] <= 0`) or away from `n` (if `current_flow_balance[child] > 0`). The problem implicitly assumes that the total flow entering `n` from its parent will exactly balance `current_flow_balance[n]`. The guarantee that a solution exists simplifies this.\n\n**Final Check:**\nAfter the initial DFS call `dfs(1, 0)` completes, all edges will have been directed. The `current_flow_balance[v]` values are implicitly handled by the choice of direction. For `1 < v < n`, the net flow out of `v` (sum of outgoing minus sum of incoming) will be zero. For `v=1`, it will be the total flow. For `v=n`, it will be negative total flow.\n\n**Example Walkthrough (First Example):**\n`n=3, m=3`\nEdges:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\nAdjacency list (stores (neighbor, flow, original_index)):\n`adj[1] = [(2, 10, 1), (3, 5, 2)]`\n`adj[2] = [(3, 10, 0), (1, 10, 1)]`\n`adj[3] = [(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F, F, F, F]`\n`current_flow_balance = [0, 0, 0, 0]`\n`ans = [?, ?, ?]`\n\n`dfs(1, 0)`:\n  `visited[1] = T`\n  `net_flow_out_of_1 = 0`\n\n  Edge (1, 2, 1) (flow 10, idx 1): `v=2` is unvisited.\n    `dfs(2, 1)`:\n      `visited[2] = T`\n      `net_flow_out_of_2 = 0`\n\n      Edge (2, 3, 0) (flow 10, idx 0): `v=3` is unvisited.\n        `dfs(3, 2)`:\n          `visited[3] = T`\n          `net_flow_out_of_3 = 0`\n          // No neighbors of 3 other than parent 2.\n          `current_flow_balance[3] = 0`\n          Return `0` (from `dfs(3,2)`)\n\n      Back in `dfs(2, 1)`: `flow_from_subtree_3 = 0`.\n      `flow_from_subtree_3 <= 0` is true.\n      `ans[0] = 0` (direction `2 -> 3`, flow 10)\n      `net_flow_out_of_2 += 0` (no change)\n\n      Edge (2, 1, 1) (flow 10, idx 1): `v=1` is parent. Skip.\n\n      `current_flow_balance[2] = net_flow_out_of_2 = 0`.\n      Return `0` (from `dfs(2,1)`)\n\n  Back in `dfs(1, 0)`: `flow_from_subtree_2 = 0`.\n  `flow_from_subtree_2 <= 0` is true.\n  `ans[1] = 0` (direction `1 -> 2`, flow 10)\n  `net_flow_out_of_1 += 0` (no change)\n\n  Edge (1, 3, 2) (flow 5, idx 2): `v=3` is visited.\n  This is a cross-edge. Direct `v -> u`.\n  `ans[2] = 1` (direction `3 -> 1`, flow 5)\n  `net_flow_out_of_1 += 5` (flow 5 incoming to 1, so 1 must output it)\n\n  `current_flow_balance[1] = net_flow_out_of_1 = 5`.\n  Return `5` (from `dfs(1,0)`)\n\nFinal `ans`:\n`ans[0]` (edge (3,2,10)): `0` (meaning `3 -> 2`)\n`ans[1]` (edge (1,2,10)): `0` (meaning `1 -> 2`)\n`ans[2]` (edge (3,1,5)): `1` (meaning `3 -> 1`)\n\nWait, the example output is `1, 0, 1`. Let's recheck.\nMy output:\n(3,2,10) -> 0 (3 -> 2)\n(1,2,10) -> 0 (1 -> 2)\n(3,1,5)  -> 1 (3 -> 1)\n\nExample output:\n(3,2,10) -> 1 (2 -> 3)\n(1,2,10) -> 0 (1 -> 2)\n(3,1,5)  -> 1 (3 -> 1)\n\nMy logic for cross-edges might be flawed.\nIf `v` is visited, it means `v` was visited *before* `u` in the DFS traversal (or is an ancestor).\nTo maintain DAG property, flow must go from `v` to `u`. This is correct.\nThe problem says \"vertex with number 1 has no incoming edges\".\nMy current solution has `3 -> 1` (flow 5). This violates the condition for vertex 1.\n\nThe issue is that vertex 1 *must* have no incoming edges. My DFS logic for `visited` nodes (cross-edges/back-edges) directs `v -> u`. If `u` is 1, and `v` is another node, this could result in `v -> 1`, which is forbidden.\n\nThe problem states \"vertex with number 1 has no incoming edges\". This is a hard constraint.\nThis means any edge `(v, 1)` must be directed `1 -> v`.\nAnd for vertex `n`, typically it has no outgoing edges. Any edge `(n, v)` must be directed `v -> n`.\n\nLet's refine the DFS:\n`dfs(u, p)`:\n  `visited[u] = true`\n  `net_flow_out_of_u = 0` // This is the flow that must leave `u` via `(u, p)` or into the sink if `u` is 1.\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`, continue.\n\n    // Handle special cases for source and sink\n    If `u == 1`: // Source: all edges must be `1 -> v`\n      `ans[idx] = 0`\n      `net_flow_out_of_u += c`\n      Continue. // No need to recurse or check visited, direction is fixed.\n    If `v == n`: // Edge to sink: all edges must be `u -> n`\n      `ans[idx] = 0`\n      `net_flow_out_of_u += c`\n      Continue. // No need to recurse or check visited, direction is fixed.\n\n    If `visited[v]`: // Not source/sink, and `v` is visited.\n      // This is a back-edge or cross-edge. To avoid cycles, flow must go `v -> u`.\n      `ans[idx] = 1`\n      `net_flow_out_of_u += c` // `u` receives flow `c`, so it must output it.\n    Else (`v` is unvisited): // Not source/sink, and `v` is unvisited. Tree edge.\n      `flow_from_subtree_v = dfs(v, u)`\n      // `flow_from_subtree_v` is the net flow that needs to exit `v` via `(v, u)`.\n      If `flow_from_subtree_v > 0`: // `v` needs to send flow to `u`.\n        `ans[idx] = 1` (direction `v -> u`)\n        `net_flow_out_of_u += flow_from_subtree_v`\n      Else (`flow_from_subtree_v <= 0`): // `u` needs to send flow to `v`.\n        `ans[idx] = 0` (direction `u -> v`)\n        `net_flow_out_of_u += flow_from_subtree_v`\n\n  `current_flow_balance[u] = net_flow_out_of_u`\n  Return `net_flow_out_of_u`\n\nLet's re-trace Example 1 with this refined logic:\n`n=3, m=3`\nEdges:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\n`adj[1] = [(2, 10, 1), (3, 5, 2)]`\n`adj[2] = [(3, 10, 0), (1, 10, 1)]`\n`adj[3] = [(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F, F, F, F]`\n`current_flow_balance = [0, 0, 0, 0]`\n`ans = [?, ?, ?]`\n\n`dfs(1, 0)`:\n  `visited[1] = T`\n  `net_flow_out_of_1 = 0`\n\n  Edge (1, 2, 1) (flow 10, idx 1): `u=1`. Source rule applies.\n    `ans[1] = 0` (direction `1 -> 2`)\n    `net_flow_out_of_1 += 10` (`net_flow_out_of_1` is now 10)\n\n  Edge (1, 3, 2) (flow 5, idx 2): `u=1`. Source rule applies.\n    `ans[2] = 0` (direction `1 -> 3`)\n    `net_flow_out_of_1 += 5` (`net_flow_out_of_1` is now 15)\n\n  `current_flow_balance[1] = 15`.\n  Return `15` (from `dfs(1,0)`)\n\nThis produces:\n`ans[0]` (edge (3,2,10)): ? (undirected)\n`ans[1]` (edge (1,2,10)): `0` (1 -> 2)\n`ans[2]` (edge (3,1,5)): `0` (1 -> 3)\n\nThis is still not right. The edge (3,2,10) was not processed because the DFS only started from 1.\nThe DFS needs to visit all nodes. This implies that the source/sink rules are for edges *incident* to them, but not necessarily that they are leaf nodes in the DFS tree.\n\nThe crucial part is that `dfs(u, p)` only handles edges `(u, v)` where `v` is a child or cross-node. The edge `(u, p)` is handled when `dfs(p, u)` processes `u`.\n\nLet's use a global `visited` array and ensure all nodes are visited.\nThe problem states \"vertex with number 1 has no incoming edges\". This means for any edge `(v, 1)`, it MUST be directed `1 -> v`.\nThe problem implies that vertex `n` is the sink. It's safe to assume for any edge `(n, v)`, it MUST be directed `v -> n`.\n\nLet's try again with the `current_flow_balance[v]` being the net flow *out* of `v`.\n`dfs(u, p)`:\n  `visited[u] = true`\n  `net_flow_out_of_u = 0`\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `idx` is already decided (e.g., if `ans[idx]` is not `?`), continue.\n    If `v == p`, continue.\n\n    If `v == 1`: // `u` is trying to send flow to the source. Forbidden. Must be `1 -> u`.\n      `ans[idx] = 0` (direction `1 -> u`)\n      `net_flow_out_of_u -= c` // `u` receives flow from 1, so its net_out decreases.\n    Else if `v == n`: // `u` is trying to send flow to the sink. Allowed. Must be `u -> n`.\n      `ans[idx] = 0` (direction `u -> n`)\n      `net_flow_out_of_u += c` // `u` sends flow to n, so its net_out increases.\n    Else if `visited[v]`: // Cross-edge or back-edge to non-source/non-sink.\n      // To ensure DAG, flow must go from `v` to `u`.\n      `ans[idx] = 1` (direction `v -> u`)\n      `net_flow_out_of_u += c` // `u` receives flow `c`, so it must output it.\n    Else (`v` is unvisited, not 1 or n): // Tree edge.\n      `flow_from_subtree_v = dfs(v, u)`\n      If `flow_from_subtree_v > 0`: // `v` needs to send flow to `u`.\n        `ans[idx] = 1` (direction `v -> u`)\n        `net_flow_out_of_u += flow_from_subtree_v`\n      Else (`flow_from_subtree_v <= 0`): // `u` needs to send flow to `v`.\n        `ans[idx] = 0` (direction `u -> v`)\n        `net_flow_out_of_u += flow_from_subtree_v`\n\n  `current_flow_balance[u] = net_flow_out_of_u`\n  Return `net_flow_out_of_u`\n\nThis still doesn't cover the case where `u=1` or `u=n` and `v` is a tree child.\nThe special rules for `1` and `n` should take precedence.\n\nLet's use a `flow_balance[v]` which stores the net flow *out* of `v` accumulated from its children in the DFS tree and cross-edges.\n`dfs(u, p)`:\n  `visited[u] = true`\n  `flow_balance[u] = 0`\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`, continue.\n\n    If `visited[v]`: // Cross-edge or back-edge.\n      // To ensure DAG, flow must go from `v` to `u`.\n      `ans[idx] = 1` (direction `v -> u`)\n      `flow_balance[u] += c` // `u` receives `c`, so this `c` must be passed up.\n    Else: // Tree edge.\n      // Recurse on `v`.\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `flow_balance[v]` is the net flow that needs to exit `v` via `(v, u)`.\n      If `flow_balance[v] > 0`: // `v` has excess outgoing flow, must send to `u`.\n        `ans[idx] = 1` (direction `v -> u`)\n        `flow_balance[u] += flow_balance[v]`\n      Else: // `v` has excess incoming flow or is balanced, `u` must send to `v`.\n        `ans[idx] = 0` (direction `u -> v`)\n        `flow_balance[u] += flow_balance[v]` // `u` sends flow, so its balance decreases.\n\n  // After iterating all children and cross-edges, `flow_balance[u]` holds the net flow that needs to exit `u` via `(u, p)`.\n  // If `u` is the source (1), this is the total flow.\n  // If `u` is the sink (n), this value must be 0 (no outgoing flow from sink).\n  // If `u` is an intermediate node (1 < u < n), this value must be 0 (flow conservation).\n\n  Return `flow_balance[u]`\n\nThis general DFS structure is correct for balancing flows and creating a DAG. The problem's \"source has no incoming\" and \"sink has no outgoing\" (implied) are critical.\n\nWhen `dfs(u, p)` returns `flow_balance[u]`, it means `u` has a net `flow_balance[u]` of flow that it wants to send to `p`.\nSo, if `flow_balance[u] > 0`, direction for `(u, p)` is `u -> p`.\nIf `flow_balance[u] <= 0`, direction for `(u, p)` is `p -> u`.\n\nLet's maintain `current_flow[v]` as the amount of flow that *must* exit `v` through its parent edge.\n`dfs(u, p_edge_idx)`:\n  `visited[u] = true`\n  `current_out_flow = 0`\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `idx == p_edge_idx`, continue.\n\n    If `visited[v]`: // Cross-edge or back-edge.\n      // To avoid cycles, flow must go from `v` to `u`.\n      `ans[idx] = 1` (direction `v -> u`)\n      `current_out_flow += c`\n    Else: // Tree edge.\n      `flow_from_subtree_v = dfs(v, idx)`\n      If `flow_from_subtree_v > 0`: // `v` has excess outgoing flow, must send to `u`.\n        `ans[idx] = 1` (direction `v -> u`)\n        `current_out_flow += flow_from_subtree_v`\n      Else: // `v` has excess incoming flow or is balanced, `u` must send to `v`.\n        `ans[idx] = 0` (direction `u -> v`)\n        `current_out_flow += flow_from_subtree_v`\n\n  If `u == n`: // Sink node. All flows must enter it.\n    // Any flow that `current_out_flow` indicates as outgoing from `n` must be redirected to incoming.\n    // This is equivalent to saying `n` must absorb all flow. The problem guarantees a solution.\n    // The `current_out_flow` will be 0 if all its children are sinks or intermediate nodes that balance out.\n    // If `current_out_flow` is non-zero, it means `n` is trying to send flow to its parent.\n    // But `n` is a sink, so it cannot send flow to its parent.\n    // This means `current_out_flow` must be 0 for the sink.\n    // For the sink, if `current_out_flow` is not 0, it means we must reverse the edge to the parent.\n    // This implies that the total flow into `n` from its parent must be `current_out_flow`.\n    // The problem statement says `vertex with number 1 has no incoming edges`. It doesn't say `n` has no outgoing.\n    // But \"no cycles\" and \"flow conservation\" usually imply `n` is a terminal node.\n    // The solution must exist. This means `current_out_flow` for `n` from its children and cross-edges must be 0.\n    // No, this is incorrect. `current_out_flow` for `n` is the flow it wants to send to its parent.\n    // Since `n` is the sink, it should accept all flow, so it should have no \"excess\" flow to send back.\n    // So, `current_out_flow` for `n` should be 0.\n    return 0 // sink absorbs all flow.\n  Else: // `u` is source or intermediate.\n    return `current_out_flow`\n\nMain logic:\nInitialize `ans` array with -1 (undecided).\nInitialize `visited` array with False.\nCall `dfs(1, -1)` (source, dummy parent edge index).\nThe value returned by `dfs(1, -1)` is the total max flow. This value is not used to direct any edge.\nThe `ans` array will contain all directions.\n\nLet's re-re-trace Example 1 with this logic:\n`n=3, m=3`\nEdges:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\n`adj[1] = [(2, 10, 1), (3, 5, 2)]`\n`adj[2] = [(3, 10, 0), (1, 10, 1)]`\n`adj[3] = [(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F, F, F, F]`\n`ans = [-1, -1, -1]`\n\n`dfs(1, -1)`:\n  `visited[1] = T`\n  `current_out_flow = 0`\n\n  Edge (1, 2, 1) (flow 10, idx 1): `idx=1 != p_edge_idx=-1`. `v=2` is unvisited.\n    `dfs(2, 1)`:\n      `visited[2] = T`\n      `current_out_flow = 0`\n\n      Edge (2, 3, 0) (flow 10, idx 0): `idx=0 != p_edge_idx=1`. `v=3` is unvisited.\n        `dfs(3, 0)`:\n          `visited[3] = T`\n          `current_out_flow = 0`\n          // No neighbors of 3 other than parent 2.\n          `u=3` is `n`. Return `0`.\n\n      Back in `dfs(2, 1)`: `flow_from_subtree_3 = 0`.\n      `flow_from_subtree_3 <= 0` is true.\n      `ans[0] = 0` (direction `2 -> 3`, flow 10)\n      `current_out_flow += 0` (no change)\n\n      Edge (2, 1, 1) (flow 10, idx 1): `idx=1 == p_edge_idx=1`. Skip.\n\n      `u=2` is not `n`. Return `current_out_flow = 0`.\n\n  Back in `dfs(1, -1)`: `flow_from_subtree_2 = 0`.\n  `flow_from_subtree_2 <= 0` is true.\n  `ans[1] = 0` (direction `1 -> 2`, flow 10)\n  `current_out_flow += 0` (no change)\n\n  Edge (1, 3, 2) (flow 5, idx 2): `idx=2 != p_edge_idx=-1`. `v=3` is visited.\n    `ans[2] = 1` (direction `3 -> 1`, flow 5)\n    `current_out_flow += 5` (`current_out_flow` is now 5)\n\n  `u=1` is not `n`. Return `current_out_flow = 5`.\n\nFinal `ans`:\n`ans[0]` (edge (3,2,10)): `0` (meaning `2 -> 3`)\n`ans[1]` (edge (1,2,10)): `0` (meaning `1 -> 2`)\n`ans[2]` (edge (3,1,5)): `1` (meaning `3 -> 1`)\n\nThis matches the example output! The key was to ensure the sink node `n` returns 0 net outgoing flow, and the source node `1` just accumulates. The `visited` check for cross-edges ensures DAG.\n\nThe logic seems sound now.\nThe `current_out_flow` for `u` is the net flow that needs to exit `u` through its parent edge (`u -> p` if positive, `p -> u` if negative).\nFor the sink `n`, any flow that it \"wants\" to send to its parent must ultimately be absorbed by `n`. So, `n` effectively returns 0, meaning it has no net outgoing flow to its parent. This forces the edge `(p, n)` to be directed `p -> n` if `current_out_flow` from `p` is positive, or `n -> p` if `current_out_flow` from `p` is negative. But for `n`, it must be `p -> n`.\nThe condition \"vertex 1 has no incoming edges\" means that for any edge `(v, 1)`, it must be directed `1 -> v`. The DFS path from `1` to `v` ensures `1` is visited first. If `(v, 1)` is a cross-edge, `v` is visited. My logic directs `v -> 1`. This is problematic.\n\nThe rule \"vertex 1 has no incoming edges\" is paramount.\nAny edge `(v, 1)` must be directed `1 -> v`.\nThis means if `u=1`, and `v` is its child, `ans[idx]` must be `0` (`1 -> v`).\nIf `v=1`, and `u` is its child, then `ans[idx]` must be `1` (`u -> 1`). (This is actually `1 -> u` if `u` is child of `1`, and `u` is not `1`. If `v` is `1` and `u` is its parent, then `u -> 1` is not allowed.)\n\nLet's modify the DFS slightly to handle the source explicitly:\n`dfs(u, p_edge_idx)`:\n  `visited[u] = true`\n  `current_out_flow = 0`\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `idx == p_edge_idx`, continue.\n\n    If `v == 1`: // Edge connects to source. Must be `1 -> u`.\n      `ans[idx] = 0` // `1` is `v`, `u` is `a_i` or `b_i`. This means `a_i=1, b_i=u` or `b_i=1, a_i=u`.\n                     // If `a_i=1`, `ans[idx]=0` means `1 -> u`. If `b_i=1`, `ans[idx]=1` means `1 -> u`.\n                     // Store edges as `(u, v, c, idx, original_a, original_b)`\n                     // If original `a_i == 1`, `ans[idx] = 0`. Else `ans[idx] = 1`.\n      // The `adj` list needs to store `(neighbor, flow, original_idx, original_a, original_b)`.\n      // Let's assume `edges` is `[(a, b, c), ...]` and `adj` stores `(v, c, idx)`.\n      // If `adj[u]` contains `(v, c, idx)`, and `v == 1`:\n      //   If `edges[idx].a == 1`, `ans[idx] = 0`.\n      //   Else (`edges[idx].b == 1`), `ans[idx] = 1`.\n      //   This ensures `1 -> u`.\n      //   `current_out_flow -= c` (flow `1 -> u` means `u` receives flow)\n      //   Continue.\n      // This is complicated. Let's simplify.\n      // The `ans` array is for the original `(a_i, b_i)`. `0` means `a_i -> b_i`, `1` means `b_i -> a_i`.\n      // If `v == 1`: The edge is `(u, 1)`. It must be `1 -> u`.\n      //   If `edges[idx][0] == 1` (i.e. `a_i = 1`), then `ans[idx] = 0`.\n      //   Else (`edges[idx][1] == 1`, i.e. `b_i = 1`), then `ans[idx] = 1`.\n      //   `current_out_flow -= c`.\n      //   Continue.\n\n    If `v == n`: // Edge connects to sink. Must be `u -> n`.\n      // If `edges[idx][0] == u`, then `ans[idx] = 0`.\n      // Else (`edges[idx][1] == u`), then `ans[idx] = 1`.\n      // `current_out_flow += c`.\n      // Continue.\n\n    If `visited[v]`: // Cross-edge or back-edge.\n      // To ensure DAG, flow must go from `v` to `u`.\n      // If `edges[idx][0] == v`, then `ans[idx] = 0`.\n      // Else (`edges[idx][1] == v`), then `ans[idx] = 1`.\n      // `current_out_flow += c`.\n      // Continue.\n    Else: // Tree edge.\n      `flow_from_subtree_v = dfs(v, idx)`\n      If `flow_from_subtree_v > 0`: // `v` has excess outgoing flow, must send to `u`.\n        // If `edges[idx][0] == v`, then `ans[idx] = 0`.\n        // Else (`edges[idx][1] == v`), then `ans[idx] = 1`.\n        `current_out_flow += flow_from_subtree_v`\n      Else: // `v` has excess incoming flow or is balanced, `u` must send to `v`.\n        // If `edges[idx][0] == u`, then `ans[idx] = 0`.\n        // Else (`edges[idx][1] == u`), then `ans[idx] = 1`.\n        `current_out_flow += flow_from_subtree_v`\n\n  If `u == n`:\n    Return 0 // Sink absorbs all.\n  Else:\n    Return `current_out_flow`\n\nThis is the most robust logic. The `ans` assignment needs to be careful about `a_i, b_i`.\nThe `adj` list should store `(neighbor, flow, original_idx, original_endpoint_1, original_endpoint_2)`.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c) for each edge, indexed by original order\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v, c))\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    \n    # current_flow_balance[u] will store the net flow that needs to exit u\n    # through its parent edge in the DFS tree.\n    # A positive value means flow u -> parent, negative means parent -> u.\n    # For intermediate nodes (1 < u < n), this must eventually be 0.\n    # For source (1), it accumulates total outgoing flow.\n    # For sink (n), it should effectively be 0, as sink absorbs all flow.\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        current_out_flow = 0 # Net flow that needs to exit 'u' via its parent edge\n\n        for v, c, edge_idx in adj[u]:\n            if edge_idx == p_edge_idx:\n                continue # Skip the edge to the parent in DFS tree\n\n            if ans[edge_idx] != -1:\n                continue # Edge already directed (e.g., by a cross-edge from other side)\n\n            # Special handling for source (vertex 1)\n            if v == 1: # Edge (u, 1) must be directed 1 -> u\n                # If original edge was (1, u), ans[edge_idx] = 0.\n                # If original edge was (u, 1), ans[edge_idx] = 1.\n                if edges_info[edge_idx][0] == 1: # Original was (1, u)\n                    ans[edge_idx] = 0\n                else: # Original was (u, 1)\n                    ans[edge_idx] = 1\n                current_out_flow -= c # u receives flow from 1\n                continue\n            \n            # Special handling for sink (vertex n)\n            if v == n: # Edge (u, n) must be directed u -> n\n                # If original edge was (u, n), ans[edge_idx] = 0.\n                # If original edge was (n, u), ans[edge_idx] = 1.\n                if edges_info[edge_idx][0] == u: # Original was (u, n)\n                    ans[edge_idx] = 0\n                else: # Original was (n, u)\n                    ans[edge_idx] = 1\n                current_out_flow += c # u sends flow to n\n                continue\n\n            if visited[v]: # Cross-edge or back-edge to a non-source/non-sink node\n                # To ensure DAG, flow must go from already visited 'v' to 'u'.\n                # If original edge was (v, u), ans[edge_idx] = 0.\n                # If original edge was (u, v), ans[edge_idx] = 1.\n                if edges_info[edge_idx][0] == v: # Original was (v, u)\n                    ans[edge_idx] = 0\n                else: # Original was (u, v)\n                    ans[edge_idx] = 1\n                current_out_flow += c # u receives flow from v\n            else: # Tree edge\n                flow_from_subtree_v = dfs(v, edge_idx)\n                if flow_from_subtree_v > 0: # v has excess outgoing flow, must send to u\n                    # If original edge was (v, u), ans[edge_idx] = 0.\n                    # If original edge was (u, v), ans[edge_idx] = 1.\n                    if edges_info[edge_idx][0] == v: # Original was (v, u)\n                        ans[edge_idx] = 0\n                    else: # Original was (u, v)\n                        ans[edge_idx] = 1\n                    current_out_flow += flow_from_subtree_v\n                else: # v has excess incoming flow or is balanced, u must send to v\n                    # If original edge was (u, v), ans[edge_idx] = 0.\n                    # If original edge was (v, u), ans[edge_idx] = 1.\n                    if edges_info[edge_idx][0] == u: # Original was (u, v)\n                        ans[edge_idx] = 0\n                    else: # Original was (v, u)\n                        ans[edge_idx] = 1\n                    current_out_flow += flow_from_subtree_v # u sends flow to v\n\n        # For the sink node 'n', it must absorb all flow, so it cannot have any net outgoing flow\n        # to its parent. Effectively, it returns 0.\n        if u == n:\n            return 0\n        else:\n            return current_out_flow\n\n    # Start DFS from source (vertex 1) with a dummy parent edge index (-1)\n    dfs(1, -1)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c) for each edge, indexed by original order\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v, c))\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    \n    # current_flow_balance[u] will store the net flow that needs to exit u\n    # through its parent edge in the DFS tree.\n    # A positive value means flow u -> parent, negative means parent -> u.\n    # For intermediate nodes (1 < u < n), this must eventually be 0.\n    # For source (1), it accumulates total outgoing flow.\n    # For sink (n), it should effectively be 0, as sink absorbs all flow.\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        current_out_flow = 0 # Net flow that needs to exit 'u' via its parent edge\n\n        for v, c, edge_idx in adj[u]:\n            if edge_idx == p_edge_idx:\n                continue # Skip the edge to the parent in DFS tree\n\n            if ans[edge_idx] != -1:\n                continue # Edge already directed (e.g., by a cross-edge from other side)\n\n            # Special handling for source (vertex 1)\n            if v == 1: # Edge (u, 1) must be directed 1 -> u\n                # If original edge was (1, u), ans[edge_idx] = 0.\n                # If original edge was (u, 1), ans[edge_idx] = 1.\n                if edges_info[edge_idx][0] == 1: # Original was (1, u)\n                    ans[edge_idx] = 0\n                else: # Original was (u, 1)\n                    ans[edge_idx] = 1\n                current_out_flow -= c # u receives flow from 1\n                continue\n            \n            # Special handling for sink (vertex n)\n            if v == n: # Edge (u, n) must be directed u -> n\n                # If original edge was (u, n), ans[edge_idx] = 0.\n                # If original edge was (n, u), ans[edge_idx] = 1.\n                if edges_info[edge_idx][0] == u: # Original was (u, n)\n                    ans[edge_idx] = 0\n                else: # Original was (n, u)\n                    ans[edge_idx] = 1\n                current_out_flow += c # u sends flow to n\n                continue\n\n            if visited[v]: # Cross-edge or back-edge to a non-source/non-sink node\n                # To ensure DAG, flow must go from already visited 'v' to 'u'.\n                # If original edge was (v, u), ans[edge_idx] = 0.\n                # If original edge was (u, v), ans[edge_idx] = 1.\n                if edges_info[edge_idx][0] == v: # Original was (v, u)\n                    ans[edge_idx] = 0\n                else: # Original was (u, v)\n                    ans[edge_idx] = 1\n                current_out_flow += c # u receives flow from v\n            else: # Tree edge\n                flow_from_subtree_v = dfs(v, edge_idx)\n                if flow_from_subtree_v > 0: # v has excess outgoing flow, must send to u\n                    # If original edge was (v, u), ans[edge_idx] = 0.\n                    # If original edge was (u, v), ans[edge_idx] = 1.\n                    if edges_info[edge_idx][0] == v: # Original was (v, u)\n                        ans[edge_idx] = 0\n                    else: # Original was (u, v)\n                        ans[edge_idx] = 1\n                    current_out_flow += flow_from_subtree_v\n                else: # v has excess incoming flow or is balanced, u must send to v\n                    # If original edge was (u, v), ans[edge_idx] = 0.\n                    # If original edge was (v, u), ans[edge_idx] = 1.\n                    if edges_info[edge_idx][0] == u: # Original was (u, v)\n                        ans[edge_idx] = 0\n                    else: # Original was (v, u)\n                        ans[edge_idx] = 1\n                    current_out_flow += flow_from_subtree_v # u sends flow to v\n\n        # For the sink node 'n', it must absorb all flow, so it cannot have any net outgoing flow\n        # to its parent. Effectively, it returns 0.\n        if u == n:\n            return 0\n        else:\n            return current_out_flow\n\n    # Start DFS from source (vertex 1) with a dummy parent edge index (-1)\n    dfs(1, -1)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 10142,
        "thoughts_token_count": 8191
    }
}