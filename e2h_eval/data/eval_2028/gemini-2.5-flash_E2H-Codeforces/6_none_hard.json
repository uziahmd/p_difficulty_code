{
    "start": 1758011283.5582266,
    "end": 1758011303.1428216,
    "start-formatted": "2025-09-16 17:28 KST",
    "end-formatted": "2025-09-16 17:28 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    max_coord = 2 * 10**5\n    min_cost_for_duration = {} # (start_day, duration) -> min_cost\n    \n    # Store vouchers by their start day\n    vouchers_by_start = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_start[l].append((r, cost))\n\n    min_total_cost = float('inf')\n\n    # Iterate through all possible end days for the first voucher\n    # and maintain minimum costs for vouchers ending at or before that day.\n    \n    # min_cost_ending_at[d] stores a list of (duration, cost) for vouchers ending at day d\n    # This structure is not efficient for queries.\n    # Instead, we need a data structure that can query min cost for a given duration.\n\n    # Let's process vouchers sorted by their end day\n    # Create a list of events: (day, type, voucher_index)\n    # type 0: voucher starts\n    # type 1: voucher ends\n    events = []\n    for i, (l, r, cost) in enumerate(vouchers):\n        events.append((l, 0, i)) # (day, type=0 for start, voucher_index)\n        events.append((r, 1, i)) # (day, type=1 for end, voucher_index)\n    \n    events.sort()\n\n    # min_costs_by_duration[duration] stores the minimum cost of a voucher with that duration\n    # that has *already ended*\n    min_costs_by_duration = {} # duration -> min_cost\n\n    # current_active_vouchers: a temporary structure to hold vouchers that are currently \"active\"\n    # (i.e., their start day has been processed, but their end day hasn't)\n    # This isn't directly used for the final calculation, but helps in conceptualizing.\n\n    # Instead, let's iterate through days from 1 to max_coord\n    # For each day `d`, we consider it as the end day of the first voucher.\n    # We need to find a second voucher that starts at `d+1` or later.\n    \n    # A better approach:\n    # Iterate through all possible end days `r1` for the first voucher.\n    # For each `r1`, we need to find a voucher `j` such that `l_j > r1` and `duration_i + duration_j = x`.\n    # To do this efficiently, we can precompute minimum costs.\n\n    # `min_cost_for_duration_ending_at_or_before[d][dur]` = min cost of a voucher with `dur` duration\n    # that ends at or before day `d`.\n    # This is too large. `max_coord * max_coord`\n\n    # Let's try iterating through the vouchers and for each voucher `i`,\n    # try to find a suitable second voucher `j`.\n    \n    # We need to maintain the minimum cost for each possible duration `d`\n    # for all vouchers that have ended *before* the current voucher's start day.\n    \n    # `dp[d]` will store the minimum cost of a voucher with duration `d`\n    # that has already been processed (i.e., its end day is less than the current day being considered).\n    # Initialize `dp` with infinity.\n    \n    # The maximum possible duration is `max_coord`.\n    # `min_cost_for_prev_vouchers[duration]` = min cost of a voucher with `duration`\n    # that has an end day `r` such that `r < current_voucher.l`.\n    \n    # We can iterate through days `d` from 1 to `max_coord`.\n    # At each day `d`, we update the `min_cost_for_prev_vouchers` based on vouchers that end at `d-1`.\n    # Then, we consider all vouchers that start at `d`.\n\n    # `min_cost_for_duration_ending_before[d]` stores the minimum cost of a voucher\n    # with duration `d` that has ended *before* the current day `i`.\n    # Initialize with a large value.\n    \n    # `min_cost_for_duration_ending_at_day[day]` is a dictionary mapping duration to min_cost\n    # for vouchers ending exactly on `day`.\n    \n    # Let's process vouchers sorted by their start day `l`.\n    # When processing vouchers that start at `l`, we need information about vouchers\n    # that end at `l-1` or earlier.\n\n    # `min_cost_for_duration_ending_before_day[day]` will store the minimum cost for each duration\n    # of a voucher that ends *strictly before* `day`.\n    # This will be an array of size `max_coord + 1`.\n    # `min_cost_for_duration_ending_before_day[d]` will store the minimum cost for a voucher\n    # with duration `d` that has an end day `r_k < current_l`.\n\n    # `min_cost_for_duration_ending_before_day[duration]`\n    # Initialize this array with infinity.\n    \n    # `min_cost_for_duration_ending_before_day_at_time[time_point][duration]`\n    # This is still too much memory.\n\n    # We need to process events chronologically.\n    # `events` will store (day, type, voucher_data)\n    # Type 0: voucher starts at `day`. `voucher_data` = (r, cost, duration)\n    # Type 1: voucher ends at `day`. `voucher_data` = (cost, duration)\n    \n    # Let's group vouchers by their start day.\n    vouchers_by_start_day = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n\n    # `min_cost_for_duration_ending_at_or_before[duration]`\n    # This array will store the minimum cost for a voucher with `duration`\n    # that has *already ended*.\n    # Initialize with infinity.\n    min_cost_for_duration_ending_at_or_before = [float('inf')] * (max_coord + 1)\n    \n    overall_min_cost = float('inf')\n\n    # Iterate through each possible day `d` from 1 to `max_coord`.\n    # `d` represents the current day.\n    # When we are at day `d`, we consider all vouchers that start at `d`.\n    # For each such voucher `v_i = (l_i, r_i, cost_i)`:\n    # 1. Calculate its duration `dur_i = r_i - l_i + 1`.\n    # 2. We need to find a second voucher `v_j` such that `r_j < l_i` (i.e., `r_j < d`)\n    #    and `dur_j = x - dur_i`.\n    # 3. The minimum cost for such a `v_j` is stored in `min_cost_for_duration_ending_at_or_before[x - dur_i]`.\n    #    If `x - dur_i > 0` and `x - dur_i <= max_coord`.\n    # 4. Update `overall_min_cost` with `cost_i + min_cost_for_duration_ending_at_or_before[x - dur_i]`.\n    \n    # After processing all vouchers that start at `d`,\n    # we need to update `min_cost_for_duration_ending_at_or_before`\n    # with vouchers that *end* at `d`.\n    \n    # Let's group vouchers by their end day.\n    vouchers_by_end_day = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_end_day[r].append((cost, duration))\n\n    for d in range(1, max_coord + 1):\n        # Step 1: Consider vouchers that start at day `d`.\n        # For each such voucher `v_i = (l_i, r_i, cost_i)`:\n        # We need to find a `v_j` that ended *before* `l_i` (i.e., `r_j < d`).\n        # The `min_cost_for_duration_ending_at_or_before` array already holds this information\n        # because it was updated with all vouchers ending up to day `d-1`.\n        for r_i, cost_i, dur_i in vouchers_by_start_day[d]:\n            required_dur_j = x - dur_i\n            if 1 <= required_dur_j <= max_coord:\n                if min_cost_for_duration_ending_at_or_before[required_dur_j] != float('inf'):\n                    overall_min_cost = min(overall_min_cost, cost_i + min_cost_for_duration_ending_at_or_before[required_dur_j])\n        \n        # Step 2: Update `min_cost_for_duration_ending_at_or_before`\n        # with vouchers that *end* at day `d`.\n        for cost_j, dur_j in vouchers_by_end_day[d]:\n            min_cost_for_duration_ending_at_or_before[dur_j] = min(min_cost_for_duration_ending_at_or_before[dur_j], cost_j)\n\n    if overall_min_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(overall_min_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    max_coord = 2 * 10**5\n    min_cost_for_duration = {} # (start_day, duration) -> min_cost\n    \n    # Store vouchers by their start day\n    vouchers_by_start = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_start[l].append((r, cost))\n\n    min_total_cost = float('inf')\n\n    # Iterate through all possible end days for the first voucher\n    # and maintain minimum costs for vouchers ending at or before that day.\n    \n    # min_cost_ending_at[d] stores a list of (duration, cost) for vouchers ending at day d\n    # This structure is not efficient for queries.\n    # Instead, we need a data structure that can query min cost for a given duration.\n\n    # Let's process vouchers sorted by their end day\n    # Create a list of events: (day, type, voucher_index)\n    # type 0: voucher starts\n    # type 1: voucher ends\n    events = []\n    for i, (l, r, cost) in enumerate(vouchers):\n        events.append((l, 0, i)) # (day, type=0 for start, voucher_index)\n        events.append((r, 1, i)) # (day, type=1 for end, voucher_index)\n    \n    events.sort()\n\n    # min_costs_by_duration[duration] stores the minimum cost of a voucher with that duration\n    # that has *already ended*\n    min_costs_by_duration = {} # duration -> min_cost\n\n    # current_active_vouchers: a temporary structure to hold vouchers that are currently \"active\"\n    # (i.e., their start day has been processed, but their end day hasn't)\n    # This isn't directly used for the final calculation, but helps in conceptualizing.\n\n    # Instead, let's iterate through days from 1 to max_coord\n    # For each day `d`, we consider it as the end day of the first voucher.\n    # We need to find a second voucher that starts at `d+1` or later.\n    \n    # A better approach:\n    # Iterate through all possible end days `r1` for the first voucher.\n    # For each `r1`, we need to find a voucher `j` such that `l_j > r1` and `duration_i + duration_j = x`.\n    # To do this efficiently, we can precompute minimum costs.\n\n    # `min_cost_for_duration_ending_at_or_before[d][dur]` = min cost of a voucher with `dur` duration\n    # that ends at or before day `d`.\n    # This is too large. `max_coord * max_coord`\n\n    # Let's try iterating through the vouchers and for each voucher `i`,\n    # try to find a suitable second voucher `j`.\n    \n    # We need to maintain the minimum cost for each possible duration `d`\n    # for all vouchers that have ended *before* the current voucher's start day.\n    \n    # `dp[d]` will store the minimum cost of a voucher with duration `d`\n    # that has already been processed (i.e., its end day is less than the current day being considered).\n    # Initialize `dp` with infinity.\n    \n    # The maximum possible duration is `max_coord`.\n    # `min_cost_for_prev_vouchers[duration]` = min cost of a voucher with `duration`\n    # that has an end day `r` such that `r < current_voucher.l`.\n    \n    # We can iterate through days `d` from 1 to `max_coord`.\n    # At each day `d`, we update the `min_cost_for_prev_vouchers` based on vouchers that end at `d-1`.\n    # Then, we consider all vouchers that start at `d`.\n\n    # `min_cost_for_duration_ending_before[d]` stores the minimum cost of a voucher\n    # with duration `d` that has ended *before* the current day `i`.\n    # Initialize with a large value.\n    \n    # `min_cost_for_duration_ending_at_day[day]` is a dictionary mapping duration to min_cost\n    # for vouchers ending exactly on `day`.\n    \n    # Let's process vouchers sorted by their start day `l`.\n    # When processing vouchers that start at `l`, we need information about vouchers\n    # that end at `l-1` or earlier.\n\n    # `min_cost_for_duration_ending_before_day[day]` will store the minimum cost for each duration\n    # of a voucher that ends *strictly before* `day`.\n    # This will be an array of size `max_coord + 1`.\n    # `min_cost_for_duration_ending_before_day[d]` will store the minimum cost for a voucher\n    # with duration `d` that has an end day `r_k < current_l`.\n\n    # `min_cost_for_duration_ending_before_day[duration]`\n    # Initialize this array with infinity.\n    \n    # `min_cost_for_duration_ending_before_day_at_time[time_point][duration]`\n    # This is still too much memory.\n\n    # We need to process events chronologically.\n    # `events` will store (day, type, voucher_data)\n    # Type 0: voucher starts at `day`. `voucher_data` = (r, cost, duration)\n    # Type 1: voucher ends at `day`. `voucher_data` = (cost, duration)\n    \n    # Let's group vouchers by their start day.\n    vouchers_by_start_day = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n\n    # `min_cost_for_duration_ending_at_or_before[duration]`\n    # This array will store the minimum cost for a voucher with `duration`\n    # that has *already ended*.\n    # Initialize with infinity.\n    min_cost_for_duration_ending_at_or_before = [float('inf')] * (max_coord + 1)\n    \n    overall_min_cost = float('inf')\n\n    # Iterate through each possible day `d` from 1 to `max_coord`.\n    # `d` represents the current day.\n    # When we are at day `d`, we consider all vouchers that start at `d`.\n    # For each such voucher `v_i = (l_i, r_i, cost_i)`:\n    # 1. Calculate its duration `dur_i = r_i - l_i + 1`.\n    # 2. We need to find a second voucher `v_j` such that `r_j < l_i` (i.e., `r_j < d`)\n    #    and `dur_j = x - dur_i`.\n    # 3. The minimum cost for such a `v_j` is stored in `min_cost_for_duration_ending_at_or_before[x - dur_i]`.\n    #    If `x - dur_i > 0` and `x - dur_i <= max_coord`.\n    # 4. Update `overall_min_cost` with `cost_i + min_cost_for_duration_ending_at_or_before[x - dur_i]`.\n    \n    # After processing all vouchers that start at `d`,\n    # we need to update `min_cost_for_duration_ending_at_or_before`\n    # with vouchers that *end* at `d`.\n    \n    # Let's group vouchers by their end day.\n    vouchers_by_end_day = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_end_day[r].append((cost, duration))\n\n    for d in range(1, max_coord + 1):\n        # Step 1: Consider vouchers that start at day `d`.\n        # For each such voucher `v_i = (l_i, r_i, cost_i)`:\n        # We need to find a `v_j` that ended *before* `l_i` (i.e., `r_j < d`).\n        # The `min_cost_for_duration_ending_at_or_before` array already holds this information\n        # because it was updated with all vouchers ending up to day `d-1`.\n        for r_i, cost_i, dur_i in vouchers_by_start_day[d]:\n            required_dur_j = x - dur_i\n            if 1 <= required_dur_j <= max_coord:\n                if min_cost_for_duration_ending_at_or_before[required_dur_j] != float('inf'):\n                    overall_min_cost = min(overall_min_cost, cost_i + min_cost_for_duration_ending_at_or_before[required_dur_j])\n        \n        # Step 2: Update `min_cost_for_duration_ending_at_or_before`\n        # with vouchers that *end* at day `d`.\n        for cost_j, dur_j in vouchers_by_end_day[d]:\n            min_cost_for_duration_ending_at_or_before[dur_j] = min(min_cost_for_duration_ending_at_or_before[dur_j], cost_j)\n\n    if overall_min_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(overall_min_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 2422,
        "thoughts_token_count": 0
    }
}