{
    "start": 1758293727.939022,
    "end": 1758293762.2217262,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\nMOD = 1000000007\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else: # m > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    ans = 0\n\n    if g == 0:\n        # Case 1: n is odd\n        if n % 2 == 1:\n            # The final result is 0\n            # This happens if m is even, or m is odd and the number of 1s in the string is odd.\n            # Number of 1s in the string is odd means m is odd.\n            # So, if n is odd, the result is 0 if m is even.\n            # If n is odd and m is odd, the result is 0.\n            # So if n is odd, the result is always 0.\n            # This logic is based on the parity of the number of 1s.\n            # If n is odd, the final character is 0 if and only if the number of 1s is even.\n            # If n is odd, the final character is 1 if and only if the number of 1s is odd.\n            # So if n is odd, and we want g=0, we need m to be even.\n            if m % 2 == 0:\n                # The final character is 0.\n                # The last character is 0, if the number of 1s is even.\n                # This is a bit counter-intuitive. Let's re-evaluate.\n                # The operation is: replace two last characters by one.\n                # 00 -> 1\n                # 01 -> 0\n                # 10 -> 0\n                # 11 -> 0\n                # The final character is 0 if and only if there is at least one '1' among the two last characters, OR if the two last characters are '11'.\n                # The final character is 1 if and only if the two last characters are '00'.\n                # This means the final character is 1 iff all characters are '0's.\n                # This is incorrect. The final character is 1 iff the number of 0s is odd and the number of 1s is even.\n                # This is incorrect. The final character is 1 iff the number of 0s is odd.\n                # This is incorrect. The final character is 1 iff the number of 0s is odd and the number of 1s is even.\n                # Let's consider the parity of the number of 1s.\n                # If we have a string S, and we replace S_k-1 S_k with C.\n                # If S_k-1 S_k = 00, C = 1. The number of 1s increases by 1.\n                # If S_k-1 S_k = 01, C = 0. The number of 1s remains the same.\n                # If S_k-1 S_k = 10, C = 0. The number of 1s remains the same.\n                # If S_k-1 S_k = 11, C = 0. The number of 1s decreases by 2.\n                # So, the parity of the number of 1s changes only when 00 -> 1 (odd change) or 11 -> 0 (even change).\n                # This means the parity of the number of 1s flips if 00 -> 1.\n                # The parity of the number of 1s is invariant if 01 -> 0, 10 -> 0, 11 -> 0.\n                # So, the final character is 1 if and only if the number of 0s is odd.\n                # And the final character is 0 if and only if the number of 0s is even.\n                # This is for a string of length 2.\n                # For a string of length L, after L-1 operations, we get a single character.\n                # Let's consider the XOR sum of the characters.\n                # 0^0=0, 0^1=1, 1^0=1, 1^1=0.\n                # The operation is: replace S_k-1 S_k with C.\n                # C = 1 if S_k-1 S_k = 00.\n                # C = 0 otherwise.\n                # This is NOT XOR sum.\n                # This is: C = 1 - (S_k-1 OR S_k). This is NOT standard.\n                # This is: C = (S_k-1 == 0 AND S_k == 0) ? 1 : 0.\n                # Let's denote the number of 0s as N_0 and number of 1s as N_1.\n                # The final character is 1 if and only if N_0 is odd.\n                # The final character is 0 if and only if N_0 is even.\n                # This is a known property for this type of operation.\n                # If n is odd, the final character is 1.\n                # If n is even, the final character is 0.\n                # This is the correct property.\n\n                # We want g = 0. So we need n to be even.\n                # If n is odd, and g = 0, the answer is 0.\n                # If n is even, and g = 0, we can have a beautiful string.\n                if n % 2 == 0:\n                    # n is even, so the final character is 0.\n                    # We need to count strings with n zeros and m ones.\n                    # This is C(n+m, n).\n                    ans = nCr_mod_p(n + m, n)\n                else: # n is odd\n                    ans = 0\n            else: # m is odd\n                # If n is odd and m is odd, and we want g=0, then the answer is 0.\n                ans = 0\n        else: # n is even\n            # If n is even, the final character is 0.\n            # This is always true regardless of m.\n            # So we count all strings with n zeros and m ones.\n            ans = nCr_mod_p(n + m, n)\n\n    else: # g == 1\n        # We want g = 1. So we need n to be odd.\n        # If n is odd, the final character is 1.\n        # If n is even, the final character is 0.\n        # So if n is even and g = 1, the answer is 0.\n        if n % 2 == 1:\n            # n is odd, so the final character is 1.\n            # We need to count strings with n zeros and m ones.\n            # This is C(n+m, n).\n            ans = nCr_mod_p(n + m, n)\n        else: # n is even\n            ans = 0\n\n    # The above logic is simple and seems to work for many cases.\n    # However, there's a subtle point: what if m = 0?\n    # If m = 0, string has only 0s.\n    # \"0\" -> 0 (n=1, m=0)\n    # \"00\" -> 1 (n=2, m=0)\n    # \"000\" -> \"01\" -> 0 (n=3, m=0)\n    # \"0000\" -> \"001\" -> \"10\" -> 0 (n=4, m=0)\n    # \"00000\" -> \"0001\" -> \"010\" -> \"00\" -> 1 (n=5, m=0)\n    # The final character is 1 if n is odd, and 0 if n is even.\n    # This matches the property \"final character is 1 iff number of 0s is odd\".\n    # So the logic holds for m=0.\n\n    # What if n = 0? String has only 1s.\n    # \"1\" -> 1 (n=0, m=1)\n    # \"11\" -> 0 (n=0, m=2)\n    # \"111\" -> \"10\" -> 0 (n=0, m=3)\n    # \"1111\" -> \"100\" -> \"11\" -> 0 (n=0, m=4)\n    # \"11111\" -> \"1100\" -> \"10\" -> 0 (n=0, m=5)\n    # Here, for n=0, the final character is 1 if m=1, and 0 if m > 1.\n    # My logic \"final character is 1 iff n is odd\" would say for n=0 (even), final char is 0.\n    # This contradicts m=1 -> 1.\n    # So the property \"final character is 1 iff number of 0s is odd\" is NOT universally true.\n    # It seems to hold IF AND ONLY IF there is at least one 0.\n    # Or more precisely, if the string contains at least one 0 and at least one 1.\n\n    # Let's re-evaluate the operation: C = 1 if (S_k-1 == 0 AND S_k == 0), else C = 0.\n    # This is equivalent to C = NOT (S_k-1 OR S_k).\n    # Let f(S) be the result of the operations on string S.\n    # f(S_1 S_2 ... S_k) = f(S_1 ... S_k-2 C) where C = NOT (S_k-1 OR S_k).\n\n    # Consider the parity of the number of 0s (N_0) and 1s (N_1).\n    # Let's analyze the effect on the last character.\n    # S_k-1 S_k -> C\n    # 00 -> 1 (N_0 decreases by 2, N_1 increases by 1)\n    # 01 -> 0 (N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. Net: N_0 same, N_1 decreases by 2)\n    # 10 -> 0 (N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. Net: N_0 same, N_1 decreases by 2)\n    # 11 -> 0 (N_1 decreases by 2, N_0 increases by 1)\n\n    # This is not about the number of 0s. This is about the value of the final character.\n    # Let's track the final character.\n    # The final character is 1 if and only if the string is \"0\" or \"00...0\" (n zeros, m=0, n is odd).\n    # If the string contains at least one '1', then the final character is 0 if and only if m > 1.\n    # If m=1, and n > 0, then the string is \"0...010...0\".\n    # The final character is 0 if n is even.\n    # The final character is 1 if n is odd.\n\n    # This is the property from a known problem: The final character is 1 if and only if the number of 0s is odd,\n    # UNLESS the string consists of only 1s and has length > 1, in which case the result is 0.\n    # If the string consists of only 1s and has length 1, the result is 1.\n\n    # Let's break it down by cases for n, m, g.\n\n    # Case 1: n = 0 (string contains only 1s)\n    # If m = 1: string is \"1\". Result is 1.\n    #   If g = 1, ans = 1.\n    #   If g = 0, ans = 0.\n    # If m > 1: string is \"1...1\".\n    #   \"11\" -> 0\n    #   \"111\" -> \"10\" -> 0\n    #   \"1111\" -> \"100\" -> \"11\" -> 0\n    #   The result is always 0.\n    #   If g = 1, ans = 0.\n    #   If g = 0, ans = 1.\n\n    # My initial special handling for n=0 was correct.\n    # if n == 0:\n    #     if m == 1:\n    #         if g == 1: print(1)\n    #         else: print(0)\n    #     else: # m > 1\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     return\n\n    # Case 2: m = 0 (string contains only 0s)\n    # If n = 1: string is \"0\". Result is 0.\n    #   If g = 1, ans = 0.\n    #   If g = 0, ans = 1.\n    # If n > 1: string is \"0...0\".\n    #   \"00\" -> 1\n    #   \"000\" -> \"01\" -> 0\n    #   \"0000\" -> \"001\" -> \"10\" -> 0\n    #   \"00000\" -> \"0001\" -> \"010\" -> \"00\" -> 1\n    #   Result is 1 if n is odd, 0 if n is even.\n    #   If g = 1, ans = 1 if n is odd, 0 if n is even.\n    #   If g = 0, ans = 1 if n is even, 0 if n is odd.\n\n    # My initial special handling for m=0 was correct.\n    # if m == 0:\n    #     if n == 1:\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     else: # n > 1\n    #         if g == 0: print(1) if n % 2 == 0 else print(0)\n    #         else: print(1) if n % 2 == 1 else print(0)\n    #     return\n\n    # Let's combine this.\n    # n=0, m=1: g=1 -> 1, g=0 -> 0\n    # n=0, m>1: g=0 -> 1, g=1 -> 0\n    # n=1, m=0: g=0 -> 1, g=1 -> 0\n    # n>1, m=0: g=0 -> (n%2==0 ? 1 : 0), g=1 -> (n%2==1 ? 1 : 0)\n\n    # My code has:\n    # if n == 0:\n    #     if m == 1:\n    #         if g == 1: print(1)\n    #         else: print(0)\n    #     else: # m > 1\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     return\n    # This is correct.\n\n    # if m == 0:\n    #     if n == 1:\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     else: # n > 1\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     return\n    # This is incorrect for n > 1. It should be:\n    # if m == 0:\n    #     if n == 1:\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     else: # n > 1\n    #         if (n % 2 == 0 and g == 0) or (n % 2 == 1 and g == 1):\n    #             print(1)\n    #         else:\n    #             print(0)\n    #     return\n\n    # Let's update the m=0 case.\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n > 1\n            if (n % 2 == 0 and g == 0) or (n % 2 == 1 and g == 1):\n                print(1)\n            else:\n                print(0)\n        return\n\n    # Case 3: n > 0 and m > 0 (string contains both 0s and 1s)\n    # In this case, the property \"final character is 1 iff number of 0s is odd\" holds.\n    # So, if g = 0, we need n to be even.\n    # If g = 1, we need n to be odd.\n\n    # The logic in my code for n > 0 and m > 0:\n    # if g == 0:\n    #     if n % 2 == 0:\n    #         ans = nCr_mod_p(n + m, n)\n    #     else: # n is odd\n    #         ans = 0\n    # else: # g == 1\n    #     if n % 2 == 1:\n    #         ans = nCr_mod_p(n + m, n)\n    #     else: # n is even\n    #         ans = 0\n    # This logic is correct for n > 0 and m > 0.\n\n    # Let's re-run the full logic with corrected m=0 case.\n\n    # n, m, g = map(int, sys.stdin.readline().split()) # already read\n\n    # Handle edge cases n=0 or m=0\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else: # m > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n > 1\n            if (n % 2 == 0 and g == 0) or (n % 2 == 1 and g == 1):\n                print(1)\n            else:\n                print(0)\n        return\n\n    # General case: n > 0 and m > 0\n    # Precompute factorials and inverse factorials\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    ans = 0\n    if g == 0:\n        if n % 2 == 0:\n            ans = nCr_mod_p(n + m, n)\n        else:\n            ans = 0\n    else: # g == 1\n        if n % 2 == 1:\n            ans = nCr_mod_p(n + m, n)\n        else:\n            ans = 0\n\n    print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else: # m > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    ans = 0\n\n    if g == 0:\n        # Case 1: n is odd\n        if n % 2 == 1:\n            # The final result is 0\n            # This happens if m is even, or m is odd and the number of 1s in the string is odd.\n            # Number of 1s in the string is odd means m is odd.\n            # So, if n is odd, the result is 0 if m is even.\n            # If n is odd and m is odd, the result is 0.\n            # So if n is odd, the result is always 0.\n            # This logic is based on the parity of the number of 1s.\n            # If n is odd, the final character is 0 if and only if the number of 1s is even.\n            # If n is odd, the final character is 1 if and only if the number of 1s is odd.\n            # So if n is odd, and we want g=0, we need m to be even.\n            if m % 2 == 0:\n                # The final character is 0.\n                # The last character is 0, if the number of 1s is even.\n                # This is a bit counter-intuitive. Let's re-evaluate.\n                # The operation is: replace two last characters by one.\n                # 00 -> 1\n                # 01 -> 0\n                # 10 -> 0\n                # 11 -> 0\n                # The final character is 0 if and only if there is at least one '1' among the two last characters, OR if the two last characters are '11'.\n                # The final character is 1 if and only if the two last characters are '00'.\n                # This means the final character is 1 iff all characters are '0's.\n                # This is incorrect. The final character is 1 iff the number of 0s is odd and the number of 1s is even.\n                # This is incorrect. The final character is 1 iff the number of 0s is odd.\n                # This is incorrect. The final character is 1 iff the number of 0s is odd and the number of 1s is even.\n                # Let's consider the parity of the number of 1s.\n                # If we have a string S, and we replace S_k-1 S_k with C.\n                # If S_k-1 S_k = 00, C = 1. The number of 1s increases by 1.\n                # If S_k-1 S_k = 01, C = 0. The number of 1s remains the same.\n                # If S_k-1 S_k = 10, C = 0. The number of 1s remains the same.\n                # If S_k-1 S_k = 11, C = 0. The number of 1s decreases by 2.\n                # So, the parity of the number of 1s changes only when 00 -> 1 (odd change) or 11 -> 0 (even change).\n                # This means the parity of the number of 1s flips if 00 -> 1.\n                # The parity of the number of 1s is invariant if 01 -> 0, 10 -> 0, 11 -> 0.\n                # So, the final character is 1 if and only if the number of 0s is odd.\n                # And the final character is 0 if and only if the number of 0s is even.\n                # This is for a string of length 2.\n                # For a string of length L, after L-1 operations, we get a single character.\n                # Let's consider the XOR sum of the characters.\n                # 0^0=0, 0^1=1, 1^0=1, 1^1=0.\n                # The operation is: replace S_k-1 S_k with C.\n                # C = 1 if S_k-1 S_k = 00.\n                # C = 0 otherwise.\n                # This is NOT XOR sum.\n                # This is: C = 1 - (S_k-1 OR S_k). This is NOT standard.\n                # This is: C = (S_k-1 == 0 AND S_k == 0) ? 1 : 0.\n                # Let's denote the number of 0s as N_0 and number of 1s as N_1.\n                # The final character is 1 if and only if N_0 is odd.\n                # The final character is 0 if and only if N_0 is even.\n                # This is a known property for this type of operation.\n                # If n is odd, the final character is 1.\n                # If n is even, the final character is 0.\n                # This is the correct property.\n\n                # We want g = 0. So we need n to be even.\n                # If n is odd, and g = 0, the answer is 0.\n                # If n is even, and g = 0, we can have a beautiful string.\n                if n % 2 == 0:\n                    # n is even, so the final character is 0.\n                    # We need to count strings with n zeros and m ones.\n                    # This is C(n+m, n).\n                    ans = nCr_mod_p(n + m, n)\n                else: # n is odd\n                    ans = 0\n            else: # m is odd\n                # If n is odd and m is odd, and we want g=0, then the answer is 0.\n                ans = 0\n        else: # n is even\n            # If n is even, the final character is 0.\n            # This is always true regardless of m.\n            # So we count all strings with n zeros and m ones.\n            ans = nCr_mod_p(n + m, n)\n\n    else: # g == 1\n        # We want g = 1. So we need n to be odd.\n        # If n is odd, the final character is 1.\n        # If n is even, the final character is 0.\n        # So if n is even and g = 1, the answer is 0.\n        if n % 2 == 1:\n            # n is odd, so the final character is 1.\n            # We need to count strings with n zeros and m ones.\n            # This is C(n+m, n).\n            ans = nCr_mod_p(n + m, n)\n        else: # n is even\n            ans = 0\n\n    # The above logic is simple and seems to work for many cases.\n    # However, there's a subtle point: what if m = 0?\n    # If m = 0, string has only 0s.\n    # \"0\" -> 0 (n=1, m=0)\n    # \"00\" -> 1 (n=2, m=0)\n    # \"000\" -> \"01\" -> 0 (n=3, m=0)\n    # \"0000\" -> \"001\" -> \"10\" -> 0 (n=4, m=0)\n    # \"00000\" -> \"0001\" -> \"010\" -> \"00\" -> 1 (n=5, m=0)\n    # The final character is 1 if n is odd, and 0 if n is even.\n    # This matches the property \"final character is 1 iff number of 0s is odd\".\n    # So the logic holds for m=0.\n\n    # What if n = 0? String has only 1s.\n    # \"1\" -> 1 (n=0, m=1)\n    # \"11\" -> 0 (n=0, m=2)\n    # \"111\" -> \"10\" -> 0 (n=0, m=3)\n    # \"1111\" -> \"100\" -> \"11\" -> 0 (n=0, m=4)\n    # \"11111\" -> \"1100\" -> \"10\" -> 0 (n=0, m=5)\n    # Here, for n=0, the final character is 1 if m=1, and 0 if m > 1.\n    # My logic \"final character is 1 iff n is odd\" would say for n=0 (even), final char is 0.\n    # This contradicts m=1 -> 1.\n    # So the property \"final character is 1 iff number of 0s is odd\" is NOT universally true.\n    # It seems to hold IF AND ONLY IF there is at least one 0.\n    # Or more precisely, if the string contains at least one 0 and at least one 1.\n\n    # Let's re-evaluate the operation: C = 1 if (S_k-1 == 0 AND S_k == 0), else C = 0.\n    # This is equivalent to C = NOT (S_k-1 OR S_k).\n    # Let f(S) be the result of the operations on string S.\n    # f(S_1 S_2 ... S_k) = f(S_1 ... S_k-2 C) where C = NOT (S_k-1 OR S_k).\n\n    # Consider the parity of the number of 0s (N_0) and 1s (N_1).\n    # Let's analyze the effect on the last character.\n    # S_k-1 S_k -> C\n    # 00 -> 1 (N_0 decreases by 2, N_1 increases by 1)\n    # 01 -> 0 (N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. Net: N_0 same, N_1 decreases by 2)\n    # 10 -> 0 (N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. Net: N_0 same, N_1 decreases by 2)\n    # 11 -> 0 (N_1 decreases by 2, N_0 increases by 1)\n\n    # This is not about the number of 0s. This is about the value of the final character.\n    # Let's track the final character.\n    # The final character is 1 if and only if the string is \"0\" or \"00...0\" (n zeros, m=0, n is odd).\n    # If the string contains at least one '1', then the final character is 0 if and only if m > 1.\n    # If m=1, and n > 0, then the string is \"0...010...0\".\n    # The final character is 0 if n is even.\n    # The final character is 1 if n is odd.\n\n    # This is the property from a known problem: The final character is 1 if and only if the number of 0s is odd,\n    # UNLESS the string consists of only 1s and has length > 1, in which case the result is 0.\n    # If the string consists of only 1s and has length 1, the result is 1.\n\n    # Let's break it down by cases for n, m, g.\n\n    # Case 1: n = 0 (string contains only 1s)\n    # If m = 1: string is \"1\". Result is 1.\n    #   If g = 1, ans = 1.\n    #   If g = 0, ans = 0.\n    # If m > 1: string is \"1...1\".\n    #   \"11\" -> 0\n    #   \"111\" -> \"10\" -> 0\n    #   \"1111\" -> \"100\" -> \"11\" -> 0\n    #   The result is always 0.\n    #   If g = 1, ans = 0.\n    #   If g = 0, ans = 1.\n\n    # My initial special handling for n=0 was correct.\n    # if n == 0:\n    #     if m == 1:\n    #         if g == 1: print(1)\n    #         else: print(0)\n    #     else: # m > 1\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     return\n\n    # Case 2: m = 0 (string contains only 0s)\n    # If n = 1: string is \"0\". Result is 0.\n    #   If g = 1, ans = 0.\n    #   If g = 0, ans = 1.\n    # If n > 1: string is \"0...0\".\n    #   \"00\" -> 1\n    #   \"000\" -> \"01\" -> 0\n    #   \"0000\" -> \"001\" -> \"10\" -> 0\n    #   \"00000\" -> \"0001\" -> \"010\" -> \"00\" -> 1\n    #   Result is 1 if n is odd, 0 if n is even.\n    #   If g = 1, ans = 1 if n is odd, 0 if n is even.\n    #   If g = 0, ans = 1 if n is even, 0 if n is odd.\n\n    # My initial special handling for m=0 was correct.\n    # if m == 0:\n    #     if n == 1:\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     else: # n > 1\n    #         if g == 0: print(1) if n % 2 == 0 else print(0)\n    #         else: print(1) if n % 2 == 1 else print(0)\n    #     return\n\n    # Let's combine this.\n    # n=0, m=1: g=1 -> 1, g=0 -> 0\n    # n=0, m>1: g=0 -> 1, g=1 -> 0\n    # n=1, m=0: g=0 -> 1, g=1 -> 0\n    # n>1, m=0: g=0 -> (n%2==0 ? 1 : 0), g=1 -> (n%2==1 ? 1 : 0)\n\n    # My code has:\n    # if n == 0:\n    #     if m == 1:\n    #         if g == 1: print(1)\n    #         else: print(0)\n    #     else: # m > 1\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     return\n    # This is correct.\n\n    # if m == 0:\n    #     if n == 1:\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     else: # n > 1\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     return\n    # This is incorrect for n > 1. It should be:\n    # if m == 0:\n    #     if n == 1:\n    #         if g == 0: print(1)\n    #         else: print(0)\n    #     else: # n > 1\n    #         if (n % 2 == 0 and g == 0) or (n % 2 == 1 and g == 1):\n    #             print(1)\n    #         else:\n    #             print(0)\n    #     return\n\n    # Let's update the m=0 case.\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n > 1\n            if (n % 2 == 0 and g == 0) or (n % 2 == 1 and g == 1):\n                print(1)\n            else:\n                print(0)\n        return\n\n    # Case 3: n > 0 and m > 0 (string contains both 0s and 1s)\n    # In this case, the property \"final character is 1 iff number of 0s is odd\" holds.\n    # So, if g = 0, we need n to be even.\n    # If g = 1, we need n to be odd.\n\n    # The logic in my code for n > 0 and m > 0:\n    # if g == 0:\n    #     if n % 2 == 0:\n    #         ans = nCr_mod_p(n + m, n)\n    #     else: # n is odd\n    #         ans = 0\n    # else: # g == 1\n    #     if n % 2 == 1:\n    #         ans = nCr_mod_p(n + m, n)\n    #     else: # n is even\n    #         ans = 0\n    # This logic is correct for n > 0 and m > 0.\n\n    # Let's re-run the full logic with corrected m=0 case.\n\n    # n, m, g = map(int, sys.stdin.readline().split()) # already read\n\n    # Handle edge cases n=0 or m=0\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else: # m > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n > 1\n            if (n % 2 == 0 and g == 0) or (n % 2 == 1 and g == 1):\n                print(1)\n            else:\n                print(0)\n        return\n\n    # General case: n > 0 and m > 0\n    # Precompute factorials and inverse factorials\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    ans = 0\n    if g == 0:\n        if n % 2 == 0:\n            ans = nCr_mod_p(n + m, n)\n        else:\n            ans = 0\n    else: # g == 1\n        if n % 2 == 1:\n            ans = nCr_mod_p(n + m, n)\n        else:\n            ans = 0\n\n    print(ans)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 5125,
        "thoughts_token_count": 0
    }
}