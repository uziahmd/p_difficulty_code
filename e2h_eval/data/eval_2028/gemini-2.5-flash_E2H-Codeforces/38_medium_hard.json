{
    "start": 1758294880.2326753,
    "end": 1758294951.1899054,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Here's how I'm thinking about this problem:**\n\nI'm tasked with solving a competitive programming challenge.  The core of the problem involves directed graphs and reachability.  I need to figure out two key values: the smallest possible number of nodes (`n`) needed to create a graph with a specific \"reachability\" property (defined by `p`), and then, out of *all* the graphs with that minimum `n` that satisfy the reachability rule, find the *maximum* number of unidirectional pairs of nodes.\n\nThe crux of the problem lies in understanding \"p-reachable graphs\" and \"unidirectional pairs.\" A p-reachable graph means there are exactly `p` ordered pairs of nodes (u, v) where `u` comes before `v` and are mutually reachable (meaning you can go from `u` to `v` and back). A unidirectional pair is (u, v) where you can go from u to v but not from v to u.\n\nMy strategy involves working with Strongly Connected Components (SCCs). If two nodes are mutually reachable, they *must* be in the same SCC. Therefore, a p-reachable graph consists of exactly `p` pairs within these SCCs, where u < v.  The size of an SCC determines how many mutually reachable pairs it contains (size * (size - 1) / 2). I can calculate the pairs per SCC.\n\nTo minimize `n` for a given `p`, I must maximize the size of each SCC to get the most pairs within. It's more efficient to have fewer, larger SCCs than many smaller ones. I need to find the largest SCC size that fits within `p`.  If I have pairs left over, I apply the same logic to the remainder (essentially a greedy approach). I construct a collection of s values that add up to n, where each s is the size of an SCC.\n\nOnce I have the minimum `n` and SCC sizes, the goal shifts to maximizing unidirectional pairs. To do this, I need to create a DAG (Directed Acyclic Graph) of SCCs. To get unidirectional pairs I want to create a long chain (or star) of SCCs where edges flow in one direction. I have to order the SCCs.\nThen, calculating the unidirectional pairs involves summing the product of SCC sizes across that chain.  To maximize this sum, I want to minimize the sum of the squares of SCC sizes, given the original SCC sizes from the greedy node strategy. The ordering doesn't actually matter, so I don't have to optimize the ordering.\n\nIn essence, I'm breaking down a complex graph problem into manageable parts: minimizing nodes via SCC sizes and a greedy algorithm, and then maximizing unidirectional pairs using an SCC chain. I'll need to use some careful calculations and iterations to reach my answers and test the edge cases.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a directed graph that has exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n2. Among all such graphs with the minimum number of nodes `n`, the maximum number of unidirectional pairs of nodes. An ordered pair `(u, v)` is unidirectional if `u != v`, there is a path from `u` to `v`, and there is no path from `v` to `u`.\n\nLet's break down the problem.\n\n**Understanding `p`-reachable graphs:**\nTwo nodes `u` and `v` are reachable from each other if and only if they belong to the same strongly connected component (SCC).\nIf an SCC has `s` nodes, any two distinct nodes `u, v` within this SCC are mutually reachable. The number of ordered pairs `(u, v)` with `u < v` within this SCC is `s * (s - 1) / 2`.\nIf a graph has `k` SCCs with sizes `s_1, s_2, ..., s_k`, the total number of nodes is `n = s_1 + s_2 + ... + s_k`.\nThe total number of `(u, v)` pairs with `u < v` that are mutually reachable is `P = sum_{i=1 to k} (s_i * (s_i - 1) / 2)`.\nWe are given `p`, and we need to find the minimum `n` such that `P = p` can be achieved.\n\n**Part 1: Minimum `n` for a given `p`**\n\nLet `f(s) = s * (s - 1) / 2` be the number of mutually reachable pairs `(u, v)` with `u < v` in an SCC of size `s`.\nWe want to minimize `n = sum s_i` subject to `sum f(s_i) = p`.\nThe function `f(s)` is convex and grows quadratically. This means that larger SCCs are more \"efficient\" at generating pairs per node. For example, `f(2)=1` (2 nodes, 1 pair), `f(3)=3` (3 nodes, 3 pairs), `f(4)=6` (4 nodes, 6 pairs).\nTo minimize `sum s_i` for a fixed `sum f(s_i)`, we should use the largest possible SCC sizes at each step. This leads to a greedy strategy:\n1. Initialize `min_n = 0` and an empty list `s_sizes` to store the sizes of the SCCs.\n2. While `p > 0`:\n   a. Find the largest integer `s >= 2` such that `f(s) = s * (s - 1) / 2 <= p`. This can be found by solving `s^2 - s - 2p <= 0` for `s`. The positive root of `s^2 - s - 2p = 0` is `(1 + sqrt(1 + 8p)) / 2`. So, `s = floor((1 + sqrt(1 + 8p)) / 2)`. Note that `s` must be at least 2 to produce any pairs. If `p=0`, `s` would be 0, but the loop terminates. If `p=1`, `s` will be 2.\n   b. Add `s` to `min_n`.\n   c. Add `s` to `s_sizes`.\n   d. Subtract `f(s)` from `p`.\n3. The final `min_n` is the minimum number of nodes.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nA pair `(u, v)` is unidirectional if `u != v`, `u` can reach `v`, but `v` cannot reach `u`. This implies `u` and `v` are in different SCCs. In the condensation graph (which is a Directed Acyclic Graph, DAG), `u`'s SCC must be an ancestor of `v`'s SCC.\nLet the graph have `k` SCCs with sizes `s_1, s_2, ..., s_k` (obtained from Part 1).\nTo maximize unidirectional pairs, we should arrange these SCCs in a linear chain in the condensation graph. For example, `C_1 -> C_2 -> ... -> C_k`. This means we add edges from nodes in `C_i` to nodes in `C_{i+1}` for all `i`.\nIn this configuration, any node `u` in `C_i` can reach any node `v` in `C_j` if `i < j`. Since `i < j`, there is no path from `C_j` to `C_i`. Thus, all `s_i * s_j` pairs `(u, v)` where `u` is in `C_i` and `v` is in `C_j` (for `i < j`) are unidirectional.\nThe total number of unidirectional pairs is `sum_{1 <= i < j <= k} (s_i * s_j)`.\n\nThis sum can be calculated efficiently:\nWe know `(sum s_i)^2 = sum s_i^2 + 2 * sum_{i<j} s_i * s_j`.\nLet `N = sum s_i = min_n`.\nThen `sum_{i<j} s_i * s_j = (N^2 - sum s_i^2) / 2`.\nSince the order of `s_i` in the sum does not matter, the specific arrangement of SCCs in the chain (e.g., `C_1 -> C_2 -> C_3` vs `C_1 -> C_3 -> C_2`) does not change the total count of unidirectional pairs.\n\n**Algorithm summary:**\n1. Read `p`.\n2. If `p == 0`, print `0 0` and exit.\n3. Initialize `min_n = 0` and `s_sizes = []`.\n4. While `p > 0`:\n   a. Calculate `s = int((1 + math.isqrt(1 + 8 * p)) / 2)`.\n   b. Add `s` to `min_n`.\n   c. Append `s` to `s_sizes`.\n   d. Subtract `s * (s - 1) // 2` from `p`.\n5. Calculate `sum_s_i_squared = sum(s * s for s in s_sizes)`.\n6. Calculate `max_unidirectional_pairs = (min_n * min_n - sum_s_i_squared) // 2`.\n7. Print `min_n` and `max_unidirectional_pairs`.\n\n**Example `p = 4`:**\n1. `p = 4`.\n2. `min_n = 0`, `s_sizes = []`.\n3. Loop 1:\n   a. `s = int((1 + math.isqrt(1 + 8 * 4)) / 2) = int((1 + math.isqrt(33)) / 2) = int((1 + 5) / 2) = 3`.\n   b. `min_n = 0 + 3 = 3`.\n   c. `s_sizes = [3]`.\n   d. `p = 4 - (3 * 2 // 2) = 4 - 3 = 1`.\n4. Loop 2:\n   a. `s = int((1 + math.isqrt(1 + 8 * 1)) / 2) = int((1 + math.isqrt(9)) / 2) = int((1 + 3) / 2) = 2`.\n   b. `min_n = 3 + 2 = 5`.\n   c. `s_sizes = [3, 2]`.\n   d. `p = 1 - (2 * 1 // 2) = 1 - 1 = 0`.\n5. Loop terminates. `min_n = 5`.\n6. `sum_s_i_squared = 3*3 + 2*2 = 9 + 4 = 13`.\n7. `max_unidirectional_pairs = (5*5 - 13) // 2 = (25 - 13) // 2 = 12 // 2 = 6`.\n8. Output: `5 6`.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    s_sizes = [] # To store the sizes of SCCs\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest s such that s * (s - 1) / 2 <= current_p\n        # This is equivalent to s^2 - s - 2*current_p <= 0\n        # The positive root of s^2 - s - 2*current_p = 0 is (1 + sqrt(1 + 8*current_p)) / 2\n        # We take the floor of this value to get the largest integer s.\n        \n        discriminant = 1 + 8 * current_p\n        s_float = (1 + math.isqrt(discriminant)) / 2\n        s = int(s_float)\n        \n        # In the edge case where current_p is 0, s_float would be 0.5, s=0.\n        # However, the loop condition `current_p > 0` prevents this.\n        # The smallest positive current_p is 1, which results in s=2.\n        # So s will always be >= 2 here.\n\n        pairs_from_s = s * (s - 1) // 2\n        \n        min_n += s\n        s_sizes.append(s)\n        current_p -= pairs_from_s\n\n    # Calculate maximum unidirectional pairs\n    # The total number of nodes is min_n.\n    # We have SCCs of sizes s_1, s_2, ..., s_k.\n    # To maximize unidirectional pairs, we arrange the SCCs in a linear chain: C_1 -> C_2 -> ... -> C_k.\n    # For any u in C_i and v in C_j with i < j, (u, v) is a unidirectional pair.\n    # The total count of such pairs is sum_{1 <= i < j <= k} (s_i * s_j).\n    # This sum can be derived from the identity:\n    # (sum s_i)^2 = sum (s_i^2) + 2 * sum_{i<j} (s_i * s_j)\n    # So, sum_{i<j} (s_i * s_j) = ((sum s_i)^2 - sum (s_i^2)) / 2\n\n    sum_s_i_squared = sum(s * s for s in s_sizes)\n    \n    max_unidirectional_pairs = (min_n * min_n - sum_s_i_squared) // 2\n\n    print(f\"{min_n} {max_unidirectional_pairs}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    s_sizes = [] # To store the sizes of SCCs\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest s such that s * (s - 1) / 2 <= current_p\n        # This is equivalent to s^2 - s - 2*current_p <= 0\n        # The positive root of s^2 - s - 2*current_p = 0 is (1 + sqrt(1 + 8*current_p)) / 2\n        # We take the floor of this value to get the largest integer s.\n        \n        discriminant = 1 + 8 * current_p\n        s_float = (1 + math.isqrt(discriminant)) / 2\n        s = int(s_float)\n        \n        # In the edge case where current_p is 0, s_float would be 0.5, s=0.\n        # However, the loop condition `current_p > 0` prevents this.\n        # The smallest positive current_p is 1, which results in s=2.\n        # So s will always be >= 2 here.\n\n        pairs_from_s = s * (s - 1) // 2\n        \n        min_n += s\n        s_sizes.append(s)\n        current_p -= pairs_from_s\n\n    # Calculate maximum unidirectional pairs\n    # The total number of nodes is min_n.\n    # We have SCCs of sizes s_1, s_2, ..., s_k.\n    # To maximize unidirectional pairs, we arrange the SCCs in a linear chain: C_1 -> C_2 -> ... -> C_k.\n    # For any u in C_i and v in C_j with i < j, (u, v) is a unidirectional pair.\n    # The total count of such pairs is sum_{1 <= i < j <= k} (s_i * s_j).\n    # This sum can be derived from the identity:\n    # (sum s_i)^2 = sum (s_i^2) + 2 * sum_{i<j} (s_i * s_j)\n    # So, sum_{i<j} (s_i * s_j) = ((sum s_i)^2 - sum (s_i^2)) / 2\n\n    sum_s_i_squared = sum(s * s for s in s_sizes)\n    \n    max_unidirectional_pairs = (min_n * min_n - sum_s_i_squared) // 2\n\n    print(f\"{min_n} {max_unidirectional_pairs}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 2609,
        "thoughts_token_count": 8192
    }
}