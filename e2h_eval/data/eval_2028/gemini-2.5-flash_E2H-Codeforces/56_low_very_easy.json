{
    "start": 1758284836.339021,
    "end": 1758284848.7670112,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:27 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Let's Tackle This Guard Duty Problem**\n\nOkay, so I'm looking at this \"Guard Duty (easy)\" problem and my initial thoughts are: it's a matching problem with a geometric constraint. First thing that jumps out is the need for a perfect matching - equal numbers of rebels and bases, or it's a straight \"No\".  The core of the problem seems to be preventing intersecting line segments.\n\nI remember this intersection detection is done through cross products. We need to check the orientations of point triplets to see if the segments cross. Thanks to the constraint \"no three points on the same line\", that simplifies things; no messy collinearity checks. Just a matter of seeing if the orientations relative to each segment's endpoints are different. That's good, less code complexity!\n\nSo, the game plan is: Read the input. Check if the rebel and base counts are equal.  If not, it is \"No\" immediately. Otherwise, I'll need to store the rebel and base coordinates as lists. Next, I can generate all possible matchings.  With such small constraints (R, B <= 10), generating all permutations is completely feasible.  This gives me the base assignment for each rebel. For each permutation (assignment), I can do a pairwise check on the assigned segments.  If I find an intersection, that permutation is invalid, move on.  If *any* permutation yields non-intersecting segments, then the answer is \"Yes\". That should do it!\n",
    "response": "```python\nimport sys\n\ndef orientation(p, q, r):\n    \"\"\"\n    Calculates the orientation of triplet (p, q, r).\n    Returns:\n    0 --> p, q and r are collinear\n    1 --> Clockwise\n    2 --> Counterclockwise\n    \"\"\"\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else 2  # Clockwise or Counterclockwise\n\ndef do_intersect(p1, q1, p2, q2):\n    \"\"\"\n    Checks if line segment p1q1 intersects line segment p2q2.\n    Assumes no three points are collinear (guaranteed by problem statement for distinct points).\n    \"\"\"\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments cross\n    if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0 and \\\n       o1 != o2 and o3 != o4:\n        return True\n\n    # Since problem guarantees \"no three points are on the same line\",\n    # we don't need to handle collinear cases (endpoints on segments).\n    # If any orientation is 0, it would imply 3 points are collinear,\n    # which is ruled out.\n    # Therefore, if we reach here, segments do not intersect properly.\n    return False\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n\n    rebels = []\n    for _ in range(R):\n        rebels.append(tuple(map(int, sys.stdin.readline().split())))\n\n    bases = []\n    for _ in range(B):\n        bases.append(tuple(map(int, sys.stdin.readline().split())))\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Use a list of indices for bases to generate permutations\n    base_indices = list(range(B))\n\n    # Iterate through all permutations of base assignments\n    import itertools\n    for p in itertools.permutations(base_indices):\n        # p is a tuple representing an assignment:\n        # rebels[i] is assigned to bases[p[i]]\n\n        # Check for intersections for this permutation\n        has_intersection = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                # Segment 1: rebels[i] to bases[p[i]]\n                # Segment 2: rebels[j] to bases[p[j]]\n                if do_intersect(rebels[i], bases[p[i]], rebels[j], bases[p[j]]):\n                    has_intersection = True\n                    break\n            if has_intersection:\n                break\n        \n        if not has_intersection:\n            print(\"Yes\")\n            return\n\n    # If no permutation worked\n    print(\"No\")\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef orientation(p, q, r):\n    \"\"\"\n    Calculates the orientation of triplet (p, q, r).\n    Returns:\n    0 --> p, q and r are collinear\n    1 --> Clockwise\n    2 --> Counterclockwise\n    \"\"\"\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else 2  # Clockwise or Counterclockwise\n\ndef do_intersect(p1, q1, p2, q2):\n    \"\"\"\n    Checks if line segment p1q1 intersects line segment p2q2.\n    Assumes no three points are collinear (guaranteed by problem statement for distinct points).\n    \"\"\"\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments cross\n    if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0 and \\\n       o1 != o2 and o3 != o4:\n        return True\n\n    # Since problem guarantees \"no three points are on the same line\",\n    # we don't need to handle collinear cases (endpoints on segments).\n    # If any orientation is 0, it would imply 3 points are collinear,\n    # which is ruled out.\n    # Therefore, if we reach here, segments do not intersect properly.\n    return False\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n\n    rebels = []\n    for _ in range(R):\n        rebels.append(tuple(map(int, sys.stdin.readline().split())))\n\n    bases = []\n    for _ in range(B):\n        bases.append(tuple(map(int, sys.stdin.readline().split())))\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Use a list of indices for bases to generate permutations\n    base_indices = list(range(B))\n\n    # Iterate through all permutations of base assignments\n    import itertools\n    for p in itertools.permutations(base_indices):\n        # p is a tuple representing an assignment:\n        # rebels[i] is assigned to bases[p[i]]\n\n        # Check for intersections for this permutation\n        has_intersection = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                # Segment 1: rebels[i] to bases[p[i]]\n                # Segment 2: rebels[j] to bases[p[j]]\n                if do_intersect(rebels[i], bases[p[i]], rebels[j], bases[p[j]]):\n                    has_intersection = True\n                    break\n            if has_intersection:\n                break\n        \n        if not has_intersection:\n            print(\"Yes\")\n            return\n\n    # If no permutation worked\n    print(\"No\")\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 512,
        "completion_token_count": 768,
        "thoughts_token_count": 759
    }
}