{
    "start": 1758284882.4844723,
    "end": 1758284946.8650146,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Analyzing the Minimum Edges to Form an Odd Cycle**\n\nOkay, I'm tackling this competitive programming problem. The core is finding the fewest edges, *t*, needed to make a simple cycle of odd length in a graph and then counting how many ways, *w*, I can do it.\n\nFirst, I know an odd cycle hinges on the graph *not* being bipartite. So, I need to check for that. Breadth-First Search (BFS) or Depth-First Search (DFS) with a color-based check is the way to go.  I'll start with an arbitrary vertex, color it, and then propagate colors to neighbors, ensuring opposite colors across an edge. If I hit a color conflict—same color on both ends of an edge—bam, odd cycle, and *t* could be zero! If *t* is zero, then *w* is just 1 (do nothing).\n\nLet's break down the possible values of *t*.\n\n*   **Case 1: *t* = 0:** The graph already has an odd cycle. I iterate through connected components, trying to 2-color each one. If any fails, *t* = 0, and *w* = 1 (no edge additions).\n\n*   **Case 2: *t* = 1:**  The graph is bipartite. I need to add one edge. To create an odd cycle, I have to add an edge between two vertices *within the same connected component* that have the *same color* in a 2-coloring. Let's look at the colors within the connected components. I have sets C0 and C1. If I add an edge between two nodes in the same color set (C0 or C1), I create an odd cycle. The number of such edges is  |C0| * (|C0| - 1) / 2 + |C1| * (|C1| - 1) / 2 summed over all connected components. I have to avoid parallel edges, but since the graph is initially simple, in a 2-colored graph, any nodes within the same color set cannot already be connected, so I don't need to worry about the parallel edges.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given graph to form a simple cycle of odd length, and `w` the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. Our strategy will be to check for bipartiteness and determine `t` based on this.\n\nWe can use Breadth-First Search (BFS) or Depth-First Search (DFS) to check if a graph is bipartite. During the traversal, we assign colors (e.g., 0 and 1) to vertices. If we find an edge connecting two vertices of the same color, the graph (or that connected component) is not bipartite, and thus contains an odd cycle.\n\nLet's analyze the possible values for `t`:\n\n**Case 1: `t = 0`**\nIf the given graph already contains an odd cycle, then `t=0`.\nTo check this, we iterate through all connected components of the graph. For each unvisited vertex, we start a BFS/DFS to traverse its connected component and attempt to 2-color it. If, at any point, we encounter an edge `(u, v)` where `u` and `v` have already been colored and `color(u) == color(v)`, then we have found an odd cycle. In this scenario, `t=0` and `w=1` (there's only one way: add no edges).\n\n**Case 2: `t = 1`**\nIf the graph is bipartite (i.e., no odd cycle was found in Case 1), we need to add at least one edge to form an odd cycle.\nTo form an odd cycle by adding a single edge, we must add an edge between two vertices `u` and `v` such that:\n1. `u` and `v` are in the same connected component.\n2. `u` and `v` have the same color in a 2-coloring of that component.\n3. `u` and `v` are not already connected by an edge. (This is guaranteed if they are in the same component and have the same color in a bipartite graph, as all existing edges connect vertices of different colors).\n\nFor each connected component, after successfully 2-coloring it, let `c0` be the count of vertices with color 0 and `c1` be the count of vertices with color 1.\nThe number of ways to add an edge between two vertices of color 0 is `c0 * (c0 - 1) / 2`.\nThe number of ways to add an edge between two vertices of color 1 is `c1 * (c1 - 1) / 2`.\nThe total number of ways `w` for `t=1` is the sum of these counts over all connected components.\nIf this sum is greater than 0, then `t=1` and `w` is this sum.\n\n**Case 3: `t = 2`**\nIf the graph is bipartite and `w` calculated in Case 2 is 0, it means that every connected component is either a single vertex or a path/cycle where `c0` or `c1` is 0 or 1. Specifically, `c0 * (c0 - 1) / 2 + c1 * (c1 - 1) / 2` will be 0 for all components. This implies that for every component, `c0 <= 1` and `c1 <= 1`. Such components are isolated vertices or single edges.\nIn this case, we cannot form an odd cycle by adding just one edge within an existing component. We must add edges between different connected components.\nTo form an odd cycle with 2 added edges, we can pick two distinct connected components, say `CompA` and `CompB`. Pick a vertex `u` from `CompA` and `v` from `CompB`. Add an edge `(u, v)`. Now `CompA` and `CompB` are merged. This new merged component is bipartite. We need to add one more edge. We can pick another vertex `x` from `CompA` and `y` from `CompB` and add an edge `(x, y)`. If `u` and `x` have the same color in `CompA`, and `v` and `y` have the same color in `CompB`, then adding `(u,v)` and `(x,y)` will form an even cycle. We want an odd cycle.\nConsider adding two edges `(u, v)` and `(x, y)` where `u` and `x` are in `CompA`, and `v` and `y` are in `CompB`.\nThe simplest way to form an odd cycle with two edges is to connect three distinct vertices `u, v, x` using two new edges, for example `(u, v)` and `(v, x)`. This forms a path `u-v-x`. If `u` and `x` are in different components, and `v` is in a third component, or if `u, v, x` are all in different components, this can form an odd cycle.\nHowever, a simpler construction for `t=2` is to pick two distinct connected components, say `Comp1` and `Comp2`. Pick any vertex `u` from `Comp1` and any vertex `v` from `Comp2`. Add an edge `(u, v)`. Now `Comp1` and `Comp2` are effectively merged into one larger bipartite component. We still need an odd cycle. We can add another edge `(u, x)` where `x` is in `Comp1` and `x` has the same color as `u` in `Comp1` (if such an `x` exists and `x != u`). But this would be `t=1` if `Comp1` had `c0 >= 2` or `c1 >= 2`.\nSince `w` for `t=1` is 0, all components have `c0 <= 1` and `c1 <= 1`. This means all components are isolated vertices or single edges.\nIf `t=1` is not possible, we must add edges between different components.\nIf there are at least 3 vertices in total (`n >= 3`), we can always pick three distinct vertices `v1, v2, v3` (possibly from different components) and add edges `(v1, v2)` and `(v2, v3)`. This forms a path `v1-v2-v3` of length 2, which is an odd cycle if `v1` and `v3` are the same vertex. But we cannot add loops. If `v1, v2, v3` are distinct, then `v1-v2-v3` is a path. To make an odd cycle, we need to add a third edge `(v3, v1)`. This would be `t=3`.\n\nLet's reconsider `t=2`.\nIf there are at least two connected components, say `CompA` and `CompB`.\nPick `u` from `CompA` and `v` from `CompB`. Add edge `(u, v)`. This merges `CompA` and `CompB`. The new merged graph is still bipartite.\nNow we need to add one more edge to make an odd cycle. This means adding an edge between two vertices of the same color in the merged component.\nLet `u` be in `CompA` (color `c_u`) and `v` in `CompB` (color `c_v`).\nAfter adding `(u,v)`, the colors in `CompB` relative to `CompA` are flipped if `c_u == c_v`, or kept the same if `c_u != c_v`.\nEssentially, we connect `u` and `v`. The path `u-v` has length 1.\nTo form an odd cycle, we need another path between `u` and `v` of even length.\nThis requires a path `u-...-v` of even length in `CompA` or `CompB`, which is impossible because they are bipartite.\nSo, we need a path `u-x-...-y-v` where `x` and `y` are in `CompA` and `CompB` respectively, and the path `x-...-y` is in the original graph. This doesn't seem right.\n\nA simpler way to achieve `t=2`:\nIf there are at least two connected components, say `C_i` and `C_j`.\nPick any vertex `u` from `C_i` and `v` from `C_j`. Add edge `(u, v)`.\nPick any vertex `x` from `C_i` and `y` from `C_j`. Add edge `(x, y)`.\nWe need to ensure `(u, v)` and `(x, y)` are distinct edges and `u, v, x, y` don't create parallel edges.\nIf `u=x` or `v=y`, this doesn't work. So `u != x` and `v != y`.\nThis requires `|C_i| >= 2` and `|C_j| >= 2`.\nThe cycle formed would be `u - v - y - x - u`. This is a 4-cycle (even).\nThis approach is only valid if we pick `u, v, x, y` such that `u, v, x, y` are distinct.\n\nThe most straightforward way to form an odd cycle with two added edges is:\nPick three distinct vertices `u, v, x`.\nAdd edges `(u, v)` and `(v, x)`. This creates a path `u-v-x`. This path has length 2, which is odd. This path itself is not a cycle.\nTo form an odd cycle, we need to add edges such that the total path length is odd.\nIf we have `N_comp` connected components, and each component has size 1 (isolated vertex) or 2 (single edge), this means `t=1` is not possible.\nIf `N_comp >= 3`, we can pick three distinct vertices `v1, v2, v3` from three distinct components. Add edges `(v1, v2)` and `(v2, v3)`. This forms a path of length 2. This path itself is not a cycle.\nIf `N_comp >= 2`, we can pick two distinct vertices `v1, v2` from two distinct components. Add edge `(v1, v2)`. This forms a new component. Now we need to add another edge to form an odd cycle. If the new component has `c0 >= 2` or `c1 >= 2`, we can add an edge within it. But this would mean `t=1` was possible if we had picked `v1` and `v2` from a component with `c0 >= 2` or `c1 >= 2`.\n\nLet's assume `t=1` is not possible. This means all connected components are either single vertices or single edges.\nLet `k1` be the number of components that are isolated vertices (size 1).\nLet `k2` be the number of components that are single edges (size 2).\nThe total number of vertices is `n = k1 + 2*k2`.\nIf `n < 3`, we cannot form any cycle of length > 1. This case is not explicitly handled by `t=2` or `t=3`.\nThe problem states \"cycle of an odd length, consisting of more than one vertex\". Minimum length is 3.\n\nIf `t=1` is impossible, then `t` must be at least 2.\nConsider `t=2`.\nWe need to add 2 edges.\nIf we add edges `(u,v)` and `(x,y)`.\nIf `u,v,x,y` are distinct, we form an even cycle `u-v-y-x-u`.\nIf `u=x`, we add `(u,v)` and `(u,y)`. This forms a path `v-u-y`. If `v` and `y` are in different components, and `u` is in a third component, we can add `(v,y)` to form `t=3`.\nIf `v` and `y` are in the same component, and `u` in another, this is `t=1` if `v` and `y` have same color.\n\nThe simplest way to form an odd cycle with 2 added edges is to pick three distinct vertices `u, v, x` and add edges `(u, v)` and `(v, x)`. This forms a path `u-v-x` of length 2. This path is not a cycle.\nThe number of ways to pick 3 distinct vertices `u, v, x` is `n * (n-1) * (n-2)`. For each such choice, there are 3 ways to assign `v` as the middle vertex: `u-v-x`, `v-u-x`, `u-x-v`. So `n * (n-1) * (n-2) / 3` ways to pick 3 vertices and specify the middle one.\nFor each such path `u-v-x`, the length is 2, which is odd. This path itself doesn't form a cycle.\nThis interpretation of \"form a simple cycle of an odd length\" means the *new graph* must contain an odd cycle.\nIf we add edges `(u,v)` and `(v,x)`, the graph now contains path `u-v-x`. If `u` and `x` were already connected by an edge, we'd have a 3-cycle. But we can't add parallel edges.\nIf `u` and `x` are not connected, the graph still doesn't have an odd cycle unless `u` and `x` happen to be in the same component and have the same color. But we are in the `t=2` case, which means `t=1` was impossible, so no component has two same-colored vertices.\nTherefore, adding `(u,v)` and `(v,x)` where `u,v,x` are distinct and not already connected doesn't create an odd cycle.\n\nThe only way to get an odd cycle with `t=2` is if we connect two components, say `C_i` and `C_j`, and then add an edge within the *newly formed* component that creates an odd cycle.\nIf we add `(u,v)` where `u \\in C_i, v \\in C_j`. The new component `C_i \\cup C_j \\cup \\{(u,v)\\}` is bipartite.\nWe need to add a second edge `(x,y)` within this new component such that `x` and `y` have the same color.\nThis means `x` and `y` must be in `C_i` and have the same color in `C_i`, or `x` and `y` must be in `C_j` and have the same color in `C_j`.\nBut this contradicts `t=1` being impossible.\nSo `t=2` is only possible if there are at least two components AND at least one of them has at least 2 vertices.\nNo, that's not right. `t=1` is impossible means *all* components have `c0 <= 1` and `c1 <= 1`.\nSo if `t=1` is impossible, then `t=2` is also impossible in this manner.\n\nLet's re-evaluate the `t=2` scenario.\nIf `t=1` is not possible, it means all connected components are either isolated vertices (size 1) or single edges (size 2).\nIf `n < 3`, we cannot form any cycle of length > 1. In this case, `t=3` is impossible, `t=2` is impossible.\nFor `n=1` or `n=2`, an odd cycle of length > 1 is impossible. The problem states \"cycle of an odd length, consisting of more than one vertex\". The minimum length of an odd cycle is 3. So `n` must be at least 3.\nIf `n < 3`, we should output `t=3` and `w=1` for `n=3` (which is the case for example 3).\n\nIf `t=1` is not possible, and `n >= 3`:\nWe need to add 2 edges.\nPick 3 distinct vertices `u, v, x`. Add edges `(u, v)` and `(v, x)`.\nThe path `u-v-x` has length 2 (odd). This makes the new graph contain an odd path.\nSince `t=1` was impossible, all components are of size 1 or 2.\nIf `u, v, x` are distinct, then `(u,v)` and `(v,x)` are valid new edges.\nThe number of ways to pick 3 distinct vertices `u, v, x` is `n * (n-1) * (n-2)`.\nFor each set of 3 vertices `{u, v, x}`, there are 3 ways to choose the \"middle\" vertex `v` (e.g., `u-v-x`, `v-u-x`, `u-x-v`).\nSo, `n * (n-1) * (n-2) / 3` ways to choose 3 vertices and specify the two edges forming a path of length 2.\nThis forms a path `u-v-x`. This path has length 2. The graph contains an odd path.\nDoes this imply the graph contains an odd cycle? Not necessarily.\nA graph has an odd cycle iff it is not bipartite.\nIf we have a graph `G = (V, E)` and add two edges `e1, e2` to get `G' = (V, E \\cup \\{e1, e2\\})`.\nWe want `G'` to contain an odd cycle.\nIf `t=1` is impossible, all components are bipartite and `c0 <= 1`, `c1 <= 1` for all components.\nThis means all components are isolated vertices or single edges.\nIf we add edges `(u, v)` and `(v, x)` where `u, v, x` are distinct, we have a path `u-v-x`.\nThe graph `G'` is still bipartite.\nExample: `n=4`, no edges. `t=3`.\nAdd `(1,2)`, `(2,3)`, `(3,1)`. This is a 3-cycle. `t=3`.\nWhat if we add `(1,2)` and `(3,4)`? This is `t=2`. The graph is `1-2, 3-4`. It's bipartite.\nWhat if `n=3`, no edges. `t=3`. Add `(1,2), (2,3), (3,1)`. `w=1`.\nThis implies that if `n=3` and `m=0`, `t=3`.\n\nIt seems my understanding of `t=2` is flawed.\nThe only way `t=2` is possible is if we have two connected components `C_i` and `C_j` such that `C_i` has `c0_i, c1_i` vertices and `C_j` has `c0_j, c1_j` vertices.\nWe connect `u \\in C_i` and `v \\in C_j` with an edge `(u, v)`.\nThen we need to add another edge `(x, y)` to form an odd cycle.\nThe new component `C_i \\cup C_j \\cup \\{(u,v)\\}` is bipartite.\nTo make it non-bipartite, we need to add an edge `(x, y)` such that `x` and `y` have the same color in this new component.\nThis means `x, y` must be in `C_i` and have same color in `C_i`, or `x, y` must be in `C_j` and have same color in `C_j`.\nThis again implies `t=1` was possible, which is a contradiction.\n\nSo, if `t=1` is not possible, then `t` must be 3.\nThis means we need to add 3 edges to form a 3-cycle.\nA 3-cycle `u-v-x-u` requires 3 vertices.\nIf `n < 3`, it's impossible. But `n >= 3` for a 3-cycle.\nIf `n=3`, `m=0`, we need to add `(1,2), (2,3), (3,1)`. `t=3, w=1`.\nIf `n=4`, `m=0`, we can add `(1,2), (2,3), (3,1)`. `t=3, w=4` (choose 3 vertices out of 4).\n\nLet's summarize the logic:\n\n1.  **Check for `t=0`**:\n    Perform a 2-coloring (BFS/DFS) on each connected component.\n    Maintain `visited` array and `color` array.\n    For each unvisited vertex `s`:\n        Start BFS from `s`, assign `color[s] = 0`.\n        `q = [s]`\n        While `q` is not empty:\n            `u = q.pop(0)`\n            For each neighbor `v` of `u`:\n                If `color[v]` is not assigned:\n                    `color[v] = 1 - color[u]`\n                    `q.append(v)`\n                Else if `color[v] == color[u]`:\n                    An odd cycle exists. Set `t=0, w=1` and terminate.\n\n2.  **If `t=0` not found, check for `t=1`**:\n    The graph is bipartite. We have successfully 2-colored all components.\n    For each connected component, count `c0` (vertices with color 0) and `c1` (vertices with color 1).\n    `ways_t1 = 0`\n    For each component `i`:\n        `ways_t1 += c0_i * (c0_i - 1) // 2`\n        `ways_t1 += c1_i * (c1_i - 1) // 2`\n    If `ways_t1 > 0`:\n        Set `t=1, w=ways_t1` and terminate.\n\n3.  **If `t=1` not found, `t` must be 2 or 3**:\n    If `t=1` is impossible, it means for all components, `c0_i <= 1` and `c1_i <= 1`.\n    This implies all components are either isolated vertices (size 1) or single edges (size 2).\n    Let `num_components` be the total number of connected components.\n    Let `num_isolated_vertices` be the count of components of size 1.\n    Let `num_single_edges` be the count of components of size 2.\n    `num_components = num_isolated_vertices + num_single_edges`.\n\n    If `num_components >= 2`:\n        We can pick two vertices `u, v` from different components and add an edge `(u, v)`.\n        This merges two components into one. The new graph is still bipartite.\n        We need to add one more edge.\n        If we pick `u` from `C_i` and `v` from `C_j`, and add `(u,v)`.\n        Now we have a larger component. We need to add an edge `(x,y)` within this new component such that `x` and `y` have the same color.\n        This would require `x,y` to be in `C_i` and have the same color in `C_i`, or `x,y` in `C_j` and have the same color in `C_j`.\n        But this contradicts `t=1` being impossible. So, this path to `t=2` is not viable.\n\n    The only remaining option for `t=2` is to add two edges `(u,v)` and `(v,x)` such that `u,v,x` are distinct vertices, and `u,x` are in different components.\n    This creates a path of length 2 (`u-v-x`). This path is an odd path.\n    The graph `G'` containing this path is still bipartite.\n    Example: `1-2`, `3-4`. Add `(2,3)`. Graph is `1-2-3-4`. Bipartite.\n    Add `(1,3)`. Graph is `1-2`, `3-4`, `(1,3)`. Bipartite.\n\n    The example `4 4\\n1 2\\n1 3\\n4 2\\n4 3` gives `t=1, w=2`.\n    Components: `1-2, 1-3, 4-2, 4-3`. This forms a 4-cycle `1-2-4-3-1`.\n    Coloring: `color[1]=0`. `color[2]=1`, `color[3]=1`. `color[4]=0`.\n    Edge `(1,2)`: `0-1`. Edge `(1,3)`: `0-1`. Edge `(4,2)`: `0-1`. Edge `(4,3)`: `0-1`.\n    This graph is bipartite. `C0={1,4}, C1={2,3}`.\n    `c0=2, c1=2`.\n    `ways_t1 = (2*(2-1)//2) + (2*(2-1)//2) = 1 + 1 = 2`.\n    So `t=1, w=2`. This matches the example.\n\n    The example `3 0` gives `t=3, w=1`.\n    `n=3, m=0`. Graph has 3 isolated vertices: `1, 2, 3`.\n    `t=0` check: No edges, so no odd cycles. Graph is bipartite.\n    `t=1` check: Components are `{1}, {2}, {3}`.\n    For `{1}`: `c0=1, c1=0`. Ways = `1*(0)/2 + 0*( -1)/2 = 0`.\n    Total `ways_t1 = 0`.\n    So `t=1` is not possible.\n    This leads to `t=3`. We need to add 3 edges to form a 3-cycle.\n    There is only one way to pick 3 vertices out of 3, which are `1, 2, 3`.\n    The edges are `(1,2), (2,3), (3,1)`. So `w=1`. This matches the example.\n\n    Therefore, the logic seems to be:\n    - If odd cycle exists: `t=0, w=1`.\n    - Else if `t=1` is possible (i.e., some component has `c0 >= 2` or `c1 >= 2`): `t=1, w=ways_t1`.\n    - Else (`t=1` is impossible, all components are isolated vertices or single edges): `t=3`.\n        In this case, we need to form a 3-cycle. This requires 3 distinct vertices.\n        The number of ways to choose 3 distinct vertices out of `n` is `n * (n-1) * (n-2) / 6`.\n        For each set of 3 vertices, there's only 1 way to form a 3-cycle (e.g., for `{1,2,3}`, edges `(1,2), (2,3), (3,1)`).\n        So `w = n * (n-1) * (n-2) / 6`.\n        This is valid only if `n >= 3`. If `n < 3`, then a 3-cycle is impossible. But the problem constraints are `n >= 1`.\n        If `n < 3`, `n*(n-1)*(n-2)` would be 0, so `w=0`. However, the problem guarantees \"cycle of an odd length, consisting of more than one vertex\". The smallest odd cycle is of length 3. So if `n < 3`, it's impossible. But examples show `n=3` is possible.\n        The problem implies `n >= 3` for this `t=3` case.\n        If `n=1` or `n=2`, it's impossible to form an odd cycle of length > 1. The problem implies such a cycle is always possible to form. This means `n` effectively must be at least 3 if `t=3`.\n\n    Let's confirm the `t=2` case. `t=2` is never the minimum.\n    If `t=0`, we are done.\n    If `t=0` not possible, graph is bipartite.\n    If `t=1` is possible, we have ways `W1`.\n    If `t=1` is not possible, it means all components are isolated vertices or single edges.\n    In this case, to form an odd cycle, we need to add at least 3 edges to form a `C_3`.\n    Any 2 edges we add will result in a bipartite graph.\n    For example, if we add `(u,v)` and `(x,y)`.\n    If `u,v,x,y` are distinct, we get a graph like `u-v, x-y`. Still bipartite.\n    If `u=x`, we get `v-u-y`. Still bipartite.\n    So, if `t=1` is not possible, `t` must be 3.\n\nFinal logic:\n1.  Initialize `t = -1`, `w = -1`.\n2.  Use BFS/DFS to 2-color the graph components.\n    - `visited`: boolean array to track visited vertices.\n    - `color`: integer array to store color (0 or 1).\n    - `component_counts`: list of `(c0, c1)` tuples for each bipartite component found.\n    - `has_odd_cycle`: boolean flag, initially `false`.\n    Iterate `i` from 1 to `n`:\n        If `i` not `visited`:\n            Start BFS from `i`.\n            `current_c0 = 0`, `current_c1 = 0`.\n            `q = deque([(i, 0)])`\n            `visited[i] = True`\n            `color[i] = 0`\n            `current_c0 = 1`\n            While `q` not empty:\n                `u, u_color = q.popleft()`\n                For each neighbor `v` of `u`:\n                    If `v` not `visited`:\n                        `visited[v] = True`\n                        `color[v] = 1 - u_color`\n                        If `color[v] == 0`: `current_c0 += 1`\n                        Else: `current_c1 += 1`\n                        `q.append((v, color[v]))`\n                    Else if `color[v] == u_color`:\n                        `has_odd_cycle = True`\n                        Break (from inner for loop)\n                If `has_odd_cycle`: Break (from while loop)\n            If `has_odd_cycle`: Break (from outer for loop)\n            Else: `component_counts.append((current_c0, current_c1))`\n\n3.  **Determine `t` and `w`**:\n    If `has_odd_cycle`:\n        `t = 0`\n        `w = 1`\n    Else:\n        `ways_t1 = 0`\n        For `(c0, c1)` in `component_counts`:\n            `ways_t1 += c0 * (c0 - 1) // 2`\n            `ways_t1 += c1 * (c1 - 1) // 2`\n        If `ways_t1 > 0`:\n            `t = 1`\n            `w = ways_t1`\n        Else:\n            `t = 3`\n            `w = n * (n - 1) * (n - 2) // 6`\n            If `n < 3`: `w` should be 0. But problem implies `n >= 3` in this scenario.\n            The minimum cycle length is 3. If `n < 3`, `w` should be 0.\n            But `n * (n-1) * (n-2) // 6` naturally handles `n < 3` by resulting in 0.\n\nThis logic seems robust and covers all cases including the examples.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    # color[i] = 0 or 1, -1 if not colored\n    color = [-1] * (n + 1)\n\n    has_odd_cycle = False\n    component_data = [] # Stores (c0, c1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_c0 = 0\n            current_c1 = 0\n            \n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0 # Start with color 0\n            current_c0 += 1\n            \n            is_bipartite_component = True\n            \n            component_q_idx = 0\n            current_component_nodes = [i]\n            \n            while component_q_idx < len(current_component_nodes):\n                u = current_component_nodes[component_q_idx]\n                u_color = color[u]\n                component_q_idx += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - u_color\n                        if color[v] == 0:\n                            current_c0 += 1\n                        else:\n                            current_c1 += 1\n                        current_component_nodes.append(v)\n                    elif color[v] == u_color:\n                        is_bipartite_component = False\n                        break\n                \n                if not is_bipartite_component:\n                    break\n            \n            if not is_bipartite_component:\n                has_odd_cycle = True\n                break\n            else:\n                component_data.append((current_c0, current_c1))\n    \n    if has_odd_cycle:\n        t = 0\n        w = 1\n    else:\n        # Graph is bipartite\n        ways_t1 = 0\n        for c0, c1 in component_data:\n            ways_t1 += c0 * (c0 - 1) // 2\n            ways_t1 += c1 * (c1 - 1) // 2\n        \n        if ways_t1 > 0:\n            t = 1\n            w = ways_t1\n        else:\n            # All components are isolated vertices or single edges\n            # Cannot form an odd cycle with 1 edge.\n            # Minimum edges to add is 3 (to form a C3).\n            t = 3\n            # Number of ways to choose 3 distinct vertices out of n\n            if n < 3:\n                w = 0 # Cannot form a 3-cycle with less than 3 vertices\n            else:\n                w = n * (n - 1) * (n - 2) // 6\n\n    print(t, w)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    # color[i] = 0 or 1, -1 if not colored\n    color = [-1] * (n + 1)\n\n    has_odd_cycle = False\n    component_data = [] # Stores (c0, c1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_c0 = 0\n            current_c1 = 0\n            \n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0 # Start with color 0\n            current_c0 += 1\n            \n            is_bipartite_component = True\n            \n            component_q_idx = 0\n            current_component_nodes = [i]\n            \n            while component_q_idx < len(current_component_nodes):\n                u = current_component_nodes[component_q_idx]\n                u_color = color[u]\n                component_q_idx += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - u_color\n                        if color[v] == 0:\n                            current_c0 += 1\n                        else:\n                            current_c1 += 1\n                        current_component_nodes.append(v)\n                    elif color[v] == u_color:\n                        is_bipartite_component = False\n                        break\n                \n                if not is_bipartite_component:\n                    break\n            \n            if not is_bipartite_component:\n                has_odd_cycle = True\n                break\n            else:\n                component_data.append((current_c0, current_c1))\n    \n    if has_odd_cycle:\n        t = 0\n        w = 1\n    else:\n        # Graph is bipartite\n        ways_t1 = 0\n        for c0, c1 in component_data:\n            ways_t1 += c0 * (c0 - 1) // 2\n            ways_t1 += c1 * (c1 - 1) // 2\n        \n        if ways_t1 > 0:\n            t = 1\n            w = ways_t1\n        else:\n            # All components are isolated vertices or single edges\n            # Cannot form an odd cycle with 1 edge.\n            # Minimum edges to add is 3 (to form a C3).\n            t = 3\n            # Number of ways to choose 3 distinct vertices out of n\n            if n < 3:\n                w = 0 # Cannot form a 3-cycle with less than 3 vertices\n            else:\n                w = n * (n - 1) * (n - 2) // 6\n\n    print(t, w)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 8295,
        "thoughts_token_count": 771
    }
}