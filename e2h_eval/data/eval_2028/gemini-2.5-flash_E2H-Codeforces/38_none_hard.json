{
    "start": 1758293705.8144631,
    "end": 1758293724.9975555,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional_for_min_nodes = -1\n\n    # Iterate through possible numbers of SCCs (k)\n    # The number of nodes in an SCC must be at least 1.\n    # The sum of sizes of SCCs must be at least 1.\n    # The maximum number of nodes is bounded by 2 * 10^5 (if all p pairs are in one SCC of size sqrt(2p))\n    # Or if p = 2 * 10^5, then a single SCC of size N, N(N-1)/2 = p => N^2 approx 2p => N approx sqrt(4 * 10^5) approx 632\n    # So N can be up to around 632 for a single SCC.\n    # If p is distributed among many SCCs, the total number of nodes could be higher.\n    # The maximum value of N for p=2e5 is around 632.\n    # A looser upper bound for N is p + 1 (if p pairs are formed by 1-node SCCs and a single SCC of size 2).\n    # N cannot exceed p+1, as p pairs mean at least 2 nodes.\n    # If p = 2e5, N = 632 for one SCC.\n    # If we have k SCCs, and s_i nodes in each SCC, total nodes N = sum(s_i).\n    # Total reachable pairs (u,v) with u<v is sum(s_i * (s_i-1) / 2) within SCCs.\n    # This sum must be <= p.\n    # To minimize N, we want to maximize s_i * (s_i-1) / 2 for a given s_i.\n    # This means we should use as few SCCs as possible, and make them as large as possible.\n    # The largest possible s_i is such that s_i * (s_i-1) / 2 <= p.\n    # Let's find the maximum s_max such that s_max * (s_max - 1) / 2 <= p.\n    # s_max^2 - s_max - 2p <= 0. Roots are (1 +/- sqrt(1 + 8p)) / 2.\n    # So s_max <= (1 + sqrt(1 + 8p)) / 2.\n    # For p = 2e5, s_max approx (1 + sqrt(1 + 1.6e6)) / 2 approx (1 + 1265) / 2 approx 633.\n    # So N can go up to around 633 for a single SCC.\n    # If we have multiple SCCs, N could be higher.\n    # For example, if p = 3. One SCC of size 3 gives 3 pairs. N=3.\n    # If p = 3, and we have two SCCs.\n    # s1(s1-1)/2 + s2(s2-1)/2 = 3.\n    # (s1,s2) can be (3,0) which is one SCC.\n    # (2,2) gives 1+1=2 pairs. Not 3.\n    # (4,0) gives 6 pairs.\n    # The minimum number of nodes can be found by trying to form p pairs using as few nodes as possible.\n    # This means making SCCs as large as possible.\n    # The number of pairs in an SCC of size s is s * (s - 1) / 2.\n    # Let's try to find k SCCs with sizes s_1, s_2, ..., s_k such that\n    # sum(s_i * (s_i - 1) / 2) = p.\n    # And sum(s_i) is minimized.\n    # To minimize sum(s_i) for a fixed sum of s_i * (s_i - 1) / 2, we want to make s_i as large as possible.\n    # This is a greedy approach. Start with the largest possible SCC.\n    # Let current_p = p.\n    # current_nodes = 0.\n    # while current_p > 0:\n    #   Find max s such that s * (s-1) / 2 <= current_p.\n    #   Add s to current_nodes.\n    #   Subtract s * (s-1) / 2 from current_p.\n    # This greedy strategy works because the function f(s) = s*(s-1)/2 grows quadratically, while s grows linearly.\n    # So for a given number of pairs, using larger SCCs is more \"node-efficient\".\n\n    current_p_remaining = p\n    current_nodes_sum = 0\n    scc_sizes = []\n\n    while current_p_remaining > 0:\n        # Find largest s such that s*(s-1)/2 <= current_p_remaining\n        s = 0\n        low = 1\n        high = int((1 + (1 + 8 * current_p_remaining)**0.5) / 2) + 2 # Upper bound for s\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * (mid - 1) // 2 <= current_p_remaining:\n                s = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        if s == 0: # This should not happen if current_p_remaining > 0\n            break\n\n        scc_sizes.append(s)\n        current_nodes_sum += s\n        current_p_remaining -= s * (s - 1) // 2\n\n    min_nodes = current_nodes_sum\n\n    # Now calculate max unidirectional pairs for this min_nodes.\n    # The number of unidirectional pairs is maximized when we connect all SCCs into a single path.\n    # If there are k SCCs with sizes s_1, s_2, ..., s_k.\n    # The number of unidirectional pairs is sum_{1 <= i < j <= k} (s_i * s_j).\n    # This is (sum(s_i))^2 - sum(s_i^2) / 2.\n    # More simply, it's N_total * (N_total - 1) / 2 - sum(s_i * (s_i - 1) / 2) - p_within_sccs.\n    # No, it's (N_total * (N_total - 1) / 2) - p_reachable_u_lt_v - p_reachable_v_lt_u.\n    # The number of pairs (u,v) with u != v that are reachable from each other is 2 * p.\n    # The total number of ordered pairs (u,v) with u != v is N * (N - 1).\n    # Total ordered pairs (u,v) such that u != v and u,v are in the same SCC is sum(s_i * (s_i - 1)).\n    # This is 2 * sum(s_i * (s_i - 1) / 2) = 2 * p_within_sccs.\n    # If we arrange k SCCs s_1, s_2, ..., s_k in a path (e.g., s_1 -> s_2 -> ... -> s_k),\n    # then for any u in s_i and v in s_j with i < j, there is a path from u to v.\n    # There is no path from v to u. These are unidirectional pairs.\n    # The number of such pairs is sum_{1 <= i < j <= k} (s_i * s_j).\n    # This is exactly ( (sum s_i)^2 - sum(s_i^2) ) / 2.\n    # Let S = sum(s_i) = min_nodes.\n    # Max unidirectional pairs = (S^2 - sum(s_i^2)) / 2.\n    \n    sum_s_squared = sum(s * s for s in scc_sizes)\n    max_unidirectional_for_min_nodes = (min_nodes * min_nodes - sum_s_squared) // 2\n\n    print(f\"{min_nodes} {max_unidirectional_for_min_nodes}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional_for_min_nodes = -1\n\n    # Iterate through possible numbers of SCCs (k)\n    # The number of nodes in an SCC must be at least 1.\n    # The sum of sizes of SCCs must be at least 1.\n    # The maximum number of nodes is bounded by 2 * 10^5 (if all p pairs are in one SCC of size sqrt(2p))\n    # Or if p = 2 * 10^5, then a single SCC of size N, N(N-1)/2 = p => N^2 approx 2p => N approx sqrt(4 * 10^5) approx 632\n    # So N can be up to around 632 for a single SCC.\n    # If p is distributed among many SCCs, the total number of nodes could be higher.\n    # The maximum value of N for p=2e5 is around 632.\n    # A looser upper bound for N is p + 1 (if p pairs are formed by 1-node SCCs and a single SCC of size 2).\n    # N cannot exceed p+1, as p pairs mean at least 2 nodes.\n    # If p = 2e5, N = 632 for one SCC.\n    # If we have k SCCs, and s_i nodes in each SCC, total nodes N = sum(s_i).\n    # Total reachable pairs (u,v) with u<v is sum(s_i * (s_i-1) / 2) within SCCs.\n    # This sum must be <= p.\n    # To minimize N, we want to maximize s_i * (s_i-1) / 2 for a given s_i.\n    # This means we should use as few SCCs as possible, and make them as large as possible.\n    # The largest possible s_i is such that s_i * (s_i-1) / 2 <= p.\n    # Let's find the maximum s_max such that s_max * (s_max - 1) / 2 <= p.\n    # s_max^2 - s_max - 2p <= 0. Roots are (1 +/- sqrt(1 + 8p)) / 2.\n    # So s_max <= (1 + sqrt(1 + 8p)) / 2.\n    # For p = 2e5, s_max approx (1 + sqrt(1 + 1.6e6)) / 2 approx (1 + 1265) / 2 approx 633.\n    # So N can go up to around 633 for a single SCC.\n    # If we have multiple SCCs, N could be higher.\n    # For example, if p = 3. One SCC of size 3 gives 3 pairs. N=3.\n    # If p = 3, and we have two SCCs.\n    # s1(s1-1)/2 + s2(s2-1)/2 = 3.\n    # (s1,s2) can be (3,0) which is one SCC.\n    # (2,2) gives 1+1=2 pairs. Not 3.\n    # (4,0) gives 6 pairs.\n    # The minimum number of nodes can be found by trying to form p pairs using as few nodes as possible.\n    # This means making SCCs as large as possible.\n    # The number of pairs in an SCC of size s is s * (s - 1) / 2.\n    # Let's try to find k SCCs with sizes s_1, s_2, ..., s_k such that\n    # sum(s_i * (s_i - 1) / 2) = p.\n    # And sum(s_i) is minimized.\n    # To minimize sum(s_i) for a fixed sum of s_i * (s_i - 1) / 2, we want to make s_i as large as possible.\n    # This is a greedy approach. Start with the largest possible SCC.\n    # Let current_p = p.\n    # current_nodes = 0.\n    # while current_p > 0:\n    #   Find max s such that s * (s-1) / 2 <= current_p.\n    #   Add s to current_nodes.\n    #   Subtract s * (s-1) / 2 from current_p.\n    # This greedy strategy works because the function f(s) = s*(s-1)/2 grows quadratically, while s grows linearly.\n    # So for a given number of pairs, using larger SCCs is more \"node-efficient\".\n\n    current_p_remaining = p\n    current_nodes_sum = 0\n    scc_sizes = []\n\n    while current_p_remaining > 0:\n        # Find largest s such that s*(s-1)/2 <= current_p_remaining\n        s = 0\n        low = 1\n        high = int((1 + (1 + 8 * current_p_remaining)**0.5) / 2) + 2 # Upper bound for s\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * (mid - 1) // 2 <= current_p_remaining:\n                s = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        if s == 0: # This should not happen if current_p_remaining > 0\n            break\n\n        scc_sizes.append(s)\n        current_nodes_sum += s\n        current_p_remaining -= s * (s - 1) // 2\n\n    min_nodes = current_nodes_sum\n\n    # Now calculate max unidirectional pairs for this min_nodes.\n    # The number of unidirectional pairs is maximized when we connect all SCCs into a single path.\n    # If there are k SCCs with sizes s_1, s_2, ..., s_k.\n    # The number of unidirectional pairs is sum_{1 <= i < j <= k} (s_i * s_j).\n    # This is (sum(s_i))^2 - sum(s_i^2) / 2.\n    # More simply, it's N_total * (N_total - 1) / 2 - sum(s_i * (s_i - 1) / 2) - p_within_sccs.\n    # No, it's (N_total * (N_total - 1) / 2) - p_reachable_u_lt_v - p_reachable_v_lt_u.\n    # The number of pairs (u,v) with u != v that are reachable from each other is 2 * p.\n    # The total number of ordered pairs (u,v) with u != v is N * (N - 1).\n    # Total ordered pairs (u,v) such that u != v and u,v are in the same SCC is sum(s_i * (s_i - 1)).\n    # This is 2 * sum(s_i * (s_i - 1) / 2) = 2 * p_within_sccs.\n    # If we arrange k SCCs s_1, s_2, ..., s_k in a path (e.g., s_1 -> s_2 -> ... -> s_k),\n    # then for any u in s_i and v in s_j with i < j, there is a path from u to v.\n    # There is no path from v to u. These are unidirectional pairs.\n    # The number of such pairs is sum_{1 <= i < j <= k} (s_i * s_j).\n    # This is exactly ( (sum s_i)^2 - sum(s_i^2) ) / 2.\n    # Let S = sum(s_i) = min_nodes.\n    # Max unidirectional pairs = (S^2 - sum(s_i^2)) / 2.\n    \n    sum_s_squared = sum(s * s for s in scc_sizes)\n    max_unidirectional_for_min_nodes = (min_nodes * min_nodes - sum_s_squared) // 2\n\n    print(f\"{min_nodes} {max_unidirectional_for_min_nodes}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 1987,
        "thoughts_token_count": 0
    }
}