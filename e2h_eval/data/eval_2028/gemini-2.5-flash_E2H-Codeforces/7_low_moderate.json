{
    "start": 1758009319.6755326,
    "end": 1758009365.9522033,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**My Approach to the Rudolf and Snowflakes Problem**\n\nOkay, so I'm tackling this \"Rudolf and Snowflakes (hard version)\" problem, and I need a Python script to get the job done. Let me break down the problem description and figure out the structure of these snowflakes.\n\nInitially, we have a central vertex. That's our base. Then, we connect this center vertex to `k` new vertices, where `k` is greater than 1. So, after the first step, we have a total of `1 + k` vertices.  These new vertices are each connected only to the center.\n\nNow comes the expansion part. The key rule is that *any* vertex connected to just one other vertex gets connected to `k` *more* new vertices.  This step must be done at least once.  If we consider the first round of expansion as *layer 1* (with the initial center as layer 0), each of the `k` vertices from layer 1 will now spawn `k` new vertices of its own, forming layer 2.\n\nWe can generalize this. The number of 'layers' of branches is important, let's call it `d`.  I'm thinking that if `d` is zero, we only have the single initial vertex. That's not the case here, as we are told `k > 1` and Step 2 must be done at least once, which means that `d` must be at least 1, and in practice, at least 2 for the second step.\n\nLet me clarify my thoughts here.  The initial setup is the central vertex. Then the rule says that it's connected to `k` new vertices. Let's call them `V_1_1` through `V_1_k`. So now the total number of vertices is `1 + k`. Then, the rule states that *each vertex* connected to *only one* other is connected by `k` new vertices. Since `V_1_1` through `V_1_k` are connected by one other vertex (the center), it means that `V_1_1` connects to `k` new vertices, let's call them `V_2_1_1` through `V_2_1_k`, and so on. This step *must* be done at least once.\n\nEssentially, `d` represents how many times we apply the branching rule. So when `d = 1`, we only have the first layer of `k` vertices. When `d = 2`, the first `k` vertices also each connect to `k` new vertices. And so on.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1.  Start with 1 central vertex.\n2.  Connect the central vertex to `k` new vertices (`k > 1`).\n3.  Each vertex that is connected to only one other vertex (i.e., a leaf node) is connected to `k` more new vertices. This step must be done at least once.\n\nLet's analyze the number of vertices.\n- The central vertex: 1 vertex.\n- The first layer of `k` vertices connected to the center: `k` vertices.\nAt this point, the total vertices are `1 + k`. The `k` vertices in the first layer are leaves.\n\nNow, the third rule applies. Since it must be done at least once, these `k` leaves must be expanded. Each of them gets `k` new children.\n- The second layer of vertices: `k * k = k^2` vertices.\nTotal vertices: `1 + k + k^2`. The `k^2` vertices in the second layer are now leaves.\n\nThis expansion can continue. If we apply the third rule `d-1` times (where `d` is the total number of layers of branches from the center), the number of vertices will be:\n`1 + k + k^2 + ... + k^d`.\nThis is a geometric series sum: `(k^(d+1) - 1) / (k - 1)`.\n\nThe problem states \"This step should be done at least once\".\nIf `d=1`, we have `1+k` vertices. The `k` vertices are leaves. If we apply the \"expansion\" step to them, we get `1+k+k^2` vertices. So `d=1` alone is not enough, as it implies the expansion step hasn't been done yet. The expansion step must be done at least once, meaning the `k` initial leaves must be expanded. This implies that the smallest possible snowflake must have at least `1 + k + k^2` vertices.\nTherefore, `d` must be at least 2.\n\nWe are looking for `n = (k^(d+1) - 1) / (k - 1)` such that `k > 1` and `d >= 2`.\n\nLet `m = d+1`. Then `m >= 3`.\nSo we need to check if `n = (k^m - 1) / (k - 1)` for some integers `k > 1` and `m >= 3`.\n\nThe given `n` can be up to `10^18`.\n\n**Case 1: `m = 3`**\nThis means `d=2`. The number of vertices is `n = 1 + k + k^2`.\nWe can rewrite this as `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4 * (1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be an integer greater than 1, `4n - 3` must be a perfect square, say `s^2`.\nSo, `s = sqrt(4n - 3)`. Then `k = (-1 + s) / 2` (since `k > 0`).\nWe need to check:\n1. `4n - 3` is a perfect square.\n2. `s = sqrt(4n - 3)` is an integer.\n3. `s` must be odd, so that `-1 + s` is even.\n4. `k = (-1 + s) / 2` must be an integer `> 1`. This implies `s > 3`.\n\nSince `n` can be very large, `4n-3` can also be very large. We can use integer square root or `math.isqrt` (Python 3.8+) to check for perfect squares.\n\n**Case 2: `m >= 4`**\nFor `m >= 4`, `k` can be found by checking `k = floor(n^(1/m))`.\nSince `n = 1 + k + k^2 + ... + k^(m-1)`, we know that `k^(m-1) < n`.\nAlso, `n = (k^m - 1) / (k - 1) < k^m / (k-1)`.\nFor `k >= 2`, `k-1 >= 1`, so `n < k^m`.\nThus, `k^(m-1) < n < k^m`. This means `k < n^(1/(m-1))`.\nMore precisely, `k` is roughly `n^(1/(m-1))`.\nSince `k >= 2`, `2^(m-1) <= n`. So `m-1 <= log2(n)`.\nGiven `n <= 10^18`, `log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79`.\nSo `m-1` can be at most 59. This means `m` can be at most 60.\n\nWe can iterate `m` from 4 up to 60 (or `log2(n)+1`). For each `m`:\n1. Calculate an approximate `k` value. A safe upper bound for `k` is `n^(1/(m-1))`. We can use `k_approx = round(n**(1/(m-1)))`.\n2. Since `n = 1 + k + ... + k^(m-1)`, `k` must be at least 2.\n3. We can binary search for `k` in the range `[2, N_max_k]`, where `N_max_k` is `2 * 10^9` (because if `k=2`, `2^60` is approx `10^18`, so `k` doesn't need to be much larger than `10^9` for `m=4`). A safe upper bound for `k` is `(10^18)^(1/3) = 10^6` for `m=4` (`m-1=3`). For `m=4`, `k` can be up to `10^6`. For `m=60`, `k` can only be `2`. So `k` is relatively small.\n\nA more precise binary search range for `k` for a given `m`:\nThe lower bound is `2`.\nThe upper bound is `(int(n**(1/(m-1))) + 2)`. For `m=4`, `n^(1/3)` is at most `(10^18)^(1/3) = 10^6`. So `10^6` is a good upper bound.\n\nFor a fixed `m`, we want to find `k` such that `sum_val(k, m) = n`.\n`sum_val(k, m) = 1 + k + k^2 + ... + k^(m-1)`.\nThis function `sum_val(k, m)` is strictly increasing with `k` for `k > 1`.\nWe can binary search for `k` in the range `[2, 10^6 + 7]` (a safe upper bound, `10^6` is enough for `m=4`, smaller for larger `m`).\n\n**Algorithm:**\n1.  **Check `m=3` (i.e., `d=2`):**\n    Calculate `val = 4 * n - 3`.\n    If `val < 0`, continue.\n    Calculate `s = math.isqrt(val)`.\n    If `s * s == val` (i.e., `val` is a perfect square):\n        If `s > 1` and `(-1 + s) % 2 == 0`:\n            `k = (-1 + s) // 2`.\n            If `k > 1`, then `n` is a snowflake. Return \"YES\".\n\n2.  **Check `m >= 4` (i.e., `d >= 3`):**\n    Iterate `m` from `4` up to `60` (or `log2(n)+1` for `n > 0`).\n    For each `m`:\n        Binary search for `k` in the range `[2, 10^6 + 7]`.\n        `low = 2`, `high = 10^6 + 7`.\n        While `low <= high`:\n            `mid = (low + high) // 2`.\n            If `mid < 2`, set `mid = 2` and continue, or just make sure `low` starts at 2.\n            Calculate `current_sum = 0`.\n            `power_k = 1`.\n            `overflow = False`.\n            For `i` from `0` to `m-1`:\n                `current_sum += power_k`.\n                If `i < m-1`: // Avoid overflow for last `power_k` calculation\n                    If `mid > n / power_k` (check `mid * power_k > n` safely) or `power_k > n`: // Check for potential overflow of power_k\n                        `overflow = True`\n                        break\n                    `power_k *= mid`.\n                If `current_sum > n`: // Check for overflow of current_sum\n                    `overflow = True`\n                    break\n\n            If `overflow` or `current_sum > n`:\n                `high = mid - 1`.\n            Else if `current_sum < n`:\n                `low = mid + 1`.\n            Else (`current_sum == n`):\n                Return \"YES\".\n\n3.  If no such `k, m` are found after checking all cases, return \"NO\".\n\n**Edge cases:**\n- `n=1, 2, 3`:\n  - `n=1`: `4*1-3 = 1`. `s=1`. `k=(-1+1)/2 = 0`. Not `k>1`. NO.\n  - `n=2`: `4*2-3 = 5`. Not a perfect square. NO.\n  - `n=3`: `4*3-3 = 9`. `s=3`. `k=(-1+3)/2 = 1`. Not `k>1`. NO.\n  These are correctly handled by the logic.\n\nThe maximum value for `m` can be determined by `2^(m-1) <= n`. For `n=10^18`, `2^59 < 10^18 < 2^60`. So `m-1` can be at most `59`, meaning `m` can be at most `60`. The loop for `m` should go from `4` to `60`.\n\nThe upper bound for `k` in the binary search:\nFor `m=4`, `k^3 < n <= 10^18`, so `k < (10^18)^(1/3) = 10^6`.\nFor `m=60`, `k^59 < n <= 10^18`, so `k < (10^18)^(1/59)`. `2^59` is already `5.76 * 10^17`, so `k` must be `2`.\nSo `10^6 + 7` is a safe upper bound for `k`.\n\nThe `power_k` and `current_sum` calculations need to be careful about overflow for intermediate values when `n` is large.\n`current_sum += power_k`: If `current_sum` exceeds `n`, we know `mid` is too large.\n`power_k *= mid`: If `power_k` grows too large, `mid * power_k` could overflow.\nA safe check for `power_k * mid` overflow for `n` is `mid > n / power_k`. If this is true, then `mid * power_k` would be greater than `n`. Since we only care if `current_sum` reaches `n`, if `power_k` itself exceeds `n` or `mid * power_k` would exceed `n`, we can mark it as overflow and prune the search.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 3 (d = 2)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4 * (1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val_for_sqrt = 4 * n - 3\n    if val_for_sqrt >= 0:\n        s = math.isqrt(val_for_sqrt)\n        if s * s == val_for_sqrt: # Check if 4n-3 is a perfect square\n            # For k to be an integer, -1 + s must be even, so s must be odd.\n            # Also, k > 1 means (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n            if s > 3 and (s % 2 == 1):\n                k = (-1 + s) // 2\n                # No need to explicitly check k > 1 again, s > 3 implies it.\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 4 (d >= 3)\n    # n = 1 + k + k^2 + ... + k^(m-1)\n    # k >= 2.\n    # Max m: 2^(m-1) <= n => m-1 <= log2(n). For n=10^18, log2(10^18) approx 59.79.\n    # So m-1 <= 59 => m <= 60.\n    \n    # Max k: For m=4, k^3 < n <= 10^18 => k < 10^6.\n    # For m=60, k=2 is the only possibility.\n    # So k is in range [2, 10^6 + 7] (a bit of buffer)\n    \n    for m in range(4, 61): # m ranges from 4 to 60\n        low = 2\n        high = 10**6 + 7 # Upper bound for k\n\n        while low <= high:\n            mid_k = (low + high) // 2\n            \n            # Calculate sum = 1 + mid_k + mid_k^2 + ... + mid_k^(m-1)\n            current_sum = 0\n            power_of_k = 1\n            overflow = False\n\n            for _ in range(m): # Loop m times for terms k^0 to k^(m-1)\n                current_sum += power_of_k\n                \n                if current_sum > n: # Check sum overflow\n                    overflow = True\n                    break\n                \n                if _ < m - 1: # Prepare power_of_k for the next term, but not after the last term\n                    # Check for power_of_k * mid_k overflow before multiplication\n                    # If mid_k > n / power_of_k, then mid_k * power_of_k would be > n.\n                    # Since n is the target, any term larger than n makes the total sum definitely larger than n.\n                    # Also, if power_of_k itself is already larger than n, the next term will be even larger.\n                    if power_of_k > n // mid_k if mid_k > 0 else True: # Handle mid_k=0 if possible, but mid_k>=2 here\n                        overflow = True\n                        break\n                    power_of_k *= mid_k\n            \n            if overflow or current_sum > n:\n                high = mid_k - 1\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 3 (d = 2)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4 * (1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val_for_sqrt = 4 * n - 3\n    if val_for_sqrt >= 0:\n        s = math.isqrt(val_for_sqrt)\n        if s * s == val_for_sqrt: # Check if 4n-3 is a perfect square\n            # For k to be an integer, -1 + s must be even, so s must be odd.\n            # Also, k > 1 means (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n            if s > 3 and (s % 2 == 1):\n                k = (-1 + s) // 2\n                # No need to explicitly check k > 1 again, s > 3 implies it.\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 4 (d >= 3)\n    # n = 1 + k + k^2 + ... + k^(m-1)\n    # k >= 2.\n    # Max m: 2^(m-1) <= n => m-1 <= log2(n). For n=10^18, log2(10^18) approx 59.79.\n    # So m-1 <= 59 => m <= 60.\n    \n    # Max k: For m=4, k^3 < n <= 10^18 => k < 10^6.\n    # For m=60, k=2 is the only possibility.\n    # So k is in range [2, 10^6 + 7] (a bit of buffer)\n    \n    for m in range(4, 61): # m ranges from 4 to 60\n        low = 2\n        high = 10**6 + 7 # Upper bound for k\n\n        while low <= high:\n            mid_k = (low + high) // 2\n            \n            # Calculate sum = 1 + mid_k + mid_k^2 + ... + mid_k^(m-1)\n            current_sum = 0\n            power_of_k = 1\n            overflow = False\n\n            for _ in range(m): # Loop m times for terms k^0 to k^(m-1)\n                current_sum += power_of_k\n                \n                if current_sum > n: # Check sum overflow\n                    overflow = True\n                    break\n                \n                if _ < m - 1: # Prepare power_of_k for the next term, but not after the last term\n                    # Check for power_of_k * mid_k overflow before multiplication\n                    # If mid_k > n / power_of_k, then mid_k * power_of_k would be > n.\n                    # Since n is the target, any term larger than n makes the total sum definitely larger than n.\n                    # Also, if power_of_k itself is already larger than n, the next term will be even larger.\n                    if power_of_k > n // mid_k if mid_k > 0 else True: # Handle mid_k=0 if possible, but mid_k>=2 here\n                        overflow = True\n                        break\n                    power_of_k *= mid_k\n            \n            if overflow or current_sum > n:\n                high = mid_k - 1\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 3787,
        "thoughts_token_count": 770
    }
}