{
    "start": 1758293706.6975548,
    "end": 1758293761.0684445,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank for Vasya\n    # To get the best rank, Vasya wants to maximize his score.\n    # The other participants should have their scores minimized, subject to Vasya's choice.\n    # However, the problem states that \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # This means for the best rank, if Vasya ties with others for the highest score, he can be assigned 1st place.\n    # So, the best rank is always 1, as long as Vasya can achieve the maximum possible score among all participants.\n    # The guarantee \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\"\n    # implies Vasya can pick any a_i and b_j. To maximize his score, he picks a_max + b_max.\n    # The problem implies Vasya is one of the N participants.\n    # The actual best rank is 1. Vasya can achieve a score of a[n-1] + b[n-1].\n    # It's guaranteed that some a_i + b_j >= x.\n    # Vasya can always choose the highest a_i and highest b_j to maximize his score.\n    # If this maximal score is unique, he is 1st. If it's not unique, he can still be 1st.\n    # So the best rank is always 1.\n    best_rank = 1\n\n    # Calculate worst possible rank for Vasya\n    # To get the worst rank, Vasya wants to minimize his score (but still >= x).\n    # The other participants should have their scores maximized.\n    # We need to find the maximum number of participants who can score strictly more than Vasya.\n    # If Vasya ties with others, the jury can assign him the worst place among them.\n    # This means if Vasya scores S, and k participants score > S, and m participants score = S,\n    # Vasya's worst rank would be k + m.\n\n    # We need to find the minimum possible score Vasya could have, such that it's >= x.\n    # And then count how many people can score >= this score.\n\n    # To maximize the number of people who score better than Vasya,\n    # Vasya should be assigned a pair (a_i, b_j) such that a_i + b_j is minimized, but >= x.\n    # The remaining n-1 'a' scores and n-1 'b' scores are then paired to maximize other participants' scores.\n\n    # Let's count how many pairs (a_i, b_j) can sum to at least X.\n    # This count represents the number of distinct people who could potentially be Vasya.\n    # And for each such person, what is their minimum possible score?\n\n    # Consider a fixed score for Vasya, say S_V.\n    # We want to maximize the number of participants whose score is >= S_V.\n    # To do this, we pair the largest remaining 'a' with the largest remaining 'b', and so on.\n\n    # The problem is tricky because Vasya's (a_i, b_j) pair is unknown.\n    # The key insight for worst rank:\n    # Vasya takes some a_i and some b_j such that a_i + b_j >= x.\n    # All other n-1 participants take the remaining n-1 'a's and n-1 'b's.\n    # We want to maximize the number of participants whose score is greater than or equal to Vasya's score.\n    # This means we want to minimize Vasya's score (but still >= x)\n    # AND maximize the scores of other participants.\n\n    # Let's try to fix Vasya's score to be S.\n    # Vasya needs to pick an a_i and b_j such that a_i + b_j = S and S >= x.\n    # The remaining n-1 'a's and n-1 'b's are paired up.\n    # We want to maximize the number of participants whose score is >= S.\n\n    # This is equivalent to finding the minimum S such that Vasya can achieve it (S >= x),\n    # and then counting how many participants can achieve a score >= S, including Vasya.\n\n    # Let's rephrase: we want to find the maximum k such that k participants can achieve scores S_1, ..., S_k\n    # where S_i >= x for all i, and Vasya's score is S_j for some j.\n    # And then we count how many people can get a score >= S_Vasya.\n\n    # The most straightforward approach for the worst rank:\n    # Vasya will be assigned some (a_i, b_j) such that a_i + b_j >= x.\n    # The remaining (n-1) 'a's and (n-1) 'b's will be assigned to the other (n-1) participants.\n    # To maximize Vasya's rank, we want to maximize the number of people who score strictly higher than Vasya.\n    # To do this, Vasya should take a pair (a_i, b_j) such that a_i + b_j is as small as possible (but >= x).\n    # And the other participants should take pairs that maximize their scores.\n\n    # This is a matching problem.\n    # For a given set of 'a's and 'b's, we can form n pairs.\n    # The sum of scores for all participants is fixed: sum(a) + sum(b).\n    # We want to find a permutation P of {0, ..., n-1} such that Vasya's score (a_i + b_{P[i]}) is minimal (but >= x),\n    # and then count how many participants (including Vasya) have score >= Vasya's score.\n\n    # Let's try to count how many participants can achieve a score of at least S.\n    # For a given score S, how many pairs (a_i, b_j) can be formed such that a_i + b_j >= S?\n    # This is a standard two-pointer problem.\n    # Sort 'a' in ascending order and 'b' in ascending order.\n    # Iterate through 'a_i'. For each a_i, find the smallest b_j such that a_i + b_j >= S.\n    # All b_k for k >= j will also satisfy a_i + b_k >= S.\n    # This counts the number of *potential* pairs, not *disjoint* pairs.\n\n    # We need to find the maximum number of participants who can achieve a score of at least S,\n    # given that Vasya is one of them, and his score is also at least S.\n    # This means we want to find the maximum k such that we can pick k distinct a_i's and k distinct b_j's\n    # and form k pairs (a_i, b_j) such that a_i + b_j >= S for all k pairs.\n\n    # Let's use a greedy approach for the worst rank.\n    # We want to find the minimum possible score Vasya could have, say `min_vasya_score`.\n    # This `min_vasya_score` must be >= x.\n    # To make Vasya's score minimal, he picks some a_i and b_j.\n    # The remaining `a` values and `b` values are paired up among other `n-1` participants.\n    # We want to maximize the number of people who score >= `min_vasya_score`.\n    # This means we want to maximize the number of pairs (a_k, b_l) such that a_k + b_l >= `min_vasya_score`.\n\n    # Let's fix Vasya's 'a' score to be a_i.\n    # Then Vasya must pick some b_j such that a_i + b_j >= x. To minimize his score, he picks the smallest such b_j.\n    # Let's say he picks b_k. So Vasya's score is a_i + b_k.\n    # Now we have a_i and b_k removed. We need to pair the remaining n-1 'a's and n-1 'b's.\n    # We want to maximize the number of pairs (a_p, b_q) from the remaining elements such that a_p + b_q >= a_i + b_k.\n    # This seems too complicated as we iterate over all possible a_i and b_k.\n\n    # A simpler approach for the worst rank:\n    # We want to count how many participants (including Vasya) can achieve a score of at least S.\n    # Let's define a function `can_form_k_pairs(S)` which returns true if we can form k pairs (a_p, b_q)\n    # such that a_p + b_q >= S for all k pairs, using distinct a_p and b_q.\n    # We are looking for the maximum k such that `can_form_k_pairs(S)` is true for some S >= x.\n    # This is not quite right. We need to maximize the number of participants who score >= Vasya's score.\n\n    # Let's consider the possible scores Vasya can get.\n    # Vasya can get any score `a_i + b_j` such that `a_i + b_j >= x`.\n    # For each such possible score `S = a_i + b_j`:\n    #   1. Vasya gets score S.\n    #   2. The remaining `n-1` 'a's and `n-1` 'b's are paired up.\n    #   3. We want to maximize the number of these `n-1` pairs that also have a sum >= S.\n    #   4. The worst rank for Vasya would be `1 + (number of other pairs with sum >= S)`.\n    # This is still too complex.\n\n    # The key insight for the worst case often involves a specific pairing strategy.\n    # To maximize the number of people who score >= Vasya's score:\n    # Vasya should be assigned a pair (a_i, b_j) such that a_i + b_j >= x.\n    # The remaining (n-1) 'a's and (n-1) 'b's are assigned to other (n-1) participants.\n    # We want to maximize the number of participants (including Vasya) whose score is >= Vasya's chosen score.\n\n    # Consider the sorted lists `a` and `b`.\n    # Let's try to match `a_i` with `b_{n-1-i}`. This maximizes the sums.\n    # Or `a_i` with `b_i`. This gives a mix.\n\n    # Let's count how many participants can achieve a score of at least S.\n    # This is the maximum `k` such that we can find `k` distinct `a_i`s and `k` distinct `b_j`s\n    # to form `k` pairs `(a_i, b_j)` with `a_i + b_j >= S`.\n    # This is a known greedy matching problem.\n    # Sort `a` in ascending order. Sort `b` in descending order.\n    # Iterate `i` from `0` to `n-1`. For each `a_i`, try to match it with `b_j`.\n    # If `a_i + b_j >= S`, then we can form a pair.\n    # To maximize the number of pairs, we use a two-pointer approach:\n    # Sort `a` ascending, `b` ascending.\n    # `count = 0`, `j = n-1` (pointer for `b`).\n    # For `i` from `0` to `n-1` (pointer for `a`):\n    #   While `j >= 0` and `a[i] + b[j] >= S`:\n    #     `j -= 1`\n    #   If `j < n-1` (meaning we found at least one `b_j` for `a_i`):\n    #     `count += 1`\n    #     `j -= 1` (This logic is wrong. This is for unique pairs.)\n\n    # Correct logic for `can_form_k_pairs(S)`:\n    # Sort `a` ascending. Sort `b` ascending.\n    # `count = 0`\n    # `j = 0` (pointer for `b`)\n    # For `i` from `0` to `n-1` (pointer for `a`):\n    #   While `j < n` and `a[i] + b[j] < S`:\n    #     `j += 1`\n    #   If `j < n`:\n    #     `count += 1`\n    #     `j += 1`\n    # Return `count`. This counts the maximum number of pairs (a_i, b_j) with a_i + b_j >= S,\n    # where each a_i and b_j is used at most once.\n    # This `can_form_k_pairs(S)` function actually counts how many participants can score >= S.\n\n    # Now, Vasya's worst rank.\n    # Vasya is guaranteed to score at least `x`.\n    # We want to find the maximum `k` such that `k` participants (including Vasya) can score at least `S`,\n    # where `S` is some score Vasya could have achieved (i.e., `S >= x`).\n    # And then we want to maximize `k`.\n\n    # The possible values for `S` are `a_i + b_j`.\n    # The range of `S` is `[0, 2*10^5]`.\n    # We can binary search for the minimum possible score `S_min_vasya` that Vasya could achieve,\n    # such that `can_form_k_pairs(S_min_vasya)` is maximized.\n    # This is not quite right. We need to find the maximum `k` such that there exists some `S >= x`\n    # for which `can_form_k_pairs(S)` returns `k`.\n\n    # Let's consider the scores `a_i + b_j`.\n    # We are looking for the minimum possible score `S_vasya` (where `S_vasya >= x`)\n    # such that the number of participants who can achieve a score of at least `S_vasya` is maximized.\n    # This is the `can_form_k_pairs(S_vasya)` value.\n\n    # Let's find the maximum number of participants `k` that can achieve a score of at least `S`.\n    # This `k` is a monotonically decreasing function of `S`.\n    # We are guaranteed that at least one pair `a_i + b_j >= x` exists.\n    # So `can_form_k_pairs(x)` will be at least 1.\n\n    # The worst rank for Vasya is the maximum `k` such that we can find `k` participants (including Vasya)\n    # who all score at least `S`, where `S` is some score Vasya could have gotten (S >= x).\n    # To maximize this `k`, Vasya should aim for the lowest possible score `S` (but >= x).\n    # If Vasya takes `a_i` and `b_j` such that `a_i + b_j = S` (and `S >= x`),\n    # then the worst rank for him is `can_form_k_pairs(S)`.\n    # We want to find `max_{S >= x, S = a_i + b_j} (can_form_k_pairs(S))`.\n    # This is still not quite right. `S` doesn't have to be `a_i + b_j`.\n    # Vasya's score could be `S_vasya`. The other `k-1` people score `S_other_1, ..., S_other_{k-1}`.\n    # All `S_vasya, S_other_1, ..., S_other_{k-1}` must be >= `S_vasya`.\n\n    # The correct interpretation for worst rank:\n    # Vasya is assigned some `a_i` and `b_j` such that `a_i + b_j >= x`.\n    # Let Vasya's score be `S_V = a_i + b_j`.\n    # The remaining `n-1` `a` values and `n-1` `b` values are assigned to the other `n-1` participants.\n    # We want to maximize the number of participants (including Vasya) whose score is >= `S_V`.\n    # This implies we want to choose `a_i, b_j` (for Vasya) and the remaining pairings\n    # such that `S_V` is as small as possible (but >= x) AND the number of participants whose score is >= `S_V` is maximized.\n\n    # Let's use a fixed-point idea.\n    # Suppose Vasya's score is `S_V`.\n    # We want to find the maximum number of pairs `(a_p, b_q)` such that `a_p + b_q >= S_V`.\n    # This is `can_form_k_pairs(S_V)`.\n    # So, we want to find `S_V` such that `S_V >= x` and `can_form_k_pairs(S_V)` is maximized.\n    # Since `can_form_k_pairs(S)` is non-increasing with `S`, we want to choose the smallest `S_V >= x`\n    # that Vasya can possibly achieve.\n    # The smallest score Vasya can achieve is `x` (if `x` can be formed by some `a_i + b_j`).\n    # Or more generally, the smallest `a_i + b_j` that is `>= x`.\n\n    # This is still not quite right. The problem states \"If two or more participants have got the same number of points,\n    # it's up to the jury to assign places to them according to their choice.\"\n    # This means if Vasya scores S, and k people score > S, and m people score = S,\n    # Vasya's worst rank is k + m + 1. (Here, k+m people are ranked better or equal to Vasya).\n    # So we want to maximize `k + m`.\n\n    # Let's try to count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= S.\n    # This is the `can_form_k_pairs(S)` function from above.\n    # The `worst_rank` will be `can_form_k_pairs(S_min_vasya)`.\n    # What is `S_min_vasya`?\n    # It is the minimum `S` such that `S >= x` and `S` can be formed by some `a_i + b_j` using *available* `a` and `b` lists.\n    # But all `a` and `b` are available. So `S_min_vasya` is the smallest `a_i + b_j` that is `>= x`.\n\n    # Let's verify this.\n    # Suppose `S_min_vasya = min { a_i + b_j | a_i + b_j >= x }`.\n    # Vasya is assigned this score.\n    # Then the number of participants who score at least `S_min_vasya` is `can_form_k_pairs(S_min_vasya)`.\n    # Can we make Vasya's rank even worse?\n    # If Vasya picks a higher score `S_V' > S_min_vasya`, then `can_form_k_pairs(S_V') <= can_form_k_pairs(S_min_vasya)`\n    # because `can_form_k_pairs` is non-increasing. So his rank would be better or equal.\n    # So the maximum rank is achieved when Vasya takes `S_min_vasya`.\n\n    # How to calculate `S_min_vasya`?\n    # This is simply `x` if `x` can be formed.\n    # Or, it's the smallest `a_i + b_j` that is `>= x`.\n    # We can find this by iterating through `a_i` and for each `a_i`, finding the smallest `b_j` such that `a_i + b_j >= x`.\n    # `min_score_vasya = infinity`\n    # For `a_val` in `a`:\n    #   Find `b_val` in `b` such that `a_val + b_val >= x`.\n    #   `target = x - a_val`\n    #   Use `bisect_left` on sorted `b` to find `b_idx` for `target`.\n    #   If `b_idx < n`, then `b[b_idx]` is the smallest `b_val` such that `a_val + b_val >= x`.\n    #   `min_score_vasya = min(min_score_vasya, a_val + b[b_idx])`.\n    # This gives the smallest possible score Vasya can get while satisfying `a_i + b_j >= x`.\n    # But this is not correct. The problem guarantees `a_i + b_j >= x` for *some* `i, j`.\n    # It does not mean Vasya has to achieve this minimum possible sum.\n    # The problem implies Vasya is one of the `n` participants.\n    # The teacher knows Vasya got AT LEAST `x` points.\n    # The teacher wants to know the best and worst rank Vasya *could have* won.\n    # This means we need to consider all possible pairings of `a` and `b` to `n` participants,\n    # and for each such pairing, identify which participant is Vasya, and then determine his rank.\n\n    # This is the crucial part: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This implies Vasya can be *any* of the `n` participants.\n    # And Vasya's score is `S_V >= x`.\n    # And the other `n-1` participants are assigned the remaining scores.\n\n    # For worst rank:\n    # Vasya is assigned some `a_i` and `b_j` such that `a_i + b_j >= x`.\n    # Let this score be `S_V`.\n    # The remaining `n-1` `a` values and `n-1` `b` values are assigned to other participants.\n    # We want to maximize the number of participants whose score is >= `S_V`.\n    # This means we want to maximize `k` such that we can find `k` pairs `(a_p, b_q)`\n    # (using distinct `a`s and `b`s) where each `a_p + b_q >= S_V`.\n    # And we want to pick `S_V` such that `S_V >= x` and this `k` is maximized.\n    # Since `k` is non-increasing with `S_V`, we want the smallest `S_V` such that `S_V >= x`.\n    # The smallest possible score Vasya could have is `x`.\n    # If Vasya scores `x`, then his worst rank is `can_form_k_pairs(x)`.\n    # Is it always possible for Vasya to score exactly `x`? No.\n    # For example, if `x=5`, `a=[1,2]`, `b=[1,2]`. No `a_i+b_j=5`.\n    # But `a_i+b_j >= x` is guaranteed for some `i,j`.\n    # So Vasya must have scored at least `x`.\n    # The smallest score Vasya *could* have is `min_possible_vasya_score = min(a_i + b_j)` over all `i,j` such that `a_i + b_j >= x`.\n    # We can find this `min_possible_vasya_score` efficiently.\n    # Sort `a` and `b`.\n    # `min_score = float('inf')`\n    # For `val_a` in `a`:\n    #   `target_b = x - val_a`\n    #   `idx = bisect_left(b, target_b)`\n    #   If `idx < n`:\n    #     `min_score = min(min_score, val_a + b[idx])`\n    # This `min_score` is the lowest score Vasya could have achieved while meeting the `x` criteria.\n    # Let `S_worst_vasya = min_score`.\n    # Then the worst rank is `can_form_k_pairs(S_worst_vasya)`.\n\n    from bisect import bisect_left\n\n    # Function to calculate maximum number of pairs (a_i, b_j) such that a_i + b_j >= S\n    def count_pairs_ge_S(S, arr1, arr2):\n        count = 0\n        j = n - 1  # Pointer for arr2 (b)\n        for i in range(n):  # Pointer for arr1 (a)\n            while j >= 0 and arr1[i] + arr2[j] >= S:\n                j -= 1\n            # After the loop, all b[0...j] are too small for a[i]\n            # All b[j+1...n-1] are large enough for a[i]\n            # We can form (n-1-j) pairs with a[i]\n            # This is not the correct greedy approach for maximum *disjoint* pairs.\n\n        # Correct greedy approach for maximum disjoint pairs:\n        # Sort arr1 ascending, arr2 ascending.\n        # Use two pointers.\n        # `count = 0`\n        # `j = 0` (pointer for `arr2`)\n        # For `i` from `0` to `n-1` (pointer for `arr1`):\n        #   While `j < n` and `arr1[i] + arr2[j] < S`:\n        #     `j += 1`\n        #   If `j < n`:  # Found a suitable `arr2[j]` for `arr1[i]`\n        #     `count += 1`\n        #     `j += 1` # Move to next `arr2` element for the next `arr1` element\n        # Return `count`\n        # Example: a=[1,2,3], b=[1,2,3], S=4\n        # i=0, a[0]=1:\n        #   j=0, b[0]=1, 1+1=2 < 4 -> j=1\n        #   j=1, b[1]=2, 1+2=3 < 4 -> j=2\n        #   j=2, b[2]=3, 1+3=4 >= 4 -> count=1, j=3\n        # i=1, a[1]=2:\n        #   j=3, j<n is false. Loop ends.\n        # Returns 1. This is correct. (1,3) is the only pair >=4.\n        # What if a=[1,1,1], b=[1,1,1], S=2.\n        # i=0, a[0]=1:\n        #   j=0, b[0]=1, 1+1=2 >= 2 -> count=1, j=1\n        # i=1, a[1]=1:\n        #   j=1, b[1]=1, 1+1=2 >= 2 -> count=2, j=2\n        # i=2, a[2]=1:\n        #   j=2, b[2]=1, 1+1=2 >= 2 -> count=3, j=3\n        # Returns 3. This is correct. (1,1), (1,1), (1,1) are 3 pairs.\n\n        count = 0\n        j = 0\n        for i in range(n):\n            while j < n and arr1[i] + arr2[j] < S:\n                j += 1\n            if j < n:\n                count += 1\n                j += 1\n        return count\n\n    # Calculate S_worst_vasya\n    min_score_vasya_potential = float('inf')\n    for val_a in a:\n        target_b = x - val_a\n        idx = bisect_left(b, target_b)\n        if idx < n:\n            min_score_vasya_potential = min(min_score_vasya_potential, val_a + b[idx])\n\n    # The problem guarantees that Vasya was present and there exist i, j such that a_i + b_j >= x.\n    # So min_score_vasya_potential will be a finite value.\n\n    worst_rank = count_pairs_ge_S(min_score_vasya_potential, a, b)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank for Vasya\n    # To get the best rank, Vasya wants to maximize his score.\n    # The other participants should have their scores minimized, subject to Vasya's choice.\n    # However, the problem states that \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # This means for the best rank, if Vasya ties with others for the highest score, he can be assigned 1st place.\n    # So, the best rank is always 1, as long as Vasya can achieve the maximum possible score among all participants.\n    # The guarantee \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\"\n    # implies Vasya can pick any a_i and b_j. To maximize his score, he picks a_max + b_max.\n    # The problem implies Vasya is one of the N participants.\n    # The actual best rank is 1. Vasya can achieve a score of a[n-1] + b[n-1].\n    # It's guaranteed that some a_i + b_j >= x.\n    # Vasya can always choose the highest a_i and highest b_j to maximize his score.\n    # If this maximal score is unique, he is 1st. If it's not unique, he can still be 1st.\n    # So the best rank is always 1.\n    best_rank = 1\n\n    # Calculate worst possible rank for Vasya\n    # To get the worst rank, Vasya wants to minimize his score (but still >= x).\n    # The other participants should have their scores maximized.\n    # We need to find the maximum number of participants who can score strictly more than Vasya.\n    # If Vasya ties with others, the jury can assign him the worst place among them.\n    # This means if Vasya scores S, and k participants score > S, and m participants score = S,\n    # Vasya's worst rank would be k + m.\n\n    # We need to find the minimum possible score Vasya could have, such that it's >= x.\n    # And then count how many people can score >= this score.\n\n    # To maximize the number of people who score better than Vasya,\n    # Vasya should be assigned a pair (a_i, b_j) such that a_i + b_j is minimized, but >= x.\n    # The remaining n-1 'a' scores and n-1 'b' scores are then paired to maximize other participants' scores.\n\n    # Let's count how many pairs (a_i, b_j) can sum to at least X.\n    # This count represents the number of distinct people who could potentially be Vasya.\n    # And for each such person, what is their minimum possible score?\n\n    # Consider a fixed score for Vasya, say S_V.\n    # We want to maximize the number of participants whose score is >= S_V.\n    # To do this, we pair the largest remaining 'a' with the largest remaining 'b', and so on.\n\n    # The problem is tricky because Vasya's (a_i, b_j) pair is unknown.\n    # The key insight for worst rank:\n    # Vasya takes some a_i and some b_j such that a_i + b_j >= x.\n    # All other n-1 participants take the remaining n-1 'a's and n-1 'b's.\n    # We want to maximize the number of participants whose score is greater than or equal to Vasya's score.\n    # This means we want to minimize Vasya's score (but still >= x)\n    # AND maximize the scores of other participants.\n\n    # Let's try to fix Vasya's score to be S.\n    # Vasya needs to pick an a_i and b_j such that a_i + b_j = S and S >= x.\n    # The remaining n-1 'a's and n-1 'b's are paired up.\n    # We want to maximize the number of participants whose score is >= S.\n\n    # This is equivalent to finding the minimum S such that Vasya can achieve it (S >= x),\n    # and then counting how many participants can achieve a score >= S, including Vasya.\n\n    # Let's rephrase: we want to find the maximum k such that k participants can achieve scores S_1, ..., S_k\n    # where S_i >= x for all i, and Vasya's score is S_j for some j.\n    # And then we count how many people can get a score >= S_Vasya.\n\n    # The most straightforward approach for the worst rank:\n    # Vasya will be assigned some (a_i, b_j) such that a_i + b_j >= x.\n    # The remaining (n-1) 'a's and (n-1) 'b's will be assigned to the other (n-1) participants.\n    # To maximize Vasya's rank, we want to maximize the number of people who score strictly higher than Vasya.\n    # To do this, Vasya should take a pair (a_i, b_j) such that a_i + b_j is as small as possible (but >= x).\n    # And the other participants should take pairs that maximize their scores.\n\n    # This is a matching problem.\n    # For a given set of 'a's and 'b's, we can form n pairs.\n    # The sum of scores for all participants is fixed: sum(a) + sum(b).\n    # We want to find a permutation P of {0, ..., n-1} such that Vasya's score (a_i + b_{P[i]}) is minimal (but >= x),\n    # and then count how many participants (including Vasya) have score >= Vasya's score.\n\n    # Let's try to count how many participants can achieve a score of at least S.\n    # For a given score S, how many pairs (a_i, b_j) can be formed such that a_i + b_j >= S?\n    # This is a standard two-pointer problem.\n    # Sort 'a' in ascending order and 'b' in ascending order.\n    # Iterate through 'a_i'. For each a_i, find the smallest b_j such that a_i + b_j >= S.\n    # All b_k for k >= j will also satisfy a_i + b_k >= S.\n    # This counts the number of *potential* pairs, not *disjoint* pairs.\n\n    # We need to find the maximum number of participants who can achieve a score of at least S,\n    # given that Vasya is one of them, and his score is also at least S.\n    # This means we want to find the maximum k such that we can pick k distinct a_i's and k distinct b_j's\n    # and form k pairs (a_i, b_j) such that a_i + b_j >= S for all k pairs.\n\n    # Let's use a greedy approach for the worst rank.\n    # We want to find the minimum possible score Vasya could have, say `min_vasya_score`.\n    # This `min_vasya_score` must be >= x.\n    # To make Vasya's score minimal, he picks some a_i and b_j.\n    # The remaining `a` values and `b` values are paired up among other `n-1` participants.\n    # We want to maximize the number of people who score >= `min_vasya_score`.\n    # This means we want to maximize the number of pairs (a_k, b_l) such that a_k + b_l >= `min_vasya_score`.\n\n    # Let's fix Vasya's 'a' score to be a_i.\n    # Then Vasya must pick some b_j such that a_i + b_j >= x. To minimize his score, he picks the smallest such b_j.\n    # Let's say he picks b_k. So Vasya's score is a_i + b_k.\n    # Now we have a_i and b_k removed. We need to pair the remaining n-1 'a's and n-1 'b's.\n    # We want to maximize the number of pairs (a_p, b_q) from the remaining elements such that a_p + b_q >= a_i + b_k.\n    # This seems too complicated as we iterate over all possible a_i and b_k.\n\n    # A simpler approach for the worst rank:\n    # We want to count how many participants (including Vasya) can achieve a score of at least S.\n    # Let's define a function `can_form_k_pairs(S)` which returns true if we can form k pairs (a_p, b_q)\n    # such that a_p + b_q >= S for all k pairs, using distinct a_p and b_q.\n    # We are looking for the maximum k such that `can_form_k_pairs(S)` is true for some S >= x.\n    # This is not quite right. We need to maximize the number of participants who score >= Vasya's score.\n\n    # Let's consider the possible scores Vasya can get.\n    # Vasya can get any score `a_i + b_j` such that `a_i + b_j >= x`.\n    # For each such possible score `S = a_i + b_j`:\n    #   1. Vasya gets score S.\n    #   2. The remaining `n-1` 'a's and `n-1` 'b's are paired up.\n    #   3. We want to maximize the number of these `n-1` pairs that also have a sum >= S.\n    #   4. The worst rank for Vasya would be `1 + (number of other pairs with sum >= S)`.\n    # This is still too complex.\n\n    # The key insight for the worst case often involves a specific pairing strategy.\n    # To maximize the number of people who score >= Vasya's score:\n    # Vasya should be assigned a pair (a_i, b_j) such that a_i + b_j >= x.\n    # The remaining (n-1) 'a's and (n-1) 'b's are assigned to other (n-1) participants.\n    # We want to maximize the number of participants (including Vasya) whose score is >= Vasya's chosen score.\n\n    # Consider the sorted lists `a` and `b`.\n    # Let's try to match `a_i` with `b_{n-1-i}`. This maximizes the sums.\n    # Or `a_i` with `b_i`. This gives a mix.\n\n    # Let's count how many participants can achieve a score of at least S.\n    # This is the maximum `k` such that we can find `k` distinct `a_i`s and `k` distinct `b_j`s\n    # to form `k` pairs `(a_i, b_j)` with `a_i + b_j >= S`.\n    # This is a known greedy matching problem.\n    # Sort `a` in ascending order. Sort `b` in descending order.\n    # Iterate `i` from `0` to `n-1`. For each `a_i`, try to match it with `b_j`.\n    # If `a_i + b_j >= S`, then we can form a pair.\n    # To maximize the number of pairs, we use a two-pointer approach:\n    # Sort `a` ascending, `b` ascending.\n    # `count = 0`, `j = n-1` (pointer for `b`).\n    # For `i` from `0` to `n-1` (pointer for `a`):\n    #   While `j >= 0` and `a[i] + b[j] >= S`:\n    #     `j -= 1`\n    #   If `j < n-1` (meaning we found at least one `b_j` for `a_i`):\n    #     `count += 1`\n    #     `j -= 1` (This logic is wrong. This is for unique pairs.)\n\n    # Correct logic for `can_form_k_pairs(S)`:\n    # Sort `a` ascending. Sort `b` ascending.\n    # `count = 0`\n    # `j = 0` (pointer for `b`)\n    # For `i` from `0` to `n-1` (pointer for `a`):\n    #   While `j < n` and `a[i] + b[j] < S`:\n    #     `j += 1`\n    #   If `j < n`:\n    #     `count += 1`\n    #     `j += 1`\n    # Return `count`. This counts the maximum number of pairs (a_i, b_j) with a_i + b_j >= S,\n    # where each a_i and b_j is used at most once.\n    # This `can_form_k_pairs(S)` function actually counts how many participants can score >= S.\n\n    # Now, Vasya's worst rank.\n    # Vasya is guaranteed to score at least `x`.\n    # We want to find the maximum `k` such that `k` participants (including Vasya) can score at least `S`,\n    # where `S` is some score Vasya could have achieved (i.e., `S >= x`).\n    # And then we want to maximize `k`.\n\n    # The possible values for `S` are `a_i + b_j`.\n    # The range of `S` is `[0, 2*10^5]`.\n    # We can binary search for the minimum possible score `S_min_vasya` that Vasya could achieve,\n    # such that `can_form_k_pairs(S_min_vasya)` is maximized.\n    # This is not quite right. We need to find the maximum `k` such that there exists some `S >= x`\n    # for which `can_form_k_pairs(S)` returns `k`.\n\n    # Let's consider the scores `a_i + b_j`.\n    # We are looking for the minimum possible score `S_vasya` (where `S_vasya >= x`)\n    # such that the number of participants who can achieve a score of at least `S_vasya` is maximized.\n    # This is the `can_form_k_pairs(S_vasya)` value.\n\n    # Let's find the maximum number of participants `k` that can achieve a score of at least `S`.\n    # This `k` is a monotonically decreasing function of `S`.\n    # We are guaranteed that at least one pair `a_i + b_j >= x` exists.\n    # So `can_form_k_pairs(x)` will be at least 1.\n\n    # The worst rank for Vasya is the maximum `k` such that we can find `k` participants (including Vasya)\n    # who all score at least `S`, where `S` is some score Vasya could have gotten (S >= x).\n    # To maximize this `k`, Vasya should aim for the lowest possible score `S` (but >= x).\n    # If Vasya takes `a_i` and `b_j` such that `a_i + b_j = S` (and `S >= x`),\n    # then the worst rank for him is `can_form_k_pairs(S)`.\n    # We want to find `max_{S >= x, S = a_i + b_j} (can_form_k_pairs(S))`.\n    # This is still not quite right. `S` doesn't have to be `a_i + b_j`.\n    # Vasya's score could be `S_vasya`. The other `k-1` people score `S_other_1, ..., S_other_{k-1}`.\n    # All `S_vasya, S_other_1, ..., S_other_{k-1}` must be >= `S_vasya`.\n\n    # The correct interpretation for worst rank:\n    # Vasya is assigned some `a_i` and `b_j` such that `a_i + b_j >= x`.\n    # Let Vasya's score be `S_V = a_i + b_j`.\n    # The remaining `n-1` `a` values and `n-1` `b` values are assigned to the other `n-1` participants.\n    # We want to maximize the number of participants (including Vasya) whose score is >= `S_V`.\n    # This implies we want to choose `a_i, b_j` (for Vasya) and the remaining pairings\n    # such that `S_V` is as small as possible (but >= x) AND the number of participants whose score is >= `S_V` is maximized.\n\n    # Let's use a fixed-point idea.\n    # Suppose Vasya's score is `S_V`.\n    # We want to find the maximum number of pairs `(a_p, b_q)` such that `a_p + b_q >= S_V`.\n    # This is `can_form_k_pairs(S_V)`.\n    # So, we want to find `S_V` such that `S_V >= x` and `can_form_k_pairs(S_V)` is maximized.\n    # Since `can_form_k_pairs(S)` is non-increasing with `S`, we want to choose the smallest `S_V >= x`\n    # that Vasya can possibly achieve.\n    # The smallest score Vasya can achieve is `x` (if `x` can be formed by some `a_i + b_j`).\n    # Or more generally, the smallest `a_i + b_j` that is `>= x`.\n\n    # This is still not quite right. The problem states \"If two or more participants have got the same number of points,\n    # it's up to the jury to assign places to them according to their choice.\"\n    # This means if Vasya scores S, and k people score > S, and m people score = S,\n    # Vasya's worst rank is k + m + 1. (Here, k+m people are ranked better or equal to Vasya).\n    # So we want to maximize `k + m`.\n\n    # Let's try to count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= S.\n    # This is the `can_form_k_pairs(S)` function from above.\n    # The `worst_rank` will be `can_form_k_pairs(S_min_vasya)`.\n    # What is `S_min_vasya`?\n    # It is the minimum `S` such that `S >= x` and `S` can be formed by some `a_i + b_j` using *available* `a` and `b` lists.\n    # But all `a` and `b` are available. So `S_min_vasya` is the smallest `a_i + b_j` that is `>= x`.\n\n    # Let's verify this.\n    # Suppose `S_min_vasya = min { a_i + b_j | a_i + b_j >= x }`.\n    # Vasya is assigned this score.\n    # Then the number of participants who score at least `S_min_vasya` is `can_form_k_pairs(S_min_vasya)`.\n    # Can we make Vasya's rank even worse?\n    # If Vasya picks a higher score `S_V' > S_min_vasya`, then `can_form_k_pairs(S_V') <= can_form_k_pairs(S_min_vasya)`\n    # because `can_form_k_pairs` is non-increasing. So his rank would be better or equal.\n    # So the maximum rank is achieved when Vasya takes `S_min_vasya`.\n\n    # How to calculate `S_min_vasya`?\n    # This is simply `x` if `x` can be formed.\n    # Or, it's the smallest `a_i + b_j` that is `>= x`.\n    # We can find this by iterating through `a_i` and for each `a_i`, finding the smallest `b_j` such that `a_i + b_j >= x`.\n    # `min_score_vasya = infinity`\n    # For `a_val` in `a`:\n    #   Find `b_val` in `b` such that `a_val + b_val >= x`.\n    #   `target = x - a_val`\n    #   Use `bisect_left` on sorted `b` to find `b_idx` for `target`.\n    #   If `b_idx < n`, then `b[b_idx]` is the smallest `b_val` such that `a_val + b_val >= x`.\n    #   `min_score_vasya = min(min_score_vasya, a_val + b[b_idx])`.\n    # This gives the smallest possible score Vasya can get while satisfying `a_i + b_j >= x`.\n    # But this is not correct. The problem guarantees `a_i + b_j >= x` for *some* `i, j`.\n    # It does not mean Vasya has to achieve this minimum possible sum.\n    # The problem implies Vasya is one of the `n` participants.\n    # The teacher knows Vasya got AT LEAST `x` points.\n    # The teacher wants to know the best and worst rank Vasya *could have* won.\n    # This means we need to consider all possible pairings of `a` and `b` to `n` participants,\n    # and for each such pairing, identify which participant is Vasya, and then determine his rank.\n\n    # This is the crucial part: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This implies Vasya can be *any* of the `n` participants.\n    # And Vasya's score is `S_V >= x`.\n    # And the other `n-1` participants are assigned the remaining scores.\n\n    # For worst rank:\n    # Vasya is assigned some `a_i` and `b_j` such that `a_i + b_j >= x`.\n    # Let this score be `S_V`.\n    # The remaining `n-1` `a` values and `n-1` `b` values are assigned to other participants.\n    # We want to maximize the number of participants whose score is >= `S_V`.\n    # This means we want to maximize `k` such that we can find `k` pairs `(a_p, b_q)`\n    # (using distinct `a`s and `b`s) where each `a_p + b_q >= S_V`.\n    # And we want to pick `S_V` such that `S_V >= x` and this `k` is maximized.\n    # Since `k` is non-increasing with `S_V`, we want the smallest `S_V` such that `S_V >= x`.\n    # The smallest possible score Vasya could have is `x`.\n    # If Vasya scores `x`, then his worst rank is `can_form_k_pairs(x)`.\n    # Is it always possible for Vasya to score exactly `x`? No.\n    # For example, if `x=5`, `a=[1,2]`, `b=[1,2]`. No `a_i+b_j=5`.\n    # But `a_i+b_j >= x` is guaranteed for some `i,j`.\n    # So Vasya must have scored at least `x`.\n    # The smallest score Vasya *could* have is `min_possible_vasya_score = min(a_i + b_j)` over all `i,j` such that `a_i + b_j >= x`.\n    # We can find this `min_possible_vasya_score` efficiently.\n    # Sort `a` and `b`.\n    # `min_score = float('inf')`\n    # For `val_a` in `a`:\n    #   `target_b = x - val_a`\n    #   `idx = bisect_left(b, target_b)`\n    #   If `idx < n`:\n    #     `min_score = min(min_score, val_a + b[idx])`\n    # This `min_score` is the lowest score Vasya could have achieved while meeting the `x` criteria.\n    # Let `S_worst_vasya = min_score`.\n    # Then the worst rank is `can_form_k_pairs(S_worst_vasya)`.\n\n    from bisect import bisect_left\n\n    # Function to calculate maximum number of pairs (a_i, b_j) such that a_i + b_j >= S\n    def count_pairs_ge_S(S, arr1, arr2):\n        count = 0\n        j = n - 1  # Pointer for arr2 (b)\n        for i in range(n):  # Pointer for arr1 (a)\n            while j >= 0 and arr1[i] + arr2[j] >= S:\n                j -= 1\n            # After the loop, all b[0...j] are too small for a[i]\n            # All b[j+1...n-1] are large enough for a[i]\n            # We can form (n-1-j) pairs with a[i]\n            # This is not the correct greedy approach for maximum *disjoint* pairs.\n\n        # Correct greedy approach for maximum disjoint pairs:\n        # Sort arr1 ascending, arr2 ascending.\n        # Use two pointers.\n        # `count = 0`\n        # `j = 0` (pointer for `arr2`)\n        # For `i` from `0` to `n-1` (pointer for `arr1`):\n        #   While `j < n` and `arr1[i] + arr2[j] < S`:\n        #     `j += 1`\n        #   If `j < n`:  # Found a suitable `arr2[j]` for `arr1[i]`\n        #     `count += 1`\n        #     `j += 1` # Move to next `arr2` element for the next `arr1` element\n        # Return `count`\n        # Example: a=[1,2,3], b=[1,2,3], S=4\n        # i=0, a[0]=1:\n        #   j=0, b[0]=1, 1+1=2 < 4 -> j=1\n        #   j=1, b[1]=2, 1+2=3 < 4 -> j=2\n        #   j=2, b[2]=3, 1+3=4 >= 4 -> count=1, j=3\n        # i=1, a[1]=2:\n        #   j=3, j<n is false. Loop ends.\n        # Returns 1. This is correct. (1,3) is the only pair >=4.\n        # What if a=[1,1,1], b=[1,1,1], S=2.\n        # i=0, a[0]=1:\n        #   j=0, b[0]=1, 1+1=2 >= 2 -> count=1, j=1\n        # i=1, a[1]=1:\n        #   j=1, b[1]=1, 1+1=2 >= 2 -> count=2, j=2\n        # i=2, a[2]=1:\n        #   j=2, b[2]=1, 1+1=2 >= 2 -> count=3, j=3\n        # Returns 3. This is correct. (1,1), (1,1), (1,1) are 3 pairs.\n\n        count = 0\n        j = 0\n        for i in range(n):\n            while j < n and arr1[i] + arr2[j] < S:\n                j += 1\n            if j < n:\n                count += 1\n                j += 1\n        return count\n\n    # Calculate S_worst_vasya\n    min_score_vasya_potential = float('inf')\n    for val_a in a:\n        target_b = x - val_a\n        idx = bisect_left(b, target_b)\n        if idx < n:\n            min_score_vasya_potential = min(min_score_vasya_potential, val_a + b[idx])\n\n    # The problem guarantees that Vasya was present and there exist i, j such that a_i + b_j >= x.\n    # So min_score_vasya_potential will be a finite value.\n\n    worst_rank = count_pairs_ge_S(min_score_vasya_potential, a, b)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 6940,
        "thoughts_token_count": 0
    }
}