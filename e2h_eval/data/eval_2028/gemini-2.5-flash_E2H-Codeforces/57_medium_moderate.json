{
    "start": 1758294744.27997,
    "end": 1758294864.6032286,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:14 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Finding Vasya's Best and Worst Olympiad Ranks**\n\nAlright, let's break this down. My goal is to figure out the absolute best and worst places Vasya could land in this Olympiad, given we only have the scores, not the names attached.  We know:\n\n*   `n`: The total number of participants.\n*   `x`: Vasya's minimum total score.\n*   `a`: A list of scores from tour 1.\n*   `b`: A list of scores from tour 2.\n\nWe need to consider every possible pairing of scores from tours 1 and 2, which affects the ranking. The jury’s choice on ties adds another layer of complexity.\n\n**Best Possible Rank:**  To be the best, Vasya needs to get the highest score possible *and* make sure no one else can match or beat it. I'm thinking:\n\n1.  **Maximize Vasya's score:** Find a pair `(a_i, b_j)` where `a_i + b_j` is at least `x` and as big as possible. Sort `a` in descending order, find the smallest `b` that results in a sum bigger than `x`.\n2.  If it is possible to achieve this maximum sum for Vasya, the key is to ensure the rest of the participants get sums that are less than or equal to this maximum score.\n3.  Given the constraints, if this max is greater than or equal to `x`, Vasya should be ranked 1, so the best rank is always 1.\n\n**Worst Possible Rank:**  To be the worst, I need to minimize Vasya's score (but still make sure it's at least `x`) and, at the same time, make it so that as many people as possible score higher or the same as him. To achieve this:\n\n1.  **Minimize Vasya's Score:** Find the smallest possible sum `(a_i, b_j)` such that `a_i + b_j` is still greater than or equal to `x`. This is the minimum achievable score `S_V`.\n2.  **Maximize Other Scores:** Pair up the remaining scores in such a way that as many participants as possible achieve a score greater than `S_V` or equal to `S_V`. Sorting and greedy pair matching will be critical here. It seems that sorting helps.\n\nThe critical thing is to play with all possible combinations to maximize rank and maximize the rest. This involves some algorithmic manipulation.  I'll need to work on how to pair the scores to maximize the number of people above or equal to Vasya. The answer appears to be dependent on the relationship between `x`, `max(a) + max(b)`, `max(a) + min(b)`, and the overall distribution of scores.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given `n` participants, a minimum total score `x` for Vasya, and two lists of scores `a` and `b` for Tour 1 and Tour 2 respectively. The scores in `a` and `b` are not associated with specific participants. We are guaranteed that Vasya participated and his total score is at least `x`.\n\nThe ranking rules are:\n1. Participants are sorted by the sum of points (Tour 1 + Tour 2) in decreasing order.\n2. If two or more participants have the same total points, the jury can assign places arbitrarily among them.\n\nThis \"jury's choice\" rule is key:\n- For the best rank, if Vasya has score `S_V` and `k` other people also have `S_V`, and `p` people have `S_P > S_V`, Vasya can be assigned rank `p+1`.\n- For the worst rank, if Vasya has score `S_V` and `k` other people also have `S_V`, and `p` people have `S_P > S_V`, Vasya can be assigned rank `p+k+1`.\n\nThe crucial insight is that since the scores `a` and `b` are unassigned, we can choose any `a_i` and any `b_j` to be Vasya's scores, as long as `a_i + b_j \\ge x`. The remaining `n-1` scores from `a` and `n-1` scores from `b` are then assigned to the other `n-1` participants. We can also choose how these remaining scores are paired to achieve the best or worst outcome for Vasya.\n\n---\n\n### Best Possible Rank for Vasya\n\nTo achieve the best rank, Vasya wants to maximize his own score and minimize the scores of others.\nThe maximum possible score any participant can achieve is `max(a) + max(b)`.\nThe problem guarantees that \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\". This implies that `max(a) + max(b)` must be greater than or equal to `x`, because it's the largest possible sum.\nSo, Vasya can choose to take the `max(a)` score from Tour 1 and `max(b)` score from Tour 2. His total score would be `S_V = max(a) + max(b)`. This score is guaranteed to be `>= x`.\n\nAfter Vasya takes `max(a)` and `max(b)`, the remaining `n-1` scores from `a` and `n-1` scores from `b` are assigned to the other `n-1` participants. No matter how these remaining scores are paired, any other participant's total score will be less than or equal to `S_V`. (For example, if `a` and `b` are sorted in descending order, Vasya takes `a[0]` and `b[0]`. The maximum score for any other participant would be at most `a[1] + b[1]`, which is less than or equal to `a[0] + b[0]`.)\n\nSince Vasya can achieve the highest possible score `S_V`, and no other participant can get a strictly higher score, by the jury's choice rule, Vasya can be ranked 1st among those with score `S_V`.\nTherefore, the best possible rank for Vasya is always **1**.\n\n---\n\n### Worst Possible Rank for Vasya\n\nTo achieve the worst rank, Vasya wants to minimize his own score (but still `S_V \\ge x`), and maximize the scores of other participants.\nThis means we need to find a permutation of scores such that:\n1. Vasya's score `S_V` is as low as possible, but `S_V \\ge x`.\n2. The maximum number of other participants get scores strictly greater than `S_V`.\n3. Among those with score equal to `S_V`, Vasya is placed last.\n\nLet's sort both score lists `a` and `b` in ascending order.\n`a = [a_0, a_1, ..., a_{n-1}]`\n`b = [b_0, b_1, ..., b_{n-1}]`\n\nWe want to find a pairing `(a_i, b_j)` for Vasya such that `a_i + b_j \\ge x`, and this `a_i + b_j` is as small as possible. This `a_i + b_j` will be Vasya's score `S_V`.\nFor any chosen `a_i` for Vasya, the smallest `b_j` such that `a_i + b_j \\ge x` can be found using binary search on `b`. Specifically, we need `b_j \\ge x - a_i`. We look for the smallest `b_j` satisfying this condition.\n\nLet `S_V` be a candidate score for Vasya. We need to determine his rank if he achieves `S_V`.\nTo maximize the number of people with scores `> S_V` or `= S_V`, we should pair the remaining `n-1` `a` scores and `n-1` `b` scores to maximize their sums. This is achieved by pairing the largest remaining `a` with the largest remaining `b`, the second largest `a` with the second largest `b`, and so on.\nHowever, we don't know which `a_i` and `b_j` Vasya took. We need to consider all possible pairings for all `n` participants simultaneously.\n\nA standard way to maximize the number of pairs `a_i + b_j > S` is to sort `a` and `b` (one ascending, one descending). This is not quite it.\n\nConsider the problem from the perspective of counting how many participants can achieve a score `S_k` such that `S_k \\ge S_V`.\nTo maximize Vasya's rank, we want to maximize the number of people who score `S_k \\ge S_V` (including Vasya).\nLet `a` be sorted in ascending order and `b` be sorted in descending order.\n`a = [a_0, a_1, ..., a_{n-1}]`\n`b = [b_{n-1}, b_{n-2}, ..., b_0]`\nIf we pair `a_i` with `b_i`, the sums `a_i + b_i` are formed. This specific pairing strategy (one sorted ascending, one descending) tends to equalize the sums, making them as close as possible.\n\nLet's rethink: We are looking for a permutation `p` such that Vasya (say, participant `k`) has score `a_k + b_{p[k]} \\ge x`, and his rank is maximized.\nThe number of participants (including Vasya) whose score is `S_k \\ge S_V` contributes to Vasya's worst rank.\nLet `cnt(S_V)` be the maximum number of participants (including Vasya) who can achieve a total score of at least `S_V` for *some* valid pairing of all `n` scores.\nIf Vasya's score is `S_V`, and `cnt(S_V)` participants can score `S_k \\ge S_V`, then Vasya's worst rank is `cnt(S_V)`.\n\nHow to calculate `cnt(S_V)` for a given `S_V`?\nSort `a` in ascending order and `b` in ascending order.\nWe want to find the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j \\ge S_V`.\nThis can be found using a two-pointer approach.\nInitialize `count = 0`. Use a pointer `ptr_a` for `a` (starting from `a_0`) and `ptr_b` for `b` (starting from `b_{n-1}`, the largest score).\nWhile `ptr_a < n` and `ptr_b >= 0`:\n  If `a[ptr_a] + b[ptr_b] >= S_V`:\n    We can form a pair that meets the criterion. Increment `count`, move `ptr_a` forward, and `ptr_b` backward.\n  Else (`a[ptr_a] + b[ptr_b] < S_V`):\n    `a[ptr_a]` is too small to form a sum `>= S_V` with `b[ptr_b]` (the largest available `b`). Since `a` is sorted ascending, `a[ptr_a]` won't work with any smaller `b` either. So `a[ptr_a]` cannot be part of a pair summing to `>= S_V` if `b[ptr_b]` is already too small. This logic is faulty. If `a[ptr_a]` is too small with `b[ptr_b]`, we should try a larger `a`.\nThe correct two-pointer approach for this specific problem (maximizing pairs `a_i + b_j >= S_V`):\nSort `a` ascending. Sort `b` ascending.\n`count = 0`\n`left = 0` (pointer for `a`)\n`right = n - 1` (pointer for `b`)\nWhile `left < n` and `right >= 0`:\n  If `a[left] + b[right] >= S_V`:\n    This pair `(a[left], b[right])` works. We use them. Increment `count`. Move `left` forward (`left += 1`). Move `right` backward (`right -= 1`).\n  Else (`a[left] + b[right] < S_V`):\n    `a[left]` is too small to form `S_V` with `b[right]`. Since `b[right]` is the largest available `b`, `a[left]` cannot form `S_V` with any other `b` (which would be smaller). So `a[left]` cannot be used to form a sum `>= S_V` with any currently available `b`. We must discard `a[left]` and try `a[left+1]`. Move `left` forward (`left += 1`). (Wait, this is if we want to maximize the number of pairs. If we want to maximize pairs `a_i + b_j < S_V`, we would move `right`.)\n\nLet's verify the two-pointer logic:\nWe want to find the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j \\ge S_V`.\nSort `a` ascending. Sort `b` ascending.\n`count = 0`\n`ptr_a = 0`\n`ptr_b = n - 1`\nWhile `ptr_a < n` and `ptr_b >= 0`:\n  If `a[ptr_a] + b[ptr_b] >= S_V`:\n    We found a valid pair. We use `a[ptr_a]` and `b[ptr_b]`. Increment `count`. `ptr_a++`, `ptr_b--`.\n  Else (`a[ptr_a] + b[ptr_b] < S_V`):\n    `a[ptr_a]` is too small to combine with `b[ptr_b]` (the largest available `b`) to reach `S_V`. So `a[ptr_a]` cannot combine with *any* `b_k` (where `k <= ptr_b`) to reach `S_V`. Therefore, `a[ptr_a]` cannot be part of any valid pair with the remaining `b`s. We must discard `a[ptr_a]` and try the next `a`. `ptr_a++`.\nThis greedy strategy works because if `a[ptr_a]` is too small for `b[ptr_b]`, it's too small for any smaller `b`. If `a[ptr_a]` works with `b[ptr_b]`, we use them to maximize count. This is a standard greedy approach for maximum pairs with a condition.\n\nThe minimum possible score Vasya could get (while still `S_V \\ge x`) is `S_min_V`.\nThe maximum possible score Vasya could get is `S_max_V = max(a) + max(b)`.\nThe possible values for `S_V` range from `x` to `S_max_V`.\nWe can binary search for the minimum `S_V` that Vasya could achieve such that `cnt(S_V)` is maximized.\nThis is not quite right. We want to find `S_V` that Vasya could achieve such that `cnt(S_V)` is maximized.\nThe `cnt(S)` function is monotonically non-increasing as `S` increases.\nSo we want to find the smallest `S_V` (such that Vasya can achieve it) that maximizes `cnt(S_V)`.\nThis is equivalent to finding the maximum `cnt(S_V)` over all possible `S_V` that Vasya could achieve.\n\nLet's sort `a` in ascending order and `b` in ascending order.\nWe are looking for the maximum possible value of `k` such that there exist `k` pairs `(a_{i_1}, b_{j_1}), ..., (a_{i_k}, b_{j_k})` satisfying `a_{i_p} + b_{j_p} \\ge S_V` for all `p`, and one of these pairs is Vasya's (`a_{i_q} + b_{j_q} = S_V` and `S_V \\ge x`).\nThe `cnt(S_V)` function gives the maximum number of participants whose score is `>= S_V`.\nVasya's worst rank will be `cnt(S_V)`. We want to maximize this `cnt(S_V)`.\n\nConsider all possible scores `S_V = a_i + b_j` for all `i, j`. This is `N^2` values. Too many.\nThe values of `S_V` can range from `0` to `2 * 10^5`.\nWe can iterate through all possible `a_i` for Vasya. For each `a_i`, Vasya should pick the smallest `b_j` such that `a_i + b_j \\ge x`.\nLet `a` be sorted ascending.\nFor each `a_i`:\n  Find `b_j` using binary search (or `bisect_left`) such that `b_j \\ge x - a_i`.\n  If such `b_j` exists, let `S_V = a_i + b_j`.\n  Then calculate `current_worst_rank = count_ge_S_V(S_V)` using the two-pointer method described above.\n  The maximum `current_worst_rank` found over all valid `S_V` will be the answer.\n\nThis approach would be:\n1. Sort `a` and `b` in ascending order.\n2. Initialize `max_worst_rank = 0`.\n3. For each `a_idx` from `0` to `n-1`:\n    a. Calculate `required_b = x - a[a_idx]`.\n    b. Find the smallest `b_val` in `b` such that `b_val >= required_b`. Use `bisect_left(b, required_b)`. Let this index be `b_idx`.\n    c. If `b_idx < n` (meaning such a `b_val` exists):\n        i. Let `S_V = a[a_idx] + b[b_idx]`.\n        ii. Calculate `current_rank = count_ge_S_V(S_V)` using the two-pointer method.\n        iii. Update `max_worst_rank = max(max_worst_rank, current_rank)`.\n4. Print `max_worst_rank`.\n\nThe `count_ge_S_V(S_V)` function takes `O(N)` time.\nThere are `N` choices for `a_idx`.\nSo total time complexity `O(N log N + N * N) = O(N^2)`.\nWith `N = 10^5`, `N^2` is `10^{10}`, which is too slow.\n\nWe need a faster way to find `max_worst_rank`.\nNotice that `count_ge_S_V(S_V)` can be computed efficiently.\nThe `count_ge_S_V` function is monotonic: as `S_V` increases, `count_ge_S_V(S_V)` decreases or stays the same.\nWe are looking for the maximum `count_ge_S_V(S_V)` over all `S_V` that Vasya can achieve.\nThis means we want to find `S_V` (which Vasya can achieve) such that `S_V` is as small as possible, because a smaller `S_V` tends to result in a larger `count_ge_S_V(S_V)`.\nHowever, we also need to ensure `S_V >= x`.\n\nLet's fix `a` sorted ascending and `b` sorted ascending.\nWe iterate `ptr_a` from `0` to `n-1`. For each `a[ptr_a]`, we want to find the smallest `b[ptr_b]` such that `a[ptr_a] + b[ptr_b] >= x`.\nThis `b[ptr_b]` can be found using `bisect_left(b, x - a[ptr_a])`. Let this be `k`.\nSo, for `a[ptr_a]`, Vasya's score could be `a[ptr_a] + b[k]`.\nWe need to compute `count_ge_S_V(a[ptr_a] + b[k])`.\n\nConsider the two-pointer approach for `count_ge_S_V(S_V)` again.\n`a` sorted ascending, `b` sorted ascending.\n`ptr_a_count = 0` (for `a` in `count_ge_S_V`)\n`ptr_b_count = n - 1` (for `b` in `count_ge_S_V`)\n`count = 0`\nWhile `ptr_a_count < n` and `ptr_b_count >= 0`:\n  If `a[ptr_a_count] + b[ptr_b_count] >= S_V`:\n    `count++`; `ptr_a_count++`; `ptr_b_count--`;\n  Else:\n    `ptr_a_count++`;\n\nLet's try to combine the iteration for `a_i` and the two-pointer `count_ge_S_V` calculation.\nSort `a` ascending, `b` ascending.\n`max_worst_rank = 0`\n`ptr_b_for_S_V = n - 1` (This pointer will help find the smallest `b_j` such that `a_i + b_j >= x`)\n`ptr_b_for_count = n - 1` (This pointer will be used in the `count_ge_S_V` logic)\n\nFor `i` from `0` to `n-1` (iterating through `a_i` for Vasya's first tour score):\n  While `ptr_b_for_S_V >= 0` and `a[i] + b[ptr_b_for_S_V] >= x`:\n    `ptr_b_for_S_V--`\n  // After this loop, `ptr_b_for_S_V + 1` is the smallest index `j` such that `a[i] + b[j] >= x`.\n  // If `ptr_b_for_S_V + 1 == n`, it means no `b_j` works for `a[i]`. This shouldn't happen based on guarantee.\n  // So, Vasya's score could be `S_V = a[i] + b[ptr_b_for_S_V + 1]`.\n  // Now we need to calculate `count_ge_S_V(S_V)`.\n\nThis `ptr_b_for_S_V` logic is for finding the smallest possible `S_V` for a given `a[i]`.\nThe `ptr_b_for_S_V` moves from `n-1` down to `0`.\nFor `a[0]`, it finds some `b[k_0]`. `S_V_0 = a[0] + b[k_0]`.\nFor `a[1]`, it finds some `b[k_1]`. `S_V_1 = a[1] + b[k_1]`.\nSince `a[1] >= a[0]`, `x - a[1] <= x - a[0]`. So `k_1` will be less than or equal to `k_0`. `ptr_b_for_S_V` will keep decreasing.\n\nThis can be done with a single pass.\nSort `a` ascending. Sort `b` ascending.\n`max_worst_rank = 0`\n`ptr_b = n - 1` // Pointer for `b` in the `count_ge_S_V` logic\n`ptr_a_for_count = 0` // Pointer for `a` in the `count_ge_S_V` logic\n\nFor `i` from `0` to `n-1` (this `i` represents Vasya's `a` score, `a[i]`):\n  // Find the smallest `b_j` such that `a[i] + b_j >= x`.\n  // We can use `bisect_left` here for `b` for each `a[i]`.\n  // `idx_b_vasya = bisect_left(b, x - a[i])`\n  // If `idx_b_vasya == n`, this `a[i]` cannot form a score `>= x`. This case is covered by the problem guarantee.\n  // `S_V = a[i] + b[idx_b_vasya]`\n\n  // This `S_V` is a candidate for Vasya's score.\n  // Now we need to count how many pairs `(a_k, b_l)` can sum up to `>= S_V`.\n  // This is `count_ge_S_V(S_V)`.\n  // The two-pointer logic for `count_ge_S_V(S_V)`:\n  //   `current_count = 0`\n  //   `l = 0`, `r = n-1`\n  //   while `l < n` and `r >= 0`:\n  //     if `a[l] + b[r] >= S_V`: `current_count++`; `l++`; `r--`;\n  //     else: `l++`;\n  //   `max_worst_rank = max(max_worst_rank, current_count)`\n\nThis is still `O(N log N)` for sorting, then `N` iterations, each with `O(log N)` for `bisect_left` and `O(N)` for `count_ge_S_V`. Total `O(N^2)`.\n\nThe crucial optimization for `count_ge_S_V(S_V)`:\nWhen `i` (Vasya's `a` index) increases, `S_V` (Vasya's score) typically increases or stays the same.\nAs `S_V` increases, `count_ge_S_V(S_V)` decreases or stays the same.\nWe can use a sliding window / two-pointer approach for `count_ge_S_V` across the outer loop.\nLet `a` be sorted ascending. `b` be sorted ascending.\n`ptr_b_vasya_min_idx = n - 1` // This pointer tracks the minimum `b` index for `a[i]` to reach `x`.\n`worst_rank = 0`\n`count_ptr_b = n - 1` // Pointer for `b` in the count_ge_S_V calculation\n`current_count = 0`\n\nFor `i` from `0` to `n-1`: (This `i` is for `a[i]`, which Vasya uses)\n  // `a[i]` is Vasya's score from tour 1.\n  // Find the smallest `b[j]` such that `a[i] + b[j] >= x`.\n  // `ptr_b_vasya_min_idx` will be non-increasing.\n  while `ptr_b_vasya_min_idx >= 0` and `a[i] + b[ptr_b_vasya_min_idx] >= x`:\n    `ptr_b_vasya_min_idx--`\n  // Now `ptr_b_vasya_min_idx + 1` is the index of the smallest `b` that works with `a[i]`.\n  // If `ptr_b_vasya_min_idx + 1 == n`, no `b` works for `a[i]` to reach `x`. Skip this `a[i]`.\n  if `ptr_b_vasya_min_idx + 1 < n`:\n    `vasya_score = a[i] + b[ptr_b_vasya_min_idx + 1]`\n\n    // Now, calculate `count_ge_S_V(vasya_score)` efficiently.\n    // The `current_count` and `count_ptr_b` from previous iteration are for a potentially lower `vasya_score`.\n    // As `vasya_score` increases (or stays same), `current_count` should decrease (or stay same).\n    // The `count_ptr_b` should stay at or move left.\n    // `current_count` is the number of pairs `(a[k], b[l])` such that `a[k] + b[l] >= vasya_score`.\n    // We need to re-evaluate `current_count` for each `vasya_score`.\n    // This is where the `O(N)` part comes from.\n\nLet's try a different perspective for the worst rank.\nWe want to maximize the number of pairs `(a_i, b_j)` whose sum is at least `S_V`, where `S_V` is Vasya's score.\nAnd Vasya's score `S_V` must be at least `x`.\nSort `a` in ascending order. Sort `b` in ascending order.\nIterate `i` from `0` to `n-1` (this `i` is for `a[i]`, Vasya's score from tour 1).\nFor each `a[i]`, Vasya needs to find a `b[j]` such that `a[i] + b[j] >= x`.\nTo make `S_V` as small as possible (to maximize `count_ge_S_V(S_V)`), Vasya should pick the smallest `b[j]` that satisfies the condition.\nLet `j_min` be the index such that `b[j_min]` is the smallest value `b_k` satisfying `b_k >= x - a[i]`.\nThis `j_min` can be found using `bisect_left(b, x - a[i])`.\nIf `j_min == n`, then `a[i]` cannot be used by Vasya to get `x` points. (This case is guaranteed not to happen for *some* `a_i, b_j`).\nSo Vasya's score `S_V = a[i] + b[j_min]`.\n\nNow, for this `S_V`, we want to find `count_ge_S_V(S_V)`.\nThis can be computed with two pointers `l=0, r=n-1` on sorted `a` and `b`.\nThe `l` pointer iterates `a`, `r` iterates `b` downwards.\n`count = 0`\nWhile `l < n` and `r >= 0`:\n  If `a[l] + b[r] >= S_V`:\n    `count += 1`\n    `l += 1`\n    `r -= 1`\n  Else:\n    `l += 1`\nReturn `count`.\n\nThis `O(N)` calculation for `count_ge_S_V` inside a loop of `N` iterations is `O(N^2)`.\nThis is the part that needs to be optimized.\n\nConsider the values `a[i] + b[j]` that Vasya could achieve. There are `N` values for `a[i]`.\nFor each `a[i]`, `S_V = a[i] + b[bisect_left(b, x - a[i])]`.\nWe need to find `max_{i} (count_ge_S_V(a[i] + b[bisect_left(b, x - a[i])]))`.\nThis is a standard pattern for `N log N` solutions.\nThe `count_ge_S_V(S_V)` function is monotonic.\nThe `S_V` values generated are also somewhat monotonic. As `i` increases, `a[i]` increases. `x - a[i]` decreases. `bisect_left(b, x - a[i])` index decreases or stays the same. So `b[bisect_left(b, x - a[i])]` decreases or stays the same. The sum `a[i] + b[bisect_left(b, x - a[i])]` could increase or decrease.\n\nLet's trace `count_ge_S_V` for different `S_V`.\n`a = [3,4,4,4,5,6]`\n`b = [0,3,4,4,6,8]`\n`x = 7`\n\n`i=0, a[0]=3`: `x - a[0] = 4`. `bisect_left(b, 4)` is index 2 (`b[2]=4`).\n  `S_V = a[0] + b[2] = 3 + 4 = 7`.\n  `count_ge_S_V(7)`:\n    `l=0, r=5`: `a[0]+b[5]=3+8=11 >= 7`. `count=1, l=1, r=4`.\n    `l=1, r=4`: `a[1]+b[4]=4+6=10 >= 7`. `count=2, l=2, r=3`.\n    `l=2, r=3`: `a[2]+b[3]=4+4=8 >= 7`. `count=3, l=3, r=2`.\n    `l=3, r=2`: `a[3]+b[2]=4+4=8 >= 7`. `count=4, l=4, r=1`.\n    `l=4, r=1`: `a[4]+b[1]=5+3=8 >= 7`. `count=5, l=5, r=0`.\n    `l=5, r=0`: `a[5]+b[0]=6+0=6 < 7`. `l=6`.\n    Loop ends. `count = 5`. `worst_rank = 5`.\n\n`i=1, a[1]=4`: `x - a[1] = 3`. `bisect_left(b, 3)` is index 1 (`b[1]=3`).\n  `S_V = a[1] + b[1] = 4 + 3 = 7`.\n  `count_ge_S_V(7)` is still 5. `worst_rank = 5`.\n\n`i=2, a[2]=4`: `x - a[2] = 3`. `bisect_left(b, 3)` is index 1 (`b[1]=3`).\n  `S_V = a[2] + b[1] = 4 + 3 = 7`.\n  `count_ge_S_V(7)` is still 5. `worst_rank = 5`.\n\n... and so on. For example 2, the worst rank is 5.\nThis `O(N^2)` approach gives the correct answer for the examples. So the logic for `count_ge_S_V` and iterating all `a_i` is likely correct. We just need to optimize `count_ge_S_V`.\n\nThe `count_ge_S_V(S_V)` is essentially asking: how many pairs `(a_i, b_j)` can be formed such that `a_i + b_j >= S_V`.\nThis is a standard problem that can be solved in `O(N)` using two pointers.\nThe overall complexity is `O(N log N)` for sorting, then `N` times `O(N)` for `count_ge_S_V`.\nThe `bisect_left` is `O(log N)`. Total `O(N^2)`.\n\nIs there a way to avoid recomputing `count_ge_S_V` from scratch?\nWhen `S_V` increases, the `l` pointer in `count_ge_S_V` can only increase or stay the same. The `r` pointer can only decrease or stay the same.\nThis suggests a two-pointer approach for the outer loop as well.\nLet `a` be sorted ascending, `b` be sorted ascending.\n`worst_rank = 0`\n`count_l = 0` (left pointer for `a` in `count_ge_S_V`)\n`count_r = n - 1` (right pointer for `b` in `count_ge_S_V`)\n\n`vasya_a_idx = 0`\n`vasya_b_idx = n - 1` // This pointer will find `b_j` for Vasya's score `a[vasya_a_idx] + b[vasya_b_idx]` to be `>= x`\n\nWhile `vasya_a_idx < n`:\n  // Find smallest `b[vasya_b_idx]` such that `a[vasya_a_idx] + b[vasya_b_idx] >= x`\n  while `vasya_b_idx >= 0` and `a[vasya_a_idx] + b[vasya_b_idx] >= x`:\n    `vasya_b_idx--`\n  // `vasya_b_idx + 1` is the index of the smallest `b` that works with `a[vasya_a_idx]`.\n  // If `vasya_b_idx + 1 == n`, then `a[vasya_a_idx]` cannot form `x` points.\n  if `vasya_b_idx + 1 < n`:\n    `S_V = a[vasya_a_idx] + b[vasya_b_idx + 1]`\n\n    // Now, we need to compute `count_ge_S_V(S_V)`.\n    // The `count_l` and `count_r` pointers are for the `count_ge_S_V` function.\n    // The `S_V` values are not necessarily monotonic.\n    // So we can't efficiently update `current_count` and `count_l`, `count_r`.\n    // We *must* recompute `count_ge_S_V(S_V)` for each `S_V`.\n\nThe problem constraints `N=10^5` and `max_score=10^5` (so `max_total_score=2*10^5`) suggest an `N log N` or `N * max_score` solution.\n`N * max_score` is `10^5 * 2 * 10^5 = 2 * 10^{10}`, also too slow.\n\nSo it must be `N log N`.\nThe only way to get `N log N` is if the `count_ge_S_V` part is optimized.\nWhat if we iterate `S_V` values?\n`S_V` can range from `0` to `2 * 10^5`.\nFor each `S_V` in this range, we can check if Vasya can achieve it (i.e. `exists i, j` such that `a_i + b_j = S_V` and `S_V >= x`).\nThen compute `count_ge_S_V(S_V)`.\nThis would be `(max_total_score) * O(N)`. Still `2*10^5 * 10^5` too slow.\n\nThe crucial observation is that we are looking for `max_{S_V_possible} count_ge_S_V(S_V)`.\nThe function `count_ge_S_V(S_V)` is monotonically non-increasing.\nThe possible `S_V` values are `a_i + b_j` for some `i, j` such that `a_i + b_j >= x`.\nThere are `N^2` such pairs.\nLet `P = [(a_i + b_j, i, j) for all i, j if a_i + b_j >= x]`.\nWe want to find `max_{(S,i,j) in P} count_ge_S_V(S)`.\nThis is equivalent to finding `count_ge_S_V(min_{(S,i,j) in P} S)`.\nBecause `count_ge_S_V` is non-increasing, if we find the smallest possible `S_V` that Vasya could achieve (let's call it `S_min_Vasya`), then `count_ge_S_V(S_min_Vasya)` will give the maximum possible count.\n\nSo, the strategy for worst rank is:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n3. Find `S_min_Vasya`: the minimum possible total score Vasya could get, subject to `S_min_Vasya >= x`.\n   Iterate `i` from `0` to `n-1` (for `a[i]`):\n     Find `j = bisect_left(b, x - a[i])`.\n     If `j < n`, then `a[i] + b[j]` is a candidate for `S_min_Vasya`.\n     Keep track of the minimum `a[i] + b[j]` found.\n   This takes `O(N log N)`.\n4. Calculate `count_ge_S_V(S_min_Vasya)` using the two-pointer method (`O(N)`).\n5. This count is the worst rank.\n\nExample 2: `n=6, x=7`. `a=[3,4,4,4,5,6]`, `b=[0,3,4,4,6,8]`.\n1. `S_min_Vasya` calculation:\n   `i=0, a[0]=3`: `x-a[0]=4`. `bisect_left(b, 4)` is `j=2` (`b[2]=4`). Candidate `S_V = 3+4=7`.\n   `i=1, a[1]=4`: `x-a[1]=3`. `bisect_left(b, 3)` is `j=1` (`b[1]=3`). Candidate `S_V = 4+3=7`.\n   `i=2, a[2]=4`: `x-a[2]=3`. `bisect_left(b, 3)` is `j=1` (`b[1]=3`). Candidate `S_V = 4+3=7`.\n   ...\n   The minimum candidate `S_V` found is `7`. So `S_min_Vasya = 7`.\n2. Calculate `count_ge_S_V(7)`:\n   As calculated before, this is `5`.\n3. Worst rank is `5`.\n\nThis approach is `O(N log N)` (for sorting and finding `S_min_Vasya`) + `O(N)` (for `count_ge_S_V`). Total `O(N log N)`. This fits the constraints.\n\nFinal check:\nBest rank: Always 1. (Vasya takes `max(a) + max(b)`, which is `>= x`. No one can score higher. Jury places him 1st.)\nWorst rank: Find `S_min_Vasya` (minimum score `>= x` Vasya could possibly get by picking an `a_i` and a `b_j`). Then, calculate `count_ge_S_V(S_min_Vasya)` (maximum number of participants, including Vasya, who can score `>= S_min_Vasya`). This count is Vasya's worst rank.\n\nThis logic seems robust and handles the jury's choice correctly for both best and worst cases.\n\n```python\nimport sys\nimport bisect\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya\n    # Vasya can choose to take max(a) and max(b).\n    # The problem guarantees that there is at least one pair (a_i, b_j) such that a_i + b_j >= x.\n    # Since max(a) + max(b) is the largest possible sum, it must be >= x.\n    # If Vasya achieves max(a) + max(b), no other participant can achieve a strictly higher score.\n    # By the jury's choice rule, Vasya can be placed 1st among those with the top score.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # To maximize Vasya's rank (make it numerically larger), we assume:\n    # 1. Vasya gets the smallest possible total score S_V such that S_V >= x.\n    # 2. We arrange the pairings for all N participants such that the maximum number of people\n    #    (including Vasya) score >= S_V. Vasya will be ranked last among these people.\n\n    # Sort a and b in ascending order to efficiently find S_min_Vasya and count_ge_S_V.\n    a.sort()\n    b.sort()\n\n    # Step 1: Find S_min_Vasya - the minimum possible score Vasya could get >= x.\n    s_min_vasya = float('inf')\n    \n    # Iterate through each score in 'a' as Vasya's first tour score.\n    # For each a_val, find the smallest b_val such that a_val + b_val >= x.\n    # This b_val must be >= x - a_val.\n    for a_val in a:\n        required_b = x - a_val\n        # Use bisect_left to find the index of the first element in b that is >= required_b.\n        b_idx = bisect.bisect_left(b, required_b)\n        \n        if b_idx < n: # If such a b_val exists\n            current_vasya_score = a_val + b[b_idx]\n            s_min_vasya = min(s_min_vasya, current_vasya_score)\n    \n    # Step 2: Calculate count_ge_S_V(S_min_Vasya) - the maximum number of participants\n    # (including Vasya) who can achieve a total score of at least S_min_Vasya.\n    # This is done using a two-pointer approach on sorted 'a' and 'b'.\n    \n    worst_rank_count = 0\n    left_ptr = 0  # Pointer for list 'a'\n    right_ptr = n - 1 # Pointer for list 'b' (starting from largest)\n\n    while left_ptr < n and right_ptr >= 0:\n        if a[left_ptr] + b[right_ptr] >= s_min_vasya:\n            # This pair (a[left_ptr], b[right_ptr]) can achieve S_min_vasya or more.\n            # We count it and move both pointers to consider new scores.\n            worst_rank_count += 1\n            left_ptr += 1\n            right_ptr -= 1\n        else:\n            # a[left_ptr] is too small to combine with b[right_ptr] (the largest available b)\n            # to reach S_min_vasya. Since 'a' is sorted ascending, a[left_ptr] won't work\n            # with any smaller b values either. So, a[left_ptr] cannot be part of any pair\n            # that sums to >= S_min_vasya using the remaining b values.\n            # We must discard a[left_ptr] and try the next a value.\n            left_ptr += 1\n            \n    worst_rank = worst_rank_count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya\n    # Vasya can choose to take max(a) and max(b).\n    # The problem guarantees that there is at least one pair (a_i, b_j) such that a_i + b_j >= x.\n    # Since max(a) + max(b) is the largest possible sum, it must be >= x.\n    # If Vasya achieves max(a) + max(b), no other participant can achieve a strictly higher score.\n    # By the jury's choice rule, Vasya can be placed 1st among those with the top score.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # To maximize Vasya's rank (make it numerically larger), we assume:\n    # 1. Vasya gets the smallest possible total score S_V such that S_V >= x.\n    # 2. We arrange the pairings for all N participants such that the maximum number of people\n    #    (including Vasya) score >= S_V. Vasya will be ranked last among these people.\n\n    # Sort a and b in ascending order to efficiently find S_min_Vasya and count_ge_S_V.\n    a.sort()\n    b.sort()\n\n    # Step 1: Find S_min_Vasya - the minimum possible score Vasya could get >= x.\n    s_min_vasya = float('inf')\n    \n    # Iterate through each score in 'a' as Vasya's first tour score.\n    # For each a_val, find the smallest b_val such that a_val + b_val >= x.\n    # This b_val must be >= x - a_val.\n    for a_val in a:\n        required_b = x - a_val\n        # Use bisect_left to find the index of the first element in b that is >= required_b.\n        b_idx = bisect.bisect_left(b, required_b)\n        \n        if b_idx < n: # If such a b_val exists\n            current_vasya_score = a_val + b[b_idx]\n            s_min_vasya = min(s_min_vasya, current_vasya_score)\n    \n    # Step 2: Calculate count_ge_S_V(S_min_Vasya) - the maximum number of participants\n    # (including Vasya) who can achieve a total score of at least S_min_Vasya.\n    # This is done using a two-pointer approach on sorted 'a' and 'b'.\n    \n    worst_rank_count = 0\n    left_ptr = 0  # Pointer for list 'a'\n    right_ptr = n - 1 # Pointer for list 'b' (starting from largest)\n\n    while left_ptr < n and right_ptr >= 0:\n        if a[left_ptr] + b[right_ptr] >= s_min_vasya:\n            # This pair (a[left_ptr], b[right_ptr]) can achieve S_min_vasya or more.\n            # We count it and move both pointers to consider new scores.\n            worst_rank_count += 1\n            left_ptr += 1\n            right_ptr -= 1\n        else:\n            # a[left_ptr] is too small to combine with b[right_ptr] (the largest available b)\n            # to reach S_min_vasya. Since 'a' is sorted ascending, a[left_ptr] won't work\n            # with any smaller b values either. So, a[left_ptr] cannot be part of any pair\n            # that sums to >= S_min_vasya using the remaining b values.\n            # We must discard a[left_ptr] and try the next a value.\n            left_ptr += 1\n            \n    worst_rank = worst_rank_count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 10469,
        "thoughts_token_count": 5310
    }
}