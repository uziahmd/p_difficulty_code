{
    "start": 1758015880.0095205,
    "end": 1758015895.9159558,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:44 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n\n    # Store minimum cost for a given duration ending at a specific day\n    # min_cost_for_duration_ending[duration][end_day] = cost\n    # This approach is too memory intensive.\n    # Instead, let's process vouchers by their end day.\n    # We need to find min cost for a voucher with duration D1 ending at R1\n    # and another voucher with duration D2 starting at L2\n    # such that D1 + D2 = X and R1 < L2.\n\n    # Max possible day is 2 * 10^5\n    MAX_DAY = 2 * 10**5 + 5\n\n    # min_cost_for_duration[duration_val][end_day] = min_cost\n    # This is also too much.\n    # We need to efficiently query for minimum cost of a voucher with duration D1\n    # that ends before L2, for a specific D1.\n\n    # Let's group vouchers by their duration\n    vouchers_by_duration = [[] for _ in range(x + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if 1 <= duration <= x:\n            vouchers_by_duration[duration].append((l, r, cost))\n\n    # Sort vouchers within each duration group by their end day\n    for i in range(1, x + 1):\n        vouchers_by_duration[i].sort(key=lambda v: v[1]) # Sort by end day 'r'\n\n    # This will store the minimum cost for a voucher of a specific duration\n    # that ends at or before a certain day.\n    # min_cost_ending_at[day][duration] = cost\n    # This is also too memory intensive.\n\n    # Instead, let's iterate through vouchers, and for each voucher (l1, r1, cost1):\n    #   1. Add it to a data structure that allows efficient queries for\n    #      min_cost_for_duration D1 ending at R1 <= r1.\n    #   2. Query for another voucher (l2, r2, cost2) such that\n    #      r1 < l2 and (r1-l1+1) + (r2-l2+1) = x.\n\n    # Let's process vouchers sorted by their start day 'l'.\n    # This might allow us to use a data structure that updates minimum costs\n    # for durations as we sweep through days.\n\n    # Option: Iterate through all possible pairs of durations (d1, d2) such that d1 + d2 = x.\n    # For each pair, we need to find min_cost(d1) and min_cost(d2) such that they don't intersect.\n    # This still requires an efficient way to find non-intersecting vouchers.\n\n    # Let's create a list of all vouchers, sorted by their start day.\n    # (l, r, cost, duration)\n    all_vouchers_with_duration = []\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        all_vouchers_with_duration.append((l, r, cost, duration))\n\n    all_vouchers_with_duration.sort() # Sort by start day 'l'\n\n    # min_cost_for_duration_ending_before[day][duration] = min_cost\n    # This is too much.\n    # We need to find min_cost_for_duration_ending_at_or_before[day_limit][duration]\n    # For a fixed duration D, we need to query for min cost of a voucher of duration D\n    # that ends before a certain day.\n\n    # Let's use an array `min_cost_ending_at_day[day]`\n    # `min_cost_ending_at_day[day]` will store a dictionary or list of (duration, cost)\n    # for vouchers ending on `day`.\n    # This is not enough. We need to query for min cost for duration D ending *before* a day.\n\n    # The standard approach for this kind of problem is often to use a sweep-line algorithm\n    # or to iterate through one voucher and query for the other.\n\n    # Let's iterate through all vouchers (l1, r1, cost1, d1).\n    # For each voucher, we need to find a voucher (l2, r2, cost2, d2) such that:\n    #   1. d1 + d2 = x\n    #   2. r1 < l2 or r2 < l1\n    #   3. cost1 + cost2 is minimal.\n\n    # If we iterate through (l1, r1, cost1, d1), we can try to find (l2, r2, cost2, d2).\n    # Case 1: r1 < l2.\n    # We need to find a voucher (l2, r2, cost2, d2) such that d2 = x - d1, l2 > r1, and cost2 is minimal.\n    # Case 2: r2 < l1.\n    # We need to find a voucher (l2, r2, cost2, d2) such that d2 = x - d1, r2 < l1, and cost2 is minimal.\n\n    # Let's iterate through vouchers sorted by their right endpoint `r`.\n    # This allows us to efficiently update minimum costs for vouchers ending at or before `r`.\n\n    # `min_cost_for_duration_ending_at_or_before[duration]`\n    # This will store the minimum cost of a voucher with that duration\n    # that we have processed so far (i.e., its `r` is less than or equal to current `r`).\n    # This is not enough, as we need to query based on `l2 > r1`.\n\n    # Let's try iterating through all possible values of `r1`.\n    # For each `r1`, we want to find a voucher (l1, r1, cost1, d1) and a voucher (l2, r2, cost2, d2)\n    # such that d1 + d2 = x and r1 < l2.\n\n    # This suggests a sweep-line approach.\n    # We will process events at each day `k` from 1 to MAX_DAY.\n    # Events:\n    #   - A voucher starts at `k` (l_i = k)\n    #   - A voucher ends at `k` (r_i = k)\n\n    # Let's maintain `min_cost_for_duration[duration]`\n    # This array will store the minimum cost of a voucher with `duration`\n    # that has already \"passed\" (i.e., its `r` is less than the current day `k`).\n\n    # `min_cost_for_duration_ending_at_day[duration]`\n    # `min_cost_for_duration_starting_at_day[duration]`\n\n    # Let's define `dp[d]` as the minimum cost of a voucher with duration `d`\n    # that has already finished (its `r` is less than the current day `k`).\n    # Initialize `dp` array with infinity.\n    dp = [float('inf')] * (x + 1)\n\n    # Group vouchers by start day `l` and end day `r`.\n    vouchers_starting_at = [[] for _ in range(MAX_DAY)] # List of (r, cost, duration)\n    vouchers_ending_at = [[] for _ in range(MAX_DAY)]   # List of (l, cost, duration)\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration <= x:\n            vouchers_starting_at[l].append((r, cost, duration))\n            vouchers_ending_at[r].append((l, cost, duration))\n\n    overall_min_cost = float('inf')\n\n    # Iterate day `k` from 1 to MAX_DAY\n    for k in range(1, MAX_DAY):\n        # Process vouchers that end at `k-1`. These vouchers are now \"available\"\n        # to be paired with vouchers starting at `k` or later.\n        # So, for each voucher (l, k-1, cost, duration) that ends at `k-1`:\n        # Update `dp[duration]` with `min(dp[duration], cost)`.\n        for l_prev, cost_prev, duration_prev in vouchers_ending_at[k-1]:\n            dp[duration_prev] = min(dp[duration_prev], cost_prev)\n\n        # Now, consider vouchers that start at `k`.\n        # For each voucher (k, r_curr, cost_curr, duration_curr) starting at `k`:\n        # We need to find a previous voucher (l_prev, r_prev, cost_prev, duration_prev)\n        # such that r_prev < k and duration_prev + duration_curr = x.\n        # This means duration_prev = x - duration_curr.\n        # We can query `dp[x - duration_curr]` for the minimum cost of such a voucher.\n        # If `dp[x - duration_curr]` is not infinity, we can form a pair.\n        for r_curr, cost_curr, duration_curr in vouchers_starting_at[k]:\n            required_duration = x - duration_curr\n            if 1 <= required_duration <= x:\n                if dp[required_duration] != float('inf'):\n                    overall_min_cost = min(overall_min_cost, cost_curr + dp[required_duration])\n\n    if overall_min_cost == float('inf'):\n        print(-1)\n    else:\n        print(overall_min_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n\n    # Store minimum cost for a given duration ending at a specific day\n    # min_cost_for_duration_ending[duration][end_day] = cost\n    # This approach is too memory intensive.\n    # Instead, let's process vouchers by their end day.\n    # We need to find min cost for a voucher with duration D1 ending at R1\n    # and another voucher with duration D2 starting at L2\n    # such that D1 + D2 = X and R1 < L2.\n\n    # Max possible day is 2 * 10^5\n    MAX_DAY = 2 * 10**5 + 5\n\n    # min_cost_for_duration[duration_val][end_day] = min_cost\n    # This is also too much.\n    # We need to efficiently query for minimum cost of a voucher with duration D1\n    # that ends before L2, for a specific D1.\n\n    # Let's group vouchers by their duration\n    vouchers_by_duration = [[] for _ in range(x + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if 1 <= duration <= x:\n            vouchers_by_duration[duration].append((l, r, cost))\n\n    # Sort vouchers within each duration group by their end day\n    for i in range(1, x + 1):\n        vouchers_by_duration[i].sort(key=lambda v: v[1]) # Sort by end day 'r'\n\n    # This will store the minimum cost for a voucher of a specific duration\n    # that ends at or before a certain day.\n    # min_cost_ending_at[day][duration] = cost\n    # This is also too memory intensive.\n\n    # Instead, let's iterate through vouchers, and for each voucher (l1, r1, cost1):\n    #   1. Add it to a data structure that allows efficient queries for\n    #      min_cost_for_duration D1 ending at R1 <= r1.\n    #   2. Query for another voucher (l2, r2, cost2) such that\n    #      r1 < l2 and (r1-l1+1) + (r2-l2+1) = x.\n\n    # Let's process vouchers sorted by their start day 'l'.\n    # This might allow us to use a data structure that updates minimum costs\n    # for durations as we sweep through days.\n\n    # Option: Iterate through all possible pairs of durations (d1, d2) such that d1 + d2 = x.\n    # For each pair, we need to find min_cost(d1) and min_cost(d2) such that they don't intersect.\n    # This still requires an efficient way to find non-intersecting vouchers.\n\n    # Let's create a list of all vouchers, sorted by their start day.\n    # (l, r, cost, duration)\n    all_vouchers_with_duration = []\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        all_vouchers_with_duration.append((l, r, cost, duration))\n\n    all_vouchers_with_duration.sort() # Sort by start day 'l'\n\n    # min_cost_for_duration_ending_before[day][duration] = min_cost\n    # This is too much.\n    # We need to find min_cost_for_duration_ending_at_or_before[day_limit][duration]\n    # For a fixed duration D, we need to query for min cost of a voucher of duration D\n    # that ends before a certain day.\n\n    # Let's use an array `min_cost_ending_at_day[day]`\n    # `min_cost_ending_at_day[day]` will store a dictionary or list of (duration, cost)\n    # for vouchers ending on `day`.\n    # This is not enough. We need to query for min cost for duration D ending *before* a day.\n\n    # The standard approach for this kind of problem is often to use a sweep-line algorithm\n    # or to iterate through one voucher and query for the other.\n\n    # Let's iterate through all vouchers (l1, r1, cost1, d1).\n    # For each voucher, we need to find a voucher (l2, r2, cost2, d2) such that:\n    #   1. d1 + d2 = x\n    #   2. r1 < l2 or r2 < l1\n    #   3. cost1 + cost2 is minimal.\n\n    # If we iterate through (l1, r1, cost1, d1), we can try to find (l2, r2, cost2, d2).\n    # Case 1: r1 < l2.\n    # We need to find a voucher (l2, r2, cost2, d2) such that d2 = x - d1, l2 > r1, and cost2 is minimal.\n    # Case 2: r2 < l1.\n    # We need to find a voucher (l2, r2, cost2, d2) such that d2 = x - d1, r2 < l1, and cost2 is minimal.\n\n    # Let's iterate through vouchers sorted by their right endpoint `r`.\n    # This allows us to efficiently update minimum costs for vouchers ending at or before `r`.\n\n    # `min_cost_for_duration_ending_at_or_before[duration]`\n    # This will store the minimum cost of a voucher with that duration\n    # that we have processed so far (i.e., its `r` is less than or equal to current `r`).\n    # This is not enough, as we need to query based on `l2 > r1`.\n\n    # Let's try iterating through all possible values of `r1`.\n    # For each `r1`, we want to find a voucher (l1, r1, cost1, d1) and a voucher (l2, r2, cost2, d2)\n    # such that d1 + d2 = x and r1 < l2.\n\n    # This suggests a sweep-line approach.\n    # We will process events at each day `k` from 1 to MAX_DAY.\n    # Events:\n    #   - A voucher starts at `k` (l_i = k)\n    #   - A voucher ends at `k` (r_i = k)\n\n    # Let's maintain `min_cost_for_duration[duration]`\n    # This array will store the minimum cost of a voucher with `duration`\n    # that has already \"passed\" (i.e., its `r` is less than the current day `k`).\n\n    # `min_cost_for_duration_ending_at_day[duration]`\n    # `min_cost_for_duration_starting_at_day[duration]`\n\n    # Let's define `dp[d]` as the minimum cost of a voucher with duration `d`\n    # that has already finished (its `r` is less than the current day `k`).\n    # Initialize `dp` array with infinity.\n    dp = [float('inf')] * (x + 1)\n\n    # Group vouchers by start day `l` and end day `r`.\n    vouchers_starting_at = [[] for _ in range(MAX_DAY)] # List of (r, cost, duration)\n    vouchers_ending_at = [[] for _ in range(MAX_DAY)]   # List of (l, cost, duration)\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration <= x:\n            vouchers_starting_at[l].append((r, cost, duration))\n            vouchers_ending_at[r].append((l, cost, duration))\n\n    overall_min_cost = float('inf')\n\n    # Iterate day `k` from 1 to MAX_DAY\n    for k in range(1, MAX_DAY):\n        # Process vouchers that end at `k-1`. These vouchers are now \"available\"\n        # to be paired with vouchers starting at `k` or later.\n        # So, for each voucher (l, k-1, cost, duration) that ends at `k-1`:\n        # Update `dp[duration]` with `min(dp[duration], cost)`.\n        for l_prev, cost_prev, duration_prev in vouchers_ending_at[k-1]:\n            dp[duration_prev] = min(dp[duration_prev], cost_prev)\n\n        # Now, consider vouchers that start at `k`.\n        # For each voucher (k, r_curr, cost_curr, duration_curr) starting at `k`:\n        # We need to find a previous voucher (l_prev, r_prev, cost_prev, duration_prev)\n        # such that r_prev < k and duration_prev + duration_curr = x.\n        # This means duration_prev = x - duration_curr.\n        # We can query `dp[x - duration_curr]` for the minimum cost of such a voucher.\n        # If `dp[x - duration_curr]` is not infinity, we can form a pair.\n        for r_curr, cost_curr, duration_curr in vouchers_starting_at[k]:\n            required_duration = x - duration_curr\n            if 1 <= required_duration <= x:\n                if dp[required_duration] != float('inf'):\n                    overall_min_cost = min(overall_min_cost, cost_curr + dp[required_duration])\n\n    if overall_min_cost == float('inf'):\n        print(-1)\n    else:\n        print(overall_min_cost)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 789,
        "completion_token_count": 2343,
        "thoughts_token_count": 0
    }
}