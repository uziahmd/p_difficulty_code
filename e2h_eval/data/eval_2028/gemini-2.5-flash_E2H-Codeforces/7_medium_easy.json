{
    "start": 1758016320.51237,
    "end": 1758016415.1534853,
    "start-formatted": "2025-09-16 18:52 KST",
    "end-formatted": "2025-09-16 18:53 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Analyzing Snowflake Numbers**\n\nOkay, so I'm tasked with figuring out if a number `n` can represent the total vertices of a special \"snowflake\" graph.  This graph has a center, branches, and leaves, with a specific structure: the center connects to `k` vertices, and each leaf node also connects to `k` more vertices.  The key is that this branching *must* happen at least once.\n\nFirst, I explored the possible forms of this `n`.  I figured out the smallest snowflake has the form `1 + k + k^2`, which is the center plus the first layer of branches and their leaves.  To get the total number of vertices, I realized this is a geometric series, and I arrived at the general formula:  `n = (k^(m+1) - 1) / (k - 1)`. Here, `m` is one less than the number of layers, and it has to be at least 2 for a valid snowflake (because of the initial branching step). This means I have to find a combination of integers `k > 1` and `m >= 2` that satisfies this equation.\n\nSince `n` can be huge (up to 10^18), I knew I had to be smart about my approach. I broke it down into cases. First, I focused on the simplest case where `m = 2`. This meant checking if `n` could be written as `1 + k + k^2`.  I rearranged this into a quadratic equation in `k`, solved for `k` using the quadratic formula, and then found a formula that determines if `k` is a whole number (namely, when `4n-3` is a perfect square). I worked out the specific steps for finding an integer k greater than 1. This handles the scenario where there are only 3 layers: the center, the branches, and the leaves of the branches.\n\nNext, I tackled the more general cases where `m > 2`.  I tried to find a systematic way of finding values for `k` and `m` that fit the equation. I noticed that if `k` is 2, then `n` takes the form `2^(m+1) - 1`. If `n+1` is a power of 2, and n > 7, it means `k` is 2, and the structure is a snowflake.\n\nBut what if `k` is greater than 2?  I realized I need to search through possibilities for `m`.  Because `n` is large, `m` can’t be arbitrarily large. The upper bound for m is relatively small - around 59 based on the logarithms involved. For each possible value of `m` (from 3 upwards), I used binary search to find a possible value for `k`.  This is the part that takes a careful look at the calculation, I'm using a geometric sum to calculate the vertex count, and I need to avoid integer overflow.\n\nFor the binary search, I need to check the sum: `1 + k + k^2 + ... + k^m` for a given `k` and `m`. I carefully crafted a function to calculate this sum, keeping track of intermediate values to avoid overflow issues. For each `k` in the search, I compare the sum to `n`.  If the sum is too small, I need a larger `k`. If the sum is too large (or overflows), I need a smaller `k`. If I find a `k` that makes the sum *equal* to `n`, then I have found a solution, and the number is a snowflake! If I go through all possible `m` and find no solution, then `n` is *not* a snowflake number.\n\nI'm confident this method is efficient because the binary search reduces the possibilities for `k` significantly, and the overflow-aware sum calculation runs quickly.\n",
    "response": "A snowflake graph with `n` vertices is defined by two parameters: `k > 1` (the number of new branches added at each step) and `m >= 2` (the number of layers of branches after the initial center vertex). The total number of vertices `n` is given by the sum of a geometric series:\n`n = 1 + k + k^2 + ... + k^m`\n\nThis sum can be expressed as `n = (k^(m+1) - 1) / (k - 1)`.\nWe need to determine if, for a given `n` (`1 <= n <= 10^18`), there exist integers `k > 1` and `m >= 2` that satisfy this equation.\n\nLet's analyze the possible values of `m`:\n\n**Case 1: `m = 2`**\nThis is the smallest possible snowflake structure (center + `k` branches + `k^2` leaves).\nThe formula becomes `n = 1 + k + k^2`.\nWe can rearrange this into a quadratic equation for `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 +/- sqrt(1 - 4 * (1 - n))) / 2 = (-1 +/- sqrt(4n - 3)) / 2`.\nSince `k` must be a positive integer, we take the positive root: `k = (-1 + sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer `k > 1`:\n1. `4n - 3` must be a perfect square. Let `s = sqrt(4n - 3)`.\n2. `s` must be an integer.\n3. `(-1 + s)` must be an even number, which means `s` must be odd.\n4. `k > 1` implies `(-1 + s) / 2 > 1`, so `s - 1 > 2`, or `s > 3`.\n\nWe can check these conditions directly:\n- Calculate `val = 4n - 3`.\n- Compute `s = isqrt(val)` (integer square root).\n- If `s * s == val` (check if `val` is a perfect square) AND `s > 3` AND `s % 2 == 1` (check if `s` is odd), then `n` can be a snowflake.\n\n**Case 2: `m >= 3`**\nFor `m >= 3`, we need to find `k > 1` such that `n = 1 + k + ... + k^m`.\nThe maximum value of `n` is `10^18`.\nIf `k=2`, `n = 2^(m+1) - 1`. So `m+1 = log2(n+1)`.\nFor `n = 10^18`, `log2(10^18) approx 59.79`. So `m+1` can be at most `59`. This means `m` can be at most `58`.\nIf `k` is larger, `m` must be smaller. For example, if `m=3`, `n = 1 + k + k^2 + k^3`. Then `k^3 < n`, so `k < n^(1/3)`. For `n = 10^18`, `k < (10^18)^(1/3) = 10^6`.\nSo, `m` can range from `3` up to about `58-59`. And `k` can range from `2` up to about `10^6`.\n\nWe can iterate `m` from `3` to `59` (a safe upper bound for `m` given `n <= 10^18`).\nFor each `m`, we need to find if there's an integer `k` in the range `[2, 10^6 + C]` (where `C` is a small constant for safety, e.g., 7) such that `1 + k + ... + k^m = n`.\nSince `f(k) = 1 + k + ... + k^m` is a monotonically increasing function for `k > 1`, we can use binary search to find `k`.\n\nInside the binary search, for a given `k` (let's call it `mid`) and `m`, we calculate `current_sum = 1 + mid + ... + mid^m`. We need to do this carefully to avoid overflow, as `mid^m` can exceed `10^18` even if `current_sum` doesn't.\n\n**`calculate_sum(k, m, n)` function:**\nThis function computes `1 + k + ... + k^m`.\nIt returns `n` if the sum equals `n`, `n+1` if the sum exceeds `n`, and a value less than `n` if the sum is less than `n`.\n```python\ndef calculate_sum(k, m, n):\n    current_val = 1  # Represents k^i\n    total_sum = 1    # Represents 1 + k + ... + k^i\n    for _ in range(m): # Loop m times to add k^1, ..., k^m\n        # Check if current_val * k would exceed n.\n        # This is equivalent to checking if k > n / current_val.\n        # If current_val is already very large, current_val * k will overflow.\n        # If current_val is 0, this check is problematic, but k > 1 and current_val starts at 1.\n        if n // k < current_val: # current_val * k would be > n\n            return n + 1 # Signal that the sum is too large\n        current_val *= k\n        \n        # Check if total_sum + current_val would exceed n.\n        if n - current_val < total_sum: # total_sum + current_val would be > n\n            return n + 1 # Signal that the sum is too large\n        total_sum += current_val\n    return total_sum\n```\nThe binary search will work as follows:\n- `low = 2`, `high = 10**6 + 7` (an upper bound for `k` when `m >= 3`).\n- While `low <= high`:\n  - `mid_k = low + (high - low) // 2`\n  - `s = calculate_sum(mid_k, m, n)`\n  - If `s == n`, we found a solution, return `True`.\n  - If `s < n`, `mid_k` is too small, `low = mid_k + 1`.\n  - If `s > n`, `mid_k` is too large, `high = mid_k - 1`.\n\nIf no solution is found after checking `m=2` and iterating through `m >= 3` with binary search, then `n` cannot be a snowflake.\n\n**Edge Cases:**\n- `n = 1, 2, 3, 6`: These are too small to be snowflakes. The smallest snowflake for `k=2, m=2` is `1+2+2^2 = 7`. For `k=3, m=2` is `1+3+3^2 = 13`.\n  Our conditions `s > 3` for `m=2` and `k >= 2, m >= 3` (which implies `n >= 1 + 2 + 2^2 + 2^3 = 15`) correctly handle these small `n` values.\n\n**Final Algorithm:**\n1. Read `t`.\n2. For each test case `n`:\n   a. Initialize `found = False`.\n   b. **Check `m = 2` case:**\n      - Calculate `val = 4 * n - 3`.\n      - If `val < 0`, continue (no real sqrt).\n      - `s = int(val**0.5)`.\n      - If `s * s == val` and `s > 3` and `s % 2 == 1`:\n         - `found = True`.\n   c. **Check `m >= 3` cases (if not `found` yet):**\n      - Iterate `m` from `3` to `59`.\n        - `low = 2`, `high = 10**6 + 7` (a generous upper bound for `k` when `m >= 3`).\n        - While `low <= high`:\n          - `mid_k = low + (high - low) // 2`.\n          - `current_sum = calculate_sum(mid_k, m, n)`.\n          - If `current_sum == n`:\n            - `found = True`. Break inner and outer loops.\n          - If `current_sum < n`:\n            - `low = mid_k + 1`.\n          - Else (`current_sum > n`):\n            - `high = mid_k - 1`.\n   d. Print \"YES\" if `found`, \"NO\" otherwise.\n\n```python\nimport sys\n\ndef calculate_sum(k, m, n):\n    \"\"\"\n    Calculates 1 + k + k^2 + ... + k^m.\n    Returns n if sum == n, n+1 if sum > n (overflow or too large),\n    or the actual sum if sum < n.\n    This helps in binary search to determine if k is too small or too large.\n    \"\"\"\n    current_val = 1  # Represents k^i\n    total_sum = 1    # Represents 1 + k + ... + k^i\n\n    for _ in range(m): # Loop m times to add k^1, ..., k^m\n        # Check if current_val * k would exceed n.\n        # This is equivalent to checking if k > n / current_val.\n        # If current_val is already very large, current_val * k will overflow n.\n        # k is always > 1, so current_val will always be positive.\n        if n // k < current_val: \n            return n + 1 # Signal that the sum is too large\n        current_val *= k\n        \n        # Check if total_sum + current_val would exceed n.\n        # This is equivalent to checking if total_sum > n - current_val.\n        if n - current_val < total_sum:\n            return n + 1 # Signal that the sum is too large\n        total_sum += current_val\n    return total_sum\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k = (-1 + sqrt(4n - 3)) / 2\n    val = 4 * n - 3\n    if val >= 0:\n        s = int(val**0.5)\n        if s * s == val and s % 2 == 1:\n            k_val = (s - 1) // 2\n            if k_val > 1: # k must be > 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 3\n    # Iterate m from 3 up to a reasonable maximum (log2(10^18) approx 59.79)\n    # So m can go up to 59.\n    # For each m, binary search for k.\n    # Max k for m=3 is (10^18)^(1/3) = 10^6.\n    # Max k for m=59 is approx (10^18)^(1/59) which is 2.\n    \n    # The upper bound for m is 60 because if k=2, 2^60-1 is approx 1.15e18.\n    # So m+1 can be at most 60, meaning m can be at most 59.\n    \n    for m in range(3, 60): \n        low = 2\n        high = int(n**(1/m)) + 2 # A slightly generous upper bound for k (e.g. 10^6 for m=3)\n        # For small n, n**(1/m) might be 0 or 1. Ensure high is at least 2.\n        high = max(high, 2) \n\n        while low <= high:\n            mid_k = low + (high - low) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = calculate_sum(mid_k, m, n)\n\n            if current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n\n                high = mid_k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef calculate_sum(k, m, n):\n    \"\"\"\n    Calculates 1 + k + k^2 + ... + k^m.\n    Returns n if sum == n, n+1 if sum > n (overflow or too large),\n    or the actual sum if sum < n.\n    This helps in binary search to determine if k is too small or too large.\n    \"\"\"\n    current_val = 1  # Represents k^i\n    total_sum = 1    # Represents 1 + k + ... + k^i\n\n    for _ in range(m): # Loop m times to add k^1, ..., k^m\n        # Check if current_val * k would exceed n.\n        # This is equivalent to checking if k > n / current_val.\n        # If current_val is already very large, current_val * k will overflow n.\n        # k is always > 1, so current_val will always be positive.\n        if n // k < current_val: \n            return n + 1 # Signal that the sum is too large\n        current_val *= k\n        \n        # Check if total_sum + current_val would exceed n.\n        # This is equivalent to checking if total_sum > n - current_val.\n        if n - current_val < total_sum:\n            return n + 1 # Signal that the sum is too large\n        total_sum += current_val\n    return total_sum\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k = (-1 + sqrt(4n - 3)) / 2\n    val = 4 * n - 3\n    if val >= 0:\n        s = int(val**0.5)\n        if s * s == val and s % 2 == 1:\n            k_val = (s - 1) // 2\n            if k_val > 1: # k must be > 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 3\n    # Iterate m from 3 up to a reasonable maximum (log2(10^18) approx 59.79)\n    # So m can go up to 59.\n    # For each m, binary search for k.\n    # Max k for m=3 is (10^18)^(1/3) = 10^6.\n    # Max k for m=59 is approx (10^18)^(1/59) which is 2.\n    \n    # The upper bound for m is 60 because if k=2, 2^60-1 is approx 1.15e18.\n    # So m+1 can be at most 60, meaning m can be at most 59.\n    \n    for m in range(3, 60): \n        low = 2\n        high = int(n**(1/m)) + 2 # A slightly generous upper bound for k (e.g. 10^6 for m=3)\n        # For small n, n**(1/m) might be 0 or 1. Ensure high is at least 2.\n        high = max(high, 2) \n\n        while low <= high:\n            mid_k = low + (high - low) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = calculate_sum(mid_k, m, n)\n\n            if current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n\n                high = mid_k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 3043,
        "thoughts_token_count": 5843
    }
}