{
    "start": 1758294753.6088254,
    "end": 1758294839.6818335,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Alright, let's break down this Olympiad problem. I'm trying to figure out the best and worst possible ranks Vasya could get, given his minimum score and the scores of everyone else.**  I've got two lists of scores, one for each tour, and I need to figure out how to \"match\" them up to determine each participant's total score. Since the jury gets to assign places in the case of ties, that's going to be crucial for both my best and worst-case scenarios.\n\n**The best-case scenario is pretty straightforward.** To get rank 1, I need to make sure Vasya scores higher than *everyone* else.  I can achieve this by giving Vasya the highest possible score he *can* get, which means pairing his scores from the two tours such that their sum is maximized, then arbitrarily pairing all others.  This means Vasya gets the highest individual scores from each tour. It’s guaranteed that Vasya can achieve at least a minimum score x.  No other participant can score higher in the process.\n\n**The worst-case scenario is more complex.** I want Vasya to be ranked as low as possible, meaning as many people as possible should score at least as high as he does. This is where I start thinking about finding Vasya's *lowest* possible score that still meets the minimum requirement `x`. Then, I need to figure out how to distribute the remaining scores in a way that maximizes the number of people who end up scoring at least that same score (or higher). This involves careful pairing of the tour 1 and tour 2 scores. My approach here looks a bit like a two-pointer technique to maximize the number of people scoring higher. To minimize Vasya's score, I want to give him the lowest scores that sum to at least `x`. Then, I'll maximize the number of people with at least that score. I am going to have to carefully consider *how* those `n` scores (one score pair for each person) get paired with the two list.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad. We are given `n` participants, a minimum score `x` Vasya achieved, and two lists `a` and `b` containing scores for the first and second tours, respectively. The scores in `a` and `b` are not linked to specific participants. We need to form `n` pairs `(a_i, b_j)` such that each score from `a` and `b` is used exactly once. Participants are ranked by total score `a_i + b_j` in decreasing order. If participants have the same total points, the jury can assign places arbitrarily.\n\n**1. Best Possible Rank:**\n\nTo achieve the best possible rank, Vasya wants to maximize his own score. The highest possible score any participant can achieve is `max(a) + max(b)`. Let `a_max` be the maximum score in tour 1 and `b_max` be the maximum score in tour 2. We can assign `a_max` and `b_max` to Vasya. His total score would be `S_V = a_max + b_max`.\n\nThe problem guarantees that \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\". Since `a_max + b_max` is the largest possible sum, it must be greater than or equal to any `a_i + b_j`, including the one that satisfies the `x` condition. Therefore, `a_max + b_max >= x` is always true.\n\nIf Vasya achieves `a_max + b_max`, no other participant can achieve a strictly higher score. According to the tie-breaking rule (\"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice\"), if Vasya is tied for the highest score, the jury can assign him the 1st place.\n\nThus, the best possible rank Vasya can achieve is always **1**.\n\n**2. Worst Possible Rank:**\n\nTo achieve the worst possible rank, Vasya wants to maximize the number of participants who score *at least* as much as him. This means we want to:\n1. Choose Vasya's scores `a_v` and `b_v` such that `a_v + b_v >= x`, and this sum `S_V = a_v + b_v` is as small as possible, while still allowing many other participants to score `S_V` or more.\n2. Arrange the remaining `n-1` scores from `a` and `n-1` scores from `b` into pairs such that as many as possible sum up to `S_V` or more.\n3. If other participants tie with Vasya's score `S_V`, the jury can rank them *before* Vasya. So, Vasya's rank will be the count of all participants whose score is `>= S_V`.\n\nLet's sort both `a` and `b` in ascending order.\n`a = [a_0, a_1, ..., a_{n-1}]`\n`b = [b_0, b_1, ..., b_{n-1}]`\n\nWe need to find a specific pairing of all `n` scores from `a` and `n` scores from `b` that maximizes Vasya's rank. This is equivalent to finding a pairing that maximizes the number of participants whose score is greater than or equal to Vasya's score `S_V`, subject to `S_V >= x`.\n\nConsider a function `count_ge_S(S)` which, given a target score `S`, returns the maximum number of pairs `(a_p, b_q)` that can be formed from the `n` scores in `a` and `n` scores in `b` such that `a_p + b_q >= S`. This function can be implemented efficiently using a two-pointer approach:\n1. Sort `a` in ascending order and `b` in ascending order.\n2. Initialize `count = 0`, `i = 0` (pointer for `a`), `j = n-1` (pointer for `b`).\n3. While `i < n` and `j >= 0`:\n   a. If `a[i] + b[j] >= S`: We can form a pair `(a[i], b[j])` that meets the condition. Increment `count`, move `i` forward (`i++`), and move `j` backward (`j--`).\n   b. Else (`a[i] + b[j] < S`): `a[i]` is too small to form a sum `>= S` even with the largest available `b` (`b[j]`). Since `a` is sorted, `a[i]` cannot be paired with any `b_k` where `k < j` either. So, `a[i]` cannot be part of a pair summing to `>= S` with any remaining `b`s. We discard `a[i]` by moving `i` forward (`i++`).\n4. Return `count`.\nThis function `count_ge_S(S)` runs in `O(N)` time after initial sorting.\n\nNow, we need to find the `S_V` for Vasya. Vasya's score `S_V` must be one of the `n` pairs formed, say `a_p + b_q`, and it must satisfy `a_p + b_q >= x`.\nThe worst rank for Vasya will be `max(count_ge_S(S))` over all possible `S` that can be achieved by Vasya and satisfy `S >= x`.\n\nWhat are the candidate values for `S`? Any sum `a_i + b_j` could potentially be Vasya's score. There are `n^2` such sums. Testing all of them would be `O(N^3)`, too slow.\nHowever, notice that `count_ge_S(S)` is a monotonically non-increasing function with `S`. As `S` decreases, `count_ge_S(S)` either stays the same or increases.\nWe are looking for `max(count_ge_S(S))` where `S` is a valid score for Vasya and `S >= x`.\nThe minimum possible `S` for Vasya (that satisfies `S >= x`) would lead to the maximum `count_ge_S(S)`.\n\nLet's find the smallest possible score Vasya could have, say `S_min_V`.\n`S_min_V` is the minimum `a_i + b_j` such that `a_i + b_j >= x`.\nThis can be found by iterating through each `a_i`. For each `a_i`, find the smallest `b_j` such that `b_j >= x - a_i`. This `b_j` can be found using `bisect_left` on the sorted `b` array. If such `b_j` exists, `a_i + b_j` is a candidate for `S_min_V`. We take the minimum of these candidates.\nLet `min_vasya_score_overall = infinity`.\nFor `i` from `0` to `n-1`:\n  `target_b = x - a[i]`\n  `idx = bisect_left(b, target_b)`\n  If `idx < n`: // Found a `b_j` such that `b_j >= target_b`\n    `min_vasya_score_overall = min(min_vasya_score_overall, a[i] + b[idx])`\n\nOnce we have `min_vasya_score_overall`, we can compute `count_ge_S(min_vasya_score_overall)`. This will be the maximum number of people who can score at least `min_vasya_score_overall`. This `min_vasya_score_overall` is guaranteed to be a score Vasya can achieve (by taking `a[i]` and `b[idx]` that generated it). And by the tie-breaking rule, if Vasya gets this score, and `k` people (including Vasya) also get this score or more, Vasya can be ranked `k`-th.\nSo, the worst rank is `count_ge_S(min_vasya_score_overall)`.\n\nThe overall algorithm for the worst rank:\n1. Sort `a` and `b` in ascending order. (`O(N log N)`)\n2. Find `min_vasya_score_overall`:\n   Initialize `min_S = 2 * 10^5 + 1` (a value larger than any possible sum).\n   For each `val_a` in `a`:\n     Find `idx = bisect_left(b, x - val_a)`. (`O(log N)`)\n     If `idx < n`:\n       `min_S = min(min_S, val_a + b[idx])`.\n   (`O(N log N)`)\n3. Calculate `worst_rank = count_ge_S(min_S)`. (`O(N)`)\n\nTotal time complexity: `O(N log N) + O(N log N) + O(N) = O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays (or `O(1)` if sorting in-place).\n\nExample 2 Walkthrough:\n`n = 6, x = 7`\n`a = [4, 3, 5, 6, 4, 4]`\n`b = [8, 6, 0, 4, 3, 4]`\n\n1. Sort `a` and `b`:\n   `a = [3, 4, 4, 4, 5, 6]`\n   `b = [0, 3, 4, 4, 6, 8]`\n\n2. Best Rank:\n   `max(a) = 6`, `max(b) = 8`.\n   Vasya's score = `6 + 8 = 14`.\n   Since `14 >= x` (7), this is a valid score for Vasya.\n   No one can score higher than 14. So, best rank is **1**.\n\n3. Worst Rank:\n   Find `min_vasya_score_overall`:\n   `min_S = infinity`\n   - `val_a = 3`: `target_b = 7 - 3 = 4`. `bisect_left(b, 4)` returns `2` (index of first `4`).\n     `min_S = min(inf, 3 + b[2]) = min(inf, 3 + 4) = 7`.\n   - `val_a = 4`: `target_b = 7 - 4 = 3`. `bisect_left(b, 3)` returns `1` (index of `3`).\n     `min_S = min(7, 4 + b[1]) = min(7, 4 + 3) = 7`.\n   - `val_a = 4`: `target_b = 7 - 4 = 3`. `bisect_left(b, 3)` returns `1`.\n     `min_S = min(7, 4 + 3) = 7`.\n   - `val_a = 4`: `target_b = 7 - 4 = 3`. `bisect_left(b, 3)` returns `1`.\n     `min_S = min(7, 4 + 3) = 7`.\n   - `val_a = 5`: `target_b = 7 - 5 = 2`. `bisect_left(b, 2)` returns `1`.\n     `min_S = min(7, 5 + b[1]) = min(7, 5 + 3) = 7`.\n   - `val_a = 6`: `target_b = 7 - 6 = 1`. `bisect_left(b, 1)` returns `1`.\n     `min_S = min(7, 6 + b[1]) = min(7, 6 + 3) = 7`.\n   So, `min_vasya_score_overall = 7`.\n\n   Now, calculate `worst_rank = count_ge_S(7)`:\n   `a = [3, 4, 4, 4, 5, 6]`\n   `b = [0, 3, 4, 4, 6, 8]`\n   `S = 7`\n   `count = 0`, `i = 0`, `j = 5`\n   - `a[0] + b[5] = 3 + 8 = 11 >= 7`: `count = 1`, `i = 1`, `j = 4`\n   - `a[1] + b[4] = 4 + 6 = 10 >= 7`: `count = 2`, `i = 2`, `j = 3`\n   - `a[2] + b[3] = 4 + 4 = 8 >= 7`: `count = 3`, `i = 3`, `j = 2`\n   - `a[3] + b[2] = 4 + 4 = 8 >= 7`: `count = 4`, `i = 4`, `j = 1`\n   - `a[4] + b[1] = 5 + 3 = 8 >= 7`: `count = 5`, `i = 5`, `j = 0`\n   - `a[5] + b[0] = 6 + 0 = 6 < 7`: `i = 6`\n   Loop ends. `count = 5`.\n   So, the worst rank is **5**.\n\nFinal Output: `1 5`\n\n```python\nimport sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Sort arrays for efficient processing\n    a.sort()\n    b.sort()\n\n    # Best Rank: Always 1\n    # Vasya can choose the largest score from tour 1 (a[n-1]) and largest from tour 2 (b[n-1]).\n    # His total score would be a[n-1] + b[n-1].\n    # This sum is guaranteed to be >= x because it's the maximum possible sum,\n    # and the problem guarantees that at least one pair sums to >= x.\n    # No one can score strictly higher than a[n-1] + b[n-1].\n    # Due to the tie-breaking rule, Vasya can be assigned 1st place if he's tied for the highest score.\n    best_rank = 1\n\n    # Worst Rank:\n    # We need to find the minimum possible score S_V that Vasya could achieve (S_V >= x).\n    # Then, we find the maximum number of participants (including Vasya) who can score >= S_V.\n    # This maximum count will be Vasya's worst rank.\n\n    # Step 1: Find the minimum possible score S_V Vasya can achieve such that S_V >= x.\n    min_vasya_score = float('inf')\n    for val_a in a:\n        # For current val_a, find smallest val_b such that val_a + val_b >= x\n        # This means val_b >= x - val_a\n        target_b = x - val_a\n        \n        # Use bisect_left to find the index of the first element in b that is >= target_b\n        idx = bisect_left(b, target_b)\n        \n        if idx < n:\n            # If such a b[idx] exists, calculate the sum and update min_vasya_score\n            min_vasya_score = min(min_vasya_score, val_a + b[idx])\n    \n    # Step 2: Calculate the maximum number of participants who can score >= min_vasya_score.\n    # This is done using a two-pointer approach on sorted 'a' and 'b'.\n    \n    # count_ge_S(S) function:\n    # Returns the maximum number of pairs (a_p, b_q) that can be formed such that a_p + b_q >= S.\n    \n    count = 0\n    i = 0  # Pointer for sorted 'a' (starts from smallest)\n    j = n - 1 # Pointer for sorted 'b' (starts from largest)\n\n    while i < n and j >= 0:\n        if a[i] + b[j] >= min_vasya_score:\n            # This pair (a[i], b[j]) meets the condition.\n            # We use a[i] and b[j] and try to form another pair.\n            count += 1\n            i += 1\n            j -= 1\n        else:\n            # a[i] + b[j] < min_vasya_score.\n            # Since a[i] is the smallest remaining 'a' and b[j] is the largest remaining 'b',\n            # a[i] cannot form a sum >= min_vasya_score with any remaining 'b' values.\n            # So, a[i] cannot be part of such a pair. We discard a[i].\n            i += 1\n            \n    worst_rank = count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Sort arrays for efficient processing\n    a.sort()\n    b.sort()\n\n    # Best Rank: Always 1\n    # Vasya can choose the largest score from tour 1 (a[n-1]) and largest from tour 2 (b[n-1]).\n    # His total score would be a[n-1] + b[n-1].\n    # This sum is guaranteed to be >= x because it's the maximum possible sum,\n    # and the problem guarantees that at least one pair sums to >= x.\n    # No one can score strictly higher than a[n-1] + b[n-1].\n    # Due to the tie-breaking rule, Vasya can be assigned 1st place if he's tied for the highest score.\n    best_rank = 1\n\n    # Worst Rank:\n    # We need to find the minimum possible score S_V that Vasya could achieve (S_V >= x).\n    # Then, we find the maximum number of participants (including Vasya) who can score >= S_V.\n    # This maximum count will be Vasya's worst rank.\n\n    # Step 1: Find the minimum possible score S_V Vasya can achieve such that S_V >= x.\n    min_vasya_score = float('inf')\n    for val_a in a:\n        # For current val_a, find smallest val_b such that val_a + val_b >= x\n        # This means val_b >= x - val_a\n        target_b = x - val_a\n        \n        # Use bisect_left to find the index of the first element in b that is >= target_b\n        idx = bisect_left(b, target_b)\n        \n        if idx < n:\n            # If such a b[idx] exists, calculate the sum and update min_vasya_score\n            min_vasya_score = min(min_vasya_score, val_a + b[idx])\n    \n    # Step 2: Calculate the maximum number of participants who can score >= min_vasya_score.\n    # This is done using a two-pointer approach on sorted 'a' and 'b'.\n    \n    # count_ge_S(S) function:\n    # Returns the maximum number of pairs (a_p, b_q) that can be formed such that a_p + b_q >= S.\n    \n    count = 0\n    i = 0  # Pointer for sorted 'a' (starts from smallest)\n    j = n - 1 # Pointer for sorted 'b' (starts from largest)\n\n    while i < n and j >= 0:\n        if a[i] + b[j] >= min_vasya_score:\n            # This pair (a[i], b[j]) meets the condition.\n            # We use a[i] and b[j] and try to form another pair.\n            count += 1\n            i += 1\n            j -= 1\n        else:\n            # a[i] + b[j] < min_vasya_score.\n            # Since a[i] is the smallest remaining 'a' and b[j] is the largest remaining 'b',\n            # a[i] cannot form a sum >= min_vasya_score with any remaining 'b' values.\n            # So, a[i] cannot be part of such a pair. We discard a[i].\n            i += 1\n            \n    worst_rank = count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 4065,
        "thoughts_token_count": 7168
    }
}