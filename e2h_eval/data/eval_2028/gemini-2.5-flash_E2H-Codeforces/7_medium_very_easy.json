{
    "start": 1758016321.3178167,
    "end": 1758016420.3641841,
    "start-formatted": "2025-09-16 18:52 KST",
    "end-formatted": "2025-09-16 18:53 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Analyzing Snowflake Graph Vertex Counts**\n\nOkay, so I'm tasked with figuring out if a given number, `n`, can represent the vertices in a \"snowflake\" graph.  This means understanding how many vertices are in these snowflake structures and if `n` fits the pattern. I know the snowflake construction: start with a center vertex, connect it to `k` new vertices, then connect any vertex that's connected to just one other vertex to `k` more new vertices. This last step *must* be done at least once, which is key.\n\nMy initial thought is to count the vertices based on how many times we apply that third step (connecting to `k` more vertices).  If we do it once, we start with 1 (the center), add `k`, and then add `k^2`, totaling `1 + k + k^2`. This must happen! Applying this step again adds `k^3`, then `k^4`, and so on. This looks like a geometric series.\n\nThis suggests that the total number of vertices, `n`, can be written as `n = 1 + k + k^2 + ... + k^d` where `k > 1` (the number of branches) and `d >= 2` (since the third step has to be done at least once, meaning at least to the second level). This simplifies to `n = (k^(d+1) - 1) / (k - 1)`.\n\nSo, the problem boils down to checking if for any given `n` (up to 10^18), I can find integer values for `k` and `d` that satisfy that formula and respect the `k > 1` and `d >= 2` constraints. I also need to be mindful of potential integer overflows during these calculations.\n\nI started by checking some specific cases, like when `d` is exactly 2, so the expression becomes a simple quadratic. For `d=2`,  `n = 1 + k + k^2`. It's a solvable quadratic equation for k, but I need to ensure that the solution for k results in an integer greater than 1. This means checking if `4n-3` is a perfect square. If it is, then the value can be determined for `k`.\n\nThen, I have to consider larger `d` values. If `d` is small, like 3 or 4, I can iterate through possible values of `k` and test. However, larger values of `d` need a different strategy. My plan is to loop through different `d` and for each loop, binary search for the value of `k`.  This is because for a given `d`, the equation becomes monotonic. The upper bound for `k` decreases rapidly with increasing `d` because the term involving `k` in the equation has an exponential form. I'll need to carefully manage the potential overflows during the calculations. Since `k > 1`, and `n` is up to 10^18, I have a reasonable upper bound for my `k` values, and I can avoid huge numbers, even if `d` is as big as 60. I also need an optimized binary search in the inner loop with careful overflow checking!\n\nHere's the approach: check small numbers directly (less than 7). If n is 7 or larger, I start with `D = 3`, test if that results in a valid value for `k`. Otherwise, I loop for values of `D` from `4` up to at most `60`, and perform a binary search within this loop to determine if there is a valid value for `k`. I must carefully check the `k` bounds. At each step, I calculate the `current_sum` safely, making sure no intermediate number exceeds the integer limits. If a valid `k` is found, I return \"YES\". Otherwise, if no combination of `k` and `d` works, I print \"NO\".\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1. Start with 1 central vertex.\n2. Connect the central vertex to `k` new vertices, where `k > 1`.\n3. Each vertex that is connected to only one other vertex is connected to `k` more new vertices. This step must be done at least once.\n\nLet's analyze the number of vertices based on these rules:\n- Initially: 1 vertex (the center).\n- After step 2: `1 + k` vertices. The `k` new vertices are connected only to the center.\n- After applying step 3 once: Each of the `k` vertices from step 2 is connected to `k` new vertices. This adds `k * k = k^2` vertices. Total vertices: `1 + k + k^2`. The `k^2` new vertices are now the leaves.\n- If step 3 is applied again: Each of the `k^2` leaf vertices is connected to `k` new vertices. This adds `k^2 * k = k^3` vertices. Total vertices: `1 + k + k^2 + k^3`.\n\nIn general, if step 3 is applied `d` times (where `d >= 1`), the total number of vertices will be `1 + k + k^2 + ... + k^(d+1)`.\nLet `D = d+1`. Since `d >= 1`, we must have `D >= 2`.\nThe problem statement \"This step should be done at least once\" implies that the graph must have at least the `k^2` level of vertices. This means the series must go up to `k^2` at minimum. So `D` must be at least 3 (`1 + k + k^2`).\n\nThus, we are looking for `n` such that `n = 1 + k + k^2 + ... + k^(D-1)` for some integers `k > 1` and `D >= 3`.\nThis is a geometric series sum: `n = (k^D - 1) / (k - 1)`.\n\nWe need to check if such `k` and `D` exist for a given `n` (`1 <= n <= 10^18`).\n\nThe strategy is as follows:\n\n1.  **Small `n` values:**\n    The smallest possible snowflake occurs when `k=2` and `D=3`. This gives `1 + 2 + 2^2 = 1 + 2 + 4 = 7` vertices. Any `n < 7` cannot be a snowflake. So, for `n` from 1 to 6, the answer is \"NO\".\n\n2.  **Case `D = 3` (i.e., `d = 2`):**\n    `n = 1 + k + k^2`.\n    Rearranging gives `k^2 + k + (1 - n) = 0`.\n    Using the quadratic formula for `k`: `k = (-1 + sqrt(1 - 4 * (1 - n))) / 2` (since `k > 0`).\n    `k = (-1 + sqrt(4n - 3)) / 2`.\n    For `k` to be an integer greater than 1:\n    *   `4n - 3` must be a perfect square. Let `4n - 3 = s^2`.\n    *   `s` must be odd (since `s^2 = 4n - 3` is always odd). This ensures `s-1` is even.\n    *   `k = (s - 1) / 2` must be greater than 1, which means `s - 1 > 2`, so `s > 3`.\n    We can check this by calculating `s = round((4n - 3)**0.5)`. If `s*s == 4n - 3` and `s > 3`, then a valid `k` exists.\n\n3.  **Case `D > 3`:**\n    The maximum value `n` can take is `10^18`.\n    If `k=2` (the smallest `k`), then `n = 2^D - 1`.\n    `2^D - 1 <= 10^18 \\implies 2^D <= 10^18 + 1`.\n    `D <= log2(10^18 + 1) \\approx 59.79`. So, `D` can go up to approximately 60.\n    We can iterate `D` from `4` up to `60` (or `61` for safety).\n    For each `D`, we need to find `k > 1` such that `(k^D - 1) / (k - 1) = n`.\n    The function `f(k) = (k^D - 1) / (k - 1)` is monotonically increasing for `k > 1`. We can use binary search to find `k`.\n    The range for binary search for `k`:\n    *   Lower bound: `2`.\n    *   Upper bound: `k^(D-1) < n \\implies k < n^(1/(D-1))`. For `D=4`, `k < n^(1/3) \\approx (10^18)^(1/3) = 10^6`. For `D=60`, `k < n^(1/59) \\approx (10^18)^(1/59) \\approx 2`. A safe upper bound for `k` can be `min(n, int(n**(1.0/(D-1))) + 2)`. Or simply `10^9 + 7` as `k` cannot exceed `sqrt(n)` for `D=3`.\n\n    Inside the binary search, we need a helper function `calculate_sum(k, D, n_target)` to compute `1 + k + ... + k^(D-1)` and check for overflows:\n    ```python\n    def calculate_sum(k_val, D_val, n_target):\n        current_sum = 0\n        term = 1\n        for _ in range(D_val):\n            current_sum += term\n            if current_sum > n_target:\n                return n_target + 1 # Sum exceeded n_target\n            \n            # Check for overflow before multiplying term for the next iteration\n            # If current term * k_val would exceed n_target, then the next term is too large.\n            # This handles cases where term * k_val might exceed sys.maxsize if n_target is large.\n            if _ < D_val - 1: # Only multiply if not the last term\n                if k_val > n_target // term: # term * k_val would exceed n_target\n                    term = n_target + 1 # Indicate term is too large\n                    break\n                term *= k_val\n        return current_sum\n    ```\n    The overall complexity will be `sum_{D=4}^{60} (log(N^(1/(D-1))) * D)`. This simplifies to approximately `sum_{D=4}^{60} ( (1/(D-1)) * log(N) * D )`. `log(N)` (base 2) is about 60. The term `D/(D-1)` is close to 1. So total operations per test case is roughly `60 * 60 = 3600`, which is efficient enough for `10^4` test cases (`3.6 * 10^7` total operations).\n\n**Example Walkthrough for n=15:**\n1. `n=15` is not `< 7`.\n2. Check `D=3`: `4n - 3 = 4*15 - 3 = 60 - 3 = 57`. `sqrt(57)` is not an integer. So `D=3` is not a solution.\n3. Check `D > 3`:\n   - `D=4`: Binary search for `k` in `[2, int(15**(1/3))+2] = [2, 3]`.\n     - Try `k=2`: `calculate_sum(2, 4, 15) = 1+2+4+8 = 15`. Found! `k=2, D=4` is a solution. Output \"YES\".\n\n**Example Walkthrough for n=10^18:**\n1. `n=10^18` is not `< 7`.\n2. Check `D=3`: `4*10^18 - 3`. `sqrt(4*10^18 - 3)` is `sqrt(4*10^18)` approximately `2*10^9`.\n   `s = round((4*10**18 - 3)**0.5)`.\n   `s*s` might not be exactly `4*10^18 - 3`.\n   `s = 1999999999.999999999...` so `s = 2000000000`.\n   `2000000000^2 = 4 * 10^18`. This is not `4*10^18 - 3`. So `D=3` is not a solution.\n3. Check `D > 3`: Loop `D` from 4 to 60.\n   For `D=4`, `k` up to `(10^18)^(1/3) = 10^6`.\n   For `D=60`, `k` up to `(10^18)^(1/59) = 2`.\n   The binary search will not find any `k` for any `D`. So output \"NO\". (This matches example).\n\n```python\nimport sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: n < 7\n    # Smallest snowflake (k=2, D=3) has 1+2+2^2 = 7 vertices.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 2: D = 3 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1-n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s_sqrt = int(val**0.5) # Using int() truncates, so we check around it\n    \n    # Check s_sqrt and s_sqrt+1\n    found_k_for_D3 = False\n    for s in [s_sqrt, s_sqrt + 1]:\n        if s * s == val:\n            # s must be odd for (s-1)/2 to be integer, but 4n-3 is always odd, so s is always odd.\n            # k = (s - 1) / 2\n            k = (s - 1) // 2\n            if k > 1: # k must be > 1\n                found_k_for_D3 = True\n                break\n    \n    if found_k_for_D3:\n        sys.stdout.write(\"YES\\n\")\n        return\n\n    # Case 3: D > 3 (n = 1 + k + k^2 + ... + k^(D-1))\n    # Iterate D from 4 up to around 60 (since 2^60-1 is approx 10^18)\n    \n    # Function to calculate sum 1 + k + k^2 + ... + k^(D-1) safely\n    def calculate_sum(k_val, D_val, n_target):\n        current_sum = 0\n        term = 1\n        for _ in range(D_val):\n            current_sum += term\n            if current_sum > n_target:\n                return n_target + 1 # Sum exceeded n_target\n            \n            # Check for overflow before multiplying term for the next iteration\n            # If current term * k_val would exceed n_target, then the next term is too large.\n            # This handles cases where term * k_val might exceed sys.maxsize if n_target is large.\n            if _ < D_val - 1: # Only multiply if not the last term\n                # Check if term * k_val would exceed n_target (or Python's int limit, which is effectively infinite for typical numbers, but good practice to check against n_target)\n                if k_val > n_target // term: \n                    term = n_target + 1 # Indicate term is too large\n                    break\n                term *= k_val\n        return current_sum\n\n    # Max D is around 60 for k=2.\n    # We can iterate D from 4 up to 60.\n    for D in range(4, 61): # D represents the number of terms in the sum (k^0 to k^(D-1))\n        # Binary search for k\n        low = 2\n        # Upper bound for k: k^(D-1) < n => k < n^(1/(D-1))\n        # For D=4, k < n^(1/3) ~ (10^18)^(1/3) = 10^6\n        # For D=60, k < n^(1/59) ~ (10^18)^(1/59) ~ 2\n        # A safe upper bound for k is min(n, int(n**(1.0/(D-1))) + 2)\n        # Using a fixed large number like 10^9+7 is also okay as k cannot exceed 10^9 for n=10^18 and D>=3\n        high = int(n**(1.0/(D-1))) + 2 if D > 1 else n # D is always > 1 here\n        high = min(high, 10**9 + 7) # Cap high to avoid excessively large initial range\n        \n        found_k_for_current_D = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = calculate_sum(mid_k, D, n)\n            \n            if current_sum == n:\n                found_k_for_current_D = True\n                break\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n\n                high = mid_k - 1\n        \n        if found_k_for_current_D:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # If no k and D found after all checks\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: n < 7\n    # Smallest snowflake (k=2, D=3) has 1+2+2^2 = 7 vertices.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 2: D = 3 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1-n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s_sqrt = int(val**0.5) # Using int() truncates, so we check around it\n    \n    # Check s_sqrt and s_sqrt+1\n    found_k_for_D3 = False\n    for s in [s_sqrt, s_sqrt + 1]:\n        if s * s == val:\n            # s must be odd for (s-1)/2 to be integer, but 4n-3 is always odd, so s is always odd.\n            # k = (s - 1) / 2\n            k = (s - 1) // 2\n            if k > 1: # k must be > 1\n                found_k_for_D3 = True\n                break\n    \n    if found_k_for_D3:\n        sys.stdout.write(\"YES\\n\")\n        return\n\n    # Case 3: D > 3 (n = 1 + k + k^2 + ... + k^(D-1))\n    # Iterate D from 4 up to around 60 (since 2^60-1 is approx 10^18)\n    \n    # Function to calculate sum 1 + k + k^2 + ... + k^(D-1) safely\n    def calculate_sum(k_val, D_val, n_target):\n        current_sum = 0\n        term = 1\n        for _ in range(D_val):\n            current_sum += term\n            if current_sum > n_target:\n                return n_target + 1 # Sum exceeded n_target\n            \n            # Check for overflow before multiplying term for the next iteration\n            # If current term * k_val would exceed n_target, then the next term is too large.\n            # This handles cases where term * k_val might exceed sys.maxsize if n_target is large.\n            if _ < D_val - 1: # Only multiply if not the last term\n                # Check if term * k_val would exceed n_target (or Python's int limit, which is effectively infinite for typical numbers, but good practice to check against n_target)\n                if k_val > n_target // term: \n                    term = n_target + 1 # Indicate term is too large\n                    break\n                term *= k_val\n        return current_sum\n\n    # Max D is around 60 for k=2.\n    # We can iterate D from 4 up to 60.\n    for D in range(4, 61): # D represents the number of terms in the sum (k^0 to k^(D-1))\n        # Binary search for k\n        low = 2\n        # Upper bound for k: k^(D-1) < n => k < n^(1/(D-1))\n        # For D=4, k < n^(1/3) ~ (10^18)^(1/3) = 10^6\n        # For D=60, k < n^(1/59) ~ (10^18)^(1/59) ~ 2\n        # A safe upper bound for k is min(n, int(n**(1.0/(D-1))) + 2)\n        # Using a fixed large number like 10^9+7 is also okay as k cannot exceed 10^9 for n=10^18 and D>=3\n        high = int(n**(1.0/(D-1))) + 2 if D > 1 else n # D is always > 1 here\n        high = min(high, 10**9 + 7) # Cap high to avoid excessively large initial range\n        \n        found_k_for_current_D = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = calculate_sum(mid_k, D, n)\n            \n            if current_sum == n:\n                found_k_for_current_D = True\n                break\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n\n                high = mid_k - 1\n        \n        if found_k_for_current_D:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # If no k and D found after all checks\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 3530,
        "thoughts_token_count": 6221
    }
}