{
    "start": 1758009420.9045033,
    "end": 1758009627.8020895,
    "start-formatted": "2025-09-16 16:57 KST",
    "end-formatted": "2025-09-16 17:00 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Initial Assessment: \"Flawed Flow\" - A Competitive Programming Challenge**\n\nOkay, so I'm looking at this \"Flawed Flow\" problem, and it seems like a classic max-flow variation, but with a few interesting twists. The core of the problem is directing the edges of a given undirected graph to satisfy certain flow constraints.  I'm given an undirected graph with `n` vertices and `m` edges, each with a capacity `ci`. My goal is to assign a direction to each edge, either `ai -> bi` (represented by `0`) or `bi -> ai` (represented by `1`), such that the resulting directed graph meets the specified criteria.\n\nThe first condition is the standard flow conservation: for all vertices *except* the source and sink, the incoming flow must equal the outgoing flow. The second and crucial conditions explicitly defines the first node (`1`) as the source, meaning no incoming edges. All flow starts from there.  The implicit sink, vertex `n`, also plays a special role, usually a flow ends in it.\n\nThe real key here is the \"no cycles\" constraint.  That screams \"directed acyclic graph\" (DAG) to me.  This automatically suggests a topological sort will be relevant.  Since flow generally moves from lower-ordered nodes to higher-ordered nodes in a topological ordering, that provides a useful structure to tackle this.\n\nI'm thinking about how to represent the flow at each vertex.  I'll need to keep track of a `balance[v]` for each vertex `v`.  This will represent the difference between the incoming and outgoing flow at that vertex. I'll need to figure out a smart way to ensure that this balance is maintained, and how to determine the direction of each edge based on this balance.  The graph is connected, and a solution is guaranteed to exist. This problem looks solvable, and the constraints are pretty reasonable.  I'm ready to dive into the algorithm.\n",
    "response": "The problem asks us to direct each edge of a given undirected graph, which has an associated flow volume `ci`, such that a set of conditions are met. These conditions are:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the total incoming flow equals the total outgoing flow.\n2.  **Source Condition:** Vertex 1 (source) has no incoming edges.\n3.  **No Cycles:** The resulting directed graph must not contain any cycles.\n\nWe are guaranteed that a solution always exists.\n\nThe \"no cycles\" condition is very powerful. It implies that the resulting directed graph must be a Directed Acyclic Graph (DAG). In a DAG, there exists a topological ordering of vertices. Flow typically goes from vertices earlier in the ordering to vertices later in the ordering.\n\nLet's consider the implications of the flow conditions:\n*   For vertex 1 (source), all connected edges must be directed *away* from 1.\n*   For vertex `n` (sink), while not explicitly stated, in a typical max-flow problem, all flow goes *into* `n` and no flow leaves `n`. This means all connected edges to `n` must be directed *towards* `n`.\n*   For any intermediate vertex `v` (1 < `v` < `n`), the net flow (incoming - outgoing) must be zero.\n\nLet's define `balance[v]` for each vertex `v`. Initially, `balance[v] = 0`.\nWhen we direct an edge `(u, v)` with flow `c` as `u -> v`, we can think of it as `u` \"losing\" `c` flow and `v` \"gaining\" `c` flow.\nSo, `balance[u]` decreases by `c` and `balance[v]` increases by `c`.\n\nThe source vertex 1 must have no incoming edges. This means all edges connected to 1 must be directed `1 -> X`.\nThe sink vertex `n` must have no outgoing edges. This means all edges connected to `n` must be directed `X -> n`.\nFor intermediate vertices `v`, `balance[v]` must be 0 after all edges are directed.\n\nConsider processing vertices using a queue. We can start with vertices whose `balance` can be determined.\nThe total flow entering `n` must be equal to the total flow leaving `1`.\nLet's initialize `balance[v]` for all `v` to 0. For each edge `(a, b, c)`, we add `c` to `balance[a]` and `c` to `balance[b]`. This `balance[v]` represents the total flow *potential* connected to `v` if all edges were outgoing from `v`. This is not very useful.\n\nA better approach might be to try to satisfy the flow conservation for intermediate nodes.\nFor each vertex `v`, let `current_in_flow[v]` be the sum of flows of edges directed *into* `v`, and `current_out_flow[v]` be the sum of flows of edges directed *out of* `v`.\nInitially, all `current_in_flow` and `current_out_flow` are 0.\nWhen an edge `(u, v)` with flow `c` is processed:\n*   If we direct it `u -> v`: `current_out_flow[u] += c`, `current_in_flow[v] += c`.\n*   If we direct it `v -> u`: `current_out_flow[v] += c`, `current_in_flow[u] += c`.\n\nFor `v` (1 < `v` < `n`), we need `current_in_flow[v] == current_out_flow[v]`.\nThe problem states that a solution always exists and the graph is connected. The \"no cycles\" condition suggests a topological sort-like approach.\n\nLet's consider the total flow that must pass *through* each vertex.\nA common technique for this type of problem involving flow conservation and DAGs is to use a \"deficit/surplus\" approach.\nFor each vertex `v`, we can calculate the total \"potential\" flow that could come into or leave it.\nLet `total_flow_connected[v]` be the sum of `c_i` for all edges incident to `v`.\n\nConsider a different perspective: each vertex `v` (1 < `v` < `n`) must have its net flow be zero.\nLet `net_flow[v]` be `sum(incoming_flow) - sum(outgoing_flow)`. We want `net_flow[v] = 0` for `1 < v < n`.\nFor vertex 1, we want `net_flow[1] <= 0` (no incoming flow, only outgoing).\nFor vertex `n`, we want `net_flow[n] >= 0` (only incoming flow, no outgoing).\n\nWe can use a queue-based approach. We maintain a `current_balance[v]` for each vertex `v`.\nInitialize `current_balance[v] = 0` for all `v`.\nFor each edge `(u, v, c)`:\n*   If `u = 1`, it must be `1 -> v`. So, `current_balance[1] -= c`, `current_balance[v] += c`. Record direction `u -> v`.\n*   If `v = 1`, it must be `1 -> u`. So, `current_balance[1] -= c`, `current_balance[u] += c`. Record direction `v -> u`.\n*   If `u = n`, it must be `u -> n`. So, `current_balance[u] -= c`, `current_balance[n] += c`. Record direction `u -> n`.\n*   If `v = n`, it must be `v -> n`. So, `current_balance[v] -= c`, `current_balance[n] += c`. Record direction `v -> n`.\n\nThis handles edges connected to source/sink directly. What about edges `(u, v)` where both `u, v` are intermediate nodes (1 < `u, v` < `n`)?\nFor these, we don't know the direction yet. We can put them aside.\nLet's refine this. We can use a queue to process vertices.\nInitially, for each vertex `v`, we calculate its `degree[v]` (sum of flow volumes of all incident edges). This is the total flow that *must* pass through `v` one way or another.\nLet's define `deficit[v]` as the amount of flow that still needs to be \"sent out\" from `v` to balance its incoming flow, or \"received\" by `v` to balance its outgoing flow.\n\nA simpler approach often works for DAGs and flow conservation:\nStart with `balance[v] = 0` for all `v`.\nFor each edge `(u, v, c)`:\n*   If we decide `u -> v`: `balance[u] -= c`, `balance[v] += c`.\n*   If we decide `v -> u`: `balance[v] -= c`, `balance[u] += c`.\n\nThe goal is `balance[v] = 0` for `1 < v < n`.\nFor `v = 1`, `balance[1]` should be negative (net outgoing flow).\nFor `v = n`, `balance[n]` should be positive (net incoming flow).\n\nConsider a single source shortest path like algorithm or a topological sort.\nSince a solution always exists and no cycles are allowed, there must be a way to direct edges such that flow always moves \"forward\" in some sense.\n\nLet's try a DFS or BFS from the source (vertex 1).\nWhen we are at a vertex `u`, and we have an unvisited neighbor `v` connected by an edge `(u, v, c)`:\nIf we direct `u -> v`, this contributes `c` to `u`'s outgoing flow and `c` to `v`'s incoming flow.\nIf we direct `v -> u`, this contributes `c` to `v`'s outgoing flow and `c` to `u`'s incoming flow.\n\nThis problem is a classic application of Euler tours or specific graph traversal if we consider the \"balance\" of flow.\nLet `current_flow_sum[v]` be the sum of flow values of edges incident to `v` that have *not yet been directed*.\nLet `net_flow[v]` be `sum(incoming_flow) - sum(outgoing_flow)` for directed edges.\nInitially, `net_flow[v] = 0` for all `v`.\n\nWe want to satisfy `net_flow[v] = 0` for `1 < v < n`.\nConsider a queue of vertices `q`. Add vertex `n` to the queue.\nWhy `n`? Because `n` is the sink, and all flow must eventually arrive there. We can think of \"balancing\" the flow from the sink backward.\nNo, that's not right. The source `1` has no incoming edges. This is a strong constraint. All edges connected to `1` must be directed `1 -> X`.\nLet's try processing from `1`.\n\nWe can use a DFS-like approach to direct edges.\nMaintain `balance[v]` for each vertex `v`. Initially, `balance[v] = 0`.\nWhen we traverse an edge `(u, v)` with flow `c`:\nIf we direct `u -> v`, we update `balance[u] -= c` and `balance[v] += c`.\nIf we direct `v -> u`, we update `balance[v] -= c` and `balance[u] += c`.\n\nThe key is that for `1 < v < n`, `balance[v]` must ultimately be 0.\nFor `v = 1`, `balance[1]` must be negative.\nFor `v = n`, `balance[n]` must be positive.\n\nLet's try to maintain `balance[v]` as the sum of flows of edges *already directed out of `v`* minus sum of flows of edges *already directed into `v`*.\nSo, we want `balance[v] = 0` for `1 < v < n`.\nFor `v = 1`, `balance[1] <= 0`. For `v = n`, `balance[n] >= 0`.\n\nConsider a queue `Q` for vertices that need to be \"balanced\".\nInitialize `current_balance[v] = 0` for all `v`.\nFor each edge `(u, v, c)`:\n  Store `(u, v, c, edge_idx)` in an adjacency list for both `u` and `v`.\n  `total_incident_flow[u] += c`\n  `total_incident_flow[v] += c`\n\nThe problem is that `total_incident_flow[v]` is not the `current_balance[v]` that we want to zero out.\n\nLet's consider the problem as finding a valid direction for each edge.\nWe can use a DFS from vertex 1. When we traverse an edge `(u, v)`:\nIf `v` is already visited, we must have visited it via some path. To avoid cycles, we should direct `u -> v` if `u` was visited \"before\" `v` in the DFS tree, or `v -> u` if `v` was visited \"before\" `u`. This is the standard way to build a DFS tree and classify edges.\nHowever, this doesn't directly help with flow conservation.\n\nThe problem guarantees a solution exists and no cycles. This implies that the graph, once directed, will be a DAG.\nIf we consider the sum of all flows `C = sum(c_i)`, then the total flow out of source 1 is `F_total`. The total flow into sink `n` is also `F_total`.\nFor any intermediate node `v`, `in_flow[v] = out_flow[v]`.\n\nLet's maintain `current_sum_flow[v]`: for each vertex `v`, this will be the sum of flows of edges that have been directed *into* `v` minus the sum of flows of edges that have been directed *out of* `v`.\nSo, for `1 < v < n`, we want `current_sum_flow[v] = 0`.\nFor `v = 1`, we want `current_sum_flow[1] < 0`.\nFor `v = n`, we want `current_sum_flow[n] > 0`.\n\nInitialize `current_sum_flow[v] = 0` for all `v`.\nInitialize `ans[edge_idx]` array.\nFor each vertex `v`, keep a list of its incident edges that have not yet been directed.\n`adj[v] = [(neighbor, flow_c, edge_idx, is_reversed_flag)]`\n\nConsider a queue `Q` for vertices whose `current_sum_flow` is known, and they have exactly one undirected edge remaining.\nThis is a common pattern for Euler path type problems or balancing problems on trees.\nIf a vertex `v` has `current_sum_flow[v] != 0` and it has only one undirected edge `(v, u)` with flow `c` remaining, then the direction of this edge is forced.\n*   If `current_sum_flow[v] > 0`, then `v` has a surplus of incoming flow. To balance it, flow must go *out* of `v` through `(v, u)`. So, `v -> u`.\n    Update `current_sum_flow[v] -= c`, `current_sum_flow[u] += c`.\n*   If `current_sum_flow[v] < 0`, then `v` has a deficit of incoming flow (or surplus of outgoing flow). To balance it, flow must come *into* `v` through `(v, u)`. So, `u -> v`.\n    Update `current_sum_flow[v] += c`, `current_sum_flow[u] -= c`.\n\nThis strategy works for tree-like structures. The \"no cycles\" condition is key.\nThe overall graph might not be a tree, but if we consider the remaining undirected edges, they might form a tree or forest.\n\nLet's try this:\n1.  Represent the graph using an adjacency list. For each edge `(u, v, c)` with original index `idx`, store `(v, c, idx)` in `adj[u]` and `(u, c, idx)` in `adj[v]`.\n2.  Initialize `ans` array of size `m` with -1 (undetermined).\n3.  Initialize `current_sum_flow[v] = 0` for all `v`.\n4.  Initialize `degree_of_undirected_edges[v]` for all `v` to be the actual degree of `v`.\n5.  Create a queue `q`.\n6.  Add all vertices `v` (1 < `v` < `n`) with `degree_of_undirected_edges[v] = 1` to `q`. These are leaves in the \"intermediate\" subgraph.\n7.  While `q` is not empty:\n    a.  Dequeue vertex `u`.\n    b.  If `u == 1` or `u == n`, continue (we only balance intermediate nodes).\n    c.  Find the unique undirected edge `(u, v)` with flow `c` (and original index `idx`).\n    d.  If `current_sum_flow[u]` is positive (surplus of incoming flow):\n        i.   Direct `u -> v`. Set `ans[idx] = 0` if `u` was `ai` and `v` was `bi`, else `ans[idx] = 1`.\n        ii.  `current_sum_flow[u] -= c`\n        iii. `current_sum_flow[v] += c`\n    e.  If `current_sum_flow[u]` is negative (deficit of incoming flow):\n        i.   Direct `v -> u`. Set `ans[idx] = 1` if `u` was `ai` and `v` was `bi`, else `ans[idx] = 0`.\n        ii.  `current_sum_flow[u] += c`\n        iii. `current_sum_flow[v] -= c`\n    f.  Update `degree_of_undirected_edges[u] -= 1` and `degree_of_undirected_edges[v] -= 1`.\n    g.  Mark edge `(u, v)` as directed.\n    h.  If `degree_of_undirected_edges[v] == 1` and `v` is not 1 or `n`, enqueue `v`.\n\nThis process will work for all intermediate nodes. What about the source and sink?\nThe problem states `1` has no incoming edges. This means all edges connected to `1` must be directed `1 -> X`.\nSimilarly, `n` must have no outgoing edges. All edges connected to `n` must be directed `X -> n`.\nThese are strong initial conditions. We should use them.\n\nRevised approach:\n1.  Store edges as `(u, v, c, original_idx)` tuples.\n2.  Create an adjacency list `adj[v]` storing `(neighbor, flow_c, original_idx)`.\n3.  Initialize `ans` array of size `m` with -1.\n4.  Initialize `current_balance[v] = 0` for all `v`. This `current_balance[v]` will track `sum(incoming_flow) - sum(outgoing_flow)`.\n5.  Initialize `num_undirected_edges[v]` for all `v` to be its actual degree.\n6.  Create a queue `q`.\n7.  For each vertex `v` from 1 to `n`:\n    If `v == 1`:\n        For each `(neighbor, flow_c, idx)` in `adj[v]`:\n            If `ans[idx]` is -1 (not yet directed):\n                `ans[idx] = 0` if `v` is `a_i` in the original edge, `1` otherwise (direct `v -> neighbor`).\n                `current_balance[v] -= flow_c`\n                `current_balance[neighbor] += flow_c`\n                `num_undirected_edges[v] -= 1`\n                `num_undirected_edges[neighbor] -= 1`\n                If `num_undirected_edges[neighbor] == 1` and `neighbor` is not 1 or `n`, add `neighbor` to `q`.\n    Else if `v == n`:\n        For each `(neighbor, flow_c, idx)` in `adj[v]`:\n            If `ans[idx]` is -1:\n                `ans[idx] = 1` if `v` is `a_i` in the original edge, `0` otherwise (direct `neighbor -> v`).\n                `current_balance[v] += flow_c`\n                `current_balance[neighbor] -= flow_c`\n                `num_undirected_edges[v] -= 1`\n                `num_undirected_edges[neighbor] -= 1`\n                If `num_undirected_edges[neighbor] == 1` and `neighbor` is not 1 or `n`, add `neighbor` to `q`.\n    Else (`v` is an intermediate node):\n        If `num_undirected_edges[v] == 1`, add `v` to `q`.\n\n    *Correction*: The above logic for `v=1` and `v=n` is problematic because `adj[v]` contains all edges, and we might process an edge twice or miscount `num_undirected_edges`.\n    A better way is to use a `visited_edge` set or boolean array.\n\nLet's use a `visited_edge` array `edge_processed[m]`.\nAnd `adj_list` stores `(neighbor, flow_c, original_idx, is_original_a_i_flag)`. The `is_original_a_i_flag` tells us if the current vertex `u` is `a_i` in `(a_i, b_i)`. If `u` is `a_i`, then `ans[original_idx]=0` means `u -> neighbor`. If `u` is `b_i`, then `ans[original_idx]=0` means `neighbor -> u`.\n\nRevised approach (using a DFS-like traversal from leaves of the \"balance\" problem):\n\n1.  Read `n, m`.\n2.  Create `adj_list[v]` as a list of `(neighbor, flow_c, original_idx, is_u_ai)` tuples. `is_u_ai` is `True` if `u` is `a_i` for this edge, `False` if `u` is `b_i`.\n    Example: if input is `a b c`, for `a`, add `(b, c, idx, True)`. For `b`, add `(a, c, idx, False)`.\n3.  Initialize `ans = [-1] * m`.\n4.  Initialize `balance = [0] * (n + 1)`. This `balance[v]` will track `sum(incoming_flow) - sum(outgoing_flow)`.\n5.  Initialize `undirected_degree = [0] * (n + 1)`. For each edge `(u, v, c, idx)`, increment `undirected_degree[u]` and `undirected_degree[v]`.\n6.  Create a `deque` `q`.\n7.  For `v` from 1 to `n`:\n    If `v != 1` and `v != n` and `undirected_degree[v] == 1`:\n        `q.append(v)`\n\n8.  While `q` is not empty:\n    a.  `u = q.popleft()`\n    b.  If `u == 1` or `u == n`: continue (these are special, we process them at the end or they don't get balanced this way).\n    c.  Find the unique undirected edge incident to `u`. Iterate through `adj_list[u]`:\n        For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n            If `ans[idx] == -1` (edge is undirected):\n                // This is the unique undirected edge for `u`.\n                // Direct it to balance `u`.\n                If `balance[u] < 0`: // `u` has more outgoing flow than incoming. Needs incoming. So `v -> u`.\n                    `ans[idx] = 1` if `is_u_ai` else `0`\n                    `balance[u] += flow_c`\n                    `balance[v] -= flow_c`\n                Else: // `balance[u] >= 0`. `u` has more incoming flow or is balanced. Needs outgoing. So `u -> v`.\n                    `ans[idx] = 0` if `is_u_ai` else `1`\n                    `balance[u] -= flow_c`\n                    `balance[v] += flow_c`\n\n                // Update degrees and potentially add `v` to queue\n                `undirected_degree[u] -= 1`\n                `undirected_degree[v] -= 1`\n                If `v != 1` and `v != n` and `undirected_degree[v] == 1`:\n                    `q.append(v)`\n                Break // Found and processed the edge\n\n9.  After the queue is empty, all intermediate nodes `v` (1 < `v` < `n`) should have `balance[v] == 0`.\n    The remaining undirected edges must form paths/components connecting `1` and `n`.\n    The sum of `balance[1]` and `balance[n]` should be 0 (total flow out of 1 equals total flow into n).\n    All remaining undirected edges must be directed such that `1` has net outgoing flow and `n` has net incoming flow.\n    This means all remaining undirected edges should be directed \"away\" from `1` and \"towards\" `n`.\n    Since the problem guarantees a solution and no cycles, all remaining undirected edges must form paths from `1` to `n`.\n    We can do a final DFS/BFS starting from `1` to direct these remaining edges.\n\nFinal DFS/BFS for remaining edges:\n1.  Use a `visited_node` array.\n2.  Create a stack/queue `dfs_stack`. Add `1` to `dfs_stack`. Mark `1` as `visited_node`.\n3.  While `dfs_stack` is not empty:\n    a.  `u = dfs_stack.pop()`\n    b.  For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n        If `ans[idx] == -1` (edge is still undirected):\n            // Direct `u -> v`\n            `ans[idx] = 0` if `is_u_ai` else `1`\n            If not `visited_node[v]`:\n                `visited_node[v] = True`\n                `dfs_stack.append(v)`\n\nThis approach seems robust. The first phase handles all intermediate nodes that become leaves in the undirected graph of remaining edges. The second phase handles the path(s) between `1` and `n`.\n\nLet's trace an example:\n`3 3`\n`3 2 10` (idx 0)\n`1 2 10` (idx 1)\n`3 1 5` (idx 2)\n\n`adj_list`:\n`1: [(2, 10, 1, True), (3, 5, 2, False)]`\n`2: [(3, 10, 0, False), (1, 10, 1, False)]`\n`3: [(2, 10, 0, True), (1, 5, 2, True)]`\n\n`ans = [-1, -1, -1]`\n`balance = [0, 0, 0, 0]`\n`undirected_degree = [0, 2, 2, 2]` (for nodes 1,2,3)\n\n`q`:\n`undirected_degree[2] = 2` (not 1)\nNo intermediate nodes have `undirected_degree = 1` initially. So `q` is empty.\n\nThis implies my initial assumption about `undirected_degree[v] == 1` for intermediate nodes is not always true.\nThe problem is that the \"no cycles\" condition means the graph of *all* edges is a DAG.\nThe first phase only works for components that are trees, or parts of trees.\nIf the graph contains cycles of intermediate nodes, this won't work. But the problem says \"no cycles\" in the *final directed graph*.\n\nThe total flow out of source 1 must equal the total flow into sink `n`.\nFor any vertex `v` (1 < `v` < `n`), `sum(in_flow) = sum(out_flow)`.\nThis implies that `sum(all_incident_flows)` must be an even number for `1 < v < n`. If it's odd, it's impossible to balance.\n`sum(all_incident_flows)` is not necessarily even. E.g., `1-2(5), 2-3(5)`. For `v=2`, sum is 10. `1->2(5), 2->3(5)`. `in=5, out=5`.\nWhat if `1-2(5), 2-3(10)`. `sum=15`. This means `2` must have `in_flow=out_flow=7.5`. But flows are integers.\nThe `c_i` are integers. So `in_flow` and `out_flow` must be integers.\nThis means `sum(c_i)` for all incident edges must be an even number for `1 < v < n`.\nLet `total_flow_at_v = sum(c_i for (v, neighbor, c_i))`. If `total_flow_at_v` is odd, then it's impossible to have `in_flow = out_flow` (because `in_flow + out_flow = total_flow_at_v`).\nLet's check example 1:\n`3 2 10`: `total_flow_at_3=10, total_flow_at_2=10`\n`1 2 10`: `total_flow_at_1=10, total_flow_at_2=10`\n`3 1 5`: `total_flow_at_3=5, total_flow_at_1=5`\n\nFinal `total_flow_at_v`:\n`1: 10 + 5 = 15`\n`2: 10 + 10 = 20`\n`3: 10 + 5 = 15`\n\nFor `v=2`, `total_flow_at_2 = 20` (even). So `in_flow = out_flow = 10`.\nThis means my `undirected_degree[v]` should be `total_flow_at_v % 2`. No, this is not correct.\n\nThe `balance` variable should be `sum(outgoing_flow) - sum(incoming_flow)`. We want this to be `0` for intermediate nodes.\nIf `balance[u]` is currently `X` (meaning `X` more flow has left `u` than entered `u`), and we have an edge `(u,v)` with flow `c`:\n*   If we direct `u -> v`: `balance[u]` becomes `X+c`.\n*   If we direct `v -> u`: `balance[u]` becomes `X-c`.\n\nLet's re-evaluate the balancing strategy.\nFor each vertex `v`, we need to determine its final `balance_out[v] = sum(out_flow) - sum(in_flow)`.\nWe want `balance_out[v] = 0` for `1 < v < n`.\n`balance_out[1] > 0` (source)\n`balance_out[n] < 0` (sink)\n\nInitialize `current_balance_out[v] = 0` for all `v`.\nInitialize `ans = [-1] * m`.\nInitialize `visited_edge = [False] * m`.\n\nThis problem is a variant of finding an Eulerian path/circuit or a flow decomposition.\nThe \"no cycles\" condition is the strongest hint. It implies a topological ordering.\nA common way to enforce no cycles is to direct edges from lower topological order to higher.\n\nConsider a DFS from vertex 1.\n`dfs(u, parent)`:\n  For each neighbor `v` of `u` via edge `(u, v, c, idx)`:\n    If `v` is not `parent` and `ans[idx]` is not set:\n      If `v` has been visited (and `ans[idx]` is still not set, meaning it's a back-edge in the DFS tree):\n        This is a problem. A back-edge would create a cycle if directed `u -> v`.\n        But the problem statement guarantees no cycles. So this shouldn't happen.\n        All edges must be tree-edges or forward-edges in a DFS from source.\n        This means we can always direct `u -> v` if `v` is unvisited.\n\nLet's try a simple DFS.\n`dfs(u)`:\n  `visited[u] = True`\n  For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n    If `visited[v]` and `ans[idx] == -1`: // This is a cross-edge or back-edge.\n      // Since no cycles are allowed, this must be a cross-edge or forward-edge\n      // where `v` was visited \"before\" `u` in the DFS tree.\n      // So, direct `v -> u`.\n      `ans[idx] = 1` if `is_u_ai` else `0`\n      `current_balance_out[v] -= flow_c`\n      `current_balance_out[u] += flow_c`\n    If not `visited[v]`: // Tree edge or forward edge.\n      // Temporarily direct `u -> v`.\n      `ans[idx] = 0` if `is_u_ai` else `1`\n      `current_balance_out[u] += flow_c`\n      `current_balance_out[v] -= flow_c`\n      `dfs(v)`\n      // After returning from `dfs(v)`, `v`'s subtree is processed.\n      // Now, `v` might have an imbalanced `current_balance_out[v]`.\n      // If `v` is an intermediate node (not 1 or n), it must be balanced.\n      // If `current_balance_out[v]` is non-zero, it means we need to flip the direction of `u -> v`.\n      If `v != 1` and `v != n` and `current_balance_out[v] != 0`:\n        // Flip direction of `u -> v` to `v -> u`.\n        // This is only possible if `current_balance_out[v]` is exactly `flow_c` or `-flow_c`.\n        // This logic is tricky.\n\nA common technique for this type of problem is to use a \"deficit/surplus\" tracking in a DFS.\nLet `dfs(u, p)` return the `balance` of `u`'s subtree (excluding the edge to `p`).\n`dfs(u, p)`:\n  `visited[u] = True`\n  `current_node_balance = 0`\n  For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n    If `v == p`: continue\n    If `visited[v]`: // Already visited, must be a cross-edge or forward-edge.\n      // Direct `v -> u` to avoid cycles.\n      `ans[idx] = 1` if `is_u_ai` else `0`\n      `current_node_balance += flow_c` // `u` gets flow from `v`\n    Else: // `v` is unvisited.\n      // Recurse. The flow on `u-v` will be determined by `v`'s needs.\n      `subtree_balance_of_v = dfs(v, u)`\n      If `subtree_balance_of_v > 0`: // `v`'s subtree has a surplus of outgoing flow.\n        // It needs incoming flow. So `u -> v`.\n        `ans[idx] = 0` if `is_u_ai` else `1`\n        `current_node_balance -= flow_c` // `u` sends flow to `v`\n      Else: // `subtree_balance_of_v <= 0`. `v`'s subtree has a deficit of outgoing flow or is balanced.\n        // It needs to send flow out. So `v -> u`.\n        `ans[idx] = 1` if `is_u_ai` else `0`\n        `current_node_balance += flow_c` // `u` gets flow from `v`\n  \n  // After processing all neighbors, `current_node_balance` is the net flow `u` has received from its children/cross-edges.\n  // We need to return `current_node_balance` to `p`.\n  // If `u` is an intermediate node (not 1 or n), its final balance must be 0.\n  // This means `current_node_balance` must be 0 if `u` is an intermediate node.\n  // This is not quite right. `subtree_balance_of_v` is `sum(out_flow) - sum(in_flow)` for `v`'s subtree.\n  // If `subtree_balance_of_v != 0` for `v` (1 < `v` < `n`), it means `v` is unbalanced.\n  // The edge `u-v` must be directed to balance `v`.\n\nLet's refine the DFS approach with `current_flow_balance[v]` representing `sum(in_flow) - sum(out_flow)`. We want this to be 0 for intermediate nodes.\n`dfs(u, p)`:\n  `visited[u] = True`\n  For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n    If `v == p`: continue\n    If `ans[idx] != -1`: continue // Edge already directed by another path\n    \n    If `visited[v]`: // Cross-edge or forward-edge. Direct `v -> u` to ensure DAG.\n      `ans[idx] = 1` if `is_u_ai` else `0` // `v -> u`\n      `current_flow_balance[v] -= flow_c`\n      `current_flow_balance[u] += flow_c`\n    Else: // Tree edge.\n      // Temporarily assume `u -> v`.\n      `ans[idx] = 0` if `is_u_ai` else `1` // `u -> v`\n      `current_flow_balance[u] -= flow_c`\n      `current_flow_balance[v] += flow_c`\n      `dfs(v, u)`\n      \n      // After `dfs(v, u)` returns, check if `v` needs balancing.\n      If `v != 1` and `v != n` and `current_flow_balance[v] != 0`:\n        // `v` is an intermediate node and is unbalanced.\n        // The only way to balance it is to flip the direction of `u -> v`.\n        // This implies `current_flow_balance[v]` must be exactly `flow_c` or `-flow_c`.\n        // This is not guaranteed if `v` has other edges.\n        // The problem is that the balance needs to be 0 for intermediate nodes.\n        // If `current_flow_balance[v]` is non-zero, it means it has a net incoming or outgoing flow.\n        // The edge `(u, v)` is the only edge connecting `v` to its parent in the DFS tree.\n        // All other edges in `v`'s subtree are balanced within the subtree or connect to `n`.\n        \n        // If `current_flow_balance[v] < 0` (net outgoing flow), it needs incoming flow. So flip to `v -> u`.\n        // If `current_flow_balance[v] > 0` (net incoming flow), it needs outgoing flow. So flip to `u -> v` (already set).\n        \n        // This means, if `current_flow_balance[v] < 0`, we need to flip the edge `u -> v` to `v -> u`.\n        // If `current_flow_balance[v] > 0`, we keep `u -> v`.\n        // This logic is incorrect. If `current_flow_balance[v]` is positive, it means `v` has an excess of incoming flow.\n        // To balance it, `v` must send flow out. So `u -> v` is correct.\n        // If `current_flow_balance[v]` is negative, it means `v` has an excess of outgoing flow.\n        // To balance it, `v` must receive flow. So `v -> u` is correct.\n\n        // So if `current_flow_balance[v] < 0`, we must flip the direction of `u -> v` to `v -> u`.\n        // This means `ans[idx]` becomes `1` if `is_u_ai` else `0`.\n        // And update balances: `current_flow_balance[u]` increases by `2 * flow_c`, `current_flow_balance[v]` decreases by `2 * flow_c`.\n        // (Because we initially assumed `u -> v`, so `u` lost `c`, `v` gained `c`. Flipping means `u` gains `c`, `v` loses `c`. Net change for `u` is `+2c`, for `v` is `-2c`).\n        If `current_flow_balance[v] < 0`:\n          `ans[idx] = 1` if `is_u_ai` else `0`\n          `current_flow_balance[u] += 2 * flow_c`\n          `current_flow_balance[v] -= 2 * flow_c`\n          \nInitial call: `dfs(1, 0)` (0 is a dummy parent).\n\nLet's test this DFS strategy with Example 1:\n`3 3`\n`0: (3, 2, 10)`\n`1: (1, 2, 10)`\n`2: (3, 1, 5)`\n\n`adj_list`:\n`1: [(2, 10, 1, True), (3, 5, 2, False)]`\n`2: [(3, 10, 0, False), (1, 10, 1, False)]`\n`3: [(2, 10, 0, True), (1, 5, 2, True)]`\n\n`ans = [-1, -1, -1]`\n`current_flow_balance = [0, 0, 0, 0]`\n`visited = [False, False, False, False]`\n\n`dfs(1, 0)`:\n  `visited[1] = True`\n  \n  Edge `(1, 2, 10, 1, True)`: `v=2` is unvisited.\n    Assume `1 -> 2`. `ans[1]=0`.\n    `current_flow_balance[1] -= 10` (now -10)\n    `current_flow_balance[2] += 10` (now 10)\n    `dfs(2, 1)`:\n      `visited[2] = True`\n      \n      Edge `(2, 3, 10, 0, False)`: `v=3` is unvisited.\n        Assume `2 -> 3`. `ans[0]=1` (since `2` is `b_i` for edge 0 `(3,2)`).\n        `current_flow_balance[2] -= 10` (now 0)\n        `current_flow_balance[3] += 10` (now 10)\n        `dfs(3, 2)`:\n          `visited[3] = True`\n          \n          Edge `(3, 2, 10, 0, True)`: `v=2`. `v==p` is false. `v` is visited. `ans[0]` is set. Skip.\n          Edge `(3, 1, 5, 2, True)`: `v=1`. `v==p` is false. `v` is visited. `ans[2]` is not set.\n            This is a cross-edge/forward-edge. Direct `1 -> 3` (or `3 -> 1` if `v` was `1`).\n            Direct `v -> u` (so `1 -> 3`). `ans[2]=0` (since `3` is `a_i` for edge 2 `(3,1)`).\n            `current_flow_balance[1] -= 5` (now -15)\n            `current_flow_balance[3] += 5` (now 15)\n          Return from `dfs(3, 2)`.\n        \n        // Back to `dfs(2, 1)` after `dfs(3, 2)`\n        // `v=3`. `v != 1` and `v != n` is false (`v=3` is `n`). So don't check `current_flow_balance[3]`.\n      \n      Edge `(2, 1, 10, 1, False)`: `v=1`. `v==p` is true. Skip.\n      Return from `dfs(2, 1)`.\n    \n    // Back to `dfs(1, 0)` after `dfs(2, 1)`\n    // `v=2`. `v != 1` and `v != n` is true. `current_flow_balance[2]` is 0. No flip needed.\n  \n  Edge `(1, 3, 5, 2, False)`: `v=3`. `v==p` is false. `v` is visited. `ans[2]` is set. Skip.\n  Return from `dfs(1, 0)`.\n\nFinal `ans`:\n`ans[0] = 1` (edge `(3,2)` becomes `2 -> 3`)\n`ans[1] = 0` (edge `(1,2)` becomes `1 -> 2`)\n`ans[2] = 0` (edge `(3,1)` becomes `3 -> 1`)\n\nOutput for Example 1:\n`1`\n`0`\n`0`\n\nExpected output for Example 1:\n`1`\n`0`\n`1`\n\nMy output for edge `(3,1)` (idx 2) is `0` (`3 -> 1`). Expected is `1` (`1 -> 3`).\nMy `current_flow_balance` for `1` is `-15`, for `2` is `0`, for `3` is `15`.\n`balance[1] = -15` (net outgoing 15)\n`balance[2] = 0` (balanced)\n`balance[3] = 15` (net incoming 15)\nThis is a valid flow! The problem says \"any solution\".\n`1 -> 2 (10)`\n`2 -> 3 (10)`\n`3 -> 1 (5)` This creates a cycle `1 -> 2 -> 3 -> 1`.\nThe \"no cycles\" condition is violated by my solution.\n\nThe problem is that my \"visited\" check for cross-edges might be wrong.\nIf `visited[v]` and `ans[idx]` is not set, it means `v` is an ancestor of `u` in the DFS tree, or `v` is in a different subtree.\nTo ensure no cycles, if `v` is an ancestor, we must direct `v -> u` (back-edge).\nIf `v` is in a different subtree (cross-edge), we must direct from the vertex visited earlier to the vertex visited later.\nThe standard way to classify edges in DFS:\n*   Tree edge: `u -> v` (v unvisited)\n*   Back edge: `u -> v` (v visited, v is ancestor of u)\n*   Forward edge: `u -> v` (v visited, v is descendant of u)\n*   Cross edge: `u -> v` (v visited, v is not ancestor/descendant)\n\nThe \"no cycle\" condition means there are no back edges. All edges must be tree, forward, or cross.\nSo, if `v` is visited:\n  If `v` is an ancestor of `u` (i.e., `v` is on the current DFS path from root to `u`): this is a back edge. We cannot direct `u -> v`. We must direct `v -> u`.\n  If `v` is not an ancestor: this is a forward or cross edge. We must direct from the vertex with lower discovery time to higher discovery time.\n\nTo implement this, we need `discovery_time[v]` and `finish_time[v]`.\nThis is getting complicated for an \"easy\" problem.\n\nWhat if we just process edges from `1` and `n` first, then use the queue method?\n1.  Store edges as `(u, v, c, original_idx)` tuples.\n2.  Create an adjacency list `adj_list[v]` storing `(neighbor, flow_c, original_idx, is_u_ai)`.\n3.  Initialize `ans = [-1] * m`.\n4.  Initialize `balance = [0] * (n + 1)`.\n5.  Initialize `current_degree = [0] * (n + 1)`. For each edge `(u, v, c, idx)`, increment `current_degree[u]` and `current_degree[v]`.\n6.  Initialize `edge_processed = [False] * m`.\n\n7.  Create a queue `q`.\n8.  For `v` from 1 to `n`:\n    If `v != 1` and `v != n` and `current_degree[v] == 1`:\n        `q.append(v)`\n\n9.  While `q` is not empty:\n    a.  `u = q.popleft()`\n    b.  If `u == 1` or `u == n`: continue (shouldn't be in queue).\n    c.  Find the unique unprocessed edge `(u, v)` with flow `c` (and original index `idx`).\n        For `(v_neighbor, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n            If not `edge_processed[idx]`:\n                // This is the unique unprocessed edge for `u`.\n                // Direct it to balance `u`.\n                If `balance[u] < 0`: // `u` has more outgoing flow than incoming. Needs incoming. So `v_neighbor -> u`.\n                    `ans[idx] = 1` if `is_u_ai` else `0`\n                    `balance[u] += flow_c`\n                    `balance[v_neighbor] -= flow_c`\n                Else: // `balance[u] >= 0`. `u` has more incoming flow or is balanced. Needs outgoing. So `u -> v_neighbor`.\n                    `ans[idx] = 0` if `is_u_ai` else `1`\n                    `balance[u] -= flow_c`\n                    `balance[v_neighbor] += flow_c`\n                \n                `edge_processed[idx] = True`\n                `current_degree[u] -= 1`\n                `current_degree[v_neighbor] -= 1`\n                If `v_neighbor != 1` and `v_neighbor != n` and `current_degree[v_neighbor] == 1`:\n                    `q.append(v_neighbor)`\n                Break // Found and processed the edge\n\n10. After the queue is empty, all intermediate nodes with `current_degree == 1` have been balanced.\n    The remaining edges form paths/components between `1` and `n`.\n    We need to direct these remaining edges.\n    The source `1` has no incoming edges. The sink `n` has no outgoing edges.\n    This means all remaining undirected edges must be directed away from `1` and towards `n`.\n    We can use a DFS/BFS starting from `1` to direct these remaining edges.\n\n    `dfs_final(u, p)`:\n      For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n        If not `edge_processed[idx]`:\n          `edge_processed[idx] = True`\n          `ans[idx] = 0` if `is_u_ai` else `1` // `u -> v`\n          `dfs_final(v, u)`\n\n    Call `dfs_final(1, 0)`.\n\nLet's retry Example 1 with this revised strategy:\n`3 3`\n`0: (3, 2, 10)`\n`1: (1, 2, 10)`\n`2: (3, 1, 5)`\n\n`adj_list`:\n`1: [(2, 10, 1, True), (3, 5, 2, False)]`\n`2: [(3, 10, 0, False), (1, 10, 1, False)]`\n`3: [(2, 10, 0, True), (1, 5, 2, True)]`\n\n`ans = [-1, -1, -1]`\n`balance = [0, 0, 0, 0]`\n`current_degree = [0, 2, 2, 2]` (for nodes 1,2,3)\n`edge_processed = [F, F, F]`\n\n`q` is empty initially. No intermediate node has `current_degree = 1`.\n\nSo, the first phase (queue-based balancing) does nothing for this example.\nAll edges remain unprocessed.\n\nThen, `dfs_final(1, 0)` is called:\n`dfs_final(1, 0)`:\n  Edge `(1, 2, 10, 1, True)`: not `edge_processed[1]`.\n    `edge_processed[1] = True`. `ans[1] = 0` (`1 -> 2`).\n    `dfs_final(2, 1)`:\n      Edge `(2, 3, 10, 0, False)`: not `edge_processed[0]`.\n        `edge_processed[0] = True`. `ans[0] = 1` (`2 -> 3`).\n        `dfs_final(3, 2)`:\n          Edge `(3, 2, 10, 0, True)`: `edge_processed[0]` is True. Skip.\n          Edge `(3, 1, 5, 2, True)`: not `edge_processed[2]`.\n            `edge_processed[2] = True`. `ans[2] = 0` (`3 -> 1`).\n            `dfs_final(1, 3)`:\n              Edge `(1, 2, 10, 1, True)`: `edge_processed[1]` is True. Skip.\n              Edge `(1, 3, 5, 2, False)`: `edge_processed[2]` is True. Skip.\n              Return from `dfs_final(1, 3)`.\n          Return from `dfs_final(3, 2)`.\n      Edge `(2, 1, 10, 1, False)`: `edge_processed[1]` is True. Skip.\n      Return from `dfs_final(2, 1)`.\n  Edge `(1, 3, 5, 2, False)`: `edge_processed[2]` is True. Skip.\n  Return from `dfs_final(1, 0)`.\n\nFinal `ans`:\n`ans[0] = 1` (`3-2` becomes `2 -> 3`)\n`ans[1] = 0` (`1-2` becomes `1 -> 2`)\n`ans[2] = 0` (`3-1` becomes `3 -> 1`)\n\nThis is the same incorrect output as before, which creates a cycle `1 -> 2 -> 3 -> 1`.\nThe \"no cycles\" condition is the hardest to satisfy.\nThe problem guarantees a solution. The DFS from source will always find a path to sink.\nThe crucial part is that `balance[v]` needs to be 0 for `1 < v < n`.\n\nThe problem statement \"vertex with number 1 has no incoming edges\" is critical.\nAnd \"the obtained directed graph does not have cycles.\"\n\nThis problem is a classic application of a specific graph traversal for flow networks called \"Potential Function\" or \"Topological Sort based flow\".\nIf there are no cycles, there is a topological order. Let `d[v]` be the topological rank of `v`.\nThen all edges `u -> v` must have `d[u] < d[v]`.\nThe flow conservation `sum(in) = sum(out)` for intermediate nodes.\n`sum(out from 1) = sum(in to n)`.\n\nLet `P[v]` be a potential function for each vertex `v`.\nFor each directed edge `u -> v` with flow `c`, `P[u]` must be greater than `P[v]`.\nThen `P[u] - P[v]` can be thought of as the \"pressure difference\" driving flow.\nThe \"no cycles\" condition implies we can find such a potential function (or a topological order).\n\nLet `deficit[v]` be `sum(flow_c)` for all edges incident to `v`.\nThis is not a deficit, it's total flow capacity.\nLet `deficit[v]` be the net flow that needs to exit `v` to satisfy conservation.\nInitially, `deficit[v] = 0` for all `v`.\nFor each edge `(u, v, c)`:\n  `deficit[u] += c`\n  `deficit[v] += c`\nThis `deficit[v]` is now `2 * sum(out_flow)` if `v` is balanced.\nNo, this is `sum(in_flow) + sum(out_flow)`.\nWe need `sum(in_flow) = sum(out_flow)`.\nSo `sum(in_flow) = total_incident_flow / 2`.\nAnd `sum(out_flow) = total_incident_flow / 2`.\nThis means `total_incident_flow` must be even for `1 < v < n`.\nLet's check example 1 again:\n`1: 15`\n`2: 20`\n`3: 15`\nNode 2 has `total_incident_flow = 20` (even). So it can be balanced. `in=10, out=10`.\nNodes 1 and 3 have `total_incident_flow = 15` (odd). This is fine for source/sink.\nThis means `current_flow_balance[v]` is what we need to track.\n\nThe key must be that the sum of `c_i` for edges incident to `v` must be even if `v` is an intermediate node.\nIf `sum(c_i)` is odd, then it's impossible to have `sum(in) = sum(out)` with integer flows.\nThe problem statement says `c_i` are integers.\nThe problem states \"a solution always exists\". This implies that `sum(c_i)` for intermediate nodes must be even.\n\nLet's use the DFS approach again, but instead of `current_flow_balance`, let's use `flow_going_into_parent[u]` which is the net flow we need to send *up* to the parent `p` from `u`'s subtree.\n`dfs(u, p)`:\n  `visited[u] = True`\n  `net_flow_from_children = 0` // Sum of flows directed `child -> u` minus `u -> child`\n  \n  For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n    If `v == p`: continue\n    If `edge_processed[idx]`: continue\n    \n    If `visited[v]`: // Cross-edge or forward-edge. `v` was visited before `u`.\n      // To avoid cycles, direct `v -> u`.\n      `ans[idx] = 1` if `is_u_ai` else `0`\n      `edge_processed[idx] = True`\n      `net_flow_from_children += flow_c`\n    Else: // Tree edge. Recurse.\n      `flow_from_subtree_v = dfs(v, u)`\n      // `flow_from_subtree_v` is the net flow that `v`'s subtree wants to send to `u`.\n      If `flow_from_subtree_v > 0`: // `v`'s subtree has surplus, wants to send flow to `u`. So `v -> u`.\n        `ans[idx] = 1` if `is_u_ai` else `0`\n        `net_flow_from_children += flow_c`\n      Else: // `v`'s subtree has deficit or is balanced, wants to receive flow from `u`. So `u -> v`.\n        `ans[idx] = 0` if `is_u_ai` else `1`\n        `net_flow_from_children -= flow_c`\n      `edge_processed[idx] = True`\n  \n  If `u == 1`: // Source. No incoming edges. All must be outgoing.\n    // `net_flow_from_children` should be 0 or negative (meaning more flow was sent out than received).\n    // The total flow out of 1 is `sum(flow_c)` for all edges directed `1 -> X`.\n    // The `net_flow_from_children` is `sum(in) - sum(out)` from children.\n    // We want `sum(out from 1) - sum(in to 1) > 0`.\n    // This `net_flow_from_children` is not the right metric.\n\nThe problem could be simpler than complex flow algorithms.\nThe \"no cycles\" condition is the key. It means we can process nodes in topological order.\nBut we don't know the topological order yet.\n\nWhat if we just run a DFS from `1` and always direct `u -> v` for tree edges?\nFor cross/forward edges `(u, v)` where `v` is already visited:\n  If `u`'s discovery time is less than `v`'s, direct `u -> v`.\n  If `v`'s discovery time is less than `u`'s, direct `v -> u`.\nThis guarantees a DAG.\nThen, after all edges are directed, check flow conservation.\n`balance[v]` = `sum(in_flow) - sum(out_flow)`.\nIf `balance[v] != 0` for `1 < v < n`, we have a problem.\nThe guarantee \"a solution always exists\" means this simple DFS with topological ordering logic won't work, because it doesn't consider flow conservation.\n\nA solution that works for similar problems:\n1.  Calculate `total_incident_flow[v]` for all `v`.\n2.  Initialize `current_balance[v] = 0`.\n3.  Initialize `ans = [-1] * m`.\n4.  Use a stack for DFS. Push `1`.\n5.  `dfs_stack = [1]`. `visited_dfs = [False]*(n+1)`. `visited_dfs[1]=True`.\n6.  `parent = [0]*(n+1)`.\n7.  While `dfs_stack`:\n    `u = dfs_stack[-1]`\n    `all_neighbors_processed = True`\n    For `(v, flow_c, idx, is_u_ai)` in `adj_list[u]`:\n        If `ans[idx] != -1`: continue // Edge already directed\n        If `v == parent[u]`: continue // Don't go back to parent immediately\n        \n        If `visited_dfs[v]`: // Cross-edge or forward-edge.\n            // Direct `v -> u` to avoid cycles.\n            `ans[idx] = 1` if `is_u_ai` else `0`\n            `current_balance[v] -= flow_c`\n            `current_balance[u] += flow_c`\n        Else: // Tree edge.\n            `parent[v] = u`\n            `visited_dfs[v] = True`\n            `dfs_stack.append(v)`\n            `all_neighbors_processed = False`\n            Break // Continue DFS from `v`\n    \n    If `all_neighbors_processed`: // All neighbors of `u` (except parent) are visited or processed.\n        `dfs_stack.pop()`\n        If `u != 1` and `u != n`:\n            // `u` is an intermediate node. It must be balanced.\n            // If `current_balance[u]` is not 0, it means the edge to its parent `parent[u]` must be flipped.\n            // Find edge `(u, parent[u])`.\n            // Let `p = parent[u]`.\n            // Find edge `(u, p, c_up, idx_up, is_u_ai_up)`\n            If `current_balance[u] != 0`:\n                // This implies `current_balance[u]` must be `c_up` or `-c_up`.\n                // If `current_balance[u] < 0` (net outgoing flow), it needs incoming. So `p -> u`.\n                // If `current_balance[u] > 0` (net incoming flow), it needs outgoing. So `u -> p`.\n                \n                // This is the tricky part. The `current_balance[u]` is the sum of flows from directed edges in `u`'s subtree.\n                // If `current_balance[u] < 0` (net outgoing flow), it means `u` has sent more flow out than it received from its children/cross-edges.\n                // So, the edge to its parent must bring flow IN. `parent[u] -> u`.\n                // If `current_balance[u] > 0` (net incoming flow), it means `u` has received more flow than it sent out.\n                // So, the edge to its parent must take flow OUT. `u -> parent[u]`.\n                \n                // Find the edge `(u, parent[u])`\n                For `(v_adj, flow_c_adj, idx_adj, is_u_ai_adj)` in `adj_list[u]`:\n                    If `v_adj == parent[u]`:\n                        If `current_balance[u] < 0`: // `u` needs incoming flow from `p`.\n                            // This means the edge from `p` to `u` must be `p -> u`.\n                            // If `ans[idx_adj]` was set to `u -> p`, flip it.\n                            // If `is_u_ai_adj` is True, `u` is `a_i`. `ans[idx_adj]=0` means `u -> p`. `ans[idx_adj]=1` means `p -> u`.\n                            If `ans[idx_adj] == 0`: // It was `u -> p`. Flip to `p -> u`.\n                                `ans[idx_adj] = 1`\n                                `current_balance[u] += 2 * flow_c_adj`\n                                `current_balance[parent[u]] -= 2 * flow_c_adj`\n                            // If it was already `p -> u`, do nothing.\n                        Else: // `current_balance[u] > 0`. `u` needs outgoing flow to `p`.\n                            // This means the edge from `u` to `p` must be `u -> p`.\n                            // If `ans[idx_adj]` was set to `p -> u`, flip it.\n                            If `ans[idx_adj] == 1`: // It was `p -> u`. Flip to `u -> p`.\n                                `ans[idx_adj] = 0`\n                                `current_balance[u] -= 2 * flow_c_adj`\n                                `current_balance[parent[u]] += 2 * flow_c_adj`\n                            // If it was already `u -> p`, do nothing.\n                        Break\n\nThis logic is much closer to the standard DFS flow balancing.\nThe `ans[idx_adj]` is set during the initial `dfs_stack.append(v)` step.\nWhen `dfs_stack.append(v)`, we temporarily assume `u -> v`.\nSo, `ans[idx_adj]` is set to `0` if `is_u_ai_adj` is `True`, else `1`.\nAnd `current_balance[u] -= flow_c_adj`, `current_balance[v] += flow_c_adj`.\n\nLet's refine the DFS:\n`dfs_stack = [(1, 0)]` // (node, parent)\n`visited_dfs = [False]*(n+1)`\n`visited_dfs[1] = True`\n`parent_map = {1: 0}` // To store parent for each node\n\n`adj_list` should store `(neighbor, flow_c, original_idx, is_u_ai, is_edge_to_parent_flag)`\nThe `is_edge_to_parent_flag` is not needed if we iterate `adj_list[u]` to find the parent edge.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj_list = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj_list[u].append((v, c, i, True))  # True if u is a_i\n        adj_list[v].append((u, c, i, False)) # False if u is b_i\n\n    ans = [-1] * m\n    current_balance = [0] * (n + 1) # sum(incoming) - sum(outgoing)\n    visited_dfs = [False] * (n + 1)\n    \n    # Stack for iterative DFS: (node, parent_node_in_dfs_tree)\n    # A node is pushed onto the stack when its DFS traversal starts.\n    # It's popped when its DFS traversal finishes.\n    dfs_stack = []\n    \n    # To handle the order of processing neighbors and popping from stack,\n    # we can use a stateful DFS or two passes.\n    # A simpler way for iterative DFS is to push (node, iterator_state)\n    # or to use recursion. Given N=2e5, recursion depth might be an issue,\n    # but Python's default limit is 1000, can be increased.\n    # Let's try explicit stack for recursion simulation.\n    \n    # Stack stores (node, neighbor_index_in_adj_list_to_process, parent_node)\n    # When neighbor_index_in_adj_list_to_process reaches len(adj_list[node]),\n    # it means all children are processed, and we can handle current_balance[node].\n    \n    # Initialize DFS from source (node 1)\n    dfs_stack.append((1, 0, 0)) # (u, parent, adj_idx_to_process)\n    visited_dfs[1] = True\n\n    # This array will store the \"state\" of the iterator for each node\n    # when it's pushed onto the stack.\n    # It allows us to resume iterating neighbors when returning from a child DFS call.\n    adj_iter_state = [0] * (n + 1)\n    \n    # This DFS processes nodes in post-order (children first, then parent)\n    # for balancing.\n    \n    # The stack will actually store (node, parent) for simpler management.\n    # We need to explicitly manage the iteration over neighbors.\n    # A common trick is to use a separate stack for nodes that have started DFS\n    # and are waiting for children to finish.\n    \n    # Let's use a standard recursive DFS. Python's default recursion limit is 1000.\n    # For N=2e5, we need to increase it.\n    sys.setrecursionlimit(2 * 10**5 + 50)\n\n    def dfs(u, p):\n        visited_dfs[u] = True\n        \n        for v_adj, flow_c_adj, idx_adj, is_u_ai_adj in adj_list[u]:\n            if v_adj == p: # Don't go back up the DFS tree\n                continue\n            \n            if ans[idx_adj] != -1: # Edge already directed (e.g., by a cross-edge from another path)\n                continue\n\n            if visited_dfs[v_adj]: # v_adj is already visited, must be a cross-edge or forward-edge\n                # To avoid cycles, direct v_adj -> u.\n                # This ensures flow is from earlier visited node to later visited node.\n                # Since we are doing DFS, v_adj must have been visited \"before\" u.\n                ans[idx_adj] = 1 if is_u_ai_adj else 0 # v_adj -> u\n                current_balance[v_adj] -= flow_c_adj\n                current_balance[u] += flow_c_adj\n            else: # v_adj is unvisited, it's a tree edge\n                # Temporarily direct u -> v_adj. This is the initial assumption.\n                ans[idx_adj] = 0 if is_u_ai_adj else 1 # u -> v_adj\n                current_balance[u] -= flow_c_adj\n                current_balance[v_adj] += flow_c_adj\n                \n                dfs(v_adj, u) # Recurse\n                \n                # After returning from dfs(v_adj, u), v_adj's subtree is processed.\n                # Now, if v_adj is an intermediate node (not 1 or n), it must be balanced.\n                # Its current_balance[v_adj] should be 0.\n                # If it's not 0, it means the temporary direction u -> v_adj was wrong.\n                # We need to flip it to v_adj -> u to balance v_adj.\n                if v_adj != 1 and v_adj != n and current_balance[v_adj] != 0:\n                    # Flip the edge direction (u -> v_adj) to (v_adj -> u)\n                    ans[idx_adj] = 1 if is_u_ai_adj else 0 # v_adj -> u\n                    # Update balances: u loses flow, v_adj gains flow.\n                    # Original: u lost c, v_adj gained c.\n                    # New: u gains c, v_adj loses c.\n                    # Net change: u +2c, v_adj -2c.\n                    current_balance[u] += 2 * flow_c_adj\n                    current_balance[v_adj] -= 2 * flow_c_adj\n\n    dfs(1, 0) # Start DFS from node 1 (source), with dummy parent 0\n\n    # Output the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj_list = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj_list[u].append((v, c, i, True))  # True if u is a_i\n        adj_list[v].append((u, c, i, False)) # False if u is b_i\n\n    ans = [-1] * m\n    current_balance = [0] * (n + 1) # sum(incoming) - sum(outgoing)\n    visited_dfs = [False] * (n + 1)\n    \n    # Stack for iterative DFS: (node, parent_node_in_dfs_tree)\n    # A node is pushed onto the stack when its DFS traversal starts.\n    # It's popped when its DFS traversal finishes.\n    dfs_stack = []\n    \n    # To handle the order of processing neighbors and popping from stack,\n    # we can use a stateful DFS or two passes.\n    # A simpler way for iterative DFS is to push (node, iterator_state)\n    # or to use recursion. Given N=2e5, recursion depth might be an issue,\n    # but Python's default limit is 1000, can be increased.\n    # Let's try explicit stack for recursion simulation.\n    \n    # Stack stores (node, neighbor_index_in_adj_list_to_process, parent_node)\n    # When neighbor_index_in_adj_list_to_process reaches len(adj_list[node]),\n    # it means all children are processed, and we can handle current_balance[node].\n    \n    # Initialize DFS from source (node 1)\n    dfs_stack.append((1, 0, 0)) # (u, parent, adj_idx_to_process)\n    visited_dfs[1] = True\n\n    # This array will store the \"state\" of the iterator for each node\n    # when it's pushed onto the stack.\n    # It allows us to resume iterating neighbors when returning from a child DFS call.\n    adj_iter_state = [0] * (n + 1)\n    \n    # This DFS processes nodes in post-order (children first, then parent)\n    # for balancing.\n    \n    # The stack will actually store (node, parent) for simpler management.\n    # We need to explicitly manage the iteration over neighbors.\n    # A common trick is to use a separate stack for nodes that have started DFS\n    # and are waiting for children to finish.\n    \n    # Let's use a standard recursive DFS. Python's default recursion limit is 1000.\n    # For N=2e5, we need to increase it.\n    sys.setrecursionlimit(2 * 10**5 + 50)\n\n    def dfs(u, p):\n        visited_dfs[u] = True\n        \n        for v_adj, flow_c_adj, idx_adj, is_u_ai_adj in adj_list[u]:\n            if v_adj == p: # Don't go back up the DFS tree\n                continue\n            \n            if ans[idx_adj] != -1: # Edge already directed (e.g., by a cross-edge from another path)\n                continue\n\n            if visited_dfs[v_adj]: # v_adj is already visited, must be a cross-edge or forward-edge\n                # To avoid cycles, direct v_adj -> u.\n                # This ensures flow is from earlier visited node to later visited node.\n                # Since we are doing DFS, v_adj must have been visited \"before\" u.\n                ans[idx_adj] = 1 if is_u_ai_adj else 0 # v_adj -> u\n                current_balance[v_adj] -= flow_c_adj\n                current_balance[u] += flow_c_adj\n            else: # v_adj is unvisited, it's a tree edge\n                # Temporarily direct u -> v_adj. This is the initial assumption.\n                ans[idx_adj] = 0 if is_u_ai_adj else 1 # u -> v_adj\n                current_balance[u] -= flow_c_adj\n                current_balance[v_adj] += flow_c_adj\n                \n                dfs(v_adj, u) # Recurse\n                \n                # After returning from dfs(v_adj, u), v_adj's subtree is processed.\n                # Now, if v_adj is an intermediate node (not 1 or n), it must be balanced.\n                # Its current_balance[v_adj] should be 0.\n                # If it's not 0, it means the temporary direction u -> v_adj was wrong.\n                # We need to flip it to v_adj -> u to balance v_adj.\n                if v_adj != 1 and v_adj != n and current_balance[v_adj] != 0:\n                    # Flip the edge direction (u -> v_adj) to (v_adj -> u)\n                    ans[idx_adj] = 1 if is_u_ai_adj else 0 # v_adj -> u\n                    # Update balances: u loses flow, v_adj gains flow.\n                    # Original: u lost c, v_adj gained c.\n                    # New: u gains c, v_adj loses c.\n                    # Net change: u +2c, v_adj -2c.\n                    current_balance[u] += 2 * flow_c_adj\n                    current_balance[v_adj] -= 2 * flow_c_adj\n\n    dfs(1, 0) # Start DFS from node 1 (source), with dummy parent 0\n\n    # Output the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 17181,
        "thoughts_token_count": 808
    }
}