{
    "start": 1758293708.697354,
    "end": 1758293746.8725088,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional_for_min_nodes = -1\n\n    # Iterate through possible numbers of nodes 'n'\n    # The maximum value for n can be estimated.\n    # A complete graph has n*(n-1)/2 pairs. If p is 2*10^5, then n*(n-1)/2 approx 2*10^5\n    # n^2 approx 4*10^5, so n approx sqrt(4*10^5) = 200*sqrt(10) approx 200*3.16 = 632\n    # Let's try up to 650 to be safe.\n    for n in range(1, 651):\n        # The maximum number of pairs (u,v) with u<v and reachable from each other\n        # in a graph with n nodes is n*(n-1)/2 (a complete graph or a strongly connected component of n nodes).\n        # We need k nodes to form a strongly connected component (SCC)\n        # such that k*(k-1)/2 is close to p.\n        # The remaining n-k nodes will be in a DAG structure with the SCC.\n\n        # Find the largest k such that k*(k-1)/2 <= p\n        # We want to minimize n. So we try to make k as large as possible.\n        # This k will be the size of the main SCC.\n        k_max_scc = 0\n        for k_test in range(1, n + 1):\n            if k_test * (k_test - 1) // 2 <= p:\n                k_max_scc = k_test\n            else:\n                break\n\n        if k_max_scc == 0: # Cannot form any SCC if p > 0 and k_max_scc is 0\n            continue\n\n        # Number of reachable-from-each-other pairs within the main SCC\n        pairs_in_scc = k_max_scc * (k_max_scc - 1) // 2\n\n        # Remaining pairs needed\n        remaining_p = p - pairs_in_scc\n\n        # If remaining_p is 0, we can use k_max_scc nodes.\n        # The total nodes would be k_max_scc.\n        # Unidirectional pairs:\n        # Inside the SCC, there are no unidirectional pairs.\n        # If there are n_total nodes and k_max_scc of them form an SCC,\n        # and the remaining n_total - k_max_scc nodes are isolated or form a DAG\n        # with no paths to the SCC, then unidirectional pairs are maximized.\n        # The number of unidirectional pairs is (n_total - k_max_scc) * k_max_scc.\n        # This is when the remaining nodes are all connected to the SCC in one direction (e.g., from SCC to them).\n        # To maximize unidirectional pairs, we want a chain of nodes, or a \"star\" structure\n        # where one node points to many, or many point to one.\n        # The best strategy to maximize unidirectional pairs is to have a single source/sink node\n        # connected to all other nodes.\n        # Or, more generally, an SCC of size k and a path of length n-k.\n        # The number of unidirectional pairs is maximized when we have a \"line\" of nodes\n        # where each node points to the next.\n        # If we have an SCC of size k and a path of n-k nodes, where the path is connected\n        # to the SCC (e.g., all path nodes point to SCC, or SCC points to all path nodes).\n        # Let's consider the structure: an SCC of size k, and n-k isolated nodes.\n        # Unidirectional pairs = 0.\n        # An SCC of size k, and n-k nodes forming a path, with edges from SCC to path nodes,\n        # or path nodes to SCC.\n        # Max unidirectional pairs when we have an SCC of size k and n-k nodes in a path.\n        # If we have n nodes and they form a single path (a_1 -> a_2 -> ... -> a_n),\n        # then the number of unidirectional pairs is n*(n-1)/2.\n        # If we have an SCC of size k and n-k other nodes,\n        # we can make the n-k nodes form a path, and connect one end of the path to the SCC.\n        # For example, a_1 -> a_2 -> ... -> a_{n-k} -> SCC.\n        # In this case, each node a_i can reach a_j for j > i, and also all nodes in SCC.\n        # And SCC nodes can reach a_i for i < n-k (if we make edges back).\n        # This becomes complicated.\n\n        # Let's simplify:\n        # We have an SCC of size k_max_scc.\n        # We have n - k_max_scc remaining nodes.\n        # To maximize unidirectional pairs, we should connect all remaining nodes\n        # to the SCC in one direction, or connect the SCC to all remaining nodes in one direction.\n        # For example, all (n - k_max_scc) nodes point to all k_max_scc nodes,\n        # or all k_max_scc nodes point to all (n - k_max_scc) nodes.\n        # This gives (n - k_max_scc) * k_max_scc unidirectional pairs.\n        # Additionally, if the (n - k_max_scc) nodes form a path or a DAG, they contribute more.\n        # The total number of unidirectional pairs in a graph of n nodes, with an SCC of size k,\n        # and the remaining n-k nodes forming a path (a_1 -> a_2 -> ... -> a_{n-k}),\n        # and an edge from a_{n-k} to one node in the SCC, and an edge from one node in the SCC to a_1.\n        # This makes the whole graph strongly connected, and all pairs become bidirectional.\n        # This is not what we want.\n\n        # To maximize unidirectional pairs, we need a structure that is NOT strongly connected.\n        # We have an SCC of size k_max_scc.\n        # We have n - k_max_scc nodes that are not part of this SCC.\n        # To maximize unidirectional pairs, these n - k_max_scc nodes should form a \"line\"\n        # and be connected to the SCC in a way that doesn't make the whole graph strongly connected.\n        # For example, the SCC points to the first node of the line, and the line continues.\n        # SCC -> v_1 -> v_2 -> ... -> v_{n-k_max_scc}.\n        # In this case, all nodes in SCC can reach all nodes in the line.\n        # All nodes v_i can reach v_j for j > i.\n        # But no node in the line can reach SCC.\n        # Unidirectional pairs:\n        # 1. Within the line: (n - k_max_scc) * (n - k_max_scc - 1) / 2\n        # 2. From SCC to line: k_max_scc * (n - k_max_scc)\n        # Total unidirectional pairs = k_max_scc * (n - k_max_scc) + (n - k_max_scc) * (n - k_max_scc - 1) / 2\n\n        # What if we have a set of nodes S and a set of nodes T, with all edges from S to T,\n        # and no edges from T to S.\n        # Unidirectional pairs = |S| * |T| + (unidirectional pairs in S) + (unidirectional pairs in T).\n        # To maximize unidirectional pairs, we want a structure that is a DAG of SCCs.\n        # In our case, we have one SCC of size k_max_scc.\n        # The remaining n - k_max_scc nodes should form a path (a_1 -> a_2 -> ... -> a_{n-k_max_scc}).\n        # Let's say this path is P.\n        # We can connect P to the SCC: P -> SCC.\n        # This means all nodes in P can reach SCC.\n        # Unidirectional pairs:\n        # 1. Within P: (n - k_max_scc) * (n - k_max_scc - 1) / 2\n        # 2. From P to SCC: (n - k_max_scc) * k_max_scc\n        # Total unidirectional pairs = (n - k_max_scc) * (n - k_max_scc - 1) / 2 + (n - k_max_scc) * k_max_scc\n\n        # Let's check this formula.\n        # If n=3, p=3. k_max_scc = 3. pairs_in_scc = 3. remaining_p = 0.\n        # Nodes = 3. Unidirectional = (3-3)*(3-3-1)/2 + (3-3)*3 = 0. Correct for example 1.\n\n        # If n=5, p=4.\n        # k_max_scc = 3. pairs_in_scc = 3. remaining_p = 1.\n        # We need 1 more bidirectional pair.\n        # This means we need to add a node to the SCC or make another SCC.\n        # If we have k nodes forming an SCC, and we need p pairs.\n        # We want to use k nodes to form an SCC of size k.\n        # This gives k*(k-1)/2 pairs.\n        # We need to find k such that k*(k-1)/2 <= p.\n        # The remaining p - k*(k-1)/2 pairs must come from \"crossing\" edges\n        # between nodes that are part of the SCC and nodes that are not,\n        # but in a way that makes them mutually reachable.\n        # This implies that some of the \"non-SCC\" nodes must also become part of the SCC.\n        # This means our initial k_max_scc logic might be flawed.\n\n        # Let's reformulate:\n        # We need a total of 'n' nodes.\n        # These 'n' nodes are partitioned into several SCCs, say S_1, S_2, ..., S_m.\n        # The graph of SCCs is a DAG.\n        # The total number of pairs (u,v) with u<v and u,v reachable from each other is\n        # sum_{i=1 to m} |S_i| * (|S_i|-1) / 2.\n        # We want this sum to be exactly p.\n        # To minimize n, we want to make the SCCs as large as possible.\n        # To maximize unidirectional pairs, we want the SCCs to be arranged in a long path in the SCC DAG,\n        # or have one large SCC and many isolated nodes connected to it in one direction.\n\n        # Let's assume we have one large SCC of size 'k' and 'n-k' isolated nodes that are not part of any SCC.\n        # The 'n-k' nodes are connected in a path to maximize unidirectional pairs among themselves.\n        # The number of reachable-from-each-other pairs is k*(k-1)/2.\n        # We need this to be 'p'. So k*(k-1)/2 = p.\n        # If p is not a triangular number, this structure is not possible.\n        # What if p is not a triangular number?\n        # We need to add nodes that are mutually reachable.\n        # The problem states \"u < v and u and v are reachable from each other\".\n        # This means these pairs must be in the same SCC.\n        # So, the total number of such pairs is the sum of k_i * (k_i - 1) / 2 for each SCC of size k_i.\n        # To minimize n, we should use as few SCCs as possible, and make them as large as possible.\n        # This means we should aim for a single SCC of size k, where k*(k-1)/2 = p.\n        # If p is not a triangular number, we need to find k such that k*(k-1)/2 <= p,\n        # and then add more nodes such that the remaining p pairs are formed.\n        # But how can we form exactly 'remaining_p' pairs without making other pairs?\n        # This implies that the 'remaining_p' pairs must come from within a single SCC.\n        # This is a key insight. The \"u < v and u and v are reachable from each other\" pairs\n        # *must* be within SCCs. So, we need to find a set of SCCs whose sizes k_1, k_2, ..., k_m\n        # sum up to p when their triangular numbers are summed.\n        # sum_{i=1 to m} k_i * (k_i - 1) / 2 = p.\n        # And the total number of nodes is n = sum_{i=1 to m} k_i.\n        # We want to minimize n.\n\n        # To minimize n for a given p, we should try to make the SCCs as large as possible.\n        # This means we should find the largest k such that k*(k-1)/2 <= p.\n        # Let this be k_1.\n        # Then we need to satisfy p - k_1*(k_1-1)/2 with other SCCs.\n        # This is a variation of the change-making problem or subset sum.\n        # We want to find a set of integers k_1, k_2, ..., k_m such that\n        # sum_{i=1 to m} k_i*(k_i-1)/2 = p, and sum_{i=1 to m} k_i is minimized.\n\n        # Let T(k) = k*(k-1)/2.\n        # We need to represent p as a sum of T(k_i)'s, minimizing sum k_i.\n        # We can use dynamic programming for this.\n        # dp[val] = minimum sum of k_i for which sum T(k_i) = val.\n        # Max p is 2 * 10^5.\n        # Max k for T(k) <= 2*10^5 is k approx 632.\n        dp = [float('inf')] * (p + 1)\n        dp[0] = 0\n\n        # Precompute triangular numbers and their corresponding k\n        triangular_numbers = []\n        for k_val in range(1, 650): # k can go up to ~632\n            t_k = k_val * (k_val - 1) // 2\n            if t_k > p:\n                break\n            triangular_numbers.append((t_k, k_val))\n\n        for current_p in range(1, p + 1):\n            for t_k, k_val in triangular_numbers:\n                if current_p - t_k >= 0:\n                    if dp[current_p - t_k] != float('inf'):\n                        dp[current_p] = min(dp[current_p], dp[current_p - t_k] + k_val)\n\n        min_nodes = dp[p]\n\n        # Now, calculate max unidirectional pairs for this min_nodes.\n        # We have found the minimum number of nodes, `min_nodes`,\n        # which are partitioned into SCCs to satisfy `p`.\n        # Let these SCCs have sizes k_1, k_2, ..., k_m, such that sum k_i = min_nodes.\n        # And sum T(k_i) = p.\n        # To maximize unidirectional pairs, we should arrange these SCCs in a chain (a DAG).\n        # For example, S_1 -> S_2 -> ... -> S_m.\n        # The number of unidirectional pairs is sum_{i<j} |S_i| * |S_j|.\n        # This sum is maximized when the SCCs are arranged in a single path.\n        # Let the sizes be k_1, k_2, ..., k_m.\n        # Total unidirectional pairs = sum_{i=1 to m} sum_{j=i+1 to m} k_i * k_j.\n        # This is equivalent to (sum k_i)^2 / 2 - sum k_i^2 / 2.\n        # Or, (sum k_i)^2 - sum k_i^2, then divide by 2 for ordered pairs.\n        # No, it's (sum k_i)^2 - sum k_i^2, then divide by 2 for (u,v) u<v.\n        # The total number of ordered pairs (u,v) with u!=v and u,v in different SCCs\n        # where u is in S_i and v is in S_j with i < j (assuming topological sort)\n        # is sum_{i<j} k_i * k_j.\n        # This is equal to ( (sum k_i)^2 - sum k_i^2 ) / 2.\n        # Let N = sum k_i = min_nodes.\n        # Total unidirectional pairs = (N^2 - sum k_i^2) / 2.\n        # To maximize this, we need to minimize sum k_i^2.\n        # Given a sum N, sum k_i^2 is minimized when k_i are as close to each other as possible.\n        # This means the DP approach naturally leads to minimizing sum k_i^2\n        # because it tries to use large k_i to reduce the number of SCCs.\n        # Wait, the DP minimizes sum k_i. It doesn't necessarily minimize sum k_i^2.\n\n        # Example: p=6.\n        # T(1)=0, T(2)=1, T(3)=3, T(4)=6.\n        # dp[6] = 4 (using k=4). Sum k_i^2 = 4^2 = 16. Unidirectional = (4^2 - 16)/2 = 0.\n        # Another way to get p=6: T(3)+T(3) = 3+3=6. Sum k_i = 3+3 = 6.\n        # Nodes = 6. Sum k_i^2 = 3^2 + 3^2 = 9+9 = 18. Unidirectional = (6^2 - 18)/2 = (36-18)/2 = 9.\n        # So for p=6, min_nodes=4, max_unidirectional=0.\n        # If we use 6 nodes, we get 9 unidirectional pairs.\n        # The problem asks for max unidirectional pairs *among all such p-reachable graphs with the minimum number of nodes*.\n        # So, we need to find the specific partition k_i that yields min_nodes AND maximizes unidirectional pairs.\n\n        # We need to modify the DP state.\n        # dp[val] = (min_sum_k, min_sum_k_sq)\n        # No, it should be dp[val] = (min_sum_k, max_unidirectional_pairs_for_min_sum_k).\n        # max_unidirectional_pairs = (min_sum_k)^2 - sum(k_i^2) / 2.\n        # So, dp[val] = (min_sum_k, min_sum_k_sq_for_min_sum_k).\n        # This is a multi-objective DP.\n        # dp[val] = (min_nodes_count, min_sum_of_squares_of_scc_sizes_for_that_min_nodes_count)\n        # Initialize dp with (inf, inf). dp[0] = (0, 0).\n\n        dp_complex = [(float('inf'), float('inf'))] * (p + 1)\n        dp_complex[0] = (0, 0) # (total nodes, sum of k_i^2)\n\n        for current_p_val in range(1, p + 1):\n            for t_k, k_val in triangular_numbers:\n                if current_p_val - t_k >= 0:\n                    prev_nodes, prev_sum_sq = dp_complex[current_p_val - t_k]\n                    if prev_nodes != float('inf'):\n                        current_nodes = prev_nodes + k_val\n                        current_sum_sq = prev_sum_sq + k_val * k_val\n\n                        if current_nodes < dp_complex[current_p_val][0]:\n                            dp_complex[current_p_val] = (current_nodes, current_sum_sq)\n                        elif current_nodes == dp_complex[current_p_val][0]:\n                            # If nodes are same, we want to maximize unidirectional pairs.\n                            # Unidirectional pairs = (N^2 - sum k_i^2) / 2.\n                            # To maximize this, we need to minimize sum k_i^2.\n                            # So, we update if current_sum_sq is smaller.\n                            if current_sum_sq < dp_complex[current_p_val][1]:\n                                dp_complex[current_p_val] = (current_nodes, current_sum_sq)\n\n        min_nodes_final, min_sum_sq_final = dp_complex[p]\n\n        max_unidirectional_pairs = (min_nodes_final * min_nodes_final - min_sum_sq_final) // 2\n\n        print(min_nodes_final, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional_for_min_nodes = -1\n\n    # Iterate through possible numbers of nodes 'n'\n    # The maximum value for n can be estimated.\n    # A complete graph has n*(n-1)/2 pairs. If p is 2*10^5, then n*(n-1)/2 approx 2*10^5\n    # n^2 approx 4*10^5, so n approx sqrt(4*10^5) = 200*sqrt(10) approx 200*3.16 = 632\n    # Let's try up to 650 to be safe.\n    for n in range(1, 651):\n        # The maximum number of pairs (u,v) with u<v and reachable from each other\n        # in a graph with n nodes is n*(n-1)/2 (a complete graph or a strongly connected component of n nodes).\n        # We need k nodes to form a strongly connected component (SCC)\n        # such that k*(k-1)/2 is close to p.\n        # The remaining n-k nodes will be in a DAG structure with the SCC.\n\n        # Find the largest k such that k*(k-1)/2 <= p\n        # We want to minimize n. So we try to make k as large as possible.\n        # This k will be the size of the main SCC.\n        k_max_scc = 0\n        for k_test in range(1, n + 1):\n            if k_test * (k_test - 1) // 2 <= p:\n                k_max_scc = k_test\n            else:\n                break\n\n        if k_max_scc == 0: # Cannot form any SCC if p > 0 and k_max_scc is 0\n            continue\n\n        # Number of reachable-from-each-other pairs within the main SCC\n        pairs_in_scc = k_max_scc * (k_max_scc - 1) // 2\n\n        # Remaining pairs needed\n        remaining_p = p - pairs_in_scc\n\n        # If remaining_p is 0, we can use k_max_scc nodes.\n        # The total nodes would be k_max_scc.\n        # Unidirectional pairs:\n        # Inside the SCC, there are no unidirectional pairs.\n        # If there are n_total nodes and k_max_scc of them form an SCC,\n        # and the remaining n_total - k_max_scc nodes are isolated or form a DAG\n        # with no paths to the SCC, then unidirectional pairs are maximized.\n        # The number of unidirectional pairs is (n_total - k_max_scc) * k_max_scc.\n        # This is when the remaining nodes are all connected to the SCC in one direction (e.g., from SCC to them).\n        # To maximize unidirectional pairs, we want a chain of nodes, or a \"star\" structure\n        # where one node points to many, or many point to one.\n        # The best strategy to maximize unidirectional pairs is to have a single source/sink node\n        # connected to all other nodes.\n        # Or, more generally, an SCC of size k and a path of length n-k.\n        # The number of unidirectional pairs is maximized when we have a \"line\" of nodes\n        # where each node points to the next.\n        # If we have an SCC of size k and a path of n-k nodes, where the path is connected\n        # to the SCC (e.g., all path nodes point to SCC, or SCC points to all path nodes).\n        # Let's consider the structure: an SCC of size k, and n-k isolated nodes.\n        # Unidirectional pairs = 0.\n        # An SCC of size k, and n-k nodes forming a path, with edges from SCC to path nodes,\n        # or path nodes to SCC.\n        # Max unidirectional pairs when we have an SCC of size k and n-k nodes in a path.\n        # If we have n nodes and they form a single path (a_1 -> a_2 -> ... -> a_n),\n        # then the number of unidirectional pairs is n*(n-1)/2.\n        # If we have an SCC of size k and n-k other nodes,\n        # we can make the n-k nodes form a path, and connect one end of the path to the SCC.\n        # For example, a_1 -> a_2 -> ... -> a_{n-k} -> SCC.\n        # In this case, each node a_i can reach a_j for j > i, and also all nodes in SCC.\n        # And SCC nodes can reach a_i for i < n-k (if we make edges back).\n        # This becomes complicated.\n\n        # Let's simplify:\n        # We have an SCC of size k_max_scc.\n        # We have n - k_max_scc remaining nodes.\n        # To maximize unidirectional pairs, we should connect all remaining nodes\n        # to the SCC in one direction, or connect the SCC to all remaining nodes in one direction.\n        # For example, all (n - k_max_scc) nodes point to all k_max_scc nodes,\n        # or all k_max_scc nodes point to all (n - k_max_scc) nodes.\n        # This gives (n - k_max_scc) * k_max_scc unidirectional pairs.\n        # Additionally, if the (n - k_max_scc) nodes form a path or a DAG, they contribute more.\n        # The total number of unidirectional pairs in a graph of n nodes, with an SCC of size k,\n        # and the remaining n-k nodes forming a path (a_1 -> a_2 -> ... -> a_{n-k}),\n        # and an edge from a_{n-k} to one node in the SCC, and an edge from one node in the SCC to a_1.\n        # This makes the whole graph strongly connected, and all pairs become bidirectional.\n        # This is not what we want.\n\n        # To maximize unidirectional pairs, we need a structure that is NOT strongly connected.\n        # We have an SCC of size k_max_scc.\n        # We have n - k_max_scc nodes that are not part of this SCC.\n        # To maximize unidirectional pairs, these n - k_max_scc nodes should form a \"line\"\n        # and be connected to the SCC in a way that doesn't make the whole graph strongly connected.\n        # For example, the SCC points to the first node of the line, and the line continues.\n        # SCC -> v_1 -> v_2 -> ... -> v_{n-k_max_scc}.\n        # In this case, all nodes in SCC can reach all nodes in the line.\n        # All nodes v_i can reach v_j for j > i.\n        # But no node in the line can reach SCC.\n        # Unidirectional pairs:\n        # 1. Within the line: (n - k_max_scc) * (n - k_max_scc - 1) / 2\n        # 2. From SCC to line: k_max_scc * (n - k_max_scc)\n        # Total unidirectional pairs = k_max_scc * (n - k_max_scc) + (n - k_max_scc) * (n - k_max_scc - 1) / 2\n\n        # What if we have a set of nodes S and a set of nodes T, with all edges from S to T,\n        # and no edges from T to S.\n        # Unidirectional pairs = |S| * |T| + (unidirectional pairs in S) + (unidirectional pairs in T).\n        # To maximize unidirectional pairs, we want a structure that is a DAG of SCCs.\n        # In our case, we have one SCC of size k_max_scc.\n        # The remaining n - k_max_scc nodes should form a path (a_1 -> a_2 -> ... -> a_{n-k_max_scc}).\n        # Let's say this path is P.\n        # We can connect P to the SCC: P -> SCC.\n        # This means all nodes in P can reach SCC.\n        # Unidirectional pairs:\n        # 1. Within P: (n - k_max_scc) * (n - k_max_scc - 1) / 2\n        # 2. From P to SCC: (n - k_max_scc) * k_max_scc\n        # Total unidirectional pairs = (n - k_max_scc) * (n - k_max_scc - 1) / 2 + (n - k_max_scc) * k_max_scc\n\n        # Let's check this formula.\n        # If n=3, p=3. k_max_scc = 3. pairs_in_scc = 3. remaining_p = 0.\n        # Nodes = 3. Unidirectional = (3-3)*(3-3-1)/2 + (3-3)*3 = 0. Correct for example 1.\n\n        # If n=5, p=4.\n        # k_max_scc = 3. pairs_in_scc = 3. remaining_p = 1.\n        # We need 1 more bidirectional pair.\n        # This means we need to add a node to the SCC or make another SCC.\n        # If we have k nodes forming an SCC, and we need p pairs.\n        # We want to use k nodes to form an SCC of size k.\n        # This gives k*(k-1)/2 pairs.\n        # We need to find k such that k*(k-1)/2 <= p.\n        # The remaining p - k*(k-1)/2 pairs must come from \"crossing\" edges\n        # between nodes that are part of the SCC and nodes that are not,\n        # but in a way that makes them mutually reachable.\n        # This implies that some of the \"non-SCC\" nodes must also become part of the SCC.\n        # This means our initial k_max_scc logic might be flawed.\n\n        # Let's reformulate:\n        # We need a total of 'n' nodes.\n        # These 'n' nodes are partitioned into several SCCs, say S_1, S_2, ..., S_m.\n        # The graph of SCCs is a DAG.\n        # The total number of pairs (u,v) with u<v and u,v reachable from each other is\n        # sum_{i=1 to m} |S_i| * (|S_i|-1) / 2.\n        # We want this sum to be exactly p.\n        # To minimize n, we want to make the SCCs as large as possible.\n        # To maximize unidirectional pairs, we want the SCCs to be arranged in a long path in the SCC DAG,\n        # or have one large SCC and many isolated nodes connected to it in one direction.\n\n        # Let's assume we have one large SCC of size 'k' and 'n-k' isolated nodes that are not part of any SCC.\n        # The 'n-k' nodes are connected in a path to maximize unidirectional pairs among themselves.\n        # The number of reachable-from-each-other pairs is k*(k-1)/2.\n        # We need this to be 'p'. So k*(k-1)/2 = p.\n        # If p is not a triangular number, this structure is not possible.\n        # What if p is not a triangular number?\n        # We need to add nodes that are mutually reachable.\n        # The problem states \"u < v and u and v are reachable from each other\".\n        # This means these pairs must be in the same SCC.\n        # So, the total number of such pairs is the sum of k_i * (k_i - 1) / 2 for each SCC of size k_i.\n        # To minimize n, we should use as few SCCs as possible, and make them as large as possible.\n        # This means we should aim for a single SCC of size k, where k*(k-1)/2 = p.\n        # If p is not a triangular number, we need to find k such that k*(k-1)/2 <= p,\n        # and then add more nodes such that the remaining p pairs are formed.\n        # But how can we form exactly 'remaining_p' pairs without making other pairs?\n        # This implies that the 'remaining_p' pairs must come from within a single SCC.\n        # This is a key insight. The \"u < v and u and v are reachable from each other\" pairs\n        # *must* be within SCCs. So, we need to find a set of SCCs whose sizes k_1, k_2, ..., k_m\n        # sum up to p when their triangular numbers are summed.\n        # sum_{i=1 to m} k_i * (k_i - 1) / 2 = p.\n        # And the total number of nodes is n = sum_{i=1 to m} k_i.\n        # We want to minimize n.\n\n        # To minimize n for a given p, we should try to make the SCCs as large as possible.\n        # This means we should find the largest k such that k*(k-1)/2 <= p.\n        # Let this be k_1.\n        # Then we need to satisfy p - k_1*(k_1-1)/2 with other SCCs.\n        # This is a variation of the change-making problem or subset sum.\n        # We want to find a set of integers k_1, k_2, ..., k_m such that\n        # sum_{i=1 to m} k_i*(k_i-1)/2 = p, and sum_{i=1 to m} k_i is minimized.\n\n        # Let T(k) = k*(k-1)/2.\n        # We need to represent p as a sum of T(k_i)'s, minimizing sum k_i.\n        # We can use dynamic programming for this.\n        # dp[val] = minimum sum of k_i for which sum T(k_i) = val.\n        # Max p is 2 * 10^5.\n        # Max k for T(k) <= 2*10^5 is k approx 632.\n        dp = [float('inf')] * (p + 1)\n        dp[0] = 0\n\n        # Precompute triangular numbers and their corresponding k\n        triangular_numbers = []\n        for k_val in range(1, 650): # k can go up to ~632\n            t_k = k_val * (k_val - 1) // 2\n            if t_k > p:\n                break\n            triangular_numbers.append((t_k, k_val))\n\n        for current_p in range(1, p + 1):\n            for t_k, k_val in triangular_numbers:\n                if current_p - t_k >= 0:\n                    if dp[current_p - t_k] != float('inf'):\n                        dp[current_p] = min(dp[current_p], dp[current_p - t_k] + k_val)\n\n        min_nodes = dp[p]\n\n        # Now, calculate max unidirectional pairs for this min_nodes.\n        # We have found the minimum number of nodes, `min_nodes`,\n        # which are partitioned into SCCs to satisfy `p`.\n        # Let these SCCs have sizes k_1, k_2, ..., k_m, such that sum k_i = min_nodes.\n        # And sum T(k_i) = p.\n        # To maximize unidirectional pairs, we should arrange these SCCs in a chain (a DAG).\n        # For example, S_1 -> S_2 -> ... -> S_m.\n        # The number of unidirectional pairs is sum_{i<j} |S_i| * |S_j|.\n        # This sum is maximized when the SCCs are arranged in a single path.\n        # Let the sizes be k_1, k_2, ..., k_m.\n        # Total unidirectional pairs = sum_{i=1 to m} sum_{j=i+1 to m} k_i * k_j.\n        # This is equivalent to (sum k_i)^2 / 2 - sum k_i^2 / 2.\n        # Or, (sum k_i)^2 - sum k_i^2, then divide by 2 for ordered pairs.\n        # No, it's (sum k_i)^2 - sum k_i^2, then divide by 2 for (u,v) u<v.\n        # The total number of ordered pairs (u,v) with u!=v and u,v in different SCCs\n        # where u is in S_i and v is in S_j with i < j (assuming topological sort)\n        # is sum_{i<j} k_i * k_j.\n        # This is equal to ( (sum k_i)^2 - sum k_i^2 ) / 2.\n        # Let N = sum k_i = min_nodes.\n        # Total unidirectional pairs = (N^2 - sum k_i^2) / 2.\n        # To maximize this, we need to minimize sum k_i^2.\n        # Given a sum N, sum k_i^2 is minimized when k_i are as close to each other as possible.\n        # This means the DP approach naturally leads to minimizing sum k_i^2\n        # because it tries to use large k_i to reduce the number of SCCs.\n        # Wait, the DP minimizes sum k_i. It doesn't necessarily minimize sum k_i^2.\n\n        # Example: p=6.\n        # T(1)=0, T(2)=1, T(3)=3, T(4)=6.\n        # dp[6] = 4 (using k=4). Sum k_i^2 = 4^2 = 16. Unidirectional = (4^2 - 16)/2 = 0.\n        # Another way to get p=6: T(3)+T(3) = 3+3=6. Sum k_i = 3+3 = 6.\n        # Nodes = 6. Sum k_i^2 = 3^2 + 3^2 = 9+9 = 18. Unidirectional = (6^2 - 18)/2 = (36-18)/2 = 9.\n        # So for p=6, min_nodes=4, max_unidirectional=0.\n        # If we use 6 nodes, we get 9 unidirectional pairs.\n        # The problem asks for max unidirectional pairs *among all such p-reachable graphs with the minimum number of nodes*.\n        # So, we need to find the specific partition k_i that yields min_nodes AND maximizes unidirectional pairs.\n\n        # We need to modify the DP state.\n        # dp[val] = (min_sum_k, min_sum_k_sq)\n        # No, it should be dp[val] = (min_sum_k, max_unidirectional_pairs_for_min_sum_k).\n        # max_unidirectional_pairs = (min_sum_k)^2 - sum(k_i^2) / 2.\n        # So, dp[val] = (min_sum_k, min_sum_k_sq_for_min_sum_k).\n        # This is a multi-objective DP.\n        # dp[val] = (min_nodes_count, min_sum_of_squares_of_scc_sizes_for_that_min_nodes_count)\n        # Initialize dp with (inf, inf). dp[0] = (0, 0).\n\n        dp_complex = [(float('inf'), float('inf'))] * (p + 1)\n        dp_complex[0] = (0, 0) # (total nodes, sum of k_i^2)\n\n        for current_p_val in range(1, p + 1):\n            for t_k, k_val in triangular_numbers:\n                if current_p_val - t_k >= 0:\n                    prev_nodes, prev_sum_sq = dp_complex[current_p_val - t_k]\n                    if prev_nodes != float('inf'):\n                        current_nodes = prev_nodes + k_val\n                        current_sum_sq = prev_sum_sq + k_val * k_val\n\n                        if current_nodes < dp_complex[current_p_val][0]:\n                            dp_complex[current_p_val] = (current_nodes, current_sum_sq)\n                        elif current_nodes == dp_complex[current_p_val][0]:\n                            # If nodes are same, we want to maximize unidirectional pairs.\n                            # Unidirectional pairs = (N^2 - sum k_i^2) / 2.\n                            # To maximize this, we need to minimize sum k_i^2.\n                            # So, we update if current_sum_sq is smaller.\n                            if current_sum_sq < dp_complex[current_p_val][1]:\n                                dp_complex[current_p_val] = (current_nodes, current_sum_sq)\n\n        min_nodes_final, min_sum_sq_final = dp_complex[p]\n\n        max_unidirectional_pairs = (min_nodes_final * min_nodes_final - min_sum_sq_final) // 2\n\n        print(min_nodes_final, max_unidirectional_pairs)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 5077,
        "thoughts_token_count": 0
    }
}