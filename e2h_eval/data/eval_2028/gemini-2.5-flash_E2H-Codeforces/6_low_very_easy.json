{
    "start": 1758009285.0153227,
    "end": 1758009316.01207,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Tackling the Voucher Problem**\n\nOkay, so I've got this competitive programming problem staring me down. The core is finding two distinct vouchers that don't overlap, add up to a specific duration *x*, and minimize their combined cost. If no such pair exists, I need to output -1. Straightforward, right? Let's break this down.\n\nFirst, I see the input: *n* vouchers, the target duration *x*, and details for each voucher – departure, arrival, and cost. The constraints tell me I'm dealing with numbers up to 2 * 10^5, so I can start thinking about feasible solution approaches.\n\nImmediately, the non-intersection condition grabs my attention. One voucher must finish *before* the other starts. Without loss of generality, I can assume voucher *i* ends before voucher *j* begins. Now, the math is simple, the duration of voucher *i* plus the duration of voucher *j* should be equal to *x*.\n\nThe problem screams out for an efficient algorithm, especially with the constraints. A naive O(N^2) brute-force approach, checking every pair, is a non-starter. I need to get down to something around O(N log N) or O(N * MaxCoord) to stay within the time limit.\n\nLet's rephrase this: I need two vouchers, *v1* and *v2*, that don't overlap, have a combined duration of *x*, and minimize the total cost. If I calculate the duration of *v1* (let's call it *d1*), then the duration of *v2* (*d2*) is simply *x - d1*. This is useful!\n\nSo, the naive approach would be to iterate through all possible pairs. But that leads to O(N^2) which is way too slow. What can I do instead? It seems that, if I fix one voucher, *v1* I can compute the duration I need for the other one (*d2* = *x - d1*).\n",
    "response": "The problem asks us to find two non-overlapping vouchers whose total duration is exactly `x` and whose combined cost is minimized. If no such pair exists, we should output -1.\n\nLet's denote a voucher by `(l, r, cost)`, where `l` is the departure day, `r` is the arrival day, and `cost` is its price. The duration of a voucher is `d = r - l + 1`.\n\nTwo vouchers `(l1, r1, cost1)` and `(l2, r2, cost2)` are non-overlapping if `r1 < l2` or `r2 < l1`.\nWe need to find a pair such that `(r1 - l1 + 1) + (r2 - l2 + 1) = x`, and `cost1 + cost2` is minimized.\n\nThe key idea is to process vouchers in a way that allows us to efficiently find a suitable second voucher for any given first voucher. We can sort the vouchers by their departure day `l` to simplify the non-overlapping condition.\n\nLet's store the vouchers grouped by their departure day `l`. We can use a list of lists or a dictionary where keys are `l` and values are lists of `(r, cost, duration)` for vouchers starting on day `l`.\n`vouchers_by_l[l]` will contain `[(r, cost, duration), ...]` for all vouchers starting on day `l`.\n\nWe also need to keep track of the minimum cost for a voucher ending on a specific day `r` with a specific duration `d`. This is because when we consider a voucher `v1 = (l1, r1, cost1, d1)`, we need to find a `v2 = (l2, r2, cost2, d2)` such that `d2 = x - d1` and `r1 < l2`.\nTo optimize this, we can maintain an array, say `min_cost_for_duration_ending_at[duration][end_day]`, which stores the minimum cost of a voucher with `duration` that ends on or before `end_day`.\nHowever, `end_day` can be up to `2 * 10^5`, and `duration` can also be up to `2 * 10^5`. A 2D array of this size `(2e5 * 2e5)` is too large.\n\nA more efficient approach is to iterate through all possible `r` values (arrival days). For each `r`, we consider all vouchers that *end* on day `r`.\nWhen processing vouchers ending on day `r`:\n1.  For each voucher `v = (l, r, cost, d)`:\n    *   We are looking for a second voucher `v_other = (l_other, r_other, cost_other, d_other)` such that `d + d_other = x` and `r_other < l`.\n    *   This means `d_other = x - d`.\n    *   We need to find the minimum cost `cost_other` among all vouchers with duration `d_other` that end *before* day `l`.\n    *   If `d_other` is not positive, this voucher `v` cannot be part of a valid pair.\n    *   To efficiently find this `cost_other`, we need to maintain information about available vouchers that have already been processed (i.e., they end before the current `l`).\n\nLet's refine this:\nIterate through days `t` from `1` to `MAX_DAY` (which is `2 * 10^5`).\nMaintain an array `min_cost_for_duration[duration]` which stores the minimum cost of a voucher with that `duration` that has *already ended* by day `t-1`. Initialize all entries to infinity.\n\nFor each day `t`:\n1.  **Check for potential pairs**: For all vouchers `(l, r, cost, d)` that *start* on day `t`:\n    *   Calculate the required duration for the second voucher: `d_other = x - d`.\n    *   If `d_other > 0` and `min_cost_for_duration[d_other]` is not infinity (meaning there's a valid first voucher that ended before day `t`), then we can form a pair.\n    *   Update the overall minimum total cost: `min_total_cost = min(min_total_cost, cost + min_cost_for_duration[d_other])`.\n\n2.  **Update `min_cost_for_duration`**: For all vouchers `(l, r, cost, d)` that *end* on day `t`:\n    *   Update `min_cost_for_duration[d] = min(min_cost_for_duration[d], cost)`. This makes this voucher available for future pairs (i.e., for vouchers starting on day `t+1` or later).\n\nThis approach processes vouchers based on both their start and end days.\nLet's store vouchers in two lists:\n*   `vouchers_by_start_day[l]` contains `(r, cost, duration)` for vouchers starting on day `l`.\n*   `vouchers_by_end_day[r]` contains `(l, cost, duration)` for vouchers ending on day `r`.\n\nInitialize `min_total_cost = infinity`.\nInitialize `min_cost_for_duration_ending_before_current_day[d]` to infinity for all `d` from `1` to `x-1`. This array will store the minimum cost of a single voucher with duration `d` that has already *finished* by the current day `t-1`.\n\nIterate `t` from `1` to `MAX_DAY` (`2 * 10^5`):\n1.  **Process vouchers starting on day `t`**:\n    For each `(r, cost, d)` in `vouchers_by_start_day[t]`:\n        Let `d_needed = x - d`.\n        If `1 <= d_needed < x`: (duration must be positive and less than x)\n            If `min_cost_for_duration_ending_before_current_day[d_needed]` is not infinity:\n                `min_total_cost = min(min_total_cost, cost + min_cost_for_duration_ending_before_current_day[d_needed])`\n\n2.  **Process vouchers ending on day `t`**:\n    For each `(l, cost, d)` in `vouchers_by_end_day[t]`:\n        If `1 <= d < x`: (duration must be positive and less than x)\n            `min_cost_for_duration_ending_before_current_day[d] = min(min_cost_for_duration_ending_before_current_day[d], cost)`\n\nAfter iterating through all days, if `min_total_cost` is still infinity, it means no valid pair was found, so print -1. Otherwise, print `min_total_cost`.\n\n**Data Structures and Complexity:**\n*   `MAX_DAY = 2 * 10^5`.\n*   `vouchers_by_start_day`: A list of lists, indexed `0` to `MAX_DAY`. Each inner list stores tuples.\n*   `vouchers_by_end_day`: Similar list of lists.\n*   `min_cost_for_duration_ending_before_current_day`: An array of size `x`, indexed `0` to `x-1`. `x` can be up to `2 * 10^5`.\n\nInitialization:\n*   `vouchers_by_start_day` and `vouchers_by_end_day`: `O(N)` to populate.\n*   `min_cost_for_duration_ending_before_current_day`: `O(x)` to initialize.\n*   `min_total_cost`: `O(1)`.\n\nMain loop:\n*   Iterates `MAX_DAY` times.\n*   Inside the loop, we iterate through vouchers starting/ending on day `t`. Each voucher is processed exactly twice (once when its start day is `t`, once when its end day is `t`).\n*   Total operations for processing vouchers: `O(N)`.\n*   Accessing `min_cost_for_duration_ending_before_current_day` is `O(1)`.\n\nTotal time complexity: `O(N + MAX_DAY + x)`. Given `N, x, MAX_DAY <= 2 * 10^5`, this is `O(2 * 10^5)`, which is efficient enough.\nSpace complexity: `O(N + MAX_DAY + x)`. Also efficient enough.\n\n**Edge Cases:**\n*   `x` can be very small (e.g., 2). If `x=2`, then `d_needed` would be `1`. The `min_cost_for_duration` array should handle durations from `1` up to `x-1`.\n*   No valid pairs: `min_total_cost` remains infinity.\n*   Single voucher: `N >= 2` is guaranteed.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5 + 1 # Max day can be 2*10^5\n\n    # vouchers_by_start_day[l] stores list of (r, cost, duration) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD)]\n    # vouchers_by_end_day[r] stores list of (l, cost, duration) for vouchers ending on day r\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((l, cost, duration))\n\n    # min_cost_for_duration_ending_before_current_day[d] stores the minimum cost\n    # of a voucher with duration 'd' that has already ended by the current day (t-1).\n    # We only care about durations d from 1 to x-1.\n    min_cost_for_duration_ending_before_current_day = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each day from 1 to MAX_COORD - 1\n    for t in range(1, MAX_COORD):\n        # Phase 1: Consider vouchers starting on day 't' as the second voucher\n        # We look for a first voucher that ended before day 't'\n        for r, cost, d in vouchers_by_start_day[t]:\n            d_needed = x - d\n            # The duration of the other voucher must be positive and less than x\n            if 1 <= d_needed < x:\n                if min_cost_for_duration_ending_before_current_day[d_needed] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost + min_cost_for_duration_ending_before_current_day[d_needed])\n\n        # Phase 2: Update min_cost_for_duration_ending_before_current_day\n        # for vouchers that end on day 't'. These vouchers become available\n        # for pairs starting on day 't+1' or later.\n        for l, cost, d in vouchers_by_end_day[t]:\n            # Only consider durations that could be part of an 'x' sum\n            if 1 <= d < x:\n                min_cost_for_duration_ending_before_current_day[d] = min(\n                    min_cost_for_duration_ending_before_current_day[d],\n                    cost\n                )\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5 + 1 # Max day can be 2*10^5\n\n    # vouchers_by_start_day[l] stores list of (r, cost, duration) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD)]\n    # vouchers_by_end_day[r] stores list of (l, cost, duration) for vouchers ending on day r\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((l, cost, duration))\n\n    # min_cost_for_duration_ending_before_current_day[d] stores the minimum cost\n    # of a voucher with duration 'd' that has already ended by the current day (t-1).\n    # We only care about durations d from 1 to x-1.\n    min_cost_for_duration_ending_before_current_day = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each day from 1 to MAX_COORD - 1\n    for t in range(1, MAX_COORD):\n        # Phase 1: Consider vouchers starting on day 't' as the second voucher\n        # We look for a first voucher that ended before day 't'\n        for r, cost, d in vouchers_by_start_day[t]:\n            d_needed = x - d\n            # The duration of the other voucher must be positive and less than x\n            if 1 <= d_needed < x:\n                if min_cost_for_duration_ending_before_current_day[d_needed] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost + min_cost_for_duration_ending_before_current_day[d_needed])\n\n        # Phase 2: Update min_cost_for_duration_ending_before_current_day\n        # for vouchers that end on day 't'. These vouchers become available\n        # for pairs starting on day 't+1' or later.\n        for l, cost, d in vouchers_by_end_day[t]:\n            # Only consider durations that could be part of an 'x' sum\n            if 1 <= d < x:\n                min_cost_for_duration_ending_before_current_day[d] = min(\n                    min_cost_for_duration_ending_before_current_day[d],\n                    cost\n                )\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 2785,
        "thoughts_token_count": 800
    }
}