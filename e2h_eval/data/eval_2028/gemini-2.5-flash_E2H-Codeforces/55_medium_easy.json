{
    "start": 1758294897.79168,
    "end": 1758294956.8498826,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Lexicographically Smallest String from Swaps**\n\nOkay, so I'm presented with a string of '0's, '1's, and '2's, and I need to find the smallest string I can get by swapping adjacent characters. The swaps are limited: '0' and '1' can swap, and '1' and '2' can swap, but '0' and '2' can't directly swap. My initial thought is to figure out the implications of these swaps. It's clear that a '0' can move past a '1' (and vice versa), and a '2' can move past a '1' (and vice versa). But, critically, '0' and '2' can't directly cross each other.\n\nThis leads to a key insight: the order of '0's and '2's relative to each other is *fixed*. If a '0' is initially before a '2', that order must be preserved in the final string, even if there are '1's in between.  However, the '1's are essentially wild cards. They can move anywhere, acting as buffers, passing freely between '0's and '2's.\n\nSo, how do I make the lexicographically smallest string? I want to put as many '0's as possible at the beginning, then the '1's, then the '2's.  I can count the occurrences of each digit, but the challenge is knowing where to insert the '1's.\n\nI realize that the relative order of '0's and '2's is the backbone of the solution. If I remove all the '1's from the original string, I get a subsequence of '0's and '2's. This subsequence's order *must* be preserved in my final, smallest string.\n\nMy strategy becomes clear: first, extract the subsequence of '0's and '2's, preserving their original order.  Then, count all the '1's.  Finally, insert those '1's into the subsequence. To make it smallest, I put all the '0's from the subsequence at the beginning, then the '1's, and then any remaining '2's (or '0's) from the subsequence. This ensures that the original '0's and '2's maintain their order while allowing the '1's to fill in the gaps for the smallest possible resulting string.  I need to find the index of the first '2' in that subsequence to figure out exactly where the '1's go.  That's the key.\n",
    "response": "The problem asks us to find the lexicographically smallest string obtainable by swapping adjacent '0' and '1', or adjacent '1' and '2'. Swapping '0' and '2' is not allowed.\n\nLet's analyze the allowed operations:\n1. '0' can swap with '1': \"01\" <-> \"10\"\n2. '1' can swap with '2': \"12\" <-> \"21\"\n\nFrom these rules, we can deduce the following:\n- A '0' can move past any '1' (to its left or right).\n- A '2' can move past any '1' (to its left or right).\n- A '1' can move past any '0' or '2'.\n\nCrucially, a '0' cannot directly swap with a '2'. This means that the relative order of any '0' and any '2' in the original string must be preserved in the final string. For example, if an original '0' appears before an original '2', it must still appear before that '2' in the final string. If an original '2' appears before an original '0', it must still appear before that '0' in the final string.\n\nThis implies that all '1's are \"mobile\" and can essentially be moved to any position relative to the '0's and '2's. The '0's and '2's, however, maintain their relative order amongst themselves.\n\nTo obtain the lexicographically smallest string, we want to place '0's as far left as possible, then '1's, then '2's.\n\nHere's the strategy:\n1.  **Separate '1's from '0's and '2's**: Iterate through the input string. Count all occurrences of '1's. Collect all '0's and '2's into a new sequence, let's call it `subsequence_02`. This `subsequence_02` preserves the relative order of '0's and '2's as they appeared in the original string.\n    *Example: For \"100210\"*, `total_ones = 2`, and `subsequence_02 = \"0020\"`.\n\n2.  **Determine the insertion point for '1's**: Since we want '0's first, then '1's, then '2's, all the '1's should be placed after any '0's that can possibly appear at the beginning of the string, and before any '2's. In terms of `subsequence_02`, this means we should insert all the `total_ones` '1's right before the first '2' encountered in `subsequence_02`.\n    *Example: For `subsequence_02 = \"0020\"`, the first '2' is at index 2. So, '1's should be inserted at this position.*\n\n3.  **Construct the final string**:\n    *   Take the part of `subsequence_02` that comes *before* the first '2'. (These are all '0's that appear before any '2' in the original string).\n    *   Append all the `total_ones` '1's.\n    *   Append the rest of `subsequence_02` (which includes the first '2' and any subsequent '2's or '0's).\n\nLet's apply this to the examples:\n\n*   **Input: \"100210\"**\n    *   `total_ones = 2` (from `s[0]` and `s[4]`)\n    *   `subsequence_02 = \"0020\"` (from `s[1], s[2], s[3], s[5]`)\n    *   The first '2' in `subsequence_02` is at index 2.\n    *   Result: `subsequence_02[0:2]` (`\"00\"`) + `two '1's` (`\"11\"`) + `subsequence_02[2:]` (`\"20\"`) = `\"001120\"`\n\n*   **Input: \"11222121\"**\n    *   `total_ones = 4`\n    *   `subsequence_02 = \"2222\"`\n    *   The first '2' in `subsequence_02` is at index 0.\n    *   Result: `subsequence_02[0:0]` (`\"\"`) + `four '1's` (`\"1111\"`) + `subsequence_02[0:]` (`\"2222\"`) = `\"11112222\"`\n\n*   **Input: \"20\"**\n    *   `total_ones = 0`\n    *   `subsequence_02 = \"20\"`\n    *   The first '2' in `subsequence_02` is at index 0.\n    *   Result: `subsequence_02[0:0]` (`\"\"`) + `zero '1's` (`\"\"`) + `subsequence_02[0:]` (`\"20\"`) = `\"20\"`\n\nThis approach is efficient: it involves a single pass to build `subsequence_02` and count `total_ones`, another pass (at most) to find the first '2', and then string construction. All operations are linear in the length of the string, making it an O(N) solution.\n\n```python\nimport sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    total_ones = 0\n    subsequence_02_chars = []\n\n    # First pass: count '1's and build the subsequence of '0's and '2's\n    for char in s:\n        if char == '1':\n            total_ones += 1\n        else:\n            subsequence_02_chars.append(char)\n\n    # Find the insertion point for '1's.\n    # This is the index of the first '2' in subsequence_02_chars.\n    # If no '2' is found, 'idx_first_2' will remain its initial value,\n    # which is the length of subsequence_02_chars, effectively placing '1's at the end.\n    idx_first_2 = len(subsequence_02_chars) \n    for i in range(len(subsequence_02_chars)):\n        if subsequence_02_chars[i] == '2':\n            idx_first_2 = i\n            break\n    \n    # Construct the result string using a list of characters for efficient appending\n    result_chars = []\n    \n    # Append the '0's (and any '0's that might be there) that appear before the first '2'\n    # in the subsequence_02_chars.\n    result_chars.extend(subsequence_02_chars[0:idx_first_2])\n    \n    # Append all the '1's that were counted.\n    result_chars.extend(['1'] * total_ones)\n    \n    # Append the rest of the subsequence_02_chars, starting from the first '2'\n    # (or from the end if no '2' was found). This includes all '2's and any '0's\n    # that originally appeared after the first '2'.\n    result_chars.extend(subsequence_02_chars[idx_first_2:])\n    \n    # Join the list of characters to form the final string and print it\n    print(\"\".join(result_chars))\n\n# Call the solve function to execute the program\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    total_ones = 0\n    subsequence_02_chars = []\n\n    # First pass: count '1's and build the subsequence of '0's and '2's\n    for char in s:\n        if char == '1':\n            total_ones += 1\n        else:\n            subsequence_02_chars.append(char)\n\n    # Find the insertion point for '1's.\n    # This is the index of the first '2' in subsequence_02_chars.\n    # If no '2' is found, 'idx_first_2' will remain its initial value,\n    # which is the length of subsequence_02_chars, effectively placing '1's at the end.\n    idx_first_2 = len(subsequence_02_chars) \n    for i in range(len(subsequence_02_chars)):\n        if subsequence_02_chars[i] == '2':\n            idx_first_2 = i\n            break\n    \n    # Construct the result string using a list of characters for efficient appending\n    result_chars = []\n    \n    # Append the '0's (and any '0's that might be there) that appear before the first '2'\n    # in the subsequence_02_chars.\n    result_chars.extend(subsequence_02_chars[0:idx_first_2])\n    \n    # Append all the '1's that were counted.\n    result_chars.extend(['1'] * total_ones)\n    \n    # Append the rest of the subsequence_02_chars, starting from the first '2'\n    # (or from the end if no '2' was found). This includes all '2's and any '0's\n    # that originally appeared after the first '2'.\n    result_chars.extend(subsequence_02_chars[idx_first_2:])\n    \n    # Join the list of characters to form the final string and print it\n    print(\"\".join(result_chars))\n\n# Call the solve function to execute the program\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 612,
        "completion_token_count": 1753,
        "thoughts_token_count": 7502
    }
}