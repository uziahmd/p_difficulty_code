{
    "start": 1758294744.5697703,
    "end": 1758294826.1499825,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Unraveling the Mystery of Vasya's Olympiad Rank**\n\nAlright, let's break this down. My goal here is to figure out the best and worst possible ranks Vasya could snag in this Olympiad.  We're given the number of participants (`n`), the minimum points Vasya got (`x`), and the scores from two rounds (`a` and `b`). The tricky part? We don't know which scores from `a` go with which scores from `b` for each participant. It's a matching game!\n\nFirst, let's understand rank.  It's simply 1 plus the number of people who scored strictly higher. If there's a tie, the jury decides –  convenient for us!  To get the *best* rank, I want Vasya to score as much as possible and minimize the number of competitors beating him. For the *worst* rank, I need to make his score as small as possible while still hitting that `x` mark, and then maximize the number of people scoring *at least* as much as he does, hoping the jury is feeling spiteful.\n\nThe real challenge is matching those scores.  We're free to pair any score from `a` with any score from `b`.  To find the best rank, my initial instinct was to give Vasya the largest possible sum, but it's more subtle than that. The problem states that he *achieved* the score, not that he *can* achieve it.\n\n**The Strategy Unfolds**\n\nLet's simplify. Since it's about points, not names, sorting seems crucial. To *maximize* the sum of scores (which is irrelevant for ranks, since it's the same sum for all participants), you'd pair the biggest with the biggest, and smallest with smallest. However, for getting the worst rank, what we really want is to find the smallest Vasya can get such that the sum is equal to `x` or more.\n\nMy idea to minimize the *maximum* sum of pairs (that is, the worst case scenario of ranking other participants with scores) is to sort array `a` and array `b`, with `a` in ascending and `b` in descending order, then pair the respective indices.\n\nTo get the worst rank, I have to ensure his score satisfies  `a_i + b_j >= x`. Since `f(S)` is monotonically non-increasing. It is the number of participants such that there is a score equal or higher than `S`. I need to figure out how many people can get the best possible matching that results in a score equal to `x` or more. The answer is given by finding the smallest score `x` or more and counting the number of participants.\n\n**Best Rank: The Triumph of the Greedy Algorithm**\n\nFor the best rank, the logic is simpler than I initially thought. I need Vasya to score high and minimize the number of people who score *more*. Sorting `a` and `b` in ascending order, Vasya taking the highest score ensures no one scores higher (with the given pairing strategy). It turns out, that regardless of the initial scores, by the problem description, Vasya should always be rank 1 if we assume the optimal pairing strategy is in favor of Vasya, for a sorted and increasing array `a`, and increasing array `b`.\n\nFinal thoughts: The key here is understanding the pairing game with two arrays `a` and `b`, the key for calculating the worst rank. I want to pair the scores to give Vasya the worst possible position, meaning matching him up against some scores such that many people reach `x` or more. By pairing the ascending array `a` with the ascending array `b`, Vasya has the worst rank, while if `a` and `b` were ascending, and `b` decreasing, then Vasya has the best rank.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given the scores from two tours for all `n` participants and a minimum total score `x` Vasya is guaranteed to have achieved. The key challenge is that we don't know which first tour score belongs to which second tour score; we can form any `n` pairs `(a_i, b_j)` such that each `a_i` and `b_j` is used exactly once. Ranks are determined by total points, with higher points being better. In case of ties, the jury can assign places arbitrarily.\n\nLet's sort the scores for the first tour (`a`) and the second tour (`b`) in ascending order.\n`a = [a_0, a_1, ..., a_{n-1}]`\n`b = [b_0, b_1, ..., b_{n-1}]`\n\n**1. Best Rank for Vasya**\n\nTo achieve the best possible rank, Vasya wants to:\na. Maximize his own total score.\nb. Minimize the number of participants who score strictly more than him.\nc. If he ties with others, the jury will give him the best possible rank among the tied participants. This means his rank is `1 + (number of participants with strictly more points than Vasya)`.\n\nConsider the scenario where Vasya takes the highest possible score he can achieve. This would be `a_{n-1} + b_{n-1}`. Let this be `S_V = a_{n-1} + b_{n-1}`. The problem guarantees that Vasya was present and achieved at least `x` points, so there exist `i, j` such that `a_i + b_j >= x`. This implies that `a_{n-1} + b_{n-1}` must also be `>= x`. So, Vasya can indeed achieve `S_V`.\n\nNow, consider the other `n-1` participants. The remaining scores are `a_0, ..., a_{n-2}` and `b_0, ..., b_{n-2}`. Any pairing of these remaining scores will result in sums `a_p + b_q` where `p, q < n-1`. Since `a_p <= a_{n-1}` and `b_q <= b_{n-1}`, it is impossible for any other participant to score strictly more than `S_V = a_{n-1} + b_{n-1}`.\nTherefore, in this arrangement, no one scores strictly more than Vasya. This means the number of participants with strictly more points than Vasya is 0.\nVasya's best possible rank is `1 + 0 = 1`.\n\nThis strategy is always possible: we assign `a_{n-1}` and `b_{n-1}` to Vasya. For the remaining `n-1` participants, we can pair `a_i` with `b_i` for `i = 0, ..., n-2` (or any other valid pairing). Since all `a_i` and `b_i` for `i < n-1` are less than or equal to `a_{n-1}` and `b_{n-1}` respectively, no other participant can achieve a score strictly greater than `a_{n-1} + b_{n-1}`.\n\nSo, the best rank is always 1.\n\n**2. Worst Rank for Vasya**\n\nTo achieve the worst possible rank, Vasya wants to:\na. Minimize his own total score, while still satisfying `S_V >= x`.\nb. Maximize the number of participants who score strictly more than him.\nc. If he ties with others, the jury will give him the worst possible rank among the tied participants. This means his rank is `1 + (number of participants with strictly more points than Vasya) + (number of participants with the same points as Vasya)`. This simplifies to `(number of participants with points >= S_V)`.\n\nLet `S_V` be Vasya's score. We want to find a pairing of all `n` scores such that `S_V >= x`, and the number of participants who score `>= S_V` is maximized.\nLet `f(S)` be the maximum number of participants that can achieve a total score of at least `S`.\nWe want to find `max(f(S))` for `S >= x`.\nSince `f(S)` is a monotonically non-increasing function (if `S` increases, `f(S)` can only decrease or stay the same), `max(f(S))` for `S >= x` is simply `f(x)`.\n\nSo, the problem reduces to calculating `f(x)`: the maximum number of participants that can achieve a total score of at least `x`.\nWe can use a two-pointer approach for this:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n3. Initialize `count = 0` (this will store `f(x)`).\n4. Initialize `j = n - 1` (pointer for `b`, starting from the largest score).\n5. Iterate `i` from `0` to `n - 1` (pointer for `a`, starting from the smallest score):\n   a. While `j >= 0` and `a_i + b_j < x`:\n      Decrement `j`. This means `a_i` is too small to pair with `b_j` (or any smaller `b` score) to reach `x`. We need a larger `a_i` or a larger `b_j`. Since `a_i` is fixed in the outer loop, we try smaller `b_j` with other `a`s.\n   b. If `j < 0`: Break the loop. No more `b` scores can form a sum `>= x` with the remaining `a` scores.\n   c. If `a_i + b_j >= x`: We found a valid pair `(a_i, b_j)`. Increment `count`. Decrement `j` (this `b_j` is now used). The `a_i` is also considered used by moving to `i+1` in the next iteration.\n\nThis greedy strategy works because to maximize the number of pairs summing to at least `x`, we should try to use the smallest `a_i` with the largest `b_j` that still satisfies the condition. If `a_i` can combine with `b_j` to make at least `x`, then `a_i` can also combine with any `b_k` where `k > j` to make at least `x`. By pairing `a_i` with `b_j`, we save the larger `b_k` values for potentially larger `a` values that might need them more. Similarly, if `a_i` cannot combine with `b_j` to make `x`, it cannot combine with any `b_k` where `k < j` either. So `b_j` must be used with a larger `a_p` (if possible), or discarded. By decrementing `j`, we effectively discard `b_j` for `a_i` and try to find a suitable `b` for `a_i` from the remaining `b`s.\n\nAfter the loop finishes, `count` will hold `f(x)`. This `count` represents the maximum number of participants who can score at least `x`. Vasya is one of these `count` participants. To get his worst rank, the jury can place him last among these `count` participants. So, his worst rank is `count`.\n\n**Example 2 Walkthrough (Worst Rank):**\n`n=6, x=7`\n`a = [4, 3, 5, 6, 4, 4]` -> sorted: `[3, 4, 4, 4, 5, 6]`\n`b = [8, 6, 0, 4, 3, 4]` -> sorted: `[0, 3, 4, 4, 6, 8]`\n\nInitialize `count = 0`, `j = 5`.\n`i=0, a_0=3`:\n  `j=5, b_5=8`. `a_0 + b_5 = 3 + 8 = 11`. `11 >= 7`. Yes.\n  `count = 1`. `j = 4`.\n`i=1, a_1=4`:\n  `j=4, b_4=6`. `a_1 + b_4 = 4 + 6 = 10`. `10 >= 7`. Yes.\n  `count = 2`. `j = 3`.\n`i=2, a_2=4`:\n  `j=3, b_3=4`. `a_2 + b_3 = 4 + 4 = 8`. `8 >= 7`. Yes.\n  `count = 3`. `j = 2`.\n`i=3, a_3=4`:\n  `j=2, b_2=4`. `a_3 + b_2 = 4 + 4 = 8`. `8 >= 7`. Yes.\n  `count = 4`. `j = 1`.\n`i=4, a_4=5`:\n  `j=1, b_1=3`. `a_4 + b_1 = 5 + 3 = 8`. `8 >= 7`. Yes.\n  `count = 5`. `j = 0`.\n`i=5, a_5=6`:\n  `j=0, b_0=0`. `a_5 + b_0 = 6 + 0 = 6`. `6 < 7`. No.\n  Decrement `j`. `j = -1`.\n  `j < 0`, so break.\n\nThe final `count` is 5. So, the worst rank for Vasya is 5.\n\n**Complexity:**\n- Sorting `a` and `b`: `O(N log N)`.\n- Two-pointer approach for worst rank: `O(N)`.\n- Best rank is constant time (1).\nOverall time complexity: `O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays (or `O(1)` if sorting in place).\nGiven `N <= 10^5`, this is efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best Rank:\n    # Vasya wants to maximize his score and minimize the number of people\n    # scoring strictly more than him.\n    # By taking the largest available score from tour A (a[n-1]) and\n    # the largest available score from tour B (b[n-1]), Vasya achieves\n    # the maximum possible total score (a[n-1] + b[n-1]).\n    # Since all other scores a_i, b_j are less than or equal to a[n-1] and b[n-1],\n    # no other participant can achieve a score strictly greater than Vasya's.\n    # In case of ties, the jury assigns the best place to Vasya.\n    # Therefore, Vasya's best rank is always 1.\n    best_rank = 1\n\n    # Worst Rank:\n    # Vasya wants to minimize his score (while still >= x) and maximize\n    # the number of people scoring greater than or equal to him.\n    # If there are K participants (including Vasya) who score >= S_Vasya,\n    # and the jury is against him, Vasya gets rank K.\n    # We want to find the maximum possible K such that K participants can score >= x.\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= x.\n    # We use a two-pointer approach after sorting both arrays.\n\n    a.sort()  # Sort a in ascending order\n    b.sort()  # Sort b in ascending order\n\n    worst_rank_count = 0\n    j = n - 1  # Pointer for array b, starting from the largest element\n\n    for i in range(n):  # Pointer for array a, starting from the smallest element\n        # For current a[i], find the largest b[j] such that a[i] + b[j] >= x.\n        # If a[i] + b[j] < x, then a[i] cannot form a sum >= x with b[j] or any smaller b_k.\n        # So, b[j] must be paired with some larger a_k (if possible) or discarded.\n        # We move j left to find a smaller b that might pair with a larger a later,\n        # or simply to discard b[j] if it cannot help a[i].\n        while j >= 0 and a[i] + b[j] < x:\n            j -= 1\n        \n        # If j becomes negative, it means no remaining b elements can form a sum >= x with current a[i]\n        # or any subsequent a_k (since a is sorted ascending).\n        if j < 0:\n            break\n        \n        # If we reach here, a[i] + b[j] >= x. We found a valid pair.\n        worst_rank_count += 1\n        j -= 1  # This b[j] is now used, move to the next largest available b.\n                # a[i] is also considered used as we move to i+1 in the next iteration.\n\n    worst_rank = worst_rank_count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best Rank:\n    # Vasya wants to maximize his score and minimize the number of people\n    # scoring strictly more than him.\n    # By taking the largest available score from tour A (a[n-1]) and\n    # the largest available score from tour B (b[n-1]), Vasya achieves\n    # the maximum possible total score (a[n-1] + b[n-1]).\n    # Since all other scores a_i, b_j are less than or equal to a[n-1] and b[n-1],\n    # no other participant can achieve a score strictly greater than Vasya's.\n    # In case of ties, the jury assigns the best place to Vasya.\n    # Therefore, Vasya's best rank is always 1.\n    best_rank = 1\n\n    # Worst Rank:\n    # Vasya wants to minimize his score (while still >= x) and maximize\n    # the number of people scoring greater than or equal to him.\n    # If there are K participants (including Vasya) who score >= S_Vasya,\n    # and the jury is against him, Vasya gets rank K.\n    # We want to find the maximum possible K such that K participants can score >= x.\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= x.\n    # We use a two-pointer approach after sorting both arrays.\n\n    a.sort()  # Sort a in ascending order\n    b.sort()  # Sort b in ascending order\n\n    worst_rank_count = 0\n    j = n - 1  # Pointer for array b, starting from the largest element\n\n    for i in range(n):  # Pointer for array a, starting from the smallest element\n        # For current a[i], find the largest b[j] such that a[i] + b[j] >= x.\n        # If a[i] + b[j] < x, then a[i] cannot form a sum >= x with b[j] or any smaller b_k.\n        # So, b[j] must be paired with some larger a_k (if possible) or discarded.\n        # We move j left to find a smaller b that might pair with a larger a later,\n        # or simply to discard b[j] if it cannot help a[i].\n        while j >= 0 and a[i] + b[j] < x:\n            j -= 1\n        \n        # If j becomes negative, it means no remaining b elements can form a sum >= x with current a[i]\n        # or any subsequent a_k (since a is sorted ascending).\n        if j < 0:\n            break\n        \n        # If we reach here, a[i] + b[j] >= x. We found a valid pair.\n        worst_rank_count += 1\n        j -= 1  # This b[j] is now used, move to the next largest available b.\n                # a[i] is also considered used as we move to i+1 in the next iteration.\n\n    worst_rank = worst_rank_count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 863,
        "completion_token_count": 3160,
        "thoughts_token_count": 7399
    }
}