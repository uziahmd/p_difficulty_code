{
    "start": 1758011277.215368,
    "end": 1758011296.4789762,
    "start-formatted": "2025-09-16 17:27 KST",
    "end-formatted": "2025-09-16 17:28 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    min_total_cost = float('inf')\n\n    # Group vouchers by duration\n    vouchers_by_duration = [[] for _ in range(x + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if 1 <= duration <= x:\n            vouchers_by_duration[duration].append((l, r, cost))\n\n    # Sort vouchers by their start day for efficient processing\n    for i in range(1, x + 1):\n        vouchers_by_duration[i].sort()\n\n    # Precompute minimum cost for a given duration ending at a certain day\n    # min_cost_ending_at[d][end_day] stores the minimum cost of a voucher\n    # with duration d that ends on or before end_day.\n    # This approach is too slow/memory intensive if `end_day` is large.\n    # Instead, we can use a segment tree or similar data structure, or\n    # iterate through days and update minimum costs.\n\n    # Let's try iterating through all possible first vouchers and finding the best second one.\n    # To optimize finding the second voucher, we need to quickly query for\n    # minimum cost vouchers that satisfy the duration and non-intersection conditions.\n\n    # We can use a sweep-line approach or process vouchers based on their start/end times.\n    # Let's store available vouchers for the second part in a way that allows efficient\n    # queries for minimum cost.\n\n    # max_coord is the maximum possible value for l or r.\n    max_coord = 2 * 10**5\n    \n    # min_cost_for_duration_ending_at[duration][end_day]\n    # Stores the minimum cost of a voucher with 'duration' that ends at 'end_day'.\n    # Initialize with infinity.\n    # This array will be updated as we sweep through days.\n    \n    # A better approach: iterate through all possible 'l' values (start days).\n    # When considering vouchers starting at day `l_curr`, we need to know\n    # the minimum cost of vouchers that end before `l_curr` and have a specific duration.\n\n    # Let's rephrase: we need to find (l1, r1, cost1) and (l2, r2, cost2) such that\n    # r1 < l2 OR r2 < l1.\n    # (r1 - l1 + 1) + (r2 - l2 + 1) = x\n    # We want to minimize cost1 + cost2.\n\n    # Let's group vouchers by their start day.\n    vouchers_starting_at = [[] for _ in range(max_coord + 2)]\n    for l, r, cost in vouchers:\n        vouchers_starting_at[l].append((r, cost))\n\n    # This array will store the minimum cost for a voucher that ends at 'day'\n    # and has a specific duration.\n    # min_cost_for_duration[duration][day] = min cost of a voucher with 'duration'\n    # that ends at 'day'.\n    # This is still too much memory/time.\n\n    # Instead, let's use a sweep-line approach.\n    # We will iterate through all possible end days `r_curr` for the first voucher.\n    # When processing `r_curr`:\n    # 1. Update information about vouchers that end at `r_curr`.\n    # 2. Query for the best second voucher that can start after `r_curr`.\n\n    # `min_cost_for_duration_ending_before_or_at[duration]` will store the minimum cost\n    # for a voucher of that duration that has been processed so far (i.e., its end day <= current day).\n    # This array needs to be updated efficiently.\n    \n    # Let's consider all vouchers sorted by their start day.\n    # Or, let's process day by day.\n    \n    # min_cost_for_duration[duration] stores the minimum cost of a voucher\n    # with that duration encountered so far.\n    \n    # `min_cost_ending_at_day[day]` stores the minimum cost of a voucher\n    # that ends at `day`.\n    \n    # This is a common pattern for \"find two non-overlapping intervals\".\n    # Iterate through all possible `r1` values.\n    # For each `r1`, we want to find a `(l1, r1, cost1)` and a `(l2, r2, cost2)`\n    # such that `l2 > r1`.\n    # The duration of the first voucher is `d1 = r1 - l1 + 1`.\n    # The duration of the second voucher is `d2 = r2 - l2 + 1`.\n    # We need `d1 + d2 = x`. So `d2 = x - d1`.\n\n    # `min_cost_for_duration_starting_at_or_after[day][duration]`\n    # This stores the minimum cost of a voucher with `duration` that starts at or after `day`.\n    # This can be precomputed by iterating `day` from `max_coord` down to `1`.\n\n    # `min_cost_for_duration_ending_at_or_before[day][duration]`\n    # This stores the minimum cost of a voucher with `duration` that ends at or before `day`.\n    # This can be precomputed by iterating `day` from `1` up to `max_coord`.\n\n    # These arrays would be too large (max_coord * x).\n    # Instead, we need a data structure that can query min cost for a given duration.\n\n    # Let's store vouchers grouped by their start day `l`.\n    # `vouchers_by_start_day[l]` = list of `(r, cost)` for vouchers starting at `l`.\n    # And by end day `r`.\n    # `vouchers_by_end_day[r]` = list of `(l, cost)` for vouchers ending at `r`.\n    \n    vouchers_by_start_day = [[] for _ in range(max_coord + 2)]\n    vouchers_by_end_day = [[] for _ in range(max_coord + 2)]\n    for l, r, cost in vouchers:\n        vouchers_by_start_day[l].append((r, cost))\n        vouchers_by_end_day[r].append((l, cost))\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher\n    # that has `duration`. This is not enough, we need to consider start/end times.\n\n    # `min_cost_for_duration_ending_at_or_before_current_day[duration]`\n    # This is what we need to maintain.\n    # We can use a segment tree or a dictionary for this, mapping duration to min cost.\n    # A simple array `current_min_cost_for_duration[duration]` initialized to infinity.\n    # This array will store the minimum cost of a voucher with `duration` that *has ended*\n    # by the current day `r1`.\n\n    current_min_cost_for_duration = [float('inf')] * (x + 1)\n    \n    for r1 in range(1, max_coord + 1):\n        # Process vouchers that *end* at `r1`.\n        # Update `current_min_cost_for_duration` for these vouchers.\n        for l1_prime, cost1_prime in vouchers_by_end_day[r1]:\n            duration1_prime = r1 - l1_prime + 1\n            if 1 <= duration1_prime < x: # Ensure d1 < x so d2 > 0\n                current_min_cost_for_duration[duration1_prime] = \\\n                    min(current_min_cost_for_duration[duration1_prime], cost1_prime)\n        \n        # Now, consider vouchers that *start* at `r1 + 1`.\n        # These are potential second vouchers `(l2, r2, cost2)` where `l2 = r1 + 1`.\n        # For each such voucher, we need to find the best first voucher.\n        for r2, cost2 in vouchers_by_start_day[r1 + 1]:\n            duration2 = r2 - (r1 + 1) + 1\n            # We need duration1 + duration2 = x.\n            # So, duration1 = x - duration2.\n            \n            if 1 <= duration2 < x: # Ensure d2 < x so d1 > 0\n                required_duration1 = x - duration2\n                \n                if required_duration1 >= 1 and required_duration1 <= x:\n                    cost1 = current_min_cost_for_duration[required_duration1]\n                    if cost1 != float('inf'):\n                        min_total_cost = min(min_total_cost, cost1 + cost2)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    min_total_cost = float('inf')\n\n    # Group vouchers by duration\n    vouchers_by_duration = [[] for _ in range(x + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if 1 <= duration <= x:\n            vouchers_by_duration[duration].append((l, r, cost))\n\n    # Sort vouchers by their start day for efficient processing\n    for i in range(1, x + 1):\n        vouchers_by_duration[i].sort()\n\n    # Precompute minimum cost for a given duration ending at a certain day\n    # min_cost_ending_at[d][end_day] stores the minimum cost of a voucher\n    # with duration d that ends on or before end_day.\n    # This approach is too slow/memory intensive if `end_day` is large.\n    # Instead, we can use a segment tree or similar data structure, or\n    # iterate through days and update minimum costs.\n\n    # Let's try iterating through all possible first vouchers and finding the best second one.\n    # To optimize finding the second voucher, we need to quickly query for\n    # minimum cost vouchers that satisfy the duration and non-intersection conditions.\n\n    # We can use a sweep-line approach or process vouchers based on their start/end times.\n    # Let's store available vouchers for the second part in a way that allows efficient\n    # queries for minimum cost.\n\n    # max_coord is the maximum possible value for l or r.\n    max_coord = 2 * 10**5\n    \n    # min_cost_for_duration_ending_at[duration][end_day]\n    # Stores the minimum cost of a voucher with 'duration' that ends at 'end_day'.\n    # Initialize with infinity.\n    # This array will be updated as we sweep through days.\n    \n    # A better approach: iterate through all possible 'l' values (start days).\n    # When considering vouchers starting at day `l_curr`, we need to know\n    # the minimum cost of vouchers that end before `l_curr` and have a specific duration.\n\n    # Let's rephrase: we need to find (l1, r1, cost1) and (l2, r2, cost2) such that\n    # r1 < l2 OR r2 < l1.\n    # (r1 - l1 + 1) + (r2 - l2 + 1) = x\n    # We want to minimize cost1 + cost2.\n\n    # Let's group vouchers by their start day.\n    vouchers_starting_at = [[] for _ in range(max_coord + 2)]\n    for l, r, cost in vouchers:\n        vouchers_starting_at[l].append((r, cost))\n\n    # This array will store the minimum cost for a voucher that ends at 'day'\n    # and has a specific duration.\n    # min_cost_for_duration[duration][day] = min cost of a voucher with 'duration'\n    # that ends at 'day'.\n    # This is still too much memory/time.\n\n    # Instead, let's use a sweep-line approach.\n    # We will iterate through all possible end days `r_curr` for the first voucher.\n    # When processing `r_curr`:\n    # 1. Update information about vouchers that end at `r_curr`.\n    # 2. Query for the best second voucher that can start after `r_curr`.\n\n    # `min_cost_for_duration_ending_before_or_at[duration]` will store the minimum cost\n    # for a voucher of that duration that has been processed so far (i.e., its end day <= current day).\n    # This array needs to be updated efficiently.\n    \n    # Let's consider all vouchers sorted by their start day.\n    # Or, let's process day by day.\n    \n    # min_cost_for_duration[duration] stores the minimum cost of a voucher\n    # with that duration encountered so far.\n    \n    # `min_cost_ending_at_day[day]` stores the minimum cost of a voucher\n    # that ends at `day`.\n    \n    # This is a common pattern for \"find two non-overlapping intervals\".\n    # Iterate through all possible `r1` values.\n    # For each `r1`, we want to find a `(l1, r1, cost1)` and a `(l2, r2, cost2)`\n    # such that `l2 > r1`.\n    # The duration of the first voucher is `d1 = r1 - l1 + 1`.\n    # The duration of the second voucher is `d2 = r2 - l2 + 1`.\n    # We need `d1 + d2 = x`. So `d2 = x - d1`.\n\n    # `min_cost_for_duration_starting_at_or_after[day][duration]`\n    # This stores the minimum cost of a voucher with `duration` that starts at or after `day`.\n    # This can be precomputed by iterating `day` from `max_coord` down to `1`.\n\n    # `min_cost_for_duration_ending_at_or_before[day][duration]`\n    # This stores the minimum cost of a voucher with `duration` that ends at or before `day`.\n    # This can be precomputed by iterating `day` from `1` up to `max_coord`.\n\n    # These arrays would be too large (max_coord * x).\n    # Instead, we need a data structure that can query min cost for a given duration.\n\n    # Let's store vouchers grouped by their start day `l`.\n    # `vouchers_by_start_day[l]` = list of `(r, cost)` for vouchers starting at `l`.\n    # And by end day `r`.\n    # `vouchers_by_end_day[r]` = list of `(l, cost)` for vouchers ending at `r`.\n    \n    vouchers_by_start_day = [[] for _ in range(max_coord + 2)]\n    vouchers_by_end_day = [[] for _ in range(max_coord + 2)]\n    for l, r, cost in vouchers:\n        vouchers_by_start_day[l].append((r, cost))\n        vouchers_by_end_day[r].append((l, cost))\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher\n    # that has `duration`. This is not enough, we need to consider start/end times.\n\n    # `min_cost_for_duration_ending_at_or_before_current_day[duration]`\n    # This is what we need to maintain.\n    # We can use a segment tree or a dictionary for this, mapping duration to min cost.\n    # A simple array `current_min_cost_for_duration[duration]` initialized to infinity.\n    # This array will store the minimum cost of a voucher with `duration` that *has ended*\n    # by the current day `r1`.\n\n    current_min_cost_for_duration = [float('inf')] * (x + 1)\n    \n    for r1 in range(1, max_coord + 1):\n        # Process vouchers that *end* at `r1`.\n        # Update `current_min_cost_for_duration` for these vouchers.\n        for l1_prime, cost1_prime in vouchers_by_end_day[r1]:\n            duration1_prime = r1 - l1_prime + 1\n            if 1 <= duration1_prime < x: # Ensure d1 < x so d2 > 0\n                current_min_cost_for_duration[duration1_prime] = \\\n                    min(current_min_cost_for_duration[duration1_prime], cost1_prime)\n        \n        # Now, consider vouchers that *start* at `r1 + 1`.\n        # These are potential second vouchers `(l2, r2, cost2)` where `l2 = r1 + 1`.\n        # For each such voucher, we need to find the best first voucher.\n        for r2, cost2 in vouchers_by_start_day[r1 + 1]:\n            duration2 = r2 - (r1 + 1) + 1\n            # We need duration1 + duration2 = x.\n            # So, duration1 = x - duration2.\n            \n            if 1 <= duration2 < x: # Ensure d2 < x so d1 > 0\n                required_duration1 = x - duration2\n                \n                if required_duration1 >= 1 and required_duration1 <= x:\n                    cost1 = current_min_cost_for_duration[required_duration1]\n                    if cost1 != float('inf'):\n                        min_total_cost = min(min_total_cost, cost1 + cost2)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 2197,
        "thoughts_token_count": 0
    }
}