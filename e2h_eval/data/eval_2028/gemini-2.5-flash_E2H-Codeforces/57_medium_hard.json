{
    "start": 1758294765.752119,
    "end": 1758294903.9334748,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Olympiad Rank Dilemma: A Summary**\n\nAs an expert in the field, I'm faced with a classic optimization challenge. The problem boils down to determining the best and worst possible ranks Vasya could achieve in an Olympiad, given his minimum score and the scores of all participants. We have a set of scores from two rounds, but the crucial missing piece is the pairings between the scores – which round 1 score belongs to which round 2 score. My task is to unravel how to strategically pair the scores to pinpoint the optimal and most disadvantageous scenarios for Vasya.\n\n**Finding the Best Rank:**\nThe best rank scenario hinges on maximizing Vasya's score relative to the competition. We know his minimum total score. This means we must consider a lot of pairings. Since the problem implicitly states that Vasya could be *any* of the participants, we iterate through all scores and find the *best possible score for Vasya*. Once we identify this best score, we can rank him based on that and if he can be at rank 1. In this scenario, we sort scores and try to get the highest possible sum, under the constraint of the sum being at least Vasya's minimum. The trick here is that there are *multiple* possible pairings.\n\n**Worst Rank:**\nThe worst rank involves a delicate balancing act. Vasya wants to minimize his total score *while still meeting the minimum requirement* and somehow maximizing the number of competitors with scores greater than or equal to his. We must then pair the remaining score to find the *worst rank*, where we maximize the number of competitors that can be greater than or equal to his score.\n\n**Strategies and Insight**\nThis isn't a direct bipartite matching issue since we don't know the pairings directly. The core is analyzing the relationship between the possible pairs. The key is to sort the scores, and then use the jury's rules for equal scores. By considering all possible `a_i` and `b_j` and the pairing, we determine the *minimum possible sum for Vasya and the pairings.* Finally, we want to maximize the scores of all the other participants. To accomplish this, we utilize a two-pointer approach, to pair the scores to ensure the worst rank.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given `n` participants, a minimum total score `x` Vasya earned, and two lists of `n` scores for the first and second tours (`a` and `b`). The key challenge is that we don't know which `a_i` belongs to which `b_j`. We only know that Vasya's scores `a_vasya` and `b_vasya` sum up to at least `x`. Ranks are 1-indexed, and ties are broken by the jury.\n\nLet `A` be the list of scores from the first tour and `B` be the list of scores from the second tour.\nWe need to find a perfect matching between `A` and `B` (i.e., a permutation `p` such that participant `k` gets `a_k + b_{p_k}` points) such that one participant (Vasya) has `a_k + b_{p_k} >= x`. We then need to find the optimal matching that yields the best rank for Vasya, and another optimal matching that yields the worst rank.\n\n**1. Best Rank for Vasya:**\n\nTo achieve the best possible rank, Vasya wants to maximize his score relative to others. The jury's rule for ties means that if Vasya has a score `S_V`, his best rank is `1 + (number of participants with score strictly greater than S_V)`. If multiple participants have the highest score, Vasya can be ranked 1st among them.\n\nConsider sorting `A` and `B` in ascending order: `A_{sorted} = [a_1, ..., a_n]` and `B_{sorted} = [b_1, ..., b_n]`.\nThe maximum possible total score any participant can achieve is `a_n + b_n`. The problem guarantees that Vasya was present and achieved at least `x` points, which implies that it's possible for some `a_i` and `b_j` to sum to at least `x`. In fact, it must be possible for the maximum sum `a_n + b_n` to be at least `x`, because if `a_n + b_n < x`, then no other sum `a_i + b_j` (since `a_i <= a_n` and `b_j <= b_n`) could be `>= x`, contradicting the guarantee.\n\nIf Vasya takes `a_n` and `b_n`, his score is `S_V = a_n + b_n`. Since `a_n + b_n >= x`, this is a valid score for Vasya.\nTo minimize the scores of other participants, we can pair the remaining `n-1` scores: `(a_1, b_1), (a_2, b_2), ..., (a_{n-1}, b_{n-1})`.\nThe scores for these `n-1` participants would be `a_1+b_1, ..., a_{n-1}+b_{n-1}`.\nSince `a_n >= a_k` and `b_n >= b_k` for all `k < n`, it follows that `a_n + b_n >= a_k + b_k` for all `k < n`.\nTherefore, Vasya's score `a_n + b_n` is greater than or equal to all other participants' scores in this specific pairing.\nWith this score, and the jury's choice in case of ties, Vasya can always be placed first.\nThus, **the best rank Vasya can achieve is 1.**\n\n**2. Worst Rank for Vasya:**\n\nTo achieve the worst possible rank, Vasya wants to minimize his score (but still `S_V >= x`), and maximize the scores of other participants (especially those whose scores are greater than or equal to `S_V`).\nThe jury's rule for ties means that if Vasya gets score `S_V`, his worst rank is `1 + (number of participants with score strictly greater than S_V) + (number of participants with score equal to S_V, excluding Vasya himself)`. This simplifies to `1 + (number of participants with score >= S_V, excluding Vasya himself)`.\n\nLet `A_sorted` be `a` sorted in ascending order and `B_sorted` be `b` sorted in ascending order.\nWe want to find a pairing `P` and a specific pair `(a_i, b_j)` for Vasya such that `a_i + b_j >= x`, and the number of other participants `k` (with scores `S_k`) such that `S_k >= a_i + b_j` is maximized.\n\nThis can be solved by iterating through all possible values for Vasya's first tour score. Let's say Vasya gets `A_sorted[i]` for some `i` from `0` to `n-1`.\nFor this `A_sorted[i]`, Vasya needs to be paired with some `B_sorted[j]` such that `A_sorted[i] + B_sorted[j] >= x`. To maximize the number of other participants who score high, Vasya should try to use a `B_sorted[j]` that is as small as possible, while still satisfying `A_sorted[i] + B_sorted[j] >= x`. This frees up larger `B` scores for other participants.\n\nLet's use a two-pointer approach for this.\nSort `A` in ascending order: `A = sorted(a)`.\nSort `B` in ascending order: `B = sorted(b)`.\n\nInitialize `worst_rank = 1`.\nWe iterate through each `a_i` in `A` as a potential score for Vasya.\nFor each `a_i`:\n  We need to find the smallest `b_j` such that `a_i + b_j >= x`. This `b_j` can be found using binary search (`bisect_left`) on `B`. Let `target_b = x - a_i`. We find the index `idx_b` of the first element in `B` that is `>= target_b`.\n  If no such `b_j` exists (i.e., `idx_b == n`), then `a_i` cannot be Vasya's score (with any `b_j` from `B`) while satisfying the `x` condition. So we skip this `a_i`.\n\n  Otherwise, `A[i]` and `B[idx_b]` form a candidate pair for Vasya. Vasya's score would be `S_V = A[i] + B[idx_b]`.\n  Now, we need to determine the maximum number of other participants whose scores can be `>= S_V`, given that `A[i]` and `B[idx_b]` are already used.\n  This is a subproblem: given `A' = A \\ {A[i]}` and `B' = B \\ {B[idx_b]}`, find the maximum number of pairs `(a'_k, b'_l)` such that `a'_k + b'_l >= S_V`.\n  This subproblem can be solved efficiently. Create `A_prime` by removing `A[i]` and `B_prime` by removing `B[idx_b]`. Then, use a two-pointer approach on `A_prime` and `B_prime` (both sorted).\n  Let `A_prime_ptr = 0` and `B_prime_ptr = n-2` (since `A_prime` and `B_prime` have `n-1` elements).\n  `count_others_ge_Sv = 0`.\n  While `A_prime_ptr < n-1` and `B_prime_ptr >= 0`:\n    If `A_prime[A_prime_ptr] + B_prime[B_prime_ptr] >= S_V`:\n      `count_others_ge_Sv += 1`\n      `A_prime_ptr += 1`\n      `B_prime_ptr -= 1`\n    Else (`A_prime[A_prime_ptr] + B_prime[B_prime_ptr] < S_V`):\n      `A_prime_ptr += 1` (This `A_prime_ptr` is too small to combine with `B_prime_ptr` to reach `S_V`, so it won't reach `S_V` with any smaller `B_prime` value. We must use `B_prime_ptr` with a larger `A_prime` value, or discard this `A_prime_ptr` for meeting the threshold. To maximize count, we move to the next `A_prime` value.)\n  Vasya's rank in this scenario would be `1 + count_others_ge_Sv`. We update `worst_rank = max(worst_rank, 1 + count_others_ge_Sv)`.\n\nThe issue with the above approach is that removing `A[i]` and `B[idx_b]` and then forming `A_prime` and `B_prime` takes `O(N)` time for each `a_i`, leading to `O(N^2)` overall, which is too slow for `N=10^5`.\n\nA more efficient approach for finding `count_others_ge_Sv`:\nInstead of physically removing elements and creating new lists, we can use the original sorted lists `A` and `B` and adjust the two-pointer logic.\nWhen `A[i]` is Vasya's first tour score and `B[idx_b]` is Vasya's second tour score:\nWe want to count pairs `(A[k], B[l])` such that `A[k] + B[l] >= S_V`, where `k != i` and `l != idx_b`.\nThis is a maximum bipartite matching problem. However, we can use a simpler greedy approach.\nThe number of pairs `(a_k, b_l)` such that `a_k+b_l >= T` can be found in `O(N)` time using two pointers on sorted `A` and `B`.\nLet `count_ge(T)` be this function.\nThe problem is that `A[i]` and `B[idx_b]` are removed.\n\nLet's fix `A_sorted` and `B_sorted`.\nWe iterate `i` from `0` to `n-1` (Vasya's `a` score).\nFor a fixed `A_sorted[i]`:\n  We need to find the smallest `B_sorted[j]` such that `A_sorted[i] + B_sorted[j] >= x`. Let this be `B_sorted[j_0]`.\n  Vasya's potential score `S_V = A_sorted[i] + B_sorted[j_0]`.\n  Now, we need to count how many pairs `(A_sorted[k], B_sorted[l])` (where `k != i`, `l != j_0`) can sum to `>= S_V`.\n  This is a maximum matching on a modified bipartite graph.\n\nThis can be done with a two-pointer approach over `A` and `B`.\nSort `A` ascending, `B` ascending.\n`worst_rank = 1`\n`j_ptr = n - 1` (pointer for `B`)\nFor `i` from `0` to `n-1` (pointer for `A`):\n  While `j_ptr >= 0` and `A[i] + B[j_ptr] >= x`:\n    `j_ptr -= 1`\n  // At this point, `j_ptr + 1` is the index of the first `b` such that `A[i] + B[j_ptr+1] >= x`.\n  // If `j_ptr + 1 == n`, it means `A[i]` cannot be paired with any `B[k]` to meet `x`.\n  // If `j_ptr + 1 < n`, then `B[j_ptr+1]` is the smallest `b` that allows `A[i]` to meet `x`.\n  // The crucial observation is that we are looking for the minimum `j` such that `A[i] + B[j] >= x`.\n  // Let this `j` be `idx_b`.\n  // The number of people who can score at least `S_V = A[i] + B[idx_b]` is maximized by pairing `A[k]` with `B[l]` such that `k` and `l` are large.\n  // The number of participants whose scores can be `>= S_V` is `count_ge(S_V)` (using the two-pointer method on the full A and B lists).\n  // The actual number of people other than Vasya is `count_ge(S_V) - 1`.\n  // This is correct if Vasya's pair `(A[i], B[idx_b])` is one of the pairs counted by `count_ge(S_V)`.\n\nLet's define `count_ge(T)`:\n`count = 0`\n`ptr_b = n-1`\nFor `ptr_a` from `0` to `n-1`:\n  While `ptr_b >= 0` and `A[ptr_a] + B[ptr_b] >= T`:\n    `ptr_b -= 1`\n  `count += (n - 1 - ptr_b)`  // This is incorrect. This counts how many `b`s can be paired with `A[ptr_a]` to meet `T`.\n  The correct `count_ge(T)` function (max number of pairs `(a_i, b_j)` summing to at least `T`):\n  `count = 0`\n  `ptr_b = n-1`\n  For `ptr_a` from `0` to `n-1`:\n    While `ptr_b >= 0` and `A[ptr_a] + B[ptr_b] < T`:\n      `ptr_b -= 1`\n    If `ptr_b >= 0`: // If we found a `B[ptr_b]` that makes `A[ptr_a] + B[ptr_b] >= T`\n      `count += 1`\n      `ptr_b -= 1` // This B[ptr_b] is now used\n  Return `count`.\n\nNow, the overall algorithm for worst rank:\n1. Sort `A` ascending and `B` ascending.\n2. `worst_rank = 1`\n3. We need to iterate through all possible `a_i` that Vasya could have. For each `a_i`, Vasya needs to be paired with some `b_j` such that `a_i + b_j >= x`.\n   To maximize the number of people with scores `>= Vasya's score`, Vasya should take the *smallest* `b_j` that satisfies `a_i + b_j >= x`.\n   Let `Vasya_score = a_i + b_j`.\n   Then we calculate `count_ge(Vasya_score)` using the `O(N)` two-pointer method described above.\n   Vasya's rank would be `count_ge(Vasya_score)`. (Since `count_ge` counts Vasya's pair if it satisfies the condition, and he's placed last among ties).\n   We take the maximum of these `count_ge(Vasya_score)` values.\n\nThis means we need to find `min_j` for each `a_i`.\n`A_sorted = sorted(a)`\n`B_sorted = sorted(b)`\n`worst_rank = 1`\n`j_ptr = n - 1` // This pointer will find `min_j` for `a_i`\nFor `i` from `0` to `n-1`:\n  // Find smallest `B_sorted[j]` such that `A_sorted[i] + B_sorted[j] >= x`.\n  // We can use `bisect_left` for this.\n  `target_b = x - A_sorted[i]`\n  `idx_b = bisect_left(B_sorted, target_b)`\n  If `idx_b < n`: // A valid `B_sorted[idx_b]` exists for `A_sorted[i]`\n    `vasya_score = A_sorted[i] + B_sorted[idx_b]`\n    // Now calculate `count_ge(vasya_score)`\n    `current_rank_candidate = 0`\n    `temp_ptr_b = n - 1`\n    For `temp_ptr_a` from `0` to `n-1`:\n      While `temp_ptr_b >= 0` and `A_sorted[temp_ptr_a] + B_sorted[temp_ptr_b] < vasya_score`:\n        `temp_ptr_b -= 1`\n      If `temp_ptr_b >= 0`:\n        `current_rank_candidate += 1`\n        `temp_ptr_b -= 1`\n    `worst_rank = max(worst_rank, current_rank_candidate)`\n\nThe issue is that `A[i]` and `B[idx_b]` are used by Vasya. The `count_ge` function above counts pairs from the full lists `A` and `B`. It doesn't account for `A[i]` and `B[idx_b]` being removed.\nThe `count_ge` function actually calculates the maximum number of pairs that can be formed from `A` and `B` (without replacement) that sum to at least `T`. If Vasya takes `A[i]` and `B[idx_b]`, and `A[i] + B[idx_b] >= T`, then Vasya's pair is one of these counted pairs. So the rank is indeed `count_ge(T)`.\n\nThe `count_ge` function is `O(N)`. We call it `N` times (for each `A[i]`). Total `O(N^2)`, still too slow.\n\nThis is a monotonic problem. As `vasya_score` increases, `count_ge(vasya_score)` decreases or stays the same.\nWe are iterating `A_sorted[i]`. As `i` increases, `A_sorted[i]` increases. `target_b = x - A_sorted[i]` decreases. `idx_b` (from `bisect_left`) decreases or stays the same. `vasya_score = A_sorted[i] + B_sorted[idx_b]` can fluctuate.\n\nLet's re-think the worst rank.\nWe need to find a pairing `(a_k, b_l)` for Vasya such that `a_k + b_l >= x`. Let `S_V = a_k + b_l`.\nThen we need to form the remaining `n-1` pairs `(a_p, b_q)` from `A \\ {a_k}` and `B \\ {b_l}` such that the number of pairs `(a_p, b_q)` with `a_p + b_q >= S_V` is maximized.\nThis is equivalent to maximizing the total number of pairs (including Vasya's) that sum to at least `S_V`.\n\nConsider pairing `A` with `B` in a specific way: `A_sorted[i]` with `B_sorted[n-1-i]`.\nThis is a standard pairing that tends to make sums more uniform.\n`sums = [A_sorted[i] + B_sorted[n-1-i] for i in range(n)]`\nVasya must be one of these participants. He must pick a pair `(A_sorted[k], B_sorted[n-1-k])` such that `A_sorted[k] + B_sorted[n-1-k] >= x`.\nTo get the worst rank, he should pick the `k` such that `A_sorted[k] + B_sorted[n-1-k]` is minimized (but still `>= x`), and then count how many other sums are `>=` this minimal sum.\nThis strategy is not necessarily optimal because it fixes the pairing for everyone. The jury can choose *any* pairing.\n\nThe problem asks for the maximum possible value of `1 + (number of participants with score >= S_V, excluding Vasya himself)`.\nThis is equivalent to finding a `S_V >= x` and a pairing `P` such that Vasya gets `S_V`, and `count_ge(S_V)` is maximized.\nThe function `count_ge(T)` (max number of pairs summing to at least `T`) is correct.\nWe need to find `max_{T >= x} count_ge(T)`.\nThe possible values for `T` are `a_i + b_j`. There are `N^2` such values.\nHowever, `count_ge(T)` is monotonic. We can binary search for the *threshold* `T`.\nWe want to find the largest `T` such that `count_ge(T)` is maximized.\nThe values of `count_ge(T)` range from `1` to `N`.\nWe can binary search for the rank `R` (from `1` to `N`).\nFor a given rank `R`, can Vasya achieve this rank?\nThis means, can we find a `S_V >= x` such that `count_ge(S_V) >= R`?\nIf `count_ge(T) >= R`, then `T` is a possible score threshold. We want the largest such `T` to maximize `R`.\n\nLet's try to binary search on the `worst_rank` itself.\nSuppose we want to check if Vasya can get a rank of at least `k`.\nThis means we need to find a `S_V >= x` such that `count_ge(S_V) >= k`.\nTo maximize `k`, we want to find the smallest `S_V` (that Vasya can achieve, `S_V >= x`) such that `count_ge(S_V)` is maximized.\nThe possible `S_V` values are `A[i] + B[j]`.\nThe maximum possible `worst_rank` is `N`. The minimum is `1`.\nBinary search for the worst rank `k` between `1` and `N`.\n`check(k)` function: Can we find a pairing where Vasya gets `S_V >= x` and `k` people (including Vasya) get `S_V` or more?\nThis means `count_ge(S_V) >= k`.\nTo maximize `k`, we need to find the `S_V` that yields the highest `count_ge(S_V)`.\nThe actual `S_V` Vasya gets *must* be `>= x`.\n\nLet's sort `A` ascending and `B` ascending.\n`worst_rank = 0`\n`j_ptr = n - 1`\nFor `i` from `0` to `n-1`: // `A[i]` is Vasya's first tour score\n  `target_b = x - A[i]`\n  `idx_b = bisect_left(B, target_b)`\n  If `idx_b < n`: // A valid `B[idx_b]` exists\n    `vasya_score = A[i] + B[idx_b]`\n    // Now we need to determine how many people (including Vasya) can score at least `vasya_score`.\n    // This is `count_ge(vasya_score)`.\n    `current_count = 0`\n    `p_b = n - 1`\n    For `p_a` from `0` to `n-1`:\n      While `p_b >= 0` and `A[p_a] + B[p_b] < vasya_score`:\n        `p_b -= 1`\n      If `p_b >= 0`:\n        `current_count += 1`\n        `p_b -= 1`\n    `worst_rank = max(worst_rank, current_count)`\n\nThis is `O(N^2)` because `count_ge` is called `N` times.\nThe `count_ge` function itself has nested loops. The inner `while` loop for `p_b` starts from `n-1` each time. This is `O(N^2)`.\nHowever, the `p_b` pointer in `count_ge` can be optimized.\nWhen `A[i]` increases, `vasya_score` changes.\nThe `count_ge` function:\n`count_ge(T)`:\n  `count = 0`\n  `b_idx = n - 1`\n  For `a_idx` from `0` to `n-1`:\n    While `b_idx >= 0` and `A[a_idx] + B[b_idx] < T`:\n      `b_idx -= 1`\n    If `b_idx >= 0`:\n      `count += 1`\n      `b_idx -= 1`\n  Return `count`.\nThis `count_ge` function is `O(N)`.\n\nThe total complexity is `N * O(N) = O(N^2)`. `N = 10^5` means `10^{10}` operations, too slow.\nWe need to optimize the outer loop.\n\nNotice that `A[i]` is increasing. `target_b = x - A[i]` is decreasing. `idx_b = bisect_left(B, target_b)` is decreasing.\n`vasya_score = A[i] + B[idx_b]` is not necessarily monotonic.\nWe have `N` possible `vasya_score` values.\n\nThis is a problem that can be solved with a two-pointer approach on the outer loop as well.\nLet `A` be sorted ascending. `B` be sorted ascending.\nIterate `i` from `0` to `n-1` (Vasya's `a_i`).\nWe need to find `idx_b` for `A[i]`. `idx_b` is the smallest index such that `A[i] + B[idx_b] >= x`.\nThis means `B[idx_b] >= x - A[i]`.\nThe `idx_b` can be found efficiently. As `i` increases, `x - A[i]` decreases, so `idx_b` (the smallest index satisfying the condition) will decrease or stay the same.\nSo, we can maintain `idx_b` with a pointer that only moves left.\n`idx_b_ptr = n - 1`\nFor `i` from `0` to `n-1`:\n  While `idx_b_ptr >= 0` and `A[i] + B[idx_b_ptr] >= x`:\n    `idx_b_ptr -= 1`\n  // After the loop, `idx_b_ptr + 1` is the smallest index `j` such that `A[i] + B[j] >= x`.\n  // If `idx_b_ptr + 1 == n`, no such `j` exists for `A[i]`.\n  // Let `actual_idx_b = idx_b_ptr + 1`.\n  // If `actual_idx_b < n`:\n  //   `vasya_score = A[i] + B[actual_idx_b]`\n  //   `worst_rank = max(worst_rank, count_ge(vasya_score))`\n\nThis is still `O(N^2)` because `count_ge` is `O(N)`.\n\nThe crucial part is that `count_ge(T)` can be computed by a two-pointer approach.\nLet `A_sorted` and `B_sorted` be sorted ascending.\n`p_a = 0`, `p_b = n-1`.\n`current_count = 0`.\n`scores_ge_x = []`\nWhile `p_a < n` and `p_b >= 0`:\n  If `A_sorted[p_a] + B_sorted[p_b] >= x`:\n    // This pair `(A_sorted[p_a], B_sorted[p_b])` is a candidate for Vasya's score.\n    // Its value is `A_sorted[p_a] + B_sorted[p_b]`.\n    // We need to calculate `count_ge(A_sorted[p_a] + B_sorted[p_b])`.\n    // This implies that for this specific `vasya_score`, we need to find how many pairs can be formed.\n    // The `count_ge` function is actually the rank itself.\n    `worst_rank = max(worst_rank, count_ge(A_sorted[p_a] + B_sorted[p_b]))`\n    `p_a += 1`\n    // Do not decrement `p_b` here if we are just iterating through potential Vasya scores.\n    // This is not correct. We need to iterate all possible `A[i]` and `B[j]` that could be Vasya's scores.\n\nThe problem can be restated as:\nFind `max_{i,j such that a_i+b_j >= x} (count of pairs (a_k, b_l) such that a_k+b_l >= a_i+b_j)`\nLet `S_V = a_i+b_j`. We want to maximize `count_ge(S_V)`.\nSince `count_ge(T)` is non-increasing with `T`, we want to find the smallest `T` (such that `T >= x` and `T = a_i+b_j` for some `i,j`) that maximizes `count_ge(T)`.\nThe set of all possible sums `a_i+b_j` is too large.\nHowever, the values `T` for which `count_ge(T)` changes are only the sums `a_k+b_l`.\nWe are looking for `max_{T' in {a_k+b_l | a_k+b_l >= x}} count_ge(T')`.\nThis is equivalent to: `max_{k,l | A_sorted[k]+B_sorted[l] >= x} count_ge(A_sorted[k]+B_sorted[l])`.\n\nLet's use the two-pointer approach for `count_ge` and optimize.\nSort `A` ascending, `B` ascending.\n`worst_rank = 0`\n`ptr_b_for_count = n - 1` // For `count_ge` function.\n`ptr_b_for_vasya = n - 1` // For finding `B[idx_b]` for Vasya's score.\n\nFor `i` from `0` to `n-1`: // `A[i]` is Vasya's first tour score\n  `target_b_vasya = x - A[i]`\n  // `idx_b_vasya = bisect_left(B, target_b_vasya)`\n  // This `idx_b_vasya` can be found by moving `ptr_b_for_vasya` leftwards.\n  While `ptr_b_for_vasya >= 0` and `B[ptr_b_for_vasya] >= target_b_vasya`:\n    `ptr_b_for_vasya -= 1`\n  `actual_idx_b_vasya = ptr_b_for_vasya + 1`\n\n  If `actual_idx_b_vasya < n`: // A valid `B[actual_idx_b_vasya]` exists\n    `vasya_score = A[i] + B[actual_idx_b_vasya]`\n    // Now, we need `count_ge(vasya_score)`.\n    // This `count_ge` part is the bottleneck. It must be `O(1)` amortized.\n    // The `count_ge` function's `p_b` pointer can be maintained across calls.\n    // As `i` increases, `A[i]` increases, `target_b_vasya` decreases, `actual_idx_b_vasya` decreases or stays same.\n    // `vasya_score` can be non-monotonic. So `ptr_b_for_count` cannot be simply monotonic.\n\nThis is a classic problem that can be solved using two pointers on the sorted arrays.\nThe `worst_rank` is the maximum value of `k` such that there exists a pairing where `k` participants (including Vasya) score `S_V` or more, and Vasya's `S_V >= x`.\nLet's sort `A` and `B` ascending.\n`worst_rank = 0`\n`j = n-1` (pointer for `B`)\nFor `i` from `0` to `n-1`: (pointer for `A`)\n  // For each `A[i]`, we need to find the smallest `B[j]` that makes `A[i] + B[j] >= x`.\n  // This `j` must be `B[k]` for some `k`.\n  // We can use a sliding window / two pointers approach.\n  // The `j` pointer for `B` should be `n-1` initially.\n  // We want to count how many pairs `(A[p], B[q])` satisfy `A[p] + B[q] >= T`.\n  // Let `T` be a candidate `vasya_score`.\n  // The `count_ge(T)` function is `O(N)`.\n\nThe solution for the worst rank `k` is to find the maximum `k` such that it's possible to form `k` pairs `(a_i, b_j)` with `a_i+b_j >= T`, for some `T` that Vasya can achieve (`T >= x`).\nThis is equivalent to finding the maximum `k` such that there exists a `T` (`T >= x`) for which `count_ge(T) >= k`.\nSince `count_ge(T)` is non-increasing, we are looking for the minimum `T` (that Vasya can achieve, `T >= x`) that maximizes `count_ge(T)`.\n\nThe values `A[i] + B[j]` for `i` in `[0, n-1]` and `j` in `[0, n-1]` are the only possible sums.\nLet `S_candidate_values` be the set of `A[i] + B[j]` values for which `A[i] + B[j] >= x`.\nWe are looking for `max_{S_V in S_candidate_values} count_ge(S_V)`.\nThis set `S_candidate_values` can have up to `N^2` values.\nHowever, `count_ge(T)` only changes values at `T = A[k] + B[l]`.\nWe need to find the maximum `count_ge(T)` for `T >= x`.\nThis is equivalent to finding `max(count_ge(T))` where `T` is any `A[k] + B[l]` such that `A[k] + B[l] >= x`.\n\nThis is the correct approach:\n1. Sort `A` ascending. Sort `B` ascending.\n2. `max_rank = 0`\n3. `ptr_b_for_vasya = n - 1`\n4. For `i` from `0` to `n-1`: // `A[i]` is Vasya's potential first tour score\n   // Find the smallest `B[j]` such that `A[i] + B[j] >= x`.\n   // This `j` is `idx_b_vasya`.\n   // `ptr_b_for_vasya` helps find this `idx_b_vasya` efficiently.\n   `target_b_for_current_a = x - A[i]`\n   While `ptr_b_for_vasya >= 0` and `B[ptr_b_for_vasya] >= target_b_for_current_a`:\n     `ptr_b_for_vasya -= 1`\n   `idx_b_vasya = ptr_b_for_vasya + 1`\n\n   If `idx_b_vasya < n`: // A valid `B[idx_b_vasya]` exists for `A[i]`\n     `vasya_score = A[i] + B[idx_b_vasya]`\n     // Now, calculate `count_ge(vasya_score)` efficiently.\n     // This is the bottleneck. We need a way to find `count_ge(vasya_score)` in O(1) or O(log N) amortized.\n     // The values of `vasya_score` are not monotonic.\n\nConsider the values `A[i] + B[j]` such that `A[i] + B[j] >= x`.\nLet's find all such pairs `(i, j)`.\nFor each `i`, `j` must be `bisect_left(B, x - A[i])` or greater.\nSo for each `i`, we have `B[bisect_left(B, x - A[i])]`, `B[bisect_left(B, x - A[i])+1]`, ..., `B[n-1]`.\nThis is still too many `vasya_score` values.\n\nThe key must be that we don't need to iterate through all `N` choices for `A[i]`.\nThe values of `count_ge(T)` can be precomputed for all `T` values.\nWhat are the distinct values for `T`?\nThe values `A[i] + B[j]` can be up to `2*10^5 + 2*10^5 = 4*10^5`.\nWe can iterate `T` from `x` to `4*10^5`. For each `T`, calculate `count_ge(T)`.\nThis is `4*10^5 * O(N) = 4*10^5 * 10^5 = 4*10^{10}` which is too slow.\n\nThe only way to get `O(N log N)` or `O(N)` is to use the two-pointer approach for `count_ge(T)` intelligently.\nLet `A_sorted` and `B_sorted` be sorted ascending.\nWe want to find `max_{S_V >= x} count_ge(S_V)`.\nLet `current_max_rank = 0`.\n`p_b_count = n - 1` (for `count_ge` function)\nFor `p_a_count` from `0` to `n-1`:\n  While `p_b_count >= 0` and `A_sorted[p_a_count] + B_sorted[p_b_count] >= x`:\n    `current_rank_for_this_T = (p_a_count + 1) + (n - 1 - p_b_count)` // This is not `count_ge`.\n    // This is the number of elements that can be paired up to make a sum >= x.\n    // This is `p_a_count` (from `A`) and `n - 1 - p_b_count` (from `B`).\n    // This is the number of pairs we can form if `T = x`.\n    // `count_ge(x)` is the maximum number of pairs `(a_i, b_j)` such that `a_i+b_j >= x`.\n    // The `count_ge(T)` function is correct.\n\nLet's trace `count_ge(T)` for various `T`.\n`A = [3, 4, 4, 4, 5, 6]`\n`B = [0, 3, 4, 4, 6, 8]`\n`x = 7`\n\n`worst_rank = 0`\n\nIterate `i` from `0` to `n-1` for `A[i]`:\n`i = 0, A[0] = 3`:\n  `target_b = 7 - 3 = 4`. `bisect_left(B, 4)` is `idx_b = 2` (since `B[2]=4`).\n  `vasya_score = A[0] + B[2] = 3 + 4 = 7`.\n  `count_ge(7)`:\n    `count = 0`, `p_b = 5`\n    `p_a = 0, A[0]=3`: `B[5]=8`. `3+8=11 >= 7`. `count=1, p_b=4`.\n    `p_a = 1, A[1]=4`: `B[4]=6`. `4+6=10 >= 7`. `count=2, p_b=3`.\n    `p_a = 2, A[2]=4`: `B[3]=4`. `4+4=8 >= 7`. `count=3, p_b=2`.\n    `p_a = 3, A[3]=4`: `B[2]=4`. `4+4=8 >= 7`. `count=4, p_b=1`.\n    `p_a = 4, A[4]=5`: `B[1]=3`. `5+3=8 >= 7`. `count=5, p_b=0`.\n    `p_a = 5, A[5]=6`: `B[0]=0`. `6+0=6 < 7`. `p_b` decrements to `-1`.\n    `count_ge(7)` returns `5`.\n  `worst_rank = max(0, 5) = 5`.\n\nThis is `O(N^2)` because `bisect_left` is `O(log N)` but `count_ge` is `O(N)`.\nThe problem states `N <= 10^5`, `O(N^2)` is too slow.\n\nThe `count_ge(T)` function can be computed for all `T` values in `O(N log N)` or `O(N)` if we use a specific approach.\nConsider `A` sorted ascending and `B` sorted descending.\n`A_asc = sorted(a)`\n`B_desc = sorted(b, reverse=True)`\nThe sums `A_asc[i] + B_desc[i]` are not necessarily sorted.\nHowever, for any `T`, `count_ge(T)` can be found in `O(N)` using the two pointers (one from `A_asc` start, one from `B_asc` end).\n\nThe final answer for the worst case is `max_{i, j s.t. A[i]+B[j] >= x} count_ge(A[i]+B[j])`.\nThis is `max_{T >= x, T is a sum} count_ge(T)`.\nSince `count_ge(T)` is non-increasing, we are looking for `count_ge(T_min)` where `T_min` is the smallest possible sum `A[i]+B[j]` that is `>= x`.\nThis is exactly `x`. So we just need `count_ge(x)`.\nIs this always true? No.\nExample: `A=[1,10], B=[1,10]`, `x=2`.\n`count_ge(2)`:\n  `T=2`. `A=[1,10], B=[1,10]`.\n  `p_a=0, A[0]=1`: `p_b=1, B[1]=10`. `1+10=11 >= 2`. `count=1, p_b=0`.\n  `p_a=1, A[1]=10`: `p_b=0, B[0]=1`. `10+1=11 >= 2`. `count=2, p_b=-1`.\n  `count_ge(2) = 2`.\n`worst_rank = 2`.\nVasya can get `1+1=2`. All 2 participants get `>=2`. So rank 2.\n\nExample: `A=[1,1,1,1,1], B=[1,1,1,1,1], x=2`.\n`count_ge(2)`:\n  `T=2`.\n  `p_a=0, A[0]=1`: `p_b=4, B[4]=1`. `1+1=2 >= 2`. `count=1, p_b=3`.\n  `p_a=1, A[1]=1`: `p_b=3, B[3]=1`. `1+1=2 >= 2`. `count=2, p_b=2`.\n  ...\n  `count_ge(2) = 5`.\n`worst_rank = 5`.\nThis matches the example.\n\nThe solution for worst rank is indeed `count_ge(x)`.\nWhy? We want to maximize the number of people who score `>= S_V` (Vasya's score).\nVasya's score `S_V` must be `>= x`.\nIf Vasya chooses `S_V = x` (if possible), then the number of people who score `>= x` is `count_ge(x)`. This is the maximum possible number of people who score `>= any Vasya score >= x`, because `count_ge(T)` is non-increasing. So `count_ge(x)` is the maximum possible count.\nAnd it is possible for Vasya to achieve `S_V = x` if there exist `a_i, b_j` s.t. `a_i+b_j = x`. If only `a_i+b_j > x` is possible, then `count_ge(min_achievable_score_ge_x)` is what we need.\n\nLet `min_S_V_ge_x` be the smallest score `S_V` that Vasya can achieve such that `S_V >= x`.\nThis `min_S_V_ge_x` is `min { A[i] + B[j] | A[i] + B[j] >= x }`.\nLet `S_0 = min { A[i] + B[j] | A[i] + B[j] >= x }`.\nThen the worst rank is `count_ge(S_0)`.\nWe can find `S_0` by iterating `i` from `0` to `n-1`, finding `idx_b = bisect_left(B, x - A[i])`, and if `idx_b < n`, `S_0 = min(S_0, A[i] + B[idx_b])`. This is `O(N log N)`.\nOnce `S_0` is found, `count_ge(S_0)` is `O(N)`.\nTotal complexity: `O(N log N)`. This is efficient enough.\n\n**Final Algorithm:**\n1. Read `n, x`.\n2. Read `a` and `b` arrays.\n3. Sort `a` and `b` in ascending order.\n\n**Best Rank:**\nThe best rank is always 1. (As explained above, Vasya can take `a[n-1]` and `b[n-1]`, which is the maximum possible score. Since `a[n-1]+b[n-1] >= x` must hold, Vasya can be ranked 1st.)\n\n**Worst Rank:**\n1. Find `S_0 = min {a_i + b_j | a_i + b_j >= x}`.\n   Initialize `S_0 = infinity`.\n   For `i` from `0` to `n-1`:\n     `target_b = x - a[i]`\n     `idx_b = bisect_left(b, target_b)`\n     If `idx_b < n`:\n       `S_0 = min(S_0, a[i] + b[idx_b])`\n   This step takes `O(N log N)` due to `N` calls to `bisect_left`.\n2. Calculate `count_ge(S_0)`:\n   `count = 0`\n   `ptr_b = n-1`\n   For `ptr_a` from `0` to `n-1`:\n     While `ptr_b >= 0` and `a[ptr_a] + b[ptr_b] < S_0`:\n       `ptr_b -= 1`\n     If `ptr_b >= 0`:\n       `count += 1`\n       `ptr_b -= 1`\n   This step takes `O(N)`.\n3. The worst rank is `count`.\n\nTotal complexity: `O(N log N)` for sorting and finding `S_0`, `O(N)` for `count_ge`. Overall `O(N log N)`.\n\n```python\nimport sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Best Rank: Always 1\n    # Vasya can achieve the maximum possible score (a[n-1] + b[n-1]).\n    # The problem guarantees that Vasya was present and got at least x points,\n    # which implies a[n-1] + b[n-1] >= x (since it's the highest possible sum).\n    # By pairing a[n-1] with b[n-1] for Vasya, and then pairing a[i] with b[i]\n    # for i < n-1 for other participants, Vasya's score will be >= all other scores.\n    # With jury's choice for ties, Vasya can always be placed 1st.\n    best_rank = 1\n\n    # Worst Rank\n    # We need to find the smallest possible score S_0 that Vasya can achieve such that S_0 >= x.\n    # Then, we find the maximum number of participants (including Vasya) that can achieve a score >= S_0.\n    # This count will be Vasya's worst rank (as jury places him last among ties).\n\n    s0 = float('inf')\n    for val_a in a:\n        # Find the smallest b_j such that val_a + b_j >= x\n        # This means b_j >= x - val_a\n        target_b = x - val_a\n        idx_b = bisect_left(b, target_b)\n        \n        if idx_b < n:\n            # A valid b_j exists. val_a + b[idx_b] is a candidate for S_0.\n            s0 = min(s0, val_a + b[idx_b])\n    \n    # Now calculate count_ge(s0): the maximum number of pairs (a_k, b_l) such that a_k + b_l >= s0.\n    # This is done using a two-pointer approach.\n    count = 0\n    ptr_b = n - 1  # Pointer for array b, starting from largest element\n    for ptr_a in range(n): # Pointer for array a, starting from smallest element\n        # Move ptr_b leftwards until a[ptr_a] + b[ptr_b] < s0\n        # All b values from ptr_b+1 to n-1 (if available) would satisfy a[ptr_a] + b[k] >= s0\n        # To maximize pairs, we pair the smallest a with the largest possible b.\n        # This specific greedy strategy works:\n        # If a[ptr_a] + b[ptr_b] >= s0, we form a pair, increment count, and move both pointers.\n        # Else (a[ptr_a] + b[ptr_b] < s0), a[ptr_a] is too small to pair with b[ptr_b] to meet s0.\n        # Since b is sorted, a[ptr_a] won't meet s0 with any smaller b values.\n        # So, we must discard a[ptr_a] for this purpose and move to next a value.\n        while ptr_b >= 0 and a[ptr_a] + b[ptr_b] < s0:\n            ptr_b -= 1\n        \n        if ptr_b >= 0:\n            # Found a pair (a[ptr_a], b[ptr_b]) that sums to at least s0\n            count += 1\n            ptr_b -= 1 # This b[ptr_b] is now used\n        else:\n            # No more b values can form a sum >= s0 with current or larger a values\n            break\n            \n    worst_rank = count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Best Rank: Always 1\n    # Vasya can achieve the maximum possible score (a[n-1] + b[n-1]).\n    # The problem guarantees that Vasya was present and got at least x points,\n    # which implies a[n-1] + b[n-1] >= x (since it's the highest possible sum).\n    # By pairing a[n-1] with b[n-1] for Vasya, and then pairing a[i] with b[i]\n    # for i < n-1 for other participants, Vasya's score will be >= all other scores.\n    # With jury's choice for ties, Vasya can always be placed 1st.\n    best_rank = 1\n\n    # Worst Rank\n    # We need to find the smallest possible score S_0 that Vasya can achieve such that S_0 >= x.\n    # Then, we find the maximum number of participants (including Vasya) that can achieve a score >= S_0.\n    # This count will be Vasya's worst rank (as jury places him last among ties).\n\n    s0 = float('inf')\n    for val_a in a:\n        # Find the smallest b_j such that val_a + b_j >= x\n        # This means b_j >= x - val_a\n        target_b = x - val_a\n        idx_b = bisect_left(b, target_b)\n        \n        if idx_b < n:\n            # A valid b_j exists. val_a + b[idx_b] is a candidate for S_0.\n            s0 = min(s0, val_a + b[idx_b])\n    \n    # Now calculate count_ge(s0): the maximum number of pairs (a_k, b_l) such that a_k + b_l >= s0.\n    # This is done using a two-pointer approach.\n    count = 0\n    ptr_b = n - 1  # Pointer for array b, starting from largest element\n    for ptr_a in range(n): # Pointer for array a, starting from smallest element\n        # Move ptr_b leftwards until a[ptr_a] + b[ptr_b] < s0\n        # All b values from ptr_b+1 to n-1 (if available) would satisfy a[ptr_a] + b[k] >= s0\n        # To maximize pairs, we pair the smallest a with the largest possible b.\n        # This specific greedy strategy works:\n        # If a[ptr_a] + b[ptr_b] >= s0, we form a pair, increment count, and move both pointers.\n        # Else (a[ptr_a] + b[ptr_b] < s0), a[ptr_a] is too small to pair with b[ptr_b] to meet s0.\n        # Since b is sorted, a[ptr_a] won't meet s0 with any smaller b values.\n        # So, we must discard a[ptr_a] for this purpose and move to next a value.\n        while ptr_b >= 0 and a[ptr_a] + b[ptr_b] < s0:\n            ptr_b -= 1\n        \n        if ptr_b >= 0:\n            # Found a pair (a[ptr_a], b[ptr_b]) that sums to at least s0\n            count += 1\n            ptr_b -= 1 # This b[ptr_b] is now used\n        else:\n            # No more b values can form a sum >= s0 with current or larger a values\n            break\n            \n    worst_rank = count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 12258,
        "thoughts_token_count": 7558
    }
}