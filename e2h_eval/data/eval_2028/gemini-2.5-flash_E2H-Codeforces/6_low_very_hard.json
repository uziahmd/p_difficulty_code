{
    "start": 1758009281.0441551,
    "end": 1758009311.7051332,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Refining the Competitive Programming Problem Solution**\n\nOkay, so I've got this competitive programming problem and I need to write a Python script for it. The core of the problem is finding two non-overlapping vouchers whose combined duration equals a target value *x*, and whose total cost is minimized. If no such pair exists, I need to output -1.\n\nMy initial thoughts are, of course, to break down the problem's conditions. I'm essentially looking for two distinct vouchers (let's call them *i* and *j*) that meet several criteria: they can't intersect (meaning one must finish before the other starts), their combined duration must equal *x*, and the sum of their costs has to be the lowest possible.\n\nThe constraints are manageable: *n* and *x* are up to 2 * 10^5, and the voucher parameters (*li*, *ri*, and *costi*) are also up to that scale. My initial thought was to simply brute-force it, looping through all possible pairs of vouchers and checking the conditions, but even with this input size, that's immediately going to be too slow, an O(n^2) solution would be too inefficient. I need to be aiming for an O(n log n) or ideally an O(n) solution.\n\nI'm starting to think about how to optimize this. I can rephrase the non-intersecting condition – assume *ri < lj*. That means voucher *i* ends before voucher *j* begins. Now, I'm focusing on the duration. Let's call the duration of voucher *i*, *duration_i*. The crucial condition, *duration_i + duration_j = x*, means I can compute *duration_j* as *x - duration_i*.\n\nNow, my strategy is starting to crystallize. I'm going to iterate through each voucher *i*. For each *i*, I'll need to locate a voucher *j* that satisfies:\n\n1.  *j* is non-intersecting (either *ri < lj* or *rj < li*).\n2.  *duration_j = x - duration_i*.\n3.  *cost_j* is minimal among all valid *j* values.\n\nI'm currently pondering how to efficiently search for *j* for each *i*. I need to avoid an *O(n)* search for *j* every time. That feels like I'm still stuck with an O(n^2) approach. There's got to be a way to pre-process or organize the vouchers to speed up that lookup. Maybe sorting the vouchers or using some sort of hash table or dictionary-based approach could help me retrieve the best *j* in O(1) or O(log n) time.\nLet's see, what about fixing voucher i and finding the other.\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet `duration_k = r_k - l_k + 1` be the duration of voucher `k`.\nThe conditions are:\n1.  `duration_i + duration_j = x`\n2.  Vouchers `i` and `j` are non-overlapping: `r_i < l_j` or `r_j < l_i`.\n3.  Minimize `cost_i + cost_j`.\n\nThe maximum value for `n`, `x`, `l_k`, `r_k` is `2 * 10^5`. A naive `O(N^2)` approach will be too slow. We need a more efficient approach, likely `O(N log N)` or `O(N + MAX_COORD)`.\n\nLet's iterate through all possible `r_i` values (end days of the first voucher). For each `r_i`, we want to find a voucher `j` such that `l_j > r_i` and `duration_j = x - duration_i`, minimizing `cost_j`.\n\nTo efficiently find the minimum `cost_j`, we can precompute minimum costs for vouchers ending at or before a certain day, and for vouchers starting at or after a certain day.\n\nWe can organize the vouchers by their start and end days. A common technique for problems involving intervals and coordinates up to `2 * 10^5` is to use arrays indexed by days.\n\nLet's define `min_cost_for_duration[duration][end_day]` as the minimum cost of a voucher with a specific `duration` that ends on `end_day`. This would be too large (`X * MAX_COORD`).\n\nInstead, let's consider the `l_k` (start day) and `r_k` (end day) values.\nWe can iterate through all possible `end_day` values from `1` to `MAX_COORD` (which is `2 * 10^5`).\nFor each `end_day`, we process vouchers that *end* on this day.\nLet `vouchers_by_end_day[d]` be a list of `(l, duration, cost)` for all vouchers ending on day `d`.\nLet `vouchers_by_start_day[d]` be a list of `(r, duration, cost)` for all vouchers starting on day `d`.\n\nWe need to maintain the minimum cost for a voucher with a specific duration that *could potentially be the second voucher*.\nLet `min_cost_for_duration_ending_before[duration]` be the minimum cost of a voucher with `duration` that has already been processed (i.e., its end day `r` is less than the current `l_j` we are considering).\nSimilarly, `min_cost_for_duration_starting_after[duration]` for the other case.\n\nThis problem can be solved by processing vouchers grouped by their end dates.\nLet's maintain an array `min_cost_for_duration_ending_at_or_before[duration]`. This array will store the minimum cost of a voucher with the given `duration` that ends on or before the current day `d` we are processing.\nInitialize `min_cost_for_duration_ending_at_or_before` with infinity for all durations.\n\nWe iterate `d` from `1` to `MAX_COORD`.\nFor each day `d`:\n1.  **Update minimum costs for vouchers ending today**: For every voucher `(l, r, cost)` where `r = d`, calculate its duration `dur = r - l + 1`. Update `min_cost_for_duration_ending_at_or_before[dur] = min(min_cost_for_duration_ending_at_or_before[dur], cost)`.\n2.  **Consider vouchers starting tomorrow**: For every voucher `(l, r, cost)` where `l = d + 1`, calculate its duration `dur_j = r - l + 1`. We are looking for a first voucher `i` such that `r_i < l_j` (i.e., `r_i <= d`). The duration of `i` must be `dur_i = x - dur_j`. If `dur_i > 0` and `dur_i <= X`, we can potentially form a pair. The cost of such a pair would be `cost + min_cost_for_duration_ending_at_or_before[dur_i]`. Update the overall minimum answer.\n\nThis approach covers one type of non-overlap: `r_i < l_j`. We process vouchers in increasing order of `r_i`. When we are at day `d`, `min_cost_for_duration_ending_at_or_before[dur_i]` stores the minimum cost of a voucher `i` with duration `dur_i` such that `r_i <= d`.\nThen, for any voucher `j` starting at `l_j = d+1`, we can pair it with such an `i`.\n\nLet `MAX_COORD = 200000`.\n`vouchers_by_end_day[d]` will store `(l, cost)` for vouchers ending on day `d`.\n`vouchers_by_start_day[d]` will store `(r, cost)` for vouchers starting on day `d`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i, r_i is 2 * 10^5\n    MAX_COORD = 200000 \n\n    # Store vouchers by their end day and start day\n    # vouchers_by_end_day[d] = list of (l, cost) for vouchers ending on day d\n    # vouchers_by_start_day[d] = list of (r, cost) for vouchers starting on day d\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_end_day[r].append((l, duration, cost))\n        vouchers_by_start_day[l].append((r, duration, cost))\n\n    # min_cost_for_duration_ending_at_or_before[d] stores the minimum cost\n    # of a voucher with duration 'd' that has been encountered so far\n    # (i.e., its end day 'r' is <= current_day_iterator)\n    # Initialize with a very large value (infinity)\n    min_cost_for_duration_ending_at_or_before = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that end on `current_day`.\n        # These vouchers can potentially be the \"first\" voucher `i` in a pair (i, j)\n        # where `r_i = current_day`.\n        for l_i, dur_i, cost_i in vouchers_by_end_day[current_day]:\n            if dur_i <= x: # Only consider durations up to x\n                min_cost_for_duration_ending_at_or_before[dur_i] = min(\n                    min_cost_for_duration_ending_at_or_before[dur_i], cost_i\n                )\n\n        # Step 2: Process vouchers that start on `current_day + 1`.\n        # These vouchers can potentially be the \"second\" voucher `j` in a pair (i, j)\n        # where `l_j = current_day + 1`.\n        # We look for a first voucher `i` such that `r_i < l_j` (i.e., `r_i <= current_day`).\n        # The required duration for voucher `i` would be `x - dur_j`.\n        \n        # Note: The problem states `ri < lj` or `rj < li`.\n        # Our loop processes `r_i` up to `current_day` and `l_j = current_day + 1`.\n        # This covers the `r_i < l_j` case.\n        # The symmetric case `r_j < l_i` will be covered when `current_day` becomes `r_j`\n        # and `l_i` becomes `current_day + 1`.\n        \n        # We need to consider vouchers starting on `current_day + 1`.\n        # The maximum day for `l` is `MAX_COORD`. So `current_day + 1` can go up to `MAX_COORD + 1`.\n        # We only need to check up to `MAX_COORD` for `vouchers_by_start_day` index.\n        next_day = current_day + 1\n        if next_day > MAX_COORD:\n            continue\n\n        for r_j, dur_j, cost_j in vouchers_by_start_day[next_day]:\n            # If dur_j is already greater than x, it cannot be part of a pair summing to x\n            if dur_j >= x: \n                continue\n\n            required_dur_i = x - dur_j\n            \n            # If required_dur_i is positive and we have a voucher with that duration\n            # ending on or before `current_day`, we can form a pair.\n            if required_dur_i > 0 and required_dur_i <= x:\n                if min_cost_for_duration_ending_at_or_before[required_dur_i] != float('inf'):\n                    current_pair_cost = cost_j + min_cost_for_duration_ending_at_or_before[required_dur_i]\n                    min_total_cost = min(min_total_cost, current_pair_cost)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i, r_i is 2 * 10^5\n    MAX_COORD = 200000 \n\n    # Store vouchers by their end day and start day\n    # vouchers_by_end_day[d] = list of (l, cost) for vouchers ending on day d\n    # vouchers_by_start_day[d] = list of (r, cost) for vouchers starting on day d\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_end_day[r].append((l, duration, cost))\n        vouchers_by_start_day[l].append((r, duration, cost))\n\n    # min_cost_for_duration_ending_at_or_before[d] stores the minimum cost\n    # of a voucher with duration 'd' that has been encountered so far\n    # (i.e., its end day 'r' is <= current_day_iterator)\n    # Initialize with a very large value (infinity)\n    min_cost_for_duration_ending_at_or_before = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that end on `current_day`.\n        # These vouchers can potentially be the \"first\" voucher `i` in a pair (i, j)\n        # where `r_i = current_day`.\n        for l_i, dur_i, cost_i in vouchers_by_end_day[current_day]:\n            if dur_i <= x: # Only consider durations up to x\n                min_cost_for_duration_ending_at_or_before[dur_i] = min(\n                    min_cost_for_duration_ending_at_or_before[dur_i], cost_i\n                )\n\n        # Step 2: Process vouchers that start on `current_day + 1`.\n        # These vouchers can potentially be the \"second\" voucher `j` in a pair (i, j)\n        # where `l_j = current_day + 1`.\n        # We look for a first voucher `i` such that `r_i < l_j` (i.e., `r_i <= current_day`).\n        # The required duration for voucher `i` would be `x - dur_j`.\n        \n        # Note: The problem states `ri < lj` or `rj < li`.\n        # Our loop processes `r_i` up to `current_day` and `l_j = current_day + 1`.\n        # This covers the `r_i < l_j` case.\n        # The symmetric case `r_j < l_i` will be covered when `current_day` becomes `r_j`\n        # and `l_i` becomes `current_day + 1`.\n        \n        # We need to consider vouchers starting on `current_day + 1`.\n        # The maximum day for `l` is `MAX_COORD`. So `current_day + 1` can go up to `MAX_COORD + 1`.\n        # We only need to check up to `MAX_COORD` for `vouchers_by_start_day` index.\n        next_day = current_day + 1\n        if next_day > MAX_COORD:\n            continue\n\n        for r_j, dur_j, cost_j in vouchers_by_start_day[next_day]:\n            # If dur_j is already greater than x, it cannot be part of a pair summing to x\n            if dur_j >= x: \n                continue\n\n            required_dur_i = x - dur_j\n            \n            # If required_dur_i is positive and we have a voucher with that duration\n            # ending on or before `current_day`, we can form a pair.\n            if required_dur_i > 0 and required_dur_i <= x:\n                if min_cost_for_duration_ending_at_or_before[required_dur_i] != float('inf'):\n                    current_pair_cost = cost_j + min_cost_for_duration_ending_at_or_before[required_dur_i]\n                    min_total_cost = min(min_total_cost, current_pair_cost)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 2424,
        "thoughts_token_count": 769
    }
}