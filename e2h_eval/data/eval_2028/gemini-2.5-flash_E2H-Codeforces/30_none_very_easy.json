{
    "start": 1758293709.5411797,
    "end": 1758293761.8017654,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n = int(input())\n    a_str = input()\n\n    # The problem asks to maximize S1 + S2.\n    # S1 is formed by n digits chosen by Homer.\n    # S2 is formed by n digits chosen by Marge.\n    # The digits are taken from left to right from A.\n    # The total prize S1 + S2 is simply the number A itself,\n    # if we consider A as a string of digits.\n    # For example, if A = \"1234\", n = 2.\n    # If Homer takes 1, 2 and Marge takes 3, 4. S1 = \"12\", S2 = \"34\". S1+S2 = 12+34 = 46.\n    # If Homer takes 1, 3 and Marge takes 2, 4. S1 = \"13\", S2 = \"24\". S1+S2 = 13+24 = 37.\n    # This is not how it works. The problem states \"appends it to his or her number Si\".\n    # This means S1 and S2 are formed by concatenating digits.\n    # So if A = \"1234\", n = 2.\n    # Homer takes 1, then Marge takes 2, then Homer takes 3, then Marge takes 4.\n    # S1 = \"13\", S2 = \"24\". The value of S1 is 13, value of S2 is 24. Total prize = 13 + 24 = 37.\n    #\n    # The problem is to maximize S1 + S2.\n    # S1 is formed by n digits. S2 is formed by n digits.\n    # The digits are taken from A in their original order.\n    # Let the digits of A be d_0, d_1, ..., d_{2n-1}.\n    # S1 will be d_{i_0}d_{i_1}...d_{i_{n-1}} where i_0 < i_1 < ... < i_{n-1}.\n    # S2 will be d_{j_0}d_{j_1}...d_{j_{n-1}} where j_0 < j_1 < ... < j_{n-1}.\n    # The set {i_0, ..., i_{n-1}} and {j_0, ..., j_{n-1}} form a partition of {0, ..., 2n-1}.\n    #\n    # To maximize S1 + S2, we want to make S1 and S2 as large as possible.\n    # The value of a number is heavily influenced by its leftmost digits.\n    # For example, \"90\" is much larger than \"100\" if \"90\" is 90 and \"100\" is 100.\n    # But if it's \"9\" vs \"10\", \"9\" is larger if it's the first digit.\n    #\n    # This is a greedy problem. To maximize the sum, we want to give the largest available digit to the player\n    # whose number will have that digit at the most significant position.\n    #\n    # Let's consider the first digit A[0].\n    # If Homer takes it, S1 starts with A[0].\n    # If Marge takes it, S2 starts with A[0].\n    #\n    # Since the problem asks to maximize S1 + S2, and S1 and S2 are numbers formed by concatenation,\n    # the total sum S1 + S2 is maximized when the digits at the higher place values are as large as possible.\n    #\n    # Consider the first digit A[0]. It will be the first digit of either S1 or S2.\n    # Consider the second digit A[1]. It will be the first digit of the other player's number, or the second digit of the first player's number.\n    #\n    # This is a bit tricky. Let's re-read carefully: \"appends it to his or her number Si\".\n    # This means S1 and S2 are formed by concatenating digits in the order they are taken.\n    #\n    # Example: n=2, A=\"1234\"\n    # Possible sequences:\n    # H H M M: S1=\"12\", S2=\"34\". Sum = 12+34 = 46.\n    # H M H M: S1=\"13\", S2=\"24\". Sum = 13+24 = 37.\n    # H M M H: S1=\"14\", S2=\"23\". Sum = 14+23 = 37.\n    # M H H M: S1=\"23\", S2=\"14\". Sum = 23+14 = 37.\n    # M H M H: S1=\"24\", S2=\"13\". Sum = 24+13 = 37.\n    # M M H H: S1=\"34\", S2=\"12\". Sum = 34+12 = 46.\n    #\n    # In the example, \"HHMM\" and \"MMHH\" both give 46. The output is \"HHMM\".\n    #\n    # This suggests a greedy strategy.\n    # At each step, we have a digit A[k]. We need to decide if Homer or Marge takes it.\n    # Homer has made h_moves moves, Marge has made m_moves moves.\n    # We need h_moves < n and m_moves < n.\n    #\n    # The value of a number is sum(digit * 10^power).\n    # The power depends on how many digits are already in the number.\n    #\n    # This problem is equivalent to assigning each digit A[k] to either S1 or S2.\n    # If A[k] is assigned to S1, it will be the (h_moves+1)-th digit of S1.\n    # If A[k] is assigned to S2, it will be the (m_moves+1)-th digit of S2.\n    #\n    # The total sum S1 + S2 is maximized.\n    #\n    # Let's think about the contribution of each digit A[k].\n    # If A[k] is taken by Homer, it adds A[k] * 10^(n - (h_moves+1)) to S1.\n    # If A[k] is taken by Marge, it adds A[k] * 10^(n - (m_moves+1)) to S2.\n    #\n    # The crucial observation is that we want to put the largest digits at the most significant positions.\n    # The most significant position in S1 or S2 is the first digit (index 0), which contributes 10^(n-1).\n    # The second digit contributes 10^(n-2), and so on.\n    #\n    # Consider the first digit A[0]. It will be the (n-1)-th power of 10 contributor for either S1 or S2.\n    # Consider the second digit A[1]. It will be the (n-1)-th power of 10 contributor for the other player,\n    # OR the (n-2)-th power of 10 contributor for the player who took A[0].\n    #\n    # This is a dynamic programming problem.\n    # dp[i][h_count][m_count] = maximum total sum from digits A[i:]\n    # given that Homer has taken h_count digits and Marge has taken m_count digits.\n    # The state needs to include the current values of S1 and S2. This makes it too complex.\n    # The values can be very large (2n digits, n=18, so 36 digits).\n    # S1 and S2 can be up to 18 digits long. So S1+S2 can be up to 18 digits.\n    # This means we need to handle numbers as strings or use arbitrary precision arithmetic.\n    # Python integers handle arbitrary precision automatically.\n    #\n    # Let's trace the example n=2, A=\"1234\"\n    # Homer_moves = 0, Marge_moves = 0\n    # Current digit A[0] = '1'.\n    # Option 1: Homer takes '1'. Homer_moves = 1, S1 = \"1\".\n    # Option 2: Marge takes '1'. Marge_moves = 1, S2 = \"1\".\n    #\n    # This is a standard greedy strategy for maximizing a sum of two numbers formed by concatenating digits.\n    # At each step, we have a choice. We need to decide which player takes the current digit.\n    # The decision should be based on which choice leads to a larger sum.\n    #\n    # Consider the current digit `d = A[k]`.\n    # Let `h_taken` be the number of digits Homer has taken so far.\n    # Let `m_taken` be the number of digits Marge has taken so far.\n    #\n    # If Homer takes `d`:\n    #   He needs `n - h_taken - 1` more digits.\n    #   `d` will be at position `h_taken` in S1 (0-indexed).\n    #   Its contribution to S1 is `d * 10^(n - 1 - h_taken)`.\n    #\n    # If Marge takes `d`:\n    #   She needs `n - m_taken - 1` more digits.\n    #   `d` will be at position `m_taken` in S2 (0-indexed).\n    #   Its contribution to S2 is `d * 10^(n - 1 - m_taken)`.\n    #\n    # We want to maximize the sum of these contributions over all digits.\n    # The problem is that the \"remaining sum\" depends on future choices.\n    #\n    # However, for this specific problem, there's a simpler greedy approach that works.\n    # The problem asks to maximize S1 + S2.\n    # The total number of digits is 2n. Each player takes n digits.\n    #\n    # Consider the first digit A[0].\n    # If Homer takes it, S1 starts with A[0].\n    # If Marge takes it, S2 starts with A[0].\n    #\n    # What if we just try to make the first digit of S1 and S2 as large as possible?\n    #\n    # The problem is equivalent to this:\n    # We have 2n digits. We need to pick n digits for S1 and n digits for S2.\n    # The order of digits in S1 and S2 is preserved from A.\n    #\n    # Let's consider the example n=2, A=\"9911\".\n    # Output: HMHM\n    # H takes 9. S1=\"9\"\n    # M takes 9. S2=\"9\"\n    # H takes 1. S1=\"91\"\n    # M takes 1. S2=\"91\"\n    # Total sum = 91 + 91 = 182.\n    #\n    # Let's try HHMM:\n    # H takes 9. S1=\"9\"\n    # H takes 9. S1=\"99\"\n    # M takes 1. S2=\"1\"\n    # M takes 1. S2=\"11\"\n    # Total sum = 99 + 11 = 110. (Lower than 182)\n    #\n    # This implies that the greedy choice is to give the current digit to the player\n    # who currently has fewer digits, or if they have the same number of digits,\n    # to the player who would benefit more from it (i.e., put it in a more significant position).\n    #\n    # This is a classic \"assign items to two bins to maximize sum\" problem.\n    # The key is that the \"value\" of a digit depends on its position.\n    # The first digit of a number contributes 10^(n-1) * digit_value.\n    # The second digit contributes 10^(n-2) * digit_value.\n    # ...\n    # The last digit contributes 10^0 * digit_value.\n    #\n    # So, for each digit A[k], if Homer takes it, it adds A[k] * 10^(n - 1 - h_count) to the total sum.\n    # If Marge takes it, it adds A[k] * 10^(n - 1 - m_count) to the total sum.\n    #\n    # We want to maximize SUM(A[k] * 10^(n - 1 - pos_in_S_i)).\n    #\n    # This is a greedy problem where we assign the digit A[k] to the player who can place it at a higher \"power of 10\" position.\n    #\n    # At each step `k` from 0 to `2n-1`:\n    # Let `d = int(a_str[k])`.\n    # Let `h_taken` be the number of digits Homer has taken.\n    # Let `m_taken` be the number of digits Marge has taken.\n    #\n    # If Homer takes `d`, its contribution to the sum is `d * 10^(n - 1 - h_taken)`.\n    # If Marge takes `d`, its contribution to the sum is `d * 10^(n - 1 - m_taken)`.\n    #\n    # We want to assign `d` to the player whose `10^power` is larger.\n    # `10^(n - 1 - h_taken)` vs `10^(n - 1 - m_taken)`.\n    # This means we want to assign `d` to the player with the smaller `h_taken` or `m_taken`.\n    #\n    # So, if `h_taken < m_taken` (and `h_taken < n`), Homer should take it.\n    # If `m_taken < h_taken` (and `m_taken < n`), Marge should take it.\n    #\n    # What if `h_taken == m_taken`?\n    # In this case, both `10^(n - 1 - h_taken)` and `10^(n - 1 - m_taken)` are the same.\n    # So `d` contributes equally to the sum regardless of who takes it.\n    # In this specific scenario, it doesn't matter who takes it for the current digit's contribution.\n    # However, it affects future choices.\n    # If Homer takes it, `h_taken` increases. The next digit will be compared with `h_taken+1` vs `m_taken`.\n    #\n    # Let's re-examine the example n=2, A=\"9911\", output \"HMHM\".\n    # k=0, A[0]='9'. h_taken=0, m_taken=0. Equal.\n    #   Homer takes '9'. h_taken=1. S1=\"9\". Result: H\n    # k=1, A[1]='9'. h_taken=1, m_taken=0. Marge has fewer.\n    #   Marge takes '9'. m_taken=1. S2=\"9\". Result: M\n    # k=2, A[2]='1'. h_taken=1, m_taken=1. Equal.\n    #   Homer takes '1'. h_taken=2. S1=\"91\". Result: H\n    # k=3, A[3]='1'. h_taken=2, m_taken=1. Marge has fewer.\n    #   Marge takes '1'. m_taken=2. S2=\"91\". Result: M\n    # Final result: HMHM. This matches the example!\n    #\n    # This greedy strategy seems to work:\n    # At each step `k` from 0 to `2n-1`:\n    #   If `h_taken < n` and `m_taken < n`:\n    #       If `h_taken < m_taken`: Homer takes `A[k]`. Increment `h_taken`. Append 'H'.\n    #       Else if `m_taken < h_taken`: Marge takes `A[k]`. Increment `m_taken`. Append 'M'.\n    #       Else (`h_taken == m_taken`): It doesn't matter for the current digit's contribution.\n    #           To maximize the sum, we want to give the larger digits to the player who has taken fewer digits.\n    #           But here, they have taken the same number of digits.\n    #           The problem states \"If there are several solutions, output any of them.\"\n    #           So, if `h_taken == m_taken`, we can choose either. Let's say Homer takes it.\n    #           Increment `h_taken`. Append 'H'.\n    #   Else if `h_taken < n`: (Marge must have taken n digits)\n    #       Homer takes `A[k]`. Increment `h_taken`. Append 'H'.\n    #   Else if `m_taken < n`: (Homer must have taken n digits)\n    #       Marge takes `A[k]`. Increment `m_taken`. Append 'M'.\n    #\n    # Let's verify this logic.\n    # The total sum is S1 + S2.\n    # S1 = sum(d_i * 10^(n - 1 - pos_in_S1_for_d_i)) for digits taken by Homer.\n    # S2 = sum(d_j * 10^(n - 1 - pos_in_S2_for_d_j)) for digits taken by Marge.\n    #\n    # The total sum is sum(A[k] * 10^(n - 1 - pos_in_S_player_for_A[k])).\n    #\n    # The `10^power` is `10^(n - 1 - (number of digits already taken by that player))`.\n    # This power is maximized when `(number of digits already taken by that player)` is minimized.\n    #\n    # So, at each step `k`, we have digit `A[k]`.\n    # We want to assign it to the player who has taken fewer digits so far.\n    # This is because that player will place `A[k]` at a higher \"power of 10\" position.\n    #\n    # If `h_taken < m_taken`: Homer has taken fewer digits. He can place `A[k]` at a more significant position.\n    #   So Homer takes `A[k]`.\n    # If `m_taken < h_taken`: Marge has taken fewer digits. She can place `A[k]` at a more significant position.\n    #   So Marge takes `A[k]`.\n    # If `h_taken == m_taken`: Both players would place `A[k]` at the same significance level (e.g., both would be their first digit, or both their second, etc.).\n    #   In this case, it doesn't matter for the current digit's contribution. We can pick either.\n    #   The example suggests Homer (HMHM for 9911, H first). Let's stick to Homer first if equal.\n    #\n    # This simple greedy strategy seems robust.\n    #\n    # Let's test with n=2, A=\"1234\"\n    # k=0, A[0]='1'. h_taken=0, m_taken=0. Equal. Homer takes. res=\"H\", h_taken=1.\n    # k=1, A[1]='2'. h_taken=1, m_taken=0. Marge has fewer. Marge takes. res=\"HM\", m_taken=1.\n    # k=2, A[2]='3'. h_taken=1, m_taken=1. Equal. Homer takes. res=\"HMH\", h_taken=2.\n    # k=3, A[3]='4'. h_taken=2, m_taken=1. Marge has fewer. Marge takes. res=\"HMHM\", m_taken=2.\n    #\n    # Result: HMHM.\n    # S1=\"13\", S2=\"24\". Sum = 37.\n    #\n    # The example output for A=\"1234\" is \"HHMM\".\n    # Let's trace \"HHMM\":\n    # k=0, A[0]='1'. h_taken=0, m_taken=0. Homer takes. res=\"H\", h_taken=1.\n    # k=1, A[1]='2'. h_taken=1, m_taken=0. Marge has fewer. Marge takes. res=\"HM\", m_taken=1.\n    #\n    # My greedy strategy results in \"HMHM\". The example output is \"HHMM\".\n    # This means my greedy strategy is wrong for the example A=\"1234\".\n    #\n    # Why is \"HHMM\" better for \"1234\"?\n    # HHMM: S1=\"12\", S2=\"34\". Sum = 12+34 = 46.\n    # HMHM: S1=\"13\", S2=\"24\". Sum = 13+24 = 37.\n    #\n    # The crucial difference is that \"HHMM\" gives the first two digits to Homer, and the last two to Marge.\n    # \"HMHM\" alternates.\n    #\n    # The sum is maximized when the largest digits are multiplied by the largest powers of 10.\n    # This means the largest digits should be at the beginning of S1 and S2.\n    #\n    # For A=\"1234\":\n    # HHMM: S1=\"12\", S2=\"34\"\n    #   '1' contributes 1 * 10^1 to S1\n    #   '2' contributes 2 * 10^0 to S1\n    #   '3' contributes 3 * 10^1 to S2\n    #   '4' contributes 4 * 10^0 to S2\n    # Total sum = (1*10 + 2*1) + (3*10 + 4*1) = 12 + 34 = 46.\n    #\n    # HMHM: S1=\"13\", S2=\"24\"\n    #   '1' contributes 1 * 10^1 to S1\n    #   '2' contributes 2 * 10^1 to S2\n    #   '3' contributes 3 * 10^0 to S1\n    #   '4' contributes 4 * 10^0 to S2\n    # Total sum = (1*10 + 3*1) + (2*10 + 4*1) = 13 + 24 = 37.\n    #\n    # The greedy strategy I proposed (give to player with fewer digits) is incorrect.\n    # It focuses on giving the current digit the highest possible power, but not necessarily distributing the largest digits.\n    #\n    # The problem is to maximize `S1 + S2`.\n    # Let `S1 = sum_{k in H_indices} A[k] * 10^(n - 1 - rank_in_H(k))`\n    # Let `S2 = sum_{k in M_indices} A[k] * 10^(n - 1 - rank_in_M(k))`\n    #\n    # This is a bitwise problem. We have 2n positions. For each position, we assign 'H' or 'M'.\n    # There must be exactly n 'H's and n 'M's.\n    #\n    # The total prize is sum of `A[k] * 10^(power_for_k)`.\n    # `power_for_k` depends on which player takes `A[k]` and how many digits that player has taken before `A[k]`.\n    #\n    # Let's consider the digits from left to right.\n    # For `A[0]`, it will be the first digit of either S1 or S2. Its power will be `10^(n-1)`.\n    # For `A[1]`, it will be the first digit of the other player, or the second digit of the first player.\n    #\n    # This problem is a bit like assigning weights to digits.\n    # We want to maximize `sum_{k=0}^{2n-1} (A[k] * weight[k])`.\n    # The `weight[k]` is `10^(n - 1 - rank_in_S_player(k))`.\n    #\n    # The powers of 10 are fixed for each \"rank\" (1st digit, 2nd digit, ...).\n    # There are `n` positions for `10^(n-1)`, `n` positions for `10^(n-2)`, ..., `n` positions for `10^0`.\n    # But only one `10^(n-1)` for S1 and one for S2.\n    #\n    # This is actually a simple greedy problem.\n    # The \"power\" for a digit `A[k]` is `10^(n - 1 - count_of_digits_taken_by_player_before_k)`.\n    # We want to give the largest `A[k]` values to the largest powers.\n    #\n    # The powers are `10^(n-1), 10^(n-2), ..., 10^0`.\n    # There are two `10^(n-1)` positions (one for S1, one for S2).\n    # There are two `10^(n-2)` positions (one for S1, one for S2).\n    # ...\n    # There are two `10^0` positions (one for S1, one for S2).\n    #\n    # We have `2n` digits `A[0], A[1], ..., A[2n-1]`.\n    # We need to assign `A[k]` to one of these `2n` \"slots\" (position in S1 or S2).\n    #\n    # The digits `A[k]` are fixed. We want to maximize `sum(A[k] * power_of_10)`.\n    # This means we should try to assign the largest digits `A[k]` to the largest `power_of_10` values.\n    #\n    # The available powers of 10 are `10^(n-1), 10^(n-1), 10^(n-2), 10^(n-2), ..., 10^0, 10^0`.\n    # There are `2n` such powers.\n    #\n    # If we sort `A[k]` in descending order, and `power_of_10` in descending order, and multiply them, we get the max sum.\n    # However, the order of `A[k]` is fixed. `A[0]` is always before `A[1]`.\n    #\n    # This means we are trying to assign `A[0]` to one of the `2n` slots, `A[1]` to one of the remaining `2n-1` slots, etc.\n    #\n    # The first `n` digits of A are \"more significant\" than the last `n` digits.\n    # Because `A[0]` can be `10^(n-1)` in S1 or S2.\n    # `A[n-1]` can be `10^(n-1)` in S1 or S2 (if it's the first digit taken by that player) or `10^0` (if it's the last digit).\n    #\n    # Let's consider the problem from the perspective of which `A[k]` gets which `10^p` multiplier.\n    # There are `2n` \"slots\" for digits:\n    # (S1, pos 0), (S1, pos 1), ..., (S1, pos n-1)\n    # (S2, pos 0), (S2, pos 1), ..., (S2, pos n-1)\n    #\n    # The multipliers are:\n    # `10^(n-1)` for (S1, pos 0) and (S2, pos 0)\n    # `10^(n-2)` for (S1, pos 1) and (S2, pos 1)\n    # ...\n    # `10^0` for (S1, pos n-1) and (S2, pos n-1)\n    #\n    # We have `2n` digits `A[0], ..., A[2n-1]`.\n    # We need to assign each `A[k]` to one of these slots, such that:\n    # 1. The order is preserved: if `A[k]` is assigned to (S_p, pos_x) and `A[j]` (j>k) is assigned to (S_p, pos_y), then `pos_y > pos_x`.\n    # 2. Each slot is used exactly once.\n    #\n    # This is a perfect matching problem on a bipartite graph, but with weights.\n    # Or, it's a dynamic programming problem.\n    #\n    # `dp[k][h_count][m_count]` = maximum sum using `A[k:]` given `h_count` digits for Homer and `m_count` for Marge.\n    # `dp[k][h_count][m_count]` will return the maximum *remaining* sum.\n    #\n    # Base case: `dp[2n][n][n] = 0`\n    #\n    # Recursive step for `dp[k][h_count][m_count]`:\n    #   `digit = int(a_str[k])`\n    #   `max_val = -infinity`\n    #\n    #   If `h_count < n`: (Homer can take `A[k]`)\n    #     `h_power = n - 1 - h_count`\n    #     `val_if_homer_takes = digit * (10**h_power) + dp[k+1][h_count+1][m_count]`\n    #     `max_val = max(max_val, val_if_homer_takes)`\n    #\n    #   If `m_count < n`: (Marge can take `A[k]`)\n    #     `m_power = n - 1 - m_count`\n    #     `val_if_marge_takes = digit * (10**m_power) + dp[k+1][h_count][m_count+1]`\n    #     `max_val = max(max_val, val_if_marge_takes)`\n    #\n    #   Return `max_val`.\n    #\n    # To reconstruct the path, we need to store the choices.\n    # `memo[k][h_count][m_count]` stores the choice ('H' or 'M') that leads to `max_val`.\n    #\n    # States: `k` from 0 to `2n`. `h_count` from 0 to `n`. `m_count` from 0 to `n`.\n    # Total states: `(2n+1) * (n+1) * (n+1)`.\n    # For n=18, this is `37 * 19 * 19 = 13369` states.\n    # Each state takes constant time (two recursive calls).\n    # This is feasible. `13369` is small.\n    #\n    # Let's implement this DP.\n    #\n    # `dp` table will store the maximum sum.\n    # `path` table will store the character ('H' or 'M') for reconstruction.\n    # Initialize `dp` with -1 (or some indicator for uncomputed).\n\n    memo = {}\n    path_choices = {}\n\n    def calculate_max_sum(k, h_count, m_count):\n        if (k, h_count, m_count) in memo:\n            return memo[(k, h_count, m_count)]\n\n        if k == 2 * n:\n            if h_count == n and m_count == n:\n                return 0\n            else:\n                # This state should not be reached if counts are not n, n\n                # as we only make choices if counts are less than n.\n                # Or, if it is reached, it means we couldn't make n moves for both.\n                # This implies a bug in the logic or an invalid state.\n                # However, the problem guarantees n moves for each.\n                # So we will always reach (2n, n, n) if we make valid choices.\n                return -float('inf') # Should not happen\n\n        digit = int(a_str[k])\n        max_val = -float('inf')\n        choice = ''\n\n        # Option 1: Homer takes A[k]\n        if h_count < n:\n            h_power = n - 1 - h_count\n            val_if_homer_takes = digit * (10**h_power) + calculate_max_sum(k + 1, h_count + 1, m_count)\n            if val_if_homer_takes > max_val:\n                max_val = val_if_homer_takes\n                choice = 'H'\n\n        # Option 2: Marge takes A[k]\n        if m_count < n:\n            m_power = n - 1 - m_count\n            val_if_marge_takes = digit * (10**m_power) + calculate_max_sum(k + 1, h_count, m_count + 1)\n            if val_if_marge_takes > max_val:\n                max_val = val_if_marge_takes\n                choice = 'M'\n            # If equal, and 'H' was chosen, we keep 'H' as per \"output any of them\".\n            # If the problem specified lexicographically smallest or largest, we'd need to be careful.\n\n        memo[(k, h_count, m_count)] = max_val\n        path_choices[(k, h_count, m_count)] = choice\n        return max_val\n\n    # Start the DP\n    calculate_max_sum(0, 0, 0)\n\n    # Reconstruct the path\n    result_path = []\n    current_k, current_h, current_m = 0, 0, 0\n    while current_k < 2 * n:\n        choice = path_choices[(current_k, current_h, current_m)]\n        result_path.append(choice)\n        if choice == 'H':\n            current_h += 1\n        else: # choice == 'M'\n            current_m += 1\n        current_k += 1\n\n    print(\"\".join(result_path))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n = int(input())\n    a_str = input()\n\n    # The problem asks to maximize S1 + S2.\n    # S1 is formed by n digits chosen by Homer.\n    # S2 is formed by n digits chosen by Marge.\n    # The digits are taken from left to right from A.\n    # The total prize S1 + S2 is simply the number A itself,\n    # if we consider A as a string of digits.\n    # For example, if A = \"1234\", n = 2.\n    # If Homer takes 1, 2 and Marge takes 3, 4. S1 = \"12\", S2 = \"34\". S1+S2 = 12+34 = 46.\n    # If Homer takes 1, 3 and Marge takes 2, 4. S1 = \"13\", S2 = \"24\". S1+S2 = 13+24 = 37.\n    # This is not how it works. The problem states \"appends it to his or her number Si\".\n    # This means S1 and S2 are formed by concatenating digits.\n    # So if A = \"1234\", n = 2.\n    # Homer takes 1, then Marge takes 2, then Homer takes 3, then Marge takes 4.\n    # S1 = \"13\", S2 = \"24\". The value of S1 is 13, value of S2 is 24. Total prize = 13 + 24 = 37.\n    #\n    # The problem is to maximize S1 + S2.\n    # S1 is formed by n digits. S2 is formed by n digits.\n    # The digits are taken from A in their original order.\n    # Let the digits of A be d_0, d_1, ..., d_{2n-1}.\n    # S1 will be d_{i_0}d_{i_1}...d_{i_{n-1}} where i_0 < i_1 < ... < i_{n-1}.\n    # S2 will be d_{j_0}d_{j_1}...d_{j_{n-1}} where j_0 < j_1 < ... < j_{n-1}.\n    # The set {i_0, ..., i_{n-1}} and {j_0, ..., j_{n-1}} form a partition of {0, ..., 2n-1}.\n    #\n    # To maximize S1 + S2, we want to make S1 and S2 as large as possible.\n    # The value of a number is heavily influenced by its leftmost digits.\n    # For example, \"90\" is much larger than \"100\" if \"90\" is 90 and \"100\" is 100.\n    # But if it's \"9\" vs \"10\", \"9\" is larger if it's the first digit.\n    #\n    # This is a greedy problem. To maximize the sum, we want to give the largest available digit to the player\n    # whose number will have that digit at the most significant position.\n    #\n    # Let's consider the first digit A[0].\n    # If Homer takes it, S1 starts with A[0].\n    # If Marge takes it, S2 starts with A[0].\n    #\n    # Since the problem asks to maximize S1 + S2, and S1 and S2 are numbers formed by concatenation,\n    # the total sum S1 + S2 is maximized when the digits at the higher place values are as large as possible.\n    #\n    # Consider the first digit A[0]. It will be the first digit of either S1 or S2.\n    # Consider the second digit A[1]. It will be the first digit of the other player's number, or the second digit of the first player's number.\n    #\n    # This is a bit tricky. Let's re-read carefully: \"appends it to his or her number Si\".\n    # This means S1 and S2 are formed by concatenating digits in the order they are taken.\n    #\n    # Example: n=2, A=\"1234\"\n    # Possible sequences:\n    # H H M M: S1=\"12\", S2=\"34\". Sum = 12+34 = 46.\n    # H M H M: S1=\"13\", S2=\"24\". Sum = 13+24 = 37.\n    # H M M H: S1=\"14\", S2=\"23\". Sum = 14+23 = 37.\n    # M H H M: S1=\"23\", S2=\"14\". Sum = 23+14 = 37.\n    # M H M H: S1=\"24\", S2=\"13\". Sum = 24+13 = 37.\n    # M M H H: S1=\"34\", S2=\"12\". Sum = 34+12 = 46.\n    #\n    # In the example, \"HHMM\" and \"MMHH\" both give 46. The output is \"HHMM\".\n    #\n    # This suggests a greedy strategy.\n    # At each step, we have a digit A[k]. We need to decide if Homer or Marge takes it.\n    # Homer has made h_moves moves, Marge has made m_moves moves.\n    # We need h_moves < n and m_moves < n.\n    #\n    # The value of a number is sum(digit * 10^power).\n    # The power depends on how many digits are already in the number.\n    #\n    # This problem is equivalent to assigning each digit A[k] to either S1 or S2.\n    # If A[k] is assigned to S1, it will be the (h_moves+1)-th digit of S1.\n    # If A[k] is assigned to S2, it will be the (m_moves+1)-th digit of S2.\n    #\n    # The total sum S1 + S2 is maximized.\n    #\n    # Let's think about the contribution of each digit A[k].\n    # If A[k] is taken by Homer, it adds A[k] * 10^(n - (h_moves+1)) to S1.\n    # If A[k] is taken by Marge, it adds A[k] * 10^(n - (m_moves+1)) to S2.\n    #\n    # The crucial observation is that we want to put the largest digits at the most significant positions.\n    # The most significant position in S1 or S2 is the first digit (index 0), which contributes 10^(n-1).\n    # The second digit contributes 10^(n-2), and so on.\n    #\n    # Consider the first digit A[0]. It will be the (n-1)-th power of 10 contributor for either S1 or S2.\n    # Consider the second digit A[1]. It will be the (n-1)-th power of 10 contributor for the other player,\n    # OR the (n-2)-th power of 10 contributor for the player who took A[0].\n    #\n    # This is a dynamic programming problem.\n    # dp[i][h_count][m_count] = maximum total sum from digits A[i:]\n    # given that Homer has taken h_count digits and Marge has taken m_count digits.\n    # The state needs to include the current values of S1 and S2. This makes it too complex.\n    # The values can be very large (2n digits, n=18, so 36 digits).\n    # S1 and S2 can be up to 18 digits long. So S1+S2 can be up to 18 digits.\n    # This means we need to handle numbers as strings or use arbitrary precision arithmetic.\n    # Python integers handle arbitrary precision automatically.\n    #\n    # Let's trace the example n=2, A=\"1234\"\n    # Homer_moves = 0, Marge_moves = 0\n    # Current digit A[0] = '1'.\n    # Option 1: Homer takes '1'. Homer_moves = 1, S1 = \"1\".\n    # Option 2: Marge takes '1'. Marge_moves = 1, S2 = \"1\".\n    #\n    # This is a standard greedy strategy for maximizing a sum of two numbers formed by concatenating digits.\n    # At each step, we have a choice. We need to decide which player takes the current digit.\n    # The decision should be based on which choice leads to a larger sum.\n    #\n    # Consider the current digit `d = A[k]`.\n    # Let `h_taken` be the number of digits Homer has taken so far.\n    # Let `m_taken` be the number of digits Marge has taken so far.\n    #\n    # If Homer takes `d`:\n    #   He needs `n - h_taken - 1` more digits.\n    #   `d` will be at position `h_taken` in S1 (0-indexed).\n    #   Its contribution to S1 is `d * 10^(n - 1 - h_taken)`.\n    #\n    # If Marge takes `d`:\n    #   She needs `n - m_taken - 1` more digits.\n    #   `d` will be at position `m_taken` in S2 (0-indexed).\n    #   Its contribution to S2 is `d * 10^(n - 1 - m_taken)`.\n    #\n    # We want to maximize the sum of these contributions over all digits.\n    # The problem is that the \"remaining sum\" depends on future choices.\n    #\n    # However, for this specific problem, there's a simpler greedy approach that works.\n    # The problem asks to maximize S1 + S2.\n    # The total number of digits is 2n. Each player takes n digits.\n    #\n    # Consider the first digit A[0].\n    # If Homer takes it, S1 starts with A[0].\n    # If Marge takes it, S2 starts with A[0].\n    #\n    # What if we just try to make the first digit of S1 and S2 as large as possible?\n    #\n    # The problem is equivalent to this:\n    # We have 2n digits. We need to pick n digits for S1 and n digits for S2.\n    # The order of digits in S1 and S2 is preserved from A.\n    #\n    # Let's consider the example n=2, A=\"9911\".\n    # Output: HMHM\n    # H takes 9. S1=\"9\"\n    # M takes 9. S2=\"9\"\n    # H takes 1. S1=\"91\"\n    # M takes 1. S2=\"91\"\n    # Total sum = 91 + 91 = 182.\n    #\n    # Let's try HHMM:\n    # H takes 9. S1=\"9\"\n    # H takes 9. S1=\"99\"\n    # M takes 1. S2=\"1\"\n    # M takes 1. S2=\"11\"\n    # Total sum = 99 + 11 = 110. (Lower than 182)\n    #\n    # This implies that the greedy choice is to give the current digit to the player\n    # who currently has fewer digits, or if they have the same number of digits,\n    # to the player who would benefit more from it (i.e., put it in a more significant position).\n    #\n    # This is a classic \"assign items to two bins to maximize sum\" problem.\n    # The key is that the \"value\" of a digit depends on its position.\n    # The first digit of a number contributes 10^(n-1) * digit_value.\n    # The second digit contributes 10^(n-2) * digit_value.\n    # ...\n    # The last digit contributes 10^0 * digit_value.\n    #\n    # So, for each digit A[k], if Homer takes it, it adds A[k] * 10^(n - 1 - h_count) to the total sum.\n    # If Marge takes it, it adds A[k] * 10^(n - 1 - m_count) to the total sum.\n    #\n    # We want to maximize SUM(A[k] * 10^(n - 1 - pos_in_S_i)).\n    #\n    # This is a greedy problem where we assign the digit A[k] to the player who can place it at a higher \"power of 10\" position.\n    #\n    # At each step `k` from 0 to `2n-1`:\n    # Let `d = int(a_str[k])`.\n    # Let `h_taken` be the number of digits Homer has taken.\n    # Let `m_taken` be the number of digits Marge has taken.\n    #\n    # If Homer takes `d`, its contribution to the sum is `d * 10^(n - 1 - h_taken)`.\n    # If Marge takes `d`, its contribution to the sum is `d * 10^(n - 1 - m_taken)`.\n    #\n    # We want to assign `d` to the player whose `10^power` is larger.\n    # `10^(n - 1 - h_taken)` vs `10^(n - 1 - m_taken)`.\n    # This means we want to assign `d` to the player with the smaller `h_taken` or `m_taken`.\n    #\n    # So, if `h_taken < m_taken` (and `h_taken < n`), Homer should take it.\n    # If `m_taken < h_taken` (and `m_taken < n`), Marge should take it.\n    #\n    # What if `h_taken == m_taken`?\n    # In this case, both `10^(n - 1 - h_taken)` and `10^(n - 1 - m_taken)` are the same.\n    # So `d` contributes equally to the sum regardless of who takes it.\n    # In this specific scenario, it doesn't matter who takes it for the current digit's contribution.\n    # However, it affects future choices.\n    # If Homer takes it, `h_taken` increases. The next digit will be compared with `h_taken+1` vs `m_taken`.\n    #\n    # Let's re-examine the example n=2, A=\"9911\", output \"HMHM\".\n    # k=0, A[0]='9'. h_taken=0, m_taken=0. Equal.\n    #   Homer takes '9'. h_taken=1. S1=\"9\". Result: H\n    # k=1, A[1]='9'. h_taken=1, m_taken=0. Marge has fewer.\n    #   Marge takes '9'. m_taken=1. S2=\"9\". Result: M\n    # k=2, A[2]='1'. h_taken=1, m_taken=1. Equal.\n    #   Homer takes '1'. h_taken=2. S1=\"91\". Result: H\n    # k=3, A[3]='1'. h_taken=2, m_taken=1. Marge has fewer.\n    #   Marge takes '1'. m_taken=2. S2=\"91\". Result: M\n    # Final result: HMHM. This matches the example!\n    #\n    # This greedy strategy seems to work:\n    # At each step `k` from 0 to `2n-1`:\n    #   If `h_taken < n` and `m_taken < n`:\n    #       If `h_taken < m_taken`: Homer takes `A[k]`. Increment `h_taken`. Append 'H'.\n    #       Else if `m_taken < h_taken`: Marge takes `A[k]`. Increment `m_taken`. Append 'M'.\n    #       Else (`h_taken == m_taken`): It doesn't matter for the current digit's contribution.\n    #           To maximize the sum, we want to give the larger digits to the player who has taken fewer digits.\n    #           But here, they have taken the same number of digits.\n    #           The problem states \"If there are several solutions, output any of them.\"\n    #           So, if `h_taken == m_taken`, we can choose either. Let's say Homer takes it.\n    #           Increment `h_taken`. Append 'H'.\n    #   Else if `h_taken < n`: (Marge must have taken n digits)\n    #       Homer takes `A[k]`. Increment `h_taken`. Append 'H'.\n    #   Else if `m_taken < n`: (Homer must have taken n digits)\n    #       Marge takes `A[k]`. Increment `m_taken`. Append 'M'.\n    #\n    # Let's verify this logic.\n    # The total sum is S1 + S2.\n    # S1 = sum(d_i * 10^(n - 1 - pos_in_S1_for_d_i)) for digits taken by Homer.\n    # S2 = sum(d_j * 10^(n - 1 - pos_in_S2_for_d_j)) for digits taken by Marge.\n    #\n    # The total sum is sum(A[k] * 10^(n - 1 - pos_in_S_player_for_A[k])).\n    #\n    # The `10^power` is `10^(n - 1 - (number of digits already taken by that player))`.\n    # This power is maximized when `(number of digits already taken by that player)` is minimized.\n    #\n    # So, at each step `k`, we have digit `A[k]`.\n    # We want to assign it to the player who has taken fewer digits so far.\n    # This is because that player will place `A[k]` at a higher \"power of 10\" position.\n    #\n    # If `h_taken < m_taken`: Homer has taken fewer digits. He can place `A[k]` at a more significant position.\n    #   So Homer takes `A[k]`.\n    # If `m_taken < h_taken`: Marge has taken fewer digits. She can place `A[k]` at a more significant position.\n    #   So Marge takes `A[k]`.\n    # If `h_taken == m_taken`: Both players would place `A[k]` at the same significance level (e.g., both would be their first digit, or both their second, etc.).\n    #   In this case, it doesn't matter for the current digit's contribution. We can pick either.\n    #   The example suggests Homer (HMHM for 9911, H first). Let's stick to Homer first if equal.\n    #\n    # This simple greedy strategy seems robust.\n    #\n    # Let's test with n=2, A=\"1234\"\n    # k=0, A[0]='1'. h_taken=0, m_taken=0. Equal. Homer takes. res=\"H\", h_taken=1.\n    # k=1, A[1]='2'. h_taken=1, m_taken=0. Marge has fewer. Marge takes. res=\"HM\", m_taken=1.\n    # k=2, A[2]='3'. h_taken=1, m_taken=1. Equal. Homer takes. res=\"HMH\", h_taken=2.\n    # k=3, A[3]='4'. h_taken=2, m_taken=1. Marge has fewer. Marge takes. res=\"HMHM\", m_taken=2.\n    #\n    # Result: HMHM.\n    # S1=\"13\", S2=\"24\". Sum = 37.\n    #\n    # The example output for A=\"1234\" is \"HHMM\".\n    # Let's trace \"HHMM\":\n    # k=0, A[0]='1'. h_taken=0, m_taken=0. Homer takes. res=\"H\", h_taken=1.\n    # k=1, A[1]='2'. h_taken=1, m_taken=0. Marge has fewer. Marge takes. res=\"HM\", m_taken=1.\n    #\n    # My greedy strategy results in \"HMHM\". The example output is \"HHMM\".\n    # This means my greedy strategy is wrong for the example A=\"1234\".\n    #\n    # Why is \"HHMM\" better for \"1234\"?\n    # HHMM: S1=\"12\", S2=\"34\". Sum = 12+34 = 46.\n    # HMHM: S1=\"13\", S2=\"24\". Sum = 13+24 = 37.\n    #\n    # The crucial difference is that \"HHMM\" gives the first two digits to Homer, and the last two to Marge.\n    # \"HMHM\" alternates.\n    #\n    # The sum is maximized when the largest digits are multiplied by the largest powers of 10.\n    # This means the largest digits should be at the beginning of S1 and S2.\n    #\n    # For A=\"1234\":\n    # HHMM: S1=\"12\", S2=\"34\"\n    #   '1' contributes 1 * 10^1 to S1\n    #   '2' contributes 2 * 10^0 to S1\n    #   '3' contributes 3 * 10^1 to S2\n    #   '4' contributes 4 * 10^0 to S2\n    # Total sum = (1*10 + 2*1) + (3*10 + 4*1) = 12 + 34 = 46.\n    #\n    # HMHM: S1=\"13\", S2=\"24\"\n    #   '1' contributes 1 * 10^1 to S1\n    #   '2' contributes 2 * 10^1 to S2\n    #   '3' contributes 3 * 10^0 to S1\n    #   '4' contributes 4 * 10^0 to S2\n    # Total sum = (1*10 + 3*1) + (2*10 + 4*1) = 13 + 24 = 37.\n    #\n    # The greedy strategy I proposed (give to player with fewer digits) is incorrect.\n    # It focuses on giving the current digit the highest possible power, but not necessarily distributing the largest digits.\n    #\n    # The problem is to maximize `S1 + S2`.\n    # Let `S1 = sum_{k in H_indices} A[k] * 10^(n - 1 - rank_in_H(k))`\n    # Let `S2 = sum_{k in M_indices} A[k] * 10^(n - 1 - rank_in_M(k))`\n    #\n    # This is a bitwise problem. We have 2n positions. For each position, we assign 'H' or 'M'.\n    # There must be exactly n 'H's and n 'M's.\n    #\n    # The total prize is sum of `A[k] * 10^(power_for_k)`.\n    # `power_for_k` depends on which player takes `A[k]` and how many digits that player has taken before `A[k]`.\n    #\n    # Let's consider the digits from left to right.\n    # For `A[0]`, it will be the first digit of either S1 or S2. Its power will be `10^(n-1)`.\n    # For `A[1]`, it will be the first digit of the other player, or the second digit of the first player.\n    #\n    # This problem is a bit like assigning weights to digits.\n    # We want to maximize `sum_{k=0}^{2n-1} (A[k] * weight[k])`.\n    # The `weight[k]` is `10^(n - 1 - rank_in_S_player(k))`.\n    #\n    # The powers of 10 are fixed for each \"rank\" (1st digit, 2nd digit, ...).\n    # There are `n` positions for `10^(n-1)`, `n` positions for `10^(n-2)`, ..., `n` positions for `10^0`.\n    # But only one `10^(n-1)` for S1 and one for S2.\n    #\n    # This is actually a simple greedy problem.\n    # The \"power\" for a digit `A[k]` is `10^(n - 1 - count_of_digits_taken_by_player_before_k)`.\n    # We want to give the largest `A[k]` values to the largest powers.\n    #\n    # The powers are `10^(n-1), 10^(n-2), ..., 10^0`.\n    # There are two `10^(n-1)` positions (one for S1, one for S2).\n    # There are two `10^(n-2)` positions (one for S1, one for S2).\n    # ...\n    # There are two `10^0` positions (one for S1, one for S2).\n    #\n    # We have `2n` digits `A[0], A[1], ..., A[2n-1]`.\n    # We need to assign `A[k]` to one of these `2n` \"slots\" (position in S1 or S2).\n    #\n    # The digits `A[k]` are fixed. We want to maximize `sum(A[k] * power_of_10)`.\n    # This means we should try to assign the largest digits `A[k]` to the largest `power_of_10` values.\n    #\n    # The available powers of 10 are `10^(n-1), 10^(n-1), 10^(n-2), 10^(n-2), ..., 10^0, 10^0`.\n    # There are `2n` such powers.\n    #\n    # If we sort `A[k]` in descending order, and `power_of_10` in descending order, and multiply them, we get the max sum.\n    # However, the order of `A[k]` is fixed. `A[0]` is always before `A[1]`.\n    #\n    # This means we are trying to assign `A[0]` to one of the `2n` slots, `A[1]` to one of the remaining `2n-1` slots, etc.\n    #\n    # The first `n` digits of A are \"more significant\" than the last `n` digits.\n    # Because `A[0]` can be `10^(n-1)` in S1 or S2.\n    # `A[n-1]` can be `10^(n-1)` in S1 or S2 (if it's the first digit taken by that player) or `10^0` (if it's the last digit).\n    #\n    # Let's consider the problem from the perspective of which `A[k]` gets which `10^p` multiplier.\n    # There are `2n` \"slots\" for digits:\n    # (S1, pos 0), (S1, pos 1), ..., (S1, pos n-1)\n    # (S2, pos 0), (S2, pos 1), ..., (S2, pos n-1)\n    #\n    # The multipliers are:\n    # `10^(n-1)` for (S1, pos 0) and (S2, pos 0)\n    # `10^(n-2)` for (S1, pos 1) and (S2, pos 1)\n    # ...\n    # `10^0` for (S1, pos n-1) and (S2, pos n-1)\n    #\n    # We have `2n` digits `A[0], ..., A[2n-1]`.\n    # We need to assign each `A[k]` to one of these slots, such that:\n    # 1. The order is preserved: if `A[k]` is assigned to (S_p, pos_x) and `A[j]` (j>k) is assigned to (S_p, pos_y), then `pos_y > pos_x`.\n    # 2. Each slot is used exactly once.\n    #\n    # This is a perfect matching problem on a bipartite graph, but with weights.\n    # Or, it's a dynamic programming problem.\n    #\n    # `dp[k][h_count][m_count]` = maximum sum using `A[k:]` given `h_count` digits for Homer and `m_count` for Marge.\n    # `dp[k][h_count][m_count]` will return the maximum *remaining* sum.\n    #\n    # Base case: `dp[2n][n][n] = 0`\n    #\n    # Recursive step for `dp[k][h_count][m_count]`:\n    #   `digit = int(a_str[k])`\n    #   `max_val = -infinity`\n    #\n    #   If `h_count < n`: (Homer can take `A[k]`)\n    #     `h_power = n - 1 - h_count`\n    #     `val_if_homer_takes = digit * (10**h_power) + dp[k+1][h_count+1][m_count]`\n    #     `max_val = max(max_val, val_if_homer_takes)`\n    #\n    #   If `m_count < n`: (Marge can take `A[k]`)\n    #     `m_power = n - 1 - m_count`\n    #     `val_if_marge_takes = digit * (10**m_power) + dp[k+1][h_count][m_count+1]`\n    #     `max_val = max(max_val, val_if_marge_takes)`\n    #\n    #   Return `max_val`.\n    #\n    # To reconstruct the path, we need to store the choices.\n    # `memo[k][h_count][m_count]` stores the choice ('H' or 'M') that leads to `max_val`.\n    #\n    # States: `k` from 0 to `2n`. `h_count` from 0 to `n`. `m_count` from 0 to `n`.\n    # Total states: `(2n+1) * (n+1) * (n+1)`.\n    # For n=18, this is `37 * 19 * 19 = 13369` states.\n    # Each state takes constant time (two recursive calls).\n    # This is feasible. `13369` is small.\n    #\n    # Let's implement this DP.\n    #\n    # `dp` table will store the maximum sum.\n    # `path` table will store the character ('H' or 'M') for reconstruction.\n    # Initialize `dp` with -1 (or some indicator for uncomputed).\n\n    memo = {}\n    path_choices = {}\n\n    def calculate_max_sum(k, h_count, m_count):\n        if (k, h_count, m_count) in memo:\n            return memo[(k, h_count, m_count)]\n\n        if k == 2 * n:\n            if h_count == n and m_count == n:\n                return 0\n            else:\n                # This state should not be reached if counts are not n, n\n                # as we only make choices if counts are less than n.\n                # Or, if it is reached, it means we couldn't make n moves for both.\n                # This implies a bug in the logic or an invalid state.\n                # However, the problem guarantees n moves for each.\n                # So we will always reach (2n, n, n) if we make valid choices.\n                return -float('inf') # Should not happen\n\n        digit = int(a_str[k])\n        max_val = -float('inf')\n        choice = ''\n\n        # Option 1: Homer takes A[k]\n        if h_count < n:\n            h_power = n - 1 - h_count\n            val_if_homer_takes = digit * (10**h_power) + calculate_max_sum(k + 1, h_count + 1, m_count)\n            if val_if_homer_takes > max_val:\n                max_val = val_if_homer_takes\n                choice = 'H'\n\n        # Option 2: Marge takes A[k]\n        if m_count < n:\n            m_power = n - 1 - m_count\n            val_if_marge_takes = digit * (10**m_power) + calculate_max_sum(k + 1, h_count, m_count + 1)\n            if val_if_marge_takes > max_val:\n                max_val = val_if_marge_takes\n                choice = 'M'\n            # If equal, and 'H' was chosen, we keep 'H' as per \"output any of them\".\n            # If the problem specified lexicographically smallest or largest, we'd need to be careful.\n\n        memo[(k, h_count, m_count)] = max_val\n        path_choices[(k, h_count, m_count)] = choice\n        return max_val\n\n    # Start the DP\n    calculate_max_sum(0, 0, 0)\n\n    # Reconstruct the path\n    result_path = []\n    current_k, current_h, current_m = 0, 0, 0\n    while current_k < 2 * n:\n        choice = path_choices[(current_k, current_h, current_m)]\n        result_path.append(choice)\n        if choice == 'H':\n            current_h += 1\n        else: # choice == 'M'\n            current_m += 1\n        current_k += 1\n\n    print(\"\".join(result_path))\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 432,
        "completion_token_count": 8202,
        "thoughts_token_count": 0
    }
}