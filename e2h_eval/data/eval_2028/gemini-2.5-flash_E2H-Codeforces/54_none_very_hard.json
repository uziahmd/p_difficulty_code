{
    "start": 1758293706.2036307,
    "end": 1758293734.983026,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 54,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mister B and Angle in Polygon\n\nOn one quiet day all of sudden Mister B decided to draw angle a on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex n-gon (regular convex polygon with n sides).That's why Mister B decided to use this polygon. Now Mister B must find three distinct vertices v1, v2, v3 such that the angle  (where v2 is the vertex of the angle, and v1 and v3 lie on its sides) is as close as possible to a. In other words, the value  should be minimum possible.If there are many optimal solutions, Mister B should be satisfied with any of them.\n\n## Input\nFirst and only line contains two space-separated integers n and a (3 ≤ n ≤ 105, 1 ≤ a ≤ 180) — the number of vertices in the polygon and the needed angle, in degrees.\n\n## Output\nPrint three space-separated integers: the vertices v1, v2, v3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to n in clockwise order.\n\n## Example\n### Input\n['3 15', '4 67', '4 68']\n\n### Output\n['1 2 3', '2 1 3', '4 1 2']\n\n## Note\nIn first sample test vertices of regular triangle can create only angle of 60 degrees, that's why every possible angle is correct.Vertices of square can create 45 or 90 degrees angles only. That's why in second sample test the angle of 45 degrees was chosen, since |45 - 67| < |90 - 67|. Other correct answers are: \"3 1 2\", \"3 2 4\", \"4 2 3\", \"4 3 1\", \"1 3 4\", \"1 4 2\", \"2 4 1\", \"4 1 3\", \"3 1 4\", \"3 4 2\", \"2 4 3\", \"2 3 1\", \"1 3 2\", \"1 2 4\", \"4 2 1\".In third sample test, on the contrary, the angle of 90 degrees was chosen, since |90 - 68| < |45 - 68|. Other correct answers are: \"2 1 4\", \"3 2 1\", \"1 2 3\", \"4 3 2\", \"2 3 4\", \"1 4 3\", \"3 4 1\".\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, a = map(int, input().split())\n\n    # The central angle subtended by each side is 360/n.\n    # The angle of a triangle formed by three vertices of a regular n-gon\n    # where the vertex of the angle is v2, and v1 and v3 are on its sides,\n    # can be found using the inscribed angle theorem.\n    # Let v2 be vertex 2 (arbitrarily chosen as a fixed point).\n    # Let v1 be vertex 1 (arbitrarily chosen as a fixed point).\n    # Then v3 can be any other vertex.\n    # The angle at v2 is formed by chords (v2, v1) and (v2, v3).\n    # The measure of an inscribed angle is half the measure of its intercepted arc.\n    # If we fix v2 as vertex 2, and v1 as vertex 1.\n    # The vertices are numbered 1 to n.\n    # Let v2 be vertex 2.\n    # Let v1 be vertex 1.\n    # The angle at v2 is formed by the chord (v2, v1) and (v2, v3).\n    # The arc intercepted by angle v1-v2-v3 is the arc (v1, v3) that does not contain v2.\n    # The number of polygon sides in this arc is (v3 - v1) mod n.\n    # If v1 = 1, v2 = 2, then v3 can be from 3 to n.\n    # The number of sides between v1 and v3 (not passing through v2)\n    # is (v3 - v1).\n    # The central angle for one side is 360/n.\n    # The central angle for (v3 - v1) sides is (v3 - v1) * (360/n).\n    # The inscribed angle is half of this: (v3 - v1) * (180/n).\n    # Let's fix v2 as vertex 2.\n    # Let v1 be vertex 1.\n    # Then v3 can be any vertex from 3 to n.\n    # The number of sides in the arc (v1, v3) is (v3 - v1).\n    # So, for v1=1, v2=2, v3=k (where k is from 3 to n), the angle is (k-1) * (180/n).\n    # The possible values for (k-1) range from (3-1)=2 to (n-1).\n    # So the possible angles are m * (180/n), where m ranges from 2 to n-1.\n\n    # We want to find m such that |m * (180/n) - a| is minimized.\n    # This is equivalent to finding m such that |m - a * (n/180)| is minimized.\n    # Let target_m = a * (n/180).\n    # We need to find an integer m in the range [2, n-1] that is closest to target_m.\n\n    target_m_float = a * n / 180.0\n\n    min_diff = float('inf')\n    best_m = -1\n\n    # Check m values from 2 to n-1\n    # Note: m cannot be 0 or 1 because v1, v2, v3 must be distinct.\n    # If m=0, v1=v3. If m=1, the angle would be 180/n, which means v1 and v3 are adjacent.\n    # The smallest possible m is 2 (e.g., v1=1, v3=3, v2=2).\n    # The largest possible m is n-1 (e.g., v1=1, v3=n, v2=2).\n    # The maximum angle is (n-1) * 180/n. This is the angle when v1 and v3 are adjacent to v2\n    # and on opposite sides of v2. For example, v1=1, v2=2, v3=n. This angle is (n-2)*180/n, not (n-1)*180/n.\n    # Let's re-evaluate the angle formula carefully.\n\n    # Consider vertices 1, 2, ..., n in clockwise order.\n    # Let v2 be the vertex of the angle. We can fix v2 to be vertex 2 without loss of generality.\n    # Let v1 and v3 be the other two distinct vertices.\n    # The arc intercepted by angle v1-v2-v3 is the arc (v1, v3) that does NOT contain v2.\n    # The number of sides in this arc determines the angle.\n    # Let's say v1 is vertex i and v3 is vertex j.\n    # The number of sides between i and j (along the shorter arc) is |i - j|.\n    # If we fix v2 as vertex 2.\n    # v1 can be vertex 1.\n    # v3 can be any vertex from 3 to n.\n    # If v1 = 1, v2 = 2, v3 = k (where k is from 3 to n).\n    # The arc intercepted by angle 1-2-k is the arc from k to 1 (clockwise, not passing through 2).\n    # The number of sides in this arc is (n - k + 1).\n    # No, this is not right.\n    # The number of sides in the arc from v1 to v3 (clockwise) is (v3 - v1) if v3 > v1.\n    # The number of sides in the arc from v3 to v1 (clockwise) is (n - (v1 - v3)) if v1 > v3.\n\n    # Let's use a simpler approach.\n    # Fix v2 as vertex 1.\n    # Fix v1 as vertex 2.\n    # Then v3 can be any vertex from 3 to n.\n    # The angle at v2 (vertex 1) is formed by chords (1,2) and (1,k).\n    # The intercepted arc is from 2 to k (clockwise).\n    # The number of sides in this arc is (k - 2).\n    # So the angle is (k - 2) * (180/n).\n    # Here, k can range from 3 to n.\n    # So (k-2) can range from (3-2)=1 to (n-2).\n    # Let m = k-2. So m ranges from 1 to n-2.\n    # The possible angles are m * (180/n) for m in [1, n-2].\n\n    # We need to find m in [1, n-2] that minimizes |m * (180/n) - a|.\n    # This is equivalent to minimizing |m - a * (n/180)|.\n    # Let target_m = a * (n/180).\n\n    # The possible values of m are integers from 1 to n-2.\n    # We are looking for an integer m in this range that is closest to target_m.\n    # There are two candidates: floor(target_m) and ceil(target_m).\n    # We need to check if these candidates are within the valid range [1, n-2].\n\n    m_cand1 = int(target_m_float)\n    m_cand2 = int(target_m_float) + 1\n\n    best_m_val = -1\n    min_diff = float('inf')\n\n    # Check m_cand1\n    if 1 <= m_cand1 <= n - 2:\n        current_angle = m_cand1 * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = m_cand1\n        elif current_diff == min_diff:\n            # If equal, problem statement says \"any of them\".\n            # We can prioritize smaller m_val or just keep the first one found.\n            # Let's keep the smaller m_val for consistency, though not strictly required.\n            if m_cand1 < best_m_val:\n                best_m_val = m_cand1\n\n    # Check m_cand2\n    if 1 <= m_cand2 <= n - 2:\n        current_angle = m_cand2 * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = m_cand2\n        elif current_diff == min_diff:\n            if m_cand2 < best_m_val:\n                best_m_val = m_cand2\n\n    # Edge case: If target_m_float is outside [1, n-2], or close to boundaries.\n    # If target_m_float < 1, then m=1 is the closest.\n    if target_m_float < 1 and 1 <= n - 2:\n        current_angle = 1 * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = 1\n        elif current_diff == min_diff:\n            if 1 < best_m_val: # This case is only relevant if best_m_val was already 1.\n                best_m_val = 1\n\n    # If target_m_float > n-2, then m=n-2 is the closest.\n    if target_m_float > n - 2 and 1 <= n - 2:\n        current_angle = (n - 2) * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = n - 2\n        elif current_diff == min_diff:\n            if (n - 2) < best_m_val:\n                best_m_val = n - 2\n\n    # This logic for handling boundaries is slightly complex.\n    # A simpler way is to just iterate over the valid range for m.\n    # Since n <= 10^5, iterating over m from 1 to n-2 is too slow if n is large.\n    # No, it's not. The range is small, just 2 candidates.\n    # Let's reconsider.\n    # The actual range for m is [1, n-2].\n    # We need to find m_opt in [1, n-2] such that |m_opt - target_m_float| is minimized.\n    # The closest integer to target_m_float is round(target_m_float).\n    # Let m_rounded = round(target_m_float).\n    # If m_rounded is in [1, n-2], then this is our best_m_val.\n    # If m_rounded < 1, then 1 is the best_m_val.\n    # If m_rounded > n-2, then n-2 is the best_m_val.\n\n    m_rounded = round(target_m_float)\n\n    if m_rounded < 1:\n        best_m_val = 1\n    elif m_rounded > n - 2:\n        best_m_val = n - 2\n    else:\n        best_m_val = m_rounded\n\n    # There's a slight ambiguity with round() in Python 3 (round half to even).\n    # To be safe, let's explicitly check floor and ceil.\n    m_floor = int(target_m_float)\n    m_ceil = int(target_m_float) + 1\n\n    candidates = []\n    if 1 <= m_floor <= n - 2:\n        candidates.append(m_floor)\n    if 1 <= m_ceil <= n - 2:\n        candidates.append(m_ceil)\n\n    # Also consider boundary cases if target_m_float is outside [1, n-2]\n    if target_m_float < 1 and 1 <= n - 2:\n        candidates.append(1)\n    if target_m_float > n - 2 and 1 <= n - 2:\n        candidates.append(n - 2)\n\n    # Remove duplicates and ensure candidates are within range\n    candidates = sorted(list(set([c for c in candidates if 1 <= c <= n - 2])))\n\n    if not candidates: # This should only happen if n-2 < 1, i.e., n < 3. But n >= 3.\n                       # If n=3, then n-2=1. So m=1 is the only option.\n                       # If n=3, target_m_float = a * 3 / 180 = a / 60.\n                       # The only possible m is 1. So angle is 1 * 180/3 = 60 degrees.\n                       # If n=3, candidates will be [1].\n        best_m_val = 1 # Fallback for n=3, m=1.\n\n    min_diff = float('inf')\n    final_best_m = -1\n\n    for m_val in candidates:\n        current_angle = m_val * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            final_best_m = m_val\n\n    # Construct the output vertices.\n    # We fixed v2 as vertex 1.\n    # We fixed v1 as vertex 2.\n    # The number of sides in the arc (v1, v3) is `final_best_m`.\n    # So v3 is `v1 + final_best_m`.\n    # v1 = 2, v2 = 1.\n    # v3 = 2 + final_best_m.\n    # Since vertices are 1 to n, if v3 > n, it wraps around.\n    # However, our formula for m assumes v3 is (k-2) from v1.\n    # If v1=2, v2=1, v3=k. The arc is from 2 to k. The number of sides is k-2.\n    # So k-2 = final_best_m => k = final_best_m + 2.\n    # So the vertices are: v1=2, v2=1, v3=final_best_m + 2.\n    # This works as long as final_best_m + 2 <= n.\n    # Since final_best_m <= n-2, then final_best_m + 2 <= n.\n    # So, v1 = 2, v2 = 1, v3 = final_best_m + 2.\n\n    print(2, 1, final_best_m + 2)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, a = map(int, input().split())\n\n    # The central angle subtended by each side is 360/n.\n    # The angle of a triangle formed by three vertices of a regular n-gon\n    # where the vertex of the angle is v2, and v1 and v3 are on its sides,\n    # can be found using the inscribed angle theorem.\n    # Let v2 be vertex 2 (arbitrarily chosen as a fixed point).\n    # Let v1 be vertex 1 (arbitrarily chosen as a fixed point).\n    # Then v3 can be any other vertex.\n    # The angle at v2 is formed by chords (v2, v1) and (v2, v3).\n    # The measure of an inscribed angle is half the measure of its intercepted arc.\n    # If we fix v2 as vertex 2, and v1 as vertex 1.\n    # The vertices are numbered 1 to n.\n    # Let v2 be vertex 2.\n    # Let v1 be vertex 1.\n    # The angle at v2 is formed by the chord (v2, v1) and (v2, v3).\n    # The arc intercepted by angle v1-v2-v3 is the arc (v1, v3) that does not contain v2.\n    # The number of polygon sides in this arc is (v3 - v1) mod n.\n    # If v1 = 1, v2 = 2, then v3 can be from 3 to n.\n    # The number of sides between v1 and v3 (not passing through v2)\n    # is (v3 - v1).\n    # The central angle for one side is 360/n.\n    # The central angle for (v3 - v1) sides is (v3 - v1) * (360/n).\n    # The inscribed angle is half of this: (v3 - v1) * (180/n).\n    # Let's fix v2 as vertex 2.\n    # Let v1 be vertex 1.\n    # Then v3 can be any vertex from 3 to n.\n    # The number of sides in the arc (v1, v3) is (v3 - v1).\n    # So, for v1=1, v2=2, v3=k (where k is from 3 to n), the angle is (k-1) * (180/n).\n    # The possible values for (k-1) range from (3-1)=2 to (n-1).\n    # So the possible angles are m * (180/n), where m ranges from 2 to n-1.\n\n    # We want to find m such that |m * (180/n) - a| is minimized.\n    # This is equivalent to finding m such that |m - a * (n/180)| is minimized.\n    # Let target_m = a * (n/180).\n    # We need to find an integer m in the range [2, n-1] that is closest to target_m.\n\n    target_m_float = a * n / 180.0\n\n    min_diff = float('inf')\n    best_m = -1\n\n    # Check m values from 2 to n-1\n    # Note: m cannot be 0 or 1 because v1, v2, v3 must be distinct.\n    # If m=0, v1=v3. If m=1, the angle would be 180/n, which means v1 and v3 are adjacent.\n    # The smallest possible m is 2 (e.g., v1=1, v3=3, v2=2).\n    # The largest possible m is n-1 (e.g., v1=1, v3=n, v2=2).\n    # The maximum angle is (n-1) * 180/n. This is the angle when v1 and v3 are adjacent to v2\n    # and on opposite sides of v2. For example, v1=1, v2=2, v3=n. This angle is (n-2)*180/n, not (n-1)*180/n.\n    # Let's re-evaluate the angle formula carefully.\n\n    # Consider vertices 1, 2, ..., n in clockwise order.\n    # Let v2 be the vertex of the angle. We can fix v2 to be vertex 2 without loss of generality.\n    # Let v1 and v3 be the other two distinct vertices.\n    # The arc intercepted by angle v1-v2-v3 is the arc (v1, v3) that does NOT contain v2.\n    # The number of sides in this arc determines the angle.\n    # Let's say v1 is vertex i and v3 is vertex j.\n    # The number of sides between i and j (along the shorter arc) is |i - j|.\n    # If we fix v2 as vertex 2.\n    # v1 can be vertex 1.\n    # v3 can be any vertex from 3 to n.\n    # If v1 = 1, v2 = 2, v3 = k (where k is from 3 to n).\n    # The arc intercepted by angle 1-2-k is the arc from k to 1 (clockwise, not passing through 2).\n    # The number of sides in this arc is (n - k + 1).\n    # No, this is not right.\n    # The number of sides in the arc from v1 to v3 (clockwise) is (v3 - v1) if v3 > v1.\n    # The number of sides in the arc from v3 to v1 (clockwise) is (n - (v1 - v3)) if v1 > v3.\n\n    # Let's use a simpler approach.\n    # Fix v2 as vertex 1.\n    # Fix v1 as vertex 2.\n    # Then v3 can be any vertex from 3 to n.\n    # The angle at v2 (vertex 1) is formed by chords (1,2) and (1,k).\n    # The intercepted arc is from 2 to k (clockwise).\n    # The number of sides in this arc is (k - 2).\n    # So the angle is (k - 2) * (180/n).\n    # Here, k can range from 3 to n.\n    # So (k-2) can range from (3-2)=1 to (n-2).\n    # Let m = k-2. So m ranges from 1 to n-2.\n    # The possible angles are m * (180/n) for m in [1, n-2].\n\n    # We need to find m in [1, n-2] that minimizes |m * (180/n) - a|.\n    # This is equivalent to minimizing |m - a * (n/180)|.\n    # Let target_m = a * (n/180).\n\n    # The possible values of m are integers from 1 to n-2.\n    # We are looking for an integer m in this range that is closest to target_m.\n    # There are two candidates: floor(target_m) and ceil(target_m).\n    # We need to check if these candidates are within the valid range [1, n-2].\n\n    m_cand1 = int(target_m_float)\n    m_cand2 = int(target_m_float) + 1\n\n    best_m_val = -1\n    min_diff = float('inf')\n\n    # Check m_cand1\n    if 1 <= m_cand1 <= n - 2:\n        current_angle = m_cand1 * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = m_cand1\n        elif current_diff == min_diff:\n            # If equal, problem statement says \"any of them\".\n            # We can prioritize smaller m_val or just keep the first one found.\n            # Let's keep the smaller m_val for consistency, though not strictly required.\n            if m_cand1 < best_m_val:\n                best_m_val = m_cand1\n\n    # Check m_cand2\n    if 1 <= m_cand2 <= n - 2:\n        current_angle = m_cand2 * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = m_cand2\n        elif current_diff == min_diff:\n            if m_cand2 < best_m_val:\n                best_m_val = m_cand2\n\n    # Edge case: If target_m_float is outside [1, n-2], or close to boundaries.\n    # If target_m_float < 1, then m=1 is the closest.\n    if target_m_float < 1 and 1 <= n - 2:\n        current_angle = 1 * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = 1\n        elif current_diff == min_diff:\n            if 1 < best_m_val: # This case is only relevant if best_m_val was already 1.\n                best_m_val = 1\n\n    # If target_m_float > n-2, then m=n-2 is the closest.\n    if target_m_float > n - 2 and 1 <= n - 2:\n        current_angle = (n - 2) * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            best_m_val = n - 2\n        elif current_diff == min_diff:\n            if (n - 2) < best_m_val:\n                best_m_val = n - 2\n\n    # This logic for handling boundaries is slightly complex.\n    # A simpler way is to just iterate over the valid range for m.\n    # Since n <= 10^5, iterating over m from 1 to n-2 is too slow if n is large.\n    # No, it's not. The range is small, just 2 candidates.\n    # Let's reconsider.\n    # The actual range for m is [1, n-2].\n    # We need to find m_opt in [1, n-2] such that |m_opt - target_m_float| is minimized.\n    # The closest integer to target_m_float is round(target_m_float).\n    # Let m_rounded = round(target_m_float).\n    # If m_rounded is in [1, n-2], then this is our best_m_val.\n    # If m_rounded < 1, then 1 is the best_m_val.\n    # If m_rounded > n-2, then n-2 is the best_m_val.\n\n    m_rounded = round(target_m_float)\n\n    if m_rounded < 1:\n        best_m_val = 1\n    elif m_rounded > n - 2:\n        best_m_val = n - 2\n    else:\n        best_m_val = m_rounded\n\n    # There's a slight ambiguity with round() in Python 3 (round half to even).\n    # To be safe, let's explicitly check floor and ceil.\n    m_floor = int(target_m_float)\n    m_ceil = int(target_m_float) + 1\n\n    candidates = []\n    if 1 <= m_floor <= n - 2:\n        candidates.append(m_floor)\n    if 1 <= m_ceil <= n - 2:\n        candidates.append(m_ceil)\n\n    # Also consider boundary cases if target_m_float is outside [1, n-2]\n    if target_m_float < 1 and 1 <= n - 2:\n        candidates.append(1)\n    if target_m_float > n - 2 and 1 <= n - 2:\n        candidates.append(n - 2)\n\n    # Remove duplicates and ensure candidates are within range\n    candidates = sorted(list(set([c for c in candidates if 1 <= c <= n - 2])))\n\n    if not candidates: # This should only happen if n-2 < 1, i.e., n < 3. But n >= 3.\n                       # If n=3, then n-2=1. So m=1 is the only option.\n                       # If n=3, target_m_float = a * 3 / 180 = a / 60.\n                       # The only possible m is 1. So angle is 1 * 180/3 = 60 degrees.\n                       # If n=3, candidates will be [1].\n        best_m_val = 1 # Fallback for n=3, m=1.\n\n    min_diff = float('inf')\n    final_best_m = -1\n\n    for m_val in candidates:\n        current_angle = m_val * (180.0 / n)\n        current_diff = abs(current_angle - a)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            final_best_m = m_val\n\n    # Construct the output vertices.\n    # We fixed v2 as vertex 1.\n    # We fixed v1 as vertex 2.\n    # The number of sides in the arc (v1, v3) is `final_best_m`.\n    # So v3 is `v1 + final_best_m`.\n    # v1 = 2, v2 = 1.\n    # v3 = 2 + final_best_m.\n    # Since vertices are 1 to n, if v3 > n, it wraps around.\n    # However, our formula for m assumes v3 is (k-2) from v1.\n    # If v1=2, v2=1, v3=k. The arc is from 2 to k. The number of sides is k-2.\n    # So k-2 = final_best_m => k = final_best_m + 2.\n    # So the vertices are: v1=2, v2=1, v3=final_best_m + 2.\n    # This works as long as final_best_m + 2 <= n.\n    # Since final_best_m <= n-2, then final_best_m + 2 <= n.\n    # So, v1 = 2, v2 = 1, v3 = final_best_m + 2.\n\n    print(2, 1, final_best_m + 2)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 3555,
        "thoughts_token_count": 0
    }
}