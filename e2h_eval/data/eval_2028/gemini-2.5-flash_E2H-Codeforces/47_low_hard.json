{
    "start": 1758284892.868907,
    "end": 1758284918.485456,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Solving the Neko Does Maths Problem: A Pythonic Approach**\n\nOkay, so I'm tackling this Neko Does Maths problem, and it's all about finding this `k` value. The goal is clear: minimize the least common multiple of `a+k` and `b+k`.  I need to pick the *smallest* non-negative integer `k` if there's a tie.  Let's break this down.\n\nFirst, I'm thinking of these new variables: `x = a+k` and `y = b+k`.  The LCM is related to the greatest common divisor: `lcm(x, y) = (x * y) / gcd(x, y)`. Also,  `y - x = b-a`.  Let's call `b - a` as `d`. It's safe to assume `a <= b` since `lcm` is symmetric and we can swap the inputs.\n\nIf `a` and `b` are equal, `d` is zero. That's a simple case!  `lcm(a+k, a+k)` is just `a+k`. To minimize this, `k` must be zero, so the answer in this case is `k = 0`, and the minimum LCM is `a`. Nice and easy.\n\nNow, the interesting part: `a < b`, so `d > 0`.  My intuition tells me to work with divisors.\nI need to find `k` such that `gcd(a+k, d)` is maximized.  Let `g = gcd(a+k, d)`. Since `g` is the GCD of `a+k` and `d`, `a+k` must be divisible by `g`.\nSo, `a+k` needs to be some multiple of `g`, let's say `m * g`. Then, `k` will be `m * g - a`. Since `k >= 0`, `m * g` must be greater than or equal to `a`.  The smallest such value of `m * g` is `ceil(a/g) * g`.\n\nAnd here's the realization: I don't strictly *need* `gcd((a+k)/g, (b+k)/g)` to be 1.  It simplifies the mental picture, but the core formula `lcm(x, y) = (x * y) / gcd(x, y)` works regardless.\nSo, I'm going to iterate through the divisors `g` of `d`. For each `g`, calculate the minimum value of `k` as `ceil(a/g) * g - a`.\nAnd then, for each `k`, compute `lcm(a+k, b+k)`.  Keep track of the minimum LCM seen so far and the corresponding `k` value.  The smallest `k` that gives the minimum LCM is the answer.  Time to get coding!\n",
    "response": "The problem asks us to find a non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If multiple `k` values yield the same minimum LCM, we should choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know the relationship `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nFirst, let's handle the case where `a = b`.\nIf `a = b`, then `lcm(a+k, b+k) = lcm(a+k, a+k) = a+k`. To minimize `a+k`, we should choose the smallest non-negative `k`, which is `k=0`. The minimum LCM would be `a`.\n\nNow, assume `a != b`. Without loss of generality, let `a` be the smaller of the two numbers. If `a > b`, we can swap them. Let `d = |b - a|`. So `d > 0`.\nWe have `gcd(x, y) = gcd(a+k, b+k)`. Using the property `gcd(A, B) = gcd(A, B-A)`, we get:\n`gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a) = gcd(a+k, d)`.\nLet `g = gcd(a+k, d)`.\nSubstituting this into the LCM formula:\n`lcm(a+k, b+k) = ((a+k) * (b+k)) / g`.\n\nSince `g` is a divisor of `d`, `g` must be a divisor of `d`.\nAlso, `g` must divide `a+k`, which means `a+k` must be a multiple of `g`.\nSo, for each divisor `g` of `d`, we are looking for `k` such that `a+k` is a multiple of `g`.\nThe smallest `a+k` that is a multiple of `g` and is greater than or equal to `a` can be found as follows:\nLet `rem = a % g`.\nIf `rem == 0`, then `a` is already a multiple of `g`. We can choose `a+k = a`, which means `k=0`.\nIf `rem != 0`, then `a` is not a multiple of `g`. The smallest multiple of `g` that is greater than or equal to `a` is `a + (g - rem)`.\nSo, `a+k = a + (g - rem)`. This implies `k = g - rem`.\nIn general, `k = (g - (a % g)) % g`. This formula gives `0` if `a % g == 0` and `g - (a % g)` otherwise.\nLet `k_g = (g - (a % g)) % g`. This is the smallest non-negative `k` such that `a+k` is a multiple of `g`.\nFor this `k_g`, the value of `a+k_g` is `a + k_g`. Let's call this `X_g`.\nThe value of `b+k_g` is `b + k_g`. Let's call this `Y_g`.\nThe `gcd(X_g, Y_g)` will be `gcd(X_g, d)`. Since `X_g` is a multiple of `g` and `d` is a multiple of `g`, their GCD must also be a multiple of `g`. Let `g' = gcd(X_g, d)`.\nThe LCM value for this `k_g` will be `(X_g * Y_g) / g'`.\n\nWe need to iterate through all divisors `g` of `d`. For each `g`, we calculate the corresponding `k_g` and the resulting `lcm_g = ((a+k_g) * (b+k_g)) / gcd(a+k_g, d)`. We keep track of the minimum `lcm_g` found and the smallest `k_g` that achieves it.\n\nThe maximum value for `a, b` is `10^9`, so `d` can be up to `10^9`.\nFinding all divisors of `d` takes `O(sqrt(d))` time. For each divisor, we do constant time arithmetic operations.\n`sqrt(10^9)` is approximately `31622`. This is efficient enough.\n\nLet's refine the process:\n1. Initialize `min_lcm` to infinity and `best_k` to 0.\n2. If `a == b`, print `0` and exit.\n3. Ensure `a < b` by swapping if necessary.\n4. Calculate `d = b - a`.\n5. Find all divisors of `d`. Iterate `i` from `1` up to `sqrt(d)`.\n   If `i` divides `d`:\n     `g = i` (first divisor)\n     `k = (g - (a % g)) % g`\n     `current_lcm = ((a+k) * (b+k)) // math.gcd(a+k, d)`\n     If `current_lcm < min_lcm`:\n       `min_lcm = current_lcm`\n       `best_k = k`\n     Else if `current_lcm == min_lcm`:\n       `best_k = min(best_k, k)`\n\n     `g = d // i` (second divisor)\n     If `g != i` (to avoid double-counting perfect square roots):\n       `k = (g - (a % g)) % g`\n       `current_lcm = ((a+k) * (b+k)) // math.gcd(a+k, d)`\n       If `current_lcm < min_lcm`:\n         `min_lcm = current_lcm`\n         `best_k = k`\n       Else if `current_lcm == min_lcm`:\n         `best_k = min(best_k, k)`\n6. Print `best_k`.\n\nExample 1: `a=6, b=10`\n`d = 10 - 6 = 4`.\nDivisors of 4: 1, 2, 4.\n\n- `g = 1`:\n  `k = (1 - (6 % 1)) % 1 = (1 - 0) % 1 = 0`.\n  `a+k = 6`, `b+k = 10`. `gcd(6, 4) = 2`.\n  `lcm = (6 * 10) / 2 = 30`.\n  `min_lcm = 30`, `best_k = 0`.\n\n- `g = 2`:\n  `k = (2 - (6 % 2)) % 2 = (2 - 0) % 2 = 0`.\n  `a+k = 6`, `b+k = 10`. `gcd(6, 4) = 2`.\n  `lcm = (6 * 10) / 2 = 30`.\n  `min_lcm = 30`, `best_k = min(0, 0) = 0`.\n\n- `g = 4`:\n  `k = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2`.\n  `a+k = 6+2 = 8`, `b+k = 10+2 = 12`. `gcd(8, 4) = 4`.\n  `lcm = (8 * 12) / 4 = 24`.\n  `min_lcm = 24`, `best_k = 2`.\n\nFinal `best_k = 2`.\n\nThis approach correctly handles the problem constraints and logic.\n\n```python\nimport math\nimport sys\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    # If a equals b, lcm(a+k, b+k) = a+k.\n    # To minimize a+k, choose k=0.\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a is the smaller number to simplify d = b - a\n    if a > b:\n        a, b = b, a\n\n    d = b - a # d is always positive here\n\n    min_lcm = -1\n    best_k = -1\n\n    # Iterate through all divisors of d\n    # A number n has divisors up to sqrt(n). If i is a divisor, then n/i is also a divisor.\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            # Check divisor g1 = i\n            g1 = i\n            # k is the smallest non-negative integer such that (a+k) is a multiple of g1\n            # (a+k) % g1 == 0  => a % g1 + k % g1 == 0 (mod g1)\n            # k % g1 == -(a % g1) (mod g1)\n            # k = (g1 - (a % g1)) % g1\n            k1 = (g1 - (a % g1)) % g1\n            \n            val_a_k1 = a + k1\n            val_b_k1 = b + k1\n            \n            # lcm(X, Y) = (X * Y) / gcd(X, Y)\n            # gcd(a+k, b+k) = gcd(a+k, d)\n            current_lcm1 = (val_a_k1 * val_b_k1) // math.gcd(val_a_k1, d)\n\n            if min_lcm == -1 or current_lcm1 < min_lcm:\n                min_lcm = current_lcm1\n                best_k = k1\n            elif current_lcm1 == min_lcm:\n                best_k = min(best_k, k1)\n\n            # Check divisor g2 = d // i\n            g2 = d // i\n            if g2 != g1: # Avoid re-checking if d is a perfect square and i == sqrt(d)\n                k2 = (g2 - (a % g2)) % g2\n                \n                val_a_k2 = a + k2\n                val_b_k2 = b + k2\n                \n                current_lcm2 = (val_a_k2 * val_b_k2) // math.gcd(val_a_k2, d)\n\n                if min_lcm == -1 or current_lcm2 < min_lcm:\n                    min_lcm = current_lcm2\n                    best_k = k2\n                elif current_lcm2 == min_lcm:\n                    best_k = min(best_k, k2)\n    \n    print(best_k)\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    # If a equals b, lcm(a+k, b+k) = a+k.\n    # To minimize a+k, choose k=0.\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a is the smaller number to simplify d = b - a\n    if a > b:\n        a, b = b, a\n\n    d = b - a # d is always positive here\n\n    min_lcm = -1\n    best_k = -1\n\n    # Iterate through all divisors of d\n    # A number n has divisors up to sqrt(n). If i is a divisor, then n/i is also a divisor.\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            # Check divisor g1 = i\n            g1 = i\n            # k is the smallest non-negative integer such that (a+k) is a multiple of g1\n            # (a+k) % g1 == 0  => a % g1 + k % g1 == 0 (mod g1)\n            # k % g1 == -(a % g1) (mod g1)\n            # k = (g1 - (a % g1)) % g1\n            k1 = (g1 - (a % g1)) % g1\n            \n            val_a_k1 = a + k1\n            val_b_k1 = b + k1\n            \n            # lcm(X, Y) = (X * Y) / gcd(X, Y)\n            # gcd(a+k, b+k) = gcd(a+k, d)\n            current_lcm1 = (val_a_k1 * val_b_k1) // math.gcd(val_a_k1, d)\n\n            if min_lcm == -1 or current_lcm1 < min_lcm:\n                min_lcm = current_lcm1\n                best_k = k1\n            elif current_lcm1 == min_lcm:\n                best_k = min(best_k, k1)\n\n            # Check divisor g2 = d // i\n            g2 = d // i\n            if g2 != g1: # Avoid re-checking if d is a perfect square and i == sqrt(d)\n                k2 = (g2 - (a % g2)) % g2\n                \n                val_a_k2 = a + k2\n                val_b_k2 = b + k2\n                \n                current_lcm2 = (val_a_k2 * val_b_k2) // math.gcd(val_a_k2, d)\n\n                if min_lcm == -1 or current_lcm2 < min_lcm:\n                    min_lcm = current_lcm2\n                    best_k = k2\n                elif current_lcm2 == min_lcm:\n                    best_k = min(best_k, k2)\n    \n    print(best_k)\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 2602,
        "thoughts_token_count": 871
    }
}