{
    "start": 1758009316.013054,
    "end": 1758009368.2360122,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Breaking Down the Snowflake Graph Problem**\n\nOkay, so I'm presented with a competitive programming problem. The goal is to determine if a given number, *n*, could represent the number of vertices in a \"snowflake\" graph.  I need to understand the structure of this snowflake and derive a formula to determine possible values of *n*.\n\nFirst, let's analyze the construction process. We start with a central vertex, then connect it to *k* other vertices, where *k* must be greater than 1. This gives us *1 + k* vertices so far.  Those *k* vertices are leaf nodes (connected only to the center).  The crucial part is then connecting these leaf nodes. We must do this at least once. Each leaf node now has *k* connections. This generates a geometric sequence as we increase iterations (*d*) where we attach new leaves.\n\nAfter the first iteration (*d = 1*), the graph has *1 + k + k^2* vertices.  Each leaf on the first iteration also gets attached to *k* vertices at the next iteration and so on.\n\nThe sum follows a geometric series: *1 + k + k^2 + ... + k^(d+1)*.  I know the formula for the sum of a geometric series is *(r^(m+1) - 1) / (r - 1)*. In our case, *r* is *k*, and *m* is *d+1*.  So the total number of vertices, *N*, is *(k^(d+2) - 1) / (k - 1)*.\n\nNow, considering the constraints. *k* must be greater than 1, and the step involving connecting leaf nodes must be done at least once (*d >= 1*). This means the exponent of *k* in the formula will be at least 2. The minimum possible snowflake will have *1 + k + k^2* vertices. This seems like a promising starting point for an algorithm. I can use this formula to work through possible values of *n*. I can likely iterate through possible values of *k* and *d* and see if I can get a match.\n",
    "response": "The problem asks us to determine if a given number `n` of vertices can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1. Start with 1 vertex (the center).\n2. Connect the center to `k` new vertices, where `k > 1`.\n3. Each vertex that is connected to only one other vertex (a leaf node) is connected to `k` more new vertices. This step must be done at least once.\n\nLet's count the total number of vertices `N` based on `k` and the number of times step 3 is performed.\n- Initially, 1 vertex.\n- After step 2, `k` new vertices are added. Total: `1 + k`. These `k` vertices are leaf nodes.\n- Step 3 must be done at least once. Let `d` be the number of times step 3 is performed. `d >= 1`.\n    - After the 1st application of step 3: Each of the `k` leaf nodes from the previous step gets `k` new children. So `k * k = k^2` new vertices are added. Total: `1 + k + k^2`. These `k^2` vertices are leaf nodes.\n    - After the 2nd application of step 3 (if `d >= 2`): Each of the `k^2` leaf nodes gets `k` new children. So `k^2 * k = k^3` new vertices are added. Total: `1 + k + k^2 + k^3`.\n    - In general, if step 3 is performed `d` times, the total number of vertices `N` will be:\n      `N = 1 + k + k^2 + ... + k^(d+1)`\n\nThis is a geometric series. The sum can be written as `N = (k^(d+2) - 1) / (k - 1)`.\nThe constraints are `k > 1` and `d >= 1`.\nThis implies that the smallest possible snowflake has `d=1`, meaning `N = 1 + k + k^2`.\nThe smallest possible `k` is `k=2`.\nFor `k=2, d=1`, `N = 1 + 2 + 2^2 = 1 + 2 + 4 = 7`.\nFor `k=3, d=1`, `N = 1 + 3 + 3^2 = 1 + 3 + 9 = 13`.\n\nWe are given `n` and need to check if there exist `k > 1` and `d >= 1` such that `n = 1 + k + ... + k^(d+1)`.\n\nLet `m = d+1`. Since `d >= 1`, we have `m >= 2`.\nSo, `n = 1 + k + k^2 + ... + k^m`, where `k > 1` and `m >= 2`.\n\nWe can iterate through possible values of `m` and `k`.\n\n**Case 1: `m = 2`**\n`n = 1 + k + k^2`.\nThis is a quadratic equation for `k`: `k^2 + k + (1 - n) = 0`.\nWe can solve for `k` using the quadratic formula: `k = (-1 ± sqrt(1 - 4 * 1 * (1 - n))) / (2 * 1)`.\n`k = (-1 ± sqrt(1 - 4 + 4n)) / 2`\n`k = (-1 ± sqrt(4n - 3)) / 2`\nFor `k` to be a valid integer greater than 1, `4n - 3` must be a perfect square, let's say `s^2`.\nAlso, `s` must be positive. Then `k = (-1 + s) / 2`.\nWe need `(-1 + s) / 2 > 1`, which implies `-1 + s > 2`, so `s > 3`.\nSo, for a given `n`, we calculate `val = 4n - 3`. If `val` is a perfect square `s^2` and `s > 3` and `(-1 + s)` is even, then `k = (-1 + s) / 2` is a valid integer `k > 1`.\n\nThe maximum value of `n` is `10^18`.\n`4n - 3` can be up to `4 * 10^18 - 3`. The square root `s` can be up to `sqrt(4 * 10^18) = 2 * 10^9`.\nChecking if `val` is a perfect square and `s > 3` is efficient.\n\n**Case 2: `m >= 3`**\n`n = 1 + k + k^2 + ... + k^m`.\nWe can rewrite this as `n - 1 = k + k^2 + ... + k^m = k(1 + k + ... + k^(m-1))`.\nThis implies `k` must be a divisor of `n - 1`.\nAlso, `n = (k^(m+1) - 1) / (k - 1)`.\nSince `k > 1`, we have `k^m < n`. So `k < n^(1/m)`.\nSince `m >= 3`, `k < n^(1/3)`.\nFor `n = 10^18`, `k < (10^18)^(1/3) = 10^6`.\nThis suggests we can iterate `k` from 2 up to `10^6`. For each `k`, we need to find `m`.\n`n = 1 + k + k^2 + ... + k^m`.\nFor a fixed `k`, we can check if `n` can be represented in this form by calculating the sum iteratively:\n`current_sum = 1`\n`power_k = 1`\n`m = 0`\nWhile `current_sum < n`:\n  `power_k *= k`\n  `current_sum += power_k`\n  `m += 1`\n  If `power_k` overflows (exceeds `n`), we can stop early for this `k`.\nIf `current_sum == n` and `m >= 2`, then `n` is a snowflake number.\n\nThe maximum `k` to check is `10^6`. For each `k`, the number of terms `m` will be `log_k(n)`.\nFor `k=2`, `m` can be up to `log_2(10^18) approx 18 * log_2(10) approx 18 * 3.32 approx 59.79`. So `m` is at most about 60.\nThe total operations for `m >= 3` would be roughly `10^6 * log(n)`. This is `10^6 * 60 = 6 * 10^7`, which is feasible within typical time limits for `t=10^4` test cases. However, `10^4 * 6 * 10^7` is too slow.\n\nWe need to optimize the `m >= 3` case.\nInstead of iterating `k`, we can iterate `m`.\nThe smallest `m` is 3. The largest `m` is `log_2(10^18) approx 60`.\nFor each `m` from 3 to 60:\nWe need to find an integer `k > 1` such that `n = 1 + k + ... + k^m`.\nThis is equivalent to finding an integer `k > 1` such that `(k^(m+1) - 1) / (k - 1) = n`.\nThis is a monotonic function of `k`. As `k` increases, `f(k) = (k^(m+1) - 1) / (k - 1)` increases.\nWe can use binary search for `k`.\nThe lower bound for `k` is 2.\nThe upper bound for `k` is `n^(1/m) + 2` (a loose bound, since `k^m < n`).\nFor `m=3`, `k < n^(1/3)`. Max `k` is `(10^18)^(1/3) = 10^6`.\nFor `m=60`, `k < n^(1/60)`. Max `k` is `(10^18)^(1/60) = (10^3)^(1/10) approx 10^0.3 approx 2`. So `k` can only be 2.\n\nBinary search for `k`:\nFor a fixed `m` (from 3 to 60):\n  Set `low = 2`, `high = min(int(n**(1/m)) + 2, 2 * 10^9)` (or a safe upper bound like `2 * 10^9` to avoid `n**(1/m)` precision issues for small `m`, actually `10^6` is sufficient for `m=3`). A safer upper bound is `2 * 10^9` because `k` can be up to `2 * 10^9` if `n` is `4 * 10^18`. But `k < n^(1/m)` is a tighter bound. Max `k` is `10^6` for `m=3`. So `high = 10^6 + 2` is sufficient.\n  While `low <= high`:\n    `mid = (low + high) // 2`\n    If `mid < 2`, set `mid = 2` and continue, or adjust `low` to `2`.\n    Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n    Be careful with overflow when calculating `mid^j`. If `mid^j` exceeds `n`, `current_sum` will also exceed `n`.\n    A safer way to calculate the sum:\n    `current_sum = 0`\n    `power = 1`\n    For `j` from 0 to `m`:\n      `current_sum += power`\n      If `j < m` and `power > n / mid`: (check for overflow before multiplication)\n        `current_sum = n + 1` (mark as overflow)\n        break\n      `power *= mid`\n    \n    If `current_sum == n`, we found a valid `k`. Return \"YES\".\n    If `current_sum < n`, `mid` is too small. `low = mid + 1`.\n    If `current_sum > n`, `mid` is too large. `high = mid - 1`.\n\nThe number of iterations for `m` is about 60.\nEach binary search takes `log(10^6)` (for `m=3`) or `log(2)` (for `m=60`) iterations. `log(10^6) approx 20`.\nInside the binary search, calculating the sum takes `m` multiplications/additions. Max `m` is 60.\nTotal operations: `60 * 20 * 60 = 72000`. This is very efficient for `t=10^4` test cases. `10^4 * 72000` is too much.\n\nThe calculation of the sum `1 + k + ... + k^m` for a given `k` and `m` can be optimized.\n`current_sum = 0`\n`power_of_k = 1`\nFor `i` from 0 to `m`:\n  `current_sum += power_of_k`\n  If `i < m`:\n    If `power_of_k > n // k`: (check for overflow `power_of_k * k > n`)\n      `current_sum = n + 1` (signal overflow)\n      break\n    `power_of_k *= k`\n\nLet's refine the binary search bounds for `k`.\nFor `m >= 3`:\n`k^m < n` implies `k < n^(1/m)`.\nSo, `k` goes from 2 up to `floor(n^(1/m))`.\nFor `n = 10^18`:\n- `m=3`, `k <= floor((10^18)^(1/3)) = 10^6`.\n- `m=4`, `k <= floor((10^18)^(1/4)) = floor(10^4.5) = floor(31622.7) = 31622`.\n- `m=5`, `k <= floor((10^18)^(1/5)) = floor(10^3.6) = floor(3981.07) = 3981`.\n- ...\n- `m=59`, `k <= floor((10^18)^(1/59)) = floor(10^(18/59)) = floor(10^0.305) = floor(2.018) = 2`.\n- `m=60`, `k <= floor((10^18)^(1/60)) = floor(10^0.3) = floor(1.995) = 1`. This `m=60` means `k` can't be `>1`. So `m` max is 59.\n\nThe maximum value of `m` is 59.\nThe loop for `m` runs from 3 to 59 (57 iterations).\nInside the loop, binary search for `k` from 2 to `n^(1/m)`.\nThe number of iterations in binary search is `log_2(n^(1/m)) = (1/m) * log_2(n)`.\nMax `log_2(10^6)` is about 20.\nThe sum calculation takes `m` steps.\nTotal operations: `sum_{m=3}^{59} (log_2(n^(1/m)) * m)`.\nThis is roughly `sum_{m=3}^{59} (log_2(n))`.\n`57 * log_2(10^18) approx 57 * 60 = 3420`.\nThis is extremely fast per test case. `10^4 * 3420` is still `3.4 * 10^7`, which is acceptable.\n\nLet's combine the logic:\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    if n < 7: # Smallest snowflake is 1+2+2^2 = 7\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    \n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = int(math.isqrt(discriminant)) # isqrt for integer square root\n    \n    if s * s == discriminant:\n        # Check if k is an integer and k > 1\n        # k = (-1 + s) / 2\n        if (s - 1) % 2 == 0: # s-1 must be even\n            k = (s - 1) // 2\n            if k > 1:\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to max_m (approx 59 for n=10^18)\n    # k^m < n => k < n^(1/m)\n    # Max m: 2^m < 10^18 => m < log2(10^18) approx 59.79. So max m is 59.\n    \n    for m in range(3, 61): # m from 3 to 60 (inclusive)\n        # Binary search for k\n        # k must be > 1\n        # Upper bound for k: n^(1/m).\n        # For m=3, k max is 10^6. For m=59, k max is 2.\n        # Use a safe upper bound for binary search, e.g., 2 * 10^6 or n^(1/m) + 2\n        # A tighter upper bound for k for binary search is floor(n**(1/m)) + 2.\n        # If n=10^18, m=3, k_max = 10^6.\n        # If n=10^18, m=59, k_max = 2.\n        \n        low = 2\n        # Calculate high more precisely to avoid floating point issues with n**(1/m)\n        # If k^m < n, then k < n^(1/m).\n        # A safe upper bound for k is max(2, int(n**(1/m)) + 2).\n        # For m=60, (10^18)^(1/60) is approx 1.995, so int is 1. If we add 2, it becomes 3.\n        # Max k could be 10^6.\n        high = min(int(n**(1/m)) + 2, 10**6 + 2) # 10^6+2 is a safe upper bound for k when m >= 3, given n <= 10^18\n\n        # If m is such that n^(1/m) is less than 2, then k cannot be > 1.\n        # E.g., for m=60, n=10^18, n^(1/60) approx 1.995. So k must be 1. Not allowed.\n        # So if high < 2, we can skip this m.\n        if high < 2: \n            continue # or break, since higher m will have even smaller n^(1/m)\n\n        while low <= high:\n            k = (low + high) // 2\n            if k < 2: # Ensure k is always at least 2 for calculations, though low starts at 2.\n                low = 2\n                continue\n\n            current_sum = 0\n            power_of_k = 1\n            overflow = False\n            \n            for _ in range(m + 1): # loop m+1 times for terms 1, k, k^2, ..., k^m\n                current_sum += power_of_k\n                if current_sum > n: # Check sum overflow\n                    overflow = True\n                    break\n                \n                if _ < m: # If not the last term, calculate next power\n                    # Check for power_of_k * k overflow before multiplication\n                    # power_of_k * k > n implies current_sum will exceed n\n                    # Check if power_of_k > n / k (integer division)\n                    if k > n // power_of_k: # This indicates power_of_k * k would exceed n\n                        overflow = True\n                        break\n                    power_of_k *= k\n            \n            if overflow:\n                high = k - 1 # k is too large\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = k + 1 # k is too small\n            else: # current_sum > n (this path should be covered by overflow=True, but as a safeguard)\n                high = k - 1\n                \n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    if n < 7: # Smallest snowflake is 1+2+2^2 = 7\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    \n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = int(math.isqrt(discriminant)) # isqrt for integer square root\n    \n    if s * s == discriminant:\n        # Check if k is an integer and k > 1\n        # k = (-1 + s) / 2\n        if (s - 1) % 2 == 0: # s-1 must be even\n            k = (s - 1) // 2\n            if k > 1:\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to max_m (approx 59 for n=10^18)\n    # k^m < n => k < n^(1/m)\n    # Max m: 2^m < 10^18 => m < log2(10^18) approx 59.79. So max m is 59.\n    \n    for m in range(3, 61): # m from 3 to 60 (inclusive)\n        # Binary search for k\n        # k must be > 1\n        # Upper bound for k: n^(1/m).\n        # For m=3, k max is 10^6. For m=59, k max is 2.\n        # Use a safe upper bound for binary search, e.g., 2 * 10^6 or n^(1/m) + 2\n        # A tighter upper bound for k for binary search is floor(n**(1/m)) + 2.\n        # If n=10^18, m=3, k_max = 10^6.\n        # If n=10^18, m=59, k_max = 2.\n        \n        low = 2\n        # Calculate high more precisely to avoid floating point issues with n**(1/m)\n        # If k^m < n, then k < n^(1/m).\n        # A safe upper bound for k is max(2, int(n**(1/m)) + 2).\n        # For m=60, (10^18)^(1/60) is approx 1.995, so int is 1. If we add 2, it becomes 3.\n        # Max k could be 10^6.\n        high = min(int(n**(1/m)) + 2, 10**6 + 2) # 10^6+2 is a safe upper bound for k when m >= 3, given n <= 10^18\n\n        # If m is such that n^(1/m) is less than 2, then k cannot be > 1.\n        # E.g., for m=60, n=10^18, n^(1/60) approx 1.995. So k must be 1. Not allowed.\n        # So if high < 2, we can skip this m.\n        if high < 2: \n            continue # or break, since higher m will have even smaller n^(1/m)\n\n        while low <= high:\n            k = (low + high) // 2\n            if k < 2: # Ensure k is always at least 2 for calculations, though low starts at 2.\n                low = 2\n                continue\n\n            current_sum = 0\n            power_of_k = 1\n            overflow = False\n            \n            for _ in range(m + 1): # loop m+1 times for terms 1, k, k^2, ..., k^m\n                current_sum += power_of_k\n                if current_sum > n: # Check sum overflow\n                    overflow = True\n                    break\n                \n                if _ < m: # If not the last term, calculate next power\n                    # Check for power_of_k * k overflow before multiplication\n                    # power_of_k * k > n implies current_sum will exceed n\n                    # Check if power_of_k > n / k (integer division)\n                    if k > n // power_of_k: # This indicates power_of_k * k would exceed n\n                        overflow = True\n                        break\n                    power_of_k *= k\n            \n            if overflow:\n                high = k - 1 # k is too large\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = k + 1 # k is too small\n            else: # current_sum > n (this path should be covered by overflow=True, but as a safeguard)\n                high = k - 1\n                \n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 4632,
        "thoughts_token_count": 701
    }
}