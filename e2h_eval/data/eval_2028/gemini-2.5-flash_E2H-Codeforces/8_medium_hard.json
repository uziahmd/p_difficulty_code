{
    "start": 1758015881.826269,
    "end": 1758015972.895669,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Flawed Flow: My Attempt at a Solution**\n\nAlright, let's tackle this \"Flawed Flow\" problem. It's about directing flow in an undirected graph, making sure it satisfies some conditions. The key is that the graph has to be a DAG, meaning no cycles, and all the intermediate vertices need flow conservation. My strategy is going to revolve around these three points:\n\nFirst off, let's make it clear. If an edge is connected to the source (vertex 1), its direction is fixed (outward from 1). This is because the problem said there's no incoming flow to the source. Any time I see an edge connected to 1, I can immediately decide its direction.\n\nNext, I'm thinking about flow conservation.  Each vertex, except the source and sink, has to have the same amount of incoming and outgoing flow. If a vertex's net flow isn't zero, it has to be changed. I am going to keep track of a \"deficit\" for each vertex. It's the amount of flow that the vertex must eventually get rid of (if positive) or receive (if negative). My goal is for this deficit to be zero at every intermediate vertex.\n\nFinally, the no-cycle condition! This is important for the flow to work and makes me think topological sort or a similar ordering-based process is right. I know that if the flow directions are such that I can assign \"potentials\" to each vertex, from high at the source to low at the sink, that I would guarantee no cycles.\n\nSo, here's my idea:\n1.  **Initialization**: Set up a \"deficit\" array for each vertex, a \"direction\" (0/1) array, and an adjacency list.\n2.  **Handle edges from 1**: For edges directly from the source, fix their direction and adjust the deficit of the connected vertex.\n3.  **Use a queue**: Initialize a queue with vertices that have a positive deficit, meaning they have received flow and need to pass it on.\n4.  **Topological Flow**: While the queue isn't empty:\n    *   Pick a vertex from the queue. It has excess flow.\n    *   Find an *undirected* edge connected to this vertex.\n    *   Set the edge's direction so that flow goes *from* the vertex with the positive deficit.\n    *   Update both the deficits of the two vertices involved.\n    *   If the connected vertex is not source or sink, and now has a positive deficit, add it to the queue.\n\nI think this method should work because it ensures flow conservation, and the queue processing avoids cycles.  The key is to always direct flow from a vertex with an excess to a vertex that can absorb it.  I'm hoping to get this sorted, because, frankly, flawed or not, I want this flow!\n",
    "response": "The problem asks us to direct each edge in an undirected graph, given its flow volume, such that three conditions are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the total incoming flow equals the total outgoing flow.\n2.  **Source Constraint:** Vertex 1 (source) has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n\nWe need to output `0` if the flow for the `i`-th edge `(a_i, b_i)` is `a_i -> b_i`, and `1` if it's `b_i -> a_i`.\n\nLet's maintain a `deficit` array for each vertex `v`. `deficit[v]` will represent the net incoming flow to `v` from edges whose directions have already been determined. For intermediate vertices (1 < `v` < `n`), our goal is to make `deficit[v]` eventually zero. For the source (vertex 1), it should have a net outgoing flow, and for the sink (vertex `n`), it should have a net incoming flow.\n\nThe \"no incoming edges to vertex 1\" condition is a strong hint. All edges incident to vertex 1 must be directed away from it. This immediately determines the direction of these edges and updates the `deficit` of their other endpoints.\n\nThe \"no cycles\" condition, combined with flow conservation, suggests a topological ordering. We can process vertices that have an excess of incoming flow and direct their incident undirected edges outwards to satisfy their flow conservation requirement. This process naturally builds a DAG.\n\nHere's the detailed algorithm:\n\n1.  **Initialization:**\n    *   `deficit = [0] * (n + 1)`: An array to store the net incoming flow for each vertex.\n    *   `ans = [-1] * m`: An array to store the direction for each edge. `ans[i] = 0` for `a_i -> b_i`, `ans[i] = 1` for `b_i -> a_i`. Initialize with `-1` to mark edges as undirected.\n    *   `adj_list = [[] for _ in range(n + 1)]`: Adjacency list where `adj_list[u]` stores tuples `(v, c, original_edge_index)` for all edges `(u,v)` that are *not* connected to vertex 1.\n    *   `original_endpoints = [(0, 0)] * m`: An array to store the original `(u, v)` pair for each edge index `i`. This is needed to correctly set `ans[i]` (0 or 1) when directing an edge `u -> v`.\n\n2.  **Process Edges Connected to Source (Vertex 1):**\n    *   Iterate through all `m` input edges `(u, v, c, i)`:\n        *   Store `original_endpoints[i] = (u, v)`.\n        *   If `u == 1`:\n            *   Direct `1 -> v`. Set `ans[i] = 0`.\n            *   Increase `deficit[v]` by `c` (flow coming into `v`).\n        *   Else if `v == 1`:\n            *   Direct `1 -> u`. Set `ans[i] = 1`.\n            *   Increase `deficit[u]` by `c` (flow coming into `u`).\n        *   Else (edge is not connected to vertex 1):\n            *   Add `(v, c, i)` to `adj_list[u]`.\n            *   Add `(u, c, i)` to `adj_list[v]`. These edges remain undirected for now.\n\n3.  **Initialize Queue for Flow Propagation:**\n    *   `q = collections.deque()`: A queue to hold vertices that have an excess of incoming flow (`deficit[v] > 0`) and need to send it out.\n    *   For each vertex `v` from 2 to `n-1` (intermediate vertices):\n        *   If `deficit[v] > 0`, add `v` to `q`.\n\n4.  **Propagate Flow and Direct Remaining Edges:**\n    *   `adj_ptr = [0] * (n + 1)`: An array of pointers, `adj_ptr[u]` keeps track of the next undirected edge in `adj_list[u]` to consider.\n    *   While `q` is not empty:\n        *   Dequeue a vertex `u`.\n        *   **While `u` has an excess flow (`deficit[u] > 0`) and there are available undirected edges from `u`:**\n            *   Get the next available edge from `adj_list[u]` using `adj_ptr[u]`. Let it be `(v, c_edge, edge_idx)`.\n            *   Increment `adj_ptr[u]`.\n            *   **Check if this edge has already been directed:** If `ans[edge_idx]` is not `-1`, it means `v` (or some other vertex) has already directed this edge. Skip to the next edge.\n            *   **Direct `u -> v`:**\n                *   Determine `u_orig, v_orig = original_endpoints[edge_idx]`.\n                *   If `u == u_orig`, then `ans[edge_idx] = 0` (flow `u_orig -> v_orig`).\n                *   Else (`u == v_orig`), then `ans[edge_idx] = 1` (flow `v_orig -> u_orig`, which means `u -> u_orig`).\n                *   Decrease `deficit[u]` by `c_edge` (flow leaving `u`).\n                *   Increase `deficit[v]` by `c_edge` (flow entering `v`).\n                *   **Enqueue `v` if it now has excess flow:** If `v != 1` and `v != n` (i.e., `v` is an intermediate vertex) and `deficit[v] > 0`, add `v` to `q`.\n\n5.  **Output:**\n    *   Print each element of the `ans` array.\n\nThis approach guarantees flow conservation for intermediate nodes because we only stop processing a node `u` when `deficit[u]` becomes 0. It guarantees no incoming edges to vertex 1 by construction. It guarantees no cycles because we always direct flow from a vertex that has received flow to another vertex that needs to receive flow or is the sink. This process effectively builds a topological ordering from source to sink.\n\nExample Walkthrough (from problem statement):\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n1.  **Initialization:**\n    `n=3, m=3`\n    `deficit = [0, 0, 0, 0]`\n    `ans = [-1, -1, -1]`\n    `adj_list = [[], [], [], []]`\n    `original_endpoints = [(0,0), (0,0), (0,0)]`\n\n2.  **Process Edges:**\n    *   Edge 0: `(3, 2, 10, 0)`\n        `original_endpoints[0] = (3, 2)`\n        Not connected to 1. `adj_list[3].append((2, 10, 0))`, `adj_list[2].append((3, 10, 0))`\n    *   Edge 1: `(1, 2, 10, 1)`\n        `original_endpoints[1] = (1, 2)`\n        `u=1`. `ans[1] = 0` (1 -> 2). `deficit[2] += 10`. `deficit` is `[0, 0, 10, 0]`.\n    *   Edge 2: `(3, 1, 5, 2)`\n        `original_endpoints[2] = (3, 1)`\n        `v=1`. `ans[2] = 1` (1 -> 3). `deficit[3] += 5`. `deficit` is `[0, 0, 10, 5]`.\n\n3.  **Initialize Queue:**\n    `q = collections.deque()`\n    `v=2`: `deficit[2]=10 > 0`. `q.append(2)`.\n    `v=3`: `deficit[3]=5 > 0`. `q.append(3)`. (Note: `n=3` is the sink, so `v=3` is `n`. The condition `v != n` means `q.append(3)` should not happen here. This is important. `q` should only contain intermediate nodes that need to balance their flow).\n    Corrected: `q` should only append `v` if `1 < v < n`. So for `n=3`, only `v=2` is an intermediate node.\n    `q = deque([2])`\n\n4.  **Propagate Flow:**\n    `adj_ptr = [0, 0, 0, 0]`\n    *   Dequeue `u = 2`. `deficit[2] = 10 > 0`.\n        `adj_ptr[2] = 0`. `adj_list[2]` is `[(3, 10, 0)]`.\n        Get `(v=3, c_edge=10, edge_idx=0)`. `adj_ptr[2]` becomes 1.\n        `ans[0]` is `-1`.\n        `u_orig, v_orig = original_endpoints[0]` which is `(3, 2)`.\n        `u` is `2`. `v_orig` is `2`. So `u == v_orig`.\n        `ans[0] = 1` (direction `v_orig -> u_orig`, i.e., `2 -> 3`).\n        `deficit[2] -= 10`. `deficit` is `[0, 0, 0, 5]`.\n        `deficit[3] += 10`. `deficit` is `[0, 0, 0, 15]`.\n        `v=3`. `v == n`. So `v` is not added to `q`.\n        `deficit[2]` is now 0. Loop for `u=2` ends.\n    *   `q` is empty.\n\n5.  **Output:**\n    `ans = [1, 0, 1]`\n    Output:\n    1\n    0\n    1\n    This matches the example output.\n\n```python\nimport collections\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # deficit[v] stores the net incoming flow for vertex v\n    # We want deficit[v] to be 0 for 1 < v < n\n    deficit = [0] * (n + 1)\n\n    # ans[i] stores the direction of the i-th edge\n    # 0 for a_i -> b_i, 1 for b_i -> a_i\n    # Initialize with -1 to mark edges as undirected\n    ans = [-1] * m\n\n    # adj_list[u] stores (neighbor, flow_capacity, original_edge_index) for edges NOT connected to vertex 1\n    adj_list = [[] for _ in range(n + 1)]\n\n    # original_endpoints[i] stores (u_orig, v_orig) for the i-th edge\n    # This is needed to correctly set ans[i] (0 or 1) based on which endpoint is 'u'\n    original_endpoints = [(0, 0)] * m\n\n    # Read all edges and process those connected to the source (vertex 1)\n    # Store others in adj_list\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        original_endpoints[i] = (u, v)\n\n        if u == 1:\n            ans[i] = 0  # 1 -> v\n            deficit[v] += c\n        elif v == 1:\n            ans[i] = 1  # 1 -> u\n            deficit[u] += c\n        else:\n            # Edge not connected to source, add to adjacency lists for later processing\n            adj_list[u].append((v, c, i))\n            adj_list[v].append((u, c, i))\n\n    # Queue for vertices that have excess incoming flow and need to send it out\n    q = collections.deque()\n\n    # Add intermediate vertices (1 < v < n) with positive deficit to the queue\n    for v in range(2, n): # n is the sink, so it's not an intermediate vertex\n        if deficit[v] > 0:\n            q.append(v)\n\n    # Pointers for iterating through adj_list for each vertex\n    # adj_ptr[u] indicates the next edge to consider in adj_list[u]\n    adj_ptr = [0] * (n + 1)\n\n    # Process vertices in the queue to propagate flow and direct remaining edges\n    while q:\n        u = q.popleft()\n\n        # u has excess flow (deficit[u] > 0) that needs to be sent out\n        # Iterate through its undirected edges\n        while deficit[u] > 0 and adj_ptr[u] < len(adj_list[u]):\n            v, c_edge, edge_idx = adj_list[u][adj_ptr[u]]\n            adj_ptr[u] += 1\n\n            # If this edge has already been directed by its other endpoint (v), skip it\n            if ans[edge_idx] != -1:\n                continue\n\n            # Direct the edge u -> v\n            u_orig, v_orig = original_endpoints[edge_idx]\n            if u == u_orig:\n                ans[edge_idx] = 0  # Flow is u_orig -> v_orig\n            else:  # u == v_orig\n                ans[edge_idx] = 1  # Flow is v_orig -> u_orig (i.e., u -> u_orig)\n\n            # Update deficits\n            deficit[u] -= c_edge\n            deficit[v] += c_edge\n\n            # If neighbor v is an intermediate vertex and now has excess flow, add it to queue\n            if 1 < v < n and deficit[v] > 0:\n                q.append(v)\n    \n    # Print the results\n    for direction in ans:\n        sys.stdout.write(str(direction) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import collections\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # deficit[v] stores the net incoming flow for vertex v\n    # We want deficit[v] to be 0 for 1 < v < n\n    deficit = [0] * (n + 1)\n\n    # ans[i] stores the direction of the i-th edge\n    # 0 for a_i -> b_i, 1 for b_i -> a_i\n    # Initialize with -1 to mark edges as undirected\n    ans = [-1] * m\n\n    # adj_list[u] stores (neighbor, flow_capacity, original_edge_index) for edges NOT connected to vertex 1\n    adj_list = [[] for _ in range(n + 1)]\n\n    # original_endpoints[i] stores (u_orig, v_orig) for the i-th edge\n    # This is needed to correctly set ans[i] (0 or 1) based on which endpoint is 'u'\n    original_endpoints = [(0, 0)] * m\n\n    # Read all edges and process those connected to the source (vertex 1)\n    # Store others in adj_list\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        original_endpoints[i] = (u, v)\n\n        if u == 1:\n            ans[i] = 0  # 1 -> v\n            deficit[v] += c\n        elif v == 1:\n            ans[i] = 1  # 1 -> u\n            deficit[u] += c\n        else:\n            # Edge not connected to source, add to adjacency lists for later processing\n            adj_list[u].append((v, c, i))\n            adj_list[v].append((u, c, i))\n\n    # Queue for vertices that have excess incoming flow and need to send it out\n    q = collections.deque()\n\n    # Add intermediate vertices (1 < v < n) with positive deficit to the queue\n    for v in range(2, n): # n is the sink, so it's not an intermediate vertex\n        if deficit[v] > 0:\n            q.append(v)\n\n    # Pointers for iterating through adj_list for each vertex\n    # adj_ptr[u] indicates the next edge to consider in adj_list[u]\n    adj_ptr = [0] * (n + 1)\n\n    # Process vertices in the queue to propagate flow and direct remaining edges\n    while q:\n        u = q.popleft()\n\n        # u has excess flow (deficit[u] > 0) that needs to be sent out\n        # Iterate through its undirected edges\n        while deficit[u] > 0 and adj_ptr[u] < len(adj_list[u]):\n            v, c_edge, edge_idx = adj_list[u][adj_ptr[u]]\n            adj_ptr[u] += 1\n\n            # If this edge has already been directed by its other endpoint (v), skip it\n            if ans[edge_idx] != -1:\n                continue\n\n            # Direct the edge u -> v\n            u_orig, v_orig = original_endpoints[edge_idx]\n            if u == u_orig:\n                ans[edge_idx] = 0  # Flow is u_orig -> v_orig\n            else:  # u == v_orig\n                ans[edge_idx] = 1  # Flow is v_orig -> u_orig (i.e., u -> u_orig)\n\n            # Update deficits\n            deficit[u] -= c_edge\n            deficit[v] += c_edge\n\n            # If neighbor v is an intermediate vertex and now has excess flow, add it to queue\n            if 1 < v < n and deficit[v] > 0:\n                q.append(v)\n    \n    # Print the results\n    for direction in ans:\n        sys.stdout.write(str(direction) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 3373,
        "thoughts_token_count": 6494
    }
}