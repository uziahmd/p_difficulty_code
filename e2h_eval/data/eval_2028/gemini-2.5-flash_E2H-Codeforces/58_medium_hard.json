{
    "start": 1758294903.9340625,
    "end": 1758295003.243359,
    "start-formatted": "2025-09-20 00:15 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Minimum Edges for Odd Cycle**\n\nOkay, so I'm tasked with figuring out the fewest edges I need to add to a graph to create a cycle with an odd number of edges, and how many ways I can do it.  First things first: an odd cycle means an odd number of edges, and it has to be simple, meaning no repeated vertices.  Also, since we can't add loops or parallel edges, a cycle needs at least three vertices.  The graph starts undirected, with no loops or multiple edges.\n\nI need to start by figuring out if the graph is bipartite.  If it already has an odd cycle, I'm done – I don't need to add any edges (`t = 0`), and there's only one way to do that (`w = 1`). I can check for bipartiteness by using BFS or DFS with 2-coloring. If I run into an edge connecting nodes of the same color, it's not bipartite, and I've got my odd cycle.\n\nIf the graph *is* bipartite, then I need to add edges (`t > 0`). To create an odd cycle, I have to add an edge between two vertices that are in the same partition of a connected component. This new edge creates an odd cycle because the path between those nodes within the original component is even. So, the absolute minimum number of edges to add is one (`t = 1`).\n\nTo get the number of ways (`w`), I do the 2-coloring, then for each connected component, I count the number of vertices in each partition (call them `cnt0` and `cnt1`). The number of ways to add an edge within a partition is `cnt0 * (cnt0 - 1) / 2 + cnt1 * (cnt1 - 1) / 2`.  I sum these up over all connected components, and that's my `w`.\n\nNow, what if `t=1` isn't possible? This means I can't add a single edge to any connected component and create an odd cycle. This happens if, in every component, either `cnt0` or `cnt1` is at most 1, meaning all components are either isolated vertices or just single edges.\n\nIf `t=1` is impossible, then I need to add at least two edges. So what are the possibilities here?\n\nIf for *every* connected component, when I run 2-coloring, *both* partition sizes are at most 1, this means that every connected component is either an isolated vertex or a single edge. In that situation, I definitely *can't* add only one edge to form an odd cycle.\n\nSo if that's the case, and all components are isolated vertices or edges, I need to look at cases of `t=2`. I want to form an odd cycle with the added edges. Let's say I add two edges. Then to make an odd cycle, I can form 3 vertex cycle, so I need to find three vertices and connect them with those added edges.\n\nIf I don't have enough vertices and edges and everything is isolated. If I have three isolated nodes, I can add edges between them to create an odd cycle of three edges (`t=3`).  If I have at least one isolated vertex and at least one edge component, I can connect them to form a 3-cycle using two added edges (`t=2`). The edges will connect these components. The remaining question is, if I have at least two edges and no isolated vertices, and how I can add the edges. In a graph with connected vertices only with one edge, to form an odd cycle, I need to make a 3-cycle by connecting two edges, so the minimum number is two.\n\nLet's summarize: If there's an odd cycle, `t=0`, `w=1`. If the graph is bipartite, I check: If adding one edge will create an odd cycle (`t=1`), then I calculate `w`. If not, and all the components are single edges or single vertices, I add 2 or 3 edges, depending on the number of components to create an odd cycle.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. This property is key.\n\n**Step 1: Check for existing odd cycles (t=0)**\n\nWe can use a 2-coloring algorithm (BFS or DFS) to check if the graph is bipartite.\nFor each connected component:\n1.  Start a traversal (e.g., BFS) from an unvisited vertex, assigning it color 0.\n2.  Assign its neighbors color 1, neighbors of color 1 vertices color 0, and so on.\n3.  If we encounter an edge `(u, v)` where `u` and `v` already have the same color, then the graph is not bipartite, and we have found an odd cycle.\n\nIf an odd cycle is found during this process:\n`t = 0`\n`w = 1` (There is 1 way to add 0 edges).\nWe can stop here and print `0 1`.\n\n**Step 2: If the graph is bipartite, find t=1 ways**\n\nIf the graph is bipartite, `t` must be at least 1. To form an odd cycle by adding a single edge `(u, v)`:\n1.  `u` and `v` must be in the same connected component.\n2.  `u` and `v` must have the same color in the 2-coloring of that component.\n3.  There must not be an existing edge between `u` and `v`.\n4.  `u` must not be equal to `v` (no loops).\n\nLet's continue the 2-coloring process. For each connected component `C`:\n-   Let `cnt0` be the number of vertices assigned color 0 in `C`.\n-   Let `cnt1` be the number of vertices assigned color 1 in `C`.\n-   The number of pairs `(u, v)` within `C` where both `u, v` have color 0 is `cnt0 * (cnt0 - 1) / 2`.\n-   The number of pairs `(u, v)` within `C` where both `u, v` have color 1 is `cnt1 * (cnt1 - 1) / 2`.\n-   Sum these counts over all connected components. Let this be `potential_w1`.\n\nSince the graph is bipartite, no existing edge connects two vertices of the same color. So, all `potential_w1` pairs represent valid ways to add one edge to form an odd cycle.\nIf `potential_w1 > 0`:\n`t = 1`\n`w = potential_w1`\nWe can stop here and print `1 potential_w1`.\n\n**Step 3: If t=1 is not possible (w=0 for t=1), find t=2 or t=3 ways**\n\nIf `potential_w1 = 0`, it means that for every connected component `C`, both `cnt0 * (cnt0 - 1) / 2` and `cnt1 * (cnt1 - 1) / 2` are zero. This implies `cnt0 <= 1` and `cnt1 <= 1` for every component.\nTherefore, every connected component must have at most 2 vertices. This means each component is either:\n-   An isolated vertex (e.g., `v`), where `cnt0=1, cnt1=0` (or vice versa).\n-   A single edge (e.g., `u-v`), where `cnt0=1, cnt1=1` (after coloring `u` as 0 and `v` as 1).\n\nIn this scenario, `t` must be at least 2.\n\nLet `N_iso` be the number of isolated vertices.\nLet `N_edge` be the number of edges in the graph (which corresponds to `N_edge` components of type `u-v`).\n\n**Case 3a: t=2 is possible**\nTo form an odd cycle with two added edges, the simplest is a 3-cycle `a-b-c-a` where one edge already exists and two are added.\nThis requires:\n-   An existing edge `(a, b)`.\n-   An isolated vertex `c`.\n-   We add edges `(b, c)` and `(c, a)`. This forms a 3-cycle `a-b-c-a`.\nThis is possible if `N_edge >= 1` and `N_iso >= 1`.\nNumber of ways:\n-   Choose an existing edge `(a, b)`: `N_edge` ways.\n-   Choose an isolated vertex `c`: `N_iso` ways.\nEach choice forms a unique set of 2 added edges: `{(a,c), (b,c)}`.\nSo, `t = 2` and `w = N_edge * N_iso`.\nWe can stop here and print `2 (N_edge * N_iso)`.\n\n**Case 3b: t=2 is not possible, find t=3 ways**\n\nIf `N_edge = 0` or `N_iso = 0` (so `t=2` is not possible using the above method), `t` must be at least 3.\n\nSubcase 3b.1: `N_edge = 0`\nAll `n` vertices are isolated. We need at least 3 vertices to form an odd cycle.\n-   Choose 3 isolated vertices `v_1, v_2, v_3`.\n-   Add edges `(v_1, v_2)`, `(v_2, v_3)`, `(v_3, v_1)`. This forms a 3-cycle.\nThis is possible if `N_iso >= 3`.\nNumber of ways: `C(N_iso, 3) = N_iso * (N_iso - 1) * (N_iso - 2) / 6`.\nSo, `t = 3` and `w = C(N_iso, 3)`.\n(If `N_iso < 3`, it's impossible to form a cycle, but `n >= 3` is usually implied for cycles)\n\nSubcase 3b.2: `N_iso = 0`\nAll `n` vertices are part of single edges. `n` must be even.\nWe need to form an odd cycle. Since all components are `u-v` (length 1 paths), any path between two vertices `x, y` in different components `C_i, C_j` has length 0. A path within a component `u_k-v_k` has length 1.\nConsider two distinct components `C_1 = (u_1-v_1)` and `C_2 = (u_2-v_2)`.\nWe can form a 3-cycle by picking one vertex from `C_1` (say `u_1`) and connecting it to both vertices of `C_2` (`u_2` and `v_2`).\n-   Add edges `(u_1, u_2)` and `(u_1, v_2)`.\n-   The cycle is `u_1 - u_2 - v_2 - u_1`. The edge `(u_2, v_2)` already exists.\nThis uses 2 added edges. This is `t=2`.\nNumber of ways:\n-   Choose two distinct edges `(u_1, v_1)` and `(u_2, v_2)`: `C(N_edge, 2)` ways.\n-   From the first chosen edge, pick one vertex (e.g., `u_1` or `v_1`): 2 ways.\nSo, `t = 2` and `w = C(N_edge, 2) * 2 = N_edge * (N_edge - 1)`.\nThis case falls under `t=2` and should be checked before `t=3`.\n\nLet's refine the `t=2` logic:\n`t=2` is possible if:\n1.  `N_edge >= 1` and `N_iso >= 1`. (Ways: `N_edge * N_iso`)\n2.  `N_iso = 0` and `N_edge >= 2`. (Ways: `N_edge * (N_edge - 1)`)\n\nThese two conditions are mutually exclusive (`N_iso >= 1` vs `N_iso = 0`). So we can sum the ways if both conditions are met, but they can't be.\nIt means:\nIf `N_edge >= 1` and `N_iso >= 1`: `t=2, w = N_edge * N_iso`.\nElse if `N_iso = 0` and `N_edge >= 2`: `t=2, w = N_edge * (N_edge - 1)`.\nElse (`N_edge = 0` or `N_edge = 1` and `N_iso = 0`): `t=3`.\n    If `N_edge = 0`: `t=3, w = C(N_iso, 3)`.\n    If `N_edge = 1` and `N_iso = 0`: This implies `n=2`. Cannot form a cycle of more than one vertex. But `n` can be up to `200000`. So this case means `n=2`. A cycle must have at least 3 vertices. So if `n < 3`, it's impossible. The problem states \"cycle of more than one vertex\", which usually implies at least 3 vertices for simple cycles. If `n=0,1,2`, output `3 1` for `n=3,m=0` example implies we should handle `n<3` as well. The example `3 0` output `3 1` means `N_iso=3, N_edge=0`, so `C(3,3)=1`. If `n=2, m=0`, `N_iso=2, N_edge=0`, `C(2,3)=0`. So `w=0` means it's impossible. The problem statement does not specify what to print if impossible. Assume `n>=3` for a cycle.\n\n**Final Algorithm:**\n\n1.  **Initialize:** `visited` array, `color` array, adjacency list `adj`.\n    `is_bipartite = True`, `num_isolated_vertices = 0`, `num_edges = 0`.\n    `ways_t1 = 0`.\n2.  **Iterate through vertices 1 to n:**\n    If vertex `i` is not visited:\n        Start BFS/DFS from `i`.\n        `current_component_nodes = []`\n        `q = deque([(i, 0)])` (vertex, color)\n        `visited[i] = True`\n        `color[i] = 0`\n        `cnt0 = 0`, `cnt1 = 0`\n        `component_edges = 0`\n        While `q` is not empty:\n            `u, c = q.popleft()`\n            `current_component_nodes.append(u)`\n            If `c == 0`: `cnt0 += 1`\n            Else: `cnt1 += 1`\n            For each `v` in `adj[u]`:\n                `component_edges += 1` (count each edge twice, once for u, once for v)\n                If `v` is not visited:\n                    `visited[v] = True`\n                    `color[v] = 1 - c`\n                    `q.append((v, 1 - c))`\n                Else if `color[v] == c`:\n                    `is_bipartite = False`\n        `component_edges /= 2` (actual edges in this component)\n        If `is_bipartite`:\n            If `len(current_component_nodes) == 1`:\n                `num_isolated_vertices += 1`\n            Else:\n                `num_edges += component_edges` (this counts edges for non-isolated components)\n                `ways_t1 += cnt0 * (cnt0 - 1) // 2`\n                `ways_t1 += cnt1 * (cnt1 - 1) // 2`\n        Else:\n            Print `0 1` and exit.\n\n3.  **After checking all components:**\n    If `is_bipartite` is still `True`:\n        If `ways_t1 > 0`:\n            Print `1 ways_t1`.\n        Else (`ways_t1 == 0`):\n            This implies `cnt0 <= 1` and `cnt1 <= 1` for all components.\n            All components are either isolated vertices or single edges.\n            `num_edges` now holds the count of `u-v` type components.\n            If `num_isolated_vertices >= 1` and `num_edges >= 1`:\n                Print `2 (num_isolated_vertices * num_edges)`.\n            Else if `num_isolated_vertices == 0` and `num_edges >= 2`:\n                Print `2 (num_edges * (num_edges - 1))`.\n            Else if `num_isolated_vertices >= 3` and `num_edges == 0`:\n                Print `3 (num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6)`.\n            Else:\n                This implies `n < 3` or `n=3` with `N_iso=1, N_edge=1` (e.g. `1-2, 3`), where no odd cycle can be formed with 2 or 3 edges. The problem implies a cycle can always be formed. Let's re-check constraints and examples. Example `3 0` gives `3 1`. `N_iso=3, N_edge=0`. My logic gives `3 (3*2*1/6) = 3 1`. Example `4 4` gives `1 2`. My logic: `1-2, 1-3, 4-2, 4-3`. Component 1: `1,2,3,4`. Color `1:0, 2:1, 3:1, 4:0`. `cnt0=2 (1,4), cnt1=2 (2,3)`. `ways_t1 = (2*1/2) + (2*1/2) = 1+1=2`. `1 2`. This matches.\n\nThe `num_edges` in my algorithm should count the number of components that are single edges.\nLet's refine the counting of `N_iso` and `N_edge_components`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_input.append((u, v))\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n\n    is_bipartite_graph = True\n    ways_t1 = 0\n    num_isolated_vertices = 0\n    num_edge_components = 0 # Number of connected components that are single edges\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            visited[i] = True\n            color[i] = 0\n            \n            component_nodes = []\n            component_edges_count = 0 # Count actual edges in this component\n            \n            current_component_is_bipartite = True\n            \n            local_cnt0 = 0\n            local_cnt1 = 0\n            \n            head = 0\n            while head < len(q):\n                u, c = q[head]\n                head += 1\n\n                component_nodes.append(u)\n\n                if c == 0:\n                    local_cnt0 += 1\n                else:\n                    local_cnt1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - c\n                        q.append((v, 1 - c))\n                    elif color[v] == c:\n                        current_component_is_bipartite = False\n                        is_bipartite_graph = False\n            \n            # Count edges in the component\n            for u_comp in component_nodes:\n                for v_comp in adj[u_comp]:\n                    # Only count if (u_comp, v_comp) is in this component\n                    # And to avoid double counting, only count if u_comp < v_comp\n                    if u_comp < v_comp and visited[v_comp] and color[v_comp] != -1: # check if v_comp belongs to this component\n                        component_edges_count += 1\n\n            if not current_component_is_bipartite:\n                # If any component is not bipartite, the whole graph is not bipartite\n                # We already set is_bipartite_graph = False\n                # No need to process further for t=1, t=2 etc.\n                pass # The outer loop will break after this iteration if is_bipartite_graph is False\n\n            if current_component_is_bipartite:\n                if len(component_nodes) == 1 and component_edges_count == 0:\n                    num_isolated_vertices += 1\n                elif len(component_nodes) == 2 and component_edges_count == 1:\n                    num_edge_components += 1\n                else:\n                    # For a bipartite component with more than 2 vertices, or more than 1 edge\n                    # We can potentially add 1 edge to form an odd cycle\n                    ways_t1 += local_cnt0 * (local_cnt0 - 1) // 2\n                    ways_t1 += local_cnt1 * (local_cnt1 - 1) // 2\n            \n            # Optimization: If an odd cycle is found, we can immediately output 0 1\n            if not is_bipartite_graph:\n                print(\"0 1\")\n                return\n\n    # If we reach here, the entire graph is bipartite\n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n    else:\n        # All connected components are either isolated vertices or single edges\n        # t=1 is not possible\n        \n        # Check for t=2\n        ways_t2 = 0\n        if num_isolated_vertices >= 1 and num_edge_components >= 1:\n            # Pick one isolated vertex, and one edge component (u-v)\n            # Add edges from isolated vertex 'c' to 'u' and 'v'\n            ways_t2 = num_isolated_vertices * num_edge_components\n        elif num_isolated_vertices == 0 and num_edge_components >= 2:\n            # All components are single edges. Pick two distinct edge components (u1-v1) and (u2-v2)\n            # Pick one vertex from (u1-v1), say u1. Connect u1 to u2 and v2.\n            # This forms u1-u2-v2-u1 cycle, where u2-v2 is an existing edge.\n            ways_t2 = num_edge_components * (num_edge_components - 1)\n\n        if ways_t2 > 0:\n            print(f\"2 {ways_t2}\")\n        else:\n            # t=2 is not possible. Check for t=3.\n            # This means either num_isolated_vertices < 1 or num_edge_components < 1\n            # AND (num_isolated_vertices < 2 or num_edge_components < 2)\n            # AND (num_isolated_vertices == 0 or num_edge_components == 0)\n            \n            # Only remaining possibility for t=3 is connecting 3 isolated vertices\n            # (or other complex scenarios, but 3 isolated vertices is the simplest)\n            \n            # If all are isolated vertices:\n            if num_isolated_vertices >= 3 and num_edge_components == 0:\n                ways_t3 = num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6\n                print(f\"3 {ways_t3}\")\n            else:\n                # This case should ideally not be reached if n >= 3.\n                # It means we have n=0,1,2 or n=3 with N_iso=1, N_edge=1 which is not 3 vertices.\n                # Example: n=2, m=0 -> N_iso=2, N_edge_components=0. ways_t3 = 0.\n                # The problem statement implies a solution always exists.\n                # For n=2, m=1 (1-2), N_iso=0, N_edge_components=1. ways_t2=0, ways_t3=0.\n                # This indicates that the problem implicitly assumes a minimum of 3 vertices are available to form a cycle.\n                # If n < 3, it's impossible to form a cycle.\n                # For n=3, m=0, N_iso=3, N_edge_components=0, ways_t3 = 1.\n                # For n=3, m=1 (1-2), N_iso=1, N_edge_components=1. ways_t2 = 1*1 = 1.\n                # For n=3, m=2 (1-2, 2-3), component 1-2-3 (path). cnt0=2, cnt1=1. ways_t1 = 2*1/2 = 1.\n                # It seems my logic covers all cases where n >= 3.\n                # If n < 3, it's impossible. The problem gives 3 0 -> 3 1.\n                # So if n < 3 it would be 3 0.\n                # Given problem constraints N up to 200,000, M up to 200,000.\n                # My logic seems sound for n >= 3.\n                # If we reach here, and n >= 3, it implies the graph is very sparse, e.g., n=4, m=1 (1-2), N_iso=2, N_edge_components=1.\n                # ways_t2 = 2*1=2.\n                # So the `else` block should not be reached for n >= 3.\n                # If it is reached, it implies `t` is even higher, but the problem implies 3 is max `t`.\n                # For competitive programming, if this state is reached, it implies 0 ways or an error in my logic.\n                # Let's assume the provided logic covers all valid scenarios for `t` up to 3.\n                pass # This branch should ideally not be hit if n >= 3\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_input.append((u, v))\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n\n    is_bipartite_graph = True\n    ways_t1 = 0\n    num_isolated_vertices = 0\n    num_edge_components = 0 # Number of connected components that are single edges\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            visited[i] = True\n            color[i] = 0\n            \n            component_nodes = []\n            component_edges_count = 0 # Count actual edges in this component\n            \n            current_component_is_bipartite = True\n            \n            local_cnt0 = 0\n            local_cnt1 = 0\n            \n            head = 0\n            while head < len(q):\n                u, c = q[head]\n                head += 1\n\n                component_nodes.append(u)\n\n                if c == 0:\n                    local_cnt0 += 1\n                else:\n                    local_cnt1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - c\n                        q.append((v, 1 - c))\n                    elif color[v] == c:\n                        current_component_is_bipartite = False\n                        is_bipartite_graph = False\n            \n            # Count edges in the component\n            for u_comp in component_nodes:\n                for v_comp in adj[u_comp]:\n                    # Only count if (u_comp, v_comp) is in this component\n                    # And to avoid double counting, only count if u_comp < v_comp\n                    if u_comp < v_comp and visited[v_comp] and color[v_comp] != -1: # check if v_comp belongs to this component\n                        component_edges_count += 1\n\n            if not current_component_is_bipartite:\n                # If any component is not bipartite, the whole graph is not bipartite\n                # We already set is_bipartite_graph = False\n                # No need to process further for t=1, t=2 etc.\n                pass # The outer loop will break after this iteration if is_bipartite_graph is False\n\n            if current_component_is_bipartite:\n                if len(component_nodes) == 1 and component_edges_count == 0:\n                    num_isolated_vertices += 1\n                elif len(component_nodes) == 2 and component_edges_count == 1:\n                    num_edge_components += 1\n                else:\n                    # For a bipartite component with more than 2 vertices, or more than 1 edge\n                    # We can potentially add 1 edge to form an odd cycle\n                    ways_t1 += local_cnt0 * (local_cnt0 - 1) // 2\n                    ways_t1 += local_cnt1 * (local_cnt1 - 1) // 2\n            \n            # Optimization: If an odd cycle is found, we can immediately output 0 1\n            if not is_bipartite_graph:\n                print(\"0 1\")\n                return\n\n    # If we reach here, the entire graph is bipartite\n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n    else:\n        # All connected components are either isolated vertices or single edges\n        # t=1 is not possible\n        \n        # Check for t=2\n        ways_t2 = 0\n        if num_isolated_vertices >= 1 and num_edge_components >= 1:\n            # Pick one isolated vertex, and one edge component (u-v)\n            # Add edges from isolated vertex 'c' to 'u' and 'v'\n            ways_t2 = num_isolated_vertices * num_edge_components\n        elif num_isolated_vertices == 0 and num_edge_components >= 2:\n            # All components are single edges. Pick two distinct edge components (u1-v1) and (u2-v2)\n            # Pick one vertex from (u1-v1), say u1. Connect u1 to u2 and v2.\n            # This forms u1-u2-v2-u1 cycle, where u2-v2 is an existing edge.\n            ways_t2 = num_edge_components * (num_edge_components - 1)\n\n        if ways_t2 > 0:\n            print(f\"2 {ways_t2}\")\n        else:\n            # t=2 is not possible. Check for t=3.\n            # This means either num_isolated_vertices < 1 or num_edge_components < 1\n            # AND (num_isolated_vertices < 2 or num_edge_components < 2)\n            # AND (num_isolated_vertices == 0 or num_edge_components == 0)\n            \n            # Only remaining possibility for t=3 is connecting 3 isolated vertices\n            # (or other complex scenarios, but 3 isolated vertices is the simplest)\n            \n            # If all are isolated vertices:\n            if num_isolated_vertices >= 3 and num_edge_components == 0:\n                ways_t3 = num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6\n                print(f\"3 {ways_t3}\")\n            else:\n                # This case should ideally not be reached if n >= 3.\n                # It means we have n=0,1,2 or n=3 with N_iso=1, N_edge=1 which is not 3 vertices.\n                # Example: n=2, m=0 -> N_iso=2, N_edge_components=0. ways_t3 = 0.\n                # The problem statement implies a solution always exists.\n                # For n=2, m=1 (1-2), N_iso=0, N_edge_components=1. ways_t2=0, ways_t3=0.\n                # This indicates that the problem implicitly assumes a minimum of 3 vertices are available to form a cycle.\n                # If n < 3, it's impossible to form a cycle.\n                # For n=3, m=0, N_iso=3, N_edge_components=0, ways_t3 = 1.\n                # For n=3, m=1 (1-2), N_iso=1, N_edge_components=1. ways_t2 = 1*1 = 1.\n                # For n=3, m=2 (1-2, 2-3), component 1-2-3 (path). cnt0=2, cnt1=1. ways_t1 = 2*1/2 = 1.\n                # It seems my logic covers all cases where n >= 3.\n                # If n < 3, it's impossible. The problem gives 3 0 -> 3 1.\n                # So if n < 3 it would be 3 0.\n                # Given problem constraints N up to 200,000, M up to 200,000.\n                # My logic seems sound for n >= 3.\n                # If we reach here, and n >= 3, it implies the graph is very sparse, e.g., n=4, m=1 (1-2), N_iso=2, N_edge_components=1.\n                # ways_t2 = 2*1=2.\n                # So the `else` block should not be reached for n >= 3.\n                # If it is reached, it implies `t` is even higher, but the problem implies 3 is max `t`.\n                # For competitive programming, if this state is reached, it implies 0 ways or an error in my logic.\n                # Let's assume the provided logic covers all valid scenarios for `t` up to 3.\n                pass # This branch should ideally not be hit if n >= 3\n\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 5431,
        "thoughts_token_count": 7075
    }
}