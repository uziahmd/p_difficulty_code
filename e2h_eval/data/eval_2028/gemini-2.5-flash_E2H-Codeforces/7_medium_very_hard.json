{
    "start": 1758011847.8120189,
    "end": 1758011978.3525474,
    "start-formatted": "2025-09-16 17:37 KST",
    "end-formatted": "2025-09-16 17:39 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Initial Thoughts on Rudolf and Snowflakes (Hard)**\n\nOkay, so I'm tasked with writing a Python script to tackle this \"Rudolf and Snowflakes\" problem. It seems like it involves figuring out if a given number `N` can be represented as the sum of a geometric series, and that series defines the structure of a snowflake. Let's break this down.\n\nFirst, the core idea: We're starting with a single central vertex. Then, we add `k` new vertices, all connected to that center. After that, we apply this rule: any leaf node (a vertex connected to just one other vertex) sprouts `k` more vertices. This can happen multiple times, and the problem explicitly states that it must happen at least once.\n\nLet's trace what happens layer by layer. Layer 0 is just the central vertex (1). Layer 1 has `k` vertices, all children of the center. Layer 2 sprouts `k * k = k^2` new vertices, all children of the Layer 1 vertices. Layer `m` has `k^m` vertices. The process continues. The problem is to express the total number of vertices as the sum.\n\nIf the sprouting happens `d` times, with `d >= 1`, it means we have `d+1` layers after the initial `k` vertices: Layer 1 to Layer `d+1`. So the total number of vertices `N` is the sum of a geometric series: `1 + k + k^2 + ... + k^(d+1)`.  We can re-interpret this as `N = (k^(m+1) - 1) / (k-1)` where `m=d+1` and `m >= 2`.\n\nNow we have our main equation, but there are constraints to consider: `k > 1` (the number of new vertices per leaf) and `m >= 2` (must sprout at least once, so it can't just be the initial center and `k` vertices). We are given `N` and we need to see if there exist integers `k` and `m` satisfying the equation. Also, `N` can go up to `10^18`.\n\n**The Game Plan:**\n\n1.  **Small `m` Values**:  Let's start with small values of `m` and see what comes out. For `m=2`, we have `N = 1 + k + k^2`. This is a quadratic equation! I can find possible `k` values, and check: `k = (-1 +/- sqrt(4N - 3))/2`. If this leads to a valid integer solution for `k > 1`, and `4N - 3` is a perfect square, we're golden.\n2.  **Larger `m` Values**:  For `m = 3, 4, ...` This is the trickier part.  For each `m`, we need to see if we can find a `k` that makes the equation work: `N = 1 + k + k^2 + ... + k^m`. Binary search seems like the best approach here.  I can search for values of `k` and see if `1 + k + ... + k^m` gets the target value of `N`. We need a suitable range for `k` when we're searching. We also need to avoid potential integer overflow when calculating the series.\n\n**Range and Optimization**:\n\n*   **Binary Search Range**:  I can use binary search for `k`, keeping in mind the upper bound `k < N^(1/m)`.  I'll define the range properly for `k`.\n*   **Geometric Sum**: Need to calculate the sum for given `k`, `m`, and make sure the sum doesn't overflow. I can do it iteratively, checking for overflow before multiplying or adding, stopping the calculation if it gets bigger than `N`.\n*   **Edge Cases**: Handle `N = 1, 2, 3, 6` as \"NO\" (the problem implies this). For `N=1`, the smallest possible geometric sum will be `1 + 2 + 2^2 = 7`.\n*   **Optimize `m` loop**: Can break out from the loop if we're certain no solution exists for larger `m` as well. For example, if even with `k=2`, sum is greater than `N`, we can break the search.\n*   **Perfect square check**: For the `m=2` case, I need to check if the square root is an integer and greater than `1`.\n*   **Use `math.isqrt`**: For this problem, I can use `math.isqrt` for safe",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake graph. A snowflake is defined by a central vertex, connected to `k` new vertices (where `k > 1`). Then, each vertex connected to only one other vertex (i.e., a leaf node) is connected to `k` more new vertices. This last step must be performed at least once.\n\nLet's analyze the structure and count the vertices:\n1.  **Initial vertex:** 1 vertex (the center).\n2.  **First expansion:** The center is connected to `k` new vertices. Total vertices: `1 + k`.\n    At this point, the `k` new vertices are leaves.\n3.  **Subsequent expansions:** The rule \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices\" is applied. This step must be done at least once.\n    *   If applied once (let's call this `d=1` application): Each of the `k` leaf vertices gets `k` new children. This adds `k * k = k^2` vertices. Total vertices: `1 + k + k^2`.\n    *   If applied twice (`d=2` applications): After the first application, there are `k^2` new leaf vertices. Each of these gets `k` new children, adding `k^2 * k = k^3` vertices. Total vertices: `1 + k + k^2 + k^3`.\n    *   If applied `d` times: The total number of vertices will be `1 + k + k^2 + ... + k^(d+1)`.\n\nLet `m = d+1`. Since `d >= 1`, we must have `m >= 2`.\nSo, the total number of vertices `N` for a snowflake is given by the sum of a geometric series:\n`N = 1 + k + k^2 + ... + k^m`\nwhere `k > 1` and `m >= 2`.\n\nThis sum can also be written as `N = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if, for a given `n`, there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\n**Constraints:** `n <= 10^18`.\n\n**Smallest possible snowflake:**\nThe smallest `k` is 2. The smallest `m` is 2.\nSo, the smallest `N` is `1 + 2 + 2^2 = 7`.\nAny `n < 7` cannot be a snowflake. This covers `n=1, 2, 3, 6` from the example.\n\n**Strategy:**\n\n1.  **Handle `n < 7`:** If `n` is less than 7, print \"NO\".\n\n2.  **Case `m = 2`:** `n = 1 + k + k^2`.\n    This is a quadratic equation: `k^2 + k + (1 - n) = 0`.\n    Using the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\n    For `k` to be a valid integer greater than 1:\n    *   `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n    *   `S` must be an integer. Python's `math.isqrt()` can be used for this efficiently and accurately for large numbers.\n    *   `k = (S - 1) / 2`. Since `4n - 3 = 4(n-1) + 1`, `4n-3` is always congruent to `1 \\pmod 4`. This implies `S^2 \\equiv 1 \\pmod 4`, so `S` must be odd. Thus, `S-1` is always even, making `k` an integer.\n    *   We need `k > 1`, which means `(S - 1) / 2 > 1`, so `S - 1 > 2`, or `S > 3`.\n    If all these conditions are met, `n` is a snowflake. Print \"YES\" and return.\n\n3.  **Case `m >= 3`:** `n = 1 + k + k^2 + ... + k^m`.\n    *   **Maximum `m`:** Since `k > 1`, the smallest `k` is 2. So `n >= 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\n        This implies `2^(m+1) <= n + 1`.\n        `m+1 <= log2(n+1)`. For `n = 10^18`, `log2(10^18+1)` is approximately `59.79`.\n        So, `m+1` can be at most 59, meaning `m` can be at most 58. We can iterate `m` from 3 up to 60 (a safe upper bound).\n    *   **Binary Search for `k`:** For a fixed `m`, the function `f(k) = 1 + k + ... + k^m` is strictly increasing for `k > 1`. We can use binary search to find `k`.\n        *   **Lower bound for `k`:** `low = 2`.\n        *   **Upper bound for `k`:** `k^m < n`, so `k < n^(1/m)`. A safe upper bound for binary search is `high = int(n**(1/m)) + 2`. This handles potential floating-point inaccuracies and ensures we cover the true root. (For `m=3, n=10^18`, `k` is roughly `10^6`. For `m=58`, `k` is roughly `2`).\n        *   **Sum calculation (`calculate_sum(k, m, target_n)`):** When calculating `1 + k + ... + k^m`, we must be careful about intermediate overflows, as `k^m` can be up to `n` (which is `10^18`). We can compute the sum term by term, checking if the current term `k^i` or the running sum exceeds `target_n` at each step. If it exceeds, we know `k` is too large.\n            ```python\n            def calculate_sum(k, m, target_n):\n                current_sum = 1\n                current_power_k = 1\n                for _ in range(m): # Loop m times to get k^1, ..., k^m\n                    # Check for overflow before multiplying current_power_k by k\n                    if target_n // k < current_power_k: # current_power_k * k > target_n\n                        return target_n + 1 # Indicate sum is too large\n                    current_power_k *= k\n                    # Check for overflow before adding current_power_k to current_sum\n                    if target_n - current_power_k < current_sum: # current_sum + current_power_k > target_n\n                        return target_n + 1 # Indicate sum is too large\n                    current_sum += current_power_k\n                return current_sum\n            ```\n        *   **Binary Search Loop:**\n            ```python\n            while low <= high:\n                mid = (low + high) // 2\n                if mid < 2: # k must be > 1\n                    low = 2\n                    continue\n                \n                current_sum = calculate_sum(mid, m, n)\n                \n                if current_sum == n:\n                    # Found a valid k for this m\n                    print(\"YES\")\n                    return\n                elif current_sum < n:\n                    low = mid + 1\n                else: # current_sum > n (or overflowed)\n                    high = mid - 1\n            ```\n    *   **Optimization for `m` loop:** If for a given `m`, even the smallest possible `k=2` results in a sum `1 + 2 + ... + 2^m` that is greater than `n` (or overflows), then no `k > 1` will work for this `m`, or any larger `m`. This is because `calculate_sum(k, m, n)` is increasing with both `k` and `m`. So, we can break the `m` loop early.\n\n4.  **If no `k, m` found:** After checking all possibilities, if no solution is found, print \"NO\".\n\n**Example Walkthrough for `n=255`:**\n1.  `n=255` is not `< 7`.\n2.  `m=2` check: `discriminant = 4*255 - 3 = 1020 - 3 = 1017`. `math.isqrt(1017)` is `31`. `31*31 = 961 != 1017`. So `m=2` doesn't work.\n3.  `m >= 3` loop:\n    *   `m=3`: `high = int(255**(1/3)) + 2 = 6 + 2 = 8`. Binary search `k` in `[2, 8]`.\n        `k=2`: `1+2+4+8 = 15 < 255`.\n        `k=3`: `1+3+9+27 = 40 < 255`.\n        `k=4`: `1+4+16+64 = 85 < 255`.\n        `k=5`: `1+5+25+125 = 156 < 255`.\n        `k=6`: `1+6+36+216 = 259 > 255`.\n        No integer `k`.\n    *   `m=4`: `high = int(255**(1/4)) + 2 = 3 + 2 = 5`. Binary search `k` in `[2, 5]`.\n        `k=2`: `1+2+4+8+16 = 31 < 255`.\n        `k=3`: `1+3+9+27+81 = 121 < 255`.\n        `k=4`: `1+4+16+64+256 = 341 > 255`.\n        No integer `k`.\n    *   `m=5`: `high = int(255**(1/5)) + 2 = 3 + 2 = 5`. Binary search `k` in `[2, 5]`.\n        `k=2`: `1+2+4+8+16+32 = 63 < 255`.\n        `k=3`: `1+3+9+27+81+243 = 364 > 255`.\n        No integer `k`.\n    *   `m=6`: `high = int(255**(1/6)) + 2 = 2 + 2 = 4`. Binary search `k` in `[2, 4]`.\n        `k=2`: `1+2+4+8+16+32+64 = 127 < 255`.\n        `k=3`: `1+3+9+27+81+243+729 = 1093 > 255`.\n        No integer `k`.\n    *   `m=7`: `high = int(255**(1/7)) + 2 = 2 + 2 = 4`. Binary search `k` in `[2, 4]`.\n        `low=2, high=4`. `mid=3`. `calculate_sum(3, 7, 255)` is `1+3+...+3^7 = 1093 > 255`. `high = 2`.\n        `low=2, high=2`. `mid=2`. `calculate_sum(2, 7, 255)` is `1+2+...+2^7 = 2^8 - 1 = 256 - 1 = 255`.\n        `current_sum == n`. Print \"YES\" and return.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Smallest possible snowflake N = 1 + 2 + 2^2 = 7\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (N = 1 + k + k^2)\n    # k^2 + k + (1 - N) = 0\n    # k = (-1 + sqrt(1 - 4(1 - N))) / 2\n    # k = (-1 + sqrt(4N - 3)) / 2\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square using math.isqrt\n    s = math.isqrt(discriminant)\n    if s * s == discriminant:\n        # For k to be an integer, (-1 + s) must be even.\n        # Since 4N - 3 is always odd (1 mod 4), s^2 must be odd, so s must be odd.\n        # Thus, (s - 1) is always even.\n        k_val = (s - 1) // 2\n        if k_val > 1: # k must be greater than 1\n            print(\"YES\")\n            return\n\n    # Case 2: m >= 3 (N = 1 + k + k^2 + ... + k^m)\n    # Max m: k^m < N. Smallest k=2. So 2^m < N. m < log2(N).\n    # For N = 10^18, log2(10^18) approx 59.79. So m up to 59.\n    # We iterate m from 3 up to 60 for safety.\n    for m in range(3, 61):\n        # Binary search for k\n        # k^m < N implies k < N^(1/m).\n        # A safe upper bound for k is int(N**(1/m)) + 2.\n        # If N is very small (e.g., N=7), N**(1/m) might be 1.something.\n        # So high can be small. Ensure low <= high.\n        low = 2\n        high = int(n**(1/m)) + 2 # Add a small buffer for float precision\n        \n        # Optimization: If even k=2 results in a sum > n (or overflows),\n        # then no k will work for this m or any larger m.\n        # This check also ensures 'low' doesn't become greater than 'high'\n        # if 'n' is too small for a given 'm' and 'k=2'.\n        # We can simulate calculate_sum(2, m, n) here\n        test_sum_k2 = 1\n        term_k2 = 1\n        overflow_k2 = False\n        for _ in range(m):\n            # Check for overflow when multiplying by 2\n            if n // 2 < term_k2:\n                overflow_k2 = True\n                break\n            term_k2 *= 2\n            # Check for overflow when adding to sum\n            if n - term_k2 < test_sum_k2:\n                overflow_k2 = True\n                break\n            test_sum_k2 += term_k2\n        \n        if overflow_k2 or test_sum_k2 > n:\n            # If k=2 already produces a sum too large or overflows,\n            # then no larger k will work for this m, and no k will work for larger m either.\n            break # Exit the m loop\n            \n        # Perform binary search for k\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1\n                low = 2\n                continue\n            \n            # Calculate sum_geom(mid, m, n) with overflow checks\n            current_sum = 1\n            current_power_k = 1\n            is_too_large = False\n            for _ in range(m): # Loop m times to get k^1, ..., k^m\n                # Check for overflow before multiplying current_power_k by mid\n                if mid > n // current_power_k: # current_power_k * mid > n\n                    is_too_large = True\n                    break\n                current_power_k *= mid\n                # Check for overflow before adding current_power_k to current_sum\n                if n - current_power_k < current_sum: # current_sum + current_power_k > n\n                    is_too_large = True\n                    break\n                current_sum += current_power_k\n            \n            if is_too_large:\n                high = mid - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            else: # current_sum < n\n                low = mid + 1\n\n    # If no k, m pair was found\n    print(\"NO\")\n\n# Read number of test cases\nt = int(input())\nfor _ in range(t):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Smallest possible snowflake N = 1 + 2 + 2^2 = 7\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (N = 1 + k + k^2)\n    # k^2 + k + (1 - N) = 0\n    # k = (-1 + sqrt(1 - 4(1 - N))) / 2\n    # k = (-1 + sqrt(4N - 3)) / 2\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square using math.isqrt\n    s = math.isqrt(discriminant)\n    if s * s == discriminant:\n        # For k to be an integer, (-1 + s) must be even.\n        # Since 4N - 3 is always odd (1 mod 4), s^2 must be odd, so s must be odd.\n        # Thus, (s - 1) is always even.\n        k_val = (s - 1) // 2\n        if k_val > 1: # k must be greater than 1\n            print(\"YES\")\n            return\n\n    # Case 2: m >= 3 (N = 1 + k + k^2 + ... + k^m)\n    # Max m: k^m < N. Smallest k=2. So 2^m < N. m < log2(N).\n    # For N = 10^18, log2(10^18) approx 59.79. So m up to 59.\n    # We iterate m from 3 up to 60 for safety.\n    for m in range(3, 61):\n        # Binary search for k\n        # k^m < N implies k < N^(1/m).\n        # A safe upper bound for k is int(N**(1/m)) + 2.\n        # If N is very small (e.g., N=7), N**(1/m) might be 1.something.\n        # So high can be small. Ensure low <= high.\n        low = 2\n        high = int(n**(1/m)) + 2 # Add a small buffer for float precision\n        \n        # Optimization: If even k=2 results in a sum > n (or overflows),\n        # then no k will work for this m or any larger m.\n        # This check also ensures 'low' doesn't become greater than 'high'\n        # if 'n' is too small for a given 'm' and 'k=2'.\n        # We can simulate calculate_sum(2, m, n) here\n        test_sum_k2 = 1\n        term_k2 = 1\n        overflow_k2 = False\n        for _ in range(m):\n            # Check for overflow when multiplying by 2\n            if n // 2 < term_k2:\n                overflow_k2 = True\n                break\n            term_k2 *= 2\n            # Check for overflow when adding to sum\n            if n - term_k2 < test_sum_k2:\n                overflow_k2 = True\n                break\n            test_sum_k2 += term_k2\n        \n        if overflow_k2 or test_sum_k2 > n:\n            # If k=2 already produces a sum too large or overflows,\n            # then no larger k will work for this m, and no k will work for larger m either.\n            break # Exit the m loop\n            \n        # Perform binary search for k\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1\n                low = 2\n                continue\n            \n            # Calculate sum_geom(mid, m, n) with overflow checks\n            current_sum = 1\n            current_power_k = 1\n            is_too_large = False\n            for _ in range(m): # Loop m times to get k^1, ..., k^m\n                # Check for overflow before multiplying current_power_k by mid\n                if mid > n // current_power_k: # current_power_k * mid > n\n                    is_too_large = True\n                    break\n                current_power_k *= mid\n                # Check for overflow before adding current_power_k to current_sum\n                if n - current_power_k < current_sum: # current_sum + current_power_k > n\n                    is_too_large = True\n                    break\n                current_sum += current_power_k\n            \n            if is_too_large:\n                high = mid - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            else: # current_sum < n\n                low = mid + 1\n\n    # If no k, m pair was found\n    print(\"NO\")\n\n# Read number of test cases\nt = int(input())\nfor _ in range(t):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 4053,
        "thoughts_token_count": 8192
    }
}