{
    "start": 1758284943.9083772,
    "end": 1758284999.065776,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Analyzing the Odd Cycle Problem**\n\nOkay, so I'm tackling this competitive programming problem. The goal is to figure out the fewest edges, *t*, to add to a graph to guarantee an odd-length cycle and also compute how many ways, *w*, we can achieve this.  \n\nMy initial thought is to look for the simplest case. If the given graph already *has* an odd cycle, then boom, *t* is zero, and there's only one way to achieve it, *w* equals one. That's the ideal scenario.\n\nHow do I check for an existing odd cycle? Bipartiteness seems like the way to go.  I'll run a BFS or DFS and try to color the graph. If I run into an edge connecting nodes of the same color, that means it's *not* bipartite, and we have our odd cycle.  Let's keep *n* as the number of nodes, and *m* the number of edges for the moment.\n\nSo, here's my breakdown:\n\n**Case 1: Existing Odd Cycle:** If any connected component fails the bipartite check, *t* is zero, *w* is one.  Simple.\n\n**Case 2: Bipartite Graph:** Okay, this is where it gets interesting. If the graph *is* bipartite, I need to force an odd cycle by adding an edge. I know I have to connect nodes within the *same* partition to make that happen.  Let's call the partitions L and R for each connected component. All existing edges are going to connect L to R.\n\nTo create the odd cycle, I have to add an edge.  I'm thinking about the length of the cycle the new edge creates.  If I add an edge (u, v) where *u* and *v* are in the same partition (say, both in L), then the path between *u* and *v* *must* have an even length in the original graph. Adding the edge closes the cycle with an odd length (even + 1).\n\nIf I connect nodes from different partitions, that won't work. It'll just form an even cycle.\n\nTherefore, to minimize *t*, I need to add an edge between two vertices within the same partition.\n\nWhat's the *minimum* number of edges I need?\n\n*   ***t = 1:*** Just one edge! I need to pick two vertices in the *same* partition that aren't already connected. If a component has at least three vertices, I can find two non-adjacent ones in the same partition, add an edge, and bang, odd cycle.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. We can use a 2-coloring algorithm (e.g., BFS or DFS) to check for bipartiteness.\n\nLet's categorize the scenarios:\n\n**Scenario 1: The graph already contains an odd cycle.**\nIf any connected component of the graph is not bipartite, then an odd cycle already exists. In this case, `t = 0` and `w = 1`. We can detect this by attempting to 2-color each connected component. If we find an edge connecting two vertices of the same color, the component is not bipartite.\n\n**Scenario 2: The graph is bipartite.**\nIf the graph is bipartite, we need to add edges to create an odd cycle. An odd cycle is formed by adding an edge `(u, v)` such that `u` and `v` are in the same partition (e.g., both colored 0 or both colored 1) and are not already connected. The path between `u` and `v` in the original graph must have an even length for them to be in the same partition. Adding `(u, v)` creates a cycle of length (path_length + 1), which is odd.\n\nLet's analyze the minimum number of edges `t` required:\n\n*   **`t = 1`**: We can add one edge `(u, v)` if there exist two non-adjacent vertices `u` and `v` in the same connected component and same partition.\n    *   For this to be possible, there must be at least one connected component with at least 3 vertices. If a component has only 1 or 2 vertices, it's impossible to pick two vertices from the same partition.\n    *   If a component has `k` vertices, and it's bipartite with partitions of size `s0` and `s1` (where `s0 + s1 = k`), we can form an odd cycle by adding an edge between two vertices in the `s0` partition (if `s0 >= 2`) or two vertices in the `s1` partition (if `s1 >= 2`).\n    *   The number of ways `w` would be the sum, over all connected components, of `(s0 * (s0 - 1) / 2) + (s1 * (s1 - 1) / 2)`, considering only non-existent edges. However, since the graph is initially bipartite, all existing edges connect vertices from different partitions. So, any edge between vertices of the same partition would be a new edge.\n    *   So, if there is at least one component with `s0 >= 2` or `s1 >= 2`, we can achieve `t=1`. The number of ways `w` is the sum of `s0 * (s0 - 1) / 2 + s1 * (s1 - 1) / 2` over all components. This is the best outcome if `t > 0`.\n\n*   **`t = 2`**: If `t = 1` is not possible, it means all connected components are either single vertices or pairs of vertices (edges).\n    *   This implies that for every component, `s0 <= 1` and `s1 <= 1`.\n    *   In this case, we need to connect three distinct vertices `u, v, x` such that `u` and `v` are in one component, `x` is in another component, and adding edges `(u, x)` and `(v, x)` forms an odd cycle.\n    *   Consider two connected components `C1` and `C2`. Pick `u` from `C1` and `v` from `C2`. Add edge `(u, v)`. Now `C1` and `C2` are merged into a larger component. This new component is still bipartite. To form an odd cycle, we need to add one more edge within this merged component, connecting two vertices of the same partition.\n    *   A simpler way to think about `t=2` is to connect three vertices `u, v, x` from potentially different components. If we add edges `(u, v)` and `(v, x)` and `(x, u)`, we form a triangle (an odd cycle of length 3). This requires 3 edges.\n    *   However, if `n >= 3`, we can pick three distinct vertices `u, v, x`. Add edges `(u, v)` and `(u, x)`. Now `u, v, x` are in the same component. If `v` and `x` are in the same partition, adding an edge `(v, x)` would form an odd cycle. But we are looking for `t=2`.\n    *   Let's consider `t=2` if we connect two components. Suppose we have `k` components. We pick two vertices `u, v` from different components, say `C_i` and `C_j`. We add edge `(u, v)`. Now `C_i` and `C_j` are merged. They form a new bipartite component. We need one more edge to create an odd cycle. This means we need to connect two vertices `x, y` within the merged component that are of the same color. But this would be `t=1` for the *new* graph.\n    *   The problem is about adding edges to the *original* graph. If we add two edges `(u, v)` and `(u, x)` where `u, v, x` are distinct vertices, we have used 2 edges. If `v` and `x` are in the same partition, adding `(v, x)` would make `t=3`.\n    *   Consider `t=2`. We add edges `(u, v)` and `(x, y)`. If `u, v, x, y` are distinct, this is `t=2`. If we want an odd cycle of length 3, we need to add `(a,b), (b,c), (c,a)`. This is 3 edges.\n    *   The only way to get `t=2` is to connect three distinct vertices `u, v, x` such that `u, v` are in different components, `v, x` are in different components, and `u, x` are in different components. Let's say `u \\in C_1`, `v \\in C_2`, `x \\in C_3`. We add edges `(u,v)` and `(v,x)`. Now `u,v,x` are in the same component. `u` and `x` are at distance 2 from each other (via `v`). If we assign `v` color 0, then `u` gets color 1 and `x` gets color 1. So `u` and `x` are in the same partition. If we now add an edge `(u, x)`, we form a triangle `u-v-x-u`. This would require 3 edges.\n    *   A different approach for `t=2`: Pick three distinct vertices `u, v, x`. Add edges `(u, v)` and `(v, x)`. If `u` and `x` are already connected, we have formed a triangle. But the graph is bipartite. So `u` and `x` are not connected. If `u, v, x` are distinct, then `u-v-x` is a path of length 2. If `u` and `x` are in the same partition, this forms a path of even length. If we add `(u,x)` then it forms a cycle of length 3. This requires 3 edges.\n    *   The only way to get `t=2` is if we connect two vertices from *different* components (say `u` from `C_i` and `v` from `C_j`) and then connect another vertex `x` (from `C_k` or `C_i` or `C_j`) to either `u` or `v`, forming an odd cycle.\n    *   This is tricky. Let's consider the structure of a bipartite graph. All paths between vertices in the same partition have even length. All paths between vertices in different partitions have odd length.\n    *   If we add edges `(u,v)` and `(x,y)`, `t=2`.\n        *   If `u,v,x,y` are all distinct, this is `t=2`.\n        *   If `u=x`, we add `(u,v)` and `(u,y)`. Now `u,v,y` form a path `v-u-y`. `v` and `y` are in the same partition (if `u` is connected to both). If we add `(v,y)`, we get a triangle. This is `t=3`.\n    *   The problem states \"simple cycle of an odd length, consisting of more than one vertex\".\n    *   If `t=1` is not possible, it means all `s0 <= 1` and `s1 <= 1` for all components. This means all components are either isolated vertices or single edges.\n    *   To get an odd cycle, we need to connect two vertices `u, v` from the same partition.\n    *   Since all components are small, `u` and `v` must be from different components.\n    *   Suppose we pick two isolated vertices `u, v`. We add `(u, v)`. They are now in a component, but still bipartite. We need a third vertex `x`.\n    *   If we have `N_1` isolated vertices and `N_2` edges (components of size 2).\n    *   To make `t=1` impossible, we need `s0 <= 1` and `s1 <= 1` for all components.\n    *   If `n >= 3`, we can always pick three distinct vertices `u, v, x`.\n    *   If we add edges `(u, v)` and `(v, x)`, we have used 2 edges. `u` and `x` are now connected by a path of length 2. If `v` is colored 0, `u` and `x` are colored 1. So `u` and `x` are in the same partition. If we add `(u, x)`, we form a triangle. This is 3 edges.\n    *   So, `t=2` is possible if we connect two vertices from different components, say `u` from `C_i` and `v` from `C_j`, and then connect a third vertex `x` from `C_k` (could be `C_i` or `C_j` or a new component) to `u` or `v` such that an odd cycle is formed.\n    *   Consider adding two edges `(u, v)` and `(u, x)`. This creates a path `v-u-x`. If `v` and `x` are not connected, we have used 2 edges. `v` and `x` are in the same partition relative to `u`. If we add `(v, x)`, it's `t=3`.\n    *   The only way to get `t=2` is if we have `N_1` isolated vertices and `N_2` edges. If `N_1 >= 1` and `n - N_1 >= 2`, we can pick an isolated vertex `u`, and two vertices `v, x` that are already connected `(v-x)`. Add `(u, v)` and `(u, x)`. This forms a cycle `u-v-x-u`. This cycle has length 3, which is odd. This uses 2 edges `(u,v)` and `(u,x)`. This requires `N_1 >= 1` and `N_2 >= 1`.\n    *   The number of ways `w` would be `N_1 * N_2 * 2` (pick isolated vertex, pick an edge, pick one of its endpoints).\n    *   This is `t=2`. This is possible if there's at least one isolated vertex and at least one edge in the graph.\n\n*   **`t = 3`**: If `t=1` and `t=2` are not possible.\n    *   `t=1` not possible implies all components have `s0 <= 1` and `s1 <= 1`.\n    *   `t=2` not possible implies either `N_1 = 0` (no isolated vertices) or `N_2 = 0` (no edges).\n        *   If `N_1 = 0`, then all vertices are part of components of size 2 (edges). This means `n` must be even. No isolated vertices.\n        *   If `N_2 = 0`, then all vertices are isolated. This means `m = 0`.\n    *   If `m = 0` (all vertices isolated, `N_2 = 0`), and `n >= 3`. We pick three distinct vertices `u, v, x`. Add edges `(u, v), (v, x), (x, u)`. This forms a triangle, an odd cycle of length 3. This uses 3 edges.\n        *   The number of ways `w` would be `n * (n - 1) * (n - 2) / 6` (number of ways to choose 3 vertices).\n    *   If `n < 3`, `t=3` is impossible. `n=1` or `n=2` cannot form a cycle of length 3.\n\n**Summary of logic:**\n\n1.  **Check for existing odd cycle:**\n    *   Perform a 2-coloring (BFS/DFS) on each connected component.\n    *   If any component is found to be non-bipartite, print `0 1` and exit.\n    *   During 2-coloring, also count `s0` (vertices colored 0) and `s1` (vertices colored 1) for each component.\n    *   Store `N_1` (number of isolated vertices) and `N_2` (number of components with at least one edge).\n\n2.  **If graph is bipartite:**\n    *   **Attempt `t = 1`:**\n        *   Calculate `ways_t1 = sum(s0 * (s0 - 1) / 2 + s1 * (s1 - 1) / 2)` over all components.\n        *   If `ways_t1 > 0`, print `1 ways_t1` and exit.\n        *   Note: `s0 * (s0 - 1) / 2` is the number of pairs of vertices within the '0' partition of a component. Same for `s1`. If `s0 >= 2` or `s1 >= 2` for any component, then `t=1` is possible.\n    *   **Attempt `t = 2`:**\n        *   This requires `N_1 >= 1` (at least one isolated vertex) AND `N_2 >= 1` (at least one component with an edge, i.e., at least one edge in the graph).\n        *   If `N_1 >= 1` and `N_2 >= 1`:\n            *   We can pick an isolated vertex `u`.\n            *   We can pick an edge `(v, x)` from any component that has edges.\n            *   Add edges `(u, v)` and `(u, x)`. This forms a triangle `u-v-x-u`. This requires 2 edges.\n            *   The number of ways `w` is `N_1 * (number of edges in the graph) * 2`. (Pick an isolated vertex, pick an edge, pick one of the two endpoints of the edge to connect to the isolated vertex).\n            *   No, this is `N_1 * m * 2`. Wait, `m` is the number of edges. If we pick an edge `(v,x)`, then we have `m` choices. And for each edge, we can choose `v` or `x` to be the \"central\" vertex of the path `u-v-x`. This is `N_1 * m * 2`.\n            *   No, `w` is `N_1 * m`. We choose an isolated vertex `u` and an edge `(v, x)`. We add edges `(u, v)` and `(u, x)`. This forms the cycle `u-v-x-u`. The number of ways to choose `u` is `N_1`. The number of ways to choose `(v, x)` is `m`. So `w = N_1 * m`.\n            *   Print `2 (N_1 * m)` and exit.\n    *   **Attempt `t = 3`:**\n        *   If `t=1` and `t=2` are not possible, it means:\n            *   All components have `s0 <= 1` and `s1 <= 1`.\n            *   AND ( `N_1 = 0` OR `N_2 = 0` ).\n        *   If `N_1 = 0`, then all vertices are part of components of size 2 (edges). This implies `n` is even. But this case is covered by `N_2 >= 1`. If `N_1=0` and `N_2 >= 1`, it means all components are edges. Then `s0=1, s1=1` for each component. `ways_t1` would be 0. `N_1 * m` would be 0. So this is not possible to reach here.\n        *   The only remaining possibility is `N_2 = 0`. This means `m = 0` (no edges in the graph). All `n` vertices are isolated.\n        *   If `m = 0` and `n >= 3`:\n            *   We need to pick 3 distinct vertices `u, v, x`. Add edges `(u, v), (v, x), (x, u)`. This forms a triangle. This uses 3 edges.\n            *   The number of ways `w` is `n * (n - 1) * (n - 2) / 6`.\n            *   Print `3 (n * (n - 1) * (n - 2) / 6)` and exit.\n        *   If `m = 0` and `n < 3`: This case is impossible to form an odd cycle. The problem statement guarantees `n >= 1`. If `n=1` or `n=2`, no cycle is possible. However, the problem statement implies a solution always exists. The minimum cycle length is 3. So `n` must be at least 3 for `t=3` to be possible.\n            *   Wait, the problem states \"cycle of an odd length, consisting of more than one vertex\". Smallest is 3.\n            *   If `n < 3`, `t=3` is impossible. What if `n=1` or `n=2`?\n                *   `n=1`: `t=0` is impossible. `t=1` is impossible. `t=2` is impossible. `t=3` is impossible.\n                *   `n=2, m=0`: `t=0` impossible. `t=1` impossible. `t=2` impossible. `t=3` impossible.\n                *   `n=2, m=1`: `t=0` impossible. `t=1` impossible. `t=2` impossible. `t=3` impossible.\n                *   The problem implies a solution always exists. This means `n` must be at least 3 if `m=0`. Or perhaps, for `n<3` the cases `t=0, t=1, t=2` would cover it if possible.\n                *   For `n=1, m=0`: `N_1=1, N_2=0`. `ways_t1=0`. `N_1*m=0`. `n*(n-1)*(n-2)/6 = 0`. This means if `n < 3`, `t=3` is not possible.\n                *   Let's assume `n >= 3` for `t=3` to be a valid scenario.\n                *   The example `3 0` output `3 1` suggests `n=3, m=0` is `t=3, w=1`. This fits `n*(n-1)*(n-2)/6 = 3*2*1/6 = 1`.\n\n**Implementation Details:**\n\n*   Use an adjacency list for the graph.\n*   Use a `color` array (e.g., initialized to -1) to store vertex colors (0 or 1) and track visited status.\n*   Iterate through all vertices. If a vertex is uncolored, start a BFS/DFS from it to find its connected component.\n*   Inside BFS/DFS:\n    *   Maintain `current_s0` and `current_s1` for the component.\n    *   If an edge connects two vertices of the same color, set a flag `is_bipartite = False`.\n    *   After processing a component, update `N_1`, `N_2`, and `total_ways_t1`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v))\n\n    color = [-1] * (n + 1)\n    is_bipartite = True\n    \n    # Store properties of connected components\n    component_stats = [] # List of (s0, s1) for each bipartite component\n\n    # For t=2 case:\n    # N_1 = number of isolated vertices\n    # N_2_components = number of components with at least one edge (size > 1)\n    \n    # For t=1 case:\n    # ways_t1 = total ways to add 1 edge to form an odd cycle\n\n    for i in range(1, n + 1):\n        if color[i] == -1: # Unvisited vertex, start a new component traversal\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            \n            current_s0 = 0\n            current_s1 = 0\n            \n            component_vertices = 0\n            component_edges_count = 0 # for this specific component\n            \n            component_bipartite_status = True # Assume current component is bipartite\n            \n            component_q = deque() # Store vertices for current component for BFS\n            component_q.append((i, 0))\n            color[i] = 0\n            \n            head = 0 # Manual queue for BFS to avoid recursion depth limit and for efficiency\n            q_list = [(i, 0)]\n\n            while head < len(q_list):\n                u, c = q_list[head]\n                head += 1\n                \n                component_vertices += 1\n                if c == 0:\n                    current_s0 += 1\n                else:\n                    current_s1 += 1\n\n                for v in adj[u]:\n                    component_edges_count += 1 # Count edges within this component\n                    if color[v] == -1:\n                        color[v] = 1 - c\n                        q_list.append((v, 1 - c))\n                    elif color[v] == c:\n                        # Found an odd cycle in this component\n                        component_bipartite_status = False\n            \n            # After BFS for a component\n            component_edges_count //= 2 # Each edge counted twice\n            \n            if not component_bipartite_status:\n                is_bipartite = False\n                break # An odd cycle already exists, no need to check further\n\n            # If component is bipartite, store its stats\n            component_stats.append((current_s0, current_s1, component_edges_count, component_vertices))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Graph is bipartite, calculate t and w\n    \n    # Check for t=1\n    ways_t1 = 0\n    for s0, s1, _, _ in component_stats:\n        ways_t1 += (s0 * (s0 - 1) // 2)\n        ways_t1 += (s1 * (s1 - 1) // 2)\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Check for t=2\n    # t=1 was not possible, so all components have s0 <= 1 and s1 <= 1.\n    # This means all components are either isolated vertices (s0=1, s1=0 or s0=0, s1=1) or single edges (s0=1, s1=1).\n    \n    num_isolated_vertices = 0\n    num_components_with_edges = 0 # Count components that are not isolated vertices\n    \n    for s0, s1, component_m, component_n_vertices in component_stats:\n        if component_n_vertices == 1 and component_m == 0: # Isolated vertex\n            num_isolated_vertices += 1\n        elif component_n_vertices > 1 and component_m > 0: # Component with at least one edge\n            num_components_with_edges += 1\n            \n    if num_isolated_vertices >= 1 and m >= 1: # m is total number of edges in graph\n        # We can pick an isolated vertex 'u' (N_1 ways)\n        # We can pick an existing edge '(v, x)' (m ways)\n        # Add edges (u, v) and (u, x) to form a triangle u-v-x-u\n        # This uses 2 edges.\n        ways_t2 = num_isolated_vertices * m\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Check for t=3\n    # If we reached here, t=0, t=1, t=2 are not possible.\n    # This implies:\n    # 1. All components have s0 <= 1 and s1 <= 1.\n    # 2. (num_isolated_vertices == 0) OR (m == 0).\n    # If num_isolated_vertices == 0, and m > 0, then all vertices are part of edges.\n    #    But if all components are single edges (s0=1, s1=1), then ways_t1 would be 0.\n    #    And if num_isolated_vertices=0 and m>0, then t=2 is not possible.\n    #    This scenario means all vertices are part of edges. No isolated vertices.\n    #    This implies n is even.\n    #    Can we form an odd cycle with 3 edges from this?\n    #    Pick 3 vertices u,v,x. Add (u,v), (v,x), (x,u). This forms a triangle.\n    #    This is only possible if n >= 3.\n    # The only remaining case is m == 0 (no edges in graph, all vertices are isolated).\n    # If m == 0, then num_isolated_vertices == n.\n    # If n >= 3:\n    #   Pick any 3 distinct vertices u, v, x. Add (u,v), (v,x), (x,u). Forms a triangle.\n    #   Number of ways to choose 3 vertices from n is nC3.\n    if n >= 3:\n        ways_t3 = n * (n - 1) * (n - 2) // 6\n        print(f\"3 {ways_t3}\")\n        return\n    else:\n        # This case should theoretically not be reached based on problem constraints or implied solvability.\n        # If n < 3, no cycle of length 3 or more is possible.\n        # For example, if n=1 or n=2, no cycle can be formed.\n        # The problem statement implies a solution always exists.\n        # This means n must be >= 3 if we reach this point.\n        pass\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v))\n\n    color = [-1] * (n + 1)\n    is_bipartite = True\n    \n    # Store properties of connected components\n    component_stats = [] # List of (s0, s1) for each bipartite component\n\n    # For t=2 case:\n    # N_1 = number of isolated vertices\n    # N_2_components = number of components with at least one edge (size > 1)\n    \n    # For t=1 case:\n    # ways_t1 = total ways to add 1 edge to form an odd cycle\n\n    for i in range(1, n + 1):\n        if color[i] == -1: # Unvisited vertex, start a new component traversal\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            \n            current_s0 = 0\n            current_s1 = 0\n            \n            component_vertices = 0\n            component_edges_count = 0 # for this specific component\n            \n            component_bipartite_status = True # Assume current component is bipartite\n            \n            component_q = deque() # Store vertices for current component for BFS\n            component_q.append((i, 0))\n            color[i] = 0\n            \n            head = 0 # Manual queue for BFS to avoid recursion depth limit and for efficiency\n            q_list = [(i, 0)]\n\n            while head < len(q_list):\n                u, c = q_list[head]\n                head += 1\n                \n                component_vertices += 1\n                if c == 0:\n                    current_s0 += 1\n                else:\n                    current_s1 += 1\n\n                for v in adj[u]:\n                    component_edges_count += 1 # Count edges within this component\n                    if color[v] == -1:\n                        color[v] = 1 - c\n                        q_list.append((v, 1 - c))\n                    elif color[v] == c:\n                        # Found an odd cycle in this component\n                        component_bipartite_status = False\n            \n            # After BFS for a component\n            component_edges_count //= 2 # Each edge counted twice\n            \n            if not component_bipartite_status:\n                is_bipartite = False\n                break # An odd cycle already exists, no need to check further\n\n            # If component is bipartite, store its stats\n            component_stats.append((current_s0, current_s1, component_edges_count, component_vertices))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Graph is bipartite, calculate t and w\n    \n    # Check for t=1\n    ways_t1 = 0\n    for s0, s1, _, _ in component_stats:\n        ways_t1 += (s0 * (s0 - 1) // 2)\n        ways_t1 += (s1 * (s1 - 1) // 2)\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Check for t=2\n    # t=1 was not possible, so all components have s0 <= 1 and s1 <= 1.\n    # This means all components are either isolated vertices (s0=1, s1=0 or s0=0, s1=1) or single edges (s0=1, s1=1).\n    \n    num_isolated_vertices = 0\n    num_components_with_edges = 0 # Count components that are not isolated vertices\n    \n    for s0, s1, component_m, component_n_vertices in component_stats:\n        if component_n_vertices == 1 and component_m == 0: # Isolated vertex\n            num_isolated_vertices += 1\n        elif component_n_vertices > 1 and component_m > 0: # Component with at least one edge\n            num_components_with_edges += 1\n            \n    if num_isolated_vertices >= 1 and m >= 1: # m is total number of edges in graph\n        # We can pick an isolated vertex 'u' (N_1 ways)\n        # We can pick an existing edge '(v, x)' (m ways)\n        # Add edges (u, v) and (u, x) to form a triangle u-v-x-u\n        # This uses 2 edges.\n        ways_t2 = num_isolated_vertices * m\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Check for t=3\n    # If we reached here, t=0, t=1, t=2 are not possible.\n    # This implies:\n    # 1. All components have s0 <= 1 and s1 <= 1.\n    # 2. (num_isolated_vertices == 0) OR (m == 0).\n    # If num_isolated_vertices == 0, and m > 0, then all vertices are part of edges.\n    #    But if all components are single edges (s0=1, s1=1), then ways_t1 would be 0.\n    #    And if num_isolated_vertices=0 and m>0, then t=2 is not possible.\n    #    This scenario means all vertices are part of edges. No isolated vertices.\n    #    This implies n is even.\n    #    Can we form an odd cycle with 3 edges from this?\n    #    Pick 3 vertices u,v,x. Add (u,v), (v,x), (x,u). This forms a triangle.\n    #    This is only possible if n >= 3.\n    # The only remaining case is m == 0 (no edges in graph, all vertices are isolated).\n    # If m == 0, then num_isolated_vertices == n.\n    # If n >= 3:\n    #   Pick any 3 distinct vertices u, v, x. Add (u,v), (v,x), (x,u). Forms a triangle.\n    #   Number of ways to choose 3 vertices from n is nC3.\n    if n >= 3:\n        ways_t3 = n * (n - 1) * (n - 2) // 6\n        print(f\"3 {ways_t3}\")\n        return\n    else:\n        # This case should theoretically not be reached based on problem constraints or implied solvability.\n        # If n < 3, no cycle of length 3 or more is possible.\n        # For example, if n=1 or n=2, no cycle can be formed.\n        # The problem statement implies a solution always exists.\n        # This means n must be >= 3 if we reach this point.\n        pass\n\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 6573,
        "thoughts_token_count": 740
    }
}