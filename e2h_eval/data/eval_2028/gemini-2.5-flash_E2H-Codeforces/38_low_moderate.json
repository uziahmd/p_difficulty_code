{
    "start": 1758285020.5117836,
    "end": 1758285050.1583414,
    "start-formatted": "2025-09-19 21:30 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Deconstructing a Competitive Programming Challenge**\n\nAlright, let's dive into this. I've got a competitive programming problem on my hands, and it boils down to two key aspects: first, figuring out the absolute *minimum* number of nodes (`n`) needed to construct a directed graph that satisfies a particular reachability condition, which they're calling `p`-reachable.  And second, determining the *maximum* number of unidirectional pairs we can cram into any such `p`-reachable graph that uses that minimal number of nodes.\n\nLet me break down the concepts involved. Reachability is straightforward: if there's a path from node *u* to node *v*, then *v* is reachable from *u*.  \"Mutually reachable\" is crucial here, as it defines our strongly connected components (SCCs): *u* and *v* are mutually reachable if there's a path both from *u* to *v* *and* from *v* to *u*. This means they reside within the same SCC.\n\nNow, the `p`-reachable condition is where it gets interesting. We're looking for graphs containing exactly `p` ordered pairs of nodes `(u, v)` where `u < v` and *u* and *v* are mutually reachable.  The constraint `u < v` means we're only counting the pairs once.  Any pair of nodes within an SCC contributes to this count, and the number of these pairs within an SCC of size *k* is calculated as `k * (k - 1) / 2`.  It's just a matter of choosing any two distinct nodes.\n\nSo, the first goal is to find the smallest possible `n` that allows us to have a `p`-reachable graph. The most efficient way is to maximize the size of the strongly connected components.  Having the biggest SCC possible is much more efficient than having many smaller ones. Imagine `p=3`. We can have a single SCC with size 3, which contributes to 3 pairs, or we can have three SCCs, each with two nodes each, but this gets us 3 pairs and uses 6 nodes in total!\n\nTo find this *minimum* `n` for a given `p`, my strategy is to consider the function `f(k) = k * (k - 1) / 2`, which gives us the number of pairs produced by an SCC of size *k*. I want to find the smallest set of *k* values so that the sum of all `f(k)`'s equals `p` and the sum of all *k* equals our desired `n`. I should start by forming the largest SCC I can.\n",
    "response": "To solve this problem, we need to find two values:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. The maximum number of unidirectional pairs among all `p`-reachable graphs with this minimum `n`.\n\nLet's break down the definitions and strategy.\n\n**Definitions:**\n*   **`p`-reachable graph:** A directed graph is `p`-reachable if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n    *   `u` and `v` are reachable from each other if and only if they belong to the same Strongly Connected Component (SCC).\n    *   If an SCC has `k` nodes, any pair of distinct nodes `(u, v)` within this SCC will be reachable from each other. The number of such unordered pairs is `k * (k - 1) / 2`. Since we only count `(u, v)` where `u < v`, this is exactly `k * (k - 1) / 2` ordered pairs.\n\n*   **Unidirectional pair:** An ordered pair of nodes `(u, v)` is unidirectional if `u != v`, there's a path from `u` to `v`, and there are no paths from `v` to `u`.\n    *   This means `u` and `v` are in different SCCs, and there's a path from the SCC containing `u` to the SCC containing `v` in the condensation graph (DAG of SCCs).\n\n---\n\n**Part 1: Minimum number of nodes `n`**\n\nTo minimize the total number of nodes `n` for a given `p`, we should try to form SCCs that are as large as possible, because the number of `p`-reachable pairs `k * (k - 1) / 2` grows quadratically with `k`. A single large SCC is more efficient in generating pairs than many small ones.\n\nLet `f(k) = k * (k - 1) / 2`. We want to find the smallest `n` such that we can partition `n` nodes into SCCs `k_1, k_2, ..., k_m` (where `sum(k_i) = n`) such that `sum(f(k_i)) = p`.\n\nWe can use a greedy approach:\n1.  Start with `n = 0` nodes and `p_current = p` pairs needed.\n2.  Iteratively find the largest `k` such that `f(k) <= p_current`.\n3.  Add `k` nodes to `n`, subtract `f(k)` from `p_current`.\n4.  Repeat until `p_current` becomes 0.\n\nThis greedy strategy works because `f(k)` is convex. To achieve a target sum `p` with minimum `n`, we should use as few terms as possible, and each term should be as large as possible.\nThe maximum `k` for which `f(k) <= p` can be found by solving `k * (k - 1) / 2 <= p` for `k`. Approximately `k^2 / 2 <= p`, so `k <= sqrt(2p)`. We can find `k` by iterating or using the quadratic formula. Since `p <= 2 * 10^5`, `2p <= 4 * 10^5`, so `k <= sqrt(4 * 10^5) approx 632`. This is a small range, so iteration is fine.\n\n**Algorithm for minimum `n`:**\n1.  Initialize `min_n = 0`.\n2.  While `p > 0`:\n    a.  Find the largest integer `k` such that `k * (k - 1) / 2 <= p`.\n        *   This can be done by iterating `k` downwards from `approx sqrt(2p) + 2` or using binary search. For `p=0`, `k=1` gives 0 pairs. For `p > 0`, `k >= 2`.\n        *   A simpler way is to find `k` by `k = floor((1 + sqrt(1 + 8p)) / 2)`. This is the exact `k` such that `f(k) <= p` and `f(k+1) > p` if `f(k) = p`. If `f(k) < p`, then this `k` is the largest such integer.\n    b.  Add `k` to `min_n`.\n    c.  Subtract `k * (k - 1) / 2` from `p`.\n3.  The final `min_n` is the minimum number of nodes.\n\n**Example for `p=3`:**\n1. `p=3`.\n2. Largest `k` such that `k*(k-1)/2 <= 3`:\n   `k=1`: `0 <= 3`\n   `k=2`: `1 <= 3`\n   `k=3`: `3 <= 3`\n   `k=4`: `6 > 3`\n   So, `k=3`.\n3. `min_n = 0 + 3 = 3`.\n4. `p = 3 - (3*2/2) = 0`.\n5. `p=0`, stop. `min_n = 3`.\n\n**Example for `p=4`:**\n1. `p=4`.\n2. Largest `k` such that `k*(k-1)/2 <= 4`: `k=3` (`3 <= 4`), `k=4` (`6 > 4`). So, `k=3`.\n3. `min_n = 0 + 3 = 3`.\n4. `p = 4 - (3*2/2) = 4 - 3 = 1`.\n5. `p=1`. Largest `k` such that `k*(k-1)/2 <= 1`: `k=2` (`1 <= 1`), `k=3` (`3 > 1`). So, `k=2`.\n6. `min_n = 3 + 2 = 5`.\n7. `p = 1 - (2*1/2) = 1 - 1 = 0`.\n8. `p=0`, stop. `min_n = 5`.\n\n---\n\n**Part 2: Maximum number of unidirectional pairs for `min_n` nodes**\n\nLet `min_n` be the minimum number of nodes found in Part 1. We need to construct a `p`-reachable graph with `min_n` nodes that maximizes unidirectional pairs.\n\nUnidirectional pairs `(u, v)` exist when `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC but not vice-versa. To maximize such pairs, we want to maximize the \"reachability\" between different SCCs. This is achieved by arranging the SCCs in a chain (a linear order) in the condensation graph.\n\nSuppose we have `m` SCCs with sizes `k_1, k_2, ..., k_m` such that `sum(k_i) = min_n` and `sum(f(k_i)) = p`.\nTo maximize unidirectional pairs, we arrange these `m` SCCs in a line: `SCC_1 -> SCC_2 -> ... -> SCC_m`.\nWe add edges such that there is a path from any node in `SCC_i` to any node in `SCC_j` if `i < j`. For example, add an edge from an arbitrary node in `SCC_i` to an arbitrary node in `SCC_{i+1}` for all `i=1, ..., m-1`.\n\nWith this arrangement:\n*   Any node `u` in `SCC_i` can reach any node `v` in `SCC_j` if `i < j`.\n*   No node `v` in `SCC_j` can reach any node `u` in `SCC_i` if `i < j`.\n*   Thus, for any `u` in `SCC_i` and `v` in `SCC_j` with `i < j`, `(u, v)` is a unidirectional pair.\n\nThe total number of unidirectional pairs is the sum of `k_i * k_j` for all `i < j`.\nThis sum is equivalent to `(sum(k_i))^2 - sum(k_i^2) / 2`.\nMore simply, it's `(min_n * min_n - sum(k_i^2)) / 2`.\nThis is because `sum_{i<j} k_i k_j = ( (sum k_i)^2 - sum k_i^2 ) / 2`.\nHere, `sum k_i = min_n`. So the number of unidirectional pairs is `(min_n^2 - sum(k_i^2)) / 2`.\n\nThe `k_i` values are exactly the sizes of the SCCs determined by the greedy algorithm in Part 1. Let these sizes be `scc_sizes`.\n\n**Algorithm for maximum unidirectional pairs:**\n1.  Initialize `scc_sizes = []`.\n2.  Initialize `min_n = 0`.\n3.  While `p > 0`:\n    a.  Find the largest integer `k` such that `k * (k - 1) / 2 <= p`.\n    b.  Add `k` to `min_n`.\n    c.  Add `k` to `scc_sizes`.\n    d.  Subtract `k * (k - 1) / 2` from `p`.\n4.  Calculate `sum_k_squared = sum(k*k for k in scc_sizes)`.\n5.  `max_unidirectional_pairs = (min_n * min_n - sum_k_squared) // 2`.\n\n**Example for `p=3`:**\n1. `min_n = 3`, `scc_sizes = [3]`.\n2. `sum_k_squared = 3*3 = 9`.\n3. `max_unidirectional_pairs = (3*3 - 9) // 2 = (9 - 9) // 2 = 0`.\n\n**Example for `p=4`:**\n1. `min_n = 5`, `scc_sizes = [3, 2]`.\n2. `sum_k_squared = 3*3 + 2*2 = 9 + 4 = 13`.\n3. `max_unidirectional_pairs = (5*5 - 13) // 2 = (25 - 13) // 2 = 12 // 2 = 6`.\n\n**Edge case `p=0`:**\n1. `p=0`. Loop doesn't run.\n2. `min_n = 0`. `scc_sizes = []`.\n3. `sum_k_squared = 0`.\n4. `max_unidirectional_pairs = (0*0 - 0) // 2 = 0`.\nThis is correct: 0 nodes, 0 pairs.\n\n---\n\n**Implementation Details:**\nThe maximum value of `p` is `2 * 10^5`.\n`sqrt(1 + 8 * 2 * 10^5) = sqrt(1600001) approx 1265`.\nSo `k` will be at most around 633. The loop for `p` will run at most `sqrt(2p)` times (if `k` is always 2), which is around 632 times. Each iteration is constant time. This is very efficient.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    scc_sizes = []\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Roots of k^2 - k - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We need the positive root, and then floor it.\n        # This gives the maximum k such that f(k) <= current_p.\n        k = int((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        \n        # Ensure k*(k-1)/2 does not exceed current_p.\n        # Due to floating point precision, it's safer to check k and k-1.\n        # If (k * (k - 1) // 2) > current_p, then k was slightly overestimated.\n        # This happens if current_p is exactly f(k-1) but sqrt calculation gives k.\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        \n        # k must be at least 2 to form an SCC that contributes pairs.\n        # If current_p > 0, k will always be at least 2 because f(1)=0, f(2)=1.\n        # If current_p = 1, k = 2.\n        # If current_p is positive, k will be >= 2.\n        # The only case k could be 1 is if current_p is 0, but we handle p=0 separately.\n\n        min_n += k\n        scc_sizes.append(k)\n        current_p -= k * (k - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    # This is (min_n^2 - sum(k_i^2)) / 2\n    sum_k_squared = sum(k * k for k in scc_sizes)\n    max_unidirectional_pairs = (min_n * min_n - sum_k_squared) // 2\n\n    print(min_n, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    scc_sizes = []\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Roots of k^2 - k - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We need the positive root, and then floor it.\n        # This gives the maximum k such that f(k) <= current_p.\n        k = int((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        \n        # Ensure k*(k-1)/2 does not exceed current_p.\n        # Due to floating point precision, it's safer to check k and k-1.\n        # If (k * (k - 1) // 2) > current_p, then k was slightly overestimated.\n        # This happens if current_p is exactly f(k-1) but sqrt calculation gives k.\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        \n        # k must be at least 2 to form an SCC that contributes pairs.\n        # If current_p > 0, k will always be at least 2 because f(1)=0, f(2)=1.\n        # If current_p = 1, k = 2.\n        # If current_p is positive, k will be >= 2.\n        # The only case k could be 1 is if current_p is 0, but we handle p=0 separately.\n\n        min_n += k\n        scc_sizes.append(k)\n        current_p -= k * (k - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    # This is (min_n^2 - sum(k_i^2)) / 2\n    sum_k_squared = sum(k * k for k in scc_sizes)\n    max_unidirectional_pairs = (min_n * min_n - sum_k_squared) // 2\n\n    print(min_n, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 3239,
        "thoughts_token_count": 828
    }
}