{
    "start": 1758009401.8199644,
    "end": 1758009561.1140125,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:59 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Initial Thoughts and Problem Decomposition**\n\nAlright, let's tackle this \"Flawed Flow\" problem. I'm looking at an undirected graph with capacities on each edge, and the goal is to direct those edges such that it forms a valid flow network. The key constraints are: flow conservation at intermediate nodes, the source has no incoming flow, the directed graph must be acyclic, and the resulting flow is a maximum flow. The bounds are reasonable (`n, m <= 2 * 10^5`, and `c_i <= 10^4`).  No edge duplication or self-loops, and a solution is guaranteed to exist.\n\n**Deconstructing the Requirements**\n\nMy understanding is that, if we consider `1` as the source and `n` as the sink, the problem can be broken down into these core ideas. First, flow conservation is the primary rule for all nodes except the source. Second, the absence of incoming edges to the source implies that all its incident edges are outgoing. Although not explicitly stated, the sink node's behavior is implied by the flow conservation property on all other nodes and the source's behavior. The acyclic condition is the most interesting; that will guide our strategy.\n\n**Focusing on Acyclicity**\n\nThe crucial requirement seems to be preventing cycles. If we can enforce this, we have a way to generate the required directed graph. Acyclic directed graphs are topologically ordered. If we can find that topological order, that's half the battle.\n\n**Topological Ordering as the Key**\n\nThe guarantee of a solution suggests a specific directed acyclic graph structure exists. Given that, with an acyclic condition, we can think about this problem in terms of a flow through a topological ordering. So the plan is to find a way to induce that ordering from the undirected graph. The source is obviously going to be the earliest node in that order and the sink will be the last node in that order.\n\nNow, how to build this order... A Depth-First Search would be an efficient method for generating the ordering. That's the way forward.  I'll need to carefully consider how to handle the edge directions, given the capacities, to satisfy the flow conditions.  I think a DFS with an assignment of directions based on the order that the edges are traversed could work.\n",
    "response": "The problem asks us to direct edges of a given undirected graph, each with a specified flow volume, such that several conditions are met:\n1.  For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow (flow conservation).\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph has no cycles.\n\nWe need to output `0` if the `i`-th edge `(a_i, b_i)` is directed `a_i -> b_i`, and `1` if it's directed `b_i -> a_i`. The problem guarantees a solution always exists.\n\n**Understanding the Conditions:**\n\n*   **No incoming edges to vertex 1:** This is a strong hint. All edges connected to vertex 1 must be directed *away* from vertex 1.\n*   **No cycles:** This implies that the resulting directed graph must be a Directed Acyclic Graph (DAG).\n*   **Flow conservation for 1 < v < n:** This means that for any such vertex `v`, its net flow (total incoming minus total outgoing) must be zero.\n\n**Strategy - Topological Sort and DFS:**\n\nThe \"no cycles\" condition, combined with the \"no incoming edges to vertex 1\" suggests that vertex 1 can be considered the starting point of a topological sort. We can try to build a topological ordering and direct edges from \"earlier\" to \"later\" vertices.\n\nLet's consider the flow balance. For each vertex `v`, let `balance[v]` be the net flow *out* of `v`. Initially, `balance[v] = 0` for all `v`.\nWhen we direct an edge `u -> v` with flow `c`:\n*   `balance[u]` increases by `c` (flow out of `u`).\n*   `balance[v]` decreases by `c` (flow into `v`).\n\nThe conditions translate to:\n*   `balance[1]` must be positive (net flow out of source).\n*   `balance[n]` must be negative (net flow into sink).\n*   `balance[v] = 0` for `1 < v < n`.\n\nSince we don't know the directions yet, let's think about the total flow incident to a vertex. For each vertex `v`, let `total_incident_flow[v]` be the sum of all `c_i` for edges connected to `v`.\nIf we knew the directions, `total_incident_flow[v]` would be `sum(incoming_flow) + sum(outgoing_flow)`.\nSince `sum(incoming_flow) = sum(outgoing_flow)` for intermediate vertices, this means `total_incident_flow[v] = 2 * sum(incoming_flow) = 2 * sum(outgoing_flow)`. This implies `total_incident_flow[v]` must be an even number for `1 < v < n`.\n\nThis observation is key: for any vertex `v` other than the source (1) or sink (n), the sum of flow on edges directed *into* `v` must equal the sum of flow on edges directed *out of* `v`. This sum is `total_incident_flow[v] / 2`.\n\n**Algorithm:**\n\n1.  **Calculate Initial Sums:** For each vertex `v`, calculate `current_outgoing_flow[v]`, which is the sum of flow volumes of all edges incident to `v` that are *initially assumed* to be directed `v -> neighbor`. Since we don't know directions yet, let's initialize `current_outgoing_flow[v] = 0` for all `v`. We will use this to track the net flow *out* of `v` as we make decisions.\n2.  **Identify Source Edges:** Vertex 1 must have no incoming edges. This means all edges connected to vertex 1 must be directed *out* from vertex 1.\n    *   For each edge `(1, u)` with flow `c`:\n        *   Direct it `1 -> u`.\n        *   Add `c` to `current_outgoing_flow[1]`.\n        *   Add `c` to `current_outgoing_flow[u]` (because `c` is now incoming to `u`, so `u` needs to \"balance\" this by sending `c` out).\n        *   Store this direction in our results.\n3.  **Use a Queue for DFS-like Traversal:** We can use a queue (or a stack for DFS) to process vertices. Initially, add all neighbors `u` of vertex 1 (that are not `n`) to the queue. These are vertices that have received flow from the source and now need to conserve it.\n4.  **Process Vertices:** While the queue is not empty:\n    *   Dequeue a vertex `u`.\n    *   If `u` is `n`, we don't need to do anything for its outgoing flow (it's the sink).\n    *   If `u` is `1`, we already processed it.\n    *   For any other vertex `u` (1 < `u` < `n`):\n        *   We need `current_outgoing_flow[u]` to be `total_incident_flow[u] / 2`.\n        *   If `current_outgoing_flow[u]` is currently less than `total_incident_flow[u] / 2`, it means `u` still needs to send out more flow. This situation won't happen if we process nodes in a topological order.\n        *   If `current_outgoing_flow[u]` is currently greater than `total_incident_flow[u] / 2`, it means `u` has too much outgoing flow, which implies we made a mistake in directing an incoming edge.\n        *   The correct approach is: when we process `u`, we know `u` has received some flow. We need to direct its remaining undirected edges such that `u` sends out exactly `total_incident_flow[u] / 2` flow.\n        *   Let `required_outgoing_flow_from_u = total_incident_flow[u] / 2`.\n        *   Iterate through all undirected edges `(u, v)` (or `(v, u)`) incident to `u`.\n            *   If `u` still needs to send out flow (i.e., `current_outgoing_flow[u]` is less than `required_outgoing_flow_from_u`):\n                *   Direct the edge `u -> v`.\n                *   Add `c` to `current_outgoing_flow[u]`.\n                *   Add `c` to `current_outgoing_flow[v]` (as it's incoming to `v`).\n                *   Mark edge `(u, v)` as directed.\n                *   Add `v` to the queue if it's not `n` and not already processed.\n            *   Otherwise (if `u` has already sent enough flow):\n                *   Direct the edge `v -> u`.\n                *   Add `c` to `current_outgoing_flow[v]`.\n                *   Add `c` to `current_outgoing_flow[u]` (as it's incoming to `u`).\n                *   Mark edge `(u, v)` as directed.\n                *   Add `v` to the queue if it's not `n` and not already processed.\n\nThis approach is flawed because `current_outgoing_flow[v]` is not just the sum of flow *out* of `v`. It tracks the balance.\nLet's redefine `current_balance[v]` as `sum(outgoing_flow) - sum(incoming_flow)`. We want `current_balance[v] = 0` for `1 < v < n`.\n\nRevised Algorithm using DFS (more robust for topological order):\n\n1.  **Data Structures:**\n    *   `adj`: Adjacency list storing `(neighbor, flow_volume, edge_index)`.\n    *   `ans`: Array to store the direction for each edge. Initialize with -1.\n    *   `visited`: Boolean array to track visited vertices in DFS.\n    *   `balance`: Array to track the current net flow *out* of a vertex. Initialize to 0.\n\n2.  **DFS Function `dfs(u)`:**\n    *   Mark `u` as visited.\n    *   For each edge `(u, v)` with flow `c` and original index `idx` in `adj[u]`:\n        *   If `ans[idx]` is already determined (meaning this edge was processed from `v`'s side), continue.\n        *   If `v` is `n` (the sink):\n            *   Direct `u -> n`. `ans[idx] = 0` if `u` was `a_idx`, `1` if `u` was `b_idx`.\n            *   Add `c` to `balance[u]`.\n            *   Subtract `c` from `balance[n]`.\n        *   Else if `v` is not visited:\n            *   Recursively call `dfs(v)`.\n            *   Now `v` and its subtree are processed. `balance[v]` reflects the net flow out of `v` *through its subtree*.\n            *   If `balance[v]` is positive (net flow out of `v` is positive):\n                *   This means `v` needs to receive flow from `u`. So direct `u -> v`.\n                *   `ans[idx] = 0` if `u` was `a_idx`, `1` if `u` was `b_idx`.\n                *   Add `c` to `balance[u]`.\n                *   Subtract `c` from `balance[v]`.\n            *   Else (`balance[v]` is zero or negative):\n                *   This means `v` needs to send flow to `u`. So direct `v -> u`.\n                *   `ans[idx] = 1` if `u` was `a_idx`, `0` if `u` was `b_idx`.\n                *   Add `c` to `balance[v]`.\n                *   Subtract `c` from `balance[u]`.\n        *   Else (`v` is visited and `v` is not `n`): This means `v` is an ancestor or a cross-edge. This case implies a cycle if we direct `u -> v`. However, the \"no cycles\" condition and \"solution always exists\" guarantee that we can avoid this. The crucial part is that `balance[v]` for `1 < v < n` must be zero. If we visit `v` and `balance[v]` is not zero, it means `v` has an imbalance.\n            *   If `balance[v]` is positive, it must send flow to `u`. Direct `v -> u`.\n            *   If `balance[v]` is negative, it must receive flow from `u`. Direct `u -> v`.\n\nThis DFS approach is typical for finding bridges/articulation points, or for processing trees/DAGs. The key insight for flow is that `balance[v]` for `1 < v < n` must be zero. When `dfs(v)` returns, if `balance[v]` is not zero, it means `v` either has excess flow that needs to go to its parent in the DFS tree, or it needs to receive flow from its parent.\n\nLet's refine the DFS:\nThe problem states \"no incoming edges to vertex 1\". This implies vertex 1 is the start of the flow.\nThe \"no cycles\" condition implies a topological ordering. If we perform a DFS from `1`, we can direct edges `u -> v` if `v` is a child in the DFS tree. For back-edges `u -> v` where `v` is an ancestor of `u`, we must direct `v -> u` to avoid cycles.\n\nConsider the `balance[u]` after visiting all children of `u`.\n`balance[u]` will be the sum of flow on edges `u -> child` minus `sum(flow on edges child -> u)`.\nFor `1 < u < n`, we need `balance[u] = 0`.\nIf `balance[u]` is positive, it means `u` has sent out `balance[u]` more than it received. This excess flow must have come from its parent in the DFS tree. So, `u` should receive `balance[u]` from its parent.\nIf `balance[u]` is negative, it means `u` has received `abs(balance[u])` more than it sent. This excess flow must be sent to its parent in the DFS tree. So, `u` should send `abs(balance[u])` to its parent.\n\nThis suggests a post-order traversal (after visiting all children).\n\n**Final Algorithm (DFS based):**\n\n1.  **Initialization:**\n    *   `adj`: Adjacency list, `adj[u]` stores `(v, flow_c, original_edge_idx)`.\n    *   `ans`: Array of size `m`, initialized to -1.\n    *   `balance`: Array of size `n+1`, initialized to 0. This tracks the net flow *out* of a vertex during DFS.\n    *   `visited`: Boolean array of size `n+1`, initialized to `False`.\n\n2.  **DFS Function `dfs(u, p)`:** (where `p` is the parent of `u` in the DFS tree, or 0 if `u` is the root)\n    *   Mark `u` as `visited[u] = True`.\n    *   For each `(v, flow_c, edge_idx)` in `adj[u]`:\n        *   If `v == p` (edge to parent), skip.\n        *   If `ans[edge_idx]` is already determined (meaning this edge was processed from `v`'s side, which happens for back-edges where `v` is an ancestor), continue.\n        *   If `v` is not `visited[v]`: (This is a tree edge, `v` is a child of `u`)\n            *   Recursively call `dfs(v, u)`.\n            *   After `dfs(v, u)` returns, `balance[v]` holds the net flow that `v` (and its subtree) needs to send *out* or receive *in* through the edge `(u, v)`.\n            *   If `balance[v] > 0`: `v` has excess flow that it needs to send out. This flow must go to `u`. So, direct `v -> u`.\n                *   `ans[edge_idx] = 1` if `u` was `a_idx` in the input for this edge, `0` if `u` was `b_idx`.\n                *   `balance[u] += balance[v]` (flow from `v` is incoming to `u`, so it reduces `u`'s net outgoing flow, or increases its net incoming flow. No, it means `u` has to send out `balance[v]` less. `balance[u]` represents flow *out* from `u`. If `v -> u` with `balance[v]` flow, then `u` receives `balance[v]`. So `balance[u]` should decrease by `balance[v]`. Let's use `balance[u]` as `sum(outgoing) - sum(incoming)`. So `balance[u] -= balance[v]`).\n            *   Else (`balance[v] <= 0`): `v` needs to receive `abs(balance[v])` flow. This flow must come from `u`. So, direct `u -> v`.\n                *   `ans[edge_idx] = 0` if `u` was `a_idx`, `1` if `u` was `b_idx`.\n                *   `balance[u] += abs(balance[v])` (flow from `u` to `v` adds to `u`'s net outgoing flow. `balance[u] += abs(balance[v])`).\n        *   Else (`v` is visited and `v != p`): (This is a back-edge or cross-edge)\n            *   This edge must be directed `u -> v` to avoid cycles. (Because `v` is already visited, meaning it's an ancestor or in another processed branch. Directing `v -> u` would create a cycle).\n            *   `ans[edge_idx] = 0` if `u` was `a_idx`, `1` if `u` was `b_idx`.\n            *   `balance[u] += flow_c`. (Flow `u -> v` adds to `u`'s net outgoing).\n            *   `balance[v] -= flow_c`. (Flow `u -> v` is incoming to `v`, reduces `v`'s net outgoing).\n\n    *   Now, `balance[u]` contains `sum(flow_out_of_u_to_children) - sum(flow_in_to_u_from_children) + sum(flow_out_of_u_to_visited_non_parent) - sum(flow_in_to_u_from_visited_non_parent)`.\n    *   The flow `flow_c` on edge `(u, p)` must be directed to balance `balance[u]`.\n    *   If `u == 1` (source):\n        *   All edges from `1` must be outgoing. The `balance[1]` should be `sum(all flow from 1)`.\n        *   The initial `balance[1]` for the DFS should be the total flow from source 1.\n    *   If `u == n` (sink):\n        *   All edges to `n` must be incoming. The `balance[n]` should be `sum(all flow into n)`.\n        *   The initial `balance[n]` for the DFS should be the total flow to sink n.\n\nThis is getting complicated. Let's simplify with the `total_incident_flow[v] / 2` property.\nFor `1 < v < n`, `sum(incoming_flow) = sum(outgoing_flow) = total_incident_flow[v] / 2`.\nLet's track `current_outgoing_flow[v]` for each `v`. This is the flow `v` has already directed *out*.\nWhen we process an edge `(u, v)` with flow `c`:\n*   If we direct `u -> v`: `current_outgoing_flow[u] += c`.\n*   If we direct `v -> u`: `current_outgoing_flow[v] += c`.\n\nThe goal is that for `1 < v < n`, `current_outgoing_flow[v]` eventually becomes `total_incident_flow[v] / 2`.\nFor `v = 1`, `current_outgoing_flow[1]` should be `total_incident_flow[1]`.\nFor `v = n`, `current_outgoing_flow[n]` should be `0`.\n\n**Revised DFS based on `total_incident_flow`:**\n\n1.  **Initialization:**\n    *   `adj`: Adjacency list `adj[u]` stores `(v, flow_c, original_edge_idx)`.\n    *   `ans`: Array of size `m`, initialized to -1.\n    *   `current_outgoing_flow`: Array of size `n+1`, initialized to 0. This tracks the flow *already directed outwards* from `u`.\n    *   `total_incident_flow`: Array of size `n+1`, initialized to 0. Pre-calculate this for all vertices.\n    *   `visited`: Boolean array of size `n+1`, initialized to `False`.\n\n2.  **DFS Function `dfs(u)`:**\n    *   Mark `u` as `visited[u] = True`.\n    *   For each `(v, flow_c, edge_idx)` in `adj[u]`:\n        *   If `ans[edge_idx]` is already determined, continue.\n        *   If `v` is not `visited[v]`:\n            *   Recursively call `dfs(v)`.\n            *   After `dfs(v)` returns, we need to decide the direction of `(u, v)`.\n            *   For `v` (if `v != 1` and `v != n`), its `current_outgoing_flow[v]` should eventually be `total_incident_flow[v] / 2`. If `current_outgoing_flow[v]` is currently less than this target, it means `v` needs to send out more flow. This flow must come from `u`. So `u -> v`.\n            *   If `v` has already sent out enough flow (or too much), it means `v` needs to receive flow. This flow must come from `u`. So `u -> v`.\n            *   This logic is still tricky. The `dfs` ensures a topological ordering. When `dfs(v)` returns, `v` and its subtree are processed. The `current_outgoing_flow[v]` should represent the flow `v` has sent out *within its subtree*.\n            *   The critical observation is that for any `u` (1 < `u` < `n`), `current_outgoing_flow[u]` must be equal to `total_incident_flow[u] / 2`.\n            *   When `dfs(v)` returns, if `v` is not `n`, its `current_outgoing_flow[v]` must be `total_incident_flow[v] / 2`. If it's not, the difference must be made up by the edge `(u, v)`.\n            *   Let `needed_out_from_v = total_incident_flow[v] / 2` (if `v` is not `1` or `n`).\n            *   If `v == n`, `needed_out_from_v = 0`.\n            *   If `v == 1`, `needed_out_from_v = total_incident_flow[1]`.\n            *   If `current_outgoing_flow[v] < needed_out_from_v`: This means `v` still needs to send `needed_out_from_v - current_outgoing_flow[v]` flow. This flow must come from `u`. So `u -> v`.\n                *   `ans[edge_idx] = 0` if `u` was `a_idx`, `1` if `u` was `b_idx`.\n                *   `current_outgoing_flow[u] += flow_c`.\n            *   Else (`current_outgoing_flow[v] >= needed_out_from_v`): This means `v` has already sent enough flow (or too much). The remaining flow on `(u, v)` must be directed `v -> u`.\n                *   `ans[edge_idx] = 1` if `u` was `a_idx`, `0` if `u` was `b_idx`.\n                *   `current_outgoing_flow[v] += flow_c`. (This is flow *into* `u`, so it's flow *out* from `v`).\n        *   Else (`v` is visited and `ans[edge_idx]` is not determined): This is a back-edge or cross-edge.\n            *   If `current_outgoing_flow[u]` is less than `total_incident_flow[u] / 2` (for `u` not `1` or `n`):\n                *   Direct `u -> v`.\n                *   `ans[edge_idx] = 0` if `u` was `a_idx`, `1` if `u` was `b_idx`.\n                *   `current_outgoing_flow[u] += flow_c`.\n            *   Else:\n                *   Direct `v -> u`.\n                *   `ans[edge_idx] = 1` if `u` was `a_idx`, `0` if `u` was `b_idx`.\n                *   `current_outgoing_flow[v] += flow_c`.\n\nThis is still confusing. The `current_outgoing_flow[u]` accumulates flow *out* from `u`. For `u != 1` and `u != n`, its final `current_outgoing_flow[u]` must be `total_incident_flow[u] / 2`.\nThe source `1` has no incoming edges, so all `total_incident_flow[1]` must be outgoing.\nThe sink `n` has no outgoing edges, so `current_outgoing_flow[n]` must be `0`.\n\n**Corrected DFS Logic (Based on examples and standard flow practices):**\n\nThe \"no incoming edges to vertex 1\" is a strong condition. This means all edges connected to `1` must be `1 -> other_node`.\nThe \"no cycles\" condition is also strong. This usually implies a topological sort.\nThe `current_outgoing_flow` should track the *net* flow *out* of `u` from edges *already directed*.\nFor `1 < u < n`, we want `net_flow_out[u] = 0`.\nFor `u = 1`, `net_flow_out[1]` should be the total max flow value.\nFor `u = n`, `net_flow_out[n]` should be `-total_max_flow_value`.\n\nLet `net_flow_out[u]` be the sum of flow on edges `u -> v` minus sum of flow on edges `v -> u` for all edges `(u, v)` where direction is determined.\n\n1.  **Initialization:**\n    *   `adj`: Adjacency list `adj[u]` stores `(v, flow_c, original_edge_idx, is_a_to_b_in_input)`. `is_a_to_b_in_input` is 1 if `u` was `a_i` and `v` was `b_i`, else 0. This helps map `ans[edge_idx]` to 0 or 1.\n    *   `ans`: Array of size `m`, initialized to -1.\n    *   `net_flow_out`: Array of size `n+1`, initialized to 0.\n    *   `visited`: Boolean array of size `n+1`, initialized to `False`.\n\n2.  **DFS Function `dfs(u)`:**\n    *   Mark `u` as `visited[u] = True`.\n    *   For each `(v, flow_c, edge_idx, u_is_a)` in `adj[u]`:\n        *   If `ans[edge_idx]` is already determined, continue.\n        *   If `v` is `1`: (This is an edge `u <-> 1`. Since `1` has no incoming, it must be `1 -> u`. This edge should have been processed from `1`'s DFS call). This case should not happen if `1` is the root of the DFS.\n        *   If `v` is `n`: (Edge `u <-> n`). Since `n` is sink, it should generally only have incoming flow. Direct `u -> n`.\n            *   `ans[edge_idx] = u_is_a`.\n            *   `net_flow_out[u] += flow_c`.\n            *   `net_flow_out[n] -= flow_c`.\n        *   Else if `v` is not `visited[v]`: (Tree edge `u -> v`)\n            *   Recursively call `dfs(v)`.\n            *   After `dfs(v)` returns, `net_flow_out[v]` represents the net flow out of `v` *within its subtree*.\n            *   For `1 < v < n`, `net_flow_out[v]` must ultimately be 0. If `net_flow_out[v]` is not 0, the difference must be balanced by the edge `(u, v)`.\n            *   If `net_flow_out[v] > 0`: `v` has a net outgoing flow. This flow must go into `u`. So, direct `v -> u`.\n                *   `ans[edge_idx] = 1 - u_is_a`.\n                *   `net_flow_out[u] -= net_flow_out[v]`. (Flow `v -> u` is incoming to `u`, so it reduces `u`'s net outgoing flow).\n            *   Else (`net_flow_out[v] <= 0`): `v` has a net incoming flow (or balanced). This means `u` must send flow to `v` to balance `v`. So, direct `u -> v`.\n                *   `ans[edge_idx] = u_is_a`.\n                *   `net_flow_out[u] += abs(net_flow_out[v])`. (Flow `u -> v` adds to `u`'s net outgoing flow).\n        *   Else (`v` is `visited[v]` and `v != 1` and `v != n`): (Back-edge or cross-edge `u <-> v`).\n            *   To avoid cycles, we must direct `u -> v`.\n            *   `ans[edge_idx] = u_is_a`.\n            *   `net_flow_out[u] += flow_c`.\n            *   `net_flow_out[v] -= flow_c`.\n\n3.  **Main:**\n    *   Read `n, m`.\n    *   Populate `adj` and store original edge info.\n    *   Call `dfs(1)`.\n    *   Print `ans`.\n\n**Example Walkthrough (First example):**\n3 3\n3 2 10 (edge 0: a=3, b=2, c=10)\n1 2 10 (edge 1: a=1, b=2, c=10)\n3 1 5  (edge 2: a=3, b=1, c=5)\n\n`adj`:\n1: [(2, 10, 1, 1), (3, 5, 2, 0)] (Note: adj[1] for (3,1,5) means v=3, u_is_a=0)\n2: [(3, 10, 0, 0), (1, 10, 1, 0)]\n3: [(2, 10, 0, 1), (1, 5, 2, 1)]\n\n`ans = [-1, -1, -1]`\n`net_flow_out = [0, 0, 0, 0]`\n`visited = [F, F, F, F]`\n\nCall `dfs(1)`:\n  `visited[1] = T`\n  \n  Edge `(1, 2)` (flow 10, idx 1, `u_is_a=1`):\n    `v=2`, not `visited[2]`. Call `dfs(2)`:\n      `visited[2] = T`\n      \n      Edge `(2, 3)` (flow 10, idx 0, `u_is_a=0` for `(3,2)`):\n        `v=3`, not `visited[3]`. Call `dfs(3)`:\n          `visited[3] = T`\n          \n          Edge `(3, 2)` (flow 10, idx 0, `u_is_a=1` for `(3,2)`):\n            `ans[0]` is not -1. This is the reverse edge of `(2,3)`. It will be handled when `dfs(3)` returns to `dfs(2)`. Skip.\n          \n          Edge `(3, 1)` (flow 5, idx 2, `u_is_a=1` for `(3,1)`):\n            `v=1`. `v` is `1` (source). So `ans[2] = 1` (direct `3 -> 1`).\n            `net_flow_out[3] += 5` (`net_flow_out = [0,0,0,5]`)\n            `net_flow_out[1] -= 5` (`net_flow_out = [-5,0,0,5]`)\n          \n          `dfs(3)` returns. `net_flow_out[3]` is 5.\n        \n        Back in `dfs(2)` for edge `(2, 3)`: `v=3` is `visited[3]`.\n        `net_flow_out[3]` is 5. Since `net_flow_out[3] > 0`, `v` has net outgoing flow, so direct `v -> u` (i.e., `3 -> 2`).\n        `ans[0] = 1 - (u_is_a for (2,3) which is 0) = 1`.\n        `net_flow_out[2] -= net_flow_out[3]` (`net_flow_out[2] -= 5`). (`net_flow_out = [-5,0,-5,5]`)\n      \n      Edge `(2, 1)` (flow 10, idx 1, `u_is_a=0` for `(1,2)`):\n        `ans[1]` is not -1. This is the reverse edge of `(1,2)`. It will be handled when `dfs(2)` returns to `dfs(1)`. Skip.\n      \n      `dfs(2)` returns. `net_flow_out[2]` is -5.\n    \n    Back in `dfs(1)` for edge `(1, 2)`: `v=2` is `visited[2]`.\n    `net_flow_out[2]` is -5. Since `net_flow_out[2] <= 0`, `v` has net incoming flow, so direct `u -> v` (i.e., `1 -> 2`).\n    `ans[1] = u_is_a for (1,2) which is 1`.\n    `net_flow_out[1] += abs(net_flow_out[2])` (`net_flow_out[1] += 5`). (`net_flow_out = [0,0,-5,5]`)\n  \n  Edge `(1, 3)` (flow 5, idx 2, `u_is_a=0` for `(3,1)`):\n    `ans[2]` is already 1. Skip.\n  \n  `dfs(1)` returns.\n\nFinal `ans`: `[1, 1, 1]`.\nOutput:\n1\n1\n1\n\nWait, the example output is `1\\n0\\n1`. My `ans[1]` is `1` but example is `0`.\nMy `ans[1]` means `2 -> 1`. Example `ans[1]` means `1 -> 2`.\nMy `ans[0]` means `3 -> 2`. Example `ans[0]` means `3 -> 2`.\nMy `ans[2]` means `3 -> 1`. Example `ans[2]` means `3 -> 1`.\n\nThe issue is with `v=1` and `v=n` handling.\nVertex 1 has NO incoming edges. So any edge `(u, 1)` must be `1 -> u`.\nVertex `n` is the sink. It typically has NO outgoing edges. So any edge `(n, u)` must be `u -> n`.\n\nLet's adjust the DFS for `v=1` and `v=n`.\nWhen `dfs(u)` processes edge `(u, v)`:\n*   If `v == 1`: Edge is `(u, 1)`. Must be `1 -> u`.\n    *   `ans[edge_idx] = 1 - u_is_a`. (If original was `a_i=u, b_i=1`, then `u_is_a=1`, `ans=0` means `u -> 1`. If original was `a_i=1, b_i=u`, then `u_is_a=0`, `ans=1` means `u -> 1`. This is wrong. It should be `1 -> u`. So if `u_is_a=1`, it means `(u,1)` was `(a_i,b_i)`. We want `1 -> u`, so it's `b_i -> a_i`, meaning `ans = 1`. If `u_is_a=0`, it means `(1,u)` was `(a_i,b_i)`. We want `1 -> u`, so it's `a_i -> b_i`, meaning `ans = 0`. So `ans[edge_idx] = u_is_a` is correct for `1 -> u` if `u` is `b_i` and `1` is `a_i`).\n    *   `net_flow_out[1] += flow_c`.\n    *   `net_flow_out[u] -= flow_c`.\n*   If `v == n`: Edge is `(u, n)`. Must be `u -> n`.\n    *   `ans[edge_idx] = u_is_a`.\n    *   `net_flow_out[u] += flow_c`.\n    *   `net_flow_out[n] -= flow_c`.\n\nThe problem states \"vertex with number 1 has no incoming edges\". It doesn't say \"vertex with number n has no outgoing edges\". However, if we preserve flow for all `1 < v < n`, and `1` only outputs, then `n` must be the sink.\n\nLet's retry the example with this specific handling for 1 and n.\n\n`adj`:\n1: [(2, 10, 1, 1), (3, 5, 2, 0)]  (edge 1: `(1,2)` was `a=1,b=2`, `u_is_a=1`. edge 2: `(3,1)` was `a=3,b=1`, `u_is_a=0` for `(1,3)`)\n2: [(3, 10, 0, 0), (1, 10, 1, 0)] (edge 0: `(3,2)` was `a=3,b=2`, `u_is_a=0` for `(2,3)`. edge 1: `(1,2)` was `a=1,b=2`, `u_is_a=0` for `(2,1)`)\n3: [(2, 10, 0, 1), (1, 5, 2, 1)]  (edge 0: `(3,2)` was `a=3,b=2`, `u_is_a=1`. edge 2: `(3,1)` was `a=3,b=1`, `u_is_a=1`)\n\n`ans = [-1, -1, -1]`\n`net_flow_out = [0, 0, 0, 0]`\n`visited = [F, F, F, F]`\n\nCall `dfs(1)`:\n  `visited[1] = T`\n  \n  Edge `(1, 2)` (flow 10, idx 1, `u_is_a=1`):\n    `v=2`, not `visited[2]`. Call `dfs(2)`:\n      `visited[2] = T`\n      \n      Edge `(2, 3)` (flow 10, idx 0, `u_is_a=0` for `(2,3)`):\n        `v=3`, not `visited[3]`. Call `dfs(3)`:\n          `visited[3] = T`\n          \n          Edge `(3, 2)` (flow 10, idx 0, `u_is_a=1` for `(3,2)`):\n            `ans[0]` is not -1. Skip.\n          \n          Edge `(3, 1)` (flow 5, idx 2, `u_is_a=1` for `(3,1)`):\n            `v=1`. This is edge `(3,1)`. We want `1 -> 3`.\n            If original was `a_i=3, b_i=1`: `u_is_a=1`. We want `b_i -> a_i`. So `ans[2]=1`.\n            If original was `a_i=1, b_i=3`: `u_is_a=0`. We want `a_i -> b_i`. So `ans[2]=0`.\n            Here, original was `(3,1)`. `u=3, v=1`. `u_is_a=1`. We want `1 -> 3`. So `ans[2] = 1`.\n            `net_flow_out[1] += 5` (`net_flow_out = [0,0,0,0] -> [5,0,0,0]`)\n            `net_flow_out[3] -= 5` (`net_flow_out = [5,0,0,-5]`)\n          \n          `dfs(3)` returns. `net_flow_out[3]` is -5.\n        \n        Back in `dfs(2)` for edge `(2, 3)`: `v=3` is `visited[3]`.\n        `net_flow_out[3]` is -5. Since `net_flow_out[3] <= 0`, `v` has net incoming flow. So direct `u -> v` (i.e., `2 -> 3`).\n        `ans[0] = u_is_a for (2,3) which is 0`.\n        `net_flow_out[2] += abs(net_flow_out[3])` (`net_flow_out[2] += 5`). (`net_flow_out = [5,0,5,-5]`)\n      \n      Edge `(2, 1)` (flow 10, idx 1, `u_is_a=0` for `(2,1)`):\n        `v=1`. This is edge `(2,1)`. We want `1 -> 2`.\n        If original was `a_i=2, b_i=1`: `u_is_a=1`. We want `b_i -> a_i`. So `ans[1]=1`.\n        If original was `a_i=1, b_i=2`: `u_is_a=0`. We want `a_i -> b_i`. So `ans[1]=0`.\n        Here, original was `(1,2)`. `u=2, v=1`. `u_is_a=0`. We want `1 -> 2`. So `ans[1]=0`.\n        `net_flow_out[1] += 10` (`net_flow_out = [5,0,5,-5] -> [15,0,5,-5]`)\n        `net_flow_out[2] -= 10` (`net_flow_out = [15,0,-5,-5]`)\n      \n      `dfs(2)` returns. `net_flow_out[2]` is -5.\n    \n    Back in `dfs(1)` for edge `(1, 2)`: `ans[1]` is already 0. Skip.\n  \n  Edge `(1, 3)` (flow 5, idx 2, `u_is_a=0` for `(1,3)`):\n    `ans[2]` is already 1. Skip.\n  \n  `dfs(1)` returns.\n\nFinal `ans`: `[0, 0, 1]`\nOutput:\n0\n0\n1\n\nThis is still not matching the example output `1\\n0\\n1`.\nLet's re-examine `ans[edge_idx]` for `v=1` and `v=n`.\n`u_is_a` is 1 if `u` was `a_i` and `v` was `b_i`. 0 otherwise (i.e., `u` was `b_i` and `v` was `a_i`).\n\nIf `v == 1`: We want `1 -> u`.\n    *   If `u_is_a == 1` (original edge was `u -> 1`): We want `1 -> u`, so `b_i -> a_i`. `ans[edge_idx] = 1`.\n    *   If `u_is_a == 0` (original edge was `1 -> u`): We want `1 -> u`, so `a_i -> b_i`. `ans[edge_idx] = 0`.\n    *   So, `ans[edge_idx] = 1 - u_is_a` for `v == 1`. This is what I used.\n\nIf `v == n`: We want `u -> n`.\n    *   If `u_is_a == 1` (original edge was `u -> n`): We want `u -> n`, so `a_i -> b_i`. `ans[edge_idx] = 0`.\n    *   If `u_is_a == 0` (original edge was `n -> u`): We want `u -> n`, so `b_i -> a_i`. `ans[edge_idx] = 1`.\n    *   So, `ans[edge_idx] = u_is_a`. This is what I used.\n\nThe `u_is_a` means `u` is `a_i` in the input.\nIf `u_is_a` is 1, `(a_i, b_i)` is `(u, v)`. `ans=0` means `u -> v`. `ans=1` means `v -> u`.\nIf `u_is_a` is 0, `(a_i, b_i)` is `(v, u)`. `ans=0` means `v -> u`. `ans=1` means `u -> v`.\n\nLet's use `ans[edge_idx]` directly as 0 for `a_i -> b_i` and 1 for `b_i -> a_i`.\nWhen processing `(u,v)` with flow `c`, `edge_idx`, and original `(orig_a, orig_b)`:\n*   If we decide `u -> v`:\n    *   If `u == orig_a` and `v == orig_b`: `ans[edge_idx] = 0`.\n    *   If `u == orig_b` and `v == orig_a`: `ans[edge_idx] = 1`.\n*   If we decide `v -> u`:\n    *   If `v == orig_a` and `u == orig_b`: `ans[edge_idx] = 0`.\n    *   If `v == orig_b` and `u == orig_a`: `ans[edge_idx] = 1`.\n\nThis is equivalent to:\n*   If `u -> v`: `ans[edge_idx] = 0` if `u == orig_a`, else `1`.\n*   If `v -> u`: `ans[edge_idx] = 0` if `v == orig_a`, else `1`.\n\nLet's use this definition of `u_is_a` for clarity:\n`u_is_a` is `True` if `u == orig_a` for the current edge.\n\n1.  **Initialization:**\n    *   `adj`: Adjacency list `adj[u]` stores `(v, flow_c, edge_idx, orig_a, orig_b)`.\n    *   `ans`: Array of size `m`, initialized to -1.\n    *   `net_flow_out`: Array of size `n+1`, initialized to 0.\n    *   `visited`: Boolean array of size `n+1`, initialized to `False`.\n\n2.  **DFS Function `dfs(u)`:**\n    *   Mark `u` as `visited[u] = True`.\n    *   For each `(v, flow_c, edge_idx, orig_a, orig_b)` in `adj[u]`:\n        *   If `ans[edge_idx]` is already determined, continue.\n        *   If `v == 1`: (Edge `(u,1)`). Must be `1 -> u`.\n            *   `ans[edge_idx] = 0` if `orig_a == 1` else `1`.\n            *   `net_flow_out[1] += flow_c`.\n            *   `net_flow_out[u] -= flow_c`.\n        *   Else if `v == n`: (Edge `(u,n)`). Must be `u -> n`.\n            *   `ans[edge_idx] = 0` if `orig_a == u` else `1`.\n            *   `net_flow_out[u] += flow_c`.\n            *   `net_flow_out[n] -= flow_c`.\n        *   Else if `v` is not `visited[v]`: (Tree edge `u -> v`)\n            *   Recursively call `dfs(v)`.\n            *   If `net_flow_out[v] > 0`: `v` has net outgoing flow. Direct `v -> u`.\n                *   `ans[edge_idx] = 0` if `orig_a == v` else `1`.\n                *   `net_flow_out[u] -= net_flow_out[v]`.\n            *   Else (`net_flow_out[v] <= 0`): `v` has net incoming flow (or balanced). Direct `u -> v`.\n                *   `ans[edge_idx] = 0` if `orig_a == u` else `1`.\n                *   `net_flow_out[u] += abs(net_flow_out[v])`.\n        *   Else (`v` is `visited[v]` and `v != 1` and `v != n`): (Back-edge or cross-edge `u <-> v`).\n            *   Direct `u -> v` to avoid cycles.\n            *   `ans[edge_idx] = 0` if `orig_a == u` else `1`.\n            *   `net_flow_out[u] += flow_c`.\n            *   `net_flow_out[v] -= flow_c`.\n\nLet's re-run the example.\n3 3\n3 2 10 (edge 0: orig_a=3, orig_b=2, c=10)\n1 2 10 (edge 1: orig_a=1, orig_b=2, c=10)\n3 1 5  (edge 2: orig_a=3, orig_b=1, c=5)\n\n`adj`:\n1: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]\n2: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]\n3: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]\n\n`ans = [-1, -1, -1]`\n`net_flow_out = [0, 0, 0, 0]`\n`visited = [F, F, F, F]`\n\nCall `dfs(1)`:\n  `visited[1] = T`\n  \n  Edge `(1, 2)` (flow 10, idx 1, orig_a=1, orig_b=2):\n    `v=2`, not `visited[2]`. Call `dfs(2)`:\n      `visited[2] = T`\n      \n      Edge `(2, 3)` (flow 10, idx 0, orig_a=3, orig_b=2):\n        `v=3`, not `visited[3]`. Call `dfs(3)`:\n          `visited[3] = T`\n          \n          Edge `(3, 2)` (flow 10, idx 0, orig_a=3, orig_b=2):\n            `ans[0]` is not -1. Skip.\n          \n          Edge `(3, 1)` (flow 5, idx 2, orig_a=3, orig_b=1):\n            `v=1`. Must be `1 -> 3`.\n            `ans[2] = 0` if `orig_a==1` (False) else `1`. So `ans[2]=1`. (Means `orig_b -> orig_a`, `1 -> 3`).\n            `net_flow_out[1] += 5` (`net_flow_out = [5,0,0,0]`)\n            `net_flow_out[3] -= 5` (`net_flow_out = [5,0,0,-5]`)\n          \n          `dfs(3)` returns. `net_flow_out[3]` is -5.\n        \n        Back in `dfs(2)` for edge `(2, 3)`: `v=3` is `visited[3]`.\n        `net_flow_out[3]` is -5. Since `net_flow_out[3] <= 0`, direct `u -> v` (i.e., `2 -> 3`).\n        `ans[0] = 0` if `orig_a==2` (False) else `1`. So `ans[0]=1`. (Means `orig_b -> orig_a`, `2 -> 3`).\n        `net_flow_out[2] += abs(net_flow_out[3])` (`net_flow_out[2] += 5`). (`net_flow_out = [5,0,5,-5]`)\n      \n      Edge `(2, 1)` (flow 10, idx 1, orig_a=1, orig_b=2):\n        `v=1`. Must be `1 -> 2`.\n        `ans[1] = 0` if `orig_a==1` (True) else `1`. So `ans[1]=0`. (Means `orig_a -> orig_b`, `1 -> 2`).\n        `net_flow_out[1] += 10` (`net_flow_out = [5,0,5,-5] -> [15,0,5,-5]`)\n        `net_flow_out[2] -= 10` (`net_flow_out = [15,0,-5,-5]`)\n      \n      `dfs(2)` returns. `net_flow_out[2]` is -5.\n    \n    Back in `dfs(1)` for edge `(1, 2)`: `ans[1]` is already 0. Skip.\n  \n  Edge `(1, 3)` (flow 5, idx 2, orig_a=3, orig_b=1):\n    `ans[2]` is already 1. Skip.\n  \n  `dfs(1)` returns.\n\nFinal `ans`: `[1, 0, 1]`\nThis matches the example output!\n\nThe logic for `v==1` and `v==n` should be handled before the `v` not visited / `v` visited cases.\nThe \"no cycles\" condition is naturally handled by DFS tree edges and back-edges. We always direct `u -> v` for back-edges where `v` is an ancestor of `u`. The problem guarantees a solution exists, so this logic should work.\n\nOne edge case: if `n=2`, then `dfs(1)` will only encounter `v=n`.\n`dfs(1)`:\n  Edge `(1, 2)` (flow `c`, idx, orig_a, orig_b):\n    `v=n`. Must be `1 -> n`.\n    `ans[idx] = 0` if `orig_a==1` else `1`.\n    `net_flow_out[1] += c`.\n    `net_flow_out[n] -= c`.\nThis seems correct.\n\nPython recursion limit: `n, m <= 2 * 10^5`. Max recursion depth needs to be increased.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Increased for deep recursion\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input_order = [] # To store (a, b, c) in input order for processing\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        # Store (neighbor, flow_c, edge_idx, original_a, original_b)\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        edges_input_order.append((u, v, c)) # Not strictly needed for logic, but good for debugging\n\n    ans = [-1] * m\n    net_flow_out = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    def dfs(u):\n        visited[u] = True\n\n        for v, flow_c, edge_idx, orig_a, orig_b in adj[u]:\n            if ans[edge_idx] != -1:\n                # This edge has already been directed by a previous DFS call (from v's side)\n                continue\n\n            if v == 1:\n                # Edge to source (1). Must be directed 1 -> u.\n                if orig_a == 1: # Original edge was (1, u), so 1 -> u is a_i -> b_i\n                    ans[edge_idx] = 0\n                else: # Original edge was (u, 1), so 1 -> u is b_i -> a_i\n                    ans[edge_idx] = 1\n                net_flow_out[1] += flow_c\n                net_flow_out[u] -= flow_c\n            elif v == n:\n                # Edge to sink (n). Must be directed u -> n.\n                if orig_a == u: # Original edge was (u, n), so u -> n is a_i -> b_i\n                    ans[edge_idx] = 0\n                else: # Original edge was (n, u), so u -> n is b_i -> a_i\n                    ans[edge_idx] = 1\n                net_flow_out[u] += flow_c\n                net_flow_out[n] -= flow_c\n            elif not visited[v]:\n                # Tree edge: v is a child of u in DFS tree\n                dfs(v)\n                # After DFS(v) returns, net_flow_out[v] indicates if v needs to send/receive flow\n                if net_flow_out[v] > 0:\n                    # v has a net outgoing flow, so u must receive flow from v (v -> u)\n                    if orig_a == v: # Original edge was (v, u), so v -> u is a_i -> b_i\n                        ans[edge_idx] = 0\n                    else: # Original edge was (u, v), so v -> u is b_i -> a_i\n                        ans[edge_idx] = 1\n                    net_flow_out[u] -= net_flow_out[v]\n                else:\n                    # v has a net incoming flow (or balanced), so u must send flow to v (u -> v)\n                    if orig_a == u: # Original edge was (u, v), so u -> v is a_i -> b_i\n                        ans[edge_idx] = 0\n                    else: # Original edge was (v, u), so u -> v is b_i -> a_i\n                        ans[edge_idx] = 1\n                    net_flow_out[u] += abs(net_flow_out[v]) # abs() because net_flow_out[v] is <= 0\n            else:\n                # Cross-edge or back-edge to an already visited node (v != 1, v != n)\n                # To avoid cycles, direct u -> v.\n                if orig_a == u: # Original edge was (u, v), so u -> v is a_i -> b_i\n                    ans[edge_idx] = 0\n                else: # Original edge was (v, u), so u -> v is b_i -> a_i\n                    ans[edge_idx] = 1\n                net_flow_out[u] += flow_c\n                net_flow_out[v] -= flow_c\n\n    dfs(1) # Start DFS from the source\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Increased for deep recursion\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input_order = [] # To store (a, b, c) in input order for processing\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        # Store (neighbor, flow_c, edge_idx, original_a, original_b)\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        edges_input_order.append((u, v, c)) # Not strictly needed for logic, but good for debugging\n\n    ans = [-1] * m\n    net_flow_out = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    def dfs(u):\n        visited[u] = True\n\n        for v, flow_c, edge_idx, orig_a, orig_b in adj[u]:\n            if ans[edge_idx] != -1:\n                # This edge has already been directed by a previous DFS call (from v's side)\n                continue\n\n            if v == 1:\n                # Edge to source (1). Must be directed 1 -> u.\n                if orig_a == 1: # Original edge was (1, u), so 1 -> u is a_i -> b_i\n                    ans[edge_idx] = 0\n                else: # Original edge was (u, 1), so 1 -> u is b_i -> a_i\n                    ans[edge_idx] = 1\n                net_flow_out[1] += flow_c\n                net_flow_out[u] -= flow_c\n            elif v == n:\n                # Edge to sink (n). Must be directed u -> n.\n                if orig_a == u: # Original edge was (u, n), so u -> n is a_i -> b_i\n                    ans[edge_idx] = 0\n                else: # Original edge was (n, u), so u -> n is b_i -> a_i\n                    ans[edge_idx] = 1\n                net_flow_out[u] += flow_c\n                net_flow_out[n] -= flow_c\n            elif not visited[v]:\n                # Tree edge: v is a child of u in DFS tree\n                dfs(v)\n                # After DFS(v) returns, net_flow_out[v] indicates if v needs to send/receive flow\n                if net_flow_out[v] > 0:\n                    # v has a net outgoing flow, so u must receive flow from v (v -> u)\n                    if orig_a == v: # Original edge was (v, u), so v -> u is a_i -> b_i\n                        ans[edge_idx] = 0\n                    else: # Original edge was (u, v), so v -> u is b_i -> a_i\n                        ans[edge_idx] = 1\n                    net_flow_out[u] -= net_flow_out[v]\n                else:\n                    # v has a net incoming flow (or balanced), so u must send flow to v (u -> v)\n                    if orig_a == u: # Original edge was (u, v), so u -> v is a_i -> b_i\n                        ans[edge_idx] = 0\n                    else: # Original edge was (v, u), so u -> v is b_i -> a_i\n                        ans[edge_idx] = 1\n                    net_flow_out[u] += abs(net_flow_out[v]) # abs() because net_flow_out[v] is <= 0\n            else:\n                # Cross-edge or back-edge to an already visited node (v != 1, v != n)\n                # To avoid cycles, direct u -> v.\n                if orig_a == u: # Original edge was (u, v), so u -> v is a_i -> b_i\n                    ans[edge_idx] = 0\n                else: # Original edge was (v, u), so u -> v is b_i -> a_i\n                    ans[edge_idx] = 1\n                net_flow_out[u] += flow_c\n                net_flow_out[v] -= flow_c\n\n    dfs(1) # Start DFS from the source\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 14104,
        "thoughts_token_count": 848
    }
}