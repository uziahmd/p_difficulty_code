{
    "start": 1758009311.7058406,
    "end": 1758009374.9339423,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Understanding Snowflake Graph Vertex Counts**\n\nOkay, so I need to create a Python script to figure out if a number, let's call it `n`, could be the number of vertices in a \"snowflake\" graph. I need to understand the rules and how the number of vertices changes as the graph grows.\n\nBasically, it starts with a center vertex. Then, we add `k` vertices connected to the center, where `k` is greater than 1. So, after the first step, we have `1 + k` vertices. These new vertices become \"leaves\" because they're only connected to the center initially.\n\nThe core rule is that each leaf (a vertex connected to only one other) gets connected to `k` *new* vertices. This step can happen multiple times (at least once).\n\nLet's break it down:\n\n*   **Step 1:** We have the center vertex and connect it to `k` new vertices. Total: `1 + k`.\n*   **Step 2 (and beyond):** Each of the initial `k` leaf vertices connects to `k` new ones, adding `k * k = k^2` new vertices. So, now we have `1 + k + k^2` vertices, and the `k^2` new vertices are leaves.\n\nThe key is that this second step can be repeated. If we do it once (m=1), we have `1 + k + k^2` vertices. If we do it twice (m=2), we add `k^3` more vertices, getting `1 + k + k^2 + k^3`, and so on.\n\nThe number of vertices will follow the pattern of the sum of a geometric series. We're looking at `n = 1 + k + k^2 + k^3 + ... + k^m` for some value of `m`, where each new term represents applying the rule a further time.\n\nSo, my script needs to figure out if, for a given `n`, I can find valid values of `k > 1` and `m >= 1` that satisfy this equation. The challenge is effectively to reverse-engineer this sum and determine if a valid `k` exists for the provided `n`.\n",
    "response": "The problem asks us to determine if a given number `n` can be the total number of vertices in a \"snowflake\" graph. A snowflake is constructed as follows:\n1. Start with 1 vertex (the center).\n2. Connect the center to `k` new vertices, where `k > 1`.\n3. Each vertex that is connected to only one other vertex (a leaf) is connected to `k` more new vertices. This step must be done at least once.\n\nLet's analyze the number of vertices.\n- Initially, we have 1 vertex (the center).\n- In step 2, `k` new vertices are added. Total vertices: `1 + k`. These `k` vertices are leaves.\n- In step 3, the rule \"each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices\" is applied. This step must be done at least once.\n\nLet `m` be the number of times this step 3 is performed. Since it must be done at least once, `m >= 1`.\n\n- If step 3 is performed once (`m=1`):\n  The `k` leaves from step 2 each connect to `k` new vertices. This adds `k * k = k^2` vertices.\n  Total vertices: `1 + k + k^2`. The `k^2` newly added vertices are now leaves.\n\n- If step 3 is performed twice (`m=2`):\n  After `m=1`, we have `1 + k + k^2` vertices, and `k^2` of them are leaves.\n  These `k^2` leaves each connect to `k` new vertices, adding `k^2 * k = k^3` vertices.\n  Total vertices: `1 + k + k^2 + k^3`. The `k^3` newly added vertices are now leaves.\n\n- In general, if step 3 is performed `m` times:\n  The total number of vertices will be `1 + k + k^2 + ... + k^(m+1)`.\n  This is a geometric series sum: `(k^(m+2) - 1) / (k - 1)`.\n\nSo, we are looking for `n` such that `n = (k^(m+2) - 1) / (k - 1)` for some integers `k > 1` and `m >= 1`.\nLet `p = m+1`. Since `m >= 1`, we have `p >= 2`.\nThe formula becomes `n = 1 + k + k^2 + ... + k^p`.\nHere, `p` represents the \"depth\" of the snowflake, or the number of layers of branches after the center. The center is layer 0, the first `k` vertices are layer 1, and so on, up to layer `p`.\n\nWe need to check if a given `n` can be expressed in this form.\n\nCase 1: `p = 2` (equivalent to `m=1`).\n`n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a positive integer greater than 1:\n- `4n - 3` must be a perfect square. Let `4n - 3 = s^2` for some integer `s`.\n- `s` must be odd, because `s^2 = 4n - 3` implies `s^2 % 4 = -3 % 4 = 1`. Only odd squares are congruent to 1 mod 4.\n- `k = (-1 + s) / 2`. We need `k > 1`, which means `(-1 + s) / 2 > 1 => -1 + s > 2 => s > 3`.\nSo, for `p=2`, we check if `4n-3` is a perfect square `s^2` where `s > 3`. If it is, then `k = (s-1)/2` is a valid `k`.\n\nCase 2: `p >= 3`.\n`n = 1 + k + k^2 + ... + k^p = (k^(p+1) - 1) / (k - 1)`.\nHere, `k >= 2` and `p >= 3`.\nFor a fixed `p`, we need to find if there exists an integer `k >= 2` such that `n = (k^(p+1) - 1) / (k - 1)`.\nThis can be rewritten as `n(k-1) = k^(p+1) - 1`.\nSince `k >= 2`, `k-1 >= 1`.\nAlso, `k^p < n` and `k^(p+1) > n(k-1)`.\nA simple bound for `k` can be found from `k^p < n`. This means `k < n^(1/p)`.\nSince `p >= 3`, `k < n^(1/3)`.\nFor `n <= 10^18`, `n^(1/3)` is at most `(10^18)^(1/3) = 10^6`.\nSo, for `p >= 3`, `k` can be at most `10^6`. This range is small enough to iterate through `k`.\nHowever, `p` can also be large. For `k=2`, `n = 2^(p+1) - 1`. If `n=10^18`, then `2^(p+1)` is roughly `10^18`, so `p+1` is roughly `log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79`. So `p` can be up to around 58.\n\nIterating through `p` up to `~60` and for each `p`, iterating `k` up to `10^6` would be too slow (`60 * 10^6` operations per test case, `10^4` test cases).\n\nInstead, let's iterate through `k` for `p >= 3`.\nFor a fixed `k`, we need to find if there exists an integer `p >= 3` such that `n = 1 + k + ... + k^p`.\nThis means `n(k-1) + 1 = k^(p+1)`.\nSo, we need to check if `n(k-1) + 1` is a perfect power of `k` with exponent `p+1 >= 4`.\nWe can use binary search or `log` to find `p+1`.\nSpecifically, we are looking for `k^(p+1) = V`, where `V = n(k-1) + 1`.\nWe can check if `V` is a perfect power of `k` by computing `log_k(V)`.\n`p+1 = log_k(V) = log(V) / log(k)`.\nIf `log(V) / log(k)` is an integer `X`, then `p+1 = X`. We then check if `X >= 4`.\nThe maximum value of `k` to check:\nIf `k=2`, `n = 2^(p+1) - 1`. `p+1` can be up to `~60`.\nIf `k` increases, `p` decreases.\nFor `p=3`, `n = 1 + k + k^2 + k^3`. `k^3 < n`. So `k < n^(1/3)`. Max `k` is `10^6`.\nFor `p=4`, `n = 1 + k + k^2 + k^3 + k^4`. `k^4 < n`. So `k < n^(1/4)`. Max `k` is `(10^18)^(1/4) = 10^(4.5) approx 31622`.\nAs `p` increases, the maximum `k` decreases.\nThe largest `k` we need to check is for `p=3`, which is `k < 10^6`.\nSo, we can iterate `k` from `2` up to `10^6`.\nFor each `k`:\n  Calculate `V = n * (k - 1) + 1`.\n  If `V <= 0` (which can happen if `n*(k-1)` overflows, but `n*(k-1)` can be up to `10^18 * 10^6 = 10^24`, which fits in Python's arbitrary precision integers), or if `V=1` (implies `k=1` or `p+1=0`), skip.\n  We need to check if `V` is a perfect power of `k`.\n  We can compute `root = round(V**(1/(p+1)))` and check `root**(p+1) == V`.\n  A more robust way for `k^(p+1) = V` is to compute `X = round(log(V) / log(k))`. Then check `k^X == V`.\n  If `k^X == V` and `X >= 4`, then `n` is a valid snowflake number.\n\nCombining these:\n1. Handle `p=2` case:\n   Calculate `s_squared = 4*n - 3`.\n   Check if `s_squared` is a perfect square `s^2`.\n   If it is, and `s > 3`, then `k = (s - 1) / 2` is an integer `> 1`. If this condition holds, `n` is a snowflake number.\n\n2. Handle `p >= 3` cases:\n   Iterate `k` from `2` up to `10^6`.\n   For each `k`:\n     Calculate `val = n * (k - 1) + 1`.\n     If `val <= k` (e.g., if `n=1`, `val=1`, but `k^(p+1)` must be at least `k^4`), continue.\n     Calculate `p_plus_1 = round(math.log(val, k))`.\n     Check if `k**p_plus_1 == val` and `p_plus_1 >= 4`.\n     If both are true, `n` is a snowflake number.\n\nMaximum `k` for `p >= 3`:\nWhen `p=3`, `n = 1 + k + k^2 + k^3`. `k^3 < n`. Max `k` is `(10^18)^(1/3) = 10^6`.\nWhen `k=2`, `n = 2^(p+1) - 1`. `p+1` can be up to `~60`.\nThe loop for `k` goes up to `10^6`. `math.log` and `**` operations are efficient enough.\nThe total complexity would be `O(sqrt(N))` for `p=2` and `O(K_max * log(N))` for `p>=3`, where `K_max = 10^6`.\n`10^6 * log(10^18) approx 10^6 * 60` operations per test case. This is `6 * 10^7`, which is acceptable for `10^4` test cases.\n\nEdge case `n=1`: `4*1-3 = 1`. `s=1`. `s > 3` is false. So `n=1` is not a snowflake for `p=2`.\nFor `p>=3`, `k=2`, `n=1`: `val = 1*(2-1)+1 = 2`. `log2(2) = 1`. `p_plus_1 = 1`, which is not `>=4`. So `n=1` is not a snowflake. Correct, as the minimum snowflake has `1+2+2^2 = 7` vertices for `k=2, m=1`.\n\nLet's check the given examples:\n- `n=1`: NO (correct)\n- `n=2`: NO (`4*2-3 = 5` not square). For `k=2`, `val = 2*(2-1)+1 = 3`. `log2(3)` is not integer. NO.\n- `n=3`: NO (`4*3-3 = 9`. `s=3`. `s > 3` is false). For `k=2`, `val = 3*(2-1)+1 = 4`. `log2(4)=2`. `p_plus_1 = 2`, not `>=4`. NO.\n- `n=6`: NO (`4*6-3 = 21` not square). For `k=2`, `val = 6*(2-1)+1 = 7`. `log2(7)` not integer. NO.\n- `n=13`: YES. `4*13-3 = 52-3 = 49 = 7^2`. `s=7`. `s > 3` is true. `k = (7-1)/2 = 3`. So `n=13` is `1+3+3^2`. YES.\n- `n=15`: YES. `4*15-3 = 57` not square. For `k=2`, `val = 15*(2-1)+1 = 16`. `log2(16) = 4`. `p_plus_1 = 4`. `4 >= 4` is true. So `n=15` is `1+2+2^2+2^3`. YES.\n- `n=255`: YES. `4*255-3 = 1020-3 = 1017` not square. For `k=2`, `val = 255*(2-1)+1 = 256`. `log2(256) = 8`. `p_plus_1 = 8`. `8 >= 4` is true. So `n=255` is `1+2+...+2^7`. YES.\n- `n=10101`: YES. `4*10101-3 = 40404-3 = 40401`. `sqrt(40401) = 201`. `s=201`. `s > 3` is true. `k = (201-1)/2 = 100`. So `n=10101` is `1+100+100^2`. YES.\n- `n=10^18`: NO. `4*10^18-3` is not a perfect square (ends in 7). For `k` loop, no `k` should work.\n\nThe maximum value for `k` in the loop `k < 10^6` is sufficient for `p >= 3`.\nIf `k = 10^6`, `p=3`, `n = 1 + 10^6 + (10^6)^2 + (10^6)^3 approx 10^18`.\nIf `k` is larger, `p` must be smaller.\nIf `p=3`, `k^3 < n`. So `k < n^(1/3)`. If `n=10^18`, `k < 10^6`.\nIf `p=4`, `k^4 < n`. So `k < n^(1/4)`. If `n=10^18`, `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\nSo iterating `k` up to `10^6` covers all `p >= 3` cases.\n\nFinal check on `p_plus_1 >= 4`.\nThe number of terms in the sum `1 + k + ... + k^p` is `p+1`.\nThe rule says \"This step should be done at least once\". This means `m >= 1`.\n`p = m+1`, so `p >= 2`.\nIf `p=2`, this is `1+k+k^2`. This corresponds to `p_plus_1 = 3`.\nThe `p=2` case is handled by `4n-3 = s^2` check.\nThe loop for `k` handles `p >= 3`, which means `p+1 >= 4`. So `p_plus_1 >= 4` is correct.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: p = 2 (m = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # For k to be a valid integer > 1:\n    #   1. 4n - 3 must be a perfect square.\n    #   2. sqrt(4n - 3) must be odd (so that -1 + sqrt is even).\n    #      4n - 3 = s^2. s^2 % 4 = 1 (since 4n-3 is odd, s must be odd, odd^2 % 4 = 1). This is always true if s is an integer.\n    #   3. (-1 + s) / 2 > 1 => s > 3.\n    \n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        s = int(math.isqrt(discriminant)) # integer square root\n        if s * s == discriminant:\n            # s is an integer square root\n            if s > 3: # Check s > 3 for k > 1\n                # k = (-1 + s) / 2\n                # Since s is odd (as 4n-3 is odd), -1+s is even, so k is an integer.\n                # k will be > 1 because s > 3.\n                print(\"YES\")\n                return\n\n    # Case 2: p >= 3 (m >= 2)\n    # n = 1 + k + k^2 + ... + k^p\n    # n * (k - 1) = k^(p+1) - 1\n    # n * (k - 1) + 1 = k^(p+1)\n    # Here, p >= 3, so p+1 >= 4.\n    # We iterate k from 2 up to a reasonable limit.\n    # If p=3, n = 1 + k + k^2 + k^3. k^3 < n, so k < n^(1/3).\n    # For n = 10^18, k < (10^18)^(1/3) = 10^6.\n    # So, k_max = 10^6 is sufficient.\n    \n    # Using a slightly higher limit for safety, e.g., 10^6 + 5.\n    # Or just 10^6, as k must be an integer.\n    K_MAX_FOR_P_GE_3 = 10**6 + 2 # Max k for p=3, n=10^18 is 10^6.\n                                 # A slightly larger value like 10^6+2 ensures we cover edge cases\n                                 # (e.g., if n is just slightly larger than k^3 for k=10^6).\n                                 # However, it's safer to use n^(1/3) as the upper bound for k.\n                                 # For n=10^18, k_max is 10^6.\n                                 # For n=10^18, k=10^6, 1+k+k^2+k^3 = 1+10^6+10^12+10^18, which is > 10^18.\n                                 # So k must be strictly less than 10^6.\n                                 # Let's use an upper bound of 10^6.\n\n    # The maximum possible value for k is when p=3.\n    # k^3 < n. So k < n^(1/3).\n    # For n = 10^18, k < 10^6.\n    # So, we only need to check k up to 10^6.\n    \n    # Python's math.log handles large numbers.\n    # But for k=2, n can be 2^60-1.\n    # For k=10^6, p can be 3.\n    # So iterating k from 2 to 10^6 is correct.\n\n    for k in range(2, K_MAX_FOR_P_GE_3):\n        # Calculate V = n * (k - 1) + 1\n        # V can be up to 10^18 * (10^6 - 1) + 1 approx 10^24. Python handles large integers.\n        V = n * (k - 1) + 1\n        \n        # If V is 1, it means n*(k-1) = 0, which implies n=0 or k=1, neither is allowed.\n        # Or if V is small, say V < k^4, then p+1 cannot be >= 4.\n        # Smallest possible k^(p+1) is k^4 (when p=3).\n        if V <= k**3: # V must be at least k^4 for p+1 >= 4\n            continue\n        \n        # Check if V is a perfect power of k\n        # p_plus_1 = log_k(V) = log(V) / log(k)\n        \n        # Use math.log for floating point log, then round to nearest integer.\n        # This can be slightly imprecise for very large numbers or powers.\n        # A more robust check for k^X = V:\n        # Calculate X = round(math.log(V) / math.log(k))\n        # Then check if k**X == V.\n        \n        # For precision, it's better to compute root_k_V = V**(1/(p+1))\n        # But we don't know p+1 yet.\n        # So we estimate p+1 using log.\n        \n        # Since k is small, k^X can be computed directly.\n        # The maximum X for k=2 and n=10^18 is around 60.\n        # The maximum X for k=10^6 and n=10^18 is 4 (for p=3).\n        \n        # Calculate X = round(math.log(V, k))\n        # This can be problematic if V is not a perfect power of k,\n        # e.g., if log_k(V) is 3.9999999999999996, round gives 4.\n        # A safer way is to check X and X-1.\n        \n        # Estimate X\n        X_approx = math.log(V) / math.log(k)\n        \n        # Check integer parts around X_approx\n        X_candidates = [math.floor(X_approx), math.ceil(X_approx)]\n        \n        for X in X_candidates:\n            if X < 4: # We need p+1 >= 4\n                continue\n            \n            # Check for potential overflow if k**X is too large,\n            # but Python handles arbitrary precision integers.\n            # However, V can be 10^24, so k^X should be checked carefully.\n            # k^X can be very large.\n            # Check if k^X equals V.\n            # If k is large, X will be small.\n            # If k is small (e.g., k=2), X can be large (up to ~80 for 10^24).\n            \n            # Direct computation of k**X\n            current_power = 1\n            for _ in range(X):\n                if current_power > V // k: # Avoid overflow for intermediate product, check if next mult will exceed V\n                    current_power = V + 1 # Mark as too large\n                    break\n                current_power *= k\n            \n            if current_power == V:\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: p = 2 (m = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # For k to be a valid integer > 1:\n    #   1. 4n - 3 must be a perfect square.\n    #   2. sqrt(4n - 3) must be odd (so that -1 + sqrt is even).\n    #      4n - 3 = s^2. s^2 % 4 = 1 (since 4n-3 is odd, s must be odd, odd^2 % 4 = 1). This is always true if s is an integer.\n    #   3. (-1 + s) / 2 > 1 => s > 3.\n    \n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        s = int(math.isqrt(discriminant)) # integer square root\n        if s * s == discriminant:\n            # s is an integer square root\n            if s > 3: # Check s > 3 for k > 1\n                # k = (-1 + s) / 2\n                # Since s is odd (as 4n-3 is odd), -1+s is even, so k is an integer.\n                # k will be > 1 because s > 3.\n                print(\"YES\")\n                return\n\n    # Case 2: p >= 3 (m >= 2)\n    # n = 1 + k + k^2 + ... + k^p\n    # n * (k - 1) = k^(p+1) - 1\n    # n * (k - 1) + 1 = k^(p+1)\n    # Here, p >= 3, so p+1 >= 4.\n    # We iterate k from 2 up to a reasonable limit.\n    # If p=3, n = 1 + k + k^2 + k^3. k^3 < n, so k < n^(1/3).\n    # For n = 10^18, k < (10^18)^(1/3) = 10^6.\n    # So, k_max = 10^6 is sufficient.\n    \n    # Using a slightly higher limit for safety, e.g., 10^6 + 5.\n    # Or just 10^6, as k must be an integer.\n    K_MAX_FOR_P_GE_3 = 10**6 + 2 # Max k for p=3, n=10^18 is 10^6.\n                                 # A slightly larger value like 10^6+2 ensures we cover edge cases\n                                 # (e.g., if n is just slightly larger than k^3 for k=10^6).\n                                 # However, it's safer to use n^(1/3) as the upper bound for k.\n                                 # For n=10^18, k_max is 10^6.\n                                 # For n=10^18, k=10^6, 1+k+k^2+k^3 = 1+10^6+10^12+10^18, which is > 10^18.\n                                 # So k must be strictly less than 10^6.\n                                 # Let's use an upper bound of 10^6.\n\n    # The maximum possible value for k is when p=3.\n    # k^3 < n. So k < n^(1/3).\n    # For n = 10^18, k < 10^6.\n    # So, we only need to check k up to 10^6.\n    \n    # Python's math.log handles large numbers.\n    # But for k=2, n can be 2^60-1.\n    # For k=10^6, p can be 3.\n    # So iterating k from 2 to 10^6 is correct.\n\n    for k in range(2, K_MAX_FOR_P_GE_3):\n        # Calculate V = n * (k - 1) + 1\n        # V can be up to 10^18 * (10^6 - 1) + 1 approx 10^24. Python handles large integers.\n        V = n * (k - 1) + 1\n        \n        # If V is 1, it means n*(k-1) = 0, which implies n=0 or k=1, neither is allowed.\n        # Or if V is small, say V < k^4, then p+1 cannot be >= 4.\n        # Smallest possible k^(p+1) is k^4 (when p=3).\n        if V <= k**3: # V must be at least k^4 for p+1 >= 4\n            continue\n        \n        # Check if V is a perfect power of k\n        # p_plus_1 = log_k(V) = log(V) / log(k)\n        \n        # Use math.log for floating point log, then round to nearest integer.\n        # This can be slightly imprecise for very large numbers or powers.\n        # A more robust check for k^X = V:\n        # Calculate X = round(math.log(V) / math.log(k))\n        # Then check if k**X == V.\n        \n        # For precision, it's better to compute root_k_V = V**(1/(p+1))\n        # But we don't know p+1 yet.\n        # So we estimate p+1 using log.\n        \n        # Since k is small, k^X can be computed directly.\n        # The maximum X for k=2 and n=10^18 is around 60.\n        # The maximum X for k=10^6 and n=10^18 is 4 (for p=3).\n        \n        # Calculate X = round(math.log(V, k))\n        # This can be problematic if V is not a perfect power of k,\n        # e.g., if log_k(V) is 3.9999999999999996, round gives 4.\n        # A safer way is to check X and X-1.\n        \n        # Estimate X\n        X_approx = math.log(V) / math.log(k)\n        \n        # Check integer parts around X_approx\n        X_candidates = [math.floor(X_approx), math.ceil(X_approx)]\n        \n        for X in X_candidates:\n            if X < 4: # We need p+1 >= 4\n                continue\n            \n            # Check for potential overflow if k**X is too large,\n            # but Python handles arbitrary precision integers.\n            # However, V can be 10^24, so k^X should be checked carefully.\n            # k^X can be very large.\n            # Check if k^X equals V.\n            # If k is large, X will be small.\n            # If k is small (e.g., k=2), X can be large (up to ~80 for 10^24).\n            \n            # Direct computation of k**X\n            current_power = 1\n            for _ in range(X):\n                if current_power > V // k: # Avoid overflow for intermediate product, check if next mult will exceed V\n                    current_power = V + 1 # Mark as too large\n                    break\n                current_power *= k\n            \n            if current_power == V:\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 5773,
        "thoughts_token_count": 653
    }
}