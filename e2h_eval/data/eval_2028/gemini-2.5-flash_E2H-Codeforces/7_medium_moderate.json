{
    "start": 1758011824.6261506,
    "end": 1758011927.8121502,
    "start-formatted": "2025-09-16 17:37 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Alright, here's my breakdown of this \"Rudolf and Snowflakes\" problem and how I plan to solve it with a Python script.**\n\nThe core of the problem boils down to figuring out if a given number, `n`, can be expressed as the sum of a geometric series plus 1, where the series' base `k` is an integer greater than 1 and the series has at least 3 terms (meaning depth `D` is at least 1).  Mathematically, I'm looking for solutions to the equation: `n = 1 + k + k^2 + ... + k^m` where `m >= 2` and `k > 1`.\n\nFirst, I'll tackle the case where `m = 2` (equivalent to `D=1`):  `n = 1 + k + k^2`. I can rearrange this to a quadratic equation, solve for `k`, and check if the solution is an integer greater than 1. The discriminant in this equation will be key.\n\nFor larger `m`, the problem gets trickier.  I'll need to iterate through potential values of `m`, but how high do I go? I know that since the numbers get very large, the geometric series' sum grows very fast.  I've reasoned that the maximum useful `m` will be around 58. I can calculate an upper bound based on `n`.\n\nFor each `m`, I'll use binary search to find a suitable `k`. Since the sum `1 + k + ... + k^m` is monotonically increasing with respect to `k`, binary search is efficient.  I'll define a function to efficiently calculate this sum, including overflow checks as calculations may grow extremely fast. The key idea here is, in the `calc_sum(k, m, n)` function, if a multiplication or sum results in value that will exceed `n` it must immediately signal an `overflow`, indicating an invalid `k`.\n\nThe strategy involves these steps: \n1.  Try the `m=2` case (quadratic equation).\n2.  Iterate `m` from 3 to 58.\n    *   For each `m`, perform a binary search for `k`. The search range for `k` must consider values near  `n^(1/m)`, or at most around `10^6` for practical implementations. The check is implemented efficiently.\n3. If no k is found for any `m`, the answer is \"NO\".\n\nThe crucial detail is preventing integer overflow within the `calc_sum()` function. I'll need to carefully check multiplication and addition for overflow, returning an overflow indication if they happen.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is defined by two parameters: `k` (an integer `k > 1`) and `D` (the number of times a specific construction step is applied, `D >= 1`).\n\nThe construction rules lead to the following number of vertices:\n1. Start with 1 vertex (the center).\n2. Connect the center to `k` new vertices. Total vertices: `1 + k`.\n3. This step must be done at least once: Each vertex connected to only one other vertex (a \"leaf\") is connected to `k` more new vertices.\n   - If this step is done once (`D=1`): The `k` vertices added in step 2 are leaves. Each gets `k` children, so `k*k` new vertices are added. Total vertices: `1 + k + k^2`.\n   - If this step is done `D` times: The total number of vertices will be `1 + k + k^2 + ... + k^(D+1)`.\n\nLet `m = D+1`. Since `D >= 1`, `m` must be at least `2`.\nSo, we are looking for `n = 1 + k + k^2 + ... + k^m` where `k > 1` and `m >= 2`.\nThis is the sum of a geometric series, which can also be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nThe input `n` can be up to `10^18`.\n\nWe can split the problem into two cases based on `m`:\n\n**Case 1: `m = 2`**\nIf `m = 2`, the equation is `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1. `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n2. `S` must be an integer.\n3. `k = (S - 1) / 2` (since `k > 0`, we take the positive root).\n4. `S - 1` must be even, which means `S` must be odd.\n5. `k > 1`, which means `(S - 1) / 2 > 1`, so `S - 1 > 2`, or `S > 3`.\n\nWe can check these conditions directly. Calculate `discriminant = 4 * n - 3`. If `discriminant` is non-negative, compute `S = int(discriminant**0.5)`. If `S * S == discriminant` and `S > 3` and `(S - 1) % 2 == 0` (which is true if `S` is odd and `S > 3`), then `k = (S - 1) // 2` is a valid `k`, and we can print \"YES\".\n\n**Case 2: `m >= 3`**\nFor `m >= 3`, we need to find if there exists an integer `k > 1` such that `n = 1 + k + k^2 + ... + k^m`.\nThe smallest possible value for `k` is 2.\nIf `k = 2`, then `n = 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\nSo, `n + 1 = 2^(m+1)`.\nThis implies `m+1 = log2(n+1)`.\nSince `n <= 10^18`, `n+1 <= 10^18 + 1`.\n`log2(10^18 + 1)` is approximately `log2(10^18) = 18 * log2(10) approx 18 * 3.3219 approx 59.79`.\nSo, `m+1` can be at most `59`. This means `m` can be at most `58`.\nTherefore, we only need to iterate `m` from `3` to `58`.\n\nFor each `m` in this range, we need to find an integer `k > 1` that satisfies the equation.\nThe function `f(k) = 1 + k + ... + k^m` is strictly increasing for `k > 1`.\nWe can use binary search to find `k`.\nThe range for `k` is `[2, k_max]`.\nA loose upper bound for `k` is `n^(1/m)`. For `m=3`, `k < (10^18)^(1/3) = 10^6`. For larger `m`, `k_max` decreases significantly (e.g., for `m=58`, `k_max` is roughly 2). A safe upper bound for `k` can be `10^6 + 7` (or `int(n**(1/m)) + 2` for a tighter bound).\n\nThe binary search process for a fixed `m`:\n- Set `low_k = 2`, `high_k = int(n**(1/m)) + 2`. Ensure `high_k >= low_k`.\n- While `low_k <= high_k`:\n    - Calculate `mid_k = (low_k + high_k) // 2`.\n    - If `mid_k < 2`, set `low_k = 2` and continue (to ensure `k > 1`).\n    - Compute `current_sum = 1 + mid_k + ... + mid_k^m`.\n      - This sum can be computed iteratively: `s = 1`, `term = 1`. For `i` from 1 to `m`: `term *= mid_k`, `s += term`.\n      - **Crucially, we must handle potential overflows** as intermediate products (`mid_k^i`) or sums can exceed `10^18` (the value of `n`). If `mid_k^i * mid_k` would exceed `n` (i.e., `mid_k^i > n / mid_k`), or if `s + mid_k^i` would exceed `n` (i.e., `s > n - mid_k^i`), then `current_sum` is definitely greater than `n`. In such cases, we can treat `current_sum` as `n + 1` to indicate it's too large.\n    - Compare `current_sum` with `n`:\n        - If `current_sum == n`, we found a solution. Print \"YES\" and return.\n        - If `current_sum < n`, `mid_k` is too small, so `low_k = mid_k + 1`.\n        - If `current_sum > n`, `mid_k` is too large, so `high_k = mid_k - 1`.\n\nIf after checking `m=2` and all `m` from `3` to `58`, no solution is found, print \"NO\".\n\n**Example `calc_sum` function with overflow checks:**\n\n```python\ndef calculate_snowflake_sum(k, m, target_n):\n    current_sum = 1\n    current_term = 1 # k^0\n    for _ in range(m): # Add terms k^1 to k^m\n        # Check for current_term * k overflow or exceeding target_n\n        # If current_term > target_n / k, then current_term * k > target_n\n        # This also handles cases where current_term * k would overflow standard 64-bit integer\n        if k > target_n // current_term: \n            return target_n + 1 # Indicate sum is too large\n        current_term *= k\n        \n        # Check for current_sum + current_term overflow or exceeding target_n\n        # If current_sum > target_n - current_term, then current_sum + current_term > target_n\n        if current_sum > target_n - current_term:\n            return target_n + 1 # Indicate sum is too large\n        current_sum += current_term\n    return current_sum\n```\n\n**Overall Algorithm:**\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case m=2: n = 1 + k + k^2\n    # k^2 + k + (1-n) = 0\n    # Discriminant = 1 - 4(1-n) = 4n - 3\n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        s_val = int(discriminant**0.5)\n        if s_val * s_val == discriminant: # Check if 4n-3 is a perfect square\n            # k = (s_val - 1) / 2\n            # For k to be an integer, s_val must be odd. If s_val is odd, s_val-1 is even.\n            # If s_val is even, s_val-1 is odd, so k won't be integer.\n            # So we only need to check s_val % 2 == 1.\n            if (s_val - 1) % 2 == 0: # This check is redundant if s_val*s_val == discriminant implies s_val is odd when 4n-3 is odd.\n                                      # 4n-3 is always odd. So S*S must be odd, which means S must be odd.\n                k = (s_val - 1) // 2\n                if k > 1: # k must be greater than 1\n                    sys.stdout.write(\"YES\\n\")\n                    return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Max m for n=10^18 is 58 (since 2^59 - 1 > 10^18)\n    for m in range(3, 60): # m goes from 3 to 59. max m is 58.\n        low_k = 2\n        # Upper bound for k: k^m < n => k < n^(1/m). For n=10^18, m=3, k_max approx 10^6.\n        # For m=58, k_max approx 2.\n        # A safe upper bound for k for m>=3\n        high_k = int(n**(1/m)) + 2 \n        # Make sure high_k is at least low_k\n        if high_k < low_k:\n            high_k = low_k\n\n        while low_k <= high_k:\n            mid_k = (low_k + high_k) // 2\n            \n            # Ensure k > 1. If mid_k becomes 0 or 1, adjust.\n            if mid_k < 2:\n                low_k = 2\n                continue\n\n            current_sum = 1\n            current_term = 1 # k^0\n            possible_overflow = False\n\n            for _ in range(m): # Calculate 1 + k + ... + k^m\n                # Check for current_term * mid_k exceeding n or overflowing\n                # If mid_k is 0 or 1, this logic is incorrect. Already handled mid_k < 2.\n                if current_term > n // mid_k: # current_term * mid_k would exceed n\n                    possible_overflow = True\n                    break\n                current_term *= mid_k\n                \n                # Check for current_sum + current_term exceeding n or overflowing\n                if current_sum > n - current_term: # current_sum + current_term would exceed n\n                    possible_overflow = True\n                    break\n                current_sum += current_term\n\n            if possible_overflow:\n                # Sum exceeded n, so mid_k is too large\n                high_k = mid_k - 1\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                # Sum is too small, need larger k\n                low_k = mid_k + 1\n            else: # current_sum > n\n                # Sum is too large, need smaller k\n                high_k = mid_k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case m=2: n = 1 + k + k^2\n    # k^2 + k + (1-n) = 0\n    # Discriminant = 1 - 4(1-n) = 4n - 3\n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        s_val = int(discriminant**0.5)\n        if s_val * s_val == discriminant: # Check if 4n-3 is a perfect square\n            # k = (s_val - 1) / 2\n            # For k to be an integer, s_val must be odd. If s_val is odd, s_val-1 is even.\n            # If s_val is even, s_val-1 is odd, so k won't be integer.\n            # So we only need to check s_val % 2 == 1.\n            if (s_val - 1) % 2 == 0: # This check is redundant if s_val*s_val == discriminant implies s_val is odd when 4n-3 is odd.\n                                      # 4n-3 is always odd. So S*S must be odd, which means S must be odd.\n                k = (s_val - 1) // 2\n                if k > 1: # k must be greater than 1\n                    sys.stdout.write(\"YES\\n\")\n                    return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Max m for n=10^18 is 58 (since 2^59 - 1 > 10^18)\n    for m in range(3, 60): # m goes from 3 to 59. max m is 58.\n        low_k = 2\n        # Upper bound for k: k^m < n => k < n^(1/m). For n=10^18, m=3, k_max approx 10^6.\n        # For m=58, k_max approx 2.\n        # A safe upper bound for k for m>=3\n        high_k = int(n**(1/m)) + 2 \n        # Make sure high_k is at least low_k\n        if high_k < low_k:\n            high_k = low_k\n\n        while low_k <= high_k:\n            mid_k = (low_k + high_k) // 2\n            \n            # Ensure k > 1. If mid_k becomes 0 or 1, adjust.\n            if mid_k < 2:\n                low_k = 2\n                continue\n\n            current_sum = 1\n            current_term = 1 # k^0\n            possible_overflow = False\n\n            for _ in range(m): # Calculate 1 + k + ... + k^m\n                # Check for current_term * mid_k exceeding n or overflowing\n                # If mid_k is 0 or 1, this logic is incorrect. Already handled mid_k < 2.\n                if current_term > n // mid_k: # current_term * mid_k would exceed n\n                    possible_overflow = True\n                    break\n                current_term *= mid_k\n                \n                # Check for current_sum + current_term exceeding n or overflowing\n                if current_sum > n - current_term: # current_sum + current_term would exceed n\n                    possible_overflow = True\n                    break\n                current_sum += current_term\n\n            if possible_overflow:\n                # Sum exceeded n, so mid_k is too large\n                high_k = mid_k - 1\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                # Sum is too small, need larger k\n                low_k = mid_k + 1\n            else: # current_sum > n\n                # Sum is too large, need smaller k\n                high_k = mid_k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 2972,
        "thoughts_token_count": 6895
    }
}