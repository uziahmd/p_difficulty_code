{
    "start": 1758293698.1550462,
    "end": 1758293731.898842,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank for Vasya\n    # To get the best rank, Vasya wants to maximize his score.\n    # The other participants should have their scores minimized relative to Vasya's potential maximum.\n    # Vasya takes the highest score from A and highest from B.\n    # The remaining participants are paired to maximize their scores.\n    # This is not how it works. Vasya's score is unknown.\n    # Vasya's best rank:\n    # Vasya wants to achieve a score S such that S >= x.\n    # To get the best rank, Vasya wants to maximize S and minimize scores of others.\n    # This means Vasya takes the largest available a_i and largest available b_j.\n    # Let's say Vasya has a_i and b_j. His score is a_i + b_j.\n    # The other n-1 participants are paired up from the remaining n-1 a's and n-1 b's.\n    # To maximize Vasya's rank, we want to maximize his score and minimize the scores of others.\n    # The problem is that Vasya's scores are just some a_i and b_j.\n    # To find the best rank, we assume Vasya gets the highest possible sum, i.e., a[n-1] + b[n-1].\n    # Then we pair the remaining a's and b's to minimize their scores.\n    # This is also not right. The scores are fixed for all participants. We just don't know who got what.\n    # We want to find a permutation of a's and b's such that Vasya gets a high score,\n    # and few other people get higher or equal scores.\n    # Vasya's best rank:\n    # Vasya can be any of the participants.\n    # To get the best rank (1st), Vasya needs to have the highest score.\n    # This is possible if Vasya takes a[n-1] and b[n-1], provided a[n-1] + b[n-1] >= x.\n    # Then the other n-1 participants are paired from the remaining a's and b's.\n    # The question is how many people can get a score greater than or equal to Vasya's score.\n    # To minimize this count, Vasya should aim for the highest possible score.\n    # Vasya's score is (a_i + b_j) >= x.\n    # The best rank is 1 if Vasya can get a score S and all other n-1 participants get scores < S.\n    # This is not necessarily true. If Vasya gets S and someone else gets S, Vasya can still be 1st.\n    # \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # So, for best rank, if Vasya gets score S, and k other people get score S, and m people get score > S,\n    # Vasya's best rank is m + 1.\n    # To minimize m, Vasya should get the highest possible score.\n    # So, Vasya takes a[n-1] and b[n-1]. His score is S_vasya = a[n-1] + b[n-1].\n    # We need to count how many other participants can get a score strictly greater than S_vasya.\n    # This is impossible if Vasya already took the maximum a and maximum b.\n    # So, if Vasya takes a[n-1] and b[n-1], his score is S_max = a[n-1] + b[n-1].\n    # No one else can get a score strictly greater than S_max.\n    # So, for the best rank, Vasya will always be rank 1.\n    # The problem states \"It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x.\"\n    # This means Vasya can always achieve a score >= x.\n    # If Vasya takes a[n-1] and b[n-1], his score is S_vasya = a[n-1] + b[n-1].\n    # Since a[n-1] is the largest a_i and b[n-1] is the largest b_j, no other participant can achieve a score strictly greater than S_vasya.\n    # Therefore, Vasya's best rank is always 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank for Vasya\n    # Vasya wants to minimize his score (while still >= x) and maximize scores of others.\n    # Or, Vasya wants to maximize the number of people who get a score >= Vasya's score.\n    # To maximize the number of people ahead of Vasya (or tied with him),\n    # Vasya should get a relatively low score (but still >= x).\n    # And other participants should get high scores.\n    # This is a matching problem. We want to find a matching of a's and b's\n    # such that for some a_i and b_j (Vasya's scores), a_i + b_j >= x,\n    # and the number of other pairs (a_k, b_l) such that a_k + b_l >= a_i + b_j is maximized.\n\n    # Let's fix Vasya's potential score (a_i + b_j).\n    # We want to find the minimum number of people who can achieve a score strictly greater than (a_i + b_j).\n    # And then maximize the number of people who can achieve a score equal to (a_i + b_j).\n    # This means we need to find a pairing for the other n-1 participants such that their scores are maximized.\n\n    # Consider the problem from the perspective of participants whose scores are NOT Vasya's.\n    # We want to pair (n-1) 'a' scores with (n-1) 'b' scores to maximize the number of pairs\n    # (a_k, b_l) such that a_k + b_l >= S_threshold, where S_threshold is Vasya's score.\n\n    # Let's try to determine Vasya's score.\n    # For the worst rank, Vasya should be paired with some (a_i, b_j) such that a_i + b_j >= x.\n    # And we want to maximize the count of (a_k + b_l) >= (a_i + b_j) for other participants.\n    # This is equivalent to finding a matching of (a, b) pairs such that:\n    # 1. One pair (a_vasya, b_vasya) has sum >= x.\n    # 2. For this chosen (a_vasya, b_vasya), the number of other pairs (a_k, b_l) with sum >= a_vasya + b_vasya is maximized.\n\n    # This is a bit tricky. Let's rephrase.\n    # We want to find a permutation P of indices {0, ..., n-1} such that participant k gets score a_k + b_{P[k]}.\n    # Vasya is one of these participants. Let's say Vasya is participant 0.\n    # So Vasya gets a_0 + b_{P[0]}. We need a_0 + b_{P[0]} >= x.\n    # We want to maximize the number of participants k (including Vasya) such that a_k + b_{P[k]} >= a_0 + b_{P[0]}.\n    # This is equivalent to maximizing the count of participants whose score is greater than or equal to Vasya's score.\n\n    # Let's consider a fixed score S for Vasya.\n    # If Vasya gets score S (where S = a_i + b_j for some i, j, and S >= x).\n    # We want to maximize the number of other participants who also get score >= S.\n    # This means we want to find a matching of the remaining n-1 'a's and n-1 'b's\n    # such that the number of pairs with sum >= S is maximized.\n    # This is a greedy approach.\n    # To maximize pairs >= S, for each remaining a_k, we try to find a b_l such that a_k + b_l >= S.\n    # We should pair the largest remaining a_k with the smallest b_l that satisfies the condition.\n    # Or, to maximize the count, we should pair the largest remaining a_k with the largest available b_l.\n    # This is a standard two-pointer approach for counting pairs.\n\n    # The maximum possible score is a[n-1] + b[n-1]. The minimum is a[0] + b[0].\n    # Vasya's score can range from x up to a[n-1] + b[n-1].\n    # We need to iterate over all possible pairs (a_i, b_j) for Vasya, where a_i + b_j >= x.\n    # For each such pair, we calculate Vasya's score S = a_i + b_j.\n    # Then we need to calculate the maximum number of other participants who can achieve a score >= S,\n    # given the remaining n-1 'a's and n-1 'b's.\n    # This is too complex, as there are N^2 possible pairs for Vasya.\n\n    # A different approach:\n    # We want to maximize the number of participants whose score is >= Vasya's score.\n    # Let Vasya's score be S_V. We want to maximize count(S_k >= S_V).\n    # This implies we want to find a permutation P such that for some k_V:\n    # a_{k_V} + b_{P[k_V]} >= x\n    # and count({k | a_k + b_{P[k]} >= a_{k_V} + b_{P[k_V]}}) is maximized.\n\n    # Let's consider the sorted lists a and b.\n    # To maximize the number of pairs (a_i, b_j) such that a_i + b_j >= S,\n    # we can use a two-pointer approach.\n    # Sort a in ascending order and b in ascending order.\n    # Let's try to match a[i] with b[j].\n    # We iterate through a from largest to smallest (a[n-1] down to a[0]).\n    # For each a[i], we want to find a b[j] such that a[i] + b[j] >= S.\n    # To maximize the count, we pair a[i] with the smallest b[j] that satisfies the condition.\n    # Or, to maximize the count, we pair the largest a[i] with the largest b[j].\n    # This is not for a fixed S.\n\n    # Consider the problem: given two sorted arrays A and B, find the maximum number of pairs (A[i], B[j])\n    # such that A[i] + B[j] >= K.\n    # This can be done by sorting A and B.\n    # Use two pointers: `left_a` at 0, `right_b` at n-1.\n    # If A[left_a] + B[right_b] >= K, then A[left_a] can be paired with B[right_b].\n    # All A[left_a...n-1] can be paired with B[right_b] to satisfy the condition (if B[right_b] is large enough).\n    # To maximize the count, we want to use B[right_b] with some A[i].\n    # If A[left_a] + B[right_b] >= K, then A[left_a] can be paired with B[right_b].\n    # We increment count, and move `left_a` up and `right_b` down.\n    # If A[left_a] + B[right_b] < K, then A[left_a] cannot be paired with B[right_b] (or any smaller B[j]).\n    # So, A[left_a] must be paired with some larger B[j] (which is not available if we are at right_b).\n    # This logic is for finding pairs from distinct sets.\n    # Here, we have n 'a' values and n 'b' values, and we need to form n pairs.\n    # Each a_i and b_j can be used exactly once.\n\n    # This is a maximum bipartite matching problem, but that's too slow.\n    # The crucial observation for worst rank:\n    # Vasya wants to be assigned a score (a_i + b_j) >= x.\n    # To maximize his rank (i.e., minimize his actual place number), we want to maximize the number of people with score >= Vasya's score.\n    # This is achieved when Vasya's score is relatively low (but >= x), and many other people can get high scores.\n    #\n    # Let's fix a score S for Vasya.\n    # How many people can get score >= S?\n    # We need to find a perfect matching (n pairs) such that the number of pairs (a_k, b_l) with sum >= S is maximized.\n    # Let's count how many pairs (a_k, b_l) can be formed from all n 'a's and n 'b's such that a_k + b_l >= S.\n    # This can be done greedily. Sort 'a' and 'b'.\n    # Iterate `i` from 0 to n-1 (for `a[i]`).\n    # For each `a[i]`, we need to find `b[j]` such that `a[i] + b[j] >= S`.\n    # To maximize the count of such pairs, we should try to use small `a[i]` with large `b[j]`.\n    # Let's use two pointers: `ptr_a` for `a` (from 0 to n-1) and `ptr_b` for `b` (from n-1 down to 0).\n    # `count = 0`\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= S`:\n    #     `count += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < S`):\n    #     `ptr_a += 1` (because `a[ptr_a]` is too small even with largest `b[ptr_b]`, so it needs a larger `b` which is not available, or it can't form a pair >= S with remaining `b`s)\n    # This greedy approach actually maximizes the number of pairs >= S.\n    # Why? Suppose we have `a[ptr_a]` and `b[ptr_b]` such that `a[ptr_a] + b[ptr_b] >= S`.\n    # If we pair them, we get one such pair.\n    # If we don't pair them, `a[ptr_a]` must be paired with some `b[k]` where `k > ptr_b`.\n    # And `b[ptr_b]` must be paired with some `a[m]` where `m > ptr_a`.\n    # This is equivalent to finding the maximum matching in a bipartite graph where edges exist if sum >= S.\n    # The greedy approach described above (sort both, use smallest `a` with largest `b` if possible) works.\n    # For a fixed S, this `count_pairs_ge_S(S)` function returns the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= S, using each a and b at most once.\n\n    # Now, how does this relate to Vasya's worst rank?\n    # Vasya's worst rank occurs when his score S_V is chosen such that S_V >= x,\n    # and the maximum possible number of people (including Vasya) achieve a score >= S_V.\n    # Let's iterate over all possible values of S_V.\n    # S_V can range from x up to 2 * 10^5.\n    # For each S_V, we calculate `count = count_pairs_ge_S(S_V)`.\n    # If `count` is the number of people who can get >= S_V, then Vasya's rank could be `count`.\n    # We want to maximize this `count`.\n    # The maximum possible score is 2 * 10^5.\n    # So we can iterate `S` from `x` to `2 * 10^5`.\n    # For each `S`, calculate `count_pairs_ge_S(S)`. The maximum such count is the worst rank.\n\n    # Let's define the `count_pairs_ge_S` function:\n    def count_pairs_ge_S(current_a, current_b, S):\n        count = 0\n        left_ptr = 0\n        right_ptr = n - 1\n        while left_ptr < n and right_ptr >= 0:\n            if current_a[left_ptr] + current_b[right_ptr] >= S:\n                count += 1\n                left_ptr += 1\n                right_ptr -= 1\n            else:\n                left_ptr += 1 # a[left_ptr] is too small even with largest b[right_ptr], so it cannot form a pair >= S with any remaining b.\n        return count\n\n    max_worst_rank = 0\n    # The problem guarantees that Vasya can get at least x points.\n    # So there exists at least one pair (a_i, b_j) such that a_i + b_j >= x.\n    # This implies that `count_pairs_ge_S(S)` will be at least 1 for some S >= x.\n    # The minimum possible score is 0, max is 2*10^5.\n    # So we can iterate S from x to 2*10^5 + 1 (max possible sum + 1).\n    # The maximum possible sum is 10^5 + 10^5 = 2*10^5.\n    # We can optimize this by noting that `count_pairs_ge_S(S)` is monotonically non-increasing with S.\n    # So we are looking for `max_{S >= x} count_pairs_ge_S(S)`.\n    # This maximum will occur at the smallest S >= x that results in the highest count.\n    # This is simply `count_pairs_ge_S(x)`.\n    # Why? If we choose Vasya's score S_V, and S_V >= x.\n    # The number of people with score >= S_V is `count_pairs_ge_S(S_V)`.\n    # Since `count_pairs_ge_S(S)` is non-increasing,\n    # `count_pairs_ge_S(x)` is the maximum possible count for any S >= x.\n    # So, the worst rank is `count_pairs_ge_S(x)`.\n\n    worst_rank = count_pairs_ge_S(a, b, x)\n\n    print(best_rank, worst_rank)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank for Vasya\n    # To get the best rank, Vasya wants to maximize his score.\n    # The other participants should have their scores minimized relative to Vasya's potential maximum.\n    # Vasya takes the highest score from A and highest from B.\n    # The remaining participants are paired to maximize their scores.\n    # This is not how it works. Vasya's score is unknown.\n    # Vasya's best rank:\n    # Vasya wants to achieve a score S such that S >= x.\n    # To get the best rank, Vasya wants to maximize S and minimize scores of others.\n    # This means Vasya takes the largest available a_i and largest available b_j.\n    # Let's say Vasya has a_i and b_j. His score is a_i + b_j.\n    # The other n-1 participants are paired up from the remaining n-1 a's and n-1 b's.\n    # To maximize Vasya's rank, we want to maximize his score and minimize the scores of others.\n    # The problem is that Vasya's scores are just some a_i and b_j.\n    # To find the best rank, we assume Vasya gets the highest possible sum, i.e., a[n-1] + b[n-1].\n    # Then we pair the remaining a's and b's to minimize their scores.\n    # This is also not right. The scores are fixed for all participants. We just don't know who got what.\n    # We want to find a permutation of a's and b's such that Vasya gets a high score,\n    # and few other people get higher or equal scores.\n    # Vasya's best rank:\n    # Vasya can be any of the participants.\n    # To get the best rank (1st), Vasya needs to have the highest score.\n    # This is possible if Vasya takes a[n-1] and b[n-1], provided a[n-1] + b[n-1] >= x.\n    # Then the other n-1 participants are paired from the remaining a's and b's.\n    # The question is how many people can get a score greater than or equal to Vasya's score.\n    # To minimize this count, Vasya should aim for the highest possible score.\n    # Vasya's score is (a_i + b_j) >= x.\n    # The best rank is 1 if Vasya can get a score S and all other n-1 participants get scores < S.\n    # This is not necessarily true. If Vasya gets S and someone else gets S, Vasya can still be 1st.\n    # \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # So, for best rank, if Vasya gets score S, and k other people get score S, and m people get score > S,\n    # Vasya's best rank is m + 1.\n    # To minimize m, Vasya should get the highest possible score.\n    # So, Vasya takes a[n-1] and b[n-1]. His score is S_vasya = a[n-1] + b[n-1].\n    # We need to count how many other participants can get a score strictly greater than S_vasya.\n    # This is impossible if Vasya already took the maximum a and maximum b.\n    # So, if Vasya takes a[n-1] and b[n-1], his score is S_max = a[n-1] + b[n-1].\n    # No one else can get a score strictly greater than S_max.\n    # So, for the best rank, Vasya will always be rank 1.\n    # The problem states \"It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x.\"\n    # This means Vasya can always achieve a score >= x.\n    # If Vasya takes a[n-1] and b[n-1], his score is S_vasya = a[n-1] + b[n-1].\n    # Since a[n-1] is the largest a_i and b[n-1] is the largest b_j, no other participant can achieve a score strictly greater than S_vasya.\n    # Therefore, Vasya's best rank is always 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank for Vasya\n    # Vasya wants to minimize his score (while still >= x) and maximize scores of others.\n    # Or, Vasya wants to maximize the number of people who get a score >= Vasya's score.\n    # To maximize the number of people ahead of Vasya (or tied with him),\n    # Vasya should get a relatively low score (but still >= x).\n    # And other participants should get high scores.\n    # This is a matching problem. We want to find a matching of a's and b's\n    # such that for some a_i and b_j (Vasya's scores), a_i + b_j >= x,\n    # and the number of other pairs (a_k, b_l) such that a_k + b_l >= a_i + b_j is maximized.\n\n    # Let's fix Vasya's potential score (a_i + b_j).\n    # We want to find the minimum number of people who can achieve a score strictly greater than (a_i + b_j).\n    # And then maximize the number of people who can achieve a score equal to (a_i + b_j).\n    # This means we need to find a pairing for the other n-1 participants such that their scores are maximized.\n\n    # Consider the problem from the perspective of participants whose scores are NOT Vasya's.\n    # We want to pair (n-1) 'a' scores with (n-1) 'b' scores to maximize the number of pairs\n    # (a_k, b_l) such that a_k + b_l >= S_threshold, where S_threshold is Vasya's score.\n\n    # Let's try to determine Vasya's score.\n    # For the worst rank, Vasya should be paired with some (a_i, b_j) such that a_i + b_j >= x.\n    # And we want to maximize the count of (a_k + b_l) >= (a_i + b_j) for other participants.\n    # This is equivalent to finding a matching of (a, b) pairs such that:\n    # 1. One pair (a_vasya, b_vasya) has sum >= x.\n    # 2. For this chosen (a_vasya, b_vasya), the number of other pairs (a_k, b_l) with sum >= a_vasya + b_vasya is maximized.\n\n    # This is a bit tricky. Let's rephrase.\n    # We want to find a permutation P of indices {0, ..., n-1} such that participant k gets score a_k + b_{P[k]}.\n    # Vasya is one of these participants. Let's say Vasya is participant 0.\n    # So Vasya gets a_0 + b_{P[0]}. We need a_0 + b_{P[0]} >= x.\n    # We want to maximize the number of participants k (including Vasya) such that a_k + b_{P[k]} >= a_0 + b_{P[0]}.\n    # This is equivalent to maximizing the count of participants whose score is greater than or equal to Vasya's score.\n\n    # Let's consider a fixed score S for Vasya.\n    # If Vasya gets score S (where S = a_i + b_j for some i, j, and S >= x).\n    # We want to maximize the number of other participants who also get score >= S.\n    # This means we want to find a matching of the remaining n-1 'a's and n-1 'b's\n    # such that the number of pairs with sum >= S is maximized.\n    # This is a greedy approach.\n    # To maximize pairs >= S, for each remaining a_k, we try to find a b_l such that a_k + b_l >= S.\n    # We should pair the largest remaining a_k with the smallest b_l that satisfies the condition.\n    # Or, to maximize the count, we should pair the largest remaining a_k with the largest available b_l.\n    # This is a standard two-pointer approach for counting pairs.\n\n    # The maximum possible score is a[n-1] + b[n-1]. The minimum is a[0] + b[0].\n    # Vasya's score can range from x up to a[n-1] + b[n-1].\n    # We need to iterate over all possible pairs (a_i, b_j) for Vasya, where a_i + b_j >= x.\n    # For each such pair, we calculate Vasya's score S = a_i + b_j.\n    # Then we need to calculate the maximum number of other participants who can achieve a score >= S,\n    # given the remaining n-1 'a's and n-1 'b's.\n    # This is too complex, as there are N^2 possible pairs for Vasya.\n\n    # A different approach:\n    # We want to maximize the number of participants whose score is >= Vasya's score.\n    # Let Vasya's score be S_V. We want to maximize count(S_k >= S_V).\n    # This implies we want to find a permutation P such that for some k_V:\n    # a_{k_V} + b_{P[k_V]} >= x\n    # and count({k | a_k + b_{P[k]} >= a_{k_V} + b_{P[k_V]}}) is maximized.\n\n    # Let's consider the sorted lists a and b.\n    # To maximize the number of pairs (a_i, b_j) such that a_i + b_j >= S,\n    # we can use a two-pointer approach.\n    # Sort a in ascending order and b in ascending order.\n    # Let's try to match a[i] with b[j].\n    # We iterate through a from largest to smallest (a[n-1] down to a[0]).\n    # For each a[i], we want to find a b[j] such that a[i] + b[j] >= S.\n    # To maximize the count, we pair a[i] with the smallest b[j] that satisfies the condition.\n    # Or, to maximize the count, we pair the largest a[i] with the largest b[j].\n    # This is not for a fixed S.\n\n    # Consider the problem: given two sorted arrays A and B, find the maximum number of pairs (A[i], B[j])\n    # such that A[i] + B[j] >= K.\n    # This can be done by sorting A and B.\n    # Use two pointers: `left_a` at 0, `right_b` at n-1.\n    # If A[left_a] + B[right_b] >= K, then A[left_a] can be paired with B[right_b].\n    # All A[left_a...n-1] can be paired with B[right_b] to satisfy the condition (if B[right_b] is large enough).\n    # To maximize the count, we want to use B[right_b] with some A[i].\n    # If A[left_a] + B[right_b] >= K, then A[left_a] can be paired with B[right_b].\n    # We increment count, and move `left_a` up and `right_b` down.\n    # If A[left_a] + B[right_b] < K, then A[left_a] cannot be paired with B[right_b] (or any smaller B[j]).\n    # So, A[left_a] must be paired with some larger B[j] (which is not available if we are at right_b).\n    # This logic is for finding pairs from distinct sets.\n    # Here, we have n 'a' values and n 'b' values, and we need to form n pairs.\n    # Each a_i and b_j can be used exactly once.\n\n    # This is a maximum bipartite matching problem, but that's too slow.\n    # The crucial observation for worst rank:\n    # Vasya wants to be assigned a score (a_i + b_j) >= x.\n    # To maximize his rank (i.e., minimize his actual place number), we want to maximize the number of people with score >= Vasya's score.\n    # This is achieved when Vasya's score is relatively low (but >= x), and many other people can get high scores.\n    #\n    # Let's fix a score S for Vasya.\n    # How many people can get score >= S?\n    # We need to find a perfect matching (n pairs) such that the number of pairs (a_k, b_l) with sum >= S is maximized.\n    # Let's count how many pairs (a_k, b_l) can be formed from all n 'a's and n 'b's such that a_k + b_l >= S.\n    # This can be done greedily. Sort 'a' and 'b'.\n    # Iterate `i` from 0 to n-1 (for `a[i]`).\n    # For each `a[i]`, we need to find `b[j]` such that `a[i] + b[j] >= S`.\n    # To maximize the count of such pairs, we should try to use small `a[i]` with large `b[j]`.\n    # Let's use two pointers: `ptr_a` for `a` (from 0 to n-1) and `ptr_b` for `b` (from n-1 down to 0).\n    # `count = 0`\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= S`:\n    #     `count += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < S`):\n    #     `ptr_a += 1` (because `a[ptr_a]` is too small even with largest `b[ptr_b]`, so it needs a larger `b` which is not available, or it can't form a pair >= S with remaining `b`s)\n    # This greedy approach actually maximizes the number of pairs >= S.\n    # Why? Suppose we have `a[ptr_a]` and `b[ptr_b]` such that `a[ptr_a] + b[ptr_b] >= S`.\n    # If we pair them, we get one such pair.\n    # If we don't pair them, `a[ptr_a]` must be paired with some `b[k]` where `k > ptr_b`.\n    # And `b[ptr_b]` must be paired with some `a[m]` where `m > ptr_a`.\n    # This is equivalent to finding the maximum matching in a bipartite graph where edges exist if sum >= S.\n    # The greedy approach described above (sort both, use smallest `a` with largest `b` if possible) works.\n    # For a fixed S, this `count_pairs_ge_S(S)` function returns the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= S, using each a and b at most once.\n\n    # Now, how does this relate to Vasya's worst rank?\n    # Vasya's worst rank occurs when his score S_V is chosen such that S_V >= x,\n    # and the maximum possible number of people (including Vasya) achieve a score >= S_V.\n    # Let's iterate over all possible values of S_V.\n    # S_V can range from x up to 2 * 10^5.\n    # For each S_V, we calculate `count = count_pairs_ge_S(S_V)`.\n    # If `count` is the number of people who can get >= S_V, then Vasya's rank could be `count`.\n    # We want to maximize this `count`.\n    # The maximum possible score is 2 * 10^5.\n    # So we can iterate `S` from `x` to `2 * 10^5`.\n    # For each `S`, calculate `count_pairs_ge_S(S)`. The maximum such count is the worst rank.\n\n    # Let's define the `count_pairs_ge_S` function:\n    def count_pairs_ge_S(current_a, current_b, S):\n        count = 0\n        left_ptr = 0\n        right_ptr = n - 1\n        while left_ptr < n and right_ptr >= 0:\n            if current_a[left_ptr] + current_b[right_ptr] >= S:\n                count += 1\n                left_ptr += 1\n                right_ptr -= 1\n            else:\n                left_ptr += 1 # a[left_ptr] is too small even with largest b[right_ptr], so it cannot form a pair >= S with any remaining b.\n        return count\n\n    max_worst_rank = 0\n    # The problem guarantees that Vasya can get at least x points.\n    # So there exists at least one pair (a_i, b_j) such that a_i + b_j >= x.\n    # This implies that `count_pairs_ge_S(S)` will be at least 1 for some S >= x.\n    # The minimum possible score is 0, max is 2*10^5.\n    # So we can iterate S from x to 2*10^5 + 1 (max possible sum + 1).\n    # The maximum possible sum is 10^5 + 10^5 = 2*10^5.\n    # We can optimize this by noting that `count_pairs_ge_S(S)` is monotonically non-increasing with S.\n    # So we are looking for `max_{S >= x} count_pairs_ge_S(S)`.\n    # This maximum will occur at the smallest S >= x that results in the highest count.\n    # This is simply `count_pairs_ge_S(x)`.\n    # Why? If we choose Vasya's score S_V, and S_V >= x.\n    # The number of people with score >= S_V is `count_pairs_ge_S(S_V)`.\n    # Since `count_pairs_ge_S(S)` is non-increasing,\n    # `count_pairs_ge_S(x)` is the maximum possible count for any S >= x.\n    # So, the worst rank is `count_pairs_ge_S(x)`.\n\n    worst_rank = count_pairs_ge_S(a, b, x)\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 4610,
        "thoughts_token_count": 0
    }
}