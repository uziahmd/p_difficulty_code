{
    "start": 1758009365.8926263,
    "end": 1758009420.9036832,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:57 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Solving the Rudolf and Snowflakes Problem: A Geometric Series Approach**\n\nOkay, so I need to tackle this \"Rudolf and Snowflakes (hard version)\" problem.  My initial thought is to figure out the formula that governs the number of vertices in this snowflake construction. Let's break down the rules and see where it leads.\n\nFirst, we start with a single center vertex. Pretty straightforward: number of vertices = 1.\n\nNext, we attach *k* new vertices to this center.  So we have the center plus *k* leaves – a total of 1 + *k* vertices.\n\nNow comes the iterative part. Each leaf (connected to only one other vertex – the center) is then connected to *k* *more* new vertices.  This step must be done at least once, which is key.  Let's track this layer by layer.\n\n*   Layer 0: the center (1 vertex)\n*   Layer 1: the initial *k* leaves\n*   First iteration of the \"connect to *k*\" rule: each of the *k* vertices in Layer 1 gets connected to *k* new ones. This forms Layer 2 with *k* \\* *k* = *k*<sup>2</sup> vertices.  Now, the initial leaves are connected to the center and the new layer.\n\nThe problem states that this iterative step is done *d* times. Each time we apply that rule, we create a new layer of vertices. Each layer is made of vertices who are linked to the ones from the previous. I am going to call `m` the number of layers (excluding the center), so the formula I came up with is `m = d+1` and as this step is done at least once, `d >= 1`, thus `m>=2`.\nSo this is a geometric series. Let's trace it out.\n*   Layer 0: 1 vertex (center)\n*   Layer 1: *k* vertices\n*   Layer 2: *k*<sup>2</sup> vertices\n*   ...\n*   Layer *m*: *k*<sup>*m*</sup> vertices\n*   ...\n*   Layer d+1: *k*<sup>*d+1*</sup> vertices.\n\nThe total number of vertices, which I'll call *n*, is the sum of all these layers: 1 + *k* + *k*<sup>2</sup> + ... + *k*<sup>*d+1*</sup>. That's a geometric series!  So, using the formula for the sum of a geometric series, I get  *n* = (*k*<sup>*d+2*</sup> - 1) / (*k* - 1). This is my formula for *n*. I need to focus on this and how it relates to the input constraints now.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is defined by a central vertex, which connects to `k` new vertices (`k > 1`). Then, each vertex connected to only one other vertex (initially, these are the `k` vertices in the first layer) connects to `k` *more* new vertices. This last step must be done at least once.\n\nLet's analyze the structure of the snowflake:\n1.  **Layer 0 (Center):** 1 vertex.\n2.  **Layer 1:** The center connects to `k` new vertices. So, `k` vertices.\n3.  **Layer 2:** Each of the `k` vertices in Layer 1 connects to `k` new vertices. This adds `k * k = k^2` vertices. At this point, the `k` vertices in Layer 1 are no longer leaves, and the `k^2` vertices in Layer 2 are leaves.\n4.  **Layer 3:** If the process continues, each of the `k^2` vertices in Layer 2 connects to `k` new vertices. This adds `k^2 * k = k^3` vertices.\nAnd so on.\n\nThe rule states that the \"step should be done at least once\". This means we must have at least Layer 2.\nLet `m` be the maximum layer index (excluding the center, so `m` is the \"depth\" of the snowflake).\nIf the step is done once, we have layers 0, 1, 2. So `m=2`.\nIf the step is done `d` times, we have layers 0, 1, ..., `d+1`. So `m = d+1`.\nSince `d >= 1`, we must have `m >= 2`.\n\nThe total number of vertices `n` is the sum of vertices in all layers:\n`n = 1 + k + k^2 + ... + k^m`\n\nThis is a geometric series sum. The formula for this sum is `n = (k^(m+1) - 1) / (k - 1)`.\nWe need to check if for a given `n`, there exist integers `k > 1` and `m >= 2` that satisfy this equation.\n\nLet's analyze the possible values of `m`:\n\n**Case 1: `m = 2`**\nIf `m = 2`, then `n = 1 + k + k^2`.\nWe can rearrange this to `k^2 + k + (1 - n) = 0`.\nThis is a quadratic equation in `k`. Using the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(1 - 4 + 4n)) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `4n - 3 = s^2` for some integer `s`.\n2.  `s` must be odd, so that `-1 ± s` is even.\n3.  `k = (-1 + s) / 2` must be an integer greater than 1. This implies `s > 3`.\n    If `s` is odd and `s > 3`, then `s >= 5`.\n    `k = (s - 1) / 2 >= (5 - 1) / 2 = 2`. This satisfies `k > 1`.\nSo, for a given `n`, we calculate `val = 4n - 3`. If `val` is a perfect square `s^2` and `s` is odd and `s > 3`, then a valid `k` exists.\n\n**Case 2: `m > 2`**\nIf `m > 2`, then `n = 1 + k + k^2 + ... + k^m`.\nSince `k > 1` and `m >= 3`:\n`n = (k^(m+1) - 1) / (k - 1)`\nWe can iterate through possible values of `m` and `k`.\nThe maximum value of `n` is `10^18`.\n*   If `k=2`, `n = 2^(m+1) - 1`. `2^(m+1) - 1 <= 10^18` implies `2^(m+1) <= 10^18 + 1`. Since `2^60` is approximately `1.15 * 10^18`, `m+1` can go up to about 60. So `m` can go up to about 59.\n*   If `k=3`, `n = (3^(m+1) - 1) / 2`. `3^(m+1) <= 2 * 10^18 + 1`. Since `3^38` is approximately `1.35 * 10^18`, `m+1` can go up to about 38. So `m` can go up to about 37.\n*   As `k` increases, `m` decreases.\n    For `m=3`, `n = 1 + k + k^2 + k^3`. `k^3 < n`. So `k < n^(1/3)`. For `n=10^18`, `k < (10^18)^(1/3) = 10^6`.\n    For `m=4`, `n = 1 + k + k^2 + k^3 + k^4`. `k^4 < n`. So `k < n^(1/4)`. For `n=10^18`, `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\n    For `m=5`, `k < n^(1/5)`. For `n=10^18`, `k < (10^18)^(1/5) = 10^(3.6) approx 3981`.\n    For `m=60`, `k < n^(1/60)`. For `n=10^18`, `k < (10^18)^(1/60) = (10^3)^(1/10) = 10^(0.3) approx 1.99`. So `k` can only be `2`.\n\nThe maximum value of `m` we need to check is around 60 (specifically, `floor(log2(N+1)) - 1` for `k=2`). Let's say `m_max = 60`.\nFor each `m` from `3` to `m_max`:\nWe need to find if there is an integer `k > 1` such that `(k^(m+1) - 1) / (k - 1) = n`.\nThis is equivalent to `k^(m+1) - 1 = n * (k - 1)`.\nThis equation is monotonic in `k` for fixed `m`. We can use binary search to find `k`.\nThe range for `k` is from `2` up to `n^(1/m)`. For `m=3`, `k` can be up to `10^6`.\nThe binary search for `k` will involve calculating `k^(m+1)`. This can be done efficiently using `pow(k, m+1)`.\nThe number of `m` values is small (around 60). The binary search takes `log(n^(1/m))` iterations, which is `log(k_max)`.\nFor `m=3`, `log(10^6)` is about 20.\nTotal complexity: `m_max * log(k_max)`. This is roughly `60 * 20 = 1200` operations per test case, which is efficient enough.\n\n**Algorithm:**\n1.  Read `t`.\n2.  For each test case `n`:\n    a.  Initialize `found = False`.\n    b.  **Check Case 1 (`m=2`):**\n        Calculate `val = 4 * n - 3`.\n        If `val < 0`, continue (no real `s`).\n        Calculate `s_float = sqrt(val)`.\n        `s = int(s_float)`.\n        If `s * s == val` (perfect square) and `s % 2 == 1` (s is odd) and `s > 3`:\n            `k = (s - 1) // 2`. This `k` is guaranteed to be `> 1`.\n            Set `found = True` and break.\n    c.  **Check Case 2 (`m > 2`):**\n        If `found` is still `False`:\n            Iterate `m` from `3` up to `60` (or `m_max` determined by `k=2`).\n            For each `m`, perform binary search for `k` in the range `[2, n^(1/m) + 2]`.\n            The upper bound for `k` can be estimated as `n^(1/m)`. A safe upper bound for binary search could be `2 * 10^6` for `m=3` or `2 * 10^18 / 2 = 10^18` if we are not careful. A tighter bound is `min(2 * 10^9, int(n**(1/m)) + 2)`.\n            Let `low = 2`, `high = min(2 * 10**9, int(n**(1/m)) + 2)` (or `high = 2 * 10**6` is sufficient for `m=3` and `n=10^18`, `2 * 10^9` is a safe upper bound generally for `k` if `m >= 3`).\n            While `low <= high`:\n                `mid = (low + high) // 2`.\n                If `mid < 2`, set `low = 2` and continue.\n                Calculate `current_sum = 0`.\n                `term = 1`.\n                `overflow = False`.\n                For `i` from `0` to `m`:\n                    `current_sum += term`.\n                    If `i < m`: // Avoid overflow for the last term * mid\n                        If `term > (n + 1) // mid`: // Check for term * mid overflow before multiplication\n                            `overflow = True`\n                            break\n                        `term *= mid`\n                If `overflow` or `current_sum > n`:\n                    `high = mid - 1`\n                Else if `current_sum < n`:\n                    `low = mid + 1`\n                Else (`current_sum == n`):\n                    `found = True`\n                    break (from binary search)\n            If `found`, break (from `m` loop).\n    d.  Print \"YES\" if `found`, \"NO\" otherwise.\n\n**Edge cases:**\n*   `n=1`: `1 = 1 + k + k^2 + ...`. This is impossible for `k > 1` and `m >= 2`. Output: NO.\n*   `n=2,3,6`: These are small `n` values.\n    *   `n=2`: `4*2-3 = 5` (not perfect square). No `m=2` solution. For `m>=3`, `1+k+k^2+... >= 1+2+4+8 = 15 > 2`. So NO.\n    *   `n=3`: `4*3-3 = 9 = 3^2`. `s=3`. `s` is odd, but `s` is not `>3`. So `k=(3-1)/2 = 1`, which is not `>1`. No `m=2` solution. For `m>=3`, `1+k+k^2+... >= 15 > 3`. So NO.\n    *   `n=6`: `4*6-3 = 21` (not perfect square). No `m=2` solution. For `m>=3`, `1+k+k^2+... >= 15 > 6`. So NO.\nThe example output matches these small `n` values.\n\n**Refined binary search upper bound for `k`:**\nFor `n = 1 + k + ... + k^m`, we know `k^m < n`. So `k < n^(1/m)`.\nFor `m=3`, `k < (10^18)^(1/3) = 10^6`.\nFor `m=60`, `k < (10^18)^(1/60) = 10^(0.3) approx 1.99`. So `k` can only be `2`.\nA safe upper bound for `k` in binary search can be `2 * 10^6` for `m=3` and it decreases quickly.\nA simple `high = 10**6 + 7` (or similar) will work for all `m >= 3` as `k` cannot exceed `10^6` for `m=3` and for higher `m`, `k` is even smaller.\n\n**Overflow check in geometric series sum:**\nWhen calculating `current_sum = 1 + k + k^2 + ... + k^m`, we need to be careful about `k^i` overflowing standard integer types if `k` is large, or `current_sum` overflowing `n` if `n` is `10^18`. Python handles large integers automatically, so `k^i` will not overflow. However, `current_sum` can exceed `n`, so we need to check `current_sum > n` to prune the binary search.\nAlso, when calculating `term *= mid`, if `term` is already very large, `term * mid` could exceed `n` even before `current_sum` does. It's better to check `term > n // mid` before multiplication to prevent `term * mid` from exceeding `n` if `n` is the target value. Or, since `n` is the maximum possible sum, we can check `term > N_MAX // mid` where `N_MAX = 10^18` to detect potential overflow for the intermediate `term` value. More simply, `current_sum` can be checked against `n` directly. If `current_sum` itself exceeds `n`, we know `mid` is too large.\n\nLet's refine the sum calculation:\n```python\ndef check_sum(k, m, n):\n    current_sum = 1\n    term = 1\n    for _ in range(m): # Add m terms: k, k^2, ..., k^m\n        # Check for overflow before multiplying term by k\n        if term > n // k: # If term * k would exceed n, then current_sum will definitely exceed n\n            return 2 # Indicates sum is too large\n        term *= k\n        # Check for overflow before adding to current_sum\n        if current_sum > n - term: # If current_sum + term would exceed n\n            return 2 # Indicates sum is too large\n        current_sum += term\n    \n    if current_sum == n:\n        return 1 # Found\n    elif current_sum < n:\n        return 0 # Sum is too small\n    else: # current_sum > n\n        return 2 # Sum is too large\n```\nThis `check_sum` function handles potential overflows by comparing against `n` before multiplications and additions.\n\nThe maximum `m` for `k=2` is `m=59` (since `2^60 - 1` is approx `1.15 * 10^18`). So `m` up to 60 is a good upper limit.\n\n```python\nimport sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n <= 6: # Smallest snowflake is 1+2+4=7 for k=2, m=2\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    if val >= 0:\n        s_float = math.isqrt(val) # integer square root\n        s = int(s_float)\n        if s * s == val: # Check if val is a perfect square\n            # k = (-1 + s) / 2\n            # For k to be integer, s must be odd.\n            # For k > 1, (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n            if s % 2 == 1 and s > 3:\n                print(\"YES\")\n                return\n\n    # Case 2: m > 2 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to ~60 (based on k=2, n=10^18)\n    # For each m, binary search for k\n    \n    # Max k for m=3 is (10^18)^(1/3) = 10^6\n    # Max k for m=60 is (10^18)^(1/60) approx 1.99, so k=2.\n    # The upper bound for k in binary search can be set to 10^6 + 7 (or similar value)\n    # since k cannot exceed 10^6 for m >= 3.\n    \n    for m in range(3, 61): # m from 3 to 60\n        low = 2\n        high = int(n**(1/m)) + 2 # A safe upper bound for k for a given m.\n                                  # n**(1/m) can be slightly off due to float precision, so add a small constant.\n                                  # Max high would be ~10^6 for m=3.\n        \n        # Ensure high is not excessively large if n is small, e.g., n=7, m=3, 7**(1/3)+2 approx 3.9.\n        # But if n is large and m is small, this bound works.\n        # If n is 10^18, m=3, high ~ 10^6.\n        # If n is 10^18, m=60, high ~ 1.99+2 = 3.99.\n        # This upper bound is fine.\n\n        while low <= high:\n            k = (low + high) // 2\n            if k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            term = 1\n            overflow = False\n\n            for _ in range(m): # Add k, k^2, ..., k^m\n                # Check for overflow before multiplying term by k\n                # If term * k would exceed n, then current_sum will definitely exceed n\n                if term > n // k: \n                    overflow = True\n                    break\n                term *= k\n                \n                # Check for overflow before adding to current_sum\n                # If current_sum + term would exceed n\n                if current_sum > n - term:\n                    overflow = True\n                    break\n                current_sum += term\n            \n            if overflow or current_sum > n:\n                high = k - 1\n            elif current_sum < n:\n                low = k + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n <= 6: # Smallest snowflake is 1+2+4=7 for k=2, m=2\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    if val >= 0:\n        s_float = math.isqrt(val) # integer square root\n        s = int(s_float)\n        if s * s == val: # Check if val is a perfect square\n            # k = (-1 + s) / 2\n            # For k to be integer, s must be odd.\n            # For k > 1, (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n            if s % 2 == 1 and s > 3:\n                print(\"YES\")\n                return\n\n    # Case 2: m > 2 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to ~60 (based on k=2, n=10^18)\n    # For each m, binary search for k\n    \n    # Max k for m=3 is (10^18)^(1/3) = 10^6\n    # Max k for m=60 is (10^18)^(1/60) approx 1.99, so k=2.\n    # The upper bound for k in binary search can be set to 10^6 + 7 (or similar value)\n    # since k cannot exceed 10^6 for m >= 3.\n    \n    for m in range(3, 61): # m from 3 to 60\n        low = 2\n        high = int(n**(1/m)) + 2 # A safe upper bound for k for a given m.\n                                  # n**(1/m) can be slightly off due to float precision, so add a small constant.\n                                  # Max high would be ~10^6 for m=3.\n        \n        # Ensure high is not excessively large if n is small, e.g., n=7, m=3, 7**(1/3)+2 approx 3.9.\n        # But if n is large and m is small, this bound works.\n        # If n is 10^18, m=3, high ~ 10^6.\n        # If n is 10^18, m=60, high ~ 1.99+2 = 3.99.\n        # This upper bound is fine.\n\n        while low <= high:\n            k = (low + high) // 2\n            if k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            term = 1\n            overflow = False\n\n            for _ in range(m): # Add k, k^2, ..., k^m\n                # Check for overflow before multiplying term by k\n                # If term * k would exceed n, then current_sum will definitely exceed n\n                if term > n // k: \n                    overflow = True\n                    break\n                term *= k\n                \n                # Check for overflow before adding to current_sum\n                # If current_sum + term would exceed n\n                if current_sum > n - term:\n                    overflow = True\n                    break\n                current_sum += term\n            \n            if overflow or current_sum > n:\n                high = k - 1\n            elif current_sum < n:\n                low = k + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 4665,
        "thoughts_token_count": 832
    }
}