{
    "start": 1758009368.2365148,
    "end": 1758009616.2382956,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 17:00 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Alright, here's the plan for tackling this \"Flawed Flow\" problem in Python.**\n\nI'm staring at this problem and immediately, the need for a Python script is clear. My expert intuition tells me this can be elegantly solved by leveraging graph structures and the conditions they impose. First, let's break down the core challenges.\n\nThe input is straightforward – number of vertices (`n`), number of edges (`m`), and the edge details: `ai`, `bi`, and flow `ci`. The goal is to determine the direction of each edge (`di = 0` for `ai -> bi`, `di = 1` for `bi -> ai`) while satisfying these key constraints:\n\n1.  **Flow Conservation:** This is the big one. At all intermediate nodes (not 1 or n), the incoming flow must perfectly balance the outgoing flow. This screams \"network flow\" right away.\n2.  **Source Condition:** Vertex 1 has no incoming flow, which means all edges connected to it *must* point outwards. This is a very strong starting point.\n3.  **Acyclicity:** The directed graph must be acyclic. No cycles allowed! This is critical for the \"max flow\" implied condition.\n4.  **Max Flow Implication:** We're not calculating the max flow explicitly. Instead, we're directed on the edges in a way the implies some Max-Flow solution.\n\nNow, let's dissect the implications of these conditions. The source condition (vertex 1) is a gift – all its edges point outwards. That's a huge simplification! Acyclicity is my main concern. I can guarantee acyclicity by ensuring flow goes from lower \"layers\" to higher \"layers\" of the graph. The \"layers\" may be the distances from the source.\n\nThe flow conservation, coupled with the source constraint, essentially means that the total flow *out* of vertex 1 must be equal to the total flow *into* vertex `n`. I should keep this fact in mind and make sure that the constraints are met.\n\nI know I can approach this by constructing a graph, probably using an adjacency list or dictionary of lists, and carefully directing the edges based on the flow values.  I see a path towards using a Depth-First Search (DFS) or a topological sort strategy might be crucial here. The goal will be to make sure that the directions I choose, based on a DFS-like approach, maintain flow conservation at all intermediate nodes and ensure there are no cycles.\n\nI'm thinking of developing an algorithm that starts by processing the edges connected to vertex 1. These are all directed outwards. Then, I can iteratively process the remaining nodes, ensuring that the direction of each edge conserves flow at each intermediate node. I'll need to keep track of the cumulative flow so that the resulting graph remains acyclic.\n",
    "response": "The problem asks us to determine the direction of flow for each edge in an undirected graph, given the flow volume `ci` for each edge. We need to satisfy three conditions:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  **Source Constraint:** Vertex 1 (source) has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n\nA crucial guarantee is that a solution always exists.\n\nLet's analyze the conditions:\n\n*   **Source Constraint:** Vertex 1 having no incoming edges means all edges connected to vertex 1 must be directed *away* from vertex 1. This gives us a starting point.\n*   **Acyclicity:** This condition, combined with the flow conservation and source constraint, strongly suggests that the flow must generally move \"away\" from the source towards the sink. A common way to achieve acyclicity in flow networks is to ensure that flow always goes from a vertex with a smaller \"distance\" from the source to a vertex with a larger \"distance\". This implies a topological ordering.\n\nConsider a Breadth-First Search (BFS) starting from the source (vertex 1). A BFS explores the graph layer by layer, giving us the shortest distance from the source to all other reachable vertices. If we direct edges such that flow always goes from a vertex `u` to a vertex `v` where `dist[u] < dist[v]`, we guarantee acyclicity. However, this is not always possible with the given flow volumes. For example, an edge `u-v` might have `dist[u] = dist[v] + 1`, meaning `v` is closer to the source, but the flow might need to go `v -> u` to satisfy conservation.\n\nA more robust approach for flow problems that guarantees acyclicity and flow conservation for intermediate nodes is to use a depth-first search (DFS) or a similar traversal that processes nodes in a specific order.\n\nLet's define `balance[v]` for each vertex `v` as the net flow *out* of `v`. Initially, `balance[v] = 0` for all `v`.\nWhen we direct an edge `u -> v` with flow `c`:\n*   `balance[u]` increases by `c`.\n*   `balance[v]` decreases by `c`.\n\nThe conditions translate to:\n*   `balance[v] = 0` for `1 < v < n`.\n*   `balance[1] >= 0` (all edges from 1 are outgoing).\n*   `balance[n] <= 0` (all edges to n are incoming, by typical max-flow definition).\n*   The total flow value is `balance[1] = -balance[n]`.\n\nThe key insight to satisfy flow conservation and acyclicity is to process vertices in an order that allows us to \"resolve\" their flow balance. A DFS-like approach is suitable here. We can start a traversal from the source (vertex 1). When we visit a vertex `u`, we try to direct its incident edges.\n\n**Algorithm:**\n\n1.  **Represent the Graph:** Store the graph using an adjacency list. For each edge, store the connected vertex, its flow capacity, and its original index.\n    `adj[u]` will contain `(v, c, edge_idx)` for an edge `(u, v)` with flow `c`.\n    We also need an array `ans` of size `m` to store the direction for each edge.\n\n2.  **Initialize `current_flow_out[v]`:** For each vertex `v`, initialize `current_flow_out[v] = 0`. This will track the *net flow out* of `v` based on edges we've already directed.\n\n3.  **DFS Traversal:**\n    *   Start a DFS from vertex 1. Maintain a `visited` array to prevent cycles in the DFS itself (not in the flow graph).\n    *   `dfs(u, parent_edge_idx)`:\n        *   Mark `u` as visited.\n        *   For each neighbor `v` of `u` with edge `(u, v)` having flow `c` and original index `idx`:\n            *   If `v` is not visited:\n                *   Recursively call `dfs(v, idx)`. This call will direct all edges in the subtree rooted at `v` that are not yet directed, and `current_flow_out[v]` will reflect the net flow *out* of `v` through its children in the DFS tree.\n                *   After the recursive call returns, we now need to direct the edge `(u, v)`.\n                *   If `current_flow_out[v]` is positive, it means `v` has an excess of outgoing flow (flow needs to come *into* `v` from `u`). So, direct `u <- v` (flow from `v` to `u`).\n                    *   `ans[idx] = 1` (flow `bi -> ai` if original edge was `ai, bi`).\n                    *   `current_flow_out[u] += c`.\n                *   If `current_flow_out[v]` is zero or negative, it means `v` needs flow *out* of it (flow needs to go from `u` to `v`). So, direct `u -> v`.\n                    *   `ans[idx] = 0` (flow `ai -> bi`).\n                    *   `current_flow_out[u] -= c`.\n            *   If `v` *is* visited and `idx != parent_edge_idx`: This means `(u, v)` is a back-edge in the DFS tree. We don't direct back-edges during the initial DFS pass. We'll handle these later or implicitly.\n                *   Actually, we don't need to distinguish tree edges and back edges. The DFS ensures that when `dfs(u)` returns, `current_flow_out[u]` will represent the net flow *out* of `u` through all its children *in the DFS tree*. The decision for edge `(u,v)` is made when returning from `dfs(v)`.\n\nLet's refine the DFS logic. The key is that for any node `u` (except `n`), its `current_flow_out[u]` must eventually be 0. For `n`, it should be negative (net incoming flow).\n\nA standard DFS approach for this type of problem is to accumulate flow.\nWhen `dfs(u)` is called, `current_flow_out[u]` is initially 0. As we visit children `v` of `u`:\n1.  Recursively call `dfs(v)`.\n2.  `dfs(v)` will return the total flow that `v` \"needs\" from `u` (if `current_flow_out[v]` is negative after processing `v`'s subtree) or \"provides\" to `u` (if `current_flow_out[v]` is positive).\n3.  We then direct the edge `(u,v)` to balance `v`'s flow.\n\nLet's use a `flow_balance[v]` array initialized to 0 for all `v`.\nWhen `dfs(u)` is called, it processes all unvisited neighbors `v`.\nFor each `(v, c, idx)` connected to `u`:\n*   If `v` is not visited:\n    *   Recursively call `dfs(v)`.\n    *   After `dfs(v)` returns, `flow_balance[v]` will contain the net flow that `v` has accumulated from its *own* children in the DFS tree.\n    *   If `flow_balance[v]` is positive: `v` has an excess of outgoing flow. This flow must come *into* `v` from `u`. So, `u <- v`.\n        *   `ans[idx] = 1` (if `a_i=u, b_i=v` or `a_i=v, b_i=u` and `v` is the first element in the original edge, then `1` means `b_i -> a_i`). Let's use `0` for `u -> v` and `1` for `v -> u`.\n        *   `ans[idx] = 1` (flow `v -> u`).\n        *   `flow_balance[u] += c`.\n    *   If `flow_balance[v]` is negative or zero: `v` needs to send flow out. This flow must go *from* `u` to `v`. So, `u -> v`.\n        *   `ans[idx] = 0` (flow `u -> v`).\n        *   `flow_balance[u] -= c`.\n    *   In both cases, we update `flow_balance[v]` by adding/subtracting `c` based on the direction. This is critical.\n        *   If `v -> u`, `flow_balance[v] -= c`. (We've balanced `v`'s excess by sending `c` to `u`).\n        *   If `u -> v`, `flow_balance[v] += c`. (We've balanced `v`'s deficit by receiving `c` from `u`).\n        *   No, this is wrong. `flow_balance[v]` should reflect the net flow *after* handling all its children. The edge `(u,v)` is the *parent* edge.\n\nLet's use a simpler state: `current_sum_out[v]` is the sum of flows *out* of `v` through its children in the DFS tree, minus the sum of flows *into* `v` from its children.\n\n**Revised DFS Algorithm:**\n\n1.  **Data Structures:**\n    *   `adj`: Adjacency list, `adj[u]` stores `(v, c, original_edge_idx)`.\n    *   `ans`: List of size `m` to store directions (0 for `a_i -> b_i`, 1 for `b_i -> a_i`).\n    *   `visited`: Boolean array to track visited nodes in DFS.\n    *   `flow_balance`: Integer array, `flow_balance[v]` will store the net flow *out* of `v` through edges already directed. Initialize to 0.\n\n2.  **`dfs(u)` function:**\n    *   Mark `u` as `visited[u] = True`.\n    *   For each neighbor `v` of `u` with edge `(u, v)` having flow `c` and original index `idx`:\n        *   If `v` is not `visited[v]`:\n            *   Recursively call `dfs(v)`.\n            *   After `dfs(v)` returns, `flow_balance[v]` contains the net flow out of `v` through its subtree.\n            *   Now we decide the direction of edge `(u, v)`:\n                *   If `flow_balance[v]` is positive: This means `v` has an excess of flow `flow_balance[v]` that needs to go *somewhere*. Since `u` is its parent, this flow must go `v -> u`.\n                    *   Set `ans[idx] = 1` (meaning flow `b_i -> a_i` if `a_i` was `u` and `b_i` was `v`, or `a_i` was `v` and `b_i` was `u`). More generally, it means flow from the second vertex to the first vertex in the input.\n                    *   Update `flow_balance[u] += c`.\n                *   If `flow_balance[v]` is zero or negative: This means `v` needs `|flow_balance[v]|` flow to come *into* it to balance its outgoing flow. This flow must come from `u`. So, `u -> v`.\n                    *   Set `ans[idx] = 0`.\n                    *   Update `flow_balance[u] -= c`.\n    *   The `flow_balance[u]` value after this loop represents the net flow out of `u` through its children in the DFS tree. This value will be used by `u`'s parent.\n\n3.  **Main Logic:**\n    *   Read `n, m`.\n    *   Populate `adj` list. Store original `a_i, b_i` for each edge to correctly map `ans[idx]` to `0` or `1`.\n    *   Call `dfs(1)`.\n\n**Example Walkthrough (First Test Case):**\n`3 3`\n`3 2 10` (edge 0: u=3, v=2, c=10)\n`1 2 10` (edge 1: u=1, v=2, c=10)\n`3 1 5` (edge 2: u=3, v=1, c=5)\n\n`adj` (storing original `a_i, b_i` for reference):\n`adj[1]: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]`\n`adj[2]: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]`\n`adj[3]: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]`\n\n`ans = [?, ?, ?]`\n`visited = [F,F,F,F]` (index 0 unused)\n`flow_balance = [0,0,0,0]`\n\nCall `dfs(1)`:\n    `visited[1] = True`\n\n    *   Consider neighbor `(2, 10, 1)` (original `1, 2`):\n        *   `visited[2]` is False. Call `dfs(2)`:\n            `visited[2] = True`\n            *   Consider neighbor `(3, 10, 0)` (original `3, 2`):\n                *   `visited[3]` is False. Call `dfs(3)`:\n                    `visited[3] = True`\n                    *   Consider neighbor `(2, 10, 0)` (original `3, 2`):\n                        *   `visited[2]` is True. This is the parent edge. Skip. (Crucial: we need to avoid processing the edge back to parent)\n                    *   Consider neighbor `(1, 5, 2)` (original `3, 1`):\n                        *   `visited[1]` is True. This is not the parent edge. This is a cross/back edge.\n                        *   This is where the problem simplifies: the source `1` has no incoming edges. So, any edge connected to `1` must be directed `1 -> x`.\n                        *   Let's modify the DFS: when `u` is `n`, we don't need to balance its flow. When `u` is `1`, it must only have outgoing flow.\n                        *   The problem statement guarantees that vertex 1 has no incoming edges. This simplifies the logic. If we encounter an edge `(u, 1)` where `u != 1`, we *must* direct it `u -> 1`. This is incorrect. The problem says \"vertex with number 1 has no incoming edges\". This means *after* all edges are directed. Our algorithm must ensure this.\n\nLet's re-evaluate the role of `flow_balance[v]`.\n`flow_balance[v]` should be the *net flow out of `v` through its children in the DFS tree*.\nWhen `dfs(u)` is called, it processes children `v`. After `dfs(v)` returns, `flow_balance[v]` is known.\n*   If `flow_balance[v] > 0`: `v` has an excess. This must go `v -> u`. So `ans[idx] = 1`. `flow_balance[u] += c`.\n*   If `flow_balance[v] <= 0`: `v` needs flow. This must come `u -> v`. So `ans[idx] = 0`. `flow_balance[u] -= c`.\n\nThe base case for DFS: If `u == n`, `flow_balance[n]` should represent the total incoming flow. It should be negative.\nThe problem states that vertex 1 has no incoming edges. This implies that for any edge `(1, v)`, it must be directed `1 -> v`.\n\n**Corrected DFS Logic for `dfs(u, p_idx)`:**\n`p_idx` is the index of the edge that brought us to `u` from its parent. This is to avoid going back immediately.\n\n```python\ndef dfs(u, p_idx):\n    visited[u] = True\n    for v, c, idx, original_a, original_b in adj[u]:\n        if idx == p_idx: # Don't go back to parent immediately\n            continue\n        if not visited[v]:\n            dfs(v, idx) # Recurse on child v\n\n            # After dfs(v) returns, flow_balance[v] has net flow from v's subtree\n            # Decide direction for edge (u, v) with flow c, original index idx\n            if flow_balance[v] > 0: # v has excess, flow must go v -> u\n                # If original edge was (original_a, original_b)\n                # and u is original_a, v is original_b: we want v -> u, so ans[idx] = 1\n                # if u is original_b, v is original_a: we want u -> v, so ans[idx] = 0\n                if original_a == u: # Edge was u-v, now v->u\n                    ans[idx] = 1\n                else: # Edge was v-u, now v->u\n                    ans[idx] = 0\n                flow_balance[u] += c\n            else: # v needs flow, flow must go u -> v\n                if original_a == u: # Edge was u-v, now u->v\n                    ans[idx] = 0\n                else: # Edge was v-u, now u->v\n                    ans[idx] = 1\n                flow_balance[u] -= c\n```\n\nThis logic handles tree edges. What about back-edges?\nThe problem statement says \"vertex with number 1 has no incoming edges\". This is a global constraint.\nThe acyclicity constraint is also global.\nThe given DFS strategy ensures acyclicity within the DFS tree structure. By directing edges based on `flow_balance[v]`, we are effectively \"pushing\" any excess flow up towards the root of the DFS tree (which is vertex 1).\n\nLet's trace `dfs(1)` again with the corrected logic:\n`dfs(1, -1)`:\n    `visited[1] = True`\n    `adj[1]` contains `(2, 10, 1, 1, 2)` and `(3, 5, 2, 3, 1)`.\n\n    1.  Process `(2, 10, 1, 1, 2)`:\n        *   `v=2`, `c=10`, `idx=1`. `visited[2]` is False.\n        *   Call `dfs(2, 1)`:\n            `visited[2] = True`\n            `adj[2]` contains `(3, 10, 0, 3, 2)` and `(1, 10, 1, 1, 2)`.\n            *   Process `(3, 10, 0, 3, 2)`:\n                *   `v=3`, `c=10`, `idx=0`. `visited[3]` is False.\n                *   Call `dfs(3, 0)`:\n                    `visited[3] = True`\n                    `adj[3]` contains `(2, 10, 0, 3, 2)` and `(1, 5, 2, 3, 1)`.\n                    *   Process `(2, 10, 0, 3, 2)`: `idx=0 == p_idx`. Skip.\n                    *   Process `(1, 5, 2, 3, 1)`:\n                        *   `v=1`, `c=5`, `idx=2`. `visited[1]` is True. `idx=2 != p_idx=0`. This is a back-edge.\n                        *   The DFS logic doesn't explicitly handle back-edges. If we simply skip visited nodes, we'd miss directing this edge. This is why the `flow_balance` approach is usually used with a post-order traversal where *all* edges are considered.\n\nThe problem guarantees a solution exists and the graph is connected. This hints that a simple DFS/BFS traversal should work.\nThe key condition \"vertex with number 1 has no incoming edges\" is crucial. This means `flow_balance[1]` must be equal to the total flow value, and it must be positive.\nThe `flow_balance[n]` must be equal to `-total_flow_value`.\n\nLet's reconsider the `flow_balance` interpretation. It's the net flow *leaving* the subtree rooted at `u` (through the edge `(u, parent)`).\nWhen `dfs(u, p_edge_idx)` finishes, `flow_balance[u]` should be the sum of all `c` for edges directed `u -> x` minus sum of all `c` for edges directed `x -> u`, for all `x` that are children of `u` in the DFS tree.\n\nThe strategy that works for this type of problem is often:\n1.  Perform a DFS.\n2.  When `dfs(u)` returns, `u` has processed all its children. `flow_balance[u]` holds the sum of flows that `u` has sent *out* to its children minus flows `u` has received *from* its children.\n3.  If `u` is not `n`: its `flow_balance[u]` must eventually be 0. If `flow_balance[u] != 0`, then the remaining flow must be handled by the edge to its parent.\n    *   If `flow_balance[u] > 0`: `u` has an excess. This excess must go `u -> parent`.\n    *   If `flow_balance[u] < 0`: `u` needs flow. This flow must come `parent -> u`.\n4.  If `u == n`: `flow_balance[n]` will accumulate the total incoming flow.\n\nThis is the standard approach for finding flow directions in a tree-like structure. The challenge here is the general graph and the specific conditions.\n\nThe condition \"vertex with number 1 has no incoming edges\" means that *all* edges incident to vertex 1 must be directed `1 -> v`. We can pre-process these edges.\nFor any edge `(1, v, c, idx)`:\n*   If `original_a == 1`, `ans[idx] = 0`.\n*   If `original_b == 1`, `ans[idx] = 1`.\n*   In both cases, `flow_balance[1] += c` and `flow_balance[v] -= c`.\nThen we run DFS starting from 1, but this time, 1 is already \"balanced\" in terms of its initial outgoing flow.\n\nThis approach is likely too complex. The problem is tagged \"very easy\".\n\nLet's reconsider the example with the simple DFS logic:\n`dfs(u, p_idx)`:\n    `visited[u] = True`\n    `current_flow_sum = 0` (local variable for `u`'s net flow to/from children)\n\n    For each neighbor `v` of `u` with edge `(u, v)` having flow `c` and original index `idx`:\n        If `idx == p_idx`: continue (skip parent edge)\n        If `v` is not `visited[v]`:\n            `dfs(v, idx)`\n            # After dfs(v) returns, flow_balance[v]` holds the net flow from v's subtree.\n            # We must balance v's subtree flow using edge (u,v)\n            if `flow_balance[v] > 0`: # v has excess, flow must go v -> u\n                # Direction: v -> u\n                if `original_a_of_idx == u`: `ans[idx] = 1` (original was u-v, now v->u)\n                else: `ans[idx] = 0` (original was v-u, now v->u)\n                `current_flow_sum += c`\n            else: # v needs flow, flow must go u -> v\n                # Direction: u -> v\n                if `original_a_of_idx == u`: `ans[idx] = 0` (original was u-v, now u->v)\n                else: `ans[idx] = 1` (original was v-u, now u->v)\n                `current_flow_sum -= c`\n        Else (`v` is visited and `idx != p_idx`): This is a back-edge or cross-edge.\n            # We need to direct this edge as well.\n            # How to direct it?\n            # If v is 1, it must be u -> 1. This contradicts the source constraint.\n            # So, if v is 1, it must be 1 -> u. This means (u,1) is directed 1->u.\n            # This implies that the current edge (u,v) where v=1 must be directed 1->u.\n            # This is equivalent to u <- 1.\n            # So, if original_a_of_idx == u: ans[idx] = 0 (u->1) is wrong, must be 1->u, so ans[idx]=1\n            # If original_b_of_idx == u: ans[idx] = 0 (1->u) is correct.\n\nThe constraint \"vertex with number 1 has no incoming edges\" is the strongest.\nLet `total_flow_out_of_1` be the sum of `c` for all edges connected to 1.\nThis `total_flow_out_of_1` must be the total max flow.\nFor any vertex `v` (1 < `v` < `n`), its net flow must be 0.\nFor vertex `n`, its net flow must be `-total_flow_out_of_1`.\n\nLet's maintain `current_flow[v]` for each vertex `v`. This will be the current net flow *out* of `v`.\nInitialize `current_flow[v] = 0` for all `v`.\n\nWe can use a queue for a BFS-like approach, or a stack for DFS.\nThe key is to process nodes whose incident edges can be fully determined.\n\nConsider the example output:\n`3 3`\n`3 2 10` (edge 0)\n`1 2 10` (edge 1)\n`3 1 5` (edge 2)\n\nOutput:\n`1` (edge 0: `3 -> 2` becomes `2 -> 3`. Flow 10)\n`0` (edge 1: `1 -> 2` becomes `1 -> 2`. Flow 10)\n`1` (edge 2: `3 -> 1` becomes `1 -> 3`. Flow 5)\n\nLet's check flow conservation:\nVertex 1: Outgoing: `1 -> 2` (10), `1 -> 3` (5). Total outgoing = 15. Incoming = 0. OK.\nVertex 2: Incoming: `1 -> 2` (10). Outgoing: `2 -> 3` (10). Total incoming = 10, total outgoing = 10. OK.\nVertex 3: Incoming: `2 -> 3` (10), `1 -> 3` (5). Total incoming = 15.\nVertex 3 is `n`. So it should have net incoming flow. Total incoming = 15. Total outgoing = 0. OK.\n\nThis solution is a valid max flow.\nNotice that for vertex 1, all edges are directed away from it.\nFor vertex 3, all edges are directed towards it.\nFor vertex 2, it's balanced.\n\nThe total flow is 15.\n`flow_balance` after directing:\n`flow_balance[1] = 10 + 5 = 15`\n`flow_balance[2] = -10 + 10 = 0`\n`flow_balance[3] = -10 - 5 = -15`\n\nThis suggests a strategy:\n1.  Initialize `current_net_flow_out[v] = 0` for all `v`.\n2.  Store edges as `(u, v, c, idx, original_a, original_b)`.\n3.  Perform a DFS from node 1.\n    `dfs(u, p_idx)`:\n        `visited[u] = True`\n        For each edge `(v, c, idx, original_a, original_b)` in `adj[u]`:\n            If `idx == p_idx`: continue.\n            If `v` is not `visited[v]`:\n                `dfs(v, idx)`\n                # After child `v` and its subtree are processed\n                # `current_net_flow_out[v]` now holds the net flow from `v`'s subtree.\n                # This flow must be balanced by the edge `(u, v)`.\n                if `current_net_flow_out[v] > 0`: # `v` has excess flow, must go `v -> u`\n                    if `original_a == u`: `ans[idx] = 1` (original `u-v`, now `v->u`)\n                    else: `ans[idx] = 0` (original `v-u`, now `v->u`)\n                    `current_net_flow_out[u] += c`\n                else: # `v` needs flow, must go `u -> v`\n                    if `original_a == u`: `ans[idx] = 0` (original `u-v`, now `u->v`)\n                    else: `ans[idx] = 1` (original `v-u`, now `u->v`)\n                    `current_net_flow_out[u] -= c`\n            Else (`v` is visited and `idx != p_idx`):\n                # This is a back-edge or cross-edge.\n                # The crucial constraint is that vertex 1 has no incoming edges.\n                # So, any edge `(u, 1)` must be directed `1 -> u`.\n                # If `v == 1`:\n                if `v == 1`:\n                    # Edge is (u, 1). Must be directed 1 -> u.\n                    # This means flow goes from v to u.\n                    if `original_a == u`: `ans[idx] = 1` (original `u-1`, now `1->u`)\n                    else: `ans[idx] = 0` (original `1-u`, now `1->u`)\n                    `current_net_flow_out[u] += c`\n                # Else: `v` is a visited node other than 1.\n                # This edge has already been directed when `v` was processed.\n                # This is a key part. We only direct edges once.\n                # The DFS should only process edges that haven't been directed yet.\n                # To do this, we need to mark edges as directed.\n\nLet's use a `directed` array for edges.\n\n**Final DFS Algorithm:**\n\n1.  **Data Structures:**\n    *   `adj`: Adjacency list, `adj[u]` stores `(v, c, original_edge_idx, original_a, original_b)`.\n    *   `ans`: List of size `m` to store directions (0 for `a_i -> b_i`, 1 for `b_i -> a_i`). Initialize with -1.\n    *   `visited`: Boolean array to track visited nodes in DFS.\n    *   `current_net_flow_out`: Integer array, `current_net_flow_out[v]` will store the net flow *out* of `v` through edges already directed within its DFS subtree. Initialize to 0.\n\n2.  **`dfs(u)` function:**\n    *   Mark `u` as `visited[u] = True`.\n    *   For each neighbor `(v, c, idx, original_a, original_b)` in `adj[u]`:\n        *   If `ans[idx]` is not -1 (edge already directed): continue.\n        *   If `v == n`:\n            # If `v` is the sink, flow must go `u -> n`.\n            if `original_a == u`: `ans[idx] = 0`\n            else: `ans[idx] = 1`\n            `current_net_flow_out[u] -= c` # Flow leaves u\n        Else if `v == 1`:\n            # If `v` is the source, flow must go `1 -> u`.\n            # This means flow goes `v -> u`.\n            if `original_a == u`: `ans[idx] = 1` # original `u-1`, now `1->u`\n            else: `ans[idx] = 0` # original `1-u`, now `1->u`\n            `current_net_flow_out[u] += c` # Flow enters u\n        Else if not `visited[v]`:\n            # Normal tree edge to an unvisited node. Recurse.\n            `dfs(v)`\n            # After dfs(v) returns, `current_net_flow_out[v]` has the net flow from v's subtree.\n            # Balance `v`'s subtree flow using edge `(u, v)`.\n            if `current_net_flow_out[v] > 0`: # `v` has excess flow, must go `v -> u`\n                if `original_a == u`: `ans[idx] = 1`\n                else: `ans[idx] = 0`\n                `current_net_flow_out[u] += c`\n            else: # `v` needs flow, must go `u -> v`\n                if `original_a == u`: `ans[idx] = 0`\n                else: `ans[idx] = 1`\n                `current_net_flow_out[u] -= c`\n\n3.  **Main Logic:**\n    *   Read `n, m`.\n    *   Populate `adj` list. Store `(v, c, original_edge_idx, original_a, original_b)`.\n    *   Initialize `ans = [-1] * m`.\n    *   Initialize `visited = [False] * (n + 1)`.\n    *   Initialize `current_net_flow_out = [0] * (n + 1)`.\n    *   Call `dfs(1)`.\n    *   Print `ans`.\n\nThis logic for `v == n` and `v == 1` inside the DFS loop is problematic.\nThe constraint \"vertex 1 has no incoming edges\" means *all* edges connected to 1 must be `1 -> x`.\nThe constraint \"vertex n has no outgoing edges\" (implied by max flow) means *all* edges connected to n must be `x -> n`.\n\nA simpler approach might be to use a queue and process nodes whose `current_net_flow_out` can be determined.\n\nConsider the problem from the perspective of source and sink.\nTotal flow out of 1 must be `X`. Total flow into `n` must be `X`.\nAll intermediate nodes `v` (1 < `v` < `n`) must have net flow 0.\n`sum(incoming flow) - sum(outgoing flow) = 0`.\n\nThis can be rephrased: for each intermediate node `v`, `sum(c_in) = sum(c_out)`.\nLet's keep track of `deficit[v] = sum(c_out) - sum(c_in)`. We want `deficit[v] = 0`.\nInitially, for an undirected edge `(u,v)` with flow `c`, `u` can send `c` to `v` or `v` can send `c` to `u`.\n\nThe problem is a variation of finding an Euler tour or path in a directed graph, or flow decomposition.\nThe acyclicity constraint is key. A topological sort is usually used for acyclic graphs.\n\nWhat if we build a directed graph where `u -> v` if `u < v` and `v -> u` if `v < u`? This is not guaranteed to work.\n\nLet's try the DFS with a slight modification for `n`.\nThe `flow_balance[u]` should represent the *excess outgoing flow* from `u`'s subtree.\nIf `u == n`, `flow_balance[n]` will be the total flow that `n` receives, which should be negative.\n\n```python\nimport sys\n\n# Increase recursion limit for deep DFS\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Adjacency list: adj[u] = [(v, c, edge_idx, original_a, original_b), ...]\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store original edge (a, b) for output mapping\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        edges_info.append((u, v, c)) # Keep for debugging if needed\n\n    # ans[i] = 0 if flow is original_a -> original_b\n    # ans[i] = 1 if flow is original_b -> original_a\n    ans = [-1] * m\n\n    # flow_balance[u] stores the net flow leaving the subtree rooted at u\n    # (i.e., sum of flows directed out of u's children - sum of flows directed into u's children)\n    flow_balance = [0] * (n + 1)\n    \n    visited = [False] * (n + 1)\n\n    # DFS function to determine edge directions\n    # u: current vertex\n    # p_edge_idx: index of the edge that led to u from its parent (to avoid going back)\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n\n        for v, c, idx, original_a, original_b in adj[u]:\n            if idx == p_edge_idx: # Skip the edge to the parent\n                continue\n            \n            if not visited[v]:\n                # This is a tree edge to an unvisited child\n                dfs(v, idx) # Recurse on child v\n\n                # After dfs(v) returns, flow_balance[v] contains the net flow from v's subtree.\n                # We need to balance this flow using the edge (u, v).\n                if flow_balance[v] > 0:\n                    # v has an excess of flow leaving its subtree. This flow must come into v from u.\n                    # So, the edge (u, v) must be directed v -> u.\n                    if original_a == u: # Original edge was u-v, now v->u\n                        ans[idx] = 1\n                    else: # Original edge was v-u, now v->u\n                        ans[idx] = 0\n                    flow_balance[u] += c # Flow c comes into u from v\n                else:\n                    # v needs flow. This flow must go from u to v.\n                    # So, the edge (u, v) must be directed u -> v.\n                    if original_a == u: # Original edge was u-v, now u->v\n                        ans[idx] = 0\n                    else: # Original edge was v-u, now u->v\n                        ans[idx] = 1\n                    flow_balance[u] -= c # Flow c leaves u for v\n            # If v is visited and idx != p_edge_idx, it's a back-edge or cross-edge.\n            # In a standard DFS tree construction for flow, these edges are not directed\n            # during the initial DFS pass as they would be handled when their other endpoint\n            # (which is already visited) was processed. However, our `ans` array ensures\n            # each edge is directed exactly once. The `flow_balance` approach correctly\n            # propagates required flow up the tree. For a back-edge (u,v) where v is an ancestor\n            # of u, it means the edge was already processed when v was visited, or it will be\n            # processed when u is visited. The crucial part is that `ans[idx]` being -1\n            # means it hasn't been directed yet.\n            # If `v` is visited and `ans[idx]` is still -1, it means this edge is part of a cycle\n            # not involving the DFS parent. This case needs careful thought.\n            # However, the problem states \"vertex with number 1 has no incoming edges\" and \"acyclic\".\n            # The DFS from source (1) naturally builds a spanning tree. Any edge not in the tree\n            # is a back-edge.\n            # If `v` is visited and `ans[idx]` is still -1, it means `v` is an ancestor of `u` (or in a different branch).\n            # The problem guarantees a solution exists and vertex 1 has no incoming edges.\n            # This implies that all edges to 1 must be outgoing from 1.\n            # If we encounter an edge `(u, 1)` where `u != 1`, it must be directed `1 -> u`.\n            # This means flow `c` goes from `v=1` to `u`.\n            elif ans[idx] == -1: # This edge connects u to an already visited node v, and it hasn't been directed yet.\n                # This must be a back-edge. `v` is an ancestor of `u` (or `n`).\n                # The only case where this edge would not have been directed is if `v` is an ancestor of `u`.\n                # If `v == 1`: this is an edge `u-1`. It MUST be `1 -> u`.\n                if v == 1:\n                    if original_a == u: # Original edge u-1, now 1->u\n                        ans[idx] = 1\n                    else: # Original edge 1-u, now 1->u\n                        ans[idx] = 0\n                    flow_balance[u] += c # Flow comes into u from 1\n                # If v is not 1, it must be n. Or an intermediate visited node.\n                # The problem guarantees acyclicity.\n                # The standard way to handle back-edges in this context is to direct them\n                # such that flow goes from the \"lower\" node in DFS tree to the \"higher\" node.\n                # Since v is already visited, it means v is \"higher\" than u.\n                # So flow should go u -> v.\n                # This is equivalent to saying `flow_balance[v]` is 0, so `u` needs to send flow to `v`.\n                # This is a bit of a heuristic. The guarantee that solution exists and acyclicity\n                # for intermediate nodes is crucial.\n                # If `v` is an ancestor of `u`, `flow_balance[v]` already accumulated its required flow.\n                # The only way to satisfy flow conservation for `u` is to \"dump\" any excess flow\n                # to its ancestor `v` or receive flow from `v`.\n                # The logic for `flow_balance[v] > 0` vs `<= 0` already handles this.\n                # So we can just apply the same logic.\n                # The problem is that `flow_balance[v]` is already finalized for `v` when `dfs(v)` returned.\n                # The key is that `flow_balance[v]` is only for the subtree below `v`.\n                # For back-edges, we don't have a `flow_balance[v]` to query.\n                # We need to decide direction for `(u, v)` (back-edge) without `flow_balance[v]`.\n\n                # The problem statement implies that vertex 1 is the source and n is the sink.\n                # This means flow generally moves from 1 to n.\n                # For a back-edge (u, v) where v is an ancestor of u:\n                # Flow should go from u to v. This means u -> v.\n                # This will contribute to `flow_balance[u]` negatively.\n                # Except if v is 1, it must be 1 -> u.\n                # The simplified approach for back-edges is usually to direct them from the child to ancestor.\n                # However, the problem's source constraint (1 has no incoming) means 1 -> u.\n                # So, if `v == 1`, it must be `1 -> u`. This is `v -> u`.\n                # This means flow comes *into* `u` from `v`.\n                # `flow_balance[u] += c`.\n                # If `v != 1`, it must be an intermediate node.\n                # For intermediate nodes, flow conservation must hold.\n                # The problem statement says \"vertex with number 1 has no incoming edges\".\n                # It does NOT say \"vertex N has no outgoing edges\".\n                # But it implies a max flow.\n                # The simplest acyclic way to direct a back-edge `u-v` where `v` is an ancestor of `u`\n                # is `u -> v`. This maintains the \"downwards\" flow direction in the DFS tree.\n                # But this means `v` gets incoming flow.\n\n                # Let's simplify: the only special cases are `1` and `n`.\n                # Any edge connected to `1` must be `1 -> x`.\n                # Any edge connected to `n` must be `x -> n`.\n                # These can be pre-directed.\n                # The remaining edges form a graph on `2...n-1`.\n                # This could be a valid approach.\n\nThe example output:\n`3 2 10` (edge 0: original `3-2`) -> `2 -> 3` (ans=1)\n`1 2 10` (edge 1: original `1-2`) -> `1 -> 2` (ans=0)\n`3 1 5` (edge 2: original `3-1`) -> `1 -> 3` (ans=1)\n\nIn `dfs(1)`:\n  `visited[1]=T`\n  Process `(2, 10, 1, 1, 2)`:\n    `v=2`, `c=10`, `idx=1`, `original_a=1`, `original_b=2`. `ans[1]` is -1.\n    `visited[2]` is `F`. Call `dfs(2, 1)`:\n      `visited[2]=T`\n      Process `(3, 10, 0, 3, 2)`:\n        `v=3`, `c=10`, `idx=0`, `original_a=3`, `original_b=2`. `ans[0]` is -1.\n        `v=3` is `n`.\n        `original_a=3` is `u`. So `ans[0] = 0` (meaning `3 -> 2`).\n        `flow_balance[2] -= 10`. (`flow_balance[2]` is now -10)\n      Process `(1, 10, 1, 1, 2)`:\n        `idx=1 == p_edge_idx`. Skip.\n      `dfs(2,1)` returns. `flow_balance[2]` is -10.\n    Back in `dfs(1)`:\n    `flow_balance[2]` is -10 (negative). So direction is `1 -> 2`.\n    `original_a=1` is `u`. So `ans[1] = 0`.\n    `flow_balance[1] -= 10`. (`flow_balance[1]` is now -10)\n\n  Process `(3, 5, 2, 3, 1)`:\n    `v=3`, `c=5`, `idx=2`, `original_a=3`, `original_b=1`. `ans[2]` is -1.\n    `v=3` is `n`.\n    `original_a=3` is `u`. So `ans[2] = 0` (meaning `3 -> 1`).\n    `flow_balance[1] -= 5`. (`flow_balance[1]` is now -15)\n\n`dfs(1)` returns.\nFinal `ans`:\n`ans[0] = 0` (`3 -> 2`)\n`ans[1] = 0` (`1 -> 2`)\n`ans[2] = 0` (`3 -> 1`)\n\nThis output is `0 0 0`. But the example output is `1 0 1`.\nMy logic for `v == n` and `v == 1` is wrong.\nThe `flow_balance` approach *already handles* the source/sink properties by propagating flow up the tree.\nThe special handling for `v == n` and `v == 1` should *not* be inside the loop. The `flow_balance` of `n` will naturally be the total incoming flow, and for `1` it will be the total outgoing flow.\n\nThe original DFS logic (without special `v==1` or `v==n` handling in the loop) is the correct one.\nLet's re-trace with that.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, u, v)) # (neighbor, capacity, original_idx, original_a, original_b)\n        adj[v].append((u, c, i, u, v))\n\n    ans = [-1] * m\n    flow_balance = [0] * (n + 1) # Net flow out of subtree rooted at u\n    visited = [False] * (n + 1)\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n\n        for v, c, idx, original_a, original_b in adj[u]:\n            if idx == p_edge_idx: # Skip the edge to the parent\n                continue\n            \n            if not visited[v]:\n                # This is a tree edge to an unvisited child\n                dfs(v, idx) # Recurse on child v\n\n                # After dfs(v) returns, flow_balance[v] contains the net flow from v's subtree.\n                # We need to balance this flow using the edge (u, v).\n                if flow_balance[v] > 0:\n                    # v has an excess of flow leaving its subtree. This flow must come into v from u.\n                    # So, the edge (u, v) must be directed v -> u.\n                    if original_a == u: # Original edge was u-v, now v->u\n                        ans[idx] = 1\n                    else: # Original edge was v-u, now v->u\n                        ans[idx] = 0\n                    flow_balance[u] += c # Flow c comes into u from v\n                else:\n                    # v needs flow (or has balanced flow). This flow must go from u to v.\n                    # So, the edge (u, v) must be directed u -> v.\n                    if original_a == u: # Original edge was u-v, now u->v\n                        ans[idx] = 0\n                    else: # Original edge was v-u, now u->v\n                        ans[idx] = 1\n                    flow_balance[u] -= c # Flow c leaves u for v\n            # If v is visited and idx != p_edge_idx (back-edge or cross-edge):\n            # These edges are not part of the DFS tree. They are effectively ignored by this DFS.\n            # This is okay because the problem guarantees a solution exists and acyclicity.\n            # The flow_balance logic ensures conservation for intermediate nodes.\n            # Any flow excess/deficit will eventually reach node 1 or node n.\n            # The condition \"vertex 1 has no incoming edges\" means that `flow_balance[1]` must be\n            # the total flow value, and it must be positive.\n            # The DFS starts from 1, so 1 is the root. Any flow that needs to leave 1\n            # will be propagated down. Any flow that needs to enter 1 will be propagated up.\n            # If flow_balance[1] ends up negative, it means 1 has net incoming flow, which violates the condition.\n            # The problem guarantees a solution exists, so this should not happen.\n\n    dfs(1, -1) # Start DFS from source 1, with an invalid parent edge index\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n```\n\nLet's re-trace the first example with this clean DFS:\n`3 3`\n`3 2 10` (edge 0: u=3, v=2, c=10)\n`1 2 10` (edge 1: u=1, v=2, c=10)\n`3 1 5` (edge 2: u=3, v=1, c=5)\n\n`adj`:\n`adj[1]: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]`\n`adj[2]: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]`\n`adj[3]: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]`\n\n`ans = [-1, -1, -1]`\n`flow_balance = [0,0,0,0]`\n`visited = [F,F,F,F]`\n\nCall `dfs(1, -1)`:\n    `visited[1] = True`\n\n    *   Process `(2, 10, 1, 1, 2)` (from `adj[1]`):\n        *   `v=2`, `c=10`, `idx=1`, `original_a=1`, `original_b=2`. `p_edge_idx=-1`.\n        *   `visited[2]` is False. Call `dfs(2, 1)`:\n            `visited[2] = True`\n            *   Process `(3, 10, 0, 3, 2)` (from `adj[2]`):\n                *   `v=3`, `c=10`, `idx=0`, `original_a=3`, `original_b=2`. `p_edge_idx=1`.\n                *   `visited[3]` is False. Call `dfs(3, 0)`:\n                    `visited[3] = True`\n                    *   Process `(2, 10, 0, 3, 2)` (from `adj[3]`): `idx=0 == p_edge_idx`. Skip.\n                    *   Process `(1, 5, 2, 3, 1)` (from `adj[3]`):\n                        *   `v=1`, `c=5`, `idx=2`, `original_a=3`, `original_b=1`. `p_edge_idx=0`.\n                        *   `visited[1]` is True. This is a back-edge. The `if not visited[v]` condition is false. The `else` block (implicit skip) is executed.\n                    `dfs(3,0)` returns. `flow_balance[3]` is 0.\n                Back in `dfs(2,1)`:\n                `flow_balance[3]` is 0 (not positive). So direction is `2 -> 3`.\n                `original_a=3` is not `u=2`. So `ans[0] = 1`. (`original_b=2` is `u`, so `u -> v` means `2 -> 3`).\n                `flow_balance[2] -= 10`. (`flow_balance[2]` is now -10).\n            *   Process `(1, 10, 1, 1, 2)` (from `adj[2]`): `idx=1 == p_edge_idx`. Skip.\n            `dfs(2,1)` returns. `flow_balance[2]` is -10.\n        Back in `dfs(1,-1)`:\n        `flow_balance[2]` is -10 (not positive). So direction is `1 -> 2`.\n        `original_a=1` is `u=1`. So `ans[1] = 0`.\n        `flow_balance[1] -= 10`. (`flow_balance[1]` is now -10).\n\n    *   Process `(3, 5, 2, 3, 1)` (from `adj[1]`):\n        *   `v=3`, `c=5`, `idx=2`, `original_a=3`, `original_b=1`. `p_edge_idx=-1`.\n        *   `visited[3]` is True. This is a back-edge. The `if not visited[v]` condition is false. The `else` block (implicit skip) is executed.\n    `dfs(1,-1)` returns. `flow_balance[1]` is -10.\n\nFinal `ans`: `ans[0]=1`, `ans[1]=0`, `ans[2]=-1`. This is incomplete. `ans[2]` is -1.\n\nThe problem is that back-edges (edges to already visited nodes) are NOT processed by this DFS.\nThe `flow_balance` approach assumes a tree structure or that back-edges are handled separately.\nThe \"very easy\" tag suggests a straightforward graph traversal.\n\nThe crucial constraint: \"vertex with number 1 has no incoming edges\".\nThis means for any edge `(u, 1)` (where `u != 1`), it must be directed `1 -> u`.\nThis implies `flow_balance[u]` should increase by `c`, `flow_balance[1]` should decrease by `c`.\nThis is handled by the `flow_balance[u] += c` line if `v` is `1`.\n\nLet's try a different DFS structure where `flow_balance[u]` is the *total* flow that has been decided to enter `u` minus total flow decided to leave `u`. This is `net_incoming_flow[u]`.\nWe want `net_incoming_flow[u] = 0` for `1 < u < n`.\n`net_incoming_flow[1] = 0`.\n`net_incoming_flow[n] = total_flow`.\n\nThis is equivalent to: `sum(incoming) - sum(outgoing)`.\n`flow_balance[u]` = sum of `c` for edges `x -> u` minus sum of `c` for edges `u -> x`.\n\nLet's try a simpler approach based on the \"no incoming edges for vertex 1\" rule.\nWe can use a queue for a topological sort like process.\nInitialize `flow_deficit[v] = 0` for all `v`.\nFor each edge `(u, v, c)`:\n    If `u == 1`: direct `1 -> v`. `flow_deficit[v] += c`.\n    Else if `v == 1`: direct `1 -> u`. `flow_deficit[u] += c`.\n    Else: store as undirected.\n\nThis is not going to work for general graph connectivity.\nThe problem is very similar to \"Maximum Flow with Demands\" or \"Circulation with Demands\", but simpler.\n\nThe provided solution structure is common for flow-related problems on trees or graphs where a spanning tree is used. The issue is handling back-edges correctly.\nThe fact that `ans[idx]` is still -1 means that the edge `(3,1)` was never directed.\nThe `if not visited[v]` block is for tree edges.\nThe `else` block (for `v` visited) should handle back-edges.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        # Store (neighbor, capacity, original_idx, original_a, original_b)\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n\n    ans = [-1] * m\n    # flow_balance[u] stores the net flow leaving the subtree rooted at u\n    # This value is updated by children and determines direction to parent.\n    flow_balance = [0] * (n + 1)\n    \n    # visited array tracks nodes visited in the current DFS call stack.\n    # It also serves to ensure each edge is processed only once as a tree edge.\n    visited = [False] * (n + 1)\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n\n        for v_neighbor, c, idx, original_a, original_b in adj[u]:\n            if idx == p_edge_idx: # Skip the edge that brought us to u from its parent\n                continue\n            \n            # If the edge has already been directed, skip it.\n            # This handles back-edges that were directed when the ancestor was processed.\n            if ans[idx] != -1:\n                continue\n\n            if not visited[v_neighbor]:\n                # This is a tree edge to an unvisited child. Recurse.\n                dfs(v_neighbor, idx) \n\n                # After dfs(v_neighbor) returns, flow_balance[v_neighbor] contains the net flow from v_neighbor's subtree.\n                # We need to balance this flow using the edge (u, v_neighbor).\n                if flow_balance[v_neighbor] > 0:\n                    # v_neighbor has an excess of flow leaving its subtree. This flow must come into v_neighbor from u.\n                    # So, the edge (u, v_neighbor) must be directed v_neighbor -> u.\n                    if original_a == u: # Original edge was u-v_neighbor, now v_neighbor->u\n                        ans[idx] = 1\n                    else: # Original edge was v_neighbor-u, now v_neighbor->u\n                        ans[idx] = 0\n                    flow_balance[u] += c # Flow c comes into u from v_neighbor\n                else:\n                    # v_neighbor needs flow (or has balanced flow). This flow must go from u to v_neighbor.\n                    # So, the edge (u, v_neighbor) must be directed u -> v_neighbor.\n                    if original_a == u: # Original edge was u-v_neighbor, now u->v_neighbor\n                        ans[idx] = 0\n                    else: # Original edge was v_neighbor-u, now u->v_neighbor\n                        ans[idx] = 1\n                    flow_balance[u] -= c # Flow c leaves u for v_neighbor\n            else:\n                # This is a back-edge to an already visited node (an ancestor or a node in a different branch).\n                # Since the problem guarantees \"vertex 1 has no incoming edges\",\n                # any edge connected to 1 must be directed away from 1.\n                # If v_neighbor is 1, the edge (u, 1) must be directed 1 -> u.\n                # This means flow goes from v_neighbor to u.\n                if v_neighbor == 1:\n                    if original_a == u: # Original edge u-1, now 1->u\n                        ans[idx] = 1\n                    else: # Original edge 1-u, now 1->u\n                        ans[idx] = 0\n                    flow_balance[u] += c # Flow c comes into u from 1\n                else:\n                    # For other back-edges (u, v_neighbor) where v_neighbor is not 1,\n                    # and v_neighbor is already visited, we want to direct it such that\n                    # flow goes from u to v_neighbor. This helps maintain acyclicity\n                    # and pushes flow towards ancestors.\n                    # This means flow goes from u to v_neighbor.\n                    if original_a == u: # Original edge u-v_neighbor, now u->v_neighbor\n                        ans[idx] = 0\n                    else: # Original edge v_neighbor-u, now u->v_neighbor\n                        ans[idx] = 1\n                    flow_balance[u] -= c # Flow c leaves u for v_neighbor\n\n\n    dfs(1, -1) # Start DFS from source 1, with an invalid parent edge index\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```\nLet's re-trace the first example with this final DFS logic:\n`3 3`\n`3 2 10` (edge 0: u=3, v=2, c=10)\n`1 2 10` (edge 1: u=1, v=2, c=10)\n`3 1 5` (edge 2: u=3, v=1, c=5)\n\n`ans = [-1, -1, -1]`\n`flow_balance = [0,0,0,0]`\n`visited = [F,F,F,F]`\n\nCall `dfs(1, -1)`:\n    `visited[1] = True`\n\n    *   Process `(2, 10, 1, 1, 2)` (from `adj[1]`):\n        *   `v_neighbor=2`, `c=10`, `idx=1`, `original_a=1`, `original_b=2`. `p_edge_idx=-1`. `ans[1]` is -1.\n        *   `visited[2]` is False. Call `dfs(2, 1)`:\n            `visited[2] = True`\n            *   Process `(3, 10, 0, 3, 2)` (from `adj[2]`):\n                *   `v_neighbor=3`, `c=10`, `idx=0`, `original_a=3`, `original_b=2`. `p_edge_idx=1`. `ans[0]` is -1.\n                *   `visited[3]` is False. Call `dfs(3, 0)`:\n                    `visited[3] = True`\n                    *   Process `(2, 10, 0, 3, 2)` (from `adj[3]`): `idx=0 == p_edge_idx`. Skip.\n                    *   Process `(1, 5, 2, 3, 1)` (from `adj[3]`):\n                        *   `v_neighbor=1`, `c=5`, `idx=2`, `original_a=3`, `original_b=1`. `p_edge_idx=0`. `ans[2]` is -1.\n                        *   `visited[1]` is True. This is a back-edge.\n                        *   `v_neighbor == 1` is True.\n                        *   `original_a=3` is `u=3`. So `ans[2] = 1` (meaning `1 -> 3`).\n                        *   `flow_balance[3] += 5`. (`flow_balance[3]` is now 5).\n                    `dfs(3,0)` returns. `flow_balance[3]` is 5.\n                Back in `dfs(2,1)`:\n                `flow_balance[3]` is 5 (positive). So direction is `3 -> 2`.\n                `original_a=3` is not `u=2`. So `ans[0] = 0`. (`original_b=2` is `u`, so `v_neighbor -> u` means `3 -> 2`).\n                `flow_balance[2] += 10`. (`flow_balance[2]` is now 10).\n            *   Process `(1, 10, 1, 1, 2)` (from `adj[2]`): `idx=1 == p_edge_idx`. Skip.\n            `dfs(2,1)` returns. `flow_balance[2]` is 10.\n        Back in `dfs(1,-1)`:\n        `flow_balance[2]` is 10 (positive). So direction is `2 -> 1`.\n        `original_a=1` is `u=1`. So `ans[1] = 1`. (`original_b=2` is `v_neighbor`, so `v_neighbor -> u` means `2 -> 1`).\n        `flow_balance[1] += 10`. (`flow_balance[1]` is now 10).\n\n    *   Process `(3, 5, 2, 3, 1)` (from `adj[1]`):\n        *   `v_neighbor=3`, `c=5`, `idx=2`, `original_a=3`, `original_b=1`. `p_edge_idx=-1`.\n        *   `ans[2]` is now 1 (from previous step `dfs(3)`). So `continue`.\n    `dfs(1,-1)` returns. `flow_balance[1]` is 10.\n\nFinal `ans`:\n`ans[0] = 0` (original `3-2`, now `3 -> 2`)\n`ans[1] = 1` (original `1-2`, now `2 -> 1`)\n`ans[2] = 1` (original `3-1`, now `1 -> 3`)\n\nThis is `0 1 1`. The example output is `1 0 1`. Still not matching.\nMy `flow_balance` interpretation is consistent, but my `ans` mapping might be off.\n`ans[idx] = 0` if `ai -> bi`. `ans[idx] = 1` if `bi -> ai`.\nEdge 0: `(3,2,10)`. My code `ans[0]=0` -> `3 -> 2`. Example `ans[0]=1` -> `2 -> 3`.\nEdge 1: `(1,2,10)`. My code `ans[1]=1` -> `2 -> 1`. Example `ans[1]=0` -> `1 -> 2`.\nEdge 2: `(3,1,5)`. My code `ans[2]=1` -> `1 -> 3`. Example `ans[2]=1` -> `1 -> 3`. (Matches!)\n\nThe core logic of `flow_balance` is correct for flow conservation and acyclicity. The discrepancy lies in how `ans[idx]` is set.\nLet's fix the `ans` setting based on the example output.\n\nExample output:\n`ans[0]=1`: edge `3-2` becomes `2 -> 3`.\n`ans[1]=0`: edge `1-2` becomes `1 -> 2`.\n`ans[2]=1`: edge `3-1` becomes `1 -> 3`.\n\nThis implies:\n`flow_balance[1]` (net outgoing) = `10 + 5 = 15`.\n`flow_balance[2]` (net outgoing) = `-10 + 10 = 0`.\n`flow_balance[3]` (net outgoing) = `-10 - 5 = -15`.\n\nMy current `flow_balance` calculation:\n`flow_balance[3]` was 5.\n`flow_balance[2]` was 10.\n`flow_balance[1]` was 10.\n\nThe `flow_balance[u] += c` or `-= c` part is correct for `u`'s flow.\nThe problem is the `if flow_balance[v_neighbor] > 0` condition.\nIf `flow_balance[v_neighbor]` is positive, it means `v_neighbor` has an excess of flow from its children.\nThis excess must go *up* to `u`. So `v_neighbor -> u`.\nIf `flow_balance[v_neighbor]` is zero or negative, it means `v_neighbor` needs flow to come *into* it from `u`. So `u -> v_neighbor`.\n\nLet's apply this to the example output's flow directions and see what `flow_balance` values would be.\n`flow_balance[u]` is net flow *out* of `u`.\n`dfs(3,0)`:\n  `ans[2]=1` (`1 -> 3`). Flow `c=5` goes `1 -> 3`. This means `flow_balance[3]` should be `-5` (flow into 3).\n  `flow_balance[3]` should be `-5` after `dfs(3)` returns.\n`dfs(2,1)`:\n  `v_neighbor=3`, `c=10`, `idx=0`. `flow_balance[3]` is -5.\n  `flow_balance[3]` is not positive. So `2 -> 3`.\n  `ans[0]=1` (original `3-2`, now `2->3`).\n  `flow_balance[2] -= 10`. (`flow_balance[2]` is -10).\n`dfs(1,-1)`:\n  `v_neighbor=2`, `c=10`, `idx=1`. `flow_balance[2]` is -10.\n  `flow_balance[2]` is not positive. So `1 -> 2`.\n  `ans[1]=0` (original `1-2`, now `1->2`).\n  `flow_balance[1] -= 10`. (`flow_balance[1]` is -10).\n\nThis results in `flow_balance[1] = -10`, `flow_balance[2] = -10`, `flow_balance[3] = -5`.\nThis is also incorrect. `flow_balance[1]` must be positive.\n\nThe `flow_balance` should accumulate the total flow *leaving* the subtree.\nIf `flow_balance[v]` is positive, it means `v`'s subtree produces `flow_balance[v]` net flow. This flow must be sent to `u`. So `v -> u`.\nIf `flow_balance[v]` is non-positive, it means `v`'s subtree consumes `|flow_balance[v]|` net flow. This flow must be sent from `u` to `v`. So `u -> v`.\n\nLet's reconsider the condition `vertex with number 1 has no incoming edges`.\nThis implies that `flow_balance[1]` must be `sum(outgoing flows from 1)`.\nThe total flow value is `sum(c)` for edges `1->x`.\nThe `dfs(u, p_idx)` processes edges to children. It ensures flow conservation for `u` with its children.\nThe flow that `u` needs to pass to `p` (its parent) is `flow_balance[u]`.\n\nThe example output `1 0 1` is:\n`ans[0]=1` (`3-2` becomes `2->3`)\n`ans[1]=0` (`1-2` becomes `1->2`)\n`ans[2]=1` (`3-1` becomes `1->3`)\n\nLet's assume this is the *correct* flow.\n`flow_balance[1]` (net outgoing): `c(1->2) + c(1->3) = 10 + 5 = 15`.\n`flow_balance[2]` (net outgoing): `c(2->3) - c(1->2) = 10 - 10 = 0`.\n`flow_balance[3]` (net outgoing): `-c(2->3) - c(1->3) = -10 - 5 = -15`.\n\nThe `dfs` should produce these `flow_balance` values.\nMy `dfs` currently calculates `flow_balance[u]` as net flow *out* of `u` through its children in the DFS tree.\nLet's trace again, carefully.\n\n`dfs(1, -1)`:\n    `visited[1] = True`\n    `flow_balance[1] = 0` (initially)\n\n    1. Process `(2, 10, 1, 1, 2)` (edge `1-2`, `idx=1`):\n        `v=2`, `c=10`. `visited[2]` is False.\n        Call `dfs(2, 1)`:\n            `visited[2] = True`\n            `flow_balance[2] = 0` (initially)\n\n            1.1. Process `(3, 10, 0, 3, 2)` (edge `3-2`, `idx=0`):\n                `v=3`, `c=10`. `visited[3]` is False.\n                Call `dfs(3, 0)`:\n                    `visited[3] = True`\n                    `flow_balance[3] = 0` (initially)\n                    \n                    1.1.1. Process `(2, 10, 0, 3, 2)` (edge `3-2`, `idx=0`): `idx == p_edge_idx`. Skip.\n                    1.1.2. Process `(1, 5, 2, 3, 1)` (edge `3-1`, `idx=2`):\n                        `v=1`, `c=5`. `ans[2]` is -1. `visited[1]` is True. This is a back-edge.\n                        `v == 1` is True.\n                        Direct `1 -> 3`.\n                        `original_a=3`, `u=3`. `ans[2] = 1`. (original `3-1`, now `1->3`).\n                        `flow_balance[3] += c` (flow `1->3` means flow into `3` is `c`, so `flow_balance[3]` is `+c` if it's net incoming, but it's net outgoing, so `-c`).\n                        My `flow_balance[u] += c` means flow `v -> u`. So `flow_balance[3] += 5`.\n                        This is the source of error! If `ans[idx]=1` means `b_i -> a_i`, and `original_a=u`, then `b_i` is `v`. So `v -> u`. This is flow *into* `u`. So `flow_balance[u] -= c`.\n                        Let's fix the `flow_balance` updates.\n\nCorrected `flow_balance` updates:\n`flow_balance[u]` is net flow *out* of `u` through its children.\nIf `v_neighbor -> u`: flow *enters* `u`. So `flow_balance[u] -= c`.\nIf `u -> v_neighbor`: flow *leaves* `u`. So `flow_balance[u] += c`.\n\nCorrected DFS for `flow_balance` update:\n```python\n            if not visited[v_neighbor]:\n                dfs(v_neighbor, idx) \n                if flow_balance[v_neighbor] > 0: # v_neighbor has excess, flow v_neighbor -> u\n                    if original_a == u: ans[idx] = 1 # u-v_neighbor becomes v_neighbor->u\n                    else: ans[idx] = 0 # v_neighbor-u becomes v_neighbor->u\n                    flow_balance[u] -= c # Flow enters u\n                else: # v_neighbor needs flow, flow u -> v_neighbor\n                    if original_a == u: ans[idx] = 0 # u-v_neighbor becomes u->v_neighbor\n                    else: ans[idx] = 1 # v_neighbor-u becomes u->v_neighbor\n                    flow_balance[u] += c # Flow leaves u\n            else: # Back-edge\n                if v_neighbor == 1: # Edge (u,1), must be 1 -> u\n                    if original_a == u: ans[idx] = 1 # u-1 becomes 1->u\n                    else: ans[idx] = 0 # 1-u becomes 1->u\n                    flow_balance[u] -= c # Flow enters u\n                else: # Back-edge (u, v_neighbor) where v_neighbor is not 1. Direct u -> v_neighbor.\n                    if original_a == u: ans[idx] = 0 # u-v_neighbor becomes u->v_neighbor\n                    else: ans[idx] = 1 # v_neighbor-u becomes u->v_neighbor\n                    flow_balance[u] += c # Flow leaves u\n```\n\nLet's re-trace with the *final* corrected `flow_balance` update logic.\n`dfs(1, -1)`:\n    `visited[1] = True`, `flow_balance = [0,0,0,0]`\n\n    1. Process `(2, 10, 1, 1, 2)` (edge `1-2`, `idx=1`):\n        `v=2`, `c=10`. `visited[2]` is False.\n        Call `dfs(2, 1)`:\n            `visited[2] = True`, `flow_balance[2]=0`\n\n            1.1. Process `(3, 10, 0, 3, 2)` (edge `3-2`, `idx=0`):\n                `v=3`, `c=10`. `visited[3]` is False.\n                Call `dfs(3, 0)`:\n                    `visited[3] = True`, `flow_balance[3]=0`\n                    \n                    1.1.1. Process `(2, 10, 0, 3, 2)` (edge `3-2`, `idx=0`): `idx == p_edge_idx`. Skip.\n                    1.1.2. Process `(1, 5, 2, 3, 1)` (edge `3-1`, `idx=2`):\n                        `v_neighbor=1`, `c=5`. `ans[2]` is -1. `visited[1]` is True. Back-edge.\n                        `v_neighbor == 1` is True.\n                        `original_a=3` is `u=3`. `ans[2] = 1` (original `3-1`, now `1->3`).\n                        `flow_balance[3] -= 5`. (`flow_balance[3]` is now -5).\n                    `dfs(3,0)` returns. `flow_balance[3]` is -5.\n                Back in `dfs(2,1)`:\n                `flow_balance[3]` is -5 (not positive). So `u -> v_neighbor` (`2 -> 3`).\n                `original_a=3` is not `u=2`. So `ans[0] = 1` (original `3-2`, now `2->3`).\n                `flow_balance[2] += 10`. (`flow_balance[2]` is now 10).\n            1.2. Process `(1, 10, 1, 1, 2)` (edge `1-2`, `idx=1`): `idx == p_edge_idx`. Skip.\n            `dfs(2,1)` returns. `flow_balance[2]` is 10.\n        Back in `dfs(1,-1)`:\n        `flow_balance[2]` is 10 (positive). So `v_neighbor -> u` (`2 -> 1`).\n        `original_a=1` is `u=1`. So `ans[1] = 1` (original `1-2`, now `2->1`).\n        `flow_balance[1] -= 10`. (`flow_balance[1]` is now -10).\n\n    2. Process `(3, 5, 2, 3, 1)` (edge `3-1`, `idx=2`):\n        `v_neighbor=3`, `c=5`. `ans[2]` is 1 (already set). Skip.\n    `dfs(1,-1)` returns. `flow_balance[1]` is -10.\n\nFinal `ans`: `ans[0]=1`, `ans[1]=1`, `ans[2]=1`. This is `1 1 1`.\nStill not matching the example `1 0 1`.\nThe example output for edge `1-2` is `1 -> 2` (`ans[1]=0`). My code produces `2 -> 1` (`ans[1]=1`).\nThis means `flow_balance[2]` should have been non-positive when `dfs(1)` processed it.\nBut `flow_balance[2]` was 10. Why? Because `flow_balance[3]` was -5 (net incoming to 3).\nThis led to `2 -> 3` (flow leaves 2). So `flow_balance[2]` increased by 10.\n\nThe issue is likely the back-edge handling or the interpretation of `flow_balance`.\nThe problem states \"vertex with number 1 has no incoming edges\". This is the strongest clue.\nAll edges incident to 1 *must* be directed `1 -> x`.\nLet's make this a hard rule.\n\nFinal attempt strategy:\n1.  Initialize `ans = [-1]*m`.\n2.  Initialize `current_flow_out = [0]*(n+1)`. (This will track the net flow *out* of each node, *after* edges are directed).\n3.  Use a queue for a traversal. Add all edges connected to `1` to the queue. For these edges, `1 -> v` is the direction. Update `ans`, `current_flow_out[1] += c`, `current_flow_out[v] -= c`.\n4.  When processing a node `u` from the queue, iterate its neighbors `v`. If edge `(u,v)` is not directed:\n    *   If `v == n`: direct `u -> n`. Update `ans`, `current_flow_out[u] += c`, `current_flow_out[n] -= c`.\n    *   If `current_flow_out[u]` is positive: `u` has excess outgoing flow. This means `u` needs incoming flow from `v`. So `v -> u`. Update `ans`, `current_flow_out[u] -= c`, `current_flow_out[v] += c`.\n    *   If `current_flow_out[u]` is negative: `u` needs outgoing flow. This means `u` must send flow to `v`. So `u -> v`. Update `ans`, `current_flow_out[u] += c`, `current_flow_out[v] -= c`.\n    *   If `current_flow_out[u]` is zero, this is tricky. This means `u` is balanced so far. We can direct `u -> v` by default, and update `current_flow_out`.\n\nThis is basically a topological sort.\nThe problem guarantees a solution exists. The simplest interpretation of \"no cycles\" and \"flow conservation\" is a DAG from source to sink.\nThe `dfs` approach is generally correct for this. The `flow_balance` update logic is critical.\n\nThe current `flow_balance` updates:\n`flow_balance[u] += c` means flow `v -> u`\n`flow_balance[u] -= c` means flow `u -> v`\n\nIf `flow_balance[v_neighbor] > 0`: `v_neighbor` has excess outgoing flow from its subtree. This must go `v_neighbor -> u`.\n    So `flow_balance[u]` should *decrease* by `c`. (Flow enters `u`).\nIf `flow_balance[v_neighbor] <= 0`: `v_neighbor` needs flow. This must go `u -> v_neighbor`.\n    So `flow_balance[u]` should *increase* by `c`. (Flow leaves `u`).\n\nThis is the opposite of what I had. Let's try this.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, u, v)) # (neighbor, capacity, original_idx, original_a, original_b)\n        adj[v].append((u, c, i, u, v))\n\n    ans = [-1] * m\n    # flow_balance[u] stores the net flow leaving the subtree rooted at u\n    # This value is updated by children and determines direction to parent.\n    flow_balance = [0] * (n + 1)\n    \n    visited = [False] * (n + 1)\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n\n        for v_neighbor, c, idx, original_a, original_b in adj[u]:\n            if idx == p_edge_idx: # Skip the edge that brought us to u from its parent\n                continue\n            \n            if ans[idx] != -1: # If the edge has already been directed, skip it.\n                continue\n\n            if not visited[v_neighbor]:\n                # This is a tree edge to an unvisited child. Recurse.\n                dfs(v_neighbor, idx) \n\n                # After dfs(v_neighbor) returns, flow_balance[v_neighbor] contains the net flow from v_neighbor's subtree.\n                # We need to balance this flow using the edge (u, v_neighbor).\n                if flow_balance[v_neighbor] > 0:\n                    # v_neighbor has an excess of flow leaving its subtree. This flow must come into v_neighbor from u.\n                    # So, the edge (u, v_neighbor) must be directed v_neighbor -> u.\n                    if original_a == u: # Original edge was u-v_neighbor, now v_neighbor->u\n                        ans[idx] = 1\n                    else: # Original edge was v_neighbor-u, now v_neighbor->u\n                        ans[idx] = 0\n                    flow_balance[u] -= c # Flow c enters u from v_neighbor (opposite of leaving)\n                else:\n                    # v_neighbor needs flow (or has balanced flow). This flow must go from u to v_neighbor.\n                    # So, the edge (u, v_neighbor) must be directed u -> v_neighbor.\n                    if original_a == u: # Original edge was u-v_neighbor, now u->v_neighbor\n                        ans[idx] = 0\n                    else: # Original edge was v_neighbor-u, now u->v_neighbor\n                        ans[idx] = 1\n                    flow_balance[u] += c # Flow c leaves u for v_neighbor\n            else:\n                # This is a back-edge to an already visited node (an ancestor or a node in a different branch).\n                # The problem guarantees \"vertex 1 has no incoming edges\".\n                # If v_neighbor is 1, the edge (u, 1) must be directed 1 -> u.\n                # This means flow goes from v_neighbor to u.\n                if v_neighbor == 1:\n                    if original_a == u: # Original edge u-1, now 1->u\n                        ans[idx] = 1\n                    else: # Original edge 1-u, now 1->u\n                        ans[idx] = 0\n                    flow_balance[u] -= c # Flow c enters u from 1\n                else:\n                    # For other back-edges (u, v_neighbor) where v_neighbor is not 1,\n                    # and v_neighbor is already visited, we want to direct it such that\n                    # flow goes from u to v_neighbor. This helps maintain acyclicity\n                    # and pushes flow towards ancestors.\n                    # This means flow goes from u to v_neighbor.\n                    if original_a == u: # Original edge u-v_neighbor, now u->v_neighbor\n                        ans[idx] = 0\n                    else: # Original edge v_neighbor-u, now u->v_neighbor\n                        ans[idx] = 1\n                    flow_balance[u] += c # Flow c leaves u for v_neighbor\n\n\n    dfs(1, -1) \n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "",
    "score": -1,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 21681,
        "thoughts_token_count": 761
    }
}