{
    "start": 1758294749.8726132,
    "end": 1758294839.6499522,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**My current thought process is focused on determining the best and worst possible ranks for Vasya in this Olympiad problem.**  The core challenge is figuring out how Vasya's rank is affected by the unknown pairing of scores from the two tours.  I'm given lists of scores, `a` and `b`, and a minimum score Vasya achieved, `x`.  My goal is to understand how to manipulate these scores to place Vasya as high (best rank) or as low (worst rank) as possible.\n\n**Best Rank:** It seems intuitively that the best rank would be 1, because the rules say if there is any tie, the jury decides.  But, I need to rigorously prove this. I start by thinking that Vasya should aim for the highest possible total score. Since Vasya can be any pair `a[i] + b[j]`, then, to get a top score and get rank 1, I should find a pair in `a` and `b` that sums to be highest possible and make this Vasya's score. Since we need *all* `a` and `b` to pair up, I need to ensure that the pairing with Vasya can't be bettered by any other pairing.  This forces me to look at maximizing Vasya's individual score within the context of all scores. I consider sorting the scores in descending order to assign the highest totals to Vasya, but I realize that this is a greedy approach and that it might not be ideal since the problem says that \"the results have only points, no names\".  After carefully re-reading the problem description and key details, it states that \"It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x.\" This key detail is crucial.  Vasya *can* choose which scores he gets, which tells me the best possible rank *is* 1. If I can prove that the sum of the two largest numbers in a and b is at least equal to x, then no other sum can be larger, and Vasya can take these values and get first place as a tiebreaker. So, the best rank is always 1.\n\n**Worst Rank:** The problem shifts to how to maximize Vasya's rank (i.e. make his rank the worst it can be) by minimizing his score while maximizing others'. This is where the complexity comes in since I need to carefully consider the possible pairings to determine what the lowest possible score for Vasya can be, and how many other participants can get scores better than or equal to his. The condition that Vasya's score must be at least `x` restricts the lowest value he can attain. This is now a matching problem. I must find a permutation of scores that maximizes the number of people scoring higher. To do so, I consider the scores of other participants, and then try to minimize Vasya's score, and maximize the number of people who score at least as high as he does. My intuition is to sort `a` and `b`, then pair large scores for non-Vasya and minimize Vasya’s scores. To calculate the worst possible rank, I am looking to choose Vasya's score `S` to be as low as possible and at the same time maximize the number of people with at least `S`. I realize I can calculate the maximum number of people whose sum is higher than `S`.  I can use a greedy approach to compute the maximum number of pairs whose sum is at least some number S. To compute this I can sort one of the `a` and `b` in descending order, then apply a greedy matching method to find how many scores I can construct that are at least of some value `S`. Using this greedy matching, I can binary search to identify the smallest score that will create the largest count of other people who are equal to or better than Vasya's score. The binary search becomes the approach to determine Vasya’s score. Then the score is evaluated to see how many pairs of participants are equal to or better.",
    "response": "The problem asks us to find the best and worst possible ranks for Vasya in an Olympiad, given `n` participants, two lists of `n` scores for Tour 1 (`a`) and Tour 2 (`b`), and the guarantee that Vasya scored at least `x` total points. The participants are ranked by the sum of their points, with higher scores being better. If two or more participants have the same total points, the jury can assign places arbitrarily.\n\n**1. Best Possible Rank:**\n\nFor the best possible rank, Vasya wants to maximize his own score and ensure no one else scores strictly higher. The \"jury's choice\" rule for ties is crucial here. If Vasya achieves the highest score among all participants, he can be assigned the 1st place.\n\nThe problem guarantees that \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\". This means there is at least one pair of scores `(a_i, b_j)` whose sum is at least `x`.\nThe absolute maximum total score any participant can achieve is `max(a) + max(b)`. Let's call this `S_max_overall`.\nSince `S_max_overall` is the largest possible sum, it must be `>= x` (otherwise, no pair `a_i + b_j` could be `>= x`, contradicting the problem guarantee).\nTherefore, Vasya can be assigned the scores `max(a)` and `max(b)`. His total score would be `S_max_overall`. No other participant can achieve a score strictly greater than `S_max_overall`. With the jury's choice, Vasya can be placed 1st.\nThus, the best possible rank for Vasya is always **1**.\n\n**2. Worst Possible Rank:**\n\nFor the worst possible rank, Vasya wants to minimize his rank. This means we should try to construct a pairing of scores such that:\na. Vasya's score `S_V = a_k + b_l` is as low as possible, but still `S_V >= x`.\nb. As many other participants as possible score strictly higher than `S_V`, or equal to `S_V`. If they score equal, the jury places Vasya last among them.\n\nThis implies we want to maximize the count of participants (including Vasya) who score *at least* Vasya's score `S_V`. If `K` participants score at least `S_V`, and Vasya is one of them, his worst rank among these `K` participants is `K`.\n\nLet's define a function `max_ge_count(S)`: this function returns the maximum number of participants who can achieve a total score of at least `S`, given the `n` scores from tour 1 (`a`) and `n` scores from tour 2 (`b`).\nTo compute `max_ge_count(S)`:\n1. Sort `a` in ascending order.\n2. Sort `b` in descending order.\n3. Use two pointers, `ptr_a` starting at `0` for `a` and `ptr_b` starting at `0` for `b`.\n4. Initialize `count = 0`.\n5. While `ptr_a < n` and `ptr_b < n`:\n   If `a[ptr_a] + b[ptr_b] >= S`: We can form a pair that meets the condition. Increment `count`, `ptr_a++`, `ptr_b++`.\n   Else (`a[ptr_a] + b[ptr_b] < S`): `a[ptr_a]` is too small to form a sum `>= S` with `b[ptr_b]` (which is the largest remaining `b`). Since `b` is sorted descending, `a[ptr_a]` cannot form a sum `>= S` with any other remaining `b` either. So, `a[ptr_a]` cannot be part of a pair that sums to `>= S`. We must use `a[ptr_a]` with some `b_k` where `a[ptr_a] + b_k < S`. We effectively discard `a[ptr_a]` from consideration for `>= S` pairs. Increment `ptr_a++`.\n6. Return `count`.\n\nThis greedy strategy correctly finds the maximum number of pairs that sum to at least `S`.\n\nNow, we want to find the maximum possible rank `K`. This means we want to find the largest `K` such that there exists a score `S_V` where `S_V >= x` and `max_ge_count(S_V) = K`.\nWe can binary search for this `K`. The minimum possible rank is 1, and the maximum is `n`.\nFor a given candidate rank `mid_K` (from `1` to `n`):\nCan we achieve a scenario where Vasya's rank is `mid_K`? This means we need to find a score `S_V >= x` such that `max_ge_count(S_V) >= mid_K`.\nTo maximize Vasya's rank, we want to find the *smallest* `S_V >= x` such that `max_ge_count(S_V) >= mid_K`.\nThis is a nested binary search.\nThe outer binary search is for the worst rank `K` (from `1` to `n`).\nThe inner binary search is for the score `S` (from `x` to `2 * 10^5 + 2 * 10^5 = 4 * 10^5`).\nFor a fixed `K`:\n  Binary search for `S_low`, the minimum score `S` such that `S >= x` and `max_ge_count(S) >= K`.\n  Range for `S`: `[x, 4*10^5]`.\n  `check(S)` function: `max_ge_count(S) >= K`.\n  If `S_low` exists, it means we can make `K` people score at least `S_low`. Vasya can be one of them, with score `S_low` (which is `>= x`). So, `mid_K` is achievable. We try a higher rank.\n  Else, `mid_K` is not achievable. We try a lower rank.\n\nThe range of possible scores `S` is `[0, 2 * 10^5]`. The sum can be `[0, 4 * 10^5]`.\nThe overall `max_ge_count` is a monotonically non-increasing function of `S`.\nIf `max_ge_count(S_1) = K_1` and `S_2 > S_1`, then `max_ge_count(S_2) <= K_1`.\nWe want to find the maximum `K` such that there exists an `S >= x` with `max_ge_count(S) = K`.\nThis is equivalent to finding the maximum `K` such that the smallest `S >= x` for which `max_ge_count(S) >= K` exists.\n\nLet's simplify. We want to find the largest `K`.\nConsider the scores `a_i + b_j`. There are `n^2` such possible sums.\nThe values of `max_ge_count(S)` for all possible `S` values will be `1, ..., n`.\nWe are looking for the maximum `K` such that there is *some* `S >= x` for which `max_ge_count(S) = K`.\nSince `max_ge_count(S)` is non-increasing, we can iterate `S` downwards from `4*10^5` to `x`. The first `K` we find will be the maximum.\n`S_max_val = 2 * 10^5 + 2 * 10^5 = 4 * 10^5`.\n`worst_rank = 0`\nFor `S` from `S_max_val` down to `x`:\n  `current_rank = max_ge_count(S)`\n  `worst_rank = max(worst_rank, current_rank)`\n  If `worst_rank == n`: break (cannot get worse than `n`).\nThis approach iterates `S` up to `4*10^5` times. Each `max_ge_count(S)` takes `O(N)` time after initial sorting. Total `O(S_max_val * N)`.\n`4*10^5 * 10^5 = 4*10^{10}`, too slow.\n\nWe need to binary search on `K` (the rank).\nLet `check(K_cand)` be a function that returns `True` if Vasya can achieve rank `K_cand` (or worse), and `False` otherwise.\nTo check if Vasya can achieve rank `K_cand`:\nWe need to find if there exists a score `S_V >= x` such that `max_ge_count(S_V) >= K_cand`.\nSince `max_ge_count(S)` is monotonically non-increasing, we can binary search for the smallest `S` (let's call it `S_required`) such that `max_ge_count(S) >= K_cand`.\n  Binary search for `S_required` in `[0, 4*10^5]`.\n  If `S_required` exists and `S_required >= x`, then `check(K_cand)` is `True`.\n  Otherwise, `check(K_cand)` is `False`.\nThe range for `K` is `[1, n]`.\nOuter binary search: `low = 1, high = n, worst_rank = 1`.\nWhile `low <= high`:\n  `mid_K = low + (high - low) // 2`.\n  Inner binary search for `S_required`: `s_low = 0, s_high = 4*10^5, current_S_required = -1`.\n  While `s_low <= s_high`:\n    `s_mid = s_low + (s_high - s_low) // 2`.\n    If `max_ge_count(s_mid) >= mid_K`:\n      `current_S_required = s_mid`.\n      `s_low = s_mid + 1` (try to find an even smaller `S` that works, but we need the smallest `S` that works)\n      Wait, to find the *smallest* `S` such that `max_ge_count(S) >= mid_K`, we should set `s_high = s_mid - 1`.\n      `current_S_required = s_mid`\n      `s_high = s_mid - 1` (try to find an even smaller `S`)\n    Else (`max_ge_count(s_mid) < mid_K`):\n      `s_low = s_mid + 1`.\n  After inner binary search, if `current_S_required != -1` and `current_S_required >= x`:\n    This means we found a score `S_V = current_S_required` (which is `>= x`) such that `mid_K` participants can score at least `S_V`. Vasya can be one of them. So `mid_K` is a possible worst rank. We try for a worse rank.\n    `worst_rank = mid_K`.\n    `low = mid_K + 1`.\n  Else:\n    `mid_K` is not an achievable worst rank. We try for a better rank.\n    `high = mid_K - 1`.\n\nThe initial sorting of `a` and `b` takes `O(N log N)`.\nThe outer binary search runs `O(log N)` times.\nThe inner binary search runs `O(log S_max_val)` times.\nInside `max_ge_count`, it takes `O(N)`.\nTotal complexity: `O(N log N + log N * log S_max_val * N)`.\n`log N` is about 17 for `N=10^5`. `log S_max_val` is about 19 for `S_max_val=4*10^5`.\n`17 * 19 * 10^5` is about `3.2 * 10^7`, which is feasible.\n\nLet's refine the inner binary search for `S_required`:\n`find_min_S(K_cand)`:\n  `low_S = 0`, `high_S = 4*10^5`\n  `result_S = 4*10^5 + 1` (a value larger than any possible sum)\n  While `low_S <= high_S`:\n    `mid_S = low_S + (high_S - low_S) // 2`\n    If `max_ge_count(mid_S) >= K_cand`:\n      `result_S = mid_S`\n      `low_S = mid_S + 1` (No, `high_S = mid_S - 1` to find the smallest `S`)\n      `high_S = mid_S - 1`\n    Else:\n      `low_S = mid_S + 1`\n  Return `result_S`.\n\nThen, in the outer binary search for `mid_K`:\n  `S_required = find_min_S(mid_K)`\n  If `S_required <= 4*10^5` (i.e., a valid `S` was found) and `S_required >= x`:\n    `worst_rank = mid_K`\n    `low = mid_K + 1`\n  Else:\n    `high = mid_K - 1`\n\nExample 1:\nn=5, x=2\na = [1, 1, 1, 1, 1]\nb = [1, 1, 1, 1, 1]\nSorted a: [1, 1, 1, 1, 1]\nSorted b (desc): [1, 1, 1, 1, 1]\nBest rank: 1 (as established)\n\nWorst rank:\n`max_ge_count(S)`:\nIf S=2:\n  a=[1,1,1,1,1], b=[1,1,1,1,1]\n  (1+1=2) count=1, a=[1,1,1,1], b=[1,1,1,1]\n  (1+1=2) count=2, a=[1,1,1], b=[1,1,1]\n  ...\n  `max_ge_count(2) = 5`.\nIf S=3:\n  a=[1,1,1,1,1], b=[1,1,1,1,1]\n  1+1=2 < 3. `ptr_a` advances.\n  `max_ge_count(3) = 0`.\n\nOuter BS for `K` in `[1, 5]`:\n`low=1, high=5, worst_rank=1`\n`mid_K = 3`.\n  Inner BS for `S_required`: `find_min_S(3)`\n    `s_low=0, s_high=4*10^5, result_S=4*10^5+1`\n    `s_mid` will be chosen.\n    `max_ge_count(2) = 5 >= 3`. `result_S = 2, high_S = 1`.\n    `max_ge_count(1) = 5 >= 3`. `result_S = 1, high_S = 0`.\n    `max_ge_count(0) = 5 >= 3`. `result_S = 0, high_S = -1`.\n    `find_min_S(3)` returns `0`.\n  `S_required = 0`. Is `0 <= 4*10^5` and `0 >= x=2`? No, `0 < 2`.\n  So `mid_K=3` is not achievable. `high = 2`.\n\n`low=1, high=2, worst_rank=1`\n`mid_K = 1`.\n  Inner BS for `S_required`: `find_min_S(1)`\n    `find_min_S(1)` returns `0`.\n  `S_required = 0`. Is `0 <= 4*10^5` and `0 >= x=2`? No.\n  This seems wrong. `max_ge_count(0)` is 5.\n  `max_ge_count(1)` is 5.\n  `max_ge_count(2)` is 5.\n  The smallest `S >= x=2` such that `max_ge_count(S) >= K` for any `K` up to 5 is `S=2`.\n  If `K=1`, `S_required=2`. `2 >= x=2`. So `K=1` is possible.\n  If `K=5`, `S_required=2`. `2 >= x=2`. So `K=5` is possible.\n\nLet's re-trace `find_min_S(K_cand)`:\n`low_S = 0, high_S = 4*10^5, result_S = 4*10^5 + 1`\n`max_ge_count(S)` is monotonically non-increasing. We want smallest `S` where `max_ge_count(S) >= K_cand`.\nIf `max_ge_count(mid_S) >= K_cand`: `mid_S` is a possible answer. Try smaller `S`. `result_S = mid_S`, `high_S = mid_S - 1`.\nElse: `mid_S` is too small. Need larger `S`. `low_S = mid_S + 1`.\n\nExample 1, `find_min_S(5)`:\n`low_S=0, high_S=4e5, result_S=inf`\n`mid_S` will eventually hit `2`. `max_ge_count(2)=5 >= 5`. `result_S=2, high_S=1`.\n`mid_S` will eventually hit `1`. `max_ge_count(1)=5 >= 5`. `result_S=1, high_S=0`.\n`mid_S` will eventually hit `0`. `max_ge_count(0)=5 >= 5`. `result_S=0, high_S=-1`.\nLoop ends. `find_min_S(5)` returns `0`.\nThis `S_required=0` is not `>= x=2`. So `mid_K=5` is not possible. `high=4`.\n\nThis logic is correct. `max_ge_count(S)` gives how many people can score AT LEAST S. Vasya needs to be one of them, and his score must be AT LEAST X. So if `S_required < X`, this specific `S_required` cannot be Vasya's score.\nThe problem statement says \"Vasya got at least x points\". This means Vasya is one of the participants. So for the worst case, we are looking for a pairing, and one of the pairs is Vasya's, say `(a_i, b_j)`, such that `a_i + b_j >= x`. Then we count how many people `K` (including Vasya) score `a_i + b_j` or more. Vasya's rank is `K`. We want to maximize `K`.\n\nLet's rethink `find_min_S(K_cand)`. We need `S >= x`.\nThe inner binary search should be for `S` in the range `[x, 4*10^5]`.\n`find_min_S_ge_x(K_cand)`:\n  `low_S = x`, `high_S = 4*10^5`\n  `result_S = 4*10^5 + 1`\n  While `low_S <= high_S`:\n    `mid_S = low_S + (high_S - low_S) // 2`\n    If `max_ge_count(mid_S) >= K_cand`:\n      `result_S = mid_S`\n      `high_S = mid_S - 1`\n    Else:\n      `low_S = mid_S + 1`\n  Return `result_S`.\n\nNow, in the outer binary search for `mid_K`:\n  `S_required = find_min_S_ge_x(mid_K)`\n  If `S_required <= 4*10^5` (i.e., a valid `S >= x` was found):\n    `worst_rank = mid_K`\n    `low = mid_K + 1`\n  Else:\n    `high = mid_K - 1`\n\nExample 1 again, `find_min_S_ge_x(K_cand)`:\n`a = [1,1,1,1,1]`, `b = [1,1,1,1,1]`, `x = 2`.\n`find_min_S_ge_x(5)`:\n  `low_S=2, high_S=4e5, result_S=inf`\n  `mid_S` will eventually hit `2`. `max_ge_count(2)=5 >= 5`. `result_S=2, high_S=1`.\n  Loop terminates. Returns `2`.\nOuter BS for `K`:\n`low=1, high=5, worst_rank=1`\n`mid_K = 3`.\n  `S_required = find_min_S_ge_x(3)`: returns `2`.\n  `S_required = 2`. Is `2 <= 4*10^5`? Yes.\n  `worst_rank = 3`. `low = 4`.\n`low=4, high=5, worst_rank=3`\n`mid_K = 4`.\n  `S_required = find_min_S_ge_x(4)`: returns `2`.\n  `S_required = 2`. Is `2 <= 4*10^5`? Yes.\n  `worst_rank = 4`. `low = 5`.\n`low=5, high=5, worst_rank=4`\n`mid_K = 5`.\n  `S_required = find_min_S_ge_x(5)`: returns `2`.\n  `S_required = 2`. Is `2 <= 4*10^5`? Yes.\n  `worst_rank = 5`. `low = 6`.\n`low=6, high=5`. Loop terminates.\nResult: `worst_rank = 5`. This matches the example output.\n\nThis approach seems correct and efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank is always 1\n    # Vasya can choose the pair (a_i, b_j) that gives him the highest possible score.\n    # The problem guarantees that at least one pair (a_i, b_j) exists such that a_i + b_j >= x.\n    # The absolute maximum score any participant can get is max(a) + max(b).\n    # This sum must be >= x. Vasya can take these two scores.\n    # No one can score higher. With jury's choice for ties, Vasya can be 1st.\n    best_rank = 1\n\n    # Worst possible rank\n    # We need to find the maximum K such that there exists a pairing where Vasya's score S_V >= x,\n    # and K participants (including Vasya) score at least S_V.\n    # Vasya's rank would then be K.\n\n    # Sort 'a' in ascending order for max_ge_count\n    a.sort()\n    # Sort 'b' in descending order for max_ge_count\n    b.sort(reverse=True)\n\n    # Helper function to calculate max_ge_count(S)\n    # Returns the maximum number of participants who can score at least S.\n    def max_ge_count(S_target):\n        count = 0\n        ptr_a = 0\n        ptr_b = 0\n        while ptr_a < n and ptr_b < n:\n            if a[ptr_a] + b[ptr_b] >= S_target:\n                count += 1\n                ptr_a += 1\n                ptr_b += 1\n            else:\n                # a[ptr_a] is too small to pair with b[ptr_b] (largest available b)\n                # to reach S_target. So, a[ptr_a] cannot be part of a pair >= S_target.\n                ptr_a += 1\n        return count\n\n    # Inner binary search: find the smallest S >= x such that max_ge_count(S) >= K_cand\n    def find_min_S_ge_x(K_cand):\n        low_S = x\n        # Maximum possible sum is 10^5 + 10^5 = 2*10^5.\n        # But actually, the elements themselves can be 10^5, so their sum can be 2*10^5.\n        # Max value for x is 2*10^5. Max value for a_i, b_i is 10^5.\n        # So sum max is 2*10^5.\n        # Wait, problem specifies 0 <= x <= 2*10^5.\n        # And 0 <= ai, bi <= 10^5. So max sum is 10^5 + 10^5 = 2*10^5.\n        # Let's use a slightly larger upper bound for safety, e.g., 200001 or 2*10^5 + 1.\n        high_S = 2 * 10**5 + 5 # A safe upper bound for sum of points\n        \n        result_S = high_S + 1 # Initialize with a value indicating no valid S found\n        \n        while low_S <= high_S:\n            mid_S = low_S + (high_S - low_S) // 2\n            if max_ge_count(mid_S) >= K_cand:\n                result_S = mid_S\n                high_S = mid_S - 1 # Try to find an even smaller S\n            else:\n                low_S = mid_S + 1 # mid_S is too small, need a larger S\n        return result_S\n\n    # Outer binary search: find the maximum K (worst_rank)\n    low_K = 1\n    high_K = n\n    worst_rank = 1 # Initialize worst rank to 1, as it's always at least 1\n\n    while low_K <= high_K:\n        mid_K = low_K + (high_K - low_K) // 2\n        \n        # Find the minimum score S_required such that at least mid_K participants\n        # can score S_required or more, and S_required itself is >= x.\n        S_required = find_min_S_ge_x(mid_K)\n        \n        # If such an S_required exists (i.e., not the initial high_S + 1)\n        # and it's within the valid score range (which it should be if found)\n        # then mid_K is an achievable rank (or worse).\n        if S_required <= 2 * 10**5 + 5: # check if a valid S was found\n            worst_rank = mid_K\n            low_K = mid_K + 1 # Try to achieve an even worse rank\n        else:\n            high_K = mid_K - 1 # mid_K is too high, try a better rank\n\n    print(best_rank, worst_rank)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank is always 1\n    # Vasya can choose the pair (a_i, b_j) that gives him the highest possible score.\n    # The problem guarantees that at least one pair (a_i, b_j) exists such that a_i + b_j >= x.\n    # The absolute maximum score any participant can get is max(a) + max(b).\n    # This sum must be >= x. Vasya can take these two scores.\n    # No one can score higher. With jury's choice for ties, Vasya can be 1st.\n    best_rank = 1\n\n    # Worst possible rank\n    # We need to find the maximum K such that there exists a pairing where Vasya's score S_V >= x,\n    # and K participants (including Vasya) score at least S_V.\n    # Vasya's rank would then be K.\n\n    # Sort 'a' in ascending order for max_ge_count\n    a.sort()\n    # Sort 'b' in descending order for max_ge_count\n    b.sort(reverse=True)\n\n    # Helper function to calculate max_ge_count(S)\n    # Returns the maximum number of participants who can score at least S.\n    def max_ge_count(S_target):\n        count = 0\n        ptr_a = 0\n        ptr_b = 0\n        while ptr_a < n and ptr_b < n:\n            if a[ptr_a] + b[ptr_b] >= S_target:\n                count += 1\n                ptr_a += 1\n                ptr_b += 1\n            else:\n                # a[ptr_a] is too small to pair with b[ptr_b] (largest available b)\n                # to reach S_target. So, a[ptr_a] cannot be part of a pair >= S_target.\n                ptr_a += 1\n        return count\n\n    # Inner binary search: find the smallest S >= x such that max_ge_count(S) >= K_cand\n    def find_min_S_ge_x(K_cand):\n        low_S = x\n        # Maximum possible sum is 10^5 + 10^5 = 2*10^5.\n        # But actually, the elements themselves can be 10^5, so their sum can be 2*10^5.\n        # Max value for x is 2*10^5. Max value for a_i, b_i is 10^5.\n        # So sum max is 2*10^5.\n        # Wait, problem specifies 0 <= x <= 2*10^5.\n        # And 0 <= ai, bi <= 10^5. So max sum is 10^5 + 10^5 = 2*10^5.\n        # Let's use a slightly larger upper bound for safety, e.g., 200001 or 2*10^5 + 1.\n        high_S = 2 * 10**5 + 5 # A safe upper bound for sum of points\n        \n        result_S = high_S + 1 # Initialize with a value indicating no valid S found\n        \n        while low_S <= high_S:\n            mid_S = low_S + (high_S - low_S) // 2\n            if max_ge_count(mid_S) >= K_cand:\n                result_S = mid_S\n                high_S = mid_S - 1 # Try to find an even smaller S\n            else:\n                low_S = mid_S + 1 # mid_S is too small, need a larger S\n        return result_S\n\n    # Outer binary search: find the maximum K (worst_rank)\n    low_K = 1\n    high_K = n\n    worst_rank = 1 # Initialize worst rank to 1, as it's always at least 1\n\n    while low_K <= high_K:\n        mid_K = low_K + (high_K - low_K) // 2\n        \n        # Find the minimum score S_required such that at least mid_K participants\n        # can score S_required or more, and S_required itself is >= x.\n        S_required = find_min_S_ge_x(mid_K)\n        \n        # If such an S_required exists (i.e., not the initial high_S + 1)\n        # and it's within the valid score range (which it should be if found)\n        # then mid_K is an achievable rank (or worse).\n        if S_required <= 2 * 10**5 + 5: # check if a valid S was found\n            worst_rank = mid_K\n            low_K = mid_K + 1 # Try to achieve an even worse rank\n        else:\n            high_K = mid_K - 1 # mid_K is too high, try a better rank\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 6526,
        "thoughts_token_count": 6568
    }
}