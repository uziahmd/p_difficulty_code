{
    "start": 1758284937.7210426,
    "end": 1758284964.737455,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Solving the Mushroom Strife Problem with Python**\n\nOkay, I've got the \"Mushroom Strife\" problem laid out in front of me.  Essentially, it's a graph problem where the nodes are lawns and the edges are roads. Each road provides us with the GCD and LCM of the mushroom counts on the connected lawns. My goal is to determine the mushroom count for each lawn, or signal that it's impossible.  The mushroom counts have to fall between 1 and 10^6.\n\nFirst, I need to really understand the relationship between GCD and LCM. I know that `GCD(a, b) * LCM(a, b) = a * b`.  So, if `g` is the GCD and `l` is the LCM, then `a * b = g * l`. Crucially,  `a` and `b` must both be multiples of `g`.  Let's say `a = g * x` and `b = g * y`. Since `g` is the greatest common divisor,  `x` and `y` must be coprime (their GCD is 1). Substituting, I get  `g * x * y = l`, which simplifies to  `x * y = l / g`.\n\nFor an edge connecting lawns `u` and `v`, with GCD `g` and LCM `l`, I'm looking for  `m_u` and `m_v` (the mushroom counts) such that:\n\n1.  `m_u * m_v = g * l`\n2.  `GCD(m_u, m_v) = g`\n3.  `LCM(m_u, m_v) = l`\n\nBased on this, it's crucial that `l` is divisible by `g`; if it's not, there's no solution. So, first check if `l % g == 0`. If it does, let's call `P = l / g`. Now, I need to find two co-prime factors, `x` and `y`, of `P`. If I find these, then `m_u = g * x` and `m_v = g * y`.\n\nThe constraints are manageable:  `n` and `m` are up to 1000, and GCD and LCM are up to 10^6.  Mushroom counts must be between 1 and 10^6, so that's helpful as well.\n\nThinking about the overall strategy, this seems like it could involve a search, potentially.  We're assigning values to nodes based on edge constraints, and we need to make sure the values are consistent across the graph. Since the maximum count is 10^6, trying all possible counts for each lawn isn't feasible. I need to use the GCD and LCM properties to narrow down the search space. I might need to consider graph algorithms to propagate the constraints. I think I'll start by writing down the math, and try to build the logic step by step.\n",
    "response": "The problem asks us to assign a number of mushrooms (an integer between 1 and 10^6) to each of `n` lawns, given `m` roads. For each road connecting two lawns, we are given the GCD and LCM of the mushroom counts on those lawns. We need to find any valid assignment or report that none exists.\n\n**Key Properties of GCD and LCM:**\nFor two positive integers `a` and `b`, let `g = GCD(a, b)` and `l = LCM(a, b)`.\nWe know that `a * b = g * l`.\nAlso, `a` must be a multiple of `g`, and `b` must be a multiple of `g`.\nWe can write `a = g * x` and `b = g * y` for some integers `x` and `y`.\nSince `g` is the *greatest* common divisor, `GCD(x, y) = 1`.\nSubstituting these into `a * b = g * l`:\n`(g * x) * (g * y) = g * l`\n`g^2 * x * y = g * l`\n`g * x * y = l`\n`x * y = l / g`\n\nFrom this, we can deduce some initial constraints:\n1. `l` must be divisible by `g`. If `l % g != 0` for any edge, no solution exists.\n2. Let `P = l / g`. We need to find two factors `x` and `y` of `P` such that `GCD(x, y) = 1`. Then the mushroom counts for the two lawns connected by this edge will be `g * x` and `g * y`.\n\n**Algorithm:**\n\n1.  **Preprocessing and Initial Checks:**\n    *   Initialize an array `ans` of size `n+1` to store the mushroom counts, initially all 0.\n    *   Initialize an adjacency list `adj` where `adj[u]` stores a list of tuples `(v, g, l)` for each edge `(u, v)` with GCD `g` and LCM `l`.\n    *   For each edge `(u, v, g, l)`:\n        *   If `l % g != 0`, it's impossible. Print \"NO\" and exit.\n        *   Add `(v, g, l)` to `adj[u]` and `(u, g, l)` to `adj[v]`.\n\n2.  **Iterate through Components (BFS/DFS):**\n    *   The graph might be disconnected. We need to process each connected component independently.\n    *   Maintain a `visited` array to keep track of processed lawns.\n    *   For each lawn `i` from 1 to `n`:\n        *   If `i` has not been visited:\n            *   Start a Breadth-First Search (BFS) or Depth-First Search (DFS) from `i`.\n            *   **Initial Assignment:** During the first visit to a lawn `u` in a component, we don't know its value yet. A simple strategy is to assign `ans[u] = 1` (since 1 is a valid mushroom count and `GCD(1, X) = 1`, `LCM(1, X) = X`). This initial guess will be propagated and refined. If `u` has no edges, `ans[u]` remains 1.\n            *   **Queue for BFS:** Add `u` to a queue. Mark `u` as visited.\n            *   **BFS Loop:** While the queue is not empty:\n                *   Dequeue `curr_u`.\n                *   For each neighbor `(curr_v, g, l)` of `curr_u`:\n                    *   Let `m_u = ans[curr_u]`.\n                    *   We need to find `m_v` such that `GCD(m_u, m_v) = g` and `LCM(m_u, m_v) = l`.\n                    *   From `m_u * m_v = g * l`, we get `m_v = (g * l) / m_u`.\n                    *   **Validation:**\n                        *   Check if `(g * l)` is divisible by `m_u`. If not, or if `(g * l) / m_u` is not an integer, it's impossible. Print \"NO\" and exit.\n                        *   Let `candidate_m_v = (g * l) // m_u`.\n                        *   Check if `1 <= candidate_m_v <= 10^6`. If not, print \"NO\" and exit.\n                        *   Check if `GCD(m_u, candidate_m_v) == g` and `LCM(m_u, candidate_m_v) == l`. If not, print \"NO\" and exit. (Note: The `GCD` check is crucial. The `LCM` check is redundant if `GCD(m_u, candidate_m_v) == g` and `m_u * candidate_m_v == g * l` are both true, because `LCM(a,b) = (a*b)/GCD(a,b)`).\n                    *   **Assignment and Enqueue:**\n                        *   If `ans[curr_v]` is 0 (meaning `curr_v` hasn't been assigned a value yet in this component):\n                            *   Assign `ans[curr_v] = candidate_m_v`.\n                            *   Enqueue `curr_v`.\n                            *   Mark `curr_v` as visited.\n                        *   If `ans[curr_v]` is not 0 (meaning `curr_v` has already been assigned a value):\n                            *   Verify that `ans[curr_v] == candidate_m_v`. If not, it's a contradiction, print \"NO\" and exit.\n\n3.  **Output:**\n    *   If the algorithm completes without printing \"NO\", it means a consistent assignment has been found. Print \"YES\" on the first line.\n    *   Print the `n` mushroom counts `ans[1]` through `ans[n]` on the second line, separated by spaces.\n\n**Example Walkthrough (2 1, 1 2 1 3):**\n*   `n=2, m=1`. Edge `(1, 2, g=1, l=3)`.\n*   `ans = [0, 0, 0]`, `visited = [F, F, F]`.\n*   Process `i=1`: `visited[1]` is `F`.\n    *   Start BFS from 1. `ans[1] = 1`. `q = [1]`. `visited[1] = T`.\n    *   Dequeue `curr_u = 1`.\n    *   Neighbor `(curr_v=2, g=1, l=3)`:\n        *   `m_u = ans[1] = 1`.\n        *   `candidate_m_v = (g * l) // m_u = (1 * 3) // 1 = 3`.\n        *   `1 <= 3 <= 10^6` (OK).\n        *   `GCD(1, 3) = 1` (matches `g`).\n        *   `ans[2]` is 0. Assign `ans[2] = 3`. Enqueue 2. `visited[2] = T`.\n    *   Dequeue `curr_u = 2`.\n    *   No unvisited neighbors of 2.\n    *   Queue empty. BFS finishes.\n*   Process `i=2`: `visited[2]` is `T`. Skip.\n*   All lawns processed. Print \"YES\", then `1 3`.\n\n**GCD Function:**\nPython's `math.gcd` can be used.\n\n**Edge Cases:**\n*   `m=0`: All `ans[i]` remain 1. Print \"YES\", then `1 1 ... 1`.\n*   Disconnected graph: Handled by iterating `i` from 1 to `n` and starting BFS for unvisited nodes.\n*   Contradictions: Handled by checking `ans[curr_v] == candidate_m_v` and `GCD` conditions.\n*   Values out of range `[1, 10^6]`: Handled by explicit checks.\n*   `l % g != 0`: Handled at the beginning.\n\n```python\nimport math\nimport collections\n\ndef solve():\n    n, m = map(int, input().split())\n\n    adj = collections.defaultdict(list)\n    \n    # Store edges and perform initial GCD/LCM consistency check\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        if l % g != 0:\n            print(\"NO\")\n            return\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    ans = [0] * (n + 1) # ans[i] stores the mushroom count for lawn i\n    visited = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            # Start BFS for a new connected component\n            q = collections.deque()\n            \n            # Initial assignment for the starting node of the component\n            # A simple valid initial value is 1, as GCD(1, X) = 1 and LCM(1, X) = X.\n            # If the node has no edges, 1 is a perfectly fine value.\n            # If it has edges, this 1 will propagate and be checked.\n            ans[i] = 1 \n            \n            q.append(i)\n            visited[i] = True\n\n            while q:\n                u = q.popleft()\n\n                for v, g, l in adj[u]:\n                    m_u = ans[u]\n                    \n                    # Calculate candidate_m_v based on m_u, g, l\n                    # m_u * m_v = g * l  =>  m_v = (g * l) / m_u\n                    \n                    # Check for divisibility before calculating m_v\n                    if (g * l) % m_u != 0:\n                        print(\"NO\")\n                        return\n                    \n                    candidate_m_v = (g * l) // m_u\n\n                    # Check constraints for candidate_m_v\n                    if not (1 <= candidate_m_v <= 10**6):\n                        print(\"NO\")\n                        return\n                    \n                    # Verify GCD and LCM properties\n                    if math.gcd(m_u, candidate_m_v) != g:\n                        print(\"NO\")\n                        return\n                    # LCM check is redundant if GCD and product are correct:\n                    # LCM(a,b) = (a*b)/GCD(a,b)\n                    # So if m_u * candidate_m_v == g * l and GCD(m_u, candidate_m_v) == g,\n                    # then LCM(m_u, candidate_m_v) == (g * l) / g == l.\n                    # This check is implicitly covered.\n\n                    if not visited[v]:\n                        # If v is unvisited, assign its value and add to queue\n                        ans[v] = candidate_m_v\n                        visited[v] = True\n                        q.append(v)\n                    else:\n                        # If v is visited, check for consistency\n                        if ans[v] != candidate_m_v:\n                            print(\"NO\")\n                            return\n    \n    # If all checks pass, print YES and the results\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport collections\n\ndef solve():\n    n, m = map(int, input().split())\n\n    adj = collections.defaultdict(list)\n    \n    # Store edges and perform initial GCD/LCM consistency check\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        if l % g != 0:\n            print(\"NO\")\n            return\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    ans = [0] * (n + 1) # ans[i] stores the mushroom count for lawn i\n    visited = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            # Start BFS for a new connected component\n            q = collections.deque()\n            \n            # Initial assignment for the starting node of the component\n            # A simple valid initial value is 1, as GCD(1, X) = 1 and LCM(1, X) = X.\n            # If the node has no edges, 1 is a perfectly fine value.\n            # If it has edges, this 1 will propagate and be checked.\n            ans[i] = 1 \n            \n            q.append(i)\n            visited[i] = True\n\n            while q:\n                u = q.popleft()\n\n                for v, g, l in adj[u]:\n                    m_u = ans[u]\n                    \n                    # Calculate candidate_m_v based on m_u, g, l\n                    # m_u * m_v = g * l  =>  m_v = (g * l) / m_u\n                    \n                    # Check for divisibility before calculating m_v\n                    if (g * l) % m_u != 0:\n                        print(\"NO\")\n                        return\n                    \n                    candidate_m_v = (g * l) // m_u\n\n                    # Check constraints for candidate_m_v\n                    if not (1 <= candidate_m_v <= 10**6):\n                        print(\"NO\")\n                        return\n                    \n                    # Verify GCD and LCM properties\n                    if math.gcd(m_u, candidate_m_v) != g:\n                        print(\"NO\")\n                        return\n                    # LCM check is redundant if GCD and product are correct:\n                    # LCM(a,b) = (a*b)/GCD(a,b)\n                    # So if m_u * candidate_m_v == g * l and GCD(m_u, candidate_m_v) == g,\n                    # then LCM(m_u, candidate_m_v) == (g * l) / g == l.\n                    # This check is implicitly covered.\n\n                    if not visited[v]:\n                        # If v is unvisited, assign its value and add to queue\n                        ans[v] = candidate_m_v\n                        visited[v] = True\n                        q.append(v)\n                    else:\n                        # If v is visited, check for consistency\n                        if ans[v] != candidate_m_v:\n                            print(\"NO\")\n                            return\n    \n    # If all checks pass, print YES and the results\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 2669,
        "thoughts_token_count": 780
    }
}