{
    "start": 1758293683.420989,
    "end": 1758293704.8041196,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He takes the highest possible score from A and B\n    # that sums up to at least X.\n    # All other N-1 participants want to minimize their scores, to make Vasya's rank better.\n    # However, the problem statement implies we are finding Vasya's best/worst rank given\n    # *any* possible assignment of scores to participants.\n    #\n    # Best rank: Vasya wants to maximize his score. He takes the largest possible a_i and b_j\n    # such that a_i + b_j >= x.\n    # To maximize his rank (get a lower number), he wants to have as many people as possible\n    # score less than him.\n    #\n    # Consider Vasya gets a score S_V. His rank is 1 + (number of people with score > S_V) +\n    # (number of people with score = S_V and jury places them above Vasya).\n    #\n    # For the best rank, Vasya wants to maximize his score. He takes the largest possible a_i and b_j.\n    # Let's say Vasya gets a score S_V.\n    # All other N-1 participants are assigned scores from the remaining (N-1) a's and (N-1) b's.\n    # For Vasya's best rank, we assume the jury places him above anyone with the same score.\n    # So, his rank is 1 + (number of people with score > S_V).\n    #\n    # To minimize this count, Vasya should try to get the highest possible score.\n    # The highest possible score Vasya can get is max(a) + max(b).\n    # It is guaranteed that there exist i, j such that a[i] + b[j] >= x.\n    # So, Vasya can always achieve a score S_V = max(a) + max(b).\n    # If he takes max(a) and max(b), he is the only one who can achieve this score.\n    # Thus, his best rank is 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but it must be at least X.\n    # The other N-1 participants want to maximize their scores, to make Vasya's rank worse.\n    #\n    # Vasya's rank is 1 + (number of people with score > S_V) +\n    # (number of people with score = S_V and jury places them above Vasya).\n    #\n    # For the worst rank, we assume the jury places Vasya below anyone with the same score.\n    # So, his rank is 1 + (number of people with score > S_V) + (number of people with score = S_V).\n    #\n    # To maximize this count, Vasya should try to get the lowest possible score (but >= x).\n    # The other N-1 participants should try to get the highest possible scores.\n    #\n    # This is a matching problem. We need to find a permutation of b that, when paired with a,\n    # maximizes the number of pairs (a_i, b_j) such that a_i + b_j >= S_V.\n    #\n    # Let's fix Vasya's score S_V. Vasya takes some a_i and b_j such that a_i + b_j >= x.\n    # The remaining N-1 a's and N-1 b's are paired up.\n    #\n    # A more direct approach:\n    # We want to count how many participants can achieve a score S_k >= S_V.\n    # Vasya's worst rank is 1 + (count of participants (including Vasya) who can achieve a score >= S_V,\n    # and Vasya gets the lowest score among them).\n    #\n    # Let's count, for each possible score `s`, how many pairs `(a_i, b_j)` sum up to at least `s`.\n    # We can iterate through `a` and for each `a_i`, find how many `b_j` satisfy `b_j >= s - a_i`.\n    # Since `b` is sorted, this can be done efficiently using two pointers or binary search.\n    #\n    # Let's count `num_participants_ge_s` for each `s`.\n    # `num_participants_ge_s` is the maximum number of participants that can achieve a total score of at least `s`.\n    # This is equivalent to finding the maximum matching where a_i + b_j >= s.\n    #\n    # We can use a two-pointer approach for this.\n    # Sort `a` in ascending order and `b` in ascending order.\n    # To maximize the number of pairs `(a_i, b_j)` such that `a_i + b_j >= s`,\n    # we can iterate through `a_i` and for each `a_i`, find the smallest `b_j` such that `a_i + b_j >= s`.\n    # This is a greedy approach.\n    #\n    # For a given target sum `s`, we want to find the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= s`.\n    # Sort `a` in ascending order. Sort `b` in ascending order.\n    # Use two pointers: `ptr_a` for `a` (from left) and `ptr_b` for `b` (from right).\n    # `count = 0`\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= s`:\n    #     `count += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < s`):\n    #     `ptr_a += 1` (try a larger `a_i` with current `b_j`)\n    #\n    # This greedy approach works for finding the maximum number of pairs.\n    #\n    # We are interested in `s_vasya` (Vasya's score) and `num_above_vasya`.\n    # For the worst case, Vasya gets the lowest possible score `S_V_min` such that `S_V_min >= x`.\n    # And other participants get higher scores.\n    #\n    # Let's try to count how many participants can achieve a score `S_k` such that `S_k >= x`.\n    # This is the `num_participants_ge_x` using the two-pointer approach described above.\n    #\n    # `count_ge_x = 0`\n    # `ptr_a = 0`\n    # `ptr_b = n - 1`\n    # while `ptr_a < n` and `ptr_b >= 0`:\n    #     if `a[ptr_a] + b[ptr_b] >= x`:\n    #         `count_ge_x += 1`\n    #         `ptr_a += 1`\n    #         `ptr_b -= 1`\n    #     else:\n    #         `ptr_a += 1`\n    #\n    # This `count_ge_x` is the maximum number of people who can score at least `x`.\n    # Vasya is one of these people. In the worst case, all these `count_ge_x` people\n    # are assigned unique pairs `(a_i, b_j)` that sum to at least `x`, and Vasya\n    # is placed last among them.\n    #\n    # So, the worst rank is `count_ge_x`.\n\n    count_ge_x = 0\n    ptr_a = 0\n    ptr_b = n - 1\n    \n    # a is sorted ascending, b is sorted ascending\n    # To maximize pairs (a_i, b_j) with sum >= x:\n    # Iterate through a from smallest. For each a_i, find largest b_j such that a_i + b_j >= x.\n    # If we use a_i and b_j, they are consumed.\n    # This is effectively a greedy matching.\n    #\n    # Let's use `a` sorted ascending, `b` sorted descending.\n    # `a_sorted = sorted(a)`\n    # `b_sorted_desc = sorted(b, reverse=True)`\n    #\n    # `count = 0`\n    # `l = 0` (pointer for `a_sorted`)\n    # `r = 0` (pointer for `b_sorted_desc`)\n    #\n    # while `l < n` and `r < n`:\n    #     if `a_sorted[l] + b_sorted_desc[r] >= x`:\n    #         `count += 1`\n    #         `l += 1`\n    #         `r += 1`\n    #     else:\n    #         `l += 1` (current `a_sorted[l]` is too small even with largest available `b_sorted_desc[r]`, try next `a`)\n    #\n    # This is the correct two-pointer approach for maximum matching.\n    # Let's re-sort `a` and `b` as needed.\n    \n    a_copy = sorted(a)\n    b_copy = sorted(b, reverse=True) # b in descending order\n\n    worst_rank = 0\n    l = 0\n    r = 0\n    while l < n and r < n:\n        if a_copy[l] + b_copy[r] >= x:\n            worst_rank += 1\n            l += 1\n            r += 1\n        else:\n            # If a_copy[l] + b_copy[r] < x, then a_copy[l] is too small to pair with b_copy[r]\n            # (which is the largest available b for this a_copy[l]).\n            # We must try a larger a_copy[l].\n            l += 1\n\n    print(best_rank, worst_rank)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He takes the highest possible score from A and B\n    # that sums up to at least X.\n    # All other N-1 participants want to minimize their scores, to make Vasya's rank better.\n    # However, the problem statement implies we are finding Vasya's best/worst rank given\n    # *any* possible assignment of scores to participants.\n    #\n    # Best rank: Vasya wants to maximize his score. He takes the largest possible a_i and b_j\n    # such that a_i + b_j >= x.\n    # To maximize his rank (get a lower number), he wants to have as many people as possible\n    # score less than him.\n    #\n    # Consider Vasya gets a score S_V. His rank is 1 + (number of people with score > S_V) +\n    # (number of people with score = S_V and jury places them above Vasya).\n    #\n    # For the best rank, Vasya wants to maximize his score. He takes the largest possible a_i and b_j.\n    # Let's say Vasya gets a score S_V.\n    # All other N-1 participants are assigned scores from the remaining (N-1) a's and (N-1) b's.\n    # For Vasya's best rank, we assume the jury places him above anyone with the same score.\n    # So, his rank is 1 + (number of people with score > S_V).\n    #\n    # To minimize this count, Vasya should try to get the highest possible score.\n    # The highest possible score Vasya can get is max(a) + max(b).\n    # It is guaranteed that there exist i, j such that a[i] + b[j] >= x.\n    # So, Vasya can always achieve a score S_V = max(a) + max(b).\n    # If he takes max(a) and max(b), he is the only one who can achieve this score.\n    # Thus, his best rank is 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but it must be at least X.\n    # The other N-1 participants want to maximize their scores, to make Vasya's rank worse.\n    #\n    # Vasya's rank is 1 + (number of people with score > S_V) +\n    # (number of people with score = S_V and jury places them above Vasya).\n    #\n    # For the worst rank, we assume the jury places Vasya below anyone with the same score.\n    # So, his rank is 1 + (number of people with score > S_V) + (number of people with score = S_V).\n    #\n    # To maximize this count, Vasya should try to get the lowest possible score (but >= x).\n    # The other N-1 participants should try to get the highest possible scores.\n    #\n    # This is a matching problem. We need to find a permutation of b that, when paired with a,\n    # maximizes the number of pairs (a_i, b_j) such that a_i + b_j >= S_V.\n    #\n    # Let's fix Vasya's score S_V. Vasya takes some a_i and b_j such that a_i + b_j >= x.\n    # The remaining N-1 a's and N-1 b's are paired up.\n    #\n    # A more direct approach:\n    # We want to count how many participants can achieve a score S_k >= S_V.\n    # Vasya's worst rank is 1 + (count of participants (including Vasya) who can achieve a score >= S_V,\n    # and Vasya gets the lowest score among them).\n    #\n    # Let's count, for each possible score `s`, how many pairs `(a_i, b_j)` sum up to at least `s`.\n    # We can iterate through `a` and for each `a_i`, find how many `b_j` satisfy `b_j >= s - a_i`.\n    # Since `b` is sorted, this can be done efficiently using two pointers or binary search.\n    #\n    # Let's count `num_participants_ge_s` for each `s`.\n    # `num_participants_ge_s` is the maximum number of participants that can achieve a total score of at least `s`.\n    # This is equivalent to finding the maximum matching where a_i + b_j >= s.\n    #\n    # We can use a two-pointer approach for this.\n    # Sort `a` in ascending order and `b` in ascending order.\n    # To maximize the number of pairs `(a_i, b_j)` such that `a_i + b_j >= s`,\n    # we can iterate through `a_i` and for each `a_i`, find the smallest `b_j` such that `a_i + b_j >= s`.\n    # This is a greedy approach.\n    #\n    # For a given target sum `s`, we want to find the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= s`.\n    # Sort `a` in ascending order. Sort `b` in ascending order.\n    # Use two pointers: `ptr_a` for `a` (from left) and `ptr_b` for `b` (from right).\n    # `count = 0`\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= s`:\n    #     `count += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < s`):\n    #     `ptr_a += 1` (try a larger `a_i` with current `b_j`)\n    #\n    # This greedy approach works for finding the maximum number of pairs.\n    #\n    # We are interested in `s_vasya` (Vasya's score) and `num_above_vasya`.\n    # For the worst case, Vasya gets the lowest possible score `S_V_min` such that `S_V_min >= x`.\n    # And other participants get higher scores.\n    #\n    # Let's try to count how many participants can achieve a score `S_k` such that `S_k >= x`.\n    # This is the `num_participants_ge_x` using the two-pointer approach described above.\n    #\n    # `count_ge_x = 0`\n    # `ptr_a = 0`\n    # `ptr_b = n - 1`\n    # while `ptr_a < n` and `ptr_b >= 0`:\n    #     if `a[ptr_a] + b[ptr_b] >= x`:\n    #         `count_ge_x += 1`\n    #         `ptr_a += 1`\n    #         `ptr_b -= 1`\n    #     else:\n    #         `ptr_a += 1`\n    #\n    # This `count_ge_x` is the maximum number of people who can score at least `x`.\n    # Vasya is one of these people. In the worst case, all these `count_ge_x` people\n    # are assigned unique pairs `(a_i, b_j)` that sum to at least `x`, and Vasya\n    # is placed last among them.\n    #\n    # So, the worst rank is `count_ge_x`.\n\n    count_ge_x = 0\n    ptr_a = 0\n    ptr_b = n - 1\n    \n    # a is sorted ascending, b is sorted ascending\n    # To maximize pairs (a_i, b_j) with sum >= x:\n    # Iterate through a from smallest. For each a_i, find largest b_j such that a_i + b_j >= x.\n    # If we use a_i and b_j, they are consumed.\n    # This is effectively a greedy matching.\n    #\n    # Let's use `a` sorted ascending, `b` sorted descending.\n    # `a_sorted = sorted(a)`\n    # `b_sorted_desc = sorted(b, reverse=True)`\n    #\n    # `count = 0`\n    # `l = 0` (pointer for `a_sorted`)\n    # `r = 0` (pointer for `b_sorted_desc`)\n    #\n    # while `l < n` and `r < n`:\n    #     if `a_sorted[l] + b_sorted_desc[r] >= x`:\n    #         `count += 1`\n    #         `l += 1`\n    #         `r += 1`\n    #     else:\n    #         `l += 1` (current `a_sorted[l]` is too small even with largest available `b_sorted_desc[r]`, try next `a`)\n    #\n    # This is the correct two-pointer approach for maximum matching.\n    # Let's re-sort `a` and `b` as needed.\n    \n    a_copy = sorted(a)\n    b_copy = sorted(b, reverse=True) # b in descending order\n\n    worst_rank = 0\n    l = 0\n    r = 0\n    while l < n and r < n:\n        if a_copy[l] + b_copy[r] >= x:\n            worst_rank += 1\n            l += 1\n            r += 1\n        else:\n            # If a_copy[l] + b_copy[r] < x, then a_copy[l] is too small to pair with b_copy[r]\n            # (which is the largest available b for this a_copy[l]).\n            # We must try a larger a_copy[l].\n            l += 1\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 2456,
        "thoughts_token_count": 0
    }
}