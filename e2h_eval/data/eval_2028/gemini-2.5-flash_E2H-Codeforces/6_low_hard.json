{
    "start": 1758009281.8177004,
    "end": 1758009325.275869,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Programming Challenge at Hand**\n\nOkay, so I've got this competitive programming problem I need to solve, and it's asking me to find a specific pair of vouchers. The goal is to identify two distinct vouchers, let's call them `i` and `j`, that are disjoint. This means their timeframes don't overlap – one must finish before the other begins.  The sum of their durations should equal a target value `x`, and the sum of their costs needs to be as low as possible. If I can't find such a pair, I need to print -1.\n\nRight now, the key elements are:\n\n*   **Input Data:** I've got `n` vouchers, the total duration `x`, and for each voucher, its start time (`li`), end time (`ri`), and cost (`costi`).\n*   **Duration Calculation:**  The duration of each voucher `i` is simply `di = ri - li + 1`.\n*   **Disjoint Condition:** Vouchers `i` and `j` are disjoint if either `ri < lj` (voucher `i` ends before `j` starts) or `rj < li` (voucher `j` ends before `i` starts).\n*   **Objective:** Minimize `cost_i + cost_j` while satisfying the duration requirement (`di + dj = x`) and the disjointness.\n\n**Tackling the Constraints**\n\nThe constraints are pretty standard for this type of problem. We have `n` and `x` limited to `2 * 10^5`, and `li`, `ri`, and `costi` are also within reasonable ranges. I know a brute-force approach, checking all possible pairs, would be `O(n^2)`, which is far too slow given the value of `n`. I need something more efficient, aiming for `O(n log n)` or even `O(n)`.\n\n**Deep Dive into the Conditions**\n\nLet's break down these conditions further. I'm essentially looking for two vouchers where:\n\n1.  Their durations add up to `x` (`di + dj = x`).\n2.  They don't overlap.\n\nMy mind keeps going back to the disjointness. This is the key. I can envision sorting the vouchers, perhaps by start or end times, to simplify this check.\n\n**Thinking Strategically**\n\nI'm thinking, if I fix one voucher `i`, then I only need to find a suitable voucher `j` such that `dj = x - di`. Once `di` is known the value of `dj` is known. The issue lies in the disjoint condition.\n\nThe duration and coordinate ranges provide a clue. I'm considering processing the vouchers. For a fixed voucher `i`, I can look for another suitable voucher `j`. The disjoint condition is the most challenging.\n\n**Toward a Solution**\n\nThe disjointness suggests that sorting the vouchers by some criteria would be helpful. Sorting by `li` or `ri` could allow me to efficiently check the disjoint condition. I have to figure out how to best leverage that for searching the other voucher.\n\nThe fact that the start and end values range from 1 to 2 * 10^5 hints at perhaps a sweep-line technique or some approach that effectively deals with intervals. Sorting might be critical. Let's see if sorting by the start or end value is more helpful.\n",
    "response": "The problem asks us to find two distinct vouchers `i` and `j` such that their total duration `(ri - li + 1) + (rj - lj + 1)` is exactly `x`, they are disjoint (meaning `ri < lj` or `rj < li`), and their total cost `costi + costj` is minimized. If no such pair exists, we should output -1.\n\nLet's denote the duration of voucher `k` as `dk = rk - lk + 1`.\nWe are looking for `(i, j)` such that:\n1.  `di + dj = x`\n2.  `ri < lj` or `rj < li`\n3.  `costi + costj` is minimized.\n\nThe coordinates `l_k`, `r_k` and `x` can be up to `2 * 10^5`. A naive `O(N^2)` approach will be too slow for `N = 2 * 10^5`. We need a more efficient approach, likely `O(N log N)` or `O(N)`.\n\nThe disjoint condition `ri < lj` or `rj < li` means one voucher must entirely end before the other begins. This suggests processing vouchers in a way that allows us to efficiently query for suitable partners.\n\nLet's consider iterating through all vouchers `i`. For each voucher `i`, we need to find a voucher `j` such that:\n1.  `dj = x - di`\n2.  `j` is disjoint from `i`.\n3.  `costj` is minimized among all such `j`.\n\nThe maximum coordinate is `MAX_COORD = 2 * 10^5`. We can use an array (or a dictionary, but an array is better for dense coordinates) to store minimum costs.\nLet `min_cost_for_end_day[k]` be the minimum cost of a voucher that ends on day `k`. This is simple to maintain.\nHowever, we need to find a voucher `j` with `dj = x - di` and `rj < li` (or `ri < lj`).\n\nA common strategy for interval problems is to sort the intervals. Let's sort all vouchers by their start times `li`. If `li` are equal, sort by `ri`.\n\nWe can maintain, for each possible duration `d`, the minimum cost of a voucher that has duration `d` and *could be a first part* of a pair.\nLet `min_cost_ending_at[end_day][duration]` store the minimum cost of a voucher that ends on `end_day` and has the given `duration`. This is too much state. `MAX_COORD * MAX_COORD` state.\n\nInstead, let's process vouchers sorted by their start day `l`.\nWhen we process a voucher `(li, ri, costi)`, we are looking for a voucher `j` such that `rj < li` and `dj = x - di`.\nThis means we need to query for vouchers that *ended before `li`*.\n\nLet's use an array `min_cost_for_duration[duration]` to store the minimum cost of a voucher with that `duration` that has *already been processed and ended*.\nThe array `min_cost_for_duration` should be initialized with infinity for all durations.\nThe maximum duration is `MAX_COORD`. So, `min_cost_for_duration` will be an array of size `MAX_COORD + 1`.\n\nThe processing order matters. If we sort vouchers by `li`, when we are at voucher `(li, ri, costi)`, we have already processed all vouchers `k` with `lk < li`. Some of these might also have `rk < li`.\nThis suggests a sweep-line approach.\n\nLet's store vouchers grouped by their start day `l`.\n`vouchers_by_l[day]` will be a list of `(r, cost, duration)` for all vouchers starting on `day`.\n`vouchers_by_r[day]` will be a list of `(l, cost, duration)` for all vouchers ending on `day`.\n\nWe can iterate `current_day` from `1` to `MAX_COORD`.\nAt each `current_day`:\n1.  **Consider vouchers that end on `current_day - 1`**: For any voucher `(l, r, c)` that ends on `current_day - 1` (i.e., `r = current_day - 1`), it can be a \"first part\" of a pair. We can update our `min_cost_for_duration` array. Specifically, `min_cost_for_duration[r - l + 1] = min(min_cost_for_duration[r - l + 1], c)`.\n    *This array `min_cost_for_duration[d]` should store the minimum cost of a voucher with duration `d` that has *already ended by `current_day - 1`*. Effectively, this means `min_cost_for_duration[d]` tracks `min(cost_k)` for all `k` such that `r_k < current_day` and `d_k = d`.\n\n2.  **Consider vouchers that start on `current_day`**: For any voucher `(l, r, c)` that starts on `current_day` (i.e., `l = current_day`), it can be a \"second part\" of a pair. We need to find a suitable \"first part\" voucher `j`.\n    *   The duration of `j` must be `dj = x - (r - l + 1)`. Let `required_duration = x - (r - l + 1)`.\n    *   If `required_duration > 0` and `required_duration <= MAX_COORD`, we can check `min_cost_for_duration[required_duration]`.\n    *   If `min_cost_for_duration[required_duration]` is not infinity, it means there exists a voucher `j` with `dj = required_duration` that ended before `current_day` (i.e., `rj < l`).\n    *   The total cost for this pair `(j, (l, r, c))` would be `min_cost_for_duration[required_duration] + c`. We update our overall minimum `min_total_cost`.\n\nLet's refine the `min_cost_for_duration` array.\n`min_cost_for_duration[d]` should store the minimum cost of a voucher with duration `d` that has *ended at or before `current_day - 1`*.\nThis means `min_cost_for_duration[d]` should be updated by `min_cost_for_duration[d] = min(min_cost_for_duration[d], c)` for all vouchers `(l, r, c)` where `r = current_day - 1`.\n\nThe `min_cost_for_duration` array should track the minimum cost for each duration seen so far.\nWhen we iterate through `current_day` from `1` to `MAX_COORD`:\n1.  **Update `min_cost_for_duration` based on vouchers ending at `current_day - 1`**:\n    For each voucher `v = (l_v, r_v, c_v)` such that `r_v = current_day - 1`:\n        `d_v = r_v - l_v + 1`\n        `min_cost_for_duration[d_v] = min(min_cost_for_duration[d_v], c_v)`\n    This step ensures that `min_cost_for_duration[d]` holds the minimum cost of a voucher of duration `d` that has *finished by `current_day - 1`*.\n\n2.  **Process vouchers starting at `current_day`**:\n    For each voucher `u = (l_u, r_u, c_u)` such that `l_u = current_day`:\n        `d_u = r_u - l_u + 1`\n        `required_duration = x - d_u`\n        If `1 <= required_duration <= MAX_COORD`:\n            If `min_cost_for_duration[required_duration]` is not infinity:\n                `min_total_cost = min(min_total_cost, min_cost_for_duration[required_duration] + c_u)`\n\nInitial `min_total_cost = infinity`.\nAfter iterating through all days, if `min_total_cost` is still infinity, output -1, otherwise output `min_total_cost`.\n\nLet's analyze the time complexity:\n*   Preprocessing: Grouping vouchers by `l` and `r` takes `O(N)` time.\n    `vouchers_by_l = [[] for _ in range(MAX_COORD + 1)]`\n    `vouchers_by_r = [[] for _ in range(MAX_COORD + 1)]`\n    For each `(l, r, c)`: `vouchers_by_l[l].append((r, c))` and `vouchers_by_r[r].append((l, c))`\n    (Note: `vouchers_by_r` is not strictly needed if we update `min_cost_for_duration` in a different way, but it simplifies the logic for updating based on `r_v = current_day - 1`).\n\n*   Main loop: Iterates `MAX_COORD` times.\n    *   Step 1 (updating `min_cost_for_duration`): For each `current_day`, we iterate through `vouchers_by_r[current_day - 1]`. The total number of `(l, c)` pairs across all `current_day - 1` is `N`. So, this step takes `O(N)` total over all `MAX_COORD` iterations.\n    *   Step 2 (processing vouchers starting at `current_day`): For each `current_day`, we iterate through `vouchers_by_l[current_day]`. The total number of `(r, c)` pairs across all `current_day` is `N`. So, this step takes `O(N)` total over all `MAX_COORD` iterations.\n\n*   `min_cost_for_duration` array: Initialized once `O(MAX_COORD)`.\n\nTotal time complexity: `O(N + MAX_COORD)`.\nSpace complexity: `O(N + MAX_COORD)` for storing vouchers and `min_cost_for_duration`.\nGiven `N, X, L, R <= 2 * 10^5`, this is efficient enough.\n\nExample walkthrough (First sample):\nN=4, X=5\nVouchers: (1,3,4), (1,2,5), (5,6,1), (1,2,4)\nMAX_COORD = 6\n\n`vouchers_by_l`:\n1: [(3,4), (2,5), (2,4)]\n5: [(6,1)]\n\n`vouchers_by_r`:\n2: [(1,5), (1,4)]\n3: [(1,4)]\n6: [(5,1)]\n\n`min_cost_for_duration` = `[inf] * (MAX_COORD + 1)`\n`min_total_cost` = `inf`\n\n`current_day = 1`:\n  No vouchers end on `day 0`.\n  Vouchers starting on `day 1`:\n    (1,3,4): `d=3`. `req_d = 5-3=2`. `min_cost_for_duration[2]` is `inf`. No update.\n    (1,2,5): `d=2`. `req_d = 5-2=3`. `min_cost_for_duration[3]` is `inf`. No update.\n    (1,2,4): `d=2`. `req_d = 5-2=3`. `min_cost_for_duration[3]` is `inf`. No update.\n\n`current_day = 2`:\n  Vouchers ending on `day 1`: None.\n  Vouchers starting on `day 2`: None.\n\n`current_day = 3`:\n  Vouchers ending on `day 2`:\n    (1,2,5): `d=2`. `min_cost_for_duration[2] = min(inf, 5) = 5`.\n    (1,2,4): `d=2`. `min_cost_for_duration[2] = min(5, 4) = 4`.\n  Vouchers starting on `day 3`: None.\n  `min_cost_for_duration` is now `[inf, inf, 4, inf, inf, inf, inf]` (index 2 has 4)\n\n`current_day = 4`:\n  Vouchers ending on `day 3`:\n    (1,3,4): `d=3`. `min_cost_for_duration[3] = min(inf, 4) = 4`.\n  Vouchers starting on `day 4`: None.\n  `min_cost_for_duration` is now `[inf, inf, 4, 4, inf, inf, inf]` (index 2 has 4, index 3 has 4)\n\n`current_day = 5`:\n  Vouchers ending on `day 4`: None.\n  Vouchers starting on `day 5`:\n    (5,6,1): `d=2`. `req_d = 5-2=3`. `min_cost_for_duration[3]` is `4`.\n      `min_total_cost = min(inf, 4 + 1) = 5`.\n\n`current_day = 6`:\n  Vouchers ending on `day 5`: None.\n  Vouchers starting on `day 6`: None.\n\nAfter loop, `min_total_cost = 5`. Output 5. This matches the example.\n\nConsider edge cases:\n*   `x` is too small or too large: `required_duration` calculation handles `required_duration > 0`. If `required_duration <= 0` or `required_duration > MAX_COORD`, it won't find a match.\n*   No two vouchers satisfy the conditions: `min_total_cost` remains `inf`, correctly prints -1.\n*   `N=2`: Works fine.\n*   All vouchers have same `l` or `r`: Handled by grouping.\n\nThe maximum coordinate value is `2 * 10^5`. Let's define `MAX_COORD = 200000`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l and r is 2 * 10^5\n    MAX_COORD = 200000\n\n    # vouchers_by_l[day]: list of (r, cost) for vouchers starting on 'day'\n    vouchers_by_l = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_r[day]: list of (l, cost) for vouchers ending on 'day'\n    vouchers_by_r = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_l[l].append((r, cost))\n        vouchers_by_r[r].append((l, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has ended by the current_day - 1.\n    # Initialize with a very large value (infinity).\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Update min_cost_for_duration based on vouchers that ended on current_day - 1\n        # These vouchers are now available as a \"first part\" for future vouchers\n        if current_day > 1: # Only process if there's a previous day\n            for l_v, c_v in vouchers_by_r[current_day - 1]:\n                d_v = (current_day - 1) - l_v + 1\n                # Only consider durations that are valid for x\n                if 1 <= d_v <= MAX_COORD:\n                    min_cost_for_duration[d_v] = min(min_cost_for_duration[d_v], c_v)\n\n        # Step 2: Process vouchers that start on current_day\n        # These vouchers can be a \"second part\" paired with an already available \"first part\"\n        for r_u, c_u in vouchers_by_l[current_day]:\n            d_u = r_u - current_day + 1\n            required_duration = x - d_u\n\n            # Check if required_duration is valid and if there's an available voucher\n            if 1 <= required_duration <= MAX_COORD:\n                if min_cost_for_duration[required_duration] != float('inf'):\n                    min_total_cost = min(min_total_cost, min_cost_for_duration[required_duration] + c_u)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l and r is 2 * 10^5\n    MAX_COORD = 200000\n\n    # vouchers_by_l[day]: list of (r, cost) for vouchers starting on 'day'\n    vouchers_by_l = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_r[day]: list of (l, cost) for vouchers ending on 'day'\n    vouchers_by_r = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_l[l].append((r, cost))\n        vouchers_by_r[r].append((l, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has ended by the current_day - 1.\n    # Initialize with a very large value (infinity).\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Update min_cost_for_duration based on vouchers that ended on current_day - 1\n        # These vouchers are now available as a \"first part\" for future vouchers\n        if current_day > 1: # Only process if there's a previous day\n            for l_v, c_v in vouchers_by_r[current_day - 1]:\n                d_v = (current_day - 1) - l_v + 1\n                # Only consider durations that are valid for x\n                if 1 <= d_v <= MAX_COORD:\n                    min_cost_for_duration[d_v] = min(min_cost_for_duration[d_v], c_v)\n\n        # Step 2: Process vouchers that start on current_day\n        # These vouchers can be a \"second part\" paired with an already available \"first part\"\n        for r_u, c_u in vouchers_by_l[current_day]:\n            d_u = r_u - current_day + 1\n            required_duration = x - d_u\n\n            # Check if required_duration is valid and if there's an available voucher\n            if 1 <= required_duration <= MAX_COORD:\n                if min_cost_for_duration[required_duration] != float('inf'):\n                    min_total_cost = min(min_total_cost, min_cost_for_duration[required_duration] + c_u)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 4042,
        "thoughts_token_count": 765
    }
}