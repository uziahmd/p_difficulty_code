{
    "start": 1758294860.8813891,
    "end": 1758294944.193417,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Initial Thoughts: The Mushroom Strife Problem**\n\nOkay, I've got this competitive programming problem, \"Mushroom Strife,\" to tackle. We're given a graph of lawns and roads, with GCD and LCM constraints on the mushrooms at connected lawns. The goal is to find valid mushroom counts for each lawn, or report that no solution exists.\n\n**Understanding the Constraints**\n\nThe heart of the problem lies in the relationship between GCD and LCM. I remember, `GCD(a, b) * LCM(a, b) = a * b`. That's the key. If we're given the GCD (`g`) and LCM (`l`) for two lawns, say `u` and `v`, then `x_u * x_v = g * l`. Crucially, `g` must divide `l`, otherwise there's no solution right off the bat. Also, `x_u` and `x_v` must be multiples of `g`. So `x_u = g * a'`, and `x_v = g * b'` where `GCD(a', b') = 1` which is coprime.\n\n**The Prime Factorization Approach**\n\nThis screams \"prime factorization\" at me. Let's express each mushroom count, `x_i`, as a product of prime powers. For an edge between `u` and `v`, the GCD is the product of the minimum exponents of each prime, and the LCM is the product of the maximum exponents.\n\n**Graph Coloring and Exponents**\n\nFor each prime `p` appearing in `g` or `l` values, we can create a graph. The nodes are the lawns.  Each edge represents the min and max exponents constraints between lawns. So, we either have the exponent of `u` = `min` and the exponent of `v` = `max`, or vice versa for `p`. This seems like a 2-coloring problem component-wise for each prime! This can be translated to a 2-SAT problem for each prime.\n\n**Building a Strategy**\n\nI'm thinking of building this up prime-by-prime. For each prime, I'll use a graph and maintain a `current_exponent[i][p]` to track its exponent in `x_i`. It will be a -1 for \"unknown\", a specific number for determined by the edge constraints.\n\n**Implementing the Solution**\n\n1.  **Sieve Primes:** I'll precompute primes up to the square root of the maximum LCM value (which is 10^6).\n2.  **Prime Factorization:** I'll create functions to get the prime factors and exponents for each number.\n3.  **Process Edges:** For each edge, I'll determine the exponents of the primes involved based on the GCD and LCM. If there's an inconsistency (like `g` not dividing `l`), I'll return \"NO\".\n4.  **Graph Traversal:** Using a Depth-First Search or Breadth-First Search, I'll propagate the constraints and determine the exponents of primes for each lawn.  I'll need to carefully handle unassigned nodes and components.\n5.  **Reconstruct the Values:** Once I have the exponents for each prime and lawn, I'll multiply them together to get the mushroom count for each lawn.\n\nI think this approach is solid and will handle the constraints efficiently.  I'm ready to start coding!",
    "response": "The problem asks us to restore the number of mushrooms `x_i` on `n` lawns, given `m` roads. For each road between lawns `u` and `v`, we are given `g = GCD(x_u, x_v)` and `l = LCM(x_u, x_v)`. We need to find any valid assignment of `x_i` values (1 to 10^6) or report if none exists.\n\n**Key Property:**\nFor any two positive integers `a` and `b`, `GCD(a, b) * LCM(a, b) = a * b`.\nThis implies `x_u * x_v = g * l`.\n\n**Prime Factorization Approach:**\nLet `x_i = product(p_j^{exp_j(x_i)})` be the prime factorization of `x_i`.\nFor any prime `p` and any edge `(u, v)` with `GCD=g, LCM=l`:\n1. `exp_p(g) = min(exp_p(x_u), exp_p(x_v))`\n2. `exp_p(l) = max(exp_p(x_u), exp_p(x_v))`\n\nFrom these two equations, we can deduce:\n- `exp_p(g)` must be less than or equal to `exp_p(l)`. If `exp_p(g) > exp_p(l)` for any prime `p` (which implies `g` does not divide `l`), then no solution exists. This is an early check: if `l % g != 0` for any edge, output \"NO\".\n- If `exp_p(g) == exp_p(l)`: Then `exp_p(x_u)` must be `exp_p(g)` and `exp_p(x_v)` must be `exp_p(g)`. This fixes the exponent of `p` for both `x_u` and `x_v`.\n- If `exp_p(g) < exp_p(l)`: Then `(exp_p(x_u), exp_p(x_v))` must be either `(exp_p(g), exp_p(l))` or `(exp_p(l), exp_p(g))`. This means `exp_p(x_u)` and `exp_p(x_v)` must take on these two distinct values.\n\nThis structure suggests that we can solve the problem independently for each prime factor.\n\n**Algorithm for a single prime `p`:**\nFor each prime `p` that appears in the factorization of any `g` or `l` from the input:\n1. **Initialize `exponents_for_p[i]`:** An array `exponents_for_p` of size `n+1`, initialized to `-1` (meaning `exp_p(x_i)` is undetermined).\n2. **Build `adj_choice[p]` and `fixed_queue`:**\n   - `adj_choice[p]` is an adjacency list for nodes `u` where `exp_p(x_u)` and `exp_p(x_v)` must be `exp_p(g)` and `exp_p(l)` (in some order). Store `(v, exp_p(g), exp_p(l))` for each edge `(u,v)`.\n   - `fixed_queue` is a queue for nodes whose `exp_p(x_i)` has been determined.\n   - Iterate through all input edges `(u, v, g_val, l_val)`:\n     - Get `g_p = exp_p(g_val)` and `l_p = exp_p(l_val)`.\n     - If `g_p == l_p`:\n       - `fixed_exp = g_p`.\n       - For `node` in `{u, v}`: If `exponents_for_p[node]` is `-1`, set it to `fixed_exp` and add `node` to `fixed_queue`. If it's already set to a different value, output \"NO\" and terminate.\n     - If `g_p < l_p`: Add `(v, g_p, l_p)` to `adj_choice[p][u]` and `(u, g_p, l_p)` to `adj_choice[p][v]`.\n3. **Propagate fixed exponents (BFS):**\n   - While `fixed_queue` is not empty:\n     - Dequeue `u`. Let `u_exp = exponents_for_p[u]`.\n     - For each `(v, edge_g_p, edge_l_p)` in `adj_choice[p][u]`:\n       - If `u_exp` is not `edge_g_p` and not `edge_l_p`, then `u_exp` is incompatible with this edge. Output \"NO\".\n       - Determine `target_v_exp`: If `u_exp == edge_g_p`, `target_v_exp = edge_l_p`. Else (`u_exp == edge_l_p`), `target_v_exp = edge_g_p`.\n       - If `exponents_for_p[v]` is `-1`, set it to `target_v_exp` and enqueue `v`.\n       - Else if `exponents_for_p[v] != target_v_exp`, output \"NO\".\n4. **Handle remaining undetermined components (BFS/DFS):**\n   - Iterate `i` from `1` to `n`:\n     - If `exponents_for_p[i]` is `-1`:\n       - If `adj_choice[p][i]` is empty (node `i` has no constraints for prime `p`), set `exponents_for_p[i] = 0` (default to not divisible by `p`).\n       - Else (node `i` is part of an unassigned `adj_choice` component):\n         - Pick an arbitrary edge `(j, edge_g_p, edge_l_p)` from `adj_choice[p][i]`.\n         - Set `exponents_for_p[i] = edge_g_p` (arbitrary choice). Add `i` to a new `bfs_queue`.\n         - Perform BFS from `i` within its component:\n           - Dequeue `u`. Let `u_exp = exponents_for_p[u]`.\n           - For each `(v, edge_g_p, edge_l_p)` in `adj_choice[p][u]`:\n             - If `u_exp` is not `edge_g_p` and not `edge_l_p`, output \"NO\".\n             - Determine `target_v_exp` as before.\n             - If `exponents_for_p[v]` is `-1`, set it to `target_v_exp` and enqueue `v`.\n             - Else if `exponents_for_p[v] != target_v_exp`, output \"NO\".\n5. **Store results:** After processing prime `p`, `exponents_for_p[i]` contains the exponent of `p` for `x_i`.\n\n**Overall Algorithm:**\n1. **Sieve:** Precompute primes and smallest prime factors up to `MAX_VAL = 10^6`.\n2. **Collect Primes:** Identify all distinct prime factors present in any `g` or `l` from the input.\n3. **Initialize `ans_x[i]`:** Create an array `ans_x` of size `n+1`, initialized to `1` (for nodes not involved in any constraint, or for primes not affecting them).\n4. **Iterate Primes:** For each prime `p` identified in step 2:\n   - Run the \"Algorithm for a single prime `p`\" described above.\n   - If any step returns \"NO\", print \"NO\" and exit.\n   - If successful, multiply `ans_x[i]` by `p ^ exponents_for_p[i]` for all `i`.\n5. **Final Check:** After all primes are processed, verify the `ans_x` values against the input edges. For each `(u, v, g, l)`:\n   - Check `GCD(ans_x[u], ans_x[v]) == g`.\n   - Check `LCM(ans_x[u], ans_x[v]) == l`.\n   - If any check fails, output \"NO\".\n   - Also check `1 <= ans_x[i] <= 10^6`. If any `ans_x[i]` exceeds `10^6`, output \"NO\".\n6. **Output:** If all checks pass, print \"YES\" and then `ans_x[1] ... ans_x[n]`.\n\n**Optimization for `get_prime_factorization` and `get_exponent`:**\nUsing a precomputed `min_prime_factor` array from a sieve allows efficient factorization.\n\n**Example of `exp_p(g) < exp_p(l)` constraint:**\nFor an edge `(u, v)` and prime `p`, if `exp_p(g) = 1` and `exp_p(l) = 2`:\nThen `(exp_p(x_u), exp_p(x_v))` must be `(1, 2)` or `(2, 1)`.\nThis means `exp_p(x_u)` and `exp_p(x_v)` must be different.\nIf `exp_p(x_u)` is determined to be `1`, then `exp_p(x_v)` must be `2`.\nIf `exp_p(x_u)` is determined to be `2`, then `exp_p(x_v)` must be `1`.\n\nThe constraint `u_exp` must be one of `edge_g_p` or `edge_l_p` is crucial. If `u_exp` is fixed to something else (e.g., `0` in the example above), it's a contradiction.\n\n```python\nimport sys\nimport collections\n\nMAX_VAL = 10**6\nmin_prime_factor = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if min_prime_factor[i] == 0:\n            min_prime_factor[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > min_prime_factor[i] or i * p > MAX_VAL:\n                break\n            min_prime_factor[i * p] = p\n\nsieve()\n\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = min_prime_factor[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\ndef get_exponent(n, p):\n    if n == 0: return 0 # Convention for GCD/LCM context, though problem uses 1-10^6\n    count = 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Function to calculate GCD\ndef calculate_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef calculate_lcm(a, b):\n    if a == 0 or b == 0: return 0\n    return (a * b) // calculate_gcd(a, b)\n\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    edges_input = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, g, l))\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    all_involved_primes = set()\n    for u, v, g, l in edges_input:\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        all_involved_primes.update(factors_g.keys())\n        all_involved_primes.update(factors_l.keys())\n\n    # exponents[node_id][prime] = exponent of prime in x_node_id\n    # Using dict for inner map for sparse primes\n    exponents = [{} for _ in range(n + 1)]\n\n    # For each prime, process its contribution to exponents\n    for p in all_involved_primes:\n        q_fixed = collections.deque()\n        \n        # adj_choice_p[u] = list of (v, edge_g_p, edge_l_p) for edges where g_p < l_p\n        adj_choice_p = [[] for _ in range(n + 1)]\n\n        # Phase 1: Process fixed exponents and build adj_choice_p\n        for u, v, g_val, l_val in edges_input:\n            g_p = get_exponent(g_val, p)\n            l_p = get_exponent(l_val, p)\n\n            if g_p == l_p: # Fixed exponent for both u and v\n                for node in (u, v):\n                    if p not in exponents[node]:\n                        exponents[node][p] = g_p\n                        q_fixed.append(node)\n                    elif exponents[node][p] != g_p:\n                        print(\"NO\")\n                        return\n            else: # Choice between (g_p, l_p) or (l_p, g_p)\n                adj_choice_p[u].append((v, g_p, l_p))\n                adj_choice_p[v].append((u, g_p, l_p))\n\n        # Phase 2: Propagate fixed values for prime p\n        while q_fixed:\n            u = q_fixed.popleft()\n            u_exp = exponents[u][p]\n\n            for v, edge_g_p, edge_l_p in adj_choice_p[u]:\n                # u_exp must be one of edge_g_p or edge_l_p for this edge\n                if u_exp != edge_g_p and u_exp != edge_l_p:\n                    print(\"NO\")\n                    return\n\n                target_v_exp = edge_l_p if u_exp == edge_g_p else edge_g_p\n                \n                if p not in exponents[v]:\n                    exponents[v][p] = target_v_exp\n                    q_fixed.append(v)\n                elif exponents[v][p] != target_v_exp:\n                    print(\"NO\")\n                    return\n        \n        # Phase 3: Handle remaining unassigned nodes in choice components for prime p\n        for i in range(1, n + 1):\n            if p not in exponents[i]: # Node i is unassigned for prime p\n                # If node i has no edges involving prime p, its exponent can be 0.\n                if not adj_choice_p[i]:\n                    exponents[i][p] = 0\n                    continue\n                \n                # Start a BFS from i to assign values to its component\n                # Pick an arbitrary edge to determine the values for this component\n                # All edges in a connected component of adj_choice_p must have the same (g_p, l_p) values\n                # (or rather, the same set of two values {g_p, l_p}).\n                # If not, it would imply a contradiction for intermediate nodes.\n                # The propagation phase would have caught this if it became fixed.\n                # If it's still unfixed, it means the whole component can be flipped.\n                \n                # Pick an arbitrary edge from adj_choice_p[i] to get the (g_p, l_p) pair\n                # If adj_choice_p[i] is not empty, it must have at least one element.\n                # This logic is safe because if different edges had different pairs,\n                # it would have led to a contradiction and \"NO\" earlier or during propagation.\n                \n                # Assign i to the lower exponent for this prime (arbitrary choice to start)\n                first_neighbor_v, first_edge_g_p, first_edge_l_p = adj_choice_p[i][0]\n                \n                exponents[i][p] = first_edge_g_p # Arbitrarily assign the lower value\n                bfs_queue = collections.deque([i])\n\n                while bfs_queue:\n                    u = bfs_queue.popleft()\n                    u_exp = exponents[u][p]\n\n                    for v, edge_g_p, edge_l_p in adj_choice_p[u]:\n                        if p not in exponents[v]: # If v is unassigned\n                            # u_exp must be one of edge_g_p or edge_l_p for this edge\n                            if u_exp != edge_g_p and u_exp != edge_l_p:\n                                print(\"NO\")\n                                return\n\n                            target_v_exp = edge_l_p if u_exp == edge_g_p else edge_g_p\n                            exponents[v][p] = target_v_exp\n                            bfs_queue.append(v)\n                        else: # If v is already assigned, check for consistency\n                            # u_exp must be one of edge_g_p or edge_l_p for this edge\n                            if u_exp != edge_g_p and u_exp != edge_l_p:\n                                print(\"NO\")\n                                return\n                            target_v_exp = edge_l_p if u_exp == edge_g_p else edge_g_p\n                            if exponents[v][p] != target_v_exp:\n                                print(\"NO\")\n                                return\n\n    # Calculate final x_i values\n    ans_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p, exp in exponents[i].items():\n            if exp > 0: # Only multiply if exponent is positive\n                ans_x[i] *= (p ** exp)\n            if ans_x[i] > MAX_VAL: # Check bounds early\n                print(\"NO\")\n                return\n\n    # Final verification of GCD and LCM constraints\n    for u, v, g_val, l_val in edges_input:\n        if calculate_gcd(ans_x[u], ans_x[v]) != g_val or \\\n           calculate_lcm(ans_x[u], ans_x[v]) != l_val:\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(*(ans_x[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\nMAX_VAL = 10**6\nmin_prime_factor = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if min_prime_factor[i] == 0:\n            min_prime_factor[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > min_prime_factor[i] or i * p > MAX_VAL:\n                break\n            min_prime_factor[i * p] = p\n\nsieve()\n\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = min_prime_factor[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\ndef get_exponent(n, p):\n    if n == 0: return 0 # Convention for GCD/LCM context, though problem uses 1-10^6\n    count = 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Function to calculate GCD\ndef calculate_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef calculate_lcm(a, b):\n    if a == 0 or b == 0: return 0\n    return (a * b) // calculate_gcd(a, b)\n\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    edges_input = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, g, l))\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    all_involved_primes = set()\n    for u, v, g, l in edges_input:\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        all_involved_primes.update(factors_g.keys())\n        all_involved_primes.update(factors_l.keys())\n\n    # exponents[node_id][prime] = exponent of prime in x_node_id\n    # Using dict for inner map for sparse primes\n    exponents = [{} for _ in range(n + 1)]\n\n    # For each prime, process its contribution to exponents\n    for p in all_involved_primes:\n        q_fixed = collections.deque()\n        \n        # adj_choice_p[u] = list of (v, edge_g_p, edge_l_p) for edges where g_p < l_p\n        adj_choice_p = [[] for _ in range(n + 1)]\n\n        # Phase 1: Process fixed exponents and build adj_choice_p\n        for u, v, g_val, l_val in edges_input:\n            g_p = get_exponent(g_val, p)\n            l_p = get_exponent(l_val, p)\n\n            if g_p == l_p: # Fixed exponent for both u and v\n                for node in (u, v):\n                    if p not in exponents[node]:\n                        exponents[node][p] = g_p\n                        q_fixed.append(node)\n                    elif exponents[node][p] != g_p:\n                        print(\"NO\")\n                        return\n            else: # Choice between (g_p, l_p) or (l_p, g_p)\n                adj_choice_p[u].append((v, g_p, l_p))\n                adj_choice_p[v].append((u, g_p, l_p))\n\n        # Phase 2: Propagate fixed values for prime p\n        while q_fixed:\n            u = q_fixed.popleft()\n            u_exp = exponents[u][p]\n\n            for v, edge_g_p, edge_l_p in adj_choice_p[u]:\n                # u_exp must be one of edge_g_p or edge_l_p for this edge\n                if u_exp != edge_g_p and u_exp != edge_l_p:\n                    print(\"NO\")\n                    return\n\n                target_v_exp = edge_l_p if u_exp == edge_g_p else edge_g_p\n                \n                if p not in exponents[v]:\n                    exponents[v][p] = target_v_exp\n                    q_fixed.append(v)\n                elif exponents[v][p] != target_v_exp:\n                    print(\"NO\")\n                    return\n        \n        # Phase 3: Handle remaining unassigned nodes in choice components for prime p\n        for i in range(1, n + 1):\n            if p not in exponents[i]: # Node i is unassigned for prime p\n                # If node i has no edges involving prime p, its exponent can be 0.\n                if not adj_choice_p[i]:\n                    exponents[i][p] = 0\n                    continue\n                \n                # Start a BFS from i to assign values to its component\n                # Pick an arbitrary edge to determine the values for this component\n                # All edges in a connected component of adj_choice_p must have the same (g_p, l_p) values\n                # (or rather, the same set of two values {g_p, l_p}).\n                # If not, it would imply a contradiction for intermediate nodes.\n                # The propagation phase would have caught this if it became fixed.\n                # If it's still unfixed, it means the whole component can be flipped.\n                \n                # Pick an arbitrary edge from adj_choice_p[i] to get the (g_p, l_p) pair\n                # If adj_choice_p[i] is not empty, it must have at least one element.\n                # This logic is safe because if different edges had different pairs,\n                # it would have led to a contradiction and \"NO\" earlier or during propagation.\n                \n                # Assign i to the lower exponent for this prime (arbitrary choice to start)\n                first_neighbor_v, first_edge_g_p, first_edge_l_p = adj_choice_p[i][0]\n                \n                exponents[i][p] = first_edge_g_p # Arbitrarily assign the lower value\n                bfs_queue = collections.deque([i])\n\n                while bfs_queue:\n                    u = bfs_queue.popleft()\n                    u_exp = exponents[u][p]\n\n                    for v, edge_g_p, edge_l_p in adj_choice_p[u]:\n                        if p not in exponents[v]: # If v is unassigned\n                            # u_exp must be one of edge_g_p or edge_l_p for this edge\n                            if u_exp != edge_g_p and u_exp != edge_l_p:\n                                print(\"NO\")\n                                return\n\n                            target_v_exp = edge_l_p if u_exp == edge_g_p else edge_g_p\n                            exponents[v][p] = target_v_exp\n                            bfs_queue.append(v)\n                        else: # If v is already assigned, check for consistency\n                            # u_exp must be one of edge_g_p or edge_l_p for this edge\n                            if u_exp != edge_g_p and u_exp != edge_l_p:\n                                print(\"NO\")\n                                return\n                            target_v_exp = edge_l_p if u_exp == edge_g_p else edge_g_p\n                            if exponents[v][p] != target_v_exp:\n                                print(\"NO\")\n                                return\n\n    # Calculate final x_i values\n    ans_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p, exp in exponents[i].items():\n            if exp > 0: # Only multiply if exponent is positive\n                ans_x[i] *= (p ** exp)\n            if ans_x[i] > MAX_VAL: # Check bounds early\n                print(\"NO\")\n                return\n\n    # Final verification of GCD and LCM constraints\n    for u, v, g_val, l_val in edges_input:\n        if calculate_gcd(ans_x[u], ans_x[v]) != g_val or \\\n           calculate_lcm(ans_x[u], ans_x[v]) != l_val:\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(*(ans_x[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 4402,
        "thoughts_token_count": 7463
    }
}