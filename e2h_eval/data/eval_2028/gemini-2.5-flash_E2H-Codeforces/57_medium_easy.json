{
    "start": 1758294757.2736838,
    "end": 1758294824.9794874,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**The Core Problem and My Approach:**\n\nAlright, I'm facing a challenging ranking problem in an Olympiad. My goal is to determine the best and worst possible ranks Vasya could achieve. We're given the number of participants (`n`), a minimum total score Vasya needs (`x`), and the scores from two rounds (`a` and `b`). The twist? We don't know *who* scored what. This lack of information makes the ranking tricky, and the jury's rules about ties add another layer of complexity.\n\n**Understanding the Goal:**\n\nThe key is to remember that Vasya needs a total score of at least `x`. To achieve the best rank (ideally, rank 1), I'd want to maximize Vasya's score while minimizing everyone else's.  Conversely, for the worst rank, I want to minimize Vasya's score (still above `x`) and maximize how many other participants score the same or higher. The jury's rule lets us assign ranks, and they'll handle assigning rank in the same score.\n\n**Breaking Down the Best Rank:**\n\nTo get rank 1, Vasya needs the highest score *and* that score should be unique. The maximum possible score is the highest score from round 1 plus the highest from round 2. If Vasya can get that maximum score (and it's at least `x`), he's potentially rank 1. This would mean assigning Vasya `max(a)` and `max(b)`. But we need to make sure he's uniquely the highest and there is no other score that's same and higher than him.\n\n**Worst Rank: The Complicated Part:**\n\nThe worst-case scenario is where Vasya shares a score with many other participants. To maximize the *worst* rank, I need to create a situation where as many people as possible score *at least* Vasya's score. This involves minimizing Vasya's score (but not below `x`) and skillfully pairing the other scores to maximize the number of equal or higher scores. The problem statement guarantee states such pairing is possible.\n\nI've been sorting `a` and `b` and using a greedy-style method, but the core of the worst-rank problem is still a challenge, and I need a better way. I realized I must find pairs `a_i+b_j >= x`. Then I want to maximize the number of other sums that are also greater than or equal to this sum. This seems like a count optimization with a constraint. This problem is not straightforward. I'm struggling to efficiently calculate it when considering every possible pairing to get a maximum ranking. I need a more efficient algorithm to handle the pairing aspect. I'm exploring the greedy strategy and the worst-case, two-pointer, sort-based approach to reach the best pairing, and I think that's the key.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given `n` participants, Vasya's minimum total score `x`, and two lists of `n` scores for Tour 1 (`a`) and Tour 2 (`b`). The scores in `a` and `b` are given in arbitrary order, meaning we don't know which participant got which score, only the sets of scores available for each tour. Each participant takes one score from `a` and one from `b`, with each score being used exactly once. If participants have the same total score, the jury can assign ranks arbitrarily among them.\n\nLet `S_V` be Vasya's total score. We are guaranteed `S_V >= x`.\nIf `P` participants have a strictly higher score than Vasya, and `E` participants have the same score as Vasya, then:\n- Vasya's best possible rank is `P + 1` (he is ranked first among those with score `S_V`).\n- Vasya's worst possible rank is `P + E` (he is ranked last among those with score `S_V`).\n\n**1. Best Rank for Vasya:**\n\nTo achieve the best rank, Vasya wants to minimize `P`. The absolute best rank is 1.\nCan Vasya always achieve rank 1?\nYes. Vasya can be assigned the highest possible score `S_max = max(a) + max(b)`.\nThe problem guarantees that there exist `i, j` such that `a_i + b_j >= x`. This implies that `max(a) + max(b)` must also be greater than or equal to `x` (since `max(a) >= a_i` and `max(b) >= b_j`).\nIf Vasya gets `S_max`, then any other participant `k` will get a score `S_k` such that `S_k <= S_max`. This is because the remaining `n-1` scores in `a` are all `<= max(a)` and similarly for `b`.\nTherefore, if Vasya is assigned `max(a)` and `max(b)`, his score `S_max` will be at least as high as any other participant's score. In this scenario, `P=0`. With the jury's discretion, Vasya can be placed first among those with score `S_max`.\nSo, the best rank Vasya can achieve is always **1**.\n\n**2. Worst Rank for Vasya:**\n\nTo achieve the worst rank, Vasya wants to maximize `P + E`. This means maximizing the total number of participants whose score is greater than or equal to Vasya's score `S_V`.\nWe need to find a pairing of scores `(a_i, b_j)` for all `n` participants, and identify one of these pairs as Vasya's, say `(a_k, b_l)`. Let `S_V = a_k + b_l`. This `S_V` must satisfy `S_V >= x`. Then, we count how many participants in *this specific pairing* have a score `S_p >= S_V`. We want to maximize this count over all possible pairings and choices for Vasya's score.\n\nLet's sort both `a` and `b` in non-decreasing order:\n`a_0 <= a_1 <= ... <= a_{n-1}`\n`b_0 <= b_1 <= ... <= b_{n-1}`\n\nConsider a specific threshold score `T`. How many participants can achieve a score of at least `T` in a *valid pairing*?\nTo maximize the number of pairs `(a_i, b_j)` such that `a_i + b_j >= T`, we can use a two-pointer approach:\n1. Initialize `count = 0`.\n2. Use two pointers: `ptr_a = 0` (for `a`) and `ptr_b = n-1` (for `b`).\n3. While `ptr_a < n` and `ptr_b >= 0`:\n   a. If `a[ptr_a] + b[ptr_b] >= T`:\n      This pair `(a[ptr_a], b[ptr_b])` forms a sum `>= T`. We can use this pair. Increment `count`, move `ptr_a` forward, and `ptr_b` backward.\n   b. Else (`a[ptr_a] + b[ptr_b] < T`):\n      Since `a[ptr_a]` is the smallest available score in `a` and `b[ptr_b]` is the largest available score in `b`, if their sum is less than `T`, then `a[ptr_a]` cannot form a sum `>= T` with any of the remaining `b` scores (`b_0, ..., b[ptr_b]`). So, `a[ptr_a]` cannot be part of a pair summing to `>= T`. We must use `a[ptr_a]` with some `b_k` to form a sum `< T`. We move `ptr_a` forward. (Note: `b[ptr_b]` might still be able to form a sum `>= T` with a larger `a_k`, but we are trying to maximize the count, so we prioritize using smaller `a`s with larger `b`s.)\nThis greedy approach correctly finds the maximum number of pairs that can sum to at least `T`. Let's call this function `max_pairs_ge_T(T)`.\n\nNow, for Vasya's worst rank, we want to find a score `S_V >= x` such that `max_pairs_ge_T(S_V)` is maximized.\nThe possible values for `S_V` are sums `a_i + b_j`. There are up to `N^2` such sums, which is too many to iterate through.\nHowever, notice that `max_pairs_ge_T(T)` is a non-increasing function of `T`. As `T` increases, `max_pairs_ge_T(T)` can only stay the same or decrease.\nWe are looking for `max_{S_V >= x} max_pairs_ge_T(S_V)`.\nThis means we want to find the largest `max_pairs_ge_T(S_V)` value for `S_V` starting from `x`.\nThe maximum `max_pairs_ge_T(S_V)` will occur when `S_V` is as small as possible. The smallest possible value for `S_V` is `x`.\nSo, Vasya's worst rank will be `max_pairs_ge_T(x)`. This is the maximum number of people who can score at least `x` points, including Vasya, if Vasya is one of them.\nBy choosing Vasya's score `S_V` to be exactly `x` (if possible, by pairing some `a_i, b_j` to sum to `x`, or if not, the smallest sum `a_i+b_j` that is `>=x`), and then pairing the remaining scores to maximize the number of people scoring `>= S_V`, we achieve the worst rank. The function `max_pairs_ge_T(x)` directly gives this maximum number of people scoring at least `x`.\n\nSo, the worst rank is `max_pairs_ge_T(x)`.\n\n**Example Walkthrough:**\n`n=6, x=7`\n`a = [4, 3, 5, 6, 4, 4]`\n`b = [8, 6, 0, 4, 3, 4]`\n\nSort `a` ascending: `[3, 4, 4, 4, 5, 6]`\nSort `b` ascending: `[0, 3, 4, 4, 6, 8]`\n\nBest rank: Always 1.\n\nWorst rank: Calculate `max_pairs_ge_T(x=7)`.\n`a = [3, 4, 4, 4, 5, 6]`\n`b = [0, 3, 4, 4, 6, 8]`\n`ptr_a = 0`, `ptr_b = 5`, `count = 0`\n\n1. `a[0] + b[5] = 3 + 8 = 11`. `11 >= 7`. Count this pair. `count = 1`. `ptr_a = 1`, `ptr_b = 4`.\n   Remaining: `a = [4, 4, 4, 5, 6]`, `b = [0, 3, 4, 4, 6]`\n2. `a[1] + b[4] = 4 + 6 = 10`. `10 >= 7`. Count this pair. `count = 2`. `ptr_a = 2`, `ptr_b = 3`.\n   Remaining: `a = [4, 4, 5, 6]`, `b = [0, 3, 4, 4]`\n3. `a[2] + b[3] = 4 + 4 = 8`. `8 >= 7`. Count this pair. `count = 3`. `ptr_a = 3`, `ptr_b = 2`.\n   Remaining: `a = [4, 5, 6]`, `b = [0, 3, 4]`\n4. `a[3] + b[2] = 4 + 4 = 8`. `8 >= 7`. Count this pair. `count = 4`. `ptr_a = 4`, `ptr_b = 1`.\n   Remaining: `a = [5, 6]`, `b = [0, 3]`\n5. `a[4] + b[1] = 5 + 3 = 8`. `8 >= 7`. Count this pair. `count = 5`. `ptr_a = 5`, `ptr_b = 0`.\n   Remaining: `a = [6]`, `b = [0]`\n6. `a[5] + b[0] = 6 + 0 = 6`. `6 < 7`. This pair does not sum to `>= 7`. Move `ptr_a` forward. `ptr_a = 6`.\n   Now `ptr_a = 6`, `ptr_b = 0`. `ptr_a` is no longer `< n`. Loop terminates.\n\nThe maximum number of participants who can score at least 7 points is 5.\nSo, Vasya's worst rank is **5**.\n\nOutput for example: `1 5`. This matches the calculation.\n\n**Complexity:**\n- Sorting `a` and `b`: `O(N log N)`.\n- Calculating `max_pairs_ge_T(x)`: `O(N)` with two pointers.\nTotal time complexity: `O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays (or `O(1)` if sorting in-place).\n\nThis solution is efficient enough for `N=10^5`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best rank is always 1.\n    # Vasya can be assigned the highest score from tour 1 and highest from tour 2.\n    # This sum will be max(a) + max(b).\n    # The problem guarantees that at least one pair (a_i, b_j) sums to >= x.\n    # Therefore, max(a) + max(b) >= x.\n    # If Vasya gets max(a) + max(b), his score is at least as high as anyone else.\n    # By jury's choice, he can be placed first.\n    best_rank = 1\n\n    # Worst rank calculation:\n    # We want to maximize the number of people who score >= Vasya's score (S_V).\n    # Vasya's score S_V must be >= x.\n    # To maximize the count of people scoring >= S_V, we should choose S_V to be as small as possible,\n    # i.e., S_V = x.\n    # Then we find the maximum number of pairs (a_i, b_j) that can be formed\n    # such that a_i + b_j >= x.\n    # This count will be Vasya's worst rank (P+E).\n\n    a.sort()  # Sort a in non-decreasing order\n    b.sort()  # Sort b in non-decreasing order\n\n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            # This pair (a[ptr_a], b[ptr_b]) sums to at least x.\n            # We count this as one participant who scores >= x.\n            worst_rank += 1\n            ptr_a += 1  # Use this a_score\n            ptr_b -= 1  # Use this b_score\n        else:\n            # a[ptr_a] + b[ptr_b] < x.\n            # Since a[ptr_a] is the smallest remaining a_score and b[ptr_b] is the largest remaining b_score,\n            # a[ptr_a] cannot form a sum >= x with any b_score from b[0]...b[ptr_b].\n            # So, a[ptr_a] must be paired with some b_score to form a sum < x.\n            # We effectively discard a[ptr_a] for the purpose of forming sums >= x.\n            ptr_a += 1\n\n    print(best_rank, worst_rank)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best rank is always 1.\n    # Vasya can be assigned the highest score from tour 1 and highest from tour 2.\n    # This sum will be max(a) + max(b).\n    # The problem guarantees that at least one pair (a_i, b_j) sums to >= x.\n    # Therefore, max(a) + max(b) >= x.\n    # If Vasya gets max(a) + max(b), his score is at least as high as anyone else.\n    # By jury's choice, he can be placed first.\n    best_rank = 1\n\n    # Worst rank calculation:\n    # We want to maximize the number of people who score >= Vasya's score (S_V).\n    # Vasya's score S_V must be >= x.\n    # To maximize the count of people scoring >= S_V, we should choose S_V to be as small as possible,\n    # i.e., S_V = x.\n    # Then we find the maximum number of pairs (a_i, b_j) that can be formed\n    # such that a_i + b_j >= x.\n    # This count will be Vasya's worst rank (P+E).\n\n    a.sort()  # Sort a in non-decreasing order\n    b.sort()  # Sort b in non-decreasing order\n\n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            # This pair (a[ptr_a], b[ptr_b]) sums to at least x.\n            # We count this as one participant who scores >= x.\n            worst_rank += 1\n            ptr_a += 1  # Use this a_score\n            ptr_b -= 1  # Use this b_score\n        else:\n            # a[ptr_a] + b[ptr_b] < x.\n            # Since a[ptr_a] is the smallest remaining a_score and b[ptr_b] is the largest remaining b_score,\n            # a[ptr_a] cannot form a sum >= x with any b_score from b[0]...b[ptr_b].\n            # So, a[ptr_a] must be paired with some b_score to form a sum < x.\n            # We effectively discard a[ptr_a] for the purpose of forming sums >= x.\n            ptr_a += 1\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 3192,
        "thoughts_token_count": 6482
    }
}