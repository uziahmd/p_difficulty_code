{
    "start": 1758011747.383443,
    "end": 1758011825.34832,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:37 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Okay, here's my plan to tackle this competitive programming problem:**\n\nI need to find two non-overlapping vouchers whose combined duration equals a given value `x` while minimizing their total cost. If I can't find such a pair, I should output -1.  The inputs are:  `n` vouchers, and the target duration `x`. Each voucher is defined by its start day (`li`), end day (`ri`), and cost (`costi`).\n\nInitially, a brute-force approach of checking all possible pairs (O(n^2)) came to mind, but that's going to be too slow given the problem's constraints (n, x <= 2 * 10^5).  So, I need something more efficient, ideally linear or near-linear time (O(n) or O(n log n)).\n\nThe core challenge is the non-overlapping condition. Two vouchers are non-overlapping if one ends before the other starts.  This hints at processing the vouchers chronologically. Sorting by either start day (`li`) or end day (`ri`) seems like a good starting point.  I decided that, to efficiently find matching vouchers, it made sense to first process vouchers based on when they end.\n\nI'm thinking about two main scenarios: one voucher *ends* before another *starts*. The non-overlap also means a voucher's start can come *after* another has ended.\n\nI need to quickly search for vouchers.  A sweep-line algorithm seems suitable, using a data structure to look for the optimal cost for a voucher of a specific duration. The idea is to maintain some sort of data structure, like a segment tree or a hash map, that stores information about vouchers that have *already ended* and can serve as the first half of a valid pair.\n\nI'll process the vouchers chronologically (by end day or start day), keeping track of the minimum cost for each possible voucher duration. As I iterate through, for each new voucher `i`, I need to find another voucher `j` such that `duration_i + duration_j = x` and `cost_i + cost_j` is minimized.  The core will be a loop, updating a data structure representing the minimum cost of a voucher with any given duration *ending before* the current voucher starts.\n\nMy approach will involve sorting vouchers and then going through them in order of either start or end. I will use the current end date to build up my information.  For a given voucher, I'm looking for another voucher that ends *before* this voucher starts, which has a duration that sums to `x` (with this voucher). I'll keep an array (or a similar data structure) to track these minimal durations.\n\nTherefore, for each voucher, I'll store its end date. As I sweep through by start day, I can update the information of all the durations ending at the previous day. For example, if I'm at the date `3`, I can update my information based on all the end dates at `2`.\n\nThis data structure will be crucial. I'll need to update it as I encounter vouchers and query it efficiently to find the best matching voucher for the duration I need. The final output is this combined minimum cost, if I find one, and -1 otherwise.\n\nLet's summarize this:\n\n1.  **Preprocessing**: Sort the vouchers. I'll maintain two lists of vouchers, organized by start and end dates.\n2.  **Iterate**: Loop through the sorted vouchers based on their start date.\n3.  **Update**: Use the end date array information, the data of the prior iteration.\n4.  **Query**: Look for a voucher to match the one I'm currently looking at. The structure will store the min cost and the needed duration.\n5.  **Calculate & Output**: Calculate the combined cost, and maintain an overall minimum. Output the minimum cost, or -1 if no such pair exists.\n\nThe time complexity should be `O(n + x)` or something comparable which is efficient enough to pass the time limit. Space complexity will also be fine, likely `O(n + x)`. The key will be the `min_cost_for_duration` array. This all seems like the right approach. Now, let's code!\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet's denote a voucher by `(l, r, cost)`, where `l` is the departure day, `r` is the arrival day, and `cost` is its price. The duration of a voucher is `r - l + 1`.\n\nTwo vouchers `(l_i, r_i, cost_i)` and `(l_j, r_j, cost_j)` are non-overlapping if `r_i < l_j` or `r_j < l_i`. This means one voucher must end strictly before the other begins.\n\nWe need to find a pair `(i, j)` such that:\n1.  `r_i < l_j` (voucher `i` ends before voucher `j` starts) OR `r_j < l_i` (voucher `j` ends before voucher `i` starts).\n2.  `(r_i - l_i + 1) + (r_j - l_j + 1) = x`.\n3.  `cost_i + cost_j` is minimized.\n\nThe maximum possible day coordinate is `2 * 10^5`. Let's call this `MAX_COORD`. The total duration `x` is also up to `2 * 10^5`.\n\nWe can solve this problem using a sweep-line approach. We iterate through each day from `1` to `MAX_COORD`. At each `current_day`, we consider two types of events:\n1.  Vouchers that *end* on `current_day - 1`. These vouchers become available to be the *first* part of a non-overlapping pair with a voucher starting on or after `current_day`.\n2.  Vouchers that *start* on `current_day`. For each such voucher, we try to find a suitable *second* part of a non-overlapping pair among the vouchers that have already ended.\n\nTo implement this efficiently, we'll use a data structure to store the minimum cost for vouchers of a specific duration that have already ended.\n\n**Data Structures:**\n1.  `vouchers_by_start_day`: A list of lists (or dictionary mapping day to list of vouchers). `vouchers_by_start_day[d]` will store `(r, cost)` for all vouchers that start on day `d`.\n2.  `vouchers_by_end_day`: Similar to `vouchers_by_start_day`, but `vouchers_by_end_day[d]` will store `(l, cost)` for all vouchers that end on day `d`.\n3.  `min_cost_for_duration`: An array of size `x + 1`, initialized to `infinity`. `min_cost_for_duration[d]` will store the minimum cost of a voucher with duration `d` that has ended *strictly before* the `current_day`.\n\n**Algorithm:**\n\n1.  **Initialization**:\n    *   Set `MAX_DAY_COORD = 200000`.\n    *   Initialize `vouchers_by_start_day = [[] for _ in range(MAX_DAY_COORD + 1)]`.\n    *   Initialize `vouchers_by_end_day = [[] for _ in range(MAX_DAY_COORD + 1)]`.\n    *   Initialize `min_cost_for_duration = [float('inf')] * (x + 1)`.\n    *   Initialize `overall_min_cost = float('inf')`.\n\n2.  **Populate `vouchers_by_start_day` and `vouchers_by_end_day`**:\n    *   Read `n` vouchers `(l_i, r_i, cost_i)`.\n    *   For each voucher:\n        *   `vouchers_by_start_day[l_i].append((r_i, cost_i))`\n        *   `vouchers_by_end_day[r_i].append((l_i, cost_i))`\n\n3.  **Sweep-line Iteration**:\n    *   Iterate `current_day` from `1` to `MAX_DAY_COORD`:\n        *   **Step 1: Update `min_cost_for_duration` for vouchers ending on `current_day - 1`**:\n            *   For each `(l_prev, cost_prev)` in `vouchers_by_end_day[current_day - 1]`:\n                *   Calculate `d_prev = (current_day - 1) - l_prev + 1`.\n                *   If `d_prev <= x` (duration is within the relevant range for `x`):\n                    *   `min_cost_for_duration[d_prev] = min(min_cost_for_duration[d_prev], cost_prev)`.\n            This ensures that `min_cost_for_duration[d]` always holds the minimum cost of a voucher of duration `d` that ends *strictly before* `current_day`.\n\n        *   **Step 2: Process vouchers starting on `current_day`**:\n            *   For each `(r_curr, cost_curr)` in `vouchers_by_start_day[current_day]`:\n                *   Calculate `d_curr = r_curr - current_day + 1`.\n                *   If `d_curr < x` (we need another voucher to reach total duration `x`):\n                    *   Calculate `d_needed = x - d_curr`.\n                    *   If `1 <= d_needed <= x` (the required duration is valid):\n                        *   If `min_cost_for_duration[d_needed]` is not `float('inf')`:\n                            *   This means we found a voucher `j` (represented by `min_cost_for_duration[d_needed]`) that has duration `d_needed` and ended strictly before `current_day` (i.e., `r_j < l_i = current_day`).\n                            *   Update `overall_min_cost = min(overall_min_cost, cost_curr + min_cost_for_duration[d_needed])`.\n\n4.  **Result**:\n    *   If `overall_min_cost` is still `float('inf')`, print `-1`.\n    *   Otherwise, print `overall_min_cost`.\n\n**Complexity Analysis:**\n*   **Time Complexity**: `O(N + MAX_DAY_COORD + x)`.\n    *   Populating `vouchers_by_start_day` and `vouchers_by_end_day` takes `O(N)` time.\n    *   The sweep-line loop runs `MAX_DAY_COORD` times.\n    *   Inside the loop, the operations on `vouchers_by_end_day` and `vouchers_by_start_day` iterate through vouchers. The total number of iterations across all `current_day` for these parts is `O(N)`.\n    *   Updates and queries to `min_cost_for_duration` are `O(1)`.\n    *   Given `N, x, MAX_DAY_COORD <= 2 * 10^5`, this is efficient enough.\n\n*   **Space Complexity**: `O(N + MAX_DAY_COORD + x)`.\n    *   `vouchers_by_start_day` and `vouchers_by_end_day` store `N` voucher details in total, plus `MAX_DAY_COORD` lists.\n    *   `min_cost_for_duration` takes `O(x)` space.\n\nThis approach correctly handles the non-overlapping condition `r_j < l_i` and ensures that distinct vouchers are chosen by the chronological processing. The symmetric case `r_i < l_j` is covered implicitly because any pair `(i, j)` where `r_i < l_j` will eventually be found when `j` is the \"current\" voucher and `i` is an \"already ended\" voucher.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_DAY_COORD = 200000\n\n    # vouchers_by_start_day[day] stores a list of (r, cost) for vouchers starting on 'day'\n    vouchers_by_start_day = [[] for _ in range(MAX_DAY_COORD + 1)]\n    # vouchers_by_end_day[day] stores a list of (l, cost) for vouchers ending on 'day'\n    vouchers_by_end_day = [[] for _ in range(MAX_DAY_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_start_day[l].append((r, cost))\n        vouchers_by_end_day[r].append((l, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended strictly before the current_day in the sweep-line.\n    # Initialize with infinity.\n    min_cost_for_duration = [float('inf')] * (x + 1)\n\n    overall_min_cost = float('inf')\n\n    # Sweep through days from 1 to MAX_DAY_COORD\n    for current_day in range(1, MAX_DAY_COORD + 1):\n        # Step 1: Update min_cost_for_duration with vouchers that ended on (current_day - 1)\n        # These vouchers are now available to be the first part of a non-overlapping pair\n        # with any voucher starting on or after current_day.\n        if current_day > 1: # Only process if current_day-1 is a valid day\n            for l_prev, cost_prev in vouchers_by_end_day[current_day - 1]:\n                d_prev = (current_day - 1) - l_prev + 1\n                if 1 <= d_prev <= x: # Only consider durations relevant for sum x\n                    min_cost_for_duration[d_prev] = min(min_cost_for_duration[d_prev], cost_prev)\n\n        # Step 2: Process vouchers that start on current_day\n        # For each such voucher, try to find a suitable preceding voucher\n        for r_curr, cost_curr in vouchers_by_start_day[current_day]:\n            d_curr = r_curr - current_day + 1\n            \n            # We need to find a second voucher with duration d_needed such that d_curr + d_needed = x\n            # And the second voucher must have ended strictly before current_day.\n            if d_curr < x: # current voucher duration must be less than x\n                d_needed = x - d_curr\n                if 1 <= d_needed <= x: # The required duration must be positive and within bounds\n                    if min_cost_for_duration[d_needed] != float('inf'):\n                        # Found a valid pair: current voucher + a previously ended voucher\n                        overall_min_cost = min(overall_min_cost, cost_curr + min_cost_for_duration[d_needed])\n\n    if overall_min_cost == float('inf'):\n        print(\"-1\")\n    else:\n        print(overall_min_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_DAY_COORD = 200000\n\n    # vouchers_by_start_day[day] stores a list of (r, cost) for vouchers starting on 'day'\n    vouchers_by_start_day = [[] for _ in range(MAX_DAY_COORD + 1)]\n    # vouchers_by_end_day[day] stores a list of (l, cost) for vouchers ending on 'day'\n    vouchers_by_end_day = [[] for _ in range(MAX_DAY_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_start_day[l].append((r, cost))\n        vouchers_by_end_day[r].append((l, cost))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended strictly before the current_day in the sweep-line.\n    # Initialize with infinity.\n    min_cost_for_duration = [float('inf')] * (x + 1)\n\n    overall_min_cost = float('inf')\n\n    # Sweep through days from 1 to MAX_DAY_COORD\n    for current_day in range(1, MAX_DAY_COORD + 1):\n        # Step 1: Update min_cost_for_duration with vouchers that ended on (current_day - 1)\n        # These vouchers are now available to be the first part of a non-overlapping pair\n        # with any voucher starting on or after current_day.\n        if current_day > 1: # Only process if current_day-1 is a valid day\n            for l_prev, cost_prev in vouchers_by_end_day[current_day - 1]:\n                d_prev = (current_day - 1) - l_prev + 1\n                if 1 <= d_prev <= x: # Only consider durations relevant for sum x\n                    min_cost_for_duration[d_prev] = min(min_cost_for_duration[d_prev], cost_prev)\n\n        # Step 2: Process vouchers that start on current_day\n        # For each such voucher, try to find a suitable preceding voucher\n        for r_curr, cost_curr in vouchers_by_start_day[current_day]:\n            d_curr = r_curr - current_day + 1\n            \n            # We need to find a second voucher with duration d_needed such that d_curr + d_needed = x\n            # And the second voucher must have ended strictly before current_day.\n            if d_curr < x: # current voucher duration must be less than x\n                d_needed = x - d_curr\n                if 1 <= d_needed <= x: # The required duration must be positive and within bounds\n                    if min_cost_for_duration[d_needed] != float('inf'):\n                        # Found a valid pair: current voucher + a previously ended voucher\n                        overall_min_cost = min(overall_min_cost, cost_curr + min_cost_for_duration[d_needed])\n\n    if overall_min_cost == float('inf'):\n        print(\"-1\")\n    else:\n        print(overall_min_cost)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 2642,
        "thoughts_token_count": 7089
    }
}