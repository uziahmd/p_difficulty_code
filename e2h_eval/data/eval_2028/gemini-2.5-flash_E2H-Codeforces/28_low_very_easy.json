{
    "start": 1758285052.840455,
    "end": 1758285094.893764,
    "start-formatted": "2025-09-19 21:30 KST",
    "end-formatted": "2025-09-19 21:31 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**My Approach to Counting Beautiful Strings**\n\nOkay, so I need to write a Python script to count these \"beautiful strings\".  I've got the definition down: strings of '0's and '1's with a specific number of each, and they need to reduce to a single character after some modifications. The modification rule seems straightforward: it's a right-associative reduction based on an XNOR (or NOT XOR) operation on the last two characters.\n\nLet's break this down.  The core of the problem seems to be efficiently computing this reduction function, `R(s)`. I've already realized that the order of operations matters and that it's right-associative. Now, I need to figure out how to efficiently determine if a given string will reduce to a specific character.\n\nInitially, I tried to track the parity of 1s during the reduction, but that didn't pan out. There's probably a more direct way to analyze the effect of each operation. I could potentially simulate the reduction, but that could be computationally expensive for large strings.\n\nI'm thinking I should focus on this reduction function `f(x, y) = 1 - (x XOR y)`. It effectively tells us how the final character is determined, and I need to find a pattern or relationship between the initial string and the final result of the reduction. My expertise tells me there's probably a clever mathematical trick or combinatorial argument to reduce the complexity here. The modulus 1000000007 hints at a need for modular arithmetic to avoid overflow issues, so I will need to keep that in mind.\n",
    "response": "The problem asks us to count the number of binary strings with `n` zeros and `m` ones that can be reduced to a single character `g` (either '0' or '1') using a specific modification operation. The operation replaces the two last characters `xy` with a new character: '1' if `xy` is \"00\", and '0' otherwise (for \"01\", \"10\", \"11\"). This operation is equivalent to `NOT (x XOR y)`, or `1 - (x XOR y)` if '0' is 0 and '1' is 1.\n\nLet's analyze the reduction process. If we have a string `c_1 c_2 ... c_k`, the operation replaces `c_{k-1} c_k` with `f(c_{k-1}, c_k)`. Then `c_{k-2}` and this new character are replaced, and so on. This is a right-associative reduction: `f(c_1, f(c_2, ..., f(c_{k-1}, c_k)...))`.\n\nLet's denote the operation `f(x, y)` as `x XNOR y`.\nThe XNOR operation has a useful property: `x XNOR y = 1` if `x=y`, and `x XNOR y = 0` if `x != y`.\nThis is equivalent to `x = y`.\nSo, `f(x, y) = 1` if `x=y`, and `f(x, y) = 0` if `x!=y`.\n\nLet `R(c_1 c_2 ... c_k)` be the final character after reduction.\n`R(c_1 c_2 ... c_k) = c_1 XNOR (c_2 XNOR (... XNOR (c_{k-1} XNOR c_k)...))`.\n\nLet's examine the final character based on the number of '1's in the string.\nConsider the case where `g=1`. We want `R(s) = 1`.\nIf `m=0` (all zeros): `00...0`.\n`R(0) = 0`.\n`R(00) = 0 XNOR 0 = 1`.\n`R(000) = 0 XNOR (0 XNOR 0) = 0 XNOR 1 = 0`.\n`R(0000) = 0 XNOR (0 XNOR (0 XNOR 0)) = 0 XNOR (0 XNOR 1) = 0 XNOR 0 = 1`.\nIt appears that for strings of all zeros, `R(s) = 1` if `len(s)` is even, and `R(s) = 0` if `len(s)` is odd.\nSo, if `m=0`, `R(s)=1` implies `n` is even. If `n` is even, there is 1 such string (\"0...0\"). If `n` is odd, there are 0 such strings.\n\nIf `m > 0` (at least one '1'):\nLet's consider the effect of the first '1' from the right. Suppose `c_j` is the rightmost '1'.\n`s = c_1 ... c_{j-1} 1 0 ... 0` (with `k-j` zeros at the end).\n`R(s) = c_1 XNOR (c_2 XNOR (... XNOR (c_{j-1} XNOR (1 XNOR (0 XNOR (... XNOR 0)...)))...))`.\nThe subexpression `1 XNOR (0 XNOR (... XNOR 0)...)` where there are `k-j` zeros after the '1':\n- If `k-j = 0` (the '1' is the last character): `1`.\n- If `k-j = 1`: `1 XNOR 0 = 0`.\n- If `k-j = 2`: `1 XNOR (0 XNOR 0) = 1 XNOR 1 = 0`.\n- If `k-j = 3`: `1 XNOR (0 XNOR (0 XNOR 0)) = 1 XNOR (0 XNOR 1) = 1 XNOR 0 = 0`.\nIt appears that for `1 0 ... 0` (where `k-j` is the count of trailing zeros), the result is '1' if `k-j=0`, and '0' if `k-j > 0`.\nThis means if there's at least one '1' and it's followed by at least one '0', the result is '0'.\nMore generally, if `m > 0` and the last character is '0', then `R(s) = 0`.\nProof: If `c_k = 0`, then `... XNOR (c_{k-1} XNOR 0)`.\nIf `c_{k-1} = 0`, then `0 XNOR 0 = 1`.\nIf `c_{k-1} = 1`, then `1 XNOR 0 = 0`.\nThis doesn't seem to simplify easily.\n\nLet's use a known property of XNOR: `a XNOR b XNOR c = (a XNOR b) XNOR c`. This is not true. XNOR is not associative.\nThe operation `f(x,y)` is `1 - (x XOR y)`.\nLet `s_k` be the result of reducing `c_1 ... c_k`.\n`s_k = 1 - (c_1 XOR (1 - (c_2 XOR (... (1 - (c_{k-1} XOR c_k))...))))`. This is complicated.\n\nLet's look at the problem constraints. `n, m <= 10^5`.\nThis implies we need a combinatorial solution, likely involving combinations `C(N, K)`.\n\nLet's re-examine the operation `f(x, y)`. It's `x == y`.\n`R(c_1 c_2 ... c_k)` is `c_1 == (c_2 == (... == (c_{k-1} == c_k)...))`.\nThis is equivalent to `c_1 == c_2 == ... == c_k` if `k` is odd, and `NOT (c_1 == c_2 == ... == c_k)` if `k` is even.\nThis is incorrect. For example, `000` -> `0 == (0 == 0)` -> `0 == 1` -> `0`.\n`0000` -> `0 == (0 == (0 == 0))` -> `0 == (0 == 1)` -> `0 == 0` -> `1`.\nThis is `c_1 == c_2 == ... == c_k` if `k-1` is even (i.e., `k` is odd).\nAnd `NOT (c_1 == c_2 == ... == c_k)` if `k-1` is odd (i.e., `k` is even).\n\nThis `==` operation is not standard boolean equality. It's the `XNOR` operation.\n`c_1 XNOR (c_2 XNOR (... XNOR (c_{k-1} XNOR c_k)...))`\nLet's denote `XNOR` as `~`.\n`c_1 ~ (c_2 ~ (... ~ (c_{k-1} ~ c_k)...))`\nThis is equivalent to `c_1 XOR c_2 XOR ... XOR c_k XOR (k-1) mod 2`.\nLet's test this.\n`k=1`: `c_1`. Formula: `c_1 XOR 0 = c_1`. Correct.\n`k=2`: `c_1 ~ c_2`. Formula: `c_1 XOR c_2 XOR 1`. Correct, as `x ~ y = NOT (x XOR y)`.\n`k=3`: `c_1 ~ (c_2 ~ c_3)`. Formula: `c_1 XOR c_2 XOR c_3 XOR (3-1) mod 2 = c_1 XOR c_2 XOR c_3`.\nTest `000`: `0 ~ (0 ~ 0) = 0 ~ 1 = 0`. Formula: `0 XOR 0 XOR 0 = 0`. Correct.\nTest `001`: `0 ~ (0 ~ 1) = 0 ~ 0 = 1`. Formula: `0 XOR 0 XOR 1 = 1`. Correct.\nTest `010`: `0 ~ (1 ~ 0) = 0 ~ 0 = 1`. Formula: `0 XOR 1 XOR 0 = 1`. Correct.\nTest `111`: `1 ~ (1 ~ 1) = 1 ~ 0 = 0`. Formula: `1 XOR 1 XOR 1 = 1`. Incorrect.\n\nMy formula `c_1 XOR c_2 XOR ... XOR c_k XOR (k-1) mod 2` is wrong.\nLet's use the property that `x XNOR y = 1 - (x XOR y)`.\nLet `S_k = R(c_1 ... c_k)`.\n`S_1 = c_1`\n`S_2 = 1 - (c_1 XOR c_2)`\n`S_3 = 1 - (c_1 XOR S_2) = 1 - (c_1 XOR (1 - (c_2 XOR c_3)))`\n`S_4 = 1 - (c_1 XOR S_3) = 1 - (c_1 XOR (1 - (c_2 XOR (1 - (c_3 XOR c_4)))))`\n\nThis is `S_k = 1 - (c_1 XOR S_{k-1})` for `k > 1`.\n`S_k = c_1` if `k=1`.\n`S_k = c_1 XOR S_{k-1} XOR 1` for `k > 1`.\nLet `P_k = c_1 XOR c_2 XOR ... XOR c_k`.\n`S_1 = c_1`\n`S_2 = c_1 XOR c_2 XOR 1`\n`S_3 = c_1 XOR S_2 XOR 1 = c_1 XOR (c_1 XOR c_2 XOR 1) XOR 1 = c_2 XOR 0 = c_2`\n`S_4 = c_1 XOR S_3 XOR 1 = c_1 XOR c_2 XOR 1`\n`S_5 = c_1 XOR S_4 XOR 1 = c_1 XOR (c_1 XOR c_2 XOR 1) XOR 1 = c_2`\n\nSo, the pattern for `S_k` is:\n`S_k = c_1` if `k=1`\n`S_k = c_1 XOR c_2 XOR 1` if `k` is even and `k >= 2`\n`S_k = c_2` if `k` is odd and `k >= 3`\n\nNow we can determine the final character `g` based on `n`, `m`, and the first two characters `c_1`, `c_2`. The total length is `L = n+m`.\n\nCase 1: `L = 1`.\n- If `n=1, m=0` (string \"0\"): `S_1 = 0`.\n- If `n=0, m=1` (string \"1\"): `S_1 = 1`.\n\nCase 2: `L` is even and `L >= 2`.\n`g = c_1 XOR c_2 XOR 1`.\n- If `g=0`: We need `c_1 XOR c_2 = 1`. This means `c_1 != c_2`.\n  - Strings must start with \"01\" or \"10\".\n  - Number of '0's is `n`, number of '1's is `m`.\n  - If `c_1=0, c_2=1`: We need `n-1` zeros and `m-1` ones for the remaining `L-2` characters. Number of ways: `C(L-2, n-1)`. (Requires `n >= 1, m >= 1`).\n  - If `c_1=1, c_2=0`: We need `n-1` zeros and `m-1` ones for the remaining `L-2` characters. Number of ways: `C(L-2, m-1)`. (Requires `n >= 1, m >= 1`).\n  - Total for `g=0`: `C(L-2, n-1) + C(L-2, m-1)` if `n,m >= 1`.\n    - If `n=0` or `m=0`, then `c_1 != c_2` is impossible. `n=0` implies all '1's, `m=0` implies all '0's.\n      - If `n=L, m=0`: string is \"00...0\". `c_1=0, c_2=0`. `c_1 XOR c_2 XOR 1 = 0 XOR 0 XOR 1 = 1`. So `g=1`.\n      - If `n=0, m=L`: string is \"11...1\". `c_1=1, c_2=1`. `c_1 XOR c_2 XOR 1 = 1 XOR 1 XOR 1 = 1`. So `g=1`.\n      - Thus, if `n=0` or `m=0`, `g` must be '1'. So 0 ways for `g=0`.\n- If `g=1`: We need `c_1 XOR c_2 = 0`. This means `c_1 = c_2`.\n  - Strings must start with \"00\" or \"11\".\n  - If `c_1=0, c_2=0`: We need `n-2` zeros and `m` ones for the remaining `L-2` characters. Number of ways: `C(L-2, n-2)`. (Requires `n >= 2`).\n  - If `c_1=1, c_2=1`: We need `n` zeros and `m-2` ones for the remaining `L-2` characters. Number of ways: `C(L-2, m-2)`. (Requires `m >= 2`).\n  - Total for `g=1`: `C(L-2, n-2) + C(L-2, m-2)`.\n    - If `n=1, m=L-1`: string is \"01...1\" or \"101...1\" or \"11...10\".\n      - If `c_1=0, c_2=0`: Impossible if `n < 2`.\n      - If `c_1=1, c_2=1`: Possible if `m >= 2`. `C(L-2, n) = C(L-2, 1) = L-2`.\n    - If `n=L, m=0`: string is \"00...0\". `c_1=0, c_2=0`. `C(L-2, L-2) = 1`.\n    - If `n=0, m=L`: string is \"11...1\". `c_1=1, c_2=1`. `C(L-2, 0) = 1`.\n\nCase 3: `L` is odd and `L >= 3`.\n`g = c_2`.\n- If `g=0`: We need `c_2 = 0`.\n  - Strings must have `c_2=0`.\n  - If `c_1=0, c_2=0`: We need `n-2` zeros and `m` ones for `L-2` characters. Ways: `C(L-2, n-2)`. (Requires `n >= 2`).\n  - If `c_1=1, c_2=0`: We need `n-1` zeros and `m-1` ones for `L-2` characters. Ways: `C(L-2, n-1)`. (Requires `n >= 1, m >= 1`).\n  - Total for `g=0`: `C(L-2, n-2) + C(L-2, n-1)`.\n    - If `n=1, m=L-1`: string \"01...1\" or \"101...1\". `c_2=0` implies `c_1=1, c_2=0`. `C(L-2, 0) = 1`.\n    - If `n=L, m=0`: string \"00...0\". `c_1=0, c_2=0`. `C(L-2, L-2) = 1`.\n    - If `n=0, m=L`: string \"11...1\". `c_2=0` is impossible. 0 ways.\n- If `g=1`: We need `c_2 = 1`.\n  - Strings must have `c_2=1`.\n  - If `c_1=0, c_2=1`: We need `n-1` zeros and `m-1` ones for `L-2` characters. Ways: `C(L-2, n-1)`. (Requires `n >= 1, m >= 1`).\n  - If `c_1=1, c_2=1`: We need `n` zeros and `m-2` ones for `L-2` characters. Ways: `C(L-2, m-2)`. (Requires `m >= 2`).\n  - Total for `g=1`: `C(L-2, n-1) + C(L-2, m-2)`.\n    - If `n=1, m=L-1`: string \"01...1\" or \"101...1\". `c_2=1` implies `c_1=0, c_2=1` or `c_1=1, c_2=1`.\n      - `c_1=0, c_2=1`: `C(L-2, 0) = 1`.\n      - `c_1=1, c_2=1`: `C(L-2, m-2) = C(L-2, L-3) = L-2`.\n      - Total `1 + (L-2) = L-1`.\n    - If `n=L, m=0`: string \"00...0\". `c_2=1` is impossible. 0 ways.\n    - If `n=0, m=L`: string \"11...1\". `c_1=1, c_2=1`. `C(L-2, 0) = 1`.\n\nLet's summarize the logic for `L = n+m`.\n`MOD = 1000000007`. We need to compute combinations `C(N, K) = N! / (K! * (N-K)!) % MOD`.\nWe can precompute factorials and inverse factorials modulo `MOD`.\n\nHelper function `nCr_mod_p(N, K)`:\n- If `K < 0` or `K > N`, return 0.\n- If `K == 0` or `K == N`, return 1.\n- If `K > N // 2`, `K = N - K`. (Optimization for smaller K).\n- `fact[N] * inv_fact[K] % MOD * inv_fact[N-K] % MOD`.\n\nSpecial case `n=0, m=0` is forbidden by `n+m >= 1`.\n\n**Final Logic:**\n\n1.  **Initialize:** `fact`, `inv_fact` arrays up to `N_MAX = 2 * 10^5` (max `L-2` is `2*10^5 - 2`).\n2.  **Read `n, m, g`**.\n3.  **`L = n + m`**.\n4.  **`ans = 0`**.\n\n5.  **Case `L = 1`:**\n    - If `n=1, m=0`: string \"0\". `S_1 = 0`. If `g=0`, `ans = 1`. Else `ans = 0`.\n    - If `n=0, m=1`: string \"1\". `S_1 = 1`. If `g=1`, `ans = 1`. Else `ans = 0`.\n\n6.  **Case `L >= 2` and `L` is even:** (`g = c_1 XOR c_2 XOR 1`)\n    - If `g=0`:\n        - We need `c_1 XOR c_2 = 1` (i.e., `c_1 != c_2`).\n        - `ans = (nCr(L-2, n-1) + nCr(L-2, m-1)) % MOD`.\n        - Note: `nCr(N, K)` handles `K<0` or `K>N` by returning 0, so no extra checks needed for `n-1` or `m-1`.\n    - If `g=1`:\n        - We need `c_1 XOR c_2 = 0` (i.e., `c_1 = c_2`).\n        - `ans = (nCr(L-2, n-2) + nCr(L-2, m-2)) % MOD`.\n\n7.  **Case `L >= 3` and `L` is odd:** (`g = c_2`)\n    - If `g=0`:\n        - We need `c_2 = 0`.\n        - `ans = (nCr(L-2, n-2) + nCr(L-2, n-1)) % MOD`.\n    - If `g=1`:\n        - We need `c_2 = 1`.\n        - `ans = (nCr(L-2, n-1) + nCr(L-2, m-2)) % MOD`.\n\n8.  **Print `ans`**.\n\nLet's double check the `L >= 2` and `L` is even case for `g=0`.\n`ans = (nCr(L-2, n-1) + nCr(L-2, m-1)) % MOD`.\nExample: `n=1, m=1, g=0`. `L=2`. Even. `g=0`.\n`ans = (nCr(0, 0) + nCr(0, 0)) % MOD = (1 + 1) % MOD = 2`. Correct (\"01\", \"10\").\n\nExample: `n=2, m=2, g=0`. `L=4`. Even. `g=0`.\n`ans = (nCr(2, 1) + nCr(2, 1)) % MOD = (2 + 2) % MOD = 4`. Correct (\"0011\", \"1001\", \"1010\", \"1100\").\n\nExample: `n=1, m=1, g=1`. `L=2`. Even. `g=1`.\n`ans = (nCr(0, -1) + nCr(0, -1)) % MOD = (0 + 0) % MOD = 0`. Correct.\n\nThis logic seems sound. The `nCr` function will correctly return 0 for invalid arguments like `n-1` or `m-1` being negative.\n\n```python\nimport sys\n\n# Modulo constant\nMOD = 1000000007\n\n# Max value for n+m, used for precomputing factorials\nMAX_N_M = 2 * 10**5\n\n# Precompute factorials and inverse factorials\nfact = [1] * (MAX_N_M + 1)\ninv_fact = [1] * (MAX_N_M + 1)\n\ndef precompute_factorials():\n    for i in range(1, MAX_N_M + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_N_M] = pow(fact[MAX_N_M], MOD - 2, MOD) # Fermat's Little Theorem for modular inverse\n    for i in range(MAX_N_M - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r > n // 2:\n        r = n - r\n    \n    numerator = fact[n]\n    denominator = (inv_fact[r] * inv_fact[n-r]) % MOD\n    \n    return (numerator * denominator) % MOD\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    precompute_factorials()\n\n    L = n + m\n    ans = 0\n\n    if L == 1:\n        if n == 1: # String is \"0\"\n            if g == 0:\n                ans = 1\n            else:\n                ans = 0\n        else: # String is \"1\" (m == 1)\n            if g == 1:\n                ans = 1\n            else:\n                ans = 0\n    elif L % 2 == 0: # L is even, L >= 2. Result is c_1 XOR c_2 XOR 1\n        if g == 0: # Need c_1 XOR c_2 = 1 (c_1 != c_2)\n            # Case \"01...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 1)) % MOD\n            # Case \"10...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, m - 1)) % MOD\n        else: # g == 1. Need c_1 XOR c_2 = 0 (c_1 == c_2)\n            # Case \"00...\" (n-2 zeros, m ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 2)) % MOD\n            # Case \"11...\" (n zeros, m-2 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, m - 2)) % MOD\n    else: # L is odd, L >= 3. Result is c_2\n        if g == 0: # Need c_2 = 0\n            # Case \"00...\" (n-2 zeros, m ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 2)) % MOD\n            # Case \"10...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 1)) % MOD\n        else: # g == 1. Need c_2 = 1\n            # Case \"01...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 1)) % MOD\n            # Case \"11...\" (n zeros, m-2 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, m - 2)) % MOD\n            \n    sys.stdout.write(str(ans) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\n# Modulo constant\nMOD = 1000000007\n\n# Max value for n+m, used for precomputing factorials\nMAX_N_M = 2 * 10**5\n\n# Precompute factorials and inverse factorials\nfact = [1] * (MAX_N_M + 1)\ninv_fact = [1] * (MAX_N_M + 1)\n\ndef precompute_factorials():\n    for i in range(1, MAX_N_M + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_N_M] = pow(fact[MAX_N_M], MOD - 2, MOD) # Fermat's Little Theorem for modular inverse\n    for i in range(MAX_N_M - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    if r > n // 2:\n        r = n - r\n    \n    numerator = fact[n]\n    denominator = (inv_fact[r] * inv_fact[n-r]) % MOD\n    \n    return (numerator * denominator) % MOD\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    precompute_factorials()\n\n    L = n + m\n    ans = 0\n\n    if L == 1:\n        if n == 1: # String is \"0\"\n            if g == 0:\n                ans = 1\n            else:\n                ans = 0\n        else: # String is \"1\" (m == 1)\n            if g == 1:\n                ans = 1\n            else:\n                ans = 0\n    elif L % 2 == 0: # L is even, L >= 2. Result is c_1 XOR c_2 XOR 1\n        if g == 0: # Need c_1 XOR c_2 = 1 (c_1 != c_2)\n            # Case \"01...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 1)) % MOD\n            # Case \"10...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, m - 1)) % MOD\n        else: # g == 1. Need c_1 XOR c_2 = 0 (c_1 == c_2)\n            # Case \"00...\" (n-2 zeros, m ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 2)) % MOD\n            # Case \"11...\" (n zeros, m-2 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, m - 2)) % MOD\n    else: # L is odd, L >= 3. Result is c_2\n        if g == 0: # Need c_2 = 0\n            # Case \"00...\" (n-2 zeros, m ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 2)) % MOD\n            # Case \"10...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 1)) % MOD\n        else: # g == 1. Need c_2 = 1\n            # Case \"01...\" (n-1 zeros, m-1 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, n - 1)) % MOD\n            # Case \"11...\" (n zeros, m-2 ones for L-2 chars)\n            ans = (ans + nCr_mod_p(L - 2, m - 2)) % MOD\n            \n    sys.stdout.write(str(ans) + '\\n')\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 6489,
        "thoughts_token_count": 834
    }
}