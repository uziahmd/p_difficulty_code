{
    "start": 1758284968.1548302,
    "end": 1758285010.9586024,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Problem Breakdown and Strategic Thinking**\n\nOkay, so I'm tackling a competitive programming problem. My goal is to figure out the smallest number of nodes (`n`) needed for a specific kind of directed graph, and then maximize the \"unidirectional pairs\" within that graph.  Let me unpack this...\n\nFirst, I need to understand what \"p-reachable\" means.  It's all about pairs of nodes that can reach each other bidirectionally.  This is directly related to Strongly Connected Components (SCCs). If two nodes are in the same SCC, they are reachable from each other, and the number of such pairs with u < v is `s_i * (s_i - 1) / 2` where `s_i` is the size of the SCC. The total number of these 'p-reachable' pairs across the whole graph must equal `p`.\n\nNow, the \"unidirectional pair\" concept is key to the maximization part. This is an ordered pair where there is a path from `u` to `v`, but not from `v` to `u` – meaning `u` and `v` are in different SCCs, and there's an edge in the condensation graph.  I need to maximize the count of these unidirectional pairs in my final solution.\n\nMy strategy to minimize `n` is to think about the sizes of the SCCs. If I fix `p` (the number of reachable pairs), I want to minimize the total number of nodes in the graph `n`. Because `s_i * (s_i - 1) / 2` grows quadratically, I'm thinking the optimal strategy is to have fewer, but larger SCCs, instead of many small ones.  For example, with `p=3`, a single SCC of size 3 (n=3) is the best solution, while with `p=6` an SCC of size 4 (n=4) is preferred to two SCCs of size 2.\n\nSo, I need to figure out how to best \"partition\" `p` into `s_i * (s_i - 1) / 2` to minimize the overall sum of the `s_i` values. This will give me `n`. Once I have `n` and the sizes of my SCCs, I can reason about the maximum number of unidirectional pairs. I'm guessing that having many edges pointing from bigger SCCs to smaller SCCs will be important to maximize the unidirectional pairs.  I need to explore this connection further and develop an algorithm.\n",
    "response": "The problem asks us to find two values:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. The maximum number of unidirectional pairs among all `p`-reachable graphs with this minimum `n`.\n\nLet's break down the definitions:\n\n**Reachable from each other:** An ordered pair `(u, v)` with `u < v` is reachable from each other if there is a path from `u` to `v` and a path from `v` to `u`. This means `u` and `v` belong to the same Strongly Connected Component (SCC).\nIf an SCC has `S` nodes, then any two distinct nodes `u, v` within this SCC are reachable from each other. The number of such pairs `(u, v)` with `u < v` is `S * (S - 1) / 2`.\nLet the graph have `k` SCCs with sizes `s_1, s_2, ..., s_k`. The total number of nodes is `n = s_1 + s_2 + ... + s_k`.\nThe condition for a `p`-reachable graph is:\n`p = sum_{i=1 to k} (s_i * (s_i - 1) / 2)`\n\n**Unidirectional pair:** An ordered pair `(u, v)` is unidirectional if `u != v`, there's a path from `u` to `v`, and there are no paths from `v` to `u`. This means `u` and `v` are in different SCCs, and there's a path from the SCC of `u` to the SCC of `v` in the condensation graph (DAG of SCCs).\n\n---\n\n**Part 1: Minimum number of nodes `n`**\n\nWe want to minimize `n = sum(s_i)` subject to `p = sum(s_i * (s_i - 1) / 2)`.\nLet `f(S) = S * (S - 1) / 2`. This function is convex and grows quadratically. To minimize `sum(s_i)` for a fixed `sum(f(s_i))`, it is generally optimal to use as few `s_i` values as possible, and make them as large as possible. This means we should try to satisfy `p` using one large SCC, or a few large SCCs.\n\nWe can use a greedy approach to find the `s_i` values.\nStart with `p_rem = p`.\nIteratively find the largest `S` such that `S * (S - 1) / 2 <= p_rem`.\nAdd this `S` to our list of SCC sizes, subtract `S * (S - 1) / 2` from `p_rem`, and continue until `p_rem` becomes 0.\nThe sum of these `S` values will give the minimum `n`.\n\nLet's analyze `f(S) = S * (S - 1) / 2`.\n`S^2 - S - 2p <= 0`.\nSo `S <= (1 + sqrt(1 + 8p)) / 2`.\nWe can precompute `S_max[p']` for all `p'` up to `p`.\nFor `p=0`, `n=0`.\nFor `p > 0`:\nInitialize `n_min = 0`.\nWhile `p > 0`:\n  Find the largest `S` such that `S * (S - 1) / 2 <= p`.\n  This `S` can be found by solving `S(S-1)/2 = p_target` for `S`. `S^2 - S - 2p_target = 0`. `S = (1 + sqrt(1 + 8p_target))/2`.\n  So `S = floor((1 + sqrt(1 + 8p))) / 2`.\n  Add `S` to `n_min`.\n  Subtract `S * (S - 1) / 2` from `p`.\nThis greedy strategy works because `f(S)` is convex. If we have `p_rem` and choose `S_1` such that `f(S_1) <= p_rem`, then we are left with `p_rem - f(S_1)`. If we could have chosen `S_1'` such that `f(S_1') < f(S_1)` and `f(S_1') + f(S_2') = p_rem` and `S_1' + S_2' < S_1 + S_2` (where `S_2` is from the remaining `p_rem - f(S_1)`), this would contradict the greedy choice. The largest possible `S` for a given `p_rem` always minimizes `n` for that `p_rem`.\n\nExample: `p=3`.\n`S = floor((1 + sqrt(1 + 8*3))/2) = floor((1 + sqrt(25))/2) = floor((1+5)/2) = 3`.\n`n_min = 3`. `p = 3 - (3*2/2) = 0`.\nResult: `n_min = 3`.\n\nExample: `p=4`.\n`S = floor((1 + sqrt(1 + 8*4))/2) = floor((1 + sqrt(33))/2) = floor((1+5.74)/2) = 3`.\n`n_min = 3`. `p = 4 - (3*2/2) = 1`.\n`S = floor((1 + sqrt(1 + 8*1))/2) = floor((1 + sqrt(9))/2) = floor((1+3)/2) = 2`.\n`n_min = 3 + 2 = 5`. `p = 1 - (2*1/2) = 0`.\nResult: `n_min = 5`.\n\nThe `s_i` values determined by this greedy strategy are `s_1 >= s_2 >= ... >= s_k`.\nNote that `s_i=1` contributes `0` to `p`. If `p_rem` becomes `0` and we have `s_i=1` in our list, it means we could have reduced `n` by `1` and still had `p_rem=0`. So we only consider `s_i >= 2`.\n\nThe minimum `n` is found by this greedy approach. Let the resulting SCC sizes be `s_1, s_2, ..., s_k` (all `s_i >= 2`). The total minimum nodes is `n_min = sum(s_i)`.\n\n---\n\n**Part 2: Maximum number of unidirectional pairs**\n\nA unidirectional pair `(u, v)` exists if `u` and `v` are in different SCCs, say `SCC_U` and `SCC_V`, and there's a path from `SCC_U` to `SCC_V` but not from `SCC_V` to `SCC_U`.\nTo maximize unidirectional pairs, we want to maximize paths between different SCCs in the condensation graph. The maximum number of such paths occurs when the condensation graph is a \"line\" or \"chain\" of SCCs.\nIf we have `k` SCCs, say `C_1, C_2, ..., C_k` with sizes `s_1, s_2, ..., s_k` respectively, we can arrange them in a topological order: `C_1 -> C_2 -> ... -> C_k`.\nThis means we add edges from every node in `C_i` to every node in `C_{i+1}`. More simply, just one edge from `C_i` to `C_{i+1}` (e.g., from an arbitrary node in `C_i` to an arbitrary node in `C_{i+1}`) is enough to establish reachability.\nIf we have `C_1 -> C_2 -> ... -> C_k`, then for any `i < j`, there is a path from `C_i` to `C_j`.\nThe number of unidirectional pairs from `C_i` to `C_j` (where `i < j`) is `s_i * s_j`.\nThe total number of unidirectional pairs is `sum_{1 <= i < j <= k} (s_i * s_j)`.\n\nThis sum is `( (sum s_i)^2 - sum (s_i^2) ) / 2`.\nWe know `sum s_i = n_min`.\nSo, the number of unidirectional pairs is `(n_min^2 - sum(s_i^2)) / 2`.\nTo maximize this value, we need to minimize `sum(s_i^2)`.\nGiven `sum(s_i) = n_min`, to minimize `sum(s_i^2)`, the `s_i` values should be as close to each other as possible.\n\nHowever, the `s_i` values are *fixed* by the greedy strategy for minimizing `n`. We cannot change them.\nSo, the maximum number of unidirectional pairs for *these specific* `s_i` values is simply `sum_{1 <= i < j <= k} (s_i * s_j)`.\n\nLet's re-evaluate the problem statement carefully: \"among all such `p`-reachable directed graphs with the minimum number of nodes, let `G` denote a graph which maximizes the number of unidirectional pairs of nodes.\"\nThis means we first find `n_min`. Then, we consider *all* possible sets of SCC sizes `s_1, ..., s_k` such that `sum(s_i) = n_min` and `sum(s_i * (s_i - 1) / 2) = p`.\nAmong these sets of `s_i`, we choose one that minimizes `sum(s_i^2)`.\n\nConsider the greedy strategy for `n_min`: it produces `s_1, s_2, ..., s_k` (all `s_i >= 2`).\nLet `N_0 = n_min`.\nLet `P_0 = p`.\nThe greedy choice `s_1, ..., s_k` gives `sum(s_i) = N_0` and `sum(s_i(s_i-1)/2) = P_0`.\nCould there be another set of SCC sizes `s'_1, ..., s'_m` such that `sum(s'_j) = N_0` and `sum(s'_j(s'_j-1)/2) = P_0`, but `sum((s'_j)^2)` is smaller than `sum(s_i^2)`?\nThis is a standard optimization problem: given `sum(x_i) = C1` and `sum(x_i^2) = C2`, find `x_i`.\nThe greedy strategy for `n_min` uses `s_i` values that are as \"spread out\" as possible to achieve `p` with minimum `n`. For example, `p=4`, greedy gives `s={3,2}`, `n=5`. `sum(s_i^2) = 3^2 + 2^2 = 9+4=13`.\nAnother way to get `n=5` and `p=4`?\n`s_i * (s_i - 1) / 2` values are `0, 1, 3, 6, 10, ...` for `s_i = 1, 2, 3, 4, 5, ...`.\nWe need `sum(f(s_i)) = 4` and `sum(s_i) = 5`.\nPossible compositions for `p=4`:\n1. `f(S)=4` has no integer solution for `S`.\n2. `f(S_1) + f(S_2) = 4`:\n   - `3+1`: `S_1=3, S_2=2`. Sum of nodes = `3+2=5`. This is the greedy solution. `sum(s_i^2) = 3^2+2^2=13`.\n   - `1+1+1+1`: `S_1=2, S_2=2, S_3=2, S_4=2`. Sum of nodes = `2+2+2+2=8`. This is not `n_min=5`.\n3. `f(S_1) + f(S_2) + f(S_3) = 4`:\n   - `1+1+1+1`: `S_1=2, S_2=2, S_3=2, S_4=2`. Sum of nodes = `8`.\nIt seems the greedy strategy for `n_min` uniquely determines the set of `s_i` values (up to order). If it does, then `sum(s_i^2)` is also fixed.\n\nLet's verify the uniqueness of the `s_i` set.\nSuppose there are two sets `A = {a_1, ..., a_k}` and `B = {b_1, ..., b_m}` such that `sum(f(a_i)) = p`, `sum(f(b_j)) = p`, `sum(a_i) = N_0`, `sum(b_j) = N_0`.\nAssume elements are sorted in descending order.\nThe greedy algorithm picks `a_1 = floor((1+sqrt(1+8p))/2)`.\nIf `b_1 < a_1`, then `f(b_1) < f(a_1)`. To make up for `p`, `B` must contain more elements or larger subsequent elements. This would tend to increase `sum(b_j)`, contradicting `sum(b_j) = N_0`.\nIf `b_1 > a_1`, then `f(b_1) > f(a_1)`. This would mean `p_rem` for `B` is smaller than for `A`, and `N_0 - b_1` is smaller than `N_0 - a_1`.\nThe greedy strategy for minimizing `sum(s_i)` for a fixed `p` is to always pick the largest possible `s_i`. This strategy indeed yields a unique set of `s_i` values (up to ordering).\nTherefore, `sum(s_i^2)` is also uniquely determined by the `s_i` values found by the greedy algorithm.\n\nSo, the algorithm is:\n1. Initialize `n_min = 0`, `sum_s_sq = 0`.\n2. Create an empty list `s_values`.\n3. While `p > 0`:\n   a. Calculate `S = floor((1 + sqrt(1 + 8p)) / 2)`.\n   b. If `S < 2`, it means `p` is `0` or `1`. If `p=0`, loop terminates. If `p=1`, `S=2` is the smallest `S` that contributes `1` to `p`. So `S` must be at least 2. If `p=1`, `S=2`.\n   c. Add `S` to `n_min`.\n   d. Add `S*S` to `sum_s_sq`.\n   e. Subtract `S * (S - 1) / 2` from `p`.\n4. The first output is `n_min`.\n5. The second output is `(n_min * n_min - sum_s_sq) / 2`.\n\nLet's test with `p=0`:\n`n_min = 0`, `sum_s_sq = 0`.\nLoop condition `p > 0` is false.\nOutput `0 0`. Correct.\n\nLet's test with `p=3`:\n`n_min = 0`, `sum_s_sq = 0`.\n1. `p=3`. `S = floor((1 + sqrt(1 + 24))/2) = 3`.\n   `n_min = 0 + 3 = 3`.\n   `sum_s_sq = 0 + 3*3 = 9`.\n   `p = 3 - (3*2/2) = 0`.\nLoop terminates.\nOutput: `n_min = 3`.\nMax unidirectional pairs = `(3*3 - 9)/2 = (9-9)/2 = 0`.\nResult: `3 0`. Correct.\n\nLet's test with `p=4`:\n`n_min = 0`, `sum_s_sq = 0`.\n1. `p=4`. `S = floor((1 + sqrt(1 + 32))/2) = floor((1 + 5.74)/2) = 3`.\n   `n_min = 0 + 3 = 3`.\n   `sum_s_sq = 0 + 3*3 = 9`.\n   `p = 4 - (3*2/2) = 1`.\n2. `p=1`. `S = floor((1 + sqrt(1 + 8))/2) = floor((1 + 3)/2) = 2`.\n   `n_min = 3 + 2 = 5`.\n   `sum_s_sq = 9 + 2*2 = 13`.\n   `p = 1 - (2*1/2) = 0`.\nLoop terminates.\nOutput: `n_min = 5`.\nMax unidirectional pairs = `(5*5 - 13)/2 = (25-13)/2 = 12/2 = 6`.\nResult: `5 6`. Correct.\n\nThe maximum value of `p` is `2 * 10^5`.\n`1 + 8p` can be up to `1 + 16 * 10^5 = 1.6 * 10^6`.\n`sqrt(1.6 * 10^6)` is about `1265`.\n`S` will be around `1265/2 = 632`.\nThe number of iterations will be small, as `p` decreases quadratically.\n`n_min` can be at most `p` (if all `s_i=2`, `p` is `k`). So `n_min` can be up to `2 * 10^5`.\n`n_min^2` can be `(2 * 10^5)^2 = 4 * 10^{10}`. This fits in a standard 64-bit integer type (Python integers handle arbitrary size).\n\nThis approach seems robust and correct.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    sum_s_squared = 0\n\n    # We need to find s_i such that sum(s_i * (s_i - 1) / 2) = p\n    # and sum(s_i) is minimized.\n    # The greedy strategy is to always pick the largest possible s_i.\n    # For a given p_rem, the largest S is such that S*(S-1)/2 <= p_rem.\n    # S^2 - S - 2*p_rem <= 0\n    # S approx (1 + sqrt(1 + 8*p_rem)) / 2\n    \n    # This greedy choice also uniquely determines the set of s_i values.\n    # Thus, sum(s_i^2) will also be uniquely determined.\n    # The number of unidirectional pairs is (sum(s_i))^2 - sum(s_i^2) / 2\n    # when SCCs are arranged in a chain.\n\n    while p > 0:\n        # Calculate S for the current p value\n        # S*(S-1)/2 <= p  => S^2 - S - 2p <= 0\n        # Roots of S^2 - S - 2p = 0 are (1 +/- sqrt(1 + 8p))/2\n        # We need the largest integer S such that S <= (1 + sqrt(1 + 8p))/2\n        \n        # Using floating point for sqrt, then floor, should be precise enough\n        # given the constraints.\n        S_float = (1 + math.sqrt(1 + 8 * p)) / 2\n        S = int(S_float)\n        \n        # Edge case: S_float might be slightly less than an integer due to precision,\n        # or S*(S-1)/2 might be slightly greater than p due to S_float being slightly larger.\n        # Ensure S*(S-1)/2 does not exceed p.\n        # If S_float is e.g. 3.9999999999999996, int(S_float) is 3. But maybe 4 is correct.\n        # If S_float is e.g. 4.0000000000000001, int(S_float) is 4.\n        # A safer way: start with floor, then check S+1.\n        \n        # Let's re-derive S more carefully.\n        # We need `S` such that `S * (S - 1) / 2 <= p` and `(S+1) * S / 2 > p`.\n        # This is equivalent to `S = floor( (1 + sqrt(1 + 8p)) / 2 )`.\n        # For example, if p=3, S_float = (1+5)/2 = 3. S=3. f(3)=3.\n        # If p=4, S_float = (1+sqrt(33))/2 approx (1+5.74)/2 = 3.37. S=3. f(3)=3.\n        # If p=6, S_float = (1+sqrt(49))/2 = (1+7)/2 = 4. S=4. f(4)=6.\n        # The int(S_float) approach seems correct.\n        \n        # A potential issue: if S_float is like 3.9999999999999996, int(S_float) is 3.\n        # But if the true value is 4, we would miss it.\n        # Let's check S and S+1.\n        \n        # S must be at least 2 to contribute to p.\n        # If p=1, S_float = (1+3)/2 = 2. S=2.\n        # If p=0, S_float = (1+1)/2 = 1. S=1.\n        # The loop condition handles p=0. If p=1, S=2.\n        \n        # Test S to ensure it's valid.\n        # If S*(S-1)/2 > p, S is too large. This shouldn't happen with floor.\n        # If (S+1)*S/2 <= p, S is too small. This means S_float was rounded down too much.\n        # A robust way:\n        low = 0\n        high = int(math.sqrt(2 * p)) + 2 # Upper bound for S, S(S-1)/2 ~ S^2/2 => S ~ sqrt(2p)\n        \n        current_S = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * (mid - 1) // 2 <= p:\n                current_S = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        # Ensure current_S is at least 2, unless p becomes 0.\n        # If p=1, current_S will be 2.\n        # If p=0, current_S will be 1 (or 0 if starting low=0, high=0).\n        # We only care about S >= 2.\n        # If current_S is 0 or 1, it implies p is 0 or 1.\n        # If p=1, current_S=2.\n        # If current_S is 1, it means p must be 0.\n        \n        if current_S < 2 and p > 0: # This means p=1, but current_S became 1.\n                                     # This should not happen with the binary search.\n                                     # E.g. p=1: low=0, high=2.\n                                     # mid=1. 1*(0)/2=0 <= 1. current_S=1, low=2.\n                                     # mid=2. 2*(1)/2=1 <= 1. current_S=2, low=3.\n                                     # low=3, high=2. Loop ends. current_S=2.\n                                     # So current_S will be 2 if p=1.\n            pass # current_S should be correct.\n            \n        min_nodes += current_S\n        sum_s_squared += current_S * current_S\n        p -= current_S * (current_S - 1) // 2\n\n    # Calculate max_unidirectional_pairs\n    # This is sum_{i<j} s_i * s_j\n    # which equals ( (sum s_i)^2 - sum (s_i^2) ) / 2\n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_s_squared) // 2\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    sum_s_squared = 0\n\n    # We need to find s_i such that sum(s_i * (s_i - 1) / 2) = p\n    # and sum(s_i) is minimized.\n    # The greedy strategy is to always pick the largest possible s_i.\n    # For a given p_rem, the largest S is such that S*(S-1)/2 <= p_rem.\n    # S^2 - S - 2*p_rem <= 0\n    # S approx (1 + sqrt(1 + 8*p_rem)) / 2\n    \n    # This greedy choice also uniquely determines the set of s_i values.\n    # Thus, sum(s_i^2) will also be uniquely determined.\n    # The number of unidirectional pairs is (sum(s_i))^2 - sum(s_i^2) / 2\n    # when SCCs are arranged in a chain.\n\n    while p > 0:\n        # Calculate S for the current p value\n        # S*(S-1)/2 <= p  => S^2 - S - 2p <= 0\n        # Roots of S^2 - S - 2p = 0 are (1 +/- sqrt(1 + 8p))/2\n        # We need the largest integer S such that S <= (1 + sqrt(1 + 8p))/2\n        \n        # Using floating point for sqrt, then floor, should be precise enough\n        # given the constraints.\n        S_float = (1 + math.sqrt(1 + 8 * p)) / 2\n        S = int(S_float)\n        \n        # Edge case: S_float might be slightly less than an integer due to precision,\n        # or S*(S-1)/2 might be slightly greater than p due to S_float being slightly larger.\n        # Ensure S*(S-1)/2 does not exceed p.\n        # If S_float is e.g. 3.9999999999999996, int(S_float) is 3. But maybe 4 is correct.\n        # If S_float is e.g. 4.0000000000000001, int(S_float) is 4.\n        # A safer way: start with floor, then check S+1.\n        \n        # Let's re-derive S more carefully.\n        # We need `S` such that `S * (S - 1) / 2 <= p` and `(S+1) * S / 2 > p`.\n        # This is equivalent to `S = floor( (1 + sqrt(1 + 8p)) / 2 )`.\n        # For example, if p=3, S_float = (1+5)/2 = 3. S=3. f(3)=3.\n        # If p=4, S_float = (1+sqrt(33))/2 approx (1+5.74)/2 = 3.37. S=3. f(3)=3.\n        # If p=6, S_float = (1+sqrt(49))/2 = (1+7)/2 = 4. S=4. f(4)=6.\n        # The int(S_float) approach seems correct.\n        \n        # A potential issue: if S_float is like 3.9999999999999996, int(S_float) is 3.\n        # But if the true value is 4, we would miss it.\n        # Let's check S and S+1.\n        \n        # S must be at least 2 to contribute to p.\n        # If p=1, S_float = (1+3)/2 = 2. S=2.\n        # If p=0, S_float = (1+1)/2 = 1. S=1.\n        # The loop condition handles p=0. If p=1, S=2.\n        \n        # Test S to ensure it's valid.\n        # If S*(S-1)/2 > p, S is too large. This shouldn't happen with floor.\n        # If (S+1)*S/2 <= p, S is too small. This means S_float was rounded down too much.\n        # A robust way:\n        low = 0\n        high = int(math.sqrt(2 * p)) + 2 # Upper bound for S, S(S-1)/2 ~ S^2/2 => S ~ sqrt(2p)\n        \n        current_S = 0\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * (mid - 1) // 2 <= p:\n                current_S = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        # Ensure current_S is at least 2, unless p becomes 0.\n        # If p=1, current_S will be 2.\n        # If p=0, current_S will be 1 (or 0 if starting low=0, high=0).\n        # We only care about S >= 2.\n        # If current_S is 0 or 1, it implies p is 0 or 1.\n        # If p=1, current_S=2.\n        # If current_S is 1, it means p must be 0.\n        \n        if current_S < 2 and p > 0: # This means p=1, but current_S became 1.\n                                     # This should not happen with the binary search.\n                                     # E.g. p=1: low=0, high=2.\n                                     # mid=1. 1*(0)/2=0 <= 1. current_S=1, low=2.\n                                     # mid=2. 2*(1)/2=1 <= 1. current_S=2, low=3.\n                                     # low=3, high=2. Loop ends. current_S=2.\n                                     # So current_S will be 2 if p=1.\n            pass # current_S should be correct.\n            \n        min_nodes += current_S\n        sum_s_squared += current_S * current_S\n        p -= current_S * (current_S - 1) // 2\n\n    # Calculate max_unidirectional_pairs\n    # This is sum_{i<j} s_i * s_j\n    # which equals ( (sum s_i)^2 - sum (s_i^2) ) / 2\n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_s_squared) // 2\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 5892,
        "thoughts_token_count": 771
    }
}