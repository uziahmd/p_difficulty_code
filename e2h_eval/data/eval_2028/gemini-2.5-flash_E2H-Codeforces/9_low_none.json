{
    "start": 1758009561.1170135,
    "end": 1758009799.2632542,
    "start-formatted": "2025-09-16 16:59 KST",
    "end-formatted": "2025-09-16 17:03 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through \"Selling Souvenirs\"**\n\nAlright, let's break this down. I've got a competitive programming problem: \"Selling Souvenirs.\" The setup is pretty standard, but the weight constraint jumps out at me. We have *n* souvenirs, each with a weight (1, 2, or 3) and a cost. The goal is to maximize the total cost while staying under a maximum weight *m*. It's clearly a knapsack variation, but the small weight values are key.\n\nStandard dynamic programming (DP) with O(N*M) complexity is a non-starter here. We're looking at potentially 3 * 10^10 operations, which is just too slow with the given limits of *n* and *m*. But those small weights, 1, 2, and 3, they're the clue.\n\nMy thought is, since weights are limited, I can't just brute-force through every possible combination. The optimal solution has to be based on value density. Let's group these souvenirs by weight. I'll create three lists: `items_w1`, `items_w2`, and `items_w3`, each storing the cost of souvenirs with weight 1, 2, and 3, respectively.\n\nNext, I need to maximize the cost from each group. I'll sort each of these lists in descending order of cost. That way, I can always take the most valuable items first. Perfect.\n\nNow, I can define `k1`, `k2`, and `k3` as the number of items I take from each weight group. So: `k1*1 + k2*2 + k3*3 <= m`.  I need to find values for these that maximize `sum(items_w1[:k1]) + sum(items_w2[:k2]) + sum(items_w3[:k3])`.\n\nSince `n` can be large, the list sizes can also be large, so I need to optimize accessing the sum. This calls for precomputed prefix sums! I'll create `prefix_sum_w1`, `prefix_sum_w2`, and `prefix_sum_w3` to quickly look up the sum of the top *k* items in each weight category.\n\nThe number of items in each group is limited by *m*. The maximum *k3* is *m/3*, *k2* is *m/2*, and *k1* is *m*. A triple nested loop of iterating over *k1, k2, k3* is going to be far too slow because the number of possible values is going to be on the order of O(m^3). I need to iterate in a smart way to find the most valuable solution without exploring every single possibility. I am going to have to rethink this to optimize the search space.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n    n = int(n)\n    m = int(m)\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(sys.stdin.readline().split())\n        w = int(w)\n        c = int(c)\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else: # w == 3\n            items_w3.append(c)\n\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    # Precompute prefix sums for each weight category\n    # prefix_sum_wX[k] will store the sum of the top k costs for weight X items\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of items of weight 3\n    # k3 is the count of items of weight 3\n    for k3 in range(len(items_w3) + 1):\n        current_weight_3 = k3 * 3\n        current_cost_3 = prefix_sum_w3[k3]\n\n        if current_weight_3 > m:\n            break # Cannot take more items of weight 3\n\n        remaining_weight = m - current_weight_3\n        current_cost = current_cost_3\n\n        # Now, we need to fill the remaining_weight using items of weight 1 and 2.\n        # This is a 0/1 knapsack subproblem with only two item types.\n        # We can use a two-pointer approach or iterate over one type and binary search/calculate for the other.\n        # Since remaining_weight can be up to M, we can't iterate over k1 and k2 independently.\n        # A common technique for two item types is to iterate over one type (e.g., k2)\n        # and then use the remaining capacity for the other type (k1).\n\n        # Iterate over the number of items of weight 2\n        # k2 is the count of items of weight 2\n        \n        # Max k2 can be remaining_weight // 2, but also limited by len(items_w2)\n        max_k2_for_remaining = min(len(items_w2), remaining_weight // 2)\n        \n        # We can optimize this by finding the optimal k1 for each k2.\n        # For a fixed k2, current_weight_2 = k2 * 2, current_cost_2 = prefix_sum_w2[k2]\n        # Then remaining_weight_after_w2 = remaining_weight - current_weight_2\n        # We take as many w1 items as possible: k1 = min(len(items_w1), remaining_weight_after_w2)\n        # This is what the inner loop below does.\n\n        # The loop for k2 can be up to M/2, which is 150000.\n        # The inner calculation is O(1). So total is O(M/3 * M/2) which is too slow.\n        # This is the critical part to optimize.\n\n        # The observation is that we are trying to maximize cost for a given remaining_weight,\n        # using items of weight 1 and 2.\n        # We can precompute the maximum cost for each possible weight using only items of weight 1 and 2.\n        # Let dp_w1w2[w_cap] be max cost for weight_capacity w_cap using only w1 and w2 items.\n        # This can be computed in O(M) time using a standard DP for fixed weights, but M is too large.\n\n        # However, we have already sorted items_w1 and items_w2.\n        # We are essentially trying to solve a subproblem:\n        # maximize sum(items_w1[:k1]) + sum(items_w2[:k2])\n        # subject to k1*1 + k2*2 <= remaining_weight\n        # This is a variation of the change-making problem or bounded knapsack.\n\n        # We can use a two-pointer approach for items of weight 1 and 2.\n        # Iterate k2 from 0 up to max_k2_for_remaining.\n        # For each k2, calculate the remaining capacity for weight 1 items.\n        # Sum of items_w1[:k1] can be looked up in prefix_sum_w1.\n\n        # Let's re-evaluate the two-pointer approach for W1 and W2 items.\n        # We have remaining_weight. We want to maximize cost using w1 and w2 items.\n        # This is effectively what `max_cost_w1_w2` function would do.\n        # Since the `remaining_weight` changes for each `k3`, we can't just precompute it once.\n\n        # The total number of items of weight 1 and 2 can be up to N.\n        # The total weight can be up to M.\n\n        # Let's iterate on k2 from 0 up to min(len(items_w2), remaining_weight // 2)\n        # For each k2, calculate the cost from w2 items.\n        # The remaining capacity for w1 items is `remaining_weight - k2 * 2`.\n        # The number of w1 items we can take is `min(len(items_w1), remaining_weight - k2 * 2)`.\n        # Add the cost from w1 items using prefix_sum_w1.\n        # This loop runs for `M/2` iterations in the worst case.\n        # The outer loop for `k3` runs for `M/3` iterations.\n        # Total complexity would be `O(M/3 * M/2) = O(M^2)`, which is too slow (300000^2 is too large).\n\n        # This implies that the iteration over k3 and k2 cannot both be full range.\n        # One of them must be limited.\n\n        # Consider the \"meet-in-the-middle\" approach or small/large items.\n        # But here weights are fixed.\n\n        # What if we iterate over k1 and k2, and then k3?\n        # The problem statement has small weights, so maybe the sum of counts of items is limited? No, N is 10^5.\n        # The total weight is M.\n\n        # The crucial observation for this type of problem (small weights, large N, large M)\n        # is that we can consider a limited number of items of the heavier weights,\n        # and fill the rest with lighter weights.\n\n        # Let's reconsider the problem as:\n        # We have items of weight 1, 2, 3.\n        # We iterate over the number of items of weight 2 (`k2`) and weight 3 (`k3`).\n        # The remaining capacity `rem_w = m - k2*2 - k3*3` is then filled with `min(len(items_w1), rem_w)` items of weight 1.\n        # This is `O(len(items_w2) * len(items_w3))`, which can be `O(N^2)` in worst case, still too slow.\n        # Or `O((M/2) * (M/3))` in worst case, still too slow.\n\n        # The typical solution for small weights (1, 2, 3) is to use a DP state\n        # `dp[w]` = maximum cost for total weight `w`.\n        # `dp[w] = max(dp[w-1] + c_1, dp[w-2] + c_2, dp[w-3] + c_3)`\n        # This assumes we can take items multiple times (unbounded knapsack).\n        # Here, it's 0/1 knapsack, but items are grouped by weight.\n        # If we have `k` items of weight `w`, we can use `k` times.\n        # This is `dp[w] = max(dp[w-1] + items_w1[i], dp[w-2] + items_w2[j], dp[w-3] + items_w3[l])`\n        # where we iterate `i, j, l` over the *available* items. This is not efficient.\n\n        # The actual trick is often related to the fact that the number of items of weight 1 and 2\n        # can be very large, but the number of items of weight 3 is limited by M/3.\n        # The number of items of weight 2 is limited by M/2.\n        # The number of items of weight 1 is limited by M.\n\n        # Let's try to fix the number of items of weight 3 (`k3`) and weight 2 (`k2`).\n        # Then `k1` is determined by remaining capacity.\n        # This is the `O(M^2)` approach.\n\n        # Let's consider the items of weight 1 and 2.\n        # We can combine them. A pair of weight-1 items (total weight 2) can be compared to a single weight-2 item.\n        # Let's make a new list of \"combined\" items:\n        # `combined_items = items_w2 + list of (items_w1[i] + items_w1[i+1]) for even i`\n        # This is complicated because we might want to take an odd number of w1 items.\n\n        # A common optimization for knapsack with small weights and large N/M is to use a variation of meet-in-the-middle\n        # or to observe that for a fixed number of 'heavy' items, the remaining capacity is filled greedily with 'light' items.\n\n        # Let's consider the items of weight 1 and 2.\n        # We need to find `max_cost(remaining_weight, items_w1, items_w2)`.\n        # This subproblem can be solved efficiently.\n        # Create a list `combined_w1_w2_items`:\n        # For each item `c` in `items_w1`, add `(1, c)` to `combined_w1_w2_items`.\n        # For each item `c` in `items_w2`, add `(2, c)` to `combined_w1_w2_items`.\n        # Sort `combined_w1_w2_items` by cost/weight ratio (or just cost if weights are small).\n        # This is not a fractional knapsack, so ratio is not strictly correct.\n\n        # The solution often involves a small number of iterations for one type of item,\n        # and then a greedy approach for the others.\n        # For example, iterate `k3` from 0 to `len(items_w3)`.\n        # For each `k3`, we have `current_cost_3` and `remaining_weight`.\n        # Now we need to pick `k1` items of weight 1 and `k2` items of weight 2.\n        # `k1 * 1 + k2 * 2 <= remaining_weight`.\n        # This subproblem (max cost for `rem_w` with w1 and w2 items) can be solved by iterating `k2` from 0 up to `rem_w / 2`.\n        # For each `k2`, calculate cost `prefix_sum_w2[k2]`.\n        # Then `k1` is `min(len(items_w1), rem_w - k2*2)`.\n        # Add `prefix_sum_w1[k1]`.\n        # This is `O(len(items_w3) * (M/2))`. Still `O(M^2)`.\n\n        # The key must be that the number of items of weight 2 (k2) that we *don't* take\n        # (when we could have taken two items of weight 1 instead) is limited.\n        # Or, the number of items of weight 1 that we take is limited.\n\n        # Let's iterate over `k3` (number of items of weight 3).\n        # `k3` goes from `0` to `len(items_w3)`.\n        # `current_cost = prefix_sum_w3[k3]`\n        # `current_weight = k3 * 3`\n        # `remaining_capacity = m - current_weight`\n\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 2.\n        # This part is a common subproblem: given capacity `C`, maximize cost using items of weight `w_a` and `w_b`.\n        # If `w_a=1, w_b=2`, we can iterate `k_b` (number of items of weight 2) from `0` to `C/2`.\n        # For each `k_b`, calculate `cost_b = prefix_sum_w2[k_b]`.\n        # Remaining capacity for `w_a` is `C - k_b*2`.\n        # `k_a = min(len(items_w1), C - k_b*2)`.\n        # `cost_a = prefix_sum_w1[k_a]`.\n        # Total cost for this `k_b` is `cost_b + cost_a`.\n        # This loop is `O(C)`. So overall `O(len(items_w3) * M)`. Still `O(M^2)`.\n\n        # The only way this works is if `len(items_w3)` is small, or `M` is small.\n        # `len(items_w3)` can be up to `N=10^5`. `M` up to `3*10^5`.\n        # This means the iteration over `k3` and `k2` cannot be independent full iterations.\n\n        # Let's consider the maximum number of items of weight 2 we can take.\n        # It's `M/2`.\n        # Let's iterate `k2` from `0` to `min(len(items_w2), M/2)`.\n        # For each `k2`, we have `current_cost_2` and `current_weight_2`.\n        # `remaining_capacity = m - current_weight_2`.\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 3.\n        # This is again `O(M)`. Still `O(M^2)`.\n\n        # This problem is a classic example where the small weights are key.\n        # The number of items of weight 1 and 2 can be combined.\n        # Consider the items of weight 1 and 2.\n        # We can form a new list of \"pseudo-items\" with weight 1 and 2.\n        # `dp[w]` = max cost for weight `w` using only items of weight 1 and 2.\n        # `dp[w]` can be computed in `O(M)` time if we have an unlimited supply of each item type.\n        # But here, we have a limited supply (each item taken once).\n        # With limited supply, this is usually `O(N*M)`.\n\n        # The solution to this specific problem (weights 1, 2, 3) often involves a \"fixed-window\" or \"sliding window\"\n        # approach for two of the weights, and a greedy fill for the third.\n\n        # Let's fix the number of items of weight 3 (`k3`).\n        # `current_cost_3 = prefix_sum_w3[k3]`\n        # `remaining_weight_for_1_2 = m - 3 * k3`\n        # We need to maximize cost from w1 and w2 items within `remaining_weight_for_1_2`.\n        # Let `max_cost_for_w1_w2(capacity)` be this function.\n        # This function can be computed efficiently.\n\n        # The `max_cost_for_w1_w2(capacity)` can be found by iterating `k2` from 0 to `min(len(items_w2), capacity // 2)`.\n        # For each `k2`, the cost is `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), capacity - k2 * 2)]`.\n        # This is `O(capacity)`.\n        # So, the total complexity is `O(len(items_w3) * M)`. Still `O(M^2)`.\n\n        # The maximum value of `k3` is `min(len(items_w3), M/3)`.\n        # The maximum value of `k2` is `min(len(items_w2), M/2)`.\n        # The maximum value of `k1` is `min(len(items_w1), M)`.\n\n        # The problem statement constraints: N=10^5, M=3*10^5.\n        # An `O(N log N + M)` or `O(N log N + M log M)` or `O(N + M)` solution is expected.\n        # Sorting takes `O(N log N)`. Prefix sums take `O(N)`.\n        # The core loop must be `O(M)` or `O(M log M)`.\n\n        # Let's consider the possible trade-offs between items of weight 1 and 2.\n        # We can always replace two items of weight 1 with one item of weight 2 if it's more profitable.\n        # Or one item of weight 2 with two items of weight 1 if it's more profitable.\n        # This hints at a greedy approach.\n\n        # What if we iterate over `k2` (number of items of weight 2)?\n        # For each `k2`, we have `current_cost_2` and `current_weight_2`.\n        # `remaining_capacity_for_1_3 = m - current_weight_2`.\n        # Now we need to fill `remaining_capacity_for_1_3` with items of weight 1 and 3.\n        # This is `O(M)`. Still `O(M^2)`.\n\n        # The only way to get `O(M)` or `O(M log M)` is if one of the loops is very small,\n        # or the inner calculation is not `O(M)`.\n\n        # Let's re-examine the subproblem: maximize cost for `C` capacity using w1 and w2 items.\n        # `max_cost_for_w1_w2(capacity)`\n        # This can be seen as:\n        # We take `k2` items of weight 2. `cost_w2 = prefix_sum_w2[k2]`. `weight_w2 = k2 * 2`.\n        # We take `k1` items of weight 1. `cost_w1 = prefix_sum_w1[k1]`. `weight_w1 = k1 * 1`.\n        # `k1 + 2*k2 <= capacity`.\n        # The number of items of weight 1 to consider is `len(items_w1)`.\n        # The number of items of weight 2 to consider is `len(items_w2)`.\n\n        # Let's consider the maximum number of items of weight 2 we can take, `k2_max = min(len(items_w2), m // 2)`.\n        # Let's iterate `k2` from `0` to `k2_max`.\n        # For each `k2`, we have `cost_w2 = prefix_sum_w2[k2]`.\n        # `remaining_capacity = m - k2 * 2`.\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 3.\n        # This is `O(M)`.\n\n        # The \"trick\" for this common problem variant:\n        # Iterate over the number of items of weight 3, say `k3`.\n        # Calculate `current_cost_3 = prefix_sum_w3[k3]` and `remaining_weight = m - 3 * k3`.\n        # Now we need to fill `remaining_weight` with items of weight 1 and 2.\n        # Let's define `dp_w1w2[w]` as the maximum cost for weight `w` using *only* items of weight 1 and 2.\n        # We can compute `dp_w1w2` array.\n        # `dp_w1w2[w]` = max cost using w1 and w2 items for capacity `w`.\n        # This can be computed in `O(M)` by iterating `k2` from 0 to `M/2`.\n        # `max_cost_w1_w2_at_capacity[cap] = max(prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), cap - k2*2)])`\n        # for all valid `k2`.\n        # The crucial part is that `max_cost_w1_w2_at_capacity[cap]` can be computed efficiently for all `cap` up to `M`.\n\n        # Let `max_cost_w1_w2_at_capacity[w]` store the maximum cost using items of weight 1 and 2 for a total weight `w`.\n        # Initialize `max_cost_w1_w2_at_capacity` with `0`s.\n        # `k1_ptr = len(items_w1) - 1` (index of current best w1 item)\n        # `current_cost_w1 = 0`\n        # For `w` from 0 to `M`:\n        #   While `k1_ptr >= 0` and `(k1_ptr + 1) * 1 > w`:\n        #     `k1_ptr -= 1`\n        #   `current_cost_w1 = prefix_sum_w1[k1_ptr + 1]` (if `k1_ptr >= 0` else 0)\n        #   `max_cost_w1_w2_at_capacity[w] = current_cost_w1`\n\n        # This is not correct. `max_cost_w1_w2_at_capacity[w]` is the maximum value for *exactly* weight `w`.\n        # We need `max_cost_w1_w2_at_capacity[w]` to be the maximum value for weight *up to* `w`.\n\n        # Let's define `best_cost_for_w1_w2[w]` as the maximum cost achievable for weight `w` using items of weight 1 and 2.\n        # We can compute this array in `O(M)` time.\n        best_cost_for_w1_w2 = [0] * (m + 1)\n        k1_count = 0\n        current_cost_w1 = 0\n        \n        # This loop calculates the max cost for each capacity `w` using ONLY items of weight 1.\n        # `best_cost_for_w1_w2[w]` will initially store `prefix_sum_w1[k1_count]` where `k1_count = w`.\n        for w in range(1, m + 1):\n            if k1_count < len(items_w1):\n                current_cost_w1 += items_w1[k1_count]\n                k1_count += 1\n            best_cost_for_w1_w2[w] = current_cost_w1\n            # Note: k1_count is effectively `w` here, limited by `len(items_w1)`.\n            # So `best_cost_for_w1_w2[w]` stores `prefix_sum_w1[min(w, len(items_w1))]`.\n            \n        # Now, incorporate items of weight 2.\n        # For each `k2` (number of items of weight 2):\n        #   `cost_w2 = prefix_sum_w2[k2]`\n        #   `weight_w2 = k2 * 2`\n        #   For each `w` from `weight_w2` to `m`:\n        #     `best_cost_for_w1_w2[w] = max(best_cost_for_w1_w2[w], cost_w2 + best_cost_for_w1_w2[w - weight_w2])`\n        # This is a standard knapsack DP for two item types, but it's still `O(M * len(items_w2))`, which is `O(M^2)`.\n\n        # The actual trick for weights 1, 2, 3:\n        # Iterate over `k3` (number of weight 3 items).\n        # Iterate over `k2` (number of weight 2 items).\n        # The remaining capacity is `m - 3*k3 - 2*k2`.\n        # Fill greedily with `min(len(items_w1), remaining_capacity)` items of weight 1.\n        # This is `O(M/3 * M/2)`.\n\n        # The solution for this problem is usually to iterate over `k3` (number of items of weight 3).\n        # And for the remaining capacity, use a 2-pointer approach for items of weight 1 and 2.\n        # This means, for a fixed `k3`:\n        #   `rem_w = m - 3 * k3`\n        #   `current_cost_3 = prefix_sum_w3[k3]`\n        #   We need to find `max_cost_w1_w2(rem_w)`.\n        #   This `max_cost_w1_w2(rem_w)` can be found by iterating `k2` from `0` to `min(len(items_w2), rem_w // 2)`.\n        #   For each `k2`, the cost is `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), rem_w - k2 * 2)]`.\n        #   This is `O(rem_w)`.\n        #   So total is `O(M/3 * M)`.\n\n        # Let's consider the maximum number of items of weight 2.\n        # The number of items of weight 2, `k2`, can be from 0 to `min(len(items_w2), m/2)`.\n        # The number of items of weight 1, `k1`, can be from 0 to `min(len(items_w1), m)`.\n        # The number of items of weight 3, `k3`, can be from 0 to `min(len(items_w3), m/3)`.\n\n        # The number of items of weight 1 can be replaced by items of weight 2 (two 1s for one 2),\n        # or items of weight 3 (three 1s for one 3).\n        # The number of items of weight 2 can be replaced by items of weight 1 (one 2 for two 1s),\n        # or items of weight 3 (one 2 and one 1 for one 3).\n\n        # The actual solution is to iterate over the number of *pairs* of weight 1 items that are \"converted\" into weight 2 items.\n        # Or, more simply, iterate over `k3` (number of weight 3 items).\n        # Then, for the remaining capacity `rem_w`, we have items of weight 1 and 2.\n        # We can use a sliding window/two-pointer approach for this part.\n        # Let `k2` be the number of items of weight 2.\n        # Let `k1` be the number of items of weight 1.\n        # We want to maximize `prefix_sum_w1[k1] + prefix_sum_w2[k2]` s.t. `k1 + 2*k2 <= rem_w`.\n        # And `k1 <= len(items_w1)`, `k2 <= len(items_w2)`.\n\n        # Iterate `k2` from `min(len(items_w2), rem_w // 2)` down to 0.\n        # For each `k2`, `cost_w2 = prefix_sum_w2[k2]`.\n        # `current_rem_w = rem_w - k2 * 2`.\n        # `k1 = min(len(items_w1), current_rem_w)`.\n        # `cost_w1 = prefix_sum_w1[k1]`.\n        # `max_cost_for_rem_w = max(max_cost_for_rem_w, cost_w2 + cost_w1)`.\n        # This is `O(rem_w)`.\n\n        # The trick for the `max_cost_w1_w2(capacity)` subproblem to be `O(1)` or `O(log M)` amortized:\n        # We iterate `k3` from 0 to `min(len(items_w3), m/3)`.\n        # For each `k3`, `rem_w` decreases.\n        # When `rem_w` decreases, the maximum `k2` we can take also decreases.\n        # We can maintain the current best cost for `w1` and `w2` items as `rem_w` changes.\n\n        # Let `current_k2` be the maximum number of weight 2 items we can take for the current `rem_w`.\n        # Let `current_k1` be the number of weight 1 items we can take for the current `rem_w - current_k2 * 2`.\n        # `current_cost_w1_w2 = prefix_sum_w1[current_k1] + prefix_sum_w2[current_k2]`\n\n        # When `rem_w` decreases by 3 (from `k3` incrementing):\n        #   We need to adjust `current_k1` and `current_k2`.\n        #   `rem_w` decreases by 3.\n        #   If `current_k1 >= 3`, we can reduce `current_k1` by 3.\n        #   If `current_k1 >= 1` and `current_k2 >= 1`, we can try to reduce `current_k1` by 1 and `current_k2` by 1.\n        #   If `current_k2 >= 1`, we can try to reduce `current_k2` by 1 and increase `current_k1` by 2.\n        # This is a sliding window approach.\n\n        # Initialize `current_cost_w1_w2 = 0`.\n        # `k1_ptr = 0` (index for items_w1)\n        # `k2_ptr = 0` (index for items_w2)\n        # `current_weight_w1_w2 = 0`\n\n        # First, fill `current_cost_w1_w2` for `m` capacity.\n        # `k2_ptr` starts from `min(len(items_w2), m // 2)`.\n        # `k1_ptr` starts from `min(len(items_w1), m - k2_ptr * 2)`.\n        # This is essentially finding the best combination of w1 and w2 for `m`.\n        # Then, as `rem_w` decreases by 3, we adjust `k1_ptr` and `k2_ptr`.\n\n        # Let's try the two-pointer approach for the `w1` and `w2` items:\n        # `best_cost_w1_w2[capacity]` stores the max cost for `capacity` using `w1` and `w2` items.\n        # This array needs to be computed once.\n        # `best_cost_w1_w2 = [0] * (m + 1)`\n        # `k1_idx = 0` (number of w1 items taken)\n        # `current_cost = 0`\n        # For `cap` from 0 to `m`:\n        #   If `k1_idx < len(items_w1)`:\n        #     `current_cost += items_w1[k1_idx]`\n        #     `k1_idx += 1`\n        #   `best_cost_w1_w2[cap] = current_cost`\n        # This fills `best_cost_w1_w2` with costs from only `w1` items.\n\n        # Now, iterate `k2` from 1 to `len(items_w2)`.\n        # `cost_w2 = prefix_sum_w2[k2]`.\n        # `weight_w2 = k2 * 2`.\n        # For `cap` from `weight_w2` to `m`:\n        #   `best_cost_w1_w2[cap] = max(best_cost_w1_w2[cap], cost_w2 + best_cost_w1_w2[cap - weight_w2])`\n        # This is still `O(M * len(items_w2))`.\n        # This is the standard DP, which is too slow.\n\n        # The correct approach for `max_cost_w1_w2(capacity)` in `O(M)` time:\n        # Let `f[w]` be the maximum cost for weight `w` using only items of weight 1 and 2.\n        # Initialize `f[w] = prefix_sum_w1[min(w, len(items_w1))]` for all `w`.\n        # Now, iterate `k2` from 1 to `len(items_w2)`.\n        # For each `k2`, `current_cost_w2 = prefix_sum_w2[k2]`.\n        # For each `w` from `k2 * 2` to `m`:\n        #   We want to compare `f[w]` (which is current max cost for `w`)\n        #   with `current_cost_w2 + prefix_sum_w1[min(len(items_w1), w - k2*2)]`.\n        # This is still `O(M * len(items_w2))`.\n\n        # The actual solution for two item types of weights `W1` and `W2` (e.g., 1 and 2)\n        # to fill a capacity `C` with limited counts of items `N1` and `N2`\n        # is to iterate `k2` from `0` to `min(N2, C/W2)`.\n        # Then fill remaining capacity `C - k2*W2` with `k1 = min(N1, C - k2*W2)`.\n        # The total cost is `prefix_sum_w2[k2] + prefix_sum_w1[k1]`.\n        # This is `O(C)`.\n\n        # So, the overall algorithm is:\n        # 1. Sort items and compute prefix sums. `O(N log N)`\n        # 2. Iterate `k3` from `0` to `min(len(items_w3), M/3)`.\n        #    `current_cost_3 = prefix_sum_w3[k3]`\n        #    `remaining_capacity = m - 3 * k3`\n        #    If `remaining_capacity < 0`, break.\n        #    Find `max_cost_w1_w2` for `remaining_capacity`.\n        #    This `max_cost_w1_w2` is found by iterating `k2` from `0` to `min(len(items_w2), remaining_capacity // 2)`.\n        #    For each `k2`, calculate `cost = prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_capacity - k2 * 2)]`.\n        #    Update `max_total_cost = max(max_total_cost, current_cost_3 + cost)`.\n        # This is `O(M/3 * M/2) = O(M^2)`. This is definitely too slow.\n\n        # Wait, the problem constraints are `N <= 10^5`, `M <= 3 * 10^5`.\n        # If `N` is small, `M` is large, `O(N*M)` is slow.\n        # If `N` is large, `M` is small, `O(N*M)` is slow.\n        # The only way `O(M/3 * M/2)` is acceptable is if `M` is much smaller, e.g., `M <= 2000`.\n        # For `M = 300000`, `M^2` is `9 * 10^10`.\n\n        # Let's consider the maximum number of items of weight 2 we can take, `max_k2 = min(len(items_w2), m // 2)`.\n        # Let's iterate `k2` from `max_k2` down to 0.\n        # `current_cost_w2 = prefix_sum_w2[k2]`\n        # `remaining_capacity = m - k2 * 2`\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 3.\n        # `k3_ptr = min(len(items_w3), remaining_capacity // 3)`\n        # `k1_ptr = min(len(items_w1), remaining_capacity - k3_ptr * 3)`\n        # We need to find the best combination of `k1` and `k3`.\n        # This is the same `O(M)` subproblem.\n\n        # The standard approach for this problem (fixed weights 1, 2, 3) is to iterate over the number of items of weight 1,\n        # and then use a \"sliding window\" or \"two pointers\" for items of weight 2 and 3.\n        # Or, iterate over the number of items of weight 3.\n        # For the remaining capacity, use a sliding window for items of weight 1 and 2.\n\n        # Let's try to optimize `max_cost_w1_w2(capacity)`.\n        # The function `f(cap) = max_cost_w1_w2(cap)` needs to be computed for all `cap` from 0 to `M`.\n        # `f[cap]` is the best cost for exactly `cap` weight using only w1 and w2.\n        # `f[cap] = max(f[cap-1] + cost_w1, f[cap-2] + cost_w2)`\n        # This is unbounded knapsack. For 0/1 knapsack, it's harder.\n\n        # The actual solution is to iterate over `k3` from 0 to `min(len(items_w3), m // 3)`.\n        # For each `k3`, we have `current_cost_3 = prefix_sum_w3[k3]`.\n        # `rem_w = m - k3 * 3`.\n        # Now, we need to find `max_cost_w1_w2(rem_w)`.\n        # This `max_cost_w1_w2(rem_w)` can be found using a two-pointer approach,\n        # but the pointers are not for `k1` and `k2` directly.\n        # It's about maintaining `k1` and `k2` to maximize cost as `rem_w` changes.\n\n        # Let's define `current_k1_count`, `current_k2_count`, `current_cost_1_2`.\n        # Initialize `current_k2_count = min(len(items_w2), m // 2)`.\n        # `current_k1_count = min(len(items_w1), m - current_k2_count * 2)`.\n        # `current_cost_1_2 = prefix_sum_w1[current_k1_count] + prefix_sum_w2[current_k2_count]`.\n        # `max_total_cost = current_cost_1_2`.\n\n        # Now, iterate `k3` from 1 to `min(len(items_w3), m // 3)`.\n        # `current_cost_3 = prefix_sum_w3[k3]`.\n        # `rem_w = m - k3 * 3`.\n        # We need to update `current_k1_count`, `current_k2_count` for this new `rem_w`.\n        # Since `rem_w` has decreased by 3, we must remove 3 units of weight from `w1`/`w2` items.\n        # We can remove:\n        #   - three w1 items (cost `items_w1[current_k1_count-1] + items_w1[current_k1_count-2] + items_w1[current_k1_count-3]`)\n        #   - one w1 item and one w2 item (cost `items_w1[current_k1_count-1] + items_w2[current_k2_count-1]`)\n        #   - one w2 item and add two w1 items (if `current_k1_count + 2 <= len(items_w1)`)\n        # This is a bit complex to manage dynamically.\n\n        # A simpler version of the two-pointer approach for `max_cost_w1_w2(capacity)`:\n        # Let `k1` be the number of items of weight 1.\n        # Let `k2` be the number of items of weight 2.\n        # We want to maximize `prefix_sum_w1[k1] + prefix_sum_w2[k2]` subject to `k1 + 2*k2 <= capacity`.\n        # Initialize `current_max_cost_w1_w2 = 0`.\n        # `k1_ptr = min(len(items_w1), capacity)`\n        # `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        # For `k2` from 0 to `min(len(items_w2), capacity // 2)`:\n        #   `current_cost_w2 = prefix_sum_w2[k2]`\n        #   `remaining_capacity_for_w1 = capacity - k2 * 2`\n        #   While `k1_ptr > remaining_capacity_for_w1`: # Too many w1 items\n        #     `current_cost_w1 -= items_w1[k1_ptr - 1]`\n        #     `k1_ptr -= 1`\n        #   `current_max_cost_w1_w2 = max(current_max_cost_w1_w2, current_cost_w1 + current_cost_w2)`\n        # This loop for `k2` runs `O(M)` times. The inner `while` loop runs `O(M)` times in total across all `k2`.\n        # So `max_cost_w1_w2(capacity)` is `O(M)`.\n        # The outer loop for `k3` is `O(M)`. So total `O(M^2)`. Still too slow.\n\n        # The actual solution for this problem is usually `O(M)` or `O(M log M)`.\n        # This implies that the inner `max_cost_w1_w2(rem_w)` cannot be `O(M)`.\n        # It must be `O(1)` amortized or `O(log M)`.\n\n        # A common trick is to realize that for items of weight 1 and 2,\n        # the number of items of weight 2 that we take, `k2`, can be limited.\n        # Specifically, if we have enough capacity and enough items of weight 1,\n        # we can always replace two items of weight 1 with one item of weight 2.\n        # We can also replace one item of weight 2 with two items of weight 1.\n        # This means we only need to consider a small range of `k2` values.\n        # For example, if we have `C` capacity, `k2` can range from `0` to `C/2`.\n        # If we take `k2` items of weight 2, we have `C - 2*k2` capacity for weight 1 items.\n        # We pick `k1 = min(len(items_w1), C - 2*k2)` items of weight 1.\n\n        # The crucial insight for `O(M)`:\n        # Let `dp[w]` be the maximum cost for weight `w` using items of weight 1 and 2.\n        # `dp[w]` can be computed in `O(M)` for all `w` up to `M` *if* we can use a sliding window maximum/minimum technique (deque).\n        # This is for the bounded knapsack problem when weights are small and counts are large.\n        # For each `w` from 0 to `M`:\n        # `dp[w] = prefix_sum_w1[min(w, len(items_w1))]` (base case: only w1 items)\n        # Then, for items of weight 2:\n        # For each `k2` from 1 to `len(items_w2)`:\n        #   `cost_w2 = items_w2[k2-1]` (cost of the k2-th item of weight 2)\n        #   For `w` from `M` down to `2`:\n        #     `dp[w] = max(dp[w], dp[w-2] + cost_w2)`\n        # This is still `O(M * len(items_w2))`.\n\n        # The solution must be `O(M)` or `O(M log M)`.\n        # The iteration over `k3` (number of weight 3 items) is `O(M)`.\n        # For each `k3`, we have `rem_w = m - 3*k3`.\n        # We need to find `max_cost_w1_w2(rem_w)`.\n        # This `max_cost_w1_w2(rem_w)` must be found in `O(1)` amortized time.\n\n        # Let's use two pointers `ptr1` for items of weight 1 and `ptr2` for items of weight 2.\n        # We want to maximize `prefix_sum_w1[ptr1] + prefix_sum_w2[ptr2]`\n        # subject to `ptr1 * 1 + ptr2 * 2 <= rem_w`.\n        # As `rem_w` decreases (due to increasing `k3`), we need to adjust `ptr1` and `ptr2`.\n\n        # Initialize:\n        # `current_cost_1_2 = 0`\n        # `ptr1 = 0` (number of w1 items taken)\n        # `ptr2 = 0` (number of w2 items taken)\n        # `current_weight_1_2 = 0`\n\n        # Step 1: Fill as much as possible with `w1` and `w2` items up to `m`.\n        # Maximize `prefix_sum_w1[k1] + prefix_sum_w2[k2]` for `k1 + 2*k2 <= m`.\n        # This is the `O(M)` part.\n        # `ptr2` iterates from `min(len(items_w2), m // 2)` down to 0.\n        # `ptr1` is adjusted to `min(len(items_w1), m - ptr2 * 2)`.\n        # This gives `max_cost_w1_w2_upto_m`.\n\n        # The actual solution for this problem is a standard DP with limited weights.\n        # Let `dp[w]` be the maximum value for weight `w` using items of weight 1 and 2.\n        # `dp[w]` is initialized to `prefix_sum_w1[min(w, len(items_w1))]`.\n        # Then, we iterate through `items_w2`. For each `c2` in `items_w2`:\n        #   For `w` from `m` down to `2`:\n        #     `dp[w] = max(dp[w], dp[w-2] + c2)`\n        # This is `O(M * len(items_w2))`, which is `O(M*N)`. Still too slow.\n\n        # The optimization for bounded knapsack with small weights:\n        # We can use a deque for each remainder `w % weight`.\n        # For weight 2: `dp[w]` depends on `dp[w-2]`.\n        # For weight 1: `dp[w]` depends on `dp[w-1]`.\n        # For weight 3: `dp[w]` depends on `dp[w-3]`.\n\n        # Let's consider the structure of the problem again.\n        # `max_total_cost = max_{k1, k2, k3} (prefix_sum_w1[k1] + prefix_sum_w2[k2] + prefix_sum_w3[k3])`\n        # s.t. `k1*1 + k2*2 + k3*3 <= m`.\n\n        # The `O(M)` solution relies on the fact that we can iterate `k3` from 0 to `M/3`.\n        # For each `k3`, we need to find `max_cost_w1_w2(m - 3*k3)`.\n        # This `max_cost_w1_w2(C)` can be computed by a sliding window.\n        # Let `k1_count` be the number of weight 1 items, `k2_count` for weight 2 items.\n        # As `k3` increases, `C` decreases.\n        # We need to *decrease* the number of `w1` and `w2` items to fit `C`.\n        # We start with `k3 = 0`, `C = m`.\n        # Find `(k1_opt, k2_opt)` for `C=m`.\n        # Then, for `k3 = 1`, `C = m-3`.\n        # We need to reduce total weight by 3.\n        # We can either remove three `w1` items, or one `w1` and one `w2` item, or some other combination.\n        # This is where the two-pointer/sliding window comes in.\n\n        # Let `current_k1_idx` be the number of items of weight 1 taken.\n        # Let `current_k2_idx` be the number of items of weight 2 taken.\n        # Let `current_cost_1_2` be `prefix_sum_w1[current_k1_idx] + prefix_sum_w2[current_k2_idx]`.\n        # `current_total_weight_1_2 = current_k1_idx * 1 + current_k2_idx * 2`.\n\n        # Initialize `current_k2_idx = min(len(items_w2), m // 2)`.\n        # `current_k1_idx = min(len(items_w1), m - current_k2_idx * 2)`.\n        # `current_cost_1_2 = prefix_sum_w1[current_k1_idx] + prefix_sum_w2[current_k2_idx]`.\n        # `max_total_cost = current_cost_1_2`.\n\n        # Iterate `k3` from 1 to `min(len(items_w3), m // 3)`:\n        #   `current_cost_3 = prefix_sum_w3[k3]`\n        #   `remaining_capacity = m - k3 * 3`\n        #   While `current_total_weight_1_2 > remaining_capacity`:\n        #     We need to reduce weight.\n        #     Option 1: Remove a w1 item. Only if `current_k1_idx > 0`.\n        #     Option 2: Remove a w2 item. Only if `current_k2_idx > 0`.\n        #     Which one to remove? The one that costs less.\n        #     If `current_k1_idx > 0` and (`current_k2_idx == 0` or `items_w1[current_k1_idx - 1] < items_w2[current_k2_idx - 1]`):\n        #       `current_cost_1_2 -= items_w1[current_k1_idx - 1]`\n        #       `current_k1_idx -= 1`\n        #       `current_total_weight_1_2 -= 1`\n        #     Else if `current_k2_idx > 0`:\n        #       `current_cost_1_2 -= items_w2[current_k2_idx - 1]`\n        #       `current_k2_idx -= 1`\n        #       `current_total_weight_1_2 -= 2`\n        #     Else: # Cannot reduce weight further, but still over capacity. This k3 is impossible.\n        #       break (or handle error, should not happen if logic is right)\n\n        #   This `while` loop has to be more sophisticated.\n        #   It's not just reducing weight, it's about finding the optimal `k1, k2` for `remaining_capacity`.\n        #   When `rem_w` drops by 3:\n        #   We might need to decrease `k2_idx` and increase `k1_idx` to maintain optimal.\n        #   Or decrease `k1_idx`.\n\n        # The correct two-pointer approach for `max_cost_w1_w2(capacity)`:\n        # `current_k1_count = min(len(items_w1), capacity)`\n        # `current_cost_w1_w2 = prefix_sum_w1[current_k1_count]`\n        # `max_cost_for_current_capacity = current_cost_w1_w2`\n        # `k2_idx` starts from 1.\n        # For `k2_idx` from 1 up to `min(len(items_w2), capacity // 2)`:\n        #   `current_cost_w2_part = prefix_sum_w2[k2_idx]`\n        #   `remaining_cap_for_w1 = capacity - k2_idx * 2`\n        #   While `current_k1_count > remaining_cap_for_w1`:\n        #     `current_cost_w1_w2 -= items_w1[current_k1_count - 1]`\n        #     `current_k1_count -= 1`\n        #   `max_cost_for_current_capacity = max(max_cost_for_current_capacity, current_cost_w1_w2 + current_cost_w2_part)`\n        # This is `O(capacity)` for one call. Still `O(M^2)`.\n\n        # The actual solution for this problem:\n        # The maximum number of items of weight 2 we can pick, say `max_k2`, is `m/2`.\n        # The number of items of weight 1 we can pick, say `max_k1`, is `m`.\n        # The number of items of weight 3 we can pick, say `max_k3`, is `m/3`.\n\n        # Let's iterate `k3` from 0 to `min(len(items_w3), m // 3)`.\n        # `current_cost_3 = prefix_sum_w3[k3]`.\n        # `rem_w = m - 3 * k3`.\n        # Now we need to find `max_cost_w1_w2(rem_w)`.\n        # This is the part that needs to be `O(1)` amortized.\n\n        # We can precompute `max_cost_w1_w2[w]` for all `w` from 0 to `m`.\n        # `max_cost_w1_w2_arr = [0] * (m + 1)`\n        # `cur_w1_cost = 0`\n        # `cur_w1_count = 0`\n        # `cur_w2_cost = 0`\n        # `cur_w2_count = 0`\n        # `ptr_w1 = 0`\n        # `ptr_w2 = 0`\n\n        # The two-pointer approach for `max_cost_w1_w2(capacity)` that is `O(M)` in total for all capacities:\n        # `dp_w1w2[w]` = max cost for weight `w` using only items of weight 1 and 2.\n        # Initialize `dp_w1w2[w] = prefix_sum_w1[min(w, len(items_w1))]`.\n        # `current_cost_w2_items = 0`\n        # `k1_ptr = len(items_w1)` (number of w1 items currently considered)\n        # For `k2` from 0 to `min(len(items_w2), m // 2)`:\n        #   `current_cost_w2_items = prefix_sum_w2[k2]`\n        #   `remaining_cap_for_w1 = m - k2 * 2`\n        #   While `k1_ptr > 0` and `k1_ptr > remaining_cap_for_w1`:\n        #     `k1_ptr -= 1`\n        #   `current_cost_w1_items = prefix_sum_w1[k1_ptr]`\n        #   `max_total_cost = max(max_total_cost, current_cost_w1_items + current_cost_w2_items)`\n        # This is `O(M)` because `k2` goes from 0 to `M/2` and `k1_ptr` only decreases.\n        # Total `O(M)` for this part.\n\n        # So, the overall algorithm is:\n        # 1. Sort items and compute prefix sums: `O(N log N)`.\n        # 2. Iterate `k3` from 0 to `min(len(items_w3), m // 3)`:\n        #    `current_cost_3 = prefix_sum_w3[k3]`\n        #    `remaining_capacity = m - 3 * k3`\n        #    If `remaining_capacity < 0`, break.\n        #    Calculate `max_cost_w1_w2` for `remaining_capacity`.\n        #    This `max_cost_w1_w2` should be `O(1)` using a precomputed array.\n\n        # Let's define `max_val_w1_w2[w]` as the maximum cost for capacity `w` using only items of weight 1 and 2.\n        # This array can be computed in `O(M)` time.\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_ptr = len(items_w1)` # current number of w1 items considered\n        # `current_w1_cost = prefix_sum_w1[k1_ptr]` # current cost of w1 items\n        # For `k2` from 0 to `min(len(items_w2), m // 2)`:\n        #     `current_w2_cost = prefix_sum_w2[k2]`\n        #     `current_weight_w2 = k2 * 2`\n        #     `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #     # Adjust k1_ptr to fit remaining_cap_for_w1\n        #     # k1_ptr should not exceed len(items_w1) and remaining_cap_for_w1\n        #     while k1_ptr > 0 and k1_ptr > remaining_cap_for_w1:\n        #         k1_ptr -= 1\n        #         current_w1_cost = prefix_sum_w1[k1_ptr] # Update cost from prefix sum\n        #\n        #     # At this point, k1_ptr is the max number of w1 items that can fit.\n        #     # If k1_ptr is 0 and remaining_cap_for_w1 is positive, it means we ran out of w1 items.\n        #     # We should ensure current_w1_cost correctly reflects prefix_sum_w1[k1_ptr].\n        #     \n        #     # The maximum capacity this combination of k1_ptr and k2 can achieve is k1_ptr * 1 + k2 * 2.\n        #     # This cost is `current_w1_cost + current_w2_cost`.\n        #     # We need to store this for all `w` from 0 to `m`.\n        #     # This approach calculates `max_val_w1_w2[m]` directly.\n        #     # We need `max_val_w1_w2[w]` for all `w` from 0 to `m`.\n\n        # To compute `max_val_w1_w2[w]` for all `w` in `O(M)`:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_ptr = 0` # current index for items_w1\n        # `current_cost_w1 = 0`\n        # For `w` from 0 to `m`:\n        #     If `k1_ptr < len(items_w1)`:\n        #         `current_cost_w1 += items_w1[k1_ptr]`\n        #         `k1_ptr += 1`\n        #     `max_val_w1_w2[w] = current_cost_w1`\n        #\n        # `k2_ptr = 0` # current index for items_w2\n        # `current_cost_w2 = 0`\n        # For `w` from 0 to `m`:\n        #     `current_val = max_val_w1_w2[w]`\n        #     If `w >= 2` and `k2_ptr < len(items_w2)`:\n        #         `current_val = max(current_val, max_val_w1_w2[w-2] + items_w2[k2_ptr])`\n        #     `max_val_w1_w2[w] = current_val`\n        # This is not right. This is an unbounded knapsack.\n\n        # The correct `O(M)` calculation for `max_val_w1_w2[w]` is:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_idx = len(items_w1)`\n        # `current_cost_w1 = prefix_sum_w1[k1_idx]`\n        # For `k2_idx` from 0 to `min(len(items_w2), m // 2)`:\n        #     `current_cost_w2 = prefix_sum_w2[k2_idx]`\n        #     `current_weight_w2 = k2_idx * 2`\n        #     `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #     while `k1_idx > 0` and `k1_idx > remaining_cap_for_w1`:\n        #         `k1_idx -= 1`\n        #         `current_cost_w1 = prefix_sum_w1[k1_idx]`\n        #\n        #     # Now, `k1_idx` is the optimal count of w1 items for this `k2_idx` and `remaining_cap_for_w1`.\n        #     # The total capacity used is `k1_idx * 1 + k2_idx * 2`.\n        #     # The total cost for this combination is `current_cost_w1 + current_cost_w2`.\n        #     # We need to store this for the capacity `k1_idx * 1 + k2_idx * 2`.\n        #     # But we need `max_val_w1_w2[w]` for *all* `w`.\n        #     # This means we need to populate `max_val_w1_w2` for capacities `0` to `m`.\n\n        # The `O(M)` approach for `max_val_w1_w2[w]` for all `w`:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_count = 0`\n        # `current_cost_w1 = 0`\n        # `k2_count = 0`\n        # `current_cost_w2 = 0`\n        # `current_weight_w1_w2 = 0`\n        # `max_cost_so_far = 0`\n\n        # Iterate `w` from 0 to `m`:\n        #   `max_val_w1_w2[w] = max_val_w1_w2[w-1]` if `w > 0` (this ensures non-decreasing property)\n        #   If we add a w1 item:\n        #     If `k1_count < len(items_w1)`:\n        #       `current_cost_w1 += items_w1[k1_count]`\n        #       `k1_count += 1`\n        #       `max_val_w1_w2[w] = max(max_val_w1_w2[w], current_cost_w1)`\n        #   If we add a w2 item:\n        #     If `w >= 2` and `k2_count < len(items_w2)`:\n        #       `current_cost_w2 += items_w2[k2_count]`\n        #       `k2_count += 1`\n        #       `max_val_w1_w2[w] = max(max_val_w1_w2[w], max_val_w1_w2[w-2] + items_w2[k2_count-1])`\n        # This is still not right. This is mixing 0/1 and unbounded.\n\n        # The correct `O(M)` precomputation for `max_val_w1_w2[w]` for all `w`:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_ptr = len(items_w1)` # This ptr will go down\n        # `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        # For `k2_idx` from 0 to `min(len(items_w2), m // 2)`:\n        #     `current_cost_w2 = prefix_sum_w2[k2_idx]`\n        #     `current_weight_w2 = k2_idx * 2`\n        #     `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #     while `k1_ptr > 0` and `k1_ptr > remaining_cap_for_w1`:\n        #         `k1_ptr -= 1`\n        #         `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        #\n        #     # At this point, `k1_ptr` is the maximum number of items of weight 1 we can take\n        #     # given `k2_idx` items of weight 2 and total capacity `m`.\n        #     # The total cost for this (k1_ptr, k2_idx) combination is `current_cost_w1 + current_cost_w2`.\n        #     # The total weight for this combination is `k1_ptr * 1 + k2_idx * 2`.\n        #     # We need to store this value in `max_val_w1_w2` for its corresponding total weight.\n        #     # No, we need to store it for `m - k3*3` capacity.\n\n        # The crucial part is that `max_val_w1_w2[w]` should be the maximum value for *any* capacity `x <= w`.\n        # `max_val_w1_w2[w]` is the maximum value for weight `w` using only items of weight 1 and 2.\n        # This can be computed by iterating `k2` and using a sliding window for `k1`.\n        # `best_cost_w1_w2 = [0] * (m + 1)`\n        # `k1_idx = 0`\n        # `current_cost_w1 = 0`\n        # `current_weight_w1 = 0`\n        # For `w` from 0 to `m`:\n        #     if k1_idx < len(items_w1):\n        #         current_cost_w1 += items_w1[k1_idx]\n        #         k1_idx += 1\n        #     best_cost_w1_w2[w] = current_cost_w1\n        #\n        # `k1_idx` is `min(w+1, len(items_w1))`.\n        # `current_cost_w1` is `prefix_sum_w1[min(w+1, len(items_w1))]`. This is correct.\n        #\n        # Now, for items of weight 2:\n        # `current_k1_count = len(items_w1)`\n        # `current_cost_for_w1 = prefix_sum_w1[current_k1_count]`\n        # For `k2_count` from 1 to `min(len(items_w2), m // 2)`:\n        #     `cost_w2_items = prefix_sum_w2[k2_count]`\n        #     `weight_w2_items = k2_count * 2`\n        #     `remaining_cap_for_w1 = m - weight_w2_items`\n        #\n        #     while `current_k1_count > 0` and `current_k1_count > remaining_cap_for_w1`:\n        #         `current_k1_count -= 1`\n        #         `current_cost_for_w1 = prefix_sum_w1[current_k1_count]`\n        #\n        #     # At this point, `current_k1_count` is the optimal number of w1 items for current `k2_count`.\n        #     # The total weight for this combination is `current_k1_count * 1 + k2_count * 2`.\n        #     # The value is `current_cost_for_w1 + cost_w2_items`.\n        #     # We need to update `best_cost_w1_w2[total_weight]`.\n        #     # This structure `best_cost_w1_w2[w]` stores the max cost for *exactly* weight `w`.\n        #     # We need to compute it for all `w` from 0 to `m`.\n        #     # This is the `O(M)` precomputation.\n        #\n        #     `total_weight_current_combo = current_k1_count * 1 + k2_count * 2`\n        #     if `total_weight_current_combo <= m`:\n        #         `best_cost_w1_w2[total_weight_current_combo] = max(best_cost_w1_w2[total_weight_current_combo], current_cost_for_w1 + cost_w2_items)`\n        #\n        # After this, `best_cost_w1_w2[w]` contains the maximum cost for *exactly* weight `w`.\n        # We need to convert it to maximum cost for *up to* weight `w`.\n        # For `w` from 1 to `m`: `best_cost_w1_w2[w] = max(best_cost_w1_w2[w], best_cost_w1_w2[w-1])`.\n        # This makes `best_cost_w1_w2` monotonic non-decreasing.\n\n        # The overall algorithm:\n        # 1. Sort `items_w1`, `items_w2`, `items_w3` in descending order. `O(N log N)`\n        # 2. Compute prefix sums for all three. `O(N)`\n        # 3. Compute `max_val_w1_w2[w]` for `w` from 0 to `m`. This is the `O(M)` part.\n        #    `max_val_w1_w2 = [0] * (m + 1)`\n        #    `k1_ptr = len(items_w1)` # Number of w1 items currently considered\n        #    `current_cost_w1 = prefix_sum_w1[k1_ptr]` # Cost of these w1 items\n        #    For `k2_count` from 0 to `min(len(items_w2), m // 2)`:\n        #        `current_cost_w2 = prefix_sum_w2[k2_count]`\n        #        `current_weight_w2 = k2_count * 2`\n        #        `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #        while `k1_ptr > 0` and `k1_ptr > remaining_cap_for_w1`:\n        #            `k1_ptr -= 1`\n        #            `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        #\n        #        `total_weight_for_combo = k1_ptr * 1 + k2_count * 2`\n        #        if `total_weight_for_combo <= m`:\n        #            `max_val_w1_w2[total_weight_for_combo] = max(max_val_w1_w2[total_weight_for_combo], current_cost_w1 + current_cost_w2)`\n        #\n        #    # Make `max_val_w1_w2` array monotonic (max for up to weight `w`)\n        #    For `w` from 1 to `m`:\n        #        `max_val_w1_w2[w] = max(max_val_w1_w2[w], max_val_w1_w2[w-1])`\n        #\n        # 4. Iterate `k3` from 0 to `min(len(items_w3), m // 3)`: `O(M)`\n        #    `current_cost_3 = prefix_sum_w3[k3]`\n        #    `remaining_capacity = m - k3 * 3`\n        #    If `remaining_capacity < 0`, break.\n        #    `max_cost_w1_w2_for_rem_cap = max_val_w1_w2[remaining_capacity]`\n        #    `max_total_cost = max(max_total_cost, current_cost_3 + max_cost_w1_w2_for_rem_cap)`\n        #\n        # This is `O(N log N + M)`. This should pass.\n\n    # Step 1 & 2: Sorting and prefix sums\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    # Step 3: Compute max_val_w1_w2[w] for w from 0 to m\n    max_val_w1_w2 = [0] * (m + 1)\n    \n    # k1_ptr represents the count of weight 1 items taken\n    # current_cost_w1 is the sum of costs for items_w1[0...k1_ptr-1]\n    k1_ptr = len(items_w1)\n    current_cost_w1 = prefix_sum_w1[k1_ptr]\n    \n    # Iterate k2_count from 0 up to max possible\n    # k2_count represents the count of weight 2 items taken\n    for k2_count in range(len(items_w2) + 1):\n        current_cost_w2 = prefix_sum_w2[k2_count]\n        current_weight_w2 = k2_count * 2\n        \n        # If current_weight_w2 already exceeds total capacity m, break\n        if current_weight_w2 > m:\n            break\n            \n        remaining_cap_for_w1 = m - current_weight_w2\n\n        # Adjust k1_ptr to fit remaining_cap_for_w1\n        # k1_ptr should not exceed remaining_cap_for_w1\n        while k1_ptr > 0 and k1_ptr > remaining_cap_for_w1:\n            k1_ptr -= 1\n            current_cost_w1 = prefix_sum_w1[k1_ptr]\n        \n        # At this point, (k1_ptr, k2_count) represents an optimal combination\n        # of w1 and w2 items for the current remaining_cap_for_w1.\n        # The total weight used by this combo is k1_ptr * 1 + k2_count * 2.\n        # The total cost is current_cost_w1 + current_cost_w2.\n        \n        total_weight_for_combo = k1_ptr * 1 + k2_count * 2\n        if total_weight_for_combo <= m: # Should always be true due to remaining_cap_for_w1 logic\n            max_val_w1_w2[total_weight_for_combo] = max(max_val_w1_w2[total_weight_for_combo], current_cost_w1 + current_cost_w2)\n\n    # Make `max_val_w1_w2` array monotonic (max for up to weight `w`)\n    for w in range(1, m + 1):\n        max_val_w1_w2[w] = max(max_val_w1_w2[w], max_val_w1_w2[w-1])\n\n    # Step 4: Iterate k3 and combine with precomputed max_val_w1_w2\n    max_total_cost = 0\n    for k3_count in range(len(items_w3) + 1):\n        current_cost_3 = prefix_sum_w3[k3_count]\n        current_weight_3 = k3_count * 3\n        \n        if current_weight_3 > m:\n            break\n            \n        remaining_capacity = m - current_weight_3\n        \n        # Look up the max cost for w1 and w2 items for the remaining capacity\n        max_cost_w1_w2_for_rem_cap = max_val_w1_w2[remaining_capacity]\n        \n        max_total_cost = max(max_total_cost, current_cost_3 + max_cost_w1_w2_for_rem_cap)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n    n = int(n)\n    m = int(m)\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(sys.stdin.readline().split())\n        w = int(w)\n        c = int(c)\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else: # w == 3\n            items_w3.append(c)\n\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    # Precompute prefix sums for each weight category\n    # prefix_sum_wX[k] will store the sum of the top k costs for weight X items\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of items of weight 3\n    # k3 is the count of items of weight 3\n    for k3 in range(len(items_w3) + 1):\n        current_weight_3 = k3 * 3\n        current_cost_3 = prefix_sum_w3[k3]\n\n        if current_weight_3 > m:\n            break # Cannot take more items of weight 3\n\n        remaining_weight = m - current_weight_3\n        current_cost = current_cost_3\n\n        # Now, we need to fill the remaining_weight using items of weight 1 and 2.\n        # This is a 0/1 knapsack subproblem with only two item types.\n        # We can use a two-pointer approach or iterate over one type and binary search/calculate for the other.\n        # Since remaining_weight can be up to M, we can't iterate over k1 and k2 independently.\n        # A common technique for two item types is to iterate over one type (e.g., k2)\n        # and then use the remaining capacity for the other type (k1).\n\n        # Iterate over the number of items of weight 2\n        # k2 is the count of items of weight 2\n        \n        # Max k2 can be remaining_weight // 2, but also limited by len(items_w2)\n        max_k2_for_remaining = min(len(items_w2), remaining_weight // 2)\n        \n        # We can optimize this by finding the optimal k1 for each k2.\n        # For a fixed k2, current_weight_2 = k2 * 2, current_cost_2 = prefix_sum_w2[k2]\n        # Then remaining_weight_after_w2 = remaining_weight - current_weight_2\n        # We take as many w1 items as possible: k1 = min(len(items_w1), remaining_weight_after_w2)\n        # This is what the inner loop below does.\n\n        # The loop for k2 can be up to M/2, which is 150000.\n        # The inner calculation is O(1). So total is O(M/3 * M/2) which is too slow.\n        # This is the critical part to optimize.\n\n        # The observation is that we are trying to maximize cost for a given remaining_weight,\n        # using items of weight 1 and 2.\n        # We can precompute the maximum cost for each possible weight using only items of weight 1 and 2.\n        # Let dp_w1w2[w_cap] be max cost for weight_capacity w_cap using only w1 and w2 items.\n        # This can be computed in O(M) time using a standard DP for fixed weights, but M is too large.\n\n        # However, we have already sorted items_w1 and items_w2.\n        # We are essentially trying to solve a subproblem:\n        # maximize sum(items_w1[:k1]) + sum(items_w2[:k2])\n        # subject to k1*1 + k2*2 <= remaining_weight\n        # This is a variation of the change-making problem or bounded knapsack.\n\n        # We can use a two-pointer approach for items of weight 1 and 2.\n        # Iterate k2 from 0 up to max_k2_for_remaining.\n        # For each k2, calculate the remaining capacity for weight 1 items.\n        # Sum of items_w1[:k1] can be looked up in prefix_sum_w1.\n\n        # Let's re-evaluate the two-pointer approach for W1 and W2 items.\n        # We have remaining_weight. We want to maximize cost using w1 and w2 items.\n        # This is effectively what `max_cost_w1_w2` function would do.\n        # Since the `remaining_weight` changes for each `k3`, we can't just precompute it once.\n\n        # The total number of items of weight 1 and 2 can be up to N.\n        # The total weight can be up to M.\n\n        # Let's iterate on k2 from 0 up to min(len(items_w2), remaining_weight // 2)\n        # For each k2, calculate the cost from w2 items.\n        # The remaining capacity for w1 items is `remaining_weight - k2 * 2`.\n        # The number of w1 items we can take is `min(len(items_w1), remaining_weight - k2 * 2)`.\n        # Add the cost from w1 items using prefix_sum_w1.\n        # This loop runs for `M/2` iterations in the worst case.\n        # The outer loop for `k3` runs for `M/3` iterations.\n        # Total complexity would be `O(M/3 * M/2) = O(M^2)`, which is too slow (300000^2 is too large).\n\n        # This implies that the iteration over k3 and k2 cannot both be full range.\n        # One of them must be limited.\n\n        # Consider the \"meet-in-the-middle\" approach or small/large items.\n        # But here weights are fixed.\n\n        # What if we iterate over k1 and k2, and then k3?\n        # The problem statement has small weights, so maybe the sum of counts of items is limited? No, N is 10^5.\n        # The total weight is M.\n\n        # The crucial observation for this type of problem (small weights, large N, large M)\n        # is that we can consider a limited number of items of the heavier weights,\n        # and fill the rest with lighter weights.\n\n        # Let's reconsider the problem as:\n        # We have items of weight 1, 2, 3.\n        # We iterate over the number of items of weight 2 (`k2`) and weight 3 (`k3`).\n        # The remaining capacity `rem_w = m - k2*2 - k3*3` is then filled with `min(len(items_w1), rem_w)` items of weight 1.\n        # This is `O(len(items_w2) * len(items_w3))`, which can be `O(N^2)` in worst case, still too slow.\n        # Or `O((M/2) * (M/3))` in worst case, still too slow.\n\n        # The typical solution for small weights (1, 2, 3) is to use a DP state\n        # `dp[w]` = maximum cost for total weight `w`.\n        # `dp[w] = max(dp[w-1] + c_1, dp[w-2] + c_2, dp[w-3] + c_3)`\n        # This assumes we can take items multiple times (unbounded knapsack).\n        # Here, it's 0/1 knapsack, but items are grouped by weight.\n        # If we have `k` items of weight `w`, we can use `k` times.\n        # This is `dp[w] = max(dp[w-1] + items_w1[i], dp[w-2] + items_w2[j], dp[w-3] + items_w3[l])`\n        # where we iterate `i, j, l` over the *available* items. This is not efficient.\n\n        # The actual trick is often related to the fact that the number of items of weight 1 and 2\n        # can be very large, but the number of items of weight 3 is limited by M/3.\n        # The number of items of weight 2 is limited by M/2.\n        # The number of items of weight 1 is limited by M.\n\n        # Let's try to fix the number of items of weight 3 (`k3`) and weight 2 (`k2`).\n        # Then `k1` is determined by remaining capacity.\n        # This is the `O(M^2)` approach.\n\n        # Let's consider the items of weight 1 and 2.\n        # We can combine them. A pair of weight-1 items (total weight 2) can be compared to a single weight-2 item.\n        # Let's make a new list of \"combined\" items:\n        # `combined_items = items_w2 + list of (items_w1[i] + items_w1[i+1]) for even i`\n        # This is complicated because we might want to take an odd number of w1 items.\n\n        # A common optimization for knapsack with small weights and large N/M is to use a variation of meet-in-the-middle\n        # or to observe that for a fixed number of 'heavy' items, the remaining capacity is filled greedily with 'light' items.\n\n        # Let's consider the items of weight 1 and 2.\n        # We need to find `max_cost(remaining_weight, items_w1, items_w2)`.\n        # This subproblem can be solved efficiently.\n        # Create a list `combined_w1_w2_items`:\n        # For each item `c` in `items_w1`, add `(1, c)` to `combined_w1_w2_items`.\n        # For each item `c` in `items_w2`, add `(2, c)` to `combined_w1_w2_items`.\n        # Sort `combined_w1_w2_items` by cost/weight ratio (or just cost if weights are small).\n        # This is not a fractional knapsack, so ratio is not strictly correct.\n\n        # The solution often involves a small number of iterations for one type of item,\n        # and then a greedy approach for the others.\n        # For example, iterate `k3` from 0 to `len(items_w3)`.\n        # For each `k3`, we have `current_cost_3` and `remaining_weight`.\n        # Now we need to pick `k1` items of weight 1 and `k2` items of weight 2.\n        # `k1 * 1 + k2 * 2 <= remaining_weight`.\n        # This subproblem (max cost for `rem_w` with w1 and w2 items) can be solved by iterating `k2` from 0 up to `rem_w / 2`.\n        # For each `k2`, calculate cost `prefix_sum_w2[k2]`.\n        # Then `k1` is `min(len(items_w1), rem_w - k2*2)`.\n        # Add `prefix_sum_w1[k1]`.\n        # This is `O(len(items_w3) * (M/2))`. Still `O(M^2)`.\n\n        # The key must be that the number of items of weight 2 (k2) that we *don't* take\n        # (when we could have taken two items of weight 1 instead) is limited.\n        # Or, the number of items of weight 1 that we take is limited.\n\n        # Let's iterate over `k3` (number of items of weight 3).\n        # `k3` goes from `0` to `len(items_w3)`.\n        # `current_cost = prefix_sum_w3[k3]`\n        # `current_weight = k3 * 3`\n        # `remaining_capacity = m - current_weight`\n\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 2.\n        # This part is a common subproblem: given capacity `C`, maximize cost using items of weight `w_a` and `w_b`.\n        # If `w_a=1, w_b=2`, we can iterate `k_b` (number of items of weight 2) from `0` to `C/2`.\n        # For each `k_b`, calculate `cost_b = prefix_sum_w2[k_b]`.\n        # Remaining capacity for `w_a` is `C - k_b*2`.\n        # `k_a = min(len(items_w1), C - k_b*2)`.\n        # `cost_a = prefix_sum_w1[k_a]`.\n        # Total cost for this `k_b` is `cost_b + cost_a`.\n        # This loop is `O(C)`. So overall `O(len(items_w3) * M)`. Still `O(M^2)`.\n\n        # The only way this works is if `len(items_w3)` is small, or `M` is small.\n        # `len(items_w3)` can be up to `N=10^5`. `M` up to `3*10^5`.\n        # This means the iteration over `k3` and `k2` cannot be independent full iterations.\n\n        # Let's consider the maximum number of items of weight 2 we can take.\n        # It's `M/2`.\n        # Let's iterate `k2` from `0` to `min(len(items_w2), M/2)`.\n        # For each `k2`, we have `current_cost_2` and `current_weight_2`.\n        # `remaining_capacity = m - current_weight_2`.\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 3.\n        # This is again `O(M)`. Still `O(M^2)`.\n\n        # This problem is a classic example where the small weights are key.\n        # The number of items of weight 1 and 2 can be combined.\n        # Consider the items of weight 1 and 2.\n        # We can form a new list of \"pseudo-items\" with weight 1 and 2.\n        # `dp[w]` = max cost for weight `w` using only items of weight 1 and 2.\n        # `dp[w]` can be computed in `O(M)` time if we have an unlimited supply of each item type.\n        # But here, we have a limited supply (each item taken once).\n        # With limited supply, this is usually `O(N*M)`.\n\n        # The solution to this specific problem (weights 1, 2, 3) often involves a \"fixed-window\" or \"sliding window\"\n        # approach for two of the weights, and a greedy fill for the third.\n\n        # Let's fix the number of items of weight 3 (`k3`).\n        # `current_cost_3 = prefix_sum_w3[k3]`\n        # `remaining_weight_for_1_2 = m - 3 * k3`\n        # We need to maximize cost from w1 and w2 items within `remaining_weight_for_1_2`.\n        # Let `max_cost_for_w1_w2(capacity)` be this function.\n        # This function can be computed efficiently.\n\n        # The `max_cost_for_w1_w2(capacity)` can be found by iterating `k2` from 0 to `min(len(items_w2), capacity // 2)`.\n        # For each `k2`, the cost is `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), capacity - k2 * 2)]`.\n        # This is `O(capacity)`.\n        # So, the total complexity is `O(len(items_w3) * M)`. Still `O(M^2)`.\n\n        # The maximum value of `k3` is `min(len(items_w3), M/3)`.\n        # The maximum value of `k2` is `min(len(items_w2), M/2)`.\n        # The maximum value of `k1` is `min(len(items_w1), M)`.\n\n        # The problem statement constraints: N=10^5, M=3*10^5.\n        # An `O(N log N + M)` or `O(N log N + M log M)` or `O(N + M)` solution is expected.\n        # Sorting takes `O(N log N)`. Prefix sums take `O(N)`.\n        # The core loop must be `O(M)` or `O(M log M)`.\n\n        # Let's consider the possible trade-offs between items of weight 1 and 2.\n        # We can always replace two items of weight 1 with one item of weight 2 if it's more profitable.\n        # Or one item of weight 2 with two items of weight 1 if it's more profitable.\n        # This hints at a greedy approach.\n\n        # What if we iterate over `k2` (number of items of weight 2)?\n        # For each `k2`, we have `current_cost_2` and `current_weight_2`.\n        # `remaining_capacity_for_1_3 = m - current_weight_2`.\n        # Now we need to fill `remaining_capacity_for_1_3` with items of weight 1 and 3.\n        # This is `O(M)`. Still `O(M^2)`.\n\n        # The only way to get `O(M)` or `O(M log M)` is if one of the loops is very small,\n        # or the inner calculation is not `O(M)`.\n\n        # Let's re-examine the subproblem: maximize cost for `C` capacity using w1 and w2 items.\n        # `max_cost_for_w1_w2(capacity)`\n        # This can be seen as:\n        # We take `k2` items of weight 2. `cost_w2 = prefix_sum_w2[k2]`. `weight_w2 = k2 * 2`.\n        # We take `k1` items of weight 1. `cost_w1 = prefix_sum_w1[k1]`. `weight_w1 = k1 * 1`.\n        # `k1 + 2*k2 <= capacity`.\n        # The number of items of weight 1 to consider is `len(items_w1)`.\n        # The number of items of weight 2 to consider is `len(items_w2)`.\n\n        # Let's consider the maximum number of items of weight 2 we can take, `k2_max = min(len(items_w2), m // 2)`.\n        # Let's iterate `k2` from `0` to `k2_max`.\n        # For each `k2`, we have `cost_w2 = prefix_sum_w2[k2]`.\n        # `remaining_capacity = m - k2 * 2`.\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 3.\n        # This is `O(M)`.\n\n        # The \"trick\" for this common problem variant:\n        # Iterate over the number of items of weight 3, say `k3`.\n        # Calculate `current_cost_3 = prefix_sum_w3[k3]` and `remaining_weight = m - 3 * k3`.\n        # Now we need to fill `remaining_weight` with items of weight 1 and 2.\n        # Let's define `dp_w1w2[w]` as the maximum cost for weight `w` using *only* items of weight 1 and 2.\n        # We can compute `dp_w1w2` array.\n        # `dp_w1w2[w]` = max cost using w1 and w2 items for capacity `w`.\n        # This can be computed in `O(M)` by iterating `k2` from 0 to `M/2`.\n        # `max_cost_w1_w2_at_capacity[cap] = max(prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), cap - k2*2)])`\n        # for all valid `k2`.\n        # The crucial part is that `max_cost_w1_w2_at_capacity[cap]` can be computed efficiently for all `cap` up to `M`.\n\n        # Let `max_cost_w1_w2_at_capacity[w]` store the maximum cost using items of weight 1 and 2 for a total weight `w`.\n        # Initialize `max_cost_w1_w2_at_capacity` with `0`s.\n        # `k1_ptr = len(items_w1) - 1` (index of current best w1 item)\n        # `current_cost_w1 = 0`\n        # For `w` from 0 to `M`:\n        #   While `k1_ptr >= 0` and `(k1_ptr + 1) * 1 > w`:\n        #     `k1_ptr -= 1`\n        #   `current_cost_w1 = prefix_sum_w1[k1_ptr + 1]` (if `k1_ptr >= 0` else 0)\n        #   `max_cost_w1_w2_at_capacity[w] = current_cost_w1`\n\n        # This is not correct. `max_cost_w1_w2_at_capacity[w]` is the maximum value for *exactly* weight `w`.\n        # We need `max_cost_w1_w2_at_capacity[w]` to be the maximum value for weight *up to* `w`.\n\n        # Let's define `best_cost_for_w1_w2[w]` as the maximum cost achievable for weight `w` using items of weight 1 and 2.\n        # We can compute this array in `O(M)` time.\n        best_cost_for_w1_w2 = [0] * (m + 1)\n        k1_count = 0\n        current_cost_w1 = 0\n        \n        # This loop calculates the max cost for each capacity `w` using ONLY items of weight 1.\n        # `best_cost_for_w1_w2[w]` will initially store `prefix_sum_w1[k1_count]` where `k1_count = w`.\n        for w in range(1, m + 1):\n            if k1_count < len(items_w1):\n                current_cost_w1 += items_w1[k1_count]\n                k1_count += 1\n            best_cost_for_w1_w2[w] = current_cost_w1\n            # Note: k1_count is effectively `w` here, limited by `len(items_w1)`.\n            # So `best_cost_for_w1_w2[w]` stores `prefix_sum_w1[min(w, len(items_w1))]`.\n            \n        # Now, incorporate items of weight 2.\n        # For each `k2` (number of items of weight 2):\n        #   `cost_w2 = prefix_sum_w2[k2]`\n        #   `weight_w2 = k2 * 2`\n        #   For each `w` from `weight_w2` to `m`:\n        #     `best_cost_for_w1_w2[w] = max(best_cost_for_w1_w2[w], cost_w2 + best_cost_for_w1_w2[w - weight_w2])`\n        # This is a standard knapsack DP for two item types, but it's still `O(M * len(items_w2))`, which is `O(M^2)`.\n\n        # The actual trick for weights 1, 2, 3:\n        # Iterate over `k3` (number of weight 3 items).\n        # Iterate over `k2` (number of weight 2 items).\n        # The remaining capacity is `m - 3*k3 - 2*k2`.\n        # Fill greedily with `min(len(items_w1), remaining_capacity)` items of weight 1.\n        # This is `O(M/3 * M/2)`.\n\n        # The solution for this problem is usually to iterate over `k3` (number of items of weight 3).\n        # And for the remaining capacity, use a 2-pointer approach for items of weight 1 and 2.\n        # This means, for a fixed `k3`:\n        #   `rem_w = m - 3 * k3`\n        #   `current_cost_3 = prefix_sum_w3[k3]`\n        #   We need to find `max_cost_w1_w2(rem_w)`.\n        #   This `max_cost_w1_w2(rem_w)` can be found by iterating `k2` from `0` to `min(len(items_w2), rem_w // 2)`.\n        #   For each `k2`, the cost is `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), rem_w - k2 * 2)]`.\n        #   This is `O(rem_w)`.\n        #   So total is `O(M/3 * M)`.\n\n        # Let's consider the maximum number of items of weight 2.\n        # The number of items of weight 2, `k2`, can be from 0 to `min(len(items_w2), m/2)`.\n        # The number of items of weight 1, `k1`, can be from 0 to `min(len(items_w1), m)`.\n        # The number of items of weight 3, `k3`, can be from 0 to `min(len(items_w3), m/3)`.\n\n        # The number of items of weight 1 can be replaced by items of weight 2 (two 1s for one 2),\n        # or items of weight 3 (three 1s for one 3).\n        # The number of items of weight 2 can be replaced by items of weight 1 (one 2 for two 1s),\n        # or items of weight 3 (one 2 and one 1 for one 3).\n\n        # The actual solution is to iterate over the number of *pairs* of weight 1 items that are \"converted\" into weight 2 items.\n        # Or, more simply, iterate over `k3` (number of weight 3 items).\n        # Then, for the remaining capacity `rem_w`, we have items of weight 1 and 2.\n        # We can use a sliding window/two-pointer approach for this part.\n        # Let `k2` be the number of items of weight 2.\n        # Let `k1` be the number of items of weight 1.\n        # We want to maximize `prefix_sum_w1[k1] + prefix_sum_w2[k2]` s.t. `k1 + 2*k2 <= rem_w`.\n        # And `k1 <= len(items_w1)`, `k2 <= len(items_w2)`.\n\n        # Iterate `k2` from `min(len(items_w2), rem_w // 2)` down to 0.\n        # For each `k2`, `cost_w2 = prefix_sum_w2[k2]`.\n        # `current_rem_w = rem_w - k2 * 2`.\n        # `k1 = min(len(items_w1), current_rem_w)`.\n        # `cost_w1 = prefix_sum_w1[k1]`.\n        # `max_cost_for_rem_w = max(max_cost_for_rem_w, cost_w2 + cost_w1)`.\n        # This is `O(rem_w)`.\n\n        # The trick for the `max_cost_w1_w2(capacity)` subproblem to be `O(1)` or `O(log M)` amortized:\n        # We iterate `k3` from 0 to `min(len(items_w3), m/3)`.\n        # For each `k3`, `rem_w` decreases.\n        # When `rem_w` decreases, the maximum `k2` we can take also decreases.\n        # We can maintain the current best cost for `w1` and `w2` items as `rem_w` changes.\n\n        # Let `current_k2` be the maximum number of weight 2 items we can take for the current `rem_w`.\n        # Let `current_k1` be the number of weight 1 items we can take for the current `rem_w - current_k2 * 2`.\n        # `current_cost_w1_w2 = prefix_sum_w1[current_k1] + prefix_sum_w2[current_k2]`\n\n        # When `rem_w` decreases by 3 (from `k3` incrementing):\n        #   We need to adjust `current_k1` and `current_k2`.\n        #   `rem_w` decreases by 3.\n        #   If `current_k1 >= 3`, we can reduce `current_k1` by 3.\n        #   If `current_k1 >= 1` and `current_k2 >= 1`, we can try to reduce `current_k1` by 1 and `current_k2` by 1.\n        #   If `current_k2 >= 1`, we can try to reduce `current_k2` by 1 and increase `current_k1` by 2.\n        # This is a sliding window approach.\n\n        # Initialize `current_cost_w1_w2 = 0`.\n        # `k1_ptr = 0` (index for items_w1)\n        # `k2_ptr = 0` (index for items_w2)\n        # `current_weight_w1_w2 = 0`\n\n        # First, fill `current_cost_w1_w2` for `m` capacity.\n        # `k2_ptr` starts from `min(len(items_w2), m // 2)`.\n        # `k1_ptr` starts from `min(len(items_w1), m - k2_ptr * 2)`.\n        # This is essentially finding the best combination of w1 and w2 for `m`.\n        # Then, as `rem_w` decreases by 3, we adjust `k1_ptr` and `k2_ptr`.\n\n        # Let's try the two-pointer approach for the `w1` and `w2` items:\n        # `best_cost_w1_w2[capacity]` stores the max cost for `capacity` using `w1` and `w2` items.\n        # This array needs to be computed once.\n        # `best_cost_w1_w2 = [0] * (m + 1)`\n        # `k1_idx = 0` (number of w1 items taken)\n        # `current_cost = 0`\n        # For `cap` from 0 to `m`:\n        #   If `k1_idx < len(items_w1)`:\n        #     `current_cost += items_w1[k1_idx]`\n        #     `k1_idx += 1`\n        #   `best_cost_w1_w2[cap] = current_cost`\n        # This fills `best_cost_w1_w2` with costs from only `w1` items.\n\n        # Now, iterate `k2` from 1 to `len(items_w2)`.\n        # `cost_w2 = prefix_sum_w2[k2]`.\n        # `weight_w2 = k2 * 2`.\n        # For `cap` from `weight_w2` to `m`:\n        #   `best_cost_w1_w2[cap] = max(best_cost_w1_w2[cap], cost_w2 + best_cost_w1_w2[cap - weight_w2])`\n        # This is still `O(M * len(items_w2))`.\n        # This is the standard DP, which is too slow.\n\n        # The correct approach for `max_cost_w1_w2(capacity)` in `O(M)` time:\n        # Let `f[w]` be the maximum cost for weight `w` using only items of weight 1 and 2.\n        # Initialize `f[w] = prefix_sum_w1[min(w, len(items_w1))]` for all `w`.\n        # Now, iterate `k2` from 1 to `len(items_w2)`.\n        # For each `k2`, `current_cost_w2 = prefix_sum_w2[k2]`.\n        # For each `w` from `k2 * 2` to `m`:\n        #   We want to compare `f[w]` (which is current max cost for `w`)\n        #   with `current_cost_w2 + prefix_sum_w1[min(len(items_w1), w - k2*2)]`.\n        # This is still `O(M * len(items_w2))`.\n\n        # The actual solution for two item types of weights `W1` and `W2` (e.g., 1 and 2)\n        # to fill a capacity `C` with limited counts of items `N1` and `N2`\n        # is to iterate `k2` from `0` to `min(N2, C/W2)`.\n        # Then fill remaining capacity `C - k2*W2` with `k1 = min(N1, C - k2*W2)`.\n        # The total cost is `prefix_sum_w2[k2] + prefix_sum_w1[k1]`.\n        # This is `O(C)`.\n\n        # So, the overall algorithm is:\n        # 1. Sort items and compute prefix sums. `O(N log N)`\n        # 2. Iterate `k3` from `0` to `min(len(items_w3), M/3)`.\n        #    `current_cost_3 = prefix_sum_w3[k3]`\n        #    `remaining_capacity = m - 3 * k3`\n        #    If `remaining_capacity < 0`, break.\n        #    Find `max_cost_w1_w2` for `remaining_capacity`.\n        #    This `max_cost_w1_w2` is found by iterating `k2` from `0` to `min(len(items_w2), remaining_capacity // 2)`.\n        #    For each `k2`, calculate `cost = prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_capacity - k2 * 2)]`.\n        #    Update `max_total_cost = max(max_total_cost, current_cost_3 + cost)`.\n        # This is `O(M/3 * M/2) = O(M^2)`. This is definitely too slow.\n\n        # Wait, the problem constraints are `N <= 10^5`, `M <= 3 * 10^5`.\n        # If `N` is small, `M` is large, `O(N*M)` is slow.\n        # If `N` is large, `M` is small, `O(N*M)` is slow.\n        # The only way `O(M/3 * M/2)` is acceptable is if `M` is much smaller, e.g., `M <= 2000`.\n        # For `M = 300000`, `M^2` is `9 * 10^10`.\n\n        # Let's consider the maximum number of items of weight 2 we can take, `max_k2 = min(len(items_w2), m // 2)`.\n        # Let's iterate `k2` from `max_k2` down to 0.\n        # `current_cost_w2 = prefix_sum_w2[k2]`\n        # `remaining_capacity = m - k2 * 2`\n        # Now we need to fill `remaining_capacity` with items of weight 1 and 3.\n        # `k3_ptr = min(len(items_w3), remaining_capacity // 3)`\n        # `k1_ptr = min(len(items_w1), remaining_capacity - k3_ptr * 3)`\n        # We need to find the best combination of `k1` and `k3`.\n        # This is the same `O(M)` subproblem.\n\n        # The standard approach for this problem (fixed weights 1, 2, 3) is to iterate over the number of items of weight 1,\n        # and then use a \"sliding window\" or \"two pointers\" for items of weight 2 and 3.\n        # Or, iterate over the number of items of weight 3.\n        # For the remaining capacity, use a sliding window for items of weight 1 and 2.\n\n        # Let's try to optimize `max_cost_w1_w2(capacity)`.\n        # The function `f(cap) = max_cost_w1_w2(cap)` needs to be computed for all `cap` from 0 to `M`.\n        # `f[cap]` is the best cost for exactly `cap` weight using only w1 and w2.\n        # `f[cap] = max(f[cap-1] + cost_w1, f[cap-2] + cost_w2)`\n        # This is unbounded knapsack. For 0/1 knapsack, it's harder.\n\n        # The actual solution is to iterate over `k3` from 0 to `min(len(items_w3), m // 3)`.\n        # For each `k3`, we have `current_cost_3 = prefix_sum_w3[k3]`.\n        # `rem_w = m - k3 * 3`.\n        # Now, we need to find `max_cost_w1_w2(rem_w)`.\n        # This `max_cost_w1_w2(rem_w)` can be found using a two-pointer approach,\n        # but the pointers are not for `k1` and `k2` directly.\n        # It's about maintaining `k1` and `k2` to maximize cost as `rem_w` changes.\n\n        # Let's define `current_k1_count`, `current_k2_count`, `current_cost_1_2`.\n        # Initialize `current_k2_count = min(len(items_w2), m // 2)`.\n        # `current_k1_count = min(len(items_w1), m - current_k2_count * 2)`.\n        # `current_cost_1_2 = prefix_sum_w1[current_k1_count] + prefix_sum_w2[current_k2_count]`.\n        # `max_total_cost = current_cost_1_2`.\n\n        # Now, iterate `k3` from 1 to `min(len(items_w3), m // 3)`.\n        # `current_cost_3 = prefix_sum_w3[k3]`.\n        # `rem_w = m - k3 * 3`.\n        # We need to update `current_k1_count`, `current_k2_count` for this new `rem_w`.\n        # Since `rem_w` has decreased by 3, we must remove 3 units of weight from `w1`/`w2` items.\n        # We can remove:\n        #   - three w1 items (cost `items_w1[current_k1_count-1] + items_w1[current_k1_count-2] + items_w1[current_k1_count-3]`)\n        #   - one w1 item and one w2 item (cost `items_w1[current_k1_count-1] + items_w2[current_k2_count-1]`)\n        #   - one w2 item and add two w1 items (if `current_k1_count + 2 <= len(items_w1)`)\n        # This is a bit complex to manage dynamically.\n\n        # A simpler version of the two-pointer approach for `max_cost_w1_w2(capacity)`:\n        # Let `k1` be the number of items of weight 1.\n        # Let `k2` be the number of items of weight 2.\n        # We want to maximize `prefix_sum_w1[k1] + prefix_sum_w2[k2]` subject to `k1 + 2*k2 <= capacity`.\n        # Initialize `current_max_cost_w1_w2 = 0`.\n        # `k1_ptr = min(len(items_w1), capacity)`\n        # `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        # For `k2` from 0 to `min(len(items_w2), capacity // 2)`:\n        #   `current_cost_w2 = prefix_sum_w2[k2]`\n        #   `remaining_capacity_for_w1 = capacity - k2 * 2`\n        #   While `k1_ptr > remaining_capacity_for_w1`: # Too many w1 items\n        #     `current_cost_w1 -= items_w1[k1_ptr - 1]`\n        #     `k1_ptr -= 1`\n        #   `current_max_cost_w1_w2 = max(current_max_cost_w1_w2, current_cost_w1 + current_cost_w2)`\n        # This loop for `k2` runs `O(M)` times. The inner `while` loop runs `O(M)` times in total across all `k2`.\n        # So `max_cost_w1_w2(capacity)` is `O(M)`.\n        # The outer loop for `k3` is `O(M)`. So total `O(M^2)`. Still too slow.\n\n        # The actual solution for this problem is usually `O(M)` or `O(M log M)`.\n        # This implies that the inner `max_cost_w1_w2(rem_w)` cannot be `O(M)`.\n        # It must be `O(1)` amortized or `O(log M)`.\n\n        # A common trick is to realize that for items of weight 1 and 2,\n        # the number of items of weight 2 that we take, `k2`, can be limited.\n        # Specifically, if we have enough capacity and enough items of weight 1,\n        # we can always replace two items of weight 1 with one item of weight 2.\n        # We can also replace one item of weight 2 with two items of weight 1.\n        # This means we only need to consider a small range of `k2` values.\n        # For example, if we have `C` capacity, `k2` can range from `0` to `C/2`.\n        # If we take `k2` items of weight 2, we have `C - 2*k2` capacity for weight 1 items.\n        # We pick `k1 = min(len(items_w1), C - 2*k2)` items of weight 1.\n\n        # The crucial insight for `O(M)`:\n        # Let `dp[w]` be the maximum cost for weight `w` using items of weight 1 and 2.\n        # `dp[w]` can be computed in `O(M)` for all `w` up to `M` *if* we can use a sliding window maximum/minimum technique (deque).\n        # This is for the bounded knapsack problem when weights are small and counts are large.\n        # For each `w` from 0 to `M`:\n        # `dp[w] = prefix_sum_w1[min(w, len(items_w1))]` (base case: only w1 items)\n        # Then, for items of weight 2:\n        # For each `k2` from 1 to `len(items_w2)`:\n        #   `cost_w2 = items_w2[k2-1]` (cost of the k2-th item of weight 2)\n        #   For `w` from `M` down to `2`:\n        #     `dp[w] = max(dp[w], dp[w-2] + cost_w2)`\n        # This is still `O(M * len(items_w2))`.\n\n        # The solution must be `O(M)` or `O(M log M)`.\n        # The iteration over `k3` (number of weight 3 items) is `O(M)`.\n        # For each `k3`, we have `rem_w = m - 3*k3`.\n        # We need to find `max_cost_w1_w2(rem_w)`.\n        # This `max_cost_w1_w2(rem_w)` must be found in `O(1)` amortized time.\n\n        # Let's use two pointers `ptr1` for items of weight 1 and `ptr2` for items of weight 2.\n        # We want to maximize `prefix_sum_w1[ptr1] + prefix_sum_w2[ptr2]`\n        # subject to `ptr1 * 1 + ptr2 * 2 <= rem_w`.\n        # As `rem_w` decreases (due to increasing `k3`), we need to adjust `ptr1` and `ptr2`.\n\n        # Initialize:\n        # `current_cost_1_2 = 0`\n        # `ptr1 = 0` (number of w1 items taken)\n        # `ptr2 = 0` (number of w2 items taken)\n        # `current_weight_1_2 = 0`\n\n        # Step 1: Fill as much as possible with `w1` and `w2` items up to `m`.\n        # Maximize `prefix_sum_w1[k1] + prefix_sum_w2[k2]` for `k1 + 2*k2 <= m`.\n        # This is the `O(M)` part.\n        # `ptr2` iterates from `min(len(items_w2), m // 2)` down to 0.\n        # `ptr1` is adjusted to `min(len(items_w1), m - ptr2 * 2)`.\n        # This gives `max_cost_w1_w2_upto_m`.\n\n        # The actual solution for this problem is a standard DP with limited weights.\n        # Let `dp[w]` be the maximum value for weight `w` using items of weight 1 and 2.\n        # `dp[w]` is initialized to `prefix_sum_w1[min(w, len(items_w1))]`.\n        # Then, we iterate through `items_w2`. For each `c2` in `items_w2`:\n        #   For `w` from `m` down to `2`:\n        #     `dp[w] = max(dp[w], dp[w-2] + c2)`\n        # This is `O(M * len(items_w2))`, which is `O(M*N)`. Still too slow.\n\n        # The optimization for bounded knapsack with small weights:\n        # We can use a deque for each remainder `w % weight`.\n        # For weight 2: `dp[w]` depends on `dp[w-2]`.\n        # For weight 1: `dp[w]` depends on `dp[w-1]`.\n        # For weight 3: `dp[w]` depends on `dp[w-3]`.\n\n        # Let's consider the structure of the problem again.\n        # `max_total_cost = max_{k1, k2, k3} (prefix_sum_w1[k1] + prefix_sum_w2[k2] + prefix_sum_w3[k3])`\n        # s.t. `k1*1 + k2*2 + k3*3 <= m`.\n\n        # The `O(M)` solution relies on the fact that we can iterate `k3` from 0 to `M/3`.\n        # For each `k3`, we need to find `max_cost_w1_w2(m - 3*k3)`.\n        # This `max_cost_w1_w2(C)` can be computed by a sliding window.\n        # Let `k1_count` be the number of weight 1 items, `k2_count` for weight 2 items.\n        # As `k3` increases, `C` decreases.\n        # We need to *decrease* the number of `w1` and `w2` items to fit `C`.\n        # We start with `k3 = 0`, `C = m`.\n        # Find `(k1_opt, k2_opt)` for `C=m`.\n        # Then, for `k3 = 1`, `C = m-3`.\n        # We need to reduce total weight by 3.\n        # We can either remove three `w1` items, or one `w1` and one `w2` item, or some other combination.\n        # This is where the two-pointer/sliding window comes in.\n\n        # Let `current_k1_idx` be the number of items of weight 1 taken.\n        # Let `current_k2_idx` be the number of items of weight 2 taken.\n        # Let `current_cost_1_2` be `prefix_sum_w1[current_k1_idx] + prefix_sum_w2[current_k2_idx]`.\n        # `current_total_weight_1_2 = current_k1_idx * 1 + current_k2_idx * 2`.\n\n        # Initialize `current_k2_idx = min(len(items_w2), m // 2)`.\n        # `current_k1_idx = min(len(items_w1), m - current_k2_idx * 2)`.\n        # `current_cost_1_2 = prefix_sum_w1[current_k1_idx] + prefix_sum_w2[current_k2_idx]`.\n        # `max_total_cost = current_cost_1_2`.\n\n        # Iterate `k3` from 1 to `min(len(items_w3), m // 3)`:\n        #   `current_cost_3 = prefix_sum_w3[k3]`\n        #   `remaining_capacity = m - k3 * 3`\n        #   While `current_total_weight_1_2 > remaining_capacity`:\n        #     We need to reduce weight.\n        #     Option 1: Remove a w1 item. Only if `current_k1_idx > 0`.\n        #     Option 2: Remove a w2 item. Only if `current_k2_idx > 0`.\n        #     Which one to remove? The one that costs less.\n        #     If `current_k1_idx > 0` and (`current_k2_idx == 0` or `items_w1[current_k1_idx - 1] < items_w2[current_k2_idx - 1]`):\n        #       `current_cost_1_2 -= items_w1[current_k1_idx - 1]`\n        #       `current_k1_idx -= 1`\n        #       `current_total_weight_1_2 -= 1`\n        #     Else if `current_k2_idx > 0`:\n        #       `current_cost_1_2 -= items_w2[current_k2_idx - 1]`\n        #       `current_k2_idx -= 1`\n        #       `current_total_weight_1_2 -= 2`\n        #     Else: # Cannot reduce weight further, but still over capacity. This k3 is impossible.\n        #       break (or handle error, should not happen if logic is right)\n\n        #   This `while` loop has to be more sophisticated.\n        #   It's not just reducing weight, it's about finding the optimal `k1, k2` for `remaining_capacity`.\n        #   When `rem_w` drops by 3:\n        #   We might need to decrease `k2_idx` and increase `k1_idx` to maintain optimal.\n        #   Or decrease `k1_idx`.\n\n        # The correct two-pointer approach for `max_cost_w1_w2(capacity)`:\n        # `current_k1_count = min(len(items_w1), capacity)`\n        # `current_cost_w1_w2 = prefix_sum_w1[current_k1_count]`\n        # `max_cost_for_current_capacity = current_cost_w1_w2`\n        # `k2_idx` starts from 1.\n        # For `k2_idx` from 1 up to `min(len(items_w2), capacity // 2)`:\n        #   `current_cost_w2_part = prefix_sum_w2[k2_idx]`\n        #   `remaining_cap_for_w1 = capacity - k2_idx * 2`\n        #   While `current_k1_count > remaining_cap_for_w1`:\n        #     `current_cost_w1_w2 -= items_w1[current_k1_count - 1]`\n        #     `current_k1_count -= 1`\n        #   `max_cost_for_current_capacity = max(max_cost_for_current_capacity, current_cost_w1_w2 + current_cost_w2_part)`\n        # This is `O(capacity)` for one call. Still `O(M^2)`.\n\n        # The actual solution for this problem:\n        # The maximum number of items of weight 2 we can pick, say `max_k2`, is `m/2`.\n        # The number of items of weight 1 we can pick, say `max_k1`, is `m`.\n        # The number of items of weight 3 we can pick, say `max_k3`, is `m/3`.\n\n        # Let's iterate `k3` from 0 to `min(len(items_w3), m // 3)`.\n        # `current_cost_3 = prefix_sum_w3[k3]`.\n        # `rem_w = m - 3 * k3`.\n        # Now we need to find `max_cost_w1_w2(rem_w)`.\n        # This is the part that needs to be `O(1)` amortized.\n\n        # We can precompute `max_cost_w1_w2[w]` for all `w` from 0 to `m`.\n        # `max_cost_w1_w2_arr = [0] * (m + 1)`\n        # `cur_w1_cost = 0`\n        # `cur_w1_count = 0`\n        # `cur_w2_cost = 0`\n        # `cur_w2_count = 0`\n        # `ptr_w1 = 0`\n        # `ptr_w2 = 0`\n\n        # The two-pointer approach for `max_cost_w1_w2(capacity)` that is `O(M)` in total for all capacities:\n        # `dp_w1w2[w]` = max cost for weight `w` using only items of weight 1 and 2.\n        # Initialize `dp_w1w2[w] = prefix_sum_w1[min(w, len(items_w1))]`.\n        # `current_cost_w2_items = 0`\n        # `k1_ptr = len(items_w1)` (number of w1 items currently considered)\n        # For `k2` from 0 to `min(len(items_w2), m // 2)`:\n        #   `current_cost_w2_items = prefix_sum_w2[k2]`\n        #   `remaining_cap_for_w1 = m - k2 * 2`\n        #   While `k1_ptr > 0` and `k1_ptr > remaining_cap_for_w1`:\n        #     `k1_ptr -= 1`\n        #   `current_cost_w1_items = prefix_sum_w1[k1_ptr]`\n        #   `max_total_cost = max(max_total_cost, current_cost_w1_items + current_cost_w2_items)`\n        # This is `O(M)` because `k2` goes from 0 to `M/2` and `k1_ptr` only decreases.\n        # Total `O(M)` for this part.\n\n        # So, the overall algorithm is:\n        # 1. Sort items and compute prefix sums: `O(N log N)`.\n        # 2. Iterate `k3` from 0 to `min(len(items_w3), m // 3)`:\n        #    `current_cost_3 = prefix_sum_w3[k3]`\n        #    `remaining_capacity = m - 3 * k3`\n        #    If `remaining_capacity < 0`, break.\n        #    Calculate `max_cost_w1_w2` for `remaining_capacity`.\n        #    This `max_cost_w1_w2` should be `O(1)` using a precomputed array.\n\n        # Let's define `max_val_w1_w2[w]` as the maximum cost for capacity `w` using only items of weight 1 and 2.\n        # This array can be computed in `O(M)` time.\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_ptr = len(items_w1)` # current number of w1 items considered\n        # `current_w1_cost = prefix_sum_w1[k1_ptr]` # current cost of w1 items\n        # For `k2` from 0 to `min(len(items_w2), m // 2)`:\n        #     `current_w2_cost = prefix_sum_w2[k2]`\n        #     `current_weight_w2 = k2 * 2`\n        #     `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #     # Adjust k1_ptr to fit remaining_cap_for_w1\n        #     # k1_ptr should not exceed len(items_w1) and remaining_cap_for_w1\n        #     while k1_ptr > 0 and k1_ptr > remaining_cap_for_w1:\n        #         k1_ptr -= 1\n        #         current_w1_cost = prefix_sum_w1[k1_ptr] # Update cost from prefix sum\n        #\n        #     # At this point, k1_ptr is the max number of w1 items that can fit.\n        #     # If k1_ptr is 0 and remaining_cap_for_w1 is positive, it means we ran out of w1 items.\n        #     # We should ensure current_w1_cost correctly reflects prefix_sum_w1[k1_ptr].\n        #     \n        #     # The maximum capacity this combination of k1_ptr and k2 can achieve is k1_ptr * 1 + k2 * 2.\n        #     # This cost is `current_w1_cost + current_w2_cost`.\n        #     # We need to store this for all `w` from 0 to `m`.\n        #     # This approach calculates `max_val_w1_w2[m]` directly.\n        #     # We need `max_val_w1_w2[w]` for all `w` from 0 to `m`.\n\n        # To compute `max_val_w1_w2[w]` for all `w` in `O(M)`:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_ptr = 0` # current index for items_w1\n        # `current_cost_w1 = 0`\n        # For `w` from 0 to `m`:\n        #     If `k1_ptr < len(items_w1)`:\n        #         `current_cost_w1 += items_w1[k1_ptr]`\n        #         `k1_ptr += 1`\n        #     `max_val_w1_w2[w] = current_cost_w1`\n        #\n        # `k2_ptr = 0` # current index for items_w2\n        # `current_cost_w2 = 0`\n        # For `w` from 0 to `m`:\n        #     `current_val = max_val_w1_w2[w]`\n        #     If `w >= 2` and `k2_ptr < len(items_w2)`:\n        #         `current_val = max(current_val, max_val_w1_w2[w-2] + items_w2[k2_ptr])`\n        #     `max_val_w1_w2[w] = current_val`\n        # This is not right. This is an unbounded knapsack.\n\n        # The correct `O(M)` calculation for `max_val_w1_w2[w]` is:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_idx = len(items_w1)`\n        # `current_cost_w1 = prefix_sum_w1[k1_idx]`\n        # For `k2_idx` from 0 to `min(len(items_w2), m // 2)`:\n        #     `current_cost_w2 = prefix_sum_w2[k2_idx]`\n        #     `current_weight_w2 = k2_idx * 2`\n        #     `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #     while `k1_idx > 0` and `k1_idx > remaining_cap_for_w1`:\n        #         `k1_idx -= 1`\n        #         `current_cost_w1 = prefix_sum_w1[k1_idx]`\n        #\n        #     # Now, `k1_idx` is the optimal count of w1 items for this `k2_idx` and `remaining_cap_for_w1`.\n        #     # The total capacity used is `k1_idx * 1 + k2_idx * 2`.\n        #     # The total cost for this combination is `current_cost_w1 + current_cost_w2`.\n        #     # We need to store this for the capacity `k1_idx * 1 + k2_idx * 2`.\n        #     # But we need `max_val_w1_w2[w]` for *all* `w`.\n        #     # This means we need to populate `max_val_w1_w2` for capacities `0` to `m`.\n\n        # The `O(M)` approach for `max_val_w1_w2[w]` for all `w`:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_count = 0`\n        # `current_cost_w1 = 0`\n        # `k2_count = 0`\n        # `current_cost_w2 = 0`\n        # `current_weight_w1_w2 = 0`\n        # `max_cost_so_far = 0`\n\n        # Iterate `w` from 0 to `m`:\n        #   `max_val_w1_w2[w] = max_val_w1_w2[w-1]` if `w > 0` (this ensures non-decreasing property)\n        #   If we add a w1 item:\n        #     If `k1_count < len(items_w1)`:\n        #       `current_cost_w1 += items_w1[k1_count]`\n        #       `k1_count += 1`\n        #       `max_val_w1_w2[w] = max(max_val_w1_w2[w], current_cost_w1)`\n        #   If we add a w2 item:\n        #     If `w >= 2` and `k2_count < len(items_w2)`:\n        #       `current_cost_w2 += items_w2[k2_count]`\n        #       `k2_count += 1`\n        #       `max_val_w1_w2[w] = max(max_val_w1_w2[w], max_val_w1_w2[w-2] + items_w2[k2_count-1])`\n        # This is still not right. This is mixing 0/1 and unbounded.\n\n        # The correct `O(M)` precomputation for `max_val_w1_w2[w]` for all `w`:\n        # `max_val_w1_w2 = [0] * (m + 1)`\n        # `k1_ptr = len(items_w1)` # This ptr will go down\n        # `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        # For `k2_idx` from 0 to `min(len(items_w2), m // 2)`:\n        #     `current_cost_w2 = prefix_sum_w2[k2_idx]`\n        #     `current_weight_w2 = k2_idx * 2`\n        #     `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #     while `k1_ptr > 0` and `k1_ptr > remaining_cap_for_w1`:\n        #         `k1_ptr -= 1`\n        #         `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        #\n        #     # At this point, `k1_ptr` is the maximum number of items of weight 1 we can take\n        #     # given `k2_idx` items of weight 2 and total capacity `m`.\n        #     # The total cost for this (k1_ptr, k2_idx) combination is `current_cost_w1 + current_cost_w2`.\n        #     # The total weight for this combination is `k1_ptr * 1 + k2_idx * 2`.\n        #     # We need to store this value in `max_val_w1_w2` for its corresponding total weight.\n        #     # No, we need to store it for `m - k3*3` capacity.\n\n        # The crucial part is that `max_val_w1_w2[w]` should be the maximum value for *any* capacity `x <= w`.\n        # `max_val_w1_w2[w]` is the maximum value for weight `w` using only items of weight 1 and 2.\n        # This can be computed by iterating `k2` and using a sliding window for `k1`.\n        # `best_cost_w1_w2 = [0] * (m + 1)`\n        # `k1_idx = 0`\n        # `current_cost_w1 = 0`\n        # `current_weight_w1 = 0`\n        # For `w` from 0 to `m`:\n        #     if k1_idx < len(items_w1):\n        #         current_cost_w1 += items_w1[k1_idx]\n        #         k1_idx += 1\n        #     best_cost_w1_w2[w] = current_cost_w1\n        #\n        # `k1_idx` is `min(w+1, len(items_w1))`.\n        # `current_cost_w1` is `prefix_sum_w1[min(w+1, len(items_w1))]`. This is correct.\n        #\n        # Now, for items of weight 2:\n        # `current_k1_count = len(items_w1)`\n        # `current_cost_for_w1 = prefix_sum_w1[current_k1_count]`\n        # For `k2_count` from 1 to `min(len(items_w2), m // 2)`:\n        #     `cost_w2_items = prefix_sum_w2[k2_count]`\n        #     `weight_w2_items = k2_count * 2`\n        #     `remaining_cap_for_w1 = m - weight_w2_items`\n        #\n        #     while `current_k1_count > 0` and `current_k1_count > remaining_cap_for_w1`:\n        #         `current_k1_count -= 1`\n        #         `current_cost_for_w1 = prefix_sum_w1[current_k1_count]`\n        #\n        #     # At this point, `current_k1_count` is the optimal number of w1 items for current `k2_count`.\n        #     # The total weight for this combination is `current_k1_count * 1 + k2_count * 2`.\n        #     # The value is `current_cost_for_w1 + cost_w2_items`.\n        #     # We need to update `best_cost_w1_w2[total_weight]`.\n        #     # This structure `best_cost_w1_w2[w]` stores the max cost for *exactly* weight `w`.\n        #     # We need to compute it for all `w` from 0 to `m`.\n        #     # This is the `O(M)` precomputation.\n        #\n        #     `total_weight_current_combo = current_k1_count * 1 + k2_count * 2`\n        #     if `total_weight_current_combo <= m`:\n        #         `best_cost_w1_w2[total_weight_current_combo] = max(best_cost_w1_w2[total_weight_current_combo], current_cost_for_w1 + cost_w2_items)`\n        #\n        # After this, `best_cost_w1_w2[w]` contains the maximum cost for *exactly* weight `w`.\n        # We need to convert it to maximum cost for *up to* weight `w`.\n        # For `w` from 1 to `m`: `best_cost_w1_w2[w] = max(best_cost_w1_w2[w], best_cost_w1_w2[w-1])`.\n        # This makes `best_cost_w1_w2` monotonic non-decreasing.\n\n        # The overall algorithm:\n        # 1. Sort `items_w1`, `items_w2`, `items_w3` in descending order. `O(N log N)`\n        # 2. Compute prefix sums for all three. `O(N)`\n        # 3. Compute `max_val_w1_w2[w]` for `w` from 0 to `m`. This is the `O(M)` part.\n        #    `max_val_w1_w2 = [0] * (m + 1)`\n        #    `k1_ptr = len(items_w1)` # Number of w1 items currently considered\n        #    `current_cost_w1 = prefix_sum_w1[k1_ptr]` # Cost of these w1 items\n        #    For `k2_count` from 0 to `min(len(items_w2), m // 2)`:\n        #        `current_cost_w2 = prefix_sum_w2[k2_count]`\n        #        `current_weight_w2 = k2_count * 2`\n        #        `remaining_cap_for_w1 = m - current_weight_w2`\n        #\n        #        while `k1_ptr > 0` and `k1_ptr > remaining_cap_for_w1`:\n        #            `k1_ptr -= 1`\n        #            `current_cost_w1 = prefix_sum_w1[k1_ptr]`\n        #\n        #        `total_weight_for_combo = k1_ptr * 1 + k2_count * 2`\n        #        if `total_weight_for_combo <= m`:\n        #            `max_val_w1_w2[total_weight_for_combo] = max(max_val_w1_w2[total_weight_for_combo], current_cost_w1 + current_cost_w2)`\n        #\n        #    # Make `max_val_w1_w2` array monotonic (max for up to weight `w`)\n        #    For `w` from 1 to `m`:\n        #        `max_val_w1_w2[w] = max(max_val_w1_w2[w], max_val_w1_w2[w-1])`\n        #\n        # 4. Iterate `k3` from 0 to `min(len(items_w3), m // 3)`: `O(M)`\n        #    `current_cost_3 = prefix_sum_w3[k3]`\n        #    `remaining_capacity = m - k3 * 3`\n        #    If `remaining_capacity < 0`, break.\n        #    `max_cost_w1_w2_for_rem_cap = max_val_w1_w2[remaining_capacity]`\n        #    `max_total_cost = max(max_total_cost, current_cost_3 + max_cost_w1_w2_for_rem_cap)`\n        #\n        # This is `O(N log N + M)`. This should pass.\n\n    # Step 1 & 2: Sorting and prefix sums\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    # Step 3: Compute max_val_w1_w2[w] for w from 0 to m\n    max_val_w1_w2 = [0] * (m + 1)\n    \n    # k1_ptr represents the count of weight 1 items taken\n    # current_cost_w1 is the sum of costs for items_w1[0...k1_ptr-1]\n    k1_ptr = len(items_w1)\n    current_cost_w1 = prefix_sum_w1[k1_ptr]\n    \n    # Iterate k2_count from 0 up to max possible\n    # k2_count represents the count of weight 2 items taken\n    for k2_count in range(len(items_w2) + 1):\n        current_cost_w2 = prefix_sum_w2[k2_count]\n        current_weight_w2 = k2_count * 2\n        \n        # If current_weight_w2 already exceeds total capacity m, break\n        if current_weight_w2 > m:\n            break\n            \n        remaining_cap_for_w1 = m - current_weight_w2\n\n        # Adjust k1_ptr to fit remaining_cap_for_w1\n        # k1_ptr should not exceed remaining_cap_for_w1\n        while k1_ptr > 0 and k1_ptr > remaining_cap_for_w1:\n            k1_ptr -= 1\n            current_cost_w1 = prefix_sum_w1[k1_ptr]\n        \n        # At this point, (k1_ptr, k2_count) represents an optimal combination\n        # of w1 and w2 items for the current remaining_cap_for_w1.\n        # The total weight used by this combo is k1_ptr * 1 + k2_count * 2.\n        # The total cost is current_cost_w1 + current_cost_w2.\n        \n        total_weight_for_combo = k1_ptr * 1 + k2_count * 2\n        if total_weight_for_combo <= m: # Should always be true due to remaining_cap_for_w1 logic\n            max_val_w1_w2[total_weight_for_combo] = max(max_val_w1_w2[total_weight_for_combo], current_cost_w1 + current_cost_w2)\n\n    # Make `max_val_w1_w2` array monotonic (max for up to weight `w`)\n    for w in range(1, m + 1):\n        max_val_w1_w2[w] = max(max_val_w1_w2[w], max_val_w1_w2[w-1])\n\n    # Step 4: Iterate k3 and combine with precomputed max_val_w1_w2\n    max_total_cost = 0\n    for k3_count in range(len(items_w3) + 1):\n        current_cost_3 = prefix_sum_w3[k3_count]\n        current_weight_3 = k3_count * 3\n        \n        if current_weight_3 > m:\n            break\n            \n        remaining_capacity = m - current_weight_3\n        \n        # Look up the max cost for w1 and w2 items for the remaining capacity\n        max_cost_w1_w2_for_rem_cap = max_val_w1_w2[remaining_capacity]\n        \n        max_total_cost = max(max_total_cost, current_cost_3 + max_cost_w1_w2_for_rem_cap)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 487,
        "completion_token_count": 19147,
        "thoughts_token_count": 774
    }
}