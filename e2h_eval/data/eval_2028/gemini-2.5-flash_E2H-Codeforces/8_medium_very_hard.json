{
    "start": 1758011978.3533306,
    "end": 1758012060.53258,
    "start-formatted": "2025-09-16 17:39 KST",
    "end-formatted": "2025-09-16 17:41 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Problem Breakdown and Algorithm Design**\n\nOkay, so I'm tackling this competitive programming problem called \"Flawed Flow.\" The core is directing edges in an undirected graph to make it a directed acyclic graph (DAG) representing a valid flow. I have to make sure flow is conserved for all intermediate nodes, that vertex 1 (the source) has no incoming edges, and that there are no cycles. Also, the flow volumes I'm given are a maximum flow, which might provide clues.\n\nI started by breaking down the constraints.  The flow conservation rule for intermediate nodes is standard. The source's lack of incoming edges means all its edges point outwards. No cycles are the big one; this guarantees there's a topological ordering, so the flow moves forward. Also, no outgoing edges from the sink, `n`, is implied.  The max-flow aspect is more of a hint at the structure of the solution. Since a solution *is* guaranteed, total incident capacity must be even for any vertex from 1 < v < n.\n\nThe \"no cycles\" condition is the strongest constraint. It suggests a topological sort-like approach.  I reasoned that if there are no cycles, the graph can be arranged so flow only moves in one direction. Since vertex 1 has no incoming edges, it must be the \"beginning\" of the flow, the source. Conversely, vertex `n` must be the final destination, and since flow is conserved, it can be assumed `n` has no outgoing edges. All intermediate vertices need their incoming and outgoing flows to be balanced.\n\nI realized I can define a \"deficit\" or \"surplus\" of flow for each vertex. Directing an edge `u -> v` increases `u`'s balance and reduces `v`'s.  I need to ensure the balance is positive for the source, negative for the sink, and zero for all intermediates.\n\nI'm thinking a queue-based approach is best. Since flow from vertex `1` is known, it gets pushed outwards to the network, and the process gets repeated. The problem guarantees there is a correct output. So if a vertex has all incoming edges' capacity calculated, then only the existing flow volume will determine the correct outgoing edges. \n\nThe strategy is to process vertices based on their flow balance. I'll maintain `current_inflow` and `total_incident_capacity` for each vertex. For an intermediate vertex, when the incoming flow equals half its total incident capacity, all remaining edges must be directed outwards. This ensures flow conservation and no cycles.\n\nI'm initializing a queue. Then, I'll direct all edges from the source outwards.  Then, as a vertex gets its flow balance \"fixed\" – meaning its incoming flow is equal to half its total incident capacity - I'll add it to the queue. While the queue is not empty, I'll pick a vertex and direct its edges.\n\nThe resulting directed graph from this method will be a DAG because I'm forcing edges to be directed from those in the queue. This will satisfy the no-cycle condition and the flow balance requirement for intermediate vertices. Vertex 1 must have a net outgoing flow, and vertex `n` must receive all the flow, but it has no need to balance incoming/outgoing edges.  The complexity should be O(N + M) - linear.\n",
    "response": "The problem asks us to direct each edge in a given undirected graph, along with its flow volume, such that several conditions are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < v < n), the sum of incoming flow must equal the sum of outgoing flow.\n2.  **Source Condition:** Vertex 1 (the source) must have no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n4.  **Max Flow:** The given flow volumes correspond to a maximum flow (this is a hint, but the core task is direction).\n\nLet's analyze the conditions:\n\n*   **Source (vertex 1):** The condition \"vertex with number 1 has no incoming edges\" means that for any edge `(1, u)` with flow `c`, it must be directed `1 -> u`.\n*   **Intermediate Vertices (1 < v < n):** For these vertices, `sum(inflow) = sum(outflow)`. Let `TotalFlowAround[v]` be the sum of capacities of all edges incident to `v`. Since `sum(inflow) + sum(outflow) = TotalFlowAround[v]`, it must be that `2 * sum(inflow) = TotalFlowAround[v]`. This implies `TotalFlowAround[v]` must be an even number, and `sum(inflow) = sum(outflow) = TotalFlowAround[v] / 2`. The problem guarantees a solution exists, so this property must hold.\n*   **Sink (vertex n):** While not explicitly stated, in a max-flow problem on a DAG, the sink `n` typically has no outgoing edges. If it had outgoing edges, and the graph must be acyclic, that flow would have to exit the graph, which is not standard for max-flow. Thus, we can safely assume `sum(outflow)` for vertex `n` is 0.\n*   **Acyclicity:** This is a strong constraint. It implies that we can find a topological ordering of the vertices. Flow must always go from a \"lower\" ranked vertex to a \"higher\" ranked vertex in this ordering. Vertex 1 will be the lowest rank, and vertex `n` the highest.\n\n**Algorithm Idea:**\n\nThe problem can be solved using a BFS-like approach that builds the topological order and directs edges. We start by processing the source (vertex 1), then propagate the flow.\n\n1.  **Initialization:**\n    *   Store the graph using an adjacency list `adj[u]` where each element is `(v, capacity, edge_index)`.\n    *   Store the original `(a_i, b_i)` for each edge `i` in `edges_info` to correctly determine the output direction (0 or 1).\n    *   `ans`: an array of size `m` to store the direction for each edge. Initialize with `-1` (undirected).\n    *   `total_incident_capacity[v]`: For each vertex `v`, calculate the sum of capacities of all edges incident to it.\n    *   `current_inflow[v]`: For each vertex `v`, keep track of the sum of capacities of edges already directed *into* `v`. Initialize to 0.\n    *   `q`: a `deque` to manage vertices whose outgoing edges need to be directed.\n\n2.  **Process Source (Vertex 1):**\n    *   For every edge `(1, u)` with capacity `c` and index `i` incident to vertex 1:\n        *   This edge *must* be directed `1 -> u` (due to condition 2).\n        *   Set `ans[i]` appropriately (0 if `edges_info[i]` was `(1, u)`, 1 if it was `(u, 1)`).\n        *   Add `c` to `current_inflow[u]`.\n        *   If `u` is an intermediate vertex (`u != n`) and its `current_inflow[u]` has reached its required value (`total_incident_capacity[u] / 2`), then `u` is ready to \"push\" flow. Add `u` to the queue `q`.\n\n3.  **BFS-like Propagation:**\n    *   While the queue `q` is not empty:\n        *   Dequeue a vertex `u`.\n        *   For every edge `(u, v)` with capacity `c` and index `i` incident to `u`:\n            *   If `ans[i]` is still `-1` (meaning this edge is not yet directed):\n                *   This edge *must* be directed `u -> v`. This is because `u` has already received all its required incoming flow (`current_inflow[u] == total_incident_capacity[u] / 2`), so all its remaining undirected edges must be outgoing to satisfy `sum(outflow) = TotalFlowAround[u] / 2`.\n                *   Set `ans[i]` appropriately (0 if `edges_info[i]` was `(u, v)`, 1 if it was `(v, u)`).\n                *   Add `c` to `current_inflow[v]`.\n                *   If `v` is an intermediate vertex (`v != n`) and its `current_inflow[v]` has reached its required value (`total_incident_capacity[v] / 2`), then `v` is ready to push flow. Add `v` to the queue `q`.\n\n**Why this works:**\n\n*   **Flow Conservation (1 < v < n):** A vertex `u` is added to the queue `q` only when `current_inflow[u] * 2 == total_incident_capacity[u]`. At this point, `u` has received exactly half of its total incident flow. When `u` is processed from the queue, all its remaining undirected edges are directed outwards. This ensures that `sum(outgoing_flow) = total_incident_capacity[u] - sum(incoming_flow) = total_incident_capacity[u] - (total_incident_capacity[u] / 2) = total_incident_capacity[u] / 2`. Thus, `sum(inflow) = sum(outflow)`.\n*   **Source Condition (v = 1):** Explicitly handled in step 2.\n*   **Acyclicity:** The process naturally creates a DAG. A vertex `u` is processed (and its outgoing edges directed) only after all its incoming flow requirements are met. This means flow is always pushed from \"earlier\" processed vertices to \"later\" processed vertices, preventing cycles.\n*   **Sink (v = n):** Vertex `n` is never added to the queue (`v != n` check). It simply accumulates all incoming flow. Its `current_inflow[n]` will naturally sum up to the total flow `F`.\n\n**Complexity:**\n*   **Time:** O(N + M) because each edge and vertex is processed a constant number of times.\n*   **Space:** O(N + M) for adjacency lists and auxiliary arrays.\n\nThis approach is efficient and correctly addresses all given constraints.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # adj[u] stores a list of tuples (neighbor_v, capacity_c, edge_index_i)\n    adj = [[] for _ in range(n + 1)]\n    # edges_info[i] stores the original (u, v) for edge i, used for output mapping\n    edges_info = [] \n    \n    # total_incident_capacity[v] stores the sum of capacities of all edges incident to v\n    total_incident_capacity = [0] * (n + 1)\n    # current_inflow[v] stores the sum of capacities of edges already directed INTO v\n    current_inflow = [0] * (n + 1)\n    # ans[i] stores the direction for edge i: 0 for a_i -> b_i, 1 for b_i -> a_i\n    # Initialize with -1 to indicate undirected\n    ans = [-1] * m \n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v)) # Store original endpoints for output mapping\n        \n        total_incident_capacity[u] += c\n        total_incident_capacity[v] += c\n\n    q = deque()\n\n    # Step 2: Handle Source (vertex 1)\n    # All edges incident to vertex 1 must be directed outwards from 1.\n    for neighbor_v, capacity_c, edge_idx in adj[1]:\n        # If this edge hasn't been directed yet (which it shouldn't be, as we start from 1)\n        if ans[edge_idx] == -1:\n            original_u, original_v = edges_info[edge_idx]\n            \n            # Determine direction: 1 -> neighbor_v\n            # If original edge was (1, neighbor_v), then 0. Else (neighbor_v, 1), then 1.\n            if original_u == 1:\n                ans[edge_idx] = 0 # 1 -> neighbor_v (original_u -> original_v)\n            else: # original_v == 1\n                ans[edge_idx] = 1 # 1 -> neighbor_v (original_v -> original_u)\n\n            current_inflow[neighbor_v] += capacity_c\n            \n            # If neighbor_v is an intermediate vertex (not the sink 'n')\n            # and its current_inflow has reached half of its total incident capacity,\n            # it means all its required incoming flow is now determined.\n            # Thus, all its remaining undirected edges must be outgoing.\n            if neighbor_v != n and current_inflow[neighbor_v] * 2 == total_incident_capacity[neighbor_v]:\n                q.append(neighbor_v)\n\n    # Step 3: BFS-like Propagation\n    while q:\n        u = q.popleft()\n\n        # Process all edges incident to u\n        for neighbor_v, capacity_c, edge_idx in adj[u]:\n            # If this edge is still undirected\n            if ans[edge_idx] == -1:\n                original_u, original_v = edges_info[edge_idx]\n                \n                # Determine direction: u -> neighbor_v\n                # If original edge was (u, neighbor_v), then 0. Else (neighbor_v, u), then 1.\n                if original_u == u:\n                    ans[edge_idx] = 0 # u -> neighbor_v (original_u -> original_v)\n                else: # original_v == u\n                    ans[edge_idx] = 1 # u -> neighbor_v (original_v -> original_u)\n\n                current_inflow[neighbor_v] += capacity_c\n                \n                # If neighbor_v is an intermediate vertex (not the sink 'n')\n                # and its current_inflow has reached half of its total incident capacity,\n                # add it to the queue to process its outgoing edges.\n                if neighbor_v != n and current_inflow[neighbor_v] * 2 == total_incident_capacity[neighbor_v]:\n                    q.append(neighbor_v)\n    \n    # Print the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # adj[u] stores a list of tuples (neighbor_v, capacity_c, edge_index_i)\n    adj = [[] for _ in range(n + 1)]\n    # edges_info[i] stores the original (u, v) for edge i, used for output mapping\n    edges_info = [] \n    \n    # total_incident_capacity[v] stores the sum of capacities of all edges incident to v\n    total_incident_capacity = [0] * (n + 1)\n    # current_inflow[v] stores the sum of capacities of edges already directed INTO v\n    current_inflow = [0] * (n + 1)\n    # ans[i] stores the direction for edge i: 0 for a_i -> b_i, 1 for b_i -> a_i\n    # Initialize with -1 to indicate undirected\n    ans = [-1] * m \n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v)) # Store original endpoints for output mapping\n        \n        total_incident_capacity[u] += c\n        total_incident_capacity[v] += c\n\n    q = deque()\n\n    # Step 2: Handle Source (vertex 1)\n    # All edges incident to vertex 1 must be directed outwards from 1.\n    for neighbor_v, capacity_c, edge_idx in adj[1]:\n        # If this edge hasn't been directed yet (which it shouldn't be, as we start from 1)\n        if ans[edge_idx] == -1:\n            original_u, original_v = edges_info[edge_idx]\n            \n            # Determine direction: 1 -> neighbor_v\n            # If original edge was (1, neighbor_v), then 0. Else (neighbor_v, 1), then 1.\n            if original_u == 1:\n                ans[edge_idx] = 0 # 1 -> neighbor_v (original_u -> original_v)\n            else: # original_v == 1\n                ans[edge_idx] = 1 # 1 -> neighbor_v (original_v -> original_u)\n\n            current_inflow[neighbor_v] += capacity_c\n            \n            # If neighbor_v is an intermediate vertex (not the sink 'n')\n            # and its current_inflow has reached half of its total incident capacity,\n            # it means all its required incoming flow is now determined.\n            # Thus, all its remaining undirected edges must be outgoing.\n            if neighbor_v != n and current_inflow[neighbor_v] * 2 == total_incident_capacity[neighbor_v]:\n                q.append(neighbor_v)\n\n    # Step 3: BFS-like Propagation\n    while q:\n        u = q.popleft()\n\n        # Process all edges incident to u\n        for neighbor_v, capacity_c, edge_idx in adj[u]:\n            # If this edge is still undirected\n            if ans[edge_idx] == -1:\n                original_u, original_v = edges_info[edge_idx]\n                \n                # Determine direction: u -> neighbor_v\n                # If original edge was (u, neighbor_v), then 0. Else (neighbor_v, u), then 1.\n                if original_u == u:\n                    ans[edge_idx] = 0 # u -> neighbor_v (original_u -> original_v)\n                else: # original_v == u\n                    ans[edge_idx] = 1 # u -> neighbor_v (original_v -> original_u)\n\n                current_inflow[neighbor_v] += capacity_c\n                \n                # If neighbor_v is an intermediate vertex (not the sink 'n')\n                # and its current_inflow has reached half of its total incident capacity,\n                # add it to the queue to process its outgoing edges.\n                if neighbor_v != n and current_inflow[neighbor_v] * 2 == total_incident_capacity[neighbor_v]:\n                    q.append(neighbor_v)\n    \n    # Print the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 2643,
        "thoughts_token_count": 8191
    }
}