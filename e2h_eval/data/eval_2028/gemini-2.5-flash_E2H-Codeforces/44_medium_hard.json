{
    "start": 1758294881.1781576,
    "end": 1758294944.0220835,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Path to Profit Maximization**\n\nOkay, so I'm diving into this competitive programming problem. I need to figure out how to maximize the total profit by strategically splitting up problems across multiple days.  The input's straightforward: number of problems (`n`), number of days (`k`), and the difficulty levels of each problem (`a`).  The goal is to get the maximum sum of the maximum difficulty level for each day.\n\nMy brain starts ticking: I realize that to get the biggest possible daily profit, I should be aiming to have the hardest problem of each day be as hard as possible. The constraints tell me that I can partition all the problems into *k* contiguous segments. That is, I'm finding places to split the array of difficulties into *k* segments. The profit for a day is the maximum difficulty *within that day's problems*.\n\nThe core idea hits me: the biggest profit will likely come from having the *k* biggest values in the entire list of problem difficulties (`a`) be the daily maximums. It makes total sense that I should select the *k* largest difficulties and arrange these `k` difficulties to be the daily maximums. I understand that the key is that all `n` problems are used and assigned to `k` days.\n\nSo I come up with a plan: sort the difficulties in descending order and consider the *k* largest values. These will ideally be my daily maxima. I need to make *k-1* cuts in the list to split it up into *k* contiguous segments. That means I need to split the array so that each of the `k` largest values will be the maximum value in *some* segment.\n\nThe strategy emerges! I'll sort the indices of the largest difficulties, and the cuts will go *after* each of these indices.  The days are defined by those cut points. I need to calculate the lengths of those days correctly.  It all clicks. Finding the maximum total profit is reduced to picking and sorting a list of the largest difficulties.\n\nThe steps are: determine the `k` biggest values and their original positions, sort those positions, define my daily segments using those sorted indices, and sum up the largest difficulties. The segments I compute will maximize the profit!\n",
    "response": "The problem asks us to partition `n` problems, given by their difficulties `a_1, ..., a_n`, into `k` contiguous segments (days). Each day's profit is the maximum difficulty of problems solved on that day. We want to maximize the total profit, which is the sum of daily profits. We also need to output the number of problems solved each day.\n\nLet's analyze the total profit. We have `k` days, and each day `j` will have a profit `P_j = max(problems_on_day_j)`. The total profit is `sum(P_j)` for `j=1` to `k`. Each `P_j` must be one of the `a_i` values from the original list. Since each problem `a_i` can only be solved once and can only be the maximum for one day's segment, the `k` values `P_1, ..., P_k` must correspond to `k` distinct problems from the list `a`. To maximize their sum, we should simply choose the `k` largest difficulties from the entire list `a`.\n\nLet the `k` largest difficulties in `a` be `M_1, M_2, ..., M_k`. The maximum possible total profit is `sum(M_i)`. The challenge is to show that we can always find a valid partition of problems into `k` days such that these `M_i` values are indeed the maximums of their respective days.\n\nHere's the strategy:\n1.  **Identify the `k` largest problems:** Find the `k` problems with the highest difficulties. If there are ties, any choice among equal difficulties is fine. We need their values to sum up for the total profit, and their original indices to determine the split points.\n2.  **Calculate total profit:** Sum the difficulties of these `k` largest problems. This is our maximum total profit.\n3.  **Determine split points:** Let the original 0-indexed positions of these `k` largest problems be `idx_1, idx_2, ..., idx_k`. Sort these indices in ascending order. Let the sorted indices be `s_1 < s_2 < ... < s_k`.\n    We need to make `k-1` cuts to divide the `n` problems into `k` segments. A simple way to ensure each `a[s_j]` (the problem at index `s_j`) becomes the maximum of its day is to make cuts *after* problems `a[s_1], a[s_2], ..., a[s_{k-1}]`.\n    *   Day 1 will include problems from index `0` up to `s_1`.\n    *   Day 2 will include problems from index `s_1+1` up to `s_2`.\n    *   ...\n    *   Day `j` (for `j` from 1 to `k-1`) will include problems from index `s_{j-1}+1` up to `s_j`.\n    *   Day `k` will include problems from index `s_{k-1}+1` up to `n-1`.\n\n**Why this strategy works:**\nConsider any segment `[s_{j-1}+1, s_j]` (with `s_0 = -1`). This segment contains exactly one of the `k` chosen largest problems, which is `a[s_j]`. Any other problem `a[x]` within this segment (where `x != s_j`) cannot be one of the `k` chosen largest problems. This is because if `a[x]` were one of the `k` chosen largest problems, then `x` would be one of the `s_p` indices. But `s_j` is the only `s_p` within this segment. Therefore, `a[s_j]` is guaranteed to be greater than or equal to any other `a[x]` in its segment, making it the maximum profit for that day.\n\n**Example walkthrough:**\n`n = 8, k = 3`, `a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Identify `k=3` largest problems:**\n    The problems with their original indices are: `(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)`.\n    Sorted by difficulty (descending): `(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)`.\n    The top `k=3` are `(9,6), (6,3), (5,0)`. (We pick the first `5` at index `0`.)\n2.  **Calculate total profit:** `9 + 6 + 5 = 20`.\n3.  **Determine split points:**\n    Original indices of these `k` problems are `6, 3, 0`.\n    Sorted indices `s_1, s_2, s_3`: `[0, 3, 6]`.\n    We need `k-1 = 2` cuts. The cuts will be after `s_1` and `s_2`. So, after index `0` and after index `3`.\n    *   Day 1: problems `a[0]` to `a[s_1]` (`a[0]` to `a[0]`). Length `s_1 - (-1) = 0 - (-1) = 1`.\n        Segment: `[5]`. Max = 5.\n    *   Day 2: problems `a[s_1+1]` to `a[s_2]` (`a[1]` to `a[3]`). Length `s_2 - s_1 = 3 - 0 = 3`.\n        Segment: `[4, 2, 6]`. Max = 6.\n    *   Day 3: problems `a[s_2+1]` to `a[n-1]` (`a[4]` to `a[7]`). Length `n - (s_2+1) = 8 - (3+1) = 4`.\n        Segment: `[5, 1, 9, 2]`. Max = 9.\n\n    The lengths of problems for each day are `[1, 3, 4]`.\n    Total profit `5 + 6 + 9 = 20`.\n\nThis matches the maximum profit from the example. The specific lengths `3 2 3` from the example also give `20` profit: `[5, 4, 2]` (max 5), `[6, 5]` (max 6), `[1, 9, 2]` (max 9). The key is that the problems `a[0]=5`, `a[3]=6`, `a[6]=9` are the maximums for their days, and these are indeed the three largest values in the array `a`. Our strategy finds one such valid distribution.\n\n**Implementation details:**\n1.  Store pairs `(difficulty, original_index)` for all problems.\n2.  Sort these pairs in descending order of difficulty.\n3.  Take the first `k` pairs. Sum their difficulties for the total profit.\n4.  Extract the original indices from these `k` pairs. Sort these `k` indices in ascending order.\n5.  Calculate day lengths:\n    Initialize `day_lengths = []` and `last_split_point = -1`.\n    For `i` from `0` to `k-2`:\n        `length = sorted_indices[i] - last_split_point`\n        `day_lengths.append(length)`\n        `last_split_point = sorted_indices[i]`\n    Finally, for the last day:\n        `length = n - (last_split_point + 1)`\n        `day_lengths.append(length)`\n6.  Print total profit and day lengths.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Create a list of (difficulty, original_index) tuples\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Sort by difficulty in descending order\n    # If difficulties are equal, the original index order doesn't matter for correctness\n    # of sum, but might affect which specific indices are chosen if there are many equal largest values.\n    # The problem statement says any valid answer is fine.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k elements\n    top_k_elements = indexed_a[:k]\n\n    # Calculate total profit\n    total_profit = sum(val for val, idx in top_k_elements)\n\n    # Get the original indices of these k largest elements\n    split_indices = [idx for val, idx in top_k_elements]\n    # Sort these indices to determine the cut points in increasing order\n    split_indices.sort()\n\n    # Calculate the lengths of problems for each day\n    day_lengths = []\n    last_split_point = -1 # Represents the index of the problem where the previous day ended\n\n    # For the first k-1 days, we make a cut after each of the first k-1 sorted indices\n    for i in range(k - 1):\n        # The current day ends at split_indices[i]\n        # The problems for this day are from (last_split_point + 1) to split_indices[i]\n        length = split_indices[i] - last_split_point\n        day_lengths.append(length)\n        last_split_point = split_indices[i]\n\n    # The last day takes all remaining problems\n    # It starts from (last_split_point + 1) and goes up to (n - 1)\n    length = n - (last_split_point + 1)\n    day_lengths.append(length)\n\n    # Print the results\n    print(total_profit)\n    print(*(day_lengths))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Create a list of (difficulty, original_index) tuples\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Sort by difficulty in descending order\n    # If difficulties are equal, the original index order doesn't matter for correctness\n    # of sum, but might affect which specific indices are chosen if there are many equal largest values.\n    # The problem statement says any valid answer is fine.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k elements\n    top_k_elements = indexed_a[:k]\n\n    # Calculate total profit\n    total_profit = sum(val for val, idx in top_k_elements)\n\n    # Get the original indices of these k largest elements\n    split_indices = [idx for val, idx in top_k_elements]\n    # Sort these indices to determine the cut points in increasing order\n    split_indices.sort()\n\n    # Calculate the lengths of problems for each day\n    day_lengths = []\n    last_split_point = -1 # Represents the index of the problem where the previous day ended\n\n    # For the first k-1 days, we make a cut after each of the first k-1 sorted indices\n    for i in range(k - 1):\n        # The current day ends at split_indices[i]\n        # The problems for this day are from (last_split_point + 1) to split_indices[i]\n        length = split_indices[i] - last_split_point\n        day_lengths.append(length)\n        last_split_point = split_indices[i]\n\n    # The last day takes all remaining problems\n    # It starts from (last_split_point + 1) and goes up to (n - 1)\n    length = n - (last_split_point + 1)\n    day_lengths.append(length)\n\n    # Print the results\n    print(total_profit)\n    print(*(day_lengths))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 972,
        "completion_token_count": 2335,
        "thoughts_token_count": 7143
    }
}