{
    "start": 1758294861.7488854,
    "end": 1758294964.2482557,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Okay, here's my plan for tackling the \"Mushroom Strife\" problem. It's a graph problem at its heart, and I think I've figured out a robust strategy.**\n\nFirst, I need to understand the problem. I'm given a graph with `n` lawns (vertices) and `m` roads (edges). Each road tells me the GCD and LCM of the mushroom counts on the connected lawns. I also know that `a * b = GCD(a, b) * LCM(a, b)`, where `a` and `b` are mushroom counts. This gives me a constraint: `g * l = a * b`, where `g` is the GCD and `l` is the LCM.\n\nThe key observation is that if I can fix one lawn's value I might be able to find others. I have to make sure each `M[i]` is a multiple of the GCD values connected to it. I want to try to solve for `M[i]` iteratively.\n\nMy initial thought was: if I knew the value for a lawn, I could easily deduce the mushroom count for its neighbors. I just need to use `M[j] = (g * l) / M[i]`. But, this calculation also needs to satisfy `GCD(M[i], M[j]) = g`. This seems easy, but it relies on an initial value.\n\nThe real challenge is starting the process. I don't know any mushroom counts initially.  I need to assign an arbitrary valid value to one lawn and propagate.\n\n**Here's the detailed strategy I came up with:**\n\n1.  **Preprocessing:** For each edge, I check if `l` is divisible by `g`. If not, there's no solution (\"NO\"). Otherwise, I calculate `P = l / g`.\n2.  **Prime Factorization:** The values `a/g` and `b/g` are coprime factors of `P`. I need to figure out how to assign prime powers to lawns and handle those constraints to ensure coprime. I'll factor `P` into prime powers. It is all the prime powers must belong completely to either `a/g` or `b/g`.\n3.  **Representing Unknowns:** I want to represent each lawn's mushroom count `M[i]` as `Base_i * Prod_i`. The `Base_i` is a product of common prime factors from the GCDs. `Prod_i` is a product of some prime powers.  This is a constraints problem, but this looks like an approach.\n\n**Revised Strategy: Prime Factorization Based Approach**\n\nSince LCM and GCD are at most 10^6, precompute prime factorization.\n\nI need to calculate `M[i]`. So `M[i]` is a multiple of `g`. And `val[u] * val[v] = g * l` and  `GCD(val[u], val[v]) = g`. `P = l/g` and  `GCD(val[u]/g, val[v]/g) = 1`. But, if I simply set values, I might have the issue of them not being coprime. So, it looks like a 2-coloring problem.\n\n**Graph Coloring/2-SAT like Approach:**\n\nHere, I'm thinking about the prime factors. For each `p^e` dividing `l/g`  This means, `p^e` must belong to `M[u]/g` or `M[v]/g`. So I can choose this. The number of primes is a constraint.\n\nSo, I create `exp[i][p]` as exponent of `p` in `M[i]`. With the edge constraints, `min(exp[u][p], exp[v][p]) = e` and `max(exp[u][p], exp[v][p]) = f`. This means `exp[u][p] + exp[v][p] = e + f`.  If `e < f`, one is `e`, other is `f`. If they are the same, they must be the same on both sides.\n\n**Algorithm Based on Prime Exponents:**\n\n1.  **Preprocessing:** Precompute primes and factorizations for efficiency.\n2.  **Initialize Exponent Ranges:** I'll set a range for exponents for all primes, for each node.\n3.  **Process Edges:** I'll use prime factorization to update these exponent ranges for each edge, taking `g` and `l` into account. The range becomes smaller with more edges.\n4.  **Propagate Fixed Exponents:** If an exponent is fixed, I can propagate this value to neighbors, and update `min_exp` and `max_exp`. I",
    "response": "The problem asks us to restore the number of mushrooms on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `g = GCD(M_u, M_v)` and `l = LCM(M_u, M_v)`, where `M_x` is the number of mushrooms on lawn `x`. We know that `M_u * M_v = g * l`. Also, `g` must divide both `M_u` and `M_v`, and `M_u` and `M_v` must divide `l`. The mushroom counts are between 1 and 10^6.\n\nThis problem can be solved by considering the prime factorization of each `M_x`. Let `M_x = product(p^exp_x_p)` over all primes `p`.\nFor an edge `(u, v, g, l)`:\nLet `e_p` be the exponent of prime `p` in `g`, and `f_p` be the exponent of prime `p` in `l`.\nThe properties of GCD and LCM imply:\n1. `min(exp_u_p, exp_v_p) = e_p`\n2. `max(exp_u_p, exp_v_p) = f_p`\n\nFrom these two conditions, we can deduce:\n*   `e_p <= exp_u_p <= f_p`\n*   `e_p <= exp_v_p <= f_p`\n*   If `e_p == f_p`: Then `exp_u_p = exp_v_p = e_p`.\n*   If `e_p < f_p`: Then one of `exp_u_p, exp_v_p` must be `e_p` and the other must be `f_p`.\n\nThis means the problem can be decoupled for each prime `p`. For each prime `p` that appears in the factorization of any `g` or `l` value, we need to determine `exp_x_p` for all lawns `x`.\n\n**Algorithm Steps:**\n\n1.  **Preprocessing (Prime Factorization):**\n    *   Precompute the smallest prime factor (SPF) for all numbers up to `MAX_VAL = 10^6` using a Sieve. This allows `O(log N)` factorization for any number `N <= MAX_VAL`.\n    *   Store all distinct primes encountered in `g` or `l` values in a list `all_primes`.\n\n2.  **Initialize Exponent Bounds:**\n    *   For each lawn `i` and each prime `p` in `all_primes`:\n        *   Initialize `min_exp[i][p] = 0` (minimum possible exponent).\n        *   Initialize `max_exp[i][p] = 20` (a safe upper bound, as `2^19 < 10^6` but `2^20 > 10^6`).\n    *   We use `defaultdict(lambda: defaultdict(int))` for `min_exp` and `defaultdict(lambda: defaultdict(lambda: 20))` for `max_exp` to handle sparse prime exponents efficiently.\n\n3.  **Process Edge Constraints (Initial Bounds):**\n    *   For each edge `(u, v, g, l)`:\n        *   If `l % g != 0`, it's impossible. Print \"NO\" and exit.\n        *   Factorize `g` and `l` to get prime exponents.\n        *   For each prime `p` appearing in `g` or `l`:\n            *   Let `e_p = exponent(p, g)` and `f_p = exponent(p, l)`.\n            *   If `e_p > f_p`, it's impossible (GCD exponent cannot be greater than LCM exponent). Print \"NO\" and exit.\n            *   Update bounds for `u` and `v`:\n                *   `min_exp[u][p] = max(min_exp[u][p], e_p)`\n                *   `max_exp[u][p] = min(max_exp[u][p], f_p)`\n                *   `min_exp[v][p] = max(min_exp[v][p], e_p)`\n                *   `max_exp[v][p] = min(max_exp[v][p], f_p)`\n        *   After processing all primes for an edge, add `(u, v, g, l)` to the adjacency list `adj[u]` and `adj[v]`.\n\n4.  **Propagate Fixed Exponents (BFS-like):**\n    *   Initialize a queue `q_fixed_exp`.\n    *   For each lawn `i` and prime `p`:\n        *   If `min_exp[i][p] > max_exp[i][p]`, it's impossible. Print \"NO\" and exit.\n        *   If `min_exp[i][p] == max_exp[i][p]` and `(i, p)` hasn't been processed, add `(i, p)` to `q_fixed_exp`.\n    *   While `q_fixed_exp` is not empty:\n        *   Dequeue `(curr_node, curr_p)`. Let `fixed_val = min_exp[curr_node][curr_p]`.\n        *   For each neighbor `next_node` of `curr_node` via edge `(curr_node, next_node, g_edge, l_edge)`:\n            *   Get `e_p = exponent(curr_p, g_edge)` and `f_p = exponent(curr_p, l_edge)`.\n            *   If `e_p == f_p`:\n                *   If `fixed_val != e_p`, conflict. Print \"NO\" and exit.\n                *   If `min_exp[next_node][curr_p]` or `max_exp[next_node][curr_p]` needs to be updated to `e_p`, do so. If `min_exp[next_node][curr_p] == max_exp[next_node][curr_p]` and `(next_node, curr_p)` is not yet processed, enqueue it.\n            *   If `e_p < f_p`:\n                *   If `fixed_val == e_p`: `exp[next_node][curr_p]` must be `f_p`. Update bounds for `next_node` to enforce `f_p`. If `min_exp[next_node][curr_p] == max_exp[next_node][curr_p]` and `(next_node, curr_p)` is not yet processed, enqueue it.\n                *   If `fixed_val == f_p`: `exp[next_node][curr_p]` must be `e_p`. Update bounds for `next_node` to enforce `e_p`. If `min_exp[next_node][curr_p] == max_exp[next_node][curr_p]` and `(next_node, curr_p)` is not yet processed, enqueue it.\n                *   If `fixed_val` is neither `e_p` nor `f_p`, conflict. Print \"NO\" and exit.\n            *   After any update, if `min_exp[next_node][curr_p] > max_exp[next_node][curr_p]`, conflict. Print \"NO\" and exit.\n\n5.  **Handle Unfixed Exponents (2-Coloring):**\n    *   After propagation, some `exp_x_p` might still have `min_exp[x][p] < max_exp[x][p]`. These are `e_p < f_p` cases where `exp_x_p` can be either `e_p` or `f_p`.\n    *   For each prime `p` in `all_primes`:\n        *   For each lawn `i = 1 to n`:\n            *   If `min_exp[i][p] < max_exp[i][p]` and `final_exp[i][p]` is not yet set:\n                *   Start a BFS/DFS from `i` on the graph of lawns related by prime `p`.\n                *   Assign `final_exp[i][p] = min_exp[i][p]` (arbitrary choice for the starting node of a component).\n                *   For each neighbor `j` of `i` via edge `(i, j, g_edge, l_edge)`:\n                    *   Let `e_p = exponent(p, g_edge)` and `f_p = exponent(p, l_edge)`.\n                    *   If `e_p < f_p` (i.e., this edge contributes to the 2-coloring for prime `p`):\n                        *   If `final_exp[j][p]` is already set: Check consistency. If `(final_exp[i][p], final_exp[j][p])` is not `(e_p, f_p)` or `(f_p, e_p)`, print \"NO\" and exit.\n                        *   If `final_exp[j][p]` is not set: Set `final_exp[j][p]` to `f_p` if `final_exp[i][p]` is `e_p`, or `e_p` if `final_exp[i][p]` is `f_p`. Add `j` to the queue.\n            *   If `final_exp[i][p]` is still not set (meaning `min_exp[i][p] == max_exp[i][p]` or no 2-coloring constraint applies to `i` for prime `p`), set `final_exp[i][p] = min_exp[i][p]`.\n\n6.  **Construct Mushroom Counts and Final Verification:**\n    *   For each lawn `i`, calculate `M[i] = product(p^final_exp[i][p])` over all `p` in `final_exp[i]`.\n    *   If any `M[i] > 10^6`, print \"NO\" and exit.\n    *   For each original edge `(u, v, g, l)`:\n        *   Verify `GCD(M[u], M[v]) == g` and `LCM(M[u], M[v]) == l`. Use `math.gcd` and `(a * b) // math.gcd(a, b)` for LCM.\n        *   If any check fails, print \"NO\" and exit.\n    *   If all checks pass, print \"YES\" and then `M[1] ... M[n]`.\n\n**Helper Functions:**\n\n*   `sieve(limit)`: Computes SPF for numbers up to `limit`.\n*   `get_prime_factorization(n, spf)`: Returns a `defaultdict(int)` mapping primes to their exponents for `n`.\n*   `get_gcd(a, b)`: Returns `math.gcd(a, b)`.\n*   `get_lcm(a, b)`: Returns `(a * b) // math.gcd(a, b)`. Handles potential overflow if `a*b` exceeds `10^6` before division, but since `a, b <= 10^6` and `LCM <= 10^6`, `a*b` could be up to `10^12`. The problem states LCM is `<= 10^6`, so `a*b = g*l <= 10^12`. However, `a, b` themselves must be `<= 10^6`. This means `a*b` can be `10^12`, but `a,b` must fit. The `M[i]` values are checked to be `<= 10^6` at the end. So `(M[u] * M[v])` can exceed standard integer limits if not careful. The problem guarantees `LCM <= 10^6`. This means `M_u * M_v = g * l <= 10^6 * 10^6 = 10^12`. A Python integer handles this fine.\n\n**Complexity:**\n*   Sieve: `O(MAX_VAL log log MAX_VAL)`.\n*   Factorization: `O(log MAX_VAL)` per number using SPF. Total `O(M log MAX_VAL)`.\n*   Number of distinct primes in `all_primes` is `pi(MAX_VAL) approx 78k`.\n*   Number of distinct prime factors for any number `X <= 10^6` is at most 7-8.\n*   Steps 3, 4, 5 involve iterating through edges and primes. Each `(node, prime)` pair is processed a constant number of times (for bounds updates and fixing). Each edge is processed a constant number of times per prime.\n*   Total complexity: Roughly `O(MAX_VAL log log MAX_VAL + M * num_distinct_prime_factors_per_number + N * pi(MAX_VAL))`.\n    *   `10^6 log log 10^6` is fine.\n    *   `10^5 * 8` is fine.\n    *   `10^5 * 78k` for `min_exp` and `max_exp` storage is too big if using arrays. Using `defaultdict` makes it `O(N * avg_primes_per_node + M * avg_primes_per_edge)`. Since `avg_primes_per_node` is `O(num_distinct_prime_factors_per_number)`, this is efficient enough.\n\n```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Factorization using SPF\ndef get_prime_factorization(n):\n    factors = defaultdict(int)\n    if n == 0: # Should not happen with problem constraints\n        return factors\n    if n == 1:\n        return factors\n    \n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        factors[p] += 1\n        temp_n //= p\n    return factors\n\n# Precompute SPF\nsieve()\n\n# Function to get exponent of prime p in n\ndef get_exponent(n, p, factors_cache):\n    if n not in factors_cache:\n        factors_cache[n] = get_prime_factorization(n)\n    return factors_cache[n][p]\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = defaultdict(list)\n    \n    # Store all unique primes encountered in g or l\n    all_primes_set = set()\n\n    # Store factorization results to avoid recomputing\n    g_factors_cache = {}\n    l_factors_cache = {}\n    \n    edges_data = [] # Store original edge data for final verification\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        # Get prime factors for g and l\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n\n        # Collect all unique primes\n        all_primes_set.update(g_factors.keys())\n        all_primes_set.update(l_factors.keys())\n        \n        edges_data.append((u, v, g, l, g_factors, l_factors))\n        adj[u].append((v, g, l, g_factors, l_factors))\n        adj[v].append((u, g, l, g_factors, l_factors))\n\n    all_primes = sorted(list(all_primes_set))\n\n    # min_exp[node][prime] = minimum exponent for prime in node's mushroom count\n    # max_exp[node][prime] = maximum exponent for prime in node's mushroom count\n    min_exp = defaultdict(lambda: defaultdict(int))\n    max_exp = defaultdict(lambda: defaultdict(lambda: 20)) # Max exponent for 2 in 10^6 is 19, for 3 is 12, etc. 20 is safe.\n\n    # Step 3: Initialize bounds from edge constraints\n    for u, v, g, l, g_factors, l_factors in edges_data:\n        current_primes = set(g_factors.keys()).union(l_factors.keys())\n        for p in current_primes:\n            e_p = g_factors[p]\n            f_p = l_factors[p]\n\n            if e_p > f_p: # GCD exponent cannot be greater than LCM exponent\n                print(\"NO\")\n                return\n\n            min_exp[u][p] = max(min_exp[u][p], e_p)\n            max_exp[u][p] = min(max_exp[u][p], f_p)\n            min_exp[v][p] = max(min_exp[v][p], e_p)\n            max_exp[v][p] = min(max_exp[v][p], f_p)\n\n    # Step 4: Propagate fixed exponents\n    q_fixed_exp = deque()\n    # Track which (node, prime) pairs have already been processed in the queue\n    processed_fixed = defaultdict(set) \n\n    for i in range(n):\n        for p in all_primes:\n            if min_exp[i][p] > max_exp[i][p]:\n                print(\"NO\")\n                return\n            if min_exp[i][p] == max_exp[i][p] and p not in processed_fixed[i]:\n                q_fixed_exp.append((i, p))\n                processed_fixed[i].add(p)\n\n    while q_fixed_exp:\n        curr_node, curr_p = q_fixed_exp.popleft()\n        fixed_val = min_exp[curr_node][curr_p]\n\n        for next_node, g_edge, l_edge, g_factors_edge, l_factors_edge in adj[curr_node]:\n            e_p = g_factors_edge[curr_p]\n            f_p = l_factors_edge[curr_p]\n\n            if e_p == f_p:\n                if fixed_val != e_p:\n                    print(\"NO\")\n                    return\n                # If next_node's bounds for curr_p are not e_p, update them\n                if min_exp[next_node][curr_p] < e_p or max_exp[next_node][curr_p] > e_p:\n                    min_exp[next_node][curr_p] = max(min_exp[next_node][curr_p], e_p)\n                    max_exp[next_node][curr_p] = min(max_exp[next_node][curr_p], e_p)\n                    if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                        print(\"NO\")\n                        return\n                    if min_exp[next_node][curr_p] == max_exp[next_node][curr_p] and curr_p not in processed_fixed[next_node]:\n                        q_fixed_exp.append((next_node, curr_p))\n                        processed_fixed[next_node].add(curr_p)\n            elif e_p < f_p:\n                if fixed_val == e_p:\n                    # next_node's exponent for curr_p must be f_p\n                    if min_exp[next_node][curr_p] < f_p or max_exp[next_node][curr_p] > f_p:\n                        min_exp[next_node][curr_p] = max(min_exp[next_node][curr_p], f_p)\n                        max_exp[next_node][curr_p] = min(max_exp[next_node][curr_p], f_p)\n                        if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                            print(\"NO\")\n                            return\n                        if min_exp[next_node][curr_p] == max_exp[next_node][curr_p] and curr_p not in processed_fixed[next_node]:\n                            q_fixed_exp.append((next_node, curr_p))\n                            processed_fixed[next_node].add(curr_p)\n                elif fixed_val == f_p:\n                    # next_node's exponent for curr_p must be e_p\n                    if min_exp[next_node][curr_p] < e_p or max_exp[next_node][curr_p] > e_p:\n                        min_exp[next_node][curr_p] = max(min_exp[next_node][curr_p], e_p)\n                        max_exp[next_node][curr_p] = min(max_exp[next_node][curr_p], e_p)\n                        if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                            print(\"NO\")\n                            return\n                        if min_exp[next_node][curr_p] == max_exp[next_node][curr_p] and curr_p not in processed_fixed[next_node]:\n                            q_fixed_exp.append((next_node, curr_p))\n                            processed_fixed[next_node].add(curr_p)\n                else:\n                    # fixed_val is neither e_p nor f_p, which is a conflict\n                    print(\"NO\")\n                    return\n            \n            # Check for any conflict after updates\n            if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                print(\"NO\")\n                return\n\n    # final_exp[node][prime] will store the chosen exponent\n    final_exp = defaultdict(lambda: defaultdict(int))\n    # Keep track of visited nodes for each prime's 2-coloring\n    visited_for_prime = defaultdict(set)\n\n    # Step 5: Handle unfixed exponents (2-coloring)\n    for p in all_primes:\n        for i in range(n):\n            if p in min_exp[i] and min_exp[i][p] == max_exp[i][p]:\n                # Exponent is already fixed\n                final_exp[i][p] = min_exp[i][p]\n                visited_for_prime[p].add(i)\n                continue\n            \n            if i not in visited_for_prime[p]: # If not visited, start a BFS/DFS\n                q_coloring = deque()\n                q_coloring.append(i)\n                visited_for_prime[p].add(i)\n                final_exp[i][p] = min_exp[i][p] # Arbitrarily choose the lower bound for the first node in component\n\n                while q_coloring:\n                    curr_node = q_coloring.popleft()\n                    \n                    for next_node, g_edge, l_edge, g_factors_edge, l_factors_edge in adj[curr_node]:\n                        e_p = g_factors_edge[p]\n                        f_p = l_factors_edge[p]\n\n                        if e_p < f_p: # This edge implies a 2-coloring constraint\n                            if next_node not in visited_for_prime[p]:\n                                visited_for_prime[p].add(next_node)\n                                if final_exp[curr_node][p] == e_p:\n                                    final_exp[next_node][p] = f_p\n                                elif final_exp[curr_node][p] == f_p:\n                                    final_exp[next_node][p] = e_p\n                                else: # Should not happen if fixed_val check was thorough\n                                    print(\"NO\")\n                                    return\n                                q_coloring.append(next_node)\n                            else:\n                                # Check consistency if next_node already visited\n                                if not ((final_exp[curr_node][p] == e_p and final_exp[next_node][p] == f_p) or\n                                        (final_exp[curr_node][p] == f_p and final_exp[next_node][p] == e_p)):\n                                    print(\"NO\")\n                                    return\n                        else: # e_p == f_p, means both must be e_p\n                            if next_node not in visited_for_prime[p]:\n                                visited_for_prime[p].add(next_node)\n                                final_exp[next_node][p] = e_p\n                                q_coloring.append(next_node)\n                            else:\n                                if final_exp[next_node][p] != e_p:\n                                    print(\"NO\")\n                                    return\n            \n            # If after all propagation and coloring, final_exp[i][p] is not set,\n            # it means this (i,p) pair was isolated or only had e_p == f_p constraints.\n            # In this case, we can simply assign it min_exp[i][p] (which must be equal to max_exp[i][p])\n            if p not in final_exp[i]:\n                 final_exp[i][p] = min_exp[i][p]\n\n\n    # Step 6: Construct M[i] and final verification\n    M = [1] * n\n    for i in range(n):\n        for p, exp in final_exp[i].items():\n            # Check for overflow during multiplication\n            if M[i] > MAX_VAL // (p**exp) and p**exp > 1: # Check before multiplying\n                M[i] = MAX_VAL + 1 # Mark as overflowed\n                break\n            M[i] *= (p**exp)\n        \n        if M[i] > MAX_VAL:\n            print(\"NO\")\n            return\n\n    # Final verification of all edges\n    for u, v, g, l, _, _ in edges_data:\n        if math.gcd(M[u], M[v]) != g:\n            print(\"NO\")\n            return\n        # Calculate LCM (a*b)/gcd(a,b) safely for large products\n        # M[u] * M[v] can be up to 10^12, but M[u], M[v] <= 10^6\n        # g, l <= 10^6\n        # So M[u] * M[v] = g * l\n        # Use g * l directly for comparison to avoid overflow if M[u]*M[v] is too big\n        # and also ensure the logic for LCM calculation is correct.\n        # The M[u] * M[v] product is fine in Python.\n        if (M[u] * M[v]) // math.gcd(M[u], M[v]) != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(M))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Factorization using SPF\ndef get_prime_factorization(n):\n    factors = defaultdict(int)\n    if n == 0: # Should not happen with problem constraints\n        return factors\n    if n == 1:\n        return factors\n    \n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        factors[p] += 1\n        temp_n //= p\n    return factors\n\n# Precompute SPF\nsieve()\n\n# Function to get exponent of prime p in n\ndef get_exponent(n, p, factors_cache):\n    if n not in factors_cache:\n        factors_cache[n] = get_prime_factorization(n)\n    return factors_cache[n][p]\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = defaultdict(list)\n    \n    # Store all unique primes encountered in g or l\n    all_primes_set = set()\n\n    # Store factorization results to avoid recomputing\n    g_factors_cache = {}\n    l_factors_cache = {}\n    \n    edges_data = [] # Store original edge data for final verification\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        # Get prime factors for g and l\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n\n        # Collect all unique primes\n        all_primes_set.update(g_factors.keys())\n        all_primes_set.update(l_factors.keys())\n        \n        edges_data.append((u, v, g, l, g_factors, l_factors))\n        adj[u].append((v, g, l, g_factors, l_factors))\n        adj[v].append((u, g, l, g_factors, l_factors))\n\n    all_primes = sorted(list(all_primes_set))\n\n    # min_exp[node][prime] = minimum exponent for prime in node's mushroom count\n    # max_exp[node][prime] = maximum exponent for prime in node's mushroom count\n    min_exp = defaultdict(lambda: defaultdict(int))\n    max_exp = defaultdict(lambda: defaultdict(lambda: 20)) # Max exponent for 2 in 10^6 is 19, for 3 is 12, etc. 20 is safe.\n\n    # Step 3: Initialize bounds from edge constraints\n    for u, v, g, l, g_factors, l_factors in edges_data:\n        current_primes = set(g_factors.keys()).union(l_factors.keys())\n        for p in current_primes:\n            e_p = g_factors[p]\n            f_p = l_factors[p]\n\n            if e_p > f_p: # GCD exponent cannot be greater than LCM exponent\n                print(\"NO\")\n                return\n\n            min_exp[u][p] = max(min_exp[u][p], e_p)\n            max_exp[u][p] = min(max_exp[u][p], f_p)\n            min_exp[v][p] = max(min_exp[v][p], e_p)\n            max_exp[v][p] = min(max_exp[v][p], f_p)\n\n    # Step 4: Propagate fixed exponents\n    q_fixed_exp = deque()\n    # Track which (node, prime) pairs have already been processed in the queue\n    processed_fixed = defaultdict(set) \n\n    for i in range(n):\n        for p in all_primes:\n            if min_exp[i][p] > max_exp[i][p]:\n                print(\"NO\")\n                return\n            if min_exp[i][p] == max_exp[i][p] and p not in processed_fixed[i]:\n                q_fixed_exp.append((i, p))\n                processed_fixed[i].add(p)\n\n    while q_fixed_exp:\n        curr_node, curr_p = q_fixed_exp.popleft()\n        fixed_val = min_exp[curr_node][curr_p]\n\n        for next_node, g_edge, l_edge, g_factors_edge, l_factors_edge in adj[curr_node]:\n            e_p = g_factors_edge[curr_p]\n            f_p = l_factors_edge[curr_p]\n\n            if e_p == f_p:\n                if fixed_val != e_p:\n                    print(\"NO\")\n                    return\n                # If next_node's bounds for curr_p are not e_p, update them\n                if min_exp[next_node][curr_p] < e_p or max_exp[next_node][curr_p] > e_p:\n                    min_exp[next_node][curr_p] = max(min_exp[next_node][curr_p], e_p)\n                    max_exp[next_node][curr_p] = min(max_exp[next_node][curr_p], e_p)\n                    if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                        print(\"NO\")\n                        return\n                    if min_exp[next_node][curr_p] == max_exp[next_node][curr_p] and curr_p not in processed_fixed[next_node]:\n                        q_fixed_exp.append((next_node, curr_p))\n                        processed_fixed[next_node].add(curr_p)\n            elif e_p < f_p:\n                if fixed_val == e_p:\n                    # next_node's exponent for curr_p must be f_p\n                    if min_exp[next_node][curr_p] < f_p or max_exp[next_node][curr_p] > f_p:\n                        min_exp[next_node][curr_p] = max(min_exp[next_node][curr_p], f_p)\n                        max_exp[next_node][curr_p] = min(max_exp[next_node][curr_p], f_p)\n                        if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                            print(\"NO\")\n                            return\n                        if min_exp[next_node][curr_p] == max_exp[next_node][curr_p] and curr_p not in processed_fixed[next_node]:\n                            q_fixed_exp.append((next_node, curr_p))\n                            processed_fixed[next_node].add(curr_p)\n                elif fixed_val == f_p:\n                    # next_node's exponent for curr_p must be e_p\n                    if min_exp[next_node][curr_p] < e_p or max_exp[next_node][curr_p] > e_p:\n                        min_exp[next_node][curr_p] = max(min_exp[next_node][curr_p], e_p)\n                        max_exp[next_node][curr_p] = min(max_exp[next_node][curr_p], e_p)\n                        if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                            print(\"NO\")\n                            return\n                        if min_exp[next_node][curr_p] == max_exp[next_node][curr_p] and curr_p not in processed_fixed[next_node]:\n                            q_fixed_exp.append((next_node, curr_p))\n                            processed_fixed[next_node].add(curr_p)\n                else:\n                    # fixed_val is neither e_p nor f_p, which is a conflict\n                    print(\"NO\")\n                    return\n            \n            # Check for any conflict after updates\n            if min_exp[next_node][curr_p] > max_exp[next_node][curr_p]:\n                print(\"NO\")\n                return\n\n    # final_exp[node][prime] will store the chosen exponent\n    final_exp = defaultdict(lambda: defaultdict(int))\n    # Keep track of visited nodes for each prime's 2-coloring\n    visited_for_prime = defaultdict(set)\n\n    # Step 5: Handle unfixed exponents (2-coloring)\n    for p in all_primes:\n        for i in range(n):\n            if p in min_exp[i] and min_exp[i][p] == max_exp[i][p]:\n                # Exponent is already fixed\n                final_exp[i][p] = min_exp[i][p]\n                visited_for_prime[p].add(i)\n                continue\n            \n            if i not in visited_for_prime[p]: # If not visited, start a BFS/DFS\n                q_coloring = deque()\n                q_coloring.append(i)\n                visited_for_prime[p].add(i)\n                final_exp[i][p] = min_exp[i][p] # Arbitrarily choose the lower bound for the first node in component\n\n                while q_coloring:\n                    curr_node = q_coloring.popleft()\n                    \n                    for next_node, g_edge, l_edge, g_factors_edge, l_factors_edge in adj[curr_node]:\n                        e_p = g_factors_edge[p]\n                        f_p = l_factors_edge[p]\n\n                        if e_p < f_p: # This edge implies a 2-coloring constraint\n                            if next_node not in visited_for_prime[p]:\n                                visited_for_prime[p].add(next_node)\n                                if final_exp[curr_node][p] == e_p:\n                                    final_exp[next_node][p] = f_p\n                                elif final_exp[curr_node][p] == f_p:\n                                    final_exp[next_node][p] = e_p\n                                else: # Should not happen if fixed_val check was thorough\n                                    print(\"NO\")\n                                    return\n                                q_coloring.append(next_node)\n                            else:\n                                # Check consistency if next_node already visited\n                                if not ((final_exp[curr_node][p] == e_p and final_exp[next_node][p] == f_p) or\n                                        (final_exp[curr_node][p] == f_p and final_exp[next_node][p] == e_p)):\n                                    print(\"NO\")\n                                    return\n                        else: # e_p == f_p, means both must be e_p\n                            if next_node not in visited_for_prime[p]:\n                                visited_for_prime[p].add(next_node)\n                                final_exp[next_node][p] = e_p\n                                q_coloring.append(next_node)\n                            else:\n                                if final_exp[next_node][p] != e_p:\n                                    print(\"NO\")\n                                    return\n            \n            # If after all propagation and coloring, final_exp[i][p] is not set,\n            # it means this (i,p) pair was isolated or only had e_p == f_p constraints.\n            # In this case, we can simply assign it min_exp[i][p] (which must be equal to max_exp[i][p])\n            if p not in final_exp[i]:\n                 final_exp[i][p] = min_exp[i][p]\n\n\n    # Step 6: Construct M[i] and final verification\n    M = [1] * n\n    for i in range(n):\n        for p, exp in final_exp[i].items():\n            # Check for overflow during multiplication\n            if M[i] > MAX_VAL // (p**exp) and p**exp > 1: # Check before multiplying\n                M[i] = MAX_VAL + 1 # Mark as overflowed\n                break\n            M[i] *= (p**exp)\n        \n        if M[i] > MAX_VAL:\n            print(\"NO\")\n            return\n\n    # Final verification of all edges\n    for u, v, g, l, _, _ in edges_data:\n        if math.gcd(M[u], M[v]) != g:\n            print(\"NO\")\n            return\n        # Calculate LCM (a*b)/gcd(a,b) safely for large products\n        # M[u] * M[v] can be up to 10^12, but M[u], M[v] <= 10^6\n        # g, l <= 10^6\n        # So M[u] * M[v] = g * l\n        # Use g * l directly for comparison to avoid overflow if M[u]*M[v] is too big\n        # and also ensure the logic for LCM calculation is correct.\n        # The M[u] * M[v] product is fine in Python.\n        if (M[u] * M[v]) // math.gcd(M[u], M[v]) != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(M))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 6445,
        "thoughts_token_count": 8192
    }
}