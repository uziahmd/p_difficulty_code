{
    "start": 1758284912.420001,
    "end": 1758284958.998364,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Thinking Through the Minimum Odd Cycle Problem**\n\nOkay, so I've got this competitive programming problem on my hands. The core challenge is finding the fewest edges I need to add to a graph to create a simple, odd-length cycle, and then figuring out how many different ways I can do that. I'm dealing with an undirected graph with no parallel edges or self-loops, but it might not be connected.\n\nFirst things first, I need to understand what constitutes an odd cycle – it just means a cycle with an odd number of edges.  And \"simple\" means no vertex appears more than once in the cycle.\n\nNow, let's break down the possibilities for `t`, the minimum number of edges I need to add.\n\n*   **Scenario 0: `t = 0`**  This means an odd cycle already exists.  The key here is that a graph contains an odd cycle if and only if it's *not* bipartite.  I can quickly check for bipartiteness using BFS or DFS with coloring. If any edge connects two vertices of the same color during traversal, boom, I have an odd cycle. If any connected component fails this bipartiteness test, then `t` is 0, and `w` is 1.\n\n*   **Scenario 1: `t = 1`**  If the graph *is* bipartite (meaning no odd cycles exist currently), I need to add at least one edge. The crucial insight is that adding a single edge, let's say (u, v), creates an odd cycle *if and only if* `u` and `v` are in the same connected component and are the same color during the bipartite coloring. Because any cycle that exists must be even, by adding an edge between nodes on the same level (color) of a bipartite graph, then that cycle created becomes odd. The length of the new cycle is  `dist(u, v) + 1`. This would mean `dist(u, v)` is even since both `u` and `v` have the same color. And it needs to not already be an existing edge. The number of ways, `w`, is then simply the count of such non-existent edges. I'll need to be careful with the complexity, though. I'm thinking of iterating through all pairs of vertices within each connected component, and for each pair, I'll need to check if they're in the same connected component, have the same color, and aren't already connected by an edge. That's O(N^2) per component.  Might be too slow if N gets large. I'll have to consider optimization strategies if this becomes a bottleneck.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given graph to form a simple cycle of odd length, and `w` the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. If the graph is bipartite, all its cycles are of even length.\n\nWe can determine `t` and `w` by considering cases based on the minimum number of edges needed:\n\n**Case 0: `t = 0`**\nThis occurs if the given graph already contains an odd cycle. We can check this by trying to 2-color (bipartition) the graph using BFS or DFS.\nFor each connected component:\n1.  Start a traversal (BFS/DFS) from an unvisited vertex, assigning it color 0.\n2.  Assign alternating colors to its neighbors.\n3.  If we encounter an edge connecting two vertices of the same color, we've found an odd cycle.\nIf any connected component is not bipartite, then `t=0` and `w=1` (there's at least one odd cycle, and we don't need to add any edges).\n\n**Case 1: `t = 1`**\nIf the graph is bipartite (i.e., `t` is not 0), we need to add at least one edge. Adding one edge `(u, v)` creates an odd cycle if and only if `u` and `v` belong to the same connected component and have the same color in a 2-coloring. The added edge `(u, v)` must not already exist.\nTo find `w` for `t=1`:\n1.  First, perform a 2-coloring on all connected components. For each component `C`, count the number of vertices assigned color 0 (`count0_C`) and color 1 (`count1_C`).\n2.  The number of potential edges `(u, v)` within component `C` that connect vertices of the same color is `count0_C * (count0_C - 1) / 2 + count1_C * (count1_C - 1) / 2`.\n3.  Sum this quantity over all connected components. Let this sum be `total_potential_same_color_edges`.\n4.  From this sum, subtract the number of existing edges that connect vertices of the same color. Since the graph is bipartite, no existing edge connects vertices of the same color. Therefore, `w = total_potential_same_color_edges`.\nIf `w > 0`, then `t=1`.\n\n**Case 2: `t = 2`**\nIf `t` is not 0 or 1 (meaning the graph is bipartite, and all pairs of same-colored vertices are already connected by an edge, or there are no such pairs within components, which is impossible if `N > 1`), we need to add at least two edges.\nAdding two edges `(u, v)` and `(x, y)` can form an odd cycle in various ways. The simplest is to connect two different connected components.\nConsider two distinct connected components, `C_1` and `C_2`. If we add an edge `(u, v)` where `u \\in C_1` and `v \\in C_2`, these two components merge. The merged component is still bipartite. To create an odd cycle, we need to add another edge `(u', v')` within this newly merged component such that `u'` and `v'` have the same color.\nA more direct way to form an odd cycle with two edges is to connect three vertices `u, v, x` such that `u` and `v` are in one component `C_1`, and `x` is in another component `C_2`. If we add edges `(u, x)` and `(v, x)`, and `u, v` have different colors in `C_1`, then `u-x-v` forms a path of length 2. The path `u...v` in `C_1` has odd length (since `u, v` have different colors). So `u...v` (odd) + `v-x` (1) + `x-u` (1) = odd + 1 + 1 = odd + 2 = odd length cycle.\nThis means we pick two vertices `u, v` from the same component `C_i` (must have different colors) and one vertex `x` from a different component `C_j`. We add edges `(u, x)` and `(v, x)`.\nThe number of ways to pick `u, v` from `C_i` with different colors is `count0_Ci * count1_Ci`.\nThe number of ways to pick `x` from any other component `C_j` (where `j \\ne i`) is `N - |C_i|`.\nSumming over all `C_i`: `sum_{i} (count0_Ci * count1_Ci * (N - |C_i|))`.\nIf `w > 0`, then `t=2`.\n\n**Case 3: `t = 3`**\nIf `t` is not 0, 1, or 2, it means the graph is bipartite, and `t=1` and `t=2` conditions are not met. This implies:\n*   Either there is only one connected component, and all same-colored pairs are already connected (not possible if `N > 1`).\n*   Or all connected components are single vertices (`N` components, `m=0`). In this case, `count0_Ci = 1, count1_Ci = 0` (or vice versa) for all `i`.\n    *   `t=1` is not possible because `count0_Ci * (count0_Ci - 1) / 2 + count1_Ci * (count1_Ci - 1) / 2 = 0`.\n    *   `t=2` is not possible because `count0_Ci * count1_Ci = 0`.\nIn this extreme case (an empty graph with `N` isolated vertices), we need to add three edges to form an odd cycle. For example, `(1,2), (2,3), (3,1)` forms a triangle (odd cycle of length 3).\nThere is only `1` way to form a specific 3-cycle using 3 new edges, but `N * (N-1) * (N-2) / 6` ways to choose 3 vertices for the triangle.\nSince `N >= 3` is required to form a triangle, if `N < 3`, `t=3` is not possible. The problem states \"cycle of more than one vertex\", and a 3-cycle is the shortest odd cycle. So if `N < 3`, it's impossible. However, `N` is up to 100,000.\nIf `N >= 3`, then `t=3` and `w = N * (N-1) * (N-2) / 6`.\n\n**Algorithm Summary:**\n\n1.  **Initialization**:\n    *   `adj`: Adjacency list for the graph.\n    *   `visited`: Boolean array to keep track of visited vertices.\n    *   `color`: Array to store 2-coloring (0 or 1).\n    *   `is_bipartite`: Flag, initially `True`.\n    *   `components_data`: List to store `(count0, count1, num_vertices)` for each component.\n\n2.  **Bipartite Check and Component Analysis**:\n    *   Iterate `i` from 1 to `n`:\n        *   If `i` is not `visited`:\n            *   Initialize `current_component_count0 = 0`, `current_component_count1 = 0`, `current_component_size = 0`.\n            *   Start a BFS/DFS from `i`:\n                *   Queue `q = [(i, 0)]` (vertex, color).\n                *   `visited[i] = True`, `color[i] = 0`, `current_component_count0 = 1`, `current_component_size = 1`.\n                *   While `q` is not empty:\n                    *   `u, c_u = q.popleft()`.\n                    *   For each neighbor `v` of `u`:\n                        *   If `v` is not `visited`:\n                            *   `visited[v] = True`, `color[v] = 1 - c_u`.\n                            *   If `1 - c_u == 0`: `current_component_count0 += 1`.\n                            *   Else: `current_component_count1 += 1`.\n                            *   `current_component_size += 1`.\n                            *   `q.append((v, 1 - c_u))`.\n                        *   Else if `color[v] == c_u`:\n                            *   `is_bipartite = False`. (Odd cycle found)\n            *   If `is_bipartite` is still `True`:\n                *   `components_data.append((current_component_count0, current_component_count1, current_component_size))`.\n            *   Else:\n                *   Break (no need to process further components).\n\n3.  **Determine `t` and `w`**:\n\n    *   **If `not is_bipartite`**:\n        *   `t = 0`, `w = 1`.\n\n    *   **Else (`is_bipartite` is True)**:\n        *   **Check for `t = 1`**:\n            *   `w1 = 0` (ways for `t=1`).\n            *   For each `(c0, c1, size)` in `components_data`:\n                *   `w1 += c0 * (c0 - 1) // 2`\n                *   `w1 += c1 * (c1 - 1) // 2`\n            *   If `w1 > 0`:\n                *   `t = 1`, `w = w1`.\n            *   **Else (no `t=1` ways)**:\n                *   **Check for `t = 2`**:\n                    *   `w2 = 0` (ways for `t=2`).\n                    *   `N_long = N` (use `N` as a long integer to avoid overflow with large `N`).\n                    *   For each `(c0, c1, size)` in `components_data`:\n                        *   `w2 += c0 * c1 * (N_long - size)`\n                    *   If `w2 > 0`:\n                        *   `t = 2`, `w = w2`.\n                    *   **Else (no `t=2` ways)**:\n                        *   **`t = 3`**:\n                            *   If `N_long < 3`:\n                                *   This case should theoretically not be reachable if the problem guarantees a solution. A 3-cycle is the shortest odd cycle. An empty graph on 2 vertices cannot form an odd cycle. If `N=0` or `N=1`, no cycle.\n                                *   However, problem constraints are `N >= 1`. If `N=1` or `N=2`, it's impossible to form an odd cycle. The problem statement guarantees \"more than one vertex\". The smallest odd cycle is a triangle, requiring 3 vertices. So if `N < 3`, `t=3` is impossible.\n                                *   Given the problem context, it's safe to assume `N >= 3` if we reach this point.\n                            *   `t = 3`, `w = N_long * (N_long - 1) * (N_long - 2) // 6`.\n\n4.  Print `t` and `w`.\n\n**Example Walkthroughs:**\n\n1.  **Input:** `4 4\\n1 2\\n1 3\\n4 2\\n4 3`\n    *   Edges: (1,2), (1,3), (4,2), (4,3)\n    *   BFS from 1:\n        *   1 (color 0)\n        *   2 (color 1), 3 (color 1)\n        *   From 2: 4 (color 0)\n        *   From 3: 4 (color 0)\n        *   Edge (4,2): 4 (color 0), 2 (color 1) -> colors different, OK.\n        *   Edge (4,3): 4 (color 0), 3 (color 1) -> colors different, OK.\n    *   Graph is bipartite. Component 1: {1,2,3,4}. Colors: {1:0, 2:1, 3:1, 4:0}.\n    *   `count0 = 2` (1,4), `count1 = 2` (2,3). `size = 4`.\n    *   `is_bipartite = True`. `components_data = [(2, 2, 4)]`.\n    *   **Check `t=1`**:\n        *   `w1 = (2 * (2-1) // 2) + (2 * (2-1) // 2) = 1 + 1 = 2`.\n        *   `w1 = 2 > 0`. So, `t=1, w=2`.\n    *   Output: `1 2`. (Edges (1,4) and (2,3) would form odd cycles)\n\n2.  **Input:** `3 3\\n1 2\\n2 3\\n3 1`\n    *   Edges: (1,2), (2,3), (3,1)\n    *   BFS from 1:\n        *   1 (color 0)\n        *   2 (color 1)\n        *   From 2: 3 (color 0)\n        *   From 3: 1 (color 0) -> `color[3]` (0) == `color[1]` (0). Odd cycle found!\n    *   `is_bipartite = False`.\n    *   Output: `0 1`.\n\n3.  **Input:** `3 0`\n    *   Edges: None.\n    *   BFS from 1: 1 (color 0). Component {1}. `count0=1, count1=0, size=1`.\n    *   BFS from 2: 2 (color 0). Component {2}. `count0=1, count1=0, size=1`.\n    *   BFS from 3: 3 (color 0). Component {3}. `count0=1, count1=0, size=1`.\n    *   `is_bipartite = True`. `components_data = [(1,0,1), (1,0,1), (1,0,1)]`.\n    *   **Check `t=1`**:\n        *   `w1 = 0 + 0 + 0 = 0`.\n    *   **Check `t=2`**:\n        *   `N_long = 3`.\n        *   For (1,0,1): `w2 += 1 * 0 * (3 - 1) = 0`.\n        *   For (1,0,1): `w2 += 1 * 0 * (3 - 1) = 0`.\n        *   For (1,0,1): `w2 += 1 * 0 * (3 - 1) = 0`.\n        *   `w2 = 0`.\n    *   **`t=3`**:\n        *   `t = 3`. `w = 3 * (3-1) * (3-2) // 6 = 3 * 2 * 1 // 6 = 1`.\n    *   Output: `3 1`.\n\nThis logic covers all cases and is efficient enough. The BFS/DFS is `O(N+M)`. The `t=1` and `t=2` calculations iterate through components, which is at most `N` components, so `O(N)`. The `t=3` calculation is `O(1)`. Overall complexity is `O(N+M)`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n    \n    is_bipartite = True\n    components_data = [] # Stores (count0, count1, size) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_component_count0 = 0\n            current_component_count1 = 0\n            current_component_size = 0\n            \n            q = deque([(i, 0)]) # (vertex, assigned_color)\n            visited[i] = True\n            color[i] = 0\n            current_component_count0 = 1\n            current_component_size = 1\n            \n            component_is_bipartite = True\n            \n            component_nodes = [i] # To iterate over nodes in this component if it's bipartite\n\n            head = 0\n            while head < len(q):\n                u, c_u = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - c_u\n                        q.append((v, 1 - c_u))\n                        component_nodes.append(v)\n                        current_component_size += 1\n                        if 1 - c_u == 0:\n                            current_component_count0 += 1\n                        else:\n                            current_component_count1 += 1\n                    elif color[v] == c_u:\n                        # Found an edge connecting two vertices of the same color\n                        # This component is not bipartite, thus the graph is not bipartite.\n                        is_bipartite = False\n                        component_is_bipartite = False\n                        # No need to continue BFS for this component or any other if an odd cycle is found\n                        break\n                if not component_is_bipartite:\n                    break\n            \n            if not is_bipartite:\n                # If an odd cycle is found, we can stop and output t=0, w=1\n                print(\"0 1\")\n                return\n            \n            # If the component is bipartite, store its data\n            components_data.append((current_component_count0, current_component_count1, current_component_size))\n            \n    # If we reached here, the entire graph is bipartite.\n    # Now check for t=1, t=2, t=3.\n\n    # Try t=1\n    w1 = 0\n    for c0, c1, _ in components_data:\n        # Number of ways to add an edge between two color-0 vertices\n        w1 += c0 * (c0 - 1) // 2\n        # Number of ways to add an edge between two color-1 vertices\n        w1 += c1 * (c1 - 1) // 2\n    \n    if w1 > 0:\n        print(f\"1 {w1}\")\n        return\n\n    # Try t=2\n    w2 = 0\n    N_long = n # Use N_long to prevent overflow in intermediate calculations for N*(N-1)*(N-2)\n    \n    # We need to pick two vertices u,v from one component (different colors)\n    # and one vertex x from another component. Add edges (u,x) and (v,x).\n    # This forms an odd cycle u-x-v-...-u\n    \n    # Iterate through all components 'i'\n    for i in range(len(components_data)):\n        c0_i, c1_i, size_i = components_data[i]\n        \n        # Number of ways to pick u,v from component i with different colors\n        ways_to_pick_uv_diff_colors = c0_i * c1_i\n        \n        # Number of ways to pick x from any other component (N - size_i)\n        ways_to_pick_x_other_component = N_long - size_i\n        \n        w2 += ways_to_pick_uv_diff_colors * ways_to_pick_x_other_component\n    \n    if w2 > 0:\n        print(f\"2 {w2}\")\n        return\n    \n    # Try t=3\n    # If N < 3, it's impossible to form a 3-cycle.\n    # The problem implies a solution always exists if N >= 3.\n    # If we reach here, it implies N >= 3 (e.g. 3 isolated vertices).\n    # We need to add 3 edges to form a triangle (e.g., (1,2), (2,3), (3,1)).\n    # This is possible if N >= 3. The number of ways is the number of ways to choose 3 vertices.\n    \n    if N_long >= 3:\n        w3 = N_long * (N_long - 1) * (N_long - 2) // 6\n        print(f\"3 {w3}\")\n    # else:\n    # This case implies N < 3 and no odd cycle could be formed, which should not happen based on problem constraints or competitive programming problem structure.\n    # For N=1, no cycle. For N=2, no odd cycle.\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n    \n    is_bipartite = True\n    components_data = [] # Stores (count0, count1, size) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_component_count0 = 0\n            current_component_count1 = 0\n            current_component_size = 0\n            \n            q = deque([(i, 0)]) # (vertex, assigned_color)\n            visited[i] = True\n            color[i] = 0\n            current_component_count0 = 1\n            current_component_size = 1\n            \n            component_is_bipartite = True\n            \n            component_nodes = [i] # To iterate over nodes in this component if it's bipartite\n\n            head = 0\n            while head < len(q):\n                u, c_u = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - c_u\n                        q.append((v, 1 - c_u))\n                        component_nodes.append(v)\n                        current_component_size += 1\n                        if 1 - c_u == 0:\n                            current_component_count0 += 1\n                        else:\n                            current_component_count1 += 1\n                    elif color[v] == c_u:\n                        # Found an edge connecting two vertices of the same color\n                        # This component is not bipartite, thus the graph is not bipartite.\n                        is_bipartite = False\n                        component_is_bipartite = False\n                        # No need to continue BFS for this component or any other if an odd cycle is found\n                        break\n                if not component_is_bipartite:\n                    break\n            \n            if not is_bipartite:\n                # If an odd cycle is found, we can stop and output t=0, w=1\n                print(\"0 1\")\n                return\n            \n            # If the component is bipartite, store its data\n            components_data.append((current_component_count0, current_component_count1, current_component_size))\n            \n    # If we reached here, the entire graph is bipartite.\n    # Now check for t=1, t=2, t=3.\n\n    # Try t=1\n    w1 = 0\n    for c0, c1, _ in components_data:\n        # Number of ways to add an edge between two color-0 vertices\n        w1 += c0 * (c0 - 1) // 2\n        # Number of ways to add an edge between two color-1 vertices\n        w1 += c1 * (c1 - 1) // 2\n    \n    if w1 > 0:\n        print(f\"1 {w1}\")\n        return\n\n    # Try t=2\n    w2 = 0\n    N_long = n # Use N_long to prevent overflow in intermediate calculations for N*(N-1)*(N-2)\n    \n    # We need to pick two vertices u,v from one component (different colors)\n    # and one vertex x from another component. Add edges (u,x) and (v,x).\n    # This forms an odd cycle u-x-v-...-u\n    \n    # Iterate through all components 'i'\n    for i in range(len(components_data)):\n        c0_i, c1_i, size_i = components_data[i]\n        \n        # Number of ways to pick u,v from component i with different colors\n        ways_to_pick_uv_diff_colors = c0_i * c1_i\n        \n        # Number of ways to pick x from any other component (N - size_i)\n        ways_to_pick_x_other_component = N_long - size_i\n        \n        w2 += ways_to_pick_uv_diff_colors * ways_to_pick_x_other_component\n    \n    if w2 > 0:\n        print(f\"2 {w2}\")\n        return\n    \n    # Try t=3\n    # If N < 3, it's impossible to form a 3-cycle.\n    # The problem implies a solution always exists if N >= 3.\n    # If we reach here, it implies N >= 3 (e.g. 3 isolated vertices).\n    # We need to add 3 edges to form a triangle (e.g., (1,2), (2,3), (3,1)).\n    # This is possible if N >= 3. The number of ways is the number of ways to choose 3 vertices.\n    \n    if N_long >= 3:\n        w3 = N_long * (N_long - 1) * (N_long - 2) // 6\n        print(f\"3 {w3}\")\n    # else:\n    # This case implies N < 3 and no odd cycle could be formed, which should not happen based on problem constraints or competitive programming problem structure.\n    # For N=1, no cycle. For N=2, no odd cycle.\n\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 5071,
        "thoughts_token_count": 762
    }
}