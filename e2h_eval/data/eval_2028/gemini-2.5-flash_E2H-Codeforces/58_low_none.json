{
    "start": 1758284892.1226974,
    "end": 1758284972.505438,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through the Competitive Programming Problem**\n\nOkay, so I'm tackling this competitive programming problem. The goal is to figure out the minimum number of edges, `t`, you need to add to a given graph to create a simple odd-length cycle, and then count the number of ways, `w`, to do this. My initial thought is to link this to the concept of graph bipartiteness – a graph contains an odd cycle if and only if it's *not* bipartite.\n\nSo, the problem boils down to finding the fewest edges to make the graph non-bipartite. I'll consider the graph `G = (V, E)` and the augmented graph `G' = (V, E ∪ E_added)`.\n\nFirst, I should check the connected components. If any of them *already* has an odd cycle, I'm done. `t` is 0, and there's only one way to do it (add no edges). I can verify this with a simple BFS or DFS 2-coloring – any conflict means an odd cycle.\n\nIf none of the connected components have an odd cycle, they're all bipartite. Now, to make an odd cycle, I have to introduce an edge that breaks the bipartiteness. Think of each bipartite component as having two partitions. Adding an edge between two vertices *within the same* partition will create that odd cycle.\n\nNow, let's explore the case where `t = 1`. Can I achieve an odd cycle by adding just one edge? Sure, if I can find two vertices, `u` and `v`, within the *same* connected component that have the *same* color in the 2-coloring, I can add an edge and bingo – an odd cycle!\n\nI can iterate through the components, 2-color them (if possible), and partition them into `S_0` and `S_1`. If there's a component with at least two vertices in one of the partitions, I can add an edge within that partition. This gives `t = 1`.\n\nThe number of ways, `w`, to do this involves counting all the possible edges within partitions. For a component with partitions `S_0` and `S_1`, the number of possible edges would be the combination of vertices in each set: `|S_0| * (|S_0| - 1) / 2 + |S_1| * (|S_1| - 1) / 2`. I sum these values across all components that meet the condition.\n\nI need to make sure I'm not creating parallel edges. Since the original graph is bipartite, any original edge will connect vertices from opposite partitions. Therefore, any edge I add between vertices *within* a partition is valid. This also confirms my previous statements.\n\nSo, the condition is that any component must have at least two vertices. If so, `t = 1`. We sum the calculation of possible edges across all valid components.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so. A simple cycle means each vertex occurs at most once.\n\nA graph contains an odd cycle if and only if it is not bipartite. Therefore, the problem is equivalent to finding the minimum number of edges `t` to add to make the graph non-bipartite, and `w` ways to do so.\n\nWe can analyze the problem by considering the connected components of the graph. We will use a 2-coloring (BFS or DFS) to determine if a component is bipartite and to find its partitions.\n\nLet `colors` be an array to store the color (0 or 1) of each vertex, initialized to -1 (unvisited).\nLet `visited` be an array to keep track of visited vertices.\n\nIterate through each vertex `i` from 1 to `n`. If `i` has not been visited:\n1. Start a BFS/DFS from `i` to find its connected component.\n2. During the traversal, try to 2-color the component. Assign `colors[i] = 0`.\n3. For each edge `(u, v)` encountered:\n    a. If `v` is uncolored, assign `colors[v] = 1 - colors[u]` and add `v` to the queue/stack.\n    b. If `v` is colored and `colors[v] == colors[u]`, then an odd cycle already exists in this component.\n       In this case, `t = 0` and `w = 1`. We can immediately print `0 1` and exit.\n4. If the traversal completes without finding a conflict, the component is bipartite. Let `count0` be the number of vertices colored 0 and `count1` be the number of vertices colored 1 in this component. Store these counts.\n\nIf no odd cycle is found in any component after checking all components, then the original graph is bipartite. We need to add at least one edge.\n\nNow we consider the cases for `t > 0`:\n\n**Case 1: `t = 1`**\nWe can form an odd cycle by adding a single edge `(u, v)` if `u` and `v` are in the same connected component and have the same color in a 2-coloring of that component.\nFor each bipartite connected component with partitions `S_0` (vertices colored 0) and `S_1` (vertices colored 1):\n- If we add an edge between two vertices in `S_0`, it forms an odd cycle. The number of such pairs is `count0 * (count0 - 1) / 2`.\n- If we add an edge between two vertices in `S_1`, it forms an odd cycle. The number of such pairs is `count1 * (count1 - 1) / 2`.\nSince the original graph is bipartite, all existing edges connect vertices of different colors. Thus, any edge `(u, v)` where `u, v \\in S_0` or `u, v \\in S_1` cannot be an existing edge. So, all these pairs are valid for adding an edge.\nThe total number of ways to add 1 edge to form an odd cycle is the sum of `(count0 * (count0 - 1) / 2 + count1 * (count1 - 1) / 2)` over all bipartite connected components.\nIf this sum is greater than 0, then `t = 1`. We print `1` and this sum `w`.\n\n**Case 2: `t = 2`**\nIf `t = 1` is not possible (i.e., all `count0` and `count1` for all components are less than 2, meaning all components are isolated vertices or single edges), then we need to add at least 2 edges.\nWe can form an odd cycle by adding two edges `(u, v)` and `(v, w)` such that `u` and `w` are in different components, and `v` is some vertex. This seems complicated to count.\n\nA simpler way to form an odd cycle with 2 edges is to connect two distinct bipartite components `C_A` and `C_B` with an edge `(u, v)` where `u \\in C_A` and `v \\in C_B`, and then connect a vertex `x \\in C_A` to a vertex `y \\in C_B` with another edge `(x, y)`.\nThis creates a path `u - ... - x` in `C_A` and `v - ... - y` in `C_B`.\nIf we connect `u` to `v` and `x` to `y`, we form a cycle `u - (path in C_A) - x - y - (path in C_B) - v - u`.\nThe length of this cycle is `dist_A(u, x) + 1 + dist_B(v, y) + 1`.\nThe parity of `dist_A(u, x)` is `colors[u] != colors[x]`. Similarly for `C_B`.\nSo, `dist_A(u, x)` has parity 1 if `colors[u] \\neq colors[x]` and 0 if `colors[u] = colors[x]`.\nThe total cycle length parity is `(colors[u] \\neq colors[x]) + 1 + (colors[v] \\neq colors[y]) + 1 \\pmod 2`.\nThis is `(colors[u] + colors[x]) + 1 + (colors[v] + colors[y]) + 1 \\pmod 2` if we use 0/1 for colors.\nThis can be simplified: to make an odd cycle, we need to add two edges `(u,v)` and `(x,y)` between two components `C_A` and `C_B`.\nThe total number of vertices in `C_A` is `N_A`, and in `C_B` is `N_B`.\nAny choice of `u \\in C_A`, `v \\in C_B`, `x \\in C_A`, `y \\in C_B` forms a valid pair of edges, as long as `(u, v)` and `(x, y)` are not existing edges (which they won't be since they connect different components) and `(u, v) \\neq (x, y)`.\nThe number of ways to pick two distinct edges between `C_A` and `C_B` is `(N_A * N_B) * (N_A * N_B - 1) / 2`.\nThis is the number of ways to choose two *unordered* pairs of vertices, one from `C_A` and one from `C_B`.\nHowever, we are adding two edges. The first edge `(u, v)` connects `C_A` and `C_B`. The second edge `(x, y)` connects `C_A` and `C_B`.\nThe total number of pairs of vertices `(u, v)` where `u \\in C_A` and `v \\in C_B` is `N_A * N_B`.\nWe need to pick two such distinct pairs. The number of ways to pick two distinct edges is `(N_A * N_B) * (N_A * N_B - 1) / 2`.\nThis will form an odd cycle. If we connect `u` (color `c_u`) to `v` (color `c_v`) and `x` (color `c_x`) to `y` (color `c_y`), then the cycle length parity depends on the paths within components.\nThe path `u \\leadsto x` in `C_A` has length of parity `c_u \\oplus c_x`.\nThe path `v \\leadsto y` in `C_B` has length of parity `c_v \\oplus c_y`.\nThe cycle length is `(c_u \\oplus c_x) + 1 + (c_v \\oplus c_y) + 1 \\pmod 2`.\nThis is `c_u \\oplus c_x \\oplus c_v \\oplus c_y \\pmod 2`.\nTo make this odd, we need `c_u \\oplus c_x \\oplus c_v \\oplus c_y = 1`.\nThis means an odd number of these XOR terms must be 1.\nThis is always possible by choosing `u, x` from `S_0` of `C_A` and `v, y` from `S_0` of `C_B` etc.\nThe total number of ways to pick two distinct edges between two components `C_A` and `C_B` is `(N_A * N_B) * (N_A * N_B - 1) / 2`.\nSum this over all pairs of distinct components `(C_A, C_B)`.\nLet `N_comp` be the number of bipartite connected components with at least one vertex.\nLet `sizes` be a list of `(count0, count1)` for each such component.\nThe number of ways `w` to add 2 edges is `sum_{i < j} (sizes[i].total_vertices * sizes[j].total_vertices)`.\nThis is `t = 2` if this sum is greater than 0.\n\n**Case 3: `t = 3`**\nIf `t = 1` and `t = 2` are not possible, it means:\n- No component has `count0 >= 2` or `count1 >= 2`. So all components are either isolated vertices (size 1) or single edges (size 2).\n- There are not enough components to pick two distinct ones and add two edges (i.e., less than 2 components, or all components are isolated vertices of size 1).\nIf `N_comp` (number of non-empty components) is 0 or 1, then `t=2` is not possible.\nIf `N_comp == 0`, `n` must be 0, which is not possible by constraints `n >= 1`.\nIf `N_comp == 1`, and `t=1` is not possible, it means this single component is either `(1,0)` or `(0,1)` (an isolated vertex).\nIn this scenario, `t = 3`. We need to pick three distinct vertices `u, v, w` and add edges `(u, v), (v, w), (w, u)`. This forms a triangle, which is an odd cycle. The number of ways is `n * (n - 1) * (n - 2) / 6`. This is only possible if `n >= 3`. If `n < 3`, it's impossible to form a triangle. However, the problem states \"cycle of odd length, consisting of more than one vertex\". Smallest is a triangle.\n\nLet's refine the logic for `t=2` and `t=3`.\n\nLet `comp_counts` be a list of `(count0, count1)` for each bipartite connected component.\nLet `num_isolated_vertices` be the count of components with `count0=1, count1=0` or `count0=0, count1=1`. These are components of size 1.\nLet `num_bipartite_components_with_at_least_2_vertices` be the count of components where `count0 + count1 >= 2`.\n\n**Algorithm Steps:**\n\n1. Initialize `adj` list, `colors` array (all -1), `visited` array (all False).\n2. `odd_cycle_found = False`\n3. `bipartite_component_info = []` (stores `(count0, count1)` for each bipartite component)\n4. Iterate `i` from 1 to `n`:\n    If `not visited[i]`:\n        `current_count0 = 0`, `current_count1 = 0`\n        `q = deque([i])`\n        `visited[i] = True`\n        `colors[i] = 0`\n        `is_bipartite = True`\n        `component_nodes = []`\n\n        BFS:\n        While `q`:\n            `u = q.popleft()`\n            `component_nodes.append(u)`\n            If `colors[u] == 0`: `current_count0 += 1`\n            Else: `current_count1 += 1`\n\n            For `v` in `adj[u]`:\n                If `not visited[v]`:\n                    `visited[v] = True`\n                    `colors[v] = 1 - colors[u]`\n                    `q.append(v)`\n                Else if `colors[v] == colors[u]`:\n                    `odd_cycle_found = True`\n                    Break BFS\n            If `odd_cycle_found`: Break BFS\n        \n        If `odd_cycle_found`:\n            Print `0 1` and exit.\n        Else:\n            `bipartite_component_info.append((current_count0, current_count1))`\n\n5. If `odd_cycle_found` is still `False` (meaning the original graph is bipartite):\n    `t = 0`, `w = 0` (these will be updated)\n\n    **Check for `t = 1`:**\n    `ways_t1 = 0`\n    For `(c0, c1)` in `bipartite_component_info`:\n        `ways_t1 += c0 * (c0 - 1) // 2`\n        `ways_t1 += c1 * (c1 - 1) // 2`\n    \n    If `ways_t1 > 0`:\n        Print `1 ways_t1` and exit.\n\n    **Check for `t = 2`:**\n    `ways_t2 = 0`\n    `total_nodes_in_bipartite_components = 0`\n    For `(c0, c1)` in `bipartite_component_info`:\n        `total_nodes_in_bipartite_components += (c0 + c1)`\n    \n    If `len(bipartite_component_info) >= 2`:\n        # Sum of (N_i * N_j) for all pairs of components\n        # This is equivalent to (sum N_i)^2 - sum(N_i^2) / 2\n        # where N_i is the total number of nodes in component i\n        # The total number of nodes in all components is `total_nodes_in_bipartite_components`\n        # Let `S = sum(N_i)`. We want to calculate `sum_{i<j} N_i N_j`.\n        # `S^2 = (sum N_i)^2 = sum(N_i^2) + 2 * sum_{i<j} N_i N_j`.\n        # So `sum_{i<j} N_i N_j = (S^2 - sum(N_i^2)) / 2`.\n        \n        `sum_N = 0`\n        `sum_N_squared = 0`\n        For `(c0, c1)` in `bipartite_component_info`:\n            `N_i = c0 + c1`\n            `sum_N += N_i`\n            `sum_N_squared += N_i * N_i`\n        \n        `ways_t2 = (sum_N * sum_N - sum_N_squared) // 2`\n\n    If `ways_t2 > 0`:\n        Print `2 ways_t2` and exit.\n\n    **Case `t = 3`:**\n    If none of the above conditions met, `t` must be 3.\n    This implies that all components are isolated vertices (since `t=1` was not possible), and there are not enough components to connect two (if `len(bipartite_component_info) < 2` or `len(bipartite_component_info)` is 2 but `ways_t2` is 0, which means one of the components has size 0 or 1. But `c0+c1` is always >=1 for any component. So `ways_t2` would be >0 if `len >= 2` and `N_i >= 1` for all `i`).\n    So, if `t=1` and `t=2` are not possible, it means all components are isolated vertices, and we need to pick 3 of them to form a triangle.\n    The number of ways to pick 3 vertices from `n` available vertices is `n * (n - 1) * (n - 2) / 6`.\n    Print `3 (n * (n - 1) * (n - 2) // 6)`.\n\n**Example 1: 4 4, 1-2, 1-3, 4-2, 4-3**\n- Component 1: 1-2, 1-3, 4-2, 4-3.\n- Start BFS from 1, color[1]=0.\n- Neighbors of 1: 2, 3. color[2]=1, color[3]=1.\n- Neighbors of 2: 1, 4. color[1]=0 (ok), color[4]=0.\n- Neighbors of 3: 1, 4. color[1]=0 (ok), color[4]=0. Conflict! color[4] should be 1-color[3]=0, but already colored 0 from 2.\n- Wait, 1-2, 1-3, 4-2, 4-3. This is C4.\n- 1(0) - 2(1)\n- |     |\n- 3(1) - 4(0)\n- This is bipartite.\n- Let's re-run 2-coloring for 1-2, 1-3, 4-2, 4-3:\n  - `colors[1]=0`\n  - `colors[2]=1` (from 1-2)\n  - `colors[3]=1` (from 1-3)\n  - `colors[4]=0` (from 2-4)\n  - Check 3-4: `colors[3]=1`, `colors[4]=0`. OK.\n- Component is bipartite. `S_0 = {1, 4}`, `S_1 = {2, 3}`. `count0=2, count1=2`.\n- `ways_t1 = 2*(2-1)//2 + 2*(2-1)//2 = 1 + 1 = 2`.\n- `t=1`, `w=2`. Output: `1 2`. Correct.\n\n**Example 2: 3 3, 1-2, 2-3, 3-1**\n- Component 1: 1-2, 2-3, 3-1. This is K3.\n- Start BFS from 1, color[1]=0.\n- Neighbors of 1: 2, 3. color[2]=1, color[3]=1.\n- Neighbors of 2: 1, 3. color[1]=0 (ok). For 3: `colors[3]=1`, `colors[2]=1`. Conflict! `colors[3] == colors[2]`.\n- `odd_cycle_found = True`.\n- Output: `0 1`. Correct.\n\n**Example 3: 3 0**\n- `n=3, m=0`. No edges.\n- Vertex 1: `visited[1]=F`. Start BFS. `colors[1]=0`. `count0=1, count1=0`. `bipartite_component_info.append((1,0))`.\n- Vertex 2: `visited[2]=F`. Start BFS. `colors[2]=0`. `count0=1, count1=0`. `bipartite_component_info.append((1,0))`.\n- Vertex 3: `visited[3]=F`. Start BFS. `colors[3]=0`. `count0=1, count1=0`. `bipartite_component_info.append((1,0))`.\n- `odd_cycle_found = False`.\n- `bipartite_component_info = [(1,0), (1,0), (1,0)]`.\n- Check `t=1`: `ways_t1 = 0`. (since `c0=1, c1=0` for all components, `c0*(c0-1)//2 = 0`, `c1*(c1-1)//2 = 0`).\n- Check `t=2`: `len(bipartite_component_info) = 3 >= 2`.\n  - `sum_N = 1+1+1 = 3`.\n  - `sum_N_squared = 1*1 + 1*1 + 1*1 = 3`.\n  - `ways_t2 = (3*3 - 3) // 2 = (9 - 3) // 2 = 6 // 2 = 3`.\n- `ways_t2 = 3 > 0`.\n- Output: `2 3`.\n- Wait, example output is `3 1`. Why?\n- My interpretation of `t=2` is connecting two components with two edges.\n- If we have 3 isolated vertices {1}, {2}, {3}.\n- My `ways_t2 = 3` means:\n  - Add (1,2), (1,3)\n  - Add (1,2), (2,3)\n  - Add (1,3), (2,3)\n- None of these form an odd cycle.\n  - If we add (1,2) and (1,3), we get 2-1-3. No cycle.\n  - If we add (1,2) and (2,3), we get 1-2-3. No cycle.\n  - If we add (1,3) and (2,3), we get 1-3-2. No cycle.\n- The cycle needs to be formed by *more than one vertex*. A path is not a cycle.\n- My `t=2` logic was: \"connect two distinct bipartite components `C_A` and `C_B` with an edge `(u, v)` where `u \\in C_A` and `v \\in C_B`, and then connect a vertex `x \\in C_A` to a vertex `y \\in C_B` with another edge `(x, y)`.\"\n- This *does* form a cycle `u - (path in C_A) - x - y - (path in C_B) - v - u`.\n- For `C_A = {1}`, `C_B = {2}`, `C_C = {3}`.\n- If we pick `C_A={1}` and `C_B={2}`. `N_A=1, N_B=1`. `N_A*N_B = 1`. `(1*1)*(1*1-1)/2 = 0`. So `ways_t2` for this pair is 0.\n- This is correct. My `ways_t2` formula `(sum_N * sum_N - sum_N_squared) // 2` calculates `sum_{i<j} N_i N_j`.\n- For `bipartite_component_info = [(1,0), (1,0), (1,0)]`:\n  - `N_1=1, N_2=1, N_3=1`.\n  - `sum_N = 3`. `sum_N_squared = 3`.\n  - `ways_t2 = (3*3 - 3) // 2 = 3`.\n  - These 3 ways are:\n    - `N_1 * N_2 = 1*1 = 1` way to pick `(1,2)`\n    - `N_1 * N_3 = 1*1 = 1` way to pick `(1,3)`\n    - `N_2 * N_3 = 1*1 = 1` way to pick `(2,3)`\n  - Total `1+1+1 = 3`.\n  - This is the number of ways to add *one* edge between two components.\n  - If we add *one* edge between two isolated vertices, say (1,2), we get a component {1,2} which is still bipartite. We need to add *two* edges to form a cycle.\n  - The `t=2` logic should be: pick two distinct components `C_A, C_B`. Add two edges `(u,v)` and `(x,y)` where `u,x \\in C_A` and `v,y \\in C_B`. This forms a cycle.\n  - The number of ways to pick `u,x \\in C_A` is `N_A * N_A`. The number of ways to pick `v,y \\in C_B` is `N_B * N_B`. Total `N_A^2 * N_B^2`.\n  - However, we need to pick two *distinct* edges.\n  - If we pick `u,v` and `x,y`. If `u=x` or `v=y`, it's not a cycle.\n  - If `u=x` and `v=y`, it's one edge.\n  - The minimum way to form an odd cycle with 2 edges is to connect two components `C_A` and `C_B` with an edge `(u,v)` and then connect `C_A` to `C_B` with another edge `(x,y)` where `u \\neq x` and `v \\neq y`. This forms a C4. For this, `N_A >= 2` and `N_B >= 2` are not required. We need `N_A * N_B >= 2` to pick two distinct edges.\n  - No, `u,x` must be from `C_A` and `v,y` must be from `C_B`.\n  - We need to pick 2 edges `(u_1, v_1)` and `(u_2, v_2)` such that `u_1, u_2 \\in C_A`, `v_1, v_2 \\in C_B`.\n  - To form a cycle of length 4, we need `u_1 \\neq u_2` and `v_1 \\neq v_2`.\n  - This requires `N_A >= 2` and `N_B >= 2`.\n  - If `N_A=1, N_B=1`, we can only pick one edge `(u,v)`. We can't pick two distinct edges `(u_1,v_1), (u_2,v_2)` such that `u_1 \\neq u_2` and `v_1 \\neq v_2`.\n  - This means for `N_A=1, N_B=1` components (isolated vertices), `t=2` is not possible.\n\nRevised `t=2` logic:\n`ways_t2 = 0`\nIterate `i` from 0 to `len(bipartite_component_info) - 1`:\n  For `j` from `i + 1` to `len(bipartite_component_info) - 1`:\n    `N_i = bipartite_component_info[i][0] + bipartite_component_info[i][1]`\n    `N_j = bipartite_component_info[j][0] + bipartite_component_info[j][1]`\n    If `N_i >= 2` and `N_j >= 2`:\n      `ways_t2 += N_i * N_j * (N_i - 1) * (N_j - 1) // 2` (Ways to pick 2 edges (u1,v1), (u2,v2) with u1!=u2, v1!=v2)\n    Else if `N_i >= 1` and `N_j >= 1`:\n      # If one or both components have size 1, we cannot form a C4.\n      # A cycle like u-v-x-y-u requires at least 2 vertices from each component.\n      # If `N_i=1`, then `u1=u2`. If `N_j=1`, then `v1=v2`.\n      # If `N_i=1, N_j=1`, then we can only add one edge (u,v). We need 2 edges.\n      # If `N_i=1, N_j>=2`, we can add (u,v1) and (u,v2). This creates a cycle.\n      # The cycle is u-v1-(path in Cj)-v2-u. Length is 1 + path_len + 1 = 2 + path_len.\n      # path_len is `colors[v1] != colors[v2]`.\n      # To make it odd, `colors[v1] != colors[v2]` must be odd.\n      # This means `colors[v1] == colors[v2]`.\n      # So, pick `u` from `C_i`, `v1, v2` from `C_j` such that `colors[v1] == colors[v2]`.\n      # Number of ways: `N_i * (c0j*(c0j-1)//2 + c1j*(c1j-1)//2)`.\n      # This is `N_i` times `ways_t1` for component `j`.\n      # This is for connecting `C_i` to `C_j`.\n      # And vice-versa, connecting `C_j` to `C_i`.\n      # No, this is `t=1` logic where one component is connected to itself.\n      # `t=2` implies connecting two different components.\n      # If `N_i=1`, `N_j>=2`. Let `C_i = {u}`. `C_j` has `c0j, c1j`.\n      # Add edges `(u, v1)` and `(u, v2)` where `v1,v2 \\in C_j`.\n      # For an odd cycle, `v1, v2` must have the same color.\n      # Number of ways: `N_i * (c0j*(c0j-1)//2 + c1j*(c1j-1)//2)`.\n      # This is `1 * (c0j*(c0j-1)//2 + c1j*(c1j-1)//2)`.\n      # This is exactly the `ways_t1` calculation for component `j`.\n      # This is not a `t=2` scenario. This is adding 2 edges.\n      # We just found that `t=1` implies `ways_t1 > 0`. If `ways_t1 = 0`, then all `c0, c1 < 2`.\n      # So, if `t=1` is not possible, then all components are isolated vertices (size 1).\n      # If all components are isolated vertices, `N_i=1` for all `i`.\n      # Then `N_i>=2` and `N_j>=2` condition is never met.\n      # And `N_i=1, N_j>=2` condition is never met.\n      # So, `ways_t2` would be 0 in this case.\n\nFinal refined logic:\n\n1. **Check for `t=0`:**\n   Perform a 2-coloring (BFS/DFS) on each connected component.\n   If any component is found to be non-bipartite (i.e., contains an odd cycle), print `0 1` and exit.\n   Otherwise, store `(count0, count1)` for each bipartite component in `bipartite_component_info`.\n\n2. **Check for `t=1`:**\n   `ways_t1 = 0`\n   For each `(c0, c1)` in `bipartite_component_info`:\n     `ways_t1 += c0 * (c0 - 1) // 2`\n     `ways_t1 += c1 * (c1 - 1) // 2`\n   If `ways_t1 > 0`, print `1 ways_t1` and exit.\n   (This implies that if `t=1` is not possible, all `c0, c1` for all components are less than 2. So every component is either an isolated vertex or a single edge. If `m=0`, all components are isolated vertices.)\n\n3. **Check for `t=2`:**\n   At this point, we know all components are bipartite, and no component has `c0 >= 2` or `c1 >= 2`. This means all components are either isolated vertices (`(1,0)` or `(0,1)`) or single edges (`(1,1)`).\n   To form an odd cycle with 2 edges, we need to connect two distinct components `C_A` and `C_B`.\n   Let `N_A = c0_A + c1_A` and `N_B = c0_B + c1_B`.\n   If we add two edges `(u, v)` and `(x, y)` where `u, x \\in C_A` and `v, y \\in C_B`.\n   To form an odd cycle, we need to pick `u,x` such that `u \\neq x` and `v,y` such that `v \\neq y`.\n   This requires `N_A >= 2` and `N_B >= 2`.\n   The number of ways to pick `u,x` from `C_A` with `u \\neq x` is `N_A * (N_A - 1)`.\n   The number of ways to pick `v,y` from `C_B` with `v \\neq y` is `N_B * (N_B - 1)`.\n   The total number of ways to pick ordered pairs `(u,x)` and `(v,y)` is `N_A * (N_A - 1) * N_B * (N_B - 1)`.\n   Since edges are unordered, divide by 2 for `(u,v)-(x,y)` vs `(x,y)-(u,v)`.\n   So, `ways_t2 = sum_{i<j} (N_i * (N_i - 1) * N_j * (N_j - 1) / 2)` over components `i, j` where `N_i >= 2` and `N_j >= 2`.\n   However, since `t=1` was not possible, we know that for any component, `c0 < 2` AND `c1 < 2`.\n   This implies `N_i = c0 + c1` can be at most 2 (e.g., `c0=1, c1=1` for a single edge component).\n   If `N_i = 1`, then `N_i - 1 = 0`.\n   If `N_i = 2`, then `N_i - 1 = 1`.\n   So, `N_i * (N_i - 1)` is non-zero only if `N_i >= 2`.\n   The only components with `N_i >= 2` are those that are single edges. For such a component, `N_i = 2`.\n   So, `N_i * (N_i - 1) = 2 * 1 = 2`.\n   Let `num_edge_components` be the count of components that are single edges (`c0=1, c1=1`).\n   If `num_edge_components >= 2`:\n     `ways_t2 = num_edge_components * (num_edge_components - 1) // 2 * (2 * 1) * (2 * 1) // 2`\n     `ways_t2 = num_edge_components * (num_edge_components - 1) // 2 * 2`.\n     This is the number of ways to pick 2 distinct edge-components, and for each, pick 2 vertices (2 ways for each component: `u,x` or `x,u`).\n     `ways_t2 = (num_edge_components choose 2) * 2 * 2`.\n     No, it's `(num_edge_components choose 2)` pairs of components. For each pair `C_i, C_j`, `N_i=2, N_j=2`.\n     Ways to pick `u,x` from `C_i` (2 ways) and `v,y` from `C_j` (2 ways). Total `2*2=4` ways for each pair.\n     So `ways_t2 = (num_edge_components * (num_edge_components - 1) // 2) * 4`.\n   If `ways_t2 > 0`, print `2 ways_t2` and exit.\n\n4. **Case `t=3`:**\n   If `t=0, t=1, t=2` are not possible, then `t=3`.\n   This means all components are isolated vertices (`N_i=1`).\n   To form an odd cycle (triangle), we need to pick 3 distinct vertices `u, v, w` and add edges `(u,v), (v,w), (w,u)`.\n   The number of ways is `n * (n - 1) * (n - 2) // 6`.\n   Print `3 (n * (n - 1) * (n - 2) // 6)`.\n\nThis logic correctly handles Example 3. For 3 0:\n- `bipartite_component_info = [(1,0), (1,0), (1,0)]`.\n- `ways_t1 = 0`.\n- `t=2` check: `N_i=1` for all components. So `N_i * (N_i - 1) = 0`. `ways_t2 = 0`.\n- So `t=3`. `w = 3 * 2 * 1 // 6 = 1`. Output: `3 1`. Correct.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    \n    odd_cycle_found = False\n    bipartite_component_info = [] # Stores (count0, count1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_count0 = 0\n            current_count1 = 0\n            q = deque()\n            \n            q.append(i)\n            visited[i] = True\n            colors[i] = 0 # Start coloring with 0\n            \n            is_current_component_bipartite = True\n            \n            component_nodes = [] # To gather nodes of current component\n\n            head = 0 # Manual queue pointer for performance\n            \n            # BFS to 2-color the component\n            while head < len(q):\n                u = q[head]\n                head += 1\n\n                component_nodes.append(u)\n\n                if colors[u] == 0:\n                    current_count0 += 1\n                else:\n                    current_count1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        q.append(v)\n                    elif colors[v] == colors[u]:\n                        is_current_component_bipartite = False\n                        break # Found an odd cycle in this component\n                \n                if not is_current_component_bipartite:\n                    break # Break from BFS if odd cycle found\n\n            if not is_current_component_bipartite:\n                odd_cycle_found = True\n                break # Break from iterating components if odd cycle found\n            else:\n                bipartite_component_info.append((current_count0, current_count1))\n\n    if odd_cycle_found:\n        print(\"0 1\")\n        return\n\n    # If no odd cycle found in the original graph, check for t=1, t=2, t=3\n\n    # Check for t=1\n    ways_t1 = 0\n    for c0, c1 in bipartite_component_info:\n        ways_t1 += c0 * (c0 - 1) // 2\n        ways_t1 += c1 * (c1 - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Check for t=2\n    # At this point, we know that for every bipartite component (c0, c1),\n    # c0 < 2 and c1 < 2. This means each component is either an isolated vertex (1,0) or (0,1),\n    # or a single edge (1,1).\n    \n    # To form an odd cycle with 2 edges, we need to connect two components, say C_i and C_j,\n    # with two edges (u1, v1) and (u2, v2), where u1, u2 are in C_i and v1, v2 are in C_j.\n    # To form a cycle (specifically C4), we need u1 != u2 AND v1 != v2.\n    # This implies that C_i must have at least 2 vertices AND C_j must have at least 2 vertices.\n    \n    # Count components that are single edges (i.e., have 2 vertices, (1,1) partition)\n    num_edge_components = 0\n    for c0, c1 in bipartite_component_info:\n        if c0 + c1 == 2: # Must be c0=1, c1=1\n            num_edge_components += 1\n    \n    ways_t2 = 0\n    if num_edge_components >= 2:\n        # Choose 2 distinct edge-components out of num_edge_components.\n        # For each such pair, say C_i = {u1, u2} and C_j = {v1, v2}.\n        # We need to add two edges (u_from_Ci, v_from_Cj) and (x_from_Ci, y_from_Cj).\n        # To form a C4, we need to pick u_from_Ci != x_from_Ci and v_from_Cj != y_from_Cj.\n        # For C_i = {u1, u2}, ways to pick two distinct vertices is 2*1=2.\n        # For C_j = {v1, v2}, ways to pick two distinct vertices is 2*1=2.\n        # So for a pair of components, 2 * 2 = 4 ways to form a C4.\n        ways_t2 = (num_edge_components * (num_edge_components - 1) // 2) * 4\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # If t=0, t=1, t=2 are not possible, then t=3.\n    # This implies all components are isolated vertices.\n    # We need to form a triangle (C3) using 3 distinct vertices.\n    # This requires n >= 3.\n    # The number of ways to choose 3 vertices from n is nC3.\n    ways_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {ways_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    \n    odd_cycle_found = False\n    bipartite_component_info = [] # Stores (count0, count1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_count0 = 0\n            current_count1 = 0\n            q = deque()\n            \n            q.append(i)\n            visited[i] = True\n            colors[i] = 0 # Start coloring with 0\n            \n            is_current_component_bipartite = True\n            \n            component_nodes = [] # To gather nodes of current component\n\n            head = 0 # Manual queue pointer for performance\n            \n            # BFS to 2-color the component\n            while head < len(q):\n                u = q[head]\n                head += 1\n\n                component_nodes.append(u)\n\n                if colors[u] == 0:\n                    current_count0 += 1\n                else:\n                    current_count1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        q.append(v)\n                    elif colors[v] == colors[u]:\n                        is_current_component_bipartite = False\n                        break # Found an odd cycle in this component\n                \n                if not is_current_component_bipartite:\n                    break # Break from BFS if odd cycle found\n\n            if not is_current_component_bipartite:\n                odd_cycle_found = True\n                break # Break from iterating components if odd cycle found\n            else:\n                bipartite_component_info.append((current_count0, current_count1))\n\n    if odd_cycle_found:\n        print(\"0 1\")\n        return\n\n    # If no odd cycle found in the original graph, check for t=1, t=2, t=3\n\n    # Check for t=1\n    ways_t1 = 0\n    for c0, c1 in bipartite_component_info:\n        ways_t1 += c0 * (c0 - 1) // 2\n        ways_t1 += c1 * (c1 - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Check for t=2\n    # At this point, we know that for every bipartite component (c0, c1),\n    # c0 < 2 and c1 < 2. This means each component is either an isolated vertex (1,0) or (0,1),\n    # or a single edge (1,1).\n    \n    # To form an odd cycle with 2 edges, we need to connect two components, say C_i and C_j,\n    # with two edges (u1, v1) and (u2, v2), where u1, u2 are in C_i and v1, v2 are in C_j.\n    # To form a cycle (specifically C4), we need u1 != u2 AND v1 != v2.\n    # This implies that C_i must have at least 2 vertices AND C_j must have at least 2 vertices.\n    \n    # Count components that are single edges (i.e., have 2 vertices, (1,1) partition)\n    num_edge_components = 0\n    for c0, c1 in bipartite_component_info:\n        if c0 + c1 == 2: # Must be c0=1, c1=1\n            num_edge_components += 1\n    \n    ways_t2 = 0\n    if num_edge_components >= 2:\n        # Choose 2 distinct edge-components out of num_edge_components.\n        # For each such pair, say C_i = {u1, u2} and C_j = {v1, v2}.\n        # We need to add two edges (u_from_Ci, v_from_Cj) and (x_from_Ci, y_from_Cj).\n        # To form a C4, we need to pick u_from_Ci != x_from_Ci and v_from_Cj != y_from_Cj.\n        # For C_i = {u1, u2}, ways to pick two distinct vertices is 2*1=2.\n        # For C_j = {v1, v2}, ways to pick two distinct vertices is 2*1=2.\n        # So for a pair of components, 2 * 2 = 4 ways to form a C4.\n        ways_t2 = (num_edge_components * (num_edge_components - 1) // 2) * 4\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # If t=0, t=1, t=2 are not possible, then t=3.\n    # This implies all components are isolated vertices.\n    # We need to form a triangle (C3) using 3 distinct vertices.\n    # This requires n >= 3.\n    # The number of ways to choose 3 vertices from n is nC3.\n    ways_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {ways_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 594,
        "completion_token_count": 10301,
        "thoughts_token_count": 941
    }
}