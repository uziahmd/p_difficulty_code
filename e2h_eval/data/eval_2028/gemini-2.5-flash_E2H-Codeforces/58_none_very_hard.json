{
    "start": 1758293731.899398,
    "end": 1758293766.523555,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_set = set()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_set.add(tuple(sorted((u, v))))\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1)\n    has_odd_cycle = False\n\n    def dfs_bipartite(u, c):\n        nonlocal has_odd_cycle\n        visited[u] = True\n        color[u] = c\n        for v in adj[u]:\n            if not visited[v]:\n                if not dfs_bipartite(v, 1 - c):\n                    return False\n            elif color[v] == color[u]:\n                has_odd_cycle = True\n                return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs_bipartite(i, 0)\n            if has_odd_cycle:\n                break\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # All components are bipartite. Need to add edges to form an odd cycle.\n\n    # Case 1: Add 1 edge\n    # An odd cycle can be formed by adding one edge if it connects two vertices\n    # within the same connected component that have the same color.\n    # Count such pairs.\n    \n    # Re-run BFS/DFS to get components and colors for each component\n    component_colors = []\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1)\n\n    def bfs_component(start_node):\n        q = [(start_node, 0)]\n        visited[start_node] = True\n        color[start_node] = 0\n        nodes_in_component = {start_node: 0}\n        head = 0\n        while head < len(q):\n            u, c = q[head]\n            head += 1\n            for v in adj[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    color[v] = 1 - c\n                    nodes_in_component[v] = 1 - c\n                    q.append((v, 1 - c))\n        return nodes_in_component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component_colors.append(bfs_component(i))\n\n    ways_t1 = 0\n    for comp_map in component_colors:\n        color0_count = 0\n        color1_count = 0\n        for node, c in comp_map.items():\n            if c == 0:\n                color0_count += 1\n            else:\n                color1_count += 1\n        \n        # Pairs within color 0\n        ways_t1 += color0_count * (color0_count - 1) // 2\n        # Pairs within color 1\n        ways_t1 += color1_count * (color1_count - 1) // 2\n        \n        # Subtract existing edges\n        for u in comp_map:\n            for v in adj[u]:\n                if comp_map[u] == comp_map[v]: # Same color\n                    if tuple(sorted((u, v))) in edges_set:\n                        ways_t1 -= 1\n    \n    # Each edge (u,v) is counted twice (once for u, once for v in adj[u])\n    # and then again if we iterate over comp_map.items().\n    # The current logic for ways_t1 counts pairs {u,v} such that u,v are in the same component\n    # and have the same color. We need to subtract existing edges from this count.\n    # The calculation `color0_count * (color0_count - 1) // 2` correctly counts pairs.\n    # We then iterate through edges_set to subtract existing edges.\n    # An edge (u,v) should be subtracted if u and v are in the same component and have the same color.\n    \n    actual_ways_t1 = 0\n    for comp_map in component_colors:\n        color0_nodes = [node for node, c in comp_map.items() if c == 0]\n        color1_nodes = [node for node, c in comp_map.items() if c == 1]\n        \n        for i in range(len(color0_nodes)):\n            for j in range(i + 1, len(color0_nodes)):\n                u, v = color0_nodes[i], color0_nodes[j]\n                if tuple(sorted((u, v))) not in edges_set:\n                    actual_ways_t1 += 1\n        for i in range(len(color1_nodes)):\n            for j in range(i + 1, len(color1_nodes)):\n                u, v = color1_nodes[i], color1_nodes[j]\n                if tuple(sorted((u, v))) not in edges_set:\n                    actual_ways_t1 += 1\n\n    if actual_ways_t1 > 0:\n        print(f\"1 {actual_ways_t1}\")\n        return\n\n    # Case 2: Add 2 edges\n    # If all components are bipartite and no single edge forms an odd cycle.\n    # This means all pairs of same-colored nodes within a component are already connected.\n    # This is only possible if each color class has at most 1 node, i.e., components are single nodes or pairs.\n    # But this is not true, e.g., a path 1-2-3-4.\n    # A single edge cannot form an odd cycle if there are no two same-colored nodes that are not connected.\n    # This happens if for every component, all pairs of same-colored nodes are already connected.\n    # This implies that each color class must have size at most 1, which means each component has size at most 2.\n    # If a component has 3 nodes (1-2-3), colors (0-1-0), nodes 1 and 3 are same color. If (1,3) is not an edge, then t=1.\n    # So if t=1 is not possible, it means for any component, if it has nodes u,v of same color, then (u,v) is an edge.\n    # This means each color class in each component has size at most 1.\n    # This implies that each component has at most 2 nodes.\n    # If a component has only one node, say {u}, then no same-colored pair.\n    # If a component has two nodes, say {u,v}, then u and v must have different colors. (0,1). No same-colored pair.\n    # So if actual_ways_t1 == 0, it implies that all connected components are either single nodes or pairs of nodes (u,v) where (u,v) is an edge.\n    # This means the graph is a collection of isolated vertices and edges.\n    # This is a very strong condition. Let's re-evaluate.\n    # actual_ways_t1 == 0 means that for every component, for every pair of nodes (u,v) of the same color, (u,v) is an existing edge.\n    # This means each color class in each component is a clique.\n    # So we have a collection of complete bipartite graphs, where each partition is a clique.\n    # This is possible if the graph is a collection of cliques.\n    # E.g., a triangle is bipartite (0,1,0), 1 and 3 are same color. If (1,3) is an edge, it's not bipartite.\n    # So if the graph is bipartite, then there are no edges between same-colored nodes.\n    # Therefore, if actual_ways_t1 == 0, it means there are no two same-colored nodes u, v such that (u,v) is not an edge.\n    # This implies that for any component, the number of nodes in any color class is at most 1.\n    # This means each component has at most 2 nodes.\n    # So the graph is a collection of isolated vertices and edges.\n    # In this case, each component is either a single vertex or an edge.\n    # Let N_comp be the number of connected components.\n    # Let N_nodes_in_comp be the number of nodes in a component.\n    # If N_nodes_in_comp == 1, it's an isolated vertex.\n    # If N_nodes_in_comp == 2, it's an edge.\n    # So the graph is a collection of isolated vertices and edges.\n\n    # To form an odd cycle with 2 edges:\n    # We need to connect three vertices u, v, w such that (u,v) is an edge, and we add (v,w) and (w,u).\n    # This forms a triangle (u,v,w). The path u-v is an existing edge. We add (v,w) and (w,u).\n    # This is not necessarily an odd cycle. A triangle is always an odd cycle.\n    # We need to pick three distinct vertices u, v, w such that (u,v) is an existing edge.\n    # And (v,w) is not an existing edge, (w,u) is not an existing edge.\n    # The number of such ways is:\n    # Iterate over all existing edges (u,v).\n    # For each (u,v), iterate over all other vertices w (w != u, w != v).\n    # If (u,w) and (v,w) are not existing edges, then we can add them.\n    # The count would be m * (n - 2 - (degree[u] - 1) - (degree[v] - 1) + common_neighbors_count).\n    # This is not right.\n    # We need to choose 3 distinct vertices u, v, w.\n    # We assume that (u,v) is an existing edge.\n    # We need to add (v,w) and (w,u).\n    # Count pairs (u,w) such that (u,w) is not an edge.\n    # Count pairs (v,w) such that (v,w) is not an edge.\n    # This is effectively counting non-edges.\n    # Total possible non-edges (u,v) is n*(n-1)/2 - m.\n    # We need to add two edges.\n    # We need to pick three distinct vertices u, v, w.\n    # Add (u,v) and (v,w) such that (u,w) is an existing edge. This forms an odd cycle (u-v-w-u).\n    # The path u-w is an existing edge. Add (u,v) and (v,w).\n    # This means we pick two vertices u,w that are already connected.\n    # And pick a third vertex v that is not connected to u and not connected to w.\n    # Ways: iterate over all existing edges (u,w).\n    # For each such edge, iterate over all other vertices v (v != u, v != w).\n    # If (u,v) is not an edge and (w,v) is not an edge, then we can add (u,v) and (w,v).\n    # Count such triples (u,w,v).\n    # Number of ways = m * (n - 2) - (sum of degrees of all nodes - 2*m) - (sum of common neighbors for each edge)\n    # No, this is simpler:\n    # Iterate over all pairs of distinct vertices (u, v) such that (u,v) is NOT an edge.\n    # Add (u,v). This is 1 edge. This connects two components or two different color classes.\n    # This results in a graph that is no longer bipartite.\n    # For example, if we connect two nodes of different components, the graph remains bipartite.\n    # If we connect two nodes of same component but different colors, graph remains bipartite.\n    # If we connect two nodes of different components, say C1 and C2, with edge (u,v).\n    # u in C1, v in C2.\n    # The new component C1 U C2 is bipartite.\n    # To form an odd cycle, we need to connect two nodes of the same color.\n    # We need to add 2 edges.\n    # Let's consider the structure of components.\n    # If all components are single nodes or edges, then n_isolated_nodes = number of nodes with degree 0.\n    # n_edges = m.\n    # To form an odd cycle of length 3 (a triangle):\n    # Pick 3 distinct vertices u, v, w.\n    # If (u,v) is an edge, and (u,w), (v,w) are not edges, we add 2 edges. This is a triangle.\n    # Number of ways = sum over existing edges (u,v) of (number of vertices w such that (u,w) and (v,w) are not edges).\n    # For each edge (u,v):\n    #   Count `free_w` = 0\n    #   For w from 1 to n:\n    #     If w == u or w == v: continue\n    #     If (u,w) not in edges_set and (v,w) not in edges_set:\n    #       free_w += 1\n    #   ways_t2 += free_w\n    # This counts ordered (u,v,w) where (u,v) is an edge. But we need unordered {u,v,w}.\n    # Each triangle {u,v,w} where (u,v) is an existing edge is counted once.\n    # So this count is correct for ways to add 2 edges to form a triangle.\n\n    ways_t2 = 0\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            if u < v: # Consider each edge (u,v) once\n                for w in range(1, n + 1):\n                    if w == u or w == v:\n                        continue\n                    if tuple(sorted((u, w))) not in edges_set and \\\n                       tuple(sorted((v, w))) not in edges_set:\n                        ways_t2 += 1\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case 3: Add 3 edges\n    # If t=0, t=1, t=2 are not possible, then we must add 3 edges.\n    # This means the graph is a collection of isolated vertices and edges,\n    # and all existing edges are part of a triangle.\n    # This implies n <= 2, otherwise there would be a path 1-2-3-4.\n    # No, this is wrong.\n    # If t=2 is not possible, it means for every existing edge (u,v),\n    # for every other vertex w, either (u,w) or (v,w) (or both) is an existing edge.\n    # This means the graph is a collection of cliques.\n    # E.g., if we have a K_n graph, then t=0 (if n>=3) or t=1 (if n=2).\n    # If t=0,1,2 are not possible, then the graph must be a collection of isolated vertices.\n    # If there are no edges (m=0), then t=3.\n    # To form an odd cycle (a triangle) with 3 edges, we need to pick 3 distinct vertices u, v, w\n    # such that (u,v), (v,w), (w,u) are all NOT existing edges.\n    # This is possible if n >= 3.\n    # Number of ways to pick 3 vertices is n * (n - 1) * (n - 2) / 6.\n    # If m=0, then all these triples form a way.\n    # If m > 0, then we need to subtract triples that contain existing edges.\n    # But if t=2 ways_t2 == 0, it means that for any edge (u,v), and any w not u,v,\n    # either (u,w) or (v,w) is an edge.\n    # This means there are no \"empty\" triangles.\n    # If the graph has no edges (m=0), then ways_t2 = 0 (no existing edges).\n    # In this case, we need to add 3 edges.\n    # Ways to pick 3 vertices: n * (n - 1) * (n - 2) / 6.\n    # This is only if n >= 3. If n < 3, then it's impossible.\n    # The problem statement says \"consisting of more than one vertex\".\n    # A cycle of length 3 is the smallest odd cycle.\n    # If n < 3, it's impossible to form a cycle of length 3.\n    # The problem states \"simple cycle of an odd length, consisting of more than one vertex\".\n    # If n < 3, then it's impossible. But the constraints are n >= 1.\n    # If n=1 or n=2, it's impossible to form an odd cycle.\n    # The problem implies such a cycle can always be formed.\n    # If n=1, m=0: no cycle possible.\n    # If n=2, m=0: no cycle possible.\n    # If n=2, m=1 (1-2): no cycle possible.\n    # Example 3: 3 0 -> 3 1. This means if n=3, m=0, we add 3 edges (1,2), (2,3), (3,1) to form a triangle.\n    # This implies that if n < 3, we should output something like \"impossible\" or \"infinity\".\n    # But the problem guarantees that an answer exists.\n    # So n must be >= 3 if m=0 and t=3 is the answer.\n\n    # If we reach here, it means t=0, t=1, t=2 are not possible.\n    # This implies m=0.\n    # Why?\n    # If m > 0, there is at least one edge (u,v).\n    # If actual_ways_t1 == 0, it means for every component, every same-colored pair (x,y) is an edge.\n    # Since the graph is bipartite, there are no edges between same-colored nodes.\n    # So this means there are no same-colored pairs (x,y) that are not edges.\n    # This implies each color class in each component has size at most 1.\n    # This means each component has at most 2 nodes.\n    # So the graph is a collection of isolated vertices and edges.\n    # If ways_t2 == 0, it means for every existing edge (u,v), and every w not u,v,\n    # either (u,w) or (v,w) is an existing edge.\n    # Consider an edge (u,v). If there is any other vertex w (n >= 3).\n    # If (u,w) is not an edge AND (v,w) is not an edge, then ways_t2 > 0.\n    # So if ways_t2 == 0, it means for every edge (u,v), and every w != u,v,\n    # either (u,w) is an edge or (v,w) is an edge.\n    # This means every vertex w is connected to at least one endpoint of every edge (u,v).\n    # This implies the graph is a clique (K_n).\n    # If the graph is K_n, and n >= 3, then it contains an odd cycle, so t=0.\n    # If n=2, K_2 is just an edge, no odd cycle.\n    # If n=1, K_1 is just a vertex, no odd cycle.\n    # So if m > 0 and the graph is a collection of cliques, then t=0 (if n>=3), or t=1 (if n=2).\n    # We already handled t=0.\n    # If n=2, m=1, then it's (1,2). It's bipartite. color[1]=0, color[2]=1.\n    # actual_ways_t1 = 0. ways_t2 = 0.\n    # In this case, n=2, m=1. We need to add 3 edges. But we only have 2 vertices.\n    # So the only remaining case is m=0.\n    # If m=0, then actual_ways_t1 = 0 (no components, no same-colored pairs).\n    # If m=0, then ways_t2 = 0 (no existing edges).\n    # So if we reach here, it must be m=0.\n    # And if m=0, we need to add 3 edges to form a triangle.\n    # This requires n >= 3.\n    # The number of ways is the number of ways to choose 3 vertices: nC3.\n    \n    if n < 3: # Should not happen based on problem constraints or interpretation.\n        # But if it does, it implies no cycle possible.\n        # The problem statement guarantees an answer exists. So n >= 3.\n        pass\n\n    ways_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {ways_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_set = set()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_set.add(tuple(sorted((u, v))))\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1)\n    has_odd_cycle = False\n\n    def dfs_bipartite(u, c):\n        nonlocal has_odd_cycle\n        visited[u] = True\n        color[u] = c\n        for v in adj[u]:\n            if not visited[v]:\n                if not dfs_bipartite(v, 1 - c):\n                    return False\n            elif color[v] == color[u]:\n                has_odd_cycle = True\n                return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs_bipartite(i, 0)\n            if has_odd_cycle:\n                break\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # All components are bipartite. Need to add edges to form an odd cycle.\n\n    # Case 1: Add 1 edge\n    # An odd cycle can be formed by adding one edge if it connects two vertices\n    # within the same connected component that have the same color.\n    # Count such pairs.\n    \n    # Re-run BFS/DFS to get components and colors for each component\n    component_colors = []\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1)\n\n    def bfs_component(start_node):\n        q = [(start_node, 0)]\n        visited[start_node] = True\n        color[start_node] = 0\n        nodes_in_component = {start_node: 0}\n        head = 0\n        while head < len(q):\n            u, c = q[head]\n            head += 1\n            for v in adj[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    color[v] = 1 - c\n                    nodes_in_component[v] = 1 - c\n                    q.append((v, 1 - c))\n        return nodes_in_component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component_colors.append(bfs_component(i))\n\n    ways_t1 = 0\n    for comp_map in component_colors:\n        color0_count = 0\n        color1_count = 0\n        for node, c in comp_map.items():\n            if c == 0:\n                color0_count += 1\n            else:\n                color1_count += 1\n        \n        # Pairs within color 0\n        ways_t1 += color0_count * (color0_count - 1) // 2\n        # Pairs within color 1\n        ways_t1 += color1_count * (color1_count - 1) // 2\n        \n        # Subtract existing edges\n        for u in comp_map:\n            for v in adj[u]:\n                if comp_map[u] == comp_map[v]: # Same color\n                    if tuple(sorted((u, v))) in edges_set:\n                        ways_t1 -= 1\n    \n    # Each edge (u,v) is counted twice (once for u, once for v in adj[u])\n    # and then again if we iterate over comp_map.items().\n    # The current logic for ways_t1 counts pairs {u,v} such that u,v are in the same component\n    # and have the same color. We need to subtract existing edges from this count.\n    # The calculation `color0_count * (color0_count - 1) // 2` correctly counts pairs.\n    # We then iterate through edges_set to subtract existing edges.\n    # An edge (u,v) should be subtracted if u and v are in the same component and have the same color.\n    \n    actual_ways_t1 = 0\n    for comp_map in component_colors:\n        color0_nodes = [node for node, c in comp_map.items() if c == 0]\n        color1_nodes = [node for node, c in comp_map.items() if c == 1]\n        \n        for i in range(len(color0_nodes)):\n            for j in range(i + 1, len(color0_nodes)):\n                u, v = color0_nodes[i], color0_nodes[j]\n                if tuple(sorted((u, v))) not in edges_set:\n                    actual_ways_t1 += 1\n        for i in range(len(color1_nodes)):\n            for j in range(i + 1, len(color1_nodes)):\n                u, v = color1_nodes[i], color1_nodes[j]\n                if tuple(sorted((u, v))) not in edges_set:\n                    actual_ways_t1 += 1\n\n    if actual_ways_t1 > 0:\n        print(f\"1 {actual_ways_t1}\")\n        return\n\n    # Case 2: Add 2 edges\n    # If all components are bipartite and no single edge forms an odd cycle.\n    # This means all pairs of same-colored nodes within a component are already connected.\n    # This is only possible if each color class has at most 1 node, i.e., components are single nodes or pairs.\n    # But this is not true, e.g., a path 1-2-3-4.\n    # A single edge cannot form an odd cycle if there are no two same-colored nodes that are not connected.\n    # This happens if for every component, all pairs of same-colored nodes are already connected.\n    # This implies that each color class must have size at most 1, which means each component has size at most 2.\n    # If a component has 3 nodes (1-2-3), colors (0-1-0), nodes 1 and 3 are same color. If (1,3) is not an edge, then t=1.\n    # So if t=1 is not possible, it means for any component, if it has nodes u,v of same color, then (u,v) is an edge.\n    # This means each color class in each component has size at most 1.\n    # This implies that each component has at most 2 nodes.\n    # If a component has only one node, say {u}, then no same-colored pair.\n    # If a component has two nodes, say {u,v}, then u and v must have different colors. (0,1). No same-colored pair.\n    # So if actual_ways_t1 == 0, it implies that all connected components are either single nodes or pairs of nodes (u,v) where (u,v) is an edge.\n    # This means the graph is a collection of isolated vertices and edges.\n    # This is a very strong condition. Let's re-evaluate.\n    # actual_ways_t1 == 0 means that for every component, for every pair of nodes (u,v) of the same color, (u,v) is an existing edge.\n    # This means each color class in each component is a clique.\n    # So we have a collection of complete bipartite graphs, where each partition is a clique.\n    # This is possible if the graph is a collection of cliques.\n    # E.g., a triangle is bipartite (0,1,0), 1 and 3 are same color. If (1,3) is an edge, it's not bipartite.\n    # So if the graph is bipartite, then there are no edges between same-colored nodes.\n    # Therefore, if actual_ways_t1 == 0, it means there are no two same-colored nodes u, v such that (u,v) is not an edge.\n    # This implies that for any component, the number of nodes in any color class is at most 1.\n    # This means each component has at most 2 nodes.\n    # So the graph is a collection of isolated vertices and edges.\n    # In this case, each component is either a single vertex or an edge.\n    # Let N_comp be the number of connected components.\n    # Let N_nodes_in_comp be the number of nodes in a component.\n    # If N_nodes_in_comp == 1, it's an isolated vertex.\n    # If N_nodes_in_comp == 2, it's an edge.\n    # So the graph is a collection of isolated vertices and edges.\n\n    # To form an odd cycle with 2 edges:\n    # We need to connect three vertices u, v, w such that (u,v) is an edge, and we add (v,w) and (w,u).\n    # This forms a triangle (u,v,w). The path u-v is an existing edge. We add (v,w) and (w,u).\n    # This is not necessarily an odd cycle. A triangle is always an odd cycle.\n    # We need to pick three distinct vertices u, v, w such that (u,v) is an existing edge.\n    # And (v,w) is not an existing edge, (w,u) is not an existing edge.\n    # The number of such ways is:\n    # Iterate over all existing edges (u,v).\n    # For each (u,v), iterate over all other vertices w (w != u, w != v).\n    # If (u,w) and (v,w) are not existing edges, then we can add them.\n    # The count would be m * (n - 2 - (degree[u] - 1) - (degree[v] - 1) + common_neighbors_count).\n    # This is not right.\n    # We need to choose 3 distinct vertices u, v, w.\n    # We assume that (u,v) is an existing edge.\n    # We need to add (v,w) and (w,u).\n    # Count pairs (u,w) such that (u,w) is not an edge.\n    # Count pairs (v,w) such that (v,w) is not an edge.\n    # This is effectively counting non-edges.\n    # Total possible non-edges (u,v) is n*(n-1)/2 - m.\n    # We need to add two edges.\n    # We need to pick three distinct vertices u, v, w.\n    # Add (u,v) and (v,w) such that (u,w) is an existing edge. This forms an odd cycle (u-v-w-u).\n    # The path u-w is an existing edge. Add (u,v) and (v,w).\n    # This means we pick two vertices u,w that are already connected.\n    # And pick a third vertex v that is not connected to u and not connected to w.\n    # Ways: iterate over all existing edges (u,w).\n    # For each such edge, iterate over all other vertices v (v != u, v != w).\n    # If (u,v) is not an edge and (w,v) is not an edge, then we can add (u,v) and (w,v).\n    # Count such triples (u,w,v).\n    # Number of ways = m * (n - 2) - (sum of degrees of all nodes - 2*m) - (sum of common neighbors for each edge)\n    # No, this is simpler:\n    # Iterate over all pairs of distinct vertices (u, v) such that (u,v) is NOT an edge.\n    # Add (u,v). This is 1 edge. This connects two components or two different color classes.\n    # This results in a graph that is no longer bipartite.\n    # For example, if we connect two nodes of different components, the graph remains bipartite.\n    # If we connect two nodes of same component but different colors, graph remains bipartite.\n    # If we connect two nodes of different components, say C1 and C2, with edge (u,v).\n    # u in C1, v in C2.\n    # The new component C1 U C2 is bipartite.\n    # To form an odd cycle, we need to connect two nodes of the same color.\n    # We need to add 2 edges.\n    # Let's consider the structure of components.\n    # If all components are single nodes or edges, then n_isolated_nodes = number of nodes with degree 0.\n    # n_edges = m.\n    # To form an odd cycle of length 3 (a triangle):\n    # Pick 3 distinct vertices u, v, w.\n    # If (u,v) is an edge, and (u,w), (v,w) are not edges, we add 2 edges. This is a triangle.\n    # Number of ways = sum over existing edges (u,v) of (number of vertices w such that (u,w) and (v,w) are not edges).\n    # For each edge (u,v):\n    #   Count `free_w` = 0\n    #   For w from 1 to n:\n    #     If w == u or w == v: continue\n    #     If (u,w) not in edges_set and (v,w) not in edges_set:\n    #       free_w += 1\n    #   ways_t2 += free_w\n    # This counts ordered (u,v,w) where (u,v) is an edge. But we need unordered {u,v,w}.\n    # Each triangle {u,v,w} where (u,v) is an existing edge is counted once.\n    # So this count is correct for ways to add 2 edges to form a triangle.\n\n    ways_t2 = 0\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            if u < v: # Consider each edge (u,v) once\n                for w in range(1, n + 1):\n                    if w == u or w == v:\n                        continue\n                    if tuple(sorted((u, w))) not in edges_set and \\\n                       tuple(sorted((v, w))) not in edges_set:\n                        ways_t2 += 1\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case 3: Add 3 edges\n    # If t=0, t=1, t=2 are not possible, then we must add 3 edges.\n    # This means the graph is a collection of isolated vertices and edges,\n    # and all existing edges are part of a triangle.\n    # This implies n <= 2, otherwise there would be a path 1-2-3-4.\n    # No, this is wrong.\n    # If t=2 is not possible, it means for every existing edge (u,v),\n    # for every other vertex w, either (u,w) or (v,w) (or both) is an existing edge.\n    # This means the graph is a collection of cliques.\n    # E.g., if we have a K_n graph, then t=0 (if n>=3) or t=1 (if n=2).\n    # If t=0,1,2 are not possible, then the graph must be a collection of isolated vertices.\n    # If there are no edges (m=0), then t=3.\n    # To form an odd cycle (a triangle) with 3 edges, we need to pick 3 distinct vertices u, v, w\n    # such that (u,v), (v,w), (w,u) are all NOT existing edges.\n    # This is possible if n >= 3.\n    # Number of ways to pick 3 vertices is n * (n - 1) * (n - 2) / 6.\n    # If m=0, then all these triples form a way.\n    # If m > 0, then we need to subtract triples that contain existing edges.\n    # But if t=2 ways_t2 == 0, it means that for any edge (u,v), and any w not u,v,\n    # either (u,w) or (v,w) is an edge.\n    # This means there are no \"empty\" triangles.\n    # If the graph has no edges (m=0), then ways_t2 = 0 (no existing edges).\n    # In this case, we need to add 3 edges.\n    # Ways to pick 3 vertices: n * (n - 1) * (n - 2) / 6.\n    # This is only if n >= 3. If n < 3, then it's impossible.\n    # The problem statement says \"consisting of more than one vertex\".\n    # A cycle of length 3 is the smallest odd cycle.\n    # If n < 3, it's impossible to form a cycle of length 3.\n    # The problem states \"simple cycle of an odd length, consisting of more than one vertex\".\n    # If n < 3, then it's impossible. But the constraints are n >= 1.\n    # If n=1 or n=2, it's impossible to form an odd cycle.\n    # The problem implies such a cycle can always be formed.\n    # If n=1, m=0: no cycle possible.\n    # If n=2, m=0: no cycle possible.\n    # If n=2, m=1 (1-2): no cycle possible.\n    # Example 3: 3 0 -> 3 1. This means if n=3, m=0, we add 3 edges (1,2), (2,3), (3,1) to form a triangle.\n    # This implies that if n < 3, we should output something like \"impossible\" or \"infinity\".\n    # But the problem guarantees that an answer exists.\n    # So n must be >= 3 if m=0 and t=3 is the answer.\n\n    # If we reach here, it means t=0, t=1, t=2 are not possible.\n    # This implies m=0.\n    # Why?\n    # If m > 0, there is at least one edge (u,v).\n    # If actual_ways_t1 == 0, it means for every component, every same-colored pair (x,y) is an edge.\n    # Since the graph is bipartite, there are no edges between same-colored nodes.\n    # So this means there are no same-colored pairs (x,y) that are not edges.\n    # This implies each color class in each component has size at most 1.\n    # This means each component has at most 2 nodes.\n    # So the graph is a collection of isolated vertices and edges.\n    # If ways_t2 == 0, it means for every existing edge (u,v), and every w not u,v,\n    # either (u,w) or (v,w) is an existing edge.\n    # Consider an edge (u,v). If there is any other vertex w (n >= 3).\n    # If (u,w) is not an edge AND (v,w) is not an edge, then ways_t2 > 0.\n    # So if ways_t2 == 0, it means for every edge (u,v), and every w != u,v,\n    # either (u,w) is an edge or (v,w) is an edge.\n    # This means every vertex w is connected to at least one endpoint of every edge (u,v).\n    # This implies the graph is a clique (K_n).\n    # If the graph is K_n, and n >= 3, then it contains an odd cycle, so t=0.\n    # If n=2, K_2 is just an edge, no odd cycle.\n    # If n=1, K_1 is just a vertex, no odd cycle.\n    # So if m > 0 and the graph is a collection of cliques, then t=0 (if n>=3), or t=1 (if n=2).\n    # We already handled t=0.\n    # If n=2, m=1, then it's (1,2). It's bipartite. color[1]=0, color[2]=1.\n    # actual_ways_t1 = 0. ways_t2 = 0.\n    # In this case, n=2, m=1. We need to add 3 edges. But we only have 2 vertices.\n    # So the only remaining case is m=0.\n    # If m=0, then actual_ways_t1 = 0 (no components, no same-colored pairs).\n    # If m=0, then ways_t2 = 0 (no existing edges).\n    # So if we reach here, it must be m=0.\n    # And if m=0, we need to add 3 edges to form a triangle.\n    # This requires n >= 3.\n    # The number of ways is the number of ways to choose 3 vertices: nC3.\n    \n    if n < 3: # Should not happen based on problem constraints or interpretation.\n        # But if it does, it implies no cycle possible.\n        # The problem statement guarantees an answer exists. So n >= 3.\n        pass\n\n    ways_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {ways_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 5099,
        "thoughts_token_count": 0
    }
}