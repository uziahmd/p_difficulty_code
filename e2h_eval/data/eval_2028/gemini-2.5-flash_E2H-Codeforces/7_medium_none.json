{
    "start": 1758015872.7183905,
    "end": 1758015946.1121395,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Problem-Solving Snowflake Detective**\n\nAlright, let's dive into this competitive programming puzzle. My objective is to create a Python script that determines whether an input integer, 'n,' represents the possible number of vertices in a snowflake.  Here's my thought process:\n\nFirstly, I have to figure out how a snowflake graph is structured. It starts with one center vertex, then connects it to 'k' new vertices.  So, at step one, we have a total of 1 + k vertices.  Subsequent steps involve connecting the leaf nodes (those connected to only one other vertex) to 'k' more vertices each. Let 'd' represent the number of times this happens, and it has to happen at least once.\n\n*   **When d = 1:** We've got 1 + k + k² vertices in total.\n*   **When d = 2:** We have 1 + k + k² + k³ vertices.\n\nAnd the pattern is, generally, that for `d` number of times we get `n = 1 + k + k² + ... + k^(d+1)`. which can be written `n = (k^(d+2) - 1) / (k-1)`. I am going to call `m = d + 1`.\n\nSo now, I need to check if, for a given 'n', there exist integers 'k' (greater than 1) and 'm' (greater than or equal to 2) such that  `n = (k^(m+1) - 1) / (k - 1)`.\n\nLet's start by looking at a special case: when `m = 2`.  This leads to the quadratic equation  `k² + k + (1 - n) = 0`.  I will use the quadratic formula to solve for `k`. For the solution to work,  `4n - 3` must be a perfect square, let's call it `S²`, the `S > 3` and is an odd number and k should also be greater than 1. This is a crucial first check that should be handled efficiently.\n\nFor the general case, where `m > 2`, I know that `n = 1 + k + ... + k^m` and I can use binary search with a calculated upper bound for `k` to find a matching 'k'. Iterating `m` from 3 up to around 60 is going to be my approach. To make sure that calculations do not overflow, I have to be careful when computing the sum. If at any point the intermediate multiplication (`k * current_k_power`) exceeds 'n', I should break and use that to change my search range in the binary search.\n",
    "response": "The problem asks us to determine if a given integer `n` ($1 \\le n \\le 10^{18}$) can be the number of vertices in a snowflake graph. A snowflake is constructed as follows:\n1.  Start with 1 vertex (the center).\n2.  Connect the center to `k` new vertices, where `k > 1`.\n3.  Repeat at least once: Each vertex connected to only one other vertex (a leaf) is connected to `k` more new vertices.\n\nLet's analyze the number of vertices:\n*   Initial state: 1 vertex.\n*   After step 2 (first layer): The center is connected to `k` new vertices. Total vertices: `1 + k`. The `k` new vertices are leaves.\n*   After step 3 (first time, `d=1`): Each of the `k` leaves from the first layer is connected to `k` new vertices. So, `k * k = k^2` new vertices are added. Total vertices: `1 + k + k^2`. These `k^2` vertices are now leaves.\n*   After step 3 (second time, `d=2`): Each of the `k^2` leaves from the second layer is connected to `k` new vertices. So, `k^2 * k = k^3` new vertices are added. Total vertices: `1 + k + k^2 + k^3`.\n\nIn general, if step 3 is performed `d` times (`d \\ge 1`), the total number of vertices `n` will be:\n`n = 1 + k + k^2 + ... + k^(d+1)`\n\nLet `m = d+1`. Since `d \\ge 1`, `m \\ge 2`.\nSo, `n` must be of the form `1 + k + k^2 + ... + k^m` for some integers `k > 1` and `m \\ge 2`.\nThis is a geometric series sum, which can be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if such `k` and `m` exist for a given `n`.\n\n**Case 1: `m = 2`**\nThis is the smallest possible snowflake (`d=1`).\n`n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 \\pm \\sqrt{1 - 4(1 - n)}) / 2 = (-1 \\pm \\sqrt{4n - 3}) / 2`.\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `4n - 3 = S^2` for some integer `S`.\n2.  Since `k > 1`, we must use the `+` sign: `k = (-1 + S) / 2`.\n3.  `S` must be odd for `(-1 + S)` to be even, so `k` is an integer.\n4.  `k > 1` implies `(-1 + S) / 2 > 1`, which means `-1 + S > 2`, so `S > 3`.\n\nSo, for `m=2`, we check if `4n - 3` is a perfect square `S^2` such that `S > 3` and `S` is odd.\nTo check if `X` is a perfect square: calculate `s = int(X**0.5)` and verify `s*s == X`.\nThis check is efficient, as `4n - 3` can be up to `4 * 10^{18} - 3`, and its square root is at most `2 * 10^9`.\n\n**Case 2: `m > 2`**\nThe equation is `n = 1 + k + k^2 + ... + k^m`.\nSince `n \\le 10^{18}` and `k \\ge 2`:\n*   If `k=2`, `n = 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\n    `2^(m+1) - 1 \\le 10^{18} \\implies 2^(m+1) \\le 10^{18} + 1`.\n    `m+1 \\le \\log_2(10^{18} + 1) \\approx 59.79`. So `m+1 \\le 59`, meaning `m \\le 58`.\n*   If `k` is larger, `m` must be smaller. For example, if `m=3`, `n = 1 + k + k^2 + k^3`. Then `k^3 < n \\implies k < n^(1/3) \\approx (10^{18})^(1/3) = 10^6`.\n    If `m=4`, `k < n^(1/4) \\approx (10^{18})^(1/4) = 10^{4.5} \\approx 31622`.\n\nThe maximum value of `m` is relatively small (around 58-59). We can iterate through possible values of `m` from `3` up to `60` (a safe upper bound).\nFor each `m`, we need to find if there exists an integer `k > 1` that satisfies `n = 1 + k + ... + k^m`.\nThe function `f(k) = 1 + k + ... + k^m` is strictly increasing for `k > 1`. We can use binary search to find `k`.\nThe search range for `k` would be `[2, \\text{upper_bound}]`. A safe upper bound for `k` is `10^6 + 5` (since `k` for `m=3` is at most `10^6`).\n\n**Binary Search for `k` for a fixed `m`:**\n`low = 2`, `high = 10^6 + 5` (or `n^(1/m)` for a tighter bound, but `10^6+5` is fine for `m \\ge 3`).\nIn each step of binary search, calculate `current_sum = 1 + mid_k + ... + mid_k^m`.\nWe must be careful about overflow when calculating powers and sums, as `mid_k^p` can exceed `10^{18}`.\nWhen computing `current_k_power *= mid_k` or `current_sum += current_k_power`:\n*   If `current_k_power > n / mid_k`, then `current_k_power * mid_k` would exceed `n`.\n*   If `current_sum > n - current_k_power`, then `current_sum + current_k_power` would exceed `n`.\nIf an overflow check indicates the sum will exceed `n`, we can immediately conclude `mid_k` is too large.\n\n**Algorithm:**\n1.  Initialize `found = False`.\n2.  **Check `m=2`:**\n    *   Calculate `val = 4 * n - 3`.\n    *   If `val < 0`, continue (should not happen for `n \\ge 1`).\n    *   Calculate `S = int(val**0.5)`.\n    *   If `S * S == val` (perfect square) AND `S > 3` AND `S % 2 == 1` (S is odd):\n        *   Then `k = (-1 + S) / 2` is an integer `> 1`. Set `found = True` and break.\n3.  **Check `m \\ge 3`:**\n    *   Iterate `m` from `3` to `60` (or `59`).\n    *   For each `m`:\n        *   Perform binary search for `k` in range `[2, 10^6 + 5]`.\n        *   `low = 2`, `high = 10^6 + 5`.\n        *   `while low <= high`:\n            *   `mid_k = (low + high) // 2`.\n            *   If `mid_k < 2`, set `low = 2` and continue (ensures `k > 1`).\n            *   Calculate `current_sum = 1`, `current_k_power = 1`. `overflow = False`.\n            *   `for _ in range(m)`:\n                *   If `current_k_power > n // mid_k` (check for `mid_k^p * mid_k` overflow): `overflow = True`; break.\n                *   `current_k_power *= mid_k`.\n                *   If `current_sum > n - current_k_power` (check for `sum + mid_k^p` overflow): `overflow = True`; break.\n                *   `current_sum += current_k_power`.\n            *   If `overflow` or `current_sum > n`: `high = mid_k - 1`.\n            *   Else if `current_sum < n`: `low = mid_k + 1`.\n            *   Else (`current_sum == n`): `found = True`; break inner loop (found `k` for this `m`).\n        *   If `found`, break outer loop (found `k, m` pair).\n4.  Print \"YES\" if `found`, \"NO\" otherwise.\n\n**Example dry run for `n = 10^18`:**\n1.  **`m=2` check:**\n    `val = 4 * 10^{18} - 3`.\n    `S = int((4 * 10^{18} - 3)**0.5)`. `S` will be `1999999999`.\n    `S*S = (2*10^9 - 1)^2 = 4*10^{18} - 4*10^9 + 1`. This is not `4*10^{18} - 3`.\n    So `4 * 10^{18} - 3` is not a perfect square. `m=2` fails.\n2.  **`m \\ge 3` check:**\n    Iterate `m` from `3` to `60`.\n    For `m=3`, binary search `k`. `k` would be around `10^6`.\n    If `k=10^6`, `1 + 10^6 + 10^{12} + 10^{18}` is too large.\n    If `k=999999`, `k^3` is slightly less than `10^{18}`. The sum `1+k+k^2+k^3` will be less than `10^{18}`.\n    For `n=10^{18}`, it turns out no such `k` exists for any `m`. The output is \"NO\".\n\nThe maximum number of iterations for `m` is about `60`. The binary search runs `log(10^6)` times, which is about `20`. Inside the binary search, we do `m` multiplications/additions. So total operations roughly `60 * 20 * 60 = 72000`, which is very fast.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Smallest snowflake is 1 + 2 + 2^2 = 7 (k=2, m=2)\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s = int(val**0.5)\n    if s * s == val:\n        # s must be odd for (-1 + s) to be even\n        # s must be > 3 for k > 1\n        if s % 2 == 1 and s > 3:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case 2: m >= 3 (d >= 2)\n    # n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to a reasonable limit.\n    # Max m for k=2 is when 2^(m+1) - 1 approx 10^18 => m+1 approx 60 => m approx 59.\n    # We can iterate m up to 60.\n    \n    # Max k for m=3 is when k^3 approx 10^18 => k approx 10^6.\n    # The upper bound for binary search can be 10^6 + 5.\n    \n    for m in range(3, 61): # m goes from d+1, d >= 2, so m >= 3\n        low = 2\n        high = int(n**(1/m)) + 2 # Tighter upper bound for k: k^m < n => k < n^(1/m)\n        # Add a small buffer to high for floating point inaccuracies\n        if high < 2: # Ensure low and high are at least 2\n            high = 2\n\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            current_k_power = 1\n            overflow = False\n\n            for _ in range(m):\n                # Check for overflow before multiplication\n                # current_k_power * mid_k could exceed N\n                if current_k_power > n // mid_k: \n                    overflow = True\n                    break\n                current_k_power *= mid_k\n                \n                # Check for overflow before addition\n                # current_sum + current_k_power could exceed N\n                if current_sum > n - current_k_power:\n                    overflow = True\n                    break\n                current_sum += current_k_power\n            \n            if overflow or current_sum > n:\n                high = mid_k - 1\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum == n\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Smallest snowflake is 1 + 2 + 2^2 = 7 (k=2, m=2)\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s = int(val**0.5)\n    if s * s == val:\n        # s must be odd for (-1 + s) to be even\n        # s must be > 3 for k > 1\n        if s % 2 == 1 and s > 3:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case 2: m >= 3 (d >= 2)\n    # n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to a reasonable limit.\n    # Max m for k=2 is when 2^(m+1) - 1 approx 10^18 => m+1 approx 60 => m approx 59.\n    # We can iterate m up to 60.\n    \n    # Max k for m=3 is when k^3 approx 10^18 => k approx 10^6.\n    # The upper bound for binary search can be 10^6 + 5.\n    \n    for m in range(3, 61): # m goes from d+1, d >= 2, so m >= 3\n        low = 2\n        high = int(n**(1/m)) + 2 # Tighter upper bound for k: k^m < n => k < n^(1/m)\n        # Add a small buffer to high for floating point inaccuracies\n        if high < 2: # Ensure low and high are at least 2\n            high = 2\n\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            current_k_power = 1\n            overflow = False\n\n            for _ in range(m):\n                # Check for overflow before multiplication\n                # current_k_power * mid_k could exceed N\n                if current_k_power > n // mid_k: \n                    overflow = True\n                    break\n                current_k_power *= mid_k\n                \n                # Check for overflow before addition\n                # current_sum + current_k_power could exceed N\n                if current_sum > n - current_k_power:\n                    overflow = True\n                    break\n                current_sum += current_k_power\n            \n            if overflow or current_sum > n:\n                high = mid_k - 1\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum == n\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 3478,
        "thoughts_token_count": 4714
    }
}