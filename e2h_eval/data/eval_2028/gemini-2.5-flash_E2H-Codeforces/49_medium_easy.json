{
    "start": 1758294858.5236862,
    "end": 1758294949.370334,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Initial Problem Decomposition and Understanding**\n\nAlright, so the task is to craft a Python script to tackle the \"Mushroom Strife\" problem. I've got to ensure the script's efficient enough, given the scale of inputs—up to 10^5 lawns and roads. Each road provides GCD and LCM info for the mushroom counts on the connected lawns. I need to find mushroom counts for each lawn, satisfying the GCD and LCM constraints. If multiple valid scenarios exist, any one's fine, but if no solution is possible, I need to flag it. The mushroom count limitations are also in mind, ranging from 1 to 10^6.\n\n**Leveraging GCD and LCM Properties and Graph Representation**\n\nThinking about the core properties of GCD and LCM, I recognize a key rule: the GCD always divides the LCM. Without that, there's no way to find a workable solution. Also, the product of GCD and LCM equals the product of the two numbers. This gives me some important equations to work with.\n\nThe problem seems like a graph problem. Each lawn is a node and roads are edges. For each edge (u, v), I have constraints involving the number of mushrooms (let's call it x_i) on the lawns. I need to find the number of mushrooms such that GCD(x_u, x_v) and LCM(x_u, x_v) are satisfied.\n\n**Prime Factorization Strategy**\n\nWorking with GCD/LCM usually means diving into prime factorizations. I think I'll create a list of all primes used, then assign exponents to each lawn and prime. This way, the GCD and LCM computations become much easier. This is a good way of breaking down the problem into smaller, simpler, independent tasks.\n\n**Constraint Satisfaction and Solving via Prime Exponents**\n\nNow, for each prime, let's look at the relationship between the exponent of that prime for the GCD, LCM, and lawn. The GCD's exponent will always be the minimum between the lawn values, and the LCM's will be the maximum. This is the crucial insight! For a prime, each edge will create a constraint: the exponents for its connected nodes must match the GCD and LCM requirements. This means for a specific edge, the exponents for nodes u and v must either be (g_p, l_p) or (l_p, g_p).\n\nThis transforms into a 2-SAT-like problem for each connected component. I can handle exponents independently for each prime, which simplifies things. For a single prime, for each edge (u, v) I know that {x_up, x_vp} = {g_p, l_p} . This is where I start thinking of using min and max values to bound the exponent.\n\n**Developing the Algorithm**\n\nI think I need to do some graph traversal to assign each exponent. For each node (lawn), I can maintain a `min_val` and `max_val` to create a range. I'll initialize with all possible values.\n\nThen, I'll update these bounds for each edge: `l % g != 0` means no solution. The new ranges become the intersection of existing range with `{g_p, l_p}` for the given prime. If at any time, `min_val > max_val`, I have an invalid scenario.\n\nI'll then check for consistency and start propagation via DFS/BFS. I select an unassigned node, assign one of the exponents, and check the values assigned to neighbors based on their edges.\n\nIf a contradiction is encountered (based on GCD and LCM), I will go back and take the other assignment, and re-propagate. This is a kind of brute force, where I need to explore different branches.\n\nAfter the assignments, I check for consistency and use the assigned values to construct the result. If a complete solution isn't found, then I return \"NO.\"\n\nEssentially, I'm building a constraint satisfaction solver, using the constraints derived from GCD and LCM. I use a clever trick to apply a 2-coloring-like algorithm to get the answer in time.\n",
    "response": "The problem asks us to restore the number of mushrooms on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are provided with `g = GCD(x_u, x_v)` and `l = LCM(x_u, x_v)`, where `x_i` is the number of mushrooms on lawn `i`. We need to output \"YES\" and any valid assignment `x_1, ..., x_n` if one exists, or \"NO\" otherwise. Mushroom counts are between 1 and 10^6.\n\n**Key Mathematical Property:**\nFor any two positive integers `a` and `b`, `GCD(a, b) * LCM(a, b) = a * b`.\nAlso, `g` must divide `l`. If `l % g != 0` for any edge, no solution exists.\n\n**Prime Factorization Approach:**\nLet `x_i = product(p_k^{e_{ik}})` be the prime factorization of `x_i`, where `p_k` are prime numbers and `e_{ik}` are their exponents.\nThen, for an edge `(u, v)` with `g = GCD(x_u, x_v)` and `l = LCM(x_u, x_v)`:\nFor each prime `p`:\n`v_p(g) = min(v_p(x_u), v_p(x_v))`\n`v_p(l) = max(v_p(x_u), v_p(x_v))`\nwhere `v_p(N)` is the exponent of prime `p` in the prime factorization of `N`.\n\nThis means that for each prime `p`, the pair of exponents `(v_p(x_u), v_p(x_v))` must be either `(v_p(g), v_p(l))` or `(v_p(l), v_p(g))`. This is a crucial observation: the problem can be solved independently for each prime factor.\n\n**Algorithm Steps:**\n\n1.  **Precompute Primes and Factorization:**\n    Since `LCM` can be up to 10^6, we need primes up to 10^6. A sieve (e.g., Sieve of Eratosthenes) can find all primes up to `sqrt(10^6) = 1000`. For numbers up to 10^6, we can precompute their prime factorizations or efficiently find them on the fly. We'll precompute all primes up to 10^6.\n\n2.  **Initial Checks and Data Structures:**\n    *   Store edges: `adj[u]` will contain a list of `(v, g, l)` for neighbors of `u`.\n    *   Initialize `final_x[i] = 1` for all `i`. This will accumulate the product of `p^{e_{ip}}` for each `x_i`.\n    *   For each prime `p`, we need to determine the exponent `e_{ip}` for each `x_i`.\n    *   For each `p`, `exp_val[i][p]` will store the determined exponent `e_{ip}`. Initialize to -1 (unassigned).\n    *   For each `p`, `adj_p[u]` will store `(v, g_p, l_p)` where `g_p = v_p(g)` and `l_p = v_p(l)`.\n\n3.  **Process Edges and Propagate Constraints (First Pass):**\n    For each edge `(u, v, g, l)`:\n    *   If `l % g != 0`, output \"NO\" and exit.\n    *   Find all distinct prime factors `p` of `g` and `l`. Let `P_edge` be this set of primes.\n    *   For each `p` in `P_edge`:\n        *   Calculate `g_p = v_p(g)` and `l_p = v_p(l)`.\n        *   Add `(v, g_p, l_p)` to `adj_p[u]` and `(u, g_p, l_p)` to `adj_p[v]`.\n        *   Initialize `min_exp[i][p] = 0` and `max_exp[i][p] = infinity` (or a large enough number like 20, since `2^20 > 10^6`).\n        *   `min_exp[u][p] = max(min_exp[u][p], g_p)`\n        *   `max_exp[u][p] = min(max_exp[u][p], l_p)`\n        *   `min_exp[v][p] = max(min_exp[v][p], g_p)`\n        *   `max_exp[v][p] = min(max_exp[v][p], l_p)`\n        *   If `min_exp[i][p] > max_exp[i][p]` for any `i, p`, output \"NO\" and exit.\n\n4.  **Solve for Each Prime Independently (BFS/DFS based on 2-coloring principle):**\n    For each prime `p` that appeared in any `g` or `l`:\n    *   For each node `i` from 1 to `n`:\n        *   If `exp_val[i][p]` is unassigned (`-1`):\n            *   Start a BFS/DFS from `i`.\n            *   We try two possibilities:\n                *   **Attempt 1:** Assign `exp_val[i][p] = min_exp[i][p]`.\n                *   Perform BFS/DFS to propagate this choice. During propagation from `u` to `v` for edge `(u, v)` with `g_p, l_p`:\n                    *   If `exp_val[u][p]` is `g_p`, `exp_val[v][p]` *must* be `l_p`.\n                    *   If `exp_val[u][p]` is `l_p`, `exp_val[v][p]` *must* be `g_p`.\n                    *   If `exp_val[u][p]` is neither `g_p` nor `l_p`, it's a contradiction.\n                    *   Check if the determined `exp_val[v][p]` is within `[min_exp[v][p], max_exp[v][p]]`. If not, contradiction.\n                    *   If `exp_val[v][p]` is already assigned and contradicts the current propagation, contradiction.\n                    *   If `exp_val[v][p]` is unassigned, assign it and add `v` to queue.\n                *   If this attempt leads to a contradiction (e.g., trying to assign `exp_val[v][p]` to two different values, or outside its `[min_exp, max_exp]` range), then:\n                    *   **Attempt 2:** Backtrack all assignments made in Attempt 1. Assign `exp_val[i][p] = max_exp[i][p]`. (This is the only other valid choice based on the `min/max` bounds).\n                    *   Perform BFS/DFS again. If this also leads to a contradiction, output \"NO\" and exit.\n                *   If either attempt succeeds, the component is successfully assigned.\n\n    *   After the loop for `i` (all components for prime `p` are processed), verify consistency:\n        For each edge `(u, v)` with `g_p, l_p`:\n            `min(exp_val[u][p], exp_val[v][p])` must be `g_p`.\n            `max(exp_val[u][p], exp_val[v][p])` must be `l_p`.\n            If not, output \"NO\" and exit.\n        Also, `exp_val[i][p]` must be within `[min_exp[i][p], max_exp[i][p]]`.\n\n5.  **Construct Final `x_i` Values:**\n    For each `i` from 1 to `n`:\n    *   For each prime `p`:\n        *   If `exp_val[i][p]` is not -1 (meaning `p` is a factor of `x_i`):\n            `final_x[i] = final_x[i] * (p ** exp_val[i][p])`\n    *   If `final_x[i]` exceeds 10^6, output \"NO\" and exit. (This check is crucial as `x_i` must be <= 10^6).\n\n6.  **Output:**\n    If all checks pass, output \"YES\" and then `final_x[1] ... final_x[n]`.\n\n**Optimization and Details:**\n\n*   **Prime Factorization:** Precomputing smallest prime factor (SPF) for all numbers up to 10^6 allows O(log N) factorization.\n*   **Managing Primes:** Instead of iterating through all primes for each node, we only need to consider primes that are factors of `g` or `l` for connected edges. A `set` can store all relevant primes.\n*   **BFS/DFS for Exponents:** The BFS/DFS needs to keep track of assigned exponents for the current prime `p`. A temporary `current_exp_val` array can be used for each attempt.\n*   **Max Exponent:** For numbers up to 10^6, the maximum exponent for any prime is `log2(10^6) approx 19.9`. So, 20 is a safe upper bound for exponents.\n*   **Graph Representation:** Adjacency list `adj[u]` stores `(v, g_original, l_original)`. `adj_p[u]` stores `(v, g_p, l_p)`.\n\n**Example Walkthrough:**\nConsider edge `(1, 2, g=1, l=3)`.\n`p=3`: `v_3(1)=0`, `v_3(3)=1`. So `g_3=0, l_3=1`.\n`min_exp[1][3]=0`, `max_exp[1][3]=1`.\n`min_exp[2][3]=0`, `max_exp[2][3]=1`.\n`exp_val[1][3]` is unassigned. Try `exp_val[1][3]=0`.\nBFS: `(1,3)` in queue. `exp_val[1][3]=0`.\nPop `(1,3)`. Neighbor `(2,3)` needs `exp_val[2][3]=1`.\n`exp_val[2][3]=1` is within `[0,1]`. Assign. Add `(2,3)` to queue.\nPop `(2,3)`. No unassigned neighbors. BFS ends.\nSolution for `p=3`: `exp_val[1][3]=0`, `exp_val[2][3]=1`.\nThis leads to `x_1` not having factor 3, `x_2` having factor `3^1`.\nFinal `x_1=1`, `x_2=3`. `GCD(1,3)=1`, `LCM(1,3)=3`. Valid.\n\n**Complexity:**\n*   **Sieve:** `O(MAX_VAL * log log MAX_VAL)`\n*   **Processing Edges (Prime Factors):** For each edge, factorizing `g` and `l` takes `O(log(MAX_VAL))` using SPF. There can be `O(log MAX_VAL)` distinct prime factors for a number. Total `O(M * log MAX_VAL * log MAX_VAL)`.\n*   **Solving for each prime:**\n    *   Number of relevant primes `P_count` is `O(MAX_VAL / log MAX_VAL)`.\n    *   For each prime `p`, we do a graph traversal on `N` nodes and `M` edges. Each node/edge visited at most twice (for two attempts). So `O(N+M)` per prime.\n    *   Total `O(P_count * (N+M))` could be too slow if `P_count` is large.\n    *   Better: Each edge `(u, v)` with `g, l` generates constraints for `O(log MAX_VAL)` primes. Each `(u, p)` pair is visited at most twice (for the two attempts). So the total complexity for all BFS/DFS traversals over all primes is `O(Sum(degrees_p) + Sum(nodes_p))` where `degrees_p` is the sum of degrees for prime `p`. This sum is bounded by `O(M * log MAX_VAL)`. So `O(M * log MAX_VAL + N * log MAX_VAL)`.\n\nTotal complexity: `O(MAX_VAL * log log MAX_VAL + M * log MAX_VAL + N * log MAX_VAL)`.\nGiven `N, M <= 10^5`, `MAX_VAL <= 10^6`, `log MAX_VAL approx 20`.\n`10^6 * log log 10^6` is feasible.\n`10^5 * 20` is feasible.\n\n```python\nimport sys\nfrom collections import deque\n\n# Max value for GCD/LCM\nMAX_VAL = 10**6\n\n# Sieve of Eratosthenes to find smallest prime factor (SPF) for numbers up to MAX_VAL\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(n):\n    factors = {}\n    while n > 1:\n        p = spf[n]\n        factors[p] = factors.get(p, 0) + 1\n        n //= p\n    return factors\n\n# Function to get exponent of a prime p in n\ndef get_exponent(n, p):\n    count = 0\n    if p == 0: return 0 # Handle p=0 case for safety, though primes are >= 2\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Adjacency list for the graph (stores original g, l)\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store all unique primes involved in g or l\n    relevant_primes = set()\n\n    # Store edges and initial constraints\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        # Collect all prime factors from g and l\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        relevant_primes.update(factors_g.keys())\n        relevant_primes.update(factors_l.keys())\n\n    # Sort primes for consistent iteration (optional, but good practice)\n    sorted_relevant_primes = sorted(list(relevant_primes))\n\n    # min_exp[i][p] and max_exp[i][p] store the tightest bounds for exponent of p in x_i\n    # Initialize to default values (0 and a large number)\n    # Using dictionaries for sparse storage, as not all (node, prime) pairs are relevant\n    min_exp = [{} for _ in range(n + 1)]\n    max_exp = [{} for _ in range(n + 1)]\n\n    # exp_val[i][p] will store the final assigned exponent of p in x_i\n    exp_val = [{} for _ in range(n + 1)]\n\n    # First pass: Initialize min_exp and max_exp bounds for each node and prime\n    for u, v, g, l in edges_data:\n        for p in sorted_relevant_primes:\n            g_p = get_exponent(g, p)\n            l_p = get_exponent(l, p)\n\n            # Ensure p is relevant for this edge\n            if g_p == 0 and l_p == 0:\n                continue\n\n            min_exp[u][p] = max(min_exp[u].get(p, 0), g_p)\n            max_exp[u][p] = min(max_exp[u].get(p, float('inf')), l_p)\n            min_exp[v][p] = max(min_exp[v].get(p, 0), g_p)\n            max_exp[v][p] = min(max_exp[v].get(p, 0), l_p) # bug fix: should be float('inf')\n\n            # Corrected line for max_exp[v][p]\n            max_exp[v][p] = min(max_exp[v].get(p, float('inf')), l_p)\n\n\n            if min_exp[u][p] > max_exp[u][p] or min_exp[v][p] > max_exp[v][p]:\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    # Second pass: Solve for exponents for each prime independently using BFS/DFS\n    for p in sorted_relevant_primes:\n        for i in range(1, n + 1):\n            if p not in exp_val[i]: # If this (node, prime) pair hasn't been assigned yet\n                \n                # If no bounds are set for this (node, prime) pair, it means this prime\n                # is not a factor of any g or l in edges connected to i.\n                # In this case, x_i's exponent for p can be 0.\n                if p not in min_exp[i]:\n                    exp_val[i][p] = 0\n                    continue\n\n                # If bounds are equal, the exponent is fixed\n                if min_exp[i][p] == max_exp[i][p]:\n                    exp_val[i][p] = min_exp[i][p]\n                    continue\n                \n                # Otherwise, we have two choices for this node's exponent for prime p: min_exp[i][p] or max_exp[i][p]\n                # Try the first choice (min_exp[i][p])\n                temp_exp_val = [dict(ev) for ev in exp_val] # Deep copy for backtracking\n                q = deque()\n                \n                # Start BFS/DFS for this component with an initial choice\n                start_node_exp = min_exp[i][p]\n                \n                # Perform two attempts for the starting node's exponent\n                for attempt in range(2):\n                    current_exp = start_node_exp if attempt == 0 else max_exp[i][p]\n                    \n                    # Reset current component's assignments for this prime\n                    for node_in_comp in range(1, n + 1):\n                        if p in temp_exp_val[node_in_comp] and temp_exp_val[node_in_comp][p] == -2: # -2 indicates assigned in previous attempt\n                            del temp_exp_val[node_in_comp][p]\n                        if p in temp_exp_val[node_in_comp] and temp_exp_val[node_in_comp][p] != -1: # -1 indicates unassigned\n                            # If it was already fixed from previous component, keep it\n                            if temp_exp_val[node_in_comp][p] != min_exp[node_in_comp].get(p, -1) or temp_exp_val[node_in_comp][p] != max_exp[node_in_comp].get(p, -1):\n                                pass # Keep value if it's a fixed value\n                            else:\n                                del temp_exp_val[node_in_comp][p]\n                        \n\n                    # If the starting node already has a fixed exp_val[i][p] from a previous component, use that\n                    if p in exp_val[i]:\n                        current_exp = exp_val[i][p]\n                    elif p in temp_exp_val[i] and temp_exp_val[i][p] != -1: # check if it was fixed earlier in this prime's pass\n                        current_exp = temp_exp_val[i][p]\n                    \n                    # If this attempt's choice is outside bounds, it's invalid\n                    if not (min_exp[i].get(p, 0) <= current_exp <= max_exp[i].get(p, float('inf'))):\n                        if attempt == 0: continue # Try second choice\n                        else: # Both choices invalid\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                    q.clear()\n                    q.append(i)\n                    temp_exp_val[i][p] = current_exp\n                    \n                    possible = True\n                    visited_in_attempt = set()\n                    visited_in_attempt.add(i)\n\n                    while q:\n                        u_node = q.popleft()\n                        \n                        # Check for neighbors\n                        for v_node, orig_g, orig_l in adj[u_node]:\n                            g_p = get_exponent(orig_g, p)\n                            l_p = get_exponent(orig_l, p)\n\n                            # If this edge doesn't involve prime p, skip\n                            if g_p == 0 and l_p == 0:\n                                continue\n\n                            # Determine required exponent for v_node\n                            required_v_exp = -1\n                            if temp_exp_val[u_node][p] == g_p:\n                                required_v_exp = l_p\n                            elif temp_exp_val[u_node][p] == l_p:\n                                required_v_exp = g_p\n                            else: # current_exp for u_node is not g_p or l_p, contradiction for this edge\n                                possible = False\n                                break\n                            \n                            if not (min_exp[v_node].get(p, 0) <= required_v_exp <= max_exp[v_node].get(p, float('inf'))):\n                                possible = False\n                                break\n\n                            if p not in temp_exp_val[v_node]:\n                                temp_exp_val[v_node][p] = required_v_exp\n                                q.append(v_node)\n                                visited_in_attempt.add(v_node)\n                            elif temp_exp_val[v_node][p] != required_v_exp:\n                                possible = False # Contradiction\n                                break\n                        if not possible:\n                            break\n                    \n                    if possible: # Found a valid assignment for this component\n                        for node_in_comp in visited_in_attempt:\n                            exp_val[node_in_comp][p] = temp_exp_val[node_in_comp][p]\n                        break # Exit attempt loop\n                    elif attempt == 1: # Both attempts failed\n                        sys.stdout.write(\"NO\\n\")\n                        return\n                    else: # Attempt 0 failed, reset values and try attempt 1\n                        for node_in_comp in visited_in_attempt:\n                            if p in temp_exp_val[node_in_comp] and temp_exp_val[node_in_comp][p] != -1:\n                                temp_exp_val[node_in_comp][p] = -1 # Mark as unassigned for next attempt\n    \n    # Final check and calculate x_i values\n    final_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in sorted_relevant_primes:\n            if p in exp_val[i] and exp_val[i][p] != -1:\n                final_x[i] *= (p ** exp_val[i][p])\n                if final_x[i] > MAX_VAL:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            elif p not in exp_val[i]: # If prime p was never relevant for node i, its exponent is 0\n                pass # final_x[i] is already initialized to 1, so p^0 doesn't change it.\n\n        # If a node has no edges connected to it, its value can be 1.\n        # This is implicitly handled if final_x[i] remains 1.\n        # But if it has no relevant primes, exp_val[i] might be empty.\n        # Ensure it's at least 1.\n        if final_x[i] == 0: # Should not happen if initialized to 1\n            final_x[i] = 1\n\n\n    # Verify all original GCD/LCM constraints\n    for u, v, g, l in edges_data:\n        actual_gcd = 1\n        actual_lcm = 1\n        \n        # Get all primes involved in final_x[u], final_x[v], g, l\n        all_factors_u = get_prime_factorization(final_x[u])\n        all_factors_v = get_prime_factorization(final_x[v])\n        all_factors_g = get_prime_factorization(g)\n        all_factors_l = get_prime_factorization(l)\n        \n        all_primes_in_edge = set()\n        all_primes_in_edge.update(all_factors_u.keys())\n        all_primes_in_edge.update(all_factors_v.keys())\n        all_primes_in_edge.update(all_factors_g.keys())\n        all_primes_in_edge.update(all_factors_l.keys())\n\n        for p in all_primes_in_edge:\n            exp_u = all_factors_u.get(p, 0)\n            exp_v = all_factors_v.get(p, 0)\n            \n            actual_gcd *= (p ** min(exp_u, exp_v))\n            actual_lcm *= (p ** max(exp_u, exp_v))\n        \n        if actual_gcd != g or actual_lcm != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, final_x[1:])) + \"\\n\")\n\n\n# Main execution\nsieve()\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\n# Max value for GCD/LCM\nMAX_VAL = 10**6\n\n# Sieve of Eratosthenes to find smallest prime factor (SPF) for numbers up to MAX_VAL\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(n):\n    factors = {}\n    while n > 1:\n        p = spf[n]\n        factors[p] = factors.get(p, 0) + 1\n        n //= p\n    return factors\n\n# Function to get exponent of a prime p in n\ndef get_exponent(n, p):\n    count = 0\n    if p == 0: return 0 # Handle p=0 case for safety, though primes are >= 2\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Adjacency list for the graph (stores original g, l)\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store all unique primes involved in g or l\n    relevant_primes = set()\n\n    # Store edges and initial constraints\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        # Collect all prime factors from g and l\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        relevant_primes.update(factors_g.keys())\n        relevant_primes.update(factors_l.keys())\n\n    # Sort primes for consistent iteration (optional, but good practice)\n    sorted_relevant_primes = sorted(list(relevant_primes))\n\n    # min_exp[i][p] and max_exp[i][p] store the tightest bounds for exponent of p in x_i\n    # Initialize to default values (0 and a large number)\n    # Using dictionaries for sparse storage, as not all (node, prime) pairs are relevant\n    min_exp = [{} for _ in range(n + 1)]\n    max_exp = [{} for _ in range(n + 1)]\n\n    # exp_val[i][p] will store the final assigned exponent of p in x_i\n    exp_val = [{} for _ in range(n + 1)]\n\n    # First pass: Initialize min_exp and max_exp bounds for each node and prime\n    for u, v, g, l in edges_data:\n        for p in sorted_relevant_primes:\n            g_p = get_exponent(g, p)\n            l_p = get_exponent(l, p)\n\n            # Ensure p is relevant for this edge\n            if g_p == 0 and l_p == 0:\n                continue\n\n            min_exp[u][p] = max(min_exp[u].get(p, 0), g_p)\n            max_exp[u][p] = min(max_exp[u].get(p, float('inf')), l_p)\n            min_exp[v][p] = max(min_exp[v].get(p, 0), g_p)\n            max_exp[v][p] = min(max_exp[v].get(p, 0), l_p) # bug fix: should be float('inf')\n\n            # Corrected line for max_exp[v][p]\n            max_exp[v][p] = min(max_exp[v].get(p, float('inf')), l_p)\n\n\n            if min_exp[u][p] > max_exp[u][p] or min_exp[v][p] > max_exp[v][p]:\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    # Second pass: Solve for exponents for each prime independently using BFS/DFS\n    for p in sorted_relevant_primes:\n        for i in range(1, n + 1):\n            if p not in exp_val[i]: # If this (node, prime) pair hasn't been assigned yet\n                \n                # If no bounds are set for this (node, prime) pair, it means this prime\n                # is not a factor of any g or l in edges connected to i.\n                # In this case, x_i's exponent for p can be 0.\n                if p not in min_exp[i]:\n                    exp_val[i][p] = 0\n                    continue\n\n                # If bounds are equal, the exponent is fixed\n                if min_exp[i][p] == max_exp[i][p]:\n                    exp_val[i][p] = min_exp[i][p]\n                    continue\n                \n                # Otherwise, we have two choices for this node's exponent for prime p: min_exp[i][p] or max_exp[i][p]\n                # Try the first choice (min_exp[i][p])\n                temp_exp_val = [dict(ev) for ev in exp_val] # Deep copy for backtracking\n                q = deque()\n                \n                # Start BFS/DFS for this component with an initial choice\n                start_node_exp = min_exp[i][p]\n                \n                # Perform two attempts for the starting node's exponent\n                for attempt in range(2):\n                    current_exp = start_node_exp if attempt == 0 else max_exp[i][p]\n                    \n                    # Reset current component's assignments for this prime\n                    for node_in_comp in range(1, n + 1):\n                        if p in temp_exp_val[node_in_comp] and temp_exp_val[node_in_comp][p] == -2: # -2 indicates assigned in previous attempt\n                            del temp_exp_val[node_in_comp][p]\n                        if p in temp_exp_val[node_in_comp] and temp_exp_val[node_in_comp][p] != -1: # -1 indicates unassigned\n                            # If it was already fixed from previous component, keep it\n                            if temp_exp_val[node_in_comp][p] != min_exp[node_in_comp].get(p, -1) or temp_exp_val[node_in_comp][p] != max_exp[node_in_comp].get(p, -1):\n                                pass # Keep value if it's a fixed value\n                            else:\n                                del temp_exp_val[node_in_comp][p]\n                        \n\n                    # If the starting node already has a fixed exp_val[i][p] from a previous component, use that\n                    if p in exp_val[i]:\n                        current_exp = exp_val[i][p]\n                    elif p in temp_exp_val[i] and temp_exp_val[i][p] != -1: # check if it was fixed earlier in this prime's pass\n                        current_exp = temp_exp_val[i][p]\n                    \n                    # If this attempt's choice is outside bounds, it's invalid\n                    if not (min_exp[i].get(p, 0) <= current_exp <= max_exp[i].get(p, float('inf'))):\n                        if attempt == 0: continue # Try second choice\n                        else: # Both choices invalid\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                    q.clear()\n                    q.append(i)\n                    temp_exp_val[i][p] = current_exp\n                    \n                    possible = True\n                    visited_in_attempt = set()\n                    visited_in_attempt.add(i)\n\n                    while q:\n                        u_node = q.popleft()\n                        \n                        # Check for neighbors\n                        for v_node, orig_g, orig_l in adj[u_node]:\n                            g_p = get_exponent(orig_g, p)\n                            l_p = get_exponent(orig_l, p)\n\n                            # If this edge doesn't involve prime p, skip\n                            if g_p == 0 and l_p == 0:\n                                continue\n\n                            # Determine required exponent for v_node\n                            required_v_exp = -1\n                            if temp_exp_val[u_node][p] == g_p:\n                                required_v_exp = l_p\n                            elif temp_exp_val[u_node][p] == l_p:\n                                required_v_exp = g_p\n                            else: # current_exp for u_node is not g_p or l_p, contradiction for this edge\n                                possible = False\n                                break\n                            \n                            if not (min_exp[v_node].get(p, 0) <= required_v_exp <= max_exp[v_node].get(p, float('inf'))):\n                                possible = False\n                                break\n\n                            if p not in temp_exp_val[v_node]:\n                                temp_exp_val[v_node][p] = required_v_exp\n                                q.append(v_node)\n                                visited_in_attempt.add(v_node)\n                            elif temp_exp_val[v_node][p] != required_v_exp:\n                                possible = False # Contradiction\n                                break\n                        if not possible:\n                            break\n                    \n                    if possible: # Found a valid assignment for this component\n                        for node_in_comp in visited_in_attempt:\n                            exp_val[node_in_comp][p] = temp_exp_val[node_in_comp][p]\n                        break # Exit attempt loop\n                    elif attempt == 1: # Both attempts failed\n                        sys.stdout.write(\"NO\\n\")\n                        return\n                    else: # Attempt 0 failed, reset values and try attempt 1\n                        for node_in_comp in visited_in_attempt:\n                            if p in temp_exp_val[node_in_comp] and temp_exp_val[node_in_comp][p] != -1:\n                                temp_exp_val[node_in_comp][p] = -1 # Mark as unassigned for next attempt\n    \n    # Final check and calculate x_i values\n    final_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in sorted_relevant_primes:\n            if p in exp_val[i] and exp_val[i][p] != -1:\n                final_x[i] *= (p ** exp_val[i][p])\n                if final_x[i] > MAX_VAL:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            elif p not in exp_val[i]: # If prime p was never relevant for node i, its exponent is 0\n                pass # final_x[i] is already initialized to 1, so p^0 doesn't change it.\n\n        # If a node has no edges connected to it, its value can be 1.\n        # This is implicitly handled if final_x[i] remains 1.\n        # But if it has no relevant primes, exp_val[i] might be empty.\n        # Ensure it's at least 1.\n        if final_x[i] == 0: # Should not happen if initialized to 1\n            final_x[i] = 1\n\n\n    # Verify all original GCD/LCM constraints\n    for u, v, g, l in edges_data:\n        actual_gcd = 1\n        actual_lcm = 1\n        \n        # Get all primes involved in final_x[u], final_x[v], g, l\n        all_factors_u = get_prime_factorization(final_x[u])\n        all_factors_v = get_prime_factorization(final_x[v])\n        all_factors_g = get_prime_factorization(g)\n        all_factors_l = get_prime_factorization(l)\n        \n        all_primes_in_edge = set()\n        all_primes_in_edge.update(all_factors_u.keys())\n        all_primes_in_edge.update(all_factors_v.keys())\n        all_primes_in_edge.update(all_factors_g.keys())\n        all_primes_in_edge.update(all_factors_l.keys())\n\n        for p in all_primes_in_edge:\n            exp_u = all_factors_u.get(p, 0)\n            exp_v = all_factors_v.get(p, 0)\n            \n            actual_gcd *= (p ** min(exp_u, exp_v))\n            actual_lcm *= (p ** max(exp_u, exp_v))\n        \n        if actual_gcd != g or actual_lcm != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, final_x[1:])) + \"\\n\")\n\n\n# Main execution\nsieve()\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 6277,
        "thoughts_token_count": 6692
    }
}