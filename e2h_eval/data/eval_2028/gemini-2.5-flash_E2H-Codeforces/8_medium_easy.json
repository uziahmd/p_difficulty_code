{
    "start": 1758011831.0418258,
    "end": 1758011918.8724759,
    "start-formatted": "2025-09-16 17:37 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**The \"Flawed Flow\" Problem: A Deep Dive into Directed Acyclic Graphs and Flow Networks**\n\nAlright, let's break down this \"Flawed Flow\" challenge. My brain immediately jumps to graph theory – we're dealing with a network, edges, and flow volumes. The core goal is to give each edge a direction such that the intermediate nodes (not the source or sink) maintain flow balance, meaning the amount coming in equals the amount going out, while also guaranteeing the resulting directed graph is acyclic. That last point, acyclicity, screams \"topological sort\" to me.\n\nThe hints are there: vertex 1 is the source, it has no incoming edges. That's a strong clue to start our graph direction from this point. If vertex 1 is the sole source and the graph is connected, all flow originates here and eventually has to reach vertex *n*, our sink. Since we need an acyclic graph (DAG), and we know the source and sink, let's focus on directing the edges in a way that aligns with this source-to-sink flow.\n\nNow the balance condition: `sum(incoming_ci) == sum(outgoing_ci)`.  Vertex 1 has no incoming flow, so all edges connected to it must be outward. Same for vertex `n`, but incoming. It's an interesting constraint. For nodes in the middle, we need the in-flow to match the out-flow. This looks like a system of equations, and it points to a greedy or iterative approach.\n\nThe crucial observation is the interplay between the \"net flow\" for each node. For any intermediate vertex *v*, the total capacity of all incident edges must be balanced, with in-flow equal to out-flow. And since a solution is guaranteed to exist, this implies a simple solution. The total flow through the graph, F, must be the sum of flow through the edges leaving the source.\n\nHere’s the plan: Let's create an \"active\" list of vertices. Start with vertex 1. All edges leaving 1 are directed outwards. Now, let’s maintain `degree[v]` to store the total capacity of all incident edges. Also, `current_in_flow[v]` and `current_out_flow[v]` which store current incoming and outgoing flow for a vertex v. Then, we look at the neighbors of vertex 1. Let's direct all edges out of 1. If for vertex *u*, the `current_in_flow[u]` is not half the capacity, then the edges in this vertex is not ready, we add this to a queue.\n\nHere's the refined strategy. Start by iterating through the edges. Set the direction of the edges leaving the source. For any middle node *v*, all edges incident to it should lead to degree(v)/2 flow, and the rest to be outgoing edges, in an acyclic form, the resulting graph has no cycles. The central idea is this: Start with the source, and from source, direct the edges based on the flow, making sure not to produce cycles. We need a way to track the already-processed/directed edges. If we get `current_in_flow[v]` exactly half of `degree[v]` for intermediate nodes, we are able to maintain the balance!\n\nIn this queue-based approach, We add the node to the queue if the incoming flow becomes equal to the half of total flow for a given node, then we know all undirected edges leaving that node have to be directed as out-going. This should produce an acyclic graph.\n",
    "response": "The problem asks us to direct the flow on each edge of an undirected graph, given the flow volume `ci` for each edge. We need to satisfy three conditions:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of flow on incoming edges must equal the sum of flow on outgoing edges.\n2.  **Source Condition:** Vertex 1 (the source) must have no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n\nThe problem guarantees that a solution always exists.\n\n**Key Observations and Strategy:**\n\n1.  **Source (Vertex 1):** The condition that vertex 1 has no incoming edges implies that all edges directly connected to vertex 1 must be directed *out of* vertex 1. This is our starting point.\n\n2.  **Intermediate Vertices (1 < `v` < `n`):** For any such vertex `v`, let `S_v` be the sum of flow volumes `ci` of all edges incident to `v`. The flow conservation condition `sum(incoming_ci) == sum(outgoing_ci)` means that `sum(incoming_ci) + sum(outgoing_ci) = S_v`. Since `sum(incoming_ci) = sum(outgoing_ci)`, it must be that `2 * sum(incoming_ci) = S_v`. This implies that `S_v` must be an even number, and `sum(incoming_ci)` (which is also `sum(outgoing_ci)`) must be exactly `S_v / 2`.\n    We can use this target value `S_v / 2` to determine when a vertex has received all its necessary incoming flow.\n\n3.  **Sink (Vertex `n`):** While not explicitly stated, the total flow must eventually reach the sink. If the graph is acyclic and vertex 1 is the only source, then vertex `n` must be the ultimate sink, meaning all edges incident to `n` must eventually be directed *into* `n` (after all other intermediate nodes are balanced).\n\n4.  **Acyclicity:** A common way to ensure acyclicity is to build the graph in a topological order. Our approach will naturally achieve this. By starting from the source and propagating flow decisions, we effectively build a DAG.\n\n**Algorithm:**\n\nWe can use a queue-based (BFS-like) approach:\n\n1.  **Data Structures:**\n    *   `adj`: An adjacency list where `adj[u]` stores tuples `(v, c, edge_idx)` for each undirected edge `(u, v)` with flow `c` and original index `edge_idx`.\n    *   `ans`: An array of size `m` to store the direction for each edge. `ans[edge_idx] = 0` means `a_i -> b_i`, `ans[edge_idx] = 1` means `b_i -> a_i`. Initialize with -1 (undetermined).\n    *   `degree`: An array where `degree[v]` stores the sum of `c` values for all edges incident to `v`.\n    *   `current_in_flow`: An array where `current_in_flow[v]` stores the sum of flow `c` for edges already directed *into* `v`. Initially all zeros.\n    *   `q`: A `collections.deque` (queue) to store vertices that are \"ready\" to have their outgoing edges determined.\n    *   `edge_input_details`: A list to store `(u, v, c)` for each edge in its original input order, along with its original index, to easily check which endpoint was `a_i` and `b_i`.\n\n2.  **Initialization:**\n    *   Read `n, m`.\n    *   Populate `adj`, `degree`, and `edge_input_details`.\n    *   Initialize `ans` to -1s and `current_in_flow` to 0s.\n\n3.  **Process Source (Vertex 1):**\n    *   Iterate through all edges `(v, c, idx)` incident to vertex 1.\n    *   Since vertex 1 has no incoming edges, all these edges must be directed *out of* 1.\n    *   Set `ans[idx]`: If `edge_input_details[idx][0] == 1` (meaning `a_i` was 1), then `ans[idx] = 0` (`1 -> v`). Otherwise (`b_i` was 1), `ans[idx] = 1` (`v -> 1`, which means `1` is `b_i` so `b_i -> a_i` is `1 -> v`).\n    *   Update `current_in_flow[v] += c`.\n    *   If `v` is not the sink (`n`) and `current_in_flow[v]` now equals `degree[v] / 2` (its target incoming flow), add `v` to the queue `q`.\n\n4.  **BFS-like Propagation:**\n    *   While `q` is not empty:\n        *   Dequeue a vertex `u` from `q`.\n        *   For `u` (which is not `n`), we know it has received all its required incoming flow (`current_in_flow[u] == degree[u] / 2`). To satisfy flow conservation, all remaining undirected edges incident to `u` *must* be directed *out of* `u`.\n        *   Iterate through all edges `(v, c, idx)` incident to `u` (using `adj[u]`).\n        *   If `ans[idx]` is still -1 (meaning this edge is not yet directed):\n            *   Direct `u -> v`.\n            *   Set `ans[idx]`: If `edge_input_details[idx][0] == u`, then `ans[idx] = 0` (`u -> v`). Otherwise, `ans[idx] = 1` (`v -> u`, meaning `u` is `b_i` so `b_i -> a_i` is `u -> v`).\n            *   Update `current_in_flow[v] += c`.\n            *   If `v` is not the sink (`n`) and `current_in_flow[v]` now equals `degree[v] / 2`, add `v` to the queue `q`.\n\n5.  **Output:** Print the values in the `ans` array.\n\n**Example Walkthrough (First Example):**\n`n=3, m=3`\nEdges:\n1. `(3, 2, 10)`\n2. `(1, 2, 10)`\n3. `(3, 1, 5)`\n\n**Initialization:**\n`adj = {1: [], 2: [], 3: []}`\n`degree = [0, 0, 0, 0]`\n`ans = [-1, -1, -1]`\n`current_in_flow = [0, 0, 0, 0]`\n`q = deque()`\n`edge_input_details = []`\n\nProcessing edges:\n1. `(3, 2, 10)` (idx 0):\n   `adj[3].append((2, 10, 0))`, `adj[2].append((3, 10, 0))`\n   `degree[3] += 10`, `degree[2] += 10` -> `degree = [0, 0, 10, 10]`\n   `edge_input_details.append((3, 2, 10))`\n2. `(1, 2, 10)` (idx 1):\n   `adj[1].append((2, 10, 1))`, `adj[2].append((1, 10, 1))`\n   `degree[1] += 10`, `degree[2] += 10` -> `degree = [0, 10, 20, 10]`\n   `edge_input_details.append((1, 2, 10))`\n3. `(3, 1, 5)` (idx 2):\n   `adj[3].append((1, 5, 2))`, `adj[1].append((3, 5, 2))`\n   `degree[3] += 5`, `degree[1] += 5` -> `degree = [0, 15, 20, 15]`\n   `edge_input_details.append((3, 1, 5))`\n\n**Degree values:**\n`degree[1] = 15`\n`degree[2] = 20` (target incoming flow = 10)\n`degree[3] = 15`\n\n**Process Source (Vertex 1):**\nEdges incident to 1: `(2, 10, 1)`, `(3, 5, 2)`\n\n1. Edge `(1, 2, 10)` (idx 1):\n   `ans[1] = 0` (since `edge_input_details[1][0] == 1`). Direction: `1 -> 2`.\n   `current_in_flow[2] += 10` -> `current_in_flow = [0, 0, 10, 0]`\n   Vertex 2 is not `n` (3). `current_in_flow[2]` (10) == `degree[2]/2` (20/2 = 10). Add 2 to `q`. `q = deque([2])`\n\n2. Edge `(1, 3, 5)` (idx 2):\n   `ans[2] = 1` (since `edge_input_details[2][0] == 3`, so `b_i` is 1). Direction: `1 -> 3`.\n   `current_in_flow[3] += 5` -> `current_in_flow = [0, 0, 10, 5]`\n   Vertex 3 is `n`. Don't add to `q`.\n\n`ans = [-1, 0, 1]`\n\n**BFS-like Propagation:**\n\n`q = deque([2])`\nDequeue `u = 2`.\n`current_in_flow[2]` (10) == `degree[2]/2` (10). Vertex 2 needs to push out its remaining flow.\nEdges incident to 2: `(3, 10, 0)`, `(1, 10, 1)`\n\n1. Edge `(2, 3, 10)` (idx 0):\n   `ans[0]` is -1. Direct `2 -> 3`.\n   `ans[0] = 1` (since `edge_input_details[0][0] == 3`, so `b_i` is 2). Direction: `2 -> 3`.\n   `current_in_flow[3] += 10` -> `current_in_flow = [0, 0, 10, 15]`\n   Vertex 3 is `n`. Don't add to `q`.\n\n2. Edge `(2, 1, 10)` (idx 1):\n   `ans[1]` is 0 (already directed `1 -> 2`). Skip.\n\n`q` is now empty.\n\n**Final `ans` array:** `[1, 0, 1]`\n\nThis matches the example output.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edge details in input order to correctly determine 0/1 for output\n    edge_input_details = [] \n    \n    # Adjacency list: adj[u] stores (v, c, edge_idx) for undirected edges\n    adj = [[] for _ in range(n + 1)]\n    \n    # degree[v] stores the sum of capacities of all edges incident to v\n    degree = [0] * (n + 1)\n    \n    # ans[edge_idx] stores the direction: 0 for a_i -> b_i, 1 for b_i -> a_i\n    # Initialize with -1 to mark as undirected\n    ans = [-1] * m\n    \n    # current_in_flow[v] stores the sum of capacities of edges already directed INTO v\n    current_in_flow = [0] * (n + 1)\n    \n    # Queue for vertices that have received their required incoming flow\n    q = collections.deque()\n\n    # Read edges and populate data structures\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edge_input_details.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        degree[u] += c\n        degree[v] += c\n\n    # Step 1: Process the source (vertex 1)\n    # All edges incident to vertex 1 must be directed OUT of 1.\n    for neighbor, capacity, edge_idx in adj[1]:\n        if ans[edge_idx] == -1: # Ensure we process each edge only once\n            # Determine direction: 0 if original (a_i, b_i) is (1, neighbor), else 1\n            if edge_input_details[edge_idx][0] == 1: # Original a_i is 1\n                ans[edge_idx] = 0 # 1 -> neighbor\n            else: # Original b_i is 1\n                ans[edge_idx] = 1 # neighbor -> 1, but we want 1 -> neighbor, so b_i -> a_i is 1\n            \n            # Update current_in_flow for the neighbor\n            current_in_flow[neighbor] += capacity\n            \n            # If neighbor is not the sink (n) and has received its required incoming flow,\n            # add it to the queue.\n            # Required incoming flow for intermediate node v is degree[v] / 2.\n            if neighbor != n and current_in_flow[neighbor] == degree[neighbor] // 2:\n                q.append(neighbor)\n\n    # Step 2: BFS-like propagation\n    # Process vertices in the queue\n    while q:\n        u = q.popleft()\n        \n        # For vertex u (not the sink), it has received all its required incoming flow.\n        # Therefore, all remaining undirected edges incident to u must be directed OUT of u.\n        for neighbor, capacity, edge_idx in adj[u]:\n            if ans[edge_idx] == -1: # If this edge is still undirected\n                # Determine direction: 0 if original (a_i, b_i) is (u, neighbor), else 1\n                if edge_input_details[edge_idx][0] == u: # Original a_i is u\n                    ans[edge_idx] = 0 # u -> neighbor\n                else: # Original b_i is u\n                    ans[edge_idx] = 1 # neighbor -> u, but we want u -> neighbor, so b_i -> a_i is 1\n                \n                # Update current_in_flow for the neighbor\n                current_in_flow[neighbor] += capacity\n                \n                # If neighbor is not the sink (n) and has received its required incoming flow,\n                # add it to the queue.\n                if neighbor != n and current_in_flow[neighbor] == degree[neighbor] // 2:\n                    q.append(neighbor)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edge details in input order to correctly determine 0/1 for output\n    edge_input_details = [] \n    \n    # Adjacency list: adj[u] stores (v, c, edge_idx) for undirected edges\n    adj = [[] for _ in range(n + 1)]\n    \n    # degree[v] stores the sum of capacities of all edges incident to v\n    degree = [0] * (n + 1)\n    \n    # ans[edge_idx] stores the direction: 0 for a_i -> b_i, 1 for b_i -> a_i\n    # Initialize with -1 to mark as undirected\n    ans = [-1] * m\n    \n    # current_in_flow[v] stores the sum of capacities of edges already directed INTO v\n    current_in_flow = [0] * (n + 1)\n    \n    # Queue for vertices that have received their required incoming flow\n    q = collections.deque()\n\n    # Read edges and populate data structures\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edge_input_details.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        degree[u] += c\n        degree[v] += c\n\n    # Step 1: Process the source (vertex 1)\n    # All edges incident to vertex 1 must be directed OUT of 1.\n    for neighbor, capacity, edge_idx in adj[1]:\n        if ans[edge_idx] == -1: # Ensure we process each edge only once\n            # Determine direction: 0 if original (a_i, b_i) is (1, neighbor), else 1\n            if edge_input_details[edge_idx][0] == 1: # Original a_i is 1\n                ans[edge_idx] = 0 # 1 -> neighbor\n            else: # Original b_i is 1\n                ans[edge_idx] = 1 # neighbor -> 1, but we want 1 -> neighbor, so b_i -> a_i is 1\n            \n            # Update current_in_flow for the neighbor\n            current_in_flow[neighbor] += capacity\n            \n            # If neighbor is not the sink (n) and has received its required incoming flow,\n            # add it to the queue.\n            # Required incoming flow for intermediate node v is degree[v] / 2.\n            if neighbor != n and current_in_flow[neighbor] == degree[neighbor] // 2:\n                q.append(neighbor)\n\n    # Step 2: BFS-like propagation\n    # Process vertices in the queue\n    while q:\n        u = q.popleft()\n        \n        # For vertex u (not the sink), it has received all its required incoming flow.\n        # Therefore, all remaining undirected edges incident to u must be directed OUT of u.\n        for neighbor, capacity, edge_idx in adj[u]:\n            if ans[edge_idx] == -1: # If this edge is still undirected\n                # Determine direction: 0 if original (a_i, b_i) is (u, neighbor), else 1\n                if edge_input_details[edge_idx][0] == u: # Original a_i is u\n                    ans[edge_idx] = 0 # u -> neighbor\n                else: # Original b_i is u\n                    ans[edge_idx] = 1 # neighbor -> u, but we want u -> neighbor, so b_i -> a_i is 1\n                \n                # Update current_in_flow for the neighbor\n                current_in_flow[neighbor] += capacity\n                \n                # If neighbor is not the sink (n) and has received its required incoming flow,\n                # add it to the queue.\n                if neighbor != n and current_in_flow[neighbor] == degree[neighbor] // 2:\n                    q.append(neighbor)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 3610,
        "thoughts_token_count": 5912
    }
}