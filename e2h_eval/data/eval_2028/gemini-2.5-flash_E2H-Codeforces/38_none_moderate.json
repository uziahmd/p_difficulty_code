{
    "start": 1758293690.388234,
    "end": 1758293713.1154428,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional_for_min_nodes = -1\n\n    # Iterate through possible numbers of SCCs (k)\n    # The number of nodes in an SCC must be at least 1.\n    # The sum of sizes of SCCs must be at least 1.\n    # The total number of nodes n = sum(s_i)\n    # The number of reachable pairs (u,v) with u < v within SCCs is sum(s_i * (s_i - 1) / 2)\n    # This sum must be equal to p.\n\n    # We are looking for sum(s_i * (s_i - 1) / 2) = p\n    # Let's precompute triangular numbers T(x) = x * (x - 1) / 2\n    # T(x) is the number of pairs (u,v) with u < v in an SCC of size x.\n    # T(x) values grow quadratically.\n    # Max p is 2 * 10^5.\n    # T(x) <= 2 * 10^5 => x * (x - 1) <= 4 * 10^5\n    # x^2 approx 4 * 10^5 => x approx sqrt(4 * 10^5) = sqrt(40 * 10^4) = 2 * 10^2 = 200\n    # So individual SCC sizes won't exceed ~632 (T(632) = 199096, T(633) = 199728, T(634) = 200361)\n    # Max possible SCC size is around 633.\n\n    max_scc_size = 0\n    while max_scc_size * (max_scc_size - 1) // 2 <= p:\n        max_scc_size += 1\n    max_scc_size += 2 # A bit of buffer\n\n    triangular_numbers = [0] * (max_scc_size + 1)\n    for i in range(1, max_scc_size + 1):\n        triangular_numbers[i] = i * (i - 1) // 2\n\n    # dp[current_p] = (min_nodes, max_unidirectional)\n    # We want to find a set of SCCs {s_1, s_2, ..., s_k} such that sum(T(s_i)) = p.\n    # The total number of nodes will be sum(s_i).\n    # The number of unidirectional pairs will be n * (n - 1) - sum(s_i * (s_i - 1)) - (n - k) * k\n    # No, this is wrong.\n    # The number of unidirectional pairs for a graph with k SCCs of sizes s_1, ..., s_k\n    # where all SCCs are arranged in a topological order (e.g., s_1 -> s_2 -> ... -> s_k)\n    # and there are edges from every node in s_i to every node in s_j for i < j.\n    # Total nodes N = sum(s_i).\n    # Total pairs (u,v) with u != v is N * (N - 1).\n    # Reachable pairs (u,v) with u != v:\n    #   - Within SCCs: sum(s_i * (s_i - 1))\n    #   - Between SCCs: sum_{i < j} (s_i * s_j) * 2 (because u->v and v->u for different SCCs is not possible)\n    # For a DAG of SCCs, if there's a path from SCC_i to SCC_j, then all nodes in SCC_i can reach all nodes in SCC_j.\n    # And no nodes in SCC_j can reach nodes in SCC_i. These are unidirectional.\n    # If we arrange k SCCs s_1, ..., s_k in a line (s_1 -> s_2 -> ... -> s_k) and add all edges\n    # from s_i to s_j for i < j, then:\n    # - Reachable (u,v) where u and v are in the same SCC: sum(s_i * (s_i - 1)). These are bidirectional.\n    # - Reachable (u,v) where u is in s_i, v is in s_j, i < j: s_i * s_j pairs. These are unidirectional.\n    # Total bidirectional pairs = sum(s_i * (s_i - 1)).\n    # Total unidirectional pairs = sum_{i < j} (s_i * s_j) * 2.\n    # Total reachable pairs = sum(s_i * (s_i - 1)) + sum_{i < j} (s_i * s_j) * 2.\n    # We need sum(s_i * (s_i - 1) / 2) = p. This is the sum of u < v reachable and bidirectional.\n\n    # Let's re-read the problem carefully.\n    # \"unidirectional if u != v, there exists a path from u to v, and there are no paths from v to u.\"\n    # \"p-reachable if it contains exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\"\n    # This means p is the count of (u, v) such that u < v AND u and v are in the same SCC.\n    # So, p = sum_{i=1 to k} s_i * (s_i - 1) / 2.\n\n    # We need to find {s_1, ..., s_k} such that sum(T(s_i)) = p,\n    # minimizing N = sum(s_i).\n    # Among those with minimum N, maximize unidirectional pairs.\n    # For a fixed set of SCCs {s_1, ..., s_k}, the total number of nodes is N = sum(s_i).\n    # To maximize unidirectional pairs, we should make a complete DAG of SCCs.\n    # That is, if SCC_i and SCC_j are distinct, and i < j, there is a path from every node in SCC_i to every node in SCC_j.\n    # In this configuration:\n    # - Pairs within an SCC (u,v): u and v are in the same SCC. These are bidirectional.\n    #   Count = sum(s_i * (s_i - 1)).\n    # - Pairs between SCCs (u,v): u in SCC_i, v in SCC_j, i < j. These are unidirectional.\n    #   Count = sum_{i < j} (s_i * s_j) * 2.\n    # The total number of unidirectional pairs is sum_{i < j} (s_i * s_j) * 2.\n    # This is equivalent to N * (N - 1) - sum(s_i * (s_i - 1)).\n    # N * (N - 1) is total (u,v) with u!=v.\n    # sum(s_i * (s_i - 1)) is total (u,v) with u!=v where u,v are in same SCC.\n    # So N * (N - 1) - sum(s_i * (s_i - 1)) is the total number of reachable pairs (u,v) with u!=v where u,v are in different SCCs.\n    # These are exactly the unidirectional pairs.\n\n    # So the problem becomes: find {s_1, ..., s_k} such that:\n    # 1. sum(s_i * (s_i - 1) / 2) = p\n    # 2. Minimize N = sum(s_i)\n    # 3. Among those with minimum N, maximize N * (N - 1) - sum(s_i * (s_i - 1))\n    # Note that sum(s_i * (s_i - 1)) = 2 * p.\n    # So we need to maximize N * (N - 1) - 2 * p.\n    # Since p is fixed, maximizing this is equivalent to maximizing N * (N - 1), which means maximizing N.\n    # This is a contradiction. We need to minimize N first, then maximize N.\n    # This implies that for the same minimum N, we want to maximize N * (N - 1) - 2 * p.\n    # But N is fixed, so N * (N - 1) - 2 * p is also fixed.\n    # This means all configurations that yield the minimum N will have the same maximum unidirectional pairs.\n    # Let's verify this.\n    # Consider p = 3.\n    # Possible SCC sizes s_i such that sum(s_i * (s_i - 1) / 2) = 3:\n    # 1. One SCC of size 3: s_1 = 3. T(3) = 3.\n    #    N = 3. Unidirectional = N * (N - 1) - 2 * p = 3 * 2 - 2 * 3 = 6 - 6 = 0.\n    # 2. One SCC of size 2, one of size 2, one of size 1 (this is not possible, T(2)+T(2)+T(1)=1+1+0=2)\n    #    T(s) values: T(1)=0, T(2)=1, T(3)=3, T(4)=6.\n    #    To get p=3:\n    #    - {3}: N=3. Unidirectional = 0.\n    #    - {2, 2, 1}: N=5. sum(T(s_i)) = T(2)+T(2)+T(1) = 1+1+0 = 2. Not 3.\n    #    - {2, 1, 1, 1}: N=5. sum(T(s_i)) = T(2)+T(1)+T(1)+T(1) = 1+0+0+0 = 1. Not 3.\n    # The only way to get p=3 is with SCC {3}.\n    # So min_nodes = 3, max_unidirectional = 0. This matches example 1.\n\n    # Consider p = 4.\n    # T(1)=0, T(2)=1, T(3)=3, T(4)=6.\n    # Possible partitions of p=4 into sum of T(s_i):\n    # 1. {4}: N=4. T(4)=6. Too large.\n    # 2. {3, 1}: N=3+1=4. T(3)+T(1)=3+0=3. Not 4.\n    # 3. {2, 2}: N=2+2=4. T(2)+T(2)=1+1=2. Not 4.\n    # 4. {2, 1, 1, ...}: Need to sum to 4.\n    #    Let's use dynamic programming.\n    #    dp[current_p] = (min_nodes, max_unidirectional)\n    #    This is a variation of change-making problem.\n    #    We want to find the minimum sum of s_i such that sum(T(s_i)) = p.\n    #    Let dp[x] be the minimum sum of s_i to get total_T = x.\n    #    dp[x] = min_{s_i} (s_i + dp[x - T(s_i)])\n    #    Initialize dp with (infinity, 0). dp[0] = (0, 0) (0 nodes, 0 unidirectional).\n    #    For current_p from 1 to p:\n    #        For s from 1 to max_scc_size:\n    #            If T(s) <= current_p:\n    #                If dp[current_p - T(s)].nodes + s < dp[current_p].nodes:\n    #                    dp[current_p].nodes = dp[current_p - T(s)].nodes + s\n    #                    dp[current_p].unidirectional = dp[current_p - T(s)].unidirectional (or some other logic?)\n    #                Else if dp[current_p - T(s)].nodes + s == dp[current_p].nodes:\n    #                    # If nodes are same, maximize unidirectional.\n    #                    # This is where the confusion lies.\n    #                    # The unidirectional pairs are N * (N - 1) - 2 * p.\n    #                    # If N is fixed, this value is fixed.\n    #                    # So, we just need to find the minimum N for p.\n    #                    # The max_unidirectional_for_min_nodes will then be N_min * (N_min - 1) - 2 * p.\n\n    # So the DP state should be just dp[x] = min_nodes for sum(T(s_i)) = x.\n    dp = [float('inf')] * (p + 1)\n    dp[0] = 0\n\n    for current_p in range(1, p + 1):\n        for s in range(1, max_scc_size + 1):\n            if triangular_numbers[s] <= current_p:\n                if dp[current_p - triangular_numbers[s]] != float('inf'):\n                    dp[current_p] = min(dp[current_p], dp[current_p - triangular_numbers[s]] + s)\n\n    min_nodes = dp[p]\n    max_unidirectional_for_min_nodes = min_nodes * (min_nodes - 1) - 2 * p\n\n    print(f\"{min_nodes} {max_unidirectional_for_min_nodes}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional_for_min_nodes = -1\n\n    # Iterate through possible numbers of SCCs (k)\n    # The number of nodes in an SCC must be at least 1.\n    # The sum of sizes of SCCs must be at least 1.\n    # The total number of nodes n = sum(s_i)\n    # The number of reachable pairs (u,v) with u < v within SCCs is sum(s_i * (s_i - 1) / 2)\n    # This sum must be equal to p.\n\n    # We are looking for sum(s_i * (s_i - 1) / 2) = p\n    # Let's precompute triangular numbers T(x) = x * (x - 1) / 2\n    # T(x) is the number of pairs (u,v) with u < v in an SCC of size x.\n    # T(x) values grow quadratically.\n    # Max p is 2 * 10^5.\n    # T(x) <= 2 * 10^5 => x * (x - 1) <= 4 * 10^5\n    # x^2 approx 4 * 10^5 => x approx sqrt(4 * 10^5) = sqrt(40 * 10^4) = 2 * 10^2 = 200\n    # So individual SCC sizes won't exceed ~632 (T(632) = 199096, T(633) = 199728, T(634) = 200361)\n    # Max possible SCC size is around 633.\n\n    max_scc_size = 0\n    while max_scc_size * (max_scc_size - 1) // 2 <= p:\n        max_scc_size += 1\n    max_scc_size += 2 # A bit of buffer\n\n    triangular_numbers = [0] * (max_scc_size + 1)\n    for i in range(1, max_scc_size + 1):\n        triangular_numbers[i] = i * (i - 1) // 2\n\n    # dp[current_p] = (min_nodes, max_unidirectional)\n    # We want to find a set of SCCs {s_1, s_2, ..., s_k} such that sum(T(s_i)) = p.\n    # The total number of nodes will be sum(s_i).\n    # The number of unidirectional pairs will be n * (n - 1) - sum(s_i * (s_i - 1)) - (n - k) * k\n    # No, this is wrong.\n    # The number of unidirectional pairs for a graph with k SCCs of sizes s_1, ..., s_k\n    # where all SCCs are arranged in a topological order (e.g., s_1 -> s_2 -> ... -> s_k)\n    # and there are edges from every node in s_i to every node in s_j for i < j.\n    # Total nodes N = sum(s_i).\n    # Total pairs (u,v) with u != v is N * (N - 1).\n    # Reachable pairs (u,v) with u != v:\n    #   - Within SCCs: sum(s_i * (s_i - 1))\n    #   - Between SCCs: sum_{i < j} (s_i * s_j) * 2 (because u->v and v->u for different SCCs is not possible)\n    # For a DAG of SCCs, if there's a path from SCC_i to SCC_j, then all nodes in SCC_i can reach all nodes in SCC_j.\n    # And no nodes in SCC_j can reach nodes in SCC_i. These are unidirectional.\n    # If we arrange k SCCs s_1, ..., s_k in a line (s_1 -> s_2 -> ... -> s_k) and add all edges\n    # from s_i to s_j for i < j, then:\n    # - Reachable (u,v) where u and v are in the same SCC: sum(s_i * (s_i - 1)). These are bidirectional.\n    # - Reachable (u,v) where u is in s_i, v is in s_j, i < j: s_i * s_j pairs. These are unidirectional.\n    # Total bidirectional pairs = sum(s_i * (s_i - 1)).\n    # Total unidirectional pairs = sum_{i < j} (s_i * s_j) * 2.\n    # Total reachable pairs = sum(s_i * (s_i - 1)) + sum_{i < j} (s_i * s_j) * 2.\n    # We need sum(s_i * (s_i - 1) / 2) = p. This is the sum of u < v reachable and bidirectional.\n\n    # Let's re-read the problem carefully.\n    # \"unidirectional if u != v, there exists a path from u to v, and there are no paths from v to u.\"\n    # \"p-reachable if it contains exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\"\n    # This means p is the count of (u, v) such that u < v AND u and v are in the same SCC.\n    # So, p = sum_{i=1 to k} s_i * (s_i - 1) / 2.\n\n    # We need to find {s_1, ..., s_k} such that sum(T(s_i)) = p,\n    # minimizing N = sum(s_i).\n    # Among those with minimum N, maximize unidirectional pairs.\n    # For a fixed set of SCCs {s_1, ..., s_k}, the total number of nodes is N = sum(s_i).\n    # To maximize unidirectional pairs, we should make a complete DAG of SCCs.\n    # That is, if SCC_i and SCC_j are distinct, and i < j, there is a path from every node in SCC_i to every node in SCC_j.\n    # In this configuration:\n    # - Pairs within an SCC (u,v): u and v are in the same SCC. These are bidirectional.\n    #   Count = sum(s_i * (s_i - 1)).\n    # - Pairs between SCCs (u,v): u in SCC_i, v in SCC_j, i < j. These are unidirectional.\n    #   Count = sum_{i < j} (s_i * s_j) * 2.\n    # The total number of unidirectional pairs is sum_{i < j} (s_i * s_j) * 2.\n    # This is equivalent to N * (N - 1) - sum(s_i * (s_i - 1)).\n    # N * (N - 1) is total (u,v) with u!=v.\n    # sum(s_i * (s_i - 1)) is total (u,v) with u!=v where u,v are in same SCC.\n    # So N * (N - 1) - sum(s_i * (s_i - 1)) is the total number of reachable pairs (u,v) with u!=v where u,v are in different SCCs.\n    # These are exactly the unidirectional pairs.\n\n    # So the problem becomes: find {s_1, ..., s_k} such that:\n    # 1. sum(s_i * (s_i - 1) / 2) = p\n    # 2. Minimize N = sum(s_i)\n    # 3. Among those with minimum N, maximize N * (N - 1) - sum(s_i * (s_i - 1))\n    # Note that sum(s_i * (s_i - 1)) = 2 * p.\n    # So we need to maximize N * (N - 1) - 2 * p.\n    # Since p is fixed, maximizing this is equivalent to maximizing N * (N - 1), which means maximizing N.\n    # This is a contradiction. We need to minimize N first, then maximize N.\n    # This implies that for the same minimum N, we want to maximize N * (N - 1) - 2 * p.\n    # But N is fixed, so N * (N - 1) - 2 * p is also fixed.\n    # This means all configurations that yield the minimum N will have the same maximum unidirectional pairs.\n    # Let's verify this.\n    # Consider p = 3.\n    # Possible SCC sizes s_i such that sum(s_i * (s_i - 1) / 2) = 3:\n    # 1. One SCC of size 3: s_1 = 3. T(3) = 3.\n    #    N = 3. Unidirectional = N * (N - 1) - 2 * p = 3 * 2 - 2 * 3 = 6 - 6 = 0.\n    # 2. One SCC of size 2, one of size 2, one of size 1 (this is not possible, T(2)+T(2)+T(1)=1+1+0=2)\n    #    T(s) values: T(1)=0, T(2)=1, T(3)=3, T(4)=6.\n    #    To get p=3:\n    #    - {3}: N=3. Unidirectional = 0.\n    #    - {2, 2, 1}: N=5. sum(T(s_i)) = T(2)+T(2)+T(1) = 1+1+0 = 2. Not 3.\n    #    - {2, 1, 1, 1}: N=5. sum(T(s_i)) = T(2)+T(1)+T(1)+T(1) = 1+0+0+0 = 1. Not 3.\n    # The only way to get p=3 is with SCC {3}.\n    # So min_nodes = 3, max_unidirectional = 0. This matches example 1.\n\n    # Consider p = 4.\n    # T(1)=0, T(2)=1, T(3)=3, T(4)=6.\n    # Possible partitions of p=4 into sum of T(s_i):\n    # 1. {4}: N=4. T(4)=6. Too large.\n    # 2. {3, 1}: N=3+1=4. T(3)+T(1)=3+0=3. Not 4.\n    # 3. {2, 2}: N=2+2=4. T(2)+T(2)=1+1=2. Not 4.\n    # 4. {2, 1, 1, ...}: Need to sum to 4.\n    #    Let's use dynamic programming.\n    #    dp[current_p] = (min_nodes, max_unidirectional)\n    #    This is a variation of change-making problem.\n    #    We want to find the minimum sum of s_i such that sum(T(s_i)) = p.\n    #    Let dp[x] be the minimum sum of s_i to get total_T = x.\n    #    dp[x] = min_{s_i} (s_i + dp[x - T(s_i)])\n    #    Initialize dp with (infinity, 0). dp[0] = (0, 0) (0 nodes, 0 unidirectional).\n    #    For current_p from 1 to p:\n    #        For s from 1 to max_scc_size:\n    #            If T(s) <= current_p:\n    #                If dp[current_p - T(s)].nodes + s < dp[current_p].nodes:\n    #                    dp[current_p].nodes = dp[current_p - T(s)].nodes + s\n    #                    dp[current_p].unidirectional = dp[current_p - T(s)].unidirectional (or some other logic?)\n    #                Else if dp[current_p - T(s)].nodes + s == dp[current_p].nodes:\n    #                    # If nodes are same, maximize unidirectional.\n    #                    # This is where the confusion lies.\n    #                    # The unidirectional pairs are N * (N - 1) - 2 * p.\n    #                    # If N is fixed, this value is fixed.\n    #                    # So, we just need to find the minimum N for p.\n    #                    # The max_unidirectional_for_min_nodes will then be N_min * (N_min - 1) - 2 * p.\n\n    # So the DP state should be just dp[x] = min_nodes for sum(T(s_i)) = x.\n    dp = [float('inf')] * (p + 1)\n    dp[0] = 0\n\n    for current_p in range(1, p + 1):\n        for s in range(1, max_scc_size + 1):\n            if triangular_numbers[s] <= current_p:\n                if dp[current_p - triangular_numbers[s]] != float('inf'):\n                    dp[current_p] = min(dp[current_p], dp[current_p - triangular_numbers[s]] + s)\n\n    min_nodes = dp[p]\n    max_unidirectional_for_min_nodes = min_nodes * (min_nodes - 1) - 2 * p\n\n    print(f\"{min_nodes} {max_unidirectional_for_min_nodes}\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 3304,
        "thoughts_token_count": 0
    }
}