{
    "start": 1758285070.4741466,
    "end": 1758285085.77868,
    "start-formatted": "2025-09-19 21:31 KST",
    "end-formatted": "2025-09-19 21:31 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Breaking Down the TV Game Problem**\n\nOkay, so I've got this \"TV Game\" problem in front of me, and it seems like a classic combinatorial optimization task. The core is figuring out the best sequence of moves for Homer and Marge to maximize their combined prize. Here's how I'm thinking about it:\n\nFirst, I need to fully understand the setup. We have a 2n-digit number, and both Homer and Marge each get to grab 'n' digits from it. The order they grab the digits directly impacts the value of their numbers since the leftmost digits have the highest place value.\n\nThe real key here is maximizing the total prize, S1 + S2, where S1 and S2 are the numbers Homer and Marge construct, respectively.  A simple example, like with \"1234\", helps to solidify this: different move sequences lead to different sums.\n\nNow, I need to get to the heart of the optimization strategy. The insight is crucial: the sum S1 + S2 depends entirely on how the digits are *assigned* to the players and their position within their numbers. I'm focusing on the place value of each digit. If a digit 'a' is taken as the `k`-th move, it adds `a * 10^(n-k)` to the respective player's score.\n\nMy immediate thought is, how do I approach this? The constraint on 'n' (up to 18) suggests a solution that explores a manageable number of combinations. My intuition is that a brute-force approach, maybe even recursive, would be viable, since I can explicitly calculate the contribution of each digit based on its position in the number.  But, I need to be careful of potential performance bottlenecks with larger 'n'.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # Convert digits to integers\n    digits = [int(d) for d in a_str]\n\n    # dp[mask] stores the maximum possible total sum for the digits represented by the mask.\n    # The mask is a bitmask of length 2n, where the i-th bit is 1 if the i-th digit\n    # has been taken, and 0 otherwise.\n    # The value stored in dp[mask] is a tuple: (max_sum, sequence_string).\n    # We initialize with a very small sum for non-reachable states.\n    # The total number of digits is 2n.\n    num_digits = 2 * n\n    \n    # Initialize dp table.\n    # dp[mask] = (current_max_sum, path_string)\n    # The initial state is mask 0 (no digits taken), sum 0, empty path.\n    dp = [(-1, \"\") for _ in range(1 << num_digits)]\n    dp[0] = (0, \"\")\n\n    # Iterate through masks in increasing order.\n    # This ensures that when we compute dp[mask'], dp[mask] (where mask is a submask of mask')\n    # has already been computed.\n    for mask in range(1 << num_digits):\n        current_sum, current_path = dp[mask]\n        \n        # If this state is not reachable, skip it.\n        if current_sum == -1:\n            continue\n\n        # Count how many digits have been taken so far.\n        # This is equivalent to the number of set bits in the mask.\n        taken_count = bin(mask).count('1')\n\n        # Calculate how many moves each player has made so far.\n        # Homer's moves: (taken_count + 1) // 2\n        # Marge's moves: taken_count // 2\n        \n        # If taken_count is even, Homer makes the next move.\n        # If taken_count is odd, Marge makes the next move.\n        \n        # Determine the current power of 10 for the next digit.\n        # If Homer makes k-th move, it's 10^(n-k).\n        # If Marge makes k-th move, it's 10^(n-k).\n        # k is (taken_count // 2) + 1 for the player who is about to move.\n        power_of_10 = 10**(n - (taken_count // 2) - 1)\n\n        # Iterate through all possible next digits to take.\n        # A digit can be taken if its bit is not set in the current mask.\n        for i in range(num_digits):\n            if not (mask & (1 << i)):  # If the i-th digit has not been taken\n                next_mask = mask | (1 << i)  # Form the new mask\n\n                # Calculate the contribution of the i-th digit.\n                digit_value = digits[i]\n                contribution = digit_value * power_of_10\n                \n                new_sum = current_sum + contribution\n                \n                # Determine who makes the move and append to the path.\n                if taken_count % 2 == 0:  # Homer's turn\n                    new_path = current_path + 'H'\n                else:  # Marge's turn\n                    new_path = current_path + 'M'\n\n                # Update dp[next_mask] if this path gives a higher sum.\n                if new_sum > dp[next_mask][0]:\n                    dp[next_mask] = (new_sum, new_path)\n\n    # The final answer is in dp[(1 << num_digits) - 1], which represents all digits taken.\n    # The problem asks for the sequence of moves, which is the second element of the tuple.\n    print(dp[(1 << num_digits) - 1][1])\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # Convert digits to integers\n    digits = [int(d) for d in a_str]\n\n    # dp[mask] stores the maximum possible total sum for the digits represented by the mask.\n    # The mask is a bitmask of length 2n, where the i-th bit is 1 if the i-th digit\n    # has been taken, and 0 otherwise.\n    # The value stored in dp[mask] is a tuple: (max_sum, sequence_string).\n    # We initialize with a very small sum for non-reachable states.\n    # The total number of digits is 2n.\n    num_digits = 2 * n\n    \n    # Initialize dp table.\n    # dp[mask] = (current_max_sum, path_string)\n    # The initial state is mask 0 (no digits taken), sum 0, empty path.\n    dp = [(-1, \"\") for _ in range(1 << num_digits)]\n    dp[0] = (0, \"\")\n\n    # Iterate through masks in increasing order.\n    # This ensures that when we compute dp[mask'], dp[mask] (where mask is a submask of mask')\n    # has already been computed.\n    for mask in range(1 << num_digits):\n        current_sum, current_path = dp[mask]\n        \n        # If this state is not reachable, skip it.\n        if current_sum == -1:\n            continue\n\n        # Count how many digits have been taken so far.\n        # This is equivalent to the number of set bits in the mask.\n        taken_count = bin(mask).count('1')\n\n        # Calculate how many moves each player has made so far.\n        # Homer's moves: (taken_count + 1) // 2\n        # Marge's moves: taken_count // 2\n        \n        # If taken_count is even, Homer makes the next move.\n        # If taken_count is odd, Marge makes the next move.\n        \n        # Determine the current power of 10 for the next digit.\n        # If Homer makes k-th move, it's 10^(n-k).\n        # If Marge makes k-th move, it's 10^(n-k).\n        # k is (taken_count // 2) + 1 for the player who is about to move.\n        power_of_10 = 10**(n - (taken_count // 2) - 1)\n\n        # Iterate through all possible next digits to take.\n        # A digit can be taken if its bit is not set in the current mask.\n        for i in range(num_digits):\n            if not (mask & (1 << i)):  # If the i-th digit has not been taken\n                next_mask = mask | (1 << i)  # Form the new mask\n\n                # Calculate the contribution of the i-th digit.\n                digit_value = digits[i]\n                contribution = digit_value * power_of_10\n                \n                new_sum = current_sum + contribution\n                \n                # Determine who makes the move and append to the path.\n                if taken_count % 2 == 0:  # Homer's turn\n                    new_path = current_path + 'H'\n                else:  # Marge's turn\n                    new_path = current_path + 'M'\n\n                # Update dp[next_mask] if this path gives a higher sum.\n                if new_sum > dp[next_mask][0]:\n                    dp[next_mask] = (new_sum, new_path)\n\n    # The final answer is in dp[(1 << num_digits) - 1], which represents all digits taken.\n    # The problem asks for the sequence of moves, which is the second element of the tuple.\n    print(dp[(1 << num_digits) - 1][1])\n\nif __name__ == '__main__':\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 432,
        "completion_token_count": 944,
        "thoughts_token_count": 798
    }
}