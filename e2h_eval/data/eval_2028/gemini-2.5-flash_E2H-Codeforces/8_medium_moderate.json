{
    "start": 1758011927.8128686,
    "end": 1758011997.2874775,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:39 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**The \"Flawed Flow\" Problem: A Deep Dive into Directed Acyclic Graphs and Flow Networks**\n\nAlright, let's break this down. My goal is to craft a valid maximum flow network from a given undirected graph, and the challenge lies in directing the edges while satisfying all the constraints. I'm focusing on three critical conditions: flow conservation at each intermediate node, the source having no incoming edges, and, most importantly, the absence of cycles, which forces a Directed Acyclic Graph (DAG) structure.\n\nFirst, I'm setting up my mental framework. I need to keep track of the flow balance at each vertex – how much flow is coming in versus going out.  I'm thinking of it like a \"deficit\" or \"surplus\" at each node.  The initial state of these vertices is critical, especially the source (vertex 1) which must have outgoing edges, and the sink (vertex n), which intuitively should have only incoming edges. I'm already seeing this as a potential bottleneck.\n\nThe \"no cycles\" rule is a major clue that I might be dealing with some form of topological ordering.  If I can find a way to direct the edges such that they always go \"forward\" in a topological sense, boom, I'm cycle-free.\n\nI'm starting to visualize this.  For edges connected to the source (vertex 1), I'm forced to direct them away from the source due to the problem definition, and these need to contribute to the overall balance.  Similarly, I'm assuming, and will verify with the solution constraints, that edges incident to the sink (vertex n) flow toward it.  These initial steps will define the overall balance of my flow and what I call the \"deficit\" at each node.\n\nThe \"meat\" of this problem seems to be the intermediate vertices. These nodes need to balance their incoming and outgoing flow. If I have a node with only one remaining edge to direct, that edge's direction is pre-determined by the required balance at that vertex – this feels like a greedy approach I can exploit.  If a vertex has one undirected edge, it should only have zero or one flow (unless something is wrong with the program).\n\nI'm thinking of a degree-based strategy, maintaining the number of undirected edges per vertex. If a vertex reaches a degree of 1 (only one edge undirected), I can immediately determine its flow direction based on its current flow balance, this will propagate to neighbors with one undirected degree. I'm imagining a queue to manage these ready vertices, allowing me to process these nodes in a logical order.\n\nMy revised plan involves two phases: first, handle edges connected to the source and sink, setting up their initial flows. Second, iterate on the middle nodes. In the process, I need to adjust the current flows at connected vertices after each direction decision, while ensuring that the current vertex balance is eventually zero (the flow will balance).\n\nI think I've got a workable strategy that's based on the key properties of the problem, the graph's balance and the inherent DAG requirements. Now, let's translate this into efficient and accurate code!\n",
    "response": "The problem asks us to direct edges in an undirected graph, given their flow volumes, such that the resulting directed graph represents a valid maximum flow from a source (vertex 1) to a sink (vertex n). The key conditions are:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the total flow entering `v` must equal the total flow leaving `v`.\n2.  **Source Condition:** Vertex 1 has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n\nThe problem guarantees that a solution always exists.\n\nLet's denote `current_balance[v]` as the net flow into vertex `v`. Initially, all `current_balance[v]` are 0. When an edge `u -> v` with flow `c` is directed, `current_balance[u]` decreases by `c` and `current_balance[v]` increases by `c`.\nAfter all edges are directed:\n*   For `1 < v < n`, `current_balance[v]` must be 0.\n*   For `v = 1`, `current_balance[1]` will be the negative of the total flow leaving the source.\n*   For `v = n`, `current_balance[n]` will be the total flow entering the sink.\n\nThe \"no cycles\" condition is crucial. It implies that there is a topological ordering of the vertices. This often suggests a processing order based on degrees or similar properties.\n\nLet's maintain `undecided_degree[v]` for each vertex `v`, which is the count of edges incident to `v` that have not yet been directed.\n\n**Algorithm Steps:**\n\n1.  **Initialization:**\n    *   Store edges: For each edge `i` with endpoints `a_i, b_i` and flow `c_i`, store it in an adjacency list for both `a_i` and `b_i`. An entry could be `(neighbor, flow_c, original_edge_index, is_original_a_node)`. `is_original_a_node` helps determine `0` or `1` for output.\n    *   `ans[m]`: An array to store the final direction for each edge. Initialize with -1 (undecided).\n    *   `current_balance[v]`: An array initialized to 0 for all `v`.\n    *   `undecided_degree[v]`: An array initialized to 0 for all `v`.\n    *   `undecided_edges_list[v]`: A list of `(neighbor, flow_c, original_edge_index)` for each vertex `v` that are still undirected.\n\n2.  **Pre-process Edges Connected to Source (1) and Sink (n):**\n    *   Iterate through all given `m` edges `(a_i, b_i, c_i, i)`:\n        *   If `a_i == 1`: The edge must be `1 -> b_i` (source has no incoming edges).\n            *   Set `ans[i] = 0`.\n            *   `current_balance[1] -= c_i`.\n            *   `current_balance[b_i] += c_i`.\n        *   Else if `b_i == 1`: The edge must be `1 -> a_i`.\n            *   Set `ans[i] = 1`.\n            *   `current_balance[1] -= c_i`.\n            *   `current_balance[a_i] += c_i`.\n        *   Else if `a_i == n`: The edge must be `b_i -> n` (to avoid cycles and satisfy sink property).\n            *   Set `ans[i] = 1`.\n            *   `current_balance[b_i] -= c_i`.\n            *   `current_balance[n] += c_i`.\n        *   Else if `b_i == n`: The edge must be `a_i -> n`.\n            *   Set `ans[i] = 0`.\n            *   `current_balance[a_i] -= c_i`.\n            *   `current_balance[n] += c_i`.\n        *   Else (both `a_i, b_i` are intermediate vertices, `1 < a_i, b_i < n`):\n            *   Add `(b_i, c_i, i)` to `undecided_edges_list[a_i]`.\n            *   Add `(a_i, c_i, i)` to `undecided_edges_list[b_i]`.\n            *   Increment `undecided_degree[a_i]` and `undecided_degree[b_i]`.\n\n3.  **Process Intermediate Vertices (1 < `v` < `n`):**\n    *   Create a queue `Q`.\n    *   For each vertex `v` from 2 to `n-1`:\n        *   If `undecided_degree[v] == 1`, add `v` to `Q`. This vertex has only one undirected edge left. Its balance must be fixed by this edge.\n\n    *   While `Q` is not empty:\n        *   Dequeue `v`.\n        *   If `undecided_degree[v]` is 0, it means this vertex has already been fully processed by its neighbors; continue.\n        *   Find the unique undirected edge `(u, c_val, idx)` for `v` from `undecided_edges_list[v]`. (This can be done by iterating `undecided_edges_list[v]` and checking `ans[idx] == -1`).\n        *   Let `(a_orig, b_orig)` be the original endpoints of edge `idx`.\n        *   **Direct the edge:**\n            *   If `current_balance[v] > 0`: Vertex `v` has received more flow than it has sent out *so far*. It needs to send `c_val` out.\n                *   Direct `v -> u`.\n                *   If `v == a_orig`, `ans[idx] = 0`. Else (`v == b_orig`), `ans[idx] = 1`.\n                *   `current_balance[v] -= c_val`.\n                *   `current_balance[u] += c_val`.\n            *   Else (`current_balance[v] < 0`): Vertex `v` has sent out more flow than it has received *so far*. It needs to receive `c_val`.\n                *   Direct `u -> v`.\n                *   If `v == a_orig`, `ans[idx] = 1`. Else (`v == b_orig`), `ans[idx] = 0`.\n                *   `current_balance[v] += c_val`.\n                *   `current_balance[u] -= c_val`.\n        *   **Update neighbors:**\n            *   `undecided_degree[v] -= 1`.\n            *   `undecided_degree[u] -= 1`.\n            *   If `u` is an intermediate vertex (`1 < u < n`) and `undecided_degree[u]` becomes 1, add `u` to `Q`.\n\n4.  **Output:** Print the values in the `ans` array.\n\n**Correctness Justification:**\n\n*   **Source/Sink Edges:** The directions for edges connected to 1 and n are fixed by the problem statement (\"vertex 1 has no incoming edges\") and the \"no cycles\" condition (implying n has no outgoing edges).\n*   **Intermediate Vertices:** For any intermediate vertex `v` (1 < `v` < `n`), its `current_balance[v]` must ultimately be 0. When `undecided_degree[v]` becomes 1, it means there's only one remaining edge incident to `v` whose direction is not yet determined. At this point, `current_balance[v]` must be either `c` or `-c` (where `c` is the flow of the last edge) for it to be possible to make the final balance 0. If `current_balance[v]` is `c`, `v` must send flow `c` out. If `current_balance[v]` is `-c`, `v` must receive flow `c`. This greedy choice is forced and ensures flow conservation for `v`.\n*   **Acyclicity:** This approach processes vertices in an order where the \"last\" edge for a vertex `v` is directed. This implicitly builds a topological order. When a vertex `v` is processed, its `current_balance` is non-zero, meaning it either needs to send flow out or receive flow. The direction chosen for the last edge `(v, u)` is always such that `v`'s balance is resolved. This process resembles a reverse topological sort (processing nodes with out-degree 0 or in-degree 0 in the residual graph), ensuring no cycles are formed. Since a solution is guaranteed to exist, this greedy strategy will work.\n\n**Example Walkthrough (First Example):**\n`n=3, m=3`\nEdges:\n1. `(3, 2, 10)`\n2. `(1, 2, 10)`\n3. `(3, 1, 5)`\n\nInitial: `current_balance = [0,0,0,0]`, `ans = [-1,-1,-1]` (indices 0,1,2 for edges)\n`undecided_degree = [0,0,0,0]`\n`undecided_edges_list = [[],[],[],[]]`\n\n**Step 2: Pre-process**\n*   Edge 1: `(3, 2, 10)`. Neither 1 nor 3. Add to `undecided_edges_list`.\n    `undecided_edges_list[3].append((2, 10, 0))`\n    `undecided_edges_list[2].append((3, 10, 0))`\n    `undecided_degree[3] = 1`, `undecided_degree[2] = 1`.\n*   Edge 2: `(1, 2, 10)`. `a_i = 1`. Direct `1 -> 2`.\n    `ans[1] = 0`.\n    `current_balance[1] -= 10` (`-10`).\n    `current_balance[2] += 10` (`10`).\n*   Edge 3: `(3, 1, 5)`. `b_i = 1`. Direct `1 -> 3`.\n    `ans[2] = 1`.\n    `current_balance[1] -= 5` (`-15`).\n    `current_balance[3] += 5` (`5`).\n\nAfter pre-processing:\n`ans = [-1, 0, 1]`\n`current_balance = [0, -15, 10, 5]` (index 0 is unused)\n`undecided_degree = [0,0,1,1]` (for nodes 1,2,3)\n`undecided_edges_list[2] = [(3, 10, 0)]`\n`undecided_edges_list[3] = [(2, 10, 0)]`\n\n**Step 3: Process Intermediate Vertices**\n`Q = []`\n`v=2`: `undecided_degree[2] = 1`. Add `2` to `Q`. `Q = [2]`\n`v=3`: `undecided_degree[3] = 1`. Add `3` to `Q`. `Q = [2, 3]`\n\nDequeue `v = 2`.\nUnique undirected edge for 2 is `(3, 10, 0)`. `u=3, c_val=10, idx=0`. Original `(a_orig=3, b_orig=2)`.\n`current_balance[2] = 10`. Since `10 > 0`, `2` needs to send flow out. Direct `2 -> 3`.\n`ans[0]` should be `0` if `2` is `a_orig`, `1` if `2` is `b_orig`. Here `2` is `b_orig`, so `ans[0] = 1`.\n`current_balance[2] -= 10` (`0`).\n`current_balance[3] += 10` (`5 + 10 = 15`).\nUpdate degrees:\n`undecided_degree[2] -= 1` (`0`).\n`undecided_degree[3] -= 1` (`0`).\n`undecided_degree[3]` became 0, so 3 is not added to Q.\n\nDequeue `v = 3`.\n`undecided_degree[3] = 0`. Continue.\n\n`Q` is empty.\n\nFinal `ans = [1, 0, 1]`.\nFinal `current_balance = [0, -15, 0, 15]`.\nThis matches the example output.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store all edges with their original index\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c, i))\n        # Store (neighbor, flow, original_edge_index, is_original_a_node)\n        # is_original_a_node helps determine 0/1 output\n        adj[u].append((v, c, i, True)) \n        adj[v].append((u, c, i, False))\n\n    ans = [-1] * m\n    current_balance = [0] * (n + 1)\n    \n    # undecided_edges_list[v] will store (neighbor, flow_c, original_edge_index)\n    # for edges incident to v that are not yet directed\n    undecided_edges_list = [[] for _ in range(n + 1)]\n    undecided_degree = [0] * (n + 1)\n\n    # Step 2: Pre-process edges connected to source (1) and sink (n)\n    for u, v, c, idx in edges_input:\n        if ans[idx] != -1: # Already processed if it's a duplicate or something (shouldn't happen with problem constraints)\n            continue\n\n        if u == 1: # Edge (1, v)\n            # Must be 1 -> v\n            ans[idx] = 0 # 0 means flow from original u to original v\n            current_balance[1] -= c\n            current_balance[v] += c\n        elif v == 1: # Edge (u, 1)\n            # Must be 1 -> u\n            ans[idx] = 1 # 1 means flow from original v to original u\n            current_balance[1] -= c\n            current_balance[u] += c\n        elif u == n: # Edge (n, v)\n            # Must be v -> n\n            ans[idx] = 1 # 1 means flow from original v to original u\n            current_balance[v] -= c\n            current_balance[n] += c\n        elif v == n: # Edge (u, n)\n            # Must be u -> n\n            ans[idx] = 0 # 0 means flow from original u to original v\n            current_balance[u] -= c\n            current_balance[n] += c\n        else: # Intermediate edge (u, v)\n            undecided_edges_list[u].append((v, c, idx))\n            undecided_edges_list[v].append((u, c, idx))\n            undecided_degree[u] += 1\n            undecided_degree[v] += 1\n\n    # Step 3: Process intermediate vertices (1 < v < n)\n    q = []\n    for v in range(2, n): # Iterate through intermediate vertices\n        if undecided_degree[v] == 1:\n            q.append(v)\n    \n    head = 0\n    while head < len(q):\n        v = q[head]\n        head += 1\n\n        if undecided_degree[v] == 0: # This vertex was already fully processed by its neighbor\n            continue\n\n        # Find the unique undirected edge for v\n        # Iterate through its potential undecided edges to find the one not yet directed\n        u_neighbor = -1\n        c_val = -1\n        idx = -1\n        is_original_a_node_for_v = False # True if v is the 'a' in (a,b,c,idx) for this edge\n\n        for neighbor, flow_c, edge_idx, original_a_node_flag in adj[v]:\n            if ans[edge_idx] == -1: # Found the undecided edge\n                u_neighbor = neighbor\n                c_val = flow_c\n                idx = edge_idx\n                is_original_a_node_for_v = original_a_node_flag\n                break\n        \n        # Direct the edge (v, u_neighbor) with flow c_val\n        if current_balance[v] > 0: # v has more incoming flow, needs to send c_val out: v -> u_neighbor\n            if is_original_a_node_for_v:\n                ans[idx] = 0\n            else:\n                ans[idx] = 1\n            current_balance[v] -= c_val\n            current_balance[u_neighbor] += c_val\n        else: # current_balance[v] < 0. v has more outgoing flow, needs to receive c_val: u_neighbor -> v\n            if is_original_a_node_for_v:\n                ans[idx] = 1\n            else:\n                ans[idx] = 0\n            current_balance[v] += c_val\n            current_balance[u_neighbor] -= c_val\n        \n        # Update degrees and add neighbor to queue if applicable\n        undecided_degree[v] -= 1\n        undecided_degree[u_neighbor] -= 1\n\n        if 1 < u_neighbor < n and undecided_degree[u_neighbor] == 1:\n            q.append(u_neighbor)\n            \n    # Step 4: Output results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store all edges with their original index\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c, i))\n        # Store (neighbor, flow, original_edge_index, is_original_a_node)\n        # is_original_a_node helps determine 0/1 output\n        adj[u].append((v, c, i, True)) \n        adj[v].append((u, c, i, False))\n\n    ans = [-1] * m\n    current_balance = [0] * (n + 1)\n    \n    # undecided_edges_list[v] will store (neighbor, flow_c, original_edge_index)\n    # for edges incident to v that are not yet directed\n    undecided_edges_list = [[] for _ in range(n + 1)]\n    undecided_degree = [0] * (n + 1)\n\n    # Step 2: Pre-process edges connected to source (1) and sink (n)\n    for u, v, c, idx in edges_input:\n        if ans[idx] != -1: # Already processed if it's a duplicate or something (shouldn't happen with problem constraints)\n            continue\n\n        if u == 1: # Edge (1, v)\n            # Must be 1 -> v\n            ans[idx] = 0 # 0 means flow from original u to original v\n            current_balance[1] -= c\n            current_balance[v] += c\n        elif v == 1: # Edge (u, 1)\n            # Must be 1 -> u\n            ans[idx] = 1 # 1 means flow from original v to original u\n            current_balance[1] -= c\n            current_balance[u] += c\n        elif u == n: # Edge (n, v)\n            # Must be v -> n\n            ans[idx] = 1 # 1 means flow from original v to original u\n            current_balance[v] -= c\n            current_balance[n] += c\n        elif v == n: # Edge (u, n)\n            # Must be u -> n\n            ans[idx] = 0 # 0 means flow from original u to original v\n            current_balance[u] -= c\n            current_balance[n] += c\n        else: # Intermediate edge (u, v)\n            undecided_edges_list[u].append((v, c, idx))\n            undecided_edges_list[v].append((u, c, idx))\n            undecided_degree[u] += 1\n            undecided_degree[v] += 1\n\n    # Step 3: Process intermediate vertices (1 < v < n)\n    q = []\n    for v in range(2, n): # Iterate through intermediate vertices\n        if undecided_degree[v] == 1:\n            q.append(v)\n    \n    head = 0\n    while head < len(q):\n        v = q[head]\n        head += 1\n\n        if undecided_degree[v] == 0: # This vertex was already fully processed by its neighbor\n            continue\n\n        # Find the unique undirected edge for v\n        # Iterate through its potential undecided edges to find the one not yet directed\n        u_neighbor = -1\n        c_val = -1\n        idx = -1\n        is_original_a_node_for_v = False # True if v is the 'a' in (a,b,c,idx) for this edge\n\n        for neighbor, flow_c, edge_idx, original_a_node_flag in adj[v]:\n            if ans[edge_idx] == -1: # Found the undecided edge\n                u_neighbor = neighbor\n                c_val = flow_c\n                idx = edge_idx\n                is_original_a_node_for_v = original_a_node_flag\n                break\n        \n        # Direct the edge (v, u_neighbor) with flow c_val\n        if current_balance[v] > 0: # v has more incoming flow, needs to send c_val out: v -> u_neighbor\n            if is_original_a_node_for_v:\n                ans[idx] = 0\n            else:\n                ans[idx] = 1\n            current_balance[v] -= c_val\n            current_balance[u_neighbor] += c_val\n        else: # current_balance[v] < 0. v has more outgoing flow, needs to receive c_val: u_neighbor -> v\n            if is_original_a_node_for_v:\n                ans[idx] = 1\n            else:\n                ans[idx] = 0\n            current_balance[v] += c_val\n            current_balance[u_neighbor] -= c_val\n        \n        # Update degrees and add neighbor to queue if applicable\n        undecided_degree[v] -= 1\n        undecided_degree[u_neighbor] -= 1\n\n        if 1 < u_neighbor < n and undecided_degree[u_neighbor] == 1:\n            q.append(u_neighbor)\n            \n    # Step 4: Output results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 4319,
        "thoughts_token_count": 5106
    }
}