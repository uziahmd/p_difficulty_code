{
    "start": 1758289052.0047445,
    "end": 1758291178.6428854,
    "start-formatted": "2025-09-19 22:37 KST",
    "end-formatted": "2025-09-19 23:12 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"TV Game,\" and from the description, I need to find a sequence of moves for Homer and Marge that maximizes their total prize. \n\nLet me try to understand the problem step by step. The game involves two players taking turns picking digits from a string A. Each player makes exactly n moves. On each turn, the current player takes the leftmost digit of A and appends it to their number. Then that digit is removed from A. Initially, both S1 and S2 are empty. At the end, the first player gets S1 dollars and the second gets S2 dollars. We need to maximize the sum of these two numbers.\n\nWait, but how do we determine the maximum sum? Oh right, because the order in which the digits are picked affects the numerical values of S1 and S2. So our goal is to assign digits to S1 and S2 in such a way that when converted into numbers, their sum is as large as possible.\n\nHmm, but wait, each digit can be part of either S1 or S2. But since each digit is chosen in a specific order, the arrangement of H and M (Homer and Marge) determines how the digits are split between the two.\n\nSo the approach here is to decide for each position whether it's taken by H or M, ensuring that each takes exactly n digits. And then calculate the sum of their numbers, trying all possibilities to find the maximum.\n\nBut with n up to 18, 2n is 36 digits. Trying all possible sequences would be computationally expensive because the number of possibilities is C(36,18), which is around 9e10—way too big for brute force.\n\nSo brute force isn't feasible. We need a smarter approach.\n\nLet me think about dynamic programming. Maybe we can model the state based on how many digits each has taken so far and which digits have been processed.\n\nWait, but considering the order of processing is important. Each digit is taken in the order they appear in A, left to right. So at any point, the next available digit is the next leftmost in the remaining A string.\n\nSo perhaps the state can be represented by the current position in the string, and the count of digits each player has taken. For each state, we can track the maximum sum achievable from that point onwards.\n\nBut even then, with 36 positions and n up to 18, the state space might be manageable.\n\nLet's formalize the state:\n\ndp[i][h][m] = the maximum sum achievable when we have processed i digits, where h is the number of digits taken by H, and m is the number taken by M. Wait, but h + m = i. So maybe we can represent it as i, and h. Since m = i - h, but only if i >= h.\n\nWait, no. Because initially, each player must take exactly n digits. So h ranges from 0 to n, and m ranges from 0 to n, but at any step, h + m = i, which is the number of digits taken so far.\n\nWait, but for each step, the next digit is either taken by H or M. So for each state, the next step is choosing which player takes the current digit.\n\nYes, that makes sense. So the DP state can be dp[i][h][m], representing the maximum sum achievable after taking i digits, with h assigned to H and m to M. But since i = h + m, perhaps the state can be simplified as (h, m) along with the current position in the string.\n\nWait, but the string is processed sequentially. So for each state (h, m), the next digit to process is at position i = h + m. So the state transitions will depend on the current digit and the choices made.\n\nHmm, let's think about the initial state: h=0, m=0, and the next digit is at position 0.\n\nAt each step, for the current digit (digit at position i), we have two choices: assign it to H or to M, provided that h < n and m < n respectively. Then, we add the value of that digit multiplied by 10^{position in their number} to their respective sums.\n\nWait, but the position in their number depends on how many digits they have already. For example, if H has already taken k digits, then the new digit is added as the (k+1)th digit, so it contributes digit * 10^k.\n\nAh, right. So the value of each digit depends on its place in the respective numbers. So the state needs to track not just how many digits each has taken, but also the current length of each number, because the place value is determined by that.\n\nWait, but the place value for a digit depends on how many digits are already present in that player's number. So for example, if H has taken h digits before, then the next digit he takes will be in the (h+1)th position, contributing 10^(h) * digit.\n\nBut wait, the first digit is the most significant, right? Like, the first digit is multiplied by 10^(n-1), then the next by 10^(n-2), etc., for each player's number. Because each number has n digits.\n\nWait, no. Because each player's number is built digit by digit. For example, if a player takes digits in the order d1, d2, ..., dn, then their number is d1*10^{n-1} + d2*10^{n-2} + ... + dn*10^0.\n\nWait, no. Wait, each time a digit is added to the number, it's placed at the end, right? So for example, the first digit is the most significant, and each subsequent digit adds to the lower significant places.\n\nYes, because each digit is appended to the end. So for S1, the first digit is the highest place, then the next is the next lower, etc. So for S1, which is n digits long, the first digit is multiplied by 10^{n-1}, the second by 10^{n-2}, etc.\n\nSo for each digit assigned to a player, its contribution depends on the number of digits they have already collected. For example, the first digit assigned to H is multiplied by 10^{n-1}, the next by 10^{n-2}, etc., and the last one by 10^0.\n\nSo, in the DP state, for each (h, m), we need to know how many digits each has already taken, so that when a new digit is added, we can compute its contribution correctly.\n\nWait, but the DP state can track h and m, but for each digit added, the position in the number increases. So perhaps the state needs to include h and m, but also the current 'power' for each player. Hmm, but that would complicate things.\n\nAlternatively, perhaps we can precompute for each position in the string and each possible h and m, the best possible sum.\n\nWait, let me think again. Let's model the state as (current index, h, m). The current index is the position in the string A that we're about to process. At each step, the digit is A[i], and we can choose to assign it to H or to M, provided that h < n and m < n respectively.\n\nWhen assigning to H, the contribution is A[i] * 10^{h}, because H has h digits so far (each digit added to H's number is in the next lower position, so the first digit contributes 10^{n-1}, but h starts at 0, so maybe the exponent is n-1 - h? Wait, let's clarify.\n\nWait, suppose H has taken h digits. The next digit will be the (h+1)th digit, so its place value is 10^{n - (h+1)}, because the first digit is 10^{n-1}, the second 10^{n-2}, etc. So the exponent for the current digit when added to H is (n-1) - (h) - 1 = n - h - 2? No, wait, maybe I'm getting confused.\n\nWait, no. Let's say n is 3.\n\nHomer's number S1 is built as follows: first digit is d1, which is the most significant (10^2), then d2 (10^1), then d3 (10^0).\n\nSo when H takes his first digit, it's multiplied by 10^{2} (since n-1=2). When he takes the second digit, it's multiplied by 10^1, and third by 10^0.\n\nSo for a given h, the next digit contributes 10^{n-1 - h}. Because after h digits, the next is the (h+1)th, which is multiplied by 10^{n-1 - h}.\n\nWait, for h=0, it's 10^{n-1}; for h=1, 10^{n-2}, etc.\n\nYes, that makes sense.\n\nSo the contribution of the current digit when assigned to H is digit * 10^{n-1 - h}.\n\nSimilarly, when assigned to M, the contribution is digit * 10^{n-1 - m}.\n\nSo, for the DP state, we need to know h and m, so that we can calculate the contribution of the current digit when it's assigned to either player.\n\nThe DP transition would then be:\n\nFor each state (i, h, m), where i is the current index being considered, h is the number of digits taken by H so far, and m is the number taken by M so far.\n\nIf h < n, we can assign the current digit to H, adding digit * 10^{n-1 - h} to the sum, and move to state (i+1, h+1, m).\n\nSimilarly, if m < n, assign to M, adding digit * 10^{n-1 - m} to the sum, and move to state (i+1, h, m+1).\n\nWe want to choose the option (H or M) that gives the maximum total sum.\n\nThe base case is when i == len(A), which is 2n digits. At that point, h must equal n and m must equal n. So the sum is the sum of the two numbers S1 and S2.\n\nWait, but how do we compute the sum of S1 and S2? Or perhaps, the DP should track the sum as it's built, rather than computing it at the end.\n\nWait, no. The sum is the sum of S1 and S2, which are the numbers formed by the digits assigned to H and M. But during the DP, it's easier to track the sum as we build it. So each transition adds the contribution of the current digit to the sum.\n\nSo the DP will store the maximum sum achievable up to that state.\n\nSo the recurrence is:\n\ndp[i][h][m] = max(\n    (if h < n) (digit * 10^{n-1 - h} + dp[i+1][h+1][m]),\n    (if m < n) (digit * 10^{n-1 - m} + dp[i+1][h][m+1])\n)\n\nThe initial state is dp[0][0][0] = 0.\n\nBut wait, when i is 0, we're processing the first digit. So for each state, the next index is i+1.\n\nNow, considering the size of the DP table. The number of states is (2n) * (n+1) * (n+1). For n=18, 2n=36, so 36 * 19 * 19 = 36 * 361 = ~13,000. That's manageable.\n\nBut we need to precompute the exponents for each possible h and m. For each possible h, the exponent is n-1 - h. So for each h in 0..n, the exponent is 10^{n-1 - h}. Similarly for m.\n\nWait, but in the DP, for each state, when considering assigning the current digit to H, the exponent is n-1 - h. So we can precompute a 2D array of exponents for h and m.\n\nWait, perhaps precompute an array pow_h where pow_h[h] = 10^{n-1 -h}, for h from 0 to n. Similarly, pow_m[m] = 10^{n-1 -m}.\n\nYes, that's manageable.\n\nSo the steps for solving the problem are:\n\n1. Precompute pow_h and pow_m arrays.\n   - For h in 0..n: pow_h[h] = 10 ** (n-1 - h)\n   - For m in 0..n: pow_m[m] = 10 ** (n-1 - m)\n\n2. Initialize a DP table. Since n is up to 18, the table can be 2n x (n+1) x (n+1). But since each state only depends on the next index, perhaps we can use a 2D array and update it in a bottom-up manner.\n\n3. Start from i=0, h=0, m=0, with sum 0.\n\n4. For each state (i, h, m), consider the next digit(s) and assign them to H or M, updating the sum accordingly.\n\n5. After processing all digits, the maximum sum is achieved when h = n and m = n, which is when all digits are assigned.\n\n6. Once the maximum sum is found, we need to reconstruct the path of H and M assignments to get that sum. This requires backtracking through the DP table.\n\nBut wait, the DP approach gives us the maximum sum, but we also need to find the actual sequence of H and M choices that leads to this sum. So we'll need to track the decisions made along the way.\n\nHmm, this complicates things a bit. Because for each state, we need to know not just the maximum sum, but also which choice (H or M) led to it. Otherwise, when multiple paths yield the same sum, we can't determine which one to take, unless we have a way to break ties.\n\nBut perhaps, in the DP, for each state, we can store the best action (H or M) that leads to the maximum sum. So for each state (i, h, m), we store whether the last digit was assigned to H or M.\n\nThis way, once the maximum sum is known, we can backtrack from the final state to reconstruct the sequence.\n\nSo the DP will have two parts: the maximum sum and the decision (H or M) that led to it.\n\nSo the state becomes:\n\ndp[i][h][m] = (max_sum, decision), where decision is 'H' or 'M'.\n\nSo the transitions become:\n\nFor state (i, h, m):\n\n- If h < n, compute the sum if we assign the current digit to H: digit * pow_h[h] + next_state_sum. Compare this with the current max_sum and possibly update.\n\n- Similarly for M.\n\nWait, but the next_state_sum is the value from dp[i+1][h+1][m], which is the sum after processing the next digit.\n\nSo, for each state (i, h, m), the possible transitions are:\n\n- Assign to H: if h < n, then the next state is (i+1, h+1, m). The added value is digit * pow_h[h].\n\n- Assign to M: if m < n, then the next state is (i+1, h, m+1). The added value is digit * pow_m[m].\n\nWe choose the transition that gives the higher sum, and record the decision (H or M) that led to it.\n\nSo the DP can be implemented as follows:\n\nInitialize dp[2n][n][n] as the sum of S1 and S2, but actually, during the DP, it's built up step by step.\n\nNow, the challenge is to implement this efficiently.\n\nAnother point to consider: the digits in A are processed in order. So the DP proceeds from left to right, processing each digit in sequence.\n\nLet me outline the steps more concretely.\n\nFirst, read the input: n and A as a string.\n\nThen, precompute pow_h and pow_m.\n\nThen, create a DP table where each entry is a tuple (max_sum, choice), where choice is 'H' or 'M'. The initial state is dp[0][0][0] = (0, None), since no digits have been processed yet.\n\nWait, no: at i=0, we're processing the first digit. So for i=0, h=0, m=0, the next digit is A[0]. So for each possible state, we process A[i].\n\nBut perhaps the DP is filled in a bottom-up manner, starting from i=2n and moving backward.\n\nWait, perhaps it's better to process the digits from left to right, and for each position i, compute the possible states for (i, h, m).\n\nWait, the index i represents the number of digits processed so far. So for each i from 0 to 2n, and for each h from 0 to min(i, n), and m from 0 to min(i, n), but with h + m = i.\n\nWait, no. Because h + m must equal i, since each step processes one digit.\n\nSo for each i, h can range from 0 to min(i, n), and m is i - h, but ensuring that m <=n.\n\nSo for each i, h can be from max(0, i - n) to min(i, n).\n\nBecause m = i - h must be <=n, so h >= i -n.\n\nWait, because m = i - h <=n → h >= i -n.\n\nSo for each i, h can be in [max(0, i -n), min(n, i)].\n\nAnd for each h in this range, m is i - h, which must be <=n.\n\nSo, the DP can be filled in a bottom-up manner, starting from i=0 to i=2n.\n\nWait, but wait: when i is 0, we're at the first digit, which is A[0]. For each possible state (i, h, m), which is (0, 0, 0), we can choose to assign A[0] to H or M, provided h and m are less than n.\n\nSo, for i=0, the next digit is A[0], and the state transitions are:\n\nIf assign to H: new state is (1, 1, 0), sum += A[0] * pow_h[0]\n\nIf assign to M: new state is (1, 0, 1), sum += A[0] * pow_m[0]\n\nSo, the DP for i=0 is straightforward.\n\nThen, for i=1, we process A[1], and for each possible (h, m) pair that sum to 1, we consider the possible transitions.\n\nSo, the plan is:\n\n- Precompute pow_h and pow_m.\n\n- Initialize a DP table, perhaps using a dictionary or a 3D list.\n\n- Iterate i from 0 to 2n:\n\n   For each possible h in the valid range for i:\n\n      m = i - h\n\n      if h >n or m >n: skip.\n\n      current_digit = A[i]\n\n      if i is 2n: continue, since no more digits to process.\n\n      options = []\n\n      if h <n:\n\n          new_h = h +1\n\n          new_sum = current_digit * pow_h[h] + dp[i+1][new_h][m].sum\n\n          options.append( ('H', new_sum) )\n\n      if m <n:\n\n          new_m = m +1\n\n          new_sum = current_digit * pow_m[m] + dp[i+1][h][new_m].sum\n\n          options.append( ('M', new_sum) )\n\n      if options is not empty:\n\n          choose the option with maximum new_sum.\n\n          dp[i][h][m] = (max_sum, choice)\n\n      else:\n\n          // no options? Not possible, since h + m =i < 2n.\n\n          pass.\n\n- After filling the DP table, the final state is dp[2n][n][n], which gives the maximum sum.\n\n- Then, reconstruct the path by backtracking from this state.\n\nBut wait, how do we handle the DP table storage? Because for each i, h, m, we need to store the maximum sum and the choice.\n\nIn Python, perhaps using a 3D list: dp[i][h][m] = (sum, choice).\n\nBut considering that for each i, h and m are limited, this should be manageable.\n\nWait, but in Python, initializing a 3D list for i up to 36, h up to 18, m up to 18 is feasible.\n\nSo, let's think about the data structure.\n\nWe can represent the DP as a list of dictionaries or a 3D list. Alternatively, for each i, have a 2D list for h and m.\n\nSo, the code could look like:\n\nn = int(input())\nA = input().strip()\ndigits = [int(c) for c in A]\n\npow_h = [10**(n-1 - h) for h in range(n+1)]\npow_m = [10**(n-1 - m) for m in range(n+1)]\n\nmax_i = 2*n\ndp = [[[ (0, None) for _ in range(n+1)] for __ in range(n+1)] for ___ in range(max_i+1)]\n\n# Base case: after all digits are processed, sum is 0\ndp[max_i][n][n] = (0, None)\n\nfor i in range(max_i-1, -1, -1):\n    for h in range(0, n+1):\n        m = i - h\n        if m <0 or m >n:\n            continue\n        # For state (i, h, m)\n        current_digit = digits[i]\n        options = []\n        if h <n:\n            new_h = h +1\n            if new_h >n:\n                pass\n            else:\n                next_sum, next_choice = dp[i+1][new_h][m]\n                added = current_digit * pow_h[h]\n                total = added + next_sum\n                options.append( (total, 'H') )\n        if m <n:\n            new_m = m +1\n            if new_m >n:\n                pass\n            else:\n                next_sum, next_choice = dp[i+1][h][new_m]\n                added = current_digit * pow_m[m]\n                total = added + next_sum\n                options.append( (total, 'M') )\n        if not options:\n            # impossible state\n            continue\n        # choose the option with maximum sum\n        max_sum = max(options, key=lambda x: x[0])[0]\n        for s, choice in options:\n            if s == max_sum:\n                dp[i][h][m] = (max_sum, choice)\n                break\n\n# Now, we have dp[0][0][0], which is the initial state\n# But wait, no. The initial state is (i=0, h=0, m=0), but the DP for i=0 may not have been processed yet. Wait, in the above code, i is processed from max_i-1 down to 0. So for i=0, the code runs.\n\n# Wait, perhaps the initial setup is wrong. Because in the code above, for i from max_i-1 downto 0, and for each state (i, h, m), the transitions are to i+1.\n\nWait, but in the code, for i= max_i-1 downto 0, and for each (i, h, m), we process the current digit (digits[i]) and compute the next states.\n\nWait, but for i=0, the next state is i=1.\n\nBut for the base case, when i=2n, h=n, m=n, the sum is 0.\n\nSo the code should correctly compute all the states.\n\nOnce the DP is filled, the maximum sum is at dp[0][0][0][0], but wait, no. Because the initial state is (i=0, h=0, m=0), which hasn't processed any digits. So the sum is 0.\n\nBut in the code, the DP starts from i=2n and works backwards. So for each i, h, m, the state is processed.\n\nBut perhaps the initial setup is incorrect. Let me think again.\n\nWait, perhaps the code should start from i=0 and go up to 2n. But that would require a different approach.\n\nAlternatively, perhaps the code should process i from 0 to 2n, but for each i, process h and m such that h + m =i.\n\nWait, perhaps the initial approach is flawed. Let me think about the correct way to fill the DP.\n\nLet me think about the indices. The digits are 0-based in the string, from 0 to 2n-1. So for each i in 0..2n-1, we process the i-th digit.\n\nWait, perhaps the DP should be filled from i=0 to i=2n-1, and for each step, compute the next states.\n\nSo, for each i from 0 to 2n-1:\n\n   current_digit = A[i]\n\n   for h in 0 to min(i, n):\n\n       m = i - h\n\n       if m >n: continue\n\n       if h <n:\n\n           new_h = h +1\n\n           next_state_sum = dp[i+1][new_h][m].sum\n\n           option1 = current_digit * pow_h[h] + next_state_sum\n\n       else:\n\n           option1 = None\n\n       if m <n:\n\n           new_m = m +1\n\n           next_state_sum = dp[i+1][h][new_m].sum\n\n           option2 = current_digit * pow_m[m] + next_state_sum\n\n       else:\n\n           option2 = None\n\n       if both options are possible:\n\n           choose the maximum between option1 and option2\n\n       elif one option is possible:\n\n           choose that option\n\n       else:\n\n           no options, which is impossible.\n\n       set dp[i][h][m] to the chosen option.\n\nWait, but how to manage the DP as a 3D array. Because for each i, the next state is i+1.\n\nBut this suggests that the DP can be built iteratively, processing i from 0 to 2n-1.\n\nBut storing a 3D array for i up to 36 is manageable.\n\nSo the revised plan is:\n\n- Precompute pow_h and pow_m.\n\n- Initialize dp as a 3D array of size (2n+1) x (n+1) x (n+1), each cell containing (sum, choice). Initially, all cells are (0, None).\n\n- Set dp[2n][n][n] = (0, None).\n\n- For i from 0 to 2n-1:\n\n   current_digit = A[i]\n\n   for h in 0 to min(i, n):\n\n       m = i - h\n\n       if m >n: continue\n\n       options = []\n\n       if h <n:\n\n           new_h = h +1\n\n           if new_h >n: continue\n\n           if dp[i+1][new_h][m].sum is not None:\n\n               added = current_digit * pow_h[h]\n\n               total = added + dp[i+1][new_h][m].sum\n\n               options.append( (total, 'H') )\n\n       if m <n:\n\n           new_m = m +1\n\n           if new_m >n: continue\n\n           if dp[i+1][h][new_m].sum is not None:\n\n               added = current_digit * pow_m[m]\n\n               total = added + dp[i+1][h][new_m].sum\n\n               options.append( (total, 'M') )\n\n       if not options:\n\n           // impossible state, since each digit must be assigned\n\n           // but since h + m = i, and i < 2n, there must be at least one option.\n\n       else:\n\n           max_option = max(options, key=lambda x: x[0])\n\n           dp[i][h][m] = (max_option[0], max_option[1])\n\nSo, for each i, h, m, we process the current digit and update the dp.\n\nWait, but in the initial setup, dp[0][0][0] is (0, None). Then, for i=0, h=0, m=0, current_digit is A[0], and we can assign it to H or M, provided h <n and m <n.\n\nSo this approach seems correct.\n\nOnce the DP is filled, the maximum sum is at dp[0][0][0].sum, but wait, no. Because after processing all 2n digits, the sum is in dp[2n][n][n]. So in the initial setup, dp[2n][n][n] is (0, None), which is correct.\n\nWait, no. Because when all 2n digits are processed, h must be n, m must be n. So the sum is the sum of S1 and S2.\n\nBut in the DP, for each state (i, h, m), the sum is the sum of the contributions of the digits assigned to H and M so far.\n\nSo when i=2n, h=n, m=n, the sum is the sum of all digits assigned to H and M, which is the total sum of S1 and S2.\n\nWait, no. Because S1 is the number formed by the digits assigned to H, and S2 is the number formed by the digits assigned to M. So the sum is S1 + S2.\n\nBut during the DP, each digit's contribution is added to the respective sum. So for each digit assigned to H, it's added as its place value to S1, and for M, to S2. So the DP's sum is the total of S1 and S2.\n\nWait, but in the DP, the sum is S1 + S2. So the maximum sum is what we're trying to find.\n\nThus, the maximum sum is dp[0][0][0].sum, but wait, no. Because when we process all digits, the sum is stored in dp[2n][n][n]. So after processing all digits, the maximum sum is the sum stored in dp[2n][n][n]. But in the initial setup, that state was set to (0, None). So that's incorrect.\n\nWait, perhaps I messed up the initial setup.\n\nWait, when all digits are processed, i=2n, and h =n, m=n. So the sum is S1 + S2.\n\nBut in the DP, the sum is built incrementally. So, during the processing, each assignment adds to the sum.\n\nThus, the final sum is in dp[2n][n][n]. So the maximum sum is dp[2n][n][n].sum.\n\nBut in the initial setup, I set dp[2n][n][n] = (0, None), which is wrong. It should instead be the sum of all digits assigned, which is S1 + S2.\n\nWait, but how is that computed?\n\nNo, wait. Let's think about the DP. Each time a digit is assigned to a player, its contribution is added to their sum. So for each state (i, h, m), the sum is the sum of all digits assigned to H and M up to that point.\n\nThus, when i=2n, h=n, m=n, the sum is S1 + S2.\n\nTherefore, the initial setup for dp[2n][n][n] should be the sum of all digits, but that's not correct because the sum is built during the DP.\n\nWait, no. The initial setup for dp[2n][n][n] is (0, None), meaning that no digits have been processed yet. But in reality, when i=2n, all digits have been processed, so the sum is S1 + S2.\n\nBut in the DP, the sum is built incrementally. So when i=2n, the sum is the sum of all digits processed, which is S1 + S2.\n\nSo the initial setup for dp[2n][n][n] is (sum, choice), but when i=2n, there are no more digits to process. So the sum is indeed S1 + S2.\n\nWait, perhaps I'm overcomplicating. Let me proceed step by step.\n\nSuppose n=1, and A is '99'.\n\nThen, each player takes one digit. The maximum sum is achieved by assigning the larger digits to the higher place values.\n\nSo for the two digits '9' and '9':\n\nHomer takes the first '9', which is the higher place (10^0, since n=1, pow_h[0] =10^(1-1-0)=10^0=1). So S1 is 9, S2 is 9. Sum is 18.\n\nAlternatively, if M takes the first '9', same result.\n\nBut the problem is to maximize the sum, so the order doesn't matter here.\n\nWait, no: the sum is the same regardless of who takes which digit. Because both have the same value.\n\nBut if the digits were different, like '91', then assigning the '9' to H would give S1=9, S2=1 → sum 10. Assigning the '9' to M would give S1=1, S2=9 → sum 10. So same result.\n\nWait, but in another example: '21'.\n\nIf n=1, the digits are '2' and '1'.\n\nOption 1: H takes '2', M takes '1' → S1=2, S2=1 → sum 3.\n\nOption 2: H takes '1', M takes '2' → S1=1, S2=2 → sum 3.\n\nSame sum.\n\nBut what about n=2 and A='9999'? The maximum sum is achieved by assigning the first two 9s to H and M alternately, but wait, no, because the place values for each player are higher for the earlier digits.\n\nWait, for n=2, each player's number is two digits.\n\nDigits: 9 9 9 9.\n\nHomer's number can be 99, M's can be 99. Sum is 198.\n\nOr, H takes the first two 9s, M takes the last two. Same sum.\n\nSo, the sum is fixed regardless of the assignment.\n\nWait, but what if the digits vary? Like A='9911' as in the sample input.\n\nSample Input:\n\nn=2\n\nA=9911.\n\nWait, the sample output is 'HMHM'.\n\nWait, let's compute:\n\nHomer takes the first '9' (digit 0) → contributes 10^1 (since n=2, pow_h[0]=10^(2-1-0)=10^1=10) → 9*10=90.\n\nThen M takes the next '9' → pow_m[0]=10^(2-1-0)=10 → 9*10=90. So sum so far is 180.\n\nThen Homer takes the '1' (digit 2) → contributes 10^(2-1 -1)=10^0=1 → 1*1=1. Sum now 181.\n\nM takes the '1' (digit 3) → contributes 10^(2-1-1)=1 → 1. Sum 182.\n\nWait, but the sample output is HM HM, which is 'H M H M' → the sum is 90+90 + 1 +1 = 182.\n\nAlternatively, if H had taken the second '9' and M the first, it might have been the same.\n\nWait, but in any case, the sum is 90 + 90 +1 +1= 182.\n\nBut perhaps the maximum sum is 182, which is what the sample shows.\n\nWait, but according to the sample output, the sequence is 'HMHM', which corresponds to H, M, H, M. So the digits are assigned as 9 (H), 9 (M), 1 (H), 1 (M). So S1 is 91, S2 is 91. Sum is 182.\n\nBut what's the alternative? Suppose H takes 9, 1 → 91, M takes 9, 1 →91. Same sum.\n\nSo the sum is fixed as 182 in this case.\n\nSo, the DP approach is correct in finding the maximum sum.\n\nBut the issue is reconstructing the path.\n\nSo, after filling the DP table, to get the sequence of choices (H or M), we need to backtrack from the final state (2n, n, n) to (0,0,0).\n\nBut wait, the final state is (2n, n, n), and from there, we can backtrack to (2n-1, n-1, n) or (2n-1, n, n-1), depending on which choice was made.\n\nWait, no. Because for the final state, the last digit was processed. So the last state before the final is either (2n-1, n, n) or (2n-1, n, n) if the last digit was assigned to M.\n\nWait, perhaps the backtracking function will start from (2n, n, n) and look at the previous state.\n\nWait, perhaps the reconstruction function will go through the DP states, starting from the end, and for each state, determine whether the last digit was assigned to H or M.\n\nSo, in code terms:\n\nsequence = []\ncurrent_state = (2n, n, n)\nwhile current_state != (0, 0, 0):\n    i, h, m = current_state\n    if h == n and m ==n:\n        break\n    # Determine whether the last digit was assigned to H or M.\n    if h ==n:\n        # last digit was assigned to M\n        sequence.append('M')\n        current_state = (i-1, h, m-1",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for two players, Homer and Marge, to maximize their total prize in a TV game. The game involves taking turns to pick digits from a given number, and each player must make exactly `n` moves. The goal is to maximize the sum of the numbers formed by the digits each player collects.\n\n### Approach\n1. **Problem Analysis**:\n   - The problem can be modeled as a dynamic programming (DP) problem where we need to decide the optimal order of moves for each player to maximize their combined score.\n   - Each digit contributes to the score based on its position in the resulting number, which depends on how many digits each player has collected so far.\n\n2. **Dynamic Programming State**:\n   - Define `dp[i][h][m]` as a tuple where `i` is the current digit being processed, `h` is the number of digits taken by Homer, and `m` is the number of digits taken by Marge. The tuple stores the maximum sum achievable up to that state and the move that led to it ('H' or 'M').\n\n3. **Transition**:\n   - For each digit, decide whether to assign it to Homer or Marge, provided neither has exceeded their allowed moves (`n`). Compute the contribution of the digit to the respective player's number and update the DP state accordingly.\n\n4. **Reconstruction**:\n   - After computing the DP table, backtrack from the final state to determine the sequence of moves that led to the maximum sum.\n\n### Solution Code\n```python\nn = int(input())\nA = input().strip()\ndigits = [int(c) for c in A]\n\npow_h = [10 ** (n - 1 - h) for h in range(n + 1)]\npow_m = [10 ** (n - 1 - m) for m in range(n + 1)]\n\nmax_i = 2 * n\ndp = [[[None for _ in range(n + 1)] for __ in range(n + 1)] for ___ in range(max_i + 1)]\n\n# Initialize the final state\ndp[max_i][n][n] = (0, None)\n\nfor i in range(max_i - 1, -1, -1):\n    for h in range(n + 1):\n        m = i - h\n        if m < 0 or m > n:\n            continue\n        current_digit = digits[i]\n        options = []\n        # Assign to H\n        if h < n:\n            new_h = h + 1\n            if new_h <= n:\n                next_sum, next_choice = dp[i + 1][new_h][m]\n                added = current_digit * pow_h[h]\n                total = added + next_sum\n                options.append((total, 'H'))\n        # Assign to M\n        if m < n:\n            new_m = m + 1\n            if new_m <= n:\n                next_sum, next_choice = dp[i + 1][h][new_m]\n                added = current_digit * pow_m[m]\n                total = added + next_sum\n                options.append((total, 'M'))\n        if not options:\n            continue  # This should not happen as per problem constraints\n        max_option = max(options, key=lambda x: x[0])\n        dp[i][h][m] = (max_option[0], max_option[1])\n\n# Reconstruct the path\nsequence = []\ncurrent_h, current_m = n, n\ncurrent_i = max_i\n\nwhile current_i > 0:\n    i = current_i\n    h = current_h\n    m = current_m\n    if h < n:\n        # Last move was H\n        sequence.append('H')\n        current_i -= 1\n        current_h -= 1\n    else:\n        # Last move was M\n        sequence.append('M')\n        current_i -= 1\n        current_m -= 1\n\nsequence.reverse()\n\nprint(''.join(sequence))\n```\n\n### Explanation\n1. **Initialization**:\n   - Precompute the place values for each possible number of digits taken by each player.\n   - Initialize the DP table with the final state where all digits have been processed.\n\n2. **DP Table Filling**:\n   - Process each digit from right to left, updating the DP state based on whether assigning the digit to Homer or Marge yields a higher sum.\n\n3. **Path Reconstruction**:\n   - Starting from the final state, backtrack through the DP table to determine the sequence of moves that led to the maximum sum.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves using dynamic programming, considering all possible states and transitions to maximize the total prize.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\nA = input().strip()\ndigits = [int(c) for c in A]\n\npow_h = [10 ** (n - 1 - h) for h in range(n + 1)]\npow_m = [10 ** (n - 1 - m) for m in range(n + 1)]\n\nmax_i = 2 * n\ndp = [[[None for _ in range(n + 1)] for __ in range(n + 1)] for ___ in range(max_i + 1)]\n\n# Initialize the final state\ndp[max_i][n][n] = (0, None)\n\nfor i in range(max_i - 1, -1, -1):\n    for h in range(n + 1):\n        m = i - h\n        if m < 0 or m > n:\n            continue\n        current_digit = digits[i]\n        options = []\n        # Assign to H\n        if h < n:\n            new_h = h + 1\n            if new_h <= n:\n                next_sum, next_choice = dp[i + 1][new_h][m]\n                added = current_digit * pow_h[h]\n                total = added + next_sum\n                options.append((total, 'H'))\n        # Assign to M\n        if m < n:\n            new_m = m + 1\n            if new_m <= n:\n                next_sum, next_choice = dp[i + 1][h][new_m]\n                added = current_digit * pow_m[m]\n                total = added + next_sum\n                options.append((total, 'M'))\n        if not options:\n            continue  # This should not happen as per problem constraints\n        max_option = max(options, key=lambda x: x[0])\n        dp[i][h][m] = (max_option[0], max_option[1])\n\n# Reconstruct the path\nsequence = []\ncurrent_h, current_m = n, n\ncurrent_i = max_i\n\nwhile current_i > 0:\n    i = current_i\n    h = current_h\n    m = current_m\n    if h < n:\n        # Last move was H\n        sequence.append('H')\n        current_i -= 1\n        current_h -= 1\n    else:\n        # Last move was M\n        sequence.append('M')\n        current_i -= 1\n        current_m -= 1\n\nsequence.reverse()\n\nprint(''.join(sequence))",
    "score": 0,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 980,
        "thoughts_token_count": 8193
    }
}