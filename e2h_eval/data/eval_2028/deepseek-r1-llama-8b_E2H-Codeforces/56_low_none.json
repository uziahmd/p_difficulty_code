{
    "start": 1758278113.7214358,
    "end": 1758278342.7276983,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:39 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Guard Duty,\" and from the description, I understand that we need to assign Rebel spaceships to guard B bases in such a way that each base has exactly one spaceship, and vice versa. But there's a catch: the paths from each base to its assigned spaceship shouldn't intersect any other paths. So, no two straight lines connecting a base to its spaceship should cross each other in the galaxy plane.\n\nHmm, right. So first, the input consists of R rebel spaceships and B bases. Both R and B can be up to 10, which isn't too bad for computation. The output is either \"Yes\" or \"No\" depending on whether such an assignment is possible.\n\nLet me think about the steps I need to take to solve this.\n\nFirst, the problem requires finding a perfect matching between the two sets of points (spaceships and bases). A perfect matching here means each point in one set is matched to exactly one in the other, with all being matched.\n\nBut the crucial part is ensuring that when you connect each spaceship to its base, the lines don't cross each other. So how can I model this?\n\nI remember that this is similar to finding a non-crossing bipartite matching. Oh right! It's related to the concept of planar graphs or perhaps using some geometric approach to avoid crossings.\n\nWait, but how do I check for non-crossing paths? Each path is a straight line from a base to a spaceship. So for any two such lines, say l1 (from base A to ship X) and l2 (from base B to ship Y), they shouldn't intersect anywhere except possibly at their endpoints.\n\nSo, the problem reduces to finding a perfect matching where all the connecting lines are non-intersecting.\n\nHmm, how can I approach this? Maybe by trying all possible permutations of assigning ships to bases and checking for each if the corresponding lines are non-crossing.\n\nWait, but R and B can be up to 10, so the number of possible matchings is R! (since it's a bipartite graph and assuming each side has the same size for a perfect matching). For R=10, 10! is 3,628,800. That's manageable because 3 million is not too big for a brute-force approach, especially since each check isn't too computationally intensive.\n\nSo the plan is:\n\n1. Generate all possible perfect matchings between the spaceships and the bases.\n2. For each matching, check if the corresponding lines (connecting each ship to its base) are non-crossing.\n3. If any matching satisfies the condition, output \"Yes\". Otherwise, output \"No\".\n\nBut wait, how to generate all perfect matchings efficiently? Well, considering that R and B can be different? Wait, the problem says that the assignment is a perfect matching, which implies that R must equal B. Because a perfect matching requires equal numbers on both sides. So the first thing I should check is whether R equals B. If not, it's impossible. So in that case, the answer is \"No\".\n\nWait, looking back at the problem statement: it says the assignment is a perfect matching, which indeed requires R = B. So yes, that's a necessary condition. So the first step is to check if R == B. If not, output \"No\".\n\nSo, in code, I should read R and B, and if R != B, immediately output \"No\".\n\nOtherwise, proceed.\n\nNow, for the cases where R == B.\n\nThe next step is to find a permutation of the bases (or the ships) such that when each ship is assigned to a base, the lines don't cross.\n\nWait, but how to model the bases and ships as points. So for each possible permutation, we can represent it as a list where each index represents a ship, and the value is the base it's assigned to.\n\nThen, for each such permutation, we need to check whether any two lines connecting a ship to its base and another ship to its base cross each other.\n\nHow to check for line crossings?\n\nFor two lines, l1 (A to X) and l2 (B to Y), they intersect if the points are arranged in a certain way.\n\nWait, but given that the problem states that no three points are colinear, so any two lines will intersect at most once.\n\nBut how to determine if two lines cross?\n\nWe can model each line as a pair of points. Then, for two lines defined by points P1-P2 and Q1-Q2, determine if the segments intersect.\n\nWait, but the lines are finite segments, right? Because each line is from a base to a ship. So the segments can only intersect if they cross within their finite extent.\n\nSo, to check if two segments AB and CD intersect, we can use the standard computational geometry method.\n\nYes, I remember the method involves checking the",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship has exactly one assigned base. Additionally, the paths from each base to its assigned spaceship should not intersect with any other paths in the galaxy plane.\n\n### Approach\n1. **Check for Perfect Matching**: The first step is to check if the number of Rebel spaceships (R) is equal to the number of bases (B). If they are not equal, it is impossible to form a perfect matching, and we immediately return \"No\".\n\n2. **Generate All Possible Matchings**: Since R and B can be up to 10, we can generate all possible permutations of assigning ships to bases. Each permutation represents a potential assignment.\n\n3. **Check for Non-Crossing Paths**: For each generated permutation, we need to check if the corresponding lines (connecting each ship to its base) are non-crossing. This involves checking each pair of lines to ensure they do not intersect except at their endpoints.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])\n\ndef segments_intersect(A, B, C, D):\n    def on_segment(p, q, r):\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n\n    ccw1 = ccw(A, B, C)\n    ccw2 = ccw(A, B, D)\n    ccw3 = ccw(C, D, A)\n    ccw4 = ccw(C, D, B)\n\n    if (ccw1 * ccw2 < 0 and on_segment(A, B, C)) or (ccw3 * ccw4 < 0 and on_segment(C, D, A)):\n        return True\n    if (ccw1 == 0 and on_segment(A, B, C)) or (ccw2 == 0 and on_segment(A, B, D)) or \\\n       (ccw3 == 0 and on_segment(C, D, A)) or (ccw4 == 0 and on_segment(C, D, B)):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    R = int(input[ptr])\n    ptr += 1\n    B = int(input[ptr])\n    ptr += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        ships.append((x, y))\n        ptr += 2\n\n    bases = []\n    for _ in range(B):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        bases.append((x, y))\n        ptr += 2\n\n    found = False\n    for perm in permutations(range(R)):\n        match = [None] * R\n        for i in range(R):\n            match[i] = perm[i]\n\n        lines = []\n        for i in range(R):\n            ship = ships[i]\n            base = bases[match[i]]\n            lines.append((ship, base))\n\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                line1 = lines[i]\n                line2 = lines[j]\n                A, B = line1\n                C, D = line2\n\n                if segments_intersect(A, B, C, D):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n\n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for both the Rebel spaceships and the bases.\n2. **Checking for Equality**: If the number of spaceships (R) does not match the number of bases (B), output \"No\".\n3. **Generating Permutations**: For each permutation of bases, check if the corresponding lines connecting ships to bases are non-crossing.\n4. **Checking Line Intersection**: For each permutation, use a helper function to determine if any two lines intersect. If a valid permutation is found where lines do not cross, output \"Yes\". If no valid permutation is found after checking all possibilities, output \"No\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])\n\ndef segments_intersect(A, B, C, D):\n    def on_segment(p, q, r):\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n\n    ccw1 = ccw(A, B, C)\n    ccw2 = ccw(A, B, D)\n    ccw3 = ccw(C, D, A)\n    ccw4 = ccw(C, D, B)\n\n    if (ccw1 * ccw2 < 0 and on_segment(A, B, C)) or (ccw3 * ccw4 < 0 and on_segment(C, D, A)):\n        return True\n    if (ccw1 == 0 and on_segment(A, B, C)) or (ccw2 == 0 and on_segment(A, B, D)) or \\\n       (ccw3 == 0 and on_segment(C, D, A)) or (ccw4 == 0 and on_segment(C, D, B)):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    R = int(input[ptr])\n    ptr += 1\n    B = int(input[ptr])\n    ptr += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        ships.append((x, y))\n        ptr += 2\n\n    bases = []\n    for _ in range(B):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        bases.append((x, y))\n        ptr += 2\n\n    found = False\n    for perm in permutations(range(R)):\n        match = [None] * R\n        for i in range(R):\n            match[i] = perm[i]\n\n        lines = []\n        for i in range(R):\n            ship = ships[i]\n            base = bases[match[i]]\n            lines.append((ship, base))\n\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                line1 = lines[i]\n                line2 = lines[j]\n                A, B = line1\n                C, D = line2\n\n                if segments_intersect(A, B, C, D):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n\n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 454,
        "completion_token_count": 1029,
        "thoughts_token_count": 1025
    }
}