{
    "start": 1758283883.5178936,
    "end": 1758286196.031054,
    "start-formatted": "2025-09-19 21:11 KST",
    "end-formatted": "2025-09-19 21:49 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. Hmm, the problem is about directed graphs and something called p-reachable graphs. Oh right, I remember from the description that a p-reachable graph has exactly p ordered pairs (u, v) where u < v, and u and v are reachable from each other. So each such pair contributes to the count of p.\n\nThe task is two-fold: first, find the minimal number of nodes required to create such a graph for a given p. Second, among all such minimal-node graphs, find the maximum possible number of unidirectional pairs.\n\nWait, unidirectional pairs are those where (u, v) is in the graph (i.e., there's a path from u to v), but the reverse isn't true. So for each such pair, u can reach v, but v can't reach u.\n\nLet me try to break down the problem.\n\nFirst part: Find the minimal number of nodes n such that the graph is p-reachable.\n\nSecond part: For this minimal n, find the maximum number of unidirectional pairs across all such graphs.\n\nLet me think about how to model this.\n\nFor the first part, perhaps the structure of the graph is a DAG with certain properties. Because if it's a DAG, then we can arrange the nodes in a topological order where edges only go from earlier to later nodes. That way, each node can reach the ones after it, but not vice versa.\n\nWait, but the p-reachable condition requires that for each pair (u, v) with u < v, they are mutually reachable. Wait no, wait the condition says that u and v are reachable from each other. So u can reach v and v can reach u. So the graph must have cycles between some pairs? Or wait, maybe not. Because if the graph is strongly connected, then every pair is mutually reachable. But wait, in the definition, it's specifically for u != v, so in a strongly connected graph, all ordered pairs (u, v) with u != v are considered, but in our case, p is the count of pairs where u < v and they are reachable. So for a strongly connected graph, the number of such pairs would be C(n,2), which is n*(n-1)/2.\n\nBut wait, that's only if the entire graph is strongly connected. But when p is less than C(n,2), perhaps the graph is structured differently.\n\nWait, maybe the minimal graph is a DAG with some specific properties. Because in a DAG, the reachability is one-way. So perhaps the graph is arranged in layers, where each layer points to the next, but not the other way.\n\nHmm, but in a DAG, the reachability is not mutual for most pairs. Only for pairs where u can reach v and v cannot reach u—those are unidirectional. But the p-reachable condition requires that for u < v, they are mutually reachable. So that suggests that the graph is not a DAG because in a DAG, if u is before v, u can reach v, but v can't reach u. So that would make (u, v) a unidirectional pair, but not a mutual one.\n\nWait, so that's conflicting. Because according to the problem statement, for a p-reachable graph, each pair (u, v) where u < v must be mutually reachable. So if the graph is a DAG, that's impossible because if u is before v, u can reach v, but v can't reach u. So that would mean (u, v) is not a mutual pair, thus not contributing to p.\n\nWait, so perhaps the graph isn't a DAG. Maybe it's a collection of components where within each component, all pairs are mutually reachable. So the graph is made up of strongly connected components (SCCs). Each SCC is a maximal subset of nodes where each node is reachable from every other node in the subset.\n\nIn that case, the count p is the sum over each SCC S of the number of pairs (u, v) where u < v and both are in S. Because within an SCC, all u and v can reach each other.\n\nSo the problem reduces to finding a set of SCCs whose combined contributions sum up to p, using as few nodes as possible.\n\nWait, but each SCC must form a strongly connected subgraph. So for an SCC of size k, the number of pairs is k*(k-1)/2.\n\nSo, the minimal number of nodes is achieved by finding a partitioning of p into sums of triangular numbers (since each term is k choose 2, which is k(k-1)/2).\n\nSo the problem becomes: find the minimal n such that the sum of s_i*(s_i - 1)/2 equals p, where s_i are the sizes of the SCCs.\n\nBut wait, that's only if each SCC is a single component. So for example, if p = 3, the possible partitions are:\n\n- One SCC of size 3: 3*2/2 =3 → total nodes 3.\n\nOr,\n\n- One SCC of size 2 and another of size 1: 2*1/2 + 1*0/2 = 1 +0=1. No, that's not enough.\n\nWait, no, because 1 is the sum for that. So 3 can't be achieved by adding 1 and 2. So perhaps the minimal is indeed 3.\n\nSo, the first step is to find the minimal n such that the sum of s_i choose 2 equals p. Then, for each such partition, the sum is p, and n is the sum of s_i.\n\nWait, but how do we find the minimal n?\n\nThis is similar to a problem where you want to represent p as a sum of triangular numbers, each of which is k choose 2, and find the minimal sum of k's.\n\nYes, because each term s_i choose 2 is the number of pairs in that SCC, and we need their sum to equal p.\n\nSo, the minimal number of nodes is the minimal n such that n is the sum of s_i's, where the sum of s_i*(s_i-1)/2 equals p.\n\nSo, our first task is to find the minimal n for the given p.\n\nHow can we compute this?\n\nWe can model this as trying all possible partitions of p into triangular numbers.\n\nEach triangular number t_k is k*(k-1)/2. So for each possible t_k, subtract it from p and recursively find the minimal sum for the remaining.\n\nBut since p can be up to 2e5, we need an efficient way.\n\nAlternatively, perhaps we can find the largest possible s_i at each step.\n\nWait, let's think: the minimal n is achieved when the sizes s_i are as large as possible.\n\nBecause for a given number of terms, larger s_i will contribute more to p, thus requiring fewer terms.\n\nSo perhaps the minimal n is achieved by taking the largest possible s_i each time.\n\nLet me test this idea.\n\nFor example, for p=3:\n\nThe largest possible t_k is 3 (when k=3). So 3 is achieved with s=3, n=3.\n\nWhich is correct.\n\nAnother example, say p=4.\n\nWhat's the minimal n?\n\nPossible options:\n\nt_3=3, then p=1 left. So s=3 and s=1: total n=4. But wait, t_3=3, and 1 can be achieved with s=2 (since 1 choose 2 is 1). So s=3 and s=2: total n=5.\n\nWait, but 3+2=5 nodes. Alternatively, perhaps t_3=3 and t_1=0. So that's 3+1=4 nodes. Wait, but 1 choose 2 is zero. So that's p=3. Not enough.\n\nWait, perhaps I'm misunderstanding. The sum of the s_i choose 2 must be exactly p.\n\nSo for p=4:\n\nOption 1: take s=4, which gives 4*3/2=6 >4, which is too much.\n\nOption 2: take s=3, which gives 3, leaving 1.\n\nNow, 1 can be achieved with s=2 (since 2*1/2=1). So total nodes 3+2=5.\n\nBut is there a better way?\n\nOption 3: take s=2, which gives 1, and then s=3 (but that's same as above).\n\nWait, perhaps another approach: 2 choose 2 is 1, and another 2 choose 2 is 1. So total 2 nodes of size 2: sum is 4. So 2+2=4 nodes.\n\nYes, because 2 choose 2 is 1 for each, and 1+1=2, but that's less than p=4. Wait no, 2 choose 2 is 1 per component. So two components of size 2: sum is 2, but p is 4. So that's not sufficient.\n\nWait, perhaps I'm making a mistake here.\n\nWait, each component contributes s_i*(s_i-1)/2 to p. So for p=4, what combinations can we have?\n\nLooking for s1 and s2 such that (s1(s1-1)/2) + (s2(s2-1)/2) =4.\n\nPossible options:\n\nCase 1: s1=3, s2=1: 3*2/2=3, 1*0/2=0 → sum is 3 <4. So no.\n\nCase 2: s1=2, s2=2: 1+1=2 <4.\n\nCase 3: s1=4: 4*3/2=6>4. No.\n\nCase 4: s1=3 and s2=2: 3+1=4 → sum is 4. So yes. So total nodes 3+2=5.\n\nIs there a way to get p=4 with fewer nodes?\n\nWait, what about s=3 and s=2, which gives 3+1=4, but that's 5 nodes.\n\nAlternatively, perhaps using three components: s=2, s=2, s=1. Each contributes 1, 1, 0 → sum 2, which is less than 4.\n\nNo, that won't work.\n\nWait, perhaps another approach: maybe using multiple components of size 3.\n\nWait, 3 choose 2 is 3, but 3+3=6, which is more than 4. So that's not helpful.\n\nHmm, perhaps the minimal n is 5 for p=4. But wait, in the sample input, when p=4, the output is 5 nodes and 6 unidirectional pairs.\n\nWait, the sample input is p=3, which outputs 3 nodes and 0 unidirectional. For p=4, the output is 5 nodes and 6 unidirectional pairs.\n\nWait, let me check the sample again. The sample input was [3,4,0], and the output was [3 0,5 6,0 0]. So for p=4, the minimal n is 5, and the max unidirectional is 6.\n\nWait, so for p=4, the minimal n is 5.\n\nBut wait, how? Because 5 nodes arranged as a chain: 1→2→3→4→5. Then each pair (i,j) with i<j is reachable from i to j but not vice versa. But in this case, the number of unidirectional pairs would be 10, which is 5 choose 2, but in reality, it's 15 (since each possible pair is unidirectional). Wait, no, in a linear DAG, each pair is unidirectional, but for the p-reachable condition, we need that for u<v, u and v are mutually reachable.\n\nWait, in a DAG, that's not the case. So that arrangement wouldn't satisfy the p-reachable condition because in that case, u can't reach v in both directions.\n\nWait, so perhaps the graph is structured as a collection of strongly connected components, each being a single node. Wait, no, because then each component is a single node, and the only way for u and v to be mutually reachable is if u and v are in the same component. But in that case, each component is a single node, so no pairs contribute to p.\n\nHmm, I'm getting stuck here. Let me try to think differently.\n\nWait, for the minimal n, the graph should be such that all the required pairs (u, v) with u < v are mutually reachable. So the graph must have a lot of cycles.\n\nWait, perhaps the minimal graph is a single strongly connected component. So all nodes are in one SCC, meaning that every pair (u, v) is mutually reachable. So the number of such pairs is C(n, 2) = n(n-1)/2.\n\nSo if p = n(n-1)/2, then the minimal n is sqrt(2p + 0.25) + 0.5, rounded up or something.\n\nWait, but that's only when p is a triangular number. Otherwise, we need to split into multiple SCCs.\n\nWait, but for p=3, n=3 is correct because 3C2=3.\n\nFor p=4, it's not a triangular number, so we need to split into multiple components.\n\nSo, the minimal n is the smallest n such that the sum of s_i choose 2 equals p, with each s_i >=1.\n\nSo, for p=4, we can have two components: one of size 3 (3C2=3) and one of size 1 (0). But 3+0=3 <4. No. So that's not good.\n\nWait, perhaps the minimal way is to have two components: one of size 3 (contributing 3) and another of size 2 (contributing 1). So 3+1=4. So total nodes 3+2=5.\n\nYes, that's how the sample gets p=4: minimal n is 5.\n\nSo the approach is to find the minimal n by splitting p into a sum of triangular numbers, each of which is s_i choose 2, and the sum of s_i is as small as possible.\n\nSo the problem now is to find the minimal n where the sum of s_i*(s_i-1)/2 equals p.\n\nNow, how to compute this efficiently.\n\nIdea: use a greedy approach, always taking the largest possible s_i at each step.\n\nSo, for a given current sum, subtract the largest possible t_k = k*(k-1)/2 that is <= remaining p.\n\nRepeat until p is reduced to zero.\n\nWait, let's test this.\n\nFor p=4:\n\nStart with remaining_p=4.\n\nFind the largest k where t_k <=4. t_3=3, t_4=6>4.\n\nSo take k=3, subtract 3, remaining_p=1.\n\nNow, take the largest possible t_j=1, which is j=2. Subtract 1, remaining_p=0.\n\nTotal s_i are 3 and 2. Sum is 3+2=5 nodes.\n\nWhich is correct.\n\nAnother example: p=6.\n\nLargest t_k <=6 is 3, which is t_3=3.\n\nSubtract 3, remaining_p=3.\n\nTake t_3 again: subtract 3, remaining_p=0.\n\nSum is 3+3=6 nodes.\n\nWait, but is there a better way?\n\nAlternatively, take t_4=6. So s=4, n=4. Which is better. So why didn't the greedy approach pick that?\n\nAh, because the greedy approach picks the largest possible s_i at each step, but sometimes combining smaller steps may give a better result.\n\nWait, so the greedy approach may not always yield the minimal n.\n\nSo that suggests that the approach needs to be adjusted.\n\nSo the problem is to find a set of s_i such that sum(s_i choose 2) = p, and the sum of s_i is minimized.\n\nHmm. So perhaps the minimal n is the smallest n where the maximum number of nodes is used to cover the p with as few nodes as possible.\n\nWait, perhaps the minimal n is found by considering that the sum of s_i choose 2 is p, and the sum of s_i is minimal.\n\nSo for p=6, the minimal n is 4, because 4C2=6.\n\nSo the approach of taking the largest possible s_i each time works for p=3 and p=4, but fails for p=6.\n\nThus, the initial approach is flawed.\n\nSo, perhaps the correct approach is to find all possible partitions of p into triangular numbers, and for each, calculate the sum of s_i, then pick the partition with the minimal sum.\n\nBut for p up to 2e5, this approach would be computationally expensive unless optimized.\n\nSo, perhaps precompute all possible triangular numbers up to 2e5.\n\nThen, for each possible t in descending order, check if p - t is achievable with the remaining.\n\nBut even that might be O(p) for each p, which is manageable.\n\nAlternatively, perhaps the minimal n is achieved by taking the largest possible s_i at each step.\n\nWait, for p=6, the largest possible s_i is 4, which gives t=6. So sum s_i is 4. So the minimal n is 4.\n\nBut in the initial approach, the algorithm would pick s=3 (t=3), then s=3 again, leading to 6 nodes.\n\nThus, the initial approach is incorrect.\n\nSo, the correct approach is to find all possible ways to express p as a sum of triangular numbers and choose the partition that gives the minimal sum of s_i.\n\nSo, the question is, for a given p, find the minimal n where n = sum s_i and sum (s_i choose 2) = p.\n\nThis is a partition problem, which is NP-hard, but perhaps with the constraint that each term is a triangular number, it can be solved efficiently.\n\nBut for p up to 2e5, perhaps dynamic programming can be used.\n\nWait, let's think about DP.\n\nDefine dp[i] as the minimal number of nodes needed to achieve exactly i pairs.\n\nWe can compute dp[0] = 0.\n\nFor each i from 1 to p, dp[i] = min(dp[i - t_k] + s_k) for all possible t_k <=i, where t_k is s_k choose 2.\n\nBut s_k is the size of the component, so s_k = m, t_k = m(m-1)/2.\n\nSo, for each possible m, compute t_m = m*(m-1)/2.\n\nIf t_m <=i, then we can consider adding m to the solution.\n\nSo, for each i, we iterate over all possible m (where t_m <=i) and update dp[i] accordingly.\n\nThe base case is dp[0]=0.\n\nBut for p up to 2e5, and m up to around 2e3 (since m(m-1)/2 <= 2e5 → m^2 ~4e5 → m~632), this could be feasible.\n\nLet me compute the maximum possible m for p=2e5.\n\nm(m-1)/2 ≤ 2e5 → m^2 ~4e5 → m≈632.\n\nSo for each i, we need to check m up to 632.\n\nThus, the DP approach is feasible.\n\nSo, the plan is:\n\n1. Precompute all possible m and their corresponding t_m = m*(m-1)/2.\n\n2. For each i from 1 to p, compute dp[i] as the minimal sum of s_i's such that the sum of t_m equals i.\n\n3. Once we have dp[p], that's the minimal n.\n\nBut wait, what about when p=0? Then, the minimal n is 0, because the graph has zero nodes. Also, the number of unidirectional pairs is zero.\n\nNow, the second part: among all minimal n graphs, find the maximum number of unidirectional pairs.\n\nIn the minimal n graph, the graph is a collection of s_i nodes, each forming an SCC.\n\nWithin each SCC, all possible pairs are mutually reachable, so no unidirectional pairs.\n\nBetween different SCCs, the direction of edges matters. If in the graph, edges only go from a lower-numbered component to higher, then any pair (u, v) where u is in a lower component and v is in a higher component will have a path from u to v, but not from v to u. Thus, these pairs contribute to unidirectional pairs.\n\nWait, but the problem states that for a p-reachable graph, the pairs (u, v) with u < v must be mutually reachable. So, in the graph, for any u < v, u and v are in the same component. So, the components must be arranged in such a way that any u < v must be in the same component.\n\nWait, that's a key point.\n\nBecause u < v, and for p, the pair (u, v) is counted only if they are mutually reachable. So if u < v, they must be in the same component, because otherwise, u can't reach v and v can't reach u.\n\nWait, no. Because if u and v are in different components, then u can't reach v and v can't reach u, so the pair (u, v) wouldn't contribute to p.\n\nBut in the p-reachable graph, the p is the number of pairs (u, v) with u < v and they are reachable from each other. So for u < v, if they are in the same component, they are counted in p. If they are in different components, they are not counted.\n\nThus, the graph's components must be such that all u < v are in the same component. Wait, no, that's not possible unless all nodes are in a single component.\n\nWait, no, because suppose u and v are in different components. Then u can't reach v, so the pair (u, v) is not in p. But the condition is that for all u < v, they are in p if they are mutually reachable.\n\nSo, the graph can have multiple components, but for any pair (u, v) with u < v, u and v must be in the same component. Otherwise, the pair is not counted in p.\n\nWait, that's not correct. Because in the problem statement, p is the number of ordered pairs (u, v) with u < v and u and v are reachable from each other. So for u < v, if they are in the same component, they contribute to p. If they are in different components, they don't contribute.\n\nBut the overall p is the sum over all components of the number of pairs (u, v) within the component with u < v.\n\nSo, in the minimal n graph, the components are arranged in such a way that all pairs (u, v) with u < v are in the same component. But that's only possible if all nodes are in a single component.\n\nWait, that's not necessarily the case. For example, if the nodes are divided into two components: {a}, {b, c}. Then, for a < b, a and b are in different components, so the pair (a, b) is not counted. Similarly, (a, c) is not counted. But within the {b, c} component, the pair (b, c) is counted. So p is 1.\n\nSo, the graph can have multiple components, but for any u < v, if they are in different components, the pair is not counted.\n\nThus, to maximize the number of unidirectional pairs, we can arrange the graph as a DAG of its components, where edges only go from earlier components to later components.\n\nWait, but wait. The unidirectional pairs are those where (u, v) is present (u can reach v) but (v, u) is not.\n\nBut in the case of the graph being a DAG of components, each component can reach the next, but not the previous. So, any pair (u, v) where u is in an earlier component and v is in a later component contributes to an unidirectional pair.\n\nAdditionally, within each component, since it's an SCC, there are no unidirectional pairs.\n\nThus, the total unidirectional pairs is the sum over all pairs (u, v) where u is in component i and v is in component j, j > i.\n\nSo, to maximize the number of unidirectional pairs, we should arrange the components in a way that the number of such cross-component edges is maximized.\n\nBut how?\n\nEach component is a strongly connected component, and the edges between them form a DAG.\n\nSo, the graph is a collection of components, each forming a clique (because within the component, every node can reach every other node), and the edges between components form a DAG.\n\nThus, the maximum number of unidirectional pairs occurs when the components form a linear chain, where each component points to all subsequent components. That way, every possible pair (u, v) where u is in an earlier component and v is in a later component contributes to an unidirectional pair.\n\nThus, the maximum number of unidirectional pairs is the sum for each component i, the product of the size of i and the sum of the sizes of all components j > i.\n\nSo, the strategy is:\n\n- Find the minimal n, which is the sum of s_i.\n\n- Arrange the components in a linear order, component 1, component 2, ..., component k.\n\n- Compute the number of unidirectional pairs as the sum for each i < j of (s_i * s_j).\n\nThis is equivalent to (sum s_i)^2 - sum s_i^2, all divided by 2. Because sum_{i<j} s_i s_j = (sum s_i)^2 - sum s_i^2)/2.\n\nBut since we're counting all ordered pairs where u is in an earlier component and v is in a later component, it's just sum_{i=1 to k} s_i * (sum_{j=i+1 to k} s_j).\n\nWhich is the same as (sum s_i)^2 - sum s_i^2.\n\nSo, the maximum number of unidirectional pairs is (n² - sum_s_i_squared) / 2.\n\nThus, for a given partition into s_i, the maximum number of unidirectional pairs is (n² - sum(s_i²)) / 2.\n\nSo, the second part of the problem is to find, among all possible partitions into s_i with sum s_i choose 2 = p, the partition that minimizes n, and among those, find the one that maximizes (n² - sum s_i squared)/2.\n\nSo, to restate:\n\nOnce we have the minimal n, we need to find the partition of p into s_i's such that sum(s_i choose 2) = p, and the sum of s_i is n. Among all possible such partitions, choose the one that maximizes (n² - sum s_i²)/2.\n\nSo, the steps are:\n\n1. For a given p, find the minimal n such that there exists a partition of p into s_i choose 2, and sum s_i = n.\n\n2. Among all possible partitions of p into s_i choose 2 that sum to p and have sum s_i = n, find the one that maximizes (n² - sum s_i²)/2.\n\nSo, the plan is:\n\n- Compute the minimal n via dynamic programming.\n\n- For the minimal n, find the partition that gives the maximum unidirectional pairs.\n\nBut how to find that partition.\n\nHmm.\n\nAn alternative approach is to realize that for a given sum of s_i and sum of s_i squared, the maximum unidirectional pairs is achieved when the components are as \"unequal\" as possible. Because when the components are as unequal as possible, the sum of their products is maximized.\n\nWait, perhaps the maximum occurs when the components are as large as possible. Because in that case, the sum of s_i squared is minimized.\n\nWait, no. Wait, sum s_i squared is minimized when the s_i's are as equal as possible. Because for a fixed sum, the sum of squares is minimized when all variables are equal.\n\nWait, but in our case, the sum of squares is to be minimized to maximize the unidirectional pairs.\n\nSo, for a given n and p, to maximize (n² - sum s_i squared)/2, we need to minimize sum s_i squared.\n\nSo, the problem reduces to, for a given n and p, find the partition into s_i's with sum s_i choose 2 = p, and sum s_i =n, and sum s_i squared is minimized.\n\nBecause the unidirectional pairs is (n² - sum s_i squared)/2, so to maximize it, we need to minimize sum s_i squared.\n\nThus, the second part is to find, among all possible partitions of p into s_i choose 2 with sum s_i =n, the partition with the minimal sum of squares.\n\nSo, how to model this.\n\nWe can model it with another DP, where for each i, we track not only the minimal n but also the minimal sum of squares for that n.\n\nThus, the DP state can be dp[i] = (minimal_n, minimal_sum_squares).\n\nBut for p up to 2e5, this could be feasible.\n\nSo, the plan is:\n\n- Precompute all possible t_m = m(m-1)/2 for m up to 632.\n\n- Initialize a DP array where dp[i] holds the minimal n and minimal sum of squares to reach i.\n\n- For each i, iterate through all possible m where t_m <=i, and update the dp[i + t_m] with the new n and sum_squares.\n\n- After filling the DP, for p, if dp[p] exists, we have the minimal n and the minimal sum of squares.\n\n- Then, the maximum unidirectional pairs is (n² - sum_squares) / 2.\n\nNow, let's think about the implementation.\n\nWe'll need to handle the cases where p=0 separately.\n\nLet's outline the steps in code.\n\nFirst, read p.\n\nIf p is 0:\n\n- Output 0 0.\n\nElse:\n\nCompute the minimal n and the sum of squares for p.\n\nThen compute (n^2 - sum_squares) // 2.\n\nBut wait, how to handle the DP.\n\nWe can represent dp as a dictionary where the key is the current sum of pairs, and the value is a tuple (n, sum_sq), representing the minimal n and minimal sum of squares to reach that sum.\n\nWe can initialize dp[0] = (0, 0).\n\nThen, for each sum in 0 to p:\n\n   for each m in possible m's:\n\n       t = m*(m-1)//2\n\n       if sum + t > p: continue\n\n       new_sum = sum + t\n\n       new_n = current_n + m\n\n       new_sum_sq = current_sum_sq + m*m\n\n       if new_sum not in dp or (new_n < dp[new_sum][0]) or (new_n == dp[new_sum][0] and new_sum_sq < dp[new_sum][1]):\n\n           dp[new_sum] = (new_n, new_sum_sq)\n\nBut this is O(p * m_max), which for p=2e5 and m_max=632 is about 2e5 * 600 ≈ 1.2e8 operations, which is acceptable.\n\nBut in Python, 1e8 operations are a bit slow. So perhaps we need a more efficient way.\n\nAlternatively, for each possible m, process all possible sums in increasing order.\n\nAnother approach is to precompute all possible t_m and for each, iterate through the possible sums.\n\nBut regardless, I think the DP approach is feasible.\n\nNow, handling the case when p=0.\n\nSo, let's proceed.\n\nImplementing this in code.\n\nBut let's also think about the initial step.\n\nWe can precompute all possible m and their t_m.\n\nSo:\n\nmax_m = floor((sqrt(8*p + 1) + 1)/2)\n\nBut for p up to 2e5, max_m is around 632.\n\nSo, precompute t_m for m from 1 to 632.\n\nNow, let's outline the code.\n\nRead p.\n\nif p ==0:\n\n   print(\"0 0\")\n\nelse:\n\n   # compute minimal n and sum_sq for p.\n\n   # Initialize dp.\n\n   dp = {}\n\n   dp[0] = (0, 0)\n\n   for m in range(1, 633):\n\n       t = m*(m-1)//2\n\n       if t > p:\n\n           continue\n\n       # for each sum in dp, add t and update.\n\n       # To avoid processing the same sum multiple times, perhaps we should make a copy of the current dp.\n\n       # Alternatively, process in reverse order.\n\n       # Wait, no. Because for each m, we can process sums in increasing order.\n\n       # So, for each sum in current dp, we can add t and see if it improves the new sum.\n\n       # But if we process m in order, for each m, for each existing sum, we can add t and possibly update.\n\n       # But to prevent processing the same sum multiple times, perhaps we should make a temporary copy.\n\n       # Or, perhaps, process the sums in reverse order.\n\n       # Wait, perhaps the standard knapsack approach applies here.\n\n       # For each sum s in dp, we can try adding t, and see if s + t is reachable with a better n or sum_sq.\n\n       # So, for each m, for each s in list(dp.keys()):\n\n       # new_s = s + t.\n\n       # new_n = dp[s][0] + m.\n\n       # new_sq = dp[s][1] + m*m.\n\n       # if new_s not in dp or new_n < dp[new_s][0], or (new_n == dp[new_s][0] and new_sq < dp[new_s][1]):\n\n       #     update dp[new_s].\n\n       # But doing this naively would lead to multiple updates for the same m. So perhaps it's better to process the sums in reverse order.\n\n       # So, for each m, iterate over the current sums in reverse, and update new sums.\n\n       # This way, each sum is processed once per m.\n\n       # So, in code:\n\n       # for s in reversed(dp.keys()):\n\n       #     if s + t <= p:\n\n       #         ...\n\n       # So, let's proceed.\n\n       # Create a copy of the current dp to iterate over.\n\n       for s in list(dp.keys()):\n\n           new_s = s + t\n\n           if new_s > p:\n\n               continue\n\n           new_n = dp[s][0] + m\n\n           new_sq = dp[s][1] + m*m\n\n           if new_s not in dp or new_n < dp[new_s][0] or (new_n == dp[new_s][0] and new_sq < dp[new_s][1]):\n\n               if new_s not in dp or (new_n < dp[new_s][0]) or (new_n == dp[new_s][0] and new_sq < dp[new_s][1]):\n\n                   dp[new_s] = (new_n, new_sq)\n\n   # Now, check if p is in dp.\n\n   if p not in dp:\n\n       # impossible? But according to problem statement, it's possible.\n\n       # Hmm, perhaps my DP setup is wrong.\n\n       # Wait, the problem says that it's possible to create a p-reachable graph for any p.\n\n       # So, dp[p] must exist.\n\n       # So, perhaps I made a mistake in the code.\n\n   else:\n\n       min_n, min_sum_sq = dp[p]\n\n       # compute unidirectional pairs.\n\n       unidirectional = (min_n * min_n - min_sum_sq) // 2\n\n       print(f\"{min_n} {unidirectional}\")\n\nBut wait, let's test this logic with the sample.\n\nSample input 3.\n\np=3.\n\nDP starts as {0: (0,0)}.\n\nProcessing m=1: t=0.\n\nFor s=0: new_s=0, new_n=1, new_sq=1.\n\nBut since t=0, adding it doesn't change anything. So no change.\n\nm=2: t=1.\n\nProcess s=0: new_s=1.\n\ndp[1] = (2, 4).\n\nm=3: t=3.\n\nProcess s=0: new_s=3. dp[3] = (3,9).\n\nAlso, process s=1: new_s=4. But 4 >3, so skip.\n\nSo, for p=3, dp[3] is (3,9).\n\nThus, unidirectional is (3^2 -9)/2 = (9-9)/2=0. Correct.\n\nAnother sample: p=4.\n\nIn the DP:\n\nAfter processing m=3, t=3.\n\ns=0: new_s=3, new_n=3, new_sq=9.\n\nThen, processing m=2, t=1.\n\nFor s=0: new_s=1, new_n=2, new_sq=4.\n\nFor s=3: new_s=4, new_n=5, new_sq=9+4=13.\n\nThus, dp[4] = (5,13).\n\nSo, unidirectional is (5^2 -13)/2 = (25-13)/2=6.\n\nWhich matches the sample.\n\nAnother test case: p=6.\n\nWhat's the minimal n?\n\nLooking for partitions:\n\n- m=4: t=6 → n=4, sum_sq=16.\n\n- m=3, t=3 and m=3, t=3 → sum is 3+3=6, n=6, sum_sq=9+9=18.\n\nSo, the minimal n is 4, sum_sq=16.\n\nThus, unidirectional is (16 -16)/2=0.\n\nWait, that can't be right.\n\nWait, no: for n=4, sum_sq=16. So (4^2 -16)/2= (16-16)/2=0.\n\nWait, but that seems to imply that all possible unidirectional pairs are zero. How is that possible?\n\nAh, because in this case, the",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable and maximize the number of unidirectional pairs among such graphs. \n\n### Approach\n1. **Understanding p-reachable Graphs**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) such that u < v and both nodes are reachable from each other. This implies that the graph must be structured in a way where all pairs (u, v) with u < v are mutually reachable.\n\n2. **Strongly Connected Components (SCCs)**: The graph can be decomposed into SCCs where within each SCC, every node is reachable from every other node. The number of such pairs within an SCC of size k is given by k*(k-1)/2.\n\n3. **Dynamic Programming (DP) Approach**: We use a DP approach to find the minimal number of nodes required to form a p-reachable graph. We also track the sum of squares of the sizes of these components to compute the maximum number of unidirectional pairs.\n\n4. **Maximizing Unidirectional Pairs**: To maximize the number of unidirectional pairs, we arrange the components in a linear order where edges only go from earlier components to later ones, maximizing the cross-component pairs.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline().strip())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    max_m = int((2 * p)**0.5 + 1)\n    t = {}\n    for m in range(1, max_m + 1):\n        t[m] = m * (m - 1) // 2\n        if t[m] > p:\n            break\n\n    dp = {0: (0, 0)}\n    for m in range(1, max_m + 1):\n        current_t = t[m]\n        for s in list(dp.keys()):\n            new_s = s + current_t\n            if new_s > p:\n                continue\n            new_n = dp[s][0] + m\n            new_sq = dp[s][1] + m * m\n            if new_s not in dp or (new_n < dp[new_s][0]) or (new_n == dp[new_s][0] and new_sq < dp[new_s][1]):\n                dp[new_s] = (new_n, new_sq)\n\n    if p not in dp:\n        print(\"Impossible\")\n        return\n\n    min_n, min_sum_sq = dp[p]\n    unidirectional = (min_n * min_n - min_sum_sq) // 2\n    print(f\"{min_n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input value p is read and checked if it is zero, in which case the output is directly \"0 0\".\n\n2. **Precompute Triangular Numbers**: We precompute triangular numbers up to the maximum possible value for p using a dictionary.\n\n3. **Dynamic Programming Setup**: We initialize a DP dictionary where each key is the number of pairs achieved so far, and the value is a tuple containing the minimum number of nodes and the sum of squares of component sizes.\n\n4. **Iterate Over Possible Component Sizes**: For each possible component size, we update the DP dictionary to track the minimal number of nodes and sum of squares required to achieve each possible number of pairs.\n\n5. **Compute Result**: After processing all possible component sizes, we check if the exact number of pairs p can be achieved. If so, we compute the maximum number of unidirectional pairs using the formula derived from the sum of squares and print the result.\n\nThis approach efficiently finds the minimal number of nodes and maximizes unidirectional pairs using dynamic programming and combinatorial insights.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p = int(sys.stdin.readline().strip())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    max_m = int((2 * p)**0.5 + 1)\n    t = {}\n    for m in range(1, max_m + 1):\n        t[m] = m * (m - 1) // 2\n        if t[m] > p:\n            break\n\n    dp = {0: (0, 0)}\n    for m in range(1, max_m + 1):\n        current_t = t[m]\n        for s in list(dp.keys()):\n            new_s = s + current_t\n            if new_s > p:\n                continue\n            new_n = dp[s][0] + m\n            new_sq = dp[s][1] + m * m\n            if new_s not in dp or (new_n < dp[new_s][0]) or (new_n == dp[new_s][0] and new_sq < dp[new_s][1]):\n                dp[new_s] = (new_n, new_sq)\n\n    if p not in dp:\n        print(\"Impossible\")\n        return\n\n    min_n, min_sum_sq = dp[p]\n    unidirectional = (min_n * min_n - min_sum_sq) // 2\n    print(f\"{min_n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 807,
        "thoughts_token_count": 8193
    }
}