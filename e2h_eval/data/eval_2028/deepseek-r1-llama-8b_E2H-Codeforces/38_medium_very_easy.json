{
    "start": 1758284245.5229666,
    "end": 1758286684.5101619,
    "start-formatted": "2025-09-19 21:17 KST",
    "end-formatted": "2025-09-19 21:58 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. Hmm, the problem is about finding the minimum number of nodes required to create a p-reachable directed graph and then determining the maximum number of unidirectional pairs in such a graph with that minimum number of nodes.\n\nWait, let me read the problem again carefully.\n\nA directed graph is called p-reachable if it contains exactly p ordered pairs (u, v) such that u < v and both can reach each other. So these are pairs where u and v are reachable from each other, and u is less than v. Oh right, because it's an ordered pair, so direction matters but only for the reachability.\n\nSo the first part is to find the minimal number of nodes needed to have exactly p such pairs. The second part is, among all such graphs with that minimal number, find the maximum possible number of unidirectional pairs. Unidirectional means that there's a path from u to v but not from v to u, and u != v.\n\nHmm. So I need to model this.\n\nLet me think about the minimal number of nodes first.\n\nI remember that in a strongly connected directed graph, every pair of nodes is reachable from each other. But wait, no, not necessarily. If the graph is strongly connected, then for any two nodes u and v, there's a path from u to v and vice versa. So in that case, the number of bidirectional edges would be based on their reachability.\n\nWait, but the p here is the count of ordered pairs (u, v) where u < v, and they can reach each other. So this is essentially the number of edges in the underlying undirected graph of the strongly connected components minus some things.\n\nAlternatively, perhaps the minimal graph is a complete DAG with certain properties? Or maybe it's a structure that allows us to maximize the number of such pairs with as few nodes as possible.\n\nWait, maybe we can model this by considering that in a graph, the number of such pairs is equal to the number of edges in the underlying undirected graph, but only within the strongly connected components. Because for each pair (u, v) where u < v and they're in the same component, if they can reach each other, then it counts towards p.\n\nWait, no. Wait, the condition is that there exists a path from u to v and from v to u. So the pair (u, v) contributes to p if u and v are in the same strongly connected component (SCC), and u < v.\n\nBut wait, the problem says exactly p such pairs. So the graph must have exactly p such ordered pairs.\n\nHmm, perhaps the minimal number of nodes is achieved when the graph is a single SCC, and the number of such pairs is equal to the number of unordered pairs (since every u < v in the component contributes to p). So for a component of size n, the number of such pairs is C(n, 2) = n*(n-1)/2. But wait, that's the total number of possible u < v pairs. So if our graph has exactly p such pairs, then the minimal n is the smallest n where n*(n-1)/2 >= p. Wait, no. Because p could be any number, so for example, if p=3, then n=3, since 3*2/2=3. That matches the sample input.\n\nWait, the sample input had p=3, output was 3 nodes. For p=4, the minimal n is 5 because 3 choose 2 is 3, which is less than 4. So 4 requires 5 nodes? Or wait, wait, maybe I'm getting this wrong.\n\nWait, no, perhaps the minimal n is determined by the triangular numbers. Because the number of such pairs is exactly the number of edges in a complete undirected graph of size n. So to have exactly p such pairs, n must be the minimal integer where n*(n-1)/2 >= p. Because if you have n nodes arranged in a way that they form a complete DAG, but wait, no—because for a complete DAG, each node points to every node after it. So the underlying undirected graph is a linear chain, but in that case, each node u can reach all v > u, but not the other way around. So in that case, the number of such pairs is zero. Which contradicts.\n\nWait, that's conflicting. So perhaps my initial assumption is wrong.\n\nWait, perhaps the minimal graph is a complete undirected graph where every node is reachable from every other. Then the number of such pairs is C(n, 2), which is the maximum possible for a given n. But then, the problem asks for exactly p such pairs. So perhaps the minimal n is the smallest n where C(n,2) >= p. Because if you can arrange the graph such that the number of such pairs is exactly p, then n is minimal.\n\nWait, but that might not always hold. For example, if p is not a triangular number, then n would be the next integer.\n\nLet me think: for p=0, the minimal n is 0 or 1. Because with 0 nodes, there are zero pairs. With one node, there are zero pairs as well. So the minimal is 0 or 1. Looking at the sample input, when p=0, the output is 0 0. So probably, for p=0, the minimal nodes is 0.\n\nWait, but the problem statement says \"the minimum number of nodes required to create a p-reachable directed graph.\" So for p=0, you can have 0 nodes. So that's why the sample output for p=0 is 0 0.\n\nFor p=1, the minimal n is 2, because with two nodes, you can have a single pair (u, v) where u can reach v and v can reach u, but that would give p=1 (since u < v). Or wait, no. Wait, with two nodes, if they form a cycle, then the pair (u, v) is counted once. So p=1 requires n=2.\n\nBut wait, what if the graph isn't a single SCC? Like, say, for p=3, the sample input uses 3 nodes. So perhaps the minimal n is indeed the smallest n where C(n, 2) >= p, and the graph is a single SCC where every pair of nodes is connected both ways. Because that way, the number of such pairs is exactly C(n, 2).\n\nWait, but that can't be, because for p=4, the sample output is 5 6. Because 5 choose 2 is 10, but wait, no. Wait, 5 choose 2 is 10, but p=4 is achieved with 5 nodes?\n\nWait, maybe I'm misunderstanding the problem.\n\nWait, the problem says that the graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So, the graph can have multiple components, but for each component, the number of such pairs is the number of edges in its underlying undirected graph, i.e., the number of unordered pairs of nodes in the component. Because each such pair contributes one to p.\n\nWait, no. Because if a component is a single node, it contributes nothing. If it's two nodes connected both ways, it contributes 1. If it's three nodes forming a cycle, it contributes 3, etc.\n\nSo the total p is the sum over all components of C(k, 2), where k is the size of the component.\n\nSo to get exactly p, the sum of C(k_i, 2) across all components equals p.\n\nNow, the minimal number of nodes is achieved when the sum is maximized per node. So perhaps each component is as large as possible, but how?\n\nAlternatively, to minimize the number of nodes, we should have as few components as possible, each as large as possible. Because C(k, 2) is maximized when k is as large as possible.\n\nWait, but the sum is fixed as p. So to minimize the number of nodes, we want each component to contribute as much as possible to p. So for example, for p=3, one component of 3 nodes gives C(3,2)=3, which is exactly p. So n=3.\n\nFor p=4, the largest possible component is 3, which contributes 3, leaving 1 more. So another component of 2 nodes, which contributes 1. So total nodes is 3+2=5. Because 3+1=4.\n\nWait, but C(3,2)=3, C(2,2)=1. So 3+1=4, which is p. So total nodes 3+2=5.\n\nSo for p=4, the minimal number of nodes is 5.\n\nWhich matches the sample output, where for p=4, the minimal nodes are 5.\n\nSo the approach is: for a given p, we need to find the minimal n such that the sum of C(k_i, 2) over all components equals p, and the sum of k_i is minimized.\n\nTo minimize the sum of k_i, the components should be as large as possible. So the optimal strategy is to take the largest possible k such that C(k,2) <= p, subtract that from p, and repeat.\n\nWait, let me think of it as breaking down p into a sum of triangular numbers, where each term is C(k,2) and the sum is p. The goal is to find the minimal number of terms (i.e., the minimal number of components) such that their C(k,2) sum up to p, and the sum of their sizes is as small as possible.\n\nWait, but no, the problem is to find the minimal number of nodes, given that the sum of C(k_i,2) equals p. So to minimize the sum of k_i, we need to maximize each C(k_i,2), which suggests that each component should be as large as possible.\n\nSo the way to do this is to find the largest k such that C(k,2) <= p, subtract that from p, and repeat until p becomes zero.\n\nWait, for example:\n\np=3: largest k is 3, C(3,2)=3, so p reduces to 0. So one component of 3, total nodes 3.\n\np=4: largest k is 3, C(3,2)=3, p becomes 1. Next, largest k is 2, C(2,2)=1. So components are 3 and 2, total nodes 5.\n\np=5: same as p=4, because 3+2=5, but 3+2=5 nodes, but C(3,2)+C(2,2)=3+1=4, which is less than 5. Wait, that can't be. Wait, maybe I'm misunderstanding.\n\nWait, p=5: let's see. The largest k where C(k,2) <=5 is 3, since 3*2/2=3 <=5. Subtracting 3, p becomes 2. Next, the largest k for 2 is 2, which contributes 1, p becomes 1. Then, the next k is 2, but C(2,2)=1 again, which exceeds p=1. So we take 1, but wait, C(1,2)=0. Hmm, this doesn't add up. Alternatively, maybe for p=5, the minimal number of nodes is 4.\n\nWait, let's think differently. Let's see:\n\nWe need to find a set of integers k_1, k_2, ..., k_m such that sum_{i} C(k_i, 2) = p and sum k_i is minimized.\n\nEach C(k_i, 2) is (k_i * (k_i -1))/2.\n\nThe minimal sum of k_i occurs when the k_i are as large as possible.\n\nSo the approach is to greedily take the largest possible k for each step.\n\nSo for p=5:\n\nThe largest k where C(k,2) <=5 is 3, since 3*2/2=3<=5.\n\nSubtract 3, p becomes 2.\n\nNext, largest k where C(k,2)<=2 is 2, since 2*1/2=1<=2.\n\nSubtract 1, p becomes 1.\n\nNow, next largest k is 1, but C(1,2)=0. So we can't contribute anything. So this approach doesn't work.\n\nWait, perhaps I need to break it down differently. Maybe I should use as many as possible the largest possible C(k,2) that doesn't exceed the remaining p.\n\nWait, for p=5:\n\nTake k=3, C(3,2)=3, p becomes 5-3=2.\n\nThen, for p=2: take k=2, C(2,2)=1, p becomes 1.\n\nBut now, p=1 remains. We can't take k=2 again because C(2,2)=1, but 1 is already taken. So perhaps we can take k=2 again, but that would add another 1, making the total 3+1+1=5, but the sum of k_i would be 3+2+2=7, which seems larger than necessary.\n\nWait, maybe another approach: perhaps for p=5, the minimal number of nodes is 5.\n\nBecause 5 can be represented as 3 + 2, which gives 3+2=5 nodes, but C(3,2)+C(2,2)=3+1=4 <5. So that's not enough.\n\nAlternatively, perhaps 4 + 1: C(4,2)=6>5, so no. Or 3 + 2 + 0: but no.\n\nWait, maybe the minimal nodes for p=5 is 5. Because each component of size 2 contributes 1, so 5 such components would give 5*1=5, but that's 10 nodes, which is worse.\n\nAlternatively, perhaps for p=5, the minimal is 4 nodes. Because 4 choose 2 is 6, which is greater than 5. So perhaps the graph is a single component of 4 nodes, but then p would be 6, which is more than 5. So that's not acceptable.\n\nHmm, maybe I'm approaching this wrong. Let me think about the problem again.\n\nThe problem is to find the minimal n such that the sum of C(k_i, 2) over all components is exactly p, and the sum of k_i is minimized.\n\nEach component is a strongly connected component, because within a component, any two nodes are reachable from each other.\n\nSo for each component, the number of pairs is C(k_i, 2), which is the number of u<v pairs within it.\n\nSo the sum of all C(k_i, 2) must equal p.\n\nOur goal is to minimize the sum of k_i.\n\nSo the way to minimize the sum is to maximize each C(k_i, 2), which means making each k_i as large as possible.\n\nSo the algorithm is:\n\nStart with the largest possible k such that C(k,2) <= p. Subtract that from p, and repeat until p is zero.\n\nWait, but that may not work because sometimes you can't cover p exactly with just C(k,2) terms.\n\nWait, for example, p=5: \n\nThe largest C(k,2) <=5 is 3. So subtract 3, p=2.\n\nNext, the largest C(k,2) <=2 is 1. So subtract 1, p=1.\n\nNow, the remaining p=1 can be covered by a component of size 2, which contributes 1. So sum of C's is 3+1+1=5, sum of k's is 3+2+2=7.\n\nBut is there a better way? Let's see.\n\nAnother approach: can we represent p=5 as 2 + 3? No, that's the same as before.\n\nAlternatively, 5 can be represented as 4 + 1, but C(4,2) is 6, which is larger than 5. So that's not allowed.\n\nWait, perhaps 5 can't be represented as a sum of C(k,2) terms. But that's impossible because for k=2, C(2,2)=1, and for k=3, C(3,2)=3.\n\nWait, 5=3+1+1: so three components, 3, 2, 2. Sum of k's is 7.\n\nIs there a way to get a sum of 5 with fewer nodes?\n\nWhat if we have a component of size 4: C(4,2)=6>5, which is too big.\n\nAlternatively, component of size 3 (3 pairs), and component of size 2 (1 pair): total 4, which is less than 5. So we need one more.\n\nWait, perhaps a component of size 3 and two components of size 2: 3+1+1=5, which is correct, but sum of k's is 3+2+2=7.\n\nIs there a way to represent 5 as a sum where the sum of k's is less than 7?\n\nHmm, perhaps not. So the minimal nodes for p=5 is 7? Or maybe I'm missing something.\n\nWait, perhaps I'm making a mistake in the way I model the problem.\n\nLet me try to see for p=5.\n\nLooking for components whose C(k,2) sum to 5.\n\nPossible combinations:\n\nOption 1: 3 + 2 → sum is 3+1=4 <5. So no.\n\nOption 2: 3 + 2 + 2 → 3+1+1=5. Sum of k's is 3+2+2=7.\n\nOption 3: 2 + 2 + 2 + ... 5 times → sum of C's is 5*1=5, sum of k's is 2*5=10.\n\nOption 4: 3 + 2 + 2 → same as option 2.\n\nOption 5: 3 + 3 → sum is 3+3=6>5, so no.\n\nOption 6: 4 → C(4,2)=6>5.\n\nNo other options seem possible.\n\nSo the minimal number of nodes is 7.\n\nWait, but that seems high. So for p=5, the minimal n is 7.\n\nBut wait, perhaps the initial approach is incorrect. Maybe the minimal n is not determined by the sum of C(k,2) being exactly p, but by the structure of the graph.\n\nAlternatively, perhaps I should model the problem differently.\n\nWait, perhaps the minimal number of nodes is determined by the minimal n where the maximal number of edges in a DAG that allows for exactly p such pairs is achieved.\n\nWait, I'm getting stuck. Maybe I should look for a pattern.\n\nLet's look at the sample inputs:\n\nSample Input 1: p=3 → Output is 3 0.\n\nSample Input 2: p=4 → Output is 5 6.\n\nSample Input 3: p=0 → Output is 0 0.\n\nWait, for p=4, the minimal nodes are 5, and the maximum unidirectional pairs is 6.\n\nHmm, how does that happen?\n\nWait, the maximum unidirectional pairs occur when the graph is structured to have as many as possible unidirectional edges.\n\nWait, but the problem is to find the maximum number of unidirectional pairs among all possible graphs that have exactly p such pairs and minimal nodes.\n\nSo, perhaps the minimal nodes is 5 for p=4, and in that setup, how many unidirectional pairs can we have.\n\nWait, in the sample, the output is 5 6.\n\nSo for p=4, the minimal nodes are 5. So the graph has 5 nodes, and the number of unidirectional pairs is 6.\n\nHmm.\n\nWait, perhaps the minimal number of nodes is determined by the minimal n such that the sum of C(k_i, 2) is >= p. No, that doesn't fit the sample.\n\nAlternatively, perhaps the minimal n is the minimal n where the sum of C(k_i, 2) is at least p, but that's not matching either.\n\nAlternatively, perhaps the minimal n is the smallest n where the maximum number of such pairs is achieved.\n\nWait, perhaps I should model the minimal n as the minimal n where the number of possible such pairs in a single component is at least p.\n\nIn other words, for a single component, the maximum possible p is C(n, 2). So, the minimal n is the smallest integer such that C(n, 2) >= p.\n\nWait, for p=3: n=3, since 3 >=3.\n\np=4: C(3,2)=3 <4, so n=4. But wait, C(4,2)=6>4, so n=4. But the sample for p=4 says the minimal n is 5.\n\nWait, that's conflicting.\n\nWait, perhaps the initial assumption is wrong.\n\nWait, the sample input for p=4 outputs 5 nodes. So according to that, the minimal n is 5. But according to the previous idea, n should be 4.\n\nSo perhaps the initial approach is incorrect.\n\nAlternatively, perhaps the minimal n is not the minimal n where C(n,2)>=p, but instead the minimal n where the sum of C(k_i,2) equals p.\n\nWait, for p=4: 3+1=4. So components of 3 and 2 nodes. So sum of nodes is 5.\n\nWhich aligns with the sample.\n\nSo the minimal n is determined by the way to split p into a sum of C(k_i,2), with the sum of k_i minimized.\n\nSo the approach is to split p into the sum of as many C(k,2) terms as possible, using the largest possible k each time.\n\nSo, for p=4, the steps are:\n\n- Take the largest k where C(k,2) <=4. That's k=3, since C(3,2)=3<=4. Subtract 3, p=1.\n\n- Then, take the largest k where C(k,2) <=1. That's k=2, C(2,2)=1. Subtract 1, p=0.\n\nSum of k_i is 3+2=5.\n\nSo the minimal n is 5.\n\nSimilarly, for p=5:\n\nLargest k where C(k,2)<=5 is 3, subtract 3, p=2.\n\nLargest k where C(k,2)<=2 is 2, subtract 1, p=1.\n\nAgain, largest k is 2, subtract 1, p=0.\n\nSum of k's: 3+2+2=7.\n\nSo minimal n is 7.\n\nWait, but that seems high. So for p=5, the minimal n is 7.\n\nSo the general approach is:\n\nTo find the minimal n, we need to represent p as the sum of C(k_i,2), and the sum of k_i is minimized.\n\nThis can be done by greedily choosing the largest possible k each time, subtracting C(k,2) from p, until p is zero.\n\nSo, the algorithm is:\n\nInitialize sum_n = 0, remaining_p = p.\n\nWhile remaining_p >0:\n\n   find the largest k such that C(k,2) <= remaining_p.\n\n   sum_n +=k\n\n   remaining_p -= C(k,2)\n\nThus, the minimal n is sum_n.\n\nWait, but wait: for p=4, this gives 3+2=5, which is correct.\n\nFor p=3: 3, sum is 3.\n\nFor p=0: sum is 0.\n\nFor p=1: largest k is 2, C(2,2)=1, sum is 2.\n\nYes.\n\nFor p=2: largest k is 2, sum is 2.\n\nSo for p=2, n=2.\n\nYes, because the graph is a single component of 2 nodes, which contributes 1 pair. Wait, but p=2 would require the sum to be 2, which can't be achieved with a single component of 2 nodes, which contributes 1. So that's a problem.\n\nWait, wait, this suggests that the approach is incorrect.\n\nBecause for p=2, the sum of C(k_i,2) needs to be exactly 2.\n\nBut with a single component of size 3: C(3,2)=3>2.\n\nSo perhaps the approach is to have two components of size 2: C(2,2)=1 each, sum is 2. So sum_n=4.\n\nBut that's worse than a single component of 3, which gives sum=3>2.\n\nWait, but that's not helpful. So perhaps the problem is that the approach of greedy selecting the largest possible k each time may not always work, especially when p is not a triangular number.\n\nAlternatively, perhaps I'm misunderstanding the problem.\n\nWait, the problem states that the graph must have exactly p such pairs. So for p=2, the sum of C(k_i,2) must be exactly 2.\n\nSo possible ways:\n\n- One component of size 3: C(3,2)=3>2 → no.\n\n- Two components of size 2: sum is 1+1=2 → sum of k's is 4.\n\nAlternatively, a component of size 2 and a component of size 1: sum is 1+0=1<2.\n\nSo, the only way is two components of size 2. So minimal n is 4.\n\nBut that seems high.\n\nWait, but perhaps there's another way. For example, a component of size 3 and a component of size 1: C(3,2)+C(1,2)=3+0=3>2. Not helpful.\n\nAnother option: a component of size 2 and a component of size 3: same as above.\n\nHmm. So for p=2, the minimal n is 4.\n\nBut that feels counterintuitive. Is there a way to have n=3?\n\nWell, with 3 nodes, the possible ways to have sum C(k_i,2)=2.\n\nIf the graph is a single component of 3 nodes, the sum is 3, which is more than 2. So that's not acceptable.\n\nIf the graph has two components: perhaps one of size 2 and one of size 1. Sum is 1+0=1<2.\n\nNo good.\n\nSo yes, for p=2, the minimal n is 4.\n\nBut that seems high. So perhaps my initial approach is correct.\n\nSo the algorithm is:\n\nCompute the minimal n as the sum of k_i, where each k_i is the largest possible such that C(k_i, 2) <= remaining p.\n\nSo the steps for p=2:\n\nremaining_p=2.\n\nLargest k where C(k,2) <=2 is 2, since C(2,2)=1<=2.\n\nsum_n +=2 → sum_n=2.\n\nremaining_p=2-1=1.\n\nNext iteration:\n\nLargest k where C(k,2)<=1 is 2 again, since C(2,2)=1<=1.\n\nsum_n +=2 → sum_n=4.\n\nremaining_p=1-1=0.\n\nSo n=4.\n\nSo for p=2, the minimal n is 4.\n\nSo the code will have to implement this.\n\nOnce the minimal n is found, the next step is to compute the maximum number of unidirectional pairs in such a graph.\n\nWhat's an unidirectional pair? It's a pair (u, v) where u≠v, there's a path from u to v but not from v to u.\n\nSo, for each component, the number of unidirectional pairs is equal to the number of edges in the component's underlying DAG, minus the edges that are bidirectional.\n\nWait, perhaps not. Because in a strongly connected component, all edges are bidirectional. So no unidirectional pairs exist within a component.\n\nWait, no, in a strongly connected component, any edge u->v implies v->u exists, because it's strongly connected. So the number of unidirectional pairs within a component is zero.\n\nWait, but in a DAG, each node u can have edges to some v's, but not the reverse. So the unidirectional pairs come from the edges in the DAG.\n\nWait, perhaps the unidirectional pairs are the edges in the DAG of the entire graph, not within the components.\n\nWait, maybe I should model the entire graph as a DAG of its strongly connected components.\n\nEach component is a node in the DAG, and edges between components indicate that there's a path from one component to another.\n\nIn this case, within each component, there are no unidirectional pairs, as all nodes are mutually reachable.\n\nSo the unidirectional pairs are those edges that go from one component to another, and are not reciprocated.\n\nWait, but if component A has a directed edge to component B, but B does not have an edge to A, then any pair (u, v) where u is in A and v is in B contributes to the unidirectional pairs.\n\nMoreover, any pair within component B can't contribute, as they are strongly connected.\n\nWait, no. Because within component B, any u and v are reachable from each other, so all pairs in B are bidirectional, hence no unidirectional pairs.\n\nSo the unidirectional pairs are only those that cross between components, and are part of the DAG edges.\n\nWait, but the DAG edges can be multiple. So for each edge from component X to component Y, if Y does not have an edge back to X, then all u in X and v in Y contribute to unidirectional pairs.\n\nSo the number of unidirectional pairs is the sum over all edges in the DAG of the product of the sizes of the source and destination components.\n\nBut wait, in the DAG, if X has an edge to Y, but Y also has an edge to X, then it's not a unidirectional edge, but a bidirectional edge. So those don't contribute.\n\nBut in our case, the components are strongly connected, so the DAG edges are unidirectional. Because if component X has an edge to Y, it means there's a path from any node in X to any node in Y, but not necessarily the other way around.\n\nWait, but in the overall graph, the DAG edges are between components, and since each component is strongly connected, any edge in the DAG is unidirectional. Because if X has an edge to Y, it's because there's a path from X to Y, but not necessarily the reverse.\n\nWait, but if the DAG edge is X → Y, then any u in X can reach any v in Y via some path, but v cannot reach u because that would imply that Y is reachable from X and X is reachable from Y, which would merge them into a single component, contradicting the fact that they are separate components.\n\nAh! So in the DAG of components, each edge is unidirectional and represents a strict direction.\n\nTherefore, any pair (u, v) where u is in component X and v is in component Y, and X has an edge to Y, contributes to the unidirectional pairs. Because u can reach v, but v cannot reach u (since otherwise, X and Y would be merged into a single component).\n\nSo the number of unidirectional pairs is the sum for each edge in the DAG between X and Y (X → Y) of |X| * |Y|.\n\nBut wait, in the DAG, if X has an edge to Y, but Y also has an edge to X, that's not possible because that would imply a cycle, which would merge X and Y into a single component. So in the DAG of components, the edges are unidirectional and acyclic.\n\nSo each edge in the DAG contributes |X| * |Y| unidirectional pairs.\n\nSo, to maximize the number of unidirectional pairs, we need to maximize the sum of |X| * |Y| for each edge in the DAG.\n\nGiven that the components are chosen such that the sum of C(k_i, 2) equals p, and the sum of k_i is minimal, we need to arrange the components into a DAG where the edges contribute as much as possible to the unidirectional pairs.\n\nHow can we maximize the sum of |X| * |Y| for the edges in the DAG of components?\n\nIt depends on the structure of the DAG.\n\nIn the DAG, the maximum sum is achieved when the components are arranged in a linear order, with each component pointing to the next. This way, each edge contributes the product of the sizes of consecutive components.\n\nFor example, if the components are ordered C1, C2, C3, C4, with edges C1→C2, C2→C3, C3→C4, then the sum is |C1|*|C2| + |C2|*|C3| + |C3|*|C4|.\n\nThis is likely to be the maximum possible.\n\nAlternatively, perhaps arranging the components in a way that larger components are placed earlier, contributing to more edges.\n\nWait, but perhaps the best way is to arrange the components in a chain, each pointing to the next, with the largest possible products.\n\nSo, for the given components, sorted in decreasing order of size, we arrange them in a chain, each pointing to the next.\n\nThus, the sum is the sum of the product of consecutive component sizes.\n\nSo, the steps to compute the maximum unidirectional pairs are:\n\n1. Find all the components (k_1, k_2, ..., k_m) such that sum of C(k_i,2) = p.\n\n2. Sort the components in non-increasing order.\n\n3. Arrange them in a linear chain, where each component points to the next.\n\n4. The total unidirectional pairs is the sum of k_i * k_{i+1} for i from 1 to m-1.\n\nWait, but let's test this with the sample.\n\nSample Input 2: p=4.\n\nComponents are 3 and 2.\n\nSorted as 3, 2.\n\nArrange as 3 → 2.\n\nSum is 3*2=6.\n\nWhich matches the sample output of 6.\n\nAnother example:\n\np=5.\n\nComponents are 3, 2, 2.\n\nSorted as 3, 2, 2.\n\nArrange as 3 →2 →2.\n\nSum is 3*2 + 2*2 =6 +4=10.\n\nSo the maximum unidirectional pairs is 10.\n\nBut let's see if that's correct.\n\nEach edge in the DAG contributes |X| * |Y|.\n\nIn this case, 3→2 (contribution 6), 2→2 (contribution 4).\n\nWait, but in the DAG, can a component point to itself? No, because that would imply a loop, but the component is a strongly connected component. So, a component cannot have an edge to itself.\n\nSo, in the case of two components of size 2, they can only have an edge from one to the other, but not both ways. But since they are in the same DAG, if one points to the other, the other cannot point back. So, in the arrangement 3 →2 →2, the second 2 points to the third 2, which is allowed.\n\nWait, but in reality, if you have two components of size 2, say C and D, you can have C →D, but D cannot have an edge to C. So the arrangement would be C →D, and that's it.\n\nWait, but according to the earlier logic, each component is a node in the DAG, and edges are unidirectional.\n\nSo, for components 3, 2, 2: the DAG can have edges 3→2, and 2→2.\n\nBut wait, 2→2 would imply that the component D points to itself, which is not allowed because that would mean a loop, which is not possible in a DAG.\n\nSo, perhaps the arrangement is 3→2 and 2→2 is not allowed. Instead, the DAG can have 3→2, and that's it. So the sum would be 3*2=6.\n\nWait, but that's less than 10.\n\nHmm, this is confusing.\n\nAlternatively, perhaps the two 2's are considered as a single component of size 4. But no, because C(4,2)=6>5, which would make p=6, which is more than 5.\n\nWait, perhaps I'm making a mistake in how the components are arranged.\n\nWait, for p=5, the components are 3, 2, 2.\n\nSo the DAG must have edges between these components, but without creating cycles.\n\nSo, one possible arrangement is 3→2 and 2→2.\n\nBut in reality, the second 2 cannot have an edge to itself.\n\nSo perhaps the DAG can only have 3→2, and the second 2 is a separate component that has no outgoing edges.\n\nThus, the sum is 3*2=6.\n\nBut that's less than the earlier calculation.\n\nHmm, perhaps the way to model this is that each component can have at most one outgoing edge to another component.\n\nWait, but that's not necessarily the case. Each component can have edges to multiple other components.\n\nBut to avoid cycles, the DAG must be a directed acyclic graph.\n\nSo, for the components 3, 2, 2, the possible edges are:\n\n3→2a, 3→2b.\n\n2a→2b.\n\nBut 2a and 2b are separate components.\n\nWait, but that's not possible because 2a and 2b are separate components. So, any edges between them would have to be from one to the other, but not both ways.\n\nWait, but if 2a has an edge to 2b, then 2b can't have an edge back.\n\nSo, the arrangement could be 3→2a, 2a→2b, and 3→2b.\n\nBut that's allowed.\n\nIn this case, the unidirectional pairs are:\n\n3→2a: 3*2=6.\n\n",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and find the maximum number of unidirectional pairs in such a graph.\n\n### Approach\n1. **Understanding p-reachable Graph**: A directed graph is p-reachable if it contains exactly `p` ordered pairs `(u, v)` such that `u < v` and both can reach each other. This implies that the graph must be structured in a way that the number of such pairs equals `p`.\n\n2. **Minimum Number of Nodes**: The goal is to find the smallest number of nodes `n` such that the sum of combinations of node pairs from each strongly connected component (SCC) equals `p`. Each SCC contributes `C(k, 2)` pairs where `k` is the size of the SCC. We use a greedy approach to find the largest possible components first to minimize the total number of nodes.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimum number of nodes is determined, we need to structure the graph to maximize the number of unidirectional pairs. These pairs are found between components in a directed acyclic graph (DAG) formed by the SCCs, where each edge contributes to the count based on the sizes of the source and destination components.\n\n### Solution Code\n```python\nimport math\n\ndef minimal_nodes(p):\n    if p == 0:\n        return 0\n    sum_n = 0\n    remaining_p = p\n    while remaining_p > 0:\n        k = int(math.sqrt(2 * remaining_p + 0.25))  # Solve k*(k-1)/2 <= remaining_p\n        while (k * (k - 1)) // 2 > remaining_p:\n            k -= 1\n        sum_n += k\n        remaining_p -= (k * (k - 1)) // 2\n    return sum_n\n\ndef max_unidirectional_pairs(components):\n    components.sort(reverse=True)\n    total = 0\n    for i in range(len(components)-1):\n        total += components[i] * components[i+1]\n    return total\n\np = int(input().strip())\nif p == 0:\n    print(\"0 0\")\nelse:\n    n = minimal_nodes(p)\n    components = []\n    remaining_p = p\n    while remaining_p > 0:\n        k = int(math.sqrt(2 * remaining_p + 0.25))\n        while (k * (k - 1)) // 2 > remaining_p:\n            k -= 1\n        components.append(k)\n        remaining_p -= (k * (k - 1)) // 2\n    max_uni = max_unidirectional_pairs(components)\n    print(f\"{n} {max_uni}\")\n```\n\n### Explanation\n1. **Finding Minimum Nodes**: The function `minimal_nodes` calculates the smallest number of nodes needed by iteratively finding the largest component that fits within the remaining number of pairs `p`. This is done using a combination of mathematical solving and iterative adjustment.\n\n2. **Calculating Maximum Unidirectional Pairs**: The function `max_unidirectional_pairs` sorts the components and computes the maximum possible unidirectional pairs by considering each component's contribution when arranged in a linear chain, maximizing the product of their sizes.\n\nThis approach ensures that we efficiently determine both the minimum number of nodes and the maximum unidirectional pairs, providing an optimal solution to the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef minimal_nodes(p):\n    if p == 0:\n        return 0\n    sum_n = 0\n    remaining_p = p\n    while remaining_p > 0:\n        k = int(math.sqrt(2 * remaining_p + 0.25))  # Solve k*(k-1)/2 <= remaining_p\n        while (k * (k - 1)) // 2 > remaining_p:\n            k -= 1\n        sum_n += k\n        remaining_p -= (k * (k - 1)) // 2\n    return sum_n\n\ndef max_unidirectional_pairs(components):\n    components.sort(reverse=True)\n    total = 0\n    for i in range(len(components)-1):\n        total += components[i] * components[i+1]\n    return total\n\np = int(input().strip())\nif p == 0:\n    print(\"0 0\")\nelse:\n    n = minimal_nodes(p)\n    components = []\n    remaining_p = p\n    while remaining_p > 0:\n        k = int(math.sqrt(2 * remaining_p + 0.25))\n        while (k * (k - 1)) // 2 > remaining_p:\n            k -= 1\n        components.append(k)\n        remaining_p -= (k * (k - 1)) // 2\n    max_uni = max_unidirectional_pairs(components)\n    print(f\"{n} {max_uni}\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 476,
        "completion_token_count": 716,
        "thoughts_token_count": 8193
    }
}