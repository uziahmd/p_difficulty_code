{
    "start": 1758278809.9086487,
    "end": 1758279234.3202102,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called Mushroom Strife. Hmm. So the setup is that Pasha and Akim made a forest map where lawns are vertices and roads are edges. Each road has two numbers: GCD and LCM of the mushrooms on the connected lawns. But now, some of the map is torn, leaving only m roads. My task is to help restore the number of mushrooms on every lawn based on the given roads. If it's not possible, output NO; else, output any valid arrangement.\n\nThe input gives n and m, followed by m lines each with four numbers: the two lawns connected by the road, the GCD, and the LCM of their mushroom counts.\n\nHmm. So, how do I model this? It seems like a graph problem where each edge imposes constraints on the values of the nodes (lawns). Each node must have a value (number of mushrooms), and each edge enforces that for the two nodes u and v, the GCD of their values is g, and the LCM is l.\n\nWait, but wait. Wait, GCD(u, v) = g and LCM(u, v) = l. Also, since GCD and LCM are related to two numbers, we know that the product of GCD and LCM equals the product of the two numbers. Because GCD(a,b) * LCM(a,b) = a*b. So that gives us a relation between u and v: u * v = g * l.\n\nBut also, because GCD(g, l) is 1? Or wait, no. Because g is the GCD of u and v, so g divides both u and v. And l is their LCM, which is the smallest number divisible by both u and v. So l must be a multiple of both u and v. So, l must be a multiple of g, because g is a divisor of both u and v. So l = k * g, where k is some integer >=1.\n\nWait, let's think about that. Let me take an example: say u=3, v=6. Then GCD is 3, LCM is 6. Here, 3 *6 =18, and GCD * LCM is 3*6=18, which matches.\n\nAnother example: u=4, v=6. GCD is 2, LCM is 12. 4*6=24, GCD*LCM=24, same as before.\n\nSo for any two nodes connected by an edge, their values must satisfy u * v = g * l, and l must be a multiple of g. Also, since g is the GCD, the maximum common factor of u and v.\n\nSo, for each edge, the pair of values for the connected nodes must satisfy these conditions.\n\nNow, the problem is to assign a value to each node such that all edges' constraints are satisfied. But since the graph is arbitrary, this might involve solving a system of equations or constraints.\n\nSo, how can I model this? Maybe using variables for each node's value and then for each edge, adding constraints.\n\nThis sounds like a problem that can be modeled with Union-Find data structure, but perhaps with some additional information attached to each component. Because each connected component needs to have consistent values across its nodes.\n\nAlternatively, perhaps each connected component can have a certain structure where all nodes' values are multiples of a base value, determined by the constraints.\n\nWait, another thought: For each connected component, all the nodes' values must be multiples of the GCD of all the edges in that component. Because, for any two nodes in the component, their values must have a GCD equal to g for their connecting edge. But when you have more than one edge, the overall GCD could be higher.\n\nWait, maybe not. Let's see: suppose in a component, there are two edges. Edge 1 connects u and v with GCD g1, and edge 2 connects v and w with GCD g2. Then, u and v must have GCD g1, v and w must have GCD g2. What's the GCD of u and w? It depends on the values. It might be the GCD of g1 and g2, but that's not necessarily the case.\n\nHmm, perhaps the minimal approach is to model each node's value as a variable, and for each edge, create equations based on the GCD and LCM constraints.\n\nBut with n variables and m equations, this could get computationally intensive, especially for larger n and m. However, considering that the constraints are based on GCD and LCM, which have a specific relationship, perhaps we can find a way to represent this.\n\nAn alternative approach is to realize that the problem can be reduced to checking if the constraints form a consistent system, and then",
    "response": "To solve this problem, we need to determine the number of laughy mushrooms on each lawn based on the given roads and their constraints. Each road provides the GCD and LCM of the mushrooms on the connected lawns, which imposes specific relationships between these values.\n\n### Approach\n1. **Graph Representation**: Represent the problem as a graph where nodes are lawns and edges represent roads with their respective GCD and LCM constraints.\n2. **Constraints Analysis**: For each edge, the product of the two nodes' mushroom counts equals the product of the GCD and LCM values. Additionally, the GCD must divide both nodes, and the LCM must be a multiple of both nodes.\n3. **Union-Find Data Structure**: Use this structure to manage connected components of the graph. Each component will track the GCD of all edges within it to ensure consistency across all constraints.\n4. **Component Check**: For each connected component, verify that all edges within it satisfy the GCD and LCM constraints. If any inconsistency is found, output \"NO\".\n5. **Mushroom Assignment**: Assign default values to each node, ensuring that the constraints are satisfied within each connected component. If a component has no valid assignment, output \"NO\".\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, m = int(input[ptr]), int(input[ptr+1])\n    ptr +=2\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])-1\n        v = int(input[ptr+1])-1\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append((u, v, g, l))\n    \n    parent = list(range(n))\n    rank = [1]*n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] *=2\n        else:\n            parent[v_root] = u_root\n            rank[u_root] *=2\n        return True\n    \n    constraints = {}\n    possible = True\n    for u, v, g, l in edges:\n        if u == v:\n            continue\n        if u not in constraints:\n            constraints[u] = {}\n        if v not in constraints:\n            constraints[v] = {}\n        if g not in constraints[u]:\n            constraints[u][g] = []\n        constraints[u][g].append(v)\n        if g not in constraints[v]:\n            constraints[v][g] = []\n        constraints[v][g].append(u)\n        if l in constraints[u]:\n            if v not in constraints[u][l]:\n                constraints[u][l].append(v)\n        else:\n            constraints[u][l] = [v]\n        if l in constraints[v]:\n            if u not in constraints[v][l]:\n                constraints[v][l].append(u)\n        else:\n            constraints[v][l] = [u]\n    \n    for u in range(n):\n        for v in constraints.get(u, {}):\n            if u < v:\n                if v in constraints.get(u, {})[v]:\n                    pass\n                else:\n                    possible = False\n                    break\n        if not possible:\n            break\n        if not constraints.get(u, {}):\n            pass\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    comp = {}\n    for u in range(n):\n        if u not in comp:\n            comp[u] = []\n    for u, v, g, l in edges:\n        if u == v:\n            continue\n        if find(u) != find(v):\n            union(u, v)\n    \n    for u in range(n):\n        root = find(u)\n        if root not in comp:\n            comp[root] = {\n                'nodes': [],\n                'g': 0,\n                'mul_gcd_lcm': {}\n            }\n        comp[root]['nodes'].append(u)\n    \n    for root in comp:\n        nodes = comp[root]['nodes']\n        g_total = 0\n        for u in nodes:\n            for g_val, vs in constraints.get(u, {}).items():\n                if u in vs and g_val in comp[root]['mul_gcd_lcm']:\n                    if comp[root]['mul_gcd_lcm'][g_val] != vs:\n                        possible = False\n                        break\n                else:\n                    comp[root]['mul_gcd_lcm'][g_val] = vs.copy()\n            if not possible:\n                break\n        if not possible:\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    assigned = {}\n    for root in comp:\n        nodes = comp[root]['nodes']\n        current_g = comp[root]['g']\n        base = 1\n        for u in nodes:\n            if u in assigned:\n                continue\n            if current_g == 0:\n                base = 1\n            else:\n                if base * current_g > 106:\n                    possible = False\n                    break\n                base *= current_g\n            assigned[u] = base\n        if not possible:\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    for u in range(n):\n        if u not in assigned:\n            assigned[u] = 1\n    \n    for u, v, g, l in edges:\n        if u == v:\n            continue\n        a = assigned[u]\n        b = assigned[v]\n        if gcd(a, b) != g or (a * b) // g != l:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(' '.join(map(str, assigned)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns, roads, and the details of each road.\n2. **Union-Find Structure**: This is used to manage connected components of the graph, ensuring that each component's constraints are consistent.\n3. **Constraint Checking**: For each edge, the constraints are checked to ensure they form a consistent system within each connected component.\n4. **Component Processing**: Each connected component is processed to assign default values to the lawns, ensuring that all constraints are satisfied.\n5. **Final Check**: After assigning values, a final check ensures that all edges' constraints are met. If any constraint is violated, \"NO\" is printed; otherwise, the values are printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, m = int(input[ptr]), int(input[ptr+1])\n    ptr +=2\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])-1\n        v = int(input[ptr+1])-1\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append((u, v, g, l))\n    \n    parent = list(range(n))\n    rank = [1]*n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] *=2\n        else:\n            parent[v_root] = u_root\n            rank[u_root] *=2\n        return True\n    \n    constraints = {}\n    possible = True\n    for u, v, g, l in edges:\n        if u == v:\n            continue\n        if u not in constraints:\n            constraints[u] = {}\n        if v not in constraints:\n            constraints[v] = {}\n        if g not in constraints[u]:\n            constraints[u][g] = []\n        constraints[u][g].append(v)\n        if g not in constraints[v]:\n            constraints[v][g] = []\n        constraints[v][g].append(u)\n        if l in constraints[u]:\n            if v not in constraints[u][l]:\n                constraints[u][l].append(v)\n        else:\n            constraints[u][l] = [v]\n        if l in constraints[v]:\n            if u not in constraints[v][l]:\n                constraints[v][l].append(u)\n        else:\n            constraints[v][l] = [u]\n    \n    for u in range(n):\n        for v in constraints.get(u, {}):\n            if u < v:\n                if v in constraints.get(u, {})[v]:\n                    pass\n                else:\n                    possible = False\n                    break\n        if not possible:\n            break\n        if not constraints.get(u, {}):\n            pass\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    comp = {}\n    for u in range(n):\n        if u not in comp:\n            comp[u] = []\n    for u, v, g, l in edges:\n        if u == v:\n            continue\n        if find(u) != find(v):\n            union(u, v)\n    \n    for u in range(n):\n        root = find(u)\n        if root not in comp:\n            comp[root] = {\n                'nodes': [],\n                'g': 0,\n                'mul_gcd_lcm': {}\n            }\n        comp[root]['nodes'].append(u)\n    \n    for root in comp:\n        nodes = comp[root]['nodes']\n        g_total = 0\n        for u in nodes:\n            for g_val, vs in constraints.get(u, {}).items():\n                if u in vs and g_val in comp[root]['mul_gcd_lcm']:\n                    if comp[root]['mul_gcd_lcm'][g_val] != vs:\n                        possible = False\n                        break\n                else:\n                    comp[root]['mul_gcd_lcm'][g_val] = vs.copy()\n            if not possible:\n                break\n        if not possible:\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    assigned = {}\n    for root in comp:\n        nodes = comp[root]['nodes']\n        current_g = comp[root]['g']\n        base = 1\n        for u in nodes:\n            if u in assigned:\n                continue\n            if current_g == 0:\n                base = 1\n            else:\n                if base * current_g > 106:\n                    possible = False\n                    break\n                base *= current_g\n            assigned[u] = base\n        if not possible:\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    for u in range(n):\n        if u not in assigned:\n            assigned[u] = 1\n    \n    for u, v, g, l in edges:\n        if u == v:\n            continue\n        a = assigned[u]\n        b = assigned[v]\n        if gcd(a, b) != g or (a * b) // g != l:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(' '.join(map(str, assigned)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 545,
        "completion_token_count": 1437,
        "thoughts_token_count": 1025
    }
}