{
    "start": 1758103521.7866862,
    "end": 1758103650.5785682,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. Hmm, the problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and their total cost is as minimal as possible. If no such pair exists, we return -1.\n\nLet me break down the problem. We have n vouchers. Each voucher has a start day li, end day ri, and cost costi. The duration of each voucher is ri - li + 1. We need to choose two different vouchers i and j. These two must not intersect, meaning either the end of i is before the start of j or vice versa. Also, the sum of their durations should be exactly x. And among all such possible pairs, we need the one with the smallest total cost.\n\nHmm, okay. So the approach is to find all possible pairs of vouchers where their durations add up to x and they don't overlap. Then, among those pairs, find the one with the minimum cost.\n\nBut wait, n can be up to 2e5. So a naive O(n^2) approach would be way too slow. We need a more efficient method.\n\nSo how do we do this efficiently?\n\nLet's think about the constraints for two vouchers. Let's say voucher A has duration d1, voucher B has duration d2. So d1 + d2 = x. And their time intervals don't overlap.\n\nWait, but the sum of durations must be exactly x. So for each voucher, maybe we can look for another voucher whose duration is x minus the current one's duration.\n\nSo first, for each voucher, compute its duration. Then, for each voucher, we can look for another voucher with duration x - d, and check if they can be non-overlapping.\n\nBut even then, considering all vouchers, this might still be O(n^2), which is not feasible for n=2e5.\n\nWe need a smarter way.\n\nAlternative idea: group the vouchers by their duration. For each duration d, we'll have a list of vouchers with that duration. Then, for each voucher in a group of duration d, we look into the group of duration x-d to find a voucher that doesn't overlap and has the minimal cost.\n\nBut again, checking all possible pairs within the groups could still be O(n^2) in the worst case if many vouchers have the same duration.\n\nWait, but maybe we can pre-process the vouchers in a way that allows us to quickly find the minimal cost voucher that doesn't overlap.\n\nAnother thought: For each voucher, we can consider two cases:\n\nCase 1: The other voucher ends before this one starts. So, the other voucher's end < current voucher's start.\n\nCase 2: The other voucher starts after this one ends. So, the other voucher's start > current voucher's end.\n\nFor each voucher, we can look for vouchers in the required duration group that fit either case, and find the minimal cost.\n\nBut how to efficiently find these?\n\nPerhaps, for each duration d, we can keep track of the earliest end and latest start, etc. Or maybe, for each duration, we can have the vouchers sorted by their end or start times.\n\nWait, here's an idea: For each possible duration d (which is from 1 to x-1, since two durations must sum to x), we can process all vouchers with duration d. Then, for each such voucher, we look for vouchers with duration x-d that either end before this voucher starts or start after this voucher ends.\n\nBut even then, for each voucher, we need to query the required duration's vouchers and find the ones that are non-overlapping.\n\nSo perhaps, for each duration d, we can pre-sort the vouchers by their end times and start times, so that for a given voucher, we can quickly find the best possible candidate in the other group.\n\nLet me try to outline the steps:\n\n1. Precompute for each voucher its duration, which is ri - li + 1.\n\n2. Group the vouchers by their duration. So, create a dictionary where the key is the duration, and the value is a list of vouchers (li, ri, costi).\n\n3. For each voucher, calculate the required duration as req_d = x - current_d. If req_d is less than 0, skip. If req_d is zero, then we need two vouchers with same duration, but that's only possible if x is twice the duration. But wait, in that case, the two vouchers cannot overlap. So in that case, we can look for vouchers with duration d = x/2 and ensure they are non-overlapping.\n\n4. For each voucher, look into the group of req_d duration. For each voucher in this group, check if they can be paired with the current voucher without overlapping. Keep track of the minimal cost.\n\nBut even this approach would be O(n * m), where m is the average number of vouchers per req_d group.",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their total duration equals the given vacation duration and their combined cost is minimized. The solution involves efficiently searching for valid pairs of vouchers using precomputed data structures.\n\n### Approach\n1. **Precompute Durations**: For each voucher, compute its duration as `ri - li + 1`.\n2. **Group Vouchers by Duration**: Use a dictionary to group vouchers by their duration.\n3. **Check for Valid Pairs**: For each voucher, determine the required duration of another voucher to sum up to `x`. Check if there exists a voucher in the required group that does not overlap with the current voucher.\n4. **Efficient Search Using Sorted Lists**: For each duration group, maintain sorted lists of vouchers based on their start and end times to facilitate quick lookups for non-overlapping conditions.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n, x = int(input[idx]), int(input[idx+1])\n    idx += 2\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        c = int(input[idx+2])\n        vouchers.append((l, r, c))\n        idx +=3\n\n    duration_map = defaultdict(list)\n    for l, r, c in vouchers:\n        d = r - l +1\n        duration_map[d].append( (l, r, c) )\n\n    min_cost = float('inf')\n\n    # Pre-sort each group's vouchers by end time and start time\n    for d in duration_map:\n        vouchers_d = duration_map[d]\n        # Sort by end time\n        sorted_end = sorted(vouchers_d, key=lambda x: x[1])\n        # Sort by start time\n        sorted_start = sorted(vouchers_d, key=lambda x: x[0])\n        duration_map[d] = (sorted_end, sorted_start)\n\n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        current_d = r_i - l_i +1\n        req_d = x - current_d\n        if req_d <=0:\n            continue\n        if req_d not in duration_map:\n            continue\n        sorted_end, sorted_start = duration_map[req_d]\n        # Case 1: other voucher ends before this one starts\n        # Find all j where r_j < l_i\n        # We can use binary search to find the latest j with r_j < l_i\n        # The earliest possible j is the first in the list\n        left = 0\n        right = len(sorted_end)-1\n        best_c = float('inf')\n        while left <= right:\n            mid = (left + right) //2\n            if sorted_end[mid][1] < l_i:\n                best_c = min(best_c, sorted_end[mid][2])\n                left = mid +1\n            else:\n                right = mid -1\n        # Also check if any j exists\n        if best_c != float('inf'):\n            if best_c < min_cost:\n                min_cost = best_c\n        # Case 2: other voucher starts after this one ends\n        # Find all j where l_j > r_i\n        # Binary search to find the earliest j where l_j > r_i\n        left = 0\n        right = len(sorted_start)-1\n        best_c2 = float('inf')\n        while left <= right:\n            mid = (left + right) //2\n            if sorted_start[mid][0] > r_i:\n                best_c2 = min(best_c2, sorted_start[mid][2])\n                right = mid -1\n            else:\n                left = mid +1\n        if best_c2 != float('inf'):\n            if best_c2 < min_cost:\n                min_cost = best_c2\n\n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers.\n2. **Grouping by Duration**: Vouchers are grouped by their computed durations using a dictionary.\n3. **Sorting Groups**: Each group of vouchers by the same duration is sorted by both end time and start time to facilitate efficient searching.\n4. **Binary Search for Non-Overlapping Pairs**: For each voucher, we use binary search to quickly find the best non-overlapping voucher in the required duration group, minimizing the total cost.\n5. **Output Result**: The minimum cost is printed if found; otherwise, `-1` is printed if no valid pairs exist.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n, x = int(input[idx]), int(input[idx+1])\n    idx += 2\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        c = int(input[idx+2])\n        vouchers.append((l, r, c))\n        idx +=3\n\n    duration_map = defaultdict(list)\n    for l, r, c in vouchers:\n        d = r - l +1\n        duration_map[d].append( (l, r, c) )\n\n    min_cost = float('inf')\n\n    # Pre-sort each group's vouchers by end time and start time\n    for d in duration_map:\n        vouchers_d = duration_map[d]\n        # Sort by end time\n        sorted_end = sorted(vouchers_d, key=lambda x: x[1])\n        # Sort by start time\n        sorted_start = sorted(vouchers_d, key=lambda x: x[0])\n        duration_map[d] = (sorted_end, sorted_start)\n\n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        current_d = r_i - l_i +1\n        req_d = x - current_d\n        if req_d <=0:\n            continue\n        if req_d not in duration_map:\n            continue\n        sorted_end, sorted_start = duration_map[req_d]\n        # Case 1: other voucher ends before this one starts\n        # Find all j where r_j < l_i\n        # We can use binary search to find the latest j with r_j < l_i\n        # The earliest possible j is the first in the list\n        left = 0\n        right = len(sorted_end)-1\n        best_c = float('inf')\n        while left <= right:\n            mid = (left + right) //2\n            if sorted_end[mid][1] < l_i:\n                best_c = min(best_c, sorted_end[mid][2])\n                left = mid +1\n            else:\n                right = mid -1\n        # Also check if any j exists\n        if best_c != float('inf'):\n            if best_c < min_cost:\n                min_cost = best_c\n        # Case 2: other voucher starts after this one ends\n        # Find all j where l_j > r_i\n        # Binary search to find the earliest j where l_j > r_i\n        left = 0\n        right = len(sorted_start)-1\n        best_c2 = float('inf')\n        while left <= right:\n            mid = (left + right) //2\n            if sorted_start[mid][0] > r_i:\n                best_c2 = min(best_c2, sorted_start[mid][2])\n                right = mid -1\n            else:\n                left = mid +1\n        if best_c2 != float('inf'):\n            if best_c2 < min_cost:\n                min_cost = best_c2\n\n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 678,
        "completion_token_count": 999,
        "thoughts_token_count": 1025
    }
}