{
    "start": 1758278109.1055071,
    "end": 1758278310.165844,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Guard Duty,\" and from the description, I understand that we need to assign Rebel spaceships to guard B bases in such a way that each base has exactly one spaceship, and vice versa. But there's a catch: the paths from each base to its assigned spaceship shouldn't intersect any other paths. So, no two straight lines connecting a base to its spaceship should cross each other in the galaxy plane.\n\nHmm, right. So the first thing that comes to mind is that this is a matching problem, but with an additional geometric constraint. The main task is to determine whether such a perfect matching exists.\n\nLet's break down the problem.\n\nWe have R Rebel spaceships and B bases. Since it's a perfect matching, R must equal B. Otherwise, it's impossible, right? Wait, the input says 1 ≤ R, B ≤ 10. Oh, wait, but if R != B, then obviously it's impossible because a perfect matching requires the same number of elements on both sides. So the first check I can do is whether R equals B. If not, output No immediately.\n\nWait, looking at the input example, the first case has R=3 and B=3, which works, and the second case has R=2 and B=2 as well, but the answer is No because there's no possible matching without crossings. So yes, R must equal B for it to be possible.\n\nSo step one: Check if R == B. If not, output No.\n\nBut even when R equals B, it's possible that some subsets of the points form a non-crossing matching. So how do I model this?\n\nI think this is similar to finding a non-crossing bipartite matching between two sets of points. So the problem reduces to checking if such a bipartite graph exists where edges don't cross.\n\nWait, but how do I model the bipartition? The left side is the Rebels (spaceships) and the right side is the bases. Each Rebel can be connected to any base, but the connections must be such that the line segments between them don't cross each other.\n\nSo the approach would be:\n\n1. Generate all possible perfect matchings between the spaceships and bases.\n2. For each perfect matching, check if the corresponding line segments are non-crossing.\n3. If any such matching exists, output Yes. Otherwise, No.\n\nBut wait, the number of perfect matchings can be very large. For R=10, the number is 10! = 3,628,800. Hmm, that's manageable for brute-force since it's within computational limits, especially since R is up to 10. But generating all permutations and checking each could be feasible.\n\nBut wait, no—because for each permutation, we have to check if the lines between the matched points are non-crossing. That's O(R^2) per permutation, which for R=10 is 100 steps per permutation. So 3.6 million * 100 is about 360 million operations. That might be manageable in Python, but perhaps there's a smarter way.\n\nAlternatively, maybe we can model this as a problem of finding a non-crossing bipartition, but I'm not sure how to approach that algorithmically.\n\nSo let's think about the process.\n\nFirst, I'll need to represent the positions of the spaceships and the bases.\n\nEach spaceship is a point (xi, yi), and each base is a point (uj, vj). For each possible perfect matching (a bijection from spaceships to bases), I need to connect each spaceship to a base, and then ensure that none of the line segments cross.\n\nHow do I check for crossing line segments? Well, for four points A, B, C, D, the segments AB and CD cross if and only if the points are arranged in a certain way. But in this problem, the line segments are between the matched points. So for each pair of line segments, I need to determine if they intersect.\n\nWait, but for the entire matching, if any two segments cross, the matching is invalid. So for each matching, I have to check all possible pairs of segments to see if any cross.\n\nBut wait, another way: if the matching is a set of non-overlapping segments, then it's valid. So for a given permutation, the order of the matched points must be such that when connected in order, they don't cross.\n\nWait, no. Because the segments can be in any order as long as they don't cross each other. So the order in which you process them doesn't matter; you have to check every pair.\n\nSo perhaps the approach is:\n\n- For each possible perfect matching (i.e., each permutation of bases assigned to spaceships):\n   - Create a list of line segments, each connecting a spaceship to a base according to the permutation.\n   - Check whether any two",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship has exactly one assigned base. Additionally, the paths from each base to its assigned spaceship should not intersect in the galaxy plane.\n\n### Approach\n1. **Check for Perfect Matching**: First, we check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate Permutations**: For each possible permutation of bases assigned to spaceships, generate the corresponding line segments.\n3. **Check for Non-Crossing Segments**: For each permutation, check if any two line segments intersect. If none intersect, the permutation is valid, and we output \"Yes\". If no valid permutation is found, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\nR, B = map(int, sys.stdin.readline().split())\nspaceships = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    spaceships.append((x, y))\nbases = []\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\nspaceships.sort()\nbases.sort()\n\ndef ccw(A, B, C):\n    return (B[0] - A[0])*(C[1]-A[1]) - (B[1] - A[1])*(C[0]-A[0])\n\ndef segments_cross(s1, s2):\n    A, B = s1\n    C, D = s2\n    return ccw(A, B, C) * ccw(C, D, A) < 0\n\ndef is_valid(matching):\n    segments = []\n    for i in range(R):\n        s = spaceships[i]\n        b = bases[matching[i]]\n        segments.append((s, b))\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            if segments_cross(segments[i], segments[j]):\n                return False\n    return True\n\nfound = False\nfor perm in permutations(range(B)):\n    if is_valid(perm):\n        found = True\n        break\nprint(\"Yes\" if found else \"No\")\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Check for Equality**: If the number of spaceships does not match the number of bases, print \"No\".\n3. **Sorting Points**: Sorting helps in efficiently checking for intersections using the CCW (Counter Clockwise) method.\n4. **Permutations Check**: For each permutation of bases, check if the corresponding line segments do not cross. This is done by generating all permutations and validating each one.\n5. **Intersection Check**: Using the CCW method, we determine if two line segments intersect. If any segment pair in a permutation intersects, the permutation is invalid.\n6. **Output Result**: If a valid permutation is found, print \"Yes\"; otherwise, print \"No\".\n\nThis approach ensures that we explore all possible ways to assign spaceships to bases and efficiently check for non-crossing paths, ensuring correctness within computational limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\nR, B = map(int, sys.stdin.readline().split())\nspaceships = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    spaceships.append((x, y))\nbases = []\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\nspaceships.sort()\nbases.sort()\n\ndef ccw(A, B, C):\n    return (B[0] - A[0])*(C[1]-A[1]) - (B[1] - A[1])*(C[0]-A[0])\n\ndef segments_cross(s1, s2):\n    A, B = s1\n    C, D = s2\n    return ccw(A, B, C) * ccw(C, D, A) < 0\n\ndef is_valid(matching):\n    segments = []\n    for i in range(R):\n        s = spaceships[i]\n        b = bases[matching[i]]\n        segments.append((s, b))\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            if segments_cross(segments[i], segments[j]):\n                return False\n    return True\n\nfound = False\nfor perm in permutations(range(B)):\n    if is_valid(perm):\n        found = True\n        break\nprint(\"Yes\" if found else \"No\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 724,
        "thoughts_token_count": 1025
    }
}