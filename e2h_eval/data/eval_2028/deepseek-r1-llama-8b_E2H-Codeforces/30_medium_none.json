{
    "start": 1758289002.5095088,
    "end": 1758291162.5625112,
    "start-formatted": "2025-09-19 22:36 KST",
    "end-formatted": "2025-09-19 23:12 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"TV Game,\" and from the description, I need to find a sequence of moves for Homer and Marge that maximizes their total prize. \n\nHmm, the input is a string A with 2n digits. Each player makes exactly n moves. On each turn, the current player takes the leftmost digit of A and appends it to their number. Then that digit is removed from A. The initial numbers S1 and S2 are empty. At the end, the prize is based on these numbers.\n\nWait, the goal is to maximize the sum of S1 and S2. So we need to decide who takes which digits in such a way that when all is done, the sum of the two numbers is as large as possible.\n\nThe output should be a string of H and M (for Homer and Marge) indicating the sequence of moves.\n\nLet me think about how to model this. Since each move depends on choosing whether to take the next digit as H or M, but each must make exactly n moves. So the sequence is a string of 2n characters, each being H or M, with exactly n H's and n M's.\n\nBut wait, no, because the choice isn't arbitrary—each step depends on the order in which they pick the digits. Because the leftmost digit is taken each time, the order in which the digits are selected depends on who takes which digits at each step.\n\nSo the problem reduces to selecting a subset of the digits for Homer, with the rest going to Marge, in a way that the sum is maximized.\n\nWait, but the order matters because each digit is taken from the left as the game progresses. So the selection isn't just any subset, but a specific sequence where each step picks the first available digit and assigns it to either H or M.\n\nThis sounds like a dynamic programming problem. Because at each step, we have a certain state of the remaining digits, and we can choose whether the next move is H or M, which affects both the remaining digits and the accumulated score.\n\nSo the key is to model the state as the current position in the string and the number of moves made by each player so far. For example, state could be (i, h_made, m_made), where i is the current index in the string, h_made is the number of times Homer has taken a digit, and m_made is for Marge. But since each must make exactly n moves, h_made can only go up to n, same for m_made.\n\nWait, but given that the total steps are 2n, the sum of h_made and m_made is i. Because each step increases i by one. So perhaps the state can be represented as (i, h_made), since m_made is i - h_made.\n\nYes, that makes sense. So for each state, we can choose to take the next digit as H or M, provided that h_made < n for H and m_made < n for M.\n\nSo the DP approach would work here. We can represent the state as the current index (i) and the number of H's chosen so far (h). The value stored would be the maximum possible sum achievable from that state onward.\n\nThe recurrence would be:\n\ndp[i][h] = max(\n    take H: (digit value * 10^k) + dp[i+1][h+1],\n    take M: (0 * 10^k) + dp[i+1][h]\n)\n\nWait, but the digits are being taken in order, so each choice affects the subsequent choices. Also, each digit is part of a number that's built by appending to S1 or S2. So the value contributed by a digit depends on its position in the number.\n\nFor example, if a digit is taken as H's move, it's added as the next digit in S1. So if S1 currently has '12', adding a new digit d would make it '12d' which is 100*1 + 10*2 + d.\n\nWait, but building the numbers step by step is tricky because each new digit is added to the right. So the value of the number is the sum of d_i * 10^{k-i} for each digit d_i, where k is the number of digits.\n\nSo for S1, each new digit is multiplied by 10^current_length, which is 10^{(number of digits so far)}.\n\nSo for the DP, when we take a digit d at position i, if it's assigned to H, then the contribution to the sum is d * 10^{(current length of S1)}. But the current length of S1 is determined by how many digits have been taken before this step.\n\nWait, but the state needs to keep track of the current lengths of S1 and S2 because each new digit adds to one of them, which changes the multiplier for the next digits.\n\nHmm, that complicates things because the state now needs to include not just the current index and the count of H and M moves, but also the current lengths of S1 and S2. But that's impossible because the state space becomes too big—each of the lengths can be up to 18, so 18 * 18 * ... for all variables.\n\nWait, but maybe there's a smarter way. Let me think again.\n\nEach time a digit is taken, it's appended to either S1 or S2. So for each digit, depending on who takes it, it contributes d * 10^k to either S1 or S2, where k is the current number of digits in that player's number before this move.\n\nSo the key is to model the state as the current index, and the current lengths of S1 and S2.\n\nBecause the contribution of a digit depends on when it's taken—its position in the sequence.\n\nSo the state is (i, s1, s2), where i is the current position in the string, s1 is the number of digits already taken for S1, and s2 is for S2. Wait, but that might be manageable because each step increases either s1 or s2 by 1.\n\nBut wait, for n=18, the maximum s1 can be up to 18, and same for s2. So the state size is 2n * 19 * 19, which for n=18 is 36*361=12996 states. That's manageable.\n\nSo the DP function will compute the maximum possible sum from state (i, s1, s2). The transitions are:\n\n- If we assign the current digit (A[i]) to H:\n   new_s1 = s1 + 1\n   new_sum = (int(digit) * 10^s1) + dp(i+1, new_s1, s2)\n   but only if new_s1 <= n.\n\n- Similarly for assigning to M:\n   new_s2 = s2 + 1\n   new_sum = (int(digit) * 10^s2) + dp(i+1, s1, new_s2)\n   but only if new_s2 <= n.\n\nThe base case is when i == len(A), which means all digits are processed. The sum is zero in that case.\n\nWait, but we also need to track the path, not just the maximum sum. Because once we know the maximum sum, we need to reconstruct the sequence of H and M moves that led to it.\n\nSo the DP will need to store not just the maximum sum for each state, but also the path taken to reach it. Alternatively, we can perform a BFS with memoization, storing for each state the best sum and the corresponding sequence.\n\nBut this could get complicated. Alternatively, after computing the DP table, we can backtrack from the end to determine the choices made at each step.\n\nSo the plan is:\n\n1. Precompute for each state (i, s1, s2) the maximum possible sum.\n\n2. Once the DP table is filled, starting from i=2n, s1=n, s2=n, we can backtrack to determine which choice (H or M) was made at each step.\n\nBut first, let's think about how to model the DP.\n\nWait, the string is given as a string of 2n digits. Let's index it from 0 to 2n-1.\n\nAt each step i, we can choose to take A[i] as H or M.\n\nIf we choose H:\n\n- H's number S1 gains a new digit. The contribution is A[i] * 10^(current length of S1). The current length is s1, so the contribution is A[i] * 10^s1.\n\n- Then, the next state is i+1, with s1+1, s2 remains the same.\n\nSimilarly for M.\n\nSo the DP recurrence is:\n\ndp[i][s1][s2] = max(\n    (A[i] * 10^s1) + dp[i+1][s1+1][s2], \n    (A[i] * 10^s2) + dp[i+1][s1][s2+1]\n)\n\nBut this is only valid if s1 < n or s2 < n, respectively.\n\nThe base case is when i == 2n: dp[2n][s1][s2] = 0, since there are no more digits to process.\n\nNow, the challenge is to implement this DP, considering all possible states.\n\nBut wait, for n=18, the maximum s1 and s2 can be up to 18 each, and i can be up to 36. So the state space is 36 * 19 * 19 = 36*361= ~13,000 states. That's manageable.\n\nSo the steps are:\n\n- Read n and A.\n\n- Convert A into a list of integers, so each digit is an integer.\n\n- Precompute the powers of 10 up to 2n. Because for each digit, when it's taken as the k-th digit, it's multiplied by 10^(current digits in S1 or S2).\n\nWait, but for each state, the power depends on s1 or s2, which is the current count of digits in their numbers. So during the DP, for a given state (i, s1, s2), the contribution for taking H is digit * 10^s1, and for M it's digit * 10^s2.\n\nSo, the precomputed powers can be stored in a 2D array, pow10, where pow10[k] = 10^k.\n\nNow, the DP can be implemented as a memoization table, using recursion with memoization or iterative DP.\n\nBut for Python, recursion with memoization might hit stack limits for n=18, which is 36 steps. So it's better to implement the DP iteratively.\n\nAlternatively, use memoization with functools.lru_cache, but for 2n=36 steps, that should be manageable.\n\nWait, but the state is (i, s1, s2). So for each state, we need to calculate the maximum sum.\n\nLet me outline the code structure.\n\nFirst, read the input:\n\nn = int(input())\nA = input().strip()\n\nThen, convert A into a list of integers:\n\ndigits = [int(c) for c in A]\n\nThen, precompute the powers of 10:\n\npow10 = [1] * (n + 1)\nfor i in range(1, n+1):\n    pow10[i] = pow10[i-1] * 10\n\nWait, but wait, the maximum s1 or s2 can be up to n. So pow10 needs to handle exponents up to n.\n\nOnce that's done, set up the DP table.\n\nWe can represent the DP as a dictionary or a 3D array. Since n can be up to 18, and i can be up to 36, and s1 and s2 up to 18, a 3D array is feasible.\n\nInitialize dp as a 3-dimensional array, where dp[i][s1][s2] represents the maximum sum achievable from state i onwards, given that s1 digits have been taken for H and s2 for M.\n\nWe can initialize all dp entries to -infinity, except the base case.\n\nInitialize dp[2n][s1][s2] = 0 for all s1, s2?\n\nWait, no. When i=2n, there are no more digits to process, so the sum is 0. So for i=2n, regardless of s1 and s2, the sum is 0.\n\nWait, but s1 can be up to n, and s2 up to n. So for i=2n, all possible (s1, s2) pairs where s1 + s2 = 2n? No, wait, because in each step, s1 or s2 increases by 1. So when i=2n, s1 + s2 = 2n, but that's only if all digits are processed.\n\nWait, no. Because in each step, either s1 or s2 is increased by 1. So for each state (i, s1, s2), i = s1 + s2.\n\nAh, right! Because each step increments either s1 or s2 by 1. So the sum s1 + s2 must equal i.\n\nThat's a crucial observation. So for each state (i, s1, s2), it must hold that s1 + s2 = i.\n\nTherefore, in the DP, for a state (i, s1, s2), s2 can be computed as i - s1.\n\nThis reduces the state space because for each i, s2 is determined by s1.\n\nSo the state can be represented as (i, s1), since s2 = i - s1.\n\nThat's a significant optimization. Now, the state is (i, s1), and for each state, we can calculate s2 as i - s1.\n\nSo, the DP table can be a 2D array of size (2n+1) x (n+1), since s1 can range from 0 to n.\n\nSo the recurrence is:\n\nif i == 2n:\n    return 0\nelse:\n    option1 = (digit[i] * 10^s1) + dp[i+1][s1 + 1]\n    option2 = (digit[i] * 10^(i - s2)) + dp[i+1][s2 + 1]\n    return max(option1, option2)\n\nWait, no. Because when taking as H, s1 increases by 1. So the next state is (i+1, s1+1). The contribution is digit[i] * 10^s1, because s1 is the current number of digits in S1 before adding this one.\n\nWhen taking as M, the s2 increases by 1, so the next state is (i+1, s1), and the contribution is digit[i] * 10^s2, which is 10^(i - s1) because s2 = i - s1.\n\nSo, for each state (i, s1), the next options are:\n\noption1: H, which requires s1 < n.\n\noption1_val = digit[i] * (10 ** s1) + dp[i+1][s1 + 1]\n\noption2: M, which requires s2 < n. But s2 = i - s1, so i - s1 < n → s1 > i - n.\n\nSo, for option2 to be valid, s1 must be greater than i - n.\n\noption2_val = digit[i] * (10 ** (i - s1)) + dp[i+1][s1]\n\nThen, the maximum of option1 and option2 is the value for dp[i][s1].\n\nWait, but we also have to consider if the current choice is allowed. For example, if H has already made n moves, we can't choose H anymore. Similarly for M.\n\nSo, for each state (i, s1):\n\nif s1 >= n → can't choose H.\n\nif s2 = i - s1 >= n → can't choose M.\n\nThus, for each state, we can only choose the options that are allowed.\n\nSo, the steps are:\n\nFor each state (i, s1):\n\n- if i == 2n → return 0.\n\n- else:\n\n   option1 = if s1 < n → digit[i] * 10^s1 + dp[i+1][s1+1]\n\n   option2 = if (i - s1) < n → digit[i] * 10^(i - s1) + dp[i+1][s1]\n\n   take the maximum between the available options.\n\nNow, the initial state is (0, 0), because before any moves, i=0, s1=0, s2=0.\n\nWe can build the DP table using a bottom-up approach.\n\nSo, for i from 2n down to 0:\n\n   for s1 in 0 to min(n, i):\n\n       s2 = i - s1\n\n       if s2 > n → skip (since M cannot have more than n moves)\n\n       if s1 > n → skip (H cannot have more than n moves)\n\n       if i == 2n:\n\n           dp[i][s1] = 0\n\n       else:\n\n           option1 = -infinity\n\n           if s1 < n:\n\n               digit_i = digits[i]\n\n               val1 = digit_i * (10 ** s1)\n\n               if i+1 <= 2n:\n\n                   option1 = val1 + dp[i+1][s1 + 1]\n\n           option2 = -infinity\n\n           if (i - s1) < n:\n\n               digit_i = digits[i]\n\n               val2 = digit_i * (10 ** (i - s1))\n\n               if i+1 <= 2n:\n\n                   option2 = val2 + dp[i+1][s1]\n\n           dp[i][s1] = max(option1, option2)\n\nWait, but this is a bottom-up approach, filling the dp table from higher i to lower i.\n\nBut wait, for i from 2n downto 0:\n\n   for each possible s1 in 0..min(n, i):\n\n       compute s2 = i - s1\n\n       check constraints on s1 and s2.\n\n       then compute the options.\n\nBut how to handle the transitions correctly.\n\nWait, but the digits are fixed, so for each i, the digit is known.\n\nSo, the code outline is:\n\nn = int(input())\nA = input().strip()\ndigits = [int(c) for c in A]\npow10 = [1]*(n+1)\nfor i in range(1, n+1):\n    pow10[i] = pow10[i-1] * 10\n\nmax_i = 2*n\n\n# Initialize DP table\ndp = [[-1 for _ in range(n+1)] for __ in range(max_i +1)]\n\nfor i in range(max_i, -1, -1):\n    for s1 in range(0, n+1):\n        s2 = i - s1\n        if s2 < 0 or s2 > n:\n            continue\n        if i == max_i:\n            dp[i][s1] = 0\n        else:\n            # Option 1: choose H\n            if s1 < n:\n                val1 = digits[i] * pow10[s1]\n                next_i = i +1\n                if next_i <= max_i:\n                    if dp[next_i][s1 +1] != -1:\n                        option1 = val1 + dp[next_i][s1 +1]\n                    else:\n                        # if the next state is unreachable, then this option is worse than the other\n                        option1 = -float('inf')\n                else:\n                    option1 = val1  # next_i is beyond, so no more steps\n            else:\n                option1 = -float('inf')\n            \n            # Option 2: choose M\n            if s2 < n:  # since s2 = i - s1, and s2 < n\n                val2 = digits[i] * pow10[s2]\n                next_i = i +1\n                if next_i <= max_i:\n                    if dp[next_i][s1] != -1:\n                        option2 = val2 + dp[next_i][s1]\n                    else:\n                        option2 = -float('inf')\n                else:\n                    option2 = val2  # no more steps\n            else:\n                option2 = -float('inf')\n            \n            dp[i][s1] = max(option1, option2)\n\nWait, but what about when the next_i is beyond max_i? For example, when i is 2n-1, next_i is 2n, which is allowed. So in that case, we add the current value and 0.\n\nWait, in the code above, for i=2n-1, next_i=2n, which is within the loop. So for i=2n, the dp is 0.\n\nSo perhaps the code should be:\n\nfor i in range(max_i, -1, -1):\n    for s1 in range(0, n+1):\n        s2 = i - s1\n        if s2 <0 or s2 >n:\n            continue\n        if i == max_i:\n            dp[i][s1] = 0\n        else:\n            option1 = option2 = -float('inf')\n            if s1 < n:\n                next_i = i +1\n                if next_i <= max_i:\n                    if dp[next_i][s1+1] != -1:\n                        option1 = digits[i] * pow10[s1] + dp[next_i][s1+1]\n                else:\n                    # next_i is 2n, which is handled by dp\n                    option1 = digits[i] * pow10[s1]\n            if option1 == -float('inf'):\n                # no option1\n                pass\n            else:\n                pass\n            \n            if s2 <n:\n                next_i = i+1\n                if next_i <= max_i:\n                    if dp[next_i][s1] != -1:\n                        option2 = digits[i] * pow10[s2] + dp[next_i][s1]\n                else:\n                    option2 = digits[i] * pow10[s2]\n            else:\n                option2 = -float('inf')\n            \n            dp[i][s1] = max(option1, option2)\n\nWait, perhaps I'm overcomplicating it. Let's try to code it properly.\n\nBut perhaps, instead of trying to code this, I can model the DP as a memoization function.\n\nBut in Python, using lru_cache for memoization might be manageable, but the parameters would be i, s1, s2. But since s2 = i - s1, we can represent it as i and s1.\n\nSo let's try to write a recursive function with memoization.\n\nSomething like:\n\nfrom functools import lru_cache\n\ndef dp(i, s1):\n    if i == 2*n:\n        return 0\n    res = 0\n    # option 1: take H\n    if s1 < n:\n        val1 = digits[i] * (10 ** s1)\n        next_val = dp(i+1, s1+1)\n        res = max(res, val1 + next_val)\n    # option 2: take M\n    s2 = i - s1\n    if s2 < n:\n        val2 = digits[i] * (10 ** s2)\n        next_val = dp(i+1, s1)\n        res = max(res, val2 + next_val)\n    return res\n\nBut wait, this function would return the maximum sum, but we need to also track the path. So for each state, we need to know not just the maximum sum, but also the choice made (H or M) to get there.\n\nHmm, that complicates things. Because the standard memoization approach only tracks the value, not the path.\n\nAn alternative approach is to perform a BFS, keeping track of the current state and the path taken to reach it, along with the current sum.\n\nBut for n=18, 2n=36, and s1 up to 18, the number of states is manageable, so this might be feasible.\n\nWait, each state is (i, s1), and for each state, we can track the best sum and the path leading to it.\n\nBut for the purposes of this problem, we just need one possible path that leads to the maximum sum. So perhaps, during the DP computation, for each state, we can store not only the maximum sum but also the choice (H or M) that led to it.\n\nAlternatively, once the DP is filled, we can backtrack from (i=2n, s1=n, s2=n) to find the sequence of choices.\n\nWait, but in the DP, the state is (i, s1), and s2 is i - s1.\n\nSo, the initial state is (i=0, s1=0). The final state is (i=2n, s1=n, s2=n).\n\nWait, but in the DP, for i=2n, s1 can be any value, but s1 + s2 = 2n.\n\nSo, to reach the final state, s1 must be n, because s1 + s2 = 2n and both must be exactly n.\n\nSo, the backtracking starts from (i=2n, s1=n).\n\nSo, let's outline the steps:\n\n1. Compute the DP table as described, storing the maximum sum for each (i, s1).\n\n2. Starting from (i=2n, s1=n), backtrack through the DP to find the sequence of choices.\n\nAt each step, for the current state (i, s1), we look at whether the previous choice was H or M.\n\nHow?\n\nFor each state (i, s1), the previous state could have been:\n\n- If the current state is (i, s1), then the previous state is (i-1, s1_prev), where s1_prev is s1-1 if the current choice is H, or s1 remains the same if the current choice is M.\n\nWait, no. Let's think about it.\n\nTo reach (i, s1), the previous state must have been (i-1, s1_prev), and the choice made was to take H or M.\n\nCase 1: Previous choice was H.\n\nThen, s1_prev = s1 -1, and i_prev = i-1.\n\nSo, dp[i][s1] = dp[i_prev][s1_prev] + (digit[i_prev] * 10^{s1_prev}).\n\nIn this case, the digit at position i_prev was taken as H.\n\nCase 2: Previous choice was M.\n\nThen, s1_prev = s1, and i_prev = i-1.\n\nSo, dp[i][s1] = dp[i_prev][s1_prev] + (digit[i_prev] * 10^{s2_prev}), where s2_prev = (i_prev) - s1_prev.\n\nWait, but s2_prev = (i-1) - s1_prev.\n\nBut since in this case, the choice is M, s1_prev = s1, so s2_prev = (i-1) - s1.\n\nAnd the contribution is digit[i-1] * 10^{s2_prev}.\n\nWait, this is getting a bit tangled.\n\nAlternatively, for each state (i, s1), the previous state is (i-1, s1_prev), and the digit taken was at position i-1.\n\nSo, the decision at step i-1 was whether to take H or M.\n\nIf it was H, then s1_prev = s1 -1, and the digit was taken as H.\n\nIf it was M, then s1_prev = s1, and the digit was taken as M.\n\nSo, to backtrack, for each state (i, s1), we can check whether taking H or M in the previous step gives a better sum.\n\nWait, but how do we determine which choice was made in the previous step?\n\nWe can compare the current dp[i][s1] with the two possible previous states.\n\nWait, perhaps not. Instead, for each state (i, s1), the previous state is (i-1, s1_prev), which could have come from either a H or M choice.\n\nBut given that, for each possible previous state, we can compute the value and see if it's equal to the current value.\n\nWait, perhaps in the backtracking, for each state (i, s1), we can look at the previous state (i-1, s1_prev) and see whether the transition from that state to (i, s1) was via H or M.\n\nBut this might require some computation.\n\nAlternatively, for each state (i, s1), the maximum sum is the maximum of the two possible options (H and M) from the previous state.\n\nWait, perhaps the backtracking can proceed as follows:\n\nStart from (i=2n, s1=n). The sum is 0.\n\nMove to (i=2n-1, s1_new) where s1_new could be n-1 (if last choice was H) or n (if last choice was M).\n\nWait, no. Because when i=2n, the previous step was i=2n-1.\n\nSo, for (i=2n, s1=n):\n\nWe came from (i=2n-1, s1_prev), where either:\n\n- s1_prev = n-1, and the last choice was H.\n\nOr:\n\n- s1_prev = n, and the last choice was M.\n\nSo, for each possibility, we can see which one gives a higher sum.\n\nWait, but in the DP, for (i=2n, s1=n), the sum is 0.\n\nSo, for i=2n-1, s1_prev can be n-1 or n.\n\nBut wait, s1_prev + s2_prev = i=2n-1.\n\nIf s1_prev is n-1, then s2_prev is 2n-1 - (n-1) = n.\n\nWhich is allowed because M can have up to n moves.\n\nSo, for i=2n-1, s1_prev could be n-1 (if last choice was H), or n (if last choice was M).\n\nBut wait, M can't have more than n moves. So, when i=2n-1, s1_prev can't be less than (2n-1) - n = n-1.\n\nWait, no. s1_prev can be from 0 to n.\n\nBut for i=2n-1, s1_prev can be anything such that s2_prev = i - s1_prev is <=n.\n\nSo, s1_prev >= i - n → s1_prev >= (2n-1) -n = n-1.\n\nSo, for i=2n-1, s1_prev can be from n-1 to n.\n\nSo, for each possible s1_prev in [n-1, n], we can see if the transition from (i=2n-1, s1_prev) to (i=2n, n) is possible.\n\nWait, but the transition to (i=2n, n) can only happen if the last choice was H (so s1_prev = n-1) or M (s1_prev = n).\n\nBut in the DP, the sum for (i=2n, n) is 0, which comes from adding the value of the last digit.\n\nSo, the sum for (i=2n, n) is equal to the sum of the last digit's contribution plus 0.\n\nWait, no. Because the last digit is added to either H or M.\n\nSo, for i=2n-1, the digit is taken as H or M, contributing to the sum.\n\nThen, the next state is i=2n, s1 or s2.\n\nSo, for the state (i=2n, s1=n), it's only possible if the last choice was M, because s1 would have remained n.\n\nWait, let me re-express:\n\nAt i=2n-1, s1_prev can be n-1 (last choice was H) or n (last choice was M).\n\nSo, if the last choice was H:\n\n- s1_prev = n-1.\n\n- The next state is (i=2n, s1_prev+1) = (2n, n).\n\n- The contribution is digit[i=2n-1] * 10^{n-1}.\n\nIf the last choice was M:\n\n- s1_prev = n.\n\n- The next state is (i=2n, s1_prev) = (2n, n).\n\n- The contribution is digit[i=2n-1] * 10^{n}.\n\nSo, for the state (2n, n), the sum is the maximum between the two options.\n\nBut wait, in the DP, the sum is stored as the maximum of all possible paths, so the sum at (2n, n) is the maximum between the two options.\n\nSo, during backtracking, for (2n, n), we can determine whether the last choice was H or M based on which option gives a higher sum.\n\nWait, but in the DP, the sum is stored as the maximum, so if both options are possible, the sum is the maximum of the two.\n\nBut for backtracking, we need to choose the path that contributed to the maximum sum.\n\nSo, perhaps, for each state, we can track not only the maximum sum but also the choice that leads to it.\n\nBut this would complicate the DP implementation, as each state would need to store two values: the maximum sum and the choice.\n\nAlternatively, during backtracking, for each state, we can compute both possibilities and choose the one that leads to the maximum sum.\n\nBut for the problem, any correct path that achieves the maximum sum is acceptable.\n\nSo, the plan is:\n\n1. Compute the DP table as described, which gives the maximum sum for each state.\n\n2. Starting from (2n, n), backtrack to find the sequence of choices.\n\n   a. For the current state (i, s1), check if it was reached by a H or M choice in the previous step.\n\n   b. To determine this, look at the possible previous states (i-1, s1_prev) and see which one, when taking the appropriate choice, leads to the current sum.\n\nBut how to do this without knowing the previous sum?\n\nWait, perhaps we can model the backtracking by checking both possibilities.\n\nFor each state (i, s1), we can look at the previous state (i-1, s1_prev) and see if transitioning from that state via H or M would result in the current sum.\n\nBut for the purposes of backtracking, perhaps it's easier to build the path step by step.\n\nAnother idea is to keep a parent pointer for each state, indicating whether the previous choice was H or M.\n\nBut this may not be feasible due to the state space.\n\nAlternatively, during the backtracking, for each state, we can iterate through all possible previous states and see which one could lead to the current state, then choose the one that gives the maximum sum.\n\nWait, but that could be time-consuming.\n\nPerhaps, for each state (i, s1), the maximum sum is known. So for each possible previous state (i-1, s_prev), we can calculate what the sum would be if we took H or M, and see if it matches the current sum.\n\nBut this seems computationally expensive.\n\nWait, perhaps the way to proceed is to create a 2D array that for each state (i, s1) stores the maximum sum, and another 2D array that stores the choice (H or M) that led to this state.\n\nBut for the DP, the maximum sum is stored, and the choice can be determined based on the previous state.\n\nAlternatively, during the backtracking, for each state, we can try both possibilities and see which one gives the maximum sum.\n\nBut how?\n\nLet me think differently. The maximum sum for a state is computed as the maximum of the two possible options.\n\nSo, for each state (i, s1), the maximum sum is either:\n\nsum_H = (digit[i] * 10^s1) + dp[i+1][s1+1]\n\nsum_M = (digit[i] * 10^(i-s1)) + dp[i+1][s1]\n\nthen dp[i][s1] = max(sum_H, sum_M)\n\nSo, during backtracking, for a given state (i, s1), we can determine whether the choice was H or M by seeing which option was chosen to get the maximum sum.\n\nBut wait, for each state, the maximum sum is stored, but the actual choice that led to it isn't tracked. So, during backtracking, for each state, we'd have to try both possibilities and see which one leads to the maximum sum.\n\nWait, but that might not be efficient, but given the small state space, it's manageable.\n\nSo, the backtracking function can be something like:\n\ndef backtrack(i, s1, path):\n    if i == 2n:\n        return path\n    if (i, s1) in memo:\n        return memo[(i, s1)]\n    max_sum = dp[i][s1]\n    # try both options\n    # option 1: H\n    if s1 < n:\n        next_sum = backtrack(i+1, s1+1, path + 'H')\n        if next_sum + (digit[i] * 10^s1) == max_sum:\n            # this path is possible\n            return backtrack(i+1, s1+1, path + 'H')\n    # option 2: M\n    if (i - s1) < n:\n        next_sum = backtrack(i+1, s1, path + 'M')\n        if next_sum + (digit[i] * 10^(i - s1)) == max_sum:\n            return backtrack(i+1, s1, path + 'M')\n    # if neither works, this path is invalid (shouldn't happen)\n    return None\n\nBut wait, this approach is incorrect because the next_sum is not known until the backtrack function returns. So, perhaps it's better to compute both possibilities and choose the one that gives the maximum sum.\n\nAlternatively, for each state, we can try",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for two players, Homer and Marge, in a TV game where they take turns picking digits from a given number to maximize their total prize. Each player must make exactly `n` moves.\n\n### Approach\nThe problem can be approached using dynamic programming (DP) to keep track of the maximum possible sum each player can achieve at each step. The key steps are as follows:\n\n1. **State Representation**: Use a DP table where `dp[i][s1]` represents the maximum sum achievable starting from the `i-th` digit with `s1` digits already taken by Homer. The remaining digits taken by Marge can be derived as `i - s1`.\n\n2. **Transitions**: For each state `(i, s1)`, consider two options:\n   - Take the current digit as Homer's move, contributing `digit[i] * 10^s1` to his sum.\n   - Take the current digit as Marge's move, contributing `digit[i] * 10^(i-s1)` to her sum.\n\n3. **Backtracking**: After computing the DP table, backtrack from the final state to determine the sequence of moves that led to the maximum sum. This involves checking both possible previous states (Homer's or Marge's move) and selecting the one that contributes to the maximum sum.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    max_i = 2 * n\n    pow10 = [1] * (n + 1)\n    for i in range(1, n+1):\n        pow10[i] = pow10[i-1] * 10\n\n    @lru_cache(maxsize=None)\n    def dp(i, s1):\n        if i == max_i:\n            return 0\n        res = 0\n        # Option 1: take H\n        if s1 < n:\n            val_h = digits[i] * pow10[s1]\n            next_val = dp(i+1, s1+1)\n            res = max(res, val_h + next_val)\n        # Option 2: take M\n        s2 = i - s1\n        if s2 < n:\n            val_m = digits[i] * pow10[s2]\n            next_val = dp(i+1, s1)\n            res = max(res, val_m + next_val)\n        return res\n\n    max_sum = dp(0, 0)\n\n    path = []\n    current_i = max_i\n    current_s1 = n\n\n    while current_i > 0:\n        s2 = current_i - current_s1\n        option1 = None\n        option2 = None\n\n        if current_s1 < n:\n            val_h = digits[current_i - 1] * pow10[current_s1]\n            next_i = current_i -1\n            next_s1 = current_s1 -1\n            if dp(next_i, next_s1) != -1:\n                option1 = val_h + dp(next_i, next_s1)\n        if s2 < n:\n            val_m = digits[current_i -1] * pow10[s2]\n            next_i = current_i -1\n            next_s1 = current_s1\n            if dp(next_i, next_s1) != -1:\n                option2 = val_m + dp(next_i, next_s1)\n\n        if option1 is not None and option2 is not None:\n            if option1 > option2:\n                path.append('H')\n                current_s1 +=1\n            else:\n                path.append('M')\n        elif option1 is not None:\n            path.append('H')\n            current_s1 +=1\n        else:\n            path.append('M')\n\n        current_i -=1\n\n    path.reverse()\n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Precompute Powers of 10**: These are used to calculate the contribution of each digit based on its position.\n3. **Dynamic Programming Function**: The `dp` function uses memoization to store results of subproblems to avoid recomputation.\n4. **Backtracking**: Starting from the end state, the code determines the sequence of moves by checking which choice (Homer or Marge) contributed to the maximum sum at each step.\n5. **Output**: The sequence of moves is printed as a string of 'H' and 'M'.\n\nThis approach efficiently computes the optimal sequence using dynamic programming and backtracking, ensuring both players make exactly `n` moves and maximize their total prize.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    max_i = 2 * n\n    pow10 = [1] * (n + 1)\n    for i in range(1, n+1):\n        pow10[i] = pow10[i-1] * 10\n\n    @lru_cache(maxsize=None)\n    def dp(i, s1):\n        if i == max_i:\n            return 0\n        res = 0\n        # Option 1: take H\n        if s1 < n:\n            val_h = digits[i] * pow10[s1]\n            next_val = dp(i+1, s1+1)\n            res = max(res, val_h + next_val)\n        # Option 2: take M\n        s2 = i - s1\n        if s2 < n:\n            val_m = digits[i] * pow10[s2]\n            next_val = dp(i+1, s1)\n            res = max(res, val_m + next_val)\n        return res\n\n    max_sum = dp(0, 0)\n\n    path = []\n    current_i = max_i\n    current_s1 = n\n\n    while current_i > 0:\n        s2 = current_i - current_s1\n        option1 = None\n        option2 = None\n\n        if current_s1 < n:\n            val_h = digits[current_i - 1] * pow10[current_s1]\n            next_i = current_i -1\n            next_s1 = current_s1 -1\n            if dp(next_i, next_s1) != -1:\n                option1 = val_h + dp(next_i, next_s1)\n        if s2 < n:\n            val_m = digits[current_i -1] * pow10[s2]\n            next_i = current_i -1\n            next_s1 = current_s1\n            if dp(next_i, next_s1) != -1:\n                option2 = val_m + dp(next_i, next_s1)\n\n        if option1 is not None and option2 is not None:\n            if option1 > option2:\n                path.append('H')\n                current_s1 +=1\n            else:\n                path.append('M')\n        elif option1 is not None:\n            path.append('H')\n            current_s1 +=1\n        else:\n            path.append('M')\n\n        current_i -=1\n\n    path.reverse()\n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 1020,
        "thoughts_token_count": 8193
    }
}