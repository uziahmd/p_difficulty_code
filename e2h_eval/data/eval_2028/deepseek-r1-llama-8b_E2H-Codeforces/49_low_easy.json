{
    "start": 1758278878.8745027,
    "end": 1758279526.3118265,
    "start-formatted": "2025-09-19 19:47 KST",
    "end-formatted": "2025-09-19 19:58 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called Mushroom Strife. Hmm. So the setup is that Pasha and Akim made a forest map where lawns are vertices and roads are edges. Each road has two numbers: GCD and LCM of the mushrooms on the connected lawns. But now, some of the map is torn, leaving only m roads. My task is to help restore the number of mushrooms on every lawn based on the given roads. If it's not possible, output NO; else, output any valid arrangement.\n\nThe input gives n and m, followed by m lines each with four numbers: the two lawns connected by the road, the GCD, and the LCM of their mushroom counts.\n\nHmm. So, how do I model this? It seems like a graph problem where each edge imposes constraints on the values of the nodes (lawns). Each node must have a value (number of mushrooms), and each edge enforces that for the two nodes u and v, the GCD of their values is g, and the LCM is l.\n\nWait, but wait. Wait, GCD(u, v) = g and LCM(u, v) = l. Also, since GCD and LCM are related to each other via the product: GCD * LCM = u * v. Because for any two numbers, GCD(a,b)*LCM(a,b) = a*b. So that's an important relationship.\n\nSo for each edge, given u and v, we know that g = GCD(a, b) and l = LCM(a, b), where a is the value of u and b is the value of v. So for each edge, a and b must satisfy:\n\ng = gcd(a, b)\nl = lcm(a, b)\n\nAnd since l must be a multiple of g, because LCM is always greater than or equal to GCD. So if the input has a case where l < g, then it's impossible, right?\n\nBut the problem says that the initial numbers on the roads were no less than 1 and didn't exceed 106. So in our input, all the given GCDs and LCMs are within that range. So perhaps during processing, if any of them is invalid, we can immediately return NO.\n\nSo, the first step is to model the problem as a system of constraints. Each edge between u and v gives us two equations:\n\n1. g = gcd(a_u, a_v)\n2. l = lcm(a_u, a_v)\n\nBut since a_u and a_v must satisfy both, perhaps we can represent the possible values of a_u and a_v for each edge and then find a consistent assignment across all edges.\n\nHmm, but the variables are the a_i's for each node i. So this is a constraint satisfaction problem. How to model this?\n\nI think using a Union-Find (Disjoint Set Union) data structure might be helpful here, but I'm not sure. Alternatively, since each edge connects two variables and imposes certain relationships, perhaps building a graph where each node's value is determined relative to others, similar to a system of equations.\n\nWait, another approach: For each connected component, assign a variable x, and express the a_i's in terms of x. For example, if we have a tree of nodes connected by edges, each edge will impose a relation between the variables, which can be represented as multiplicative factors.\n\nLet me think more carefully. Suppose we have a chain of nodes: u - (g1, l1) -> v - (g2, l2) -> w. Each edge gives constraints on the pairs.\n\nFor the first edge, u and v: a_u and a_v must satisfy g1 = gcd(a_u, a_v), l1 = lcm(a_u, a_v). Similarly for the second edge between v and w.\n\nBut how to model this across multiple edges? It's a system that needs to be solved.\n\nWait, maybe for each connected component, we can assign a variable to a root node, say r, and express all other nodes in terms of r.\n\nEach edge in the component would then relate the variables of its endpoints. For example, if node u is connected to node v with edge (g, l), then a_u and a_v must satisfy g = gcd(a_u, a_v) and l = lcm(a_u, a_v).\n\nLet’s see: Since g is the gcd, we can write a_u = g * x and a_v = g * y, where x and y are coprime integers. Then, the LCM of a_u and a_v is g * x * y (since x and y are coprime). So l must be equal to g * x * y.\n\nSo from this, x*y = l / g.\n\nAlso, since x and y are coprime, we can find all possible pairs",
    "response": "To solve this problem, we need to determine the number of laughy mushrooms on each lawn based on the given roads and their GCD and LCM values. The solution involves modeling the problem as a system of constraints and solving it using a Union-Find data structure with additional constraints.\n\n### Approach\n1. **Graph Representation**: Represent the problem as a graph where each node is a lawn and each edge represents a road with given GCD and LCM constraints.\n2. **Union-Find Data Structure**: Use this to manage connected components of the graph. For each component, assign a root node and express the values of other nodes relative to this root.\n3. **Constraints Handling**: For each edge, express the values of the connected nodes in terms of their GCD and LCM. Use these expressions to build relationships between nodes within each connected component.\n4. **Validation**: After determining the possible values for each node, validate the constraints across all edges to ensure consistency.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd, lcm\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr +=1\n    \n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])-1  # 0-based\n        ptr +=1\n        v = int(input[ptr])-1\n        ptr +=1\n        g = int(input[ptr])\n        ptr +=1\n        l = int(input[ptr])\n        ptr +=1\n        edges.append( (u, v, g, l) )\n    \n    parent = list(range(n))\n    rank = [1]*n\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v, g, l):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        \n        if rank[u_root] < rank[v_root]:\n            u_root, v_root = v_root, u_root\n            g, l = l, g\n            \n        parent[v_root] = u_root\n        rank[u_root] *= 2\n        \n        return True\n    \n    for u, v, g, l in edges:\n        if g == 0 or l ==0:\n            print(\"NO\")\n            return\n        if l < g:\n            print(\"NO\")\n            return\n        if g > l:\n            print(\"NO\")\n            return\n        if not union(u, v, g, l):\n            print(\"NO\")\n            return\n    \n    # Now assign values\n    value = [0]*n\n    # Find root for each node\n    roots = {}\n    for i in range(n):\n        roots[i] = find(i)\n    \n    # For each root, set its value to some variable\n    # We can represent the value as product of primes from the constraints\n    # But since the constraints are multiplicative, perhaps we can assign the smallest possible value\n    \n    # Let's represent each root's value as a variable, but since all edges are processed, we can assign the root's value as 1 and compute others accordingly\n    \n    # Wait, no. Because the edges may have multiple constraints.\n    # So perhaps, for each root, we can track the possible factors based on edges\n    \n    # Alternative approach: For each node, store its value as a product of primes, but this could get complicated.\n    # Alternatively, for each edge, the value is determined by the root.\n    \n    # Maybe a better way is to model each node's value as a multiple of the root's value, based on the edges.\n    # So for each root, the value is x. For a node u connected via an edge to root, its value is y, and y must satisfy certain conditions based on the edge.\n    \n    # So, for each node, after finding its root, we can track the multiplier relative to the root's value.\n    \n    # Let's create a dictionary to store the multipliers for each node relative to their root.\n    multiplier = defaultdict(int)\n    for i in range(n):\n        multiplier[i] = 1\n    \n    # For each edge, process the constraints\n    for u, v, g, l in edges:\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            # They are already connected, so check if the existing constraints are satisfied\n            current_gcd = gcd(value[u_root] * multiplier[u], value[v_root] * multiplier[v])\n            current_lcm = lcm(current_gcd, ... ) Wait, no. Alternatively, the current values should satisfy the edge's g and l.\n            # Actually, the values are determined by the root's value and the multipliers.\n            # So, the edge between u and v has u's value = value[u_root] * multiplier[u], v's value = value[v_root] * multiplier[v].\n            # So, compute the GCD and LCM of these two values and see if they match the edge's g and l.\n            # If not, it's impossible.\n            # Wait, but how do we compute value[u_root] and value[v_root]?\n            # Because value is initially zero, this approach might not work.\n            # Hmm, perhaps I need a different approach.\n            # Maybe the initial approach of setting the root's value to 1 and then computing the others based on edges is better, but how to handle when multiple edges connect the same nodes.\n            # This suggests that the problem is more complex than I thought.\n            \n            # Perhaps another approach: For each connected component, the values of the nodes must form a tree where each edge enforces the GCD and LCM constraints.\n            # So, for each connected component, we can assign a base value (like 1) to one node and compute the others based on the edges.\n            # However, if any edge creates a conflict, it's impossible.\n            \n            # Let's try this approach.\n            # First, for each connected component, pick a root node (say, the first node in the component) and assign it a value of 1.\n            # Then, for each edge in the component, compute the possible values for the other nodes.\n            # If any edge conflicts, return NO.\n            \n            # But how to compute the values? Let's think about each edge as u - (g, l) -> v.\n            # When the root is assigned a value, the value of u and v must satisfy the edge's constraints.\n            # So, for each edge, the value of u and v must be such that their GCD is g and LCM is l.\n            # Which implies that the product of u and v is g*l.\n            # So, if u is in the same component as v, and the root's value is known, then the values of u and v can be determined based on the edge's g and l.\n            \n            # So, let's proceed step by step:\n            # 1. For each connected component, pick a root node and assign it a value of 1.\n            # 2. For each node in the component, compute its value based on the path from the root.\n            # 3. For each edge, check if the computed values satisfy the GCD and LCM constraints.\n            # 4. If any edge fails, output NO.\n            \n            # But how to compute the node values based on the path from the root?\n            # Each edge introduces a constraint that the product of the two nodes' values is g*l.\n            # So, for the root's value (1), each node's value is determined by the product of the edges along the path from the root to that node.\n            # However, this needs to be consistent across all edges.\n            \n            # This seems tricky. Maybe another approach is to model each node's value as a multiple of the root's value, adjusted by the edges.\n            # For example, each node's value is root_value * k, where k is a product of certain factors derived from the edges.\n            # Then, for each edge, the product of the two nodes' values must equal g*l, which gives an equation involving their k's.\n            # Solving these equations would give the possible k values.\n            \n            # But this might involve solving a system of equations, which could be computationally intensive.\n            # Given the constraints (values up to 106), perhaps a brute-force approach is feasible.\n            \n            # Another idea: For each connected component, assign a base value to the root, then for each edge, compute the possible values for the connected nodes and propagate these values through the component.\n            # If any inconsistency is found during propagation, output NO.\n            \n            # Let's try this:\n            # Initialize all node values as None.\n            # For each connected component:\n            #   Assign a value to the root (e.g., 1).\n            #   For each node in BFS order starting from the root:\n            #       For each edge from this node to another node:\n            #           Compute the expected value of the other node based on the edge's g and l and the current node's value.\n            #           If the other node's value is already set, check for consistency.\n            #           Otherwise, set it and continue.\n            \n            # This seems manageable.\n            \n            # So, let's implement this.\n            # First, find all connected components using Union-Find.\n            # For each component, perform BFS or DFS to assign values.\n            \n            # Wait, but how to determine the value of each node based on the edges.\n            # For each edge, the two nodes must satisfy:\n            # a = g * x\n            # b = g * y\n            # where x and y are coprime, and l = g * x * y.\n            # So, for each edge, we can express the relationship between a and b as a / b = x / y = (l / g) / (b / a)\n            # Hmm, not sure.\n            \n            # Maybe a better approach is to represent each node's value as a multiple of the root's value, and for each edge, compute the required ratio between the two nodes.\n            \n            # For example, in the edge between u and v, after assigning a value to the root, we can compute the value of u and v based on the edge's g and l.\n            # Then, for each node connected to u, compute their values based on the edges, ensuring that all constraints are satisfied.\n            \n            # This seems complex, but perhaps manageable with a BFS approach.\n            \n            # Let's proceed with this plan:\n            # 1. Use Union-Find to group nodes into connected components.\n            # 2. For each component, perform BFS starting from a root node (initially assigned a value of 1).\n            # 3. For each edge in the component, check if the current values of the connected nodes satisfy the GCD and LCM constraints.\n            # 4. If any inconsistency is found, output NO.\n            # 5. If all constraints are satisfied, output YES and the values.\n            \n            # Implementing this requires tracking the value of each node relative to the root.\n            \n            # So, for each node, we'll have a value that is the product of the root's value and some factors derived from the edges.\n            # We'll use a dictionary to track these values.\n            \n            # Let's initialize the value of the root to 1.\n            # For each node reachable from the root via edges, compute its value based on the edges.\n            \n            # But how? Each edge gives a constraint between two nodes, which can be used to compute the value of one node based on the other.\n            \n            # So, during BFS, for each node, when processing its edges, we can compute the required value of the connected node and propagate it.\n            \n            # Let's try to code this:\n            \n            # After the Union-Find phase, for each component:\n            #   Select a root (any node in the component).\n            #   Assign value[root] = 1.\n            #   Use a queue to process nodes in BFS order.\n            #   For each node u in the queue:\n            #       For each edge (u, v, g, l):\n            #           If v hasn't been visited yet:\n            #               Compute the value of v based on u's value and the edge's g and l.\n            #               Set value[v] and add it to the queue.\n            #           Else:\n            #               Check if the current values of u and v satisfy the edge's constraints.\n            #               If not, return NO.\n            \n            # Now, how to compute v's value based on u's value and the edge's g and l.\n            \n            # Let's denote:\n            # u_val = value[u]\n            # v_val = ?\n            # g = gcd(u_val, v_val)\n            # l = lcm(u_val, v_val)\n            \n            # Also, u_val * v_val = g * l.\n            \n            # So, v_val = (g * l) / u_val.\n            \n            # But this must be an integer, and also, the GCD(u_val, v_val) must be g.\n            \n            # So, for each edge, when processing node u and trying to compute v's value, we calculate v_val = (g * l) // u_val.\n            # Then, we check if gcd(u_val, v_val) == g and lcm(u_val, v_val) == l.\n            # If not, it's invalid.\n            \n            # Additionally, if v has already been assigned a value, we must check that it matches what's computed here.\n            \n            # This seems manageable.\n            \n            # So, the steps are:\n            # 1. Process each connected component.\n            # 2. For each component, assign a root and set its value to 1.\n            # 3. Use BFS to process each node's edges, computing the values of connected nodes.\n            # 4. For each edge, verify the constraints.\n            \n            # Now, let's think about the example provided in the problem statement.\n            \n            # Example Input:\n            # 1 0\n            # 2 1\\n1 2 1 3\n            # 3 2\\n3 2 1 2\\n3 1 1 10\n            # 2 1\\n1 2 3 7\n            \n            # The first line is '1 0', meaning there are 1 lawn and 0 roads. So the output is 'YES\\n1'.\n            \n            # Another example:\n            # 2 1\n            # 1 2 1 3\n            # Output: 'YES\\n1 3'\n            \n            # So, the algorithm should correctly handle these cases.\n            \n            # Now, implementing this in code.\n            \n            # We'll need to process each connected component. For each component, we'll:\n            # - Assign a root.\n            # - Initialize its value to 1.\n            # - Use BFS to compute values for all nodes in the component.\n            # - Check all edges in the component for validity.\n            \n            # Let's proceed.\n    \n    # Now, the code continues with the BFS approach.\n    # Initializing the value array.\n    value = [0] * n\n    visited = [False] * n\n    # For each node, if not visited, start BFS\n    for i in range(n):\n        if not visited[i]:\n            # Assign root\n            root = i\n            queue = [root]\n            visited[root] = True\n            value[root] = 1\n            while queue:\n                u = queue.pop(0)\n                for (v, g, l) in edges_from_u[u]:\n                    if not visited[v]:\n                        # Compute v's value based on u's value and edge's g and l\n                        v_val = (g * l) // value[u]\n                        if v_val <= 0 or v_val > 106:\n                            print(\"NO\")\n                            return\n                        # Check if u_val and v_val satisfy the GCD and LCM\n                        if gcd(value[u], v_val) != g or lcm(value[u], v_val) != l:\n                            print(\"NO\")\n                            return\n                        value[v] = v_val\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check if the current values satisfy the edge's constraints\n                        current_gcd = gcd(value[u], value[v])\n                        current_lcm = lcm(value[u], value[v])\n                        if current_gcd != g or current_lcm != l:\n                            print(\"NO\")\n                            return\n    # After processing all components, check all edges again\n    for u, v, g, l in edges:\n        if value[u] == 0 or value[v] == 0:\n            print(\"NO\")\n            return\n        current_gcd = gcd(value[u], value[v])\n        current_lcm = lcm(value[u], value[v])\n        if current_gcd != g or current_lcm != l:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, value)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution uses a BFS approach to propagate values through each connected component of the graph, ensuring that each edge's constraints are satisfied. The algorithm starts by initializing the root node's value to 1 and then computes the values of connected nodes based on the edges' GCD and LCM constraints. If any inconsistency is found during this process, the solution outputs \"NO\". If all constraints are satisfied, it outputs the values of the mushrooms on each lawn.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd, lcm\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr +=1\n    \n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])-1  # 0-based\n        ptr +=1\n        v = int(input[ptr])-1\n        ptr +=1\n        g = int(input[ptr])\n        ptr +=1\n        l = int(input[ptr])\n        ptr +=1\n        edges.append( (u, v, g, l) )\n    \n    parent = list(range(n))\n    rank = [1]*n\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v, g, l):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        \n        if rank[u_root] < rank[v_root]:\n            u_root, v_root = v_root, u_root\n            g, l = l, g\n            \n        parent[v_root] = u_root\n        rank[u_root] *= 2\n        \n        return True\n    \n    for u, v, g, l in edges:\n        if g == 0 or l ==0:\n            print(\"NO\")\n            return\n        if l < g:\n            print(\"NO\")\n            return\n        if g > l:\n            print(\"NO\")\n            return\n        if not union(u, v, g, l):\n            print(\"NO\")\n            return\n    \n    # Now assign values\n    value = [0]*n\n    # Find root for each node\n    roots = {}\n    for i in range(n):\n        roots[i] = find(i)\n    \n    # For each root, set its value to some variable\n    # We can represent the value as product of primes from the constraints\n    # But since the constraints are multiplicative, perhaps we can assign the smallest possible value\n    \n    # Let's represent each root's value as a variable, but since all edges are processed, we can assign the root's value as 1 and compute others accordingly\n    \n    # Wait, no. Because the edges may have multiple constraints.\n    # So perhaps, for each root, we can track the possible factors based on edges\n    \n    # Alternative approach: For each node, store its value as a product of primes, but this could get complicated.\n    # Alternatively, for each edge, the value is determined by the root.\n    \n    # Maybe a better way is to model each node's value as a multiple of the root's value, based on the edges.\n    # So for each root, the value is x. For a node u connected via an edge to root, its value is y, and y must satisfy certain conditions based on the edge.\n    \n    # So, for each node, after finding its root, we can track the multiplier relative to the root's value.\n    \n    # Let's create a dictionary to store the multipliers for each node relative to their root.\n    multiplier = defaultdict(int)\n    for i in range(n):\n        multiplier[i] = 1\n    \n    # For each edge, process the constraints\n    for u, v, g, l in edges:\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            # They are already connected, so check if the existing constraints are satisfied\n            current_gcd = gcd(value[u_root] * multiplier[u], value[v_root] * multiplier[v])\n            current_lcm = lcm(current_gcd, ... ) Wait, no. Alternatively, the current values should satisfy the edge's g and l.\n            # Actually, the values are determined by the root's value and the multipliers.\n            # So, the edge between u and v has u's value = value[u_root] * multiplier[u], v's value = value[v_root] * multiplier[v].\n            # So, compute the GCD and LCM of these two values and see if they match the edge's g and l.\n            # If not, it's impossible.\n            # Wait, but how do we compute value[u_root] and value[v_root]?\n            # Because value is initially zero, this approach might not work.\n            # Hmm, perhaps I need a different approach.\n            # Maybe the initial approach of setting the root's value to 1 and then computing the others based on edges is better, but how to handle when multiple edges connect the same nodes.\n            # This suggests that the problem is more complex than I thought.\n            \n            # Perhaps another approach: For each connected component, the values of the nodes must form a tree where each edge enforces the GCD and LCM constraints.\n            # So, for each connected component, we can assign a base value (like 1) to one node and compute the others based on the edges.\n            # However, if any edge creates a conflict, it's impossible.\n            \n            # Let's try this approach.\n            # First, for each connected component, pick a root node (say, the first node in the component) and assign it a value of 1.\n            # Then, for each edge in the component, compute the possible values for the other nodes.\n            # If any edge conflicts, return NO.\n            \n            # But how to compute the values? Let's think about each edge as u - (g, l) -> v.\n            # When the root is assigned a value, the value of u and v must satisfy the edge's constraints.\n            # So, for each edge, the value of u and v must be such that their GCD is g and LCM is l.\n            # Which implies that the product of u and v is g*l.\n            # So, if u is in the same component as v, and the root's value is known, then the values of u and v can be determined based on the edge's g and l.\n            \n            # So, let's proceed step by step:\n            # 1. For each connected component, pick a root node and assign it a value of 1.\n            # 2. For each node in the component, compute its value based on the path from the root.\n            # 3. For each edge, check if the computed values satisfy the GCD and LCM constraints.\n            # 4. If any edge fails, output NO.\n            \n            # But how to compute the node values based on the path from the root?\n            # Each edge introduces a constraint that the product of the two nodes' values is g*l.\n            # So, for the root's value (1), each node's value is determined by the product of the edges along the path from the root to that node.\n            # However, this needs to be consistent across all edges.\n            \n            # This seems tricky. Maybe another approach is to model each node's value as a multiple of the root's value, adjusted by the edges.\n            # For example, each node's value is root_value * k, where k is a product of certain factors derived from the edges.\n            # Then, for each edge, the product of the two nodes' values must equal g*l, which gives an equation involving their k's.\n            # Solving these equations would give the possible k values.\n            \n            # But this might involve solving a system of equations, which could be computationally intensive.\n            # Given the constraints (values up to 106), perhaps a brute-force approach is feasible.\n            \n            # Another idea: For each connected component, assign a base value to the root, then for each edge, compute the possible values for the connected nodes and propagate these values through the component.\n            # If any inconsistency is found during propagation, output NO.\n            \n            # Let's try this:\n            # Initialize all node values as None.\n            # For each connected component:\n            #   Assign a value to the root (e.g., 1).\n            #   For each node in BFS order starting from the root:\n            #       For each edge from this node to another node:\n            #           Compute the expected value of the other node based on the edge's g and l and the current node's value.\n            #           If the other node's value is already set, check for consistency.\n            #           Otherwise, set it and continue.\n            \n            # This seems manageable.\n            \n            # So, let's implement this.\n            # First, find all connected components using Union-Find.\n            # For each component, perform BFS or DFS to assign values.\n            \n            # Wait, but how to determine the value of each node based on the edges.\n            # For each edge, the two nodes must satisfy:\n            # a = g * x\n            # b = g * y\n            # where x and y are coprime, and l = g * x * y.\n            # So, for each edge, we can express the relationship between a and b as a / b = x / y = (l / g) / (b / a)\n            # Hmm, not sure.\n            \n            # Maybe a better approach is to represent each node's value as a multiple of the root's value, and for each edge, compute the required ratio between the two nodes.\n            \n            # For example, in the edge between u and v, after assigning a value to the root, we can compute the value of u and v based on the edge's g and l.\n            # Then, for each node connected to u, compute their values based on the edges, ensuring that all constraints are satisfied.\n            \n            # This seems complex, but perhaps manageable with a BFS approach.\n            \n            # Let's proceed with this plan:\n            # 1. Use Union-Find to group nodes into connected components.\n            # 2. For each component, perform BFS starting from a root node (initially assigned a value of 1).\n            # 3. For each edge in the component, check if the current values of the connected nodes satisfy the GCD and LCM constraints.\n            # 4. If any inconsistency is found, output NO.\n            # 5. If all constraints are satisfied, output YES and the values.\n            \n            # Implementing this requires tracking the value of each node relative to the root.\n            \n            # So, for each node, we'll have a value that is the product of the root's value and some factors derived from the edges.\n            # We'll use a dictionary to track these values.\n            \n            # Let's initialize the value of the root to 1.\n            # For each node reachable from the root via edges, compute its value based on the edges.\n            \n            # But how? Each edge gives a constraint between two nodes, which can be used to compute the value of one node based on the other.\n            \n            # So, during BFS, for each node, when processing its edges, we can compute the required value of the connected node and propagate it.\n            \n            # Let's try to code this:\n            \n            # After the Union-Find phase, for each component:\n            #   Select a root (any node in the component).\n            #   Assign value[root] = 1.\n            #   Use a queue to process nodes in BFS order.\n            #   For each node u in the queue:\n            #       For each edge (u, v, g, l):\n            #           If v hasn't been visited yet:\n            #               Compute the value of v based on u's value and the edge's g and l.\n            #               Set value[v] and add it to the queue.\n            #           Else:\n            #               Check if the current values of u and v satisfy the edge's constraints.\n            #               If not, return NO.\n            \n            # Now, how to compute v's value based on u's value and the edge's g and l.\n            \n            # Let's denote:\n            # u_val = value[u]\n            # v_val = ?\n            # g = gcd(u_val, v_val)\n            # l = lcm(u_val, v_val)\n            \n            # Also, u_val * v_val = g * l.\n            \n            # So, v_val = (g * l) / u_val.\n            \n            # But this must be an integer, and also, the GCD(u_val, v_val) must be g.\n            \n            # So, for each edge, when processing node u and trying to compute v's value, we calculate v_val = (g * l) // u_val.\n            # Then, we check if gcd(u_val, v_val) == g and lcm(u_val, v_val) == l.\n            # If not, it's invalid.\n            \n            # Additionally, if v has already been assigned a value, we must check that it matches what's computed here.\n            \n            # This seems manageable.\n            \n            # So, the steps are:\n            # 1. Process each connected component.\n            # 2. For each component, assign a root and set its value to 1.\n            # 3. Use BFS to process each node's edges, computing the values of connected nodes.\n            # 4. For each edge, verify the constraints.\n            \n            # Now, let's think about the example provided in the problem statement.\n            \n            # Example Input:\n            # 1 0\n            # 2 1\\n1 2 1 3\n            # 3 2\\n3 2 1 2\\n3 1 1 10\n            # 2 1\\n1 2 3 7\n            \n            # The first line is '1 0', meaning there are 1 lawn and 0 roads. So the output is 'YES\\n1'.\n            \n            # Another example:\n            # 2 1\n            # 1 2 1 3\n            # Output: 'YES\\n1 3'\n            \n            # So, the algorithm should correctly handle these cases.\n            \n            # Now, implementing this in code.\n            \n            # We'll need to process each connected component. For each component, we'll:\n            # - Assign a root.\n            # - Initialize its value to 1.\n            # - Use BFS to compute values for all nodes in the component.\n            # - Check all edges in the component for validity.\n            \n            # Let's proceed.\n    \n    # Now, the code continues with the BFS approach.\n    # Initializing the value array.\n    value = [0] * n\n    visited = [False] * n\n    # For each node, if not visited, start BFS\n    for i in range(n):\n        if not visited[i]:\n            # Assign root\n            root = i\n            queue = [root]\n            visited[root] = True\n            value[root] = 1\n            while queue:\n                u = queue.pop(0)\n                for (v, g, l) in edges_from_u[u]:\n                    if not visited[v]:\n                        # Compute v's value based on u's value and edge's g and l\n                        v_val = (g * l) // value[u]\n                        if v_val <= 0 or v_val > 106:\n                            print(\"NO\")\n                            return\n                        # Check if u_val and v_val satisfy the GCD and LCM\n                        if gcd(value[u], v_val) != g or lcm(value[u], v_val) != l:\n                            print(\"NO\")\n                            return\n                        value[v] = v_val\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check if the current values satisfy the edge's constraints\n                        current_gcd = gcd(value[u], value[v])\n                        current_lcm = lcm(value[u], value[v])\n                        if current_gcd != g or current_lcm != l:\n                            print(\"NO\")\n                            return\n    # After processing all components, check all edges again\n    for u, v, g, l in edges:\n        if value[u] == 0 or value[v] == 0:\n            print(\"NO\")\n            return\n        current_gcd = gcd(value[u], value[v])\n        current_lcm = lcm(value[u], value[v])\n        if current_gcd != g or current_lcm != l:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, value)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 3756,
        "thoughts_token_count": 1025
    }
}