{
    "start": 1758278653.2541835,
    "end": 1758279044.836013,
    "start-formatted": "2025-09-19 19:44 KST",
    "end-formatted": "2025-09-19 19:50 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Vitaly and Cycle.\" Hmm, I need to find the minimum number of edges to add to a graph to form an odd-length cycle (more than one vertex) and also count the number of ways to do this. \n\nAlright, let's break it down. The input is an undirected graph with n vertices and m edges. No loops or parallel edges. The output should be two numbers: t is the minimal edges to add, and w is the number of ways.\n\nFirst, I think about what constitutes a simple cycle here. A cycle where each vertex appears exactly once, and the length is odd. So for example, a triangle is a 3-length cycle, which is odd. A pentagon would be 5-length, etc.\n\nNow, the approach. I need to consider each connected component of the graph separately because adding edges can only connect within components, right? Wait, no. Because cycles are formed by connecting nodes, but perhaps adding edges across components can create new cycles. Hmm, maybe not necessary to separate by components initially, but perhaps we can process each component and then combine results.\n\nWait, perhaps the key is to look for existing paths that could form part of an odd cycle when certain edges are added. For each connected component, I need to determine whether it already contains an odd cycle. If not, how many edges need to be added to create one, and how many ways there are to do that.\n\nWait, but the problem allows adding edges anywhere in the graph, not just within a component. So maybe it's better to model the problem as looking for any pair of paths between two nodes that form an odd cycle when combined with some edges.\n\nAlternatively, another angle: for any two nodes u and v, if there exists a path from u to v of even length and another path of odd length, then adding an edge between u and v will create an odd-length cycle. But wait, the sum of even and odd is odd, so u and v would form a cycle of length (even + 1). But I'm not sure if that's the right way to think about it.\n\nAlternatively, think about the parity of the distance between nodes. If in a component, there are two nodes u and v such that their distance is even and another path exists with an odd length, then adding an edge between u and v would create an odd-length cycle. Or wait, perhaps more accurately: for any pair of nodes u and v, if the shortest path between them has even length, then adding an edge u-v will create a cycle of length (even + 1), which is odd. But wait, maybe the path isn't the shortest. Because maybe there's a longer path that's even or odd, which could affect the outcome.\n\nHmm, perhaps the key is to find for each connected component, the minimal number of edges required to form an odd cycle, considering all possible pairs of nodes.\n\nBut I'm getting stuck. Let me think about the problem differently. What's the minimal t? It depends on whether the graph already has an odd cycle. If it does, then t is zero, and w is the number of such existing cycles. Otherwise, t is the minimal number of edges that, when added, form an odd cycle. And w is the number of ways to add those edges.\n\nWait, no. Because adding edges can create multiple new cycles. So perhaps the first step is to check if the graph already contains an odd-length cycle. If yes, then t is zero and w is the count of such cycles.\n\nIf not, then for each connected component, we need to see if it's possible to form an odd cycle by adding edges.\n\nWait, but adding edges can connect different components. So perhaps the minimal way is to find two paths between two nodes that can form an odd cycle when connected.\n\nWait, perhaps the minimal number of edges needed is 1. Like, if there exists two nodes u and v such that the sum of their distances (in terms of parity) is even, then adding an edge u-v creates a cycle of length (d + 1), which could be odd.\n\nAlternatively, I'm thinking that if in a component, there exists two nodes u and v such that the parity of their distance is even, and the parity of another path is odd, then adding an edge u-v will create an odd cycle.\n\nWait, perhaps the problem can be approached by considering the bipartition of the graph. Because in a bipartite graph, any cycle must be of even length. So if a component is bipartite, then adding an edge between two nodes of the same partition won't create an odd cycle. But adding an edge between two nodes of different partitions might.\n\nWait, perhaps for each component, if it's bipartite, then to form an odd cycle, we need to have a situation where in the component, there's",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length and count the number of ways to achieve this.\n\n### Approach\n1. **Check for Existing Cycles**: First, check if the graph already contains an odd-length cycle. If it does, the minimum number of edges to add (t) is 0, and the number of ways (w) is the count of such cycles.\n2. **Bipartite Check**: For each connected component, determine if it is bipartite. A bipartite graph cannot have any odd-length cycles.\n3. **Component Analysis**: For each component, if it is not bipartite, it already has an odd-length cycle. Otherwise, check for pairs of nodes where adding an edge can form an odd-length cycle.\n4. **Edge Addition Strategy**: For each component, calculate the minimum edges needed and the number of ways to form an odd-length cycle by considering node pairs and their distances.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx +=1\n    m = int(input[idx])\n    idx +=1\n\n    edges = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[idx])\n        idx +=1\n        b = int(input[idx])\n        idx +=1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    visited = [False]*(n+1)\n    odd_cycles = 0\n    for v in range(1, n+1):\n        if not visited[v]:\n            q = deque()\n            q.append((v, 0))\n            visited[v] = True\n            color = {}\n            color[v] = 0\n            possible = False\n            while q:\n                u, d = q.popleft()\n                if d %2 ==1:\n                    possible = True\n                for nei in edges[u]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        color[nei] = color[u] ^ 1\n                        q.append((nei, d+1))\n                    else:\n                        if color[nei] == color[u]:\n                            cycle_length = d + 1 + (color[nei] - color[u]) *1\n                            if cycle_length %2 ==1:\n                                odd_cycles +=1\n            if possible:\n                pass\n\n    if odd_cycles >0:\n        print(\"0\", odd_cycles)\n        return\n\n    # Now, find for each component the minimal edges to add and ways\n    visited = [False]*(n+1)\n    components = []\n    for v in range(1, n+1):\n        if not visited[v]:\n            q = deque([v])\n            visited[v] = True\n            comp = []\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for nei in edges[u]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        q.append(nei)\n            components.append(comp)\n\n    min_edges = float('inf')\n    total_ways =0\n\n    for comp in components:\n        if len(comp) <2:\n            continue\n        # Check if it's bipartite\n        is_bipartite = True\n        color = {}\n        q = deque()\n        q.append(comp[0])\n        color[comp[0]] =0\n        while q:\n            u = q.popleft()\n            for nei in edges[u]:\n                if nei in color:\n                    if color[nei] == color[u]:\n                        is_bipartite = False\n                        break\n                else:\n                    color[nei] = color[u]^1\n                    q.append(nei)\n            if not is_bipartite:\n                break\n        if is_bipartite:\n            continue\n\n        # Now, for bipartition, find pairs where adding edge creates odd cycle\n        # Let's get the two partitions\n        part0 = []\n        part1 = []\n        for node in comp:\n            part0.append(node) if color[node] ==0 else part1.append(node)\n\n        # Find all pairs (u in part0, v in part1) where distance between them is even\n        # Wait, no. Because if u and v are in different parts, their shortest path is odd.\n        # So adding an edge between u and v would create a cycle of length (path length) +1, which could be even or odd.\n        # Alternatively, perhaps for any u in part0, v in part1, if there exists a path from u to v of even length, then adding u-v would create a cycle of odd length.\n\n        # To find the minimal edges needed, we can look for any pair u in part0, v in part1 where the parity of the distance is even.\n        # Because then adding edge u-v would create a cycle of length (even +1), which is odd.\n        # The minimal edges needed is 1.\n\n        # But wait, what if the component is connected but not bipartite? Then it already has an odd cycle, but that was handled earlier.\n\n        # So now, for each component that is bipartite, we need to see if there exists a pair of nodes u and v in different partitions such that their shortest path is even. If so, adding an edge u-v will create an odd cycle.\n\n        # So for each component, if it's bipartite, we can compute the minimal edges as 1, and the number of ways as the number of such pairs.\n\n        # So for each component, the minimal edges to add is 1, and the ways is the number of possible pairs (u, v) where u is in part0, v is in part1, and the shortest path from u to v is even.\n\n        # But how to compute the number of such pairs?\n\n        # This might be computationally intensive, but given the constraints, perhaps it's manageable.\n\n        # So for each component, if it's bipartite, we need to find the number of pairs (u, v) where u is in part0, v in part1, and the shortest path from u to v is even.\n\n        # To do this, for each u in part0, perform BFS to find the distances to all nodes in part1, and count how many have even distances.\n\n        # Then sum over all u in part0, the count of such v in part1.\n\n        # The minimal edges is 1, and the number of ways is the total count.\n\n        # Additionally, if the component is not bipartite, but the initial check didn't find any odd cycles, which shouldn't happen because non-bipartite implies existence of odd cycles.\n\n        # So assuming that for bipartite components, we can compute the required values.\n\n        # Let's proceed with this approach.\n\n        # Now, for the current component, compute the number of valid (u, v) pairs where u in part0, v in part1, and the shortest path from u to v is even.\n\n        # We can do this by BFS from each u in part0 to all nodes in part1 and count how many have even distances.\n\n        # But this might be time-consuming for large components. However, given the problem constraints, it's manageable.\n\n        # So let's implement this.\n\n        # Initialize variables for the component\n        min_t = 1\n        ways =0\n\n        # Get part0 and part1\n        part0 = [node for node in color if color[node]==0]\n        part1 = [node for node in color if color[node]==1]\n\n        # For each u in part0, BFS to find distances to all nodes in part1\n        for u in part0:\n            dist = {u:0}\n            q = deque()\n            q.append(u)\n            while q:\n                current = q.popleft()\n                for nei in edges[current]:\n                    if nei in dist:\n                        continue\n                    dist[nei] = dist[current] +1\n                    q.append(nei)\n            # Now, for all v in part1, check if dist[v] is even\n            for v in part1:\n                if v not in dist:\n                    continue  # unreachable, but since component is connected, this shouldn't happen\n                if dist[v] %2 ==0:\n                    ways +=1\n\n        # Update global min_edges and total_ways\n        if min_edges > min_t:\n            min_edges = min_t\n        if ways >0:\n            total_ways += ways\n\n    # After processing all components\n    if min_edges == float('inf'):\n        # No way to form an odd cycle\n        print(\"0 0\")\n    else:\n        print(f\"{min_edges} {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution first checks if the graph already contains an odd-length cycle. If it does, it outputs `t=0` and the count of such cycles. If not, it processes each connected component to determine if it can be transformed into an odd-length cycle by adding edges. For each bipartite component, it calculates the minimum edges needed (which is 1) and the number of ways to achieve this by finding pairs of nodes that can form an odd-length cycle when connected. The results are then aggregated to provide the final answer.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx +=1\n    m = int(input[idx])\n    idx +=1\n\n    edges = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[idx])\n        idx +=1\n        b = int(input[idx])\n        idx +=1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    visited = [False]*(n+1)\n    odd_cycles = 0\n    for v in range(1, n+1):\n        if not visited[v]:\n            q = deque()\n            q.append((v, 0))\n            visited[v] = True\n            color = {}\n            color[v] = 0\n            possible = False\n            while q:\n                u, d = q.popleft()\n                if d %2 ==1:\n                    possible = True\n                for nei in edges[u]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        color[nei] = color[u] ^ 1\n                        q.append((nei, d+1))\n                    else:\n                        if color[nei] == color[u]:\n                            cycle_length = d + 1 + (color[nei] - color[u]) *1\n                            if cycle_length %2 ==1:\n                                odd_cycles +=1\n            if possible:\n                pass\n\n    if odd_cycles >0:\n        print(\"0\", odd_cycles)\n        return\n\n    # Now, find for each component the minimal edges to add and ways\n    visited = [False]*(n+1)\n    components = []\n    for v in range(1, n+1):\n        if not visited[v]:\n            q = deque([v])\n            visited[v] = True\n            comp = []\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for nei in edges[u]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        q.append(nei)\n            components.append(comp)\n\n    min_edges = float('inf')\n    total_ways =0\n\n    for comp in components:\n        if len(comp) <2:\n            continue\n        # Check if it's bipartite\n        is_bipartite = True\n        color = {}\n        q = deque()\n        q.append(comp[0])\n        color[comp[0]] =0\n        while q:\n            u = q.popleft()\n            for nei in edges[u]:\n                if nei in color:\n                    if color[nei] == color[u]:\n                        is_bipartite = False\n                        break\n                else:\n                    color[nei] = color[u]^1\n                    q.append(nei)\n            if not is_bipartite:\n                break\n        if is_bipartite:\n            continue\n\n        # Now, for bipartition, find pairs where adding edge creates odd cycle\n        # Let's get the two partitions\n        part0 = []\n        part1 = []\n        for node in comp:\n            part0.append(node) if color[node] ==0 else part1.append(node)\n\n        # Find all pairs (u in part0, v in part1) where distance between them is even\n        # Wait, no. Because if u and v are in different parts, their shortest path is odd.\n        # So adding an edge between u and v would create a cycle of length (path length) +1, which could be even or odd.\n        # Alternatively, perhaps for any u in part0, v in part1, if there exists a path from u to v of even length, then adding u-v would create a cycle of odd length.\n\n        # To find the minimal edges needed, we can look for any pair u in part0, v in part1 where the parity of the distance is even.\n        # Because then adding edge u-v would create a cycle of length (even +1), which is odd.\n        # The minimal edges needed is 1.\n\n        # But wait, what if the component is connected but not bipartite? Then it already has an odd cycle, but that was handled earlier.\n\n        # So now, for each component that is bipartite, we need to see if there exists a pair of nodes u and v in different partitions such that their shortest path is even. If so, adding an edge u-v will create an odd cycle.\n\n        # So for each component, if it's bipartite, we can compute the minimal edges as 1, and the number of ways as the number of such pairs.\n\n        # So for each component, the minimal edges to add is 1, and the ways is the number of possible pairs (u, v) where u is in part0, v is in part1, and the shortest path from u to v is even.\n\n        # But how to compute the number of such pairs?\n\n        # This might be computationally intensive, but given the constraints, perhaps it's manageable.\n\n        # So for each component, if it's bipartite, we need to find the number of pairs (u, v) where u is in part0, v in part1, and the shortest path from u to v is even.\n\n        # To do this, for each u in part0, perform BFS to find the distances to all nodes in part1, and count how many have even distances.\n\n        # Then sum over all u in part0, the count of such v in part1.\n\n        # The minimal edges is 1, and the number of ways is the total count.\n\n        # Additionally, if the component is not bipartite, but the initial check didn't find any odd cycles, which shouldn't happen because non-bipartite implies existence of odd cycles.\n\n        # So assuming that for bipartite components, we can compute the required values.\n\n        # Let's proceed with this approach.\n\n        # Now, for the current component, compute the number of valid (u, v) pairs where u in part0, v in part1, and the shortest path from u to v is even.\n\n        # We can do this by BFS from each u in part0 to all nodes in part1 and count how many have even distances.\n\n        # But this might be time-consuming for large components. However, given the problem constraints, it's manageable.\n\n        # So let's implement this.\n\n        # Initialize variables for the component\n        min_t = 1\n        ways =0\n\n        # Get part0 and part1\n        part0 = [node for node in color if color[node]==0]\n        part1 = [node for node in color if color[node]==1]\n\n        # For each u in part0, BFS to find distances to all nodes in part1\n        for u in part0:\n            dist = {u:0}\n            q = deque()\n            q.append(u)\n            while q:\n                current = q.popleft()\n                for nei in edges[current]:\n                    if nei in dist:\n                        continue\n                    dist[nei] = dist[current] +1\n                    q.append(nei)\n            # Now, for all v in part1, check if dist[v] is even\n            for v in part1:\n                if v not in dist:\n                    continue  # unreachable, but since component is connected, this shouldn't happen\n                if dist[v] %2 ==0:\n                    ways +=1\n\n        # Update global min_edges and total_ways\n        if min_edges > min_t:\n            min_edges = min_t\n        if ways >0:\n            total_ways += ways\n\n    # After processing all components\n    if min_edges == float('inf'):\n        # No way to form an odd cycle\n        print(\"0 0\")\n    else:\n        print(f\"{min_edges} {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 2004,
        "thoughts_token_count": 1025
    }
}