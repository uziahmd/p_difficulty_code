{
    "start": 1758286389.2303224,
    "end": 1758288560.6792665,
    "start-formatted": "2025-09-19 21:53 KST",
    "end-formatted": "2025-09-19 22:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. Hmm, the problem is called Polycarp's Practice. The goal is to maximize the total profit from solving problems over k days.\n\nLet me read the problem statement again carefully.\n\nSo, Polycarp has a list of n problems with difficulties a_1 to a_n. He needs to solve all of them in exactly k days. Each day he must solve at least one problem, and he can't skip any. So each day's problems are a contiguous sequence starting from some point. For example, on day 1, he might solve the first m problems, then on day 2, the next p, and so on until all are done.\n\nThe profit for each day is the maximum difficulty in that day's problems. The total profit is the sum of these maxima across all days. We need to distribute the problems into k contiguous groups (days) such that the sum is as large as possible.\n\nOur task is to find this maximum sum and output the way to split the list.\n\nHmm, how to approach this?\n\nFirst, let's think about what contributes to the maximum profit. Each day's profit is the maximum in its segment. So, to maximize the total, we want as many high values as possible to be the maximums of their respective segments.\n\nBut since the segments are contiguous and cover the entire array without skipping, we have to arrange the splits in such a way that the highest elements are each in their own segment if possible.\n\nWait, but sometimes that's not possible because k is less than n. So, perhaps the optimal strategy is to include as many of the top k elements as possible as the maximums of their own segments, and then arrange the rest.\n\nAlternatively, maybe the best way is to select the largest k elements as the maxima of each day, but that depends on whether they can be placed in separate segments.\n\nWait, for example, in the sample given:\n\nn=8, k=3, a = [5,4,2,6,5,1,9,2]\n\nThe optimal split is [5,4,2], [6,5], [1,9,2]. The profits are 5,6,9, summing to 20.\n\nSo the three maxima are 5,6,9. These are the third, fourth, and seventh elements of the array.\n\nHmm, interesting. So perhaps the key is to select the top k elements as the maxima of each day.\n\nBut wait, in the third example:\n\nn=4, k=2, a = [1,2000,2000,2]\n\nThe best is to split into [1,2000] and [2000,2], giving maxima 2000 and 2000, which sum to 4000.\n\nSo both splits' maxima are the same as the two highest elements.\n\nSo maybe the approach is to choose the top k elements as the maxima, and arrange the splits such that each of these elements is the maximum in their day.\n\nBut how do we arrange this? Because the splits have to be contiguous and cover the entire array.\n\nSo here's an idea: the optimal solution is to take the top k elements, assign each to be the maximum of a day, and then split the array into k segments where each of these elements is a maximum in their segment.\n\nSo the steps could be:\n\n1. Select the k largest elements in the array.\n\n2. Sort these in decreasing order.\n\n3. Assign each to a day, making sure that in the array, each of these elements is the maximum in their respective segment.\n\nBut how to ensure that? Because the segments must be contiguous.\n\nWait, perhaps the problem reduces to selecting positions where the top k elements are the maxima, and the splits are between these positions.\n\nAnother thought: each of these top k elements must be the maximum in their own segment. So, their positions must form a non-decreasing order when considering their indices.\n\nWait, no, that's not necessarily true. Wait, suppose you have two high elements, say at positions i and j, where j > i. Then, if you make i's segment end before j, j will be in a later segment, but j's value is higher than those in its segment. But if j is the maximum in its segment, that's fine.\n\nSo, perhaps the optimal way is to pick the top k elements and place each in a separate day, and arrange the splits around them.\n\nBut how?\n\nAnother approach: dynamic programming.\n\nLet's model dp[i][j] as the maximum profit when considering the first i problems, divided into j days.\n\nOur goal is to compute dp[n][k].\n\nHow can we compute dp[i][j]?\n\nFor each i and j, we can consider the last day: on that day, we solve m problems, ending at i. So m can be from 1 to i-j+1 (since we need j-1 days before, each with at least one problem).\n\nSo for each possible m, the maximum in the last m problems is the a_i - m + 1 ... a_i.\n\nThen, dp[i][j] = max over m of (a[m ... i] + dp[i - m][j-1]).\n\nWait, but finding the maximum for each m would be O(n^2 * k), which for n=2000 and k=2000, would be 2e6*2e3=4e9 operations, which is way too slow.\n\nThat's not feasible.\n\nSo, we need a smarter approach.\n\nAlternative idea: Since each day's profit is the maximum in that day's segment, the problem resembles finding a partition of the array into k contiguous segments, and choosing the maximum in each segment, then sum them.\n\nWe need to maximize this sum.\n\nThis seems similar to some problem where you choose certain points to split the array into k parts, and each part contributes the maximum in that part.\n\nWait, maybe the problem can be transformed into selecting k-1 split points in the array, such that when we compute the maximum for each of the k resulting segments, their sum is maximized.\n\nYes. So our problem is to choose k-1 split points (positions after some elements) such that the sum of maxima of the k resulting segments is as large as possible.\n\nNow, the question is: how to choose these split points optimally.\n\nHmm. What's the optimal way to choose the split points?\n\nEach split point should be placed in such a way that the maximum in the current segment is as large as possible, and also allows for the remaining segments to have their maximums as large as possible.\n\nWait, maybe the optimal split points are the positions where a new maximum is found.\n\nAlternatively, let's consider that for the sum to be maximum, each of the k segments should have their maximum as high as possible.\n\nThus, the best way is to have each of the top k elements as the maximum of their respective segments.\n\nSo, the plan is:\n\n- Find the top k elements in the array.\n\n- Ensure that each is the maximum in its segment.\n\n- Arrange the segments such that the split points are between these top elements, allowing each to be the maximum of their own segment.\n\nBut how to formalize this.\n\nWait, perhaps the key is to select the k largest elements, and arrange the splits such that each of these elements is the maximum of their respective segment.\n\nOnce we have those elements, the split points are determined by the earliest positions after which a higher element occurs.\n\nAlternatively, perhaps we can model this as follows:\n\nThe optimal solution will consist of the top k elements, each being the maximum of their respective segments.\n\nThese top k elements must be arranged such that each is in a separate segment, and the segments are as small as possible beyond that.\n\nWait, perhaps the way to maximize the sum is to collect the top k elements, and for each, create a segment that ends just before the next higher element.\n\nBut I'm not sure.\n\nAlternatively, think about the following: each time you have a new maximum in the array, it's better to split the array there so that this maximum becomes the profit of a day.\n\nBut that's only possible if we have enough days left.\n\nWait, perhaps we can precompute for each position the next occurrence of a higher or equal element. Then, when trying to split the array, the optimal split points would be just after these positions.\n\nBut I'm not sure.\n\nWait, perhaps another approach is to realize that for any split into k segments, the sum of the maxima is the sum of the maximum of each segment.\n\nThus, to maximize this sum, we need to select the k segments in such a way that each segment contributes as much as possible.\n\nBut how?\n\nMaybe, for each possible split into k segments, the sum is the sum of the maxima of the segments. To find the maximum possible sum, perhaps we can model this as a dynamic programming problem.\n\nLet me think about the DP approach again.\n\nDefine dp[i][j] as the maximum sum we can get for the first i elements split into j segments.\n\nTo compute dp[i][j], we can consider all possible m (from 1 to i-j+1), and for each m, the maximum of the last m elements (i-m+1 to i) is a certain value, say a[p], and then add that to dp[i-m][j-1].\n\nThe problem is that for each i and j, checking all possible m is O(n), leading to O(n^2k) time, which is 2000^3=8e10 operations, which is way too slow.\n\nSo, we need a way to compute this more efficiently.\n\nAn alternative idea: For each position i and j, instead of considering all possible m, find the maximum possible a[p] in the range [i - m +1, i], and then see if adding this a[p] to dp[i - m][j-1] gives a better result.\n\nBut how can we find the maximum quickly?\n\nWait, for each j, we can process i in order, and for each i, track the maximum so far as we move backwards.\n\nWait, perhaps for each j, we can iterate i from 1 to n, and for each i, we can compute the maximum of the last m elements for varying m, but using a sliding window approach.\n\nAlternatively, for each j, we can precompute for each i the maximum in the ranges ending at i, for various lengths.\n\nHmm, but I'm not sure.\n\nWait, another observation: the maximum for the last segment (ending at i) is the maximum among a[i], a[i-1], ..., a[i - m +1], where m is the length of the last segment.\n\nSo, for each j, when computing dp[i][j], the maximum of the last segment can be found by considering all possible m, and the maximum of a[i - m +1 ... i].\n\nBut finding the maximum for all possible m is O(n) per i, j pair, which is too slow.\n\nSo, perhaps we can precompute for each position i, the next occurrence of a higher or equal element. Then, for each i, the maximum of the last segment can be found in O(1) time, by knowing the previous maximum.\n\nWait, perhaps using a monotonic stack to find for each position the nearest greater or equal element to the right.\n\nAlternatively, for each i, the maximum in the range [i - m +1, i] is the maximum between a[i] and the maximum in [i - m, i-1]. So, perhaps we can compute for each i, j the maximum in the last m elements quickly.\n\nWait, let's think differently. For the DP approach, the recurrence is:\n\ndp[i][j] = max( dp[i - m][j-1] + max(a[i - m + 1 ... i]) ) for m in 1..i-j+1.\n\nSo, the inner loop is for m, but to compute max(a[i -m +1 ... i]), perhaps we can precompute for each i, the maximum for all possible m.\n\nWait, for each i, we can precompute the maximum for all possible subarrays ending at i.\n\nThis can be done in O(n^2) time, which for n=2000 is manageable.\n\nLet me think: create a 2D array max_sub, where max_sub[i][m] represents the maximum of the subarray of length m ending at position i.\n\nWait, but m can be up to 2000, and i up to 2000, so this would be a 2000x2000 array, which is manageable.\n\nHow to compute max_sub:\n\nFor each i from 0 to n-1:\n   current_max = a[i]\n   for m from 1 to i+1:\n       if m ==1:\n           current_max = a[i]\n       else:\n           current_max = max(current_max, a[i - m +1])\n       max_sub[i][m] = current_max\n\nWait, no, because for m=2, the subarray is a[i-1], a[i], so the maximum is max(a[i-1], a[i]).\n\nWait, perhaps it's better to build it as for each i, and for each possible start s (from 0 to i), compute the maximum from s to i.\n\nBut that's O(n^2), which is acceptable.\n\nSo, precompute for all i, j where j <= i+1, the maximum of a[j ... i].\n\nWait, perhaps it's easier to precompute for each position i, the maximum of every possible subarray ending at i.\n\nLet me try this.\n\nCompute for each i, an array of maxima for subarrays ending at i of length 1, 2, ..., i+1.\n\nWait, but for i=0 (the first element), the maxima for length 1 is a[0], and that's it.\n\nFor i=1, the subarrays are [a1], [a0,a1], so maxima are a1 and max(a0,a1).\n\nAnd so on.\n\nSo, for each i, we can compute for each possible length m (from 1 to i+1) the maximum of a[i - m +1 ... i].\n\nThis can be computed in O(n^2) time.\n\nOnce we have this, for any i and j, when considering a segment ending at i with length m, the maximum is known.\n\nBut how does this help us in the DP?\n\nIn the DP step, for dp[i][j], we have to choose m in 1..i-j+1, and then the maximum is max_sub[i][m], and then dp[i][j] = max over m of ( dp[i - m][j-1] + max_sub[i][m] )\n\nBut even with the max_sub precomputed, for each i and j, we'd have to loop through m, which is O(n) per i,j.\n\nWhich for n=2000 and k=2000 is 2000*2000*2000=8e9 operations—way too slow.\n\nHmm, so this suggests that the DP approach is not efficient enough.\n\nWe need a smarter way.\n\nAlternative idea: Since the maximum of a segment is crucial, perhaps the optimal solution is to greedily split the array into segments where each segment's maximum is as large as possible, but ensuring that we have exactly k segments.\n\nBut how?\n\nWait, perhaps the best way is to split the array into the top k elements, each as a single-element segment, and then merge the remaining segments into the preceding ones.\n\nWait, but that's not necessarily correct. Because sometimes combining multiple lower elements into a single segment may allow a higher maximum elsewhere.\n\nWait, for example, suppose we have elements like [3,1,4,2]. If k=2, splitting into [3,1], [4,2] gives maxes 3 and 4, sum 7. Alternatively, [3,1,4], [2] gives 4 and 2, sum 6. Or [3], [1,4,2] gives 3 and 4, same sum.\n\nSo, the first option is better.\n\nBut if the array is [5,4,2,6,5,1,9,2], as in the sample, the best is to split into [5,4,2], [6,5], [1,9,2], which includes 5,6,9 as maxes.\n\nSo, the top three elements are 9,6,5, but the maxes are 5,6,9, which are in the order they appear.\n\nWait, perhaps the key is to select the top k elements, and then arrange the splits such that each of these is the maximum in their segment.\n\nBut how to determine the splits.\n\nAnother approach: Since each day's profit is the maximum of the segment, the optimal way is to have the largest possible elements as the maximums.\n\nSo, the problem reduces to selecting the k largest elements, and assigning each to be the maximum of a segment, with the constraint that the segments are contiguous and cover the entire array.\n\nSo, the algorithm could be:\n\n1. Identify the positions of the top k elements in the array.\n\n2. Arrange the splits such that each of these elements is in a separate segment, and the segments are contiguous.\n\nBut how to do this.\n\nPerhaps, the optimal way is to have each of these top k elements as the maximum of their own segment, and the segments are as small as possible beyond that.\n\nWait, perhaps the way is to go through the array from left to right, and whenever we encounter a new top element, we split the segment.\n\nBut we need to have exactly k segments.\n\nWait, but the top k elements may not be consecutive, so perhaps the number of splits required is k.\n\nWait, for example, if the array has more than k top elements, but that's not possible because k is the number of days.\n\nWait, perhaps the top k elements are all the ones that will be the maxima of their segments.\n\nSo, the steps are:\n\n- Collect the indices of the top k elements in the array.\n\n- Sort these indices in increasing order.\n\n- Now, these elements will be the maxima of their respective segments.\n\n- The segments will be the ranges between consecutive indices.\n\nWait, for example, in the sample, the top 3 elements are 9 (index 6), 6 (index 3), 5 (index 4). Sorted indices: 3,4,6.\n\nSo, the segments are [0..3], [4..4], [5..6], but wait, that doesn't fit. Or perhaps the segments are [0..3], [4..4], [5..6], but that would require 3 segments, each containing one of the top elements.\n\nBut in the sample, the splits are [5,4,2], [6,5], [1,9,2]. So the maxima are 5,6,9.\n\nWait, 5 is at index 0, 6 at 3, 9 at 6.\n\nSo, the segments are 0-2 (max 5), 3-4 (max 6), 5-7 (max 9).\n\nHmm, so the indices of the top elements are 0,3,6.\n\nSo, the splits are made after 2 (so first segment is 0-2), then after 4 (second segment is 3-4), then the third is 5-7.\n\nWait, but how to decide where to split.\n\nAh, perhaps the way is to greedily assign each top element to be the maximum of a segment, and the segments are built around these elements.\n\nWait, perhaps the process is:\n\n- Sort the top k elements in the order they appear.\n\n- Then, create the segments as follows:\n\n   - The first segment starts from the beginning and ends at the first top element's index.\n\n   - The second segment starts from the next position after the first top element and ends at the next top element's index.\n\n   - And so on.\n\nBut wait, in the sample, the top elements are 5 (index 0), 6 (index 3), 9 (index 6).\n\nSo, according to this approach, the first segment is 0-0, second 1-3, third 4-6.\n\nBut that's not the case in the sample. The sample's first segment is 0-2, which includes 5,4,2, whose max is 5.\n\nHmm, so this approach doesn't directly give the sample's answer.\n\nSo, perhaps my initial assumption is incorrect.\n\nAnother idea: Maybe the way to maximize the sum is to have each of the top k elements as the maximum of their own segment, and the segments are formed in such a way that the next segment starts right after the previous one, and the maximum of the new segment is the next top element.\n\nBut how to arrange the segments.\n\nWait, perhaps the optimal way is to have the top k elements as the maxima of the segments, and the other segments are merged into the previous ones, but that doesn't seem to fit.\n\nWait, perhaps the approach is to have the top k elements as the maxima of their own segments, and the other elements are arranged in such a way that they don't introduce a higher maximum in their own segments.\n\nSo, the plan is:\n\n1. Select the top k elements, say e_1 >= e_2 >= ... >= e_k.\n\n2. These elements will be the maxima of their respective segments.\n\n3. The segments are arranged such that each e_i is in a separate segment, and the segments are contiguous.\n\nSo, the question is, how to arrange the segments.\n\nPerhaps, the way to do this is to have each segment contain exactly one of the top k elements, and all elements in the segment are before the next top element.\n\nWait, but that's not necessarily the case because the next top element could come earlier.\n\nWait, perhaps we can model this as follows:\n\nWe have the top k elements sorted in the order they appear in the array. Let's call their indices p_1, p_2, ..., p_k, where p_1 < p_2 < ... < p_k.\n\nThen, the segments would be:\n\nSegment 1: from 0 to p_1.\n\nSegment 2: from p_1 + 1 to p_2.\n\nSegment 3: from p_2 + 1 to p_3.\n\n...\n\nSegment k: from p_{k-1} + 1 to p_k.\n\nWait, but then the sum would be e_1 + e_2 + ... + e_k, plus the maxima of the other segments.\n\nBut wait, no. Because in the sample, the third segment is [1,9,2], whose maximum is 9, which is the last top element.\n\nSo, perhaps the segments are structured such that each contains exactly one of the top elements, and the rest are filled with elements before and after in such a way that the maximum is the top element.\n\nBut how?\n\nAlternatively, perhaps the optimal way is to arrange the segments so that each contains exactly one of the top k elements, and the segments are as large as possible to include that element, but not include any larger elements.\n\nWait, perhaps the segments are defined as:\n\nFor each top element e_i, the segment starts at the beginning of the array and ends at the position just before the next top element, ensuring that e_i is the maximum in that segment.\n\nBut I'm not sure.\n\nAnother approach: Let's imagine that we have k segments. Each segment must contain exactly one of the top k elements, and within that segment, no element is larger than that top element.\n\nSo, the steps are:\n\n1. Find all the top k elements, sort them in the order of their occurrence.\n\n2. For each top element, the segment containing it must start at the earliest possible position such that all elements in the segment are <= this top element, and the segment must end before the next top element.\n\nBut this is getting complicated.\n\nWait, perhaps the optimal way is to have the first segment end at the first top element, the second segment end at the second top element, etc., and then the last segment includes everything after the last top element.\n\nBut I'm not sure.\n\nAlternatively, perhaps the problem can be approached by noting that the sum of the maxima is the sum of the top k elements, provided that each is the maximum of their segment.\n\nBut that's only possible if the top k elements can be arranged in a way that each is the maximum of their own segment.\n\nSo, the sum is at least the sum of the top k elements. But can it be more?\n\nNo, because any other arrangement would have segments where the maximum is less than or equal to the top k elements.\n\nThus, the maximum possible sum is the sum of the top k elements.\n\nWait, but in the sample, the sum is 5+6+9=20, which is indeed the sum of the top 3 elements.\n\nIn the third example, the sum is 2000+2000=4000, which is the sum of the top 2 elements.\n\nSo, yes, the maximum possible sum is the sum of the top k elements.\n\nThus, the problem reduces to arranging the splits such that each of the top k elements is in a separate segment, and each is the maximum of their segment.\n\nBut how to arrange the splits.\n\nSo, the plan is:\n\n1. Select the top k elements.\n\n2. Arrange the splits such that each of these elements is the maximum of their own segment.\n\n3. The sum will be the sum of these top k elements.\n\nThus, the problem now is to find the way to split the array into k segments, each containing exactly one of the top k elements, and each of these elements is the maximum in their segment.\n\nSo, how to find the split points.\n\nIdea:\n\n- Sort the top k elements in the order of their occurrence in the array.\n\n- The first segment starts at 0 and ends at the position of the first top element.\n\n- The second segment starts right after the first top element and ends at the position of the second top element.\n\n- Continue this until the last top element, and then the last segment includes all elements after the last top element.\n\nBut wait, this may not always work.\n\nWait, let's test this idea on the sample.\n\nSample array: [5,4,2,6,5,1,9,2]\n\nTop 3 elements are 9,6,5. Their indices are 6,3,4.\n\nWait, no, when sorted in the order of occurrence, the indices are 0 (5),3 (6),4 (5?), wait no.\n\nWait, the array is:\n\nIndices: 0:5, 1:4, 2:2, 3:6,4:5,5:1,6:9,7:2.\n\nTop 3 elements are 9 (6), 6 (3),5 (0 and 4). Wait, but 5 appears twice.\n\nSo, the top 3 elements are 9,6,5. Or wait, wait, the array is [5,4,2,6,5,1,9,2]. So the top 3 are 9,6,5,5.\n\nWait, but 5 appears twice. So, the top 3 are 9,6,5.\n\nBut in the array, 5 is at 0 and 4.\n\nSo, when we collect the top k elements, we need to pick the k largest, and in case of duplicates, perhaps pick the earliest occurrences.\n\nWait, perhaps in the selection, it's the k largest elements, regardless of their positions.\n\nSo, in the sample, the top 3 elements are 9,6,5.\n\nTheir positions are 6,3,0.\n\nWait, no, wait 5 is at 0, which is the first element. So when sorted in order of their occurrence, the positions are 0,3,6.\n\nWait, but 5 is at 0 and 4. So 0 comes before 3 and 6.\n\nThus, the top 3 elements are 9 (6), 6 (3),5 (0).\n\nSo, according to the earlier idea, the first segment is 0-0 (just 5), the second is 1-3 (elements 4,2,6), but the maximum of this segment is 6. Then, the third segment is 4-6, which includes 5,1,9. The maximum here is 9.\n\nSo the sum is 5+6+9=20, which matches the sample.\n\nSo, the split points are after 0, after 3, and after 6.\n\nThus, the segments are [0], [1-3], [4-6], and then the remaining [7]. But wait, in the sample, the third segment is [5,1,9,2], but that's 5-7.\n\nWait, perhaps the earlier approach isn't sufficient.\n\nWait, perhaps the way is to have the first segment end at the first top element, the second segment ends at the second top, etc., but the last segment starts from the position after the last top element.\n\nWait, in the sample, the last top element is 9 at position 6.\n\nThe next elements are 7, which is 2. So the last segment is from 7 to 7.\n\nThus, the segments are:\n\n0-0: [5] → sum 5.\n\n1-3: [4,2,6] → sum 6.\n\n4-6: [5,1,9] → sum 9.\n\n7-7: [2] → sum 2.\n\nWait, but that's four segments, but k=3 in the sample.\n\nHmm, so perhaps this approach isn't directly applicable.\n\nAlternatively, perhaps the way to split is to have the first segment end at the first top element, the second segment starts right after that and ends at the next top element, and the third segment starts right after that and ends at the end.\n\nSo, in the sample, the first segment is 0-0, the second is 1-3, the third is 4-7.\n\nThus, the segments are [5], [4,2,6], [5,1,9,2]. The maxima are 5,6,9, sum 20.\n\nYes, that's the sample's split.\n\nSo, according to this approach, the split points are after 0, after 3, and at the end.\n\nSo, the way is to collect the top k elements, and for each, the segment ends at their position, except for the last, which covers until the end.\n\nThus, the steps are:\n\n1. Identify the top k elements.\n\n2. For each of these elements, in the order of their occurrence, the segment ends at their position.\n\n3. The first segment starts at 0 and ends at the first top element.\n\n4. The second segment starts at the position after the first top element and ends at the second top element.\n\n5. The third segment starts at the position after the second top element and ends at the third top element.\n\n6. The last segment starts at the position after the last top element and ends at the end of the array.\n\nBut wait, in the sample, the third top element is at position 6. So, the third segment starts at 4 (position after 3, which was the second top element) and ends at 6. The last segment is from 7 to 7.\n\nBut that leaves the last segment as [2], which is correct.\n\nSo, the way to compute the split is:\n\n- Find the indices of the top k elements, sorted in the order they appear in the array.\n\n- The first split is after the first top element.\n\n- The second split is after the second top element.\n\n- ...\n\n- The last split is at the end.\n\nBut wait, what about when a top element is followed by another top element? Like in the third example.\n\nIn the third example, the array is [1,2000,2000,2], and k=2.\n\nTop 2 elements are 2000 and 2000.\n\nTheir positions are 1 and 2.\n\nSo, the first split is after 1, the second after 2.\n\nSo, the segments are [1,2000], [2000, 2]. Maxima are 2000 and 2000, sum 4000.\n\nWhich is correct.\n\nSo, this approach works.\n\nThus, the algorithm is:\n\n1. Find the top k elements in the array, sorted in the order of their occurrence.\n\n2. These elements will be the maxima of their respective segments.\n\n3. The segments are formed as follows:\n\n   a. The first segment starts at 0 and ends at the first top element.\n\n   b. The second segment starts at the next position after the first top element and ends at the second top element.\n\n   c. Continue until the k-th top element.\n\n   d. The last segment starts at the position after the last top element and ends at the end of the array.\n\n4. Compute the sum of the top k elements.\n\nSo, the problem reduces to finding the top k elements and their positions.\n\nBut wait, how do we find the top k elements, considering that some may be duplicates.\n\nBecause the problem says \"top k elements\", so if there are more than k elements with the same maximum, we can choose any k of them.\n\nBut in the selection, to maximize the sum, it's best to choose the earliest ones, perhaps.\n\nWait, but the sum is fixed as the sum of the top k elements, regardless of their order.\n\nWait, no. Wait, in the problem, the sum is the sum of the maxima of the segments, which are the top k elements. So, the sum is the sum of the top k elements.\n\nSo, regardless of how the segments are arranged, the sum is fixed as the sum of the top k elements.\n\nThus, the problem is to find any split into k segments where each segment's maximum is among the top k elements.\n\nBut the way to find the split is to select the top k elements, and arrange the segments so that each is in a separate segment.\n\nThus, the steps are:\n\n- Find the indices of the top k elements in the array, in the order they appear.\n\n- Split the array into k segments as described.\n\nThus, the code steps are:\n\n1. Read n, k and the array.\n\n2. Create a list of tuples (value, index) for all elements.\n\n3. Sort this list in descending order, and pick the first k elements.\n\n4. Among these k elements, sort them by their index in ascending order to get the order in which they appear in the array.\n\n5. Now, the segments are:\n\n   a. The first segment starts at 0 and ends at the first element's index.\n\n   b. The second segment starts at first_element.index + 1 and ends at the second element's index.\n\n   c. ...\n\n   d. The k-th segment starts at (k-1)th element's index +1 and ends at n-1.\n\n6. Also, for the case where there are fewer than k elements, but in our problem, k <=n, so this is handled.\n\nWait, but in the sample, the first top element is at 0, the second at 3, the third at 6.\n\nSegments:\n\n0-0: [5]\n\n1-3: [4,2,6]\n\n4-6: [5,1,9]\n\n7-7: [2]\n\nBut wait, the third segment is from 4 to 6, which includes the third top element at 6.\n\nThus, the sum is 5+6+9=20.\n\nYes.\n\nBut what if the top k elements are not in order of their occurrence?\n\nLike, suppose the array is [3,1,4,2], k=2.\n\nTop two elements are 4 and 3.\n\nTheir indices are 2 and 0.\n\nWhen sorted by their occurrence, the order is 0,2.\n\nThus, the first segment is 0-0, the second is 1-2, third is 3-3.\n\nWait, but k=2, so we have two segments.\n\nWait, according to the approach, the first segment is 0-0, the second is 1-2.\n\nThus, the sum is 3 +4 =7.\n\nWhich is correct.\n\nSo, the approach seems solid.\n\nThus, the steps are:\n\n- Extract the top k elements.\n\n- Sort them in the order of their occurrence (sorted by their indices).\n\n- Split the array into k segments:\n\n   - The first segment is from 0 to the first element's index.\n\n   - The second is from (first index +1) to the second's index.\n\n   - ...\n\n   - The k-th segment is from (k-1-th element's index +1) to the end.\n\nThus, the code can proceed as:\n\nRead n, k.\n\nRead the array.\n\nCreate a list of (value, index) pairs.\n\nSort this list in descending order of value, and in case of ties, by index in ascending order (to choose the earliest occurrence).\n\nTake the first k elements.\n\nSort these k elements by their index in ascending order.\n\nThen, the split points are after the first element's index, after the second's, etc.\n\nBut for the code, how to represent this.\n\nSo, the code can proceed as follows:\n\nRead n, k.\n\na = list of integers.\n\npairs = sorted( [(a[i], i) for i in range(n)], key=lambda x: (-x[0], x[1]) )\n\ntop_k = pairs[:k]\n\n# Now, sort top_k by their index in ascending order.\n\ntop_k_sorted = sorted(top_k, key=lambda x: x[1])\n\n# Now, create the split points.\n\nprev = -1\n\nsplit_indices = []\n\nfor i in range(len(top_k_sorted)):\n\n    pos = top_k_sorted[i][1]\n\n    if i < len(top_k_sorted) -1:\n\n        split_indices.append(pos)\n\n    else:\n\n        # The last segment goes to the end.\n\n        pass\n\nWait, no.\n\nWait, the split points are the indices where the segments end.\n\nThe first segment is from 0 to top_k_sorted[0][1].\n\nThe second is from top_k_sorted[0][1]+1 to top_k_sorted[1][1].\n\nAnd so on, until the last segment, which is from top_k_sorted[-2][1]+1 to top_k_sorted[-1][1].\n\nWait, no, because the last segment should go until the end of the array.\n\nSo, the code would collect the split points as the indices of the top_k_sorted elements, except the last, which is not needed as the last segment goes to the",
    "response": "To solve this problem, we need to maximize the total profit Polycarp can achieve by solving problems over k days. Each day, he solves a contiguous segment of problems, and the profit for each day is the maximum difficulty of the problems solved that day. The goal is to distribute the problems into k segments such that the sum of these maxima is maximized.\n\n### Approach\n1. **Identify Top k Elements**: The optimal strategy involves selecting the top k elements from the list of problem difficulties. These top k elements will each be the maximum of their respective segments.\n2. **Sort and Select**: Sort these top k elements in ascending order of their indices to maintain their original order in the array.\n3. **Determine Segments**: Using the sorted indices, split the array into k segments where each segment ends at the index of a top k element. The first segment starts at the beginning of the array and ends at the first top element, the second segment starts right after the first top element and ends at the next top element, and so on until the last segment, which extends to the end of the array.\n\n### Solution Code\n```python\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Create a list of tuples (value, index)\npairs = sorted([(a[i], i) for i in range(n)], key=lambda x: (-x[0], x[1]))\n\ntop_k = pairs[:k]\ntop_k_sorted = sorted(top_k, key=lambda x: x[1])\n\n# Generate the split points\nprev = -1\nsegments = []\nfor i in range(len(top_k_sorted)):\n    pos = top_k_sorted[i][1]\n    if i < len(top_k_sorted) - 1:\n        segments.append(pos + 1)\n    else:\n        segments.append(n)\n\n# Now, construct the split positions\nsplit_indices = [0] + segments\n\n# Calculate the sum of top k elements\nsum_profit = sum(x[0] for x in top_k_sorted)\n\n# Prepare the output\nprint(sum_profit)\nprint(' '.join(map(str, split_indices)))\n```\n\n### Explanation\n- **Reading Input**: The code reads the number of problems `n` and the number of days `k`, followed by the list of problem difficulties.\n- **Top k Selection**: It creates a list of tuples where each tuple contains a problem's difficulty and its index. This list is sorted in descending order of difficulty, ensuring we get the top k elements.\n- **Sorting Indices**: The top k elements are then sorted by their original indices to maintain the order they appear in the array.\n- **Segmentation**: The array is divided into k segments based on the indices of the top k elements. Each segment ends at the index of a top element, except the last segment, which goes to the end of the array.\n- **Profit Calculation**: The sum of the top k elements' difficulties is computed, which is the maximum possible total profit.\n- **Output**: The sum is printed, followed by the indices where each segment ends, which are used to form the segments as described.\n\nThis approach ensures that each segment's maximum difficulty is one of the top k elements, maximizing the total profit efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Create a list of tuples (value, index)\npairs = sorted([(a[i], i) for i in range(n)], key=lambda x: (-x[0], x[1]))\n\ntop_k = pairs[:k]\ntop_k_sorted = sorted(top_k, key=lambda x: x[1])\n\n# Generate the split points\nprev = -1\nsegments = []\nfor i in range(len(top_k_sorted)):\n    pos = top_k_sorted[i][1]\n    if i < len(top_k_sorted) - 1:\n        segments.append(pos + 1)\n    else:\n        segments.append(n)\n\n# Now, construct the split positions\nsplit_indices = [0] + segments\n\n# Calculate the sum of top k elements\nsum_profit = sum(x[0] for x in top_k_sorted)\n\n# Prepare the output\nprint(sum_profit)\nprint(' '.join(map(str, split_indices)))",
    "score": 0,
    "metadata": {
        "prompt_token_count": 909,
        "completion_token_count": 667,
        "thoughts_token_count": 8193
    }
}