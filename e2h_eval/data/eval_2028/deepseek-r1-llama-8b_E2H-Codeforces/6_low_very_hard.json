{
    "start": 1758103527.5985544,
    "end": 1758103656.0324883,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. Hmm, the problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and the total cost is as minimal as possible. If no such pair exists, we return -1.\n\nLet me try to understand the problem step by step. So, each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1. We need to choose two vouchers i and j (i ≠ j) such that:\n\n1. Their durations sum exactly to x.\n2. They don't intersect. That means either the first ends before the second starts or the second ends before the first starts. So, for vouchers i and j, either ri < lj or rj < li.\n\nAnd among all possible pairs that satisfy these conditions, find the one with the minimal total cost.\n\nHmm, how do I approach this? Let's think about the steps.\n\nFirst, I need to process all possible pairs of vouchers. But since n can be up to 2e5, a brute-force approach checking every pair would be O(n^2), which is way too slow for n=2e5. So, we need a more efficient method.\n\nWait, but wait. Maybe we can pre-process the vouchers in some way. Like, group them by their duration. Because the sum of their durations needs to be exactly x. So for each voucher, if its duration is d, then the other voucher must have duration x - d.\n\nSo, perhaps for each voucher, we can look for another voucher with duration x - d, and non-overlapping with it.\n\nBut even that might not be efficient enough because for each voucher, searching through all vouchers with x-d duration could still be O(n^2) in the worst case.\n\nWait, but maybe we can structure the data in a way that allows us to quickly find the best possible pair for each voucher.\n\nAnother thought: for each possible duration d, collect all vouchers with that duration. Then, for each voucher i with duration d, look into the list of vouchers with duration x-d. For each such voucher j, check if they are non-overlapping, and keep track of the minimal cost.\n\nBut again, for large n, this could be expensive.\n\nAlternatively, perhaps we can sort the vouchers in some way, like by their end times, to make it easier to check for non-overlapping.\n\nWait, let's think about the non-overlapping condition. For two vouchers i and j, either i ends before j starts, or j ends before i starts. So, when considering a voucher i, any voucher j that comes after i and doesn't overlap must have lj > ri. Or, j could come before i, but then lj < li.\n\nSo, perhaps for each voucher i, we can find the minimal cost voucher j in the required duration group that is either entirely after i or entirely before i.\n\nBut how to efficiently find those?\n\nAnother idea: for each possible duration d, have a sorted list of vouchers with that duration, ordered by their end time. Then, for a voucher i with duration d, we can look for vouchers j with duration x-d in the same or different group, and check if j's end is before i's start, or j's start is after i's end.\n\nWait, but vouchers j can be in any group as long as their duration is x-d.\n\nSo, perhaps for each voucher i, we can consider two cases:\n\n1. Find vouchers j where j's end <= i's start. So j must be before i, and their duration is x - d_i. We can look for the minimal cost j in the group of vouchers with duration x-d_i, whose end is <= i's start.\n\n2. Find vouchers j where j's start >= i's end. So j is after i, and their duration is x - d_i. Again, look for the minimal cost j in the group x-d_i, with start >= i's end.\n\nIf we can do this efficiently, then for each i, we can find the best j in O(log n) time.\n\nSo, the plan is:\n\n- Preprocess the vouchers into groups based on their duration. Each group will store the vouchers sorted by end time and also sorted by start time.\n\n- For each voucher i, compute the needed duration d = x - duration_i. If d is negative, skip.\n\n- Check if there are any vouchers in the group with duration d. If not, skip.\n\n- For the group with duration d, find the minimal cost voucher j that satisfies either:\n\n   a. j's end <= i's start, or\n\n   b. j's start >= i's end.\n\n- Keep track of the minimal total cost across all such pairs.\n\nBut how to represent the groups to allow efficient querying.\n\nFor each group d, we can have two sorted lists:\n\n- Sorted by end time, to",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their total duration equals exactly x days and their combined cost is minimized. If no such pair exists, we return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers based on their duration. This helps in quickly finding pairs of vouchers whose durations sum up to x.\n2. **Sort Vouchers**: For each group of vouchers with a specific duration, we sort them by their end time. This allows us to efficiently check for non-overlapping conditions.\n3. **Check Non-Overlapping Conditions**: For each voucher, we look for another voucher in the required duration group that either ends before the current voucher starts or starts after the current voucher ends. We use binary search to efficiently find these candidates.\n4. **Track Minimum Cost**: For each valid pair of vouchers, we calculate the total cost and keep track of the minimum cost encountered.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    x = int(data[idx+1])\n    idx +=2\n    vouchers = []\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        c = int(data[idx+2])\n        idx +=3\n        vouchers.append((l, r, c))\n    \n    # Group vouchers by their duration\n    from collections import defaultdict\n    duration_groups = defaultdict(list)\n    for l, r, c in vouchers:\n        d = r - l + 1\n        duration_groups[d].append( (l, r, c) )\n    \n    min_total = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i +1\n        needed_d = x - d_i\n        if needed_d <=0:\n            continue\n        if needed_d not in duration_groups:\n            continue\n        \n        # Case 1: j ends before i starts\n        # Find j where r_j <= l_i\n        # So j's end time is <= l_i\n        # Among these, find the one with minimal cost\n        group = duration_groups[needed_d]\n        # We can search in the group for j's where r_j <= l_i\n        # To do this, we can sort the group by r_j\n        # Then perform a binary search to find the largest r_j <= l_i\n        sorted_group = sorted(group, key=lambda x: x[1])\n        # Binary search for the maximum index where r_j <= l_i\n        # Using bisect_right\n        pos = bisect.bisect_right([v[1] for v in sorted_group], l_i)\n        if pos >0:\n            candidate = sorted_group[pos-1]\n            min_cost = candidate[2]\n            total = c_i + min_cost\n            if total < min_total:\n                min_total = total\n        \n        # Case 2: j starts after i ends\n        # j's l_j >= r_i\n        # We can search for j's where l_j >= r_i\n        # Since the group is sorted by r, perhaps it's better to sort by l?\n        # Alternatively, we can sort the group by l_j and then use bisect_left to find first l_j >= r_i\n        # Let's try sorting by l_j\n        sorted_by_l = sorted(group, key=lambda x: x[0])\n        pos = bisect.bisect_left([v[0] for v in sorted_by_l], r_i)\n        if pos < len(sorted_by_l):\n            candidate = sorted_by_l[pos]\n            min_cost = candidate[2]\n            total = c_i + min_cost\n            if total < min_total:\n                min_total = total\n    \n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers.\n2. **Grouping Vouchers**: Vouchers are grouped by their duration using a dictionary where the key is the duration and the value is a list of vouchers with that duration.\n3. **Sorting**: Each group of vouchers is sorted by their end time and start time to facilitate efficient searching.\n4. **Binary Search**: For each voucher, we use binary search to find the best possible non-overlapping voucher in the required duration group.\n5. **Cost Calculation**: For each valid pair of vouchers, the total cost is calculated and the minimum cost is tracked.\n6. **Output Result**: The minimum cost is printed if a valid pair exists; otherwise, -1 is printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    x = int(data[idx+1])\n    idx +=2\n    vouchers = []\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        c = int(data[idx+2])\n        idx +=3\n        vouchers.append((l, r, c))\n    \n    # Group vouchers by their duration\n    from collections import defaultdict\n    duration_groups = defaultdict(list)\n    for l, r, c in vouchers:\n        d = r - l + 1\n        duration_groups[d].append( (l, r, c) )\n    \n    min_total = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i +1\n        needed_d = x - d_i\n        if needed_d <=0:\n            continue\n        if needed_d not in duration_groups:\n            continue\n        \n        # Case 1: j ends before i starts\n        # Find j where r_j <= l_i\n        # So j's end time is <= l_i\n        # Among these, find the one with minimal cost\n        group = duration_groups[needed_d]\n        # We can search in the group for j's where r_j <= l_i\n        # To do this, we can sort the group by r_j\n        # Then perform a binary search to find the largest r_j <= l_i\n        sorted_group = sorted(group, key=lambda x: x[1])\n        # Binary search for the maximum index where r_j <= l_i\n        # Using bisect_right\n        pos = bisect.bisect_right([v[1] for v in sorted_group], l_i)\n        if pos >0:\n            candidate = sorted_group[pos-1]\n            min_cost = candidate[2]\n            total = c_i + min_cost\n            if total < min_total:\n                min_total = total\n        \n        # Case 2: j starts after i ends\n        # j's l_j >= r_i\n        # We can search for j's where l_j >= r_i\n        # Since the group is sorted by r, perhaps it's better to sort by l?\n        # Alternatively, we can sort the group by l_j and then use bisect_left to find first l_j >= r_i\n        # Let's try sorting by l_j\n        sorted_by_l = sorted(group, key=lambda x: x[0])\n        pos = bisect.bisect_left([v[0] for v in sorted_by_l], r_i)\n        if pos < len(sorted_by_l):\n            candidate = sorted_by_l[pos]\n            min_cost = candidate[2]\n            total = c_i + min_cost\n            if total < min_total:\n                min_total = total\n    \n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 1018,
        "thoughts_token_count": 1025
    }
}