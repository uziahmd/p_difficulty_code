{
    "start": 1758278109.564469,
    "end": 1758278332.3373675,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Guard Duty,\" and from the description, I understand that we need to assign Rebel spaceships to guard B bases in such a way that each base has exactly one spaceship, and vice versa. But there's a catch: the paths from each base to its assigned spaceship shouldn't intersect any other paths. So, no two straight lines connecting a base to its spaceship should cross each other in the galaxy plane.\n\nHmm, right. So the first thing that comes to mind is that this is a matching problem, but with an additional geometric constraint. The main task is to determine whether such a perfect matching exists.\n\nLet's break down the problem.\n\nWe have R Rebel ships and B bases. The input gives R points for the ships and B points for the bases. We need to find a bijection between the two sets (since R equals B, as per the problem statement) such that when we connect each ship to a base, none of these line segments intersect each other.\n\nWait, wait. Wait—no. Actually, the problem says R can be equal to or different from B? No, looking back at the input constraints, it's given that R and B are between 1 and 10. Oh, wait, no—looking again, the first line contains two integers R and B. Then, R lines follow for the ships, and B lines for the bases. So, in the first example, R=3 and B=3, which matches. So I think in general, R must equal B because the assignment requires a perfect matching. Otherwise, if R != B, it's impossible. So the first check is whether R equals B. If not, output 'No' immediately.\n\nSo step one: check if R == B. If not, return 'No'.\n\nNow, assuming R equals B, the next step is to find a perfect matching between the two sets, where each line segment doesn't intersect any others.\n\nHow do we model this? It seems like a bipartite matching problem with an added geometric condition. So perhaps the approach is to generate all possible permutations of matching ships to bases and then check for each permutation whether the corresponding line segments are non-intersecting.\n\nBut wait, R can be up to 10. So the number of permutations is 10! = 3,628,800. That's manageable, even in Python. Because 3 million iterations are feasible.\n\nFor each permutation, we can check whether the lines between the ships and bases in that order form a non-crossing set of segments.\n\nWait, but how to model the order? Because the order in which the ships are matched to the bases determines the line segments. For example, if we have a permutation P where P[i] is the base index assigned to the i-th ship, then the segments are ship_0 to base_{P[0]}, ship_1 to base_{P[1]}, etc. We need to ensure that none of these segments cross each other.\n\nSo for each permutation, we can generate the list of segments and check for any two segments whether they cross. If any pair crosses, we discard this permutation. Otherwise, if all pairs are non-crossing, we return 'Yes'.\n\nSo the plan is:\n\n1. Check if R != B. If so, output 'No'.\n2. Otherwise, generate all possible permutations of the B bases for the R ships.\n3. For each permutation:\n   a. Create a list of line segments: ship_0 to permutation[0], ship_1 to permutation[1], ..., ship_{R-1} to permutation[R-1}.\n   b. For every pair of segments in this list, check if they intersect.\n   c. If all pairs do not intersect, then return 'Yes'.\n4. If after checking all permutations none satisfy the condition, output 'No'.\n\nThat makes sense. Now, the key is to efficiently implement the line segment intersection check.\n\nHow do we check if two line segments intersect?\n\nI remember that two line segments AB and CD intersect if and only if:\n\n- The endpoints of one segment lie on opposite sides of the other segment, and vice versa.\n\nThe algorithm for this is:\n\nTo check if two segments AB and CD intersect:\n\n1. Compute the orientation of A, B, C and of A, B, D.\n2. Similarly compute the orientation of C, D, A and C, D, B.\n3. The segments AB and CD intersect if and only if:\n   - The orientations of (A,B,C) and (A,B,D) are different, and orientations of (C,D,A) and (C,D,B) are also different.\n   Or\n   - One of the orientations is zero, but the other is not zero, and similarly for the other pair.\n\nAlternatively, another method is to use parametric equations for the lines and compute if they cross within the segments.\n\nBut the orientation method",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship has exactly one assigned base. Additionally, the paths from each base to its assigned spaceship should not intersect any other paths.\n\n### Approach\n1. **Check for Perfect Matching**: First, we check if the number of Rebel spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate Permutations**: For each permutation of bases corresponding to the order of Rebel spaceships, generate the segments connecting each spaceship to its assigned base.\n3. **Check Segment Intersection**: For each permutation, check if any two segments intersect. If a permutation exists where no segments intersect, output \"Yes\". If all permutations result in intersecting segments, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n\n    ccw1 = ccw(A, B, C)\n    ccw2 = ccw(A, B, D)\n    ccw3 = ccw(C, D, A)\n    ccw4 = ccw(C, D, B)\n\n    if ccw1 * ccw2 < 0 and ccw3 * ccw4 < 0:\n        return True\n\n    if ccw1 == 0 and ccw2 == 0:\n        if (A[0] == C[0] and A[1] == C[1]) or (B[0] == C[0] and B[1] == C[1]):\n            return True\n        if (A[0] == D[0] and A[1] == D[1]) or (B[0] == D[0] and B[1] == D[1]):\n            return True\n\n    if ccw3 == 0 and ccw4 == 0:\n        if (C[0] == A[0] and C[1] == A[1]) or (D[0] == A[0] and D[1] == A[1]):\n            return True\n        if (C[0] == B[0] and C[1] == B[1]) or (D[0] == B[0] and D[1] == B[1]):\n            return True\n\n    return False\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    R_B = data[0].split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x, y = map(int, data[_+1].split())\n        ships.append((x, y))\n\n    bases = []\n    for _ in range(B):\n        x, y = map(int, data[_ + R + 1].split())\n        bases.append((x, y))\n\n    for perm in permutations(range(B)):\n        segments = []\n        for i in range(R):\n            ship = ships[i]\n            base_index = perm[i]\n            base = bases[base_index]\n            segments.append( (ship, base) )\n\n        conflict = False\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                s1 = segments[i]\n                s2 = segments[j]\n                if segments_intersect(s1, s2):\n                    conflict = True\n                    break\n            if conflict:\n                break\n\n        if not conflict:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for Rebel spaceships and bases.\n2. **Permutation Check**: For each permutation of bases, we create segments connecting each spaceship to its assigned base.\n3. **Intersection Check**: Using the `ccw` function to determine the orientation of points, we check if any two segments intersect. If any permutation avoids all intersections, we print \"Yes\". If none do, we print \"No\".\n\nThis approach ensures that we efficiently check all possible assignments using permutations and geometric checks for segment intersections.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n\n    ccw1 = ccw(A, B, C)\n    ccw2 = ccw(A, B, D)\n    ccw3 = ccw(C, D, A)\n    ccw4 = ccw(C, D, B)\n\n    if ccw1 * ccw2 < 0 and ccw3 * ccw4 < 0:\n        return True\n\n    if ccw1 == 0 and ccw2 == 0:\n        if (A[0] == C[0] and A[1] == C[1]) or (B[0] == C[0] and B[1] == C[1]):\n            return True\n        if (A[0] == D[0] and A[1] == D[1]) or (B[0] == D[0] and B[1] == D[1]):\n            return True\n\n    if ccw3 == 0 and ccw4 == 0:\n        if (C[0] == A[0] and C[1] == A[1]) or (D[0] == A[0] and D[1] == A[1]):\n            return True\n        if (C[0] == B[0] and C[1] == B[1]) or (D[0] == B[0] and D[1] == B[1]):\n            return True\n\n    return False\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    R_B = data[0].split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x, y = map(int, data[_+1].split())\n        ships.append((x, y))\n\n    bases = []\n    for _ in range(B):\n        x, y = map(int, data[_ + R + 1].split())\n        bases.append((x, y))\n\n    for perm in permutations(range(B)):\n        segments = []\n        for i in range(R):\n            ship = ships[i]\n            base_index = perm[i]\n            base = bases[base_index]\n            segments.append( (ship, base) )\n\n        conflict = False\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                s1 = segments[i]\n                s2 = segments[j]\n                if segments_intersect(s1, s2):\n                    conflict = True\n                    break\n            if conflict:\n                break\n\n        if not conflict:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 983,
        "thoughts_token_count": 1025
    }
}