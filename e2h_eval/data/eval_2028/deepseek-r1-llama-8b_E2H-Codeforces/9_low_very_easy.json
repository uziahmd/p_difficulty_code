{
    "start": 1758104197.1036317,
    "end": 1758104347.728034,
    "start-formatted": "2025-09-17 19:16 KST",
    "end-formatted": "2025-09-17 19:19 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Selling Souvenirs.\" Hmm, I think I understand the problem.\n\nSo, Petya has n souvenirs. Each souvenir has a weight (wi) and a cost (ci). He can carry a total weight not exceeding m. We need to select a subset of these souvenirs such that their total weight is <= m, and the total cost is as large as possible. Our task is to find this maximum cost.\n\nThe constraints are n up to 1e5 and m up to 3e5. Oh right, so we need an efficient solution because a naive approach might not work within the time limits.\n\nLet me think about how to model this. It feels like a knapsack problem, but with some optimizations since the weights are small (wi can be 1, 2, or 3).\n\nWait, in the knapsack problem, when the weights are small, we can use a dynamic programming approach with a state for each possible weight. But with m up to 3e5, that could be manageable. However, n is up to 1e5, which might make a straightforward DP approach too slow because for each item, we might have to iterate through all possible weights up to m.\n\nHmm, maybe there's a smarter way. Since the items have small weights, perhaps we can group them by their weight and process each group separately.\n\nFor example, group all items of weight 1, then 2, then 3. For each group, we can sort the items in descending order of cost. Then, for each group, we can precompute the prefix sums, so that for any number of items taken from that group, we know the maximum cost we can get for that count.\n\nOnce we have these prefix sums, we can try to combine the groups in a way that maximizes the total cost without exceeding the weight m.\n\nBut how do we combine them? Since the groups are ordered by weight, adding items from lower-weight groups before higher ones makes sense.\n\nWait, here's an idea: For each possible total weight up to m, keep track of the maximum cost. But since the items are grouped by weight, we can iterate through the groups and update the DP accordingly.\n\nAlternatively, another approach is to represent the DP state as the maximum cost for a certain number of items taken from each group. But that might get complicated.\n\nWait, perhaps a better approach is to model the DP as follows:\n\nWe can have a DP array where dp[j] represents the maximum cost achievable with a total weight j. We initialize dp[0] = 0, and the rest as -infinity or something.\n\nThen, for each group of items (sorted by weight), we process them one by one. For each item in the group, we consider adding it to existing states in the DP.\n\nWait, but processing each item individually might be expensive. So, perhaps instead, for each group, we can compute the best way to take k items from that group and add it to the current DP states.\n\nWait, for each group, say weight w, we can sort the items in descending order of cost. Then, compute the prefix sums for the group. That way, taking the first t items gives us the maximum possible cost for that group.\n\nOnce we have the prefix sums, we can loop through the groups in order of increasing weight (since taking items with lower weight allows more flexibility). For each group, we can compute the new DP by considering adding 0, 1, ..., up to the maximum possible items from this group, given the remaining weight.\n\nWait, let's think step by step.\n\n1. Sort each group by cost in descending order and compute prefix sums.\n\nGroup1 (weight=1): sorted c1, c2, ... cn. Prefix sum s1[0], s1[1], ... s1[k] where s1[i] is sum of first i items.\n\nSimilarly for group2 (weight=2) and group3 (weight=3).\n\n2. Now, process the groups in order of increasing weight. Because adding a group with weight 1 is more flexible than adding a group with weight 2, since it leaves more space for other items.\n\n3. For each group, for each possible number of items taken from the group, update the DP. But how?\n\nAlternatively, for each group, we can compute the maximum number of items we can take (up to the size of the group) and then see how they can fit into the current DP.\n\nWait, maybe we can model the DP as the maximum cost for a certain total weight, and for each group, we can iterate through the current DP and see if adding items from this group improves the cost.\n\nBut considering the size of m (up to 3e5), and n being 1e5, this might be feasible.\n\nLet me outline the steps again.\n\n",
    "response": "To solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. This is a variation of the knapsack problem with specific constraints on the weights of the items.\n\n### Approach\n1. **Problem Analysis**: The problem is a knapsack problem where each item has a weight of 1, 2, or 3, and a cost. The goal is to maximize the total cost without exceeding the weight limit `m`.\n\n2. **Intuition**: Given the constraints, a direct dynamic programming (DP) approach might be too slow. However, since the weights are limited to 1, 2, or 3, we can optimize by grouping items by their weights and processing each group separately.\n\n3. **Optimization Strategy**:\n   - **Grouping Items**: Group items by their weights into three separate lists: one for weight 1, one for weight 2, and one for weight 3.\n   - **Sorting and Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums. This allows us to quickly determine the maximum cost for taking a certain number of items from each group.\n   - **Dynamic Programming with Weight Groups**: Use a DP array where `dp[j]` represents the maximum cost achievable with a total weight `j`. Process each group of items, updating the DP array to account for the additional cost and weight each item contributes.\n\n4. **Implementation Steps**:\n   - Read and parse the input.\n   - Group items by their weights.\n   - Sort each group by cost in descending order and compute prefix sums.\n   - Initialize the DP array.\n   - Process each group, updating the DP array to reflect the best possible costs considering items from that group.\n   - After processing all groups, the maximum value in the DP array up to the weight limit `m` is the result.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n    groups = {1: [], 2: [], 3: []}\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx += 2\n        groups[w].append(c)\n    \n    # Compute prefix sums for each group\n    for w in groups:\n        groups[w].sort(reverse=True)\n        prefix = [0]\n        s = 0\n        for c in groups[w]:\n            s += c\n            prefix.append(s)\n        groups[w] = (prefix)\n    \n    # Initialize DP\n    dp = [-float('inf')] * (m + 1)\n    dp[0] = 0\n    \n    # Process groups in order of increasing weight\n    for w in sorted(groups.keys()):\n        prefix = groups[w]\n        max_take = len(prefix) - 1\n        for j in range(m, -1, -1):\n            if dp[j] == -float('inf'):\n                continue\n            for k in range(1, max_take + 1):\n                new_weight = j + w * k\n                if new_weight > m:\n                    break\n                new_cost = dp[j] + prefix[k]\n                if new_cost > dp[new_weight]:\n                    dp[new_weight] = new_cost\n    \n    max_cost = max(dp[:m+1])\n    print(max_cost if max_cost != -float('inf') else 0)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Weight**: We group items by their weights (1, 2, 3) to handle them separately.\n- **Sorting and Prefix Sums**: Sorting each group by cost in descending order allows us to efficiently compute the maximum cost for taking a certain number of items using prefix sums.\n- **Dynamic Programming**: We use a DP array to keep track of the maximum cost for each possible weight up to `m`. By processing each group and updating the DP array, we ensure that we consider all possible ways to include items from each group without exceeding the weight limit.\n\nThis approach efficiently handles the constraints and ensures that we find the optimal solution within acceptable time limits.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n    groups = {1: [], 2: [], 3: []}\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx += 2\n        groups[w].append(c)\n    \n    # Compute prefix sums for each group\n    for w in groups:\n        groups[w].sort(reverse=True)\n        prefix = [0]\n        s = 0\n        for c in groups[w]:\n            s += c\n            prefix.append(s)\n        groups[w] = (prefix)\n    \n    # Initialize DP\n    dp = [-float('inf')] * (m + 1)\n    dp[0] = 0\n    \n    # Process groups in order of increasing weight\n    for w in sorted(groups.keys()):\n        prefix = groups[w]\n        max_take = len(prefix) - 1\n        for j in range(m, -1, -1):\n            if dp[j] == -float('inf'):\n                continue\n            for k in range(1, max_take + 1):\n                new_weight = j + w * k\n                if new_weight > m:\n                    break\n                new_cost = dp[j] + prefix[k]\n                if new_cost > dp[new_weight]:\n                    dp[new_weight] = new_cost\n    \n    max_cost = max(dp[:m+1])\n    print(max_cost if max_cost != -float('inf') else 0)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 451,
        "completion_token_count": 900,
        "thoughts_token_count": 1025
    }
}