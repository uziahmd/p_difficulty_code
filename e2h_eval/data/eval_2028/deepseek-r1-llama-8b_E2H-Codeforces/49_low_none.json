{
    "start": 1758278812.1330745,
    "end": 1758279200.721166,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called Mushroom Strife. Hmm. So the setup is that Pasha and Akim made a forest map where lawns are vertices and roads are edges. Each road has two numbers: GCD and LCM of the mushrooms on the connected lawns. But now, some of the map is torn, leaving only m roads. My task is to help restore the number of mushrooms on every lawn based on the given roads. If it's not possible, output NO; else, output any valid arrangement.\n\nThe input gives n and m, followed by m lines each with four numbers: the two lawns connected by the road, the GCD, and the LCM of their mushroom counts.\n\nHmm. So, how do I model this? It seems like a graph problem where each edge imposes constraints on the values of the nodes (lawns). Each node must have a value (number of mushrooms), and each edge enforces that for the two nodes u and v, the GCD of their values is g, and the LCM is l.\n\nWait, but wait. Wait, GCD(u, v) = g and LCM(u, v) = l. Also, since GCD and LCM are related to two numbers, we know that the product of GCD and LCM equals the product of the two numbers. So u * v = g * l. Because GCD(u, v) * LCM(u, v) = u*v. So that's an important relation.\n\nSo for each edge, the two nodes' values must satisfy u * v = g * l, and also GCD(u, v) = g, which implies that g divides both u and v.\n\nSo, for each edge, we can model it as a constraint between u and v. Our goal is to assign values to each node such that all these constraints are satisfied.\n\nThis feels like a problem that can be modeled using a system of equations or constraints, which can be solved using a union-find data structure with some additional information attached to each node. Alternatively, perhaps a BFS approach where we assign values step by step, ensuring that all constraints are satisfied.\n\nBut considering that the constraints are multiplicative, it's tricky because the variables are interdependent. So perhaps the best way is to model this as a graph where each edge represents equations between pairs of variables.\n\nLet me think about how to model this. Each edge between u and v gives us:\n\nu * v = g * l\nand\ng = gcd(u, v)\nl = lcm(u, v)\n\nWait, but since LCM is the least common multiple, which is the smallest number divisible by both u and v. So, if we have u and v, their LCM is determined by the max exponents of primes in their factorizations.\n\nBut perhaps a better way is to represent the relationship between u and v as a ratio. Since u * v = g * l, and g is the GCD, then u = g * a, v = g * b, where a and b are coprime integers (since we've factored out the GCD). Then, the LCM would be g * a * b, because LCM(u, v) = g * a * b when a and b are coprime.\n\nWait, yes! Because if u = g*a and v = g*b, then GCD(u, v) is g * GCD(a, b). But since GCD(u, v) is given as g, this implies that GCD(a, b) must be 1. So a and b are coprime. Then, LCM(u, v) is (g*a*b) because that's the LCM when a and b are coprime.\n\nSo for each edge, the two nodes must be assigned values such that when divided by their GCD, they become coprime, and their product times the GCD gives the product of the GCD and LCM.\n\nSo for each edge, u and v can be represented as u = g * a, v = g * b, where a and b are coprimes, and a*b = (l / g). Because u*v = g*l, substituting u and v gives g^2 * a*b = g*l → g a b = l → a*b = l/g.\n\nSo, for each edge, the product a*b is l/g, and a and b are coprimes.\n\nThus, for each edge, the possible pairs (a, b) are those where a * b = (l/g), and GCD(a, b) = 1.\n\nSo, the approach is:\n\n- Assign variables to each node, which can be either undefined, or set to a certain value.\n- For each edge, create constraints that the product of the two variables (after dividing by their GCD) must equal l/g",
    "response": "To solve this problem, we need to determine the number of laughy mushrooms on each lawn based on the given roads and their GCD and LCM values. The solution involves modeling the problem as a graph where each edge represents constraints on the values of the connected nodes (lawns).\n\n### Approach\n1. **Graph Representation**: Represent the problem as a graph where each node is a lawn and each edge represents the constraints between two lawns in terms of GCD and LCM.\n2. **Constraints Handling**: For each edge, the values of the connected nodes must satisfy that the product of their values equals the product of the given GCD and LCM. Additionally, the values must be such that their GCD is the given value and their LCM is the given value.\n3. **Union-Find Data Structure**: Use a union-find data structure with path compression and union by rank to efficiently manage connected components and track the values of the nodes.\n4. **Breadth-First Search (BFS)**: Perform BFS to explore each connected component, assigning values to nodes step-by-step while ensuring all constraints are satisfied.\n5. **Validation**: After assigning values, validate the solution by checking if all constraints are satisfied for each edge.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n\n    parent = list(range(n + 1))\n    rank = [1] * (n + 1)\n    value = [0] * (n + 1)\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            value[v_root] += value[u_root]\n        else:\n            parent[v_root] = u_root\n            value[u_root] += value[v_root]\n            if rank[u_root] == rank[v_root]:\n                rank[u_root] += 1\n        return True\n\n    for u, v, g, l in edges:\n        if u == v:\n            print(\"NO\")\n            return\n        if find(u) != find(v):\n            union(u, v)\n        else:\n            if value[u] == 0:\n                if l == 0:\n                    print(\"NO\")\n                    return\n                if g * l % (g + l) == 0:\n                    value[u] = g\n                    value[v] = l\n                else:\n                    print(\"NO\")\n                    return\n            else:\n                if (value[u] * value[v]) != (g * l):\n                    print(\"NO\")\n                    return\n\n    visited = [False] * (n + 1)\n    possible = True\n    for u in range(1, n + 1):\n        if not visited[u]:\n            queue = [(u, value[u])]\n            visited[u] = True\n            while queue:\n                current, val = queue.pop(0)\n                for edge in edges:\n                    other = edge[0] if edge[1] == current else edge[1]\n                    if find(other) != find(current):\n                        continue\n                    if value[current] == 0:\n                        possible = False\n                        break\n                    if value[other] == 0:\n                        possible = False\n                        break\n                    if (val * value[other]) != (edge[2] * edge[3]):\n                        possible = False\n                        break\n                if not possible:\n                    break\n            if not possible:\n                break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    result = []\n    for i in range(1, n + 1):\n        if value[i] == 0:\n            print(\"NO\")\n            return\n        result.append(str(value[i]))\n    print(\"YES\")\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution reads the input and constructs the graph representation of the problem. It uses a union-find data structure to manage connected components and assign values to nodes while ensuring all constraints are satisfied. The BFS is used to explore each connected component, assigning values step-by-step. Finally, the solution validates the assigned values against all constraints and outputs the result. This approach ensures that we efficiently determine the possible arrangement of mushrooms or identify if it's impossible.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n\n    parent = list(range(n + 1))\n    rank = [1] * (n + 1)\n    value = [0] * (n + 1)\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            value[v_root] += value[u_root]\n        else:\n            parent[v_root] = u_root\n            value[u_root] += value[v_root]\n            if rank[u_root] == rank[v_root]:\n                rank[u_root] += 1\n        return True\n\n    for u, v, g, l in edges:\n        if u == v:\n            print(\"NO\")\n            return\n        if find(u) != find(v):\n            union(u, v)\n        else:\n            if value[u] == 0:\n                if l == 0:\n                    print(\"NO\")\n                    return\n                if g * l % (g + l) == 0:\n                    value[u] = g\n                    value[v] = l\n                else:\n                    print(\"NO\")\n                    return\n            else:\n                if (value[u] * value[v]) != (g * l):\n                    print(\"NO\")\n                    return\n\n    visited = [False] * (n + 1)\n    possible = True\n    for u in range(1, n + 1):\n        if not visited[u]:\n            queue = [(u, value[u])]\n            visited[u] = True\n            while queue:\n                current, val = queue.pop(0)\n                for edge in edges:\n                    other = edge[0] if edge[1] == current else edge[1]\n                    if find(other) != find(current):\n                        continue\n                    if value[current] == 0:\n                        possible = False\n                        break\n                    if value[other] == 0:\n                        possible = False\n                        break\n                    if (val * value[other]) != (edge[2] * edge[3]):\n                        possible = False\n                        break\n                if not possible:\n                    break\n            if not possible:\n                break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    result = []\n    for i in range(1, n + 1):\n        if value[i] == 0:\n            print(\"NO\")\n            return\n        result.append(str(value[i]))\n    print(\"YES\")\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 536,
        "completion_token_count": 1056,
        "thoughts_token_count": 1025
    }
}