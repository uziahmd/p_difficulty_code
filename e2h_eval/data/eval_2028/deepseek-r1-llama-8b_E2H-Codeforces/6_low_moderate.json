{
    "start": 1758103525.698585,
    "end": 1758103639.5496924,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. Hmm, the problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and the total cost is as minimal as possible. If no such pair exists, we return -1.\n\nLet me break down the problem. We have n vouchers. Each voucher has a start day li, end day ri, and cost costi. The duration of each voucher is ri - li + 1. We need to choose two different vouchers i and j. These two must not intersect, meaning either the end of i is before the start of j or vice versa. Also, the sum of their durations should be exactly x. And among all such possible pairs, we need the one with the smallest total cost.\n\nHmm, okay. So the approach is to find all possible pairs of vouchers where their durations add up to x and they don't overlap. Then, among those pairs, find the one with the minimum cost.\n\nBut wait, n can be up to 2e5. So a naive O(n^2) approach would be way too slow. We need a more efficient method.\n\nSo how do we do this efficiently?\n\nLet's think about the constraints for two vouchers. Let's say voucher A has duration d1, voucher B has duration d2. So d1 + d2 = x. And their time intervals don't overlap.\n\nWait, but the sum of durations must be exactly x. So for each voucher, maybe we can look for another voucher whose duration is x minus the current one's duration.\n\nSo first, for each voucher, compute its duration. Then, for each voucher, we can look for another voucher with duration x - d, and check if they can be non-overlapping.\n\nBut even then, considering all vouchers, this might still be O(n^2), which is not feasible for n=2e5.\n\nWe need a smarter way.\n\nAlternative idea: group the vouchers by their duration. For each duration d, we'll have a list of vouchers with that duration. Then, for each voucher in a group of duration d, we can look for vouchers in the group of duration (x - d), and check whether any of them are non-overlapping.\n\nBut even this might not be efficient enough because for each voucher, we might have to scan through a lot of other vouchers.\n\nWait, but perhaps we can pre-process the vouchers in a way that allows us to quickly find the minimal cost pair that meets the non-overlapping condition.\n\nAnother thought: For each voucher i, we can find all vouchers j that have duration (x - di) and are either completely before i or completely after i.\n\nSo the plan could be:\n\n1. Precompute the duration for each voucher.\n2. Group the vouchers into a dictionary where the key is the duration, and the value is a list of vouchers (their start and end times and cost).\n3. For each voucher i, calculate the required duration d = x - di. If d is less than 0, skip.\n4. Look into the group for duration d and find all vouchers j in that group which are either before i's interval or after i's interval.\n5. For each such j, check if their intervals are non-overlapping with i's.\n6. Among all such pairs (i,j), keep track of the minimal total cost.\n\nBut how do we efficiently find j's that are either before or after i's interval?\n\nHmm, perhaps for each group of a certain duration, we can sort the vouchers based on their end times. Then, for a given voucher i, we can perform a binary search to find all j's in the group that end before i starts.\n\nSimilarly, we can find j's that start after i ends by looking for those that begin at or after i's end+1.\n\nWait, that sounds promising. Let's think about it.\n\nFor each group (duration d), we can sort the vouchers in that group by their end time. Then, for a voucher i, when looking for j's in group d, we can query the sorted list to find all j's where j's end <= i's start - 1. Because that way, j ends before i starts, so they don't overlap.\n\nAdditionally, for j's that start after i ends, we can find j's where j's start >= i's end + 1. So for these, we can sort the group by their start time and use binary search.\n\nWait, but for each group, maybe we can have two sorted lists: one sorted by end time, and another sorted by start time. Or perhaps we can have each group as a list sorted by end time, and for each i, when looking for j's in the same duration group, we can find j's that end before i starts, and j's that start after i ends.\n\nAlternatively, perhaps for each group, we can have a list sorted by end time, and",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals the given vacation duration `x` and whose total cost is minimized. If no such pair exists, we return `-1`.\n\n### Approach\n1. **Precompute Durations**: Calculate the duration for each voucher as `ri - li + 1`.\n2. **Group Vouchers by Duration**: Use a dictionary where the key is the duration and the value is a list of vouchers with that duration.\n3. **Sort Voucher Lists**: For each duration group, sort the vouchers by their end time and start time to facilitate efficient searching.\n4. **Binary Search for Non-overlapping Vouchers**: For each voucher, determine the required complementary duration. Check for vouchers in the complementary group that either end before the current voucher starts or start after the current voucher ends using binary search.\n\n### Solution Code\n```python\nimport bisect\n\nn, x = map(int, input().split())\nvouchers = []\nfor _ in range(n):\n    l, r, c = map(int, input().split())\n    duration = r - l + 1\n    vouchers.append((l, r, duration, c))\n\nfrom collections import defaultdict\n\n# Group vouchers by duration\nduration_groups = defaultdict(list)\nfor v in vouchers:\n    l, r, d, c = v\n    duration_groups[d].append((l, r, c))\n\nmin_cost = float('inf')\n\nfor i in range(n):\n    li, ri, di, ci = vouchers[i]\n    required_d = x - di\n    if required_d < 0:\n        continue\n    if required_d not in duration_groups:\n        continue\n    group = duration_groups[required_d]\n    \n    # Find vouchers that end before li\n    # Sort group by end time\n    sorted_end = sorted(group, key=lambda x: x[1])\n    idx = bisect.bisect_right(sorted_end, (li - 1, float('inf'), float('inf'))) \n    for j in range(idx):\n        lj, rj, cj = sorted_end[j]\n        if rj < li:\n            total_cost = ci + cj\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    # Find vouchers that start after ri\n    # Sort group by start time\n    sorted_start = sorted(group, key=lambda x: x[0])\n    idx = bisect.bisect_left(sorted_start, (ri + 1, float('inf'), float('inf')))\n    for j in range(idx, len(sorted_start)):\n        lj, rj, cj = sorted_start[j]\n        if lj > ri:\n            total_cost = ci + cj\n            if total_cost < min_cost:\n                min_cost = total_cost\n\nif min_cost != float('inf'):\n    print(min_cost)\nelse:\n    print(-1)\n```\n\n### Explanation\n1. **Grouping by Duration**: Each voucher is grouped by its duration to efficiently find complementary vouchers.\n2. **Sorting**: Vouchers in each duration group are sorted by their end and start times to allow binary search operations.\n3. **Binary Search**: For each voucher, we use binary search to quickly find valid complementary vouchers that either end before the current voucher starts or start after the current voucher ends, ensuring non-overlapping intervals.\n4. **Efficiency**: This approach ensures we efficiently check all potential pairs without resorting to an O(n^2) brute force method, making it suitable for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\nn, x = map(int, input().split())\nvouchers = []\nfor _ in range(n):\n    l, r, c = map(int, input().split())\n    duration = r - l + 1\n    vouchers.append((l, r, duration, c))\n\nfrom collections import defaultdict\n\n# Group vouchers by duration\nduration_groups = defaultdict(list)\nfor v in vouchers:\n    l, r, d, c = v\n    duration_groups[d].append((l, r, c))\n\nmin_cost = float('inf')\n\nfor i in range(n):\n    li, ri, di, ci = vouchers[i]\n    required_d = x - di\n    if required_d < 0:\n        continue\n    if required_d not in duration_groups:\n        continue\n    group = duration_groups[required_d]\n    \n    # Find vouchers that end before li\n    # Sort group by end time\n    sorted_end = sorted(group, key=lambda x: x[1])\n    idx = bisect.bisect_right(sorted_end, (li - 1, float('inf'), float('inf'))) \n    for j in range(idx):\n        lj, rj, cj = sorted_end[j]\n        if rj < li:\n            total_cost = ci + cj\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    # Find vouchers that start after ri\n    # Sort group by start time\n    sorted_start = sorted(group, key=lambda x: x[0])\n    idx = bisect.bisect_left(sorted_start, (ri + 1, float('inf'), float('inf')))\n    for j in range(idx, len(sorted_start)):\n        lj, rj, cj = sorted_start[j]\n        if lj > ri:\n            total_cost = ci + cj\n            if total_cost < min_cost:\n                min_cost = total_cost\n\nif min_cost != float('inf'):\n    print(min_cost)\nelse:\n    print(-1)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 722,
        "thoughts_token_count": 1025
    }
}