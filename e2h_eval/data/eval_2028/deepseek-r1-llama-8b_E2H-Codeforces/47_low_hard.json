{
    "start": 1758278310.8154235,
    "end": 1758278588.446414,
    "start-formatted": "2025-09-19 19:38 KST",
    "end-formatted": "2025-09-19 19:43 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Neko does Maths\" and the task is to find a non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. If there are multiple k's that give the same minimal LCM, I have to choose the smallest one.\n\nHmm. So, given two integers a and b, I need to compute this k. Let me think about how to approach this.\n\nFirst, let's understand the problem with some examples. Like the sample input: 6 and 10. When k=2, 6+2=8 and 10+2=12. The LCM of 8 and 12 is 24. That's the minimal possible, right?\n\nAnother example: when a and b are equal, like 5 and 10. Then, adding 0 gives 5 and 10, which have an LCM of 10. Adding anything else would make them larger, so k=0 is the best choice.\n\nWait, but in another case where a and b are not equal, how do we find k? Hmm.\n\nLet me think about the mathematical approach here. Let's denote x = a + k and y = b + k. Since both are increased by k, the difference between them is fixed as d = |a - b|. Because x - y = a - b.\n\nSo, the problem reduces to finding two numbers x and y such that y = x - d, and their LCM is minimized. Or, alternatively, since d is fixed, the problem becomes choosing x such that x and x - d have the smallest possible LCM.\n\nWait, that's a good point. Because for any k, x and y are a+k and b+k, and their difference is always a - b (assuming a >= b; otherwise, it's b - a). So, without loss of generality, we can assume that a >= b, and then the difference is d = a - b.\n\nSo, the problem now is: find x such that x and x - d have the smallest possible LCM, and x >= b (since k is non-negative, x = a + k >= a >= b). Also, we need to find the minimal k, which corresponds to the minimal x, because x = a + k, so smaller x implies smaller k.\n\nWait, no. Because x increases as k increases. So, for x values in increasing order, k is also increasing. So, the earliest x that gives the minimal LCM is the best k.\n\nSo, our goal is to find x such that x and x -d have the minimal LCM, and among all such x, choose the smallest one.\n\nBut how do I find x?\n\nHmm. Let's think about the LCM of x and (x - d). The LCM(x, x-d) is equal to x*(x-d)/gcd(x, x-d). But since x and x-d share a gcd of g, perhaps we can express this in terms of g.\n\nWait, let me see: Let g be the greatest common divisor of x and x-d. Then, x = g * m, and x - d = g * n, where m and n are coprime integers. So, the LCM is g*m*n.\n\nSo, the LCM is (g * m * n).\n\nBut since x - d = g(n) = x - d, so d = g(m - n).\n\nSo, d must be divisible by g.\n\nTherefore, g is a divisor of d.\n\nThat's an important observation. So, for each possible divisor g of d, we can try to find the optimal m and n.\n\nWait, but d is fixed. So, for each possible divisor g of d, we can express d as g * t, where t is some integer.\n\nThen, since x = g * m and x -d = g * n, subtracting gives d = g(m -n) = g*t. So, m - n = t.\n\nAlso, since m and n must be coprime, as per the earlier step.\n\nOur goal is to minimize the LCM, which is g*m*n.\n\nGiven that, for each possible g (divisor of d), we can find the best m and n.\n\nSo, for each g, we can compute the minimal product m*n, given that m and n are positive integers, m > n (since m - n = t, which is positive?), and they are coprime.\n\nWait, but t could be positive or negative, depending on whether x is larger than x-d. Wait, no: x is a +k, and x -d is b +k. Since a >= b, x >= x-d. So, m > n.\n\nSo, m = n + t, where t is a positive",
    "response": "To solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**:\n   - Given two integers \\( a \\) and \\( b \\), we need to find \\( k \\) such that the LCM of \\( a + k \\) and \\( b + k \\) is as small as possible.\n   - The difference between \\( a \\) and \\( b \\) is fixed, denoted as \\( d = |a - b| \\). Without loss of generality, assume \\( a \\geq b \\) so that \\( d = a - b \\).\n\n2. **Key Insight**:\n   - Let \\( x = a + k \\) and \\( y = b + k \\). Then, \\( y = x - d \\).\n   - The goal is to minimize the LCM of \\( x \\) and \\( x - d \\). This can be approached by considering the greatest common divisor (GCD) of \\( x \\) and \\( x - d \\).\n\n3. **Mathematical Formulation**:\n   - Let \\( g \\) be a divisor of \\( d \\). We can express \\( d \\) as \\( g \\times t \\) where \\( t \\) is an integer.\n   - We need to find \\( x \\) such that \\( x = g \\times m \\) and \\( x - d = g \\times n \\) with \\( m > n \\) and \\( \\gcd(m, n) = 1 \\).\n   - The LCM of \\( x \\) and \\( x - d \\) is \\( g \\times m \\times n \\).\n\n4. **Optimization Strategy**:\n   - For each divisor \\( g \\) of \\( d \\), compute the optimal \\( m \\) and \\( n \\) such that \\( m - n = t \\) and \\( \\gcd(m, n) = 1 \\).\n   - Among all valid pairs \\( (m, n) \\), find the one that minimizes \\( g \\times m \\times n \\) and then determine the corresponding \\( k \\).\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    min_lcm = float('inf')\n    best_k = 0\n    # Consider all divisors of d\n    for g in get_divisors(d):\n        if g == 0:\n            continue\n        t = d // g\n        # Find m and n such that m = n + t, gcd(m, n) = 1, and m*n is minimized\n        # Since m = n + t, and m > n >= 1\n        n_min = 1\n        m_min = n_min + t\n        # Check if m_min and n_min are coprime\n        if math.gcd(m_min, n_min) != 1:\n            # Find the smallest n where m and n are coprime\n            n = 1\n            while True:\n                m = n + t\n                if math.gcd(m, n) == 1:\n                    break\n                n += 1\n            product = g * m * n\n        else:\n            product = g * m_min * n_min\n        # Now compute the corresponding k\n        x = g * m\n        k = x - a\n        if k < 0:\n            continue\n        current_lcm = product\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    return best_k\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    a, b = map(int, sys.stdin.readline().split())\n    print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Divisor Calculation**: The function `get_divisors` computes all divisors of \\( d \\), which helps in iterating through possible values of \\( g \\).\n- **Finding Optimal \\( k \\)**: For each divisor \\( g \\), we calculate the smallest \\( m \\) and \\( n \\) such that their product with \\( g \\) gives the minimal LCM. This involves checking pairs where \\( m \\) and \\( n \\) are coprime and differ by \\( t \\).\n- **Efficiency**: The approach efficiently checks all possible divisors of \\( d \\) and finds the optimal \\( k \\) by leveraging number theory properties, ensuring the solution is both correct and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    min_lcm = float('inf')\n    best_k = 0\n    # Consider all divisors of d\n    for g in get_divisors(d):\n        if g == 0:\n            continue\n        t = d // g\n        # Find m and n such that m = n + t, gcd(m, n) = 1, and m*n is minimized\n        # Since m = n + t, and m > n >= 1\n        n_min = 1\n        m_min = n_min + t\n        # Check if m_min and n_min are coprime\n        if math.gcd(m_min, n_min) != 1:\n            # Find the smallest n where m and n are coprime\n            n = 1\n            while True:\n                m = n + t\n                if math.gcd(m, n) == 1:\n                    break\n                n += 1\n            product = g * m * n\n        else:\n            product = g * m_min * n_min\n        # Now compute the corresponding k\n        x = g * m\n        k = x - a\n        if k < 0:\n            continue\n        current_lcm = product\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    return best_k\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    a, b = map(int, sys.stdin.readline().split())\n    print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 391,
        "completion_token_count": 1082,
        "thoughts_token_count": 1025
    }
}