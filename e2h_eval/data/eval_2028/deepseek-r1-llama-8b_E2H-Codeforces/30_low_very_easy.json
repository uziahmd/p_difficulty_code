{
    "start": 1758279530.6148005,
    "end": 1758279652.1068652,
    "start-formatted": "2025-09-19 19:58 KST",
    "end-formatted": "2025-09-19 20:00 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"TV Game,\" and from the description, I need to find a sequence of moves for Homer and Marge that maximizes their total prize. \n\nHmm, the input is a string A with exactly 2n digits. Both players make exactly n moves each. In each turn, the current player takes the leftmost digit of A and appends it to their number. Then that digit is removed from A. The goal is to choose the order of H and M (Homer and Marge) such that when all moves are done, the sum of S1 and S2 is as large as possible. If there are multiple solutions, any will do.\n\nWait, but how do we determine which sequence of H and M leads to the maximum sum? Because each choice affects the future digits available. So it's a decision-making process where each step depends on the previous choices.\n\nI think the key here is that for each digit in A, we want to assign it to either Homer or Marge in a way that the overall sum is maximized. But since the order in which they take the digits matters, because once a digit is taken, it's no longer available.\n\nWait, but maybe the optimal strategy is to greedily assign the largest possible digit to the current player who can get more benefit from it. Or perhaps it's better to consider the digits in the order they appear and decide who should take them based on some priority.\n\nLet me think about this. Each time a player takes a digit, it's added to their own number. So the earlier digits have more weight because they form higher place values. For example, the first digit taken is the most significant, then the second, etc. So for each position, we want the highest possible digit to be assigned to the player whose turn it is, but also considering that each player must make exactly n moves.\n\nWait, but how does the order of taking affect this? Because the assignment of each digit depends on whether it's taken by H or M in their respective turns.\n\nAlternatively, maybe the problem can be approached by determining for each digit whether it's better to assign it to H or M, regardless of the order. But I'm not sure if that's the case.\n\nWait, another approach: since the two players take turns, each taking n digits, the problem reduces to partitioning the digits into two groups of size n each, such that the sum of the numbers formed by each group is maximized. But wait, no—because the order in which the digits are taken affects the actual value. For example, 91 is 9*10 +1 =91, but 19 is 1*10 +9=19. So the order definitely matters.\n\nSo the problem isn't just about selecting which digits go to H and which to M, but also about the order in which they are taken. Hmm, that complicates things.\n\nBut wait, perhaps the initial arrangement of the digits is fixed. Each player takes the next leftmost digit in the order of A. So the digits are processed in the given order, but the question is, on whose turn is that digit being taken?\n\nAh, right. So the sequence of H and M is determined by the order in which the digits are taken. So the first digit is taken by whoever starts first. The second digit is taken by the other player, unless the first was H, then the second is M, and so on.\n\nWait, but the players can choose who goes first. Wait, no—the problem says \"they manage to know the number A beforehand.\" So they can plan their moves. But the initial decision is who makes the first move. So the sequence of H and M could start with either.\n\nWait, but the output is the sequence of moves, so the first character is whether it's H or M for the first move.\n\nSo the initial step is to decide whether Homer or Marge should make the first move. Then, for each subsequent step, the next player alternates.\n\nThe objective is to maximize the sum of the two numbers S1 and S2 after all 2n digits have been taken.\n\nSo how can we model this? It feels like a dynamic programming problem, where for each position in the string and the current state (who is to take the next digit), we track the maximum possible sum achievable from that point onward.\n\nBut with n up to 18, the string can be up to 36 digits long. So a DP approach might be feasible.\n\nWait, let's think about the DP state. Maybe we can represent it as dp[i][turn], where i is the current position in the string (the first i digits have been processed), and turn indicates whose turn it is to take the next digit. The value of dp[i][turn] would be the maximum possible sum that can be achieved starting from position i with the given turn.\n\nBut wait, the sum is",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for two players, Homer and Marge, to maximize their total prize in a TV game. The game involves taking turns to pick the leftmost digit from a given number A, which consists of exactly 2n digits. Each player makes exactly n moves, and the goal is to maximize the sum of the numbers formed by each player's collected digits.\n\n### Approach\nThe key insight is that each player should take the largest possible digit available on their turn to maximize their score. This can be achieved using a greedy approach combined with dynamic programming (DP) to keep track of the optimal moves at each step.\n\n1. **Greedy Strategy**: At each step, the current player takes the largest remaining digit. If it's Homer's turn, he should take the largest digit; if it's Marge's turn, she should do the same.\n2. **Dynamic Programming**: Use a DP table to track the maximum possible sum starting from each position in the string and whose turn it is. This helps in making optimal decisions at each step without recomputing previous states.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    \n    # Convert A into a list of integers\n    digits = [int(c) for c in A]\n    \n    # Define the DP state: dp[i][turn] = (max_sum, next_turn)\n    # 'H' for Homer's turn, 'M' for Marge's turn\n    dp = [[(0, '') for _ in range(2)] for __ in range(len(digits)+1)]\n    \n    # Fill DP table\n    for i in range(len(digits)-1, -1, -1):\n        for turn in [0, 1]:\n            max_sum = 0\n            if turn == 0:\n                # Current player is H, he will take the largest possible digit\n                max_digit = -1\n                max_pos = -1\n                for j in range(i+1, len(digits)):\n                    if digits[j] > max_digit:\n                        max_digit = digits[j]\n                        max_pos = j\n                if max_pos != -1:\n                    new_sum, new_turn = dp[max_pos + 1][1]\n                    taken = max_digit\n                    new_sum += taken * (10 ** (len(digits) - max_pos - 1))\n                    dp[i][turn] = (new_sum + dp[i+1][0], new_turn)\n            else:\n                # Current player is M, she will take the largest possible digit\n                max_digit = -1\n                max_pos = -1\n                for j in range(i+1, len(digits)):\n                    if digits[j] > max_digit:\n                        max_digit = digits[j]\n                        max_pos = j\n                if max_pos != -1:\n                    new_sum, new_turn = dp[max_pos + 1][0]\n                    taken = max_digit\n                    new_sum += taken * (10 ** (len(digits) - max_pos - 1))\n                    dp[i][turn] = (new_sum + dp[i+1][1], new_turn)\n    \n    # Determine the initial turn (who starts)\n    if dp[0][0][1] != '':\n        initial_turn = 'M'\n    else:\n        initial_turn = 'H'\n    \n    # Generate the move sequence\n    move_sequence = []\n    current_turn = initial_turn\n    for i in range(len(digits)):\n        if current_turn == 'H':\n            move_sequence.append('H')\n            # Update the DP state for next turn\n            if i == len(digits) - 1:\n                break\n            next_turn = dp[i+1][1][1]\n            current_turn = next_turn\n        else:\n            move_sequence.append('M')\n            if i == len(digits) - 1:\n                break\n            next_turn = dp[i+1][0][1]\n            current_turn = next_turn\n    \n    print(''.join(move_sequence))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **DP Initialization**: We initialize a DP table where `dp[i][turn]` keeps track of the maximum sum achievable starting from the `i-th` digit and whose turn it is (`turn` is either 'H' or 'M').\n3. **Filling DP Table**: For each position and turn, we determine the best move by taking the largest remaining digit and updating the DP state accordingly.\n4. **Determining Initial Turn**: Based on the DP table, we decide who starts first.\n5. **Generating Move Sequence**: Using the DP table, we construct the sequence of moves by alternately appending 'H' or 'M' based on whose turn it is.\n\nThis approach ensures that we always make the optimal choice at each step, leading to the maximum possible total prize for both players.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    \n    # Convert A into a list of integers\n    digits = [int(c) for c in A]\n    \n    # Define the DP state: dp[i][turn] = (max_sum, next_turn)\n    # 'H' for Homer's turn, 'M' for Marge's turn\n    dp = [[(0, '') for _ in range(2)] for __ in range(len(digits)+1)]\n    \n    # Fill DP table\n    for i in range(len(digits)-1, -1, -1):\n        for turn in [0, 1]:\n            max_sum = 0\n            if turn == 0:\n                # Current player is H, he will take the largest possible digit\n                max_digit = -1\n                max_pos = -1\n                for j in range(i+1, len(digits)):\n                    if digits[j] > max_digit:\n                        max_digit = digits[j]\n                        max_pos = j\n                if max_pos != -1:\n                    new_sum, new_turn = dp[max_pos + 1][1]\n                    taken = max_digit\n                    new_sum += taken * (10 ** (len(digits) - max_pos - 1))\n                    dp[i][turn] = (new_sum + dp[i+1][0], new_turn)\n            else:\n                # Current player is M, she will take the largest possible digit\n                max_digit = -1\n                max_pos = -1\n                for j in range(i+1, len(digits)):\n                    if digits[j] > max_digit:\n                        max_digit = digits[j]\n                        max_pos = j\n                if max_pos != -1:\n                    new_sum, new_turn = dp[max_pos + 1][0]\n                    taken = max_digit\n                    new_sum += taken * (10 ** (len(digits) - max_pos - 1))\n                    dp[i][turn] = (new_sum + dp[i+1][1], new_turn)\n    \n    # Determine the initial turn (who starts)\n    if dp[0][0][1] != '':\n        initial_turn = 'M'\n    else:\n        initial_turn = 'H'\n    \n    # Generate the move sequence\n    move_sequence = []\n    current_turn = initial_turn\n    for i in range(len(digits)):\n        if current_turn == 'H':\n            move_sequence.append('H')\n            # Update the DP state for next turn\n            if i == len(digits) - 1:\n                break\n            next_turn = dp[i+1][1][1]\n            current_turn = next_turn\n        else:\n            move_sequence.append('M')\n            if i == len(digits) - 1:\n                break\n            next_turn = dp[i+1][0][1]\n            current_turn = next_turn\n    \n    print(''.join(move_sequence))\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 1058,
        "thoughts_token_count": 1025
    }
}