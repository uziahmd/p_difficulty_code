{
    "start": 1758278306.8358226,
    "end": 1758278551.7988007,
    "start-formatted": "2025-09-19 19:38 KST",
    "end-formatted": "2025-09-19 19:42 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called \"Neko does Maths\" and the task involves finding a non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. If there are multiple k's that give the same minimal LCM, we choose the smallest one.\n\nHmm, let me think about how to approach this. \n\nFirst, the problem gives two integers a and b. We need to find k ≥ 0 that minimizes the LCM of (a + k) and (b + k). Also, since LCM is involved, perhaps the difference between a and b plays a role here.\n\nWait, wait. Let's denote x = a + k and y = b + k. Then, x - y = a - b, which is a fixed value because a and b are given. So, for any k, x and y differ by the same amount, say d = |a - b|. Wait, no, because if a > b, then x = a +k, y= b +k, so x - y = a - b, but if a < b, then x - y would be negative. But in any case, the absolute difference is |a - b|.\n\nBut maybe it's better to assume that a >= b without loss of generality, because swapping them doesn't change the problem. So let's suppose a >= b. Then, x - y = a - b = d, where d is a non-negative integer.\n\nSo the problem reduces to: find x and y such that y = x - d, and both x and y are positive, and their LCM is minimized.\n\nBut wait, since x and y must be positive, and since d could be zero (if a == b), but let's consider when a == b first.\n\nIf a == b, then for any k, x = y. So the LCM is just x, which is a +k. To minimize the LCM, we need to minimize x, which is a +k. So the smallest k is 0, because a + 0 is the smallest possible. So in that case, the answer is k=0.\n\nSo the case when a == b is straightforward.\n\nNow, when a != b, let's assume a > b, so d = a - b is positive. Then, x = a +k, y = b +k, and y = x -d.\n\nWe need to find x and y such that y = x -d, and both x and y are positive. Also, x must be >= b +k, which for k >= 0, y is at least b.\n\nWait, but since k can be any non-negative integer, x can be as large as needed, but we want the LCM(x, x -d) to be as small as possible.\n\nSo, the problem now is: find x > d (since y = x -d must be positive) such that LCM(x, x-d) is minimized.\n\nAlternatively, since x and y are consecutive terms with a fixed difference, perhaps the optimal occurs when x and y are such that their GCD is as large as possible. Because LCM(x, y) = x*y / GCD(x,y). So to minimize LCM, we need to maximize GCD(x, y).\n\nWait, yes. Since x and y are fixed apart by d, their GCD is the same as the GCD of x and d. Because GCD(x, x -d) = GCD(x, d). So the GCD is determined by the factors of d.\n\nSo, to maximize the GCD, we should look for x such that x is a multiple of some divisor of d. Because then, the GCD will be at least that divisor.\n\nSo the strategy is: find all divisors of d, then for each divisor g, compute x as a multiple of g, and then find the minimal LCM.\n\nWait, but d can be up to 1e9, so factoring it may take time, but for programming competition purposes, it's manageable.\n\nSo, step by step:\n\n1. Compute d = |a - b|. If d is zero, return k=0.\n\n2. Otherwise, find all the divisors of d.\n\n3. For each divisor g, we can set x to be a multiple of g, i.e., x = m * g. Then y = x -d = m*g -d. But since y must be positive, m*g -d > 0 → m > d/(g). Since m must be an integer, m must be at least floor(d/g) +1.\n\nWait, not necessarily. Let's see:\n\nx must be >= y +d → since y = x -d, and y must be positive. So x must be > d",
    "response": "To solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Difference Calculation**: Compute the absolute difference \\( d \\) between \\( a \\) and \\( b \\). This difference helps us understand the relationship between the two numbers.\n2. **Divisors of Difference**: Find all divisors of \\( d \\). These divisors will help us determine potential values for \\( k \\) that could minimize the LCM.\n3. **Optimal \\( k \\) Calculation**: For each divisor \\( g \\) of \\( d \\), compute the smallest \\( k \\) such that \\( a + k \\) is a multiple of \\( g \\). This ensures that the GCD of \\( a + k \\) and \\( b + k \\) is maximized, thereby minimizing the LCM.\n\n### Solution Code\n```python\nimport math\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    # Find all divisors of d\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    min_lcm = float('inf')\n    best_k = 0\n    for g in divisors:\n        m = (d + g - 1) // g  # ceiling division\n        x = a + k_candidate\n        y = b + k_candidate\n        # Wait, perhaps we need to compute x as a multiple of g, but also ensure y is positive\n        # Let me think again\n        # We have x = a + k_candidate, which should be a multiple of g\n        # So k_candidate must be such that (a + k_candidate) % g == 0\n        # Rearranged: k_candidate ≡ (-a) mod g\n        # The smallest non-negative k_candidate is (g - a % g) % g\n        # But since a + k_candidate must be at least d + 1 (since y = x -d > 0)\n        remainder = a % g\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = g - remainder\n        # Now check if y is positive\n        y = b + k_candidate\n        if y <= 0:\n            continue  # not acceptable\n        # Compute x and y\n        x = a + k_candidate\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n    return best_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))\n```\n\n### Explanation\n1. **Difference Calculation**: Compute \\( d = |a - b| \\). This helps in understanding how \\( a \\) and \\( b \\) relate to each other.\n2. **Divisors of Difference**: Finding all divisors of \\( d \\) allows us to explore potential values of \\( k \\) that can maximize the GCD of \\( a + k \\) and \\( b + k \\), thus minimizing their LCM.\n3. **Optimal \\( k \\) Calculation**: For each divisor \\( g \\) of \\( d \\), compute the smallest \\( k \\) such that \\( a + k \\) is a multiple of \\( g \\). This ensures that the GCD is maximized, leading to a minimized LCM. The smallest \\( k \\) is chosen to ensure the solution is optimal when multiple \\( k \\) values yield the same LCM.\n\nThis approach efficiently narrows down the possible values of \\( k \\) by leveraging the properties of divisors and GCD, ensuring an optimal solution in a reasonable time frame.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    # Find all divisors of d\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    min_lcm = float('inf')\n    best_k = 0\n    for g in divisors:\n        m = (d + g - 1) // g  # ceiling division\n        x = a + k_candidate\n        y = b + k_candidate\n        # Wait, perhaps we need to compute x as a multiple of g, but also ensure y is positive\n        # Let me think again\n        # We have x = a + k_candidate, which should be a multiple of g\n        # So k_candidate must be such that (a + k_candidate) % g == 0\n        # Rearranged: k_candidate ≡ (-a) mod g\n        # The smallest non-negative k_candidate is (g - a % g) % g\n        # But since a + k_candidate must be at least d + 1 (since y = x -d > 0)\n        remainder = a % g\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = g - remainder\n        # Now check if y is positive\n        y = b + k_candidate\n        if y <= 0:\n            continue  # not acceptable\n        # Compute x and y\n        x = a + k_candidate\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n    return best_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))",
    "score": -1,
    "metadata": {
        "prompt_token_count": 383,
        "completion_token_count": 895,
        "thoughts_token_count": 1025
    }
}