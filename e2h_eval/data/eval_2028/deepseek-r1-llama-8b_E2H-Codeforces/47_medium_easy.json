{
    "start": 1758282112.5741398,
    "end": 1758284035.2994244,
    "start-formatted": "2025-09-19 20:41 KST",
    "end-formatted": "2025-09-19 21:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem says that Neko has two integers a and b, and he wants to find a non-negative integer k such that the least common multiple (LCM) of a + k and b + k is as small as possible. If there are multiple k's that give the same minimal LCM, he picks the smallest one.\n\nHmm, right. So the task is to compute the optimal k for given a and b.\n\nFirst, let's think about how the LCM works. The LCM of two numbers x and y is (x*y)/gcd(x,y). So to minimize the LCM, we want to maximize the GCD of x and y. Because if the GCD is large, the product is divided by a larger number, making the LCM smaller.\n\nSo, the key here is to find x and y such that their GCD is as large as possible. Since x = a + k and y = b + k, adding the same k to both. Let's see, the difference between x and y is (a - b), because x - y = (a +k) - (b +k) = a - b. So the difference between x and y remains constant as k changes.\n\nWait, so the difference d between a and b is fixed. Let me denote d as |a - b|. So, without loss of generality, let's assume that a >= b, so d = a - b. Then, x - y is always d for any k.\n\nBut wait, since a and b can be in any order, maybe I should compute d as |a - b| anyway.\n\nSo, the problem becomes: find k such that (a +k) and (b +k) have the maximum possible GCD. Because higher GCD will lead to lower LCM.\n\nSo, the approach is to find the maximum possible g, which divides both (a +k) and (b +k). But since (a +k) - (b +k) = a - b = d, then g must divide d. Because any common divisor of (a +k) and (b +k) must also divide their difference, which is d.\n\nSo, the maximum possible g is the largest divisor of d that is greater than or equal to 1, but wait, since d can be zero. Oh right! Because if a == b, then d is zero. So in that case, x = y for any k, so the LCM is x. So the optimal k is 0, because x is a + 0 = b, which is the same as y, and the LCM is just a.\n\nSo, when a == b, the answer is k=0.\n\nOtherwise, when d != 0, we need to find the largest possible divisor g of d, and then find the minimal k such that (a +k) is divisible by g.\n\nWait, not exactly. Because g is a divisor of d, and we want (a +k) and (b +k) to be both divisible by g. Since (a +k) - (b +k) is d, which is divisible by g, that's why.\n\nSo, the maximum possible g is the maximum divisor of d such that g <= a + k and g <= b +k. Wait, but since k can be chosen, perhaps the condition is that (a +k) mod g == 0 and (b +k) mod g == 0.\n\nBut since (a +k) mod g == (a mod g + k mod g) mod g. For (a +k) to be divisible by g, (a mod g) + (k mod g) must be congruent to 0 mod g. Similarly for (b +k).\n\nAlternatively, since (a +k) and (b +k) are both multiples of g, then (a +k) = m * g and (b +k) = n * g. Then, subtracting gives (a - b) = (m -n)*g. Which is consistent with d being a multiple of g.\n\nSo, our goal is to find the largest possible g that divides d, and then find the minimal k such that (a +k) is a multiple of g. Because that would ensure that both (a +k) and (b +k) are multiples of g, giving us the maximum possible GCD, thus minimizing the LCM.\n\nSo the steps are:\n\n1. Compute d = |a - b|. If d is 0, return k=0.\n2. Otherwise, find all the divisors of d, sorted in decreasing order.\n3. For each divisor g in this list (starting from largest), check if there exists a k such that (a +k) is a multiple of g. Because (b +k) = (a +k) + (b -a) which is also a multiple of g.\n4. For each such g, compute the minimal k required. That k would be (g - (a mod g)) mod g. Wait, because (a +k) mod g should be 0. So k = (g - (a mod g)) % g. Or perhaps k = (g - a % g) if a mod g is not zero, else 0.\n\nWait, no. Let me think. Suppose a mod g is r. Then a +k ≡ 0 mod g implies k ≡ (-r) mod g. So the smallest non-negative k is (g - r) mod g. But since r is less than g, this is (g - r) if r !=0, else 0.\n\nYes.\n\nSo for each divisor g of d (sorted in decreasing order), compute the k needed. Among all possible g's, the first one (largest) where a feasible k exists will give the minimal possible LCM.\n\nWait, but for each g, the required k is (g - (a mod g)) mod g, which could be positive or zero. But since k is non-negative, that's acceptable.\n\nSo the plan is:\n\n- Compute d = |a - b|\n- If d is zero: output k=0\n- Else:\n   - Find all divisors of d, sorted in descending order.\n   - For each divisor g in this list:\n      - Check if a +k and b +k are both divisible by g. Since (a +k) - (b +k) =d, which is divisible by g, then if (a +k) is divisible by g, (b +k) must be as well.\n      - So, compute the required k for this g: k = (g - (a % g)) % g\n      - But wait, if (a % g) is zero, then k is zero. So a +k is already a multiple of g.\n      - So, for each g, compute the k as (g - (a % g)) % g. This ensures that (a +k) is divisible by g.\n      - Now, among all possible g's, the one that gives the smallest LCM is the one with the largest possible g. Because higher g leads to higher GCD, which reduces LCM.\n      - So, the process is to iterate through the divisors of d in descending order. For each g, compute the required k. The first g for which such a k exists (which it always does, since g divides d, and we can set k accordingly) will give the optimal solution.\n\nWait, but wait a minute. Because different g's might result in the same LCM. For example, suppose d is 12, and g is 6 and 4. Let's say for g=6, the required k is some value, leading to (a+k) = 6 * m and (b +k) = 6*(m+1). Their LCM is 6 * m * (m+1). For g=4, the LCM would be 4 * something. Depending on the values, it might be that g=6 gives a smaller LCM than g=4.\n\nBut since we're trying the largest g first, the first one that gives a valid k will give the maximum possible GCD, hence the minimal LCM. So once we find such a g, and the corresponding k, that's our answer.\n\nWait, but is it possible that a larger g doesn't give a better LCM than a smaller one? Hmm, no. Because the GCD is directly proportional to g. So a larger g will lead to a larger GCD, which in turn leads to a smaller LCM.\n\nSo, the algorithm should proceed by checking the divisors of d in decreasing order. The first g for which the required k is non-negative will give the minimal LCM.\n\nWait, but what if g is a divisor of d, but when you add k, a +k is less than g? No, because k is computed as (g - (a % g)) mod g, which is always non-negative. So a +k is a multiple of g, which is at least g if a mod g was zero, or more than zero otherwise.\n\nWait, for example, if a is 6 and g is 5, a mod g is 1. So k is 4, making a +k =10, which is 2*5.\n\nSo, in any case, the a +k will be a multiple of g, which is >=1.\n\nSo, the steps are:\n\nCompute d = |a - b|\n\nIf d ==0: return k=0.\n\nElse:\n\nFind all divisors of d, sorted in descending order.\n\nFor each g in divisors:\n\n   compute rem = a % g\n\n   k = (g - rem) % g\n\n   (if rem ==0, then k=0)\n\n   Now, compute the LCM of (a +k) and (b +k). Since (a +k) and (b +k) are both multiples of g, their GCD is at least g. So the LCM is (x*y)/gcd(x,y) >= (x*y)/(g). But since x and y are both multiples of g, perhaps the actual GCD is larger?\n\nWait, no. Because the maximum possible GCD is g. Because the difference between x and y is d, which is a multiple of g, but x and y could have a GCD larger than g only if they share a common factor.\n\nWait, no. Because x and y are (a +k) and (b +k). Their difference is d, which is a multiple of g. So, the GCD of x and y must divide d, which means that the maximum possible GCD is g, because we're considering all possible divisors of d. So for each g, the GCD of x and y is exactly g (since x and y are multiples of g and their difference is a multiple of g; but could they have a higher GCD?)\n\nWait, for example, let x = 6, y = 12. Then their GCD is 6, which is g=6. But suppose x=8 and y=14. Their GCD is 2, which is a divisor of d=6. So, the maximum GCD is indeed g, because when g is the maximum possible divisor, the GCD is exactly g. So, for each g, the GCD is g.\n\nWait, perhaps not. Let's take another example: a=10, b=4. So d=6. Let's pick g=3. Then, a +k must be a multiple of 3. Let's say a is 10, so 10 mod 3 is 1. So k=2, making a +k=12. b +k is 6. So the numbers are 12 and 6, whose GCD is 6, which is larger than g=3. Hmm, so my previous reasoning was wrong.\n\nWait, that's a problem. So in this case, when g is 3, the actual GCD is 6, which is larger than g.\n\nSo what's going on here? Because d is 6, and g=3 is a divisor of 6. Then, x and y differ by 6, which is a multiple of g=3. But their GCD could be larger than g.\n\nSo, this complicates things. Because for a particular g, the actual GCD could be a multiple of g. So, perhaps the initial approach is incorrect, as choosing a certain g might not lead to the maximum possible GCD.\n\nWait, but in that example, the GCD is 6, which is a divisor of 6. So, perhaps the maximum possible g is 6, not 3. So, perhaps the initial approach is correct because when considering all the divisors of d, including all possible factors, including the maximum, so that for each g, even if the actual GCD is larger, it's because a higher g was considered earlier.\n\nSo, perhaps the way to proceed is to consider all the divisors of d, and for each g (from largest to smallest), compute the required k and the resulting GCD. Then, among all possible (g, k) pairs, choose the one that gives the minimal LCM.\n\nBut that seems computationally expensive because for large d (like up to 1e9), finding all divisors can be time-consuming.\n\nWait, but the constraints are manageable. Because for 1e9, the number of divisors is up to around 1000, which is manageable.\n\nSo, perhaps the steps are:\n\nCompute d = |a - b|\n\nIf d ==0: return 0.\n\nElse:\n\nGenerate all divisors of d, sorted in descending order.\n\nFor each g in these divisors:\n\n   compute k = (g - (a mod g)) % g\n\n   compute x = a +k\n\n   compute y = b +k\n\n   current_gcd = gcd(x, y)\n\n   current_lcm = (x * y) // current_gcd\n\n   Keep track of the minimal lcm and the corresponding k.\n\nOnce all g's are processed, select the k with the smallest current_lcm, and in case of tie, the smallest k.\n\nWait, but that's more accurate. Because for each g, the actual GCD could be larger than g, especially when the higher g's are considered first.\n\nWait, but that's not the case. Because when you process the divisors in descending order, the first g for which a feasible k exists will have the maximum possible GCD. Because higher g's are considered first, and if a k exists for that g, then the GCD will be at least g.\n\nWait, but in the earlier example, when g=6 is a divisor of d=6, then k is computed as (6 - (10 mod6)) mod6 = (6-4)=2. So a +k is 12, b +k is 4 +2=6. GCD is 6, which is larger than g=6? No, it's equal to g.\n\nWait, no, in that example, d=6, g=6 is a divisor. So when processing g=6, the k is 2, and the GCD is 6. So the LCM is 12*6 /6=12.\n\nIf I instead process g=3, then k is (3 - (10%3)) mod3 = (3-1)=2. a +k is 12, b +k is 6. GCD is 6, which is larger than g=3. So the GCD is 6, which is a multiple of g=3.\n\nHmm, but in this case, the LCM is same as when g=6. So, perhaps processing g=6 first is sufficient because the GCD is higher, but the LCM may not change.\n\nBut wait, what if I have a case where for a larger g, the GCD is smaller than expected.\n\nNo, because the GCD must divide d, and for each g, which is a divisor of d, the GCD of x and y must be a multiple of g. Because x and y are multiples of g, and their difference is a multiple of g. So, the GCD of x and y is at least g, but could be a multiple of g.\n\nWait, no. For example, x=6, y=12. Their GCD is 6, which is g=6. But x=12, y=18: GCD is 6, which is a divisor of d=6. So in this case, the GCD is 6, which is equal to g=6.\n\nAnother example: x=8, y=14. d=6. GCD is 2, which is a divisor of 6.\n\nWait, but in this case, when g=2, which is a divisor of 6, the k is (2 - (8 mod2)) mod2 = (2-0) mod2=0. So x=8, y=14. GCD is 2, which is equal to g=2.\n\nWait, but in the earlier example where a=10, b=4, d=6, when g=3, the GCD is 6, which is a multiple of g=3. So for that g, the GCD is higher than g.\n\nSo, perhaps when considering each g, the actual GCD could be a multiple of g. So, the minimal LCM may come from a larger g, which could give a higher GCD, but perhaps not necessarily. It depends on whether the higher g leads to a better (smaller) LCM.\n\nBut regardless, the way to find the optimal k is to find the maximum possible GCD between x and y, which can be achieved by trying all possible divisors of d in descending order, and for each, compute the required k, and the resulting GCD and LCM. The first such g that gives the minimal LCM is our answer.\n\nBut perhaps that's not efficient enough. Because for each g, we have to compute the GCD and LCM, which could be O(√d) time per test. But since d can be up to 1e9, and the number of divisors is up to 1e3, it's manageable.\n\nWait, but how do we get all the divisors of d efficiently?\n\nSo, the plan is:\n\n1. Compute d = abs(a - b). If d is 0, output 0.\n\n2. Generate all divisors of d, sorted in descending order.\n\n3. For each g in this list:\n\n   a. Compute rem = a % g\n\n   b. k = (g - rem) % g\n\n   c. x = a +k, y = b +k\n\n   d. Compute current_gcd = gcd(x, y)\n\n   e. current_lcm = (x * y) // current_gcd\n\n   f. Keep track of the minimal current_lcm and the corresponding k.\n\n4. After processing all g's, select the k with the smallest current_lcm. If multiple k's have the same minimal LCM, choose the smallest k.\n\nWait, but step 3.f is a bit off. Because for each g, the current_gcd could be larger than g, which may not be the maximum possible. So perhaps after computing current_gcd, compare it with the best_gcd found so far. But in any case, the minimal LCM is determined by the current_gcd and the product.\n\nWait, perhaps it's better to compute the LCM for each possible g and track the minimal one.\n\nBut in practice, perhaps the first g (the largest) will give the minimal LCM, because it has the highest possible GCD. But the earlier example shows that sometimes a larger g may not give a better LCM than a smaller one.\n\nWait, let's take the sample input:\n\nSample Input 1: 6 10 → d=4\n\nDivisors of 4 are [4,2,1]\n\nLet's process each g.\n\ng=4:\n\nrem=6%4=2 → k=(4-2)=2.\n\nx=8, y=12 → GCD=4, LCM=24.\n\ng=2:\n\nrem=6%2=0 → k=0.\n\nx=6, y=10 → GCD=2, LCM=30.\n\ng=1:\n\nrem=6%1=0 → k=0.\n\nx=6, y=10 → same as above.\n\nSo the minimal LCM is 24, achieved when k=2.\n\nWhich matches the sample.\n\nSample Input 2: 21 31 → d=10.\n\nDivisors of 10 are [10,5,2,1].\n\ng=10:\n\nrem=21%10=1 → k=9.\n\nx=30, y=40 → GCD=10 → LCM= (30*40)/10=120.\n\ng=5:\n\nrem=21%5=1 → k=4.\n\nx=25, y=35 → GCD=5 → LCM=175.\n\nWhich is bigger than 120.\n\ng=2:\n\nrem=21%2=1 → k=1.\n\nx=22, y=32 → GCD=2 → LCM= 352.\n\ng=1:\n\nk=0 → x=21, y=31 → GCD=1 → LCM= 651.\n\nSo the minimal LCM is 120, achieved when k=9.\n\nSample Input 3: 5 10 → d=5.\n\nDivisors of 5 are [5,1].\n\ng=5:\n\nrem=5%5=0 →k=0.\n\nx=5, y=10 → GCD=5 → LCM=10.\n\ng=1:\n\nrem=5%1=0 →k=0.\n\nx=5, y=10 → same as above.\n\nSo the minimal LCM is 10, achieved when k=0.\n\nWhich matches the sample.\n\nAnother test case: a=10, b=4. d=6.\n\nDivisors of 6 are 6,3,2,1.\n\nProcessing each g:\n\ng=6:\n\nrem=10%6=4 →k=2.\n\nx=12, y=6 → GCD=6 → LCM=12.\n\ng=3:\n\nrem=10%3=1 →k=2.\n\nx=12, y=6 → GCD=6 → LCM=12.\n\nSame as before.\n\ng=2:\n\nrem=10%2=0 →k=0.\n\nx=10, y=4 → GCD=2 → LCM=20.\n\ng=1:\n\nk=0 → same as above.\n\nSo the minimal LCM is 12, achieved when k=2 or k=2 for g=6 and g=3. So in this case, the first g (6) gives k=2, which is the same as for g=3. So the code would pick the first occurrence, which is k=2.\n\nWait, but in this case, the minimal LCM is achieved with k=2 for both g=6 and g=3. So the code would have to try all the divisors, but since the first g=6 gives a k=2, and the other g=3 also gives the same k, but same LCM. So the code would choose k=2, which is correct.\n\nAnother example: a=7, b=15. d=8.\n\nDivisors are 8,4,2,1.\n\ng=8:\n\nrem=7%8=7 →k=1.\n\nx=8, y=16 → GCD=8 → LCM= 16.\n\ng=4:\n\nrem=7%4=3 →k=1.\n\nx=8, y=16 → same as above.\n\ng=2:\n\nrem=7%2=1 →k=1.\n\nx=8, y=16 → same.\n\ng=1:\n\nk=0 → x=7, y=15 → LCM=105.\n\nSo the minimal is 16, achieved when k=1.\n\nThus, the approach seems correct.\n\nSo, the steps to implement are:\n\nImplement a function to generate all divisors of d, sorted in descending order.\n\nThen, for each g in this list:\n\n   compute k = (g - (a % g)) % g.\n\n   compute x = a +k, y = b +k.\n\n   compute current_gcd = gcd(x, y).\n\n   current_lcm = (x * y) // current_gcd.\n\n   keep track of the minimal current_lcm and the corresponding k.\n\nOnce all g's are processed, choose the k with the smallest current_lcm, and if tie, the smallest k.\n\nWait, but in the first sample, the code processes g=4, then 2, then 1. For each, computes k and LCM. It finds that for g=4, the LCM is 24, which is smaller than the others, so it chooses k=2.\n\nIn the second sample, g=10 gives an LCM of 120, which is smaller than others.\n\nIn the third sample, g=5 and g=1 both give the same LCM, but the first one (g=5) is processed first, so k=0 is chosen.\n\nWait, but in the third sample, when g=5 is processed first, k is 0, and the LCM is 10. When g=1 is processed later, k is also 0, same LCM. So the code would choose the first k=0, which is correct.\n\nSo, in the code, the earliest g that gives the minimal LCM is chosen, along with its k. But wait, in the case where multiple g's give the same minimal LCM, but different k's, which one do we choose?\n\nThe problem statement says that if there are multiple k's that yield the same minimal LCM, choose the smallest k.\n\nSo, the code needs to track the minimal LCM, and among all possible k's that achieve this, pick the smallest k.\n\nThus, the approach is:\n\n- Initialize min_lcm as a very large number, and best_k as None.\n\n- For each g in divisors of d:\n\n   compute k.\n\n   compute x and y.\n\n   compute current_lcm.\n\n   if current_lcm < min_lcm:\n\n       update min_lcm and best_k.\n\n   elif current_lcm == min_lcm:\n\n       if k < best_k:\n\n           update best_k.\n\nThus, in the code, during iteration, whenever a new k gives the same min_lcm but a smaller k, it replaces the current best_k.\n\nThis way, after all g's are processed, the best_k is the smallest possible.\n\nNow, the challenge is to implement this correctly.\n\nSo, first, we need to generate all divisors of d.\n\nHow to generate all divisors of d efficiently?\n\nWell, one approach is to factorize d into its prime factors, then generate all possible products of those factors.\n\nBut for d up to 1e9, trial division is manageable.\n\nAlternatively, for each number from 1 to sqrt(d), if i divides d, add i and d/i to the list.\n\nBut we have to be careful to avoid duplicates when d is a perfect square.\n\nSo, the code for generating the divisors:\n\nInitialize a list of divisors.\n\nfor i in 1 to sqrt(d):\n\n   if d % i ==0:\n\n      add i to the list.\n\n      if i != d//i:\n\n          add d//i to the list.\n\nThen, sort the list in descending order.\n\nBut note that 1 and d are included.\n\nWait, but for d=0, which is handled separately.\n\nSo, in code:\n\ndef get_divisors(d):\n\n    divisors = set()\n\n    for i in range(1, int(math.sqrt(d)) +1):\n\n        if d % i ==0:\n\n            divisors.add(i)\n\n            divisors.add(d //i)\n\n    # convert to list and sort in reverse order\n\n    divisors = list(divisors)\n\n    divisors.sort(reverse=True)\n\n    return divisors\n\nWait, but when d is 0, this function would throw an error. But in code, d is 0 only when a == b, which is handled before calling this function.\n\nSo, that's okay.\n\nOnce the divisors are generated, we proceed.\n\nNow, let's think about the code structure.\n\nRead a and b.\n\nif a == b:\n\n   print(0)\n\nelse:\n\n   d = abs(a - b)\n\n   divisors = get_divisors(d)\n\n   min_lcm = infinity\n\n   best_k = None\n\n   for g in divisors:\n\n       rem = a % g\n\n       k = (g - rem) % g\n\n       x = a +k\n\n       y = b +k\n\n       current_gcd = math.gcd(x, y)\n\n       current_lcm = (x * y) // current_gcd\n\n       if current_lcm < min_lcm:\n\n           min_lcm = current_lcm\n\n           best_k = k\n\n       elif current_lcm == min_lcm:\n\n           if k < best_k:\n\n               best_k = k\n\n   print(best_k)\n\nWait, but this may not handle all cases correctly.\n\nWait, what if d is 0? We already handled it.\n\nTesting the code against the sample inputs:\n\nSample 1: a=6, b=10.\n\nd=4.\n\ndivisors: 4,2,1.\n\nProcessing g=4:\n\nrem=6%4=2 → k=2.\n\nx=8, y=12. GCD=4. LCM=24.\n\nSince this is the first, min_lcm=24, best_k=2.\n\ng=2:\n\nrem=6%2=0 →k=0.\n\nx=6, y=10 → GCD=2. LCM=30.\n\n30>24 → no change.\n\ng=1:\n\nrem=6%1=0 →k=0.\n\nx=6, y=10 → same as above.\n\nNo change.\n\nThus, best_k=2.\n\nSample 2: a=21, b=31 →d=10.\n\ndivisors:10,5,2,1.\n\ng=10:\n\nrem=21%10=1 →k=9.\n\nx=30, y=40. GCD=10. LCM= (30*40)/10=120.\n\nmin_lcm=120, best_k=9.\n\ng=5:\n\nrem=21%5=1 →k=4.\n\nx=25, y=35. GCD=5. LCM=175 >120 → no change.\n\ng=2:\n\nrem=21%2=1 →k=1.\n\nx=22, y=32. GCD=2. LCM= 352>120.\n\ng=1:\n\nk=0 →x=21, y=31. LCM=651>120.\n\nThus, best_k=9.\n\nSample 3: a=5, b=10 →d=5.\n\ndivisors:5,1.\n\ng=5:\n\nrem=5%5=0 →k=0.\n\nx=5, y=10 → GCD=5. LCM=10.\n\nmin_lcm=10, best_k=0.\n\ng=1:\n\nrem=5%1=0 →k=0.\n\nx=5, y=10 → same as above.\n\ncurrent_lcm is same, but k is same as best_k.\n\nThus, no change.\n\nSo, code seems to handle samples correctly.\n\nAnother test case: a=10, b=4 →d=6.\n\ndivisors:6,3,2,1.\n\ng=6:\n\nrem=10%6=4 →k=2.\n\nx=12, y=6 → GCD=6. LCM=12.\n\ng=3:\n\nrem=10%3=1 →k=2.\n\nx=12, y=6 → GCD=6 → same as above.\n\ncurrent_lcm is same as min_lcm (12). Now, k is 2, which is same as best_k. So no change.\n\ng=2:\n\nrem=10%2=0 →k=0.\n\nx=10, y=4 → GCD=2 → LCM=20>12.\n\ng=1:\n\nk=0 → same as above.\n\nThus, best_k is 2.\n\nAnother test case: a=7, b=15 →d=8.\n\ndivisors:8,4,2,1.\n\ng=8:\n\nrem=7%8=7 →k=1.\n\nx=8, y=16 → GCD=8 → LCM= 16.\n\ng=4:\n\nrem=7%4=3 →k=1.\n\nx=8, y=16 → same as above.\n\ng=2:\n\nrem=7%2=1 →k=1.\n\nx=8, y=16 → same.\n\ng=1:\n\nk=0 →x=7, y=15 → LCM=105.\n\nThus, min_lcm is 16, best_k=1.\n\nSo code works.\n\nAnother test case: a=8, b=14 →d=6.\n\ndivisors:6,3,2,1.\n\ng=6:\n\nrem=8%6=2 →k=4.\n\nx=12, y=18 → GCD=6 → LCM=36.\n\ng=3:\n\nrem=8%3=2 →k=1.\n\nx=9, y=15 → GCD=3 → LCM=45>36.\n\ng=2:\n\nrem=8%2=0 →k=0.\n\nx=8, y=14 → GCD=2 → LCM=56>36.\n\ng=1:\n\nk=0 → same as above.\n\nThus, best_k is 4.\n\nAnother test case: a=9, b=15 →d=6.\n\ndivisors:6,3,2,1.\n\ng=6:\n\nrem=9%6=3 →k=3.\n\nx=12, y=18 → GCD=6 → LCM=36.\n\ng=3:\n\nrem=9%3=0 →k=0.\n\nx=9, y=15 → GCD=3 → LCM=45>36.\n\ng=2:\n\nrem=9%2=1 →k=1.\n\nx=10, y=16 → GCD=2 → LCM=80>36.\n\ng=1:\n\nk=0 → same as above.\n\nThus, best_k is 3.\n\nSo, the code seems to handle all these cases.\n\nPotential edge cases:\n\nCase where a=1, b=2 →d=1.\n\ndivisors:1.\n\ng=1.\n\nrem=1%1=0 →k=0.\n\nx=1, y=2 → GCD=1 → LCM=2.\n\nThus, output is 0.\n\nAnother case: a=2, b=4 →d=2.\n\ndivisors:2,1.\n\ng=2:\n\nrem=2%2=0 →k=0.\n\nx=2, y=4 → GCD=2 → LCM=4.\n\ng=1:\n\nrem=2%1=0 →k=0.\n\nx=2, y=4 → same as above.\n\nThus, best_k is 0.\n\nAnother case: a=3, b=5 →d=2.\n\ndivisors:2,1.\n\ng=2:\n\nrem=3%2=1 →k=1.\n\nx=4, y=6 → GCD=2 → LCM=12.\n\ng=1:\n\nk=0 →x=3, y=5 → LCM=15>12.\n\nThus, best_k is 1.\n\nAnother case: a=4, b=6 →d=2.\n\ndivisors:2,1.\n\ng=2:\n\nrem=4%2=0 →k=0.\n\nx=4, y=6 → GCD=2 → LCM=12.\n\ng=1:\n\nk=0 →x=4, y=6 → same.\n\nThus, best_k is 0.\n\nAnother edge case: a=0, but according to the problem statement, a and b are ≥1. So no need to handle that.\n\nWhat about when d is a prime number?\n\nLike a=5, b=7 →d=2.\n\ndivisors:2,1.\n\ng=2:\n\nrem=5%2=1 →k=1.\n\nx=6, y=8 → GCD=2 → LCM=24.\n\ng=1:\n\nk=0 →x=5, y=7 → LCM=35>24.\n\nThus, best_k=1.\n\nSo, code works.\n\nNow, the code seems solid.\n\nBut wait, in the code, when we process the divisors, for each g, we compute x and y as a +k and b +k. But since a and b can be up to 1e9, x and y can be up to 2e9, which is manageable.\n\nBut calculating x * y could be up to (2e9)^2 = 4e18, which in Python is fine as it can handle big integers.\n\nBut in the code, the LCM is computed as (x * y) // current_gcd, which can be a huge number. However, in the code, it's compared to min_lcm, which is initially a very large number. But in Python, big integers are handled well.\n\nAnother thing to consider: when a and b are very large, but the code is still efficient. The number of divisors is O(sqrt(d)), which is up to about 3e4 for d=1e9, which is manageable.\n\nThus, the code should be efficient enough.\n\nNow, let's think about the implementation.\n\nWe'll need to import math for the gcd function.\n\nBut wait, in Python 3, math.gcd returns the absolute value, but in our case, x and y are positive, so it's fine.\n\nWait, no. Because x and y are a +k and b +k, which are positive since a and b are ≥1 and k is non-negative.\n\nThus, the gcd function is safe.\n\nSo, putting it all together.\n\nThe code:\n\nRead a and b from input.\n\nHandle the case where a == b.\n\nElse, compute d = abs(a - b).\n\nGenerate all divisors of d, sorted in descending order.\n\nFor each g in divisors:\n\n   compute rem = a % g\n\n   k = (g - rem) % g",
    "response": "To solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**:\n   - The difference between \\( a \\) and \\( b \\) is crucial because it determines the potential divisors that can be used to find the optimal \\( k \\).\n   - The LCM of two numbers is minimized when their greatest common divisor (GCD) is maximized. Thus, we need to find the largest possible GCD of \\( a + k \\) and \\( b + k \\).\n\n2. **Key Insight**:\n   - The difference \\( d = |a - b| \\) must be considered because any common divisor of \\( a + k \\) and \\( b + k \\) must also divide \\( d \\).\n\n3. **Algorithm**:\n   - Compute all divisors of \\( d \\) and sort them in descending order.\n   - For each divisor \\( g \\), compute the smallest \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are multiples of \\( g \\).\n   - Track the minimum LCM and the corresponding \\( k \\). If multiple \\( k \\) values yield the same LCM, choose the smallest \\( k \\).\n\n4. **Complexity**:\n   - Generating all divisors of \\( d \\) involves iterating up to \\( \\sqrt{d} \\), which is efficient even for large values of \\( d \\) (up to \\( 10^9 \\)).\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(d):\n    if d == 0:\n        return []\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    sorted_divisors = sorted(divisors, reverse=True)\n    return sorted_divisors\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = None\n\n    for g in divisors:\n        rem = a % g\n        k = (g - rem) % g\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k\n        elif current_lcm == min_lcm:\n            if k < best_k:\n                best_k = k\n\n    print(best_k)\n```\n\n### Explanation\n1. **Reading Input**: The integers \\( a \\) and \\( b \\) are read from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the answer is \\( k = 0 \\) because the LCM is simply \\( a \\) or \\( b \\).\n3. **Divisor Calculation**: Compute all divisors of \\( d = |a - b| \\) and sort them in descending order.\n4. **Iterate Over Divisors**: For each divisor \\( g \\), calculate the required \\( k \\) to make both \\( a + k \\) and \\( b + k \\) multiples of \\( g \\).\n5. **Track Minimum LCM**: For each \\( k \\), compute the resulting LCM and update the minimum LCM and corresponding \\( k \\) if a smaller LCM is found or if the same LCM is found with a smaller \\( k \\).\n\nThis approach ensures that we efficiently find the optimal \\( k \\) to minimize the LCM of \\( a + k \\) and \\( b + k \\).",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(d):\n    if d == 0:\n        return []\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    sorted_divisors = sorted(divisors, reverse=True)\n    return sorted_divisors\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = None\n\n    for g in divisors:\n        rem = a % g\n        k = (g - rem) % g\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k\n        elif current_lcm == min_lcm:\n            if k < best_k:\n                best_k = k\n\n    print(best_k)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 391,
        "completion_token_count": 858,
        "thoughts_token_count": 8193
    }
}