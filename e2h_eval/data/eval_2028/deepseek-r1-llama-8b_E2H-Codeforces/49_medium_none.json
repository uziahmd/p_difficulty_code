{
    "start": 1758285773.1922884,
    "end": 1758288102.0587022,
    "start-formatted": "2025-09-19 21:42 KST",
    "end-formatted": "2025-09-19 22:21 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I've got this programming problem to solve. Let's see what it's about. The problem is called Mushroom Strife. Hmm. So the setup is that Pasha and Akim made a forest map where lawns are vertices and roads are edges. Each road has two numbers: GCD and LCM of the mushrooms on the connected lawns. But now, some of the map is torn, leaving only m roads. My task is to help restore the number of mushrooms on every lawn based on the given roads. If it's not possible, output NO; else, output any valid arrangement.\n\nThe input gives n and m, followed by m lines each with four numbers: the two lawns connected by the road, the GCD, and the LCM of their mushroom counts.\n\nWait, but in the example input, the first line seems to be '1 0' which might represent n=1 and m=0? Or maybe I'm misinterpreting. Oh, wait no, looking at the sample input:\n\nIn the sample, the input lines are like '1 0', then several others. Wait, perhaps the first line is the number of test cases or something. No, no, the first line is n and m for the problem instance.\n\nWait, the problem statement says the first line contains n and m. Then the next m lines are the roads. So in the sample, let's see:\n\nSample Input:\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\nWait, perhaps I should parse the first line as n=1, m=0. Because the sample output for that case is 'YES' with 1. So yeah, if there are no roads, then each lawn can have any value, but since it's allowed to have any arrangement, we can just assign 1 to all. Or maybe when n=1 and m=0, there's nothing to connect, so it's automatically possible with x=any number.\n\nBut perhaps that's a special case to consider.\n\nSo, the main approach here is to model the problem as a graph with variables (the mushrooms) and constraints based on the edges.\n\nEach edge connects two nodes u and v, with a given GCD and LCM. So for u and v, the values x_u and x_v must satisfy:\n\ngcd(x_u, x_v) = g\nlcm(x_u, x_v) = l\n\nBut wait, isn't lcm(x_u, x_v) equal to (x_u * x_v)/gcd(x_u, x_v)? So from g and l, we can find that:\n\nl = (x_u * x_v) / g\n\nWhich implies that x_u * x_v = l * g.\n\nAlso, since g is the GCD, it must divide both x_u and x_v. So x_u = g * a, x_v = g * b, where a and b are coprime (their GCD is 1).\n\nThen substituting into x_u * x_v = l * g:\n\ng^2 * a * b = l * g → a*b = l / g.\n\nSince a and b are coprimes, this tells us that l must be divisible by g. Otherwise, it's impossible. So if for any edge, l < g, or l mod g != 0, then it's invalid.\n\nSo for each edge, first check if l % g == 0. If not, output NO.\n\nIf that condition holds, then proceed.\n\nSo the steps are:\n\n1. For each edge, compute a and b such that a*b = (l/g), and a and b are coprimes.\n\n2. Then, for each node, assign a variable x_i, which can be represented as g_i multiplied by some product of a's and b's based on the edges.\n\nBut how to model this? It seems like a system of equations or constraints between variables.\n\nThis feels similar to solving a system of constraints where each constraint is x_u = a * g and x_v = b * g, but ensuring that all these assignments are consistent across the graph.\n\nWait, but for each edge, the GCD and LCM define a relation between x_u and x_v. So for each edge, the possible x_u and x_v must satisfy that their GCD is g and LCM is l.\n\nSo the approach is to model each edge as a constraint between two variables, which can be represented using union-find data structures with additional information about the relationships.\n\nThis sounds like a problem that can be modeled using a bipartitioned graph, but more specifically, each connected component will have variables that are related through these constraints.\n\nHmm. So perhaps we can model this using a DSU (Disjoint Set Union) structure, where each set has a representative node and also tracks the necessary multiplicative factors relative to that representative.\n\nWait, yes. So each node can be part of a connected component, and within each component, variables are related through products of certain primes. So for each node, its value is determined relative to the root of its component.\n\nFor example, in a component with variables x1, x2, x3, each connected via edges with known GCD and LCM, we can express x1 as some base value, and x2, x3 as multiples of that base value based on the constraints.\n\nSo, the plan is:\n\n- For each connected component, assign a root node.\n- For each node, maintain a factor that represents the product of certain primes that relate it to the root.\n- When processing an edge between u and v, if they are already in the same component, check if the existing relations are compatible with the new GCD and LCM constraints. If not, output NO.\n- If they are in different components, merge them and update the factors accordingly.\n\nSo, the key steps are:\n\n1. For each edge, process the GCD and LCM to determine if they form a valid pair. That is, l must be a multiple of g.\n\n2. For each edge, compute the product a*b = (l/g), where a and b are coprimes.\n\n3. Then, for each node, the variables are related by these a and b factors.\n\n4. Using DSU with path compression and the ability to track the multiplicative factors from each node to the root, we can manage the constraints.\n\nSo, the DSU structure needs to support two things:\n\n- Find the root of a node and the product from the node to the root.\n- When merging two sets, compute the new factors based on the edge's a and b.\n\nLet me think about how the DSU with factors works. Each node has a parent, and a weight which is the product of the factors from this node to its parent. When finding the root, we can also calculate the cumulative product from the node to the root.\n\nWhen merging two sets, say, u and v, each with their own roots, we need to adjust the weights so that the new edge between u and v satisfies the a and b factors.\n\nWait, perhaps the way to do this is as follows:\n\nSuppose we have an edge u-v with GCD g and LCM l. Then, as before, l must be a multiple of g. Let k = l/g. So, a*b = k, with a and b being coprimes.\n\nWe can represent the relationship between u and v as x_u = a * g and x_v = b * g. Alternatively, x_u = a * g_r, where g_r is the GCD of x_u and x_v. Wait, perhaps I'm getting confused here.\n\nWait, perhaps for each edge, the GCD of x_u and x_v is g, which means that g is the maximum divisor common to both. So x_u = g * a, x_v = g * b, where a and b are coprimes.\n\nThen, the LCM is l = (x_u * x_v) / g = g*a*b.\n\nSo, l must be divisible by g, which is checked first.\n\nSo, for the edge u-v, we have:\n\nx_u = g * a\n\nx_v = g * b\n\nAnd a and b are coprimes.\n\nNow, the problem is to assign a and b such that when merging the sets, the constraints are satisfied.\n\nSo, for each edge, when we process it, we need to find the current factors for u and v relative to their roots, and then set up the new a and b accordingly.\n\nWait, perhaps the factors are tracked as the product of a's and b's along the path from the node to the root. So, for each node, the value x is the product of the factors along the path from the node to the root.\n\nThus, when we have an edge u-v, the factors from u to its root is f_u, and from v to its root is f_v.\n\nBut wait, no—perhaps the factors are stored as the product of a's and b's. Hmm, maybe I'm overcomplicating.\n\nAlternatively, for each node, when we find its root, we can compute the cumulative product of a's and b's along the path, which gives the value of x_node relative to the root.\n\nSo, during the DSU operations, for each node, we keep track of the product from itself to its parent, and when we find the root, we can compute the total product from the node to the root.\n\nWhen merging two nodes u and v, which are in different sets, we need to link them in such a way that the edge u-v's a and b are correctly represented.\n\nSo, suppose u's root is ru with a product p_u, and v's root is rv with a product p_v.\n\nWait, perhaps the product p_u is the product of a's and b's along the path from u to ru. Similarly for p_v.\n\nWait, perhaps the product p_u is the value of x_u divided by x_ru. Because x_u = x_ru * p_u.\n\nSo, when processing the edge u-v with a and b, we have x_u = a * g and x_v = b * g.\n\nBut also, x_u = x_ru * p_u and x_v = x_rv * p_v.\n\nSo, substituting into the edge's equation:\n\na * g = x_ru * p_u → x_ru = (a * g) / p_u\n\nSimilarly, x_v = b * g = x_rv * p_v → x_rv = (b * g) / p_v\n\nBut since x_ru and x_rv are the roots, when we merge the two sets, we can set the new root's product accordingly.\n\nWait, perhaps it's better to express everything in terms of the roots.\n\nAfter merging, the root of one set becomes the root of the other. So, let's say we make rv the root of ru.\n\nThen, x_ru = (a * g) / p_u → but since rv is now the root, x_ru = x_rv * p_ru.\n\nSimilarly, x_rv is known as x_rv = (b * g) / p_v.\n\nWait, I'm getting stuck here. Maybe I should look for some examples.\n\nTake the sample input:\n\nSample Input 1:\n\nn=1, m=0 → Output is YES with 1.\n\nSample Input 2:\n\nn=2, m=1.\n\nThe edge is 1-2, GCD 1, LCM 6.\n\nWait, because 1 and 2 have GCD 1 and LCM 6. So x_1 and x_2 must satisfy x_1 * x_2 = 6 * 1 = 6.\n\nBut since GCD is 1, x_1 and x_2 are coprimes. So possible pairs are (1,6), (2,3), (3,2), (6,1).\n\nBut for the arrangement, any is acceptable. So in the output, it's 1 and 3.\n\nWait, but how does that fit into the DSU approach.\n\nHmm, perhaps another approach is to model the variables in terms of the edges.\n\nEach edge defines a relationship between two variables. We can model this as a graph where each node has a value, and each edge enforces a certain ratio between two variables.\n\nBut ratios can be expressed in terms of primes. Since GCD and LCM are involved, perhaps we can represent each variable as a product of certain primes raised to certain exponents.\n\nBut that might get complicated.\n\nAlternatively, for each variable, we can represent it as a product of primes, each raised to an exponent, and the constraints from the edges would dictate how these exponents are related.\n\nBut that's probably too abstract.\n\nWait, going back to the initial idea: for each edge, x_u and x_v must satisfy x_u * x_v = g * l, and x_u = a * g, x_v = b * g, with a and b coprimes.\n\nSo, the edge can be represented as a constraint that x_u / g and x_v / g are coprimes, and their product is l/g.\n\nSo, for each edge, after checking that l is a multiple of g, we can compute k = l/g. Then, we need to find two integers a and b such that a*b=k and gcd(a,b)=1.\n\nOnce a and b are found, the variables are connected in a way that x_u = a*g, x_v = b*g.\n\nBut how to model this in the DSU structure.\n\nEach node in the DSU can have a value representing x_u, and the DSU's union operation must enforce the constraints imposed by the edges.\n\nWait, perhaps the DSU can be augmented to track the product of a's and b's needed to reach each node from the root.\n\nSo, for each node u, we can store a value called 'weight', which is the product of a's and b's along the path from u to the root. Then, when we have an edge u-v with a and b, we can compute the required relationship between the roots of u and v.\n\nLet me try to formalize this.\n\nEach node u has a parent p[u], and a weight w[u]. The meaning is that x_u = w[u] * x_p.\n\nSo, when we find the root of u, we can compute x_u as w[u] * w[...] * ... until we reach the root.\n\nNow, when processing an edge u-v with g and l, we first check if l is divisible by g. If not, it's invalid.\n\nThen, k = l/g. We need to find a and b such that a*b =k and gcd(a,b)=1.\n\nOnce a and b are found, the relationship is x_u = a * g, x_v = b * g.\n\nBut according to the DSU structure, x_u = w_u * x_root_u, and x_v = w_v * x_root_v.\n\nSo, substituting:\n\na * g = w_u * x_root_u\n\nb * g = w_v * x_root_v\n\nWe can rearrange:\n\nx_root_u = (a * g) / w_u\n\nx_root_v = (b * g) / w_v\n\nBut since x_root_u and x_root_v are the roots of their respective trees, when we merge the two trees, one will become the parent of the other.\n\nAssuming we make one root the parent of the other, say, x_root_v becomes the parent of x_root_u.\n\nThen, x_root_u = x_root_v * w_new.\n\nBut from earlier, x_root_u is (a * g) / w_u.\n\nSo, substituting:\n\nx_root_v * w_new = (a * g) / w_u\n\n→ w_new = (a * g) / (w_u * x_root_v )\n\nSimilarly, we can find x_root_v in terms of b and w_v.\n\nBut this seems a bit tangled.\n\nAlternatively, perhaps when we have u and v in different sets, we can compute the required relationship between their roots.\n\nThe product of the weights along the path from u to its root is w_u, and similarly for v.\n\nSo, the product of x_u and x_v is (a*g) * (b*g) = abg².\n\nBut x_u * x_v = (w_u * x_root_u) * (w_v * x_root_v) = w_u w_v x_root_u x_root_v.\n\nThis must equal abg².\n\nSo,\n\nw_u w_v x_root_u x_root_v = ab g².\n\nBut x_root_u = (a g)/(w_u), from the earlier equation.\n\nSimilarly, x_root_v = (b g)/(w_v).\n\nSubstituting:\n\nw_u w_v * [(a g)/(w_u)] * [(b g)/(w_v)] = ab g².\n\nSimplify left side:\n\nw_u * w_v * (a g)/(w_u) * (b g)/(w_v) = a b g².\n\nWhich equals the right side.\n\nSo, this condition holds.\n\nSo, when merging u and v, we can set the root of one tree as the root of the other, and adjust the weights accordingly.\n\nSo, during the DSU's union operation, for the edge u-v, we compute a and b, then compute the required weight for the root of one set relative to the other.\n\nWait, perhaps it's better to represent the relationship as x_root_u = (a * g) / w_u.\n\nSimilarly, x_root_v = (b * g) / w_v.\n\nWhen merging, we need to set x_root_u = (a * g) / w_u and x_root_v = (b * g) / w_v.\n\nBut since x_root_u and x_root_v are roots, their relationship depends on which tree is attached to which.\n\nSo, perhaps we can choose to attach one root to the other, and compute the necessary weight.\n\nFor example, suppose we make x_root_v the parent of x_root_u. Then:\n\nx_root_u = x_root_v * new_weight.\n\nBut x_root_u is equal to (a * g) / w_u.\n\nSo:\n\nnew_weight = (a * g) / (w_u * x_root_v).\n\nBut x_root_v is equal to (b * g) / w_v.\n\nSubstituting:\n\nnew_weight = (a * g) / (w_u * (b g / w_v)) ) \n\n= (a g w_v) / (w_u b g) )\n\nSimplify: (a w_v) / (w_u b)\n\nSo, new_weight is (a w_v)/(b w_u).\n\nWait, but this is getting complicated.\n\nAn alternative approach is to compute the product of the weights and see if they can be adjusted to satisfy the necessary conditions.\n\nBut perhaps I'm making this more complex than it needs to be.\n\nSo, the plan is:\n\n- For each edge, check if l is a multiple of g. If not, return NO.\n\n- For each edge, compute k = l / g.\n\n- Find a and b such that a * b = k and gcd(a, b) = 1.\n\n- Then, for the two nodes u and v, we need to ensure that x_u / g and x_v / g are a and b respectively.\n\nSo, the variables are x_u = a * g and x_v = b * g.\n\nBut in the DSU structure, x_u is equal to the product of the weights along the path from u to the root.\n\nSo, when merging, the weights must be adjusted accordingly.\n\nSo, during the DSU's find and union operations, the following steps are taken:\n\nFor each edge u-v, g, l:\n\n1. Check if l % g != 0 → invalid, return NO.\n\n2. Compute k = l / g.\n\n3. Find a and b such that a * b = k and gcd(a, b) = 1.\n\n   - How to find a and b? Well, since a and b are coprimes, we can factor k into its prime factors, and split them into a and b such that all primes are in either a or b, but not both.\n\n   For example, factor k into primes, then assign each prime to a or b. The a will be the product of primes assigned to it, and b the product of those assigned to it.\n\n   So, for each prime factor p of k, we can decide whether to put it in a or in b.\n\n   However, since the order doesn't matter (since a*b is the same as b*a), but the choice affects the assignment.\n\n   For the purpose of the problem, any valid a and b will work, as long as a*b =k and gcd(a,b)=1.\n\n4. Once a and b are found, perform the DSU union operation for u and v, with the constraints that x_u = a*g and x_v = b*g.\n\nIn the DSU, each node has a parent and a weight. The weight represents the product of the a's and b's along the path from the node to its parent.\n\nSo, during the union, we need to adjust the weights so that the constraints are satisfied.\n\nSo, for the union(u, v, a, b):\n\n- Find the roots of u and v, say, root_u and root_v.\n\n- If root_u == root_v, check if the existing relationship between u and v is compatible with the new a and b. If not, return NO.\n\n- Else, merge the two trees.\n\n   - Compute the required relationship between root_u and root_v.\n\n   - The x_u = a * g = (w_u) * x_root_u → x_root_u = (a * g) / w_u.\n\n   - Similarly, x_v = b * g = (w_v) * x_root_v → x_root_v = (b * g) / w_v.\n\n   - Now, we need to make one root the parent of the other. Let's say we make root_v the parent of root_u.\n\n   - Then, x_root_u = x_root_v * new_weight.\n\n   - Substituting x_root_u = (a g) / w_u and x_root_v = (b g) / w_v:\n\n      new_weight = ((a g) / w_u) / ( (b g) / w_v ) \n\n      Simplify:\n\n      new_weight = (a g * w_v) / (w_u b g) ) \n\n      The g cancels out:\n\n      new_weight = (a w_v) / (w_u b )\n\n   - So, the new_weight is (a w_v) / (w_u b ).\n\n   - Then, we set the parent of root_u to root_v, and set the weight of root_u to new_weight.\n\nThis way, when we find the root of any node, the product of the weights along the path gives the value relative to the overall root.\n\nWait, but why is this sufficient?\n\nBecause, for any node in the tree, the x value is computed as the product of the weights along the path to the root.\n\nSo, after the union, the new_weight ensures that the x values of root_u and root_v are correctly related.\n\nThis seems manageable.\n\nNow, the challenge is to implement this in code.\n\nSo, steps for the code:\n\nRead n and m.\n\nFor each of the m edges:\n\n   Read u, v, g, l.\n\n   Check if l is divisible by g. If not, output NO.\n\n   Compute k = l / g.\n\n   Factor k into its prime factors.\n\n   Assign a and b such that a*b =k and gcd(a,b)=1.\n\n   Then, for u and v, process the DSU.\n\nSo, the DSU needs to support find and union operations, with the path compression and tracking of the weights.\n\nImplementing this requires a DSU with each node having a parent and a weight.\n\nSo, in code:\n\nImplement the DSU with path compression and maintaining the product of the weights from each node to its root.\n\nWait, but in the DSU's find function, when we find the root, we also need to compute the product of the weights from the node to the root.\n\nWait, perhaps the find function returns both the root and the product from the node to the root.\n\nSo, in Python, each node can have a parent and a weight.\n\nThe find function for a node u:\n\n   if parent[u] != u:\n\n      orig_parent = parent[u]\n\n      root, product = find(parent[u])\n\n      # Update the parent and weight for u\n\n      parent[u] = root\n\n      weight[u] *= product\n\n      # Also, the original product was the product from orig_parent to root.\n\n      # So, the product from u to root is weight[orig_parent] * product.\n\n      # Wait, no: the weight[u] is the product from u to orig_parent. When orig_parent's weight is updated, u's weight is multiplied by the product from orig_parent to root.\n\n      # Hmm, perhaps the find function should return the product from u to the root, and during path compression, the weights are updated.\n\nYes, perhaps during the find, we can compute the product from u to the root, and also update the direct parent pointers to point closer to the root.\n\nSo, the find function could be written recursively or iteratively.\n\nAn iterative version would be better for Python to avoid stack overflows.\n\nSo, for the find function:\n\ndef find(u):\n\n    if parent[u] != u:\n\n        # save the current parent\n\n        p = parent[u]\n\n        # find the root of p\n\n        root = find(p)\n\n        # update u's parent to root\n\n        parent[u] = root\n\n        # the weight from u to root is the product of the weights from u to p, and p to root.\n\n        # So, weight[u] *= weight[p]\n\n        weight[u] *= weight[p]\n\n    return parent[u]\n\nWait, but in the initial setup, weight[u] is the product from u to its parent.\n\nSo, when we find the root, we need to update u's weight to be the product from u to the root.\n\nSo, during find, when we traverse from u to its parent, then from parent to root, etc., we can accumulate the product.\n\nIn the iterative version:\n\ndef find(u):\n\n    path = []\n\n    while parent[u] != u:\n\n        path.append(u)\n\n        u = parent[u]\n\n    # u is now the root.\n\n    for v in path:\n\n        parent[v] = u\n\n        weight[v] *= weight[parent[v]]  # Wait, no. Because parent[v] is u, and weight[v] was the product from v to its old parent, which is now pointing to u.\n\n        # Or perhaps, during the find, we can collect the path and then update the weights.\n\n        # Hmm, perhaps the iterative find is more complex.\n\nAlternatively, perhaps the recursive approach is manageable, but in Python, recursion depth is limited. So for large n, it may not work, but given the problem constraints, perhaps it's manageable.\n\nBut for the purposes of writing code, perhaps it's better to use an iterative approach.\n\nSo, the find function:\n\ndef find(u):\n\n    orig_u = u\n\n    path = []\n\n    # Traverse to root\n\n    while parent[u] != u:\n\n        path.append(u)\n\n        u = parent[u]\n\n    # u is root.\n\n    # Now, update all nodes in the path.\n\n    for v in path:\n\n        parent[v] = u\n\n        weight[v] = weight[v] * weight[orig_parent] ? Not sure.\n\nWait, perhaps for each node in the path, we can compute the product from the node to the root.\n\nWait, perhaps during the traversal, we can compute the product step by step.\n\nAnother approach is to have the find function return the product from u to the root, and also update the parent pointers along the way.\n\nWait, perhaps during the find, for each node along the path, we can directly point to the root and set their weight as the product from themselves to the root.\n\nSo, in code:\n\ndef find(u):\n\n    if parent[u] == u:\n\n        return u, 1  # product is 1, since u is root.\n\n    # else, find the root of parent[u]\n\n    root, product = find(parent[u])\n\n    # Now, update u's parent to root, and compute the product from u to root.\n\n    parent[u] = root\n\n    # The product from u to root is the product from u to parent[u] multiplied by the product from parent[u] to root.\n\n    # So, weight[u] is the product from u to parent[u], and product is the product from parent[u] to root.\n\n    weight[u] = weight[u] * product\n\n    return root, weight[u]\n\nWait, that makes sense.\n\nSo, for each node u, during find, we first find the root of its parent, and then set u's parent to the root, and the weight[u] is the product of u's original weight (from u to parent) multiplied by the product from parent to root.\n\nThis way, when we call find(u), it returns the root and the product from u to the root.\n\nSo, the find function returns (root, product_from_u_to_root).\n\nThis seems manageable.\n\nNow, for the union function:\n\nGiven two nodes u and v, with a and b (from the edge), we need to merge their sets.\n\nSo, first, find the roots of u and v, and the products from u and v to their roots.\n\nru, pu = find(u)\n\nrv, pv = find(v)\n\nIf ru == rv:\n\n   Then, check if the existing relationship between u and v is compatible with a and b.\n\n   Since x_u = a*g and x_v = b*g, and x_u = pu * x_ru, x_v = pv * x_rv.\n\n   But since ru == rv, x_ru = x_rv.\n\n   So, a * g = pu * x_ru → x_ru = (a g) / pu.\n\n   Similarly, b * g = pv * x_ru → substituting x_ru from above, we get:\n\n   b * g = pv * (a g) / pu → (b a g^2) = (p u * p v) → ?\n\n   Wait, perhaps I'm complicating things.\n\n   So, when ru == rv, then the existing relationship between u and v must match the new a and b.\n\n   The current relationship is that x_u / x_v = (pu)/(pv) * (x_ru)^{-1} ?\n\n   Hmm, perhaps it's better to compute whether the existing x_u and x_v are compatible with the new a and b.\n\n   Since x_u = a g and x_v = b g.\n\n   But also, x_u = pu * x_ru, x_v = pv * x_ru.\n\n   So, a g = pu * x_ru → x_ru = (a g)/ pu.\n\n   Similarly, b g = pv * x_ru → substituting x_ru:\n\n   b g = pv * (a g) / pu → (b a g^2) = (p u * p v) → ?\n\n   So, for the condition to hold, (b a) * g^2 must equal (pu * pv) * x_ru^2 ?\n\n   Not sure.\n\n   Alternatively, since x_u = a g and x_v = b g, and x_u = pu * x_ru, x_v = pv * x_ru.\n\n   So, a g = pu * x_ru → x_ru = a g / pu.\n\n   Similarly, b g = pv * x_ru → substituting x_ru:\n\n   b g = pv * (a g / pu) → (b a g^2) = (p v * p u) → ?\n\n   So, the condition is:\n\n   b * a * g^2 = p u * p v.\n\n   If this is not true, then the existing constraints are incompatible with the new edge, so output NO.\n\nElse, proceed.\n\nElse, merge the two sets.\n\nSo, during the union:\n\nCompute the required relationship between ru and rv.\n\nWe have:\n\nx_u = a g = p_u * x_ru.\n\nx_v = b g = p_v * x_rv.\n\nBut we want to link ru and rv such that x_ru and x_rv are related correctly.\n\nAssume we make rv the parent of ru.\n\nThen, x_ru = x_rv * w_new.\n\nSo:\n\nx_ru = x_rv * w_new.\n\nFrom the previous equations:\n\nx_ru = (a g) / p_u.\n\nx_rv = (b g) / p_v.\n\nSubstituting into x_ru = x_rv * w_new:\n\n(a g) / p_u = (b g / p_v) * w_new.\n\nSolve for w_new:\n\nw_new = (a g / p_u) / (b g / p_v) ) \n\n= (a g p_v) / (p_u b g) )\n\n= (a p_v) / (b p_u )\n\nSo, set the parent of ru to rv, and set the weight of ru to (a p_v) / (b p_u).\n\nSo, in code:\n\nparent[ru] = rv\n\nweight[ru] = (a * pv) // (b * pu)\n\nBut wait, since a, b, p_u, p_v are integers, and the division must result in an integer, otherwise, it's impossible.\n\nWait, but the problem statement says that the initial numbers are between 1 and 106, inclusive. So, perhaps it's guaranteed that all divisions will result in integers.\n\nBut perhaps we should verify this.\n\nSo, during the union, we need to compute (a * pv) / (b * pu) and see if it's an integer. If not, output NO.\n\nSo, the steps during the union are:\n\nif ru == rv:\n\n   check if (a * g * b * g) == (p_u * p_v) → because:\n\n   From x_u = a g = p_u * x_ru.\n\n   x_v = b g = p_v * x_ru.\n\n   So, x_u * x_v = a b g².\n\n   On the other hand, x_u * x_v is also (p_u x_ru) * (p_v x_ru) = p_u p_v x_ru².\n\n   So, equate:\n\n   a b g² = p_u p_v x_ru².\n\n   But x_ru is (a g / p_u) from x_u = p_u x_ru → x_ru = a g / p_u.\n\n   Substitute into the equation:\n\n   a b g² = p_u p_v ( (a g / p_u ) )².\n\n   Simplify RHS:\n\n   p_u p_v ( a² g² / p_u² ) → (p_v a² g²) / p_u.\n\n   So:\n\n   a b g² = (p_v a² g²) / p_u.\n\n   Multiply both sides by p_u:\n\n   a b p_u g² = p_v a² g².\n\n   Divide both sides by a g² (assuming a and g are non-zero, which they are):\n\n   b p_u = p_v a.\n\n   So, the condition is whether b p_u == p_v a.\n\n   If not, the existing constraints are incompatible with the new edge, so output NO.\n\nElse, proceed.\n\nElse:\n\n   Check that (a * p_v) is divisible by (b * p_u). Because weight[ru] must be an integer.\n\n   If not, output NO.\n\n   Else, proceed to set the parent and weight.\n\nSo, putting it all together.\n\nSo, in code:\n\nFor each edge u, v, g, l:\n\n   if l % g != 0 → output NO.\n\n   k = l // g.\n\n   factor k into a and b, where a*b =k, and gcd(a,b)=1.\n\n   then, perform DSU find on u and v.\n\n   if u and v are in the same set:\n\n       compute whether b * p_u == a * p_v → if not, output NO.\n\n   else:\n\n       compute whether (a * p_v) is divisible by (b * p_u). If not, output NO.\n\n       then, merge the sets.\n\nOnce all edges are processed without conflict, assign the values to each node.\n\nThe final step is to assign the values.\n\nFor each node, find its root, and compute x = weight[u] * x_root.\n\nBut wait, the x_root can be any value, but we can assign it as 1, since all edges are defined in terms of their GCD and LCM, which may allow scaling.\n\nWait, no. Because all edges are relative, the absolute values are not fixed except for the root.\n\nWait, for example, if we have a chain of edges, the root can be set to any value, and the rest are scaled accordingly.\n\nBut since the problem allows any valid arrangement, we can choose the root's value as 1, and then scale the other nodes accordingly.\n\nSo, for each node, x = (product of a's and b's along the path) * root_value.\n\nSetting root_value to 1 will give a valid solution.\n\nSo, in code:\n\nAfter processing all edges, for each node u:\n\n   root = find(u)\n\n   x_u = weight[u] * 1 → because x_root is 1.\n\nSo, the code can proceed to assign x_u = weight[u].\n\nBut wait, because the find function returns the product from u to the root, which is weight[u] * product from parent to root.\n\nWait, in the find function, when you find u, it returns the root and the product from u to the root. So, x_u = product.\n\nSo, for each node, x_u is the product from u to the root.\n\nSo, in code, for each node, after all unions, we can compute x_u as the product.\n\nThus, the steps are:\n\nAfter processing all edges successfully, for each node u:\n\n   root, product = find(u)\n\n   x_u = product\n\nOutput all x_u's.\n\nSo, now, the code outline is clear.\n\nNow, the challenges are:\n\n1. Implementing the DSU with find and union functions.\n\n2. Factoring k into a and b, which are coprimes.\n\n3. Handling the union step correctly, including the cases where u and v are already connected.\n\nSo, the first thing is to implement the DSU with the find function that returns the root and the product.\n\nNext, for factoring k into a and b, how to generate a and b such that a*b=k and gcd(a,b)=1.\n\nAn approach is to factor k into its prime factors, and assign each prime to either a or b.\n\nFor example:\n\nFor k=12=2^2 *3^1.\n\nWe can assign 2^2 to",
    "response": "To solve this problem, we need to determine the number of laughy mushrooms on each lawn based on the given roads and their GCD and LCM values. The solution involves using a Disjoint Set Union (DSU) structure with path compression and additional tracking of multiplicative factors to manage the constraints imposed by the edges.\n\n### Approach\n1. **Input Reading and Initialization**: Read the number of lawns and roads. Initialize the DSU structure where each node has a parent and a weight representing the product of factors from the node to its root.\n2. **Edge Processing**: For each edge, check if the LCM is a multiple of the GCD. If not, output \"NO\". Compute the product of the GCD and LCM divided by the GCD (k).\n3. **Factorization**: Factorize k into two coprime integers a and b. This ensures that the relationship between the nodes connected by the edge is correctly captured.\n4. **Union Operation**: Use the DSU structure to merge sets while ensuring the constraints are satisfied. If merging fails due to incompatibility, output \"NO\".\n5. **Root Assignment**: After processing all edges, assign values to each node based on the computed factors and their roots.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    parent = [i for i in range(n+1)]\n    weight = [1 for _ in range(n+1)]\n\n    def find(u):\n        if parent[u] != u:\n            orig_parent = parent[u]\n            root, product = find(parent[u])\n            parent[u] = root\n            weight[u] *= product\n        return parent[u], weight[u]\n\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        k = l // g\n        if k == 0:\n            print(\"NO\")\n            return\n\n        a, b = 1, 1\n        temp = k\n        factors = {}\n        for p in range(2, int(math.isqrt(temp)) + 1):\n            if p * p > temp:\n                break\n            if temp % p == 0:\n                cnt = 0\n                while temp % p == 0:\n                    cnt += 1\n                    temp //= p\n                factors[p] = cnt\n\n        if temp > 1:\n            factors[temp] = 1\n\n        primes = list(factors.keys())\n        a = 1\n        b = 1\n        for p in primes:\n            if p % 2 == 0:\n                a *= p\n            else:\n                b *= p\n\n        if a == 0 or b == 0:\n            print(\"NO\")\n            return\n\n        ru, pu = find(u)\n        rv, pv = find(v)\n\n        if ru == rv:\n            if (b * pu) != (a * pv):\n                print(\"NO\")\n                return\n        else:\n            if (a * pv) % (b * pu) != 0:\n                print(\"NO\")\n                return\n            parent[ru] = rv\n            weight[ru] = (a * pv) // (b * pu)\n\n    x = [0] * (n + 1)\n    for i in range(1, n + 1):\n        root, prod = find(i)\n        x[i] = prod\n\n    print(\"YES\")\n    print(' '.join(map(str, x[1:n+1])))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **DSU Structure**: Each node has a parent and a weight. The weight tracks the product of factors from the node to its root.\n- **Find Function**: Recursively finds the root of a node and updates the node's parent and weight to point directly to the root, ensuring efficient lookups.\n- **Union Operation**: Merges two sets while maintaining the constraints imposed by the edges. If merging is not possible, it outputs \"NO\".\n- **Factorization**: Ensures that the product of the GCD and LCM divided by the GCD is split into two coprime integers to maintain the correct relationships between nodes.\n\nThis approach efficiently handles the constraints and ensures that the solution is both correct and optimal.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    parent = [i for i in range(n+1)]\n    weight = [1 for _ in range(n+1)]\n\n    def find(u):\n        if parent[u] != u:\n            orig_parent = parent[u]\n            root, product = find(parent[u])\n            parent[u] = root\n            weight[u] *= product\n        return parent[u], weight[u]\n\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        k = l // g\n        if k == 0:\n            print(\"NO\")\n            return\n\n        a, b = 1, 1\n        temp = k\n        factors = {}\n        for p in range(2, int(math.isqrt(temp)) + 1):\n            if p * p > temp:\n                break\n            if temp % p == 0:\n                cnt = 0\n                while temp % p == 0:\n                    cnt += 1\n                    temp //= p\n                factors[p] = cnt\n\n        if temp > 1:\n            factors[temp] = 1\n\n        primes = list(factors.keys())\n        a = 1\n        b = 1\n        for p in primes:\n            if p % 2 == 0:\n                a *= p\n            else:\n                b *= p\n\n        if a == 0 or b == 0:\n            print(\"NO\")\n            return\n\n        ru, pu = find(u)\n        rv, pv = find(v)\n\n        if ru == rv:\n            if (b * pu) != (a * pv):\n                print(\"NO\")\n                return\n        else:\n            if (a * pv) % (b * pu) != 0:\n                print(\"NO\")\n                return\n            parent[ru] = rv\n            weight[ru] = (a * pv) // (b * pu)\n\n    x = [0] * (n + 1)\n    for i in range(1, n + 1):\n        root, prod = find(i)\n        x[i] = prod\n\n    print(\"YES\")\n    print(' '.join(map(str, x[1:n+1])))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 536,
        "completion_token_count": 987,
        "thoughts_token_count": 8193
    }
}