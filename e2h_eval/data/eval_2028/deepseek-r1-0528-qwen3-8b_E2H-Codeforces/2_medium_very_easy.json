{
    "start": 1758089275.811474,
    "end": 1758091753.5025957,
    "start-formatted": "2025-09-17 15:07 KST",
    "end-formatted": "2025-09-17 15:49 KST",
    "gpu": 2,
    "pid": 2,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Valera and X\n\nValera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter \"X\". Valera's teacher thinks that the letters on the piece of paper form an \"X\", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.\n\n## Input\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\n## Output\nPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\n## Example\n### Input\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n### Output\n['NO', 'YES', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are given an odd integer n, then n lines of n characters.\n Conditions for \"YES\":\n 1. On both diagonals (the main diagonal and the anti-diagonal) all letters are the same.\n 2. All other squares (not on the diagonals) contain the same letter that is different from the diagonal letter.\n\n Steps:\n - Read n.\n - Read the grid.\n\n Let the two diagonals be:\n   Main diagonal: positions (i, i) for i from 0 to n-1.\n   Anti-diagonal: positions (i, n-1-i) for i from 0 to n-1.\n\n Condition 1: Every character on the main diagonal must be the same, and every character on the anti-diagonal must be the same.\n Condition 2: The letter on the diagonals must be the same? Actually, note: the problem says \"on both diagonals\" (so two sets) but they might be two different letters? \n However, the example outputs: \n   Input: 3x3 with 'w','s','w' in first row, 's','w','s' in second, 'w','s','w' in third -> YES.\n But wait, the example input is: \n      3\n      wsw\n      sws\n      wsw\n\n In this example, the main diagonal is ['w', 'w', 'w'] and the anti-diagonal is ['w', 'w', 'w'].\n\n However, consider if the diagonals had two different letters? The problem says: \"on both diagonals of the square paper all letters are the same\", meaning each diagonal has one letter repeated.\n\n But note: the example does not specify that the two diagonals must have the same letter. However, condition 2 says: \"all other squares ... different from the letters on the diagonals\". \n This implies that the diagonals can have two different letters? But then condition 2 says \"different\" from the letters on the diagonals. However, if the two diagonals have two different letters, then the non-diagonal part must be the same and different from both.\n\n But wait: let's read the problem statement again: \n   \"on both diagonals of the square paper all letters are the same\" -> meaning each diagonal has one letter repeated, but the two diagonals can be two different letters?\n   Then condition 2: \"all other squares ... contain the same letter that is different from the letters on the diagonals\".\n\n So if the two diagonals have two different letters, say 'a' and 'b', then the non-diagonal squares must be the same letter, say 'c', and 'c' must be different from both 'a' and 'b'.\n\n However, the example outputs provided: \n   Input: 5x5: \n        xooox\n        oxoxo\n        soxoo\n        oxoxo\n        xooox -> NO\n\n Why NO? Because in the third row (index 2) the center is 's' which is on the diagonal (because it's at (2,2)) and also on the anti-diagonal (2,4-2=2). So the center is part of both diagonals. \n\n But wait, the example input: \n   n=5\n   row0: 'xooox'\n   row1: 'oxoxo'\n   row2: 'soxoo'\n   row3: 'oxoxo'\n   row4: 'xooox'\n\n The center is at (2,2): the third row third character is 's'. However, the main diagonal requires the same letter, so we check:\n   row0[0] = 'x'\n   row1[1] = 'o'\n   row2[2] = 's'\n   row3[3] = 'o'\n   row4[4] = 'x'\n\n So the main diagonal has letters: ['x','o','s','o','x'] -> not all same, so condition fails.\n\n But wait, what about the anti-diagonal?\n   row0[4] = 'x'\n   row1[3] = 'x'\n   row2[2] = 's'\n   row3[1] = 'x'\n   row4[0] = 'x'\n\n So the anti-diagonal has: ['x','x','s','x','x'] -> not all same because of the center.\n\n However, the example input also includes:\n\n   Input: 3\\nwsw\\nsws\\nwsw -> YES\n\n   Input: 3\\nxpx\\npxp\\nxpe -> NO\n\n Let me break down the second example (n=3):\n\n   Grid:\n     row0: 'xpx'\n     row1: 'pxp'\n     row2: 'xpe'\n\n   Main diagonal: [grid[0][0], grid[1][1], grid[2][2]] = ['x','p','e'] -> not the same. So condition 1 fails.\n\n   Therefore, the example input \"3\\nxpx\\npxp\\nxpe\" outputs \"NO\".\n\n Now, what if the diagonals are two different letters? Example: \n   Let n=3, grid:\n        aba\n        bbb\n        cac\n\n   Main diagonal: ['a','b','c'] -> not same -> fails.\n\n   So the problem requires that both diagonals have constant letters (each diagonal has one constant letter, but the two diagonals can be two different letters) and the rest of the letters are a third constant letter that is different from both.\n\n However, note: the center element is on both diagonals. Therefore, the two diagonals must have the same letter at the center. \n\n So actually, the two diagonals must share the center letter. But wait, the center is (n//2) and the two diagonals must be constant. Therefore, the entire main diagonal must be one letter, say 'a', and the entire anti-diagonal must be one letter, say 'b'. However, the center is (n//2, n//2) which is part of both, so we must have 'a' == 'b' at the center. Therefore, the two diagonals must be the same letter.\n\n Conclusion: The two diagonals must have the same letter, say 'a'. Then, the rest of the letters (non-diagonal) must be a single letter 'b' (which is different from 'a').\n\n Steps:\n 1. Extract the main diagonal and anti-diagonal.\n 2. Check if all characters in the main diagonal are the same. If not, output \"NO\".\n 3. Check if all characters in the anti-diagonal are the same. If not, output \"NO\".\n 4. Check that the common letter for the main diagonal is the same as the common letter for the anti-diagonal. If not, output \"NO\".\n\n However, step 3 is actually included in step 2 because the center is common. But note: we can do:\n\n   Let d1 = set(main_diagonal)\n   Let d2 = set(anti_diagonal)\n\n   Then we require len(d1)==1 and len(d2)==1, and also the letter from d1 must equal the letter from d2? Actually, because the center is common, if d1 and d2 are sets of one element, then they must be the same. But wait, what if the two diagonals are not the same? Then d1 would have one letter and d2 would have one letter, but they are different. Then condition 2 would require that the non-diagonal part is a letter different from both, but the diagonals are two different letters. However, the problem says \"the letters on the diagonals\" (plural) meaning two sets, but the non-diagonal part must be different from the diagonals. But if the diagonals have two different letters, then the non-diagonal part must be different from both.\n\n However, the problem does not say that the two diagonals must be the same letter. But note: the center is part of both diagonals, so if the two diagonals are different, then at the center we have two different letters? That is impossible. Therefore, the two diagonals must be the same letter.\n\n So we can combine: the two diagonals must be the same letter.\n\n Alternatively, we can think: the entire cross (both diagonals) must have the same letter, because the center is shared. And then the rest must be a different letter.\n\n Steps:\n\n   Let diag_letter = the letter that is in the main diagonal (must be unique) and also the same for anti-diagonal.\n\n   Then, for every cell (i, j) that is not on the main diagonal and not on the anti-diagonal, the letter must be the same and different from diag_letter.\n\n How to check:\n\n   Step 1: Read grid.\n\n   Step 2: Traverse the main diagonal and anti-diagonal to determine if they are uniform.\n\n   Step 3: Check the center: the two diagonals must have the same letter at the center, so we can use the main diagonal's letter for the entire cross.\n\n   Step 4: Check the entire grid: for every cell (i, j):\n        if (i == j) or (i+j == n-1): then the letter must be the diagonal_letter.\n        else: the letter must be the same as the other_letter and not equal to the diagonal_letter.\n\n   But note: the problem does not require that the two diagonals are the same letter? Actually, the center being common forces the two diagonals to have the same letter at the center. But what if the main diagonal is all 'a' and the anti-diagonal is all 'b' (with a != b)? Then the center must be both 'a' and 'b' -> contradiction. Therefore, the two diagonals must be the same letter.\n\n   So we can do:\n\n        diag_letter = None\n        for i in range(n):\n            if grid[i][i] != grid[0][0]:\n                # But wait, we haven't checked the entire main diagonal yet.\n        Alternatively, we can check the entire main diagonal and anti-diagonal.\n\n   Let's define:\n\n        main_diag = [grid[i][i] for i in range(n)]\n        anti_diag = [grid[i][n-1-i] for i in range(n)]\n\n   Then:\n        if not all(c == main_diag[0] for c in main_diag):\n            print(\"NO\")\n            exit(0)\n\n        if not all(c == anti_diag[0] for c in anti_diag):\n            print(\"NO\")\n            exit(0)\n\n   Then, we must also check that main_diag[0] == anti_diag[0]? Actually, no: the center element must be the same, but the entire main diagonal is main_diag[0] and the entire anti-diagonal is anti_diag[0]. The center is grid[n//2][n//2] which is in both. Therefore, we must have main_diag[0] == anti_diag[0].\n\n   So we can do:\n\n        if main_diag[0] != anti_diag[0]:\n            print(\"NO\")\n            exit(0)\n\n   Then, let diag_char = main_diag[0]\n\n   Then, we traverse the grid and check:\n\n        For each cell (i, j):\n            if (i == j) or (i+j == n-1): \n                if grid[i][j] != diag_char:\n                    print(\"NO\")\n                    exit(0)\n            else:\n                if grid[i][j] != diag_char and grid[i][j] != the_other_char? \n\n   But wait, we don't know the_other_char. We only know that the non-diagonal part must be the same letter and different from diag_char.\n\n   So we can:\n\n        Let other_char = None\n        found = False\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if other_char is None:\n                    other_char = grid[i][j]\n                    found = True\n                else:\n                    if grid[i][j] != other_char:\n                        print(\"NO\")\n                        exit(0)\n\n        But wait, what if there's no non-diagonal cell? Then n=1, but n>=3, so there is at least one non-diagonal.\n\n        However, we must ensure that other_char is not diag_char. \n\n        So after getting other_char, we check that other_char != diag_char.\n\n   Alternatively, we can do:\n\n        Step 1: Check the diagonals are uniform and same letter (diag_char).\n        Step 2: Check that all non-diagonal cells are the same letter, and that letter is not diag_char.\n\n   But note: there might be multiple non-diagonal cells. We can collect the non-diagonal cells and check they are all the same and different from diag_char.\n\n   However, we can do:\n\n        non_diag_letters = set()\n        for i in range(n):\n            for j in range(n):\n                if i != j and i+j != n-1:\n                    non_diag_letters.add(grid[i][j])\n\n        Then, if len(non_diag_letters) == 1 and non_diag_letters.pop() != diag_char:\n            then YES\n        else NO.\n\n   But note: what if the grid is entirely diag_char? Then non_diag_letters would be empty -> then condition fails.\n\n   However, we are guaranteed n>=3 and odd, so there is at least one non-diagonal cell.\n\n   But wait, the problem says: \"all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals\"\n\n   So we must have at least one non-diagonal cell (since n>=3, the grid has n*n cells, and the two diagonals have 2*n-1 cells, so if n>=3, then 2*n-1 < n*n, so there is at least one non-diagonal cell).\n\n   However, we can break down:\n\n        Condition 1: Diagonals are uniform and the same letter (diag_char).\n        Condition 2: All non-diagonal cells are the same letter (say x) and x != diag_char.\n\n   But note: we can also check without building a set for non_diag_letters by:\n\n        other_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if other_char is None:\n                    other_char = grid[i][j]\n                elif grid[i][j] != other_char:\n                    print(\"NO\")\n                    return\n\n        Then, if other_char is None: # which shouldn't happen because n>=3, but still\n            print(\"NO\")\n            return\n\n        Then check other_char != diag_char.\n\n   But wait, what if the non-diagonal cells are not the same? Then we break and output \"NO\".\n\n   However, we must also check that the non-diagonal letter is different from diag_char.\n\n   So code structure:\n\n        n = int(input().strip())\n        grid = []\n        for i in range(n):\n            grid.append(input().strip())\n\n        # Extract main diagonal and anti-diagonal\n        main_diag = [grid[i][i] for i in range(n)]\n        anti_diag = [grid[i][n-1-i] for i in range(n)]\n\n        # Check main diagonal is uniform\n        if len(set(main_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        # Check anti-diagonal is uniform\n        if len(set(anti_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        # Check the two diagonals have the same letter (because the center is common)\n        if main_diag[0] != anti_diag[0]:\n            print(\"NO\")\n            exit(0)\n\n        diag_char = main_diag[0]\n\n        # Now, check that all non-diagonal cells are the same and different from diag_char.\n        other_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if other_char is None:\n                    other_char = grid[i][j]\n                else:\n                    if grid[i][j] != other_char:\n                        print(\"NO\")\n                        exit(0)\n\n        # If we didn't find any non-diagonal cell, then n=1? But n>=3, so we should have found one.\n        if other_char is None:\n            print(\"NO\") # This case should not occur for n>=3, but safe guard.\n            exit(0)\n\n        if other_char == diag_char:\n            print(\"NO\")\n            exit(0)\n\n        print(\"YES\")\n\n   However, wait: what if the grid has more than two distinct letters? But note, the problem requires that the non-diagonal part is the same letter and the diagonals are one letter. So if we find two different non-diagonal letters, we break.\n\n   But note: the above code breaks on the first non-diagonal cell and then checks the rest. Then we set other_char and then check the rest. Then at the end we check that other_char != diag_char.\n\n   But there's an issue: what if the non-diagonal part is empty? Then other_char remains None. But for n>=3, the grid has n*n - (2*n-1) = n*n - 2*n + 1 = (n-1)^2 cells, which is at least (3-1)^2 = 4, so non-empty.\n\n   Let's test with the example that should be \"YES\": \n        n=3, grid:\n          wsw\n          sws\n          wsw\n\n        main_diag: ['w','w','w'] -> uniform, diag_char='w'\n        anti_diag: ['w','w','w'] -> uniform, and same as diag_char.\n\n        Now, non-diagonal cells: \n          (0,1): 's' -> set other_char='s'\n          (1,0): 's'\n          (1,2): 's'\n          (2,1): 's'\n\n        Then check other_char != 'w' -> yes, so output \"YES\".\n\n   Another example: \n        Input: 3\\nxpx\\npxp\\nxpe -> NO\n\n        main_diag: ['x','p','e'] -> not uniform -> we output \"NO\" at the first condition.\n\n   Another example: \n        Input: 5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox -> NO\n\n        main_diag: ['x','o','s','o','x'] -> not uniform -> NO.\n\n   But wait, what if the two diagonals are the same letter, but the non-diagonal part has two different letters? Then we break in the non-diagonal check.\n\n   Example: \n        n=3\n        aba\n        bcb\n        aba\n\n        main_diag: ['a','c','a'] -> not uniform -> NO.\n\n   Another example with uniform diagonals but non-diagonal not uniform:\n\n        n=3\n        aaa\n        aba\n        aaa\n\n        main_diag: ['a','a','a'] -> uniform, diag_char='a'\n        anti_diag: ['a','a','a'] -> uniform, same.\n\n        Now, non-diagonal: \n            (0,1): 'a' -> but wait, this is the same as diag_char. \n            (1,0): 'a'\n            (1,2): 'a'\n            (2,1): 'a'\n\n        Then we set other_char='a' and then check if other_char != diag_char -> 'a' != 'a'? No, so output \"NO\".\n\n   This matches.\n\n   However, note: the example input \"3\\nwsw\\nsws\\nwsw\" works.\n\n   One more edge: n=3, but what if the grid is:\n\n        aaa\n        aab\n        aaa\n\n        Then main_diag: ['a','a','a'] -> uniform.\n        anti_diag: ['a','a','a'] -> uniform.\n\n        Then non-diagonal: \n            (0,1): 'a' -> same as diag_char -> then we set other_char='a' and then at the end check other_char != 'a' -> fails -> NO.\n\n   But wait, the problem says: the non-diagonal part must be the same letter and different from the diagonal. So having an 'a' in a non-diagonal cell is invalid because it's the same as the diagonal.\n\n   Therefore, the code is correct.\n\n   However, note: the two diagonals must be the same letter. But what if the two diagonals are uniform but have two different letters? We already check that they are the same by comparing the first element. But wait, what if the main diagonal is all 'a' and the anti-diagonal is all 'b' (with a != b)? Then we check the center: \n        main_diag[0] = 'a'\n        anti_diag[0] = 'b'\n        Then we compare and see they are different -> output \"NO\".\n\n   But wait, the center is (n//2, n//2) and also (n//2, n-1-n//2) which is the same index. So the center must be 'a' (from main diagonal) and 'b' (from anti-diagonal) -> impossible. So the condition main_diag[0] != anti_diag[0] will catch that.\n\n   However, note: the entire main diagonal is 'a' and the entire anti-diagonal is 'b'. Then the center is part of both: so the center must be 'a' and 'b' at the same time, which is impossible. Therefore, our condition that the two diagonals must be the same letter is necessary.\n\n   So the code:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Get the two diagonals\n        main_diag = [grid[i][i] for i in range(n)]\n        anti_diag = [grid[i][n-1-i] for i in range(n)]\n\n        # Check if main diagonal is uniform\n        if len(set(main_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        # Check if anti-diagonal is uniform\n        if len(set(anti_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        # Check the two diagonals are the same letter (since the center is common)\n        if main_diag[0] != anti_diag[0]:\n            print(\"NO\")\n            exit(0)\n\n        diag_char = main_diag[0]\n\n        # Now, check the non-diagonal part: must be uniform and different from diag_char.\n        # We'll traverse the grid and collect the non-diagonal letters.\n        other_char = None\n        valid_non_diag = True\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if other_char is None:\n                    other_char = grid[i][j]\n                else:\n                    if grid[i][j] != other_char:\n                        valid_non_diag = False\n                        break\n            if not valid_non_diag:\n                break\n\n        if not valid_non_diag:\n            print(\"NO\")\n            exit(0)\n\n        if other_char is None:\n            # This means there are no non-diagonal cells. But n>=3, so this should not happen.\n            print(\"NO\")\n            exit(0)\n\n        if other_char == diag_char:\n            print(\"NO\")\n            exit(0)\n\n        print(\"YES\")\n\n   But wait, we can optimize the non-diagonal part: we can break early and also avoid traversing the whole grid if we break early.\n\n   However, note that the grid is at most 299x299, so it's acceptable.\n\n   But we can also do:\n\n        # Instead of two separate conditions, we can do:\n\n        # Condition 1: diagonals are uniform and same letter.\n        # Condition 2: non-diagonal part is uniform and different.\n\n   Alternatively, we can do one pass for the diagonals and then one pass for the non-diagonals.\n\n   But the above code is clear.\n\n   However, we can also avoid building the set for the entire main and anti-diagonal by checking as we go.\n\n   But the grid size is small, so building a set for two lists of length n (which is up to 299) is acceptable.\n\n   Let me test with the provided examples.\n\n   Example 1: \n        Input: 5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox -> NO (because main_diag is not uniform)\n\n   Example 2:\n        Input: 3\\nwsw\\nsws\\nwsw -> YES\n\n   Example 3:\n        Input: 3\\nxpx\\npxp\\nxpe -> NO (because main_diag is not uniform)\n\n   But wait, example 3: \n        main_diag: [grid[0][0]='x', grid[1][1]='p', grid[2][2]='e'] -> set(['x','p','e']) -> size 3 -> not uniform -> NO.\n\n   Another example: \n        n=3, grid:\n          xxx\n          xyy\n          xxx\n\n        main_diag: ['x','y','x'] -> not uniform -> NO.\n\n   But wait, what if the grid is:\n\n        aaa\n        aba\n        aaa\n\n        We already did: NO because the non-diagonal part has 'b' but wait, no: the non-diagonal part is only the middle of the second row? Actually, the non-diagonal part is:\n\n          (0,1): 'a' -> same as diag_char -> so we set other_char='a' and then check other_char != diag_char -> fails.\n\n        So output \"NO\".\n\n   But what if we want to allow the non-diagonal part to be the same as the diagonal? The problem says: \"different from the letters on the diagonals\". So if the non-diagonal part is the same as the diagonal, it's invalid.\n\n   So the code is correct.\n\n   However, we can also write without breaking the grid into two separate steps for diagonals and non-diagonals.\n\n   But the above code is clear.\n\n   Let's run through the example that should be \"YES\":\n\n        n=3\n        grid = ['wsw','sws','wsw']\n\n        main_diag = [ 'w', 'w', 'w' ] -> set has one element -> okay.\n        anti_diag = [ 'w', 'w', 'w' ] -> set has one element -> okay.\n        Then check main_diag[0] == anti_diag[0]: 'w'=='w' -> okay.\n\n        Then non-diagonal: \n            i=0: j=0 -> skip; j=1 -> not on diagonal? (0!=1 and 0+1=1 != 2) -> so non-diagonal. Set other_char='s'\n            i=0: j=2 -> skip (main diagonal: 0==2? no, but anti-diagonal: 0+2=2 -> n-1=2, so yes, skip.\n\n            i=1: j=0 -> non-diagonal: set other_char (already set) then check: grid[1][0]=='s' -> matches.\n            i=1: j=1 -> skip (diagonal)\n            i=1: j=2 -> non-diagonal: 's'\n\n            i=2: j=0 -> skip (anti-diagonal: 2+0=2 -> n-1=2, so skip)\n            i=2: j=1 -> non-diagonal: 's'\n            i=2: j=2 -> skip.\n\n        Then check other_char != 'w': 's' != 'w' -> yes.\n\n        Output \"YES\".\n\n   One more example: \n        n=3, grid:\n          aba\n          bab\n          aba\n\n        main_diag: ['a','a','a'] -> uniform.\n        anti_diag: ['a','a','a'] -> uniform.\n\n        Then non-diagonal: \n            (0,1): 'b' -> set other_char='b'\n            (1,0): 'b' -> matches.\n            (1,2): 'b' -> matches.\n            (2,1): 'b' -> matches.\n\n        Then check: 'b' != 'a' -> YES.\n\n   So the grid:\n        a b a\n        b a b\n        a b a\n\n   This forms an X.\n\n   But wait, the diagonals are all 'a' and the non-diagonal is 'b'. So it should be YES.\n\n   The example input in the problem was:\n\n        ['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n   Our code returns:\n        For first: NO\n        For second: YES\n        For third: NO\n\n   So we output the expected.\n\n   However, note: the example input format is given as a list of strings, but in the actual input we read from stdin.\n\n   We'll write the code accordingly.\n\n   Final code:\n\n        n = int(input().strip())\n        grid = []\n        for i in range(n):\n            grid.append(input().strip())\n\n        main_diag = [grid[i][i] for i in range(n)]\n        anti_diag = [grid[i][n-1-i] for i in range(n)]\n\n        if len(set(main_diag)) != 1 or len(set(anti_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        if main_diag[0] != anti_diag[0]:\n            print(\"NO\")\n            exit(0)\n\n        diag_char = main_diag[0]\n\n        other_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if other_char is None:\n                    other_char = grid[i][j]\n                else:\n                    if grid[i][j] != other_char:\n                        print(\"NO\")\n                        exit(0)\n\n        if other_char is None:\n            print(\"NO\")\n            exit(0)\n\n        if other_char == diag_char:\n            print(\"NO\")\n            exit(0)\n\n        print(\"YES\")\n\n   However, note: the condition `if len(set(main_diag)) != 1 or len(set(anti_diag)) != 1` can be written as two separate if's for clarity, but the above combined condition is acceptable.\n\n   But wait, the problem says that the two diagonals must be the same letter. We are checking that the two diagonals are uniform and then separately that their first element is the same. But if the two diagonals are uniform but have different letters (which is impossible because the center is common) then we catch it by the next condition. However, the first condition (checking that both are uniform) is necessary.\n\n   But note: if one diagonal is uniform and the other is not, then the first condition (len(set(main_diag))!=1 OR len(set(anti_diag))!=1) will be true and we output \"NO\", which is correct.\n\n   However, the condition `if main_diag[0]!=anti_diag[0]` might not be reached if either diagonal is not uniform. So the code is safe.\n\n   Let me test with a grid where main diagonal is uniform but anti-diagonal is not:\n\n        n=3\n        grid = [\n            'aaa',\n            'aaa',\n            'aaa'\n        ]\n\n        Then main_diag is uniform, anti_diag is uniform (all 'a'), then we check main_diag[0]==anti_diag[0] -> 'a'=='a' -> okay.\n\n        Then non-diagonal: all are 'a', so other_char='a', then check other_char != diag_char -> fails -> NO.\n\n   This is correct.\n\n   But wait, what if the grid is:\n\n        n=3\n        grid = [\n            'aaa',\n            'aaa',\n            'aaa'\n        ]\n\n        Then the diagonals are uniform and same, but the non-diagonal part is also 'a' (same as the diagonal) -> invalid.\n\n   This is according to the problem.\n\n   Another test: grid with two different diagonals but both uniform (but the center is common so they must be same, but what if the grid is:\n\n        n=3\n        grid = [\n            'aaa',\n            'aba',\n            'aaa'\n        ]\n\n        Then main_diag: ['a','a','a'] -> uniform.\n        anti_diag: ['a','a','a'] -> uniform.\n        Then check center: same -> okay.\n\n        Then non-diagonal: the middle of the second row is 'b'. Then we set other_char='b', and then check 'b' != 'a' -> YES.\n\n   So the code is correct.\n\n   However, note: the above example is the classic X pattern.\n\n   I think we are good.\n\n   But wait, let me test with:\n\n        n=3\n        grid = [\n            'abc',\n            'def',\n            'ghi'\n        ]\n\n        main_diag: ['a','e','i'] -> not uniform -> NO.\n\n   Correct.\n\n   One last corner: n=3, grid:\n\n        aaa\n        aab\n        aaa\n\n        main_diag: ['a','a','a'] -> uniform.\n        anti_diag: ['a','a','a'] -> uniform.\n        Then non-diagonal: \n            (0,1): 'a' -> same as diag_char -> then at the end we check other_char != diag_char -> 'a' != 'a' -> NO.\n\n   Correct.\n\n   However, note: the problem says \"all other squares ... contain the same letter that is different\". So if there is a mix of two non-diagonal letters, we break early.\n\n   Example:\n\n        n=3\n        grid = [\n            'aab',\n            'aba',\n            'baa'\n        ]\n\n        main_diag: ['a','a','a'] -> uniform.\n        anti_diag: ['b','a','b'] -> not uniform -> NO.\n\n   So we don't even get to the non-diagonal part.\n\n   Therefore, the code is complete.\n\n   But wait, we can optimize the diagonal check by breaking early?\n\n   However, the grid is small, so it's acceptable.\n\n   We'll submit the code as is.\n\n   However, note: the condition `if len(set(main_diag)) != 1 or len(set(anti_diag)) != 1` can be broken into two conditions to avoid building two sets if one is already not uniform.\n\n   But for clarity and since n is small, we can leave it.\n\n   Alternatively, we can do:\n\n        if len(set(main_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        if len(set(anti_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        if main_diag[0] != anti_diag[0]:\n            print(\"NO\")\n            exit(0)\n\n   This is the same.\n\n   Let me change to that for clarity.\n\n   Final code:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Extract the two diagonals\n        main_diag = [grid[i][i] for i in range(n)]\n        anti_diag = [grid[i][n-1-i] for i in range(n)]\n\n        # Check main diagonal is uniform\n        if len(set(main_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        # Check anti-diagonal is uniform\n        if len(set(anti_diag)) != 1:\n            print(\"NO\")\n            exit(0)\n\n        # Check the two diagonals have the same letter (at the center, they must be the same)\n        if main_diag[0] != anti_diag[0]:\n            print(\"NO\")\n            exit(0)\n\n        diag_char = main_diag[0]\n\n        # Now, check the non-diagonal part: must be uniform and different from diag_char.\n        other_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if other_char is None:\n                    other_char = grid[i][j]\n                else:\n                    if grid[i][j] != other_char:\n                        print(\"NO\")\n                        exit(0)\n\n        # If there are no non-diagonal cells (shouldn't happen for n>=3, but safe)\n        if other_char is None:\n            print(\"NO\")\n            exit(0)\n\n        if other_char == diag_char:\n            print(\"NO\")\n            exit(0)\n\n        print(\"YES\")\n\n   We'll run the sample tests.\n\n   Sample 1: \n        Input: 3\\nwsw\\nsws\\nwsw -> YES.\n\n   Sample 2:\n        Input: 3\\nxpx\\npxp\\nxpe -> NO (because main_diag is not uniform)\n\n   Sample 3:\n        Input: 5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox -> NO (main_diag not uniform)\n\n   But wait, the example input provided in the problem is:\n\n        ['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n   And the expected output is ['NO','YES','NO'].\n\n   Our code produces that.\n\n   However, note: the example input in the problem is given as a list of strings, but we are reading from stdin.\n\n   We assume the input is given as described.\n\n   Submit the code.\n\n   But wait, what if the grid has spaces? The problem says: \"each of the next n lines contains n small English letters\", so no spaces.\n\n   We are using input().strip() for each line, so leading/trailing spaces are removed.\n\n   But the problem says: n lines, each containing n small English letters. So we assume no spaces.\n\n   We are good.\n\n   Let me run the provided examples:\n\n        Example 1: n=5, grid as given -> main_diag: ['x','o','s','o','x'] -> set has {'x','o','s'} -> size 3 -> NO.\n\n       ",
    "response": "\nTo solve this problem, we need to determine if a given square grid forms the letter \"X\" based on specific conditions. The conditions are that all letters on both diagonals must be the same, and all other letters (not on the diagonals) must be the same and different from the diagonal letters.\n\n### Approach\n1. **Problem Analysis**: The problem requires checking two main conditions:\n   - **Diagonals Uniformity**: All characters on both the main diagonal (from top-left to bottom-right) and the anti-diagonal (from top-right to bottom-left) must be identical.\n   - **Non-Diagonal Uniformity**: All characters not on either diagonal must be the same and different from the diagonal characters.\n\n2. **Intuition**: The solution involves:\n   - Extracting the main and anti-diagonals from the grid.\n   - Verifying that all characters in each diagonal are the same.\n   - Ensuring the diagonals share the same character (since the center cell is common to both).\n   - Checking that all non-diagonal cells have the same character, which differs from the diagonal character.\n\n3. **Algorithm Selection**: The approach involves:\n   - Reading the grid dimensions and the grid itself.\n   - Collecting characters from both diagonals.\n   - Using set operations to check uniformity within each diagonal.\n   - Iterating through the grid to verify the non-diagonal cells meet the required conditions.\n\n4. **Complexity Analysis**: The algorithm processes each cell in the grid once for diagonal checks and once for non-diagonal checks, resulting in a time complexity of O(n²), where n is the grid size. This is efficient given the constraint n < 300.\n\n### Solution Code\n```python\nn = int(input().strip())\ngrid = [input().strip() for _ in range(n)]\n\nmain_diag = [grid[i][i] for i in range(n)]\nanti_diag = [grid[i][n-1-i] for i in range(n)]\n\nif len(set(main_diag)) != 1:\n    print(\"NO\")\n    exit(0)\n\nif len(set(anti_diag)) != 1:\n    print(\"NO\")\n    exit(0)\n\nif main_diag[0] != anti_diag[0]:\n    print(\"NO\")\n    exit(0)\n\ndiag_char = main_diag[0]\n\nother_char = None\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n-1:\n            continue\n        if other_char is None:\n            other_char = grid[i][j]\n        else:\n            if grid[i][j] != other_char:\n                print(\"NO\")\n                exit(0)\n\nif other_char is None:\n    print(\"NO\")\n    exit(0)\n\nif other_char == diag_char:\n    print(\"NO\")\n    exit(0)\n\nprint(\"YES\")\n```\n\n### Explanation\n1. **Reading Input**: The code reads the grid size `n` and the grid itself as a list of strings.\n2. **Diagonal Extraction**: The main diagonal consists of characters where row index equals column index (`grid[i][i]`). The anti-diagonal consists of characters where the sum of row and column indices equals `n-1` (`grid[i][n-1-i]`).\n3. **Uniformity Check**: The code checks if all characters in both diagonals are the same by converting each diagonal into a set and verifying its length is 1.\n4. **Common Diagonal Character**: The first character of each diagonal must be the same because they intersect at the center cell.\n5. **Non-Diagonal Check**: The code iterates through all cells not on the diagonals to ensure they are uniform and different from the diagonal character.\n6. **Output Result**: If all conditions are met, it prints \"YES\"; otherwise, it prints \"NO\" at the first failure.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input().strip())\ngrid = [input().strip() for _ in range(n)]\n\nmain_diag = [grid[i][i] for i in range(n)]\nanti_diag = [grid[i][n-1-i] for i in range(n)]\n\nif len(set(main_diag)) != 1:\n    print(\"NO\")\n    exit(0)\n\nif len(set(anti_diag)) != 1:\n    print(\"NO\")\n    exit(0)\n\nif main_diag[0] != anti_diag[0]:\n    print(\"NO\")\n    exit(0)\n\ndiag_char = main_diag[0]\n\nother_char = None\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n-1:\n            continue\n        if other_char is None:\n            other_char = grid[i][j]\n        else:\n            if grid[i][j] != other_char:\n                print(\"NO\")\n                exit(0)\n\nif other_char is None:\n    print(\"NO\")\n    exit(0)\n\nif other_char == diag_char:\n    print(\"NO\")\n    exit(0)\n\nprint(\"YES\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 439,
        "completion_token_count": 805,
        "thoughts_token_count": 8191
    }
}