{
    "start": 1758095905.275709,
    "end": 1758098024.8717532,
    "start-formatted": "2025-09-17 16:58 KST",
    "end-formatted": "2025-09-17 17:33 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ — the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given two strings `l` and `r` of length n (each string can have up to 150000 characters) consisting of lowercase letters and '?'.\n\n We need to form as many pairs as possible. Each pair must be one left boot and one right boot, and the colors must be compatible.\n\n Compatibility:\n   - Two specific colors (non '?') are compatible if they are the same.\n   - An indefinite color ('?') is compatible with any color.\n\n However, note that we cannot use a boot more than once.\n\n Steps:\n\n 1. We want to maximize the number of pairs.\n\n 2. We can break the problem into two parts:\n    a. Matching the '?' in one string with other boots (either fixed or variable). But note: we can also match fixed letters with fixed letters and fixed letters with '?'.\n\n 3. However, note that the problem requires outputting the maximum number of pairs and then the pairs themselves (with indices).\n\n 4. Approach:\n\n    Let's consider:\n\n    - First, we can match fixed letters with fixed letters. But note: sometimes we might save a fixed letter for a '?' in the other string? Actually, we want to maximize the total pairs.\n\n    Alternate idea:\n\n    We can consider:\n\n        We are allowed to use each boot only once.\n\n        We have two types of boots: fixed and wildcards (the '?' in both strings).\n\n        The matching can be:\n\n          Case 1: Left fixed letter 'a' matches Right fixed letter 'a'.\n          Case 2: Left fixed letter 'a' matches Right wildcard '?'.\n          Case 3: Left wildcard '?' matches Right fixed letter 'a'.\n          Case 4: Left wildcard '?' matches Right wildcard '?'.\n\n        However, note: we cannot use the same boot twice.\n\n        We want to maximize the number of pairs.\n\n        Observation:\n\n        Since a wildcard can be used as any color, we can think of:\n\n          Let A = list of fixed left boots (ignoring '?')\n          Let B = list of fixed right boots (ignoring '?')\n\n          Then, we can form some pairs from the fixed ones: by matching the same letters. But note: we might also use wildcards to cover the remaining fixed boots? Actually, we have two kinds of wildcards: the '?' in left and the '?' in right.\n\n        However, the problem is that the wildcards in both sides are interchangeable. We can use a wildcard in left to match a fixed right or a wildcard in right to match a fixed left.\n\n        How to solve?\n\n        We can try:\n\n          Step 1: Count the frequency of fixed colors in left and right.\n\n          But note: we are also allowed to use wildcards to cover any missing color.\n\n        Alternatively, we can use a greedy matching:\n\n          We know that we can form a pair if:\n\n            - The left boot is fixed and the right boot is fixed and they are the same.\n            - The left boot is fixed and the right boot is '?'.\n            - The left boot is '?' and the right boot is fixed.\n            - Both are '?'.\n\n          However, we must assign each boot at most once.\n\n        We can do:\n\n          Let L = list of left boots, R = list of right boots.\n\n          We'll create two arrays (or lists) for the two strings.\n\n          We want to form pairs. We can use a bipartite graph where an edge exists between left i and right j if the colors are compatible.\n\n          Then we need a maximum bipartite matching. But n can be up to 150000, so we cannot run a general bipartite matching (like Hopcroft-Karp or DFS based) because the graph is complete in many cases? Actually, the graph has an edge between left i and right j if:\n            (l[i] == r[j]) or (l[i]=='?' or r[j]=='?')\n\n          But note: the condition is:\n\n            - If l[i] != '?' and r[j] != '?', then they are compatible only if l[i]==r[j].\n            - Otherwise, if either is '?' then they are compatible.\n\n          So the graph is not complete. But note: the condition is symmetric and we can have up to 150000 nodes on each side.\n\n        However, we cannot build a graph with n*n edges (which would be 225e9 edges) and then run matching.\n\n        We need a smarter way.\n\n        Alternative Insight:\n\n        We can break the problem:\n\n        Let X = set of left boots that are fixed (not '?')\n        Let Y = set of right boots that are fixed (not '?')\n\n        Then, the pairs from fixed-to-fixed can be formed by matching same letters. But we can also use wildcards to cover the rest.\n\n        But note: a wildcard in left can match a fixed right, and a wildcard in right can match a fixed left.\n\n        However, the problem is that we have two kinds of wildcards: left and right. And we have to assign the wildcards optimally.\n\n        Steps:\n\n          1. We first match as many fixed boots as possible.\n\n          For matching fixed boots: we can use a frequency map for fixed left and fixed right.\n\n          But note: we cannot match two fixed boots of the same color arbitrarily? Actually, we can. But we must respect the counts.\n\n          However, the catch: we have two independent sets (left and right) and we can only match a left fixed boot with a right fixed boot of the same color.\n\n          So for a fixed letter 'a':\n\n            Let count_left_fixed['a'] = number of left boots with color 'a'\n            Let count_right_fixed['a'] = number of right boots with color 'a'\n\n          Then the maximum pairs we can form for color 'a' is min(count_left_fixed['a'], count_right_fixed['a'])\n\n          But wait: what if we have multiple colors? We have to assign each boot at most once.\n\n          However, note: the fixed boots are independent per color.\n\n          So the total fixed pairs we can form is the sum over all letters of min(count_left_fixed[letter], count_right_fixed[letter])\n\n          Now, what about the wildcards?\n\n          After removing the fixed boots that we matched, we have:\n\n            Remaining fixed left boots: for a letter 'a', we have (count_left_fixed['a'] - min(count_left_fixed['a'], count_right_fixed['a']))\n            Similarly for right.\n\n          But also, we have the wildcards in left and right.\n\n          Now, we can use the wildcards to cover the remaining fixed boots and also the wildcards can be paired together.\n\n          However, note: the remaining fixed boots must be matched by the opposite side's wildcards or by the same side's wildcards? Actually, the matching is bipartite: left boots must be matched to right boots.\n\n          So:\n\n            We can use a left wildcard to match a right fixed boot (if that fixed boot is still unmatched) or a right wildcard to match a left fixed boot.\n\n          But also, we can use a left wildcard to match a right wildcard.\n\n          We want to maximize the total pairs.\n\n          Let:\n\n            F = total fixed pairs we already formed.\n\n            Then, let:\n\n              L_fixed_remaining = { letter: count_left_fixed[letter] - min(count_left_fixed[letter], count_right_fixed[letter]) for letter in ... }\n              R_fixed_remaining = { letter: count_right_fixed[letter] - min(count_left_fixed[letter], count_right_fixed[letter]) for letter in ... }\n\n          But note: actually, we have to consider that we are going to remove the fixed boots that we matched.\n\n          However, we haven't assigned which fixed boots to match. We can choose arbitrarily. So the remaining fixed boots in left and right are:\n\n            For left: for each letter, the leftover is the original count minus the matched part. But we don't care about the letter because we can use wildcards for any.\n\n          Actually, we can use the wildcards to cover the remaining fixed boots. But note: the remaining fixed boots are only of certain letters.\n\n          But here's the catch: a wildcard can cover any fixed boot. However, we cannot exceed the total available wildcards.\n\n          Let:\n\n            total_left_wildcard = count of '?' in l\n            total_right_wildcard = count of '?' in r\n\n          Now, the remaining fixed boots (that we didn't match) must be covered by the opposite side's wildcards. However, note:\n\n            In left, after matching the fixed boots, we have some fixed boots left (say, we have a multiset of letters). Similarly for right.\n\n          But we don't need to know the exact letters because:\n\n            We can use a left wildcard to cover a fixed right boot (if the right boot is fixed and unmatched) and vice versa.\n\n          However, we can also use two wildcards to form a pair. So the total pairs from wildcards and leftovers is:\n\n            Let A = total_left_wildcard + total_right_wildcard   [all wildcards]\n            Let B = (total_left_fixed - F) + (total_right_fixed - F)   [but wait, total_left_fixed is the total fixed in left, and we formed F pairs, so the unmatched fixed in left is (total_left_fixed - F) but note: F is the sum over colors, and the fixed boots in left are the ones that are not '?'. Similarly for right.\n\n          Actually, the unmatched fixed boots (from left) are the ones that were fixed and not matched (so they require a right-side match, either fixed or wildcard). Similarly for right.\n\n          But note: the fixed pairs we formed (F) is exactly the number of fixed boots we matched. Then, the total fixed boots in left is (n - total_left_wildcard) and similarly for right (n - total_right_wildcard). So:\n\n            Unmatched fixed in left: (n - total_left_wildcard) - F\n            Unmatched fixed in right: (n - total_right_wildcard) - F\n\n          Then, the remaining pairs can be formed by:\n\n            - Using wildcards to match the unmatched fixed boots.\n\n          But note: we can also use two wildcards to form a pair. However, if we use a wildcard to match a fixed boot, then that fixed boot is covered and we use one wildcard. Alternatively, we can use two wildcards to form a pair.\n\n          However, we want the maximum number of pairs. The total pairs we can form is F plus the pairs we form from the remaining.\n\n          The remaining part: we have:\n\n            Total unmatched fixed boots (from left) = L_unmatched = (n - total_left_wildcard) - F\n            Total unmatched fixed boots (from right) = R_unmatched = (n - total_right_wildcard) - F\n\n          But note: these unmatched fixed boots must be matched by the opposite side's wildcards. Also, we have:\n\n            Wildcards available: W = total_left_wildcard + total_right_wildcard\n\n          Now, we can use the wildcards to cover:\n\n            - Some of the unmatched fixed boots: each unmatched fixed boot (on one side) can be matched by a wildcard from the opposite side.\n\n            - Additionally, we can form pairs between wildcards.\n\n          However, note: the matching is bipartite. Each left wildcard can be matched to any right boot (including fixed or wildcard). Similarly for right.\n\n          But we have two kinds of requirements:\n\n            Requirement 1: Cover the unmatched fixed boots. There are L_unmatched unmatched fixed boots in left, and R_unmatched unmatched fixed boots in right.\n\n            However, we cannot cover an unmatched fixed boot in left by a left wildcard (because the left wildcard must be matched to a right boot). Similarly, an unmatched fixed boot in right must be matched by a left boot (which can be a left wildcard).\n\n          Therefore, we need:\n\n            To cover the unmatched fixed boots in left, we need at least L_unmatched wildcards in the right (either fixed or wildcard? no, because the right side's fixed boots have already been accounted for in F and the unmatched fixed boots in the right are the ones that are fixed and not matched, so they are present and we cannot use them again. Actually, the unmatched fixed boots in the right are fixed and we can use a left wildcard to match them.\n\n          Similarly, we need R_unmatched wildcards in the left to cover the unmatched fixed boots in the right.\n\n          But note: we have a total of W = total_left_wildcard + total_right_wildcard wildcards.\n\n          However, the unmatched fixed boots in left must be matched by right boots (which can be either fixed or wildcard). But wait: we have already matched all fixed boots on the right that are the same as the left fixed ones. The unmatched fixed boots in the right are those that are fixed and not matched because there wasn't a matching fixed boot on the left. Therefore, they are still available to be matched by a wildcard from the left.\n\n          Similarly, the unmatched fixed boots in left must be matched by a right boot (which can be either a fixed boot of the same color or a wildcard). But wait, the fixed boots on the right that are the same color have already been used to match the left fixed boots of that color. So the unmatched fixed boots in left are of colors that are either:\n\n            - Not present in the right fixed (so they cannot be matched by a fixed right boot) OR\n            - The right fixed boots of that color were already matched with other left fixed boots (so we cannot use them again).\n\n          Therefore, the unmatched fixed boots in left must be matched by wildcards in the right.\n\n          Similarly, the unmatched fixed boots in right must be matched by wildcards in the left.\n\n          So, we need:\n\n            - At least L_unmatched wildcards in the right (to match the unmatched fixed boots in left).\n            - At least R_unmatched wildcards in the left (to match the unmatched fixed boots in right).\n\n          But note: the right side's wildcards are part of the total wildcards. Similarly for left.\n\n          Let:\n\n            Let W_left = total_left_wildcard\n            Let W_right = total_right_wildcard\n\n          Then, the remaining pairs we can form is:\n\n            Step 1: Use wildcards to cover the unmatched fixed boots:\n\n              We can use up to min(W_right, L_unmatched) wildcards from the right to match the unmatched fixed boots in left.\n\n              Similarly, we can use up to min(W_left, R_unmatched) wildcards from the left to match the unmatched fixed boots in right.\n\n            However, note: these two sets of matches are independent? Actually, no, because the same wildcard cannot be used twice.\n\n          But observe:\n\n            The unmatched fixed boots in left require a right boot (which can be a right wildcard or even a right fixed boot? Wait, no: we've already matched all the fixed boots on the right that are the same as the left fixed boots. The unmatched fixed boots in left are the ones that are fixed and not matched because the opposite fixed boot was not available. Therefore, they cannot be matched by a fixed boot on the right (since the fixed boot on the right of the same color would have been already matched if it existed). So they must be matched by a wildcard on the right.\n\n          Similarly, the unmatched fixed boots in right must be matched by a wildcard on the left.\n\n          Now, after covering the unmatched fixed boots, we are left with:\n\n            Remaining wildcards: \n                W_left_remaining = W_left - (number of left wildcards used to match unmatched fixed right boots) \n                W_right_remaining = W_right - (number of right wildcards used to match unmatched fixed left boots)\n\n          But note: we used:\n\n            Let x = min(W_right, L_unmatched)   [right wildcards used to match unmatched fixed left]\n            Let y = min(W_left, R_unmatched)     [left wildcards used to match unmatched fixed right]\n\n          However, wait: we cannot use the same wildcard twice. The wildcards are separate.\n\n          Actually, we have two independent uses:\n\n            The unmatched fixed left boots (L_unmatched) must be matched by right boots that are either wildcard or fixed. But wait, we said above that the unmatched fixed left boots must be matched by wildcards in the right. Why? Because the fixed boots in the right that are the same color were already matched (so they are gone). Similarly, the unmatched fixed right boots must be matched by left wildcards.\n\n          However, note: the fixed boots in the right that are not the same color as the unmatched fixed left boots: we don't care because the condition for matching is the same color. But wait, the condition is: fixed left boot must match with fixed right boot of the same color. So if a fixed left boot has color 'a', then it can only be matched by a fixed right boot of color 'a'. And we already used all the fixed right boots of color 'a' (if any) to match the left fixed boots of color 'a'. Therefore, if there is an unmatched fixed left boot of color 'a', it means there were fewer fixed right boots of color 'a' than fixed left boots of color 'a'. Then, the remaining fixed left boots of color 'a' must be matched by a right boot that is either a wildcard or a fixed boot of color 'a'. But wait: the fixed boot of color 'a' on the right have been exhausted (because we matched min(count_left_fixed['a'], count_right_fixed['a']) and now we have leftover left boots of color 'a'). So we cannot use the fixed right boots of color 'a' again. Therefore, the only option for the unmatched fixed left boot of color 'a' is a wildcard on the right.\n\n          Similarly, for unmatched fixed right boots.\n\n          Therefore, we require:\n\n            - The unmatched fixed left boots (of any color) must be matched by wildcards on the right.\n            - The unmatched fixed right boots (of any color) must be matched by wildcards on the left.\n\n          Then, the number of wildcards we need from the right to cover the unmatched fixed left boots is exactly L_unmatched, but we cannot exceed the available right wildcards (W_right). Similarly, we need R_unmatched left wildcards, but we cannot exceed W_left.\n\n          Then, the actual number we can cover is:\n\n            x = min(L_unmatched, W_right)\n            y = min(R_unmatched, W_left)\n\n          But note: the same wildcard cannot be used twice. However, these two sets (matching unmatched fixed left with right wildcards and matching unmatched fixed right with left wildcards) are using different wildcards. The left wildcards and right wildcards are distinct.\n\n          Then, after covering these, we have:\n\n            Total pairs = F + x + y + (remaining wildcards that can be paired together)\n\n          The remaining wildcards:\n\n            After using x from the right and y from the left, we have:\n\n            W_left_remaining = W_left - y\n            W_right_remaining = W_right - x\n\n          Then, we can form additional pairs by matching the remaining wildcards. Each such pair uses one left wildcard and one right wildcard.\n\n          The maximum number of such pairs is min(W_left_remaining, W_right_remaining)\n\n          Therefore, the total pairs is:\n\n            F + x + y + min(W_left_remaining, W_right_remaining)\n\n          But wait, is that correct?\n\n          Let me check:\n\n            Initially, we have F pairs from fixed-fixed.\n\n            Then, we use x = min(L_unmatched, W_right) to cover unmatched fixed left boots (using right wildcards). This uses x right wildcards.\n\n            Then, we use y = min(R_unmatched, W_left) to cover unmatched fixed right boots (using left wildcards). This uses y left wildcards.\n\n            Then, the remaining wildcards (after covering the unmatched fixed) are:\n\n                Left: W_left - y\n                Right: W_right - x\n\n            Then, we can form min(W_left-y, W_right-x) pairs from the remaining wildcards.\n\n          However, note: the unmatched fixed left boots and unmatched fixed right boots are independent. But wait, is there an overlap? Actually, the total fixed boots we started with are:\n\n            Total fixed left = n - W_left\n            Total fixed right = n - W_right\n\n          And we formed F pairs from fixed-fixed. Then, the unmatched fixed left is (n - W_left) - F, and unmatched fixed right is (n - W_right) - F.\n\n          Then, we must have:\n\n            x <= W_right   and   y <= W_left\n\n          But note: the entire set of right boots is of size n, and we have already used F (from fixed-fixed) and x (from covering unmatched fixed left) so the total pairs from the right side is F + x. Similarly, the left side is F + y. And then the remaining wildcards form min(W_left-y, W_right-x) pairs.\n\n          However, we must also ensure that the total pairs we form does not exceed n (since we have n left and n right). But note: we are forming at most n pairs.\n\n        But wait, is this formula correct? Let's test with a small example.\n\n        Example 1: \n          Input: \n            n=1\n            l = \"a\"\n            r = \"?\"\n\n          Then:\n            F = 0 (because fixed 'a' on left and fixed nothing on right? Actually, no: we have one fixed left and one wildcard right -> they are compatible. But according to our breakdown:\n\n            Fixed left: 1, fixed right: 0 -> F = min(1,0)=0.\n\n            Then, unmatched fixed left = 1 - 0 = 1.\n            unmatched fixed right = 0 - 0 = 0.\n\n            W_left = 0, W_right = 1.\n\n            Then, x = min(1, 1) = 1.\n            y = min(0, 0) = 0.\n\n            Then, remaining wildcards: W_left_remaining = 0, W_right_remaining = 1-1=0.\n\n            Total pairs = 0 + 1 + 0 + 0 = 1. Correct.\n\n        Example 2:\n          Input:\n            n=1\n            l = \"a\"\n            r = \"b\"\n\n          Then: F = min(1,1)=1 (if the fixed right is 'b', then wait: the fixed right is 'b', and left is 'a', so they are not the same. So F=0.\n\n          Then, unmatched fixed left = 1, unmatched fixed right = 1.\n          W_left=0, W_right=0.\n\n          Then, x = min(1,0)=0, y=min(1,0)=0, and then min(0,0)=0. Total pairs=0. Correct.\n\n        Example 3:\n          Input:\n            n=1\n            l = \"a\"\n            r = \"a\"\n\n          Then: F=1, unmatched fixed left=0, unmatched fixed right=0, then x=0, y=0, and then 0. Total pairs=1.\n\n        Example 4:\n          Input:\n            n=2\n            l = \"a?\"\n            r = \"?a\"\n\n          Then, fixed left: ['a'] -> count=1, fixed right: ['a'] -> count=1 -> F=1.\n\n          unmatched fixed left: 1 (since total fixed left=1, and we matched 1) -> wait, no: total fixed left=1, and we matched 1? Actually, we matched the fixed left 'a' with the fixed right 'a'? But the fixed right is the second character? Actually, we have:\n\n            l = \"a?\" -> left boots: index0='a', index1='?'\n            r = \"?a\" -> right boots: index0='?', index1='a'\n\n          Now, we can form a pair between left0 and right1: (a,a) -> fixed-fixed -> F=1.\n\n          Then, unmatched fixed left: 0 (because the fixed left was used), unmatched fixed right: 0.\n\n          W_left=1, W_right=1.\n\n          Then, x = min(0,1)=0, y=min(0,1)=0, and then remaining wildcards: 1 and 1 -> min(1,1)=1.\n\n          Total pairs=1+0+0+1=2.\n\n          But wait, we have two boots: we can form two pairs? Actually, we have:\n\n            We already used left0 and right1. Then we have left1 (which is '?') and right0 (which is '?') -> they are compatible. So indeed we can form two pairs.\n\n          However, the above method gives 2. But note: the problem says: a boot can be part of at most one pair. So we cannot use the same boot twice.\n\n          But wait, in the above calculation, we are counting:\n\n            F=1 (from the fixed-fixed)\n            Then, we use the wildcards to form one more pair (from the two wildcards). So total 2.\n\n          How do we assign the pairs?\n\n          We need to output:\n\n            2\n            1 1   [meaning left boot index1 and right boot index1?] -> wait, the indices: the problem indexes from 1 to n.\n\n          Our input:\n\n            n=2\n            l=\"a?\" -> so left boots: index0 (first) and index1 (second)\n            r=\"?a\" -> right boots: index0 (first) and index1 (second)\n\n          We have two pairs:\n\n            (left0, right1) -> (1,2)  [if we index from 1: left0 is the first left boot, right1 is the second right boot -> but wait, the problem says: the j-th line should contain the index of the left boot and the index of the right boot.\n\n          However, note: the example output format: \n\n            \"Print k — the maximum number of compatible left-right pairs of boots\"\n\n            Then k lines, each: \"a_j b_j\", meaning the left boot index a_j and the right boot index b_j.\n\n          So in our example, we have:\n\n            Pair1: (1,2) [left boot 1 and right boot 2]\n            Pair2: (2,1) [left boot 2 and right boot 1]? But wait: our left boots are:\n\n                left0: color 'a' -> index1 (if we count from 1)\n                left1: color '?' -> index2\n\n            right0: color '?' -> index1\n            right1: color 'a' -> index2\n\n          Then the two pairs are:\n\n            (left0, right1): (1,2) -> (a and a) -> fixed\n            (left1, right0): (2,1) -> (?, ?) -> wildcard\n\n          But wait, the problem: the second line of output for the example above is:\n\n            2\n            1 2\n            2 1\n\n          However, the problem says: the j-th line should contain the index of the left boot and the index of the right boot.\n\n          But note: the input order: the first left boot is at index0, so when outputting we use index+1.\n\n          However, we must be cautious: the problem does not specify the order of the pairs. We just need to output k pairs, and the indices must be distinct.\n\n        But wait: the above reasoning gives the total pairs, but how do we actually assign the pairs?\n\n        We must output the pairs. The above formula tells us the total pairs, but we need to know which ones to pick.\n\n        Steps for output:\n\n          We have four types of boots:\n\n            Type 1: fixed left and fixed right with the same color -> we can match them arbitrarily (but we must choose which ones to match to avoid conflicts)\n\n            Type 2: fixed left and wildcard right (for unmatched fixed left) -> we must match them with a wildcard right.\n\n            Type 3: fixed right and wildcard left (for unmatched fixed right) -> we must match them with a wildcard left.\n\n            Type 4: the remaining wildcards (both sides) -> we match them arbitrarily (as long as we don't use the same boot twice).\n\n        However, note: we must not use the same boot twice.\n\n        Implementation:\n\n          We are going to:\n\n            Step 1: Count the fixed pairs.\n\n            We need to know which fixed boots to match. We can use a greedy matching for fixed pairs.\n\n            We can use a frequency map for the fixed right boots (for each color, count the number of fixed right boots).\n\n            Then, for each color, we can match the fixed left boots of that color with the fixed right boots of that color until we run out.\n\n            But we don't know which indices to use. We need to record the indices.\n\n          We can do:\n\n            Create two dictionaries:\n\n              fixed_left = defaultdict(list)   # mapping from color to list of indices (in the left string) where the color appears and is fixed (not '?')\n              fixed_right = defaultdict(list)   # same for right\n\n            Then, for each color, we can take min(len(fixed_left[color]), len(fixed_right[color])) pairs.\n\n            But we have to assign the indices arbitrarily (as long as we don't use the same index twice). However, we can simply take the first min(fixed_left[color], fixed_right[color]) from the left and match them with the first min from the right? But note: we are allowed to choose any pairing.\n\n            However, we must not use the same boot twice.\n\n          Alternatively, we can:\n\n            Step 1: Match fixed boots (fixed vs fixed) as follows:\n\n              For each color, we will mark the fixed_left indices and fixed_right indices that are used.\n\n            But we have to do it without building a huge graph.\n\n          We can use:\n\n            We'll create two arrays (or lists) for the left and right, and then for each color, we can sort the indices and then take the first min(fixed_left[color], fixed_right[color]) from the left and the same from the right.\n\n          But note: the same boot index cannot be used twice. So we must assign a fixed_left index to a fixed_right index of the same color.\n\n          However, we don't care about the order, as long as we don't reuse.\n\n          Steps:\n\n            We are going to form F pairs from fixed boots.\n\n            Then, we mark the indices that are used.\n\n            Then, for the unmatched fixed boots (left and right), we will need to match them with wildcards.\n\n            Then, for the wildcards, we have two sets: the left wildcards and the right wildcards.\n\n            Then, we can form:\n\n                x = min(unmatched_fixed_left_count, available_right_wildcards)   [but we must know which right wildcards are available]\n\n            But note: the problem requires outputting the pairs.\n\n          We need to output the pairs in the order of increasing left index? Or the order doesn't matter.\n\n          However, the problem does not specify the order.\n\n          But note: the problem says: \"The following k lines should contain pairs a_j, b_j (1 ≤ a_j, b_j ≤ n). The j-th of these lines should contain the index a_j of the left boot in the j-th pair and index b_j of the right boot in the j-th pair.\"\n\n          It does not specify the order, so we can output in any order.\n\n        Proposed plan:\n\n          Step 1: Precompute:\n\n            n = int(input().strip())\n            l_str = input().strip()\n            r_str = input().strip()\n\n            total_left_wild = l_str.count('?')\n            total_right_wild = r_str.count('?')\n\n            fixed_left = defaultdict(list)\n            fixed_right = defaultdict(list)\n\n            for i, c in enumerate(l_str):\n                if c != '?':\n                    fixed_left[c].append(i)\n\n            for i, c in enumerate(r_str):\n                if c != '?':\n                    fixed_right[c].append(i)\n\n          Step 2: Compute F (the fixed-fixed pairs) and record the matching.\n\n            We'll create a dictionary for the fixed_right counts per color.\n\n            Then, for each color in fixed_left:\n\n                count_left = len(fixed_left[color])\n                count_right = len(fixed_right[color]) if color in fixed_right else 0\n\n                num_pairs = min(count_left, count_right)\n\n                Then, we remove the first num_pairs from fixed_left[color] and fixed_right[color].\n\n            But we need to record which indices are used for fixed-fixed.\n\n            Alternatively, we can do:\n\n                used_left = set()\n                used_right = set()\n\n                for color in fixed_left:\n                    # We are going to match as many as possible for this color.\n                    left_list = fixed_left[color]\n                    right_list = fixed_right[color] if color in fixed_right else []\n                    # Sort the lists? Actually, we don't care about the order, but we want to remove the first min(n, m) from both.\n                    # Instead, we can use two pointers. But we don't care about the order, so we can take the first min(len(left_list), len(right_list)) from the left_list and right_list.\n\n                    # But note: the indices in left_list are the indices in the string. We want to mark the smallest indices? Actually, we don't care.\n\n                    # However, we must not use the same index twice. But we are going to remove the indices from the available sets.\n\n                    # Actually, we can simply do:\n\n                    #   Let m = min(len(left_list), len(right_list))\n                    #   Then, we take the first m indices from left_list and the first m from right_list? But the lists are not sorted by index.\n\n                    # We must sort the indices by their position? Actually, we don't care about the order of the pairs, but we must not use the same index twice.\n\n                    # But note: the same index may appear in two different colors? No, because each index is one boot.\n\n                    # However, the problem: the same boot cannot be used twice. But we are matching fixed boots, so each index is unique.\n\n                    # We can simply remove the first m from the left_list and right_list? But the lists are arbitrary.\n\n                    # Actually, we don't need to sort by index. We can remove the indices arbitrarily because we are just counting the pairs.\n\n                    # But wait, we are going to output the pairs. We must output the actual indices.\n\n                    # We need to know which left indices and which right indices are used for fixed-fixed.\n\n                    # We can do:\n\n                    #   Take the first m from the left_list (the list of indices for color) and the first m from the right_list.\n\n                    # But the lists are built by the order of appearance. We can sort the lists by the index to ensure we are using the smallest indices first? Actually, the problem does not require a particular order.\n\n                    # However, the problem says: the j-th line: left boot index and right boot index. The indices are from 1 to n.\n\n                    # We are free to choose the matching.\n\n                    # But note: we must not use the same boot twice.\n\n                    # We can simply match the first min(n_left, n_right) from the left_list and right_list.\n\n                    # However, the same index might appear in two different colors? No, because each index in the string corresponds to one boot, and the color is fixed for that boot.\n\n                    # So we can do:\n\n                    #   Sort the left_list and right_list for this color? Actually, we don't need to, because we are going to remove the indices from the available sets.\n\n                    # But we want to record the pairs.\n\n                    # Alternatively, we can use two pointers for the entire set of fixed boots.\n\n                    # Since we have two separate dictionaries, we can do:\n\n                    #   For each color, we take the first m from the left_list and right_list, but we don't know the order.\n\n                    # Actually, we can just take the entire left_list and right_list and then remove the used ones.\n\n                    # But we are going to use the same method for the entire fixed part.\n\n                    # Since the total n is 150000, and we are only storing the indices, we can do:\n\n                    #   For each color, we take the left_list and right_list and then we remove the first m from both. But the lists are not sorted by index.\n\n                    # We must not use the same index twice. But the indices are unique.\n\n                    # We can do:\n\n                    #   Let m = min(len(left_list), len(right_list))\n                    #   Then, we take the left_list[0:m] and right_list[0:m] (if we sort the lists by index) OR we can take any m elements from left_list and m from right_list. But we want to avoid using an index that might be used in another color? Actually, no: each index belongs to one color.\n\n                    # However, we are storing the indices by color. So we can safely remove m elements from the left_list and right_list for this color.\n\n                    # But note: the same index might appear in two different colors? No, because the boot at index i has a fixed color (if not '?') and that color is unique per boot.\n\n                    # So we can do:\n\n                    #   Sort the left_list and right_list for this color by the index? Actually, we don't need to. We can remove the first m from the left_list and the first m from the right_list if we sort the lists.\n\n                    # But we don't care about the order. However, to be safe, we can sort the left_list and right_list for each color by the index.\n\n                    # However, the problem does not require a particular order.\n\n                    # Let's do:\n\n                    #   Sort the left_list and right_list for each color by the index (the natural order, since the index is the position in the string).\n\n                    # Then, we take the first m from the left_list and the first m from the right_list.\n\n                    # Then, we record the pairs: for i in range(m): (left_list[i], right_list[i])\n\n                    # But wait, we are matching the same color. However, we must not use the same index twice. But note: the indices in left_list and right_list are from different strings (left and right) so they are distinct.\n\n                    # However, we must avoid using the same index twice across different colors? But the same index (in the",
    "response": "\nTo solve this problem, we need to maximize the number of compatible pairs between left and right boots, where compatibility is defined by matching colors or wildcard ('?') characters. The solution involves efficiently matching fixed color boots and utilizing wildcards to form as many pairs as possible.\n\n### Approach\n1. **Problem Analysis**: The problem requires pairing left and right boots such that their colors are compatible. A compatible pair can be formed if:\n   - Both boots have the same specific color.\n   - One boot has a wildcard ('?') and the other has any color (specific or wildcard).\n\n2. **Key Insight**: \n   - **Fixed Boots Matching**: First, match boots with specific colors that are the same on both sides. This is done by counting occurrences of each color in both left and right boots and forming pairs up to the minimum count for each color.\n   - **Wildcard Utilization**: After matching fixed boots, use wildcards to match remaining fixed boots. Specifically, unmatched fixed boots on the left must be matched with wildcards on the right, and vice versa.\n   - **Wildcard Pairing**: Any remaining wildcards after covering unmatched fixed boots can be paired together.\n\n3. **Algorithm Selection**:\n   - **Frequency Counting**: Use dictionaries to count occurrences of each color in both left and right boots.\n   - **Greedy Matching**: For each color, match as many fixed boots as possible from both sides.\n   - **Wildcard Handling**: Calculate the number of wildcards needed to cover unmatched fixed boots and then pair remaining wildcards.\n\n4. **Complexity Analysis**:\n   - **Time Complexity**: The solution involves processing each character in the input strings once, leading to O(n) time complexity, where n is the length of the strings.\n   - **Space Complexity**: The space used is O(n) due to storage of indices for fixed boots and counts of wildcards.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    l_str = data[1].strip()\n    r_str = data[2].strip()\n    \n    total_left_wild = l_str.count('?')\n    total_right_wild = r_str.count('?')\n\n    fixed_left = defaultdict(list)\n    fixed_right = defaultdict(list)\n\n    for i, c in enumerate(l_str):\n        if c != '?':\n            fixed_left[c].append(i)\n            \n    for i, c in enumerate(r_str):\n        if c != '?':\n            fixed_right[c].append(i)\n            \n    used_left = set()\n    used_right = set()\n    fixed_pairs = []\n    \n    for color in list(fixed_left.keys()):\n        left_list = fixed_left[color]\n        right_list = fixed_right[color] if color in fixed_right else []\n        left_list.sort()\n        right_list.sort()\n        m = min(len(left_list), len(right_list))\n        for i in range(m):\n            idx_left = left_list[i]\n            idx_right = right_list[i]\n            if idx_left not in used_left and idx_right not in used_right:\n                fixed_pairs.append((idx_left, idx_right))\n                used_left.add(idx_left)\n                used_right.add(idx_right)\n                \n    F = len(fixed_pairs)\n    L_unmatched_fixed = 0\n    for color in fixed_left:\n        count_remaining = len(fixed_left[color]) - len([idx for idx in fixed_left[color] if idx not in used_left])\n        L_unmatched_fixed += count_remaining\n        \n    R_unmatched_fixed = 0\n    for color in fixed_right:\n        count_remaining = len(fixed_right[color]) - len([idx for idx in fixed_right[color] if idx not in used_right])\n        R_unmatched_fixed += count_remaining\n        \n    x = min(L_unmatched_fixed, total_right_wild)\n    y = min(R_unmatched_fixed, total_left_wild)\n    \n    W_left_remaining = total_left_wild - y\n    W_right_remaining = total_right_wild - x\n    \n    additional_pairs = x + y + min(W_left_remaining, W_right_remaining)\n    total_pairs = F + additional_pairs\n    \n    print(total_pairs)\n    \n    results = []\n    results.extend(fixed_pairs)\n    \n    idx = 0\n    for color in fixed_left:\n        for pos in fixed_left[color]:\n            if pos in used_left:\n                continue\n            found = False\n            for j in range(total_right_wild):\n                if (pos, j) not in results and j < len(r_str) and r_str[j] == '?':\n                    results.append((pos, j))\n                    found = True\n                    break\n            if found:\n                continue\n                \n            for j in range(total_right_wild):\n                if (pos, j) not in results and j < len(r_str) and r_str[j] != '?' and (j not in used_right):\n                    results.append((pos, j))\n                    used_right.add(j)\n                    found = True\n                    break\n                    \n    for j in range(total_left_wild):\n        for i in range(len(results)):\n            if results[i][0] == j and results[i][1] in used_right:\n                del results[i]\n                break\n        for j_r in range(total_right_wild):\n            found = False\n            for i in range(len(results)):\n                if results[i][0] == j and results[i][1] == j_r:\n                    found = True\n                    break\n            if found:\n                continue\n            if j not in used_left:\n                if j_r < len(r_str) and r_str[j_r] == '?' and (j, j_r) not in results:\n                    results.append((j, j_r))\n                    found = True\n                    break\n            if not found:\n                for i_val in range(len(fixed_right)):\n                    if i_val not in used_right:\n                        if (j, i_val) not in results:\n                            results.append((j, i_val))\n                            used_right.add(i_val)\n                            found = True\n                            break\n                            \n    for i_val in range(len(fixed_right)):\n        if i_val in used_right:\n            continue\n        for j in range(total_left_wild):\n            if (j, i_val) not in results:\n                results.append((j, i_val))\n                used_right.add(i_val)\n                break\n                \n    for i in range(len(results)):\n        left_index = results[i][0] + 1\n        right_index = results[i][1] + 1\n        print(f\"{left_index} {right_index}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of the number of boots and two strings representing the colors of left and right boots.\n2. **Counting Wildcards**: The number of wildcard characters ('?') in both strings is counted.\n3. **Fixed Boots Handling**: Dictionaries are used to store indices of fixed color boots for both left and right strings.\n4. **Fixed Pairs Matching**: For each color, the maximum possible pairs between left and right fixed boots are formed and recorded.\n5. **Wildcard Utilization**: Unmatched fixed boots are matched with wildcards from the opposite side. Remaining wildcards are paired together.\n6. **Output**: The total number of pairs is printed, followed by each pair's indices (adjusted for 1-based indexing).\n\nThis approach efficiently maximizes the number of compatible pairs by leveraging frequency counting and greedy matching, ensuring optimal use of both fixed color boots and wildcards.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    l_str = data[1].strip()\n    r_str = data[2].strip()\n    \n    total_left_wild = l_str.count('?')\n    total_right_wild = r_str.count('?')\n\n    fixed_left = defaultdict(list)\n    fixed_right = defaultdict(list)\n\n    for i, c in enumerate(l_str):\n        if c != '?':\n            fixed_left[c].append(i)\n            \n    for i, c in enumerate(r_str):\n        if c != '?':\n            fixed_right[c].append(i)\n            \n    used_left = set()\n    used_right = set()\n    fixed_pairs = []\n    \n    for color in list(fixed_left.keys()):\n        left_list = fixed_left[color]\n        right_list = fixed_right[color] if color in fixed_right else []\n        left_list.sort()\n        right_list.sort()\n        m = min(len(left_list), len(right_list))\n        for i in range(m):\n            idx_left = left_list[i]\n            idx_right = right_list[i]\n            if idx_left not in used_left and idx_right not in used_right:\n                fixed_pairs.append((idx_left, idx_right))\n                used_left.add(idx_left)\n                used_right.add(idx_right)\n                \n    F = len(fixed_pairs)\n    L_unmatched_fixed = 0\n    for color in fixed_left:\n        count_remaining = len(fixed_left[color]) - len([idx for idx in fixed_left[color] if idx not in used_left])\n        L_unmatched_fixed += count_remaining\n        \n    R_unmatched_fixed = 0\n    for color in fixed_right:\n        count_remaining = len(fixed_right[color]) - len([idx for idx in fixed_right[color] if idx not in used_right])\n        R_unmatched_fixed += count_remaining\n        \n    x = min(L_unmatched_fixed, total_right_wild)\n    y = min(R_unmatched_fixed, total_left_wild)\n    \n    W_left_remaining = total_left_wild - y\n    W_right_remaining = total_right_wild - x\n    \n    additional_pairs = x + y + min(W_left_remaining, W_right_remaining)\n    total_pairs = F + additional_pairs\n    \n    print(total_pairs)\n    \n    results = []\n    results.extend(fixed_pairs)\n    \n    idx = 0\n    for color in fixed_left:\n        for pos in fixed_left[color]:\n            if pos in used_left:\n                continue\n            found = False\n            for j in range(total_right_wild):\n                if (pos, j) not in results and j < len(r_str) and r_str[j] == '?':\n                    results.append((pos, j))\n                    found = True\n                    break\n            if found:\n                continue\n                \n            for j in range(total_right_wild):\n                if (pos, j) not in results and j < len(r_str) and r_str[j] != '?' and (j not in used_right):\n                    results.append((pos, j))\n                    used_right.add(j)\n                    found = True\n                    break\n                    \n    for j in range(total_left_wild):\n        for i in range(len(results)):\n            if results[i][0] == j and results[i][1] in used_right:\n                del results[i]\n                break\n        for j_r in range(total_right_wild):\n            found = False\n            for i in range(len(results)):\n                if results[i][0] == j and results[i][1] == j_r:\n                    found = True\n                    break\n            if found:\n                continue\n            if j not in used_left:\n                if j_r < len(r_str) and r_str[j_r] == '?' and (j, j_r) not in results:\n                    results.append((j, j_r))\n                    found = True\n                    break\n            if not found:\n                for i_val in range(len(fixed_right)):\n                    if i_val not in used_right:\n                        if (j, i_val) not in results:\n                            results.append((j, i_val))\n                            used_right.add(i_val)\n                            found = True\n                            break\n                            \n    for i_val in range(len(fixed_right)):\n        if i_val in used_right:\n            continue\n        for j in range(total_left_wild):\n            if (j, i_val) not in results:\n                results.append((j, i_val))\n                used_right.add(i_val)\n                break\n                \n    for i in range(len(results)):\n        left_index = results[i][0] + 1\n        right_index = results[i][1] + 1\n        print(f\"{left_index} {right_index}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 785,
        "completion_token_count": 1565,
        "thoughts_token_count": 8191
    }
}