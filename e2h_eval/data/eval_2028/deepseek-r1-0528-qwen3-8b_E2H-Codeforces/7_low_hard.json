{
    "start": 1758089220.3007114,
    "end": 1758090756.5422454,
    "start-formatted": "2025-09-17 15:07 KST",
    "end-formatted": "2025-09-17 15:32 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are to determine for a given n (which can be up to 10^18) whether there exists an integer k>1 and a nonnegative integer t (at least one step after the initial) such that:\n\n The snowflake construction:\n   Step 0: Start with 1 vertex.\n   Step 1: Add k vertices connected to the center. Now total vertices = 1 + k.\n   Step 2: Each of the k leaves from step 1 now each get k new vertices? But note: the problem says \"Each vertex that is connected to only one other vertex\" (i.e., leaves) is connected to k new vertices. And we must do this at least once.\n\n However, note that the example for k=4 is the smallest snowflake. The example drawing probably shows:\n   Step0: 1 vertex (center)\n   Step1: center connects to 4 -> total 5\n   Then, each of the 4 leaves (each has degree 1) so they each connect to 4 new ones -> but wait, if we do step1 and then step2, then the total becomes 1 + 4 + 4*4 = 21? \n\n Actually, let me re-read the construction:\n\n   Rule 1: Start with one vertex.\n   Rule 2: Then, the initial vertex is connected to k new vertices (k>1). So now we have 1+k vertices.\n   Rule 3: Then, each vertex that is connected to only one other vertex (i.e., the leaves from the previous step) is connected by edges to k more new vertices. And we do this at least once.\n\n But note: after the first expansion, the center has k edges (so degree k) and the new leaves have 1 edge (so they are leaves). Then we do the next expansion: each leaf (there are k leaves) gets k new children. Then those new ones become leaves. Then we can stop.\n\n However, the problem does not specify the number of expansions. We can have multiple expansions. The total number of vertices is:\n\n   Level0: 1\n   Level1: k\n   Level2: k * k\n   ...\n   Level i: k^i\n\n Then the total number of vertices is: 1 + k + k^2 + ... + k^t, where t>=1 (at least one expansion beyond the initial).\n\n But note: the problem says \"at least once\" meaning we must do the second step (the expansion from the initial leaves) at least once. So we must have at least two steps: the initial and then at least one expansion.\n\n However, the problem says: \n   Step 0: one vertex.\n   Then, the initial vertex is connected to k new -> that's step 1 (with k>=2).\n   Then, the condition says \"Each vertex that is connected to only one other vertex\" (the leaves from step1) are expanded. This step is done at least once.\n\n So the minimal snowflake has two layers: center (level0), then level1 (k nodes) and level2 (k*k nodes). But wait, what if we stop after one expansion? Then we have 1 + k + k^2? Actually, no: the expansion step is applied at least once, meaning we must do the expansion from the leaves (which are the level1 nodes) at least one time. But then we can choose to stop after that? Or can we do more?\n\n Actually, the problem says: \"Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices (k > 1). Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\"\n\n This means that we have at least two layers: the center (layer0) and layer1 (from the first expansion). Then we must do the expansion from the leaves (which are the layer1 nodes) at least once, so we add layer2 (k^2 nodes). Then we can choose to stop or continue? \n\n But note: the problem does not say we have to stop. It just says the construction must be done at least once (meaning the expansion from leaves must occur at least once). However, the problem does not specify the number of layers. So the total number of vertices can be:\n\n   n = 1 + k + k^2 + ... + k^t   for some t>=1 and k>=2.\n\n Alternatively, we can consider that the process stops after any number of expansions (at least one expansion beyond the center). \n\n Therefore, the problem reduces to: Does there exist an integer k>=2 and an integer t>=1 such that:\n\n   n = 1 + k + k^2 + ... + k^t   ?\n\n However, note: the example input and output:\n\n  ",
    "response": "\nTo solve this problem, we need to determine whether a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in layers, starting from a single central vertex and expanding outward in layers where each leaf node in the previous layer connects to \\( k \\) new nodes. The key insight is that the total number of vertices in such a graph must satisfy a specific mathematical condition.\n\n### Approach\n1. **Problem Analysis**: The snowflake graph is built in layers. The first layer (after the central vertex) has \\( k \\) vertices, the next layer has \\( k^2 \\) vertices, and so on. The total number of vertices after \\( t \\) layers is the sum of a geometric series: \\( 1 + k + k^2 + \\ldots + k^t \\). This sum can be expressed as \\( \\frac{k^{t+1} - 1}{k - 1} \\).\n\n2. **Key Insight**: For \\( n \\) to be a valid snowflake graph, there must exist integers \\( k > 1 \\) and \\( t \\geq 1 \\) such that \\( n = \\frac{k^{t+1} - 1}{k - 1} \\). However, directly checking all possible \\( k \\) and \\( t \\) for very large \\( n \\) (up to \\( 10^{18} \\)) is infeasible.\n\n3. **Optimization**: Instead of iterating over all possible \\( k \\), we recognize that \\( t \\) (the number of layers) is likely small. We can fix \\( t \\) (starting from 1 upwards) and solve for \\( k \\) in the equation \\( n = \\frac{k^{t+1} - 1}{k - 1} \\). Rearranging gives \\( k^{t+1} - (n)(k - 1) - 1 = 0 \\). For each \\( t \\), we can use binary search to find if there exists an integer \\( k > 1 \\) satisfying this equation.\n\n4. **Edge Cases**: \n   - If \\( n < 5 \\), it's impossible to form a valid snowflake (since the smallest snowflake has 1 + 2 + 4 = 7 vertices? Actually, let's recheck: The minimal snowflake requires at least two layers. For \\( k=2 \\), the first expansion adds 2 vertices (total 3), but then the next expansion adds \\( 2^2 = 4 \\) vertices, making the total 7. However, the problem states that the initial expansion must have \\( k > 1 \\), and the expansion step must be done at least once. Thus, the minimal valid \\( n \\) is 7 for \\( k=2 \\) and \\( t=2 \\). But note: the example input includes cases like \\( n=6 \\) which outputs \"NO\". \n\n5. **Algorithm Selection**: For each test case, iterate over possible values of \\( t \\) (from 1 to a reasonable upper limit, say 60, since \\( 2^{60} \\) is around \\( 1e18 \\)). For each \\( t \\), use binary search to check if there exists an integer \\( k > 1 \\) such that \\( n = \\frac{k^{t+1} - 1}{k - 1} \\). If found, output \"YES\"; otherwise, after all \\( t \\) are checked, output \"NO\".\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    tests = [int(x) for x in data[1:1+t]]\n    \n    results = []\n    for n_val in tests:\n        if n_val == 1:\n            results.append(\"NO\")\n            continue\n        found = False\n        for exp in range(1, 61):\n            low = 2\n            high = 10**18\n            candidate_k = None\n            while low <= high:\n                mid = (low + high) // 2\n                s = (mid**(exp+1) - 1) // (mid - 1)\n                if s == n_val:\n                    found = True\n                    candidate_k = mid\n                    break\n                elif s < n_val:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            if found:\n                break\n        results.append(\"YES\" if found else \"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read in one go for efficiency, especially given the constraints.\n2. **Handling Small Values**: If \\( n \\) is 1, it's immediately determined that no valid snowflake can be formed (output \"NO\").\n3. **Binary Search for Valid \\( k \\)**: For each possible number of layers \\( t \\) (from 1 to 60), the code performs a binary search to check if there exists a \\( k > 1 \\) such that the sum of the geometric series equals \\( n \\). The binary search adjusts the range for \\( k \\) based on whether the computed sum is less than or greater than \\( n \\).\n4. **Output Result**: After checking all possible \\( t \\), if no valid \\( k \\) is found, the result for that test case is \"NO\"; otherwise, it's \"YES\".\n5. **Efficiency**: The approach efficiently narrows down the search space using binary search for each \\( t \\), making it feasible even for very large \\( n \\) (up to \\( 10^{18} \\)). The upper limit for \\( t \\) is set to 60 because \\( 2^{60} \\) exceeds \\( 10^{18} \\), ensuring coverage of all possible values.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    tests = [int(x) for x in data[1:1+t]]\n    \n    results = []\n    for n_val in tests:\n        if n_val == 1:\n            results.append(\"NO\")\n            continue\n        found = False\n        for exp in range(1, 61):\n            low = 2\n            high = 10**18\n            candidate_k = None\n            while low <= high:\n                mid = (low + high) // 2\n                s = (mid**(exp+1) - 1) // (mid - 1)\n                if s == n_val:\n                    found = True\n                    candidate_k = mid\n                    break\n                elif s < n_val:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            if found:\n                break\n        results.append(\"YES\" if found else \"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 556,
        "completion_token_count": 1272,
        "thoughts_token_count": 1023
    }
}