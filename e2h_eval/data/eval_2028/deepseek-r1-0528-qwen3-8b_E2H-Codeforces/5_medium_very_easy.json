{
    "start": 1758095610.9088788,
    "end": 1758097684.2217479,
    "start-formatted": "2025-09-17 16:53 KST",
    "end-formatted": "2025-09-17 17:28 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ — the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are going to break the problem into two parts:\n 1. Matching the specific boots that have the same color (or '?' with any).\n 2. We cannot use a boot twice.\n\n However, note: the problem has two strings of length n (each) and we have to form pairs (one left and one right) such that the colors are compatible.\n\n Steps:\n - We note that the matching can be done in two ways: \n   a) When both boots are specific and the same.\n   b) When one is '?' and the other is anything (so it matches).\n\n But note: an indefinite color '?' can match any color (even if the other is '?'). Also, we are allowed to assign arbitrarily.\n\n However, we are constrained by the fact that we have exactly n left and n right boots.\n\n We need to maximize the number of pairs. Since each pair uses one left and one right, the maximum possible pairs is n, but we may not achieve that.\n\n Approach:\n\n We can consider two types of boots: fixed and variable (with '?').\n\n But note: we have two strings, one for left and one for right.\n\n Idea:\n\n Let's denote:\n   l[i] = color of left boot i (0-indexed)\n   r[j] = color of right boot j\n\n We want to form as many pairs as possible.\n\n We can think greedily:\n\n Step 1: Count the frequency of each color in the left and right boots.\n\n However, note: there are up to 26 letters and the question mark. The total distinct colors is 27.\n\n But wait: the problem says the string can have lowercase Latin letters and '?'. The total distinct letters is 27.\n\n However, the catch: we have two arrays, and we have to assign without repetition.\n\n Alternate idea:\n\n We can first try to match all the '?'s with something? Actually, we can also match non-'?' boots.\n\n But note: the requirement is that two specific colors must be the same to be compatible. So:\n\n   - A '?' in left can match a letter or a '?' in the right.\n   - Similarly for the right.\n\n However, we can also match two '?' together.\n\n How to solve:\n\n We can use a greedy matching with two passes:\n\n 1. Match the fixed boots (non '?') first? But sometimes a '?' might be necessary to fill in the gap.\n\n Alternatively, we can use a graph matching? But n can be up to 150000, so we cannot do a general graph matching (like bipartite matching) because that would be O(n^2) or more.\n\n However, note: the compatibility condition is very structured.\n\n Another idea:\n\n We can count the number of '?' in left and right. Then, we can try to match the '?' with the remaining boots (both fixed and variable) as long as they are compatible.\n\n But note: the condition is symmetric and the matching is arbitrary.\n\n Steps:\n\n We can separate the boots into two groups: left and right.\n\n Let:\n   L_fixed = [index for index, color in enumerate(l) if color != '?']\n   L_question = [index for index, color in enumerate(l) if color == '?']\n\n Similarly for R.\n\n Now, the total pairs we can form is limited by the entire set. However, we can form:\n\n   - Pairs between fixed left and fixed right: if the colors match.\n   - Pairs between fixed left and right_question: always, because '?' in right matches any fixed left.\n   - Pairs between left_question and fixed right: always, because '?' in left matches any fixed right.\n   - Pairs between left_question and right_question: always.\n\n But note: we must avoid using the same boot twice.\n\n However, we cannot simply assign arbitrarily because we have to use each boot at most once.\n\n We can do:\n\n   Step 1: Count the total number of fixed boots on the left and right.\n\n   Step 2: We can form pairs from fixed boots first.\n\n   But note: we are allowed to use '?' to match fixed boots. However, we want to maximize the pairs.\n\n Observation:\n\n   The total pairs is at most n. We can use a greedy two-phase:\n\n   Phase 1: Use the '?' to cover the unmatched fixed boots.\n\n   However, we can also use the '?' to cover the '?' in the opposite side.\n\n   Actually, the problem is similar to: we have two sets of nodes (left and right) and edges exist if the colors are compatible.\n\n   Since the graph is defined by:\n\n        Edge between left i and right j if:\n            (l[i] == r[j]) or (l[i]=='?' and r[j]!='?') is not the condition. Actually:\n\n        Condition: \n            if l[i] == '?' or r[j] == '?' OR (l[i] == r[j] and l[i]!='?' and r[j]!='?'):\n                then edge exists.\n\n   But wait: the condition is: \n        compatible if (l[i] == r[j]) OR (l[i]=='?' OR r[j]=='?')   -> but note: if both are '?' then they are compatible.\n\n   However, note: the condition is defined as:\n        An indefinite color is compatible with any (specific or indefinite) color.\n\n   So: \n        (l[i], r[j]) is compatible if:\n            (l[i] == r[j]) OR (l[i]=='?' OR r[j]=='?')\n\n   But wait, this is not entirely correct. Actually, the condition is:\n\n        - If l[i] is a letter and r[j] is a letter, then they must be equal.\n        - If at least one is '?', then they are compatible.\n\n   So the condition is: (l[i] == r[j]) OR (l[i]=='?' OR r[j]=='?') is actually not correct because if one is '?' then we don't care about the other.\n\n   Correct condition: \n        (l[i] == r[j]) or (l[i]=='?' and True) or (r[j]=='?' and True) -> but wait, we can combine:\n\n        It's: (l[i] == r[j]) or (l[i]=='?' or r[j]=='?')\n\n   However, note: if both are '?' then (l[i]=='?' or r[j]=='?') is true, and (l[i]==r[j]) is also true (because '?'== '?' is True). So it's okay.\n\n   But wait: in Python, '?' == '?' is True. So the condition is satisfied.\n\n   Therefore, the condition can be written as: (l[i] == r[j]) or (l[i]=='?' or r[j]=='?') \n\n   However, note: the condition (l[i]=='?' or r[j]=='?') already implies that if either is '?', then they are compatible. And if neither is '?', then we require l[i]==r[j].\n\n   So the condition is: (l[i] == r[j]) or (l[i]=='?' or r[j]=='?') \n\n   But wait, if one is '?' and the other is not, then we don't require the letter to match. But if both are letters, then they must match.\n\n   This condition is correct.\n\n   Now, the graph has two sets of nodes (left and right) and edges as defined. We wish to find the maximum matching.\n\n   However, note: the graph is defined by 150000 nodes on each side, so we cannot use standard bipartite matching (like Hopcroft–Karp) because 150000 is too large for O(n^2) algorithms.\n\n   But note the structure: the condition is based on colors and '?'. There are only 27 distinct colors.\n\n   We can try to use color frequencies and then:\n\n        - First, match the fixed boots (non '?') by their color.\n\n        - Then, use the '?' boots to cover the remaining fixed boots (if any) and the '?' boots.\n\n   However, we can also form pairs between two '?' boots.\n\n   Steps:\n\n        Step 1: Count the total fixed boots per color (for left and right).\n\n        Step 2: For each color (from 'a' to 'z'), we can match the fixed left boots of that color with the fixed right boots of that color.\n\n        Step 3: Then, we can use the '?' boots to cover the remaining fixed boots (from the opposite side) and the '?' boots.\n\n   But note: we can also use a '?' boot from left to cover a fixed boot in right (and vice versa). And we can use a '?' boot to cover a '?' boot.\n\n   However, we must remember that we cannot use the same boot twice.\n\n   We can do:\n\n        Let:\n            L_non_question = {color: list of indices where l[i]==color and color!='?'}\n            R_non_question = {color: list of indices where r[i]==color and color!='?'}\n\n        Then, for each color c in the alphabet (including '?'), we don't have to consider '?' separately for fixed? Actually, the fixed ones are non '?'. But note: we have two kinds: non '?' and '?'.\n\n   Alternatively, we can split the boots:\n\n        Let:\n            L_normal = all indices i where l[i] != '?'\n            R_normal = all indices i where r[i] != '?'\n            L_question = all indices i where l[i]=='?'\n            R_question = all indices i where r[i]=='?'\n\n        Then, the matching can be:\n\n            Type 1: (L_normal, R_normal): only if the color matches.\n\n            Type 2: (L_normal, R_question): always, because R_question is '?' which matches any.\n\n            Type 3: (L_question, R_normal): always.\n\n            Type 4: (L_question, R_question): always.\n\n        But note: we cannot use a boot twice. We have to assign without repetition.\n\n        The goal is to maximize the total pairs.\n\n        We can use a two-step matching:\n\n            Step 1: Match as many normal boots as possible (i.e., Type 1). We can do this by:\n\n                For each color c (from 'a' to 'z'):\n                    Let x = min(len(L_normal[c]), len(R_normal[c]))\n                    Then we can form x pairs of Type 1.\n\n            Step 2: Then, we have some unmatched normal boots. These unmatched normal boots can be matched with the question marks.\n\n                Specifically, after Step 1, we have:\n\n                    For left: for each color c, the unmatched normal left boots are: |L_normal[c]| - min(|L_normal[c]|, |R_normal[c]|)\n\n                    Similarly for the right.\n\n                Now, we can use the question marks to cover these unmatched normal boots.\n\n                We have two kinds of pairs that use question marks:\n\n                    Type 2: (unmatched normal left, R_question) -> but note: we can also use R_question to cover unmatched normal left, but we have to consider that R_question can also cover unmatched normal left and also unmatched L_question.\n\n                    Type 3: (L_question, unmatched normal right)\n\n                    Type 4: (L_question, R_question)\n\n                However, note: the total available '?' boots are |L_question| and |R_question|.\n\n                The problem is: we want to maximize the total pairs. The maximum pairs we can form is n.\n\n                After Step 1, we have:\n\n                    matched_normal = sum_{c} min(|L_normal[c]|, |R_normal[c]|)\n\n                    Then, we have unmatched_normal_left = n - (sum_{c} |L_normal[c]|) + (number of '?' in left?) -> wait, no: the normal boots are the non '?'. Actually, the total left boots is n, so:\n\n                    unmatched_normal_left = (n - len(L_question)) - (matched_normal_from_left_side) ?\n\n                Actually, let me define:\n\n                    Let U_L = set of left boots indices that are not '?'.\n                    Then, the normal left boots are the non '?' ones.\n\n                Alternatively, we can compute:\n\n                    total_pairs_after_step1 = matched_normal\n\n                    Then, the remaining left boots (that are not yet paired) are:\n                        left_remaining = n - matched_normal   [but note: the matched_normal pairs used some left boots?]\n\n                Actually, in Step 1 we matched min(|L_normal[c]|, |R_normal[c]|) for each color c. So the total left boots used in Step 1 is the sum over colors of min(|L_normal[c]|, |R_normal[c]|). Similarly for the right.\n\n                Then, the remaining left boots (both normal and question) are:\n\n                    remaining_left = n - matched_normal   [This is the total left boots minus the ones used in Step 1, but note: Step 1 only used the normal left boots that were matched. However, the normal left boots that were not matched are still available, and the question marks are also available.]\n\n                But wait: we haven't touched the question marks in Step 1. We only matched the normal boots. So:\n\n                    remaining_left = (total left boots) - (number of normal left boots that were matched in Step 1)\n\n                Similarly, remaining_right = (total right boots) - (number of normal right boots that were matched in Step 1)\n\n                However, the total left boots is n, and the number of normal left boots is (n - len(L_question)). Similarly for the right.\n\n                But note: the matching in Step 1 used min(|L_normal[c]|, |R_normal[c]|) for each color c, so the total matched normal left boots is matched_normal.\n\n                Therefore, the remaining normal left boots (that were not matched) is: (n - len(L_question)) - matched_normal.\n\n                And the remaining question marks in left: len(L_question) (they weren't used in Step 1).\n\n                Similarly for the right.\n\n                Then, the total remaining left boots (to be matched) is: (n - len(L_question)) - matched_normal + len(L_question) = n - matched_normal.\n\n                Similarly, the total remaining right boots is: n - matched_normal.\n\n                Now, in the remaining, we have:\n\n                    Left: (n - len(L_question) - matched_normal) normal boots and len(L_question) question marks.\n                    Right: (n - len(R_question) - matched_normal) normal boots and len(R_question) question marks.\n\n                Now, the remaining graph is complete: because any left boot (either normal or question) is compatible with any right boot (either normal or question). \n\n                Why? Because:\n\n                    - If the left boot is normal, then it's a letter, and the right boot can be either a letter or '?' (if the right boot is a letter, then the normal left boot requires that the right boot is the same letter? Not necessarily, because we haven't matched the normal boots by color in the remaining? Actually, no: the Step 1 matched all the normal boots by color. In the remaining, the normal boots on the left and right are the ones that did not get matched by color. But note: we matched by color in Step 1, so the remaining normal boots are the ones that didn't have a match in the opposite normal boots for the same color. However, they are still letters and they might not match.\n\n                Wait, this is a problem: the condition for normal boots is that they must be the same. So the remaining normal boots on the left and right are not necessarily compatible.\n\n                Therefore, we cannot use the remaining normal boots arbitrarily. We can only use the question marks to fill in the gaps.\n\n                So we must reevaluate:\n\n                Actually, after Step 1, we have:\n\n                    For each color c, we have:\n\n                        L_normal[c] = original list, we matched min(|L_normal[c]|, |R_normal[c]|) from L_normal[c] and from R_normal[c].\n\n                    Then, the unmatched normal left boots are: for each color c, |L_normal[c]| - min(|L_normal[c]|, |R_normal[c]|) = max(0, |L_normal[c]| - |R_normal[c]|) for that color.\n\n                    Similarly, unmatched normal right boots for color c: max(0, |R_normal[c]| - |L_normal[c]|).\n\n                Now, for the remaining normal boots (that are unmatched) we cannot match them with the opposite normal boots (because we already matched the common ones, and now the left unmatched normal boots for color c cannot be matched with right unmatched normal boots for color d unless c==d? But then we would have matched them in Step 1). \n\n                So the remaining normal boots are stuck unless we use a question mark to bridge.\n\n                Therefore, the remaining normal boots can only be matched if we have a question mark on the opposite side.\n\n                Now, we can do:\n\n                    Step 2: Use the question marks to match the remaining unmatched normal boots.\n\n                Specifically:\n\n                    We have two types of remaining normal boots:\n\n                        Type A: Left normal boots that are unmatched (because there were fewer right normal boots of the same color) -> these are the ones that are left over from Step 1.\n                        Type B: Right normal boots that are unmatched (because there were fewer left normal boots of the same color).\n\n                Then, we can use:\n\n                    - A left normal boot (Type A) can be matched with a right question mark (if available) OR with a right normal boot (Type B) of the same color? But wait: no, because in Step 1 we matched all the common colors. The Type A left normal boots are the ones that were in excess, and the right normal boots of the same color are exhausted. So the Type A left normal boot (of color c) can only be matched with a right question mark (because the condition requires that the right side must be '?' or the same color, but the same color is gone).\n\n                    Similarly, Type B right normal boots (of color c) can only be matched with a left question mark.\n\n                Then, we can also match two question marks together.\n\n                So, the plan:\n\n                    Step 1: Match the normal boots (non '?') by color. We form pairs for each color c: min(L_normal[c], R_normal[c]) pairs.\n\n                    Step 2: Now, we have:\n\n                         left_normal_remaining = [for each color c, max(0, L_normal[c] - R_normal[c])]\n                         right_normal_remaining = [for each color c, max(0, R_normal[c] - L_normal[c])]\n\n                    Step 3: We can use the left_normal_remaining and right_normal_remaining to see how many we can cover with the question marks.\n\n                    Specifically, we can cover:\n\n                         - Each left_normal_remaining boot (say of color c) must be matched with a right question mark (because there's no right normal boot of color c left).\n                         - Similarly, each right_normal_remaining boot (say of color c) must be matched with a left question mark.\n\n                    However, we have a fixed set of question marks.\n\n                    Let:\n\n                         total_left_normal_remaining = sum(left_normal_remaining)   [which is the total unmatched normal left boots]\n                         total_right_normal_remaining = sum(right_normal_remaining)   [which is the total unmatched normal right boots]\n\n                    Then, we can use:\n\n                         - The question marks from the right side (R_question) to match the left_normal_remaining.\n                         - The question marks from the left side (L_question) to match the right_normal_remaining.\n\n                    But note: we can also use the question marks to match each other.\n\n                    We have:\n\n                         available_L_question = len(L_question)\n                         available_R_question = len(R_question)\n\n                    Then, the maximum pairs we can form from Step 2 and beyond is:\n\n                         We can form:\n\n                            pairs_from_left_normal_remaining = min(total_left_normal_remaining, available_R_question)\n\n                            pairs_from_right_normal_remaining = min(total_right_normal_remaining, available_L_question)\n\n                    Then, the remaining question marks (after covering the normal boots) is:\n\n                         remaining_L_question = available_L_question - pairs_from_right_normal_remaining\n                         remaining_R_question = available_R_question - pairs_from_left_normal_remaining\n\n                    Then, we can form additional pairs from the remaining question marks: min(remaining_L_question, remaining_R_question)\n\n                    Therefore, the total pairs = Step1 (matched_normal) + pairs_from_left_normal_remaining + pairs_from_right_normal_remaining + min(remaining_L_question, remaining_R_question)\n\n                    But wait: is that correct?\n\n                    Actually, we have:\n\n                         Step1: matched_normal\n\n                         Step2: \n                             pairs_A = pairs_from_left_normal_remaining   [matching left_normal_remaining with right_question]\n                             pairs_B = pairs_from_right_normal_remaining [matching right_normal_remaining with left_question]\n                             pairs_C = min(remaining_L_question, remaining_R_question) [matching the leftover question marks]\n\n                    Then total pairs = matched_normal + pairs_A + pairs_B + pairs_C.\n\n                    However, note: we are allowed to use the same question mark only once. The above counts:\n\n                         For pairs_A: we use some of the right_question (exactly pairs_A) and for pairs_B: we use some of the left_question (exactly pairs_B). Then the remaining question marks are (available_L_question - pairs_B) and (available_R_question - pairs_A), and then we form min(available_L_question-pairs_B, available_R_question-pairs_A) pairs from the question marks.\n\n                    This is valid.\n\n                    But note: we must output the actual pairs, not just the count.\n\n   However, the problem requires to output the pairs.\n\n   We must assign the pairs in a way that:\n\n        - The normal boots are matched in Step1 (by color) and then the remaining normal boots (that are left over) are matched with the question marks.\n\n        - Then, the remaining question marks are matched arbitrarily.\n\n   Implementation:\n\n        We need to record:\n\n            For Step1: For each color c, we take the first min(L_normal[c], R_normal[c]) boots from left and right? But we have to output the indices.\n\n        How to store the indices?\n\n        We can store:\n\n            For left: for each color c, the list of indices (in increasing order) for the normal boots (non '?').\n            Similarly for the right.\n\n        Then, for Step1:\n\n            For each color c:\n\n                Let m = min(len(L_normal[c]), len(R_normal[c]))\n\n                Then, we take the first m from L_normal[c] and the first m from R_normal[c] (but we have to preserve the order? The problem doesn't specify the order of pairs, but the indices are given).\n\n                However, note: the input gives two strings, and the indices are from 1 to n (the problem uses 1-indexed indices for the boots).\n\n                But the problem: the i-th character in the string corresponds to the i-th boot (so index 0 is the first boot, but the output uses 1-indexed index: so we must output (i+1, j+1) for a pair between left boot i and right boot j).\n\n                We must output the pairs in any order, but the example output does not specify the order.\n\n        Steps:\n\n            Step 1: Precompute:\n\n                n = int(input().strip())\n                l_str = input().strip()\n                r_str = input().strip()\n\n                L_normal = {}  # key: color, value: list of indices (0-indexed) for left\n                L_question = []  # list of indices for left that are '?'\n                for i, char in enumerate(l_str):\n                    if char == '?':\n                        L_question.append(i)\n                    else:\n                        if char not in L_normal:\n                            L_normal[char] = []\n                        L_normal[char].append(i)\n\n                Similarly for R.\n\n                Then, Step1: For each color c in L_normal (and also consider that R_normal might not have the color, then we use 0 for R_normal):\n\n                    Actually, we iterate over the union of keys that appear in L_normal or R_normal, but we can iterate over the 26 letters? Or just the keys that are present.\n\n                    Alternatively, we can iterate over the keys that are in L_normal, and also consider the keys that are in R_normal but not in L_normal? Actually, we should consider all colors that appear in either.\n\n                But note: we only have 26 letters, so we can iterate over 'abcdefghijklmnopqrstuvwxyz'.\n\n                However, we have to be cautious: the input might not have all letters.\n\n                Let's do:\n\n                    matched_normal = 0\n                    pairs_step1 = []   # list of tuples (left_index, right_index) for Step1\n\n                    # We'll create a mapping for R_normal as well.\n\n                    # For Step1, we want to match as many as possible for each color.\n\n                    # But note: the same boot cannot be used twice, and we are taking the first m from each list.\n\n                    # We must sort the lists for each color? Actually, the indices are given in increasing order (because we traverse the string from left to right). But we don't know the order of the pairs. The problem doesn't specify.\n\n                    # However, we must output distinct pairs. We can output the pairs in any order.\n\n                    # Let's create for R_normal:\n\n                    R_normal = {}\n                    R_question = []\n                    for i, char in enumerate(r_str):\n                        if char == '?':\n                            R_question.append(i)\n                        else:\n                            if char not in R_normal:\n                                R_normal[char] = []\n                            R_normal[char].append(i)\n\n                    # Now, for each color in the set (all_colors = set(L_normal.keys()) | set(R_normal.keys())):\n\n                    # But wait: what if a color is only in L_normal? Then we use the entire R_normal list (which is empty) and vice versa.\n\n                    # Actually, we can iterate over the colors that are in L_normal OR R_normal.\n\n                    # However, we must consider that the same color might be represented by the same letter.\n\n                    # But note: the condition is that the color must be the same. So we only consider the common colors? Actually, no: if a color appears only in left, then we cannot match those left boots (unless we use a question mark) in Step1.\n\n                    # So Step1 only matches the same color. Therefore, we only consider colors that are in both L_normal and R_normal? Actually, no: if a color is in L_normal and also in R_normal, then we can match.\n\n                    # But wait, what if a color is in L_normal but not in R_normal? Then we cannot match those left boots in Step1.\n\n                    # Similarly, for R_normal.\n\n                    # Therefore, we only consider the colors that are in both.\n\n                    # However, we must match as many as possible. So:\n\n                    #   For each color c that is in both L_normal and R_normal, we do:\n\n                    #       m = min(len(L_normal[c]), len(R_normal[c]))\n                    #       Then, we take the first m from L_normal[c] and the first m from R_normal[c] (but we have to decide the order: the problem doesn't specify, so we can take arbitrarily).\n\n                    #   But note: the problem does not require a particular order of the pairs.\n\n                    #   We can take the smallest indices? Or just the first m in the list.\n\n                    #   However, the problem says: \"Print k — the maximum number of compatible left-right pairs of boots, The following k lines should contain pairs a_j, b_j (1 ≤ a_j, b_j ≤ n). The j-th of these lines should contain the index a_j of the left boot in the j-th pair and index b_j of the right boot in the j-th pair.\"\n\n                    #   The indices are the positions in the input (1-indexed). We are storing 0-indexed indices, so we add 1.\n\n                    #   But note: the input order: the i-th character is the i-th boot. So the index in the string is the boot index.\n\n                    #   We have two strings: l_str and r_str, of length n.\n\n                    #   We are storing the indices as the position in the string (0-indexed).\n\n                    #   Then, we can take the first m from L_normal[c] and the first m from R_normal[c] (which are sorted by the index, because we traversed from 0 to n-1).\n\n                    #   However, we are free to choose any m pairs from the min(L_normal[c], R_normal[c])? Actually, we must use each boot at most once, so we have to assign the pairs without repetition.\n\n                    #   We can simply take the first min(L_normal[c], R_normal[c]) from the left list and the same number from the right list.\n\n                    #   But note: we have to assign the same color. We don't care about the order of the pairs.\n\n                    #   However, we must not use the same boot twice.\n\n                    #   We'll do:\n\n                    #       for color in set(L_normal.keys()) & set(R_normal.keys()):\n                    #           left_list = L_normal[color]\n                    #           right_list = R_normal[color]\n                    #           m = min(len(left_list), len(right_list))\n                    #           # We take the first m from left_list and the first m from right_list? But wait, we have to match the same color, but we can assign arbitrarily.\n\n                    #           # Actually, we can take the first m from left_list and the first m from right_list, but we must match the same color. Since the color is the same, it's okay.\n\n                    #           # But note: we are not forced to take contiguous ones. However, we want to use the smallest indices? The problem doesn't specify.\n\n                    #           # We can take the first m from left_list and the first m from right_list, but we must match the same color. Since the color is the same, we can just take the first m from both.\n\n                    #           # However, we must output the pairs. We can output the pairs in the order of the left boot index? Or we can output the pairs in the order of the right boot index? The problem doesn't specify.\n\n                    #           # Let's take the first m from left_list and the first m from right_list, and then form pairs: the i-th smallest left index with the i-th smallest right index.\n\n                    #           # But wait: we have two lists of indices (from the string traversal). They are in increasing order (because we traverse from 0 to n-1). So we can take the first m from each.\n\n                    #           # Then, we record the pairs.\n\n                    #           for i in range(m):\n                    #               left_index = left_list[i]\n                    #               right_index = right_list[i]\n                    #               pairs_step1.append((left_index, right_index))\n\n                    #           Then, we remove these from the lists? Actually, we don't need to remove because we are going to use the remaining for Step2.\n\n                    #   But wait: we are storing the entire list. We can simply use the entire list for Step1 and then the rest (the unmatched) will be used in Step2.\n\n                    #   However, we must not use the same boot twice.\n\n                    #   We are going to use the entire list for Step1, and then the remaining (the unmatched) for Step2.\n\n                    #   But note: Step2 uses the remaining normal boots (which are the ones that were not used in Step1) and the question marks.\n\n                    #   So we can do:\n\n                    #       matched_normal += m\n                    #       Then, we update L_normal[color] = L_normal[color][m:]   (the remaining left normal boots for color c)\n                    #       and R_normal[color] = R_normal[color][m:]\n\n                    #   But wait: we are going to use the entire list for Step1, and then in Step2 we use the remaining. However, the remaining normal boots (if any) are the ones that were not matched.\n\n                    #   But note: Step2 requires to match the remaining normal boots (that are unmatched) with the question marks. We don't need to know the color for that, because the condition is always satisfied.\n\n                    #   However, we must not use the same boot twice.\n\n                    #   So we do:\n\n                    #       Step1: for each color c in the intersection of keys (both L_normal and R_normal):\n\n                    #           m = min(len(L_normal[c]), len(R_normal[c]))\n                    #           pairs_step1.extend( (left_list[i], right_list[i]) for i in range(m) )\n\n                    #       Then, for each color c in the intersection, we update:\n\n                    #           L_normal[c] = L_normal[c][m:]\n                    #           R_normal[c] = R_normal[c][m:]\n\n                    #   But wait: what if a color c is in L_normal but not in R_normal? Then we don't do anything in Step1 for that color, and the entire L_normal[c] remains.\n\n                    #   Similarly for R_normal.\n\n                    #   Then, Step2:\n\n                    #       total_left_normal_remaining = 0\n                    #       for color in L_normal:\n                    #           total_left_normal_remaining += len(L_normal[color])\n\n                    #       Similarly, total_right_normal_remaining = 0\n                    #       for color in R_normal:\n                    #           total_right_normal_remaining += len(R_normal[color])\n\n                    #       Then, we can use:\n\n                    #           pairs_step2_1 = min(total_left_normal_remaining, len(R_question))\n                    #           pairs_step2_2 = min(total_right_normal_remaining, len(L_question))\n\n                    #       Then, the remaining question marks are:\n\n                    #           remaining_L_question = len(L_question) - pairs_step2_2\n                    #           remaining_R_question = len(R_question) - pairs_step2_1\n\n                    #       Then, pairs_step2_3 = min(remaining_L_question, remaining_R_question)\n\n                    #       Total pairs = len(pairs_step1) + pairs_step2_1 + pairs_step2_2 + pairs_step2_3\n\n                    #   But wait: Step2_1 and Step2_2 are not independent? Actually, we must assign the question marks to the remaining normal boots.\n\n                    #   However, we have to output the pairs.\n\n                    #   How to assign the pairs for Step2?\n\n                    #   Step2 has three parts:\n\n                    #       Part A: Match the remaining left normal boots (that were not matched in Step1) with the right_question.\n\n                    #           We have a list of left_normal_remaining (the indices) and a list of right_question (the indices). We can form min(total_left_normal_remaining, len(R_question)) pairs.\n\n                    #       Part B: Match the remaining right normal boots with the left_question.\n\n                    #           We have a list of right_normal_remaining (indices) and a list of left_question (indices). We can form min(total_right_normal_remaining, len(L_question)) pairs.\n\n                    #       Part C: Match the remaining left_question and right_question arbitrarily.\n\n                    #   However, we must not use the same boot twice.\n\n                    #   We have:\n\n                    #       For Part A: We need to assign the remaining left_normal boots (each of which is a normal boot) to a right_question boot. We can choose any right_question boot that hasn't been used.\n\n                    #       Similarly for Part B.\n\n                    #   But note: the same right_question boot cannot be used in both Part A and Part C.\n\n                    #   So we must do:\n\n                    #       Step2:\n\n                    #         Let A = the list of left_normal_remaining indices (all indices from L_normal.values() flattened)\n                    #         Let B = the list of right_normal_remaining indices (all indices from R_normal.values() flattened)\n                    #         Let C = L_question (list of indices)\n                    #         Let D = R_question (list of indices)\n\n                    #         Then, we can:\n\n                    #           Use the first min(len(A), len(D)) of A and the first min(len(A), len(D)) of D (but we must assign arbitrarily, but we don't care about the order).\n\n                    #         However, we must output the pairs. We can output the pairs in any order.\n\n                    #   But note: we have to avoid using the same boot twice.\n\n                    #   We can do:\n\n                    #         Step2A: Form pairs from A and D: we take the first min(len(A), len(D)) pairs by arbitrarily matching (we can sort A and D and then take the first min(len(A), len(D)) from A and the first min(len(A), len(D)) from D, and then form pairs).\n\n                    #         Step2B: Form pairs from B and C: we take the first min(len(B), len(C)) pairs from B and C.\n\n                    #         Then, Step2C: From the remaining C (if any) and D (if any) (after removing the ones used in Step2A and Step2B) form min(|remaining_C|, |remaining_D|) pairs.\n\n                    #   However, wait: the lists A and B are the remaining normal boots (from Step1). We have already updated L_normal and R_normal in Step1. So we can collect:\n\n                    #         A = []\n                    #         for color in L_normal:\n                    #             A.extend(L_normal[color])\n\n                    #         B = []\n                    #         for color in R_normal:\n                    #             B.extend(R_normal[color])\n\n                    #         Then, Step2A: We use some of D (the R_question) to match A.\n\n                    #         Step2B: We use some of C (the L_question) to match B.\n\n                    #         Then, Step2C: We use the remaining C and D to form pairs.\n\n                    #   But note: the total available for Step2A is len(D) and for Step2B is len(C). And the number of pairs in Step2A is min(len(A), len(D)), and Step2B is min(len(B), len(C)).\n\n                    #   Then, the remaining D is len(D) - min(len(A), len(D)) and remaining C is len(C) - min(len(B), len(C)).\n\n                    #   Then, Step2C: min(remaining_C, remaining_D)\n\n                    #   However, we must assign the pairs without repetition.\n\n                    #   But note: we are not forced to use the same set of question marks for Step2A and Step2B. Actually, we have:\n\n                    #         Step2A uses min(len(A), len(D)) from D.\n                    #         Step2B uses min(len(B), len(C)) from C.\n\n                    #         Then, Step2C uses min(len(C) - min(len(B),len(C)), len(D) - min(len(A),len(D)))",
    "response": "\nTo solve this problem, we need to maximize the number of compatible pairs of boots, where each pair consists of one left boot and one right boot with compatible colors. The compatibility is defined such that two specific colors must be identical, while an indefinite color ('?') can match any color.\n\n### Approach\n1. **Problem Analysis**: The problem requires matching left and right boots based on their colors. The key observation is that '?' in either boot can match any color, including '?'. The goal is to maximize the number of such pairs without reusing any boot.\n\n2. **Intuition**: The solution involves two main steps:\n   - **Step 1**: Match boots with specific colors (non '?') by pairing them if they have the same color. This ensures we utilize all possible exact matches first.\n   - **Step 2**: Use the remaining '?' boots to match the unmatched boots from Step 1. Additionally, match any leftover '?' boots with each other.\n\n3. **Algorithm Selection**:\n   - **Step 1**: For each color, count the number of left and right boots. Pair the minimum of these counts for each color.\n   - **Step 2**: Calculate the remaining normal boots (non '?') that couldn't be paired in Step 1. These can be matched with '?' boots from the opposite side. Finally, match any remaining '?' boots with each other.\n\n4. **Complexity Analysis**: The algorithm processes each boot once during the initial counting and then performs linear scans to form pairs. The overall complexity is O(n), which is efficient for the given constraints (n ≤ 150000).\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0].strip())\n    l_str = data[1].strip()\n    r_str = data[2].strip()\n    \n    L_normal = {}\n    L_question = []\n    for i, char in enumerate(l_str):\n        if char == '?':\n            L_question.append(i)\n        else:\n            if char not in L_normal:\n                L_normal[char] = []\n            L_normal[char].append(i)\n            \n    R_normal = {}\n    R_question = []\n    for i, char in enumerate(r_str):\n        if char == '?':\n            R_question.append(i)\n        else:\n            if char not in R_normal:\n                R_normal[char] = []\n            R_normal[char].append(i)\n            \n    total_pairs = 0\n    result_pairs = []\n    \n    common_colors = set(L_normal.keys()) & set(R_normal.keys())\n    for color in common_colors:\n        left_list = L_normal[color]\n        right_list = R_normal[color]\n        m = min(len(left_list), len(right_list))\n        total_pairs += m\n        for i in range(m):\n            result_pairs.append((left_list[i], right_list[i]))\n            \n    for color in list(L_normal.keys()):\n        L_normal[color] = L_normal[color][min(len(L_normal[color]), len(R_normal.get(color, []))):]\n        \n    for color in list(R_normal.keys()):\n        R_normal[color] = R_normal[color][min(len(R_normal[color]), len(L_normal.get(color, []))):]\n        \n    A = []\n    for color in L_normal:\n        A.extend(L_normal[color])\n        \n    B = []\n    for color in R_normal:\n        B.extend(R_normal[color])\n        \n    partA = min(len(A), len(R_question))\n    partB = min(len(B), len(L_question))\n    \n    remaining_R_question = len(R_question) - partA\n    remaining_L_question = len(L_question) - partB\n    \n    partC = min(remaining_R_question, remaining_L_question)\n    \n    total_pairs += partA + partB + partC\n    \n    for i in range(partA):\n        a_index = A[i]\n        b_index = R_question[i]\n        result_pairs.append((a_index, b_index))\n        \n    for i in range(partB):\n        a_index = L_question[i]\n        b_index = B[i]\n        result_pairs.append((a_index, b_index))\n        \n    for i in range(partC):\n        a_index = L_question[partB + i]\n        b_index = R_question[partA + i]\n        result_pairs.append((a_index, b_index))\n        \n    print(total_pairs)\n    for pair in result_pairs:\n        print(f\"{pair[0]+1} {pair[1]+1}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of the number of boots and two strings representing the colors of left and right boots.\n2. **Categorizing Boots**: Boots are categorized into those with specific colors (non '?') and those with '?'.\n3. **Step 1 Matching**: For each color present in both left and right boots, the minimum count of boots is used to form pairs. These pairs are recorded.\n4. **Step 2 Matching**: The remaining boots (those not paired in Step 1) are matched with '?' boots from the opposite side. Any leftover '?' boots are paired together.\n5. **Output**: The total number of pairs is printed, followed by each pair's indices (converted to 1-based indexing as required).\n\nThis approach efficiently maximizes the number of compatible pairs by leveraging exact matches first and then utilizing flexible '?' matches to cover any remaining boots.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0].strip())\n    l_str = data[1].strip()\n    r_str = data[2].strip()\n    \n    L_normal = {}\n    L_question = []\n    for i, char in enumerate(l_str):\n        if char == '?':\n            L_question.append(i)\n        else:\n            if char not in L_normal:\n                L_normal[char] = []\n            L_normal[char].append(i)\n            \n    R_normal = {}\n    R_question = []\n    for i, char in enumerate(r_str):\n        if char == '?':\n            R_question.append(i)\n        else:\n            if char not in R_normal:\n                R_normal[char] = []\n            R_normal[char].append(i)\n            \n    total_pairs = 0\n    result_pairs = []\n    \n    common_colors = set(L_normal.keys()) & set(R_normal.keys())\n    for color in common_colors:\n        left_list = L_normal[color]\n        right_list = R_normal[color]\n        m = min(len(left_list), len(right_list))\n        total_pairs += m\n        for i in range(m):\n            result_pairs.append((left_list[i], right_list[i]))\n            \n    for color in list(L_normal.keys()):\n        L_normal[color] = L_normal[color][min(len(L_normal[color]), len(R_normal.get(color, []))):]\n        \n    for color in list(R_normal.keys()):\n        R_normal[color] = R_normal[color][min(len(R_normal[color]), len(L_normal.get(color, []))):]\n        \n    A = []\n    for color in L_normal:\n        A.extend(L_normal[color])\n        \n    B = []\n    for color in R_normal:\n        B.extend(R_normal[color])\n        \n    partA = min(len(A), len(R_question))\n    partB = min(len(B), len(L_question))\n    \n    remaining_R_question = len(R_question) - partA\n    remaining_L_question = len(L_question) - partB\n    \n    partC = min(remaining_R_question, remaining_L_question)\n    \n    total_pairs += partA + partB + partC\n    \n    for i in range(partA):\n        a_index = A[i]\n        b_index = R_question[i]\n        result_pairs.append((a_index, b_index))\n        \n    for i in range(partB):\n        a_index = L_question[i]\n        b_index = B[i]\n        result_pairs.append((a_index, b_index))\n        \n    for i in range(partC):\n        a_index = L_question[partB + i]\n        b_index = R_question[partA + i]\n        result_pairs.append((a_index, b_index))\n        \n    print(total_pairs)\n    for pair in result_pairs:\n        print(f\"{pair[0]+1} {pair[1]+1}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 794,
        "completion_token_count": 1133,
        "thoughts_token_count": 8191
    }
}