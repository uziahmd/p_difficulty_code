{
    "start": 1758296506.5194654,
    "end": 1758299454.0270455,
    "start-formatted": "2025-09-20 00:41 KST",
    "end-formatted": "2025-09-20 01:30 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized.\n\n Note: LCM(x, y) = (x * y) / GCD(x, y)\n\n Let d = (a+k) - (b+k) = a - b (if a >= b, then positive; if a < b, then negative). Actually, note that k is added to both, so the difference between (a+k) and (b+k) is fixed: d = a - b.\n\n Alternatively, we can consider:\n   Let x = a + k, y = b + k, then x - y = a - b = d (constant).\n\n Then, note that LCM(x, y) = (x * y) / GCD(x, y) = ((x+y)*(x-y)) / GCD(x,y) doesn't hold directly. However, we know that GCD(x, y) must divide (x-y) = d.\n\n So, let g be a divisor of |d| (unless d=0). Then, note that we can write:\n   x = g * m, y = g * n, with GCD(m,n)=1, and then x-y = g*(m-n) = d.\n\n But note: if d=0 (i.e., a==b), then we have x=y. Then LCM(x,y) = x = a+k, and we want to minimize that. The minimal k is 0, because then x=y=a, and increasing k will only increase the value.\n\n For d != 0, we have that the GCD(x,y) must divide d. Therefore, the possible values for GCD(x,y) are divisors of |d|.\n\n However, note that k can be chosen arbitrarily. We are looking for k such that (a+k) and (b+k) have a large GCD (because LCM = (a+k)*(b+k)/GCD(a+k,b+k)). The LCM is minimized when the GCD is as large as possible? Not exactly: because the product (a+k)*(b+k) also increases as k increases. But note: we are adding k to both.\n\n Alternate approach:\n\n Let d = a - b (could be positive or negative). Without loss of generality, assume a >= b, then d>=0. If a < b, then set d = b - a and swap? But note: we can consider absolute divisors.\n\n However, note that the problem is symmetric in the sense that the LCM is the same for (a+k, b+k) as for (b+k, a+k). So we can assume without loss of generality that a >= b.\n\n Steps:\n\n 1. If a == b, then answer is 0.\n\n 2. Otherwise, let d = |a - b|. Then, the GCD of (a+k, b+k) must divide d. Therefore, we can consider all divisors of d (the absolute difference). But note: the divisor must be positive.\n\n How does k relate to the divisor? Let g be a divisor of d. Then, we require that g divides (a+k) and (b+k). But note that (a+k) - (b+k) = d, so g divides d (which it does by assumption) and also g divides (a+k) and (b+k). \n\n Then, we can set up the condition: \n   (a+k) mod g = 0 and (b+k) mod g = 0.\n\n Since (a+k) - (b+k) = d, and g divides d, then if one of them is divisible by g, the other automatically is? Actually, no: but note that (a+k) ≡ (b+k) mod g, so they are congruent. Therefore, we require that k ≡ (-a) mod g and k ≡ (-b) mod g. But since a ≡ b mod g? Not necessarily, unless g divides (a-b)=d, which it does. Actually, we have a ≡ b mod g because g divides d = a-b. Therefore, the condition for k is that k ≡ (-a) mod g, and then automatically k ≡ (-b) mod g.\n\n So, for a divisor g of d, we can compute the smallest non-negative k that satisfies:\n   k ≡ (-a) mod g   => k = (g - a % g) % g   [if we define modulo operation for negative numbers appropriately]\n\n However, note: we can also consider negative k? No, k>=0.\n\n But wait: what if we consider divisors of d that are negative? We don't, because divisors are positive.\n\n However, note: the divisor g must",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. The solution involves leveraging mathematical insights about divisors and modular arithmetic to efficiently determine the optimal \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) is constant (\\( a - b \\)). The LCM of two numbers \\( x \\) and \\( y \\) is given by \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\). To minimize the LCM, we need to maximize the GCD of \\( x \\) and \\( y \\), since the product \\( x \\times y \\) increases with \\( k \\).\n\n2. **Insight**: The GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of the absolute difference \\( |a - b| \\). Therefore, we can consider all divisors of \\( |a - b| \\) to find potential candidates for the GCD.\n\n3. **Algorithm Selection**:\n   - If \\( a \\) equals \\( b \\), the answer is trivially 0.\n   - For \\( a \\neq b \\), compute the absolute difference \\( d = |a - b| \\).\n   - Find all divisors of \\( d \\). For each divisor \\( g \\), compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) can be derived using modular arithmetic: \\( k = (g - (a \\% g)) \\% g \\).\n   - Among all computed \\( k \\) values, select the one that minimizes the LCM. If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The time complexity is dominated by the factorization of \\( d \\), which in the worst case (when \\( d \\) is a product of two large primes) is \\( O(\\sqrt{d}) \\). Given the constraints \\( 1 \\leq a, b \\leq 10^9 \\), this approach is feasible as \\( \\sqrt{d} \\) can be up to \\( 10^4.5 \\), which is manageable.\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    best_k = None\n    best_lcm = None\n\n    for g in divisors:\n        rem_a = a % g\n        k_candidate = (g - rem_a) % g\n        x = a + k_candidate\n        y = b + k_candidate\n        current_gcd = math.gcd(x, y)\n        lcm_val = (x * y) // current_gcd\n\n        if best_lcm is None or lcm_val < best_lcm or (lcm_val == best_lcm and k_candidate < best_k):\n            best_lcm = lcm_val\n            best_k = k_candidate\n\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Function `get_divisors`**: This helper function computes all divisors of a given number \\( n \\) by checking divisibility up to \\( \\sqrt{n} \\). Each divisor and its complement (i.e., \\( n/i \\)) are added to a set to avoid duplicates.\n\n2. **Main Logic**:\n   - **Input Handling**: Reads two integers \\( a \\) and \\( b \\).\n   - **Trivial Case**: If \\( a \\) equals \\( b \\), prints 0 immediately.\n   - **Difference Calculation**: Computes the absolute difference \\( d \\) between \\( a \\) and \\( b \\).\n   - **Divisor Processing**: For each divisor \\( g \\) of \\( d \\), calculates the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\) using modular arithmetic.\n   - **LCM Calculation**: For each candidate \\( k \\), computes the LCM of \\( a + k \\) and \\( b + k \\). Tracks the minimal LCM and the corresponding smallest \\( k \\).\n\n3. **Output**: Prints the smallest \\( k \\) that minimizes the LCM, ensuring correctness even when multiple \\( k \\) values yield the same minimal LCM.\n\nThis approach efficiently narrows down the problem to considering only relevant divisors, leveraging mathematical properties to avoid brute-force checks and ensure optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    best_k = None\n    best_lcm = None\n\n    for g in divisors:\n        rem_a = a % g\n        k_candidate = (g - rem_a) % g\n        x = a + k_candidate\n        y = b + k_candidate\n        current_gcd = math.gcd(x, y)\n        lcm_val = (x * y) // current_gcd\n\n        if best_lcm is None or lcm_val < best_lcm or (lcm_val == best_lcm and k_candidate < best_k):\n            best_lcm = lcm_val\n            best_k = k_candidate\n\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1091,
        "thoughts_token_count": 1023
    }
}