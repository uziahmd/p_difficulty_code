{
    "start": 1758089244.9747887,
    "end": 1758091580.308498,
    "start-formatted": "2025-09-17 15:07 KST",
    "end-formatted": "2025-09-17 15:46 KST",
    "gpu": 2,
    "pid": 2,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Valera and X\n\nValera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter \"X\". Valera's teacher thinks that the letters on the piece of paper form an \"X\", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.\n\n## Input\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\n## Output\nPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\n## Example\n### Input\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n### Output\n['NO', 'YES', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are given an odd integer n, then n lines of n characters.\n Conditions for \"YES\":\n 1. On both diagonals (the main diagonal and the anti-diagonal) all letters are the same.\n 2. All other squares (not on the diagonals) contain the same letter that is different from the diagonal letter.\n\n Steps:\n - Read n.\n - Read the grid.\n\n Let the two diagonals be:\n   Main diagonal: positions (i, i) for i from 0 to n-1.\n   Anti-diagonal: positions (i, n-1-i) for i from 0 to n-1.\n\n Condition 1: Every character on the main diagonal must be the same, and every character on the anti-diagonal must be the same.\n Condition 2: The letter on the diagonals must be the same? Actually, note: the problem says \"on both diagonals\" (so two sets) but they might be two different letters? \n However, the example outputs: \n   Input: 3x3 with 'w','s','w' in first row, 's','w','s' in second, 'w','s','w' in third -> YES.\n But wait, the example input is: \n      3\n      wsw\n      sws\n      wsw\n\n In this example, the main diagonal is ['w', 'w', 'w'] and the anti-diagonal is ['w', 'w', 'w'].\n\n However, consider if the diagonals had two different letters? The problem states:\n   \"on both diagonals of the square paper all letters are the same\"\n\n So the entire main diagonal must be one letter, say 'X', and the entire anti-diagonal must be one letter, say 'Y'. \n Then condition 2: all other squares must be the same letter, say 'Z', and 'Z' must be different from both 'X' and 'Y'.\n\n But note: what if the two diagonals have the same letter? Then condition 1 is satisfied (each diagonal has the same letter). Then condition 2 requires that the non-diagonal letters are the same and different from that letter.\n\n However, there is a possibility: what if the entire grid is filled with the same letter? Then condition 1: the diagonals are the same (each being that letter). Condition 2: the non-diagonal squares are that same letter, which is not different. So it fails.\n\n Therefore, we can break down:\n\n Step 1: Check the two diagonals.\n   Let diag1 = [grid[i][i] for i in range(n)]\n   Let diag2 = [grid[i][n-1-i] for i in range(n)]\n\n   Condition 1a: All letters in diag1 are the same.\n   Condition 1b: All letters in diag2 are the same.\n\n Step 2: Let the letter for diag1 be c1 and for diag2 be c2. Note: c1 and c2 could be the same or different.\n\n Step 3: For the rest of the cells (non-diagonal), we need to check:\n   Condition 2a: All non-diagonal cells have the same letter, say c.\n   Condition 2b: This letter c must be different from both c1 and c2.\n\n However, note: what if the two diagonals have different letters? Then condition 2b requires that c is different from both.\n\n But wait, what if the grid is such that the diagonals are one letter and the rest are another? Then we have two distinct letters. But what if the two diagonals are the same letter and the rest is that same letter? Then condition 2b fails because the rest must be different.\n\n Actually, the problem states: \"all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals\"\n\n So the letter for the non-diagonals must be different from the letter(s) on the diagonals. \n\n However, note: the diagonals might have two different letters (c1 and c2). Then the non-diagonals must be a third letter? Or can the non-diagonals be any one letter that is different from both?\n\n Example: \n   If the diagonals are made of two different letters, then the non-diagonals must be a single letter that is not equal to c1 and not equal to c2.\n\n But what if the two diagonals are the same letter? Then the non-diagonals must be a letter different from that one.\n\n However, the problem does not require that the two diagonals have the same letter. It only requires that each diagonal is uniform.\n\n Therefore, the conditions are:\n\n 1. The main diagonal is uniform (say with letter d1).\n 2. The anti-diagonal is uniform (say with letter d2).\n 3. The non-diagonal cells are all the same letter, say d3, and d3 must not be equal to d1 and not equal to d2.\n\n But note: what if d1 and d2 are different? Then d3 must be different from both. What if d1 and d2 are the same? Then d3 must be different from d1 (which is also d2).\n\n However, wait: there's a catch. The problem does not specify that the two diagonals must be the same letter. So if they are different, then the non-diagonals must be a letter that is not d1 and not d2. But note: what if the non-diagonals are a letter that is the same as d1 or d2? Then condition 2b fails.\n\n Therefore, we can do:\n\n Let d1 = the letter on the main diagonal (we know they are all the same)\n Let d2 = the letter on the anti-diagonal (all the same)\n\n Then, let d3 be the letter that should appear in the non-diagonals.\n\n How to determine d3?\n   Condition 3: All non-diagonal cells must be the same and that same letter must be different from d1 and d2.\n\n However, note: the problem says \"all other squares ... contain the same letter\". So we must check that every non-diagonal cell is the same.\n\n Steps:\n\n 1. Check that all the main diagonal cells are the same. If not, output \"NO\".\n 2. Check that all the anti-diagonal cells are the same. If not, output \"NO\".\n\n 3. Now, let d1 = grid[0][0] (if n>=1) and d2 = grid[0][n-1]. But note: we must use the entire diagonal to verify.\n\n Alternatively, we can set:\n   d1 = grid[0][0]\n   Then for i in range(n): if grid[i][i] != d1 -> NO.\n\n   Similarly, d2 = grid[0][n-1]\n   Then for i in range(n): if grid[i][n-1-i] != d2 -> NO.\n\n 4. Then, we need to check the non-diagonal cells.\n\n We can iterate over the grid and for each cell (i, j):\n   If (i == j) or (i+j == n-1): skip (because these are the two diagonals)\n   Otherwise, check that the letter is the same as some base letter (say base) and that base is not d1 and not d2.\n\n But note: we don't know base yet. So we can:\n\n   - First, collect all non-diagonal cells and check they are the same.\n\n   Alternatively, we can:\n     base = None\n     for i in range(n):\n         for j in range(n):\n             if i == j or i+j == n-1:\n                 continue\n             if base is None:\n                 base = grid[i][j]\n             else:\n                 if grid[i][j] != base:\n                     print(\"NO\")\n                     exit(0)\n\n     Then, check that base is not equal to d1 and not equal to d2.\n\n However, wait: what if the grid has non-diagonal cells that are not the same? Then we break.\n\n But note: what if the grid is such that the diagonals are uniform and the non-diagonals are uniform but the same as one of the diagonals? Then condition 2b fails.\n\n However, we must also consider: what if the entire grid is the same letter? Then:\n   Diagonals: uniform (all the same letter, say 'x')\n   Non-diagonals: uniform (all the same letter, which is 'x') -> but condition 2b requires that the non-diagonals are different from the diagonals. So it fails.\n\n Implementation:\n\n   n = int(input().strip())\n   grid = []\n   for i in range(n):\n        grid.append(input().strip())\n\n   # Step 1: Check main diagonal\n   d1 = grid[0][0]\n   for i in range(n):\n        if grid[i][i] != d1:\n            print(\"NO\")\n            exit(0)\n\n   # Step 2: Check anti-diagonal\n   d2 = grid[0][n-1]\n   for i in range(n):\n        if grid[i][n-1-i] != d2:\n            print(\"NO\")\n            exit(0)\n\n   # Step 3: Check non-diagonal cells\n   base_char = None\n   valid_base = True\n   for i in range(n):\n        for j in range(n):\n            if i == j or i+j == n-1:\n                continue\n            if base_char is None:\n                base_char = grid[i][j]\n            else:\n                if grid[i][j] != base_char:\n                    valid_base = False\n                    break\n        if not valid_base:\n            break\n\n   if not valid_base:\n        print(\"NO\")\n        exit(0)\n\n   # Now, check that base_char is not equal to d1 and not equal to d2.\n   if base_char == d1 or base_char == d2:\n        print(\"NO\")\n   else:\n        print(\"YES\")\n\n But wait: what if the grid has no non-diagonal cells? \n   However, n>=3 (odd and at least 3). The smallest grid is 3x3, so there are non-diagonal cells (because total cells 9, diagonals 3+3-1=5, so non-diagonal 4). So base_char will be set.\n\n However, there's an issue: what if the grid has two different letters in the non-diagonals? We break at the first inconsistency.\n\n But there's another issue: the above base_char is set arbitrarily from the first non-diagonal cell. Then we compare the rest. And then we check that base_char is not d1 and not d2.\n\n However, consider: what if the two diagonals are different? Then we require base_char to be different from both. But what if the non-diagonals are two different letters? Then we break in the inner loop.\n\n But note: the problem does not require the two diagonals to be the same. So d1 and d2 could be different. Then base_char must be a third letter.\n\n However, there's a catch: what if the grid is such that the main diagonal is 'a', the anti-diagonal is 'b', and the non-diagonals are 'a'? Then base_char is 'a', which is the same as d1 -> fails.\n\n Similarly, if non-diagonals are 'b', then same as d2 -> fails.\n\n And if non-diagonals are a mix of two letters (not the same) then we break in the inner loop.\n\n But note: we break the inner loop as soon as we find a non-base_char, so we don't even check the rest.\n\n However, there is one more possibility: what if the grid has non-diagonal cells that are all the same, but that same letter is one of the diagonals? Then we output \"NO\", which is correct.\n\n But wait: what if the grid is 3x3 and the non-diagonals are the same, and the diagonals are two different letters? Then we must check that the non-diagonals are not equal to either of the diagonals.\n\n Example: \n   Input: \n        3\n        www\n        wwww\n        www\n\n   Actually, let me write a proper example for 3x3:\n\n   Example 1: \n        www\n        www\n        www\n\n   This grid: \n        main diagonal: 'w','w','w' -> d1='w'\n        anti-diagonal: 'w','w','w' -> d2='w'\n        non-diagonals: all 'w' -> then base_char='w' -> which is same as d1 and d2 -> NO.\n\n   Example 2: \n        xoo\n        oox\n        oxo\n\n   Actually, wait, let me use 3x3:\n\n   Example 3x3:\n        x . .\n        . x .\n        . . x\n\n   But wait, the example input provided was:\n        Input: 3\n               wsw\n               sws\n               wsw\n\n   This grid:\n        row0: 'w','s','w'\n        row1: 's','w','s'\n        row2: 'w','s','w'\n\n   Main diagonal: [grid[0][0]='w', grid[1][1]='w', grid[2][2]='w'] -> d1='w'\n   Anti-diagonal: [grid[0][2]='w', grid[1][1]='w', grid[2][0]='w'] -> d2='w'\n\n   Now, non-diagonals: \n        (0,1): 's'\n        (1,0): 's'\n        (1,2): 's'\n        (2,1): 's'\n\n   So base_char='s', which is different from 'w' -> YES.\n\n   Another example: \n        Input: 3\n               xxx\n               xyy\n               xxx\n\n   Main diagonal: ['x','y','x'] -> not uniform -> NO.\n\n   Another example: \n        Input: 3\n               xyy\n               yxx\n               xyy\n\n   Main diagonal: ['x','x','y'] -> not uniform -> NO.\n\n   But wait, the example input also includes: \n        ['3\\nxpx\\npxp\\nxpe']\n\n   Let me break down the third example:\n\n        grid = [\n            \"xpx\",\n            \"pxp\",\n            \"xpe\"\n        ]\n\n   Main diagonal: [grid[0][0]='x', grid[1][1]='x', grid[2][2]='e'] -> not uniform (because 'x','x','e') -> fails at last element.\n\n   So we output \"NO\", which matches.\n\n   However, note: the example input is given as a list of strings, but in the example input we have:\n\n        Input: ['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n   And the expected output is ['NO', 'YES', 'NO'].\n\n   Our program for the first string (n=5) would check:\n\n        Main diagonal: \n          row0: 'x' (at col0)\n          row1: 'o' (at col1) -> wait, the second row is \"oxoxo\": \n          Actually, the grid for the first example is:\n\n          5\n          xooox\n          oxoxo\n          soxoo\n          oxoxo\n          xooox\n\n        Main diagonal: \n          row0: index0 -> 'x'\n          row1: index1 -> 'o'\n          row2: index2 -> 'x' (from \"soxoo\": the third character is 'x')\n          row3: index3 -> 'o' (from \"oxoxo\": fourth character is 'o')\n          row4: index4 -> 'x'\n\n        So the main diagonal is ['x','o','x','o','x'] -> not uniform. So we output \"NO\".\n\n   This matches.\n\n   But wait: the example input also says the first one is \"NO\", so we are good.\n\n   However, note: the example input is given as a list of three strings, but in reality we are reading from stdin. The example input is provided in the problem statement.\n\n   There is one more corner: what if n=1? But n>=3, so we don't have to worry.\n\n   But wait: the problem says n is odd and between 3 and 299.\n\n   However, there is a potential issue: when n=3, the center element is part of both diagonals. In our code, we skip the center element because (i==j) and (i+j==n-1) for the center? \n        For center (i=1, j=1): \n            i==j -> yes, so skipped.\n            i+j = 1+1 = 2, and n-1=2 -> so also skipped.\n\n   That's correct, because the center is shared by both diagonals.\n\n   But note: the condition for the anti-diagonal: for i=1, j= n-1-1 = 3-1-1 = 1 -> so (1,1) is included in the anti-diagonal too.\n\n   So we skip (1,1) twice, which is okay.\n\n   However, what if the two diagonals have different center letters? But wait, the center is the same point. So the center must be the same letter for both diagonals. \n\n   Actually, the problem does not say that the two diagonals have to be the same letter. It says \"on both diagonals\" (each uniformly). So the main diagonal must be uniform and the anti-diagonal must be uniform. \n\n   But the center is part of both. Therefore, the center must be the same for both diagonals? \n\n   Yes, because the center is a common element. So d1 (the main diagonal) must be the same as d2 (the anti-diagonal) at the center. \n\n   Therefore, if the main diagonal is uniform and the anti-diagonal is uniform, then the center must be the same for both. \n\n   However, note: what if the main diagonal is uniform (say 'a') and the anti-diagonal is uniform (say 'b') and the center is the same for both? Then the center must be both 'a' and 'b'. So if 'a' != 'b', then the center would have to be both, which is impossible.\n\n   Therefore, the two diagonals must have the same letter at the center. But since the center is the same element, then the entire main diagonal must be the same and the entire anti-diagonal must be the same, and the center is the only element that is in both. \n\n   So the two diagonals must be the same letter? \n\n   Actually, no: consider the entire anti-diagonal: the center is the same as the main diagonal's center. But the rest of the anti-diagonal must be the same as the center. Similarly, the rest of the main diagonal must be the same as the center.\n\n   Therefore, the entire main diagonal is one letter, and the entire anti-diagonal is one letter, and the center is the same element, so the two letters must be the same.\n\n   However, wait: the problem does not require the two diagonals to be the same letter. But the center is in both. So if the main diagonal is uniform (all 'a') and the anti-diagonal is uniform (all 'b'), then the center must be 'a' (from the main diagonal) and also 'b' (from the anti-diagonal). So 'a' must equal 'b'.\n\n   Therefore, the two diagonals must be the same letter.\n\n   Then we can simplify:\n\n   Condition 1: The entire main diagonal is the same letter (d) and the entire anti-diagonal is the same letter (d) [because the center forces it].\n\n   Then condition 2: The non-diagonal cells are the same letter (say e) and e != d.\n\n   So we can change our approach:\n\n   Step 1: Check the main diagonal: all same letter, say d.\n   Step 2: Check the anti-diagonal: all same letter, and must be d (because the center is already d). If we find a letter that is not d, then NO.\n\n   Then step 3: Check non-diagonals: all same and different from d.\n\n   Alternatively, we can combine:\n\n   After step 1, we know the main diagonal is uniform with letter d.\n\n   Then for the anti-diagonal, we can set d2 = grid[0][n-1] (the top-right) and then traverse the anti-diagonal. But if we find an element that is not d, then we break. But note: the center must be d (from the main diagonal). So if the anti-diagonal is uniform and the center is d, then the entire anti-diagonal must be d.\n\n   Therefore, we can do:\n\n        d1 = grid[0][0]\n        for i in range(n):\n            if grid[i][i] != d1:\n                print(\"NO\")\n                exit(0)\n\n        # Now, check anti-diagonal: must be the same d1?\n        # Actually, the top-right is grid[0][n-1]. But the center must be d1. However, the anti-diagonal is defined as (i, n-1-i). We can check the anti-diagonal against d1.\n\n        for i in range(n):\n            if grid[i][n-1-i] != d1:\n                print(\"NO\")\n                exit(0)\n\n   Then proceed to check non-diagonals.\n\n   But wait, what if the main diagonal is uniform but the anti-diagonal is uniform with a different letter? Then we break at the anti-diagonal check because the center is d1 (from the main diagonal) and the anti-diagonal's center must be d1, but if the anti-diagonal is uniform with a different letter, then the center (which is the same) would be that different letter. So we break.\n\n   Therefore, we can do:\n\n        d1 = grid[0][0]\n        # Check main diagonal\n        for i in range(n):\n            if grid[i][i] != d1:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal\n        for i in range(n):\n            if grid[i][n-1-i] != d1:\n                print(\"NO\")\n                exit(0)\n\n   Then, we check the non-diagonals for a uniform letter (say base) and base != d1.\n\n   However, wait: what if the main diagonal is uniform and the anti-diagonal is uniform, but they are different? Then we break at the anti-diagonal check because the center must be d1, but the anti-diagonal is a different letter. So we don't need to separately check the anti-diagonal being uniform, because if the anti-diagonal is uniform and the center is d1, then the entire anti-diagonal must be d1.\n\n   But note: the anti-diagonal's top element is grid[0][n-1]. This might not be the same as d1. For example, if the grid is:\n\n        a b c\n        d e f\n        g h i\n\n   Then the anti-diagonal is [c, e, g]. We require that c==e==g. But the main diagonal requires a==e==i. Then we require a==e==i and c==e==g. So the center must be the same for both, but the top and bottom of the anti-diagonal must be the same as the center.\n\n   However, we are checking the anti-diagonal against d1 (which is the main diagonal's letter). So if the main diagonal is 'a', then we require the anti-diagonal to be 'a' as well.\n\n   Therefore, the two diagonals must be the same letter.\n\n   So the code becomes:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Check main diagonal\n        d = grid[0][0]\n        for i in range(n):\n            if grid[i][i] != d:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal: must be the same letter d\n        for i in range(n):\n            if grid[i][n-1-i] != d:\n                print(\"NO\")\n                exit(0)\n\n        # Now, check non-diagonal cells\n        base_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if base_char is None:\n                    base_char = grid[i][j]\n                else:\n                    if grid[i][j] != base_char:\n                        print(\"NO\")\n                        exit(0)\n\n        # Check that base_char is not d\n        if base_char == d:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n   Let's test with the provided examples.\n\n   Example 1: \n        Input: 3\\nwsw\\nsws\\nwsw\n\n        Main diagonal: \n            [0][0] = 'w', [1][1]='w', [2][2]='w' -> ok, d='w'\n        Anti-diagonal: \n            [0][2]='w', [1][1]='w', [2][0]='w' -> ok.\n\n        Then non-diagonals: \n            (0,1): 's', (1,0):'s', (1,2):'s', (2,1):'s' -> base_char='s'\n            Then check: 's' != 'w' -> YES.\n\n   Example 2: \n        Input: 3\\nxpx\\npxp\\nxpe\n\n        Main diagonal: \n            [0][0]='x', [1][1]='x', [2][2]='e' -> at [2][2] we get 'e' which is not 'x'. So we output \"NO\".\n\n   Example 3: \n        Input: 5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox\n\n        Main diagonal: \n            [0][0]='x', [1][1]='o', -> fails. Output \"NO\".\n\n   But wait, the example input also includes a 5x5 example. However, the example input is given as:\n\n        ['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', ...]\n\n   And the expected output is \"NO\", which we get.\n\n   However, wait: the example input provided in the problem statement is:\n\n        Input: \n            5\n            xooox\n            oxoxo\n            soxoo\n            oxoxo\n            xooox\n\n        Expected output: \"NO\"\n\n   But note: the example input also includes:\n\n        Input: 3\n               wsw\n               sws\n               wsw\n\n        Expected output: \"YES\"\n\n        Input: 3\n               xpx\n               pxp\n               xpe\n\n        Expected output: \"NO\"\n\n   So our code produces the expected outputs.\n\n   However, wait: what if the main diagonal is uniform and the anti-diagonal is uniform, but the anti-diagonal is uniform with a different letter than the main diagonal? Then we break in the anti-diagonal check.\n\n   But note: the center is shared. So if the main diagonal is 'a', then the center is 'a'. The anti-diagonal must be uniform, and the center is 'a', so the entire anti-diagonal must be 'a'. Therefore, the two diagonals must be the same.\n\n   Therefore, we are safe.\n\n   However, let's test with a grid where the main diagonal is 'a', the anti-diagonal is 'a', and non-diagonals are 'b':\n\n        Example: 3x3\n        a b a\n        b a b\n        a b a\n\n        Main diagonal: [a, a, a] -> ok.\n        Anti-diagonal: [a, a, a] -> ok.\n        Non-diagonals: [b, b, b] -> base_char='b', and 'b' != 'a' -> YES.\n\n   Another example: 3x3 with main and anti-diagonal 'a', and non-diagonals 'a': \n        a b a\n        b a b\n        a b a\n\n        But wait, if we change the non-diagonals to 'a', then:\n        a b a\n        b a b\n        a b a\n\n        Then the non-diagonals are not uniform: the four corners of the non-diagonals are actually not the same as the center? Actually, the non-diagonals are the four edges and the center is already considered. The non-diagonals are the four corners? No, in 3x3:\n\n        Positions: \n          (0,0): a (diagonal)\n          (0,1): b (non-diagonal)\n          (0,2): a (diagonal)\n          (1,0): b (non-diagonal)\n          (1,1): a (diagonal)\n          (1,2): b (non-diagonal)\n          (2,0): a (diagonal)\n          (2,1): b (non-diagonal)\n          (2,2): a (diagonal)\n\n        So the non-diagonals are the four 'b's. They are uniform.\n\n        But then base_char='b', and 'b' != 'a' -> YES.\n\n        However, wait: the problem says the non-diagonals must be the same and different from the diagonals. This example meets the condition.\n\n        But now, consider if we set the non-diagonals to two different letters, say:\n\n        a b c\n        b a b\n        c a a\n\n        Main diagonal: [a, a, a] -> ok.\n        Anti-diagonal: [c, a, c] -> not uniform (because first and last are 'c', middle is 'a') -> so we break.\n\n        Actually, the anti-diagonal is [c, a, c] -> not uniform, so we output NO.\n\n   One more: \n        a b c\n        d a e\n        f a g\n\n        Main diagonal: [a, a, g] -> not uniform -> NO.\n\n   Therefore, the code is as follows.\n\n   However, note: there is a possibility that the grid has the two diagonals as the same letter, but the non-diagonals are not uniform. Then we break in the non-diagonal check.\n\n   Example:\n\n        a b c\n        d a e\n        f g a\n\n        Main diagonal: [a, a, a] -> ok.\n        Anti-diagonal: [c, a, f] -> not uniform (c, a, f) -> NO.\n\n   So we are good.\n\n   But wait: what if the grid has two different letters in the non-diagonals? Then we break in the non-diagonal check.\n\n   Example:\n\n        a b c\n        d a e\n        f g h\n\n        Main diagonal: [a, a, h] -> not uniform -> NO.\n\n   So the code is complete.\n\n   However, note: we are using exit(0) to terminate early. Alternatively, we can use return if in a function, but since we are writing a script, we can use exit(0) or simply break and then use a flag.\n\n   But the problem requires standard input and output.\n\n   Let me rewrite without exit(0) for clarity, but we can use functions.\n\n   Alternatively, we can do:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Check main diagonal\n        d = grid[0][0]\n        for i in range(n):\n            if grid[i][i] != d:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal\n        for i in range(n):\n            if grid[i][n-1-i] != d:\n                print(\"NO\")\n                exit(0)\n\n        base_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if base_char is None:\n                    base_char = grid[i][j]\n                elif grid[i][j] != base_char:\n                    print(\"NO\")\n                    exit(0)\n\n        if base_char == d:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n   This is acceptable.\n\n   However, we can also avoid the multiple exits by using a function and returning.\n\n   But since the problem is small, and we are going to exit anyway, it's fine.\n\n   But note: the problem constraints say n<300, so worst-case we do about n^2 iterations, which is 300^2 = 90000, which is acceptable.\n\n   Final code.\n\n   However, wait: what if the grid is 3x3 and the main diagonal is uniform, but the anti-diagonal is uniform with the same letter, and the non-diagonals are uniform but the same as the diagonal letter? Then we output \"NO\", which is correct.\n\n   Example:\n\n        aaa\n        aab\n        aba\n\n        Actually, wait: \n        Main diagonal: [a, a, a] -> ok.\n        Anti-diagonal: [a, a, a] (from the grid: \n            row0: \"aaa\"\n            row1: \"aab\"\n            row2: \"aba\"\n\n        Anti-diagonal: \n            row0: last char 'a'\n            row1: middle char 'a'\n            row2: first char 'a' -> so anti-diagonal is \"aaa\", so d='a'\n\n        Non-diagonals: \n            (0,1): 'a' (from \"aaa\") -> but wait, (0,1) is not on the diagonal? \n            Actually, the diagonals are (0,0),(1,1),(2,2) and (0,2),(1,1),(2,0). \n            So (0,1) is not diagonal, (1,0) is not, (1,2) is not, (2,1) is not.\n\n        So non-diagonals: \n            (0,1): 'a'\n            (1,0): 'a'\n            (1,2): 'b'\n            (2,1): 'b'\n\n        Then base_char: first non-diagonal is (0,1): 'a', then (1,0): 'a' -> same, then (1,2): 'b' -> different -> break and output NO.\n\n        But wait, the grid is:\n\n            aaa\n            aab\n            aba\n\n        So (0,1) is 'a', (1,0) is 'a', (1,2) is 'b', (2,1) is 'b'\n\n        Then we break at (1,2) because base_char is 'a' and we see 'b'. So we output NO.\n\n   This is correct because the non-diagonals are not uniform.\n\n   But what if the non-diagonals are not uniform? Then we break.\n\n   Therefore, the code is correct.\n\n   However, let me test with a grid that has two different non-diagonal letters (but the same base_char is set from the first occurrence, then we see a different one).\n\n   Example: \n        a b c\n        d a e\n        f g h\n\n        We break at the first non-diagonal that doesn't match the base_char.\n\n   But note: the base_char is set arbitrarily from the first non-diagonal. Then we check the rest.\n\n   This is correct.\n\n   We'll submit the code as below.\n\n   Note: We assume the input is as described.\n\n   Let me run the provided examples.\n\n   Example 1: 5x5 -> NO (correct)\n   Example 2: 3x3 -> YES (correct)\n   Example 3: 3x3 -> NO (correct)\n\n   Code:\n",
    "response": "\nTo solve this problem, we need to determine if a given square grid forms the letter \"X\" based on specific conditions. The conditions are that all letters on both diagonals must be the same, and all other letters (not on the diagonals) must be the same and different from the diagonal letters.\n\n### Approach\n1. **Check Main Diagonal**: The main diagonal consists of cells where the row index equals the column index (i.e., positions (0,0), (1,1), ..., (n-1,n-1)). All these cells must contain the same letter.\n2. **Check Anti-Diagonal**: The anti-diagonal consists of cells where the sum of the row and column indices equals n-1 (i.e., positions (0,n-1), (1,n-2), ..., (n-1,0)). All these cells must also contain the same letter, which should be identical to the letter found on the main diagonal.\n3. **Check Non-Diagonal Cells**: All cells not on either diagonal must contain the same letter, and this letter must differ from the letter found on the diagonals.\n\nThe solution involves iterating through the grid to verify these conditions. If any condition fails, the answer is \"NO\"; otherwise, it is \"YES\".\n\n### Solution Code\n```python\ndef main():\n    n = int(input().strip())\n    grid = [input().strip() for _ in range(n)]\n    \n    d = grid[0][0]\n    for i in range(n):\n        if grid[i][i] != d:\n            print(\"NO\")\n            return\n            \n    for i in range(n):\n        if grid[i][n-1-i] != d:\n            print(\"NO\")\n            return\n            \n    base_char = None\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                continue\n            if base_char is None:\n                base_char = grid[i][j]\n            else:\n                if grid[i][j] != base_char:\n                    print(\"NO\")\n                    return\n                    \n    if base_char == d:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The code starts by reading the size of the grid `n` and then reads `n` lines of input to form the grid.\n2. **Main Diagonal Check**: The first loop checks that all elements on the main diagonal (from top-left to bottom-right) are the same. If any element differs, it prints \"NO\" and exits.\n3. **Anti-Diagonal Check**: The second loop checks that all elements on the anti-diagonal (from top-right to bottom-left) are the same as the main diagonal's letter. If any element differs, it prints \"NO\" and exits.\n4. **Non-Diagonal Cells Check**: The nested loops iterate over all cells not on the diagonals. The first non-diagonal cell sets `base_char`, and subsequent cells must match this character. If any cell does not match, it prints \"NO\" and exits.\n5. **Final Check**: After verifying all non-diagonal cells are the same, it checks if this character differs from the diagonal character. If they are the same, it prints \"NO\"; otherwise, it prints \"YES\".\n\nThis approach efficiently verifies all conditions required to determine if the grid forms an \"X\", ensuring correctness with minimal computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    n = int(input().strip())\n    grid = [input().strip() for _ in range(n)]\n    \n    d = grid[0][0]\n    for i in range(n):\n        if grid[i][i] != d:\n            print(\"NO\")\n            return\n            \n    for i in range(n):\n        if grid[i][n-1-i] != d:\n            print(\"NO\")\n            return\n            \n    base_char = None\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                continue\n            if base_char is None:\n                base_char = grid[i][j]\n            else:\n                if grid[i][j] != base_char:\n                    print(\"NO\")\n                    return\n                    \n    if base_char == d:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 438,
        "completion_token_count": 731,
        "thoughts_token_count": 7745
    }
}