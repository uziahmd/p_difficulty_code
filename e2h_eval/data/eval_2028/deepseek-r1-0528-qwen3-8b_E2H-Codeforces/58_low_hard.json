{
    "start": 1758300326.806419,
    "end": 1758303990.8622456,
    "start-formatted": "2025-09-20 01:45 KST",
    "end-formatted": "2025-09-20 02:46 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are to find the minimum number of edges t to add to the graph to form an odd cycle, and the number of ways w (without creating loops or parallel edges) to do so.\n\n Observing that:\n  - An odd cycle must have at least 3 edges (a triangle is the smallest odd cycle, which has 3 edges).\n  - We cannot add loops or parallel edges.\n\n Let's break down:\n\n Case 1: The graph already contains an odd cycle.\n   Then we don't need to add any edge (t=0) and there is one way (w=1) because we don't need to add anything.\n\n How to check for an odd cycle? We can use bipartite coloring (BFS/DFS). If the graph is not bipartite, then it contains an odd cycle.\n\n Case 2: The graph is bipartite (so no odd cycle) but has at least one connected component with more than one vertex?\n   Actually, note: if the graph is bipartite, then we can color the graph with two colors. But note: the entire graph might be disconnected.\n\n However, the problem says: we are to form a simple cycle of odd length. The odd cycle must be formed by adding edges.\n\n Steps:\n\n 1. Check if the graph already has an odd cycle (i.e., is not bipartite). Then t=0, w=1.\n\n 2. If the graph is bipartite, then we consider adding edges.\n\n What is the minimum number of edges to add?\n\n Note: We are allowed to add edges arbitrarily (as long as we don't create loops or parallel edges). We want the minimum t (number of edges) such that after adding t edges, the graph contains an odd cycle.\n\n Observation:\n\n  - The smallest odd cycle is a triangle (3 vertices). However, we might form an odd cycle by connecting two non-adjacent vertices in a complete bipartite graph? Actually, wait.\n\n In a bipartite graph, all cycles are even. To form an odd cycle, we must connect two vertices that are in the same bipartite set (same color) because then we get an odd-length path between them (the existing even path and the direct edge together form an odd cycle). But note: the direct edge might not be enough if the two vertices are not directly connected by an even-length path? Actually, the entire cycle is the even-length path (from u to v) plus the direct edge (which is 1, so total odd). So if we can connect two same-colored vertices, then we get an odd cycle.\n\n However, what if we don't have an edge between two same-colored vertices? Then adding one edge between two same-colored vertices (that are not adjacent) would create an odd cycle.\n\n But wait: what if the two same-colored vertices are already connected by an even-length path? Then the cycle formed by that path and the new edge will be of odd length.\n\n However, we must also consider that the graph might not be connected.\n\n Let's consider:\n\n  - The graph is bipartite and has at least two vertices. Then we can try to form an odd cycle by adding one edge? \n\n  Example: \n    Input: \"3 0\" -> n=3, m=0. We have three isolated vertices. We can form a triangle (odd cycle) by adding 3 edges. But note, we can also form an odd cycle by connecting two of them and then connecting one more? However, note the problem: the cycle must be simple and of odd length. \n\n    But note: the problem says \"minimum number of edges\". \n\n    With 3 edges we can form a triangle (cycle of length 3). But is it possible to form an odd cycle with fewer than 3 edges? \n\n    Odd cycle must have at least 3 edges. So minimum t is 3.\n\n    However, wait: can we form an odd cycle by connecting two edges? \n        Example: two edges forming a path of two edges (a chain of three vertices) is not a cycle. Then we need to close the cycle. So the minimal odd cycle is a triangle (3 edges).\n\n    But note: the example input \"3 0\" outputs \"3 1\", meaning we add 3 edges (and there is exactly one way: add all three edges of the triangle).\n\n    Now, what if the graph is bipartite and connected, and we have two same-colored vertices that are not connected by an edge? Then we can add one edge between them to form an odd cycle? \n\n    Example: Consider a graph with two vertices and one edge. This graph is bipartite (two-colorable). Then we can add an edge between the two same-colored vertices? Wait, in a two-vertex graph, the two vertices are colored differently. So we cannot connect two same-colored vertices? Then how do we form an odd cycle?\n\n",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and the number of ways to add those edges without creating loops or parallel edges.\n\n### Approach\n1. **Check for Existing Odd Cycle**: The graph already contains an odd cycle if it is not bipartite. We can check this using BFS or DFS with bipartite coloring. If the graph is not bipartite, the answer is `0 1` because no edges need to be added.\n2. **Bipartite Graph Handling**: If the graph is bipartite, we then check for connected components. For each connected component, we consider the two color sets (let's say set A and set B). The minimum edges required to form an odd cycle is determined by:\n   - **Case 1**: Adding one edge between two vertices in the same color set (if they are not already connected). This forms an odd cycle with the existing even-length path between them.\n   - **Case 2**: If there are no such pairs (i.e., the graph is a complete bipartite graph), we need to form a triangle by adding three edges connecting three vertices from the same color set.\n3. **Calculate Minimum Edges and Ways**: For each connected component, compute the number of valid pairs (vertices in the same color set) that can be connected to form an odd cycle. The total minimum edges required is the smallest value across all components, and the total ways is the sum of ways from all components that require the same minimum edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    # Check bipartiteness\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n\n    for i in range(1, n+1):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = 1\n            comp_nodes = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 3 - color[node]\n                        q.append(neighbor)\n                        comp_nodes.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        is_bipartite = False\n            components.append(comp_nodes)\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_ways = 0\n    min_edges = float('inf')\n    for comp in components:\n        size_comp = len(comp)\n        colors_in_comp = {}\n        for node in comp:\n            colors_in_comp[color[node]] = colors_in_comp.get(color[node], 0) + 1\n            \n        setA = colors_in_comp.get(1, 0)\n        setB = colors_in_comp.get(2, 0)\n        \n        total_edges_in_comp = 0\n        for node in comp:\n            total_edges_in_comp += len(graph[node])\n            \n        total_edges_in_comp //= 2\n        \n        max_possible_edges_in_comp = (size_comp * (size_comp-1)) // 2\n        missing_edges = max_possible_edges_in_comp - total_edges_in_comp\n        \n        total_pairs_same_color = (setA*(setA-1))//2 + (setB*(setB-1))//2\n        \n        if total_pairs_same_color > 0:\n            min_edges = 1\n            total_ways += total_pairs_same_color\n        else:\n            min_edges = 3\n            total_ways += missing_edges\n            \n    if min_edges == float('inf'):\n        print(\"0 1\")\n    else:\n        print(f\"{min_edges} {total_ways}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The graph is checked for bipartiteness using BFS. If during the traversal, a node is found with the same color as its parent, the graph is not bipartite, and the answer is `0 1`.\n2. **Component Analysis**: For each connected component, the number of nodes in each color set (setA and setB) is counted. The total possible edges within each set (same color) is calculated.\n3. **Edge Calculation**: If there are any missing edges within the same color set, adding one such edge creates an odd cycle, so the minimum edges required is 1. Otherwise, forming a triangle requires 3 edges.\n4. **Result Compilation**: The solution aggregates results from all components. The minimum edges required is the smallest value found, and the total ways is the sum of valid configurations across all components. If no edges are needed (already has an odd cycle), the result is `0 1`.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    # Check bipartiteness\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n\n    for i in range(1, n+1):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = 1\n            comp_nodes = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 3 - color[node]\n                        q.append(neighbor)\n                        comp_nodes.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        is_bipartite = False\n            components.append(comp_nodes)\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_ways = 0\n    min_edges = float('inf')\n    for comp in components:\n        size_comp = len(comp)\n        colors_in_comp = {}\n        for node in comp:\n            colors_in_comp[color[node]] = colors_in_comp.get(color[node], 0) + 1\n            \n        setA = colors_in_comp.get(1, 0)\n        setB = colors_in_comp.get(2, 0)\n        \n        total_edges_in_comp = 0\n        for node in comp:\n            total_edges_in_comp += len(graph[node])\n            \n        total_edges_in_comp //= 2\n        \n        max_possible_edges_in_comp = (size_comp * (size_comp-1)) // 2\n        missing_edges = max_possible_edges_in_comp - total_edges_in_comp\n        \n        total_pairs_same_color = (setA*(setA-1))//2 + (setB*(setB-1))//2\n        \n        if total_pairs_same_color > 0:\n            min_edges = 1\n            total_ways += total_pairs_same_color\n        else:\n            min_edges = 3\n            total_ways += missing_edges\n            \n    if min_edges == float('inf'):\n        print(\"0 1\")\n    else:\n        print(f\"{min_edges} {total_ways}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 572,
        "completion_token_count": 1116,
        "thoughts_token_count": 1023
    }
}