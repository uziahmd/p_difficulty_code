{
    "start": 1758296933.8756547,
    "end": 1758300394.2638392,
    "start-formatted": "2025-09-20 00:48 KST",
    "end-formatted": "2025-09-20 01:46 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (with 1 <= a,b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\n Note: We can assume without loss of generality that a != b. If a == b, then we are looking for k such that LCM(a+k, a+k) = a+k is minimized. The smallest k would be 0.\n\n However, note that when a == b, then k=0 gives LCM(a, a)=a, but if we take k>0 then the numbers become larger. So k=0 is the answer.\n\n But the problem is more complicated when a != b.\n\n Observation:\n Let d = gcd(a+k, b+k). Then note that d divides (a+k) and (b+k), so it also divides (a+k) - (b+k) = a-b (if a>=b, else negative, but absolute value). Therefore, d must divide |a-b|.\n\n Moreover, note that:\n   LCM(a+k, b+k) = (a+k)*(b+k) / gcd(a+k, b+k)\n\n We want to minimize this.\n\n Let g = gcd(a+k, b+k). Then g divides |a-b|. Also, note that we can write:\n   (a+k) = g * m\n   (b+k) = g * n\n\n Then, we have:\n   (a+k) - (b+k) = g*(m-n) = a-b.\n\n So, g must be a divisor of (a-b) (taking absolute value). But note: k can be chosen arbitrarily, so the divisors we consider are the divisors of |a-b|? However, note that k might be zero or positive, and we are allowed to let k be any non-negative integer.\n\n Alternate approach:\n\n Consider: Let d = |a-b|. Then, note that the condition on g is that g divides d (if d != 0). For each divisor g of d (or perhaps of a-b, but we can take absolute value) we can set up an equation:\n\n   We require that g divides both (a+k) and (b+k). Since (a+k) mod g = 0 and (b+k) mod g = 0, then k ≡ (-a) mod g and k ≡ (-b) mod g. But note that a ≡ b (mod g) because g divides d = |a-b|. So these two congruences are consistent.\n\n The smallest non-negative k that satisfies k ≡ (-a) mod g is:\n   k0 = (-a) mod g, but we want non-negative, so k0 = (g - a % g) % g.\n\n However, note: we are free to choose any divisor g of d. But wait, is that all? Actually, note that the condition is necessary that g divides d, but is it sufficient? Yes, because if g divides d, then there exists k such that g divides both a+k and b+k (for example, k0 as above).\n\n But note: we are not limited to divisors of d only? Actually, the gcd g must divide d, so the divisors we consider are the divisors of d. However, note that k might be chosen so that the gcd is a divisor of d, but also note that the gcd could be any divisor of d. However, note that the gcd of (a+k, b+k) must divide d, so we can consider all divisors of d.\n\n But wait, what if d=0? Then we are in the case a==b, which we already handled.\n\n Steps:\n\n 1. If a == b, output 0.\n\n 2. Otherwise, let d = abs(a-b). Then, we consider all divisors of d (both positive divisors). For each divisor g (which will be positive) of d, we can compute the smallest non-negative k0 such that g divides (a+k0) and (b+k0). This k0 is the solution to:\n        k0 ≡ (-a) mod g   (and similarly for b, but since g divides d, the congruences are consistent)\n\n    How to compute k0? \n        k0 = (g - (a % g)) % g   [Note: if a % g == 0, then k0=0]\n\n    However, note: we have two conditions: (a+k0) % g == 0 and (b+k0) % g == 0. Since g divides d, we know that (a-b) % g == 0, so if (a+k0) % g == 0 then automatically (b+k0) % g == 0.\n\n    But note: we can also consider negative divisors? No, divisors are positive.\n\n 3. For each divisor g (including 1 and d, and all divisors in between), we get a candidate k0.\n\n 4. Then, for each candidate k0, we can compute the LCM of (a+k0) and (b+k0). However, note that the LCM is (a+k0)*(b+k0)//gcd(a+k0, b+k0). But note: the gcd(a+k0, b+k0) is at least g, but actually we know that the gcd is exactly g? Not necessarily, because by setting k0 we only ensure that g divides (a+k0) and (b+k0). The actual gcd might be greater than g? \n\n    Actually, no: we set g as a divisor of d, but the gcd might be a multiple of g? Wait, no: we set k0 so that g divides (a+k0) and (b+k0). The gcd could be any multiple of g? But note: the gcd must divide d, and g is a divisor of d, but we are free to have a gcd that is a divisor of d and also divides (a+k0) and (b+k0). However, note that our k0 was computed from g, but the actual gcd might be a multiple of g? Actually, no: we set k0 so that g divides (a+k0) and (b+k0). Then the gcd must be a divisor of d and a multiple of g? Actually, no: the gcd is the greatest common divisor. But note: we are iterating over all divisors of d. However, the gcd of (a+k0, b+k0) might be greater than g? \n\n    Example: Let a=6, b=10, then d=4. Divisors: 1,2,4.\n        g=1: k0 = (1 - (6 % 1)) % 1 -> 6%1 is 0, so k0=0. Then numbers are 6 and 10, gcd=2, which is greater than 1.\n        g=2: k0 = (2 - (6 % 2)) % 2 = (2-0)%2=0. Then numbers are 6 and 10, gcd=2.\n        g=4: k0 = (4 - (6 % 4)) % 4 = (4-2)%4=2. Then numbers are 8 and 12, gcd=4.\n\n    So, the actual gcd is not necessarily g, but note that the candidate k0 we computed for divisor g may yield a gcd that is a multiple of g? Actually, the gcd we get is the gcd of (a+k0) and (b+k0). And note that (a+k0) and (b+k0) are multiples of g, but the gcd might be larger. \n\n    However, observe: the condition for k0 is that (a+k0) and (b+k0) are divisible by g, but they might be divisible by a larger divisor (which is also a divisor of d). \n\n    But note: we are iterating over all divisors. So even if we set g=1 and get k0=0, the actual gcd is 2, which we will also get when we set g=2. Then, the LCM for k0=0 (from g=1) is LCM(6,10)=30, and for k0=0 (from g=2) we get the same k0, but then we compute the LCM with gcd=2: (6*10)//2 = 30, same. And for k0=2 (from g=4) we get LCM(8,12)=24.\n\n    So, we cannot rely on the divisor g to give the actual gcd. But note: the candidate k0 we compute for a divisor g is the smallest k that makes g divide (a+k) and (b+k). However, the same k0 might be generated by multiple divisors. \n\n    How to avoid duplicates? We can consider each distinct k0 only once? But note: we are iterating over divisors and we might get the same k0 from different divisors. For example, k0=0 is obtained from every divisor g that divides (a) and (b) (which is all divisors of d). \n\n    Alternatively, we can think: the set of k we need to consider is the set of k that are solutions to the system of congruences for some divisor g of d. But note that the condition for k is that it must make the two numbers have a gcd that divides d. And the minimal k that makes the gcd at least g (for a divisor g) is k0.\n\n    However, note: the minimal k that minimizes the LCM might come from one of these candidates. But note: there might be k that are not of this form? \n\n    Let me reexamine: The gcd of (a+k) and (b+k) must divide (a-b). Therefore, the gcd must be one of the divisors of |a-b|. So the condition is necessary. Hence, the minimal LCM must occur at one of these candidate k's.\n\n    Therefore, we can consider all divisors of d (which are the divisors of |a-b|) and for each divisor g, we compute the smallest non-negative k0 such that g divides (a+k0) and (b+k0). Then, for each k0, we compute the LCM and then choose the k0 that minimizes the LCM, and if there are multiple, choose the smallest k0.\n\n    However, note: the set of divisors of d is about O(sqrt(d)), and d can be up to 10^9, so the number of divisors is at most around 1300 (in worst-case). This is acceptable.\n\n    But wait: what if d=0? Then we skip and use the special case.\n\n    Steps:\n\n      if a == b: print(0)\n\n      else:\n          d = abs(a-b)\n          divisors = all positive divisors of d\n\n          candidate_ks = set()   # we'll store distinct candidate k's\n\n          for each divisor g in divisors:\n              k0 = (g - a % g) % g   # smallest non-negative k such that (a+k0) % g == 0\n              candidate_ks.add(k0)\n\n          Then, we also note: we must consider k0=0? Actually, the above formula works for g>=1.\n\n          Now, for each candidate k in candidate_ks, we compute:\n            x = a + k\n            y = b + k\n            g_val = gcd(x, y)   # but note: we don't know the gcd beforehand, but we can compute it.\n\n          Then, lcm = (x * y) // g_val\n\n          Then, we want the candidate k that minimizes lcm. If two k's have the same lcm, choose the smallest k.\n\n    However, note: the set of candidate_ks might be large (but the divisors are not too many). But note: the candidate_ks set might have up to 1300 elements, which is acceptable.\n\n    But wait: we are computing the gcd for each candidate k. How expensive is that? The numbers x and y can be up to 10^9 + 1300, so the gcd computation is O(log(min(x,y))), which is about 30 steps. So 1300 * 30 operations is acceptable.\n\n    However, note: we might have duplicate k's? We used a set, so we avoid duplicates.\n\n    But wait: is it possible that two different divisors g1 and g2 yield the same k0? Yes, for example, if a=5, b=10, d=5. Divisors: 1,5.\n        g=1: k0 = (1-5%1)%1 -> 5%1 is 0, so k0=0.\n        g=5: k0 = (5-5%5)%5 = (5-0)%5=0.\n        So k0=0 is repeated.\n\n    Using set avoids duplicates.\n\n    But note: there is another issue: what if d is very large (up to 10^9)? Then the number of divisors is at most around 1344 (for highly composite numbers). This is acceptable.\n\n    However, there is a catch: we must consider that k0 might be negative? Our formula (g - a % g) % g ensures non-negativity.\n\n    But note: the modulo operation in Python for negative numbers: \n        We are doing: (g - a % g) % g\n        Since a % g is in [0, g-1], then (g - a % g) is in [1, g]. Then mod g: if a % g !=0, then (g - a % g) % g = g - a % g (which is < g). If a % g ==0, then (g -0)%g = g % g = 0.\n\n    This is correct.\n\n    However, note: what if g > a? Then a % g is a, so k0 = (g - a) % g. Since g>a, then (g - a) is positive and less than g, so k0 = g - a.\n\n    Example: a=6, g=7 -> k0 = (7-6)%7 = 1.\n\n    But wait: we are iterating over divisors of d, and d=abs(a-b). In the example a=6, b=10, d=4, so g=7 is not a divisor of 4. So we are safe.\n\n    But note: the divisors we consider are the divisors of d, which is |a-b|, and we are only considering divisors that are positive.\n\n    However, there is a problem: the above reasoning says that the gcd must divide d, but note that the gcd of (a+k, b+k) must divide d. But we are only considering divisors of d. However, the gcd might be any divisor of d, and we are generating candidate k's for every divisor. \n\n    But note: the candidate k0 we generate for a divisor g is the minimal k that makes g divide (a+k) and (b+k). However, the actual gcd might be a divisor of d that is greater than g. But we are iterating over all divisors, so we are covering all possibilities.\n\n    However, note: the minimal k for a divisor g is independent of other divisors. But the same k0 might be generated by multiple divisors, and that k0 might lead to a gcd that is a divisor of d (and we don't know which one). But we are going to compute the actual gcd for that k0 anyway.\n\n    But wait: is it possible that the minimal k that minimizes the LCM is not among the candidate_ks? \n\n    Let me think: the gcd of (a+k, b+k) must divide d, so the condition is necessary. Therefore, the minimal LCM must occur at a k that satisfies the condition for some divisor g (namely the gcd itself). However, note: the candidate k0 for a divisor g is the minimal k that makes g divide (a+k) and (b+k). But the actual k that minimizes the LCM might be larger than the candidate k0 for the divisor g that is the actual gcd? \n\n    Example: \n        a=6, b=10, d=4, divisors=[1,2,4]\n        candidate k0s: \n            g=1 -> k0=0\n            g=2 -> k0=0\n            g=4 -> k0=2\n\n        Now, k=0: LCM(6,10)=30\n        k=2: LCM(8,12)=24 -> better.\n\n        But note: k=1 is not considered. What happens at k=1?\n            Numbers: 7 and 11, gcd=1, LCM=77.\n\n        Why is k=1 not considered? Because the gcd at k=1 is 1, which is a divisor of 4, so we did consider g=1 and got k0=0. However, note: the candidate k0 for g=1 is 0, which is the minimal k that makes 1 divide (a+k) and (b+k). But k=1 also makes 1 divide (a+k) and (b+k). However, we are taking the minimal k for each divisor. But note: the condition for g=1 is satisfied by any k (because 1 divides everything). So the minimal k for g=1 is 0.\n\n        However, the minimal k for a divisor g is the minimal k such that (a+k) and (b+k) are divisible by g. But note: the condition for g=1 is always satisfied, so we don't need to consider k=1 for g=1? We are only storing the minimal k for each divisor. But then, how do we account for k=1? \n\n        Actually, we are only storing the minimal k for each divisor. But note: the minimal k for g=1 is 0, and we don't need to consider k=1 because the LCM for k=0 is 30, which is less than 77. \n\n        However, what if the minimal k for a divisor is 0, but there is a k>0 that gives a smaller LCM? \n\n        Example: Consider a=2, b=4, d=2. Divisors: [1,2]\n            g=1: k0=0 -> numbers (2,4): gcd=2, LCM=4.\n            g=2: k0= (2-2%2)%2=0 -> same as above.\n\n        But what if we try k=1?\n            (3,5): gcd=1, LCM=15 -> worse.\n\n        Another example: a=3, b=5, d=2. Divisors: [1,2]\n            g=1: k0=0 -> (3,5): gcd=1, LCM=15.\n            g=2: k0= (2-3%2)%2 = (2-1)%2=1 -> k0=1: (4,6): gcd=2, LCM=12.\n\n        Then the minimal LCM is 12 at k=1.\n\n        So we found k=1 by the divisor g=2.\n\n        But note: the divisor g=1 also gives k0=0, and we computed the LCM for k=0, but we also computed for k=1 (from divisor g=2). \n\n        However, what if we don't consider k=1 for divisor g=1? We only consider the minimal k for each divisor. But note: the minimal k for divisor g=1 is 0, but k=1 is also a solution for divisor g=1 (but we don't need to consider it because 0 is smaller). But we are iterating over all divisors and storing the minimal k for each divisor, so k=1 is stored only from divisor g=2.\n\n        Therefore, we are covering all k's that are minimal for some divisor. But note: the minimal k for divisor g is the minimal k that satisfies the condition for g. However, the same k might satisfy the condition for multiple divisors. But we are storing distinct k's.\n\n        But note: there might be k that is not the minimal for any divisor? \n\n        Actually, the condition for k is that the gcd of (a+k, b+k) divides d. Then, the gcd must be one of the divisors. But note: the minimal k for a divisor g is the minimal k such that g divides (a+k) and (b+k). However, the same k might satisfy the condition for multiple divisors (like k=0 satisfies for every divisor). \n\n        However, the key point is: the minimal k for divisor g is the minimal k that makes g divide (a+k) and (b+k). Then, the set of candidate k's is the set of minimal k's for each divisor. \n\n        But note: it is possible that a k that is not the minimal for any divisor might yield a smaller LCM? \n\n        Example: Let a=1, b=3, d=2. Divisors: [1,2].\n            g=1: k0=0 -> (1,3): gcd=1, LCM=3.\n            g=2: k0= (2-1%2)%2 = (2-1)%2=1 -> (2,4): gcd=2, LCM=4.\n\n        Now, consider k=2: (3,5): gcd=1, LCM=15 -> worse.\n\n        k=3: (4,6): gcd=2, LCM=12 -> worse.\n\n        k=4: (5,7): gcd=1, LCM=35 -> worse.\n\n        So the minimal LCM is 3 at k=0.\n\n        But what if we take k=-1? Not allowed (k>=0).\n\n        Now, consider a=1, b=4, d=3. Divisors: [1,3].\n            g=1: k0=0 -> (1,4): gcd=1, LCM=4.\n            g=3: k0= (3-1%3)%3 = (3-1)%3=2 -> (3,6): gcd=3, LCM=6.\n\n        Now, consider k=1: (2,5): gcd=1, LCM=10 -> worse.\n        k=2: (3,6): same as g=3 candidate, LCM=6.\n\n        So k=2 is the candidate from divisor g=3.\n\n        But note: k=0 and k=2 are the only candidates.\n\n        However, note: the condition for divisor g=1 is always satisfied, so we don't need to consider k=0 and k=2 separately for g=1? We only need to consider k=0 for g=1, and k=2 for g=3.\n\n        But wait: what if the minimal k for divisor g=1 is 0, but the minimal k for divisor g=3 is 2. We are storing both.\n\n        Therefore, the algorithm is:\n\n          if a == b: print(0)\n\n          else:\n            d = abs(a-b)\n            divisors = get_divisors(d)\n\n            candidate_ks = set()\n            for g in divisors:\n                # We want the smallest non-negative k such that (a+k) % g == 0 and (b+k) % g == 0.\n                # Since g divides d, then (a+k) % g = (a % g + k % g) % g, and we require that to be 0.\n                # Similarly for b.\n                # We can compute k0 = (-a) mod g, but note: we want non-negative, so k0 = (g - a % g) % g.\n\n                # But note: if g divides a, then a % g == 0, then k0=0.\n                # However, we must consider: what if g is 0? But d>0, and divisors are positive, so g>=1.\n\n                k0 = (g - (a % g)) % g\n                candidate_ks.add(k0)\n\n            # Also, note: we must consider k=0 if it is not included? But if g=1 is always a divisor, then k0 for g=1 is 0.\n\n            best_k = None\n            best_lcm = None\n\n            for k in candidate_ks:\n                x = a + k\n                y = b + k\n                g_val = gcd(x, y)\n                current_lcm = (x * y) // g_val\n\n                # We want to minimize current_lcm, and if equal then choose the smallest k (but note: we are iterating over distinct k's, and we are checking each distinct k)\n                if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n                    best_lcm = current_lcm\n                    best_k = k\n\n            print(best_k)\n\n        However, wait: the above code does not consider the possibility that the same k might appear multiple times? We use a set, so duplicates are avoided.\n\n        But note: we must consider that the gcd we compute for (a+k, b+k) is the actual gcd, and we use that to compute the LCM.\n\n        However, there is a problem: the set of divisors includes 1 and d, but what about divisors that are not positive? We only consider positive divisors.\n\n        How to get all divisors of d?\n\n          We can factorize d (which can be up to 10^9) and then generate all divisors.\n\n        Steps to get divisors:\n\n          def get_divisors(n):\n            if n == 1:\n                return [1]\n            i = 1\n            divisors = set()\n            while i*i <= n:\n                if n % i == 0:\n                    divisors.add(i)\n                    divisors.add(n//i)\n                i += 1\n            return list(divisors)\n\n        But note: n can be 0? No, because if a==b we handled, so d>=1.\n\n        However, there is a catch: what if d is very large? The divisor enumeration is O(sqrt(d)), which is acceptable for d up to 10^9 (sqrt(10^9) ~ 31622, which is acceptable in C++ but in Python we must be cautious). However, worst-case d is a prime, then we do about sqrt(d) iterations, which is 31622, which is acceptable.\n\n        But note: the problem constraints say a, b up to 10^9, so d can be up to 10^9, and the worst-case for divisor enumeration is 10^4.5 which is 31622, which is acceptable in Python if we do it once.\n\n        However, we must also compute the gcd for each candidate k, but the candidate set size is the number of divisors (at most ~1344) so that's acceptable.\n\n        But wait: what if d=0? We handled a==b, so d>=1.\n\n        Let me test with the examples:\n\n        Example 1: \"6 10\" -> d=4, divisors=[1,2,4]\n          candidate_ks: \n            g=1: k0=(1-6%1)%1 -> 6%1 is 0, so k0=0.\n            g=2: k0=(2-6%2)%2=(2-0)%2=0.\n            g=4: k0=(4-6%4)%4=(4-2)%4=2.\n\n          candidate_ks = {0,2}\n\n          Then compute:\n            k=0: x=6,y=10, gcd=2, LCM= (6*10)//2 = 30.\n            k=2: x=8,y=12, gcd=4, LCM= (8*12)//4=24.\n\n          Then best_k=2.\n\n        Example 2: \"21 31\" -> d=10, divisors=[1,2,5,10]\n          candidate_ks:\n            g=1: k0=0\n            g=2: k0=(2-21%2)%2=(2-1)%2=1\n            g=5: k0=(5-21%5)%5=(5-1)%5=4\n            g=10: k0=(10-21%10)%10=(10-1)%10=9\n\n          candidate_ks={0,1,4,9}\n\n          Now, we need to compute the LCM for each:\n\n            k=0: (21,31) -> gcd=1, LCM=21*31=651.\n            k=1: (22,32) -> gcd=2, LCM= (22*32)//2=352.\n            k=4: (25,35) -> gcd=5, LCM= (25*35)//5=175.\n            k=9: (30,40) -> gcd=10, LCM= (30*40)//10=120.\n\n          Then the minimal LCM is 120 at k=9.\n\n        Example 3: \"5 10\" -> d=5, divisors=[1,5]\n          candidate_ks:\n            g=1: k0=0\n            g=5: k0=(5-5%5)%5=0\n\n          candidate_ks={0}\n          Then k=0: (5,10): gcd=5, LCM=10.\n\n          But the example output is '0'. Correct.\n\n        However, wait: the example input \"5 10\" is provided and expected output is 0.\n\n        But note: there's another example: \"2 4\", which we did above and got k=0.\n\n        However, note: the example input \"5 10\" is the same as the third example.\n\n        But wait, there is an example in the note: Input ['6 10', '21 31', '5 10'] -> Output ['2','9','0'].\n\n        So the code above produces the expected outputs.\n\n        However, note: the example \"5 10\" had two divisors, but both gave k0=0. So the set only has one element.\n\n        But wait: what if d=0? We handled a==b, so d>0.\n\n        But note: there is a possibility that the minimal k might be negative? Our method computes non-negative k.\n\n        One more example: a=10, b=6 -> same as example1.\n\n        However, note: the problem states that k must be non-negative.\n\n        But wait: what if the minimal k is negative? Our method uses modulo and ensures non-negative. But we are only considering divisors, and the condition for k is that k>=0.\n\n        But note: the minimal k we compute is non-negative.\n\n        However, there is a catch: what if the divisor g is greater than a and b? Then k0 = g - a (if a<g) which is positive. But note: the divisor g must divide d, and d=|a-b|, so g<=d. But d=|a-b|, so if a and b are large, then d might be small compared to a and b, but also if a and b are close, then d is small.\n\n        But note: the divisor g is a divisor of d, so g<=d. Then k0 = (g - a % g) % g. This is non-negative.\n\n        However, note: the minimal k that satisfies the condition for divisor g might be negative? Then we take modulo and get a positive. But we are only interested in non-negative k.\n\n        Our formula: k0 = (g - a % g) % g, which gives a non-negative k0 in [0, g-1] (if g>0). So we are safe.\n\n        But note: what if a % g is 0? Then k0=0.\n\n        However, there is a potential performance issue: factorization of d (which is up to 10^9) is acceptable because we only do it once and the inner loop is O(sqrt(d)).\n\n        But note: the divisor enumeration function must be efficient.\n\n        Let me write the divisor enumeration:\n\n        We'll write:\n\n          import math\n\n          def get_divisors(n):\n              divisors = set()\n              for i in range(1, int(math.isqrt(n)) + 1):\n                  if n % i == 0:\n                      divisors.add(i)\n                      divisors.add(n // i)\n              return divisors\n\n        Then, we use this.\n\n        However, note: the example with a=10, b=6: same as 6,10.\n\n        But wait: the problem says: \"If there are multiple optimal integers k, he needs to choose the smallest one.\" \n\n        Our algorithm considers distinct k's and then picks the smallest k if the LCM is the same. However, note: the set of candidate_ks is distinct, and we iterate over them. Then, when comparing, if two k's have the same LCM, we pick the smallest k. But note: we are iterating in an arbitrary order. We should compare by LCM first and then by k.\n\n        We can do:\n\n          best_k = None\n          best_lcm = None\n          for k in candidate_ks:\n              ... compute LCM ...\n              if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n                  best_lcm = current_lcm\n                  best_k = k\n\n        This works.\n\n        However, note: the LCM might be very large? The numbers a+k and b+k can be up to 10^9 + 1344, so the product is about 1e18, which is acceptable in Python integers, but we must be cautious about overflow? But the problem constraints say a,b up to 10^9, and k up to maybe 10^9 (if d is large and the divisor is large, then k0 can be up to d, and d up to 10^9). But wait, the divisors are divisors of d, so d=|a-b|, which is up to 10^9. Then k0 for divisor g=d is (d - a % d) % d. Since a % d is in [0, d-1], then k0 = d - (a % d) if a % d !=0, otherwise 0. But note: a and d are related: d = |a-b|. \n\n        Example: a=1, b=10**9, then d=10**9-1. Then k0 for divisor g=d is (d - 1 % d) % d = d-1 (since 1 % d = 1). Then k0 = d-1, which is 10**9-2, which is about 10^9, and then the numbers a+k0 = 1+10**9-2 = 10**9-1, and b+k0 = 10**9 + 10**9-2 = 2*10**9-2. The product is (10**9-1)*(2*10**9-2) which is about 2e18, which is acceptable in Python (Python integers are arbitrary precision, but the arithmetic operations might be slow for numbers that big, but 1e18 is acceptable in terms of representation, but the modulus and gcd might be heavy?).\n\n        However, note: the gcd of two numbers up to 2e9 is computed by Euclidean algorithm, which is O(log(min(x,y))). The Euclidean algorithm for two numbers around 2e9 takes about 60 steps (log2(2e9) is about 31, and the Euclidean algorithm runs in O(c*log(min(x,y))) for some constant c). So it is acceptable.\n\n        But note: the candidate_ks set might include k's that are as large as d (which is 10^9). Then we have to compute the gcd for numbers up to 10^9 + 10^9 = 2e9. The Euclidean algorithm for two numbers of 2e9 is fast.\n\n        However, note: the total number of candidate_ks is the number of divisors (about 1300) so we do 1300 gcd computations, each taking about 60 steps, so 1300*60 = 78000 operations, which is acceptable.\n\n        But wait: the divisor enumeration might be the bottleneck. The divisor enumeration for d up to 10^9 takes about O(sqrt(d)) which is 31622 iterations, which is acceptable.\n\n        However, note: if d is a prime, then the divisors are [1, d] and we do about 31622 iterations (the same worst-case). \n\n        But wait: the divisor enumeration loop goes from 1 to sqrt(d). So for d=10^9, sqrt(d)=31622.7, so we do about 31622 iterations. That is acceptable in Python.\n\n        Let me test with d=10**9 (a prime, say 1000000007)",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the greatest common divisor (GCD) of \\( a+k \\) and \\( b+k \\) must divide the absolute difference \\( |a-b| \\). This means we only need to consider divisors of \\( |a-b| \\) when determining potential values of \\( k \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a-b| \\), compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is given by \\( k = (g - (a \\% g)) \\% g \\). \n\n3. **Algorithm Selection**:\n   - **Divisor Enumeration**: Enumerate all positive divisors of \\( |a-b| \\).\n   - **Candidate Generation**: For each divisor, compute the corresponding \\( k \\) value.\n   - **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a+k \\) and \\( b+k \\).\n   - **Optimal Selection**: Among all candidates, select the \\( k \\) that yields the smallest LCM. If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The algorithm involves enumerating divisors of \\( |a-b| \\), which takes \\( O(\\sqrt{d}) \\) time where \\( d = |a-b| \\). For each divisor, we perform a constant amount of work, including computing the GCD and LCM, which are logarithmic in the input size. Thus, the overall complexity is manageable even for large \\( a \\) and \\( b \\) (up to \\( 10^9 \\)).\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    candidate_ks = set()\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n        candidate_ks.add(k0)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidate_ks:\n        x = a + k\n        y = b + k\n        g_val = gcd(x, y)\n        current_lcm = (x * y) // g_val\n        \n        if best_lcm is None:\n            best_lcm = current_lcm\n            best_k = k\n        else:\n            if current_lcm < best_lcm:\n                best_lcm = current_lcm\n                best_k = k\n            elif current_lcm == best_lcm:\n                if k < best_k:\n                    best_k = k\n                    \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is trivially \\( k = 0 \\) because the LCM of \\( a \\) and \\( a \\) is minimized at \\( k = 0 \\).\n3. **Divisor Enumeration**: The code computes all positive divisors of \\( |a-b| \\) by checking each integer up to the square root of \\( |a-b| \\).\n4. **Candidate Generation**: For each divisor \\( g \\), the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\) is calculated and stored in a set to avoid duplicates.\n5. **LCM Calculation and Comparison**: For each candidate \\( k \\), the LCM of \\( a+k \\) and \\( b+k \\) is computed. The candidate \\( k \\) with the smallest LCM is selected, with ties broken by choosing the smallest \\( k \\).\n6. **Output**: The optimal \\( k \\) is printed.\n\nThis approach efficiently narrows down the potential candidates for \\( k \\) by leveraging mathematical properties of divisors and GCD, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    candidate_ks = set()\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n        candidate_ks.add(k0)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidate_ks:\n        x = a + k\n        y = b + k\n        g_val = gcd(x, y)\n        current_lcm = (x * y) // g_val\n        \n        if best_lcm is None:\n            best_lcm = current_lcm\n            best_k = k\n        else:\n            if current_lcm < best_lcm:\n                best_lcm = current_lcm\n                best_k = k\n            elif current_lcm == best_lcm:\n                if k < best_k:\n                    best_k = k\n                    \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 388,
        "completion_token_count": 1044,
        "thoughts_token_count": 8191
    }
}