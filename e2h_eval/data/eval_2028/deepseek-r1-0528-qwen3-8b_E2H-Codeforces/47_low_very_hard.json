{
    "start": 1758296519.5775688,
    "end": 1758299445.4809191,
    "start-formatted": "2025-09-20 00:41 KST",
    "end-formatted": "2025-09-20 01:30 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that LCM(a+k, b+k) is minimized.\n\n Observation:\n Let d = (a+k, b+k) be the gcd of (a+k) and (b+k). Note that:\n   d divides (a+k) and (b+k), so it also divides (a+k - (b+k)) = a-b (if a>=b) or (b+k - (a+k)) = b-a.\n\n Therefore, d must be a divisor of |a-b|.\n\n Also, note that:\n   LCM(a+k, b+k) = (a+k)*(b+k) / d\n\n We can express k in terms of d? Alternatively, note that:\n\n   Let g = gcd(a+k, b+k). Then g divides (a-b). So, we can consider all divisors d of |a-b| (if a != b) and then for each divisor d, we can try to find the smallest k such that d divides both (a+k) and (b+k).\n\n But note: if a == b, then for any k, we have two same numbers. Then LCM(a+k, a+k) = a+k, which is minimized when k=0.\n\n For a != b:\n   Let g be a divisor of |a-b|. Then we require:\n        (a+k) mod g == 0   and   (b+k) mod g == 0.\n\n   This implies that k ≡ (-a) mod g and k ≡ (-b) mod g. Since g divides (a-b), then (-a) ≡ (-b) mod g, so the congruences are compatible.\n\n   The smallest non-negative k for a given divisor g is:\n        k = (-a) % g   [but note: if (-a) % g gives a negative remainder? In Python, modulus is non-negative, but let's see:]\n\n   Actually, we can write: k0 = (-a) % g. However, note that (-a) % g = g - (a % g) if a % g != 0, but if a % g == 0 then (-a)%g==0.\n\n   But wait: we require (a+k) divisible by g, so k must be such that k ≡ (-a) (mod g). The smallest non-negative k is indeed (-a) % g.\n\n   However, note: the modulus operation in Python for negative: \n        (-a) % g = g - (a % g) if a % g != 0, and if a % g == 0 then 0.\n\n   But there's a catch: we are also considering that g divides |a-b|, but note that g can be any divisor (positive) of |a-b|.\n\n   Now, for a given divisor g (which is positive), the k we get is k0 = (-a) % g. Then the numbers are (a+k0) and (b+k0). Then the LCM is (a+k0)*(b+k0)//g.\n\n   But note: we must consider that the same g might be represented by divisors from the absolute difference. Also, note that k must be non-negative.\n\n   However, there is an alternative: sometimes the divisor g might not be the only one that appears? Actually, note that the gcd of (a+k) and (b+k) must divide (a-b). So we consider all divisors of |a-b|.\n\n   Steps:\n     1. If a == b: then answer is 0.\n     2. Otherwise, let D = |a-b|. Then factorize D and get all divisors (both positive and negative? Actually, gcd is positive, so we consider positive divisors only).\n     3. For each divisor g of D (positive divisors), compute k0 = (-a) % g. But note: (-a) % g is the same as (g - (a % g)) % g, which gives a value in [0, g-1]. However, we must ensure that with this k0, the gcd of (a+k0) and (b+k0) is at least g? Actually, we know that g divides (a-b), and then k0 is chosen so that g divides (a+k0) and (b+k0). But note: the gcd might be greater than g? \n\n   However, we are iterating over divisors of |a-b|. The gcd of (a+k0, b+k0) will be at least g, but it might be a multiple of g? Actually, no: because the gcd must divide (a-b), and we are taking divisors of |a-b|, so the gcd must be one of the divisors. But",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must divide the absolute difference between \\( a \\) and \\( b \\). This is because any common divisor of \\( a + k \\) and \\( b + k \\) will also divide \\( (a + k) - (b + k) = a - b \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a - b| \\), we can compute the smallest \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\). This \\( k \\) is given by \\( (-a) \\% g \\). Once we have \\( k \\), we can compute the LCM of \\( a + k \\) and \\( b + k \\) as \\( \\frac{(a + k) \\times (b + k)}{g} \\).\n\n3. **Algorithm Selection**: \n   - If \\( a \\) equals \\( b \\), the answer is trivially 0 since \\( k = 0 \\) minimizes the LCM.\n   - Otherwise, factorize \\( |a - b| \\) to find all its positive divisors.\n   - For each divisor \\( g \\), compute the corresponding \\( k \\) and the LCM. Track the minimal LCM and the smallest \\( k \\) that achieves it.\n\n4. **Complexity Analysis**: The factorization step dominates the complexity. For numbers up to \\( 10^9 \\), the factorization can be done efficiently by checking divisors up to \\( \\sqrt{n} \\), which is feasible within time constraints for competitive programming.\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    diff = abs(a - b)\n    divisors = get_divisors(diff)\n    \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors:\n        k0 = (-a) % g\n        num1 = a + k0\n        num2 = b + k0\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // current_gcd\n        \n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm:\n            if k0 < best_k:\n                best_k = k0\n                \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, the answer is immediately \\( k = 0 \\) because the LCM of two identical numbers is minimized at their smallest possible value.\n3. **Divisor Calculation**: Compute all positive divisors of the absolute difference between \\( a \\) and \\( b \\).\n4. **Finding Optimal \\( k \\)**: For each divisor \\( g \\), compute the smallest non-negative \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\). This \\( k \\) is found using the modulo operation \\( (-a) \\% g \\).\n5. **LCM Calculation**: For each computed \\( k \\), calculate the LCM of \\( a + k \\) and \\( b + k \\). Track the smallest LCM encountered and the corresponding smallest \\( k \\).\n6. **Output**: Print the smallest \\( k \\) that minimizes the LCM.\n\nThis approach efficiently narrows down the problem to checking divisors of the difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    diff = abs(a - b)\n    divisors = get_divisors(diff)\n    \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors:\n        k0 = (-a) % g\n        num1 = a + k0\n        num2 = b + k0\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // current_gcd\n        \n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm:\n            if k0 < best_k:\n                best_k = k0\n                \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1006,
        "thoughts_token_count": 1023
    }
}