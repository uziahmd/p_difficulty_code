{
    "start": 1758302771.8748386,
    "end": 1758306552.582421,
    "start-formatted": "2025-09-20 02:26 KST",
    "end-formatted": "2025-09-20 03:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given n, m and then m lines each with four numbers: a, b, g, l (the two lawns connected and the gcd and lcm)\n We know that for two numbers x and y (on the two lawns), we have:\n   gcd(x, y) = g and lcm(x, y) = l.\n And we also know that for any two numbers: \n   x * y = g * l   [since gcd(x,y)*lcm(x,y) = x*y]\n\n Additionally, note that the prime factors of x and y must be such that the common part is exactly g.\n\n Steps:\n 1. For each edge (a, b, g, l): \n      - Check if g * l is divisible by g? Actually, we can check that the gcd(g, l) must be equal to g (because the gcd of two numbers cannot exceed the minimum of the two, but note: the gcd of g and l might not be directly g, however, we know that g divides both numbers and the lcm must be divisible by g). But more importantly, we must have that g divides l? Actually, from the definitions, the gcd divides the lcm. So if g does not divide l, then this edge is invalid.\n\n    However, note: the condition we must have is that the gcd of the two numbers is g and the lcm is l. This implies:\n        - The product of the two numbers must be g * l.\n        - Moreover, the two numbers must be multiples of g, and we can write x = g * x', y = g * y' where gcd(x', y') = 1.\n        - Then, the LCM would be g * x' * y' (because they are coprime). Therefore, we must have x' * y' = l / g.\n\n    But note: we must have that l is divisible by g. So first check: if l % g != 0, then this edge is invalid.\n\n 2. Also, from the equation: x * y = g * l, and x and y must be multiples of g.\n\n 3. Now, we have a graph with n nodes and m edges. We need to assign a positive integer to each node such that for each edge (a,b,g,l):\n        Let x = value at node a, y = value at node b.\n        Conditions:\n          (i) x * y = g * l\n          (ii) gcd(x, y) = g\n\n    Alternatively, we can write:\n        x = g * a, y = g * b, with gcd(a, b) = 1, and then the LCM would be g * a * b = l -> so a * b = l // g.\n\n    Therefore, for each edge, we require that l is divisible by g, and then we can set the two numbers as g*a and g*b, with a and b coprime and a*b = l//g.\n\n 4. However, note that the same lawn might appear in multiple edges. We must assign one number per lawn.\n\n Approach:\n\n Since the problem is about assigning numbers to nodes such that for every edge (a, b, g, l):\n        Let x_a and x_b be the numbers at a and b.\n        Then, gcd(x_a, x_b) = g and lcm(x_a, x_b) = l.\n\n We can think of the following:\n\n   - The entire graph might be disconnected. Then we can solve each connected component independently.\n\n   - In each connected component, we can use the constraints from the edges to determine the values.\n\n   How?\n\n   Note: From an edge (a, b, g, l), we know that the value of a must be a multiple of g, and similarly for b.\n\n   But note: the gcd of the entire component might be constrained by the edges.\n\n   Observation: Consider that the value of each node must be a multiple of some base value. Actually, consider that the gcd of two adjacent nodes is given. Then, what is the minimum value that must be assigned to a node?\n\n   Let's define for each node i, let d_i be the gcd of all the edges incident to i? Not exactly.\n\n   Alternatively, note that the entire assignment must satisfy: for each edge (u, v, g, l), \n        x_u * x_v = g * l, and gcd(x_u, x_v) = g.\n\n   How can we relate the values across the graph?\n\n   Another idea: factorize the numbers? But note that the numbers can be up to 10^6 and the graph can have up to 10^5 edges (since n, m up to 10^5, but note input constraints: n, m are given, but we don't know the exact limits, so we must design efficiently).\n\n   However, note: the problem says n",
    "response": "\nTo solve this problem, we need to determine if it's possible to assign numbers of mushrooms to each lawn (vertex) in a graph such that for every given edge, the greatest common divisor (GCD) and least common multiple (LCM) of the numbers on its two connected lawns match the provided values. If possible, we should output one such assignment; otherwise, we should indicate that no solution exists.\n\n### Approach\n1. **Problem Analysis**:\n   - For each edge connecting two lawns with GCD `g` and LCM `l`, the product of the numbers on the two lawns must equal `g * l`. Additionally, the GCD of these two numbers must be exactly `g`.\n   - The key insight is that for any edge `(a, b, g, l)`, the numbers assigned to the connected lawns must satisfy `x * y = g * l` and `gcd(x, y) = g`. This implies that both `x` and `y` must be multiples of `g`, and the remaining parts of `x` and `y` (after dividing by `g`) must be coprime.\n   - We can model the problem as assigning values to vertices in a graph where edges enforce constraints between connected vertices.\n\n2. **Algorithm Selection**:\n   - **Graph Processing**: Treat each lawn as a node and each edge as a constraint between two nodes. Use Depth-First Search (DFS) or Breadth-First Search (BFS) to process connected components separately.\n   - **Constraint Handling**: For each edge, verify that `l` is divisible by `g`. If not, the solution is impossible. Then, derive candidate values for the connected nodes based on the edge constraints.\n   - **Value Assignment**: For each connected component, assign values starting from the smallest node (with the least value) and propagate values to adjacent nodes ensuring all constraints are met.\n\n3. **Complexity Analysis**:\n   - The algorithm processes each node and edge once, leading to a time complexity of O(n + m), where `n` is the number of nodes and `m` is the number of edges. This is efficient for large graphs as specified in the problem constraints.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        a = int(data[index]); b = int(data[index+1]); g_val = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((a, b, g_val, l_val))\n    \n    graph = [[] for _ in range(n+1)]\n    for a, b, g_val, l_val in edges:\n        graph[a].append((b, g_val, l_val))\n        graph[b].append((a, g_val, l_val))\n    \n    ans = [0] * (n+1)\n    valid = True\n    \n    for i in range(1, n+1):\n        if ans[i] != 0:\n            continue\n            \n        stack = [i]\n        ans[i] = 1\n        \n        while stack:\n            node = stack.pop()\n            for neighbor, g_val, l_val in graph[node]:\n                if ans[neighbor] == 0:\n                    if l_val % g_val != 0:\n                        valid = False\n                        break\n                    base = l_val // g_val\n                    if base == 1:\n                        ans[neighbor] = g_val\n                    else:\n                        x = 1\n                        y = base\n                        while x < y:\n                            if x * y == base and gcd(x, y) == 1:\n                                break\n                            x += 1\n                        if x * y != base or gcd(x, y) != 1:\n                            valid = False\n                            break\n                        if ans[node] % g_val != 0 or ans[node] // g_val != x:\n                            valid = False\n                            break\n                        ans[neighbor] = g_val * y\n                    stack.append(neighbor)\n                elif ans[neighbor] == -1:\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if not valid:\n            break\n            \n    if not valid:\n        print(\"NO\")\n    else:\n        for i in range(1, n+1):\n            if ans[i] == 0:\n                print(\"NO\")\n                return\n                \n        print(\"YES\")\n        print(\" \".join(map(str, ans[1:])))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns (`n`) and roads (`m`), followed by the details of each road (connected lawns and their GCD/LCM values).\n2. **Graph Construction**: A graph is built where each node represents a lawn, and edges store the GCD and LCM values along with the connected node.\n3. **DFS/BFS Processing**: For each unvisited node, a DFS is initiated to explore its connected component. During traversal, candidate values for connected nodes are derived based on edge constraints.\n4. **Validation**: For each edge, it checks if the LCM is divisible by the GCD. If not, the solution is impossible. It then verifies if the derived candidate values meet all constraints (product equals `g * l` and GCD equals `g`).\n5. **Output**: If all constraints are satisfied, the solution outputs \"YES\" followed by the assigned values; otherwise, it outputs \"NO\".\n\nThis approach efficiently checks for the existence of a valid mushroom count assignment by leveraging graph traversal and mathematical constraints validation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        a = int(data[index]); b = int(data[index+1]); g_val = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((a, b, g_val, l_val))\n    \n    graph = [[] for _ in range(n+1)]\n    for a, b, g_val, l_val in edges:\n        graph[a].append((b, g_val, l_val))\n        graph[b].append((a, g_val, l_val))\n    \n    ans = [0] * (n+1)\n    valid = True\n    \n    for i in range(1, n+1):\n        if ans[i] != 0:\n            continue\n            \n        stack = [i]\n        ans[i] = 1\n        \n        while stack:\n            node = stack.pop()\n            for neighbor, g_val, l_val in graph[node]:\n                if ans[neighbor] == 0:\n                    if l_val % g_val != 0:\n                        valid = False\n                        break\n                    base = l_val // g_val\n                    if base == 1:\n                        ans[neighbor] = g_val\n                    else:\n                        x = 1\n                        y = base\n                        while x < y:\n                            if x * y == base and gcd(x, y) == 1:\n                                break\n                            x += 1\n                        if x * y != base or gcd(x, y) != 1:\n                            valid = False\n                            break\n                        if ans[node] % g_val != 0 or ans[node] // g_val != x:\n                            valid = False\n                            break\n                        ans[neighbor] = g_val * y\n                    stack.append(neighbor)\n                elif ans[neighbor] == -1:\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if not valid:\n            break\n            \n    if not valid:\n        print(\"NO\")\n    else:\n        for i in range(1, n+1):\n            if ans[i] == 0:\n                print(\"NO\")\n                return\n                \n        print(\"YES\")\n        print(\" \".join(map(str, ans[1:])))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1230,
        "thoughts_token_count": 1023
    }
}