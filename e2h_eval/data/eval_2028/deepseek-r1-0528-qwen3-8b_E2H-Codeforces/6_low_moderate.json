{
    "start": 1758088076.618261,
    "end": 1758089223.705739,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of [l, r, cost]\n Conditions:\n   Two vouchers i and j must have total duration = x (i.e., (r_i - l_i + 1) + (r_j - l_j + 1) = x)\n   They must not intersect: either voucher i ends before voucher j starts (r_i < l_j) or voucher j ends before voucher i starts (r_j < l_i)\n\n We are to minimize the total cost.\n\n Steps:\n\n 1. We note that the duration d_i = r_i - l_i + 1. So we are looking for two vouchers i and j such that d_i + d_j = x.\n\n 2. We can group the vouchers by their duration. Let's create a dictionary (or list of lists) where key is duration d, and value is a list of tuples (l, r, cost) for vouchers with that duration.\n\n 3. However, the condition of non-intersection is important. Also, we have to consider that the two vouchers might have the same duration.\n\n 4. We cannot iterate over all pairs because n can be up to 200,000.\n\n Alternative approach:\n\n Let d1 = duration1, then d2 = x - d1 must exist.\n\n For each duration d, we want to store the vouchers with that duration, but we need to check non-intersection.\n\n How to check non-intersection? The condition is: \n   Either [l1, r1] and [l2, r2] don't overlap if r1 < l2 OR r2 < l1.\n\n But note: the two vouchers are independent. However, we have two different durations.\n\n We can think: For a fixed pair (d1, d2) such that d1+d2=x, we want to choose one voucher from d1 and one from d2 that do not intersect.\n\n But also, note: it is possible that d1 == d2 (if x is even). Then we have two vouchers from the same duration group.\n\n However, the problem does not require the two vouchers to be distinct in terms of index, but they are two different vouchers.\n\n 5. We need an efficient way to check for a given voucher (from group d1) and a voucher (from group d2) whether they don't intersect.\n\n 6. Instead of grouping by duration, we might also consider the intervals. But the constraints on days (up to 200,000) suggest that we can use coordinate compression or segment trees.\n\n Another idea:\n\n Precomputation:\n   Let's create an array for each day? Or maybe we can use two pointers or sweep line?\n\n Alternatively, we can precompute for each duration the list of vouchers and then for each voucher in duration d1, we look for a voucher in duration d2 that satisfies the non-intersection condition.\n\n But how to quickly find a voucher in group d2 that does not intersect with a given voucher from group d1?\n\n Condition for non-intersection for two vouchers (a from d1 and b from d2):\n   Case 1: a ends before b starts -> a.r < b.l\n   Case 2: b ends before a starts -> b.r < a.l\n\n Since the total number of vouchers is large, we cannot check every pair.\n\n 7. We can break the problem:\n\n   Step 1: Group by duration.\n\n   Step 2: For each duration d, we can also sort the list of vouchers by some criteria (like by l or by r) so that we can do binary search.\n\n   Step 3: For each duration d, let the other required duration be d_other = x - d.\n\n   Step 4: For each voucher in group d, we want to find in group d_other the best voucher (lowest cost) that satisfies either:\n        condition1: the voucher's l is > current voucher's r   (because then the current voucher ends before the other starts)\n        condition2: the voucher's r is < current voucher's l   (then the other voucher ends before the current starts)\n\n   However, note: the two conditions are independent. But we are allowed to use any one of them.\n\n   But wait: the two vouchers are symmetric? Actually, the condition is: at least one of the two holds.\n\n   So for a given voucher a (from d), we need to check:\n        Option1: find a voucher in d_other with l > a.r (and take the one with minimal cost)\n        Option2: find a voucher in d_other with r < a.l (and take the one with minimal cost)\n\n   Then the candidate cost for voucher a is min( cost_a + min_cost_in_d_other_with_l>a.r, cost_a + min_cost_in_d_other_with_r<a.l )\n\n   But note: we are allowed to pick only one voucher from d_other.\n\n   However",
    "response": "\nTo solve this problem, we need to find two non-intersecting travel vouchers such that the sum of their durations equals exactly `x` and their total cost is minimized. The solution involves efficiently grouping and searching through the vouchers based on their durations and intervals.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. For each duration `d`, we store a list of tuples `(l, r, cost)` representing the start day, end day, and cost of each voucher.\n2. **Sort Vouchers Within Each Group**: For each duration group, we sort the vouchers primarily by their start day (`l`) and secondarily by their end day (`r`). This allows us to efficiently search for non-intersecting vouchers using binary search.\n3. **Precompute Minimum Costs**: For each duration `d`, we precompute two arrays:\n   - `min_cost_by_start[d]`: An array where the index represents the start day, and the value at that index is the minimum cost among all vouchers with duration `d` that start on or after that day.\n   - `min_cost_by_end[d]`: Similarly, an array where the index represents the end day, and the value at that index is the minimum cost among all vouchers with duration `d` that end on or before that day.\n4. **Check Valid Pairs**: For each voucher in a group with duration `d`, we check if there exists another voucher in the group with duration `x - d` that does not intersect with it. This is done by checking two conditions: either the other voucher starts after the current voucher ends or ends before the current voucher starts. Using the precomputed arrays, we can quickly find the minimum cost voucher that meets these conditions.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 400000\n    min_cost_by_start = [10**18] * (max_day + 1)\n    min_cost_by_end = [10**18] * (max_day + 1)\n    \n    d_group = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        d = r - l + 1\n        d_group[d].append((l, r, cost_val))\n        \n    for d, arr in d_group.items():\n        arr.sort(key=lambda x: (x[0], x[1]))\n        m = len(arr)\n        if m == 0:\n            continue\n            \n        starts = [item[0] for item in arr]\n        ends = [item[1] for item in arr]\n        costs = [item[2] for item in arr]\n        \n        min_cost_by_start_for_d = [10**18] * (max_day + 1)\n        min_cost_by_end_for_d = [10**18] * (max_day + 1)\n        \n        for i in range(m):\n            l_val = starts[i]\n            e_val = ends[i]\n            c_val = costs[i]\n            j = i\n            while j < m and starts[j] == l_val:\n                if costs[j] < min_cost_by_start_for_d[l_val]:\n                    min_cost_by_start_for_d[l_val] = costs[j]\n                j += 1\n                \n        ptr = 0\n        best_start = 10**18\n        for day in range(0, max_day + 1):\n            if ptr < m and starts[ptr] <= day:\n                if costs[ptr] < best_start:\n                    best_start = costs[ptr]\n                ptr += 1\n            min_cost_by_start[day] = best_start\n        \n        ptr = m - 1\n        best_end = 10**18\n        for day in range(max_day, -1, -1):\n            if ptr >= 0 and ends[ptr] >= day:\n                if costs[ptr] < best_end:\n                    best_end = costs[ptr]\n                ptr -= 1\n            min_cost_by_end[day] = best_end\n\n    ans = 10**18\n    for d, arr in d_group.items():\n        d_other = x - d\n        if d_other not in d_group:\n            continue\n            \n        for (l, r, cost_val) in arr:\n            candidate1 = 10**18\n            candidate2 = 10**18\n            \n            if d_other != d:\n                cand1 = min_cost_by_start[r+1]\n                if cand1 != 10**18:\n                    candidate1 = cost_val + cand1\n            else:\n                cand1 = min_cost_by_start[r+1]\n                if cand1 != 10**18:\n                    candidate1 = cost_val + cand1\n                    \n            cand2 = min_cost_by_end[l-1]\n            if cand2 != 10**18:\n                candidate2 = cost_val + cand2\n                \n            current_min = min(candidate1, candidate2)\n            if current_min < ans:\n                ans = current_min\n                \n            if d_other == d:\n                cand1_alt = min_cost_by_start[r+1]\n                cand2_alt = min_cost_by_end[l-1]\n                current_min_alt = min(cand1_alt, cand2_alt)\n                if current_min_alt < ans:\n                    ans = current_min_alt\n                    \n    if ans == 10**18:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: Vouchers are grouped by their duration, and within each group, they are sorted by their start and end days. This organization allows efficient searching for non-intersecting vouchers.\n2. **Precomputing Minimum Costs**: For each duration, we precompute two arrays:\n   - `min_cost_by_start` holds the minimum cost for any voucher starting at or after a given day.\n   - `min_cost_by_end` holds the minimum cost for any voucher ending at or before a given day.\n3. **Finding Valid Pairs**: For each voucher, we check if there exists another voucher (from the complementary duration group) that does not intersect with it. Using the precomputed arrays, we quickly find the cheapest valid voucher and update the minimum cost accordingly.\n4. **Output the Result**: After processing all vouchers, if a valid pair is found, the minimum cost is printed; otherwise, `-1` is printed indicating no valid pair exists.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 400000\n    min_cost_by_start = [10**18] * (max_day + 1)\n    min_cost_by_end = [10**18] * (max_day + 1)\n    \n    d_group = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        d = r - l + 1\n        d_group[d].append((l, r, cost_val))\n        \n    for d, arr in d_group.items():\n        arr.sort(key=lambda x: (x[0], x[1]))\n        m = len(arr)\n        if m == 0:\n            continue\n            \n        starts = [item[0] for item in arr]\n        ends = [item[1] for item in arr]\n        costs = [item[2] for item in arr]\n        \n        min_cost_by_start_for_d = [10**18] * (max_day + 1)\n        min_cost_by_end_for_d = [10**18] * (max_day + 1)\n        \n        for i in range(m):\n            l_val = starts[i]\n            e_val = ends[i]\n            c_val = costs[i]\n            j = i\n            while j < m and starts[j] == l_val:\n                if costs[j] < min_cost_by_start_for_d[l_val]:\n                    min_cost_by_start_for_d[l_val] = costs[j]\n                j += 1\n                \n        ptr = 0\n        best_start = 10**18\n        for day in range(0, max_day + 1):\n            if ptr < m and starts[ptr] <= day:\n                if costs[ptr] < best_start:\n                    best_start = costs[ptr]\n                ptr += 1\n            min_cost_by_start[day] = best_start\n        \n        ptr = m - 1\n        best_end = 10**18\n        for day in range(max_day, -1, -1):\n            if ptr >= 0 and ends[ptr] >= day:\n                if costs[ptr] < best_end:\n                    best_end = costs[ptr]\n                ptr -= 1\n            min_cost_by_end[day] = best_end\n\n    ans = 10**18\n    for d, arr in d_group.items():\n        d_other = x - d\n        if d_other not in d_group:\n            continue\n            \n        for (l, r, cost_val) in arr:\n            candidate1 = 10**18\n            candidate2 = 10**18\n            \n            if d_other != d:\n                cand1 = min_cost_by_start[r+1]\n                if cand1 != 10**18:\n                    candidate1 = cost_val + cand1\n            else:\n                cand1 = min_cost_by_start[r+1]\n                if cand1 != 10**18:\n                    candidate1 = cost_val + cand1\n                    \n            cand2 = min_cost_by_end[l-1]\n            if cand2 != 10**18:\n                candidate2 = cost_val + cand2\n                \n            current_min = min(candidate1, candidate2)\n            if current_min < ans:\n                ans = current_min\n                \n            if d_other == d:\n                cand1_alt = min_cost_by_start[r+1]\n                cand2_alt = min_cost_by_end[l-1]\n                current_min_alt = min(cand1_alt, cand2_alt)\n                if current_min_alt < ans:\n                    ans = current_min_alt\n                    \n    if ans == 10**18:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1466,
        "thoughts_token_count": 1023
    }
}