{
    "start": 1758088079.751685,
    "end": 1758089242.8534951,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of [l, r, cost]\n Conditions:\n   Two vouchers i and j must have total duration = x (i.e., (r_i - l_i + 1) + (r_j - l_j + 1) = x)\n   They must not intersect: either voucher i ends before voucher j starts (r_i < l_j) or voucher j ends before voucher i starts (r_j < l_i)\n\n We are to minimize the total cost.\n\n Steps:\n\n 1. We note that the duration d_i = r_i - l_i + 1. So we require d_i + d_j = x.\n\n 2. We can group the vouchers by their duration. For a given duration d, we want to store all vouchers with that duration, but we also care about the intervals (l, r) and the cost.\n\n 3. However, we also need to check non-overlapping condition. The problem is that two vouchers might have the same duration, but we need to pick two that do not overlap.\n\n 4. Approach:\n    Let's create an array (or dictionary) `groups` where for each duration d (from 1 to maybe 200000, since x and days up to 200000) we store a list of (l, r, cost) for vouchers with duration d.\n\n    But note: the total duration x might be as large as 200000, so the two durations d1 and d2 must satisfy d1 + d2 = x. Then d1 from 1 to x-1, d2 = x - d1.\n\n    However, storing all vouchers by duration and then trying to combine two groups (for d and x-d) might lead to O(n^2) if we don't use smart data structures.\n\n 5. We need to avoid O(n^2). Instead, we can precompute for each duration d, the best cost for a voucher that ends at or before a certain point, and similarly the best cost for a voucher that starts at or after a certain point? But note the non-overlapping condition: we require either r_i < l_j or r_j < l_i.\n\n    Actually, the condition is that one voucher must end before the other starts. There are two cases:\n\n        Case 1: Voucher i (with duration d1) is taken first, then voucher j (duration d2) must start after i ends -> r_i < l_j.\n        Case 2: Voucher j is taken first, then voucher i must start after j ends -> r_j < l_i.\n\n    But note: the problem does not specify which comes first. However, the two vouchers are independent. We can consider:\n\n        We want to combine a voucher from group d1 and a voucher from group d2 (with d1+d2=x) such that they do not overlap.\n\n    This means: if we take a voucher i (l_i, r_i) and a voucher j (l_j, r_j), then either:\n        (a) r_i < l_j   OR\n        (b) r_j < l_i\n\n    But note: we cannot assume which one is taken first because the travel days might not be contiguous. However, the condition is just that the two intervals do not share any common day.\n\n    Actually, the condition \"don't intersect\" is defined as: \n        not ( [l_i, r_i] ∩ [l_j, r_j] ≠ ∅ )\n        which is equivalent to: r_i < l_j OR r_j < l_i.\n\n 6. Alternate approach:\n\n    We can break the problem into two parts:\n\n        Part 1: Precompute for each duration d, the minimal cost and the necessary information to enforce non-overlapping when combining with another duration.\n\n    However, note: even if two vouchers have the same duration, they might be from the same group (if x = 2*d). Then we need two distinct vouchers from the same group that do not overlap.\n\n 7. Steps:\n\n    a) Group the vouchers by duration. But note: the duration d can be from 1 to 200000 (since ri, li up to 200000, so d in [1, 200000]). We are only interested in durations d such that d <= x and x-d is also in the range [1, 200000].\n\n    b) For each duration d, we want to store the vouchers in a way that we can quickly query for a voucher that ends (r) before a given start (l) of the other, and vice versa.\n\n    But note: we are going to combine d and x-d. Then we have two sets: set1 for d, set2 for x-d.\n\n    We need to consider:\n\n",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Grouping by Duration**: First, we group all vouchers by their duration. For each duration `d`, we store a list of tuples containing the departure day `l`, return day `r`, and cost `cost` for each voucher of that duration.\n2. **Handling Each Duration Pair**: For each duration `d`, we consider its complement `x - d`. If both durations exist, we look for pairs of vouchers (one from each duration) that do not overlap.\n3. **Non-overlapping Condition**: Two vouchers do not overlap if one ends before the other starts. To efficiently find such pairs, we preprocess the vouchers for each duration. Specifically, for each duration, we sort the vouchers by their return day `r` and maintain a separate list sorted by departure day `l`.\n4. **Binary Search for Efficiency**: For each voucher in one duration group, we use binary search to find the best matching voucher in the complement group that does not overlap. The best match is determined by the minimal cost while ensuring the non-overlapping condition is met.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 200000\n    groups = [[] for _ in range(max_day + 1)]\n    for l, r, cost_val in vouchers:\n        d = r - l + 1\n        if d <= max_day:\n            groups[d].append((l, r, cost_val))\n    \n    for d in range(1, max_day + 1):\n        if groups[d]:\n            groups[d] = sorted(groups[d], key=lambda x: x[0])\n    \n    best_ans = float('inf')\n    comp_groups = {}\n    for d in range(1, max_day + 1):\n        if d == x - d:\n            continue\n        if x - d < 1 or x - d > max_day:\n            continue\n        if d in comp_groups:\n            continue\n        comp_groups[d] = x - d\n    \n    for d in range(1, max_day + 1):\n        if not groups[d] or not groups[x - d]:\n            continue\n        if d == x - d:\n            arr = groups[d]\n            arr.sort(key=lambda x: x[1])\n            prefix_min = [0] * len(arr)\n            if arr:\n                prefix_min[0] = arr[0][2]\n                for idx in range(1, len(arr)):\n                    prefix_min[idx] = min(prefix_min[idx - 1], arr[idx][2])\n            else:\n                continue\n            \n            suffix_min = [0] * len(arr)\n            if arr:\n                suffix_min[-1] = arr[-1][2]\n                for idx in range(len(arr) - 2, -1, -1):\n                    suffix_min[idx] = min(suffix_min[idx + 1], arr[idx][2])\n            \n            for i in range(len(arr)):\n                l_i, r_i, cost_i = arr[i]\n                j = bisect_right([a[0] for a in arr], r_i) - 1\n                if j < i:\n                    continue\n                if j >= 0 and j < len(arr):\n                    candidate_cost = cost_i + prefix_min[j]\n                    if candidate_cost < best_ans:\n                        best_ans = candidate_cost\n                if i + 1 < len(arr):\n                    candidate_cost = cost_i + suffix_min[i + 1]\n                    if candidate_cost < best_ans:\n                        best_ans = candidate_cost\n            continue\n        \n        d1 = d\n        d2 = x - d\n        list1 = groups[d1]\n        list2 = groups[d2]\n        list1.sort(key=lambda x: x[0])\n        list2.sort(key=lambda x: x[1])\n        \n        for l1, r1, c1 in list1:\n            pos = bisect_right([a[0] for a in list2], r1)\n            if pos == 0:\n                continue\n            if pos <= len(list2) - 1:\n                candidate = list2[pos - 1]\n                total_cost = c1 + candidate[2]\n                if total_cost < best_ans:\n                    best_ans = total_cost\n        \n        list2_sorted_by_l = sorted(list2, key=lambda x: x[0])\n        for l2, r2, c2 in list2_sorted_by_l:\n            pos = bisect_right([a[1] for a in list1], r2)\n            if pos == 0:\n                continue\n            if pos <= len(list1) - 1:\n                candidate = list1[pos - 1]\n                total_cost = candidate[2] + c2\n                if total_cost < best_ans:\n                    best_ans = total_cost\n    \n    print(-1 if best_ans == float('inf') else best_ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initialization**: The input is read and parsed into a list of vouchers. Each voucher is characterized by its departure day, return day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration (calculated as `return_day - departure_day + 1`). Each group is stored in a list where the index corresponds to the duration.\n3. **Sorting Groups**: For each duration, the vouchers are sorted by their departure day to facilitate efficient searching later.\n4. **Finding Valid Pairs**: For each duration `d`, the complement duration `x - d` is checked. If both durations exist, we look for pairs of vouchers (one from each duration) that do not overlap. This is done using binary search to find the best matching voucher in the complement group that ends before the current voucher starts.\n5. **Cost Calculation**: The minimal total cost for valid pairs is tracked throughout the process. If no valid pair is found, the output is `-1`; otherwise, the minimal cost is printed.\n\nThis approach efficiently narrows down the search space using grouping and sorting, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 200000\n    groups = [[] for _ in range(max_day + 1)]\n    for l, r, cost_val in vouchers:\n        d = r - l + 1\n        if d <= max_day:\n            groups[d].append((l, r, cost_val))\n    \n    for d in range(1, max_day + 1):\n        if groups[d]:\n            groups[d] = sorted(groups[d], key=lambda x: x[0])\n    \n    best_ans = float('inf')\n    comp_groups = {}\n    for d in range(1, max_day + 1):\n        if d == x - d:\n            continue\n        if x - d < 1 or x - d > max_day:\n            continue\n        if d in comp_groups:\n            continue\n        comp_groups[d] = x - d\n    \n    for d in range(1, max_day + 1):\n        if not groups[d] or not groups[x - d]:\n            continue\n        if d == x - d:\n            arr = groups[d]\n            arr.sort(key=lambda x: x[1])\n            prefix_min = [0] * len(arr)\n            if arr:\n                prefix_min[0] = arr[0][2]\n                for idx in range(1, len(arr)):\n                    prefix_min[idx] = min(prefix_min[idx - 1], arr[idx][2])\n            else:\n                continue\n            \n            suffix_min = [0] * len(arr)\n            if arr:\n                suffix_min[-1] = arr[-1][2]\n                for idx in range(len(arr) - 2, -1, -1):\n                    suffix_min[idx] = min(suffix_min[idx + 1], arr[idx][2])\n            \n            for i in range(len(arr)):\n                l_i, r_i, cost_i = arr[i]\n                j = bisect_right([a[0] for a in arr], r_i) - 1\n                if j < i:\n                    continue\n                if j >= 0 and j < len(arr):\n                    candidate_cost = cost_i + prefix_min[j]\n                    if candidate_cost < best_ans:\n                        best_ans = candidate_cost\n                if i + 1 < len(arr):\n                    candidate_cost = cost_i + suffix_min[i + 1]\n                    if candidate_cost < best_ans:\n                        best_ans = candidate_cost\n            continue\n        \n        d1 = d\n        d2 = x - d\n        list1 = groups[d1]\n        list2 = groups[d2]\n        list1.sort(key=lambda x: x[0])\n        list2.sort(key=lambda x: x[1])\n        \n        for l1, r1, c1 in list1:\n            pos = bisect_right([a[0] for a in list2], r1)\n            if pos == 0:\n                continue\n            if pos <= len(list2) - 1:\n                candidate = list2[pos - 1]\n                total_cost = c1 + candidate[2]\n                if total_cost < best_ans:\n                    best_ans = total_cost\n        \n        list2_sorted_by_l = sorted(list2, key=lambda x: x[0])\n        for l2, r2, c2 in list2_sorted_by_l:\n            pos = bisect_right([a[1] for a in list1], r2)\n            if pos == 0:\n                continue\n            if pos <= len(list1) - 1:\n                candidate = list1[pos - 1]\n                total_cost = candidate[2] + c2\n                if total_cost < best_ans:\n                    best_ans = total_cost\n    \n    print(-1 if best_ans == float('inf') else best_ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1389,
        "thoughts_token_count": 1023
    }
}