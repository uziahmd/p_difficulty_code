{
    "start": 1758296434.5836034,
    "end": 1758299367.6521974,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (with 1 <= a,b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b (if a < b then d is negative, but we can assume without loss of generality that we set x = a+k and y = b+k, then note that x-y = a-b is fixed).\n\nWe have: \n  Let g = gcd(a+k, b+k) = gcd(a+k, |a-b|)   [since gcd(x,y)=gcd(x,y-x)]\n\nThen, LCM(a+k, b+k) = (a+k)*(b+k) / g.\n\nNote: Since (a+k) and (b+k) share a divisor that divides |a-b|, we can set d = |a-b|.\n\nBut note: if a==b, then for k=0: LCM(a, a) = a, and for any k>0, the LCM becomes (a+k)*(a+k)/g, but g=gcd(a+k, a+k)=a+k, so LCM=(a+k)^2/(a+k)=a+k. Then we want the minimum k such that a+k is at least a (so k=0 is the best). So when a==b, answer is 0.\n\nNow, assume a != b. Without loss of generality, let d = abs(a-b). Then, for a given k, let:\n   x = a+k, y = b+k, and g = gcd(x,y) = gcd(x, d)\n\nWe know that g divides d. Therefore, the problem reduces to: we are looking for divisors of d (which will be the gcd) and then we can consider k such that g divides both x and y.\n\nBut note: k must be chosen so that (a+k) and (b+k) are divisible by g. Since g divides d, we can also note that:\n\n   Condition: g divides (a+k) and g divides (b+k) => g divides (a+k - (b+k)) = a-b, which is true because g divides d.\n\nHow to relate k to g? We require:\n   k ≡ (-a) mod g, and k ≡ (-b) mod g.\n\nBut note that since g divides d, and d = a-b (if a>=b, then d = a-b; if a<b, then d = b-a), then we can write:\n\n   Let g be a divisor of d. Then we need to find the smallest non-negative k such that g divides (a+k) (and hence (b+k)).\n\nThe smallest k for divisor g is: k = (g - a % g) % g, but wait: we require (a+k) mod g == 0. So k = (g - a%g) % g. However, note: if a % g == 0, then k=0. But also note that k must be non-negative.\n\nBut wait: actually, we can also consider that the condition is equivalent to k ≡ (-a) mod g. The smallest non-negative k for a divisor g is:\n\n   k0 = (-a) % g   [this gives the smallest non-negative residue]\n\nHowever, note: (-a) % g = (g - a % g) % g, but if a % g == 0, then (-a)%g=0.\n\nBut note: the divisor g must divide d. And then we can compute the LCM for that k0 (if k0 is the candidate for divisor g) and then take the minimum LCM over all divisors g of d?\n\nBut note: the LCM for k0 is: LCM = ((a+k0)*(b+k0)) // gcd(a+k0, b+k0)\n\nBut here's the catch: the gcd(a+k0, b+k0) might not necessarily be g? Actually, it is at least g, but note that g is defined as the gcd of (a+k0, d). However, we have that g divides d and also divides (a+k0) and (b+k0). But the actual gcd might be a multiple of g? Actually, no: the gcd must divide d, and we are only considering divisors of d. However, the gcd we get from the candidate k0 for divisor g might be a divisor of d that is greater than or equal to g? \n\nWait: actually, for k0 computed with divisor g, we have that g divides (a+k0) and (b+k0). But the gcd might be a multiple of g? Actually, no: the gcd must divide d, and d has divisors. We are iterating over div",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) is constant and equals \\( |a - b| \\). This means the greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must be a divisor of \\( |a - b| \\). \n\n2. **Insight**: For each divisor \\( g \\) of \\( |a - b| \\), we can determine the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). The LCM for such \\( k \\) can then be computed, and the minimal LCM across all divisors gives the solution.\n\n3. **Algorithm Selection**:\n   - **Case 1**: If \\( a = b \\), the answer is \\( k = 0 \\) because the LCM of two identical numbers is the number itself.\n   - **Case 2**: If \\( a \\neq b \\), compute all divisors of \\( |a - b| \\). For each divisor \\( g \\), compute the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is given by \\( (-a) \\mod g \\).\n   - **Compute LCM**: For each valid \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\) and keep track of the minimal LCM encountered.\n\n4. **Complexity Analysis**: The algorithm involves finding all divisors of \\( |a - b| \\), which for numbers up to \\( 10^9 \\) is efficient as the number of divisors is relatively small (typically around hundreds or thousands).\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = []\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.append(i)\n            if i != d // i:\n                divisors.append(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + 0) * (b + 0) // math.gcd(a, b)\n    \n    for g in divisors:\n        k = (-a) % g\n        num1 = a + k\n        num2 = b + k\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, it immediately returns \\( k = 0 \\) since the LCM is minimized at this point.\n3. **Divisor Calculation**: For \\( a \\neq b \\), the code calculates all divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\).\n4. **Finding Minimal LCM**: For each divisor \\( g \\), it computes the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). The LCM for this \\( k \\) is then calculated and compared to the current minimal LCM.\n5. **Output**: The smallest \\( k \\) yielding the minimal LCM is printed.\n\nThis approach efficiently narrows down the problem to checking divisors of the absolute difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large values.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = []\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.append(i)\n            if i != d // i:\n                divisors.append(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + 0) * (b + 0) // math.gcd(a, b)\n    \n    for g in divisors:\n        k = (-a) % g\n        num1 = a + k\n        num2 = b + k\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 926,
        "thoughts_token_count": 1023
    }
}