{
    "start": 1758294369.6171355,
    "end": 1758296428.9556272,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:40 KST",
    "gpu": 2,
    "pid": 41,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Zoning Restrictions Again\n\nYou are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.\n\n## Input\nThe first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$) — the number of spots, the maximum height, and the number of restrictions.Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$) — left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.\n\n## Output\nPrint a single integer, the maximum profit you can make.\n\n## Example\n### Input\n['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n### Output\n['14', '262']\n\n## Note\nIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Since n, m, h are at most 50, we can use dynamic programming with state (position, current height) but the restrictions might require knowing the maximum in intervals.\n\n However, note: There are up to 50 restrictions. Each restriction is a constraint on an interval [l_i, r_i] that the maximum height must be <= x_i.\n\n We cannot simply assign each house a value independently because of the constraints.\n\n Idea:\n 1. Preprocess the restrictions to find for each position i (from 1 to n) the minimum allowed maximum value in any interval that covers i.\n    Actually, we can define an array `max_height` for each position i: the minimum x_i from all restrictions that cover i? \n    But note: a restriction says \"the tallest house in [l_i, r_i] must be <= x_i\". This means that in that entire segment, no house can exceed x_i.\n\n    However, there might be multiple overlapping restrictions. For a given position i, we must satisfy all restrictions that include i.\n    So the condition for house i is: its height must be <= min_{for all restrictions covering i} (x_i). But wait: actually, the restriction only constrains the maximum in the segment. However, if we set the house i to a value that is <= the minimum of the x_i's of all restrictions that cover i, then we are safe for that house. However, note: the same house might be constrained by multiple restrictions, and the constraint on one restriction might be tighter than another.\n\n    But note: it is not enough to just look at the house itself. The restriction is about the entire segment. However, if we ensure that in every segment [l_i, r_i] the maximum height is <= x_i, then the house i must be <= x_i for every restriction that includes i. Therefore, the maximum value we can assign to house i is the minimum x_i among all restrictions that include i.\n\n    However, consider: what if two restrictions overlap but don't directly constrain the same house? Actually, the house i is included in a restriction if and only if the restriction's interval [l_i, r_i] contains i.\n\n    Therefore, we can compute for each position i:\n        low[i] = min{ x_i | the restriction j has l_j <= i <= r_j }\n\n    But note: there might be no restriction covering i? Then we should set low[i] = h (since the overall maximum height is h). However, wait: the problem states that in each spot the height can be between 0 and h. But without any restriction, we can set up to h.\n\n    However, the example input: \n        \"4 10 2\\n2 3 8\\n3 4 7\"\n        For house 1: no restriction -> so maximum allowed is 10.\n        For house 2: covered by first restriction (x=8) -> so maximum 8.\n        For house 3: covered by both -> minimum(8,7)=7.\n        For house 4: covered by second restriction (x=7) -> so maximum 7.\n\n    But wait: the example output uses [10,8,7,7]. So house 1 is 10, which is the maximum overall (h=10). House 2 is 8, house 3 and 4 are 7.\n\n    However, note the second restriction says the tallest house in [3,4] must be at most 7. So house 3 must be at most 7, and house 4 at most 7. But house 1 is not constrained by any restriction, so we can set it to 10.\n\n    So we can define for each position i: \n        allowed[i] = min( h, min_{j such that l_j<=i<=r_j} (x_j) )   [but wait: actually, we don't want to cap by h here because h is the global maximum. However, if a restriction gives an x_j < h, then we must use that. But if no restriction, then we use h.]\n\n    However, note: the problem says \"each spot, you can build a house with an integer height between 0 and h\". So without restriction, the maximum is h. And a restriction with x_j might be less than h, then we must use x_j. So:\n\n        allowed[i] = min_{all restrictions j that cover i} (x_j)   if there is at least one restriction covering i, otherwise h.\n\n    But wait: what if there are multiple restrictions? Then we take the minimum x_j. However, note: the restrictions are independent and must be satisfied. So if a house is covered by two restrictions, say one says <=5 and another says <=10, then we must satisfy <=5.\n\n    However, the above does",
    "response": "\nTo solve this problem, we need to maximize the profit from building houses on a street while adhering to zoning restrictions. The profit is calculated as the sum of the squares of the heights of the houses built on each spot. The constraints require that in certain intervals, the maximum height of any house within that interval does not exceed a specified value.\n\n### Approach\n1. **Problem Analysis**: The problem involves selecting heights for each house such that all zoning restrictions are satisfied. Each restriction specifies that the tallest house in a particular interval must not exceed a given height. The goal is to maximize the sum of the squares of the selected heights.\n\n2. **Key Insight**: For each position on the street, the maximum allowable height is determined by the most restrictive zoning restriction that includes that position. This means for each position `i`, we compute the minimum value among all `x_i` from restrictions that include `i`. If no restrictions apply, the maximum height is the global maximum `h`.\n\n3. **Dynamic Programming (DP) Setup**: We use a DP approach where `dp[i][j]` represents the maximum profit achievable from the first `i` positions with the `i-th` position having height `j`. The solution involves iterating over each position and each possible height, updating the DP table based on the constraints.\n\n4. **DP Transition**: For each position `i` and each possible height `j` (from 0 to `allowed[i]`), the profit is updated by considering the profit from previous positions and adding the square of the current height. The transition ensures that all constraints are respected by only allowing heights up to the computed `allowed[i]`.\n\n5. **Result Extraction**: The result is found in `dp[n][j]` for the maximum `j` (height) at the last position, but actually, we take the maximum value across all possible heights at the last position.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    h_global = int(data[1])\n    m = int(data[2])\n    \n    allowed = [h_global] * (n + 1)\n    \n    idx = 3\n    restrictions = []\n    for _ in range(m):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        x_val = int(data[idx + 2])\n        idx += 3\n        restrictions.append((l, r, x_val))\n        \n    for i in range(1, n + 1):\n        min_x = h_global\n        for (l, r, x_val) in restrictions:\n            if l <= i <= r:\n                if x_val < min_x:\n                    min_x = x_val\n        allowed[i] = min_x\n\n    dp = [[-1] * (h_global + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(0, allowed[i] + 1):\n            prev_max = -1\n            for k in range(i):\n                if dp[k][j] != -1:\n                    if j > allowed[k]:\n                        continue\n                    if prev_max < dp[k][j]:\n                        prev_max = dp[k][j]\n            if prev_max == -1:\n                dp[i][j] = j * j\n            else:\n                dp[i][j] = prev_max + j * j\n                \n    ans = 0\n    for j in range(0, allowed[n] + 1):\n        if ans < dp[n][j]:\n            ans = dp[n][j]\n            \n    print(ans)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into integers representing the number of spots (`n`), the global maximum height (`h_global`), and the number of restrictions (`m`). The restrictions are stored in a list.\n\n2. **Computing Allowed Heights**: For each position from 1 to `n`, the maximum allowable height is determined by checking all restrictions that include that position. The smallest `x_i` from these restrictions is chosen; if no restrictions apply, the global maximum `h_global` is used.\n\n3. **Dynamic Programming Initialization**: A DP table `dp` is initialized with dimensions `(n+1) x (h_global+1)` to store the maximum profit up to each position for each possible height.\n\n4. **DP Table Population**: For each position `i` and each possible height `j` (up to `allowed[i]`), the DP table is updated by considering the maximum profit from all previous positions that allow the current height `j`. The profit for the current position is then the sum of the previous maximum profit and the square of `j`.\n\n5. **Result Calculation**: The maximum value in the last row of the DP table (corresponding to the last position) is printed as the result, representing the highest possible profit under the given constraints.\n\nThis approach efficiently handles the constraints using dynamic programming, ensuring optimal profit while respecting all zoning restrictions.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    h_global = int(data[1])\n    m = int(data[2])\n    \n    allowed = [h_global] * (n + 1)\n    \n    idx = 3\n    restrictions = []\n    for _ in range(m):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        x_val = int(data[idx + 2])\n        idx += 3\n        restrictions.append((l, r, x_val))\n        \n    for i in range(1, n + 1):\n        min_x = h_global\n        for (l, r, x_val) in restrictions:\n            if l <= i <= r:\n                if x_val < min_x:\n                    min_x = x_val\n        allowed[i] = min_x\n\n    dp = [[-1] * (h_global + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(0, allowed[i] + 1):\n            prev_max = -1\n            for k in range(i):\n                if dp[k][j] != -1:\n                    if j > allowed[k]:\n                        continue\n                    if prev_max < dp[k][j]:\n                        prev_max = dp[k][j]\n            if prev_max == -1:\n                dp[i][j] = j * j\n            else:\n                dp[i][j] = prev_max + j * j\n                \n    ans = 0\n    for j in range(0, allowed[n] + 1):\n        if ans < dp[n][j]:\n            ans = dp[n][j]\n            \n    print(ans)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 823,
        "completion_token_count": 1075,
        "thoughts_token_count": 1023
    }
}