{
    "start": 1758088073.4770901,
    "end": 1758089210.3070142,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:06 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of [l, r, cost]\n Conditions:\n   Two vouchers i and j must have total duration = x (i.e., (r_i - l_i + 1) + (r_j - l_j + 1) = x)\n   They must not intersect: either voucher i ends before voucher j starts (r_i < l_j) or voucher j ends before voucher i starts (r_j < l_i)\n\n Steps:\n   1. We note that the total duration is x, so if we let d_i = (r_i - l_i + 1), then we need two vouchers i and j such that d_i + d_j = x.\n\n   2. We cannot try all pairs because n can be up to 200,000.\n\n Approach:\n   We can preprocess the vouchers by grouping them by duration. But note: the condition also involves non-overlapping intervals.\n\n   However, note that the problem requires two disjoint vouchers. There are two possibilities for disjointness: \n        a) [voucher i] ends before [voucher j] starts (so r_i < l_j)\n        b) [voucher j] ends before [voucher i] starts (so r_j < l_i)\n\n   Since the two vouchers are symmetric, we can consider one ordering (say, by the start day) and then check the other.\n\n   Alternate approach:\n\n   Let's define:\n        A = list of all vouchers.\n\n   We want to find two vouchers (i, j) such that:\n        d_i + d_j = x, and (r_i < l_j OR r_j < l_i)\n\n   We can break the problem into two cases:\n\n   Case 1: The first voucher ends before the second starts (r_i < l_j). Then we require:\n        d_i + d_j = x, and r_i < l_j.\n\n   Case 2: The second voucher ends before the first starts (r_j < l_i). Then similarly.\n\n   But note: the two conditions are symmetric. So we can assume without loss of generality that we look for pairs (i, j) with r_i < l_j, and then also look for pairs (j, i) with r_j < l_i? Actually, the problem condition is symmetric: if we swap i and j, then condition becomes the same. So we can just consider one order, but we have to consider both orders of the two vouchers? Actually, no: we can fix one voucher and look for the other.\n\n   However, note that the two vouchers are distinct and we are allowed to take any two. So we can consider two scenarios:\n\n   Scenario 1: First voucher ends before the second starts (r_i < l_j)\n   Scenario 2: Second voucher ends before the first starts (r_j < l_i)\n\n   But these are the same condition in different orders. Actually, we can combine: we require that the two intervals do not overlap, which is equivalent to: max(r_i, r_j) < min(l_i, l_j)? No, actually: \n        Condition: (r_i < l_j) OR (r_j < l_i)\n\n   Alternatively, we can think: the two intervals are disjoint if they do not share any common day. \n\n   How to solve?\n\n   Idea:\n\n   Step 1: Precompute for each voucher i: duration = d_i = r_i - l_i + 1.\n\n   Step 2: We want to group the vouchers by duration. For each duration d, we have a list of vouchers (each voucher has l, r, cost) that have that duration.\n\n   But note: we also need to consider the intervals for non-overlapping condition.\n\n   Alternatively, we can use two pointers or dynamic programming by processing the vouchers in a sorted way.\n\n   Let's try:\n\n   We can sort the vouchers by their start day (or end day) and then use a two-pointer technique or binary search.\n\n   However, we have two conditions: one for the duration and the other for non-overlapping.\n\n   Another idea:\n\n   Let F(d) be the minimal cost for a voucher of duration d that ends by day t (for some t). But we have two vouchers and they must not overlap.\n\n   We can break the problem:\n\n   We are going to consider pairs (d, x-d). Then for each d, we want to find a voucher i with duration d and a voucher j with duration x-d such that they do not overlap.\n\n   How to check non-overlap? It is equivalent to: \n        (voucher i's end < voucher j's start) OR (voucher j's end < voucher i's start)\n\n   We can precompute two sets of vouchers:\n\n        Set1: All vouchers, grouped by duration. Then for each duration d, we have a list of (l, r, cost).\n\n   Then for each duration d, we want",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Problem Analysis**: The problem requires selecting two non-overlapping vouchers where the sum of their durations is exactly `x`. The key challenge is efficiently checking all possible pairs without resorting to a brute-force approach, which would be computationally expensive for large inputs.\n\n2. **Intuition**: \n   - **Grouping by Duration**: We first group all vouchers by their duration. This allows us to quickly access all vouchers that could potentially form a pair with another voucher to meet the total duration requirement (i.e., if one voucher has duration `d`, the other must have duration `x - d`).\n   - **Non-overlapping Condition**: For each voucher, we need to check if there exists another voucher that does not overlap with it. This involves ensuring that either the first voucher ends before the second starts or vice versa.\n\n3. **Algorithm Selection**:\n   - **Sorting and Binary Search**: We sort all vouchers by their end dates (or start dates) to facilitate efficient searching for non-overlapping vouchers. For each voucher, we use binary search to find the best matching voucher that meets the duration and non-overlapping conditions.\n   - **Two-Pointer Technique**: Alternatively, we can use a two-pointer technique on sorted lists of vouchers to efficiently find pairs that meet the criteria. However, given the constraints, a more optimal approach involves precomputing and storing the best costs for vouchers grouped by their duration and end dates.\n\n4. **Complexity Analysis**: \n   - **Time Complexity**: The solution involves sorting the vouchers, which takes O(n log n) time. The subsequent steps involve iterating through each duration group and performing binary searches, each taking O(log n) time per operation. Thus, the overall complexity is O(n log n), which is efficient for the given constraints.\n   - **Space Complexity**: We use additional space to store groups of vouchers by duration and their end dates, resulting in O(n) space complexity.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    durations = []\n    \n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        d = r - l + 1\n        durations.append(d)\n        \n    d_to_vouchers = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        d = r - l + 1\n        d_to_vouchers[d].append((l, r, cost_val))\n        \n    end_date_dict = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        end_date_dict[r].append((l, cost_val))\n        \n    for d in d_to_vouchers:\n        d_to_vouchers[d] = sorted(d_to_vouchers[d], key=lambda x: x[1])\n        \n    end_date_dict_sorted = {}\n    for date in end_date_dict:\n        end_date_dict_sorted[date] = sorted(end_date_dict[date], key=lambda x: x[0])\n        \n    min_total_cost = float('inf')\n    \n    for d in d_to_vouchers:\n        other_d = x - d\n        if other_d < 0:\n            continue\n        if other_d == d:\n            list1 = d_to_vouchers[d]\n            for voucher in list1:\n                l1, r1, c1 = voucher\n                target_start = r1 + 1\n                if target_start > 200000:\n                    continue\n                arr = d_to_vouchers[d]\n                low = 0\n                high = len(arr) - 1\n                candidate = None\n                while low <= high:\n                    mid = (low + high) // 2\n                    l_mid, r_mid, c_mid = arr[mid]\n                    if l_mid >= target_start:\n                        candidate = (c1 + c_mid, l_mid, r_mid, c_mid)\n                        break\n                    else:\n                        low = mid + 1\n                if candidate:\n                    total_cost = candidate[0]\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n            continue\n            \n        if other_d in d_to_vouchers:\n            list1 = d_to_vouchers[d]\n            list2 = d_to_vouchers[other_d]\n            for voucher in list1:\n                l1, r1, c1 = voucher\n                target_start = r1 + 1\n                if target_start > 200000:\n                    continue\n                arr = list2\n                low = 0\n                high = len(arr) - 1\n                candidate = None\n                while low <= high:\n                    mid = (low + high) // 2\n                    l_mid, r_mid, c_mid = arr[mid]\n                    if l_mid >= target_start:\n                        candidate = (c1 + c_mid, l_mid, r_mid, c_mid)\n                        break\n                    else:\n                        low = mid + 1\n                if candidate:\n                    total_cost = candidate[0]\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by its start day, end day, and cost.\n2. **Grouping Vouchers**: Vouchers are grouped by their duration (end day minus start day plus one). This helps in quickly finding vouchers that can form a pair with a given duration.\n3. **Sorting Vouchers**: Within each duration group, vouchers are sorted by their cost to facilitate finding the minimum cost pair efficiently.\n4. **Finding Valid Pairs**: For each voucher, we determine if there exists another voucher of complementary duration (i.e., `x - current duration`) that does not overlap in time. This is done using binary search to find the earliest starting voucher that begins after the current voucher ends.\n5. **Output Result**: The minimum total cost of valid pairs is printed. If no such pair exists, `-1` is printed.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    durations = []\n    \n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        d = r - l + 1\n        durations.append(d)\n        \n    d_to_vouchers = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        d = r - l + 1\n        d_to_vouchers[d].append((l, r, cost_val))\n        \n    end_date_dict = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        end_date_dict[r].append((l, cost_val))\n        \n    for d in d_to_vouchers:\n        d_to_vouchers[d] = sorted(d_to_vouchers[d], key=lambda x: x[1])\n        \n    end_date_dict_sorted = {}\n    for date in end_date_dict:\n        end_date_dict_sorted[date] = sorted(end_date_dict[date], key=lambda x: x[0])\n        \n    min_total_cost = float('inf')\n    \n    for d in d_to_vouchers:\n        other_d = x - d\n        if other_d < 0:\n            continue\n        if other_d == d:\n            list1 = d_to_vouchers[d]\n            for voucher in list1:\n                l1, r1, c1 = voucher\n                target_start = r1 + 1\n                if target_start > 200000:\n                    continue\n                arr = d_to_vouchers[d]\n                low = 0\n                high = len(arr) - 1\n                candidate = None\n                while low <= high:\n                    mid = (low + high) // 2\n                    l_mid, r_mid, c_mid = arr[mid]\n                    if l_mid >= target_start:\n                        candidate = (c1 + c_mid, l_mid, r_mid, c_mid)\n                        break\n                    else:\n                        low = mid + 1\n                if candidate:\n                    total_cost = candidate[0]\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n            continue\n            \n        if other_d in d_to_vouchers:\n            list1 = d_to_vouchers[d]\n            list2 = d_to_vouchers[other_d]\n            for voucher in list1:\n                l1, r1, c1 = voucher\n                target_start = r1 + 1\n                if target_start > 200000:\n                    continue\n                arr = list2\n                low = 0\n                high = len(arr) - 1\n                candidate = None\n                while low <= high:\n                    mid = (low + high) // 2\n                    l_mid, r_mid, c_mid = arr[mid]\n                    if l_mid >= target_start:\n                        candidate = (c1 + c_mid, l_mid, r_mid, c_mid)\n                        break\n                    else:\n                        low = mid + 1\n                if candidate:\n                    total_cost = candidate[0]\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1420,
        "thoughts_token_count": 1023
    }
}