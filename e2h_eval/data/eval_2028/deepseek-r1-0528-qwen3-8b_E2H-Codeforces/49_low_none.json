{
    "start": 1758303144.2649658,
    "end": 1758306659.7894611,
    "start-formatted": "2025-09-20 02:32 KST",
    "end-formatted": "2025-09-20 03:30 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given n, m and then m lines each with four numbers: a, b, g, l (the two lawns connected and the gcd and lcm)\n We need to assign to each lawn i a number x_i (at least 1) such that for every edge (a, b, g, l):\n   gcd(x_a, x_b) = g and lcm(x_a, x_b) = l.\n\n Note: For any two numbers x and y, we have:\n   x * y = gcd(x,y) * lcm(x,y)\n\n So for an edge (a, b, g, l): x_a * x_b must equal g * l.\n\n Steps:\n\n 1. Check consistency of the input: for an edge (a, b, g, l), if g > l then it's invalid.\n    Also, note that g must divide both numbers, and l must be divisible by g, and also the product condition: g*l must be divisible by g (which is true) and also note that x_a and x_b must be multiples of g.\n\n 2. Moreover, from the equation: x_a * x_b = g * l, and we know that x_a and x_b must be multiples of g, so let x_a = g * a', x_b = g * b'. Then:\n        (g * a') * (g * b') = g * l  =>  g^2 * a' * b' = g * l  =>  g * a' * b' = l.\n    Then, we can write: a' * b' = l / g.\n\n    But note: l must be divisible by g? Actually, from the definition, since g divides both numbers, then g divides the gcd and hence divides the lcm as well? Actually, yes: because the lcm is a multiple of the gcd.\n\n    However, wait: the problem says \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 10^6\", but note the input might have an edge where g does not divide l? Then we can immediately say \"NO\".\n\n    Actually, by the properties of gcd and lcm: \n        gcd(a,b) * lcm(a,b) = a*b, and also lcm(a,b) must be divisible by gcd(a,b). So we must have that g divides l.\n\n    Therefore, we can check: for each edge, if l % g != 0, then output \"NO\".\n\n 3. Then, for the edge (a, b, g, l): we have a' * b' = l//g. And note that the original numbers are x_a = g * a', x_b = g * b'.\n\n    Also, we know that the gcd(x_a, x_b) = g * gcd(a', b') must be g. So gcd(a', b') must be 1.\n\n    So we require that a' and b' are coprime and their product is l//g.\n\n    However, note: there might be multiple factorizations of l//g into two factors (a', b') such that a' * b' = l//g and gcd(a',b')=1.\n\n    But note: the entire graph structure must be consistent. We have multiple edges and nodes, so we cannot assign arbitrarily.\n\n 4. Approach:\n\n    We can use a graph to represent the constraints. Each node has an unknown value, but we can express the value in terms of the base g and the factor a'.\n\n    However, note that the same node might appear in multiple edges. So we need to assign one value per node.\n\n    Alternate approach:\n\n        Let's denote the value for node i as x_i.\n\n        For an edge (u, v, g, l):\n            x_u * x_v = g * l\n            and gcd(x_u, x_v) = g\n\n        Since x_u and x_v must be multiples of g, we can write x_u = g * u_i, x_v = g * v_i, and then u_i * v_i = L, where L = l // g, and gcd(u_i, v_i) = 1.\n\n        Now, consider the entire graph. The assignment for each node is defined by the base g (which is fixed for all edges incident to the node) and the factor.\n\n        But note: the base g for edges may be different for different edges incident to the same node. This is a problem because if a node appears in two edges with different gcds, then the base g would conflict.\n\n        Actually, for a node, the value x must be divisible by all the gcds of the edges incident to it? Not necessarily, but note: if two edges incident to the same node have different gcds, then the node's value must be divisible by both. Therefore, the value must be divisible by the least",
    "response": "\nTo solve this problem, we need to determine if it's possible to assign numbers of mushrooms to each lawn (vertex) in a graph such that for every given edge, the greatest common divisor (GCD) and least common multiple (LCM) of the numbers on its two connected lawns match the provided values. The solution involves verifying the consistency of the input data and then solving a system of equations derived from these constraints.\n\n### Approach\n1. **Initial Checks**: For each edge, verify that the LCM is divisible by the GCD. If not, output \"NO\" immediately as it's impossible to satisfy the conditions.\n2. **Graph Construction**: Construct an adjacency list where each node stores edges connected to it along with their GCD and LCM values.\n3. **Component Processing**: Process each connected component of the graph separately. For each node, compute the product of the base value (GCD) and the factor derived from the LCM divided by the GCD.\n4. **Factor Assignment**: Ensure that for each edge, the product of the factors of the two nodes equals the LCM divided by the GCD, and that these factors are coprime.\n5. **Consistency Check**: Verify that all edges within a connected component have consistent assignments. If any inconsistency is found, output \"NO\". Otherwise, output \"YES\" along with the assigned mushroom counts for each node.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\nimport math\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        a = int(data[index]); b = int(data[index+1]); g = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((a, b, g, l_val))\n        graph[a].append((b, g, l_val))\n        graph[b].append((a, g, l_val))\n        \n    valid = True\n    for (a, b, g, l_val) in edges:\n        if l_val % g != 0:\n            valid = False\n            \n    if not valid:\n        print(\"NO\")\n        return\n        \n    factors = [0] * (n+1)\n    base = [0] * (n+1)\n    for i in range(1, n+1):\n        base[i] = None\n        \n    for (a, b, g, l_val) in edges:\n        temp_base = g\n        temp_factor = l_val // g\n        if base[a] is None and base[b] is None:\n            base[a] = temp_base\n            base[b] = temp_base\n            factors[a] = temp_factor\n            factors[b] = temp_factor\n        elif base[a] is not None and base[b] is None:\n            if base[a] != temp_base:\n                valid = False\n            factors[b] = temp_factor\n            base[b] = temp_base\n        elif base[b] is not None and base[a] is None:\n            if base[b] != temp_base:\n                valid = False\n            factors[a] = temp_factor\n            base[a] = temp_base\n        else:\n            if base[a] != temp_base or factors[a] * factors[b] != temp_factor:\n                valid = False\n            if math.gcd(factors[a], factors[b]) != 1:\n                valid = False\n                \n    if not valid:\n        print(\"NO\")\n        return\n        \n    visited = [False] * (n+1)\n    result = [0] * (n+1)\n    components = []\n    comp_index = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            comp_nodes = []\n            stack = [i]\n            visited[i] = True\n            while stack:\n                node = stack.pop()\n                comp_nodes.append(node)\n                for neighbor, g_val, l_val in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        stack.append(neighbor)\n            components.append(comp_nodes)\n            \n    for comp in components:\n        comp_factors = {}\n        comp_base = {}\n        for node in comp:\n            if base[node] is not None:\n                comp_base[node] = base[node]\n                comp_factors[node] = factors[node]\n                \n        for node in comp:\n            if len(graph[node]) == 0:\n                result[node] = comp_base[node] * comp_factors[node]\n            else:\n                break\n                \n        if len(comp) == 1:\n            continue\n            \n        q = deque()\n        for node in comp:\n            if len(graph[node]) == 1:\n                q.append(node)\n                \n        while q:\n            node = q.popleft()\n            for neighbor, g_val, l_val in graph[node]:\n                if neighbor == node:\n                    continue\n                if base[neighbor] is not None:\n                    continue\n                factors[neighbor] = factors[node] * (l_val // g_val) // factors[node]\n                base[neighbor] = g_val\n                result[neighbor] = g_val * factors[neighbor]\n                visited_neighbor = False\n                for nbh, g_val2, l_val2 in graph[neighbor]:\n                    if nbh == node:\n                        continue\n                    if base[nbh] is not None:\n                        if factors[neighbor] * factors[nbh] != l_val2 // g_val2 or math.gcd(factors[neighbor], factors[nbh]) != 1:\n                            valid = False\n                        visited_neighbor = True\n                if not visited_neighbor:\n                    q.append(neighbor)\n                    \n        for node in comp:\n            if base[node] is None:\n                continue\n            for neighbor, g_val, l_val in graph[node]:\n                if base[neighbor] is None:\n                    continue\n                if factors[node] * factors[neighbor] != l_val // g_val or math.gcd(factors[node], factors[neighbor]) != 1:\n                    valid = False\n                    \n    if not valid:\n        print(\"NO\")\n        return\n        \n    for i in range(1, n+1):\n        if base[i] is None:\n            if any(base[j] is not None for j in graph[i]):\n                valid = False\n            else:\n                result[i] = 1\n        else:\n            result[i] = base[i] * factors[i]\n            \n    if not valid:\n        print(\"NO\")\n        return\n        \n    print(\"YES\")\n    out_str = \"\\n\" + \" \".join(str(result[i]) for i in range(1, n+1))\n    print(out_str)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Initial Checks**: The code first checks if the LCM for each edge is divisible by the GCD. If not, it immediately outputs \"NO\".\n2. **Graph Construction**: The graph is built using an adjacency list where each node stores connected edges along with their GCD and LCM values.\n3. **Component Processing**: The graph is split into connected components. For each node, the base value (GCD) and factor (LCM divided by GCD) are stored.\n4. **Factor Assignment**: The code ensures that for each edge, the product of the factors of the two nodes matches the LCM divided by the GCD, and that these factors are coprime.\n5. **Consistency Check**: Within each connected component, the code checks if the assignments are consistent. If any inconsistency is found, it outputs \"NO\"; otherwise, it outputs \"YES\" followed by the assigned mushroom counts for each node.\n\nThis approach efficiently checks the feasibility of the mushroom assignment and constructs a valid solution if possible.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\nimport math\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        a = int(data[index]); b = int(data[index+1]); g = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((a, b, g, l_val))\n        graph[a].append((b, g, l_val))\n        graph[b].append((a, g, l_val))\n        \n    valid = True\n    for (a, b, g, l_val) in edges:\n        if l_val % g != 0:\n            valid = False\n            \n    if not valid:\n        print(\"NO\")\n        return\n        \n    factors = [0] * (n+1)\n    base = [0] * (n+1)\n    for i in range(1, n+1):\n        base[i] = None\n        \n    for (a, b, g, l_val) in edges:\n        temp_base = g\n        temp_factor = l_val // g\n        if base[a] is None and base[b] is None:\n            base[a] = temp_base\n            base[b] = temp_base\n            factors[a] = temp_factor\n            factors[b] = temp_factor\n        elif base[a] is not None and base[b] is None:\n            if base[a] != temp_base:\n                valid = False\n            factors[b] = temp_factor\n            base[b] = temp_base\n        elif base[b] is not None and base[a] is None:\n            if base[b] != temp_base:\n                valid = False\n            factors[a] = temp_factor\n            base[a] = temp_base\n        else:\n            if base[a] != temp_base or factors[a] * factors[b] != temp_factor:\n                valid = False\n            if math.gcd(factors[a], factors[b]) != 1:\n                valid = False\n                \n    if not valid:\n        print(\"NO\")\n        return\n        \n    visited = [False] * (n+1)\n    result = [0] * (n+1)\n    components = []\n    comp_index = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            comp_nodes = []\n            stack = [i]\n            visited[i] = True\n            while stack:\n                node = stack.pop()\n                comp_nodes.append(node)\n                for neighbor, g_val, l_val in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        stack.append(neighbor)\n            components.append(comp_nodes)\n            \n    for comp in components:\n        comp_factors = {}\n        comp_base = {}\n        for node in comp:\n            if base[node] is not None:\n                comp_base[node] = base[node]\n                comp_factors[node] = factors[node]\n                \n        for node in comp:\n            if len(graph[node]) == 0:\n                result[node] = comp_base[node] * comp_factors[node]\n            else:\n                break\n                \n        if len(comp) == 1:\n            continue\n            \n        q = deque()\n        for node in comp:\n            if len(graph[node]) == 1:\n                q.append(node)\n                \n        while q:\n            node = q.popleft()\n            for neighbor, g_val, l_val in graph[node]:\n                if neighbor == node:\n                    continue\n                if base[neighbor] is not None:\n                    continue\n                factors[neighbor] = factors[node] * (l_val // g_val) // factors[node]\n                base[neighbor] = g_val\n                result[neighbor] = g_val * factors[neighbor]\n                visited_neighbor = False\n                for nbh, g_val2, l_val2 in graph[neighbor]:\n                    if nbh == node:\n                        continue\n                    if base[nbh] is not None:\n                        if factors[neighbor] * factors[nbh] != l_val2 // g_val2 or math.gcd(factors[neighbor], factors[nbh]) != 1:\n                            valid = False\n                        visited_neighbor = True\n                if not visited_neighbor:\n                    q.append(neighbor)\n                    \n        for node in comp:\n            if base[node] is None:\n                continue\n            for neighbor, g_val, l_val in graph[node]:\n                if base[neighbor] is None:\n                    continue\n                if factors[node] * factors[neighbor] != l_val // g_val or math.gcd(factors[node], factors[neighbor]) != 1:\n                    valid = False\n                    \n    if not valid:\n        print(\"NO\")\n        return\n        \n    for i in range(1, n+1):\n        if base[i] is None:\n            if any(base[j] is not None for j in graph[i]):\n                valid = False\n            else:\n                result[i] = 1\n        else:\n            result[i] = base[i] * factors[i]\n            \n    if not valid:\n        print(\"NO\")\n        return\n        \n    print(\"YES\")\n    out_str = \"\\n\" + \" \".join(str(result[i]) for i in range(1, n+1))\n    print(out_str)\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1655,
        "thoughts_token_count": 1023
    }
}