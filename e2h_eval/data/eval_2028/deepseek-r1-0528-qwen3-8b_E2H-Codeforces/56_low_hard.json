{
    "start": 1758294378.4015172,
    "end": 1758296581.040568,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:43 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given up to 10 spaceships and 10 bases. We need to check if there is a perfect matching (i.e., a bijection) between the R spaceships and B bases such that the straight lines connecting each spaceship to its base do not intersect.\n\n Conditions:\n - Each base must be connected to exactly one spaceship and vice versa.\n - The straight lines (in the galaxy plane) must not intersect (except at the endpoints, which are distinct points).\n\n Note: It is guaranteed that no two points coincide and that no three points are collinear.\n\n However, note that the problem says \"any two (straight) paths\" (from a base to its assigned spaceship) do not intersect. This means that we have a set of line segments (each from a base to a spaceship) and they must not cross.\n\n Since R and B are at most 10, we can try to use a combinatorial approach. But note: we have two sets (spaceships and bases) and we are looking for a perfect matching (if R != B then we cannot have a perfect matching). However, the problem says \"assign R Rebel spaceships to guard B bases so that every base has exactly one guardian\", meaning that we are only considering bases? Actually, note: the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so the assignment is a bijection between the R spaceships and the B bases. Therefore, we must have R = B. Otherwise, it's impossible.\n\n So first, check if R == B. If not, output 'No'.\n\n Now, if R == B, we have to assign each spaceship to a base. The condition is that the straight lines (segments) connecting the pairs must not intersect.\n\n How to check for non-intersecting segments?\n We have a set of n = R segments (n = B as well) and they must not cross. However, note that these segments are from two sets: the spaceships and the bases. But the problem does not specify which set is which. Actually, the input gives first R lines for spaceships and then B lines for bases.\n\n Steps:\n\n 1. Check if R != B -> output 'No'\n\n 2. We have two lists: \n    - spaceships = list of (x, y) for the first R points\n    - bases = list of (x, y) for the next B points\n\n 3. We need to assign each spaceship to a base. There are R! assignments. Since R<=10, we can iterate over all permutations (R! up to 10! ~ 400000) but wait: 10! is 3628800, which is too many in worst-case. However, note that we have two sets of size 10, and we are matching the first set (spaceships) to the second set (bases). So we can consider all permutations of the base indices (size 10) and check the condition.\n\n Alternatively, we can use a recursive backtracking or even better: we can use the fact that the condition of non-intersecting segments is related to planarity and ordering.\n\n But note: we are only drawing segments between two sets. There is a known fact: if we fix an order for one set (say, sort the spaceships by x-coordinate) and then assign the bases in an order that is compatible (i.e., the order of the bases by x-coordinate must be the same as the order of the spaceships' connections) then the segments might not cross? Actually, the problem is similar to matching two sets of points (like bipartite matching) and ensuring that the matching is non-crossing.\n\n However, note: the bases and spaceships are given arbitrarily. We can sort both sets by x-coordinate (and if same x, by y-coordinate) and then try to assign the smallest base to the smallest spaceship, next to next, etc. But wait: is that always the case? \n\n Actually, the non-crossing condition is equivalent to: when we draw the segments, if we order the spaceships by increasing x, then the corresponding bases must appear in increasing order of x as well (if we ignore the y-coordinate)? Not exactly, because the segments are straight lines and they might cross even if the x-order is preserved, but actually the standard non-crossing condition for two sets is that the permutation of the bases must be the same as the permutation of the spaceships (when both are sorted by x). But note: the problem does not require that the matching is the identity after sorting. \n\n Actually, there is a well-known fact: for two sets of points (each sorted by x) the non-crossing matching is achieved by matching the i-th smallest x in the first set to the i-th smallest x in the second set? Not necessarily, because the sets are independent. However, we can use the",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking all possible permutations of assignments between the two sets and verifying the non-intersection condition for each permutation.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijection) between two sets of points (spaceships and bases) such that the line segments connecting them do not intersect. Given the constraints (R and B are at most 10), a brute-force approach is feasible.\n2. **Key Insight**: For each permutation of base assignments to spaceships, we check if the line segments formed by these assignments intersect. If any permutation satisfies the condition, the answer is \"Yes\"; otherwise, it's \"No\".\n3. **Algorithm Selection**: \n   - **Check Cardinality**: If the number of spaceships (R) does not equal the number of bases (B), output \"No\" immediately since a perfect matching is impossible.\n   - **Permutations Check**: For each permutation of base indices, compute the line segments from each spaceship to its assigned base and verify that no two segments intersect.\n   - **Non-Intersection Check**: Two segments (p1, q1) and (p2, q2) intersect if the points q1 and q2 lie on opposite sides of the line defined by p1 and p2, or vice versa. This is checked using the cross product method to determine the relative orientation of points.\n\n### Solution Code\n```python\nimport itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    \n    index = 2\n    spaceships = []\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        spaceships.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    def orientation(a, b, c):\n        val = (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(seg1, seg2):\n        p1, q1 = seg1\n        p2, q2 = seg2\n        \n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        if o1 == 0 and on_segment(p1, q1, p2):\n            return True\n        if o2 == 0 and on_segment(p1, q1, q2):\n            return True\n        if o3 == 0 and on_segment(p2, q2, p1):\n            return True\n        if o4 == 0 and on_segment(p2, q2, q1):\n            return True\n            \n        return False\n\n    def on_segment(a, b, c):\n        if c[0] <= max(a[0], b[0]) and c[0] >= min(a[0], b[0]) and \\\n           c[1] <= max(a[1], b[1]) and c[1] >= min(a[1], b[1]):\n            return True\n        return False\n\n    bases_permutations = list(itertools.permutations(range(b)))\n    \n    for perm in bases_permutations:\n        segments = []\n        for i in range(r):\n            base_index = perm[i]\n            segments.append((spaceships[i], bases[base_index]))\n            \n        valid = True\n        n = len(segments)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if do_intersect(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into two lists: `spaceships` and `bases`.\n2. **Cardinality Check**: If the number of spaceships does not match the number of bases, the solution immediately outputs \"No\".\n3. **Orientation Check**: The `orientation` function determines the relative position of three points (collinear, clockwise, or counterclockwise).\n4. **Segment Intersection Check**: The `do_intersect` function checks if two line segments intersect using the orientation values. It also handles cases where points lie on the same line (collinear) using the `on_segment` function.\n5. **Permutations Check**: For each permutation of base assignments, the code checks all pairs of segments to ensure none intersect. If a valid permutation is found, it prints \"Yes\" and exits; otherwise, after checking all permutations, it prints \"No\".\n\nThis approach efficiently checks all possible assignments using permutations and ensures correctness by leveraging geometric properties to validate segment intersections.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    \n    index = 2\n    spaceships = []\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        spaceships.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    def orientation(a, b, c):\n        val = (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(seg1, seg2):\n        p1, q1 = seg1\n        p2, q2 = seg2\n        \n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        if o1 == 0 and on_segment(p1, q1, p2):\n            return True\n        if o2 == 0 and on_segment(p1, q1, q2):\n            return True\n        if o3 == 0 and on_segment(p2, q2, p1):\n            return True\n        if o4 == 0 and on_segment(p2, q2, q1):\n            return True\n            \n        return False\n\n    def on_segment(a, b, c):\n        if c[0] <= max(a[0], b[0]) and c[0] >= min(a[0], b[0]) and \\\n           c[1] <= max(a[1], b[1]) and c[1] >= min(a[1], b[1]):\n            return True\n        return False\n\n    bases_permutations = list(itertools.permutations(range(b)))\n    \n    for perm in bases_permutations:\n        segments = []\n        for i in range(r):\n            base_index = perm[i]\n            segments.append((spaceships[i], bases[base_index]))\n            \n        valid = True\n        n = len(segments)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if do_intersect(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 479,
        "completion_token_count": 1198,
        "thoughts_token_count": 1023
    }
}