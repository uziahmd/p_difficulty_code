{
    "start": 1758300183.8291135,
    "end": 1758304039.014821,
    "start-formatted": "2025-09-20 01:43 KST",
    "end-formatted": "2025-09-20 02:47 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000) and we need to output two integers: \n   n = minimum number of nodes required for a p-reachable directed graph.\n   and the maximum number of unidirectional pairs among such graphs with n nodes.\n\n Conditions for p-reachable:\n   The graph must contain exactly p ordered pairs (u, v) such that u < v and there is a path from u to v and from v to u.\n\n Note: In a strongly connected component (SCC) of size k, the condition (u < v and mutual reachability) is satisfied for every pair (u, v) with u < v in that SCC. However, note that the problem says \"exactly p\", so we are counting unordered pairs (with u < v) that are mutually reachable. But note: the definition also includes the entire graph being broken into several components? Actually, the graph might have multiple SCCs.\n\n However, note: the condition for p-reachability is defined only on the pairs (u, v) with u < v and mutual reachability. So if the graph has several SCCs, then the pairs (u, v) that are mutually reachable are exactly the pairs within each SCC. \n\n But note: the problem does not require the graph to be strongly connected. We can have multiple strongly connected components. However, the condition is that the total number of such pairs (u < v with mutual reachability) is p.\n\n Observation:\n   Let the graph have k strongly connected components (SCCs). Then the entire graph is a DAG of these SCCs. In each SCC of size s_i, the number of mutual pairs (u < v) is C(s_i, 2) = s_i*(s_i-1)//2.\n\n   Then, the total p is the sum over i from 1 to k of C(s_i, 2).\n\n   But note: the problem also requires that the graph is p-reachable. There's no requirement for connectivity between the components? Actually, the condition only counts the pairs (u, v) that are mutually reachable. So if two nodes are in different SCCs, they are not mutually reachable (unless there is a cycle connecting them? Actually, by definition of SCC, if two nodes are in the same SCC then they are mutually reachable, and if they are in different SCCs then there is no path from one to the other in both directions). \n\n   Therefore, the entire graph's set of mutual pairs is just the union of the mutual pairs in each SCC.\n\n   Now, we are allowed to choose the graph arbitrarily (as long as it is directed and satisfies the condition). We want the minimum number of nodes n such that there exists a set of SCCs (each being a complete directed graph? or any structure? Actually, note: the condition for mutual reachability is automatically satisfied if the SCC is strongly connected. However, we don't have to use complete graphs. But to minimize the number of nodes, we want to form SCCs that account for the p pairs.\n\n   We can break down the problem:\n\n   Step 1: Find the minimum n (number of nodes) such that we can partition the n nodes into some SCCs (each node in exactly one SCC) and the sum of C(s_i, 2) for each SCC of size s_i equals p.\n\n   However, note: we cannot change the fact that the entire graph must be built with n nodes. The graph must be built with exactly n nodes and the condition is that the total mutual pairs (for u < v) is exactly p.\n\n   But note: the problem says \"p-reachable\", meaning the graph must have exactly p such pairs. We are free to arrange the edges arbitrarily (as long as the mutual reachability condition holds for exactly p pairs). \n\n   However, we must have at least the number of nodes n such that we can represent p as the sum of triangle numbers (each triangle number being C(s_i, 2)) from parts (the SCCs). And we want the minimum n.\n\n   How to compute n?\n     Let n = total nodes = s_1 + s_2 + ... + s_k, and we require that the sum_{i} C(s_i, 2) = p.\n\n     We wish to minimize n, so we should try to use as few nodes as possible. How?\n\n     Notice: The function f(k) = C(k, 2) is increasing for k>=1. To minimize the total nodes, we want to use as large SCCs as possible because a single SCC of size k gives C(k,2) pairs and uses k nodes, while two SCCs of sizes a and b (with a+b=k) would give C(a,2)+C(b,2) which is less than C(k,2) if k>=a+b and we are using the same total nodes? Actually, we are constrained by the total pairs being p.\n\n     Alternatively, we can think: we want to represent p as the sum of triangle numbers (each triangle number is C(s_i,2)), and we want to minimize the total nodes (which is the sum of the s_i).\n\n     We know that the maximum triangle number we can get from an SCC of size s is T(s) = s*(s-1)//2.\n\n     This is similar to the coin problem but with coins being triangle numbers. However, we are allowed to use as many coins (SCCs) as we want, and we want to minimize the total nodes (which is the sum of the s_i) for a given p.\n\n     Note: The triangle numbers are: 0, 1, 3, 6, 10, 15, ... (for s=0,1,2,3,...)\n\n     We are allowed to use multiple SCCs of the same size.\n\n     How to minimize the total nodes? We want to use the largest possible SCCs because they give more pairs per node. For example, an SCC of size s gives T(s) pairs and uses s nodes. The efficiency (pairs per node) is (s-1)/2. So larger s gives more pairs per node.\n\n     Therefore, to minimize the total nodes, we should use as few SCCs as possible and make the SCCs as large as possible.\n\n     But note: we are constrained by the total pairs being p. We need to represent p as a sum of distinct triangle numbers (but actually, we can repeat the same triangle number multiple times) and the goal is to minimize the total nodes.\n\n     Example: p=3.\n        If we use one SCC of size 3: T(3)=3, total nodes=3.\n        Alternatively, we could use an SCC of size 2 (gives 1) and another SCC of size 2 (gives 1) -> total pairs=2, which is not enough.\n        Or three SCCs of size 2: then pairs=3, but then total nodes=6, which is worse.\n\n     So the idea: we want to use the greedy algorithm for representing p as a sum of triangle numbers, but we care about the total nodes (which is the sum of the corresponding s_i). \n\n     However, note: we are allowed to use the same triangle number multiple times? Yes, because we can have multiple SCCs of the same size.\n\n     But note: the triangle numbers are not necessarily distinct. We can use the same triangle number multiple times.\n\n     We wish to minimize the total nodes. Let x_i be the number of SCCs of size i. Then we have:\n\n        Sum_{i} [x_i * C(i,2)] = p\n\n        and we want to minimize Sum_{i} [x_i * i]\n\n     Since the triangle numbers are non-decreasing with i, we can use dynamic programming or greedy to minimize the total nodes.\n\n     However, note that the problem constraints: p up to 200000. We cannot iterate over all possibilities.\n\n     Alternate approach:\n\n        We know that the maximum triangle number we can form with n nodes is when we put all n nodes in one SCC: T(n) = n*(n-1)//2.\n\n        So we must have n*(n-1)//2 >= p.\n\n        But we are allowed to split the graph into multiple SCCs. However, note: the condition is exactly p. We must form p as the sum of the triangle numbers from the SCCs.\n\n        We can also consider: what is the minimal n such that we can form p by summing some triangle numbers (each triangle number from 0 to T(floor(n/???)) but wait, the SCC sizes cannot exceed n.\n\n        Actually, the SCCs are disjoint and their total is n. So the maximum triangle number we can use for an SCC is limited by the available nodes.\n\n        We want to minimize n, so we look for the smallest n such that there exists a representation of p as a sum of triangle numbers (each triangle number T(i) = i*(i-1)//2) and the sum of the corresponding i's (the sizes) is <= n? Actually, we are going to use exactly n nodes (because we can always put the remaining nodes in singleton SCCs which contribute 0 pairs). But note: we don't have to use all nodes? Actually, the graph must have exactly n nodes, but we can leave some nodes unused? \n\n        However, the problem says \"minimum number of nodes required\". We are constructing a graph with n nodes. We can have isolated nodes (which are SCCs of size 1, contributing 0 pairs). But note: the condition is that the graph must have exactly p mutual pairs. We can use the entire set of n nodes, but we don't have to use all of them for forming pairs? Actually, we can have some nodes not involved in any mutual pair (then they are in SCCs of size 1). \n\n        But note: the condition is \"exactly p\", so we must have the sum of the triangle numbers of the SCCs (of sizes at least 1) equal to p.\n\n        Now, the minimal n must satisfy: the sum of the triangle numbers from the SCCs (which are disjoint) is p, and the total nodes is the sum of the sizes.\n\n        We wish to minimize the total nodes.\n\n        We can use the following:\n\n          Let n_min be the smallest integer such that the maximum total pairs we can form with n_min nodes (if we use the entire set as one SCC) is at least p: i.e., n_min*(n_min-1)//2 >= p.\n\n          But is that sufficient? Actually, we are allowed to break the graph into multiple SCCs. However, if we break the graph, the total pairs is the sum of the triangle numbers of the SCCs, and the total nodes is the sum of the sizes.\n\n          The key is: we can represent p as the sum of triangle numbers (each at most T(n_min) but actually the SCCs cannot exceed n_min). However, we are minimizing n_min.\n\n          But note: we are allowed to use any set of triangle numbers (from the set {T(1)=0, T(2)=1, T(3)=3, T(4)=6, ...}) and we want the minimal total nodes (sum of the sizes) such that the sum of the triangle numbers is p.\n\n          However, we are constrained by the total nodes being at least the sum of the sizes, and the sizes must be positive integers.\n\n          We can use the following greedy: use the largest triangle number that does not exceed the remaining p, then subtract it and add the corresponding size to the total nodes, and continue until p becomes 0.\n\n          But is this minimal? \n\n          Example: p=3. \n            Largest triangle <=3 is 3 (from size 3). Then total nodes=3.\n            Alternatively, using two SCCs of size 2: triangle numbers 1+1=2, not 3. Then we need to use a third? Actually, we can use one SCC of size 3 and that's it.\n\n          Example: p=4.\n            Largest triangle <=4 is 3 (size 3). Then remaining p=1. Then next largest triangle <=1 is 1 (size 2). Then total nodes=3+2=5.\n            But wait, is there a representation for 4? \n              We cannot use two SCCs of size 3 because that would be 3+3=6 which is too much. \n              We can use one SCC of size 3 (3 pairs) and one SCC of size 2 (1 pair): total pairs=4, total nodes=5.\n            Is there a representation with fewer nodes? \n              With 4 nodes: maximum pairs we can form is T(4)=6, but we can also break it. \n              We need to form 4. Let's check: \n                Use an SCC of size 3 (3 pairs) and one node (0) -> total pairs=3, not enough.\n                Use two SCCs of size 3? But we only have 4 nodes: one of size 3 and one of size 1 -> pairs=3, not 4.\n                Use an SCC of size 4: T(4)=6, which is too big.\n                Use two SCCs: one of size 3 (3) and one of size 1 (0) -> 3.\n                Use two SCCs: one of size 2 (1) and one of size 2 (1) -> total pairs=2, then we need to add more? Actually, we can break the remaining 2 nodes differently? \n                We have 4 nodes. We can have:\n                  Option 1: one SCC of size 4 -> 6 (too big)\n                  Option 2: one SCC of size 3 and one singleton -> 3\n                  Option 3: two SCCs of size 2 -> 1+1=2\n                  Option 4: one SCC of size 2 and two singletons -> 1\n                None gives 4.\n\n            So the minimal n for p=4 is 5.\n\n          Now, how to compute n_min? We want the minimal n such that there exists a set of triangle numbers (each from the set {T(1), T(2), ..., T(n)}) that sum to p and the sum of the corresponding indices (the sizes) is n_min (but note: the total nodes is the sum of the sizes, so n_min is the total nodes). However, we are allowed to use the entire set of n_min nodes arbitrarily (so we can form any set of triangle numbers that do not exceed T(floor(n_min/i)) for the i-th SCC? Actually, the SCCs are disjoint so the sizes must be positive integers that add up to n_min.\n\n          We can use the following:\n\n            Let n_min be the smallest integer such that the maximum total pairs we can form with n_min nodes is at least p, but we can also break the graph arbitrarily. However, we are constrained by the fact that we cannot use a triangle number more than the available nodes.\n\n          Actually, we can reframe: we wish to minimize the total nodes (which is the sum of the sizes) given that we have a multiset of triangle numbers (each T(i) for i from 1 to n_min) that sum to p.\n\n          This is a variant of the classic \"coin\" problem but with coins being the triangle numbers (each triangle number can be used any number of times) and the goal is to minimize the total value (which is the sum of the sizes, not the sum of the triangle numbers). However, note: we are constrained by the total nodes being the sum of the sizes, and we are using the triangle numbers (each T(i) is associated with a cost i). \n\n          We wish to minimize the total cost (which is the total nodes) to achieve a total value (the sum of the triangle numbers) of p.\n\n          This is a classic problem that can be solved by greedy if the coin system is canonical? However, the triangle numbers are not a canonical system? Actually, we know that the triangle numbers are increasing, but sometimes breaking a large triangle number might lead to a lower total cost? \n\n          Example: p=10.\n            Using one SCC of size 5: T(5)=10, cost=5.\n            Using two SCCs: two of size 4: T(4)=6, 6+6=12>10 -> too big.\n                    one of size 4 and one of size 3: 6+3=9, then we need 1 more: one SCC of size 2: 9+1=10, total nodes=4+3+2=9 -> worse than 5.\n\n          But consider: p=15.\n            One SCC of size 6: T(6)=15, cost=6.\n            Alternatively: three SCCs of size 5: T(5)=10, 10*3=30 -> too big.\n                         two SCCs of size 5: 10+10=20 -> too big.\n                         one SCC of size 5: 10, then we need 5 more. The next largest triangle <=5 is 3 (size 3) and then 1 (size 2) -> 10+3+1=14, not enough. Then we need to break further? Actually, we can use two SCCs of size 4: 6+6=12, then 10+6+6=22 -> too big.\n\n          Alternatively, we can use the greedy method:\n\n            Step 1: Start with the largest triangle number (from the largest SCC size) that is <= p. Let that be T(k) and k is the smallest integer such that T(k) <= p.\n            Then, we use as many T(k) as possible? But note: we are constrained by the total nodes. However, we are trying to minimize the total nodes.\n\n          Actually, we can use dynamic programming to compute the minimal total nodes for a given p, but p can be up to 200000.\n\n          We note that the triangle numbers grow as O(n^2). The maximum k such that T(k) <= 200000 is about sqrt(4*p+1)-1 ~ 894 (since 894*893//2 ~ 400000, wait: 894*893//2 = (894*893)//2 = (approx 800000)//2 = 400000, which is more than 200000). Actually, we need k such that k*(k-1)//2 <= 200000 -> k ~ 632 (because 632*631//2 = 632*315.5 ~ 200000).\n\n          But note: we are not limited to one type of SCC. We can use multiple SCCs. \n\n          Another idea: we are allowed to use any set of triangle numbers (any repetition) and we wish to minimize the total nodes (which is the sum of the sizes) for a given p.\n\n          Let dp[i] = minimal total nodes needed to represent the total pairs i.\n\n          Then, for each i from 0 to p, and for each k from 2 upwards (until T(k) <= i) we can do:\n\n            dp[i] = min(dp[i], dp[i - T(k)] + k)\n\n          But the state goes from 0 to p (200000) and k goes up to about 632, so the total operations would be about 200000 * 632 which is about 126e6, which is acceptable in Pyton if we code carefully in C++ but in Python we might need to optimize.\n\n          However, note that we are iterating for each k (from 2 to about 632) and for each i from T(k) to p. That is 632 * (p - T(k) + 1) which is roughly 632 * 200000 = 126400000, which is acceptable in C++ but in Python we might need to use faster loops or use mathematical insight.\n\n          But note: we are only considering k from 2 to 632, and for each k we iterate from T(k) to p. However, we can precompute the list of triangle numbers for k from 2 to 632 (there are about 631 numbers). Then, we can use a DP that iterates over the triangle numbers (or use a BFS-like relaxation).\n\n          Alternatively, we can use a greedy method: since the triangle numbers are increasing, and the goal is to minimize the total nodes, we should use the largest triangle numbers first (because they give more pairs per node). This is known as the \"canonical\" coin system for this problem? \n\n          Actually, we can use the greedy algorithm for the coin system with denominations being the triangle numbers (in decreasing order). However, we must check if the system is canonical. \n\n          But note: the triangle numbers are not powers of a base, and they are increasing. However, we can use the following:\n\n            Let k_max = floor((sqrt(8*p+1)-1)/2)  [this is the maximum k such that T(k) <= p]\n\n            Then, we start from k = k_max down to 2, and use as many k as possible (i.e., use the largest triangle numbers) until the remainder is 0.\n\n          However, is that optimal? \n\n          Example: p=10.\n            k_max = floor((sqrt(81)+1-1)/2) = floor(sqrt(81)/2) = 9/2=4.5 -> floor 4? Actually, T(4)=6, T(5)=10. So k_max=5.\n\n            Then, we use one triangle of 10 (k=5) -> total nodes=5.\n\n            Example: p=11.\n                k_max=5 (T(5)=10). Then we use one 10, and then we have 1 left. The next largest triangle <=1 is 1 (k=2). Then total nodes=5+2=7.\n\n            But is there a better way? \n                We can use one 10 (from k=5) and one 1 (from k=2) -> 11 pairs, total nodes=7.\n                Alternatively: use two 6 (k=4): 6+6=12 -> too big.\n                Or one 6 and then 5: 5 is not a triangle number. Then we break 5: the next largest triangle <=5 is 3 (k=3) -> 6+3=9, then we have 2 left, which is 1+1 (two k=2) -> 6+3+2+2=13, total nodes=4+3+2+2=11, which is worse.\n\n            So the greedy (using the largest triangle numbers) seems to work for p=10 and p=11.\n\n          However, consider p=2.\n            k_max: T(2)=1, T(3)=3 -> so k_max=2.\n            Then, we use two triangles of 1: 1+1=2, total nodes=2+2=4.\n\n            But wait, we can use one triangle of 2 (but wait, k=2 gives T(2)=1). Actually, we cannot use k=3 because T(3)=3 >2. So we have to use two triangles of 1 (each from k=2). Then total nodes=4.\n\n            But is there a representation with 3 nodes? \n                We can have an SCC of size 2 and an SCC of size 1: then pairs=1, not 2.\n                Or three nodes: we can form a cycle (strongly connected) then we have 3 pairs (C(3,2)=3) which is more than 2.\n\n            Alternatively, we can have two SCCs of size 2: then the pairs are 1+1=2, and the total nodes=4.\n\n            So minimal n=4.\n\n          Example p=0: then we use 0 pairs. We can use 0 nodes? But the problem states: \"ordered pairs (u, v) in a directed graph\", and the graph must have exactly 0 pairs. We can have a graph with 0 nodes, or with any number of nodes as long as we don't form any mutual pair (i.e., no SCC of size>=2). But note: the condition is \"exactly p\", so p=0. The minimal n is 0? Or 1? \n\n          The problem says: \"minimum number of nodes required\". For p=0, we can have a graph with 0 nodes. However, sometimes problems consider at least one node. But the input includes p=0, and the example output for p=0 is \"0 0\".\n\n          But wait, the example: Input 0 -> Output \"0 0\"\n\n          So we must consider n=0.\n\n          Steps:\n\n            Step 1: Precompute the list of triangle numbers for k from 2 up to k_max (where k_max is the maximum k such that T(k) <= p, but note p can be 0). \n\n            Step 2: Use dynamic programming (DP) or a greedy method to compute the minimal total nodes for p.\n\n          However, note: the problem also asks for the second part: the maximum number of unidirectional pairs.\n\n          What is a unidirectional pair? \n            An ordered pair (u, v) (u != v) is unidirectional if there exists a path from u to v but not from v to u.\n\n          In our graph, we are constructing a graph with n nodes (minimal n) and we have broken the graph into SCCs (with the condition that the sum of the triangle numbers is p). \n\n          Now, we want to maximize the number of unidirectional pairs.\n\n          How to count unidirectional pairs?\n\n          Consider two nodes u and v. There are two cases:\n\n            Case 1: u and v are in the same SCC. Then there is a path from u to v and from v to u, so they are not unidirectional.\n\n            Case 2: u and v are in different SCCs. Then the graph is a DAG of SCCs. Without loss of generality, assume the SCC containing u is A and the SCC containing v is B, and there is a directed edge (or a path) from A to B. Then we have a path from u to v, but not from v to u (because there's no path from B to A). Similarly, if there is a path from B to A, then (v, u) would be unidirectional (from v to u) but not from u to v. But note: in a DAG, the SCCs are topologically ordered. If A comes before B, then there is no path from B to A, so (u, v) is unidirectional (if there is a path from A to B). However, we can choose the edges arbitrarily as long as the SCCs are formed and the mutual reachability condition is satisfied (within each SCC) and the total mutual pairs is p.\n\n          How do we form the DAG? We can choose the edges arbitrarily (even multiple edges) as long as the SCCs are fixed. \n\n          Note: The problem does not fix the structure of the edges between SCCs. We are free to choose any directed edges that maintain the SCC property (within each SCC, we can choose any strongly connected graph, and between SCCs we can choose edges arbitrarily as long as the entire graph is a DAG of the SCCs).\n\n          But note: the condition for being an SCC is that the subgraph induced by the nodes in the SCC is strongly connected. We can choose the edges arbitrarily as long as the SCCs are as given (and the edges between SCCs do not create new mutual reachabilities). \n\n          Now, to maximize the unidirectional pairs, we want to maximize the number of ordered pairs (u, v) (u != v) such that there is a path from u to v but not from v to u.\n\n          This happens only when u and v are in different SCCs and there is a path from the SCC of u to the SCC of v (but not the reverse). \n\n          However, note: we are allowed to choose the edges arbitrarily (as long as the SCCs are fixed). So we can choose the edges to form a complete DAG (i.e., for every pair of distinct SCCs, we direct all edges from one to the other). Then, for any two nodes u and v in different SCCs, if we fix a topological order of the SCCs, then if u's SCC comes before v's SCC, then there is a path from u to v (by going through the edges we added) but not from v to u (since the reverse edge doesn't exist). Similarly, if u's SCC comes after v's SCC, then we have the opposite.\n\n          But note: we can choose the direction of the edges arbitrarily between two SCCs? Actually, we can choose a linear ordering (topological sort) of the SCCs and then put edges from every node in an earlier SCC to every node in a later SCC. Then, for any two nodes u and v in different SCCs, if u is in an earlier SCC and v in a later SCC, then (u, v) is unidirectional. Also, if u is in a later SCC and v in an earlier SCC, then (v, u) is unidirectional. \n\n          However, the problem counts ordered pairs. So for a pair (u, v) and (v, u) separately.\n\n          But note: the condition for unidirectional is for an ordered pair (u, v). So if we have a complete DAG (with edges from every earlier SCC to every later SCC), then for any two distinct SCCs A and B (with A < B in the topological order):\n\n            For every node u in A and v in B: the pair (u, v) is unidirectional (from u to v).\n            For every node u in B and v in A: the pair (u, v) is unidirectional (from u to v)? No, because if we only have edges from A to B, then from B to A we don't have edges. So for u in B and v in A, there is no path from u to v (because we only have edges from A to B, so to go from B to A we would need edges from B to A, which we don't have). Therefore, (u, v) for u in B and v in A is not unidirectional because there is no path from u to v? Actually, wait: we have defined the graph as having edges from earlier SCCs to later SCCs. So if we have a topological order from A to B, then we have edges from A to B, but not from B to A. Then:\n\n            - If u is in A and v is in B: there is a path (via the edge from A to B) from u to v, and no path from v to u (since no edges from B to A). So (u, v) is unidirectional.\n\n            - If u is in B and v is in A: there is no path from u to v (because we only have edges from A to B, and we are going backwards from B to A without edges). So (u, v) is not unidirectional.\n\n          Therefore, in the complete DAG setup, for two distinct SCCs A and B (with A < B), we get |A| * |B| unidirectional pairs (all the (u, v) for u in A and v in B).\n\n          Now, what about the entire graph? The total unidirectional pairs is the sum over every ordered pair of distinct SCCs (A, B) (with A < B) of |A| * |B|.\n\n          But note: we are free to choose the topological ordering. However, the number |A| * |B| for a fixed set of SCCs is independent of the ordering? Actually, no: we must consider that we are going to count only the pairs (u, v) where u is in the earlier SCC and v in the later one. \n\n          However, we can choose the ordering arbitrarily. The total unidirectional pairs will be the same regardless of the ordering? \n\n          Let the SCCs be of sizes s1, s2, ..., sk. Then, if we fix an ordering, the total unidirectional pairs is:\n\n            Sum_{i < j} [s_i * s_j]   (if we put the i-th SCC before the j-th SCC)\n\n          But note: we can also choose not to put all edges from one SCC to another? Actually, the condition for unidirectional is that there must be a path. We can also choose to not put edges from an SCC to another (but then we break the condition that the graph is a DAG and we can have multiple topological relations). However, to maximize the unidirectional pairs, we want to have as many paths as possible (without creating mutual reachability). The complete DAG (with edges from every node in an earlier SCC to every node in a later SCC) maximizes the number of directed paths (and hence unidirectional pairs) because for any two nodes in different SCCs, we have a directed path from the earlier to the later.\n\n          Now, the question: is the total unidirectional pairs independent of the ordering? \n\n          Actually, no. Consider two SCCs A and B. In the complete DAG, we have edges from A to B OR from B to A, but not both. The total contribution from the pair (A, B) is either |A|*|B| (if we put A before B) or |B|*|A| (if we put B before A). But note: the ordering is fixed and we count the pairs (u, v) only in one direction. \n\n          However, observe: the expression Sum_{i<j} [s_i * s_j] is independent of the ordering. Why?\n\n          Because the complete DAG will have for every unordered pair {A, B} (with sizes s_A and s_B) exactly one of the two ordered pairs (A, B) or (B, A) in the DAG, and the total unidirectional pairs from these two SCCs is s_A*s_B (if we put A before B) or s_B*s_A (if we put B before A) which is the same. But note: we are summing over all ordered pairs of distinct SCCs (with the ordering of the entire graph fixed). However, the entire graph has a fixed set of SCCs and we can choose the ordering arbitrarily, but the total sum of the products for every unordered pair is fixed: \n\n            Total = ( (sum_i s_i)^2 - sum_i s_i^2 ) / 2\n\n          But wait, we are only counting the pairs (u, v) for which u is in an earlier SCC and v in a later one. In the complete DAG, we count for each unordered pair {A, B} exactly one direction. Therefore, the total unidirectional pairs is:\n\n            Total_unidirectional = ( (n^2 - sum_i s_i^2) ) / 2\n\n          Why? Because the total number of ordered pairs of distinct nodes is n*(n-1). Then, the pairs that are not unidirectional are those that are in the same SCC (which are not counted) and the pairs that are in different SCCs but we don't have a path (but in our complete DAG we have a path in one direction only). Actually, in our complete DAG, for two distinct nodes in different SCCs, we have exactly one direction (either from the earlier to the later). So the unidirectional pairs are all the pairs of distinct nodes that are in different SCCs, but note: \n\n            For two distinct nodes u and v in different SCCs, we have two possibilities: \n              (u, v) is unidirectional if u is in the earlier SCC and v in the later; \n              (v, u) is unidirectional if v is in the earlier and u in the later.\n\n            But wait, no: we only have one direction (the edges go from earlier to later). Therefore, for a fixed pair (u, v) (with u and v in different SCCs) only one of (u, v) or (v, u) is unidirectional.\n\n            The total number of distinct node pairs (ignoring direction) is (n*(n-1)). The total unidirectional pairs is the number of ordered pairs (u, v) (with u != v) that are in different SCCs and that follow the edge direction. But note: in our complete DAG, we have an edge from every node in an earlier SCC to every node in a later SCC, so for every unordered pair (u, v) (u and v in different SCCs) we have exactly one ordered pair that is unidirectional.\n\n            Therefore, the total unidirectional pairs is the number of ordered pairs (u, v) (u != v) that are in different SCCs. But wait, that is simply:\n\n                n*(n-1) - (sum_i C(s_i, 2)*2)   ??? \n\n            Actually, no: the condition for being unidirectional is that there is a path in one direction but not the other. In the complete DAG, for two distinct nodes in different SCCs, there is a path in exactly one direction (the direction of the DAG). So the total unidirectional pairs is the total number of ordered pairs (u, v) (u != v) that are in different SCCs.\n\n            But note: the total number of ordered pairs (u, v) (u != v) is n*(n-1). And the pairs that are not unidirectional are the pairs (u, v) that are in the same SCC (and then we have both directions? Actually, no: in the same SCC, we have mutual reachability, so both (u, v) and (v, u)",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs. \n\n### Approach\n1. **Problem Analysis**:\n   - A graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and there is a path from u to v and vice versa (i.e., u and v are in the same strongly connected component (SCC)).\n   - The goal is to find the smallest number of nodes `n` such that the sum of the combinations of nodes within each SCC equals `p`. Each SCC of size `k` contributes `C(k, 2)` pairs.\n   - The unidirectional pairs are those ordered pairs (u, v) where there is a path from u to v but not from v to u. To maximize these, we consider a complete DAG structure between SCCs, where edges flow from earlier to later SCCs in a topological order.\n\n2. **Key Insights**:\n   - **Finding Minimum Nodes (`n`)**: The minimal `n` is found by decomposing `p` into a sum of triangular numbers (each representing an SCC). The greedy approach of using the largest possible triangular numbers first minimizes `n`.\n   - **Maximizing Unidirectional Pairs**: For the minimal `n`, the maximum number of unidirectional pairs is derived from the complete DAG structure between SCCs. The formula involves summing the products of sizes of all distinct SCC pairs, which simplifies to `(n^2 - sum_i s_i^2) / 2`.\n\n3. **Algorithm Selection**:\n   - **Greedy Decomposition**: Efficiently break down `p` into triangular numbers to determine the minimal `n`.\n   - **Mathematical Formula**: Use the derived formula to compute the maximum unidirectional pairs once the SCC sizes are known.\n\n4. **Complexity Analysis**:\n   - **Time Complexity**: The decomposition step involves iterating over possible triangular numbers, which is feasible since triangular numbers grow quadratically. The overall complexity is O(p) due to the linear pass through possible triangular values.\n   - **Space Complexity**: The solution uses constant space, storing intermediate results and not scaling with input size beyond manageable limits.\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    p = int(input().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    k_max = int((math.sqrt(8 * p + 1) - 1) // 2)\n    triangles = [0] * (k_max + 1)\n    for i in range(1, k_max + 1):\n        triangles[i] = i * (i - 1) // 2\n\n    total_nodes = 0\n    remaining = p\n    sizes = []\n    \n    k = k_max\n    while remaining > 0:\n        if triangles[k] <= remaining:\n            count_k = remaining // triangles[k]\n            total_nodes += count_k * k\n            remaining %= triangles[k]\n            sizes.extend([k] * count_k)\n        k -= 1\n        if k < 2:\n            break\n\n    while remaining > 0:\n        k = 2\n        while k <= k_max and triangles[k] <= remaining:\n            if remaining >= triangles[k]:\n                count_k = remaining // triangles[k]\n                total_nodes += count_k * k\n                remaining %= triangles[k]\n                sizes.extend([k] * count_k)\n            k += 1\n        if remaining == 0:\n            break\n\n    n = total_nodes\n    s_sum_sq = 0\n    for s in sizes:\n        s_sum_sq += s * s\n        \n    total_ordered_pairs = n * (n - 1)\n    same_scc_pairs = 0\n    for s in sizes:\n        same_scc_pairs += s * (s - 1)\n        \n    unidirectional = total_ordered_pairs - same_scc_pairs\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads the integer `p` which specifies the number of p-reachable pairs.\n2. **Special Case Handling**: If `p` is zero, the solution immediately outputs \"0 0\" since no nodes or edges are needed.\n3. **Triangular Number Calculation**: The maximum possible SCC size (`k_max`) is determined based on `p`. Triangular numbers up to `k_max` are precomputed.\n4. **Greedy Decomposition**: The algorithm decomposes `p` into a sum of triangular numbers, starting with the largest possible, to minimize the total nodes (`n`).\n5. **Unidirectional Pairs Calculation**: Using the derived SCC sizes, the code calculates the maximum unidirectional pairs by considering all ordered pairs of nodes from different SCCs in a complete DAG structure.\n6. **Output**: The minimal number of nodes and the maximum unidirectional pairs are printed.\n\nThis approach efficiently addresses both parts of the problem by leveraging mathematical insights and greedy decomposition to ensure optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    p = int(input().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    k_max = int((math.sqrt(8 * p + 1) - 1) // 2)\n    triangles = [0] * (k_max + 1)\n    for i in range(1, k_max + 1):\n        triangles[i] = i * (i - 1) // 2\n\n    total_nodes = 0\n    remaining = p\n    sizes = []\n    \n    k = k_max\n    while remaining > 0:\n        if triangles[k] <= remaining:\n            count_k = remaining // triangles[k]\n            total_nodes += count_k * k\n            remaining %= triangles[k]\n            sizes.extend([k] * count_k)\n        k -= 1\n        if k < 2:\n            break\n\n    while remaining > 0:\n        k = 2\n        while k <= k_max and triangles[k] <= remaining:\n            if remaining >= triangles[k]:\n                count_k = remaining // triangles[k]\n                total_nodes += count_k * k\n                remaining %= triangles[k]\n                sizes.extend([k] * count_k)\n            k += 1\n        if remaining == 0:\n            break\n\n    n = total_nodes\n    s_sum_sq = 0\n    for s in sizes:\n        s_sum_sq += s * s\n        \n    total_ordered_pairs = n * (n - 1)\n    same_scc_pairs = 0\n    for s in sizes:\n        same_scc_pairs += s * (s - 1)\n        \n    unidirectional = total_ordered_pairs - same_scc_pairs\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 1096,
        "thoughts_token_count": 8191
    }
}