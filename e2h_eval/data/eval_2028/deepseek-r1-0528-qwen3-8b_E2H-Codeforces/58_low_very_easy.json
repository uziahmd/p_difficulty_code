{
    "start": 1758299369.857256,
    "end": 1758303139.092572,
    "start-formatted": "2025-09-20 01:29 KST",
    "end-formatted": "2025-09-20 02:32 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are to find the minimum number of edges t to add to form an odd cycle (simple cycle) and the number of ways w.\n\n Observing:\n - A simple cycle of odd length must have at least 3 vertices. The smallest odd cycle is a triangle (length 3).\n\n Steps:\n\n 1. If the graph already contains an odd-length cycle, then t = 0 and w = 1? But wait: note that the problem says \"form a cycle\", meaning we don't necessarily require the graph to have one initially. However, if it does, then we don't need to add any edge.\n\n But note: the problem says \"the minimum number of edges that must be added\", so if there's already an odd cycle, then t=0.\n\n However, the example: \n   Input: \"3 3\\n1 2\\n2 3\\n3 1\" -> Output: \"0 1\"\n\n So first, we must check if the graph has an odd cycle.\n\n How to check for odd cycle?\n   We can use BFS/DFS with coloring (bipartite check). If the graph is not bipartite, then it contains an odd cycle.\n\n But note: the graph may be disconnected.\n\n Steps for bipartite check (for each connected component):\n   We color the graph with two colors. If we can color the entire graph with two colors without conflict, then it is bipartite (and no odd cycle).\n   Otherwise, there is an odd cycle.\n\n However, note: the problem also requires that we count the number of ways to add t edges (minimum edges) to form an odd cycle.\n\n Let's break down by cases:\n\n Case 1: There is already an odd cycle -> then t = 0, and w = 1.\n\n Case 2: No odd cycle (so the graph is bipartite). Then we need to consider what is the minimum number of edges to add to create an odd cycle.\n\n Note: In a bipartite graph, all cycles are even. To form an odd cycle, we need to connect two vertices that are in the same part (same color) in such a way that creates an odd cycle.\n\n But note: adding one edge might not be enough. Actually, let's think:\n\n Example: \n   Consider a bipartite graph (with two parts: A and B). \n   If we add an edge within part A (same color), then we might form an odd cycle. However, we need to ensure that there exists a path from the two endpoints of the new edge (in A) that goes through an even number of edges (since bipartite) so that the entire cycle becomes odd.\n\n   Actually, the minimal odd cycle we can form by adding one edge is when the two vertices are connected by a path of even length? Not necessarily.\n\n   Actually, the new cycle would be: the new edge (u, v) and the existing path from u to v. The parity of the total cycle length is (length of the path) + 1.\n\n   For the cycle to be odd, the path must be even (so that even+1 is odd). But note: in a bipartite graph, the path between two nodes in the same part must have even length, and two nodes in different parts must have odd length.\n\n   Therefore, to form an odd cycle by adding one edge, we must connect two vertices that are in the same part (so the path between them is even) and then the total cycle length is even+1 = odd.\n\n   But wait: is one edge enough? Actually, if we add an edge between two vertices in the same part, then we form a cycle: the edge and the existing path (which is even). The total length is even+1 = odd.\n\n   However, there is a catch: the existing path must exist. But note: if two vertices are in the same part, they might not be connected by an edge? They could be in the same connected component or not.\n\n   Actually, if they are in the same connected component (then we have an even-length path) then adding the edge will form an odd cycle.\n\n   What if they are in different connected components?\n   Then the two vertices are in the same part (because we colored independently in each component) but there is no path connecting them. Then adding an edge between them would form a cycle that is the sum of the two paths from a common ancestor? Actually, no, because they are in separate components.\n\n   Actually, the cycle formed by connecting two vertices from two different components would require going from one vertex to a common vertex? But there isn't one. However, we can consider: if we connect two vertices from the same part (from two different components), then the cycle is: the edge we add and then two separate paths from the two vertices to a common vertex? But they are in different components so there's no common vertex.\n\n   Actually, the",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and the number of ways to add those edges. The solution involves checking if the graph already contains an odd cycle, and if not, calculating the minimal edges required to create one.\n\n### Approach\n1. **Check for Existing Odd Cycle**: \n   - Use a bipartite check (BFS or DFS coloring) to determine if the graph contains any odd cycles. If it does, no edges need to be added (t = 0, w = 1).\n   \n2. **Bipartite Graph Handling**:\n   - If the graph is bipartite (no odd cycles), then all cycles are even. To form an odd cycle, we need to connect two vertices in the same partition (same color) that are part of the same connected component. Adding an edge between them creates an odd cycle because the existing path between them (even length) plus the new edge (length 1) results in an odd total length.\n   \n3. **Disconnected Components**:\n   - If vertices are in different components but share the same partition, connecting them forms an odd cycle only if they are in the same partition. However, the minimal edges required might be more than one in some cases, but the problem specifies finding the minimal number of edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n    comp_id = [0]*(n+1)\n    comp_count = 0\n    \n    for i in range(1, n+1):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = 0\n            comp_id[i] = comp_count\n            current_comp = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[node] ^ 1\n                        comp_id[neighbor] = comp_count\n                        current_comp.append(neighbor)\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        is_bipartite = False\n            components.append(current_comp)\n            comp_count += 1\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    t = float('inf')\n    w = 0\n    comp_colors = {}\n    for comp_index, comp in enumerate(components):\n        comp_color0 = 0\n        comp_color1 = 0\n        for node in comp:\n            if color[node] == 0:\n                comp_color0 += 1\n            else:\n                comp_color1 += 1\n                \n        total_pairs_in_comp = comp_color0 * comp_color1\n        missing_edges_in_comp = total_pairs_in_comp - sum(1 for u in comp for v in graph[u] if u < v and v in comp and v > u)\n        if missing_edges_in_comp > 0:\n            t = min(t, missing_edges_in_comp)\n            w += missing_edges_in_comp\n            \n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if comp_id[i] != comp_id[j] and color[i] == color[j]:\n                t = min(t, 1)\n                w += 1\n                \n    if t == float('inf'):\n        t = 3\n        w = 1\n    else:\n        if t == 1:\n            pass\n            \n    print(f\"{t} {w}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initialization**: The input is read and parsed into the number of vertices `n` and edges `m`. The graph is constructed using adjacency lists.\n2. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness by attempting to color vertices with two colors. If any vertex cannot be colored without conflict, the graph contains an odd cycle.\n3. **Edge Calculation**: For each bipartite component, calculate the number of missing edges needed to form an odd cycle within that component. If vertices from different components share the same partition, adding an edge between them also forms an odd cycle.\n4. **Result Determination**: If no odd cycle exists, the minimal edges required are either 1 (for same-component vertices) or 3 (if no such edges exist, implying a disconnected graph). The number of valid ways to add these edges is counted accordingly.\n\nThis approach efficiently checks for existing odd cycles and calculates the minimal edges needed to create one, ensuring optimal performance even for large graphs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n    comp_id = [0]*(n+1)\n    comp_count = 0\n    \n    for i in range(1, n+1):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = 0\n            comp_id[i] = comp_count\n            current_comp = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[node] ^ 1\n                        comp_id[neighbor] = comp_count\n                        current_comp.append(neighbor)\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        is_bipartite = False\n            components.append(current_comp)\n            comp_count += 1\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    t = float('inf')\n    w = 0\n    comp_colors = {}\n    for comp_index, comp in enumerate(components):\n        comp_color0 = 0\n        comp_color1 = 0\n        for node in comp:\n            if color[node] == 0:\n                comp_color0 += 1\n            else:\n                comp_color1 += 1\n                \n        total_pairs_in_comp = comp_color0 * comp_color1\n        missing_edges_in_comp = total_pairs_in_comp - sum(1 for u in comp for v in graph[u] if u < v and v in comp and v > u)\n        if missing_edges_in_comp > 0:\n            t = min(t, missing_edges_in_comp)\n            w += missing_edges_in_comp\n            \n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if comp_id[i] != comp_id[j] and color[i] == color[j]:\n                t = min(t, 1)\n                w += 1\n                \n    if t == float('inf'):\n        t = 3\n        w = 1\n    else:\n        if t == 1:\n            pass\n            \n    print(f\"{t} {w}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 573,
        "completion_token_count": 1108,
        "thoughts_token_count": 1023
    }
}