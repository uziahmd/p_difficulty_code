{
    "start": 1758300228.3022392,
    "end": 1758304089.1480086,
    "start-formatted": "2025-09-20 01:43 KST",
    "end-formatted": "2025-09-20 02:48 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000) and we need to output two numbers:\n\n 1. The minimum number of nodes required to have a directed graph that is p-reachable (i.e., contains exactly p ordered pairs (u, v) such that u < v and there is a path from u to v and from v to u). Note: the problem says \"exactly p ordered pairs with u < v and mutual reachability\". However, note that in a strongly connected component (SCC) the entire set of mutual reachability pairs is for every unordered pair (u, v) with u != v. But note: the condition is for u < v. So if we have a complete SCC of size n, then the number of mutual reachability pairs (with u < v) is C(n,2) = n*(n-1)//2.\n\n 2. Among all graphs with the minimum number of nodes that are p-reachable, we want the graph that maximizes the number of unidirectional pairs.\n\n Observations:\n\n - We are allowed to have multiple strongly connected components (SCCs). In fact, the condition for being p-reachable is that the total number of mutual reachability pairs (for u < v) is p.\n\n - How do we break down the mutual reachability? Note that within each SCC, every pair (u, v) with u != v is mutually reachable. But between two different SCCs, there should be no mutual reachability (otherwise they would be merged into one SCC). Therefore, the entire graph can be partitioned into SCCs, and the mutual reachability pairs are the sum over each SCC of C(size_i, 2).\n\n - We are to have exactly p mutual reachability pairs (each corresponding to an unordered pair {u, v} with u < v and mutual reachability). But note: the problem says \"ordered pairs (u, v) in a directed graph\" but then specifies \"u < v\" and mutual reachability. Actually, the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". However, note that the condition for mutual reachability is symmetric. So each unordered pair {u, v} with u < v that is mutually reachable counts as one.\n\n - Therefore, we are looking for a set of SCCs (each being a complete strongly connected component) such that the total number of mutual pairs (which is the sum of C(size_i, 2) for each SCC) is exactly p.\n\n However, note: the problem does not require that the entire graph is strongly connected. It can have multiple SCCs. And the graph must be p-reachable, meaning the total number of mutual reachability pairs (for u < v) is p.\n\n But wait: in a directed graph, the mutual reachability condition is only satisfied within an SCC. Between two different SCCs, we cannot have a path in both directions (otherwise they would be merged). Moreover, we can design the graph so that the SCCs form a DAG. Then, the mutual reachability pairs are only the pairs within each SCC.\n\n Therefore, we are to represent p as the sum of triangle numbers (i.e., T(n) = n*(n-1)//2) from distinct positive integers (since we can't use the same node twice). However, note: we can use the same node only once (each node is in one SCC). So we are to write p as a sum of triangle numbers (each representing an SCC of size k_i) and we want to minimize the total number of nodes (which is the sum of the sizes of the SCCs).\n\n But note: the problem does not require that the SCCs are disjoint? They are by definition. So we are to decompose p into a sum of triangle numbers (allowing repetitions? Actually, we can have multiple SCCs of the same size, but then the triangle number for that size is added multiple times). However, we are free to choose the decomposition as long as the total nodes is minimized.\n\n However, let's think: we want to minimize the total number of nodes. Let n_i be the size of the i-th SCC. Then the total nodes is N = sum_i n_i, and the total mutual pairs is sum_i [n_i*(n_i-1)//2] = p.\n\n We wish to minimize N such that there exists a sequence of n_i (positive integers) with sum_i [n_i*(n_i-1)//2] >= p? Actually, we need exactly p. But note: we can also have more than p? No, because the condition is exactly p.\n\n However, the problem says \"contains exactly p ordered pairs\", so we must have exactly p.\n\n But note: we can have a graph that is not strongly connected. The mutual reachability pairs are the pairs inside the SCCs. So we can have multiple SCCs. The total mutual pairs is the sum of the triangle numbers of the sizes of the SCCs.\n\n Now, we wish to minimize the total nodes N = n_1 + n_2 + ... + n_k such that the sum of the triangle numbers is p.\n\n However, we can also consider that the graph must be built with the minimum number of nodes. How do we assign the SCCs?\n\n Observation: We can use SCCs of size 1 (which contribute 0) or larger. But note: if we use an SCC of size 1, it doesn't add any mutual pair. But we can also use SCCs of different sizes.\n\n We want to minimize the total nodes. So we want to use as few nodes as possible to get a sum of triangle numbers equal to p.\n\n Let T(n) = n*(n-1)//2.\n\n We are to express p as a sum of T(n_i) (each n_i>=1) and we want to minimize the sum of the n_i.\n\n But note: the problem requires exactly p. So we are looking for a representation of p as a sum of triangle numbers (without regard to order) and we want the minimal total node count.\n\n However, we can use any number of triangle numbers (each at least T(1)=0, T(2)=1, T(3)=3, T(4)=6, etc.)\n\n But note: the problem says \"minimum number of nodes\", so we want the minimal N such that there exists a set of positive integers (sizes) n_1, n_2, ..., n_k (k>=1) with:\n   sum_i T(n_i) = p   and   N = n_1+n_2+...+n_k.\n\n However, we can use the same triangle number multiple times? Yes, because we can have multiple SCCs of the same size.\n\n But note: the minimal total node count for achieving a given p is achieved by using as large triangle numbers as possible (because a triangle number grows quadratically and we want to cover p with as few nodes as possible). However, we are constrained by the fact that the triangle numbers must be consecutive in the sense of being from distinct SCCs, but the sizes can repeat.\n\n Actually, we can use multiple copies of the same triangle number.\n\n Example: \n   p=1: we can use an SCC of size 2 (T(2)=1) -> nodes used=2.\n        Alternatively, we can use two SCCs of size 2? Then we would have two mutual pairs (each T(2)=1) so total 2, which is too much.\n        Or one SCC of size 2 and one of size 1: then total mutual pairs = 1, and total nodes=3. But that is worse than just one SCC of size 2.\n\n   So for p=1, the minimal nodes is 2.\n\n   p=2: we can use two SCCs of size 2: then T(2)+T(2)=2, and nodes=4. \n        Alternatively, we can use one SCC of size 3: T(3)=3, which is too big (3>2). \n        Or one SCC of size 2 and two SCCs of size 1: T(2)=1, so total 1, which is less than 2.\n        But wait, we can also use two SCCs of size 2? That gives 2. So minimal nodes is 4.\n\n   But wait, what if we use one SCC of size 3? Then we get 3 mutual pairs, which is more than 2. So that doesn't work.\n\n   Alternatively, we can use one SCC of size 2 (which gives 1) and then we still need 1 more. Then we can use another SCC of size 2? Then we get 1+1=2. Then total nodes=4.\n\n   Alternatively, we can use an SCC of size 3 and then remove one edge? But note: the problem requires the graph to be p-reachable, meaning the mutual reachability must be exactly p. If we have an SCC of size 3, then we have 3 mutual pairs (for the three edges). We cannot have 2 without breaking the strong connectivity? Actually, if we break one edge in the cycle, then the graph is not strongly connected. Then we would have two SCCs: one of size 2 and one of size 1? Then the mutual pairs would be T(2)=1 and T(1)=0, so total 1, which is not 2.\n\n   Therefore, we must use two separate SCCs of size 2 (so two cycles of length 2, but then we have two mutual pairs, each from one cycle). Then the graph has two components, each of size 2, and no edges between them (so no mutual reachability across). Then the total mutual pairs is 1+1=2.\n\n   But wait, is there a way to have one SCC that gives 2 mutual pairs? The triangle number for n=3 is 3, which is too much. For n=2, we get 1. There's no n such that T(n)=2. So we must use two SCCs.\n\n   Therefore, the minimal nodes for p=2 is 4.\n\n   Another example: p=3. \n        One SCC of size 3: T(3)=3, so we can use one SCC of size 3. Then nodes=3. \n        Alternatively, we can use three SCCs of size 2: T(2)*3 = 3, then nodes=6. \n        So minimal nodes is 3.\n\n   So the minimal node count is the smallest integer N such that we can partition p into a sum of triangle numbers (each being T(n_i) for some n_i>=1) and the sum of the n_i is N, and we wish to minimize N.\n\n   However, note: we are allowed to use any triangle numbers (from T(1)=0, T(2)=1, T(3)=3, T(4)=6, T(5)=10, etc.). \n\n   But note: we can use T(1)=0 arbitrarily without affecting p. However, including T(1) doesn't help because we want to minimize the total nodes. So we should avoid using SCCs of size 1 if we can achieve the same p without them.\n\n   So we are to represent p as a sum of triangle numbers (each from the set {0,1,3,6,10,...}) and we wish to minimize the total nodes (the sum of the sides of the triangles, i.e., if we use T(n_i) then we use n_i nodes for that SCC).\n\n   However, note: the triangle numbers are defined for n>=1. T(1)=0, so we can use as many 0's as we want without affecting p. But the node count for a T(1) is 1. So including a T(1) adds 1 node and doesn't change p. We don't want that because we want to minimize the total nodes.\n\n   So we are to represent p as a sum of triangle numbers (from T(2), T(3), ...) and we wish to minimize the total node count.\n\n   This is similar to the classic coin change problem but with coins being triangle numbers and we want to minimize the total value (in terms of node count) for a given p.\n\n   Let f(p) = minimal total nodes required to represent p as a sum of triangle numbers (excluding T(1)=0, because we don't want to use extra nodes for zero contribution).\n\n   But note: we might use T(1)=0 if we cannot represent p without having leftover? Actually, we can always represent p by using enough T(1)=0. But that would be inefficient. We want the minimal node count.\n\n   Steps:\n\n   We are to find the minimal N such that there exists a sequence of integers n_1, n_2, ..., n_k (each >=2) for which:\n        sum_{i=1}^{k} T(n_i) = p   and   N = sum_{i=1}^{k} n_i.\n\n   Alternatively, we can think greedily: we want to use the largest triangle numbers first to minimize the total node count.\n\n   Why? Because the triangle number T(n) = n*(n-1)/2, and the node count per triangle is n. The ratio of triangle number to node count is (n-1)/2. To cover a given amount of p, we want to use the triangle numbers with the highest (n-1)/2 per unit p. However, note that we are not covering p by the triangle numbers, but we are breaking p into a sum of triangle numbers and then the total node count is the sum of the n_i.\n\n   But note: we are allowed to use multiple copies of the same triangle number.\n\n   Since the triangle numbers are increasing and the node count for a given triangle number is fixed, we can try to use as many large triangle numbers as possible.\n\n   However, we cannot exceed p. We need exactly p.\n\n   We can use dynamic programming? But p can be up to 200000.\n\n   Alternatively, we can precompute the minimal node count for p from 0 to 200000.\n\n   Steps for minimal node count:\n\n   Let dp[i] = minimal total nodes required to form a sum of triangle numbers equal to i (using triangle numbers from T(2)=1, T(3)=3, T(4)=6, ...)\n\n   Then we have:\n        dp[0] = 0\n        For each i from 1 to p:\n            dp[i] = min_{k>=2, T(k) <= i} { dp[i - T(k)] + k }\n\n   But note: we can use the same triangle number multiple times.\n\n   However, the state i goes up to 200000, and the triangle numbers go up to T(n) <= 200000. The largest n such that T(n) <= 200000 is about n = ceil((sqrt(8*p+1)+1)/2) which for p=200000 is about n ~ 633 (since T(633)=633*632//2 ~ 200000). Then the inner loop for each state i would iterate over about 633 different triangle numbers. Then the total operations would be about 200000 * 633 which is around 126e6, which is acceptable in C++ but in Python might be borderline.\n\n   However, note that p can be 0. Also, we are allowed to use any triangle number (and we can use the same one repeatedly). But the above DP would consider every triangle number for every state.\n\n   But wait, we are allowed to use the same triangle number repeatedly. However, the above recurrence does not enforce that we use the same triangle number multiple times? Actually, it does: because when we subtract T(k) from i, we are effectively removing one SCC of size k, and then we can use any combination for the rest. However, the recurrence does not consider using the same triangle number multiple times because we are iterating over all k for each state, and the same k can be used again in the dp[i-T(k)] part.\n\n   But note: the dp[i-T(k)] might itself use k again. So this recurrence is for unlimited supply of triangle numbers.\n\n   However, the problem is that the triangle numbers are not necessarily the denominations we use. We have to consider all triangle numbers (each k>=2 gives a triangle number T(k)).\n\n   But note: the triangle numbers are fixed. So we can precompute all the triangle numbers that are <= p (max p=200000). Then the set of denominations is { T(k) for k from 2 up to the maximum k such that T(k)<=p }.\n\n   Then we can run:\n\n        dp = [a big number]*(p+1)\n        dp[0] = 0\n        For i from 1 to p:\n            for each t in triangle_numbers (sorted, and only those <= i):\n                if dp[i-t] != big number:\n                    dp[i] = min(dp[i], dp[i-t] + k)   # but note: t = T(k) = k*(k-1)//2, so we have stored k for each t.\n\n   But wait, we need to map t to k. Alternatively, we can store the triangle numbers and their corresponding node counts (k). However, note: the same t might appear from different k? No, because T(k) is strictly increasing.\n\n   Steps:\n\n        Precompute triangle numbers and corresponding k for k from 2 until T(k) > 200000.\n\n        Then, for each p from 0 to 200000, we compute dp[p] as above.\n\n   But note: p can be 0, then we use 0 nodes.\n\n   However, the problem says: p in [0,200000]. So we need to handle p=0.\n\n   But wait, is that the only part? The problem also asks for the maximum number of unidirectional pairs.\n\n   What is a unidirectional pair? An ordered pair (u, v) (u != v) such that there is a path from u to v but not from v to u.\n\n   In our graph, which is built by multiple SCCs and edges between them (forming a DAG), we have:\n\n   - Within an SCC, there are no unidirectional pairs (because if (u, v) is a path then so is (v, u)).\n   - Between two different SCCs, say A and B, we might have edges from A to B but not from B to A (if the DAG has edges from A to B then we cannot have edges from B to A, otherwise they would be merged). \n\n   But note: the problem does not specify the structure of the DAG. However, to maximize the number of unidirectional pairs, we can assume that the graph is built so that between two SCCs we have either all edges from A to B or none (but not both). Then, if there is an edge from A to B, then for any node u in A and v in B, we have a path from u to v (via the edges of A and then the edge from A to B) but no path from v to u (because the DAG has no reverse edges). Similarly, if there is an edge from B to A, then we have paths from B to A but not from A to B.\n\n   However, we are free to choose the edges between the SCCs arbitrarily (as long as the DAG condition holds: no cycles between the SCCs). \n\n   Therefore, the unidirectional pairs come from:\n\n        For two distinct SCCs A and B, we can choose to put edges from A to B or from B to A or none or both? But wait, if we put both, then we would have a path from A to B and from B to A, so A and B should be merged. Therefore, we cannot have both. So we have three choices: A->B, B->A, or none.\n\n   Now, if we choose to put edges from A to B, then we get |A| * |B| unidirectional pairs (from A to B). Similarly, if we put edges from B to A, we get |B| * |A| unidirectional pairs (from B to A). But note: the problem counts ordered pairs (u, v) with u != v. \n\n   However, we are allowed to choose the direction arbitrarily. To maximize the total unidirectional pairs, we would choose the direction that gives the maximum product? Actually, we can choose independently for each pair of SCCs? But wait, the entire graph must be a DAG. We can arrange the SCCs in a linear order (like a total order) and then put edges from an earlier SCC to a later one? But actually, we can choose any DAG structure.\n\n   However, note: the condition for being p-reachable only constrains the mutual reachability (within SCCs). The DAG structure can be arbitrary.\n\n   But to maximize the unidirectional pairs, we would want to maximize the edges between SCCs. The maximum edges we can have between two SCCs is either |A|*|B| (if we choose one direction) or 0 (if we choose none). However, we are allowed to choose the direction arbitrarily for each pair (as long as we don't create cycles). The maximum is achieved when we choose a total order on the SCCs and put edges from every earlier SCC to every later SCC. Then, for two SCCs A and B (with A before B in the order), we have edges from A to B, so we get |A|*|B| unidirectional pairs.\n\n   Then, the total unidirectional pairs would be the sum over all ordered pairs (A, B) (with A and B distinct) of |A|*|B|, but only if we have chosen to put edges from A to B (and not the reverse). But note: we are building a DAG, and we can choose the direction arbitrarily for each pair (but we cannot have both). However, the maximum is achieved when we fix a total order and put edges from every earlier to every later.\n\n   Then the total unidirectional pairs is:\n\n        Sum_{all unordered pairs (A, B) with A != B} max(|A|*|B|, 0)   [but actually we are only allowed to pick one direction, and we choose the one that gives the full |A|*|B|]\n\n        Actually, if we fix a total order, then for each pair (A, B) we get |A|*|B| if A is earlier and |B|*|A| if B is earlier? No: we choose the direction. But note: we cannot have both. However, we are free to choose the direction arbitrarily for each edge. But if we choose the direction arbitrarily, then we can get the product for one direction and not the other. But the maximum for a single pair (A, B) is |A|*|B| (by putting edges from A to B). However, we can do that independently for every pair.\n\n   But wait, if we put edges from A to B, then we cannot put edges from B to A. However, we can choose independently for each pair (A, B) the direction. The maximum total unidirectional pairs is the sum over all unordered pairs (A, B) of |A|*|B|, because we can always orient the edge from the smaller one to the larger one? Not necessarily, but we can choose the direction arbitrarily. Actually, the maximum for a pair (A, B) is |A|*|B| (by putting edges from A to B). But note: we are allowed to put edges from A to B and from B to A only if we don't create a cycle? Actually, we are not allowed to put both. However, we are building a DAG, so we must choose one direction or none.\n\n   But the problem says: we are to maximize the number of unidirectional pairs. The unidirectional pairs from two SCCs A and B: if we put edges from A to B, then we get |A|*|B| (all pairs (u in A, v in B) are unidirectional). Similarly, if we put edges from B to A, we get |B|*|A| (same number). So the product is the same. Therefore, for each unordered pair (A, B) we can get |A|*|B| unidirectional pairs by choosing one direction arbitrarily.\n\n   However, we cannot choose both directions. But we can choose one direction and get |A|*|B|. Then the total unidirectional pairs is the sum over all unordered pairs (A, B) of |A|*|B|, provided that we choose one direction for every pair.\n\n   But wait, is that allowed? We are building a DAG. If we choose a direction for every pair (A, B) arbitrarily, then we must ensure that the entire graph is acyclic. However, if we choose a total order (linear order) on the SCCs, then we can put edges from every earlier SCC to every later SCC, and then the graph is acyclic. Then, we get for every pair (A, B) (with A before B) the edges from A to B, and then the unidirectional pairs are |A|*|B|. And the total is:\n\n        Sum_{i<j} (size_i * size_j)\n\n   But note: the entire graph has N nodes (the sum of the sizes of the SCCs). Then the total number of unordered pairs is C(N,2) and the total mutual pairs is p (the given). The total unidirectional pairs (when we use the maximal configuration) is:\n\n        (Total pairs of nodes) * 1 - (Mutual reachability pairs) - (Unidirectional pairs) ??? \n\n   Actually, note: the entire relation is:\n\n        For two distinct nodes u and v, there are four possibilities:\n\n          1. There is a path from u to v and from v to u: then (u,v) and (v,u) are mutual (counted in p only for u<v, but the problem counts the mutual pairs only for u<v, but for the entire graph, the mutual pairs are counted as unordered pairs? Actually, the problem states: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". So the mutual pairs are counted as unordered pairs (each unordered pair is represented by one ordered pair with u<v). However, for the entire graph, the mutual pairs (for distinct nodes) are the ones within the same SCC. And note: within an SCC, every unordered pair (u,v) (with u != v) is mutual, and there are C(n_i,2) for each SCC.\n\n        Now, for two distinct nodes in different SCCs, they are not mutually reachable. Then, the directed edge (or lack thereof) determines the unidirectional pairs.\n\n        However, note: the problem does not require that the graph is strongly connected. It only requires that the total mutual pairs (for u<v) is p.\n\n        The total number of ordered pairs (u, v) with u != v is N*(N-1). Then, the graph can be broken down as:\n\n          - Mutual pairs: exactly p (but note: the mutual pairs are defined for u<v, so the total mutual pairs (counting both orders) is 2*p? Actually, the problem says \"exactly p ordered pairs\" but wait: the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v\". So the mutual pairs are only counted once (for u<v). \n\n        But note: the definition of unidirectional pair: (u, v) is unidirectional if there is a path from u to v and not from v to u. This is an ordered pair. So for each unordered pair (u, v) (with u != v) that is not mutual, we can have:\n\n          - Either (u->v) is present (and v->u is absent) OR (v->u) is present (and u->v is absent).\n\n        However, the total number of ordered pairs (u, v) with u != v is N*(N-1). The mutual pairs (for u<v) are p. But note: the mutual pairs are symmetric. So the entire graph has:\n\n          - For each unordered pair {u, v} that is mutual, we have two ordered pairs (u, v) and (v, u) that are mutual. However, the problem only counts one of them (the one with u<v). But the definition of unidirectional pair is asymmetric.\n\n        Actually, the problem does not require that the graph is built in a particular way. We are free to choose the edges arbitrarily (as long as the mutual reachability condition is satisfied: within an SCC, the graph is strongly connected; between two SCCs, we cannot have two-way paths). \n\n        Now, the total number of ordered pairs (u, v) (u != v) is N*(N-1). This breaks down as:\n\n          - Mutual: for each unordered pair {u, v} that is in the same SCC, we have two ordered pairs (u, v) and (v, u) that are mutual. But wait, the problem only counts the one with u<v. So the total mutual pairs (as per the problem) is p, which is the number of unordered pairs that are mutual (because for each mutual unordered pair, we count one ordered pair (the one with u<v)).\n\n          - Unidirectional: the remaining ordered pairs (u, v) (u != v) that are not mutual.\n\n        However, note: if two nodes are in different SCCs, then they are not mutually reachable, so they form an unidirectional pair in one direction and not the other? Actually, they can form unidirectional pairs in one direction or the other, but we are allowed to choose the edges arbitrarily (as long as we don't create cycles).\n\n        The total number of ordered pairs (u, v) (u != v) is N*(N-1). The mutual pairs (for u<v) are p. But note: the mutual pairs are symmetric, so the entire mutual pairs (counting both orders) is 2*p? Actually, no: because the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v\". So the total mutual ordered pairs (considering both orders) would be 2*p only if the graph were undirected? But here, the graph is directed and the mutual condition is symmetric. \n\n        Actually, the mutual condition is symmetric: if (u, v) is mutual then (v, u) is also mutual. And the problem counts (u, v) for u<v. So the total mutual ordered pairs (if we count both orders) is 2*p? But wait, the problem says \"exactly p ordered pairs (u, v) such that u < v\", so the total mutual ordered pairs (over all u, v with u != v) is 2*p? \n\n        However, let me clarify: \n          - The problem states: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\".\n\n        So the total mutual pairs (if we consider ordered pairs) is 2*p? Actually, no: because the condition for mutual is symmetric. So the set of ordered pairs (u, v) with u<v and mutual is p. Then the set of ordered pairs (v, u) (with v<u) is also mutual? But the problem does not require that. However, note the definition: a directed graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and mutual reachability.\n\n        But the condition for mutual reachability is symmetric. So if (u, v) is mutual, then (v, u) is also mutual. But the problem only counts (u, v) when u < v. Therefore, the entire graph has 2*p mutual ordered pairs (if we consider all ordered pairs) but the condition only requires p (for u<v). \n\n        However, wait: the problem does not say anything about the other ordered pair. But note: the graph must be built so that the mutual condition holds for the entire graph. \n\n        Now, the unidirectional pairs are the ordered pairs (u, v) (u != v) that are not mutual. \n\n        Therefore, the total number of ordered pairs (u, v) (u != v) is N*(N-1). The number of mutual ordered pairs is 2*p? Actually, no: because the problem counts only the ones with u<v. The mutual condition for the entire graph must hold: for any two nodes u and v, if they are in the same SCC, then they are mutually reachable, so both (u, v) and (v, u) are mutual. But if they are in different SCCs, then neither (u, v) nor (v, u) is mutual? Actually, no: if they are in different SCCs, then by definition there is no path from one to the other in both directions. However, there might be a path in one direction? \n\n        But wait, the problem says: \"there exists a path from u to v and no path from v to u\" for unidirectional. And for mutual: there exists a path from u to v and from v to u.\n\n        Therefore, for two nodes in different SCCs, they are not mutually reachable, but they might be unidirectionally reachable (if there is a path from u to v but not from v to u). \n\n        So the breakdown:\n\n          Total ordered pairs (u, v) (u != v): N*(N-1)\n\n          = Mutual pairs (both directions) + Unidirectional pairs\n\n        But note: the mutual pairs are symmetric. So the mutual pairs are counted twice in the symmetric view, but the problem only counts one per unordered pair.\n\n        Actually, we can break the graph into:\n\n          - Within each SCC (of size s): there are s*(s-1) ordered pairs (u, v) (u != v) that are mutual.\n\n          - Between two different SCCs (say of sizes s and t): the number of ordered pairs (u, v) with u in the first and v in the second is s*t. These are not mutual. However, we can choose to put edges from the first to the second or from the second to the first or none. The unidirectional pairs from these s*t pairs are:\n\n                If we put edges from the first to the second, then we get s*t unidirectional pairs (from the first to the second) and 0 from the second to the first.\n\n                If we put edges from the second to the first, then we get t*s unidirectional pairs (from the second to the first) and 0 from the first to the second.\n\n                If we put no edges, then we get 0.\n\n          But note: we are allowed to choose independently for each pair of SCCs? However, we must maintain a DAG. \n\n        Therefore, the total mutual pairs (for ordered pairs) is: \n            Sum_{each SCC of size s} [s*(s-1)]\n\n        And the problem says: this sum (for u<v) is p. But note: the problem counts the ordered pairs (u, v) with u<v. However, the mutual pairs (for u<v) is the number of unordered pairs that are mutual? Actually, the number of unordered pairs that are mutual is p (because the problem says \"exactly p ordered pairs (u, v) with u < v\", and each unordered pair is represented by one ordered pair with u<v). \n\n        But note: the total mutual ordered pairs (both directions) is 2*p? Actually, no: because the problem counts only the ones with u<v. The entire graph has mutual ordered pairs for both directions? \n\n        Let me re-read: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\".\n\n        This means that the graph has exactly p mutual pairs (each unordered pair is counted once). But in reality, each unordered pair that is mutual gives two ordered pairs (u, v) and (v, u) that are mutual. However, the problem only counts the one with u<v. So the total mutual ordered pairs (if we were to count all) would be 2*p? \n\n        Actually, no: because the problem does not require that the graph is built in a way that the mutual pairs are counted only for u<v. The condition for being p-reachable is that the number of ordered pairs (u, v) with u<v and mutual is p. \n\n        But note: the entire graph might have more mutual pairs if we consider both orders? Actually, the condition does not forbid that. The condition is: the graph must have exactly p ordered pairs (u, v) with u<v and mutual. \n\n        However, the mutual condition is symmetric. So if (u, v) is mutual (with u<v), then (v, u) is also mutual. But (v, u) is not considered in the count (because v>u). So the condition is only about the pairs with u<v.\n\n        Therefore, the entire graph has exactly p unordered pairs that are mutual. And the total mutual ordered pairs (if we count all) is 2*p.\n\n        Then, the total unidirectional pairs (ordered) is:\n\n            Total ordered pairs (u != v) - Total mutual ordered pairs (both directions)\n\n            = N*(N-1) - 2*p\n\n        However, wait: in the between-SCCs part, we can choose the direction arbitrarily, but we are not forced to put edges in one direction. We can choose to put edges in one direction for some pairs and none for others. But note: the problem says \"among all such p-reachable directed graphs with the minimum number of nodes, let G denote a graph which maximizes the number of unidirectional pairs\".\n\n        We are free to choose the edges arbitrarily (as long as the mutual condition is satisfied and the graph is built with",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the one that maximizes the number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and there is mutual reachability between u and v.\n   - The mutual reachability condition implies that nodes within the same strongly connected component (SCC) must form a complete SCC, contributing C(n_i, 2) mutual pairs for an SCC of size n_i.\n   - The goal is to partition p into a sum of triangle numbers (C(n_i, 2)) such that the total number of nodes (sum of n_i) is minimized.\n\n2. **Key Insight**:\n   - The minimal number of nodes is achieved by using the largest possible triangle numbers first, as they contribute more mutual pairs per node.\n   - For example, an SCC of size 3 contributes 3 mutual pairs (C(3, 2) = 3) with only 3 nodes, whereas three SCCs of size 2 each contribute 1 mutual pair (C(2, 2) = 1) per SCC, requiring 6 nodes total.\n\n3. **Dynamic Programming**:\n   - We use dynamic programming to precompute the minimal node count for each possible p up to 200,000. The DP state `dp[i]` represents the minimal nodes needed to achieve exactly i mutual pairs.\n   - The recurrence relation involves considering all triangle numbers (T(k) = k*(k-1)/2) less than or equal to i and updating `dp[i]` based on `dp[i - T(k)] + k`.\n\n4. **Maximizing Unidirectional Pairs**:\n   - Once the minimal node count is determined, the maximum number of unidirectional pairs is calculated by considering all ordered pairs of nodes minus the mutual pairs. Specifically, it's N*(N-1) - 2*p, where N is the minimal number of nodes.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    max_val = 200000\n    tri = []\n    k = 2\n    while True:\n        t_val = k * (k - 1) // 2\n        if t_val > max_val:\n            break\n        tri.append((t_val, k))\n        k += 1\n        \n    dp = [10**9] * (max_val + 1)\n    dp[0] = 0\n    \n    for i in range(1, max_val + 1):\n        best = 10**9\n        for t_val, k_val in tri:\n            if i >= t_val:\n                if dp[i - t_val] != 10**9:\n                    best = min(best, dp[i - t_val] + k_val)\n        dp[i] = best\n\n    n_nodes = dp[p]\n    \n    if n_nodes == 10**9:\n        n_nodes = 0\n        \n    total_ordered_pairs = n_nodes * (n_nodes - 1)\n    unidirectional = total_ordered_pairs - 2 * p\n    \n    print(f\"{n_nodes} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, which is a single integer p.\n2. **Special Case Handling**: If p is 0, the output is \"0 0\" since no nodes are needed and there are no unidirectional pairs.\n3. **Triangle Numbers Calculation**: We compute all triangle numbers (T(k) = k*(k-1)/2) up to 200,000, storing each along with its corresponding k (node count).\n4. **Dynamic Programming Setup**: The DP array `dp` is initialized with a large value (10^9) to represent unreachable states, except `dp[0]` which is 0 (no nodes needed for zero mutual pairs).\n5. **DP Array Population**: For each value from 1 to 200,000, we check all triangle numbers less than or equal to the current value. If a valid combination is found, `dp[i]` is updated to the minimal node count.\n6. **Result Calculation**: The minimal node count for p is retrieved from `dp[p]`. The maximum number of unidirectional pairs is then calculated as the total ordered pairs (N*(N-1)) minus twice the mutual pairs (2*p).\n7. **Output**: The results are printed, showing the minimal node count and the maximum unidirectional pairs.\n\nThis approach efficiently computes the solution by leveraging dynamic programming to minimize node usage and straightforward arithmetic to determine unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    max_val = 200000\n    tri = []\n    k = 2\n    while True:\n        t_val = k * (k - 1) // 2\n        if t_val > max_val:\n            break\n        tri.append((t_val, k))\n        k += 1\n        \n    dp = [10**9] * (max_val + 1)\n    dp[0] = 0\n    \n    for i in range(1, max_val + 1):\n        best = 10**9\n        for t_val, k_val in tri:\n            if i >= t_val:\n                if dp[i - t_val] != 10**9:\n                    best = min(best, dp[i - t_val] + k_val)\n        dp[i] = best\n\n    n_nodes = dp[p]\n    \n    if n_nodes == 10**9:\n        n_nodes = 0\n        \n    total_ordered_pairs = n_nodes * (n_nodes - 1)\n    unidirectional = total_ordered_pairs - 2 * p\n    \n    print(f\"{n_nodes} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 1080,
        "thoughts_token_count": 8191
    }
}