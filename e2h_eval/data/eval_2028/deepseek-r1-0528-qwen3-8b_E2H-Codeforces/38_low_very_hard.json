{
    "start": 1758299434.7390244,
    "end": 1758303128.112289,
    "start-formatted": "2025-09-20 01:30 KST",
    "end-formatted": "2025-09-20 02:32 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000) and we need to output two numbers:\n\n 1. The minimum number of nodes required to have a directed graph that is p-reachable (i.e., contains exactly p ordered pairs (u, v) such that u < v and there is a path from u to v and from v to u). Note: the problem says \"exactly p ordered pairs with u < v and mutual reachability\". However, note that in a strongly connected component (SCC), every pair (u, v) with u < v is counted? Actually, the problem states: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". So we are counting unordered pairs (but ordered by node index) that form a strongly connected component? Actually, note: the entire graph might not be strongly connected. But the condition is that the graph is p-reachable.\n\n However, note: the problem says \"a directed graph is called p-reachable if it contains exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\" \n\n Let me clarify: We are counting the pairs (u, v) with u < v for which u and v are mutually reachable. This means that the graph can be decomposed into strongly connected components (SCCs). The condition for two distinct nodes u and v to be in the same SCC is that they are mutually reachable. Then, for a given SCC, if it has k nodes, then the number of pairs (u, v) with u < v and both in the same SCC is C(k,2) = k*(k-1)//2.\n\n Therefore, the entire graph's p is the sum of C(k_i, 2) for each SCC of size k_i.\n\n Now, we are allowed to design a graph (with minimum number of nodes) such that the total number of mutual pairs (i.e., the sum of C(k_i,2) over all SCCs) is exactly p.\n\n Additionally, we are to maximize the number of unidirectional pairs (u, v) (with u != v, a path from u to v but not from v to u) in the graph with the minimum number of nodes.\n\n Steps:\n\n 1. Find the minimum number of nodes n such that we can partition the n nodes into several SCCs (each being a set of nodes that are mutually reachable) and the total number of mutual pairs (i.e., the sum of C(k_i,2) for each SCC of size k_i) is at least p, and we want to achieve exactly p? Actually, we must have exactly p.\n\n However, note: we can also have multiple SCCs. The entire graph does not have to be strongly connected. The condition is that the graph is p-reachable (exactly p mutual pairs). \n\n But note: the definition of mutual pairs is only for pairs (u, v) with u < v. And we are counting them per SCC. Since the graph is decomposed into SCCs, the mutual pairs are entirely contained within each SCC.\n\n So the problem reduces to: represent p as the sum of terms of the form t_i = k_i*(k_i-1)//2, where the k_i are positive integers (the sizes of the SCCs) and the sum of the k_i is the total number of nodes n (which we want to minimize). Moreover, we can have as many SCCs as we wish, but the nodes are partitioned.\n\n However, note: we are allowed to have isolated nodes (SCC of size 1) which contribute 0 to p.\n\n But wait: the problem says \"exactly p\", so we must have the sum of C(k_i,2) equal to p.\n\n How to minimize the total nodes? We want to minimize n = sum_i k_i.\n\n Also, we want to maximize the number of unidirectional pairs.\n\n First, let's focus on minimizing n.\n\n Observation: \n   We can use the fact that the function f(k) = k*(k-1)//2 is the triangular number. We want to represent p as a sum of triangular numbers (each term corresponding to an SCC) and minimize the total nodes (sum of the k_i).\n\n However, note: we cannot break an SCC arbitrarily. Each SCC must be a complete subgraph? Not necessarily, but the minimal representation for a given k is to have one SCC of size k. And the triangular number for k is fixed.\n\n But note: we are allowed to have multiple SCCs. The problem does not require the entire graph to be strongly connected.\n\n Therefore, the minimal n is the minimal sum of k_i such that the multiset {k_i} (each k_i>=1) satisfies:\n      sum_i [k_i*(k_i-1)//2] = p",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the one that maximizes the number of unidirectional node pairs.\n\n### Approach\n1. **Understanding p-Reachable Graph**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) such that u < v and there is a path from u to v and from v to u. These pairs correspond to nodes within strongly connected components (SCCs). The number of such pairs in an SCC of size k is given by the triangular number \\( \\frac{k(k-1)}{2} \\).\n\n2. **Minimizing Nodes**: The goal is to partition the graph into SCCs such that the sum of their triangular numbers equals p, and the total number of nodes (sum of the sizes of all SCCs) is minimized. This involves using the largest possible SCCs first to cover more of p with fewer nodes.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, the next step is to maximize the number of unidirectional pairs (u, v) where there is a path from u to v but not from v to u. This is achieved by structuring the graph such that nodes are arranged in a linear order, with edges directed from higher-numbered nodes to lower-numbered ones, except within each SCC where edges are bidirectional.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"1 0\")\n        return\n        \n    n_nodes = 0\n    remaining = p\n    scc_sizes = []\n    \n    k = 1\n    while remaining > 0:\n        tri_k = k * (k - 1) // 2\n        if tri_k > remaining:\n            k -= 1\n            tri_k = (k * (k - 1)) // 2\n            \n        count = remaining // tri_k\n        scc_size = k\n        scc_count = count\n        remaining %= tri_k\n        \n        for _ in range(scc_count):\n            scc_sizes.append(scc_size)\n            \n        k += 1\n        \n    total_nodes = sum(scc_sizes)\n    print(total_nodes, end=' ')\n    \n    if total_nodes == 0:\n        print(0)\n        return\n        \n    max_unidirectional = 0\n    for size in scc_sizes:\n        max_unidirectional += size * (size - 1)\n        \n    n = total_nodes\n    max_unidirectional += n * (n - 1) // 2 - p\n    \n    print(max_unidirectional)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer p, which represents the number of mutual pairs required in the graph.\n2. **Handling Edge Cases**: If p is 0, the solution requires at least one node with no edges, hence output is \"1 0\".\n3. **Finding SCC Sizes**: The algorithm calculates the sizes of SCCs needed to sum up their triangular numbers to p. It starts with the largest possible SCC size and uses as many as possible before moving to smaller sizes.\n4. **Calculating Total Nodes**: The total number of nodes is the sum of all SCC sizes.\n5. **Maximizing Unidirectional Pairs**: The maximum number of unidirectional pairs is derived by considering all possible directed edges between nodes outside the SCCs, adjusted by the existing mutual pairs (p). The formula used is \\( \\frac{n(n-1)}{2} - p \\), where n is the total number of nodes.\n\nThis approach efficiently minimizes the number of nodes while maximizing the unidirectional pairs by leveraging triangular numbers and combinatorial mathematics.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"1 0\")\n        return\n        \n    n_nodes = 0\n    remaining = p\n    scc_sizes = []\n    \n    k = 1\n    while remaining > 0:\n        tri_k = k * (k - 1) // 2\n        if tri_k > remaining:\n            k -= 1\n            tri_k = (k * (k - 1)) // 2\n            \n        count = remaining // tri_k\n        scc_size = k\n        scc_count = count\n        remaining %= tri_k\n        \n        for _ in range(scc_count):\n            scc_sizes.append(scc_size)\n            \n        k += 1\n        \n    total_nodes = sum(scc_sizes)\n    print(total_nodes, end=' ')\n    \n    if total_nodes == 0:\n        print(0)\n        return\n        \n    max_unidirectional = 0\n    for size in scc_sizes:\n        max_unidirectional += size * (size - 1)\n        \n    n = total_nodes\n    max_unidirectional += n * (n - 1) // 2 - p\n    \n    print(max_unidirectional)\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 847,
        "thoughts_token_count": 1023
    }
}