{
    "start": 1758300349.9723275,
    "end": 1758304147.7373192,
    "start-formatted": "2025-09-20 01:45 KST",
    "end-formatted": "2025-09-20 02:49 KST",
    "gpu": 2,
    "pid": 53,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# You're Given a String...\n\nYou're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).\n\n## Input\nThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n\n## Output\nOutput one number — length of the longest substring that can be met in the string at least twice.\n\n## Example\n### Input\n['abcd', 'ababa', 'zzz']\n\n### Output\n['0', '3', '2']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n We are guaranteed the string length is at most 100, so we can use a straightforward approach.\n Steps:\n 1. Read the input string.\n 2. We are to find the longest substring that appears at least twice (and occurrences can overlap).\n 3. We'll consider all possible substrings and check for duplicates. However, note that the string length is at most 100, so we can try from longest to shortest.\n\n Approach:\n Let n = length of the string.\n We'll iterate over possible lengths from n//2 down to 1 (but note: we might have duplicates even in shorter ones? Actually, we want the longest, so we start from the maximum possible and go downwards until we find one that appears at least twice).\n\n However, note: the problem says \"longest substring that can be met at least twice\". So we want the maximum length L such that there exists a substring of length L that appears at least two times (possibly overlapping).\n\n Alternate approach: \n   For a fixed length L, we can generate all contiguous substrings of length L and use a set to check for duplicates. The moment we find a duplicate for a given L, then the answer is L.\n\n But note: the problem says the substring must appear at least twice. So for each L (from max_possible down to 1) we check if there's any substring of length L that appears at least twice.\n\n However, the maximum L for which a duplicate can occur is floor((n)/2) ? Actually, consider: the entire string of length n can't have a duplicate unless the string is repeated, but we are allowed to overlap. But the maximum duplicate substring cannot exceed half the string? Actually, no: consider \"abcabc\" -> the substring \"abc\" of length 3 appears twice, and the string length is 6. So maximum duplicate substring length can be up to floor(n/2) only if the substring is repeated without overlapping? Actually, when overlapping is allowed, we can have a substring of length L appearing multiple times even if the entire string is not long enough for two non-overlapping copies. \n\n Example: \"aaa\" -> the substring \"a\" (length 1) appears three times. But the longest substring that appears at least twice is \"a\" (so 1). However, note that \"aa\" (length 2) also appears twice? \n   In \"aaa\": \n      \"aa\" starting at index0: \"aa\"\n      \"aa\" starting at index1: \"aa\"\n   So yes, \"aa\" also appears twice. Therefore, the answer for \"aaa\" is 2.\n\n But wait, the problem says \"longest\", so we take the maximum L for which there is a duplicate.\n\n How to do it?\n   Let n = len(s)\n   We can iterate L from min(n, ...) but actually we can consider L from 1 to n//2 (because if we have two copies, the total length needed is at least 2*L, but note they can overlap arbitrarily). However, we can also have a substring of length L that appears twice with some overlap. The condition is that there are two starting indices i and j (with i < j) such that s[i:i+L] == s[j:j+L] and j-i >= 0 (they can overlap as long as the substring is within the string).\n\n But note: the maximum L for which a duplicate can exist is n - L + 1 >= 2? Actually, we need at least two starting positions. The last starting position is n-L. So we require that the substring length L is such that there are at least two distinct starting indices i and j (with i<j) such that i+L <= n and j+L <= n.\n\n However, we can have overlapping, so the condition is just that the substring length L must be at most n, and we are looking for two starting indices (which can be consecutive). The maximum L for which duplicate can occur is n-1 (if the whole string is repeated, but wait: if the string is \"aaaa\", then the substring \"aaa\" (length 3) appears three times. But note: the starting indices for \"aaa\" in \"aaaa\" are 0 and 1, so two distinct starting indices for the same substring of length 3. \n\n Actually, the constraint on L is that the substring must fit in the string at least two times. The minimal gap between two starting indices is 0 (overlapping). So the condition is that the substring of length L must appear at least two times, meaning the string must have at least two contiguous segments of length L that are equal.\n\n Since the problem allows overlapping, the maximum L we need to check is up to n (but if we take L = n, then we have only one occurrence). So the maximum L for which we can have two occurrences is n-1? Actually, no: consider a string of length 5: \"abcde\". Then the longest substring that appears twice must be of length less than 5. But wait, what about \"a\" in \"aaa\"? The substring \"aa\" (length 2) appears twice in \"aaa\", and the string length is 3. So the maximum L we need to check is from 1 to n-1? Actually, no: consider a string of length 4: \"abab\". The substring \"ab\" (length 2) appears twice. But also \"aba\" (length 3) appears once, but wait: \n   \"abab\": \n        substrings of length 3: \"aba\" (at index0) and \"bab\" (at index1). They are different.\n\n However, note: the problem does not require the two occurrences to be non-overlapping. But the substring must appear at least twice. The maximum L for which we can have two occurrences is floor((n+1)/2) ??? Not exactly.\n\n Actually, the maximum L for which two occurrences can exist is n - L + 1 >= 2? We don't require non-overlapping. We just require two starting indices i and j (with i<j) such that the substring of length L starting at i and the substring of length L starting at j are the same. The condition for the existence of two starting indices is that the string has at least two starting indices for a substring of length L, i.e., we need at least two positions: from 0 to n-L. So the number of starting indices is (n - L + 1). We need at least two, so n-L+1 >= 2 => L <= n-1.\n\n So we can iterate L from 1 to n-1 (in descending order) and check if there exists a substring of length L that appears at least twice.\n\n But note: if we find a substring of length L that appears at least twice, then we output L and break.\n\n However, we must consider that the same substring might appear more than twice, but we only need two.\n\n Implementation for a fixed L:\n   We can use a set to record all substrings of length L and check for duplicates.\n\n Example: \n   s = 'ababa'\n   n = 5\n   Check L=4: \n        substrings: 'abab', 'baba' -> two distinct, no duplicate -> continue.\n   Check L=3: \n        substrings: 'aba', 'bab', 'aba' -> 'aba' appears twice -> answer is 3.\n\n But wait, the example input: ['abcd', 'ababa', 'zzz'] -> outputs [0, 3, 2]\n\n For \"abcd\": \n   n=4, so we check L from 3 down to 1.\n     L=3: substrings: 'abc','bcd' -> distinct -> no duplicate.\n     L=2: 'ab','bc','cd' -> distinct -> no duplicate.\n     L=1: 'a','b','c','d' -> distinct -> no duplicate.\n   So answer is 0.\n\n However, the problem says: output one number — length of the longest substring that can be met in the string at least twice.\n\n If none is found, then output 0.\n\n But note: the example input includes the string \"zzz\", which gives output 2.\n\n For \"zzz\":\n   n=3\n   Check L=2: \n        substrings: 'zz','zz' -> duplicate -> answer 2.\n\n However, wait: why not 3? Because the substring of length 3 is \"zzz\", and it appears only once (if we consider the entire string). But wait, the entire string is \"zzz\", so there is only one occurrence of the substring \"zzz\". However, the substring \"zz\" appears twice: at index0 and index1.\n\n So the algorithm:\n\n   n = len(s)\n   # We'll check from L = min(n, ...) but we know L from 1 to n-1 (max L is n-1 because we need at least two starting indices, so n-L+1>=2 -> L<=n-1)\n\n   We can iterate L from n-1 down to 1 (and then if we find one, output and break) OR from n//2 down to 1? Actually, the maximum L we can get is n-1, but we are going from largest to smallest.\n\n   Steps:\n     for L in range(n-1, 0, -1):\n        seen = {}\n        found_duplicate = False\n        # Alternatively, we can use a set for the substrings of length L.\n        substrings = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            # If we have seen this substring before, then we found a duplicate.\n            if substr in substrings:\n                found_duplicate = True\n                break\n            else:\n                substrings.add(substr)\n\n        if found_duplicate:\n            print(L)\n            exit(0)\n\n     # If we didn't find any, then output 0.\n\n But wait, what if the same substring appears more than twice? We break at the first duplicate. That's okay because we are checking for at least two.\n\n However, we are iterating from largest L to smallest, so we return the first (largest) L for which a duplicate is found.\n\n But note: we are using a set for each L. Since n is at most 100, and L from 1 to 99, and for each L we iterate over (n-L+1) which is at most 100, and each substring operation is O(L) (which is at most 99), so worst-case 100*100*99 = 990000 operations, which is acceptable.\n\n However, we can optimize by breaking early in the inner loop.\n\n But note: the above code uses a set and breaks as soon as a duplicate is found for the current L.\n\n Let me test with the examples:\n\n Example 1: \"abcd\" (n=4)\n   L=3: substrings: \n        i=0: \"abc\" -> add\n        i=1: \"bcd\" -> add\n        no duplicate -> next L=2\n   L=2: substrings: \n        i=0: \"ab\" -> add\n        i=1: \"bc\" -> add\n        i=2: \"cd\" -> add -> no duplicate -> next L=1\n   L=1: \n        i=0: 'a' -> add\n        i=1: 'b' -> add\n        i=2: 'c' -> add\n        i=3: 'd' -> add -> no duplicate -> then output 0.\n\n Example 2: \"ababa\" (n=5)\n   L=4: \n        i=0: \"abab\" -> add\n        i=1: \"baba\" -> add -> no duplicate\n   L=3:\n        i=0: \"aba\" -> add\n        i=1: \"bab\" -> add\n        i=2: \"aba\" -> already in set -> duplicate found -> output 3.\n\n Example 3: \"zzz\" (n=3)\n   L=2:\n        i=0: \"zz\" -> add\n        i=1: \"zz\" -> duplicate -> output 2.\n\n Example 4: \"aaa\" (n=3)\n   L=2:\n        i=0: \"aa\" -> add\n        i=1: \"aa\" -> duplicate -> output 2.\n\n But wait, what about \"aaaa\" (n=4)? \n   We expect: \n        substring \"aaa\" (L=3) appears twice? \n            i=0: \"aaa\"\n            i=1: \"aaa\" -> duplicate -> so output 3.\n\n However, let's see: \n   s = \"aaaa\", n=4\n   L=3: \n        i=0: \"aaa\" -> add\n        i=1: \"aaa\" -> duplicate -> output 3.\n\n This is correct.\n\n But wait: the problem statement example output for \"ababa\" is 3, which we got.\n\n However, note: the example input is given as a list of strings? Actually, the problem says: the first input line contains the string.\n\n But the sample input is given as: \n   Input: ['abcd', 'ababa', 'zzz']\n\n This is probably just showing three separate examples. The actual input is one string per run.\n\n So we read one string from stdin.\n\n Code:\n\n   s = input().strip()\n\n   n = len(s)\n   # If the string is empty, then output 0. But the problem says non-empty.\n\n   # We consider L from n-1 down to 1.\n   for L in range(n-1, 0, -1):\n        substrings_seen = set()\n        found = False\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in substrings_seen:\n                found = True\n                break\n            else:\n                substrings_seen.add(substr)\n        if found:\n            print(L)\n            exit(0)\n\n   print(0)\n\n But wait, is there a possibility that a substring of length L appears twice, but we break the inner loop and then the outer loop continues? Actually, no: we break the inner loop and then check `found` and if true we break the outer loop and exit.\n\n However, we are exiting the program when we find the first L (starting from the largest) that has a duplicate.\n\n But note: we are iterating from the largest L (n-1) down to 1, so the first duplicate we find is the longest.\n\n This should be correct.\n\n Let me test with a simple example: \"aba\" (n=3)\n   L=2: \n        i=0: \"ab\" -> add\n        i=1: \"ba\" -> add -> no duplicate.\n   L=1:\n        i=0: 'a' -> add\n        i=1: 'b' -> add\n        i=2: 'a' -> already in set -> duplicate -> output 1.\n\n But is there a longer substring that appears twice? \n   The substring \"a\" (length 1) is the longest? Actually, the substring \"a\" appears twice (at index0 and index2) and there is no substring of length 2 that appears twice. So 1 is correct.\n\n However, note: the substring \"a\" is the longest common substring that appears at least twice? Actually, we have to consider: \n   The substring \"a\" (length 1) is the only one that appears twice. There is no substring of length 2 that appears twice. So yes.\n\n But wait, the substring \"aba\" (the whole string) doesn't appear twice, and the substring \"ab\" and \"ba\" are distinct.\n\n So the answer for \"aba\" is 1.\n\n Another example: \"a\" (n=1) -> then we iterate L from 0 down to 1? Actually, n=1, so range(0,0,-1) doesn't run. Then we print 0.\n\n But wait, for n=1, the substring must be of length at least 1, but the only substring is \"a\", and it appears once. So no duplicate -> output 0.\n\n The code above: \n   for L in range(n-1, 0, -1): \n        when n=1: n-1=0, so range(0,0,-1) is empty -> then we print 0.\n\n So it works.\n\n But note: the problem says the string is non-empty, so n>=1.\n\n We are good.\n\n However, note: the problem input is from standard input. We assume one string per line.\n\n Let's write the code accordingly.\n\n But note: the problem says the first input line contains the string.\n\n Example: \n   Input: \"abcd\"\n\n Code:\n\n   s = input().strip()\n\n   n = len(s)\n   # Edge: if n==0, but guaranteed non-empty.\n\n   for L in range(n-1, 0, -1):\n        seen = set()\n        duplicate_found = False\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                duplicate_found = True\n                break\n            seen.add(substr)\n        if duplicate_found:\n            print(L)\n            exit(0)\n\n   print(0)\n\n However, we can make it more efficient by avoiding creating a set for each L from high to low. But since n is small, it's acceptable.\n\n But note: worst-case, we might check many L's. The maximum L we check is from n-1 down to 1, so n-1 iterations, and each iteration does O(n) work (n-L+1 substrings, each substring of length L). The worst-case total operations is sum_{L=1}^{n-1} (n-L+1)*L. \n\n However, since n<=100, the worst-case is about 100*100*100 = 1e6, which is acceptable.\n\n But we can break early when we find a duplicate. \n\n However, the above code already breaks the inner loop as soon as a duplicate is found. \n\n But note: we are iterating from the largest L to the smallest. So we are checking the longest possible substring first, which is optimal.\n\n Let me test with a string that has no duplicate until a very short L. For example, a string with all distinct characters except two identical adjacent ones at the end? \n\n Example: \"abcdbd\" (n=6). \n   We are looking for the longest substring that repeats.\n\n   The substring \"d\" (length1) will definitely appear twice (at index4 and index5). But we are checking from L=5 down to 1. \n\n   We must check:\n     L=5: \"abcdb\", \"bcdbd\" -> no duplicate.\n     L=4: \"abcd\", \"bcdb\" -> no duplicate.\n     L=3: \"abc\", \"bcd\", \"cdb\", \"dbd\" -> no duplicate? \n           But wait, the substring \"bd\" (length2) appears twice? \n           Actually, we haven't checked L=2 yet.\n\n   But note: the substring \"bd\" (length2) is not checked until we get to L=2. However, we are going from L=5 down to 1, so we will eventually check L=2.\n\n   However, we are not required to find the duplicate at the maximum L only. We are going from large to small and returning the first duplicate.\n\n   But the problem asks for the longest substring that appears at least twice. So we must return the maximum L for which a duplicate exists.\n\n   In \"abcdbd\", the longest substring that appears twice is of length 1? Actually, let's check:\n\n   Substrings of length 2: \n        \"ab\", \"bc\", \"cd\", \"db\", \"bd\" -> all distinct? \n        Wait, \"db\" and \"bd\" are different. So no duplicate for L=2.\n\n   Then the answer is 1.\n\n   Now, what about the substring \"d\" (length1) appears twice (at index4 and index5). So the answer is 1.\n\n   But wait, is there a substring of length 2 that appears twice? \n        The string: \"abcdbd\"\n        The substring \"bd\" appears at index4: \"bd\" (from index4 to 5) and also at index3: \"bd\" (from index3 to 4: \"db\" is not \"bd\", but wait: \n        index3: substring of length2 is \"db\", and index4: \"bd\". So no.\n\n   Then indeed the answer is 1.\n\n   However, note: the substring \"d\" appears twice, so the answer is 1.\n\n   The code will check L=5,4,3,2,1. \n        L=5: no duplicate.\n        L=4: no duplicate.\n        L=3: no duplicate.\n        L=2: \n            i=0: \"ab\" -> add\n            i=1: \"bc\" -> add\n            i=2: \"cd\" -> add\n            i=3: \"db\" -> add\n            i=4: \"bd\" -> add -> no duplicate.\n        L=1:\n            i=0: 'a' -> add\n            i=1: 'b' -> add\n            i=2: 'c' -> add\n            i=3: 'd' -> add\n            i=4: 'b' -> already in set -> duplicate -> output 1.\n\n   Correct.\n\n One more example: \"aabaa\" (n=5)\n   We expect: \n        What are the duplicates?\n        Substring \"aa\" (length2) appears multiple times: \n            indices: 0,1; 3,4; and also at index1: \"aa\" from index1 to 2? \n            Actually, the string: \n                index0: \"a\", index1: \"a\", index2: \"b\", index3: \"a\", index4: \"a\"\n            For L=2:\n                i0: \"aa\" (from index0-1) -> add\n                i1: \"ab\" -> add\n                i2: \"ba\" -> add\n                i3: \"aa\" -> duplicate -> output 2.\n\n   But wait, the substring \"a\" (length1) also appears multiple times, but 2 is larger, so we output 2.\n\n   The code: \n        L=4: \n            i0: \"aaba\" -> add\n            i1: \"abaa\" -> add -> no duplicate.\n        L=3:\n            i0: \"aab\", i1: \"aba\", i2: \"baa\" -> all distinct -> no duplicate.\n        L=2: \n            i0: \"aa\" -> add\n            i1: \"ab\" -> add\n            i2: \"ba\" -> add\n            i3: \"aa\" -> duplicate -> output 2.\n\n   Correct.\n\n However, note: the substring \"aa\" appears at index0 and index3, but also at index1? \n        Actually, the substring starting at index1 is \"ab\", so not \"aa\". But wait, the substring \"aa\" also appears at index3 (covering indices3 and4). So two distinct occurrences: [0,1] and [3,4]. \n\n   The code finds the second occurrence at i=3 and breaks.\n\n So the code is correct.\n\n But note: we are using `exit(0)` which terminates the program. Alternatively, we can break out of the loop and then print.\n\n However, we can restructure without exit:\n\n   for L in range(n-1, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)   # or break out and then print, but we break the inner loop and then break the outer loop.\n                break\n        # We don't break the outer loop here, so we need to break the outer loop.\n\n   Alternatively, we can use:\n\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        duplicate_found = False\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                duplicate_found = True\n                break\n            seen.add(substr)\n        if duplicate_found:\n            ans = L\n            break\n\n   print(ans)\n\n But then we have to initialize ans to 0 and then break.\n\n However, the above code is acceptable.\n\n Since the problem is small, we can do either.\n\n Let me choose the version without exit(0) and use a flag.\n\n Final code:\n\n   s = input().strip()\n   n = len(s)\n   # If the string length is 1, then we skip the loop and output 0.\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        duplicate_found = False\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                duplicate_found = True\n                break\n            seen.add(substr)\n        if duplicate_found:\n            ans = L\n            break\n\n   print(ans)\n\n But wait, the above code does not account for the fact that we are breaking the inner loop and then setting ans and breaking the outer loop.\n\n However, if we don't break the outer loop, then we would check the next L (smaller) even after finding a duplicate for a larger L. But we break the outer loop because we found the largest L.\n\n Alternatively, we can break the outer loop with a break statement after setting ans.\n\n But the above code sets ans and then breaks the outer loop.\n\n However, note: the for loop breaks naturally after the break.\n\n But wait: the break inside the for loop (the outer one) breaks the inner for loop, then we set ans and break the outer for loop.\n\n Actually, the code above breaks the inner loop and then checks if duplicate_found, then sets ans and then breaks the outer loop.\n\n But we can also use:\n\n   s = input().strip()\n   n = len(s)\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                ans = L\n                # Break both loops\n                break\n            seen.add(substr)\n        else:\n            # This else corresponds to the inner loop finishing without break\n            continue\n        break   # break the outer loop if we broke the inner one\n\n   print(ans)\n\n But that's more complicated.\n\n I think the initial version with a flag is clearer.\n\n However, let's stick to the first version that uses a flag and breaks the outer loop.\n\n But wait, the above code I wrote earlier (with the flag) breaks the inner loop and then checks the flag to set ans and break the outer loop.\n\n But note: the flag is set to True and then we break the outer loop.\n\n Alternatively, we can avoid the flag by using:\n\n   s = input().strip()\n   n = len(s)\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                ans = L\n                break\n            seen.add(substr)\n        else:\n            # This else is executed if the inner loop did not break\n            continue\n        break   # break the outer loop if the inner loop broke\n\n   print(ans)\n\n But this is a bit more complex. \n\n I'll use the flag method for clarity.\n\n However, let me test the flag method with the examples.\n\n   Example: \"abcd\" -> no duplicate found for any L, so ans remains 0.\n\n   Example: \"ababa\" -> at L=3, we break the inner loop and set ans=3 and break the outer loop.\n\n   Example: \"zzz\" -> at L=2, we break the inner loop and set ans=2 and break the outer loop.\n\n   Example: \"aaa\" -> at L=2, we break and set ans=2.\n\n   Example: \"aba\" -> at L=1, we break and set ans=1.\n\n   Example: \"a\" -> no loop runs, so ans remains 0.\n\n   Example: \"aabaa\" -> at L=2, we break and set ans=2.\n\n So the flag method is correct.\n\n But wait, what if we have a duplicate in the inner loop, but then we break the inner loop and set ans, and then break the outer loop. Then we output the first L (largest) that has a duplicate.\n\n However, what if there are two different substrings of the same length L that are duplicates? We break at the first duplicate we find. But that's okay because we only need one.\n\n But note: we are iterating the starting index from 0 to n-L. We break at the first duplicate. But the duplicate condition is met as soon as we see a substring that we've seen before. \n\n However, we are storing all the substrings we've seen so far. So the first time we see a duplicate, we break.\n\n This is correct.\n\n Final code with the flag:\n\n   s = input().strip()\n   n = len(s)\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        duplicate_found = False\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                duplicate_found = True\n                break\n            seen.add(substr)\n        if duplicate_found:\n            ans = L\n            break\n\n   print(ans)\n\n But note: we can avoid the flag by using:\n\n   s = input().strip()\n   n = len(s)\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                ans = L\n                break\n            seen.add(substr)\n        else:\n            continue\n        break   # break the outer loop if we broke the inner one\n\n   print(ans)\n\n This is also acceptable. \n\n Which one is better? The flag method is more explicit, but the second one uses the for-else construct.\n\n Since the problem is small, either is acceptable.\n\n I'll choose the flag method for clarity.\n\n However, note: the second method is more efficient in the case where we don't break the inner loop? Actually, no, because in the first method we still have to check the entire set of substrings for that L if there's no duplicate. The second method does the same.\n\n But the second method avoids an extra variable (the flag) and the condition after the inner loop.\n\n However, the first method is easier to read for beginners.\n\n Let me submit the flag method.\n\n But wait, there is a caveat: the set `seen` is built for each L. We could break the outer loop early, so we don't build sets for all L's. But the flag method is clear.\n\n I'll submit the flag method.\n\n However, note: the problem says the string length is at most 100, so building sets for each L (from n-1 down to 1) is acceptable.\n\n But we can also try to use a different approach: \n   Instead of iterating from the largest L, we can use a dictionary to store all substrings for each length and then check from large L to small. But the above method is straightforward.\n\n One more optimization: we can avoid building the set for a given L by checking if there are at least two occurrences. But the set method is natural.\n\n Alternatively, we can use a dictionary to count the frequency of substrings for a fixed L, but that would be similar.\n\n Given the constraints, we stick to the above.\n\n However, note: we are breaking the inner loop as soon as we find a duplicate, so we don't have to check all substrings for that L.\n\n But we are building the set until we find a duplicate.\n\n This is efficient.\n\n Let me run the code for the worst-case: a string of 100 distinct characters? Then we won't find any duplicate until L=1. \n\n   For L=99: 2 substrings, distinct -> build set with two elements and then check next L=98: 3 substrings, distinct -> ... until L=1.\n\n   The total number of substrings we check is: \n        L=99: 2\n        L=98: 3\n        L=97: 4\n        ...\n        L=1: 100\n\n   Total operations: 2+3+...+100 = (100*101)//2 - 1 = 5050, and each substring of length L (from 1 to 99) so the total operations is sum_{L=1}^{99} (n-L+1)*L = ?\n\n   But note: n=100, so for L=99: 2*99 = 198 comparisons (each substring comparison is O(L)).\n\n   Actually, the cost of each substring extraction and comparison is O(L). \n\n   The total cost is: for each L from 1 to 99, we do (100-L+1) * (cost of extracting substring and comparing, which is O(L))\n\n   The total cost is: sum_{L=1}^{99} (100-L+1) * L = sum_{L=1}^{99} (101 - L) * L = sum_{L=1}^{99} (101L - L^2)\n\n   This is 101 * (99*100//2) - (sum of squares from 1 to 99) = 101 * 4950 - (99*100*199)//6\n\n   Without exact calculation, but n=100 is small, and the maximum value of L is 99, so the worst-case total operations is about 100*100*100 = 1e6, which is acceptable.\n\n Therefore, we can use the above code.\n\n Let me write the final code.\n\n However, note: the problem says the string is non-empty and consists of lower-case Latin letters.\n\n We are reading the string with strip() to remove any extraneous whitespace.\n\n But the problem says the first input line contains the string, so we can use:\n\n   s = input().strip()\n\n But what if the string has leading/trailing spaces? The problem says non-empty and lower-case Latin letters, so we assume no spaces. But to be safe, we use strip.\n\n Alternatively, we can use:\n\n   s = input().strip()\n\n But note: the problem says the string is given on the first input line. It might have spaces? The problem says \"lower-case Latin letters\", so no spaces. But the problem does not specify if there are spaces. \n\n However, the example inputs are given without spaces.\n\n Since the problem says the string is non-empty and consists of lower-case Latin letters, we can assume no spaces. But using strip is safe.\n\n Final code:\n\n   s = input().strip()\n   n = len(s)\n   if n == 0:\n        print(0)\n        exit(0)\n\n   ans = 0\n   # We consider L from n-1 down to 1.\n   for L in range(n-1, 0, -1):\n        seen = set()\n        duplicate_found = False\n        # Iterate over all starting indices for substring of length L\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                duplicate_found = True\n                break\n            seen.add(substr)\n        if duplicate_found:\n            ans = L\n            break\n\n   print(ans)\n\n But wait, what if the string is empty? The problem says non-empty, so n>=1. But we have the condition n==0, but the problem says non-empty, so we can remove that.\n\n Alternatively, we can assume n>=1.\n\n We'll remove the n==0 check.\n\n Final code:\n\n   s = input().strip()\n   n = len(s)\n   ans = 0\n   for L in range(n-1, 0, -1):\n        seen = set()\n        duplicate_found = False\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                duplicate_found = True\n                break\n            seen.add(substr)\n        if duplicate_found:\n            ans = L\n            break\n\n   print(ans)\n\n Let me test with a few examples.\n\n Example: \"a\" -> n=1, so the range is from 0 to 0 (exclusive of 0) -> no loop -> prints 0.\n\n Example: \"aa\" -> n=2, L from 1 to 1 (inclusive). \n        L=1: \n            i=0: 'a' -> add\n            i=1: 'a' -> duplicate -> ans=1, break -> output 1.\n\n Example: \"aaa\" -> n=3, L from 2 to 1.\n        L=2: \n            i0: \"aa\" -> add\n            i1: \"aa\" -> duplicate -> output 2.\n\n Example: \"ab\" -> n=2, L=1: \n        i0: 'a' -> add\n        i1: 'b' -> no duplicate -> output 0.\n\n Example: \"aba\" -> n=3, L=2: \n        i0: \"ab\" -> add\n        i1: \"ba\" -> add -> no duplicate for L=2.\n        Then",
    "response": "\nTo solve this problem, we need to find the length of the longest substring that appears at least twice in a given string. The occurrences can overlap, and the solution should efficiently handle all edge cases.\n\n### Approach\n1. **Problem Analysis**: The task is to identify the longest contiguous substring within a given string that appears at least twice. The substrings can overlap, which means we need to check all possible substrings of each possible length from the largest to the smallest until we find a duplicate.\n2. **Intuition**: The solution involves checking all possible substrings of decreasing lengths. For each length, we generate all substrings of that length and use a set to track seen substrings. If a substring is encountered more than once, we immediately return its length as the result since we are checking from the largest to the smallest length.\n3. **Algorithm Selection**: The algorithm iterates over possible substring lengths from the maximum possible (n-1) down to 1. For each length, it checks all starting positions in the string. If a substring of the current length is found in the set of previously seen substrings, the length is recorded as the answer, and the loop terminates early.\n4. **Complexity Analysis**: The worst-case time complexity is O(n^3) due to nested loops (iterating over lengths and starting positions, and comparing substrings). However, given the constraint that the string length does not exceed 100, this approach is efficient enough for the problem constraints.\n\n### Solution Code\n```python\ns = input().strip()\nn = len(s)\nans = 0\nfor L in range(n-1, 0, -1):\n    seen = set()\n    duplicate_found = False\n    for i in range(0, n - L + 1):\n        substr = s[i:i+L]\n        if substr in seen:\n            duplicate_found = True\n            break\n        seen.add(substr)\n    if duplicate_found:\n        ans = L\n        break\nprint(ans)\n```\n\n### Explanation\n1. **Reading Input**: The input string is read and stripped of any leading or trailing whitespace.\n2. **Initialization**: The variable `ans` is initialized to 0, which will store the length of the longest duplicate substring found.\n3. **Iterating Over Lengths**: The outer loop runs from the largest possible substring length (n-1) down to 1. For each length `L`, it initializes a set `seen` to keep track of substrings encountered.\n4. **Checking Substrings**: The inner loop generates all substrings of length `L` starting from each position in the string. Each substring is checked against the set `seen`. If a substring is found in the set, it means there is a duplicate, and the loop breaks early.\n5. **Updating Answer**: If a duplicate is found during the inner loop, the current length `L` is stored in `ans`, and the outer loop terminates immediately since we are checking from the largest to the smallest length.\n6. **Output Result**: After processing all possible lengths, the value of `ans` is printed, which is the length of the longest substring appearing at least twice, or 0 if no such substring exists.\n\nThis approach efficiently checks for the longest repeating substring by leveraging early termination upon finding a valid candidate, ensuring optimal performance for the given problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "s = input().strip()\nn = len(s)\nans = 0\nfor L in range(n-1, 0, -1):\n    seen = set()\n    duplicate_found = False\n    for i in range(0, n - L + 1):\n        substr = s[i:i+L]\n        if substr in seen:\n            duplicate_found = True\n            break\n        seen.add(substr)\n    if duplicate_found:\n        ans = L\n        break\nprint(ans)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 227,
        "completion_token_count": 695,
        "thoughts_token_count": 8191
    }
}