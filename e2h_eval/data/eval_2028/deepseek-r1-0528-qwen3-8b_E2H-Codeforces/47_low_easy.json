{
    "start": 1758296452.366839,
    "end": 1758299396.3253036,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (with 1 <= a,b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b (if a < b then d is negative, but we can assume without loss of generality that we set x = a+k and y = b+k, then note that x-y = a-b is fixed).\n\nWe have: \n  Let g = gcd(a+k, b+k) = gcd(a+k, |a-b|)   [since gcd(x,y)=gcd(x,y-x)]\n\nThen, LCM(a+k, b+k) = (a+k)*(b+k) / g.\n\nNote: Without loss of generality, we can assume that we are looking for k such that a+k and b+k are positive (which they are for k>=0).\n\nObservation:\n  The difference between (a+k) and (b+k) is fixed: d = a-b (which is constant). So we can write:\n      x = a+k, y = b+k, then x - y = a-b.\n\nBut note: if a==b, then we have to consider the case separately.\n\nHowever, note that when a==b, then we are trying to minimize LCM(a+k, a+k) = a+k. Since k>=0, the minimum is achieved at k=0.\n\nBut what if a != b?\nLet d = |a-b|. Then note that the gcd of (a+k) and (b+k) must divide d. Therefore, the gcd must be a divisor of d.\n\nSo the problem reduces to: \n  For each divisor g of d (where d = |a-b|), we can set:\n      a+k ≡ 0 (mod g)   => k ≡ (-a) mod g, but note: we require k >=0 and the smallest k for this modulus condition is k0 = (g - a % g) % g? Actually, we want k such that (a+k) is divisible by g, so k = (g - a % g) % g, but if a % g ==0 then k=0.\n\nBut wait: also note that the condition is on both numbers: (a+k) % g == 0 and (b+k) % g == 0. But since (a+k) - (b+k) = a-b, which is divisible by g (because g divides d and d=a-b), then if one is divisible by g then the other is too? Actually, no: we require both to be divisible by g? Actually, the gcd condition is that g divides both. But note: if g divides d and g divides a+k, then g divides (a+k) - (b+k) = d, and then automatically g divides b+k? Not necessarily: because if g divides a+k and g divides d, then it divides (a+k) - d = b+k? Actually, yes: because d = a-b, so a+k - d = (a+k) - (a-b) = k+b, but wait, that is not the same as b+k. Actually, note:\n\n  d = a-b, so a = b+d. Then if g divides d and g divides a+k, then a+k = b+d+k, and since g divides d and a+k, then g divides (a+k) - d = (b+d+k) - d = b+k.\n\nSo yes, if g divides d and g divides a+k, then it automatically divides b+k.\n\nTherefore, for each divisor g of |a-b| (if a != b), we can set k0 = the smallest non-negative integer such that (a+k0) mod g == 0. That k0 is: k0 = (g - (a % g)) % g, but note: if a % g ==0 then k0=0, else k0 = g - (a % g).\n\nBut note: there's another way to think: the condition is that k ≡ (-a) mod g. However, note that we are free to choose any divisor g (as long as g divides d). Then, for each divisor g, we get a candidate k = k0 (the smallest non-negative k satisfying the condition). Then, we compute the LCM for (a+k0) and (b+k0) (which is (a+k0)*(b+k0)//g) and then choose the k that minimizes the LCM. If two k give the same LCM, choose the smallest k.\n\nBut wait: what if d=0 (i.e., a=b)? Then we don't have divisors from |a-b|, but we know the answer is 0.\n\n",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant (\\( a - b \\)). The greatest common divisor (gcd) of \\( a+k \\) and \\( b+k \\) must be a divisor of this constant difference. Therefore, for each divisor \\( g \\) of \\( |a - b| \\), we can determine a candidate \\( k \\) that makes both numbers divisible by \\( g \\). \n\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the minimal LCM is achieved when \\( k = 0 \\) because the LCM of two identical numbers is the number itself.\n\n3. **Candidate Generation**: For each divisor \\( g \\) of \\( |a - b| \\), compute the smallest non-negative \\( k \\) such that \\( g \\) divides \\( a + k \\). This \\( k \\) is derived from the congruence \\( k \\equiv (-a) \\mod g \\).\n\n4. **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\) using the formula \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{gcd}(x, y)} \\). Track the \\( k \\) that results in the smallest LCM.\n\n5. **Edge Cases**: Handle cases where \\( a \\) and \\( b \\) are equal separately, and ensure all divisors of \\( |a - b| \\) are considered, including negative divisors (though absolute value ensures uniqueness).\n\n### Solution Code\n```python\nimport math\nfrom math import gcd as math_gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    candidates = []\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k = 0\n        else:\n            k = g - remainder\n        candidates.append(k)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        current_gcd = math_gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The program reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Check**: If \\( a \\) and \\( b \\) are equal, it immediately prints \\( 0 \\) since the minimal LCM is achieved at \\( k = 0 \\).\n3. **Divisor Calculation**: For the difference \\( d = |a - b| \\), all divisors are computed and stored in a set to avoid duplicates.\n4. **Candidate Generation**: For each divisor \\( g \\), the smallest non-negative \\( k \\) is calculated such that \\( g \\) divides \\( a + k \\). This \\( k \\) ensures that both \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\).\n5. **LCM Evaluation**: For each candidate \\( k \\), the LCM of \\( a + k \\) and \\( b + k \\) is computed. The \\( k \\) resulting in the smallest LCM is selected, with ties broken by choosing the smallest \\( k \\).\n6. **Output**: The optimal \\( k \\) is printed.\n\nThis approach efficiently narrows down potential candidates by leveraging mathematical properties of divisors and gcd, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd as math_gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    candidates = []\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k = 0\n        else:\n            k = g - remainder\n        candidates.append(k)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        current_gcd = math_gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 976,
        "thoughts_token_count": 1023
    }
}