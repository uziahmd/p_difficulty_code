{
    "start": 1758296429.8282363,
    "end": 1758299378.0762935,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (with 1 <= a,b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\n Note: We can assume without loss of generality that a != b. If a == b, then we are looking for k such that LCM(a+k, a+k) = a+k is minimized. The smallest k would be 0.\n\n However, note that when a == b, then k=0 gives LCM(a, a)=a, but if we take k>0 then the numbers become larger. So k=0 is the answer.\n\n But the problem is more complicated when a != b.\n\n Observation:\n Let d = gcd(a+k, b+k). Then note that d divides (a+k) and (b+k), so it also divides (a+k) - (b+k) = a-b (if a>=b, else negative, but absolute value). Therefore, d must divide |a-b|.\n\n Moreover, note that:\n   LCM(a+k, b+k) = (a+k)*(b+k) / gcd(a+k, b+k)\n\n We want to minimize this.\n\n Alternate approach:\n\n Consider g = gcd(a+k, b+k). Then g divides (a-b) (assuming a>=b, then g divides a-b). Also, we can write:\n   Let t = a+k, then b+k = t + (b-a) [if a>=b, then we can think of shifting].\n\n Actually, let’s set d0 = |a-b|. Then any common divisor of (a+k) and (b+k) must divide d0.\n\n Also, note that:\n   gcd(a+k, b+k) = gcd(a+k, |a-b|)\n\n So, if we let g = gcd(a+k, |a-b|), then the LCM is (a+k)*(b+k)/g.\n\n How can we minimize the LCM? Since (a+k)*(b+k) = (max(a,b)+k)^2 - (max(a,b)-min(a,b))^2, which is increasing with k, but wait: actually the product is not necessarily increasing because we are adding k to both. However, note that the product is quadratic in k and thus grows without bound as k increases. But the denominator g might change and sometimes a larger k might lead to a larger divisor and hence a smaller LCM.\n\n However, note that the LCM is (a+k)*(b+k)/gcd(a+k, b+k). The key is that the gcd can only take divisors of |a-b|.\n\n Therefore, we can consider the divisors of |a-b|. Let d be a divisor of |a-b| (including negative? no, positive divisors). Then we require that g = d (or a divisor of d) but actually we are constrained by the condition that d must divide |a-b|.\n\n However, note: the gcd must divide |a-b|, so the gcd is one of the divisors of |a-b|.\n\n Now, we can try to set the gcd to be a divisor d of |a-b|. Then we require that d divides (a+k) and (b+k). But note that (a+k) mod d = (a mod d + k mod d) mod d. We require that (a+k) mod d = 0 and (b+k) mod d = 0. This is equivalent to requiring that k ≡ (-a) mod d and k ≡ (-b) mod d. Since d divides (a-b), then -a ≡ -b mod d, so these two congruences are consistent.\n\n Therefore, for a divisor d (positive) of |a-b|, the smallest non-negative k that satisfies k ≡ (-a) mod d is k0 = (-a) mod d? Actually, we want the smallest k>=0 such that k ≡ (-a) mod d. That is k0 = (d - a % d) % d. But note: if a % d == 0, then k0=0.\n\n However, note: there are many divisors. But |a-b| can be up to 10^9, so we cannot iterate over all divisors if we do it naively? Actually, the number of divisors is O(sqrt(|a-b|)), which is acceptable because |a-b| is at most 10^9, so sqrt(10^9) is about 31622, which is acceptable.\n\n Steps:\n\n 1. If a == b, then we return 0.\n\n 2. Otherwise, let D = |a-b|.\n\n 3. Find all divisors of D. Note: we consider positive divisors.\n\n 4",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must divide the absolute difference between \\( a \\) and \\( b \\). This is because \\( \\text{GCD}(a + k, b + k) = \\text{GCD}(a + k, |a - b|) \\). Therefore, any common divisor of \\( a + k \\) and \\( b + k \\) must be a divisor of \\( |a - b| \\).\n\n2. **Intuition**: For each divisor \\( d \\) of \\( |a - b| \\), we can determine the smallest \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are divisible by \\( d \\). This \\( k \\) is given by \\( k = (-a) \\mod d \\) (adjusted to be non-negative). \n\n3. **Algorithm Selection**: We generate all positive divisors of \\( |a - b| \\). For each divisor \\( d \\), compute the corresponding \\( k \\) that makes both \\( a + k \\) and \\( b + k \\) divisible by \\( d \\). Then, for each such \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\). The smallest \\( k \\) yielding the minimal LCM is our answer.\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{|a - b|}) \\). Given that \\( |a - b| \\) can be up to \\( 10^9 \\), the maximum number of divisors is around 1000, making this approach efficient.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return sorted(divisors)\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    n = abs(a - b)\n    divisors_list = get_divisors(n)\n    best_k = 0\n    best_lcm = (a + best_k) * (b + best_k) // gcd(a + best_k, b + best_k)\n    \n    for d in divisors_list:\n        k = (-a) % d\n        candidate_a = a + k\n        candidate_b = b + k\n        current_lcm = candidate_a * candidate_b // gcd(candidate_a, candidate_b)\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The program reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the answer is immediately \\( 0 \\) since the LCM of two identical numbers is the number itself, and increasing \\( k \\) would only make the numbers larger.\n3. **Divisor Calculation**: For the absolute difference \\( n = |a - b| \\), all positive divisors are computed. These divisors are potential candidates for the GCD of \\( a + k \\) and \\( b + k \\).\n4. **Finding Optimal \\( k \\)**: For each divisor \\( d \\), the corresponding \\( k \\) is calculated as \\( (-a) \\mod d \\). The LCM of \\( a + k \\) and \\( b + k \\) is then computed. The smallest \\( k \\) that results in the minimal LCM is tracked and printed.\n5. **Output**: The optimal \\( k \\) is printed, ensuring the LCM of \\( a + k \\) and \\( b + k \\) is minimized, with the smallest \\( k \\) chosen in case of ties. \n\nThis approach efficiently narrows down the problem to checking divisors of the absolute difference between \\( a \\) and \\( b \\), leveraging mathematical properties to minimize the LCM without exhaustive search.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return sorted(divisors)\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    n = abs(a - b)\n    divisors_list = get_divisors(n)\n    best_k = 0\n    best_lcm = (a + best_k) * (b + best_k) // gcd(a + best_k, b + best_k)\n    \n    for d in divisors_list:\n        k = (-a) % d\n        candidate_a = a + k\n        candidate_b = b + k\n        current_lcm = candidate_a * candidate_b // gcd(candidate_a, candidate_b)\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 388,
        "completion_token_count": 1008,
        "thoughts_token_count": 1023
    }
}