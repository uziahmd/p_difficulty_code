{
    "start": 1758294373.121054,
    "end": 1758296452.749768,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:40 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given up to 10 spaceships and 10 bases. We need to check if there is a perfect matching (i.e., a bijection) between the R spaceships and B bases such that the straight line segments connecting each spaceship to its base do not intersect.\n\n Since R and B are at most 10, we can consider using a bipartite matching algorithm (like the Hungarian algorithm) but with an additional condition: the non-intersection of the segments.\n\n However, note that the problem does not require the entire set of segments to be non-intersecting? Actually, the problem states: \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\".\n\n Important: The condition is that no two segments (from any base to its assigned spaceship) should intersect. This is a geometric condition.\n\n Steps:\n\n 1. Read input: first line has R and B, then R lines for spaceships, then B lines for bases.\n\n 2. We have two sets of points: \n    - Spaceships: S = [s1, s2, ..., sR]\n    - Bases: Bases = [b1, b2, ..., bB]\n\n 3. We are to assign each spaceship to exactly one base and vice versa, so we require a matching of size min(R, B) and actually we need a perfect matching (so R == B? Actually, the problem says: \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so we require R == B. But note the input constraints: 1<=R,B<=10, and the example has R=3, B=3.\n\n However, the problem does not explicitly say that R must equal B, but the assignment is perfect: every base gets one and every spaceship gets one. Therefore, we must have R = B. But wait, the input might have R != B? The problem says: \"assign R Rebel spaceships to guard B bases\" and then \"every base has exactly one guardian and each spaceship has exactly one assigned base\". So this implies R = B. \n\n But the problem does not specify that R must equal B. Let me read again: \"the assignment is a perfect matching\". Perfect matching in a bipartite graph requires the two partitions to have the same size. So we must have R = B.\n\n However, the example input: \n   First example: \"3 3 ...\" -> R=3, B=3.\n   Second example: \"2 1 ...\" -> R=2, B=1.\n\n Wait, the second example output is 'No'. But according to the problem statement, we are to assign R spaceships to B bases such that every base has one and each spaceship has one. That is only possible if R == B. Therefore, if R != B, then it's impossible.\n\n But the problem says: \"The following is a competitive programming problem.\" and the example input has two cases: one with (3,3) and one with (2,1). So we must handle the case when R != B: then output No.\n\n However, note the problem statement: \"if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base\". This is a perfect matching, which requires |R| = |B|. So if R != B, we immediately output \"No\".\n\n But wait: what if we have more bases than spaceships? Then we cannot assign each base to a unique spaceship. Similarly, if we have more spaceships than bases, we cannot assign each spaceship to a unique base. Therefore, the condition for even having a perfect matching is R == B.\n\n However, note: the problem does not require to use all spaceships or all bases? It says: \"assign R Rebel spaceships to guard B bases\" meaning we are going to use all R and all B? Then yes, we require R == B.\n\n So step 0: if R != B, output \"No\".\n\n But wait, the example input: \n   Input: \"2 1\\n1 0\\n2 2\\n3 1\"\n   Output: \"No\"\n\n Here, R=2, B=1 -> not equal, so we output \"No\". Correct.\n\n Now, if R == B, then we have to check if there exists a perfect matching (a bijection) such that the straight line segments connecting each spaceship to its base do not intersect.\n\n However, note: the problem does not require the entire set of segments to be non-intersecting? Actually, the problem states: \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\". This means that two segments (from different pairs) should not cross.\n\n How to check for non-intersection?\n\n We have a set of segments: from spaceship i to base j. We want that for two distinct",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking two main conditions: whether the number of spaceships equals the number of bases, and if so, whether a valid matching exists where no segments intersect.\n\n### Approach\n1. **Check for Perfect Matching Condition**: The first step is to verify if the number of spaceships (R) equals the number of bases (B). If they are not equal, it's impossible to form a perfect matching, and the answer is immediately \"No\".\n2. **Geometric Matching Check**: If R equals B, we proceed to check all possible permutations of assigning each spaceship to a base. For each permutation, we check if the segments connecting each spaceship to its assigned base do not intersect with any other segment. This involves using geometric algorithms to determine segment intersections.\n3. **Efficient Checking**: Given the constraints (R and B up to 10), we can afford to check all permutations (factorial time) since 10! is manageable (3,628,800 permutations). For each permutation, we use the standard method to check if two line segments intersect by verifying the orientation of points relative to each other.\n\n### Solution Code\n```python\nimport itertools\n\ndef orientation(a, b, c):\n    val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n        \n    if o1 == 0 and on_segment(a, b, c):\n        return True\n    if o2 == 0 and on_segment(a, b, d):\n        return True\n    if o3 == 0 and on_segment(c, d, a):\n        return True\n    if o4 == 0 and on_segment(c, d, b):\n        return True\n        \n    return False\n\ndef on_segment(a, b, c):\n    if min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1]):\n        return True\n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    idx = 0\n    R = int(data[idx]); B = int(data[idx+1]); idx += 2\n    spaceships = []\n    for _ in range(R):\n        x = int(data[idx]); y = int(data[idx+1]); idx += 2\n        spaceships.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(data[idx]); y = int(data[idx+1]); idx += 2\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    if R == 0:\n        print(\"Yes\")\n        return\n        \n    found = False\n    for perm in itertools.permutations(range(B)):\n        valid = True\n        for i in range(R):\n            s = spaceships[i]\n            b1 = bases[perm[i]]\n            for j in range(i + 1, R):\n                s2 = spaceships[j]\n                b2 = bases[perm[j]]\n                if do_segments_intersect(s, b1, s2, b2):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into lists of spaceship and base coordinates.\n2. **Perfect Matching Check**: If the number of spaceships does not match the number of bases, the answer is \"No\".\n3. **Permutation Check**: For each permutation of base assignments, the code checks if the segments connecting each spaceship to its assigned base intersect with any other segment. This is done using the `do_segments_intersect` function, which relies on the `orientation` and `on_segment` helper functions to determine if segments cross or touch.\n4. **Output Result**: If any valid permutation is found where all segments do not intersect, the answer is \"Yes\"; otherwise, it's \"No\".\n\nThis approach efficiently checks all possible assignments by leveraging permutation generation and geometric intersection checks, ensuring correctness within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef orientation(a, b, c):\n    val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n        \n    if o1 == 0 and on_segment(a, b, c):\n        return True\n    if o2 == 0 and on_segment(a, b, d):\n        return True\n    if o3 == 0 and on_segment(c, d, a):\n        return True\n    if o4 == 0 and on_segment(c, d, b):\n        return True\n        \n    return False\n\ndef on_segment(a, b, c):\n    if min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1]):\n        return True\n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    idx = 0\n    R = int(data[idx]); B = int(data[idx+1]); idx += 2\n    spaceships = []\n    for _ in range(R):\n        x = int(data[idx]); y = int(data[idx+1]); idx += 2\n        spaceships.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(data[idx]); y = int(data[idx+1]); idx += 2\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    if R == 0:\n        print(\"Yes\")\n        return\n        \n    found = False\n    for perm in itertools.permutations(range(B)):\n        valid = True\n        for i in range(R):\n            s = spaceships[i]\n            b1 = bases[perm[i]]\n            for j in range(i + 1, R):\n                s2 = spaceships[j]\n                b2 = bases[perm[j]]\n                if do_segments_intersect(s, b1, s2, b2):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 471,
        "completion_token_count": 1067,
        "thoughts_token_count": 1023
    }
}