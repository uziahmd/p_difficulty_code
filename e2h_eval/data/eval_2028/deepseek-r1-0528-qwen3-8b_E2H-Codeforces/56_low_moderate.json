{
    "start": 1758294366.9073267,
    "end": 1758296022.1576056,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:33 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given up to 10 spaceships and 10 bases. We need to check if there exists a perfect matching (i.e., a bijection) between the R spaceships and B bases such that the straight line segments connecting each spaceship to its base do not intersect.\n\n Since R and B are at most 10, we can consider using a combinatorial matching approach. However, note that the condition of non-intersecting paths is geometric.\n\n Steps:\n 1. We have two sets: \n    - S: spaceships (size R)\n    - Bases: bases (size B)\n\n 2. We are to assign each spaceship to a base such that the entire set of segments does not intersect.\n\n Observation:\n The problem is equivalent to: \n   Is there a perfect matching (if R=B) or a matching from the larger set to the smaller? But note: the problem states that every base has exactly one guardian and each spaceship has exactly one assigned base, so we require a bijection. Therefore, we must have R = B.\n\n However, note the example input: the first example has R=3, B=3. The second example has R=2, B=1. But wait, the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\" -> so we must have R = B. \n\n But wait, the second example input is: \n   \"2 1\\n1 0\\n2 2\\n3 1\"\n This means R=2, B=1. Then it's impossible to have a perfect matching (since we need two bases for two spaceships, but only one base). So the example output is 'No'.\n\n Therefore, first check: if R != B, then output 'No'. However, note the problem statement: \"assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base\". This requires R = B.\n\n But wait, the problem does not explicitly say that R must equal B? It says \"perfect matching\", which in bipartite matching requires the two sets to have the same size. So we can assume that if R != B, then no matching exists.\n\n However, the problem also says: \"each spaceship has exactly one assigned base\" and \"every base has exactly one guardian\". So indeed, the sets must be of equal size.\n\n Approach:\n\n Since the numbers are small (at most 10), we can try to use bipartite matching with a twist: the edges in the bipartite graph are only allowed if the segment from the spaceship to the base does not intersect any other segment.\n\n But note: the condition is that the entire set of segments must be non-intersecting. This is a global condition. \n\n However, note: we are to assign all spaceships to all bases (if R=B) and the assignment must yield non-intersecting segments.\n\n Important: Two segments AB and CD (where A is a spaceship, B is a base, C is a spaceship, D is a base) should not intersect. But note: the problem says \"any two (straight) paths\" meaning the segments connecting the matched pairs.\n\n How to check if two segments (from different pairs) intersect?\n\n We have two segments: one from (x1,y1) to (x2,y2) and another from (x3,y3) to (x4,y4). They should not share an endpoint (because no three points are colinear and no two coincide, and also we are matching distinct points). So we can use the standard segment intersection algorithm.\n\n However, note: the matching condition is that the entire set of segments must be non-intersecting. This is a property of the entire drawing.\n\n But observe: if we have a set of non-intersecting segments, then the drawing is planar. However, the problem does not require the entire drawing to be planar in the abstract sense because we are fixing the endpoints (which are given).\n\n We can use the following idea:\n\n 1. Check if R == B. If not, output 'No'.\n 2. Consider the bipartite graph where left side is spaceships and right side is bases. We can connect a spaceship to a base if the segment between them does not cross any other segment in the final matching? But wait, we don't know the entire matching.\n\n Alternatively, note: the condition of non-intersecting segments is equivalent to the matching being non-crossing.\n\n We can use the following: \n\n   We are to find a non-crossing perfect matching between two sets of points (spaceships and bases) in the plane.\n\n There is a known fact: non-crossing matchings in the plane can be found by considering the two sets as two interleaved sets on a convex curve (like circles). However, we have two sets that are not necessarily interleaved arbitrarily.\n\n Another idea: sort the spaceships and bases by",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking for a bipartite matching where the geometric condition of non-intersecting segments is satisfied.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijection) between two sets of points (spaceships and bases) such that no two connecting segments intersect. Given the constraints (R and B are at most 10), a brute-force approach is feasible.\n2. **Key Insight**: For any two segments to not intersect, they must not cross each other. This can be checked using standard geometric algorithms that determine if two line segments intersect.\n3. **Algorithm Selection**: \n   - **Bipartite Matching**: We use a recursive backtracking approach to explore all possible matchings between spaceships and bases.\n   - **Segment Intersection Check**: For each potential segment in the current matching, we check if it intersects with any already placed segment. If it does, the matching is invalid.\n4. **Complexity Analysis**: With R and B up to 10, the number of permutations to check is manageable (factorial in the size of R and B). The intersection checks are constant time per pair, making the overall complexity feasible for the given constraints.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    if r != b:\n        print(\"No\")\n        return\n        \n    spaceships = []\n    index = 2\n    for _ in range(r):\n        x = float(data[index])\n        y = float(data[index+1])\n        index += 2\n        spaceships.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = float(data[index])\n        y = float(data[index+1])\n        index += 2\n        bases.append((x, y))\n        \n    def ccw(A, B, C):\n        return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])\n    \n    def do_intersect(seg1, seg2):\n        A, B = seg1\n        C, D = seg2\n        return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n    \n    def backtrack(idx, current_matching, used_spaceships, used_bases):\n        if idx == len(spaceships):\n            print(\"Yes\")\n            exit(0)\n            \n        for i in range(len(bases)):\n            if used_bases[i]:\n                continue\n            valid = True\n            for j in range(len(current_matching)):\n                s_idx = list(current_matching.keys())[j]\n                base_idx = current_matching[s_idx]\n                seg1 = (spaceships[s_idx], bases[base_idx])\n                seg2 = (spaceships[idx], bases[i])\n                if do_intersect(seg1, seg2):\n                    valid = False\n                    break\n                    \n            if valid:\n                used_bases[i] = True\n                current_matching[idx] = i\n                backtrack(idx + 1, current_matching, used_spaceships, used_bases)\n                del current_matching[idx]\n                used_bases[i] = False\n                \n    used_bases = [False] * len(bases)\n    current_matching = {}\n    backtrack(0, current_matching, [False] * len(spaceships), used_bases)\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of spaceships (R) and bases (B). If R ≠ B, the answer is immediately \"No\".\n2. **Geometric Functions**: \n   - `ccw` (Counter-Clockwise): Determines the orientation of three points.\n   - `do_intersect`: Checks if two line segments intersect using the `ccw` function.\n3. **Backtracking**: The algorithm recursively tries to assign each spaceship to a base, ensuring no segments intersect. If all spaceships are matched without any intersections, it prints \"Yes\" and exits; otherwise, after exhausting all possibilities, it prints \"No\".\n\nThis approach efficiently explores all possible matchings while leveraging geometric checks to ensure the solution meets the problem's constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    if r != b:\n        print(\"No\")\n        return\n        \n    spaceships = []\n    index = 2\n    for _ in range(r):\n        x = float(data[index])\n        y = float(data[index+1])\n        index += 2\n        spaceships.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = float(data[index])\n        y = float(data[index+1])\n        index += 2\n        bases.append((x, y))\n        \n    def ccw(A, B, C):\n        return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])\n    \n    def do_intersect(seg1, seg2):\n        A, B = seg1\n        C, D = seg2\n        return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n    \n    def backtrack(idx, current_matching, used_spaceships, used_bases):\n        if idx == len(spaceships):\n            print(\"Yes\")\n            exit(0)\n            \n        for i in range(len(bases)):\n            if used_bases[i]:\n                continue\n            valid = True\n            for j in range(len(current_matching)):\n                s_idx = list(current_matching.keys())[j]\n                base_idx = current_matching[s_idx]\n                seg1 = (spaceships[s_idx], bases[base_idx])\n                seg2 = (spaceships[idx], bases[i])\n                if do_intersect(seg1, seg2):\n                    valid = False\n                    break\n                    \n            if valid:\n                used_bases[i] = True\n                current_matching[idx] = i\n                backtrack(idx + 1, current_matching, used_spaceships, used_bases)\n                del current_matching[idx]\n                used_bases[i] = False\n                \n    used_bases = [False] * len(bases)\n    current_matching = {}\n    backtrack(0, current_matching, [False] * len(spaceships), used_bases)\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 963,
        "thoughts_token_count": 1023
    }
}