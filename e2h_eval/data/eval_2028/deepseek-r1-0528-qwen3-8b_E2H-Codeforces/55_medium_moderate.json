{
    "start": 1758307805.8918307,
    "end": 1758311388.456849,
    "start-formatted": "2025-09-20 03:50 KST",
    "end-formatted": "2025-09-20 04:49 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. Notice that we cannot swap '0' and '2' directly.\n\n Observation:\n Since we can only swap adjacent 0-1 and 1-2, we cannot change the relative order of 0's and 2's arbitrarily. However, note that 1 acts as an intermediary: \n We can move a 0 through a series of 1's (by swapping 0 and 1) and similarly we can move a 2 through a series of 1's (by swapping 1 and 2). But what about moving 0 and 2 past each other?\n\n Actually, consider: \n - We cannot swap 0 and 2 directly, but we can use 1's to bypass? However, note that if there is a 1 between a 0 and a 2, then we can first move the 0 past the 1 (so the 0 goes to the left of the 1) and then the 2 past the 1 (so the 2 goes to the right of the 1). Then the 0 and 2 are adjacent and cannot be swapped. \n\n But wait, let me think: \n Example: \"012\"\n We can swap the '0' and '1' to get \"102\", then swap the '0' and the '2'? No, because the allowed swaps are only for adjacent 0-1 or 1-2. In \"102\", we have adjacent \"0\" and \"2\", but that is not allowed. So from \"012\", we cannot get \"120\" by these swaps.\n\n Similarly, from \"120\": we can swap the '1' and '2' to get \"210\", then swap the '1' and '0' (if present)? But wait, in \"210\", the adjacent pairs are \"21\" and \"10\". The \"21\" can be swapped to \"12\", so we get \"120\" again. Actually, from \"012\", we can only get strings that have the same relative order of 0's and 2's? \n\n Let me reexamine: \n The operations are:\n   Swap adjacent 0 and 1, and swap adjacent 1 and 2.\n\n This means that the relative order of the zeros and the twos cannot change? Not exactly.\n\n Actually, note that zeros can pass through ones (so zeros can move leftward through ones) and twos can pass through ones (so twos can move rightward through ones). But what if we have a zero and a two separated by ones? \n\n Example: \"012\" -> swap the 0 and 1: \"102\" -> now we cannot swap the 0 and 2 (because they are adjacent and not allowed). But if we have more than one 1, say \"0112\":\n   Start: \"0112\"\n   Step1: swap the first '0' and the first '1': \"1012\"\n   Step2: swap the second '1' and the '0' is now at the front? Actually, we can also move the 0 further to the left by swapping with the next 1: \"1102\"\n   Now, the two is at the end. Can we bring the two forward? \n   Step3: swap the last two (the '2' and the '1')? Actually, from \"1102\": the adjacent pairs are [1,1], [1,0], [0,2] -> we cannot swap the 0 and 2. But note: we can also swap the 1 and 2 when they are adjacent. In \"1102\", the two is adjacent to a 0, so we can't swap. But wait, we can swap the 0 and the 1's? Actually, we can move the 0 backwards? \n\n Alternatively, consider: \n   We can also move the two backwards? Because we can swap the two with the one that is to its left, but only if the two is adjacent to a one. In the initial string \"0112\", we have two ones separating the 0 and the 2. \n\n How do we get the minimal lexicographical string?\n\n Lexicographical minimum: we want the smallest character as early as possible.\n\n What are the possibilities?\n We cannot change the relative order of the zeros and the twos? Actually, note:\n\n Consider: \"02\" -> cannot be swapped. So if we have a zero and then a two, we cannot change that. But if we have a two and then a zero, we cannot swap them either.\n\n However, what about having a one in between? We can use the ones to separate the zeros and twos. \n\n Actually, note: \n   The zeros can only move leftward (because to move a zero to the right, we would have to swap with ones to the left, but swapping 0 and 1 moves the zero to the right? Wait, no: \n   Operation: \n        \"01\" becomes \"10\": so the zero moves to the right.\n        Similarly, \"12\" becomes \"21\": so the two moves to the left.\n\n So zeros can move right (by swapping with ones) and twos can move left (by swapping with ones). \n\n Therefore, we can think of the zeros and twos being able to pass through ones, but zeros and twos cannot pass through each other.\n\n Now, what about the relative order of zeros and twos?\n   Since zeros can only move right and twos can only move left, if a zero is to the left of a two, then they can never cross because any attempt to swap them would require a direct swap (which is disallowed) or going through a one (but zeros can only go right and twos left, so if a zero is to the left of a two, then the zero can move right until it hits the two, but then they are adjacent and cannot swap. Similarly, the two cannot move left past the zero because the swap is disallowed.\n\n Therefore, the relative order of zeros and twos must remain the same as the original.\n\n But wait, what if there are multiple ones? Example: \"012\" has a zero and a two that are separated by a one. We can move the zero to the right until it is adjacent to the one? Then the one can be moved to the right by swapping with the two? Actually, let's break down:\n\n Original: \"012\"\n   Step1: swap the 0 and 1 -> \"102\"\n   Now, the zero is at the front? Actually, no: the zero was originally at index0, then after swapping with the next character (index1) we get:\n        Original: index0='0', index1='1', index2='2'\n        After swapping index0 and index1: index0='1', index1='0', index2='2'\n\n   Now, we cannot swap the '0' and '2' (adjacent) because that swap is disallowed.\n\n   Alternatively, from \"012\", we can try to move the two to the left? \n        Swap the '1' and '2': \"021\" -> now we have a two in the middle. Then we cannot swap the '0' and the two because they are separated by nothing? They are adjacent: \"02\" -> not allowed to swap.\n\n So the conclusion is: the relative order of zeros and twos must be preserved.\n\n But note: what if we have two zeros and two twos? For example, \"001122\" -> can we rearrange the zeros and the twos arbitrarily? \n\n Actually, the zeros can all move to the right (by swapping with ones) and the twos can all move to the left (by swapping with ones). So the zeros will eventually be pushed to the right and the twos to the left, but the zeros and twos that are originally interleaved might change their relative positions.\n\n However, note: we cannot change the relative order of zeros and twos. \n\n So the problem reduces to: \n   We have three types: '0', '1', '2'\n   The relative order of zeros and twos must remain the same as in the original string.\n\n But wait, let's test with two zeros and two twos and some ones in between.\n\n Example: \"02\" -> cannot change.\n Example: \"0022\" -> cannot change because zeros are at the beginning and twos at the end, so they don't interfere. But if we have \"0202\": \n   Original: ['0','2','0','2']\n   We cannot swap the first two because they are '0' and '2' (disallowed). Similarly, the two zeros are separated by a two, so the first zero is stuck until the two moves? But the two can only move left. However, the two is between two zeros. To move the first two (at index1) to the left, we need a one to its left to swap with? There isn't. So we cannot move the two to the left. Similarly, we cannot move the zeros to the right because there is no one to the right to swap with? \n\n Actually, the key is that we can only swap adjacent 0-1 and 1-2. So without ones, we cannot move the zeros or the twos.\n\n Therefore, the presence of ones is necessary for movement.\n\n How do we solve this?\n\n Insight: \n   We can independently consider the movement of zeros and twos through the ones.\n\n   Actually, we can think of the ones as separators. The zeros can only be moved to the right until they hit a two (then they stop) and the twos can only be moved to the left until they hit a zero (then they stop). But note: the zeros and twos can also move past the ones arbitrarily, so we can \"extract\" all zeros and twos from the ones.\n\n   However, note that the relative order of zeros and twos must be the same as the original. So if we have two zeros and two twos, and the original order is [0,0,2,2] then we can push the zeros to the right and the twos to the left to get [0,0,2,2] -> actually, we cannot change the zeros and twos order? \n\n   But wait: the original string is \"0022\", so the zeros are at the beginning and the twos at the end. That's already minimal? \n\n   However, what if the string is \"0202\"? \n        Original: ['0','2','0','2'] -> we cannot change the relative order of zeros and twos. So the zeros that are originally at even indices (0-indexed) must remain in the same relative order as the zeros that are at odd indices? \n\n   Actually, the relative order of zeros must be preserved, and the relative order of twos must be preserved. And the zeros and twos cannot pass each other.\n\n   Therefore, we can separate the zeros and twos by the ones, but the zeros must appear in the same order as in the original, and the twos must appear in the same order as in the original.\n\n   However, note: the zeros and twos are mixed. We can use the ones as buffers to rearrange the zeros and twos independently? \n\n   Actually, we can remove all the ones and then interleave them optimally? \n\n   Alternate approach:\n\n   We note that the operations are reversible and generate a group of permutations. We are allowed to do arbitrary adjacent swaps of 0-1 and 1-2. This means that the positions of zeros, ones, and twos can be rearranged subject to:\n\n   - The zeros can be rearranged arbitrarily among themselves? Actually, no. The relative order of zeros must be preserved. Why? Because swapping zeros with ones doesn't change the relative order of zeros. Similarly, swapping twos with ones doesn't change the relative order of twos.\n\n   Therefore, the zeros must appear in the same relative order as in the original, and the twos must appear in the same relative order as in the original.\n\n   And the ones can be arbitrarily rearranged? Actually, we can swap adjacent 0-1 and 1-2. So a one can be moved arbitrarily by swapping with zeros and twos. Therefore, the ones can be placed arbitrarily.\n\n   Then the problem becomes: we have three independent sequences (zeros, ones, twos) and we can interleave them arbitrarily, but the zeros must appear in the original order, the twos must appear in the original order, and the ones can be placed anywhere. \n\n   But wait, is that true? \n\n   Example: \"010\" -> zeros: [0,0] (but wait, we have two zeros? Actually, the example is \"010\": zeros at index0 and index2, and one at index1.\n\n   We can swap the first two: \"0\" and \"1\" -> \"100\", which gives two zeros together. The relative order of zeros is preserved (the first zero was at the beginning, then the second zero comes after the first). \n\n   Similarly, for twos.\n\n   Therefore, the minimal lexicographical string is achieved by having the zeros as left as possible, then the ones, then the twos? \n\n   But wait, we cannot put a two before a zero if that zero originally came before that two? Because the relative order of zeros and twos must be preserved. \n\n   Actually, we can only put a two before a zero if in the original string that two came before that zero? But wait, the relative order of zeros and twos must be the same as the original. \n\n   Example: Original string \"02\" -> we cannot change, so the zero must come before the two.\n\n   Example: Original string \"20\" -> we cannot change, so the two must come before the zero.\n\n   Therefore, we cannot arbitrarily reorder zeros and twos. We can only reorder zeros and twos relative to the ones, but the zeros that are originally to the left of a two must remain to the left of that two.\n\n   However, note: the entire string is built from the three independent sequences (zeros, ones, twos) and the ones can be inserted arbitrarily. \n\n   How to form the minimal string?\n\n   We know:\n     - The zeros must appear in the original order (relative to each other).\n     - The twos must appear in the original order (relative to each other).\n     - The ones can be placed arbitrarily.\n\n   But note: the zeros and twos cannot pass each other. So the relative order of zeros and twos must be the same as in the original.\n\n   Therefore, we can consider:\n\n   Let A = list of zeros (with their original indices)\n   Let B = list of ones (with their original indices)\n   Let C = list of twos (with their original indices)\n\n   Then, the final string must contain all zeros (in the order of increasing original indices), all ones (in any order? but wait, the ones can be rearranged arbitrarily because they can swap with zeros and twos) and all twos (in the order of increasing original indices).\n\n   However, the catch: the relative order of zeros and twos must be the same as the original. But note: if we have a zero that originally was to the left of a two, then in the final string that zero must appear to the left of that two. Similarly, if a zero was to the right of a two, then that zero must appear to the right of that two.\n\n   But wait: if we have two zeros and two twos, and the original string is \"0202\", then the zeros are at indices0 and index2, and the twos are at indices1 and index3. The first zero is at index0 (which is less than index1, so the first zero is before the first two). The second zero is at index2, which is between the two twos (at index1 and index3). \n\n   How do we arrange the zeros and twos? \n\n   The condition: the relative order of zeros must be preserved: so the zeros must appear in the order: first zero (from index0), then the second zero (from index2). Similarly, the twos must appear in the order: first two (from index1), then the second two (from index3).\n\n   Now, the entire string must be an interleaving of the zeros (in the order of increasing index), the ones (in any order, but we can sort them arbitrarily because we can rearrange them arbitrarily), and the twos (in the order of increasing index). And the constraint: for any zero and any two, if in the original string the zero appeared before the two (i.e., the index of the zero is less than the index of the two) then the zero must appear before the two in the final string. If the zero originally appeared after the two, then the zero must appear after the two.\n\n   How to build the lexicographically smallest string?\n\n   We know that the zeros must appear in the original order (so the earliest zero must be the first zero, then the next, etc.), and the twos must appear in the original order. The ones can be placed arbitrarily.\n\n   However, we cannot break the constraint: for any zero and two, if in the original the zero was at an index i and the two at index j, then if i < j then the zero must come before the two, else the two must come before the zero.\n\n   But note: the original string is fixed. The zeros and twos are fixed. So we can determine for every zero and every two whether the zero originally was before the two or not.\n\n   However, there is a simpler way: \n\n   We can extract the zeros and twos and then merge them with the ones, but respecting the original relative order of zeros and twos.\n\n   Actually, we can think of the entire string as having three independent sets (zeros, ones, twos) and we are allowed to interleave them arbitrarily, except that the zeros must appear in the order of their original indices and the twos must appear in the order of their original indices.\n\n   Then, the minimal lexicographical string is obtained by:\n\n     - Outputting all the zeros (from left to right, i.e., in the order of increasing index) and all the twos (from left to right) but we are allowed to insert ones arbitrarily.\n\n   However, we are not forced to output the zeros first. We can mix zeros, ones, and twos, but we must preserve the relative order of zeros and the relative order of twos.\n\n   And we have the constraint that the relative order of zeros and twos must be the same as in the original.\n\n   But note: the relative order of zeros and twos is fixed by the original string. We can use the following:\n\n   We can assign to each zero and two a \"rank\" (the order in which they appear in the original string) and then in the final string, the zeros must appear in increasing rank and the twos must appear in increasing rank, and for a zero and a two, if the zero's index is less than the two's index then the zero must come before the two, and vice versa.\n\n   This is equivalent to: the entire sequence of zeros and twos (ignoring the ones) must be in the same relative order as in the original.\n\n   Then, we can do:\n\n     Step 1: Collect the zeros and twos and record their original indices and their order.\n\n     Step 2: We are allowed to insert the ones arbitrarily, so we can use the ones to fill gaps and also to allow zeros and twos to be adjacent.\n\n   However, how to combine zeros, ones, and twos to get the lexicographically smallest string?\n\n   Lexicographical order: we want as many '0's as early as possible, then '1's, then '2's? But wait, we cannot put a '0' after a '2' if the original had the '2' before the '0'. \n\n   Actually, the minimal lex string would be:\n\n     We can output all zeros that are available (but we must output them in the original order) and we can output the ones arbitrarily, and the twos arbitrarily (but in the original order). But the constraint: if a zero originally was after a two, then we cannot put that zero before the two.\n\n   Another idea: \n\n   We can consider that the entire set of characters is divided into three independent chains (zeros, ones, twos) and the only constraints are:\n\n     - The zeros must appear in increasing order of their original indices.\n     - The twos must appear in increasing order of their original indices.\n     - For any zero and two, the one that appears earlier in the original must appear earlier in the result.\n\n   This is similar to a problem where we have two increasing sequences (for zeros and twos) and we can interleave them arbitrarily, but with the additional condition that the relative order of zeros and twos is fixed (like a merge of two sorted lists, but the two sorted lists are zeros and twos, and the ones are just free to be placed anywhere).\n\n   However, note: the zeros and twos are not independent: the relative order of zeros and twos is fixed by the original string.\n\n   Actually, we can merge the zeros and twos according to their original order, and then insert the ones arbitrarily. But the catch is: we are allowed to insert ones arbitrarily, so we can put as many ones as we want in between.\n\n   How to get the minimal lex string?\n\n   We want the smallest character as early as possible. The smallest character is '0'. Then '1', then '2'.\n\n   But we must output the zeros in their original order (so we cannot skip a zero that comes later in the original just because we want to put a one earlier). \n\n   Actually, we must output the zeros in the order they appear in the original, but we can delay a zero by putting ones in front of it? No, because we can move zeros to the right arbitrarily (by swapping with ones). Similarly, we can move ones arbitrarily.\n\n   However, note: we cannot change the relative order of zeros and ones arbitrarily? Actually, we can: \n        Example: \"10\" -> swap to \"01\", so the one moves to the right and the zero to the left. Similarly, \"01\" -> \"10\", so the zero moves right and the one left.\n\n   But wait, we can also move zeros to the right (by swapping with ones) and ones to the left (by swapping with zeros). So the zeros and ones can be rearranged arbitrarily? \n\n   However, note: we cannot swap zeros and twos. But we can use ones as intermediaries to effectively swap zeros and twos? \n\n   Actually, we cannot swap zeros and twos, but we can use ones to separate them. \n\n   Let me clarify with an example: \n\n        Original: \"02\"\n        We cannot swap, so the string remains \"02\".\n\n        Original: \"012\"\n        We can swap the 0 and 1 to get \"102\", and then we cannot swap the 0 and 2. So the zeros and twos are still separated by the one? \n\n   But note: we can also swap the 1 and 2 in \"012\": \n        \"012\" -> swap the 1 and 2: \"021\", then we cannot swap the 0 and 2 (adjacent) because that's not allowed.\n\n   So in fact, the zeros and twos cannot be swapped, but they can be separated arbitrarily by ones.\n\n   Therefore, the minimal lex string is achieved by:\n\n        - We can move zeros to the very left (by swapping zeros to the right until they are at the leftmost possible positions, but note: we can also move zeros to the right arbitrarily, so actually we can push zeros to the left? \n\n        Wait, let me think: \n            Operation: swapping 0 and 1 moves the 0 to the right and the 1 to the left.\n            So to move a zero to the left, we need to swap it with a one to its left. \n\n        Example: \"10\" -> swap to \"01\": the zero moves left.\n\n        Similarly, we can move a zero to the left as long as there is a one to its left. \n\n        So we can move zeros to the far left, and we can move twos to the far right.\n\n        Then, the minimal lex string would be:\n\n            All zeros (that are originally present) moved to the far left, then all ones, then all twos.\n\n        But wait: what if there is a two that originally is to the left of a zero? Then we cannot put that zero (which originally was after the two) to the left of the two.\n\n        Example: \"20\" -> we cannot change, so the string must be \"20\", not \"02\".\n\n        So we cannot move zeros arbitrarily to the left if there is a two that originally was before that zero.\n\n        Therefore, we must consider the constraints: the relative order of zeros and twos must be the same as the original.\n\n        How to incorporate the constraint?\n\n        We can split the string into zeros, ones, and twos. Then, we know:\n\n          - The zeros must appear in the order of their original indices (so the zero that appeared first must be the first zero in the result, etc.)\n          - The twos must appear in the order of their original indices.\n\n        And for the entire sequence of non-one characters (zeros and twos), the relative order must be the same as the original.\n\n        Then, the minimal lex string is obtained by:\n\n          We are allowed to insert ones arbitrarily, so we can put ones wherever we want. But we must maintain the relative order of zeros and twos.\n\n        Steps:\n\n          Let Z = list of zeros (each element is (index, '0'))\n          Let O = list of ones (each element is (index, '1'))\n          Let T = list of twos (each element is (index, '2'))\n\n          We want to output a string that is a merge of Z, O, and T, such that:\n\n            - The relative order of Z is preserved.\n            - The relative order of T is preserved.\n            - The relative order of Z and T is the same as in the original (i.e., if a zero is at index i and a two is at index j, then if i < j, the zero must come before the two; if i > j, the two must come before the zero).\n\n          And we want the lexicographically smallest string.\n\n        How to merge?\n\n          We can consider: the entire set of non-one characters (zeros and twos) must be arranged in the order of their original indices. That is, we can create an array of the non-one characters in the order they appear in the original, but then we can insert ones arbitrarily.\n\n        But wait, we can also break up the non-one characters arbitrarily with ones. \n\n        Actually, the constraint is only on the relative order of zeros and twos (and zeros and zeros, twos and twos). The ones can be inserted anywhere.\n\n        So the minimal lex string is:\n\n          We can put as many zeros as possible at the beginning? But we cannot put a zero at the beginning if there is a two that originally was before that zero.\n\n        Example: \"20\" -> we cannot put the zero first.\n\n        Therefore, the algorithm:\n\n          Step 1: Extract the positions of zeros, ones, and twos.\n\n          Step 2: We know that the zeros must appear in the order of increasing index, and the twos must appear in the order of increasing index, and the entire sequence of zeros and twos must be the same as the original (i.e., if we ignore the ones, the zeros and twos must be in the original order).\n\n          Step 3: We can simulate the minimal lex by:\n\n            We are going to output the entire string as a merge of the zeros, ones, and twos, but we have the constraint on the order of zeros and twos.\n\n          How to merge zeros and twos? \n\n            We can create an array D of the non-one characters (each with its type and index) and sort them by index. But that gives the original order.\n\n          Then, we can consider: we want to output the entire string by interleaving the ones arbitrarily. \n\n          The minimal lex string is achieved by:\n\n            We can put all the zeros that are available (without violating the constraint) and then the ones, and then the twos, but wait: we cannot put a zero after a two if in the original the two was before the zero.\n\n          Actually, the constraint is: the entire sequence of zeros and twos must be the same as the original. So we can use a two-pointer for zeros and twos and then insert the ones arbitrarily.\n\n        Alternate solution:\n\n          We can note that the allowed moves are such that the string is equivalent to being able to independently permute the zeros and ones arbitrarily (subject to adjacent swaps) and independently permute the ones and twos arbitrarily, but the zeros and twos are fixed relative to each other.\n\n          Then, the minimal lex string is:\n\n            We can rearrange the zeros and ones arbitrarily (so we can put all zeros at the beginning and then ones) and rearrange the ones and twos arbitrarily (so we can put all ones and then twos). But wait, the constraint: the zeros and twos must be in the original relative order.\n\n          However, if we put all zeros at the beginning and then ones and then twos, then the zeros are all before the twos. But if in the original there was a two before a zero, then this arrangement would break the constraint.\n\n        Therefore, we must output the zeros and twos in the original relative order, and we can insert ones arbitrarily.\n\n        Then, the minimal lex string is:\n\n          We can output the entire sequence of non-one characters (zeros and twos) in the original order, but we are allowed to insert ones arbitrarily. And we want the lexicographically smallest string.\n\n        How to insert ones arbitrarily? \n\n          We can insert ones anywhere. So we can put ones at the beginning, in the middle, or at the end. \n\n        Since the goal is lexicographical minimality, we want to output as many '0's as early as possible, then as many '1's, then as many '2's.\n\n        However, we cannot break the constraint: the zeros must appear in the original order and the twos must appear in the original order, and the relative order of zeros and twos must be the same as the original.\n\n        But note: the entire sequence of non-one characters is fixed (the original order). We can only insert ones.\n\n        Then, the minimal lex string is:\n\n          We have a fixed sequence of non-one characters (say, we mark the positions of zeros and twos in the original string). Then, we can insert ones arbitrarily. \n\n        The lex order: \n\n          We want to put as many zeros as possible at the beginning, but note: the zeros that are available at the beginning are fixed. We cannot change the order of zeros.\n\n        Actually, the entire non-one sequence is fixed. We can only insert ones. \n\n        Example: \"012\"\n\n          Non-one sequence: ['0','2'] (if we remove the one) but wait, the original string is \"012\", so the non-one sequence is ['0','2'].\n\n          Now, we can insert the one arbitrarily. \n\n          Possibilities:\n\n            Insert the one at the beginning: \"102\"\n            Insert the one in the middle: \"012\"\n            Insert the one at the end: \"021\"\n\n          Which is the smallest lex?\n\n            \"012\": \n            \"021\": \n            \"102\":\n\n          Compare:\n            \"012\": starts with '0'\n            \"021\": starts with '0'\n            \"102\": starts with '1'\n\n          Then, between \"012\" and \"021\": \n            First character: both '0'\n            Second character: '1' vs '2' -> so \"012\" is smaller.\n\n          So the minimal is \"012\".\n\n          But wait, we can also not insert the one? The original is \"012\", so one possibility is the original.\n\n          But note: we are allowed to swap adjacent 0-1 and 1-2 arbitrarily. So we can also get \"102\" and \"021\", but we cannot get \"012\" from \"012\" by swapping? Actually, we can leave it as is.\n\n          However, we can also get \"012\" by doing nothing. \n\n          But wait, the problem says we can use the swaps arbitrary number of times. We are allowed to do zero swaps.\n\n          Therefore, we can choose the original string as one possibility, but we can also rearrange.\n\n          However, the minimal lex string is \"012\", which is the original.\n\n          But what if we have \"012\" and we can also get \"102\" and \"021\". We choose the smallest.\n\n          How do we compute the minimal lex string?\n\n          We have a fixed sequence of non-one characters (in the original order). Then, we can insert the ones arbitrarily. \n\n          The entire string is the fixed non-one sequence (without the ones) plus the ones inserted arbitrarily.\n\n          But note: the fixed non-one sequence is the sequence of zeros and twos in the order of the original string, skipping the ones.\n\n          Then, the minimal lex string is simply:\n\n            The entire non-one sequence (zeros and twos) merged with the ones inserted in the optimal positions.\n\n          How to insert the ones? \n\n            We want the smallest lex string. \n\n            We can insert a '1' anywhere. The character '1' is greater than '0' and less than '2'. \n\n            So we want to put the ones as late as possible? Or as early as possible?\n\n            Example: \"0\" and \"2\" with one '1':\n\n                Option1: \"012\"\n                Option2: \"021\"\n                Option3: \"102\"\n\n            We saw that \"012\" is the smallest.\n\n            How did we get \"012\"? We inserted the '1' in the middle.\n\n            But note: we cannot change the relative order of zeros and twos. So the non-one sequence is fixed: first the zero, then the two.\n\n            Then, the ones can be inserted anywhere, but we must not break the non-one sequence.\n\n            The minimal lex string is obtained by:\n\n              We can insert ones arbitrarily, so we can insert ones between zeros and twos, or at the ends.\n\n            We want to minimize the entire string.\n\n            We can break down the string into segments by the non-one characters (the zeros and twos). Then, we can distribute the ones arbitrarily.\n\n            How does inserting ones affect the lex order?\n\n              Inserting a '1' at a position will yield a string that is the concatenation of:\n\n                  [part1] + '1' + [part2]\n\n              We want to minimize the entire string.\n\n            We can use a greedy strategy:\n\n              We have a fixed sequence of non-one characters (say, S = [c1, c2, ..., ck] where each ci is either '0' or '2').\n\n              We also have a multiset of ones (say, count = m).\n\n              We can insert the ones in the gaps: there are k+1 gaps (before the first, between the first and second, ... , after the last).\n\n            Then, the problem becomes: distribute m identical ones into k+1 gaps, and we want the lexicographically smallest string.\n\n            How to distribute?\n\n              The lex order: we compare the first character, then the second, etc.\n\n              We want the first character to be as small as possible. The first character is either:\n\n                  - The first character of S (if we put no one at the beginning) or \n                  - '1' (if we put at least one one at the beginning)\n\n              Since '0' < '1' < '2', we prefer to have a '0' at the beginning if available.\n\n              So we should not put any one at the beginning if the first non-one character is '0'. \n\n              Similarly, if the first non-one character is '2', then we can put ones at the beginning because '1' is less than '2'? \n\n              But wait, if we put ones at the beginning, the string starts with '1', and if we don't, the string starts with '2'. Since '1' < '2', we would prefer to put ones at the beginning if the first non-one is '2'.\n\n              However, we cannot break the constraint: the non-one sequence must appear in the original order. \n\n            Steps:\n\n              Let S = the sequence of non-one characters (from the original string, in order) and let m = number of ones.\n\n              We are allowed to insert the ones arbitrarily.\n\n              We want to minimize the string.\n\n            We can use dynamic programming or greedy:\n\n              Consider that we have a fixed sequence S and we can insert ones in the gaps. The entire string is the concatenation of:\n\n                  [gap0] + S[0] + [gap1] + S[1] + ... + S[k-1] + [gap_k]\n\n              where gap_i is a sequence of ones (possibly empty) and the total number of ones is m.\n\n              The length of the string is n = len(S) + m.\n\n            How to assign the ones to the gaps?\n\n              We want the lexicographically smallest string.\n\n            Note: We can put any number of ones in any gap.\n\n            Lex order: we compare the first character, then the second, etc.\n\n            We can decide the gaps from left to right.\n\n            For gap0 (the beginning):\n\n              The first character will be:\n                - If we put x ones (x>=1) in gap0, then the first character is '1'.\n                - Otherwise, the first character is S[0].\n\n              Compare:\n\n                If S[0] == '0': then we definitely don't want to put any one",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing any number of adjacent swaps between '0' and '1', or between '1' and '2' in a given ternary string. The key observation is that the relative order of '0's and '2's must remain the same as in the original string, while '1's can be rearranged freely.\n\n### Approach\n1. **Problem Analysis**: The allowed swaps are between adjacent '0' and '1', or between adjacent '1' and '2'. This means '0's can move left or right through '1's, and '2's can move left or right through '1's, but '0's and '2's cannot directly swap places. Therefore, the relative order of '0's and '2's in the original string must be preserved in the result.\n2. **Insight**: The solution involves separating the string into three parts: '0's, '1's, and '2's. The '0's and '2's must appear in the same relative order as in the original string, while '1's can be inserted anywhere. To achieve the lexicographically smallest string, we should place '0's as early as possible, followed by '1's, and then '2's, ensuring the relative order of '0's and '2's is maintained.\n3. **Algorithm Selection**: \n   - Traverse the original string to collect all '0's, '1's, and '2's.\n   - The positions of '0's and '2's are recorded to ensure their relative order is preserved.\n   - Construct the result string by placing '0's first (in their original order), followed by '1's (which can be placed arbitrarily), and then '2's (in their original order).\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    zeros = []\n    ones = []\n    twos = []\n    \n    for char in s:\n        if char == '0':\n            zeros.append(char)\n        elif char == '1':\n            ones.append(char)\n        else:\n            twos.append(char)\n            \n    result = ''.join(zeros) + ''.join(ones) + ''.join(twos)\n    print(result)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input string is read from standard input.\n2. **Separating Characters**: The string is traversed character by character, and each character is categorized into '0's, '1's, or '2's, stored in separate lists.\n3. **Constructing Result**: The result string is constructed by concatenating the list of '0's, followed by the list of '1's, and then the list of '2's. This ensures the lexicographically smallest string because '0's are the smallest characters, followed by '1's, and then '2's. The relative order of '0's and '2's is preserved since they appear in the same sequence as in the original string, while '1's can be placed anywhere without affecting the order of '0's and '2's. \n\nThis approach efficiently leverages the constraints of the problem to produce the desired result with optimal performance, handling all edge cases including strings with only one type of character.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    zeros = []\n    ones = []\n    twos = []\n    \n    for char in s:\n        if char == '0':\n            zeros.append(char)\n        elif char == '1':\n            ones.append(char)\n        else:\n            twos.append(char)\n            \n    result = ''.join(zeros) + ''.join(ones) + ''.join(twos)\n    print(result)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 589,
        "completion_token_count": 701,
        "thoughts_token_count": 8191
    }
}