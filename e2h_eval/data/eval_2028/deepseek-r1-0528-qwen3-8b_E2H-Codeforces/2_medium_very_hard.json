{
    "start": 1758089355.8189461,
    "end": 1758091906.5527077,
    "start-formatted": "2025-09-17 15:09 KST",
    "end-formatted": "2025-09-17 15:51 KST",
    "gpu": 2,
    "pid": 2,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Valera and X\n\nValera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter \"X\". Valera's teacher thinks that the letters on the piece of paper form an \"X\", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.\n\n## Input\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\n## Output\nPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\n## Example\n### Input\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n### Output\n['NO', 'YES', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n We are given an odd integer n, then n lines of n characters each.\n Conditions for \"X\":\n 1. On both diagonals, all letters must be the same (and the same letter for both diagonals? Actually, note: the problem says \"on both diagonals\", meaning each diagonal has the same letter, but the two diagonals might have different letters? Let's read again: \n    - The problem states: \"on both diagonals of the square paper all letters are the same\"\n    - Then: \"all other squares ... contain the same letter that is different from the letters on the diagonals\"\n\n However, note: the example input:\n   Input 1: \n        5\n        xooox\n        oxoxo\n        soxoo\n        oxoxo\n        xooox\n   Output: NO\n\n Why? Because the center cell (which is part of both diagonals) is 's'. But wait, in the example, the diagonals must be the same letter? Actually, let's break down:\n\n Condition 1: Both diagonals must have the same letter throughout. So for the main diagonal (top-left to bottom-right) and anti-diagonal (top-right to bottom-left) we require:\n   - For the main diagonal: all letters are the same.\n   - For the anti-diagonal: all letters are the same.\n\n But note: the center cell is common to both diagonals. Therefore, the letter at the center must be the same for both diagonals.\n\n Condition 2: All non-diagonal cells must be the same letter, and that letter must be different from the diagonal letter.\n\n However, in the example:\n\n   Example 1: \n        n=5\n        xooox\n        oxoxo\n        soxoo\n        oxoxo\n        xooox\n\n   The main diagonal: ['x','o','s','o','x'] -> not all same (because we have x, o, s, o, x). So condition 1 fails.\n\n   Example 2:\n        Input: 3\n                wsw\n                sws\n                wsw\n\n        Main diagonal: ['w','s','w'] -> not all same? Wait, the example output is 'YES'. \n\n        Let me check the example: \n          The main diagonal: \n            row0: index0 -> 'w'\n            row1: index1 -> 's'\n            row2: index2 -> 'w'\n\n        This is not all same. So why is it \"YES\"?\n\n        Let me reread the problem statement: \n          \"on both diagonals of the square paper all letters are the same\"\n\n        But note: the example input is:\n\n            wsw\n            sws\n            wsw\n\n        The main diagonal: \n            (0,0) = 'w'\n            (1,1) = 's'\n            (2,2) = 'w'\n\n        The anti-diagonal:\n            (0,2) = 'w'\n            (1,1) = 's'\n            (2,0) = 'w'\n\n        So the diagonals are not homogeneous. \n\n        There seems to be a misunderstanding. Let me check the example provided:\n\n        Example 3:\n            Input: 3\n                    xpx\n                    pxp\n                    xpe\n\n            Output: NO\n\n        Now, let's analyze example 2 again.\n\n        Actually, the example 2 is described as:\n\n            Input: 3\n                   wsw\n                   sws\n                   wsw\n\n            Output: YES\n\n        And example 3:\n\n            Input: 3\n                   xpx\n                   pxp\n                   xpe\n\n            Output: NO\n\n        So what is the correct condition?\n\n        Let me reexamine the problem statement:\n\n        \"Valera's teacher thinks that the letters on the piece of paper form an \"X\", if: \n         1. on both diagonals of the square paper all letters are the same; \n         2. all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals.\"\n\n        In example 2, the diagonals are not the same letter. Then why is the answer YES?\n\n        Wait, I think I misread the example. Actually, the example input string is:\n\n            ['3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n        But note: the example input format: the first line is the integer n, then n lines of n letters.\n\n        However, the example output for the first one is 'YES' and the second is 'NO'.\n\n        Let me write out the example 2:\n\n            n=3\n            grid = [\n                ['w','s','w'],\n                ['s','w','s'],   # wait, no, the example input is three lines: \"wsw\", \"sws\", \"wsw\"\n                ['w','s','w']\n            ]\n\n        Correction: the example input is:\n\n            Line1: \"wsw\" -> ['w','s','w']\n            Line2: \"sws\" -> ['s','w','s']\n            Line3: \"wsw\" -> ['w','s','w']\n\n        So the grid is:\n\n            w s w\n            s w s\n            w s w\n\n        Now, the main diagonal (from top-left to bottom-right) is: \n            [ grid[0][0], grid[1][1], grid[2][2] ] -> ['w','w','w'] -> same.\n\n        The anti-diagonal (from top-right to bottom-left) is:\n            [ grid[0][2], grid[1][1], grid[2][0] ] -> ['w','w','w'] -> same.\n\n        So condition 1 holds: both diagonals are the same letter (here, 'w').\n\n        Condition 2: All other squares (non-diagonal) must be the same letter and different from the diagonal letter.\n\n        Non-diagonal cells: \n            (0,1): 's'\n            (1,0): 's'\n            (1,2): 's'\n            (2,1): 's'\n\n        So they are all 's'. And 's' is different from 'w'. So condition 2 holds.\n\n        Now, example 3:\n\n            Input: 3\n                   xpx\n                   pxp\n                   xpe\n\n            Grid:\n                x p x\n                p x p\n                x p e\n\n        Condition 1: \n            Main diagonal: [grid[0][0], grid[1][1], grid[2][2]] = ['x','x','e'] -> not all same.\n\n        So condition 1 fails -> output 'NO'.\n\n        Example 1:\n\n            Input: \n                  5\n                  xooox\n                  oxoxo\n                  soxoo\n                  oxoxo\n                  xooox\n\n            Main diagonal: [grid[0][0], grid[1][1], grid[2][2], grid[3][3], grid[4][4]] \n                = ['x','o','s','o','x'] -> not all same.\n\n        Therefore, condition 1 fails -> output 'NO'.\n\n        So the steps:\n\n        Step 1: Read n, then n lines.\n\n        Step 2: Check the two diagonals.\n\n            Let diag1 = [ grid[i][i] for i in range(n) ]\n            Let diag2 = [ grid[i][n-1-i] for i in range(n) ]\n\n        Step 3: Check if all elements in diag1 are the same and all elements in diag2 are the same.\n\n            Also, note: the center cell is common to both. So if the two diagonals are to be the same letter, then the entire diagonal must be one letter and the other diagonal must be the same letter? \n\n        However, wait: the problem does not say the two diagonals must be the same letter. It says \"on both diagonals all letters are the same\", meaning each diagonal is uniform, but the two diagonals could be two different letters? \n\n        Let me consider: \n            Example: \n                n=3\n                a b c\n                d e f\n                g h i\n\n            Condition 1: \n                Diagonal1: a, e, i must be the same (say X)\n                Diagonal2: c, e, g must be the same (say Y)\n\n            Now, if a=e=i=X and c=e=g=Y, then we must have X=Y because the center is shared.\n\n            So actually, the two diagonals must have the same letter because the center is common.\n\n        Therefore, the entire cross must be composed of two diagonals with the same letter (the center being the same for both).\n\n        Step 4: If the diagonals are not uniform or if the two diagonals are not the same letter, then output 'NO'.\n\n        Step 5: Then, check the non-diagonal cells: they must all be the same and different from the diagonal letter.\n\n        However, note: the non-diagonal cells might include multiple letters? We have to check that every non-diagonal cell is the same letter, and that letter is different from the diagonal letter.\n\n        How to check non-diagonal cells?\n\n        We can iterate over every cell (i, j) that is not on the main diagonal (i != j) and not on the anti-diagonal (i+j != n-1). But note: the center is included in both diagonals, so we have already covered it.\n\n        Alternatively, we can do:\n\n        Let center_letter = the letter from the diagonal (since both diagonals are uniform, we can take any, say grid[0][0])\n\n        Then, for every cell (i, j):\n            if (i == j) or (i+j == n-1): skip (diagonal)\n            else: check that the cell is the same letter, say 'other'\n\n        But note: there might be multiple letters in non-diagonal? We have to check that all non-diagonal cells are the same and that this letter is different from the diagonal letter.\n\n        Steps:\n\n        1. Read n and grid.\n\n        2. Check the two diagonals:\n            diag1 = set(grid[i][i] for i in range(n))\n            diag2 = set(grid[i][n-1-i] for i in range(n))\n\n            Conditions:\n                - len(diag1) == 1\n                - len(diag2) == 1\n                - the element in diag1 must equal the element in diag2 (because the center is common, but also even if they are different sets, the problem requires both diagonals to be uniform and the non-diagonal condition says the non-diagonal letter is different from the diagonal letter. However, if the two diagonals are uniform but different, then we have two different letters for the diagonals. But note: the center is common, so if the two diagonals are uniform and the center is the same for both, then the entire diagonal1 must be the same and diagonal2 must be the same and they must be the same letter. \n\n            Actually, if the two diagonals are uniform and the center is common, then the entire diagonal1 must be the same and diagonal2 must be the same, and the center being common forces that the two diagonals have the same letter. \n\n            But what if the grid is:\n\n                a b c\n                d e f\n                g h i\n\n            and we require:\n                a==e==i and c==e==g -> then a==c==e==g==i, so the two diagonals must be the same letter.\n\n            Therefore, we can set:\n                diag_letter = grid[0][0]   (since the entire diagonal1 must be the same, so grid[0][0] is the letter for diagonal1, and similarly for diagonal2, but we know they must be the same)\n\n            However, what if n>=3 and the diagonal1 is uniform but the diagonal2 is uniform but with a different letter? Then the center cell would have two different letters? That is impossible. So we can check:\n\n            if set(diag1) != {letter} or set(diag2) != {letter} for some fixed letter, then we must use the same letter for both.\n\n            Actually, we can do:\n\n                if diag1 has more than one distinct letter OR diag2 has more than one distinct letter -> NO.\n\n            But also, if the letter from diag1 is not the same as the letter from diag2, then NO.\n\n            However, because the center is common, if diag1 and diag2 are uniform but with different letters, then the center would be two different letters? So that is impossible. Therefore, we can just check that both diagonals are uniform and the two diagonals have the same letter.\n\n        3. Now, for non-diagonal cells:\n\n            We need to collect the letters that are not on the diagonals.\n\n            But note: the problem says \"all other squares\" (non-diagonal) must be the same letter and that letter is different from the diagonal letter.\n\n            Steps for non-diagonal:\n                Let non_diag_letters = set()\n                For i in range(n):\n                    for j in range(n):\n                        if i == j or i+j == n-1:\n                            continue\n                        else:\n                            non_diag_letters.add(grid[i][j])\n\n                Conditions:\n                    - The set non_diag_letters must have exactly one element.\n                    - That one element must be different from the diagonal_letter.\n\n            However, what if there are no non-diagonal cells? (n=1) but n>=3, so we are safe.\n\n        But wait, the above approach for non-diagonal uses a set. What if the non-diagonal cells are all the same? Then the set will have one element.\n\n        However, note: the grid has size n (odd and >=3). The total cells: n*n. The diagonals have 2*n - 1 cells (but the center is counted twice, so actually n+n-1 = 2*n-1). But wait, the two diagonals together have 2*n-1 cells. The rest: n*n - (2*n-1) = n*(n-2)+1? \n\n        Example n=3: total 9 cells, diagonals have 3+3-1=5 cells, so non-diagonals: 4.\n\n        So we can do:\n\n            if len(non_diag_letters) != 1:\n                print(\"NO\")\n            else:\n                if next(iter(non_diag_letters)) != diag_letter:\n                    print(\"YES\")\n                else:\n                    print(\"NO\")\n\n        However, wait: what if the two diagonals are uniform but the non-diagonal cells are not all the same? Then we already fail at the set having more than one.\n\n        But note: the problem requires that the non-diagonal cells are the same.\n\n        However, there is a catch: the entire grid must have two diagonals of one letter and the rest one letter. But what if the non-diagonal letter is the same as the diagonal letter? Then condition 2 is violated.\n\n        So the algorithm:\n\n        Step 1: Read n and grid.\n\n        Step 2: Extract the two diagonals.\n\n        Step 3: Check if diag1 is uniform and diag2 is uniform and they are the same letter.\n\n            diag1_letter = grid[0][0]\n            for i in range(n):\n                if grid[i][i] != diag1_letter:\n                    print(\"NO\")\n                    exit(0)\n\n            diag2_letter = grid[0][n-1]   # but wait, the first element of the anti-diagonal is grid[0][n-1]?\n            Actually, we can set diag2_letter = grid[0][n-1] and then check the anti-diagonal. But note: the entire anti-diagonal must be the same, and we know the center must be the same as diag1_letter.\n\n            Alternatively, we can check:\n\n            diag_letter = grid[0][0]   # from the first diagonal\n            for i in range(n):\n                if grid[i][i] != diag_letter:\n                    print(\"NO\")\n                    return\n\n            # Now check the anti-diagonal\n            for i in range(n):\n                if grid[i][n-1-i] != diag_letter:\n                    print(\"NO\")\n                    return\n\n            But wait, what if the two diagonals are supposed to be the same letter? Then yes, we check both against the same letter.\n\n            However, note: the problem doesn't say the two diagonals must be the same letter? Actually, they must be because the center is common. But our check above: we are checking the main diagonal for diag_letter, and then the anti-diagonal for the same diag_letter. This ensures the two diagonals are the same and uniform.\n\n        Step 4: Check the non-diagonal cells.\n\n            non_diag_char = None\n            valid_non_diag = True\n            for i in range(n):\n                for j in range(n):\n                    if i == j or i+j == n-1:\n                        continue\n                    # But note: we want to check that all non-diagonal cells are the same and different from diag_letter.\n                    if non_diag_char is None:\n                        non_diag_char = grid[i][j]\n                    else:\n                        if grid[i][j] != non_diag_char:\n                            valid_non_diag = False\n                            break\n                if not valid_non_diag:\n                    break\n\n            However, we also must check that non_diag_char is not the same as diag_letter.\n\n            But note: what if there are no non-diagonal cells? Then we skip the loop and non_diag_char remains None. Then we have to handle that.\n\n            Since n>=3, there are non-diagonal cells.\n\n        Alternatively, we can do:\n\n            non_diag_set = set()\n            for i in range(n):\n                for j in range(n):\n                    if i != j and i+j != n-1:\n                        non_diag_set.add(grid[i][j])\n\n            Then, if non_diag_set is empty -> but n>=3, so there should be non-diagonal cells. Then:\n                if len(non_diag_set) != 1:\n                    print(\"NO\")\n                    return\n                else:\n                    if list(non_diag_set)[0] == diag_letter:\n                        print(\"NO\")\n                    else:\n                        print(\"YES\")\n\n        But wait, we already checked the diagonals. Now we are checking non-diagonals.\n\n        However, there's a possibility: the two diagonals are uniform and same letter, but the non-diagonals are not uniform? Then we output NO.\n\n        But note: what if the two diagonals are uniform and same, and the non-diagonals are uniform but same as the diagonal letter? Then we output NO because the non-diagonal letter must be different.\n\n        But wait, the problem says: \"all other squares ... contain the same letter that is different from the letters on the diagonals\"\n\n        So the non-diagonal letter must be different.\n\n        However, what if the non-diagonal_set is empty? Then we don't have any non-diagonal cell. But for n>=3, the smallest n=3 has 9-5=4 non-diagonal cells.\n\n        Therefore, we can write:\n\n        Steps:\n\n            n = int(input().strip())\n            grid = []\n            for i in range(n):\n                grid.append(input().strip())\n\n            # Check the two diagonals for a uniform letter (same letter for entire diagonal) and the two diagonals share the same letter.\n            diag_letter = grid[0][0]\n            # Check main diagonal\n            for i in range(n):\n                if grid[i][i] != diag_letter:\n                    print(\"NO\")\n                    exit(0)\n\n            # Check anti-diagonal\n            for i in range(n):\n                if grid[i][n-1-i] != diag_letter:\n                    print(\"NO\")\n                    exit(0)\n\n            # Now check non-diagonal cells\n            # We'll collect all non-diagonal letters and make sure they are the same and different from diag_letter.\n            non_diag_letters = set()\n            for i in range(n):\n                for j in range(n):\n                    if i == j or i+j == n-1:\n                        continue\n                    non_diag_letters.add(grid[i][j])\n\n            # But note: there might be multiple non-diagonal letters? Then we require only one distinct letter.\n            if len(non_diag_letters) != 1:\n                print(\"NO\")\n                exit(0)\n\n            non_diag_char = next(iter(non_diag_letters))\n            if non_diag_char == diag_letter:\n                print(\"NO\")\n            else:\n                print(\"YES\")\n\n        However, wait: what if the two diagonals are uniform and same, and the non-diagonals are uniform and different, then YES.\n\n        But consider: what if the grid has a non-diagonal cell that is not the same as the others? Then the set non_diag_letters will have more than one element, and we output NO.\n\n        However, there's a catch: what if the entire grid is the same letter? Then the two diagonals are uniform (with that letter) and the non-diagonal set will have the same letter. Then we output NO because the non-diagonal letter is the same as the diagonal.\n\n        That is correct because the condition requires the non-diagonal letter to be different.\n\n        But wait: what if the grid is:\n\n            n=3\n            aaa\n            aaa\n            aaa\n\n        Then:\n            Diagonals: a, a, a -> uniform and same letter 'a'.\n            Non-diagonals: the set will be {'a'} -> then we check: non_diag_char == 'a' which equals diag_letter -> output NO.\n\n        Another example:\n\n            n=3\n            xxx\n            xyy\n            xxx\n\n        Then:\n            Diagonals: \n                main: [x, y, x] -> not uniform -> NO.\n\n        But wait, our code checks the main diagonal first and sees the second element is 'y' (if diag_letter is grid[0][0]='x') then we break.\n\n        Another example: \n            n=3\n            xyy\n            yxx\n            xyx\n\n        This is not an X. Let's check:\n\n        Main diagonal: [x, x, x] -> uniform? \n            row0: x\n            row1: x\n            row2: x -> uniform.\n\n        Anti-diagonal: [y, x, y] -> not uniform -> NO.\n\n        But wait, the anti-diagonal is defined as: \n            (0,2)=y, (1,1)=x, (2,0)=x -> wait no, (2,0) is 'x'? The grid is:\n\n            row0: x y y\n            row1: y x x\n            row2: x y x\n\n        Actually, the grid was:\n\n            xyy\n            yxx\n            xyx\n\n        Then the anti-diagonal: \n            (0,2): 'y'\n            (1,1): 'x'\n            (2,0): 'x'\n\n        So anti-diagonal is not uniform -> NO.\n\n        But wait, the example input:\n\n            Input: \n                3\n                wsw\n                sws\n                wsw\n\n            Our code:\n\n                n=3\n                grid = ['wsw', 'sws', 'wsw']\n\n                diag_letter = 'w'\n\n                Check main diagonal:\n                    i=0: grid[0][0]=='w' -> ok.\n                    i=1: grid[1][1]=='w' -> ok.\n                    i=2: grid[2][2]=='w' -> ok.\n\n                Check anti-diagonal:\n                    i=0: grid[0][2]=='w' -> ok.\n                    i=1: grid[1][1]=='w' -> ok.  (because n-1=2, so grid[1][2-1]=grid[1][1])\n                    i=2: grid[2][0]=='w' -> ok.\n\n                Then non-diagonal:\n                    i=0: j=1 -> grid[0][1]=='s' -> add to set: {'s'}\n                    i=1: j=0 -> grid[1][0]=='s' -> add 's' (set remains {'s'})\n                          j=2 -> grid[1][2]=='s' -> add 's' (set remains {'s'})\n                    i=2: j=1 -> grid[2][1]=='s' -> add 's' (set remains {'s'})\n\n                Then set has one element 's', and 's' != 'w' -> output YES.\n\n        So the code works for the examples.\n\n        However, note: the above method for the anti-diagonal uses the same diag_letter (which we set from the main diagonal). But what if the main diagonal is uniform but the anti-diagonal is uniform with a different letter? \n\n        Example:\n\n            n=3\n            aaa\n            aba\n            aaa\n\n        Then main diagonal: [a,a,a] -> uniform with 'a'\n        Anti-diagonal: [a, b, a] -> not uniform -> caught by the anti-diagonal check.\n\n        But what if:\n\n            n=3\n            aaa\n            bab\n            aaa\n\n        Main diagonal: [a, b, a] -> not uniform -> caught.\n\n        What if:\n\n            n=3\n            aaa\n            abb\n            aca\n\n        Main diagonal: [a,b,a] -> not uniform -> caught.\n\n        Now, what if:\n\n            n=3\n            bbb\n            bcb\n            bbb\n\n        Then main diagonal: [b, c, b] -> not uniform -> caught.\n\n        But wait, what if the two diagonals are uniform but with two different letters? \n\n        Example:\n\n            n=3\n            aba\n            bbb\n            caa\n\n        Main diagonal: [a, b, a] -> not uniform -> caught.\n\n        However, consider:\n\n            n=3\n            aaa\n            aab\n            aaa\n\n        Main diagonal: [a,a,a] -> uniform with 'a'\n        Anti-diagonal: [a, a, a] -> uniform with 'a'\n\n        Then non-diagonal: \n            (0,1): 'a' -> but wait, the non-diagonal condition requires a letter different from 'a'. However, the non-diagonal cells are:\n                (0,1): 'a'\n                (1,0): 'a'\n                (1,2): 'b'\n                (2,1): 'a'\n\n            So the non-diagonal set: {'a','b'} -> two distinct letters -> NO.\n\n        But wait, the grid is:\n\n            aaa\n            aab\n            aaa\n\n        The non-diagonal cells are not all the same. So condition 2 fails.\n\n        However, note: the problem says \"all other squares ... contain the same letter\". So the non-diagonal cells must be the same.\n\n        Therefore, the code is as follows.\n\n        But note: the above code for the diagonals checks the entire main diagonal and anti-diagonal with the same letter (diag_letter from the top-left). \n\n        There is a possibility: what if the main diagonal is uniform, but the anti-diagonal is uniform with a different letter? \n\n        Example:\n\n            n=3\n            aba\n            bbb\n            abc\n\n        Actually, let me construct one:\n\n            n=3\n            xyz\n            zyz\n            xyy\n\n        Main diagonal: [x, y, y] -> not uniform.\n\n        Another:\n\n            n=3\n            xyz\n            yzz\n            zxy\n\n        Main diagonal: [x, y, y] -> not uniform.\n\n        Actually, because the center is common, if the two diagonals are uniform then they must be the same letter. So we cannot have two different letters for the two diagonals.\n\n        Therefore, the code is correct.\n\n        However, note: we are using the top-left corner to set diag_letter. But what if the main diagonal is uniform but not the same as the top-left corner? \n\n        Example:\n\n            n=3\n            bbb\n            bcb\n            bbb\n\n        Then the main diagonal is [b, c, b] -> not uniform, so we catch it.\n\n        Another:\n\n            n=3\n            aaa\n            aab\n            aaa\n\n        Main diagonal: [a, a, a] -> uniform, and the anti-diagonal: [a, a, a] -> uniform, but then non-diagonal: not uniform -> NO.\n\n        One more: \n\n            n=3\n            aaa\n            aaa\n            aaa\n\n        This is all 'a'. Then:\n            Diagonals: [a,a,a] and [a,a,a] -> uniform and same letter 'a'.\n            Non-diagonal: all 'a' -> set has one element 'a', but then we check: non_diag_char == 'a' and diag_letter=='a' -> so we output NO.\n\n        This is correct.\n\n        Therefore, we write the code accordingly.\n\n        However, note: the problem says the two diagonals must be the same letter. We are checking both against the top-left corner. But what if the top-left corner is not the letter of the diagonal? \n\n        Example:\n\n            n=3\n            bbb\n            bbb\n            bbb\n\n        Then diag_letter = grid[0][0] = 'b'\n        Check main diagonal: [b,b,b] -> ok.\n        Check anti-diagonal: [b,b,b] -> ok.\n\n        Then non-diagonal: set() -> but wait, there are non-diagonal cells? Actually, in a 3x3, the non-diagonal cells are the ones that are not (0,0),(1,1),(2,2) and not (0,2),(1,1),(2,0). The center is (1,1) and is included in both. The non-diagonal cells are (0,1), (1,0), (1,2), (2,1). They are all 'b'. Then non_diag_letters = {'b'}, and then we check: 'b' == 'b' -> output NO.\n\n        Correct.\n\n        But wait: what if the grid is:\n\n            n=3\n            bbb\n            bcb\n            bbb\n\n        Then main diagonal: [b, c, b] -> not uniform -> NO.\n\n        What if:\n\n            n=3\n            bbb\n            bbc\n            bbb\n\n        Main diagonal: [b, b, b] -> uniform with 'b'\n        Anti-diagonal: [b, b, b] -> uniform with 'b'\n\n        Then non-diagonal: \n            (0,1): 'b'\n            (1,0): 'b'\n            (1,2): 'c'\n            (2,1): 'b'\n\n        Then non_diag_letters = {'b','c'} -> two distinct -> NO.\n\n        This is correct.\n\n        Therefore, the code is:\n\n        Note: We must check the entire grid for the diagonals and then the non-diagonals.\n\n        However, we can optimize by breaking early.\n\n        Let me code accordingly.\n\n        But note: the problem constraints: n<300, so maximum 299. The grid has up to 299*299 ~ 90000 cells. The double loop for non-diagonal is O(n^2) which is acceptable for n=299 (about 89000 iterations, which is acceptable in Python).\n\n        Code:\n\n        n = int(input().strip())\n        grid = []\n        for i in range(n):\n            grid.append(input().strip())\n\n        # Check the two diagonals for uniformity and same letter.\n        diag_letter = grid[0][0]\n        # Check main diagonal\n        for i in range(n):\n            if grid[i][i] != diag_letter:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal\n        for i in range(n):\n            if grid[i][n-1-i] != diag_letter:\n                print(\"NO\")\n                exit(0)\n\n        # Now check non-diagonal cells\n        non_diag_letters = set()\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                non_diag_letters.add(grid[i][j])\n\n        # If there are no non-diagonal cells, then n must be 1, but n>=3 so we don't worry.\n        if len(non_diag_letters) != 1:\n            print(\"NO\")\n        else:\n            non_diag_char = next(iter(non_diag_letters))\n            if non_diag_char == diag_letter:\n                print(\"NO\")\n            else:\n                print(\"YES\")\n\n        However, wait: what if the grid has non-diagonal cells that are not covered by the condition? Actually, we are iterating over every cell and skipping the diagonals.\n\n        But note: the center cell is included in both diagonals and skipped.\n\n        This code should be correct.\n\n        Let me test with the provided examples.\n\n        Example 1: \n            Input: \n                5\n                xooox\n                oxoxo\n                soxoo\n                oxoxo\n                xooox\n\n            Main diagonal: \n                [0][0] = 'x' -> diag_letter='x'\n                [1][1] = 'o' -> not 'x' -> prints \"NO\"\n\n        Example 2:\n            Input: \n                3\n                wsw\n                sws\n                wsw\n\n            Main diagonal: \n                [0][0]='w', [1][1]='w', [2][2]='w' -> ok.\n            Anti-diagonal:\n                [0][2]='w', [1][1]='w', [2][0]='w' -> ok.\n            Non-diagonal: \n                (0,1)='s', (1,0)='s', (1,2)='s', (2,1)='s' -> set={'s'} -> then compare: 's' != 'w' -> YES.\n\n        Example 3:\n            Input:\n                3\n                xpx\n                pxp\n                xpe\n\n            Main diagonal: \n                [0][0]='x', [1][1]='x', [2][2]='e' -> 'e' != 'x' -> NO.\n\n        But wait, the example 3 input is:\n\n            xpx\n            pxp\n            xpe\n\n        Our code: \n            n=3\n            grid[0]=\"xpx\"\n            grid[1]=\"pxp\"\n            grid[2]=\"xpe\"\n\n            diag_letter = grid[0][0] = 'x'\n\n            Check main diagonal:\n                i=0: grid[0][0]=='x' -> ok.\n                i=1: grid[1][1]=='x' -> ok.\n                i=2: grid[2][2]=='e' -> not 'x' -> print \"NO\"\n\n        So the output is \"NO\", which matches.\n\n        However, wait: the example 3 in the problem is:\n\n            Input: 3\n                   xpx\n                   pxp\n                   xpe\n\n            Output: NO\n\n        So our code passes.\n\n        But wait, there is an alternative: what if the two diagonals are uniform but the non-diagonal condition is not satisfied? \n\n        Example:\n\n            n=3\n            xxx\n            xyy\n            xxx\n\n        Our code: \n            diag_letter = 'x'\n            Main diagonal: [x,x,x] -> ok.\n            Anti-diagonal: [x, y, x] -> at i=1: grid[1][1] is 'y' != 'x' -> NO.\n\n        But wait, the anti-diagonal is: \n            (0,2): 'x'\n            (1,1): 'y'\n            (2,0): 'x'\n\n        So we break at i=1.\n\n        Example:\n\n            n=3\n            xxx\n            xyy\n            xyy\n\n        Main diagonal: [x,y,y] -> not uniform -> NO.\n\n        Example:\n\n            n=3\n            xxx\n            xyy\n            xxy\n\n        Main diagonal: [x,y,x] -> not uniform -> NO.\n\n        Example:\n\n            n=3\n            xxx\n            xxy\n            xxy\n\n        Main diagonal: [x,x,x] -> ok.\n        Anti-diagonal: [x, x, x] -> ok.\n\n        Then non-diagonal: \n            (0,1): 'x' -> but wait, the grid is:\n                row0: \"xxx\"\n                row1: \"xxy\"\n                row2: \"xxy\"\n\n            The non-diagonal cells: \n                (0,1): 'x' -> but note: (0,1) is not on the main diagonal (0!=1) and not on the anti-diagonal (0+1=1 != 2) -> so non-diagonal includes (0,1) and (1,0) is not present? \n                Let me index:\n\n                row0: [0,0]='x', [0,1]='x', [0,2]='x'\n                row1: [1,0]='x', [1,1]='x', [1,2]='y'\n                row2: [2,0]='x', [2,1]='x', [2,2]='y'\n\n            Non-diagonal cells: \n                (0,1): 'x'\n                (1,0): 'x' -> wait, (1,0): i+j=1+0=1 != 2 (for n=3, n-1=2) -> so not anti-diagonal? \n                Actually, the anti-diagonal condition is i+j == n-1 -> 1+0=1 !=2 -> so (1,0) is not on the anti-diagonal.\n\n                (1,2): 'y' -> i+j=1+2=3 !=2 -> so non-diagonal? But wait, (1,2) is not on the main diagonal (1!=2) and not on the anti-diagonal (1+2=3 !=2) -> so non-diagonal.\n\n                (2,0): 'x' -> i+j=2+0=2 -> this is the anti-diagonal (since n",
    "response": "\nTo solve this problem, we need to determine if a given square grid forms the letter \"X\" based on specific conditions. The conditions are that all letters on both diagonals must be the same, and all other letters (not on the diagonals) must be the same and different from the diagonal letters.\n\n### Approach\n1. **Check Diagonals**: The first step is to verify that all letters on both the main diagonal (from top-left to bottom-right) and the anti-diagonal (from top-right to bottom-left) are identical. This involves checking each cell along these diagonals to ensure uniformity.\n2. **Check Non-Diagonal Cells**: After confirming the diagonals are uniform, we then check that all cells not on either diagonal are the same letter and that this letter differs from the diagonal letter.\n3. **Output Result**: Based on the checks, we output \"YES\" if all conditions are met; otherwise, we output \"NO\".\n\n### Solution Code\n```python\ndef main():\n    n = int(input().strip())\n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    diag_letter = grid[0][0]\n    # Check main diagonal\n    for i in range(n):\n        if grid[i][i] != diag_letter:\n            print(\"NO\")\n            return\n            \n    # Check anti-diagonal\n    for i in range(n):\n        if grid[i][n-1-i] != diag_letter:\n            print(\"NO\")\n            return\n            \n    non_diag_letters = set()\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                continue\n            non_diag_letters.add(grid[i][j])\n            \n    if len(non_diag_letters) != 1:\n        print(\"NO\")\n    else:\n        non_diag_char = next(iter(non_diag_letters))\n        if non_diag_char == diag_letter:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The code starts by reading the integer `n` (the size of the grid) and then reads `n` lines of input to form the grid.\n2. **Diagonal Check**: The code checks each cell along the main diagonal (where row index equals column index) and the anti-diagonal (where row index plus column index equals `n-1`). If any cell in these diagonals does not match the first cell's value (`grid[0][0]`), it immediately prints \"NO\" and exits.\n3. **Non-Diagonal Check**: The code collects all letters from cells not on either diagonal into a set. If this set contains more than one distinct letter, it prints \"NO\". Otherwise, it checks if the collected letter is different from the diagonal letter. If they are the same, it prints \"NO\"; otherwise, it prints \"YES\".\n\nThis approach efficiently verifies the conditions for forming an \"X\" by systematically checking each required part of the grid, ensuring correctness with minimal computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    n = int(input().strip())\n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    \n    diag_letter = grid[0][0]\n    # Check main diagonal\n    for i in range(n):\n        if grid[i][i] != diag_letter:\n            print(\"NO\")\n            return\n            \n    # Check anti-diagonal\n    for i in range(n):\n        if grid[i][n-1-i] != diag_letter:\n            print(\"NO\")\n            return\n            \n    non_diag_letters = set()\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                continue\n            non_diag_letters.add(grid[i][j])\n            \n    if len(non_diag_letters) != 1:\n        print(\"NO\")\n    else:\n        non_diag_char = next(iter(non_diag_letters))\n        if non_diag_char == diag_letter:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 439,
        "completion_token_count": 646,
        "thoughts_token_count": 8190
    }
}