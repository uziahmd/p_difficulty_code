{
    "start": 1758093170.7126985,
    "end": 1758094945.0175338,
    "start-formatted": "2025-09-17 16:12 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given up to 100000 items, each with weight either 1, 2, or 3, and a cost (which can be up to 10^9). We have a maximum total weight m (up to 300000).\n\n Since the weights are only 1, 2, or 3, we can categorize the souvenirs by their weight.\n\n Let:\n   type1 = list of costs for weight 1\n   type2 = list of costs for weight 2\n   type3 = list of costs for weight 3\n\n Then, we can sort each type in descending order (so that we can pick the most expensive ones first).\n\n Now, note that the total weight is the sum of the weights of the chosen items. We are allowed to use at most m weight.\n\n We can think of it as: we will choose some number of items from type1, type2, type3. Let:\n   x1 = number of type1 chosen (each 1)\n   x2 = number of type2 chosen (each 2)\n   x3 = number of type3 chosen (each 3)\n\n Then, the total weight is: w = x1 + 2*x2 + 3*x3 <= m\n And the total cost is: c = sum(type1[0:x1]) + sum(type2[0:x2]) + sum(type3[0:x3])\n\n However, iterating over all x1, x2, x3 is too expensive because n can be 100000.\n\n Alternate approach:\n\n We can precompute the prefix sums for each type (since we'll take the top k from each type).\n\n Steps:\n 1. Separate the items into three lists: [w1, c1] -> separate by w=1,2,3.\n 2. Sort each list by cost in descending order (so that the highest costs come first).\n 3. Precompute the prefix sums for each list (for the sorted order).\n\n Then, note: the problem becomes: choose non-negative integers x1, x2, x3 (with x1 <= len(type1), etc.) such that:\n      x1 + 2*x2 + 3*x3 <= m\n and maximize the sum of the prefix sums for type1 at x1, type2 at x2, and type3 at x3.\n\n But note: we cannot iterate over x1, x2, x3 independently because m can be up to 300000 and the counts of each type can be up to 100000.\n\n However, note that the weights per item are small (only 1,2,3). Therefore, the number of items we can take from one type is limited by m (but also by the count of that type). Also, the total weight is at most m (300000) so the maximum number of items from one type is at most 300000/1 = 300000, but our n is 100000, so we are safe to consider only up to the length of each type.\n\n But 100000 * 100000 is too big. We need a better way.\n\n Observation: since the weights are small, we can iterate over the number of type3 items (because they are the heaviest, so fewer of them) and then for each fixed x3, we are left with a budget of m - 3*x3 for the other two types.\n\n Then, the remaining budget is R = m - 3*x3, and we need to choose x1 and x2 (nonnegative integers) such that:\n        x1 + 2*x2 <= R\n\n and we want to maximize: prefix1[x1] + prefix2[x2]\n\n But note: the total number of type1 and type2 items we can use is limited by the available counts (say, n1 and n2). So x1 in [0, min(R, n1)] and x2 in [0, min(floor(R/2), n2)].\n\n However, we can restructure: for a fixed x3, we have to choose between type1 and type2. Let T = R (remaining weight). Then, we can use any combination of x1 and x2 such that x1 + 2*x2 <= T.\n\n We can precompute for type1 and type2 separately the best cost for a given total weight (or for a given number of items) but note: the weight of type1 is 1 and type2 is 2.\n\n Alternatively, we can think: we can take at most T items from type1 and type2, but the type2 items take two units. We can try to fix the number of type2 items (x2) and",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs have weights of either 1, 2, or 3 units, and each has a specific cost. The challenge is to select a subset of these souvenirs such that their total weight does not exceed the limit, and their total cost is as high as possible.\n\n### Approach\n1. **Categorize Souvenirs**: Separate the souvenirs into three categories based on their weights (1, 2, or 3). Each category will contain the costs of souvenirs with the corresponding weight.\n2. **Sort by Cost**: For each category, sort the souvenirs in descending order of their costs. This allows us to pick the most expensive items first, maximizing the total cost.\n3. **Prefix Sums**: Compute prefix sums for each sorted list. This helps in quickly calculating the total cost of selecting the top `k` items from any category.\n4. **Iterate Over Possible Type3 Items**: Since items with weight 3 are the heaviest, we iterate over the number of such items (from 0 to the maximum possible) that can be included without exceeding the weight limit.\n5. **Remaining Weight Calculation**: For each number of type3 items, calculate the remaining weight available for type1 and type2 items.\n6. **Maximize Combined Cost**: For the remaining weight, determine the optimal combination of type1 and type2 items. This involves checking all possible combinations of type1 and type2 items that fit within the remaining weight and using the prefix sums to find the maximum cost efficiently.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    prefix1 = [0] * (len1 + 1)\n    prefix2 = [0] * (len2 + 1)\n    prefix3 = [0] * (len3 + 1)\n    \n    for i in range(1, len1+1):\n        prefix1[i] = prefix1[i-1] + type1[i-1]\n        \n    for i in range(1, len2+1):\n        prefix2[i] = prefix2[i-1] + type2[i-1]\n        \n    for i in range(1, len3+1):\n        prefix3[i] = prefix3[i-1] + type3[i-1]\n        \n    best = 0\n    \n    max_x3 = min(len3, m // 3)\n    for x3 in range(0, max_x3 + 1):\n        rem = m - 3 * x3\n        if rem < 0:\n            continue\n        total3 = prefix3[x3]\n        if rem == 0:\n            candidate = total3\n            if candidate > best:\n                best = candidate\n            continue\n            \n        max_x2 = min(len2, rem // 2)\n        for x2 in range(0, max_x2 + 1):\n            rem_after2 = rem - 2 * x2\n            total2 = prefix2[x2]\n            if rem_after2 < 0:\n                continue\n            max_x1 = min(len1, rem_after2)\n            total1 = prefix1[max_x1]\n            candidate = total1 + total2 + total3\n            if candidate > best:\n                best = candidate\n                \n    print(best)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum allowed weight `m`. Each souvenir's weight and cost are then categorized into one of three lists based on their weight.\n2. **Sorting and Prefix Sums**: Each category's list of costs is sorted in descending order. Prefix sums are computed for each list to facilitate quick summation of the top `k` items.\n3. **Iterating Over Type3 Items**: The solution iterates over all possible counts of type3 items (items with weight 3). For each count, it checks if the remaining weight can accommodate any combination of type1 and type2 items.\n4. **Combination Check**: For each valid count of type3 items, the remaining weight is split between type1 and type2 items. The solution checks all possible counts of type2 items within the remaining weight, then uses the prefix sums to find the maximum cost from type1 items.\n5. **Result Calculation**: The maximum total cost encountered during the iterations is printed as the result.\n\nThis approach efficiently narrows down the problem by leveraging the constraints on item weights and using sorting and prefix sums to optimize the selection process. The solution ensures that the maximum cost is achieved without exceeding the weight limit.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    prefix1 = [0] * (len1 + 1)\n    prefix2 = [0] * (len2 + 1)\n    prefix3 = [0] * (len3 + 1)\n    \n    for i in range(1, len1+1):\n        prefix1[i] = prefix1[i-1] + type1[i-1]\n        \n    for i in range(1, len2+1):\n        prefix2[i] = prefix2[i-1] + type2[i-1]\n        \n    for i in range(1, len3+1):\n        prefix3[i] = prefix3[i-1] + type3[i-1]\n        \n    best = 0\n    \n    max_x3 = min(len3, m // 3)\n    for x3 in range(0, max_x3 + 1):\n        rem = m - 3 * x3\n        if rem < 0:\n            continue\n        total3 = prefix3[x3]\n        if rem == 0:\n            candidate = total3\n            if candidate > best:\n                best = candidate\n            continue\n            \n        max_x2 = min(len2, rem // 2)\n        for x2 in range(0, max_x2 + 1):\n            rem_after2 = rem - 2 * x2\n            total2 = prefix2[x2]\n            if rem_after2 < 0:\n                continue\n            max_x1 = min(len1, rem_after2)\n            total1 = prefix1[max_x1]\n            candidate = total1 + total2 + total3\n            if candidate > best:\n                best = candidate\n                \n    print(best)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 476,
        "completion_token_count": 1170,
        "thoughts_token_count": 1023
    }
}