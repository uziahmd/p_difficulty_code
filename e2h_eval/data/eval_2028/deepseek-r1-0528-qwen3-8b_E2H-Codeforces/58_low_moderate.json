{
    "start": 1758298843.4996967,
    "end": 1758302275.651365,
    "start-formatted": "2025-09-20 01:20 KST",
    "end-formatted": "2025-09-20 02:17 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are to find the minimum number of edges t to add to the graph to form an odd cycle, and the number of ways w (without creating loops or parallel edges) to do so.\n\n Observing that:\n  - An odd cycle must have at least 3 edges (a triangle is the smallest odd cycle, with length 3).\n\n Steps:\n\n 1. If the graph already contains an odd-length cycle, then t=0 and w=1? But note: the problem says \"form a simple cycle of odd length\", meaning we don't need to add any edge. However, the example input \"3 3\\n1 2\\n2 3\\n3 1\" outputs \"0 1\".\n\n 2. Otherwise, we consider adding edges.\n\n Let's break down:\n\n Case 1: The graph already has an odd cycle -> then we don't need to add any edge.\n\n How to check for an odd cycle?\n   We can use BFS/DFS with coloring (bipartite check). If the graph is not bipartite, then it contains an odd cycle.\n\n Case 2: The graph is bipartite (so no odd cycle). Then we need to consider how to form an odd cycle by adding edges.\n\n Note: We cannot add an edge that already exists or creates a loop.\n\n There are two possibilities:\n\n   a) We might form an odd cycle by adding just one edge (t=1). When can this happen?\n        Consider: if there is a path of even length between two vertices (say u and v) and we add an edge (u, v), then we get a cycle of odd length (even+1 is odd). But note: the cycle formed must be simple and of odd length.\n\n        Actually, in a bipartite graph, the entire graph is 2-colorable. Suppose we have two parts: A and B.\n\n        Adding an edge within the same part will create an odd cycle. Why?\n          Let the edge connect two nodes in part A. Then consider the shortest path from node u to v (which is in A) in the original graph. Since the graph is bipartite, the parity of the path length from u to v is even (because both are in A). Then the cycle formed by the path and the new edge has length (even + 1) which is odd.\n\n        Therefore, if we can find at least one pair of non-adjacent vertices (in the same part) then we can form an odd cycle by adding one edge.\n\n        But note: we must not add an edge that already exists.\n\n        So, t=1 is possible if there exists at least one edge that we can add (i.e., within the same part and not present) and then the condition is satisfied.\n\n        However, what if the graph is complete? Then we cannot add any edge without violating the condition (no parallel edges and no loops). But note: the graph is bipartite, so if the graph is complete and bipartite, then the two parts are independent sets and we cannot add edges within the same part because the graph is complete? Actually, no: in a complete bipartite graph, we can only have edges between the two parts. So we cannot add an edge within the same part because the graph is complete? \n\n        But wait: the graph is bipartite, but not necessarily complete. We are allowed to add any edge that is not present and not a loop.\n\n        However, note: if the graph is disconnected, then the bipartite coloring might be done independently on each connected component. But the entire graph must be bipartite.\n\n        Steps for case 2 (graph is bipartite):\n\n        Option 1: Add one edge (t=1) if there exists at least one edge that connects two nodes in the same part and that edge is not present.\n\n        Option 2: If there is no such edge (meaning the graph is a complete bipartite graph, or more generally, we cannot add an edge within a part because every non-edge within a part is not available? Actually, no: we can always add an edge unless the graph is complete in the sense that all edges between the two parts are present and also all edges within the same part are absent? Actually, we are only concerned about edges within the same part. So if the graph is not complete (with respect to the same part), then we can add an edge.\n\n        But wait: if the graph is bipartite, then the edges are only between A and B. So the edges within A and within B are absent (by definition of being bipartite). However, the graph might not have all the edges between A and B. But note: we are only concerned with edges within A or within B. Since the graph is bipartite, there are no edges within A or within B. So we can always add an edge within A or within B as long as",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and the number of ways to add those edges without creating loops or parallel edges.\n\n### Approach\n1. **Check for Existing Odd Cycle**: The graph already contains an odd cycle if it is not bipartite. We can detect this using a BFS or DFS-based bipartite check. If the graph is not bipartite, no edges need to be added (t=0, w=1).\n\n2. **Bipartite Graph Handling**: If the graph is bipartite, we then check if adding one edge within the same part (either of the two bipartite sets) will create an odd cycle. This is because connecting two nodes in the same part with an existing even-length path results in an odd-length cycle when combined with the new edge.\n\n3. **Complete Bipartite Graph Check**: If the graph is a complete bipartite graph (all possible edges between the two parts are present), then adding one edge within a part is impossible. In this case, we need to consider adding three edges to form a triangle (odd cycle). The number of ways to add three edges depends on the number of non-edges in the graph that can form such a triangle.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    \n    graph = [[] for _ in range(n+1)]\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    color = [-1] * (n+1)\n    is_bipartite = True\n    comp_label = [0] * (n+1)\n    comp_id = 0\n    \n    for i in range(1, n+1):\n        if color[i] == -1:\n            color[i] = 0\n            q = deque([i])\n            comp_id += 1\n            while q:\n                node = q.popleft()\n                comp_label[node] = comp_id\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[node] ^ 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        is_bipartite = False\n                        break\n                if not is_bipartite:\n                    break\n            if not is_bipartite:\n                break\n            comp_id += 1\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_edges = n*(n-1)//2\n    existing_edges = m\n    missing_edges = total_edges - existing_edges\n    same_part_edges = {}\n    part1_edges = 0\n    part2_edges = 0\n    part1_nodes = set()\n    part2_nodes = set()\n    \n    for i in range(1, n+1):\n        if color[i] == 0:\n            part1_nodes.add(i)\n        else:\n            part2_nodes.add(i)\n            \n    part1_size = len(part1_nodes)\n    part2_size = len(part2_nodes)\n    max_possible_edges_between_parts = part1_size * part2_size\n    existing_between_edges = m\n    \n    for i in range(1, n+1):\n        for j in graph[i]:\n            if i < j:\n                if color[i] != color[j]:\n                    pass\n                else:\n                    part1_edges += 1 if color[i] == 0 else 0\n                    part2_edges += 1 if color[i] == 1 else 0\n            else:\n                continue\n                \n    same_part_edges = {\n        0: part1_edges,\n        1: part2_edges\n    }\n    \n    total_same_part_edges = part1_edges + part2_edges\n    total_possible_same_part_edges = part1_size*(part1_size-1)//2 + part2_size*(part2_size-1)//2\n    \n    if missing_edges > 0:\n        t = 1\n        w = 0\n        for part in [0, 1]:\n            available = total_possible_same_part_edges - same_part_edges[part]\n            if available > 0:\n                w += available\n        print(f\"1 {w}\")\n    else:\n        t = 3\n        w = 0\n        if part1_size >= 3:\n            w += part1_size*(part1_size-1)*(part1_size-2)//6\n        if part2_size >= 3:\n            w += part2_size*(part2_size-1)*(part2_size-2)//6\n        print(f\"3 {w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The code first checks if the graph is bipartite using BFS. If it's not, an odd cycle exists, so no edges need to be added (output \"0 1\").\n\n2. **Edge Addition for Odd Cycle**: If the graph is bipartite, the code checks if adding one edge within the same part (either of the two bipartite sets) is possible. The number of such edges is calculated based on the available non-edges within each part.\n\n3. **Complete Bipartite Handling**: If no single edge can form an odd cycle (i.e., the graph is complete bipartite), the code calculates the number of ways to add three edges to form a triangle (odd cycle) by considering all combinations of three nodes in the same part that do not already form a triangle.\n\nThis approach efficiently handles both scenarios where edges can be added with minimal additions (one or three edges) and ensures correctness by leveraging bipartite graph properties and combinatorial counting.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    \n    graph = [[] for _ in range(n+1)]\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    color = [-1] * (n+1)\n    is_bipartite = True\n    comp_label = [0] * (n+1)\n    comp_id = 0\n    \n    for i in range(1, n+1):\n        if color[i] == -1:\n            color[i] = 0\n            q = deque([i])\n            comp_id += 1\n            while q:\n                node = q.popleft()\n                comp_label[node] = comp_id\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[node] ^ 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        is_bipartite = False\n                        break\n                if not is_bipartite:\n                    break\n            if not is_bipartite:\n                break\n            comp_id += 1\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_edges = n*(n-1)//2\n    existing_edges = m\n    missing_edges = total_edges - existing_edges\n    same_part_edges = {}\n    part1_edges = 0\n    part2_edges = 0\n    part1_nodes = set()\n    part2_nodes = set()\n    \n    for i in range(1, n+1):\n        if color[i] == 0:\n            part1_nodes.add(i)\n        else:\n            part2_nodes.add(i)\n            \n    part1_size = len(part1_nodes)\n    part2_size = len(part2_nodes)\n    max_possible_edges_between_parts = part1_size * part2_size\n    existing_between_edges = m\n    \n    for i in range(1, n+1):\n        for j in graph[i]:\n            if i < j:\n                if color[i] != color[j]:\n                    pass\n                else:\n                    part1_edges += 1 if color[i] == 0 else 0\n                    part2_edges += 1 if color[i] == 1 else 0\n            else:\n                continue\n                \n    same_part_edges = {\n        0: part1_edges,\n        1: part2_edges\n    }\n    \n    total_same_part_edges = part1_edges + part2_edges\n    total_possible_same_part_edges = part1_size*(part1_size-1)//2 + part2_size*(part2_size-1)//2\n    \n    if missing_edges > 0:\n        t = 1\n        w = 0\n        for part in [0, 1]:\n            available = total_possible_same_part_edges - same_part_edges[part]\n            if available > 0:\n                w += available\n        print(f\"1 {w}\")\n    else:\n        t = 3\n        w = 0\n        if part1_size >= 3:\n            w += part1_size*(part1_size-1)*(part1_size-2)//6\n        if part2_size >= 3:\n            w += part2_size*(part2_size-1)*(part2_size-2)//6\n        print(f\"3 {w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 573,
        "completion_token_count": 1278,
        "thoughts_token_count": 1023
    }
}