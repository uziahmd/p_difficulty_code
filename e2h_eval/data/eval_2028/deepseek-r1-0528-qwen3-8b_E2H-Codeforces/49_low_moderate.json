{
    "start": 1758303163.5679727,
    "end": 1758306620.812815,
    "start-formatted": "2025-09-20 02:32 KST",
    "end-formatted": "2025-09-20 03:30 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given n (number of lawns) and m (number of roads). Then m lines, each with four numbers: a, b, gcd, lcm (the two lawns connected and the gcd and lcm for the two numbers on those lawns).\n\n We know that for two numbers x and y (on the two lawns), we have:\n   gcd(x, y) = g, lcm(x, y) = l.\n And it is known that: x * y = g^2 * (x/g) * (y/g) = g^2 * (x//g) * (y//g) = g^2 * (lcm(x,y) / g) ??? Actually, note that:\n   x * y = gcd(x, y) * lcm(x, y)\n\n But wait, actually: \n   x * y = gcd(x, y) * lcm(x, y)   [This is a standard identity]\n\n However, note that we are given that the initial numbers were at least 1 and at most 10^6.\n\n Steps:\n\n 1. We must check for consistency in each edge: \n      For an edge (a, b, g, l): we must have g divides both x and y, and l must be divisible by g, and also x*y = g*l.\n\n 2. Moreover, the entire graph must be consistent. We can think of assigning to each lawn a number.\n\n How?\n\n Observation: Let's denote by x_i the number of mushrooms on lawn i.\n\n For an edge (i, j, g, l):\n   Let x_i = g_i * d_i, x_j = g_i * d_j, where d_i and d_j are integers such that gcd(d_i, d_j) = 1.\n\n   Then, the LCM would be g_i * d_i * d_j (since d_i and d_j are coprime). So, we have:\n        g_i * d_i * d_j = l   =>   d_i * d_j = l // g_i\n\n   Also, note that the GCD is g_i, so the common part is g_i.\n\n However, note that the same lawn might appear in multiple edges and the common part (the base factor) might be different? Actually, the base factor for the entire lawn must be fixed.\n\n Alternate approach:\n\n   From the identity: x * y = g * l, and also we know that g divides both x and y, and that g divides l (because g divides x and y, so g divides any linear combination, and in particular, since x divides l? Not exactly, but note: l is the LCM, which is divisible by g).\n\n   We can write for each edge (u, v) with given gcd g and lcm l:\n        x_u * x_v = g * l.\n\n   Also, we know that g must divide both x_u and x_v.\n\n   However, note: there might be multiple constraints on one lawn. So we need to assign a value to each lawn such that for every edge (u, v, g, l):\n\n        g divides x_u and x_v, and x_u * x_v = g * l.\n\n   Additionally, we can factorize the numbers to see the prime factors.\n\n Another idea:\n\n   Let the number for each node be represented as a product of primes. But note that the constraints say that the numbers are at least 1 and at most 10^6, and the graph can have up to 1000 nodes and 2000 edges? (n, m: first line says \"n m\", and the example input has n=2, m=1 etc.)\n\n   However, the problem does not specify the bounds on n and m, but note that the GCD and LCM are at most 10^6, and the numbers on the lawns must be at least 1 and at most 10^6.\n\n   Steps:\n\n   For each edge (u, v, g, l):\n        Condition 1: g must divide l (otherwise, no solution for this edge).\n        Condition 2: The product g*l must be the product of the two numbers, and also the numbers must be multiples of g.\n\n   But note: if we set x_u and x_v, then they must satisfy:\n        x_u = g * a, x_v = g * b, and a*b = l//g, and gcd(a, b) = 1 (if we want to use the minimal representation) but actually, note that the GCD of x_u and x_v is g, so we can write:\n        g = gcd(g*a, g*b) = g * gcd(a, b)  => so gcd(a, b) must be 1.\n\n   However, wait: what if the two numbers share a factor beyond g? Then the GCD would be larger than",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn in a forest based on given roads, each specified by their GCD and LCM values. The solution involves verifying the consistency of these values across all roads and ensuring that the derived numbers for each lawn meet the given constraints.\n\n### Approach\n1. **Problem Analysis**: The problem requires us to assign a number to each lawn such that for every road connecting two lawns, the GCD and LCM of the numbers on those lawns match the given values. The key insight here is that for any two numbers \\(x\\) and \\(y\\), the product \\(x \\times y\\) must equal the product of their GCD and LCM (i.e., \\(x \\times y = \\text{GCD} \\times \\text{LCM}\\)). Additionally, the GCD must divide both numbers without leaving a remainder.\n\n2. **Graph Representation**: We model the problem as a graph where each node represents a lawn, and each edge represents a road with its associated GCD and LCM values. We then process each edge to derive potential values for the connected nodes.\n\n3. **Value Assignment**: For each edge, we compute the product of the given GCD and LCM. This product must be the product of the two numbers assigned to the connected nodes. Using this product, we derive candidate values for each node by considering the GCD constraint. Specifically, for an edge between nodes \\(u\\) and \\(v\\) with GCD \\(g\\) and LCM \\(l\\), the numbers \\(x_u\\) and \\(x_v\\) must satisfy \\(x_u = g \\times a\\) and \\(x_v = g \\times b\\), where \\(a \\times b = l / g\\) and \\(\\text{gcd}(a, b) = 1\\).\n\n4. **Consistency Check**: After deriving candidate values for all nodes, we verify if these values satisfy all given edges. If any edge's constraints are violated, the solution is impossible (\"NO\"). Otherwise, we output the derived values (\"YES\") or the first valid assignment found.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\nfrom collections import defaultdict, deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    edges = []\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g_val = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g_val, l_val))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g_val, l_val in edges:\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n        \n    assignments = [0] * n\n    candidates = [set() for _ in range(n)]\n    \n    for u, v, g_val, l_val in edges:\n        prod = g_val * l_val\n        if prod == 0:\n            print(\"NO\")\n            return\n            \n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n            \n        base = l_val // g_val\n        factors = {}\n        temp = base\n        d = 1\n        while d * d <= temp:\n            if temp % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                other = temp // d\n                factors[other] = factors.get(other, 0) + 1\n            d += 1\n            \n        for d in factors:\n            if factors[d] % 2 == 1:\n                factors[d] //= 2\n                \n        a_candidate = 1\n        for p, exp in factors.items():\n            a_candidate *= p ** exp\n            \n        b_candidate = base // a_candidate\n        \n        for i in range(2):\n            num = g_val * a_candidate\n            if i == 1:\n                num = g_val * b_candidate\n            if num < 1 or num > 10**6:\n                continue\n            if i == 0:\n                candidates[u].add(num)\n            else:\n                candidates[v].add(num)\n                \n        if len(candidates[u]) == 0 or len(candidates[v]) == 0:\n            print(\"NO\")\n            return\n            \n    for i in range(n):\n        if len(candidates[i]) == 0:\n            print(\"NO\")\n            return\n            \n    if n == 0:\n        print(\"YES\")\n        return\n        \n    assignment = [0] * n\n    used = [False] * n\n    q = deque()\n    for i in range(n):\n        if len(candidates[i]) == 1:\n            assignment[i] = next(iter(candidates[i]))\n            used[i] = True\n            q.append(i)\n            \n    while q:\n        node = q.popleft()\n        for neighbor, g_val, l_val in graph[node]:\n            if used[neighbor]:\n                continue\n            for cand in candidates[neighbor]:\n                x = assignment[node]\n                y = cand\n                if (x * y != g_val * l_val) or (x % g_val != 0) or (y % g_val != 0):\n                    continue\n                assignment[neighbor] = cand\n                used[neighbor] = True\n                q.append(neighbor)\n                break\n                \n    if any(not used[i] for i in range(n)):\n        print(\"NO\")\n        return\n        \n    print(\"YES\")\n    print(\" \".join(map(str, assignment)))\n    \nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of lawns \\(n\\) and roads \\(m\\). Each road's details (connected lawns and GCD/ LCM values) are stored in a list of edges.\n2. **Graph Construction**: A graph is built where each node is a lawn, and edges store the GCD and LCM values.\n3. **Candidate Generation**: For each edge, potential values for the connected nodes are derived by factorizing the product of the GCD and LCM. These values are stored in sets for each node.\n4. **Consistency Check**: Using a BFS approach, we propagate the candidate values through the graph, ensuring all edges' constraints are satisfied. If any node cannot be assigned a valid value, the solution is deemed impossible.\n5. **Output**: If all nodes are successfully assigned values satisfying all edge constraints, the solution outputs \"YES\" followed by the assigned values; otherwise, it outputs \"NO\".\n\nThis approach efficiently checks for the feasibility of the mushroom distribution and ensures all constraints are met using graph traversal and mathematical derivations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\nfrom collections import defaultdict, deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    edges = []\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g_val = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g_val, l_val))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g_val, l_val in edges:\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n        \n    assignments = [0] * n\n    candidates = [set() for _ in range(n)]\n    \n    for u, v, g_val, l_val in edges:\n        prod = g_val * l_val\n        if prod == 0:\n            print(\"NO\")\n            return\n            \n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n            \n        base = l_val // g_val\n        factors = {}\n        temp = base\n        d = 1\n        while d * d <= temp:\n            if temp % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                other = temp // d\n                factors[other] = factors.get(other, 0) + 1\n            d += 1\n            \n        for d in factors:\n            if factors[d] % 2 == 1:\n                factors[d] //= 2\n                \n        a_candidate = 1\n        for p, exp in factors.items():\n            a_candidate *= p ** exp\n            \n        b_candidate = base // a_candidate\n        \n        for i in range(2):\n            num = g_val * a_candidate\n            if i == 1:\n                num = g_val * b_candidate\n            if num < 1 or num > 10**6:\n                continue\n            if i == 0:\n                candidates[u].add(num)\n            else:\n                candidates[v].add(num)\n                \n        if len(candidates[u]) == 0 or len(candidates[v]) == 0:\n            print(\"NO\")\n            return\n            \n    for i in range(n):\n        if len(candidates[i]) == 0:\n            print(\"NO\")\n            return\n            \n    if n == 0:\n        print(\"YES\")\n        return\n        \n    assignment = [0] * n\n    used = [False] * n\n    q = deque()\n    for i in range(n):\n        if len(candidates[i]) == 1:\n            assignment[i] = next(iter(candidates[i]))\n            used[i] = True\n            q.append(i)\n            \n    while q:\n        node = q.popleft()\n        for neighbor, g_val, l_val in graph[node]:\n            if used[neighbor]:\n                continue\n            for cand in candidates[neighbor]:\n                x = assignment[node]\n                y = cand\n                if (x * y != g_val * l_val) or (x % g_val != 0) or (y % g_val != 0):\n                    continue\n                assignment[neighbor] = cand\n                used[neighbor] = True\n                q.append(neighbor)\n                break\n                \n    if any(not used[i] for i in range(n)):\n        print(\"NO\")\n        return\n        \n    print(\"YES\")\n    print(\" \".join(map(str, assignment)))\n    \nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1463,
        "thoughts_token_count": 1023
    }
}