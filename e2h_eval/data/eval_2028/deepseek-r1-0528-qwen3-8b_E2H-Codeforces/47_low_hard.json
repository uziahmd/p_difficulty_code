{
    "start": 1758296435.1597848,
    "end": 1758299373.318461,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (with 1 <= a,b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b (if a < b then d is negative, but we can assume without loss of generality that we set x = a+k and y = b+k, then note that |x-y| = |a-b| is fixed.\n\nLet g = gcd(a+k, b+k). Then, note that:\n  LCM(a+k, b+k) = (a+k)*(b+k) / g\n\nBut note that g must divide both (a+k) and (b+k). Also, note that the difference between the two numbers is (a+k) - (b+k) = a - b (if a>=b) or (b+k)-(a+k)=b-a (if b>=a). So the gcd must divide |a-b|.\n\nTherefore, we can think of the problem as: we are looking for k such that the two numbers x = a+k and y = b+k have a large gcd (so that the product divided by the gcd is minimized). However, note that the product (a+k)*(b+k) also increases with k. There is a trade-off.\n\nAlternatively, we can consider the following:\n\nLet d0 = |a-b|. Then, the gcd g must be a divisor of d0. Moreover, note that if we let d = g, then we require that d divides (a+k) and (b+k). Since d divides (a+k) and (b+k), then d divides (a+k) - (b+k) = a-b (or b-a). So d must divide |a-b|.\n\nNow, let d be a divisor of |a-b| (if a != b). Then, we can set up equations for k:\n\nWe require that (a+k) ≡ 0 (mod d) and (b+k) ≡ 0 (mod d). This implies that k ≡ (-a) mod d and k ≡ (-b) mod d. But note that since d divides (a-b), then (-a) mod d is the same as (-b) mod d? Actually, because d divides (a-b), we have a ≡ b (mod d). Therefore, we only require one congruence: k ≡ (-a) mod d.\n\nMoreover, we can write k = t*d - a (for some t) but note that k must be non-negative. Alternatively, k must be at least max(ceil((a mod d)/d)? Actually, we can set k_min(d) = (d - (a % d)) % d, but if a % d == 0 then k_min(d)=0, else k_min(d)= d - (a % d). However, note that we require both a+k and b+k to be divisible by d. Since a ≡ b (mod d), then if k is chosen as the smallest non-negative solution for k ≡ (-a) mod d, then it automatically satisfies k ≡ (-b) mod d.\n\nBut wait: what if a==b? Then d0=0. We cannot use divisors of 0. In that case, we have a special case.\n\nCase 1: a == b.\n  Then, we are to minimize LCM(a+k, a+k) = a+k. The smallest value is when k=0, so answer is 0.\n\nCase 2: a != b.\n  Then, we consider all divisors d of |a-b| (including negative divisors? No, positive divisors). For each divisor d (positive) of |a-b|, we can compute the smallest non-negative k that satisfies k ≡ (-a) mod d. That is, k_d = (d - (a % d)) % d. But note: if a % d == 0, then (d - (a%d)) % d = 0. Otherwise, we get a positive number.\n\nHowever, note: we are not limited to divisors that are positive? The divisors of |a-b| are usually taken as positive. But note: the gcd is positive, so we only consider positive divisors.\n\nBut wait: is every divisor d of |a-b| giving a valid candidate? Yes, because then k_d is the smallest non-negative k such that d divides (a+k) and (b+k). Then, for this k_d, the two numbers become multiples of d. Then the LCM would be (a+k_d)*(b+k_d)/d.\n\nBut note: the gcd might actually be larger than d? Because the gcd of two numbers that are multiples of d might be more than",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Special Case Handling (a == b):** If \\( a \\) and \\( b \\) are equal, the LCM of \\( a + k \\) and \\( b + k \\) simplifies to \\( a + k \\). The smallest value occurs when \\( k = 0 \\).\n2. **Divisor Analysis (a != b):** For \\( a \\neq b \\), the difference \\( d = |a - b| \\) is fixed. The LCM of \\( a + k \\) and \\( b + k \\) can be expressed in terms of their greatest common divisor (GCD). The GCD must be a divisor of \\( d \\). \n3. **Finding Valid k Values:** For each divisor \\( d \\) of \\( |a - b| \\), compute the smallest non-negative \\( k \\) such that \\( d \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is derived from the congruence \\( k \\equiv (-a) \\mod d \\).\n4. **Minimizing LCM:** For each valid \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\). Track the \\( k \\) that yields the smallest LCM, choosing the smallest \\( k \\) in case of ties.\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    n = abs(n)\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d_abs = abs(a - b)\n    divisors = get_divisors(d_abs)\n    candidates = set()\n    \n    for d in divisors:\n        rem_a = a % d\n        if rem_a == 0:\n            k_candidate = 0\n        else:\n            k_candidate = d - (a % d)\n        candidates.add(k_candidate)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        g = math.gcd(x, y)\n        current_lcm = x * y // g\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input:** The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling:** If \\( a \\) equals \\( b \\), the answer is \\( 0 \\) because adding any positive \\( k \\) would increase the LCM.\n3. **Divisor Calculation:** For \\( a \\neq b \\), compute all positive divisors of \\( |a - b| \\).\n4. **Candidate Generation:** For each divisor \\( d \\), compute the smallest non-negative \\( k \\) such that \\( d \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is found using modular arithmetic.\n5. **LCM Evaluation:** For each candidate \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\). Track the \\( k \\) that results in the smallest LCM, ensuring the smallest \\( k \\) is chosen if there are ties.\n6. **Output:** Print the optimal \\( k \\) found.\n\nThis approach efficiently narrows down the problem to evaluating only relevant divisors and their corresponding \\( k \\) values, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    n = abs(n)\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d_abs = abs(a - b)\n    divisors = get_divisors(d_abs)\n    candidates = set()\n    \n    for d in divisors:\n        rem_a = a % d\n        if rem_a == 0:\n            k_candidate = 0\n        else:\n            k_candidate = d - (a % d)\n        candidates.add(k_candidate)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        g = math.gcd(x, y)\n        current_lcm = x * y // g\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 944,
        "thoughts_token_count": 1023
    }
}