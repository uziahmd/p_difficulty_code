{
    "start": 1758088076.870209,
    "end": 1758089220.3003476,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of [l, r, cost]\n Conditions:\n   Two vouchers i and j (i != j) such that:\n     1. They don't intersect: either ri < lj or rj < li.\n     2. The sum of durations is exactly x: (ri - li + 1) + (rj - lj + 1) = x.\n\n We are to find the minimal total cost.\n\n Steps:\n\n 1. Note: duration_i = d_i = (r_i - l_i + 1). Then we need two vouchers with durations d1 and d2 such that d1 + d2 = x.\n\n 2. We can group vouchers by their duration. However, note that the condition for disjointness is more complex.\n\n 3. Let's denote:\n        For voucher i: (l_i, r_i, cost_i, duration_i)\n\n 4. Since the total duration must be x, we can consider for each voucher with duration d, we are looking for a voucher with duration x-d.\n\n 5. But the vouchers must not intersect. There are two conditions for non-intersection: \n        Condition 1: r_i < l_j   (voucher i ends before j starts)\n        Condition 2: r_j < l_i   (voucher j ends before i starts)\n\n 6. So if we have two vouchers (i, j) with durations d1 and d2 (d1+d2=x), we require that either:\n        (a) The first voucher ends before the second starts: r_i < l_j, OR\n        (b) The second voucher ends before the first starts: r_j < l_i.\n\n 7. We can try to preprocess the vouchers by grouping by duration.\n\n 8. However, the constraints (n, x up to 200,000) and the fact that the days are up to 200,000 suggest we need an efficient solution.\n\n Approach:\n\n We can do:\n\n   Step 1: Group all vouchers by duration. Let's create a dictionary or list of lists where key is duration, value is a list of (l, r, cost) for that duration.\n\n   Step 2: For each duration d, we are going to look for the complementary duration x-d. But note: if d == x-d, then we are looking for two distinct vouchers (same duration) that do not overlap.\n\n   Step 3: How to check for non-overlapping without iterating over all pairs?\n\n   Idea: For each voucher, we can store its (l, r, cost). Then, for a fixed pair of durations (d, x-d), we have two groups. We want to find two vouchers (one from the first group, one from the second) that do not intersect.\n\n   However, the non-intersection condition can be broken down as:\n        Condition (a): r1 < l2   (for the first voucher ending before the second starts)\n        Condition (b): r2 < l1   (for the second voucher ending before the first starts)\n\n   Alternatively, we can rephrase: the two intervals [l1, r1] and [l2, r2] are disjoint if they do not overlap, which is equivalent to:\n        max(r1, r2) < min(l1, l2)   ? Actually no, the condition is: two intervals [a,b] and [c,d] are disjoint if b < c or d < a.\n\n   But note: we have two conditions: (r1 < l2) OR (r2 < l1). This is the same as: the two intervals do not share any point.\n\n   Step 4: We can precompute for each group (each duration) some data structure that allows us to quickly query for a given interval (from the other group) whether there exists a voucher that does not intersect.\n\n   However, note that the problem requires the minimal total cost.\n\n   Alternatively, we can consider:\n\n   For each duration d, we have a set of vouchers. We want to combine with the set for x-d. But how?\n\n   We can break the problem into two cases:\n\n   Case 1: d1 != d2 (where d1 = d, d2 = x-d, and d1 != d2)\n        We are looking for a voucher in group d1: (l1, r1, cost1) and a voucher in group d2: (l2, r2, cost2) such that either r1 < l2 or r2 < l1.\n\n        And we want to minimize cost1 + cost2.\n\n   Case 2: d1 == d2 (then d*2 = x, so d = x/2) then we are looking for two distinct vouchers in the same group that do not overlap.\n\n   How to handle Case 1:\n\n        Without",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Grouping by Duration**: First, we group all vouchers by their duration. This allows us to efficiently look for pairs of vouchers whose durations sum up to `x`.\n2. **Handling Different Durations**: For each voucher with duration `d`, we look for another voucher with duration `x - d`. The non-overlapping condition (either the first voucher ends before the second starts or vice versa) must be satisfied.\n3. **Handling Same Durations**: If `x` is even, we might need to consider two vouchers with the same duration `x/2`. Here, we ensure they do not overlap.\n4. **Efficient Search**: For each group of vouchers (same duration), we sort them by their end date. This helps in quickly finding a voucher that does not overlap with another using binary search.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost))\n        \n    groups = {}\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        if dur not in groups:\n            groups[dur] = []\n        groups[dur].append((l, r, cost))\n        \n    ans = float('inf')\n    \n    for dur, v_list in list(groups.items()):\n        if dur * 2 == x:\n            v_list_sorted = sorted(v_list, key=lambda x: x[1])\n            costs = [cost for _, _, cost in v_list_sorted]\n            ends = [r for _, r, _ in v_list_sorted]\n            m = len(ends)\n            for i in range(m):\n                r1 = ends[i]\n                target_start = r1 + 1\n                j = bisect_right(ends, target_start, lo=i+1) - 1\n                if j < m:\n                    candidate_cost = costs[i] + costs[j]\n                    if candidate_cost < ans:\n                        ans = candidate_cost\n                else:\n                    continue\n        else:\n            complement = x - dur\n            if complement in groups:\n                list1 = groups[dur]\n                list2 = groups[complement]\n                if dur < complement:\n                    list1, list2 = list2, list1\n                    \n                list1_sorted = sorted(list1, key=lambda x: x[1])\n                list2_sorted = sorted(list2, key=lambda x: x[0], reverse=True)\n                \n                ends1 = [r for _, r, _ in list1_sorted]\n                starts2 = [l for l, _, _ in list2_sorted]\n                \n                for i in range(len(list1_sorted)):\n                    l1, r1, cost1 = list1_sorted[i]\n                    if r1 < list2_sorted[0][0]:\n                        candidate = cost1 + list2_sorted[0][2]\n                        if candidate < ans:\n                            ans = candidate\n                    else:\n                        target_start = r1 + 1\n                        pos = bisect_right(starts2, target_start)\n                        if pos < len(list2_sorted):\n                            cost2_val = list2_sorted[pos][2]\n                            candidate = cost1 + cost2_val\n                            if candidate < ans:\n                                ans = candidate\n                                \n                list1_sorted = sorted(list1, key=lambda x: x[0], reverse=True)\n                list2_sorted = sorted(list2, key=lambda x: x[1])\n                \n                ends1 = [r for _, r, _ in list1_sorted]\n                starts2 = [l for l, _, _ in list2_sorted]\n                \n                for i in range(len(list1_sorted)):\n                    l1, r1, cost1 = list1_sorted[i]\n                    if r1 < list2_sorted[0][0]:\n                        candidate = cost1 + list2_sorted[0][2]\n                        if candidate < ans:\n                            ans = candidate\n                    else:\n                        target_start = r1 + 1\n                        pos = bisect_right(starts2, target_start)\n                        if pos < len(list2_sorted):\n                            cost2_val = list2_sorted[pos][2]\n                            candidate = cost1 + cost2_val\n                            if candidate < ans:\n                                ans = candidate\n                        \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into a list of vouchers, each characterized by its start day, end day, and cost.\n2. **Grouping Vouchers**: Vouchers are grouped by their duration (end day - start day + 1). This helps in efficiently finding pairs of vouchers whose durations sum to `x`.\n3. **Handling Same Durations**: If `x` is even, we look for two vouchers with the same duration. These vouchers must not overlap, meaning one must end before the other starts. We sort these vouchers by their end dates and use binary search to find non-overlapping pairs.\n4. **Handling Different Durations**: For each voucher duration `d`, we check for a complementary duration `x - d`. We sort one group by end dates and the other by start dates to efficiently find non-overlapping pairs using binary search.\n5. **Result Calculation**: The minimal cost found during the search is printed. If no valid pair is found, `-1` is printed.\n\nThis approach efficiently narrows down the search space using grouping and sorting, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost))\n        \n    groups = {}\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        if dur not in groups:\n            groups[dur] = []\n        groups[dur].append((l, r, cost))\n        \n    ans = float('inf')\n    \n    for dur, v_list in list(groups.items()):\n        if dur * 2 == x:\n            v_list_sorted = sorted(v_list, key=lambda x: x[1])\n            costs = [cost for _, _, cost in v_list_sorted]\n            ends = [r for _, r, _ in v_list_sorted]\n            m = len(ends)\n            for i in range(m):\n                r1 = ends[i]\n                target_start = r1 + 1\n                j = bisect_right(ends, target_start, lo=i+1) - 1\n                if j < m:\n                    candidate_cost = costs[i] + costs[j]\n                    if candidate_cost < ans:\n                        ans = candidate_cost\n                else:\n                    continue\n        else:\n            complement = x - dur\n            if complement in groups:\n                list1 = groups[dur]\n                list2 = groups[complement]\n                if dur < complement:\n                    list1, list2 = list2, list1\n                    \n                list1_sorted = sorted(list1, key=lambda x: x[1])\n                list2_sorted = sorted(list2, key=lambda x: x[0], reverse=True)\n                \n                ends1 = [r for _, r, _ in list1_sorted]\n                starts2 = [l for l, _, _ in list2_sorted]\n                \n                for i in range(len(list1_sorted)):\n                    l1, r1, cost1 = list1_sorted[i]\n                    if r1 < list2_sorted[0][0]:\n                        candidate = cost1 + list2_sorted[0][2]\n                        if candidate < ans:\n                            ans = candidate\n                    else:\n                        target_start = r1 + 1\n                        pos = bisect_right(starts2, target_start)\n                        if pos < len(list2_sorted):\n                            cost2_val = list2_sorted[pos][2]\n                            candidate = cost1 + cost2_val\n                            if candidate < ans:\n                                ans = candidate\n                                \n                list1_sorted = sorted(list1, key=lambda x: x[0], reverse=True)\n                list2_sorted = sorted(list2, key=lambda x: x[1])\n                \n                ends1 = [r for _, r, _ in list1_sorted]\n                starts2 = [l for l, _, _ in list2_sorted]\n                \n                for i in range(len(list1_sorted)):\n                    l1, r1, cost1 = list1_sorted[i]\n                    if r1 < list2_sorted[0][0]:\n                        candidate = cost1 + list2_sorted[0][2]\n                        if candidate < ans:\n                            ans = candidate\n                    else:\n                        target_start = r1 + 1\n                        pos = bisect_right(starts2, target_start)\n                        if pos < len(list2_sorted):\n                            cost2_val = list2_sorted[pos][2]\n                            candidate = cost1 + cost2_val\n                            if candidate < ans:\n                                ans = candidate\n                        \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 734,
        "completion_token_count": 1271,
        "thoughts_token_count": 1023
    }
}