{
    "start": 1758294376.6001499,
    "end": 1758296495.5972707,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:41 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given up to 10 spaceships and 10 bases. The problem is to check if there exists a perfect matching (i.e., a bijection) between the R spaceships and B bases such that the straight lines connecting each spaceship to its base do not intersect.\n\n Since R and B are at most 10, we can consider using a combinatorial matching approach. However, note that the condition of non-intersecting paths is geometric.\n\n Observation:\n We have 2R+2B points (R spaceships and B bases). The condition is that the set of segments (each segment from a spaceship to a base) must not intersect.\n\n But note: we are assigning exactly one spaceship to one base. There might be multiple ways to assign, but we require that in the chosen assignment, the segments do not cross.\n\n However, note that the problem does not require the entire set of segments to be drawn without any crossings? Actually, the problem says: \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\".\n\n Important: The problem states that the assignment is a perfect matching (so every base has one guardian and every spaceship has one base). And the condition is that the straight lines (the segments) do not intersect.\n\n But note: the example input and output.\n\n However, note that the problem says \"any two (straight) paths\", meaning if we draw the segments for the matched pairs, then no two segments should intersect (except possibly at endpoints? but the problem says \"in the galaxy plane\", and typically we consider proper intersections).\n\n But note: the problem also states that no three points are collinear and no two points coincide.\n\n How to approach?\n\n Since R, B <= 10, the total number of points is at most 20. The matching is a set of R (or B) non-intersecting segments.\n\n However, note: the problem does not require that the entire drawing is planar? Actually, it requires that the matching (the set of segments) is non-intersecting (except at endpoints). But note: two segments that share an endpoint are allowed? The problem says \"any two (straight) paths\" - so even if they share an endpoint, that is allowed because the paths start at the base and go to the spaceship, and the base is shared by two? Actually, wait: each base is assigned exactly one spaceship, so the base is an endpoint of exactly one segment. Similarly, each spaceship is an endpoint of exactly one segment. Therefore, two segments cannot share an endpoint because the endpoints are distinct: the set of endpoints for bases are the base points and for spaceships are the spaceship points. So the two sets are disjoint.\n\n Therefore, the segments do not share endpoints.\n\n Now, the problem is: given two sets of points (spaceships and bases), is there a perfect matching (one-to-one) such that the segments connecting them do not cross?\n\n This is similar to the problem of drawing non-crossing bipartite matchings. However, note that the two sets are not necessarily on two parallel lines.\n\n Alternate idea:\n\n We can use the following known fact: In a set of points with no three collinear, a set of segments is non-crossing if and only if it is a planar straight-line graph (PSLG) and the matching is non-crossing.\n\n However, we are to assign all spaceships to bases. We have two sets: S (spaceships) and B (bases). We want a matching M (a bijection) such that for any two edges (s1, b1) and (s2, b2) in M, they do not cross.\n\n Conditions for two segments (a1, b1) and (a2, b2) to not cross: \n   They do not intersect at a point that is not an endpoint.\n\n There is a known computational geometry fact: non-crossing bipartite matching can be found by considering the convex hulls or by using a greedy method? But note the small constraints.\n\n Steps:\n\n 1. Check if there is a perfect matching (bipartite matching) in terms of graph existence? Actually, we are not limited by graph structure (all points are available) but by the condition that the segments must not cross.\n\n 2. We can try all possible matchings? There are R! (factorial) possibilities. Since R, B <= 10, the maximum factorial is 10! = 3628800, which is acceptable.\n\n However, we must check for crossing conditions for each matching.\n\n But wait: what is the condition for two segments to cross?\n\n Two segments (a, b) and (c, d) (with a, b, c, d being distinct points) cross if the points are interleaved. Specifically, the orientation of the quadruple (a, b, c, d) must be such that the points are in alternating order",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking all possible perfect matchings between the given spaceships and bases to see if any of them satisfy the non-intersecting condition.\n\n### Approach\n1. **Problem Analysis**: The problem requires us to find a bijection between two sets of points (spaceships and bases) such that the segments connecting each pair do not intersect. Given the constraints (R and B are at most 10), we can afford to check all possible permutations of assignments.\n2. **Key Insight**: For each permutation of assigning spaceships to bases, we need to verify that no two segments intersect. Two segments intersect if the endpoints of one segment are on opposite sides of the other segment's line.\n3. **Algorithm Selection**: We generate all possible permutations of base assignments for the spaceships. For each permutation, we check all pairs of segments to ensure they do not intersect. If any permutation satisfies the condition, we return \"Yes\"; otherwise, we return \"No\".\n4. **Complexity Analysis**: The number of permutations is R! (factorial of R), which for R=10 is 3,628,800. For each permutation, we check up to C(R,2) pairs of segments, where C(n,2) is n*(n-1)/2. With R=10, this is 45 checks per permutation. Thus, the total operations are manageable within the constraints.\n\n### Solution Code\n```python\nimport itertools\n\ndef orientation(a, b, c):\n    val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n    return val\n\ndef do_segments_intersect(seg1, seg2):\n    (a, b) = seg1\n    (c, d) = seg2\n    \n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if ((o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0)) and ((o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0)):\n        return True\n        \n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n        \n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    it = iter(data)\n    R = int(next(it)); B = int(next(it))\n    spaceships = []\n    for i in range(R):\n        x = int(next(it)); y = int(next(it))\n        spaceships.append((x, y))\n        \n    bases = []\n    for i in range(B):\n        x = int(next(it)); y = int(next(it))\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    if R == 0:\n        print(\"Yes\")\n        return\n        \n    perms = list(itertools.permutations(range(B)))\n    \n    def check_permutation(perm):\n        segs = []\n        for i, ship_idx in enumerate(spaceships):\n            base_idx = bases[perm[i]]\n            segs.append((ship_idx, base_idx))\n            \n        for i in range(len(segs)):\n            for j in range(i+1, len(segs)):\n                if do_segments_intersect(segs[i], segs[j]):\n                    return False\n        return True\n        \n    found = False\n    for perm in perms:\n        if check_permutation(perm):\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **orientation(a, b, c)**: This function calculates the orientation of three points. It returns positive, negative, or zero indicating whether point c lies to the clockwise, counterclockwise, or collinear side of the line from a to b.\n2. **do_segments_intersect(seg1, seg2)**: This function checks if two segments intersect by verifying if their endpoints are on opposite sides of each other's lines. If any endpoint lies on the line, the segments are considered non-intersecting.\n3. **main()**: Reads input data, processes the coordinates of spaceships and bases, and checks if there is a perfect matching. It generates all permutations of base assignments and checks each permutation for non-intersecting segments using the `do_segments_intersect` function. If any permutation satisfies the condition, it prints \"Yes\"; otherwise, it prints \"No\".\n\nThis approach efficiently checks all possible matchings by leveraging permutations and geometric intersection checks, ensuring correctness within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef orientation(a, b, c):\n    val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n    return val\n\ndef do_segments_intersect(seg1, seg2):\n    (a, b) = seg1\n    (c, d) = seg2\n    \n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if ((o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0)) and ((o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0)):\n        return True\n        \n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n        \n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    it = iter(data)\n    R = int(next(it)); B = int(next(it))\n    spaceships = []\n    for i in range(R):\n        x = int(next(it)); y = int(next(it))\n        spaceships.append((x, y))\n        \n    bases = []\n    for i in range(B):\n        x = int(next(it)); y = int(next(it))\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    if R == 0:\n        print(\"Yes\")\n        return\n        \n    perms = list(itertools.permutations(range(B)))\n    \n    def check_permutation(perm):\n        segs = []\n        for i, ship_idx in enumerate(spaceships):\n            base_idx = bases[perm[i]]\n            segs.append((ship_idx, base_idx))\n            \n        for i in range(len(segs)):\n            for j in range(i+1, len(segs)):\n                if do_segments_intersect(segs[i], segs[j]):\n                    return False\n        return True\n        \n    found = False\n    for perm in perms:\n        if check_permutation(perm):\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 1075,
        "thoughts_token_count": 1023
    }
}