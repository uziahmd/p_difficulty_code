{
    "start": 1758300080.582129,
    "end": 1758303940.2314086,
    "start-formatted": "2025-09-20 01:41 KST",
    "end-formatted": "2025-09-20 02:45 KST",
    "gpu": 2,
    "pid": 53,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# You're Given a String...\n\nYou're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).\n\n## Input\nThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n\n## Output\nOutput one number â€” length of the longest substring that can be met in the string at least twice.\n\n## Example\n### Input\n['abcd', 'ababa', 'zzz']\n\n### Output\n['0', '3', '2']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n We are guaranteed the string length is at most 100, so we can use a straightforward approach.\n However, note: we need the longest substring that appears at least twice (and these occurrences can overlap).\n\n Steps:\n 1. We can consider all substrings and check for duplicates. But note: the problem asks for the longest one.\n\n Alternate approach:\n   - We can iterate over possible lengths from the maximum possible down to 1, and check if there exists a substring of that length that appears at least twice.\n\n But note: the entire string might be up to 100, so the maximum length of substring we can have is 50 (because two non-overlapping? but note: they can overlap). Actually, the maximum length we can get is floor(n/2) if we require two distinct occurrences? However, note: even with overlapping, the same substring can occur multiple times. But we are looking for two occurrences (which may overlap). For example, in \"aaa\", the substring \"aa\" occurs three times.\n\n However, note: the problem says \"at least twice\". So we are to find the maximum L such that there exists a substring of length L that appears at least twice.\n\n But note: the two occurrences must be in the string. Since the string length is at most 100, we can try:\n\n Approach 1: \n   For length L from n//2 down to 1 (but actually we can go from min(n-1, ...) down to 1, but note: the maximum possible duplicate substring length cannot exceed floor(n/2) if we require two non-overlapping? Actually, no: the two occurrences can overlap arbitrarily. However, consider: the entire string is of length n. The same substring of length L can appear at positions i and j (with i < j) as long as j-i >= L? Actually, no: for overlapping, we don't require that much separation. For example, in \"ababa\", the substring \"aba\" appears starting at index0 and index2. The two occurrences overlap by two characters.\n\n How to check for a given L: we can extract all contiguous substrings of length L and use a set to see if any substring appears more than once.\n\n However, note: we are to find the maximum L for which there is at least one substring that appears at least twice.\n\n But wait: what is the maximum L? It cannot be more than n-1 (if n>=2) because if L = n, then we have only one substring. So maximum L is n-1? Actually, if we have two identical consecutive characters, then L=1 is the minimal, and the maximum L for which we can have two occurrences is at most n-1? Actually, no: two occurrences of a substring of length L must have two starting indices i and j such that the substring from i to i+L-1 equals the substring from j to j+L-1. The condition on indices is that j can be from i+1 to ... but note: the substring must not run beyond the string. The maximum L for which two occurrences can exist is when the two occurrences start at different indices and the substring doesn't go out of bounds. However, the two occurrences must lie entirely in the string. The maximum L for which two occurrences are possible is when the two occurrences are as close as possible (overlapping). The maximum L can be up to floor((n+1)/2) ??? Actually, let's think:\n\n Example: string \"abcabc\" (n=6). The longest substring that appears at least twice is \"abc\", length 3. But note: we can have two occurrences of \"abc\" at indices0 and indices3. Also, we can have \"abca\" (length4) but that only appears once. Similarly, \"abcab\" (length5) only once. \n\n However, consider a string like \"aaaaa\": \n   Substrings of length 4: \"aaaa\", \"aaaa\" -> two occurrences? Actually, in \"aaaaa\", the substring \"aaaa\" appears at index0 and index1. So for n=5, maximum L is 4.\n\n But note: the two occurrences must be two distinct occurrences. In \"aaaaa\", \"aaaa\" appears at [0:4] and [1:5]. These are two distinct occurrences (even though they overlap).\n\n Therefore, the maximum L we can have is n-1. However, if we take L = n, then we only have one substring. So we look for L from n-1 down to 1.\n\n But wait: if the entire string is of length n, then the maximum substring length that can appear twice is n-1, because the two occurrences would require two starting indices i and j (with j>=i+1) and the substring from i to i+n-2 must equal from j to j+n-2. But the first substring goes from i to i+n-2 (which is the last character at index i+n-2) and the second from j to j+n-2. The condition for j is j <= n - (n-1) = 1? Actually, the second occurrence must end by n-1, so j + (n-1) - 1 <= n-1 => j <= 1. So for example, in a string of length n, the substring of length n-1 can appear at index0 and index1. But if the string is \"abcde\", then at index0: \"abcd\", at index1: \"bcde\". These are different. So we have to check.\n\n However, the problem does not require the two occurrences to be non-overlapping. They can overlap arbitrarily.\n\n So algorithm:\n\n Let n = len(s)\n We are going to check for L from n-1 down to 1:\n\n   Create an empty dictionary (or set) to record the substrings and their starting indices (but we don't need the indices, just whether we've seen the substring at least twice).\n\n   Actually, we can do:\n\n   seen = {}\n   for start index i from 0 to n-L:\n        substring = s[i:i+L]\n        if substring in seen:\n            then we found a duplicate for length L -> so we output L and break.\n        else:\n            seen[substring] = True   (or just store the substring and then check for duplicates)\n\n   But wait, we are iterating for each L. We want the maximum L for which there is at least one duplicate.\n\n   Alternatively, we can do:\n\n   for L in range(n-1, 0, -1):\n        found = False\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                found = True\n                break\n            else:\n                seen.add(substr)\n        if found:\n            print(L)\n            exit(0)\n\n   If we don't find any for any L, then print 0.\n\n However, worst-case: we are iterating from L = n-1 down to 1, and for each L we iterate over O(n) substrings, each substring operation is O(L). The total complexity is O(n^3) which is acceptable for n<=100 (since 100^3 = 1e6, which is acceptable in Python).\n\n But note: we can optimize by breaking early when we find a duplicate for a given L.\n\n However, let me test with the examples:\n\n Example 1: 'abcd'\n   n=4, so we check L=3: \n        substrings: 'abc', 'bcd' -> no duplicate -> then L=2: 'ab','bc','cd' -> no duplicate -> L=1: 'a','b','c','d' -> no duplicate -> output 0.\n\n Example 2: 'ababa'\n   n=5, check L=4: \n        substrings: 'abab', 'baba' -> no duplicate.\n        L=3: \n            'aba', 'bab', 'aba' -> found 'aba' twice -> output 3.\n\n Example 3: 'zzz'\n   n=3, check L=2: \n        'zz', 'zz' -> duplicate -> output 2.\n\n But wait, in the example input: \n        Input: ['abcd', 'ababa', 'zzz']\n        Expected Output: ['0', '3', '2']\n\n This matches.\n\n However, note: the problem says the string is given as the first input line. We are to read from stdin.\n\n But wait: the example input is given as a list of strings? Actually, the problem says:\n\n        Input: \n          ['abcd', 'ababa', 'zzz']\n\n        Output:\n          ['0', '3', '2']\n\n This is just showing examples. We are to read one string.\n\n Actually, the problem states: \n        The first input line contains the string.\n\n So we read one string.\n\n Let's code accordingly.\n\n However, note: the example input format is shown as a list, but we are reading from stdin. The sample test cases are provided for clarity.\n\n Implementation:\n\n   s = input().strip()\n\n   n = len(s)\n   # If the string is empty, then output 0. But guaranteed non-empty.\n\n   # We'll iterate L from n-1 down to 1.\n\n   # But wait: what if the string has duplicate characters? We are checking for two occurrences.\n\n   However, note: the problem says \"at least twice\", so two or more.\n\n   Our method: for a fixed L, we are storing the substrings we've seen. When we see a substring that is already in the set, we break and return L.\n\n   But note: it's possible that the same substring appears more than twice, but we only need two.\n\n   Edge: what if the string is all same character? e.g., \"aaa\"\n        n=3, L from 2 down to 1.\n        L=2: substrings: \"aa\", \"aa\" -> duplicate -> output 2.\n\n   This is correct.\n\n   However, what if the string is \"a\"? Then n=1, then we check L from 0? But our loop starts from n-1=0. Then we check L=0: but substring of length 0? The problem doesn't specify, but note: the string is non-empty, so n>=1. The problem says the string is non-empty. And the output for a string of length 1: we check L=0? Actually, we start from n-1=0, then we check L=0: \n        substring of length 0: the empty string. But the problem says \"at least twice\": the empty string appears many times? But the problem says the string is non-empty and consists of lower-case Latin letters. And the problem is about contiguous substring. The empty substring is always present, but the problem likely doesn't consider the empty substring because the problem says \"longest substring\", and typically we consider non-empty. Moreover, the example outputs: for \"abcd\" (length4) output 0.\n\n   But note: the example input \"abcd\" gives 0. Why? Because the longest substring that appears at least twice is 0? That implies that we are considering the empty substring? However, the problem says \"longest substring\", and the empty substring is the shortest. \n\n   But the problem statement says: the substring must be met at least twice. The empty substring is met many times (every gap between characters and at the beginning and end). However, the problem says \"longest\", so if we have the empty substring (length0) then we are returning 0.\n\n   However, note: the problem says \"non-empty\" string, but the substring can be empty? Typically in competitive programming, substring usually means contiguous part of the string and often includes the empty substring. But the problem does not explicitly say non-empty substring.\n\n   Let me check the example: \"abcd\" -> output 0. So the answer is 0. That implies that the problem considers the empty substring.\n\n   But wait: the problem says \"longest substring\", and if we have the empty substring, then the answer is 0. However, the problem also says \"the string is non-empty\", so we don't have to worry about the whole string being empty.\n\n   However, the problem says \"at least twice\". The empty substring appears infinitely many times (in theory) in the string. But in practice, we are limited by the positions. In a string of length n, the empty substring appears n+1 times (if we consider every gap). So yes, it appears at least twice.\n\n   But then why is the answer for \"abcd\" 0? Because 0 is the length of the empty substring, and it is the longest substring that appears at least twice? \n\n   However, wait: the empty substring has length 0, and there is no substring of length 1 that appears at least twice (because all characters are distinct). So 0 is the answer.\n\n   But is the empty substring allowed? The problem statement says \"substring\", and typically substring problems allow empty substring. However, sometimes they don't. The problem says: \"The following is a competitive programming problem.\" and the example input 'abcd' returns 0.\n\n   Let me check the sample: \n        Input: 'abcd' -> output 0.\n\n   But wait, the problem says: \"longest substring\". If we allow empty substring, then 0 is the answer for any string with no repeated substring of positive length.\n\n   However, the problem says \"can be met in the string at least twice\". The empty substring is met, but is that considered? \n\n   According to the problem sample, yes.\n\n   But note: the problem says \"These occurrences can overlap\". The empty substring can overlap? Actually, the empty substring occurs at every position, so it can be considered to overlap arbitrarily.\n\n   Therefore, our solution must account for the empty substring.\n\n   However, note: our current method for L=0: \n        We are iterating L from n-1 down to 1, so we never check L=0.\n\n   But wait: in the example \"abcd\", we didn't check L=0. Then how did we get 0?\n\n   Actually, we break out of the loop and then if we don't find any L from n-1 down to 1, we output 0. That 0 is the minimum value we are checking (we start from n-1 and go down to 1, and if none of those work, then the next candidate is 0). \n\n   However, note: the empty substring (L=0) is always present. But our algorithm doesn't check L=0. So we must account for that.\n\n   But wait: our loop goes from n-1 down to 1. Then after the loop, we output 0. That 0 is the length of the empty substring.\n\n   However, the problem says the string is non-empty. The empty substring is always present (at least twice). So the answer should be 0 for any string that has no repeated substring of positive length.\n\n   But wait, is the empty substring considered a substring? In many definitions, yes. However, sometimes problems specify non-empty. The problem does not specify.\n\n   But the example output for \"abcd\" is 0.\n\n   Therefore, we must consider the empty substring.\n\n   However, note: the problem says \"longest substring\", and the empty substring is the shortest. So if there is a non-empty substring that appears at least twice, then we return the maximum positive L. Otherwise, we return 0.\n\n   Our algorithm currently does:\n\n        for L in range(n-1, 0, -1):   # This goes from n-1 down to 1 (inclusive)\n            ... check for duplicate ...\n\n        if we break inside the loop, we output the L and exit.\n\n        Otherwise, we finish the loop and then we output 0.\n\n   This 0 is the length of the empty substring.\n\n   But wait, the empty substring has length 0, and we are not checking L=0. However, the problem requires the longest substring that appears at least twice. The empty substring is one such substring, and if no positive-length substring appears twice, then the answer is 0.\n\n   But note: the problem does not say the substring must be non-empty.\n\n   Therefore, our algorithm is correct.\n\n   However, let me test with a string that has a repeated positive-length substring and also the empty substring. The answer should be the positive one.\n\n   Example: \"aaa\": \n        We check L=2: duplicate -> output 2.\n\n   Example: \"aabb\": \n        Check L=3: \n            \"aab\", \"abb\" -> no duplicate.\n        L=2: \n            \"aa\", \"ab\", \"bb\" -> no duplicate? Actually, wait: \n            \"aa\" appears once, \"ab\" once, \"bb\" once -> no duplicate for L=2.\n        Then we output 0.\n\n   But wait: in \"aabb\", the substring \"a\" appears at least twice (at index0 and index3) and \"b\" appears at least twice (index2 and index3). So we should output 1.\n\n   However, our algorithm checks from L=3 down to 1. At L=1: \n        We consider all substrings of length1: \n            'a','a','b','b'\n        We will see:\n            first 'a' -> add to set\n            second 'a' -> already in set -> duplicate found -> output 1.\n\n   So that is correct.\n\n   Correction: I made a mistake above. In \"aabb\", for L=1 we have four substrings: 'a','a','b','b'. We will find the first 'a' and then the second 'a' is duplicate, so we break and output 1.\n\n   But wait, in the example \"aabb\", the two occurrences of 'a' are non-overlapping? Actually, the two 'a's are at index0 and index1? Wait, the string is \"aabb\": \n        indices: 0:'a', 1:'a', 2:'b', 3:'b'\n\n   So the substring 'a' appears at index0 and index1 (two consecutive 'a's). \n\n   However, note: we are considering contiguous substrings. The substring 'a' at index0 is from 0 to 0, and at index1 is from 1 to 1. These are two distinct occurrences.\n\n   Therefore, the algorithm is correct.\n\n   But wait, the example \"aabb\" was handled correctly.\n\n   However, note: the problem says \"These occurrences can overlap\", and in this case they do not overlap, but that's allowed.\n\n   One more example: \"abab\"\n        n=4, check L=3: \n            \"aba\", \"bab\" -> no duplicate.\n        L=2:\n            \"ab\", \"ba\", \"ab\" -> duplicate found -> output 2.\n\n   But wait: the substring \"ab\" appears at index0 and index2. The two occurrences: \n        [0:2] = \"ab\", [2:4] = \"ab\" (if we take substring of length2 from index2: s[2:4] is \"ab\")? \n        Actually, the string \"abab\": \n            index0: 'a', index1: 'b', index2: 'a', index3: 'b'\n            substring of length2: \n                index0: \"ab\"\n                index1: \"ba\"\n                index2: \"ab\"\n\n        So we have two \"ab\"s: at index0 and index2.\n\n   Correct.\n\n   Therefore, the algorithm:\n\n        Read the string s.\n        n = len(s)\n        # We consider L from n-1 down to 1\n        for L in range(n-1, 0, -1):\n            seen = set()\n            duplicate_found = False\n            for i in range(0, n - L + 1):\n                substr = s[i:i+L]\n                if substr in seen:\n                    print(L)\n                    exit(0)\n                else:\n                    seen.add(substr)\n        # If we didn't break, then the answer is 0 (empty substring)\n        print(0)\n\n   But wait: what if n=1? Then the loop runs from 0 down to 1? Actually, range(n-1, 0, -1) for n=1: range(0,0,-1) -> empty range. Then we print 0.\n\n   For n=1: the string has one character. There's no substring of positive length that appears twice (because there's only one occurrence). The empty substring is the only one that appears at least twice (appears two times: at the beginning and at the end, and also in the middle? Actually, in a string of length1, the empty substring appears at index0 and index1 (if we consider the gaps). So the answer is 0.\n\n   This is correct.\n\n   However, note: the problem says the string is non-empty, so n>=1.\n\n   But wait: the problem says the string is non-empty, but we are handling n=1.\n\n   But wait, the example input: ['abcd', 'ababa', 'zzz'] are all of length>=4, but our code must handle any non-empty string.\n\n   Let me test with a string of length 2: \"aa\"\n        n=2, L from 1 down to 1 (so one iteration for L=1)\n        i=0: substr = \"a\", then i=1: substr=\"a\" -> duplicate found -> output 1.\n\n   This is correct.\n\n   Another test: \"aab\"\n        n=3, L=2: \n            substrings: \"aa\", \"ab\" -> no duplicate.\n        L=1:\n            substrings: \"a\",\"a\",\"b\" -> duplicate \"a\" -> output 1.\n\n   But wait: the substring \"a\" appears twice (at index0 and index1). So correct.\n\n   However, wait: the substring \"aa\" is of length2 and appears once (only at index0). The substring \"a\" appears twice.\n\n   But note: the problem asks for the longest substring. The substring \"a\" has length1, and there is no substring of length2 that appears twice. So the answer is 1.\n\n   But wait, the example \"aab\" has two 'a's. The substring \"a\" is the longest one that appears twice? Actually, no: we have to consider if there is a longer substring. The only longer substring is \"aa\" (length2) which appears only once, and \"ab\" (length2) which appears once. So 1 is correct.\n\n   However, note: the substring \"a\" is of length1, but is there a substring of length2 that appears twice? No.\n\n   So the algorithm is correct.\n\n   But wait, we are checking for duplicates in the set for each L independently. This is correct because we are looking for the maximum L.\n\n   However, we must note: we are checking from the maximum L (n-1) downwards, so we find the largest L for which there is a duplicate.\n\n   But wait: what if a substring of length L appears twice, but a longer substring (L+1) does not? Then we break and output L.\n\n   But note: we are iterating from the maximum possible L (which is n-1) downwards, so we are guaranteed to find the maximum L.\n\n   However, what if a substring of length L appears twice, but there is a substring of length L+1 that also appears twice? Then we would have found the longer one first.\n\n   Actually, we are iterating from the maximum L (n-1) down to 1. So we check the longer ones first.\n\n   Therefore, we are correct.\n\n   But note: the problem says the string length doesn't exceed 100, so worst-case we do about 100 * 100 * 100 = 1e6 operations (for each L from 99 down to 1, and for each L we do n-L+1 iterations, each of which creates a substring of length L). The worst-case total operations is sum_{L=1}^{n-1} (n-L+1)*L. For n=100, that is about 100^3/2 = 500000, which is acceptable.\n\n   However, we can optimize by using a dictionary (or set) that we reuse? Actually, we break early if we find a duplicate for a given L, so worst-case we do:\n\n        For L = n-1: we do n - (n-1) + 1 = 2 iterations (if n=100, then 2 substrings of length99) and if no duplicate, then we do two set lookups.\n\n        Then L = n-2: we do 3 substrings, etc.\n\n   But worst-case (when there is no duplicate until L=1) we do:\n\n        For L from n-1 down to 1: we do (n - L + 1) * (cost of creating substring and set lookup)\n\n   The total number of substrings we consider is about n*(n+1)/2, which is O(n^2). And each substring operation is O(L). The worst-case total operations is O(n^3), which for n=100 is 100^3 = 1e6, which is acceptable in Python.\n\n   But we can do better by not recalculating from scratch for each L.\n\n   However, the problem size is small (n<=100), so we can stick to the simple solution.\n\n   Let me write the code accordingly.\n\n   Code:\n\n        s = input().strip()\n        n = len(s)\n\n        # We are going to check from L = n-1 down to 1.\n        # If we find a duplicate for a given L, we output L and exit.\n\n        # If we don't find any, output 0.\n\n        # Special note: the empty substring is considered (output 0 if no positive duplicate)\n\n        # Iterate L from n-1 down to 1 (both inclusive)\n        for L in range(n-1, 0, -1):\n            seen = set()\n            found = False\n            # Generate all substrings of length L\n            for i in range(0, n - L + 1):\n                substr = s[i:i+L]\n                if substr in seen:\n                    print(L)\n                    exit(0)\n                seen.add(substr)\n\n        print(0)\n\n   However, wait: what if the string has duplicate substrings of different lengths? We are checking from the maximum L first, so we break at the first duplicate we find (which is the maximum L). \n\n   But note: we are checking for each L independently. This is correct.\n\n   But wait: the example \"abab\": \n        We check L=3: \n            substrings: \"aba\", \"bab\" -> no duplicate.\n        Then L=2: \n            substrings: \"ab\", \"ba\", \"ab\" -> duplicate found -> output 2.\n\n   Correct.\n\n   But wait: what if the same substring of length L appears twice, but we break at the first occurrence. That is okay because we only need one duplicate.\n\n   However, note: we are storing the substrings in a set. We are storing every substring we've seen. \n\n   But what if we have two different substrings of the same length that are duplicates? We don't care, because we break as soon as we find one duplicate.\n\n   This is efficient.\n\n   But wait: is there a possibility that we miss a longer substring? No, because we are checking from the maximum L first.\n\n   However, note: the same substring of length L might appear more than twice, but that doesn't matter.\n\n   One more corner: if the string is \"a\" (n=1), then the loop doesn't run (because range(0,0,-1) is empty) and we output 0.\n\n   This is correct.\n\n   But wait: the problem says the string is non-empty, so n>=1.\n\n   However, we must consider performance: worst-case when the string has no duplicate substring for any positive length (like \"abcd\"), then we do:\n\n        L from 99 down to 1 (if n=100) and for each L, we generate (100-L+1) substrings.\n\n        Total number of substrings generated: \n            for L=99: 2 substrings\n            for L=98: 3 substrings\n            ...\n            for L=1: 100 substrings\n\n        Total substrings = 2 + 3 + ... + 100 = (sum from 1 to 100) - 1 = 5050 - 1 = 5049.\n\n        And each substring of length L takes O(L) to create, so the total operations is about the sum_{L=1}^{99} (number of substrings for L) * L.\n\n        Which is: \n            for L=1: 100 * 1 = 100\n            for L=2: 99 * 2 = 198\n            ...\n            for L=99: 2 * 99 = 198\n\n        Actually, for a fixed L, the number of substrings is (n - L + 1) and each substring is of length L, so the cost is (n-L+1)*L.\n\n        Total operations = sum_{L=1}^{n-1} (n-L+1)*L.\n\n        For n=100: \n            = sum_{k=1}^{99} k*(100-k)   [let k=L, then n-L+1 = 100 - L + 1 = 101 - L, but wait: we defined L from 1 to 99, then n-L+1 = 100-L+1 = 101-L]\n\n        Alternatively, we can compute:\n\n            = sum_{L=1}^{99} (101 - L) * L\n            = 101 * sum_{L=1}^{99} L - sum_{L=1}^{99} L^2\n\n        We know: \n            sum_{L=1}^{m} L = m(m+1)/2, and sum_{L=1}^{m} L^2 = m(m+1)(2m+1)/6.\n\n        Let m=99.\n\n        But note: we are doing 5049 substrings, but the total operations is the sum of the lengths of the substrings we generate.\n\n        Actually, the set operations (adding and checking) are O(L) per substring (because the hash of a string of length L takes O(L)), so the total time is the sum_{L=1}^{99} (101-L)*L * L.\n\n        Wait, no: the set operations are O(L) for each substring, and we have (n-L+1) substrings of length L. So the cost for a fixed L is (n-L+1)*O(L). The total is O(n^4) in the worst-case? \n\n        Actually, no: the set operations (adding and checking) for a string of length L are O(L) per operation. And we do (n-L+1) operations for that L. So the total operations for a fixed L is (n-L+1)*L. \n\n        And the total over all L is the sum_{L=1}^{n-1} (n-L+1)*L.\n\n        For n=100: \n            = sum_{L=1}^{99} (101 - L)*L\n            = 101 * (sum_{L=1}^{99} L) - (sum_{L=1}^{99} L^2)\n\n        We can compute:\n\n            sum_{L=1}^{99} L = 99*100//2 = 4950\n            sum_{L=1}^{99} L^2 = 99*100*199//6 = 328350\n\n            Then, 101 * 4950 = 500000 - 50? Actually, 101*4950 = 499950\n            Then subtract: 499950 - 328350 = 171600.\n\n        So the total operations (in terms of character comparisons) is 171600, which is acceptable.\n\n        But wait: the set operations are not just comparing the entire substring, they are hashing the substring. The hashing of a string of length L takes O(L). So the total operations is 171600 * (average cost per character)? Actually, no: the total operations is the sum_{L} [ (number of substrings of length L) * L ].\n\n        And that is exactly the same as the formula above.\n\n        However, note: the set operations (adding and checking) are done for each substring. The cost for adding a string of length L is O(L). So the total cost is the sum_{L=1}^{99} [ (n-L+1) * L * (cost per operation) ].\n\n        But the cost per operation (for a set) is proportional to the length of the string. So the total operations is the same as the total length of all substrings we generate.\n\n        We are generating each substring by slicing the string. The slice operation for s[i:i+L] creates a new string of length L, which takes O(L) time and space.\n\n        Therefore, the total time is O(n^3) in the worst-case (which is acceptable for n=100, because 100^3 = 1e6, but wait: our calculation above for n=100 was about 171600, which is less than 1e6). Actually, the exact total length of all substrings we generate is:\n\n            For a fixed L: (n-L+1) * L.\n\n            Then the total is the same as above: 171600.\n\n        So the worst-case (n=100) is about 171600 operations, which is acceptable.\n\n   However, we can avoid the high memory usage by not storing the entire set of substrings for each L? Actually, we break early if we find a duplicate, so in the worst-case (no duplicate) we store all substrings for that L. But we are iterating from the maximum L downward, so the worst-case is that we do all L from n-1 down to 1 without finding a duplicate, and for each L we store all the substrings of that length.\n\n   The memory usage: for a given L, we store (n-L+1) strings of length L. The total memory is the sum_{L=1}^{n-1} (n-L+1)*L * (size of a character in bytes). For n=100, the maximum L is 99, and the total number of characters stored is 171600, which is acceptable.\n\n   But note: we are using a set for each L, and we do not reuse sets. However, we break early if we find a duplicate, so in many cases we won't store all substrings.\n\n   Given the constraints (n<=100) and the fact that worst-case is acceptable, we leave the code as is.\n\n   However, we can optimize by using a rolling hash to avoid the expensive substring extraction and set operations. But the problem size is small, so we don't need to.\n\n   Let me run the code on the provided examples.\n\n   Example: \"abcd\" -> output 0\n   Example: \"ababa\" -> output 3\n   Example: \"zzz\" -> output 2\n\n   But wait: for \"zzz\", n=3, so we check L=2: \n        substrings: \"zz\", \"zz\" -> duplicate -> output 2.\n\n   Correct.\n\n   Now, let's test \"ababa\":\n        n=5, check L=4: \n            substrings: \"abab\", \"baba\" -> no duplicate.\n        L=3:\n            substrings: \"aba\", \"bab\", \"aba\" -> duplicate -> output 3.\n\n   Correct.\n\n   However, note: the example \"ababa\" has a duplicate substring \"aba\" of length3, but also \"aba\" of length3 appears again. The code finds it.\n\n   One more: \"abcabc\" (n=6)\n        Check L=5: \n            substrings: \"abcab\", \"bcabc\" -> no duplicate.\n        L=4:\n            \"abca\", \"bcab\", \"cabc\" -> no duplicate.\n        L=3:\n            \"abc\", \"bca\", \"cab\", \"abc\" -> duplicate \"abc\" -> output 3.\n\n   Correct.\n\n   Therefore, we write the code as below.\n\n   But note: the problem says the string is given in the first input line.\n\n   Final code:\n\n        s = input().strip()\n        n = len(s)\n\n        # We consider L from n-1 down to 1.\n        for L in range(n-1, 0, -1):\n            seen = set()\n            for i in range(0, n - L + 1):\n                substr = s[i:i+L]\n                if substr in seen:\n                    print(L)\n                    exit(0)\n                seen.add(substr)\n\n        print(0)\n\n   However, wait: the problem says the string is non-empty, but what if the input has spaces? We are using strip(), so we remove leading/trailing spaces. But the problem says \"lower-case Latin letters\", so there should be no spaces. But to be safe, we use strip().\n\n   But the problem says: the first input line contains the string. So we assume the string is given without spaces (unless specified otherwise). But the problem says it consists of lower-case Latin letters.\n\n   Alternatively,",
    "response": "\nTo solve this problem, we need to find the length of the longest substring that appears at least twice in a given string. The occurrences of these substrings can overlap, which means we need to consider all possible substrings of each length and check for duplicates efficiently.\n\n### Approach\n1. **Problem Analysis**: The task is to determine the longest contiguous substring that occurs at least twice in the input string. The solution involves checking all possible substrings of decreasing lengths from the maximum possible (n-1) down to 1. For each length, we examine all substrings of that length and use a set to track seen substrings. If a duplicate is found, we immediately return the current length as the result since we are checking from the largest possible length downwards.\n2. **Intuition**: By starting with the largest possible substring length and decrementing, we ensure that the first duplicate found corresponds to the longest valid substring. This approach leverages the fact that longer substrings are less likely to repeat, so checking them first optimizes the solution.\n3. **Algorithm Selection**: The algorithm iterates over each possible substring length from the string's length minus one down to one. For each length, it generates all substrings of that length and checks for duplicates using a set. The presence of a duplicate indicates the solution.\n4. **Complexity Analysis**: The worst-case time complexity is O(n^3), where n is the length of the string. This is because for each length L (from n-1 down to 1), we process up to (n - L + 1) substrings, each of length L, leading to a cubic complexity. However, given the constraint that the string length does not exceed 100, this approach is feasible and efficient enough.\n\n### Solution Code\n```python\ns = input().strip()\nn = len(s)\n\nfor L in range(n-1, 0, -1):\n    seen = set()\n    for i in range(0, n - L + 1):\n        substr = s[i:i+L]\n        if substr in seen:\n            print(L)\n            exit(0)\n        seen.add(substr)\n\nprint(0)\n```\n\n### Explanation\n1. **Reading Input**: The input string is read and stripped of any leading or trailing whitespace.\n2. **Iterating Over Lengths**: The loop starts from the largest possible substring length (n-1) and decrements down to 1. For each length L, it initializes an empty set to keep track of seen substrings.\n3. **Checking Substrings**: For each starting index i, the substring of length L starting at i is extracted. If this substring is found in the set, its length L is printed, and the program exits. Otherwise, the substring is added to the set.\n4. **Output Result**: If no duplicates are found for any length, the program prints 0, indicating only the empty substring (which trivially appears multiple times) meets the criteria.\n\nThis approach efficiently checks for the longest repeating substring by leveraging early termination upon finding a valid solution, ensuring optimal performance for the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "s = input().strip()\nn = len(s)\n\nfor L in range(n-1, 0, -1):\n    seen = set()\n    for i in range(0, n - L + 1):\n        substr = s[i:i+L]\n        if substr in seen:\n            print(L)\n            exit(0)\n        seen.add(substr)\n\nprint(0)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 236,
        "completion_token_count": 642,
        "thoughts_token_count": 8191
    }
}