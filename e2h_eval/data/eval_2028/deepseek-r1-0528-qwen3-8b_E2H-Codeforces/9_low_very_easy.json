{
    "start": 1758093176.1663277,
    "end": 1758094937.8826914,
    "start-formatted": "2025-09-17 16:12 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are given up to 100000 items, each with weight in {1,2,3} and cost up to 10^9.\n Since the weights are only 1, 2, or 3, we can separate the items by their weight.\n\n Let:\n   type1: list of costs for weight 1\n   type2: list of costs for weight 2\n   type3: list of costs for weight 3\n\n Then, we have to consider that we can take multiple items (each item is independent) but the total weight must be <= m.\n\n The idea is to use dynamic programming for small weight sets and then combine them. However, note that m can be up to 300000 and n up to 100000.\n\n Alternatively, we can precompute for each type the best way to use k items of that type (if we use k items, what is the minimum total weight? Actually, we don't need minimum weight, we want maximum cost for a given weight limit).\n\n But note: the problem is similar to the knapsack problem with three types of items (each having fixed weight 1,2,3) and each type having multiple items (each with different cost).\n\n Steps:\n\n 1. Separate the items into three lists: w1, w2, w3.\n\n 2. Sort each list in descending order (so that the highest cost items are first) because we want to maximize cost.\n\n 3. Precompute prefix sums for each type to quickly get the total cost for taking k items (or k times the same weight). However, note that we can mix the types arbitrarily.\n\n 4. We can think of the problem as: we have three independent sets of items (each set has items of same weight). We want to choose a number of type1, type2, type3 such that:\n        x1 + 2*x2 + 3*x3 <= m\n    and the total cost is maximized.\n\n 5. Since the weights are small (only 1,2,3) and the total weight m can be up to 300000, we cannot iterate over all x1, x2, x3 (which would be O(n^3)).\n\n Alternate approach:\n\n We can fix the number of type3 items (x3) and then for the remaining weight (m - 3*x3), we distribute it between type1 and type2.\n\n But note: we have two more variables: x1 and x2. The constraint becomes: x1 + 2*x2 <= m - 3*x3.\n\n However, we can precompute for type1 and type2 separately:\n\n   For type1: let dp1[i] = maximum total cost we can get from using i items of type1 (but note: we can use at most len(type1) items). Similarly for type2.\n\n But wait: we don't need to know the exact count of items, but the total cost for a given number of items. However, the items are not identical in cost. So for type1, we can sort the costs in descending order and then compute prefix sums.\n\n Similarly for type2 and type3.\n\n However, we are going to use the fact that for a fixed x3, the remaining weight is W = m - 3*x3. Then we can use at most floor(W/1) from type1 and type2, but note type2 items are 2 units.\n\n But we can also use a two-variable knapsack for the remaining two types? That might be too heavy.\n\n Another idea: since the two remaining types are 1 and 2, we can use the following:\n\n   Let's denote:\n     Let a = number of type1 items, b = number of type2 items.\n     Then we require: a + 2*b <= W.\n\n   How to maximize the cost from type1 and type2?\n\n   We can precompute two arrays for type1 and type2:\n\n     Let A[i] = maximum total cost from taking i items of type1. Similarly, B[j] for type2.\n\n   But note: we have many items (up to 100000) but the counts for type1 and type2 are the number of items in that type (which can be up to 100000). However, the total weight W can be up to 300000, so the maximum i (for type1) is up to 300000, which is too big.\n\n Instead, we can use the following:\n\n   Since the weight per type1 is 1, we can use at most W items from type1. Similarly, for type2, we can use at most floor(W/2) items.\n\n   But note: we are allowed to mix arbitrarily. We can do:\n\n     total_cost = max_{",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs come in three different weights (1, 2, or 3), and each has a specific cost. The challenge is to select a subset of these souvenirs such that their combined weight does not exceed the limit, and their total cost is as high as possible.\n\n### Approach\n1. **Categorize Items**: Separate the souvenirs into three categories based on their weights (1, 2, or 3). This helps in systematically processing each type.\n2. **Sort and Prefix Sums**: For each category, sort the items by their cost in descending order. Then, compute prefix sums for each category. The prefix sum at index `i` represents the maximum total cost achievable by selecting the top `i` items from that category.\n3. **Iterate Over Possible Combinations**: For each possible number of type-3 items (which have the highest weight), calculate the remaining weight available for type-1 and type-2 items. Use the prefix sums of type-1 and type-2 items to determine the maximum cost achievable with the remaining weight. The solution involves checking all feasible combinations of these three categories within the weight constraint.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    index = 2\n    for _ in range(n):\n        wi = int(data[index])\n        ci = int(data[index + 1])\n        index += 2\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        elif wi == 3:\n            w3.append(ci)\n            \n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    prefix1 = [0] * len(w1)\n    if w1:\n        prefix1[0] = w1[0]\n        for i in range(1, len(w1)):\n            prefix1[i] = prefix1[i - 1] + w1[i]\n            \n    prefix2 = [0] * len(w2)\n    if w2:\n        prefix2[0] = w2[0]\n        for i in range(1, len(w2)):\n            prefix2[i] = prefix2[i - 1] + w2[i]\n            \n    prefix3 = [0] * len(w3)\n    if w3:\n        prefix3[0] = w3[0]\n        for i in range(1, len(w3)):\n            prefix3[i] = prefix3[i - 1] + w3[i]\n            \n    def get_max_cost(arr, prefix, max_count):\n        if not arr:\n            return 0\n        res = 0\n        for i in range(min(max_count, len(arr))):\n            if prefix[i] > res:\n                res = prefix[i]\n        return res\n        \n    best = 0\n    max_count_type3 = m // 3\n    for i in range(min(len(prefix3), max_count_type3 + 1)):\n        rem_weight = m - 3 * i\n        if rem_weight < 0:\n            continue\n        count1 = rem_weight\n        count2 = rem_weight // 2\n        \n        cost1 = get_max_cost(w1, prefix1, count1)\n        cost2 = get_max_cost(w2, prefix2, count2)\n        \n        total = prefix3[i - 1] if i > 0 else 0 + cost1 + cost2\n        if total > best:\n            best = total\n            \n    print(best)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of souvenirs `n` and the maximum weight `m`. Each souvenir's weight and cost are then categorized into one of three lists based on their weight.\n2. **Sorting and Prefix Sums**: Each list of souvenirs is sorted in descending order of cost. Prefix sums are computed for each list to quickly access the cumulative cost of selecting the top `k` items from that list.\n3. **Combination Check**: For each possible number of type-3 items (from 0 to the maximum possible given the weight limit), the remaining weight is calculated. Using the remaining weight, the maximum cost from type-1 and type-2 items is determined by leveraging their prefix sums. The total cost for each combination is compared to find the maximum value.\n4. **Output**: The highest total cost found during the iteration is printed as the result.\n\nThis approach efficiently narrows down the problem by categorizing items and using prefix sums to explore all feasible combinations within the weight constraint, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    index = 2\n    for _ in range(n):\n        wi = int(data[index])\n        ci = int(data[index + 1])\n        index += 2\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        elif wi == 3:\n            w3.append(ci)\n            \n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    prefix1 = [0] * len(w1)\n    if w1:\n        prefix1[0] = w1[0]\n        for i in range(1, len(w1)):\n            prefix1[i] = prefix1[i - 1] + w1[i]\n            \n    prefix2 = [0] * len(w2)\n    if w2:\n        prefix2[0] = w2[0]\n        for i in range(1, len(w2)):\n            prefix2[i] = prefix2[i - 1] + w2[i]\n            \n    prefix3 = [0] * len(w3)\n    if w3:\n        prefix3[0] = w3[0]\n        for i in range(1, len(w3)):\n            prefix3[i] = prefix3[i - 1] + w3[i]\n            \n    def get_max_cost(arr, prefix, max_count):\n        if not arr:\n            return 0\n        res = 0\n        for i in range(min(max_count, len(arr))):\n            if prefix[i] > res:\n                res = prefix[i]\n        return res\n        \n    best = 0\n    max_count_type3 = m // 3\n    for i in range(min(len(prefix3), max_count_type3 + 1)):\n        rem_weight = m - 3 * i\n        if rem_weight < 0:\n            continue\n        count1 = rem_weight\n        count2 = rem_weight // 2\n        \n        cost1 = get_max_cost(w1, prefix1, count1)\n        cost2 = get_max_cost(w2, prefix2, count2)\n        \n        total = prefix3[i - 1] if i > 0 else 0 + cost1 + cost2\n        if total > best:\n            best = total\n            \n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1065,
        "thoughts_token_count": 1023
    }
}