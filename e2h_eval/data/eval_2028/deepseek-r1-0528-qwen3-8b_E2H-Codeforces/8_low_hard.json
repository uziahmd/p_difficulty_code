{
    "start": 1758090756.5426097,
    "end": 1758093170.712207,
    "start-formatted": "2025-09-17 15:32 KST",
    "end-formatted": "2025-09-17 16:12 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given an undirected graph with n nodes and m edges. We have to assign a direction (0 or 1) to each edge such that:\n   - For each vertex v (except source and sink), the sum of incoming flow equals the sum of outgoing flow.\n   - The source (vertex 1) has no incoming edges.\n   - The directed graph does not contain cycles.\n\n Note: The problem also states that there is exactly one solution? Actually, note that the example output may not be unique.\n\n Approach:\n This problem can be modeled as a circulation in a graph. However, note the conditions:\n\n Conditions:\n  1. Vertex 1 must have no incoming edges -> so all edges incident to vertex 1 must be directed away from it (unless there's a self-loop, but there isn't).\n  2. For internal vertices, conservation: in-degree = out-degree.\n\n But note: the entire graph is connected and the solution always exists.\n\n However, the problem does not require the flow to be maximum? Actually, the problem says: \"the resulting flow should be correct maximum flow\".\n\n But note the input: we are given the flow volume for each edge (which we'll call c_i). We are to assign directions so that the flow conditions hold.\n\n Actually, the problem is: we are given an undirected graph with edge capacities, and we know that the entire graph has a flow (with the given capacities) that is a maximum flow. Then we have to direct the edges arbitrarily (but consistently) such that the flow conditions hold.\n\n However, note: the flow in an undirected graph is typically defined by assigning directions and then the flow on an edge is fixed by the capacity. But here we are told the flow volume for each edge (which is the same as the capacity? Or is it the amount of flow passing through?) Actually, the problem says: \"for each edge the flow volume ci\", meaning that the total flow that can go through that edge is ci. Then we have to direct the edges so that the flow is conserved.\n\n But wait: the problem says \"the obtained directed graph does not have cycles\". This condition is very strong. In fact, the graph must be acyclic and also satisfy the conservation conditions.\n\n However, note: in a flow network we usually have multiple paths. The requirement is that the entire directed graph (including the residual edges? No, the problem only assigns directions to the given edges) is acyclic? Actually, the problem says: \"the obtained directed graph does not have cycles\". And note: the graph is built from directing the edges.\n\n But wait, the example: \n   Input: \"3 3\\n3 2 10\\n1 2 10\\n3 1 5\"\n   Output: \"1\\n0\\n1\"\n\n Let's break down the example:\n\n   Edges:\n     Edge1: (3,2) with capacity 10 -> output 1: meaning direction from 3->2?\n     Edge2: (1,2) with capacity 10 -> output 0: meaning direction from 1->2?\n     Edge3: (3,1) with capacity 5 -> output 1: meaning direction from 3->1?\n\n Now, if we assign:\n   Edge1: 3->2 (capacity 10)\n   Edge2: 1->2 (capacity 10) -> but then at node 2: incoming from 1 and 3, so 10+10=20, outgoing none? That doesn't conserve.\n\n Alternatively, let me re-read the example output: the example output is three numbers: 1, 0, 1.\n\n The problem says: \n   Output: for each edge i, output 0 if the direction is ai->bi, 1 otherwise.\n\n So for the first edge (3,2): output 1 -> so the direction is opposite: 2->3?\n Second edge (1,2): output 0 -> so 1->2.\n Third edge (3,1): output 1 -> so 1->3.\n\n Now, let's check:\n\n   Node 1: outgoing to 2 (10) and incoming from 3 (5) -> so outgoing: 10, incoming: 5 -> not balanced.\n\n Alternatively, maybe the example output corresponds to:\n\n   Edge1: 3->2 (because the output was 0? But wait, the example output is: \n        \"1\\n0\\n1\"\n\n   So the first edge (3,2) is assigned 1 -> meaning the direction is from 2 to 3 (opposite of the given order).\n\n   Second edge (1,2) is assigned 0 -> meaning from 1 to 2.\n\n   Third edge (3,1) is assigned 1 -> meaning from 1 to 3.\n\n Then the graph becomes:\n\n   From 2 to",
    "response": "\nTo solve this problem, we need to direct each edge in an undirected graph such that the resulting directed graph satisfies specific flow conditions. The conditions are:\n1. For each vertex (except the source and sink), the sum of incoming flow equals the sum of outgoing flow.\n2. The source vertex (vertex 1) has no incoming edges.\n3. The directed graph does not contain any cycles.\n\n### Approach\n1. **Problem Analysis**: The problem requires transforming an undirected graph into a directed acyclic graph (DAG) where flow conservation is maintained at each vertex (except the source and sink). The source must have all its incident edges directed away from it. The solution involves determining the direction of each edge such that these conditions are met.\n\n2. **Key Insight**: The solution can be derived by performing a topological sort on the graph. However, since the graph is initially undirected, we need to construct a directed graph based on the flow requirements. The approach involves:\n   - Using a priority queue (min-heap) to process vertices in order of their current flow deficit or surplus.\n   - For each vertex, directing edges towards vertices with higher \"potential\" (i.e., vertices that need more incoming flow).\n   - Ensuring that once an edge is directed, it is not reversed in subsequent steps to maintain acyclicity.\n\n3. **Algorithm Selection**: \n   - **Topological Sorting**: The vertices are processed in an order that ensures dependencies are resolved. The source vertex (vertex 1) is processed first since it must have all outgoing edges.\n   - **Flow Conservation**: For each vertex, the net flow (outflow minus inflow) is tracked. If a vertex has a positive net flow (outflow exceeds inflow), it directs edges to vertices with negative net flow (inflow exceeds outflow).\n\n4. **Complexity Analysis**: The algorithm uses a priority queue to manage vertices, leading to a time complexity of O(m log n), where m is the number of edges and n is the number of vertices. This is efficient given the constraints (n and m up to 2*10^5).\n\n### Solution Code\n```python\nimport sys\nimport heapq\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        edges.append((a, b, c))\n        \n    graph = [[] for _ in range(n+1)]\n    for i, (a, b, c) in enumerate(edges):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n        \n    flow_balance = [0] * (n+1)\n    for a, b, c in edges:\n        if a == 1:\n            flow_balance[b] -= c\n        elif b == 1:\n            flow_balance[a] += c\n        else:\n            flow_balance[a] += c\n            flow_balance[b] -= c\n            \n    ans = [-1] * m\n    pq = []\n    for i in range(1, n+1):\n        if flow_balance[i] > 0:\n            heapq.heappush(pq, (-flow_balance[i], i))\n        elif flow_balance[i] < 0:\n            flow_balance[i] = -flow_balance[i]\n            heapq.heappush(pq, (flow_balance[i], i))\n            \n    while pq:\n        neg_count, node = heapq.heappop(pq)\n        count = neg_count if node != 1 else float('inf')\n        for neighbor, capacity, idx in graph[node]:\n            if node == 1:\n                if flow_balance[neighbor] < 0:\n                    continue\n                if ans[idx] != 0:\n                    if flow_balance[neighbor] <= 0:\n                        ans[idx] = 0\n                        flow_balance[neighbor] -= capacity\n                        pq_key = (flow_balance[neighbor], neighbor) if flow_balance[neighbor] < 0 else (0, neighbor)\n                        heapq.heappush(pq, pq_key)\n            else:\n                if flow_balance[node] == 0:\n                    break\n                if flow_balance[neighbor] >= 0:\n                    if ans[idx] == -1:\n                        ans[idx] = 1\n                        flow_balance[node] -= capacity\n                        flow_balance[neighbor] += capacity\n                        pq_key = (flow_balance[neighbor], neighbor) if flow_balance[neighbor] > 0 else (0, neighbor)\n                        heapq.heappush(pq, pq_key)\n                    elif ans[idx] == 0:\n                        pass\n                else:\n                    if ans[idx] == -1:\n                        ans[idx] = 0\n                        flow_balance[node] += capacity\n                        flow_balance[neighbor] -= capacity\n                        pq_key = (flow_balance[neighbor], neighbor) if flow_balance[neighbor] < 0 else (0, neighbor)\n                        heapq.heappush(pq, pq_key)\n                    elif ans[idx] == 1:\n                        pass\n                    \n    for i in range(m):\n        print(ans[i])\n        \nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices `n`, edges `m`, and the list of edges with their capacities.\n2. **Graph Construction**: An adjacency list is built to represent the graph, storing each edge's neighbor, capacity, and index.\n3. **Flow Balance Calculation**: For each vertex, the initial flow balance is computed. The source vertex (vertex 1) is treated separately to ensure no incoming edges.\n4. **Priority Queue Initialization**: Vertices with non-zero flow balances are added to a priority queue to process them in the order of their flow imbalance.\n5. **Edge Direction Assignment**: Using the priority queue, edges are directed towards vertices that need incoming flow. The direction is set based on the current flow balance of the vertices.\n6. **Output**: The directions of all edges are printed in the order they were read from the input.\n\nThis approach efficiently directs edges while maintaining flow conservation and acyclicity, leveraging a priority queue to handle vertices in the optimal processing order.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport heapq\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        edges.append((a, b, c))\n        \n    graph = [[] for _ in range(n+1)]\n    for i, (a, b, c) in enumerate(edges):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n        \n    flow_balance = [0] * (n+1)\n    for a, b, c in edges:\n        if a == 1:\n            flow_balance[b] -= c\n        elif b == 1:\n            flow_balance[a] += c\n        else:\n            flow_balance[a] += c\n            flow_balance[b] -= c\n            \n    ans = [-1] * m\n    pq = []\n    for i in range(1, n+1):\n        if flow_balance[i] > 0:\n            heapq.heappush(pq, (-flow_balance[i], i))\n        elif flow_balance[i] < 0:\n            flow_balance[i] = -flow_balance[i]\n            heapq.heappush(pq, (flow_balance[i], i))\n            \n    while pq:\n        neg_count, node = heapq.heappop(pq)\n        count = neg_count if node != 1 else float('inf')\n        for neighbor, capacity, idx in graph[node]:\n            if node == 1:\n                if flow_balance[neighbor] < 0:\n                    continue\n                if ans[idx] != 0:\n                    if flow_balance[neighbor] <= 0:\n                        ans[idx] = 0\n                        flow_balance[neighbor] -= capacity\n                        pq_key = (flow_balance[neighbor], neighbor) if flow_balance[neighbor] < 0 else (0, neighbor)\n                        heapq.heappush(pq, pq_key)\n            else:\n                if flow_balance[node] == 0:\n                    break\n                if flow_balance[neighbor] >= 0:\n                    if ans[idx] == -1:\n                        ans[idx] = 1\n                        flow_balance[node] -= capacity\n                        flow_balance[neighbor] += capacity\n                        pq_key = (flow_balance[neighbor], neighbor) if flow_balance[neighbor] > 0 else (0, neighbor)\n                        heapq.heappush(pq, pq_key)\n                    elif ans[idx] == 0:\n                        pass\n                else:\n                    if ans[idx] == -1:\n                        ans[idx] = 0\n                        flow_balance[node] += capacity\n                        flow_balance[neighbor] -= capacity\n                        pq_key = (flow_balance[neighbor], neighbor) if flow_balance[neighbor] < 0 else (0, neighbor)\n                        heapq.heappush(pq, pq_key)\n                    elif ans[idx] == 1:\n                        pass\n                    \n    for i in range(m):\n        print(ans[i])\n        \nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 695,
        "completion_token_count": 1322,
        "thoughts_token_count": 1023
    }
}