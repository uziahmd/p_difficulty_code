{
    "start": 1758294372.4394677,
    "end": 1758296443.2172308,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:40 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given up to 10 spaceships and 10 bases. We need to check if there is a perfect matching (i.e., a bijection) between the R spaceships and B bases such that the straight lines connecting each spaceship to its base do not intersect.\n\n Observation: Since the points are in general position (no three collinear) and the assignment must be a perfect matching, we can use a recursive backtracking (brute force) because R and B are at most 10, so maximum 10! possibilities (which is 3628800, acceptable for n=10? Actually, worst-case 10! is about 3.6 million, but we have two sets of 10 points, so we are matching 10 rebels to 10 bases, and checking the non-intersection condition for the entire set of edges.\n\n However, note: the problem states that the assignment is a perfect matching (so R must equal B? Actually, the input says: first line two integers R and B, then R lines for spaceships and B lines for bases. The example input has R and B, and the example input \"2 1\" leads to output \"No\", meaning if R != B, then it's impossible to have a perfect matching? \n\n But note: the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\", which implies that the number of spaceships must equal the number of bases. So if R != B, we immediately output \"No\".\n\n However, the example input format: \n   First line: \"3 3\"\n   Then three lines for spaceships and three for bases.\n\n Second example: \"2 1\" -> no, because 2 != 1.\n\n Steps:\n\n 1. Read R and B. If R != B, output \"No\".\n 2. Read the next R lines for spaceships and then B lines for bases.\n 3. We need to assign each spaceship to a base (a bijection) such that the straight lines (edges) do not intersect.\n\n How to check for non-intersecting edges?\n\n Note: The edges are drawn as straight lines between points. Since no three points are collinear, two edges (each connecting a spaceship to a base) will either intersect at an endpoint or not at all. But note: endpoints are distinct, so two edges (from disjoint pairs) might share an endpoint only if they are incident to the same point (which they are: one edge from a spaceship to a base, and the other from another spaceship to a base). However, the problem says \"any two (straight) paths from a base to its assigned spaceship do not intersect\". This means that edges should not cross in the interior.\n\n However, note: the edges are defined by two sets: one set of R points (spaceships) and one set of B points (bases). And we are drawing edges from each spaceship to its base.\n\n Important: The edges are between two different sets. So two edges (u1, b1) and (u2, b2) (where u1, u2 are spaceships and b1, b2 are bases) will not share an endpoint (unless u1=u2, but that doesn't happen because each spaceship is assigned once). Therefore, the edges are disjoint in terms of endpoints? Actually, no: the edges are from one set to the other, so the four endpoints are distinct.\n\n So we have two sets: S (spaceships) and T (bases). We are drawing a matching from S to T. The condition is that the edges do not intersect.\n\n How to check for intersection between two edges (a, b) and (c, d)? We can use the standard method: check the orientation of the four points.\n\n Standard way to check if two segments (p1, p2) and (p3, p4) intersect (in the plane) when they are not collinear (and no three are collinear) is to use the cross product to determine the orientation.\n\n However, note: our edges are from S to T. We don't require the edges to form a polygon, just that the straight lines do not cross.\n\n But note: the problem says \"any two paths do not intersect\". So we must check that for every pair of edges (from the matching) they do not intersect.\n\n However, note: the entire matching consists of R edges (if R=B). We must check that none of these edges intersect.\n\n But wait: what if three edges are involved? Actually, two edges are enough to check for crossing. However, we must check every pair of edges? Actually, no: the problem says \"any two paths\", meaning every pair of edges (that are part of the matching) should not intersect.\n\n However, note: if we have a matching, then the edges are independent. The condition is that the entire set of edges has no crossings",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the straight lines connecting each spaceship to its base do not intersect. The solution involves checking all possible bijections between the spaceships and bases for the non-intersection condition.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijection) between two sets of points (spaceships and bases) such that no two connecting edges intersect. Given the constraints (R and B are at most 10), a brute-force approach is feasible.\n2. **Key Insight**: For each permutation of base assignments (matching each spaceship to a unique base), we need to verify that no two edges intersect. The intersection check between two line segments can be efficiently done using the cross product method to determine the orientation of four points.\n3. **Algorithm Selection**: \n   - **Permutation Generation**: Generate all possible permutations of base indices to explore every possible matching.\n   - **Edge Intersection Check**: For each generated permutation, check all pairs of edges to ensure none intersect. The intersection is determined by verifying if the points of the two edges are interleaved in any order.\n4. **Complexity Analysis**: With R and B up to 10, the number of permutations is R! (up to 3,628,800). For each permutation, checking all pairs of edges (O(R^2) checks) is manageable due to the small input size.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else -1\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    it = iter(data)\n    R = int(next(it)); B = int(next(it))\n    \n    rebels = []\n    for _ in range(R):\n        x = int(next(it)); y = int(next(it))\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(next(it)); y = int(next(it))\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    if R == 0:\n        print(\"Yes\")\n        return\n        \n    perms = list(itertools.permutations(range(B)))\n    \n    def check_assignment(perm):\n        edges = []\n        for i in range(R):\n            s = rebels[i]\n            b = bases[perm[i]]\n            edges.append((s, b))\n            \n        n_edges = len(edges)\n        for i in range(n_edges):\n            for j in range(i+1, n_edges):\n                a, b = edges[i]\n                c, d = edges[j]\n                if do_segments_intersect(a, b, c, d):\n                    return False\n        return True\n        \n    for perm in perms:\n        if check_assignment(perm):\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into integers R and B (number of spaceships and bases), followed by their respective coordinates.\n2. **Initial Checks**: If R and B are not equal, output \"No\" immediately since a perfect matching is impossible. Also handles the edge case where both R and B are zero.\n3. **Permutations Generation**: All possible permutations of base indices are generated to explore every possible matching between spaceships and bases.\n4. **Intersection Check**: For each permutation, edges are formed between each spaceship and its assigned base. The `do_segments_intersect` function uses the cross product (orientation) to determine if any two edges intersect.\n5. **Result Determination**: If any permutation results in all edges not intersecting, print \"Yes\" and exit. If no valid permutation is found after checking all possibilities, print \"No\".\n\nThis approach efficiently checks all possible matchings for the non-intersection condition, leveraging the small input size to make brute-force feasible.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else -1\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    it = iter(data)\n    R = int(next(it)); B = int(next(it))\n    \n    rebels = []\n    for _ in range(R):\n        x = int(next(it)); y = int(next(it))\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(next(it)); y = int(next(it))\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    if R == 0:\n        print(\"Yes\")\n        return\n        \n    perms = list(itertools.permutations(range(B)))\n    \n    def check_assignment(perm):\n        edges = []\n        for i in range(R):\n            s = rebels[i]\n            b = bases[perm[i]]\n            edges.append((s, b))\n            \n        n_edges = len(edges)\n        for i in range(n_edges):\n            for j in range(i+1, n_edges):\n                a, b = edges[i]\n                c, d = edges[j]\n                if do_segments_intersect(a, b, c, d):\n                    return False\n        return True\n        \n    for perm in perms:\n        if check_assignment(perm):\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 982,
        "thoughts_token_count": 1023
    }
}