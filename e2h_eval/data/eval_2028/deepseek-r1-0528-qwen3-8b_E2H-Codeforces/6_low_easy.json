{
    "start": 1758088077.7110798,
    "end": 1758089229.7783551,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of [l, r, cost]\n Conditions:\n   Two vouchers i and j (i != j) such that:\n     1. They don't intersect: either ri < lj or rj < li.\n     2. The sum of durations is exactly x: (ri - li + 1) + (rj - lj + 1) = x.\n\n We are to find the minimal total cost.\n\n Steps:\n\n 1. Note: duration_i = d_i = (r_i - l_i + 1). Then we need two vouchers with durations d1 and d2 such that d1 + d2 = x.\n\n 2. We can group vouchers by their duration. However, note that the condition for disjointness is more complex.\n\n 3. Let's denote:\n        For voucher i: (l_i, r_i, cost_i, duration_i)\n\n 4. Since the total duration must be x, we can consider for each voucher with duration d, we look for a voucher with duration x-d.\n\n 5. But the disjoint condition: \n        Condition 1: [l1, r1] and [l2, r2] are disjoint if r1 < l2 OR r2 < l1.\n\n    This means that one voucher must end before the other starts.\n\n 6. How to efficiently check for disjointness? We cannot check every pair.\n\n 7. Plan:\n    - Precompute for each voucher: duration, and the interval [l, r].\n    - Group vouchers by duration. But note: the same duration may appear many times, but we also care about the time intervals.\n\n 8. Alternatively, we can do:\n\n    Step 1: Precompute an array for each duration from 1 to maybe max_duration (which is up to 200000) the list of intervals (or the necessary information) for that duration.\n\n    But note: x is at most 200000, so we only need to consider durations d and x-d.\n\n    Step 2: We want to consider pairs (d, x-d) for d in [1, x-1].\n\n    However, the disjoint condition requires that the two intervals do not overlap. So we need to know the earliest start and the latest end for a given duration? Or perhaps we can precompute for each duration the set of intervals, but that might be too heavy.\n\n 9. Another idea:\n\n    We can preprocess two arrays:\n\n        - One array for all vouchers, sorted by l (start) and then by r (end) or vice versa.\n\n    But note: the disjoint condition is symmetric. We have two cases: \n        Case 1: First voucher ends before the second starts -> r1 < l2.\n        Case 2: Second voucher ends before the first starts -> r2 < l1.\n\n    But note: we don't know which one is first. However, we can consider two orders.\n\n    However, note: the problem does not require the order of travel. The two vouchers can be taken independently as long as they don't overlap.\n\n    Actually, the condition is: either r1 < l2 OR r2 < l1. This is equivalent to saying that the two intervals do not overlap.\n\n 10. Alternate approach:\n\n     We can try to fix the first voucher and then search for a second one that has duration = x - d1 and that satisfies the disjoint condition.\n\n     But with n up to 200000, we cannot iterate over each voucher and then over each matching duration.\n\n 11. We can use:\n\n     - Create a dictionary mapping duration to a list of (l, r, cost) for each voucher.\n\n     Then, for each duration d, we look for duration d2 = x - d.\n\n     Now, for a fixed d and d2, we have two sets of intervals. We want to choose one interval from set1 (duration d) and one from set2 (duration d2) such that they are disjoint and the total cost is minimized.\n\n     How to check disjointness? \n\n        Condition: [l1, r1] and [l2, r2] are disjoint if r1 < l2 OR r2 < l1.\n\n        But note: we have two sets, so we have to consider both orders? Actually, we can break the condition into two cases.\n\n        However, we can also think: without loss of generality, assume the first voucher has duration d and the second has duration d2. Then we have two possibilities:\n\n            Possibility 1: The first voucher ends before the second starts: r1 < l2.\n            Possibility 2: The second voucher ends before the first starts: r2 < l1.\n\n        But wait: the two vouchers are independent, so we can consider:\n\n            We need to choose two intervals I and J",
    "response": "\nTo solve this problem, we need to find two non-overlapping travel vouchers such that the sum of their durations equals a given value \\( x \\), and their total cost is minimized. The solution involves efficiently searching through the vouchers grouped by their durations and checking for non-overlapping conditions.\n\n### Approach\n1. **Group Vouchers by Duration**: We first categorize all vouchers based on their duration. This allows us to quickly access all vouchers that contribute to a specific part of the required total duration \\( x \\).\n\n2. **Check Valid Pairs**: For each voucher with duration \\( d \\), we look for another voucher with duration \\( x - d \\). The key insight here is that the two vouchers must not overlap in time. This means either the first voucher ends before the second starts or vice versa.\n\n3. **Efficient Search for Non-Overlapping Vouchers**: To efficiently check for non-overlapping pairs, we sort the vouchers within each duration group by their start date (or end date). This allows us to use binary search to find the earliest possible start date or the latest possible end date that ensures non-overlapping with the current voucher.\n\n4. **Minimize Total Cost**: For each valid pair of vouchers, we keep track of the minimum total cost encountered. If no such pair exists, we return -1.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    \n    vouchers = []\n    max_day = 0\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n        max_day = max(max_day, r)\n    \n    duration_map = defaultdict(list)\n    for l, r, cost_val in vouchers:\n        dur = r - l + 1\n        duration_map[dur].append((l, r, cost_val))\n    \n    for key in duration_map:\n        duration_map[key] = sorted(duration_map[key], key=lambda x: x[0])\n    \n    min_total_cost = float('inf')\n    found = False\n    \n    for dur, vouchers_list in duration_map.items():\n        other_dur = x - dur\n        if other_dur <= 0:\n            continue\n            \n        if other_dur not in duration_map:\n            continue\n            \n        other_vouchers = duration_map[other_dur]\n        \n        if dur == other_dur:\n            used = set()\n            for idx, (l1, r1, cost1) in enumerate(vouchers_list):\n                if idx in used:\n                    continue\n                l2_min = 0\n                r2_max = 0\n                pos = bisect.bisect_left(other_vouchers, (l1, r1, 0))\n                if pos < len(other_vouchers):\n                    cand1 = other_vouchers[pos][1]\n                else:\n                    cand1 = -1\n                    \n                pos2 = bisect.bisect_right(other_vouchers, (l1-1, 10**9, 0)) - 1\n                if pos2 >= 0:\n                    cand2 = other_vouchers[pos2][0]\n                else:\n                    cand2 = 10**9\n                    \n                if cand1 < l1 or cand2 < l1:\n                    total_cost = cost1 + other_vouchers[pos if cand1 < l1 else pos2][2]\n                    min_total_cost = min(min_total_cost, total_cost)\n                    used.add(idx)\n                    if len(used) * 2 >= len(vouchers_list):\n                        break\n            continue\n                \n        left_ptr = 0\n        right_ptr = len(other_vouchers) - 1\n        \n        for l1, r1, cost1 in vouchers_list:\n            while left_ptr <= right_ptr:\n                mid = (left_ptr + right_ptr) // 2\n                l2, r2, cost2 = other_vouchers[mid]\n                if r1 < l2:\n                    min_total_cost = min(min_total_cost, cost1 + cost2)\n                    found = True\n                    break\n                elif r2 < l1:\n                    min_total_cost = min(min_total_cost, cost1 + cost2)\n                    found = True\n                    break\n                else:\n                    if r2 > l1:\n                        left_ptr = mid + 1\n                    else:\n                        right_ptr = mid - 1\n        \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    import bisect\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into a list of tuples, each representing a voucher's start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary where keys are durations and values are lists of vouchers sorted by start day.\n3. **Checking Valid Pairs**: For each duration \\( d \\), we check if there exists another duration \\( x - d \\). For each voucher in \\( d \\), we use binary search to find a voucher in \\( x - d \\) that does not overlap with it.\n4. **Binary Search for Efficiency**: The binary search helps in quickly locating the earliest start date or latest end date in the other duration group that ensures non-overlapping with the current voucher.\n5. **Cost Calculation**: The total cost of valid pairs is tracked, and the minimum cost is updated whenever a cheaper valid pair is found.\n6. **Output Result**: If no valid pair is found, -1 is printed; otherwise, the minimum total cost is printed.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    \n    vouchers = []\n    max_day = 0\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n        max_day = max(max_day, r)\n    \n    duration_map = defaultdict(list)\n    for l, r, cost_val in vouchers:\n        dur = r - l + 1\n        duration_map[dur].append((l, r, cost_val))\n    \n    for key in duration_map:\n        duration_map[key] = sorted(duration_map[key], key=lambda x: x[0])\n    \n    min_total_cost = float('inf')\n    found = False\n    \n    for dur, vouchers_list in duration_map.items():\n        other_dur = x - dur\n        if other_dur <= 0:\n            continue\n            \n        if other_dur not in duration_map:\n            continue\n            \n        other_vouchers = duration_map[other_dur]\n        \n        if dur == other_dur:\n            used = set()\n            for idx, (l1, r1, cost1) in enumerate(vouchers_list):\n                if idx in used:\n                    continue\n                l2_min = 0\n                r2_max = 0\n                pos = bisect.bisect_left(other_vouchers, (l1, r1, 0))\n                if pos < len(other_vouchers):\n                    cand1 = other_vouchers[pos][1]\n                else:\n                    cand1 = -1\n                    \n                pos2 = bisect.bisect_right(other_vouchers, (l1-1, 10**9, 0)) - 1\n                if pos2 >= 0:\n                    cand2 = other_vouchers[pos2][0]\n                else:\n                    cand2 = 10**9\n                    \n                if cand1 < l1 or cand2 < l1:\n                    total_cost = cost1 + other_vouchers[pos if cand1 < l1 else pos2][2]\n                    min_total_cost = min(min_total_cost, total_cost)\n                    used.add(idx)\n                    if len(used) * 2 >= len(vouchers_list):\n                        break\n            continue\n                \n        left_ptr = 0\n        right_ptr = len(other_vouchers) - 1\n        \n        for l1, r1, cost1 in vouchers_list:\n            while left_ptr <= right_ptr:\n                mid = (left_ptr + right_ptr) // 2\n                l2, r2, cost2 = other_vouchers[mid]\n                if r1 < l2:\n                    min_total_cost = min(min_total_cost, cost1 + cost2)\n                    found = True\n                    break\n                elif r2 < l1:\n                    min_total_cost = min(min_total_cost, cost1 + cost2)\n                    found = True\n                    break\n                else:\n                    if r2 > l1:\n                        left_ptr = mid + 1\n                    else:\n                        right_ptr = mid - 1\n        \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    import bisect\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 734,
        "completion_token_count": 1226,
        "thoughts_token_count": 1023
    }
}