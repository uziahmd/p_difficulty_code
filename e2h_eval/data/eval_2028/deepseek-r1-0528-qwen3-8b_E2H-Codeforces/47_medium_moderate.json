{
    "start": 1758296911.3540084,
    "end": 1758300360.6495454,
    "start-formatted": "2025-09-20 00:48 KST",
    "end-formatted": "2025-09-20 01:46 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (with 1 <= a,b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b (if a < b then d is negative, but we can assume without loss of generality that we set x = a+k and y = b+k, then note that |x-y| = |a-b| is fixed.\n\nWe have:\n  Let g = gcd(x, y) = gcd(a+k, b+k). Then we know that:\n      LCM(x, y) = (x * y) / g\n\nBut note: x = a+k, y = b+k, so x-y = a-b (a constant).\n\nWe can also write: \n  Let d = |a-b|. Then without loss of generality, assume a>=b? Actually, we can consider the absolute difference.\n\nHowever, note: if k increases, then both x and y increase by the same amount. The LCM is (x*y)/gcd(x,y). Since x and y are increasing, we cannot iterate over all k from 0 to ... because k might be very large.\n\nAlternative approach:\n\nConsider the condition for k. Note that the LCM must be as small as possible. The LCM is minimized when the product (x*y) is minimized relative to the gcd (which divides both). But note that the gcd must divide the difference (x-y)=a-b. So let d = |a-b|.\n\nThen, any common divisor of x and y must divide d. Therefore, the gcd(x,y) must be a divisor of d.\n\nSo, the idea is to consider all divisors of d (the absolute difference) and then for each divisor g (which will be the gcd), we can try to find the smallest k such that g divides both (a+k) and (b+k). \n\nNote: For g to divide both (a+k) and (b+k), then g must divide (a+k) and (b+k). But note that (a+k) - (b+k) = a-b. So g must divide (a-b). That is why g must be a divisor of d = |a-b|.\n\nNow, for a fixed divisor g (which is positive) of d, we want the smallest non-negative k such that:\n   (a+k) mod g == 0   and   (b+k) mod g == 0.\n\nBut note: if g divides (a+k) and (b+k), then it must divide (a-b). This condition is already satisfied because g divides d.\n\nNow, we can solve for k modulo g. However, note that k must be chosen so that:\n   k ≡ (-a) mod g   and   k ≡ (-b) mod g.\n\nSince g divides (a-b), then (-a) mod g and (-b) mod g are related: indeed, (-a) ≡ (-b + (b-a)) mod g, but since g divides (a-b) (so (a-b)%g==0), then (b-a)%g==0, so the two congruences are consistent.\n\nThe smallest non-negative k that satisfies both is the smallest k such that:\n   k ≡ (-a) mod g   (and similarly for b).\n\nBut note: we can write k = t*g - a (if we adjust for the modulus). However, we require k >=0 and the smallest k that satisfies the congruence.\n\nActually, we can compute the remainder when a is divided by g, and then k must be such that (a+k) is divisible by g. So k must be at least (g - (a % g)) % g? But wait, if a % g == 0, then k=0? Not necessarily: we require both conditions.\n\nAlternatively, we can consider:\n\n   k ≡ (-a) mod g   =>   k ≡ (g - (a % g)) % g   [unless a%g==0, then k=0 mod g, but then we can take k=0]\n\nBut note: if we define r = a % g, then we require (a+k) % g == 0 => k ≡ (-r) mod g. The smallest non-negative k is (g - r) % g. However, if r==0 then k=0 is the solution.\n\nBut wait: we have two conditions. However, because (a-b) is divisible by g, then (b % g) = (a % g) (because (a-b)%g=0). So the two conditions are the same: k ≡ (-a) mod g and k ≡ (-b) mod g are equivalent because a ≡ b mod g.\n\nTherefore, for divisor g, the condition is just one congruence: k ≡ (-a) mod g.\n\nBut note: we must also consider that k must be non-negative.\n\nSo for each divisor g of d (where d = |a-b|), we can compute:\n\n   candidate_k = (g - (a % g)) % g   [but if a%g==0, then candidate_k=0]\n\nHowever, note: if we do (g - (a % g)) % g, then when a%g==0, (a%g)==0, so (g-0)%g = g % g = 0. So that formula works.\n\nBut wait: what if we set g to be a divisor of d, but note: d can be zero? Then if a==b, then d=0. Then the divisors of 0 are undefined? Actually, if a==b, then the problem becomes: find k minimizing LCM(a+k, a+k) = a+k. So the smallest k is 0 (since k>=0). \n\nSo we must handle the case a==b separately.\n\nAlso, note: the divisors of d (when d !=0) are the divisors of |a-b|.\n\nBut note: the divisors of d include positive divisors only (since g is a divisor and we are working with positive modulus).\n\nHowever, we must consider: what if d=0? Then we output k=0.\n\nNow, the problem: we are to minimize the LCM, which is (x*y)/g = ((a+k)*(b+k))/g. But note: we don't know which g (divisor) will yield the smallest LCM. Also, note that k is determined by the divisor g (via the congruence above). \n\nBut note: there might be multiple divisors, and for each divisor we get a candidate k. Then we must compute the LCM for that candidate k and then choose the candidate k that minimizes the LCM (and if two k's give the same LCM, choose the smallest k).\n\nHowever, note: the LCM for a candidate k is (a+k)*(b+k) / g. But wait: is g the gcd of (a+k) and (b+k)? Yes, because we set g to be the divisor and we found k so that g divides both, but actually the gcd might be larger than g. \n\nWait, that's an issue. Our method sets g as a divisor, but the actual gcd might be a multiple of g? Actually, no: we are iterating over divisors of d, and we are setting the gcd to be g? Actually, no: we are forcing that g divides both (a+k) and (b+k). But the actual gcd could be any multiple of g (as long as it divides d). However, note: the gcd must divide d, so the actual gcd is a divisor of d. But we are not guaranteed that the gcd is exactly g. \n\nBut note: our candidate k is chosen so that g divides (a+k) and (b+k). However, the gcd might be a multiple of g (if there is a larger divisor that divides both). Then how can we account for that?\n\nActually, we are iterating over all divisors of d (the absolute difference). Then the candidate k we get for divisor g might be the same for multiple divisors. Moreover, the actual gcd for the candidate k is the gcd of (a+k) and (b+k). Since (a+k)-(b+k)=d, the gcd must divide d. Therefore, the set of divisors we consider is complete.\n\nBut here's the catch: the candidate k we compute for a divisor g is the smallest non-negative k such that g divides (a+k) and (b+k). However, for that k, the gcd might be greater than g (if there is a divisor of d that is a multiple of g and divides (a+k) and (b+k)). But note: we are going to consider every divisor. So we are going to consider the divisor that is the actual gcd as well.\n\nBut wait: the candidate k we get for a divisor g might be the same as the candidate k for a divisor h (if h divides d and g divides d, and the congruences coincide). However, we are going to consider every divisor, so we will compute the LCM for that k using the actual gcd (which we don't know until we compute it). \n\nBut note: we are trying to minimize the LCM. The LCM is (x*y)/gcd(x,y). Since x and y are increasing with k, but the denominator (gcd) can be larger, so the LCM might be smaller.\n\nHow can we compute the LCM for candidate k? We would have to compute gcd(x,y) and then the LCM. But note: the candidate k was chosen so that g divides (a+k) and (b+k). However, the actual gcd might be a multiple of g. But we don't know the exact gcd without checking.\n\nBut note: the problem does not require us to use the divisor g to compute the LCM. We must use the actual gcd. However, we are iterating over divisors, so we can also consider that the actual gcd is one of the divisors of d. And we are going to consider every divisor. But the candidate k we get for a divisor g might be the same for multiple divisors (if they are divisors of d and the congruences match). \n\nBut we are going to consider every divisor. Then we compute the LCM for the candidate k (using the actual gcd). However, the candidate k we get for a divisor g is the smallest k that makes g divide both. But maybe a different divisor h (larger than g) also divides both, and then the candidate k for h might be different and yield a smaller LCM.\n\nSo the plan is:\n\n1. If a == b: output 0.\n\n2. Otherwise, let d = abs(a-b). Then find all divisors of d.\n\n3. For each divisor g (positive) of d, compute candidate_k = (g - (a % g)) % g.\n\n   But note: we must ensure that k is non-negative and the smallest.\n\n4. Then, for each candidate_k, we must check that (b+k) is divisible by g as well (it should be, by construction). Then, we compute the actual gcd of (a+k) and (b+k). Then compute the LCM = (a+k)*(b+k)//gcd.\n\n5. Then, we compare the LCM for all candidate_k's (and note: the same k might appear from different divisors, so we must avoid duplicates). However, we are interested in the minimal LCM and then the smallest k.\n\nBut wait: is it efficient to iterate over all divisors (which can be up to about 1344 divisors for numbers around 10^9) and then for each candidate k (which is at most the divisor value, but we are computing k from the modulus) and then compute the gcd and the product? The product can be very large (a,b up to 10^9, so k is at most ... the maximum candidate_k from divisors is at most d, which is up to 10^9, then (a+k) and (b+k) can be up to 2e9, so the product is 4e18, which is acceptable in Python for integers, but the gcd computation is O(log(n)), so it's acceptable.\n\nHowever, note: we must avoid duplicates. The same k might be generated by multiple divisors. So we can store the candidate k and the corresponding LCM, then at the end choose the minimal LCM and then the smallest k.\n\nBut wait: we don't know the LCM until we compute the actual gcd. However, we have a candidate k, and we can compute the LCM from the candidate k. But note: we are iterating over divisors, and the same k might be generated by multiple divisors. We want to compute the LCM only once per distinct k.\n\nAlternatively, we can collect distinct candidate k's and then for each distinct candidate k, compute the gcd and the LCM. But note: the candidate k is determined by the divisor g. However, two different divisors might lead to the same candidate k.\n\nBut note: the candidate k is the solution to k ≡ (-a) mod g. There might be multiple divisors g that satisfy the condition and yield the same k.\n\nBut we must compute the LCM for that k. However, we cannot compute the LCM without knowing the gcd. But the gcd for a fixed k is the gcd of (a+k) and (b+k). We can compute that.\n\nSo the algorithm:\n\n   candidates = {}   # mapping from k to LCM (or we can store (k, lcm))\n\n   Steps:\n\n   if a == b:\n        print(0)\n        return\n\n   d = abs(a-b)\n\n   Find all divisors of d.\n\n   For each divisor g in divisors (including 1 and d):\n\n        k0 = (g - a % g) % g   [this gives the smallest non-negative k for modulus g]\n\n        Then, we have candidate_k = k0.\n\n        But note: we must consider that k0 might be negative? No, because modulus operation in Python for positive g: a % g is in [0, g-1], so (g - a%g) is in [1, g] and then mod g gives in [0, g-1]. So k0 is non-negative.\n\n        Now, we must check: is k0 the smallest k? Actually, yes.\n\n        But note: we must also consider that k0 might be the same for different divisors.\n\n        Then, we can record candidate_k.\n\n        Then, we compute x = a + k0, y = b + k0.\n        Then, compute g0 = gcd(x, y)\n        Then, LCM = (x * y) // g0\n\n        Then, we store (candidate_k, LCM)\n\n   Then, we also must consider k=0? Actually, we are including divisor g=1, so k0 for g=1 is (1 - a%1) % 1. But a%1 is always 0, so (1-0)%1 = 1%1=0. So k0=0 is considered.\n\n   However, note: we are iterating over divisors of d, but if d=0 we skip (handled above). So we are good.\n\n   Then, we must consider: is it possible that there is a k that is not generated by any divisor of d? \n\n   Remember: the gcd of (a+k) and (b+k) must divide (a-b)=d. So the gcd must be a divisor of d. Therefore, the candidate k we get from the divisors will cover all possibilities. However, note: the candidate k we get for divisor g is the smallest k that makes g divide (a+k) and (b+k). But there might be a k that is not the smallest for any divisor but still leads to a lower LCM? \n\n   Actually, no: because the LCM is determined by the actual gcd (which is a divisor of d). And for the actual gcd (say g0) we would have candidate_k0 = (g0 - (a % g0)) % g0. But note: the actual k we use might be larger than that candidate_k0. However, we are looking for the minimal LCM. But note: the LCM is (x*y)/g0. As k increases, x and y increase, so the product increases. However, the gcd might change (to a divisor of d). \n\n   But note: we are considering the minimal k for each divisor. However, the minimal k for a divisor g is the smallest k that makes g divide (a+k) and (b+k). But there might be a larger k that yields a divisor g' (with g' being a divisor of d) and a smaller LCM? \n\n   Example: Consider a=6, b=10, d=4. Divisors: 1,2,4.\n\n   For g=1: k0=0 -> x=6, y=10, gcd=2, LCM=30.\n   For g=2: k0= (2-6%2)%2 = (2-0)%2=0 -> same k0=0, then same result.\n   For g=4: k0= (4-6%4)%4 = (4-2)%4=2 -> k=2, then x=8, y=12, gcd=4, LCM=24.\n\n   So we found k=2.\n\n   But what if we consider k=1? \n        x=7, y=11, gcd=1, LCM=77 -> worse.\n\n   k=3: x=9, y=13, gcd=1, LCM=117 -> worse.\n\n   k=4: x=10, y=14, gcd=2, LCM=70 -> worse.\n\n   So the minimal k is 2.\n\n   But note: the candidate k we found is 0 and 2. We computed the LCM for k=0 and k=2.\n\n   However, note: the divisor g=2 gave the same k=0 as g=1. So we don't miss k=0.\n\n   But wait: what if there is a divisor g that does not divide d? We don't consider them. But the gcd must divide d, so we are safe.\n\n   However, note: the candidate k we get from divisor g is the smallest k that makes g divide (a+k) and (b+k). But there might be a k that is not the smallest for any divisor but still yields a divisor g (from d) that is larger? \n\n   Actually, the set of k that make the gcd divisible by g is periodic with period g. So the minimal k for a divisor g is the first occurrence. And we must consider all divisors.\n\n   But note: the LCM is determined by the actual gcd (which is a divisor of d). The minimal k for a divisor g might be the same as the minimal k for a divisor h (if they are multiples or something). \n\n   However, the problem is that we are iterating over divisors, and we are computing the candidate k for each divisor. Then we compute the LCM for that candidate k (using the actual gcd). But note: the actual gcd for candidate k (computed from divisor g) might be larger than g. Then, we are effectively considering the same k multiple times (for divisors that are divisors of the actual gcd). \n\n   But that's okay because we are storing the candidate k and the LCM. We are going to consider the same k multiple times, but then we can avoid recalculating the same k.\n\n   However, we can optimize by storing the candidate k's we've seen. But note: the same k might appear from different divisors, so we can break early? Actually, we are storing the LCM for each k, and we want the minimal LCM and then the smallest k.\n\n   But wait: is it possible that the same k appears from multiple divisors? Yes, as in the example above.\n\n   So we can do:\n\n        Let best_LCM = None\n        Let best_k = None\n\n        For each divisor g of d (including d itself and 1):\n\n            k0 = (g - a % g) % g   [if g==0, skip but we don't have g=0]\n\n            Then, if we have not processed k0 before, then:\n\n                x = a + k0\n                y = b + k0\n                g0 = gcd(x, y)\n                LCM_val = (x * y) // g0\n\n                Then, compare with best_LCM.\n\n            But wait: we are going to process the same k0 again if it appears from another divisor. Then we compute the LCM twice. But note: the LCM depends on k0, and k0 is fixed. So we can store the LCM for k0 in a dictionary.\n\n        Alternatively, we can do:\n\n            candidates = {}   # k: LCM\n\n            For each divisor g of d:\n                k0 = (g - a % g) % g\n\n                if k0 not in candidates:\n                    x = a + k0\n                    y = b + k0\n                    g0 = gcd(x, y)\n                    LCM_val = (x * y) // g0\n                    candidates[k0] = LCM_val\n\n            Then, we must also consider: is there a possibility that a k that is not generated by any divisor exists? \n\n            Remember: the gcd must divide d, so the k must be such that the gcd (which is a divisor of d) divides (a+k) and (b+k). But the minimal k for a divisor g is the candidate we generate. However, there might be a k that is not the minimal for any divisor but still yields a divisor (from d) that divides (a+k) and (b+k). \n\n            But note: for a divisor g, the set of k that satisfy the condition is: k ≡ (-a) mod g. The minimal non-negative k is k0. Then, the next k is k0 + g, then k0 + 2g, etc. So we are only generating the minimal k for each divisor. However, the minimal k overall might be one of these minimal k's for some divisor? \n\n            Why? Because the LCM is (x*y)/gcd(x,y). As k increases, the product increases (unless the gcd increases, which might reduce the LCM). But note: the minimal k for a divisor g might be the first time we hit that divisor. However, sometimes a larger k might yield a higher divisor (which is a divisor of d) and a smaller LCM? \n\n            Example: a=21, b=31, d=10. The divisors of 10: 1,2,5,10.\n\n            k0 for g=1: 0 -> (21,31): gcd=1, LCM=21*31=651.\n            k0 for g=2: (2-21%2)%2 = (2-1)%2=1 -> k=1 -> (22,32): gcd=2, LCM=22*32//2 = 352.\n            k0 for g=5: (5-21%5)%5 = (5-1)%5=4 -> k=4 -> (25,35): gcd=5, LCM=25*35//5=175.\n            k0 for g=10: (10-21%10)%10=(10-1)%10=9 -> k=9 -> (30,40): gcd=10, LCM=30*40//10=120.\n\n            So the minimal LCM is 120 at k=9.\n\n            But wait: is there a k between 0 and 9 that we haven't considered? \n\n            k=0: LCM=651\n            k=1: LCM=352\n            k=2: (23,33): gcd=1 -> 23*33=759\n            k=3: (24,34): gcd=2 -> 24*34//2=408\n            k=4: 175\n            k=5: (26,36): gcd=2 -> 26*36//2=468\n            k=6: (27,37): gcd=1 -> 999\n            k=7: (28,38): gcd=2 -> 28*38//2=532\n            k=8: (29,39): gcd=1 -> 1131\n            k=9: 120\n\n            So the minimal k is 9.\n\n            However, note: the minimal k for divisor 10 is 9, and we did consider it.\n\n            But why did we not consider k=9 from a divisor other than 10? Actually, we did: divisor 10 gives k0=9.\n\n            Now, what if we consider k=9+10=19? \n                (40,49): gcd=1 -> LCM=40*49=1960 -> worse.\n\n            So the minimal k is the one we found.\n\n            But note: the LCM is not necessarily monotonic. However, the minimal k for each divisor is the first k that achieves the condition for that divisor. And because the product (x*y) is increasing, and the denominator (gcd) is bounded (by d), the minimal LCM must occur at one of these minimal k's for the divisors.\n\n            Why? Consider: the LCM is (x*y)/g. As k increases, x and y increase, so the product increases. However, the denominator (gcd) might increase (if we hit a divisor that divides both). But note: the gcd can only be divisors of d, so the denominator is bounded by d. Therefore, the LCM might decrease when the denominator increases. But we are forced to wait until k hits the residue condition for that divisor.\n\n            However, the minimal k for a divisor g is the smallest k that satisfies the condition for g. And if we don't take that minimal k, we might have a larger product (since k is larger) and the same or larger denominator? Actually, the denominator might be larger if we wait for a multiple of g? But note: the gcd might be a multiple of g (if the actual divisor is a multiple of g). But we are iterating over divisors, so we are covering all divisors. \n\n            But note: the candidate k we get for divisor g is the minimal k for g, but the actual gcd might be a divisor of d that is larger than g (and then the condition for that divisor would be satisfied at a k that is the minimal for that divisor, which might be less than the minimal k for g). \n\n            Example: In the above example, the divisor 10 (which is larger than 5) gives k0=9, but the divisor 5 gives k0=4. However, the divisor 10 requires that 10 divides (a+k) and (b+k). This implies that 5 divides (a+k) and (b+k) as well. But the minimal k for 5 is 4, and at k=4, 10 does not divide (21+4)=25 (since 25/10 is not integer). Then the next k for 10 is 9 (which is 4+5). So the minimal k for 10 is 9.\n\n            Therefore, we must consider each divisor independently.\n\n            However, the key observation is: the minimal k for divisor g is the smallest k such that g divides (a+k) and (b+k). Then, the LCM at that k is (a+k)*(b+k)/gcd(a+k, b+k). Since the gcd at k0 might be greater than g, we are effectively considering the same k for multiple divisors (all divisors of the actual gcd). \n\n            But we are storing the LCM for k0 only once (if we use a dictionary). \n\n            Therefore, the algorithm:\n\n            Step 1: Handle a==b.\n\n            Step 2: d = abs(a-b)\n\n            Step 3: Find all divisors of d.\n\n            Step 4: Use a dictionary `min_lcm` to store the LCM for a particular k (key: k, value: LCM).\n\n            Step 5: For each divisor g of d (positive divisors):\n\n                    k0 = (g - a % g) % g   [if g==0, skip, but d>0 so divisors are positive]\n\n                    If k0 is already in the dictionary, skip.\n\n                    Else, compute x = a+k0, y = b+k0, and then:\n\n                        g0 = gcd(x, y)\n                        LCM_val = (x * y) // g0\n\n                    Store min_lcm[k0] = LCM_val\n\n            Step 6: Additionally, note: k must be non-negative, and we are only considering k0>=0.\n\n            Step 7: But wait: is it possible that the minimal k is not among the divisors? \n\n            We argued that the gcd must divide d, so the k must be such that the gcd (a divisor of d) divides (a+k) and (b+k). Therefore, the minimal k for each divisor is the candidate. However, note: the minimal k overall might be 0, which we have (from divisor 1). \n\n            But note: the example outputs:\n\n                Input: ['6 10', '21 31', '5 10']\n\n                Output: ['2', '9', '0']\n\n            For the third test: a=5, b=10 -> d=5.\n\n            Divisors: 1,5.\n\n            For g=1: k0 = (1-5%1)%1 -> 5%1 is 0, so k0=0 -> then x=5, y=10, gcd=5, LCM= (5*10)//5=10.\n\n            For g=5: k0 = (5-5%5)%5 = (5-0)%5=0 -> same k0.\n\n            Then, the minimal LCM is 10 at k=0.\n\n            However, what if k=0 is the answer? Then output 0.\n\n            But the example says output '0'.\n\n            However, wait: the example input \"5 10\" -> output '0'. So our algorithm returns k=0.\n\n            But note: the example also includes k=0 for the third test.\n\n            But wait: what if we consider k=0 and k=5? \n\n            k=0: LCM=10\n            k=5: x=10, y=15, gcd=5, LCM= (10*15)//5=30 -> worse.\n\n            So k=0 is the best.\n\n            However, note: the example input \"5 10\" is handled correctly.\n\n            But wait: in the example input \"5 10\", the divisor 1 and 5 both yield k0=0. Then we store the LCM for k=0 once.\n\n            Now, the problem: the divisors of d can be many (up to about 1344 for d near 10^9). But 1344 is acceptable.\n\n            However, note: the gcd computation for two numbers up to 10^9 (then k0 is at most d, so x and y are up to 10^9+d, which is about 2e9) is efficient (Euclidean algorithm is logarithmic).\n\n            But note: we must factorize d (which is up to 10^9) to get all divisors. How to factorize d? We can do trial division up to sqrt(d) (about 31622). That is acceptable.\n\n            Steps for factorization:\n\n                def get_divisors(n):\n                    if n==0: return set()\n                    divs = set()\n                    i = 1\n                    while i*i <= n:\n                        if n % i == 0:\n                            divs.add(i)\n                            divs.add(n//i)\n                        i += 1\n                    return divs\n\n            Then, we use that set of divisors.\n\n            However, note: if d==0, we skip (already handled a==b). But if a!=b, d>0.\n\n            But wait: what if a and b are negative? The problem states a,b>=1, so we don't have negatives.\n\n            So the code:\n\n            import math\n            from math import gcd as math_gcd\n\n            def get_divisors(n):\n                # returns a set of divisors of n (positive)\n                if n == 0:\n                    return set()\n                divs = set()\n                i = 1\n                # iterate until sqrt(n)\n                while i * i <= n:\n                    if n % i == 0:\n                        divs.add(i)\n                        divs.add(n//i)\n                    i += 1\n                return divs\n\n            Then:\n\n            if a == b:\n                print(0)\n                exit(0)\n\n            d = abs(a-b)\n            divisors = get_divisors(d)\n\n            best_k = None\n            best_lcm = None\n            seen_k = set()\n\n            for g in divisors:\n                # g is positive divisor\n                # Compute candidate k0\n                # We do: k0 = (g - (a % g)) % g\n                # But note: if a % g == 0, then k0=0.\n                k0 = (g - a % g) % g\n\n                if k0 in seen_k:\n                    continue\n\n                seen_k.add(k0)\n\n                x = a + k0\n                y = b + k0\n                g0 = math_gcd(x, y)\n                current_lcm = (x * y) // g0\n\n                # Now, we want to choose the candidate k that minimizes current_lcm, and if tie the smallest k.\n                if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k0 < best_k):\n                    # But wait: we are storing the best_k and best_lcm. However, we are iterating and we might have multiple k's. \n                    # However, we are comparing: if current_lcm is smaller, update. If equal, then update if k0 is smaller than the previously recorded best_k?\n                    # But note: we want the smallest k in case of tie in LCM.\n                    best_lcm = current_lcm\n                    best_k = k0\n\n            print(best_k)\n\n            However, wait: the condition for updating best_k and best_lcm: we update if current_lcm is less than best_lcm OR if equal and k0 is less than best_k.\n\n            But note: we are iterating over divisors, and we might get the same k0 from multiple divisors (but we skip duplicates). So we don't have to worry about the same k0 appearing twice.\n\n            But wait: the above condition updates even if the same k0 is encountered again? No, because we skip duplicates. But we are storing best_k and best_lcm, and we update only once per k0.\n\n            However, there is a catch: we are iterating over divisors, and we might get a k0 that is not the smallest k overall? \n\n            Example: the divisor set might have two divisors that yield the same k0, but we skip the second. Then we compute the LCM only once.\n\n            But what if we get a k0 that is not the minimal k for the actual LCM? \n\n            Actually, we are computing the LCM for k0 (the minimal k for the divisor g). And we are comparing across k0's.\n\n            However, note: the problem asks for the smallest k that minimizes the LCM. But what if two different k0's (say k1 and k2) yield the same LCM? Then we choose the smallest k0. But our update condition: if we have a new k0 that has the same LCM as the current best, then we update only if k0 is smaller than the current best_k. But wait: we are storing the best_lcm and best_k. \n\n            Example: \n                k1: LCM=100, k2: LCM=100 and k1<k2 -> then when we see k1 first, best_k=k1, best_lcm=100. Then when we see k2, we check: 100==best_lcm and k2>k1 -> so we don't update.\n\n            But what if we see k2 first? Then we set best_k=k2, best_lcm=100. Then when we see k1, we check: 100==best_lcm and k1<k2 -> then update to k1.\n\n            So we must update when we find a k0 with the same LCM and k0 is smaller.\n\n            However, we are iterating arbitrarily over the divisors. We might get a larger k0 first and then a smaller k0. So we must not break early.\n\n            But note: we are storing the best_lcm and best_k and updating whenever we find a better (or equal) LCM (with the tie-breaker). \n\n            But the problem: the number of divisors is not too large (about 1344). We can simply store the best candidate and update as we go.\n\n            However, we must consider: is it possible that a divisor gives a k0 that is very large, but then we later find a divisor that gives a much smaller k0 with the same LCM? \n\n            Yes, so we must iterate through all divisors and update accordingly.\n\n            But note: the divisors",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant (\\( |a-b| \\)). The LCM of two numbers \\( x \\) and \\( y \\) can be expressed as \\( \\frac{x \\times y}{\\text{gcd}(x, y)} \\). The gcd of \\( x \\) and \\( y \\) must divide their difference, which is \\( |a-b| \\). Therefore, any possible gcd of \\( a+k \\) and \\( b+k \\) must be a divisor of \\( |a-b| \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a-b| \\), we can compute the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is given by \\( k = (g - (a \\% g)) \\% g \\). Once we have all such \\( k \\) values, we compute the LCM for each corresponding \\( (a+k, b+k) \\) and select the \\( k \\) that yields the smallest LCM. If multiple \\( k \\) values yield the same LCM, we choose the smallest \\( k \\).\n\n3. **Algorithm Selection**:\n   - **Divisor Calculation**: First, compute all positive divisors of \\( |a-b| \\).\n   - **Candidate Generation**: For each divisor \\( g \\), compute the smallest \\( k \\) that satisfies the condition \\( g \\) divides both \\( a+k \\) and \\( b+k \\).\n   - **LCM Calculation**: For each unique \\( k \\), compute the LCM of \\( a+k \\) and \\( b+k \\) using their gcd.\n   - **Optimal Selection**: Track the \\( k \\) with the smallest LCM, breaking ties by selecting the smallest \\( k \\).\n\n4. **Complexity Analysis**: The most computationally intensive part is finding all divisors of \\( |a-b| \\), which can be up to \\( O(\\sqrt{n}) \\) where \\( n \\) is \\( |a-b| \\). Given the constraints \\( 1 \\leq a, b \\leq 10^9 \\), the worst-case \\( |a-b| \\) is \\( 10^9 \\), and its square root is \\( 31622 \\), making the divisor calculation feasible.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd as math_gcd\n\ndef get_divisors(n):\n    if n == 0:\n        return set()\n    divs = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divs.add(i)\n            divs.add(n // i)\n        i += 1\n    return divs\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    \n    seen_k = set()\n    best_k = None\n    best_lcm = None\n    \n    for g in divisors:\n        r = a % g\n        if r == 0:\n            k0 = 0\n        else:\n            k0 = g - r\n            \n        if k0 in seen_k:\n            continue\n            \n        seen_k.add(k0)\n        \n        x = a + k0\n        y = b + k0\n        g0 = math_gcd(x, y)\n        current_lcm = (x * y) // g0\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k0 < best_k):\n            best_lcm = current_lcm\n            best_k = k0\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\). If they are equal, it immediately returns \\( 0 \\) since the LCM of \\( a+0 \\) and \\( b+0 \\) is trivially minimized.\n2. **Divisor Calculation**: The function `get_divisors` computes all positive divisors of \\( |a-b| \\) by checking each integer up to the square root of \\( |a-b| \\).\n3. **Candidate Generation**: For each divisor \\( g \\), the smallest \\( k \\) ensuring \\( g \\) divides both \\( a+k \\) and \\( b+k \\) is calculated. This \\( k \\) is derived from the modulus operation.\n4. **LCM Calculation**: For each unique \\( k \\), the LCM of \\( a+k \\) and \\( b+k \\) is computed using their gcd. The solution keeps track of the smallest LCM encountered, updating the best \\( k \\) whenever a smaller LCM is found or when the same LCM corresponds to a smaller \\( k \\).\n5. **Output**: The optimal \\( k \\) is printed, which minimizes the LCM of \\( a+k \\) and \\( b+k \\). \n\nThis approach efficiently narrows down the candidates for \\( k \\) by leveraging mathematical properties of divisors and gcd, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd as math_gcd\n\ndef get_divisors(n):\n    if n == 0:\n        return set()\n    divs = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divs.add(i)\n            divs.add(n // i)\n        i += 1\n    return divs\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    \n    seen_k = set()\n    best_k = None\n    best_lcm = None\n    \n    for g in divisors:\n        r = a % g\n        if r == 0:\n            k0 = 0\n        else:\n            k0 = g - r\n            \n        if k0 in seen_k:\n            continue\n            \n        seen_k.add(k0)\n        \n        x = a + k0\n        y = b + k0\n        g0 = math_gcd(x, y)\n        current_lcm = (x * y) // g0\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k0 < best_k):\n            best_lcm = current_lcm\n            best_k = k0\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1212,
        "thoughts_token_count": 8191
    }
}