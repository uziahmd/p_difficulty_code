{
    "start": 1758299311.7381976,
    "end": 1758302860.5682104,
    "start-formatted": "2025-09-20 01:28 KST",
    "end-formatted": "2025-09-20 02:27 KST",
    "gpu": 2,
    "pid": 53,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# You're Given a String...\n\nYou're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).\n\n## Input\nThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n\n## Output\nOutput one number — length of the longest substring that can be met in the string at least twice.\n\n## Example\n### Input\n['abcd', 'ababa', 'zzz']\n\n### Output\n['0', '3', '2']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are guaranteed the string length is at most 100, so we can use a straightforward approach.\n Steps:\n 1. Read the input string.\n 2. We want to find the longest substring that appears at least twice (and they can overlap).\n 3. We can consider all possible substrings and check for duplicates. However, note that the problem asks for the longest such substring.\n\n Approach:\n Since the maximum length of the string is 100, we can try from the longest possible substring (which is floor(n/2) because two copies must be present, but note: they can overlap so we might have a substring that is longer than n/2? Actually, no: if we have two occurrences, even if they overlap, the total length of two occurrences would require at least as much space as the length of the substring repeated. However, note the problem says \"at least twice\", and the two occurrences can overlap.\n\n But note: Consider \"ababa\". The substring \"aba\" appears twice: starting at index0 and index2. So the two occurrences overlap.\n\n However, the entire string is 5 characters. The longest substring that appears twice is \"aba\" (length 3). \n\n How to do it?\n We can iterate over all substring lengths from the maximum possible down to 1, and for each length, check every substring of that length and see if it appears at least twice.\n\n However, note: the maximum length of a substring that can appear twice is floor(n/2)*2? Actually, no. Because if we have two overlapping occurrences, the substring length L must satisfy: 2*L - (L - (n - L)) ??? Maybe not. Alternatively, we can think: the two occurrences must be distinct in starting indices, and the second occurrence starts at an index >= first occurrence's start + 1 (if we don't require non-overlapping) but actually they can overlap arbitrarily. However, the constraint is that the entire substring must appear twice.\n\n But note: the problem does not require the two occurrences to be non-overlapping. So the same substring can appear in overlapping positions.\n\n Example: \"aaa\" -> the substring \"a\" appears three times. But also \"aa\" appears twice: [0:2] and [1:3]. So the longest substring that appears twice is \"aa\", which has length 2.\n\n However, the example input includes: \n   Input: ['abcd', 'ababa', 'zzz']\n   Output: ['0', '3', '2']\n\n So for \"abcd\": no substring appears twice -> output 0.\n For \"ababa\": the substring \"aba\" appears twice (at index0 and index2) -> output 3.\n For \"zzz\": the substring \"z\" appears three times, and \"zz\" appears twice (at index0 and index1) -> so the longest is 2.\n\n Alternate approach:\n We can use a set or dictionary to store all substrings and their frequencies. But then we have to consider the length. We want the maximum length.\n\n Steps:\n 1. Let n = len(s)\n 2. We'll iterate over all possible lengths from n//2 down to 1 (but note: the two occurrences must be distinct, so the maximum length cannot exceed n-1, because if we have a substring of length n, then we need two of them, but there's only one occurrence of the whole string. Actually, wait: two occurrences of a substring of length L must appear. The entire string is one occurrence, so we cannot have two entire strings. But note: the two occurrences can be the same contiguous block? No, they must be two distinct starting indices.\n\n However, note: the problem says \"at least twice\", meaning two or more. So if we have two distinct starting indices (even if the substring is the whole string, then we need two whole strings, which requires the string to be duplicated. But the string is given, so we cannot have two whole strings unless the string is duplicated. \n\n Actually, the two occurrences must be in the same string. So the maximum length L must satisfy: there exists two starting indices i and j (i < j) such that s[i:i+L] == s[j:j+L]. The condition for j is that j <= n - L.\n\n Now, what is the maximum L? It can be at most n-1? Actually, no: consider \"abcabc\" (n=6). The substring of length 3 \"abc\" appears twice. But the entire string is 6, so the maximum L is 3. However, the two occurrences of \"abc\" do not require the entire string to be duplicated, just two copies.\n\n How to compute the maximum L? Actually, the two occurrences can be anywhere, so the maximum L is limited by the fact that we need two distinct starting indices. The minimal condition is that the substring of length L must appear at least twice.\n\n",
    "response": "\nTo solve this problem, we need to find the length of the longest substring that appears at least twice in a given string. The occurrences can overlap, which adds a bit of complexity but also allows for longer substrings to be considered.\n\n### Approach\n1. **Problem Analysis**: The task is to identify the longest contiguous sequence of characters within a string that appears at least twice. The key observation here is that these occurrences can overlap, meaning the same substring can start at different positions within the string.\n2. **Intuition**: The solution involves checking all possible substrings of the string from the longest to the shortest. For each substring length, we check if there are at least two distinct starting positions where the substring appears. The first such length found during this process will be the answer since we are checking from the longest to the shortest.\n3. **Algorithm Selection**: We use a nested loop approach:\n   - The outer loop iterates over possible substring lengths, starting from the maximum possible (which is half the string length) down to 1.\n   - The inner loop checks all substrings of the current length and uses a set to track seen substrings. If a substring is encountered more than once, it means it appears at least twice, and we return its length immediately.\n4. **Complexity Analysis**: Given the constraints (string length ≤ 100), this approach is efficient enough. The worst-case time complexity is O(n^3) due to the nested loops, but with n ≤ 100, it remains feasible.\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    n = len(s)\n    # We'll consider substring lengths from n//2 down to 1\n    # But note: two occurrences can overlap, so the maximum length might be up to n-1? Actually, no: because two occurrences require at least two starting indices, the maximum length L must satisfy L <= n - k (where k is the gap between starts). However, overlapping allows for L up to n-1 only if the string has at least two identical characters. But our approach checks from the maximum possible down.\n    # The maximum length for a substring to appear twice is floor((n + 1)/2) * 2? Actually, we don't know exactly, so we start from the maximum possible (which is n//2) but note: in \"ababa\", n=5, n//2=2, but answer is 3. So we need to consider longer substrings.\n\n    # Correction: the maximum length cannot exceed n-1 because if you take a substring of length n, it's the entire string and can appear only once. Similarly, for length n-1, it requires two starting positions separated by at least one character. However, the example \"ababa\" shows that a substring of length 3 (which is more than n//2=2) appears twice. Therefore, we must consider all lengths from min(n, n) down to 1, but practically, the maximum possible length is n-1 (if the string is like \"aaa...aa\", then the substring of length n-1 appears multiple times).\n\n    # We'll start from the maximum possible length (which is n-1) down to 1. But wait, what is the maximum length? It must be such that there are two non-overlapping or overlapping occurrences. The minimal requirement is that the substring length L must satisfy: there exists two starting indices i and j (i < j) such that j + L <= n. The maximum L is n - i_min, where i_min is the smallest gap between the start of two occurrences. However, to keep it simple, we start from the maximum possible L (which is n-1) down to 1.\n\n    # But note: if we start from n-1, then for \"abcd\": n=4, n-1=3. Substrings of length 3: \"abc\", \"bcd\" — each appears once. Then length 2: \"ab\", \"bc\", \"cd\" — each once. Then length 1: \"a\",\"b\",\"c\",\"d\" — each once. So answer 0.\n\n    # However, in \"ababa\": n=5. Start from 4: substrings \"abab\", \"baba\" — each once. Then 3: \"aba\", \"bab\", \"aba\" — \"aba\" appears twice. So answer 3.\n\n    # But wait, in \"zzz\": n=3. Start from 2: substrings \"zz\" (from index0 and index1) — appears twice. So answer 2.\n\n    # However, the above example \"ababa\" shows that starting from n-1 (which is 4) is too high because the answer is 3. So we need to adjust the starting point. The maximum length L must be such that there are two starting indices i and j (i < j) with j + L <= n. The minimal condition is j >= i + 1 (overlapping allowed). The maximum L is n - 1 (if j = i + 1, then L can be up to n - (i+1) + 1 = n - i, and i can be 0, so L = n-1). But in practice, we can start from the maximum possible L (which is n-1) down to 1.\n\n    # However, the example \"ababa\" (n=5) requires checking L=4 and then L=3. Since L=4 doesn't yield a duplicate, we proceed to L=3 and find \"aba\". \n\n    # Therefore, we'll iterate L from n-1 down to 1.\n\n    # But note: the maximum L is actually the entire string minus one, but we can also consider that the two occurrences must fit in the string. The maximum L is n - 1 (if the string is \"aaaaa\", then a substring of length 4 appears multiple times).\n\n    # We'll iterate L from n-1 down to 1:\n    #   For each starting index i from 0 to n - L:\n    #       substring = s[i:i+L]\n    #       Check if this substring has been seen before. But note: two occurrences can be anywhere, even overlapping.\n\n    # However, we must ensure that the two occurrences are distinct (different starting indices). So if we see the same substring starting at two different indices, that's valid.\n\n    # We can use a set to record substrings we've seen. But note: if we use a set, we lose information about where the substring was seen. However, we don't need the exact positions, just whether it appeared before.\n\n    # Steps for each L:\n    #   seen = set()\n    #   for i in range(0, n - L + 1):\n    #       substr = s[i:i+L]\n    #       if substr in seen:\n    #           print(L)\n    #           return\n    #       else:\n    #           seen.add(substr)\n\n    # But wait, what if the same substring appears three times? We still return the first occurrence (the longest L) that satisfies the condition.\n\n    # However, the above approach will work because we are iterating from the longest L down to 1. Once we find an L for which a substring appears at least twice, we immediately return that length.\n\n    # But note: we must consider that a substring might appear more than twice, but we only need at least two.\n\n    # Edge case: if no substring appears twice, we return 0.\n\n    # However, the example \"abcd\" returns 0.\n\n    # But there's a catch: the same substring might appear in overlapping positions, but the set will still catch it because we are storing the substring itself.\n\n    # Example: \"ababa\" for L=3: \n    #   i=0: substring \"aba\" -> not seen, add to set.\n    #   i=1: substring \"bab\" -> not seen, add to set.\n    #   i=2: substring \"aba\" -> seen! So return 3.\n\n    # This works.\n\n    # However, the above approach does not account for the fact that two occurrences must be distinct. But by checking the same substring appearing at different indices, we are ensuring distinct occurrences.\n\n    # Implementation:\n\n    # But note: the problem says the string is non-empty, so we don't need to handle empty string.\n\n    # Let's code accordingly.\n\n    # However, we can optimize by starting from the maximum possible L (which is n-1) down to 1, but note: the maximum L might be less than n-1. For example, in \"abcde\", the maximum L is 1 because no substring of length 2 or more repeats. \n\n    # We'll iterate L from min(n, n) down to 1, but note that the maximum L we need to consider is n-1 (since a substring of length n can't appear twice). So we start from L = n-1 down to 1.\n\n    # But wait, in the string \"aaa\", n=3, then L from 2 down to 1: \n    #   L=2: substring \"aa\" appears twice (at index0 and index1) -> return 2.\n\n    # Correct.\n\n    # However, let's test with \"ababa\":\n    #   n=5, L from 4 down to 1.\n    #   L=4: substrings \"abab\", \"baba\" — both unique, no return.\n    #   L=3: substrings \"aba\", \"bab\", \"aba\" — \"aba\" repeats, return 3.\n\n    # Another test: \"abcde\", n=5, L from 4 down to 1:\n    #   L=4: \"abcd\", \"bcde\" — unique.\n    #   L=3: \"abc\", \"bcd\", \"cde\" — unique.\n    #   L=2: \"ab\", \"bc\", \"cd\", \"de\" — unique.\n    #   L=1: \"a\",\"b\",\"c\",\"d\",\"e\" — unique.\n    #   Returns 0.\n\n    # This matches the sample input.\n\n    # But note: the sample input includes ['abcd', 'ababa', 'zzz'] which outputs [0, 3, 2]. Our approach will correctly output 0 for \"abcd\", 3 for \"ababa\", and for \"zzz\" (n=3): \n    #   L=2: substrings \"zz\" (from index0 and index1) — \"zz\" appears twice, so returns 2.\n\n    # Therefore, the solution is to iterate from L = n-1 down to 1, and for each L, check all substrings of length L. If any substring is found more than once, return L immediately. If no such substring is found after checking all lengths, return 0.\n\n    # However, we must consider that the two occurrences must be distinct (different starting indices). The set approach naturally ensures this because we are adding each substring along with its starting index? Actually, no: the set stores the substring itself, not the index. But that's okay because if the same substring appears again, it's the same value. \n\n    # But wait, what if the same substring appears in two different forms due to different starting indices? No, because the substring is defined by its characters. \n\n    # Example: \"ababa\" — the substring \"aba\" is the same regardless of where it starts.\n\n    # Therefore, the set approach is valid.\n\n    # Code accordingly:\n\n    # Edge: if the string length is 0 or 1, then no substring can appear twice (except for length 0, but the problem states non-empty string and minimum length 1). For length 1, we need two occurrences, which requires at least two same characters. \n\n    # Example: \"a\" -> no duplicate substring -> output 0.\n\n    # Let's adjust the loop to start from n-1 down to 1.\n\n    # However, note: the maximum L is n-1, but what if n=1? Then we start from 0. We should avoid negative indices.\n\n    # Revised plan: \n    #   If n == 0: return 0 (but guaranteed non-empty).\n    #   Iterate L from n-1 down to 1 (inclusive).\n    #       seen = set()\n    #       for i in range(0, n - L + 1):\n    #           substr = s[i:i+L]\n    #           if substr in seen:\n    #               print(L)\n    #               return\n    #           else:\n    #               seen.add(substr)\n    #   If no L found, print(0)\n\n    # But note: the set operations and substring creation for small strings (n<=100) is acceptable.\n\n    # However, we can optimize by breaking early when a duplicate is found.\n\n    # Let's write the code accordingly.\n\n    # One more edge: if the string is very long (though n<=100), but the approach is O(n^2) per L, and L goes from n-1 down to 1, so worst-case O(n^3). With n=100, the worst-case number of operations is about 100^3 = 1,000,000, which is acceptable in Python.\n\n    # Code implementation:\n\n    # But note: the problem reads from stdin and writes to stdout.\n\n    # Let's code accordingly.\n\n    # However, there is a possibility to break out as soon as we find a duplicate for a given L.\n\n    # We'll do that.\n\n    # Special case: if n==0, but guaranteed non-empty, so skip.\n\n    # Let's run the provided examples.\n\n    # Example 1: \"abcd\" (n=4)\n    #   L=3: substrings \"abc\", \"bcd\" -> no duplicates.\n    #   L=2: \"ab\", \"bc\", \"cd\" -> no duplicates.\n    #   L=1: \"a\",\"b\",\"c\",\"d\" -> no duplicates.\n    #   Output 0.\n\n    # Example 2: \"ababa\" (n=5)\n    #   L=4: \"abab\", \"baba\" -> no duplicates.\n    #   L=3: \"aba\", \"bab\", \"aba\" -> duplicate \"aba\", output 3.\n\n    # Example 3: \"zzz\" (n=3)\n    #   L=2: \"zz\", \"zz\" -> duplicate, output 2.\n\n    # All correct.\n\n    # Write the code:\n\n    n_val = len(s)\n    # If the string length is 1, then no substring of length>=1 can appear twice.\n    # We'll iterate from L = n_val-1 down to 1.\n\n    # If the string length is 0, but guaranteed non-empty, so no need to handle 0.\n    # If the string length is 1, then we start from L=0, but our loop starts from n_val-1 which is 0, and then we check L=0. But substring of length 0 is the empty string, which appears everywhere. However, the problem says \"substring\" and typically we consider non-empty substrings. Also, the problem states that the string consists of lower-case Latin letters, so empty string is not considered.\n\n    # According to the problem, the substring must appear at least twice. The empty string technically appears infinitely many times, but the problem likely implies non-empty substrings. \n\n    # However, the problem statement does not explicitly say non-empty, but the examples and context suggest non-empty. Also, the problem says \"longest substring\", and empty substring has length 0, which is the smallest. \n\n    # But the problem's sample outputs include 0, which corresponds to no non-empty substring found. \n\n    # So we are to return 0 if no non-empty substring appears twice. \n\n    # Therefore, we stick to non-empty substrings.\n\n    # We'll iterate from L = n_val-1 down to 1.\n\n    # If we find a duplicate for any L, we return L.\n\n    # Otherwise, after all L, return 0.\n\n    # Code:\n\n    # But note: the maximum L we consider is n_val-1, but sometimes a substring of length greater than n_val//2 might appear twice (like \"aba\" in \"ababa\"). Our loop handles that because we start from the top.\n\n    for L in range(n_val-1, 0, -1):\n        seen = set()\n        found = False\n        for i in range(0, n_val - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                return\n            seen.add(substr)\n    print(0)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\nThe solution involves checking all possible substrings of the given string from the longest to the shortest. For each length, it checks every substring of that length to see if it appears more than once. The first length for which a duplicate substring is found is returned immediately, as it is the longest possible substring meeting the criteria. If no such substring is found after checking all lengths, the solution returns 0, indicating no substring appears at least twice. The algorithm efficiently handles overlapping occurrences by using a set to track seen substrings during each length iteration.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    n = len(s)\n    # We'll consider substring lengths from n//2 down to 1\n    # But note: two occurrences can overlap, so the maximum length might be up to n-1? Actually, no: because two occurrences require at least two starting indices, the maximum length L must satisfy L <= n - k (where k is the gap between starts). However, overlapping allows for L up to n-1 only if the string has at least two identical characters. But our approach checks from the maximum possible down.\n    # The maximum length for a substring to appear twice is floor((n + 1)/2) * 2? Actually, we don't know exactly, so we start from the maximum possible (which is n//2) but note: in \"ababa\", n=5, n//2=2, but answer is 3. So we need to consider longer substrings.\n\n    # Correction: the maximum length cannot exceed n-1 because if you take a substring of length n, it's the entire string and can appear only once. Similarly, for length n-1, it requires two starting positions separated by at least one character. However, the example \"ababa\" shows that a substring of length 3 (which is more than n//2=2) appears twice. Therefore, we must consider all lengths from min(n, n) down to 1, but practically, the maximum possible length is n-1 (if the string is like \"aaa...aa\", then the substring of length n-1 appears multiple times).\n\n    # We'll start from the maximum possible length (which is n-1) down to 1. But wait, what is the maximum length? It must be such that there are two non-overlapping or overlapping occurrences. The minimal requirement is that the substring length L must satisfy: there exists two starting indices i and j (i < j) such that j + L <= n. The maximum L is n - i_min, where i_min is the smallest gap between the start of two occurrences. However, to keep it simple, we start from the maximum possible L (which is n-1) down to 1.\n\n    # But note: if we start from n-1, then for \"abcd\": n=4, n-1=3. Substrings of length 3: \"abc\", \"bcd\" — each appears once. Then length 2: \"ab\", \"bc\", \"cd\" — each once. Then length 1: \"a\",\"b\",\"c\",\"d\" — each once. So answer 0.\n\n    # However, in \"ababa\": n=5. Start from 4: substrings \"abab\", \"baba\" — each once. Then 3: \"aba\", \"bab\", \"aba\" — \"aba\" appears twice. So answer 3.\n\n    # But wait, in \"zzz\": n=3. Start from 2: substrings \"zz\" (from index0 and index1) — appears twice. So answer 2.\n\n    # However, the above example \"ababa\" shows that starting from n-1 (which is 4) is too high because the answer is 3. So we need to adjust the starting point. The maximum length L must be such that there are two starting indices i and j (i < j) with j + L <= n. The minimal condition is j >= i + 1 (overlapping allowed). The maximum L is n - 1 (if j = i + 1, then L can be up to n - (i+1) + 1 = n - i, and i can be 0, so L = n-1). But in practice, we can start from the maximum possible L (which is n-1) down to 1.\n\n    # However, the example \"ababa\" (n=5) requires checking L=4 and then L=3. Since L=4 doesn't yield a duplicate, we proceed to L=3 and find \"aba\". \n\n    # Therefore, we'll iterate L from n-1 down to 1.\n\n    # But note: the maximum L is actually the entire string minus one, but we can also consider that the two occurrences must fit in the string. The maximum L is n - 1 (if the string is \"aaaaa\", then a substring of length 4 appears multiple times).\n\n    # We'll iterate L from n-1 down to 1:\n    #   For each starting index i from 0 to n - L:\n    #       substring = s[i:i+L]\n    #       Check if this substring has been seen before. But note: two occurrences can be anywhere, even overlapping.\n\n    # However, we must ensure that the two occurrences are distinct (different starting indices). So if we see the same substring starting at two different indices, that's valid.\n\n    # We can use a set to record substrings we've seen. But note: if we use a set, we lose information about where the substring was seen. However, we don't need the exact positions, just whether it appeared before.\n\n    # Steps for each L:\n    #   seen = set()\n    #   for i in range(0, n - L + 1):\n    #       substr = s[i:i+L]\n    #       if substr in seen:\n    #           print(L)\n    #           return\n    #       else:\n    #           seen.add(substr)\n\n    # But wait, what if the same substring appears three times? We still return the first occurrence (the longest L) that satisfies the condition.\n\n    # However, the above approach will work because we are iterating from the longest L down to 1. Once we find an L for which a substring appears at least twice, we immediately return that length.\n\n    # But note: we must consider that a substring might appear more than twice, but we only need at least two.\n\n    # Edge case: if no substring appears twice, we return 0.\n\n    # However, the example \"abcd\" returns 0.\n\n    # But there's a catch: the same substring might appear in overlapping positions, but the set will still catch it because we are storing the substring itself.\n\n    # Example: \"ababa\" for L=3: \n    #   i=0: substring \"aba\" -> not seen, add to set.\n    #   i=1: substring \"bab\" -> not seen, add to set.\n    #   i=2: substring \"aba\" -> seen! So return 3.\n\n    # This works.\n\n    # However, the above approach does not account for the fact that two occurrences must be distinct. But by checking the same substring appearing at different indices, we are ensuring distinct occurrences.\n\n    # Implementation:\n\n    # But note: the problem says the string is non-empty, so we don't need to handle empty string.\n\n    # Let's code accordingly.\n\n    # However, we can optimize by starting from the maximum possible L (which is n-1) down to 1, but note: the maximum L might be less than n-1. For example, in \"abcde\", the maximum L is 1 because no substring of length 2 or more repeats. \n\n    # We'll iterate L from min(n, n) down to 1, but note that the maximum L we need to consider is n-1 (since a substring of length n can't appear twice). So we start from L = n-1 down to 1.\n\n    # But wait, in the string \"aaa\", n=3, then L from 2 down to 1: \n    #   L=2: substring \"aa\" appears twice (at index0 and index1) -> return 2.\n\n    # Correct.\n\n    # However, let's test with \"ababa\":\n    #   n=5, L from 4 down to 1.\n    #   L=4: substrings \"abab\", \"baba\" — both unique, no return.\n    #   L=3: substrings \"aba\", \"bab\", \"aba\" — \"aba\" repeats, return 3.\n\n    # Another test: \"abcde\", n=5, L from 4 down to 1:\n    #   L=4: \"abcd\", \"bcde\" — unique.\n    #   L=3: \"abc\", \"bcd\", \"cde\" — unique.\n    #   L=2: \"ab\", \"bc\", \"cd\", \"de\" — unique.\n    #   L=1: \"a\",\"b\",\"c\",\"d\",\"e\" — unique.\n    #   Returns 0.\n\n    # This matches the sample input.\n\n    # But note: the sample input includes ['abcd', 'ababa', 'zzz'] which outputs [0, 3, 2]. Our approach will correctly output 0 for \"abcd\", 3 for \"ababa\", and for \"zzz\" (n=3): \n    #   L=2: substrings \"zz\" (from index0 and index1) — \"zz\" appears twice, so returns 2.\n\n    # Therefore, the solution is to iterate from L = n-1 down to 1, and for each L, check all substrings of length L. If any substring is found more than once, return L immediately. If no such substring is found after checking all lengths, return 0.\n\n    # However, we must consider that the two occurrences must be distinct (different starting indices). The set approach naturally ensures this because we are adding each substring along with its starting index? Actually, no: the set stores the substring itself, not the index. But that's okay because if the same substring appears again, it's the same value. \n\n    # But wait, what if the same substring appears in two different forms due to different starting indices? No, because the substring is defined by its characters. \n\n    # Example: \"ababa\" — the substring \"aba\" is the same regardless of where it starts.\n\n    # Therefore, the set approach is valid.\n\n    # Code accordingly:\n\n    # Edge: if the string length is 0 or 1, then no substring can appear twice (except for length 0, but the problem states non-empty string and minimum length 1). For length 1, we need two occurrences, which requires at least two same characters. \n\n    # Example: \"a\" -> no duplicate substring -> output 0.\n\n    # Let's adjust the loop to start from n-1 down to 1.\n\n    # However, note: the maximum L is n-1, but what if n=1? Then we start from 0. We should avoid negative indices.\n\n    # Revised plan: \n    #   If n == 0: return 0 (but guaranteed non-empty).\n    #   Iterate L from n-1 down to 1 (inclusive).\n    #       seen = set()\n    #       for i in range(0, n - L + 1):\n    #           substr = s[i:i+L]\n    #           if substr in seen:\n    #               print(L)\n    #               return\n    #           else:\n    #               seen.add(substr)\n    #   If no L found, print(0)\n\n    # But note: the set operations and substring creation for small strings (n<=100) is acceptable.\n\n    # However, we can optimize by breaking early when a duplicate is found.\n\n    # Let's write the code accordingly.\n\n    # One more edge: if the string is very long (though n<=100), but the approach is O(n^2) per L, and L goes from n-1 down to 1, so worst-case O(n^3). With n=100, the worst-case number of operations is about 100^3 = 1,000,000, which is acceptable in Python.\n\n    # Code implementation:\n\n    # But note: the problem reads from stdin and writes to stdout.\n\n    # Let's code accordingly.\n\n    # However, there is a possibility to break out as soon as we find a duplicate for a given L.\n\n    # We'll do that.\n\n    # Special case: if n==0, but guaranteed non-empty, so skip.\n\n    # Let's run the provided examples.\n\n    # Example 1: \"abcd\" (n=4)\n    #   L=3: substrings \"abc\", \"bcd\" -> no duplicates.\n    #   L=2: \"ab\", \"bc\", \"cd\" -> no duplicates.\n    #   L=1: \"a\",\"b\",\"c\",\"d\" -> no duplicates.\n    #   Output 0.\n\n    # Example 2: \"ababa\" (n=5)\n    #   L=4: \"abab\", \"baba\" -> no duplicates.\n    #   L=3: \"aba\", \"bab\", \"aba\" -> duplicate \"aba\", output 3.\n\n    # Example 3: \"zzz\" (n=3)\n    #   L=2: \"zz\", \"zz\" -> duplicate, output 2.\n\n    # All correct.\n\n    # Write the code:\n\n    n_val = len(s)\n    # If the string length is 1, then no substring of length>=1 can appear twice.\n    # We'll iterate from L = n_val-1 down to 1.\n\n    # If the string length is 0, but guaranteed non-empty, so no need to handle 0.\n    # If the string length is 1, then we start from L=0, but our loop starts from n_val-1 which is 0, and then we check L=0. But substring of length 0 is the empty string, which appears everywhere. However, the problem says \"substring\" and typically we consider non-empty substrings. Also, the problem states that the string consists of lower-case Latin letters, so empty string is not considered.\n\n    # According to the problem, the substring must appear at least twice. The empty string technically appears infinitely many times, but the problem likely implies non-empty substrings. \n\n    # However, the problem statement does not explicitly say non-empty, but the examples and context suggest non-empty. Also, the problem says \"longest substring\", and empty substring has length 0, which is the smallest. \n\n    # But the problem's sample outputs include 0, which corresponds to no non-empty substring found. \n\n    # So we are to return 0 if no non-empty substring appears twice. \n\n    # Therefore, we stick to non-empty substrings.\n\n    # We'll iterate from L = n_val-1 down to 1.\n\n    # If we find a duplicate for any L, we return L.\n\n    # Otherwise, after all L, return 0.\n\n    # Code:\n\n    # But note: the maximum L we consider is n_val-1, but sometimes a substring of length greater than n_val//2 might appear twice (like \"aba\" in \"ababa\"). Our loop handles that because we start from the top.\n\n    for L in range(n_val-1, 0, -1):\n        seen = set()\n        found = False\n        for i in range(0, n_val - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                return\n            seen.add(substr)\n    print(0)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 235,
        "completion_token_count": 3709,
        "thoughts_token_count": 1023
    }
}