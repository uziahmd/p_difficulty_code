{
    "start": 1758294473.9192524,
    "end": 1758297047.6621861,
    "start-formatted": "2025-09-20 00:07 KST",
    "end-formatted": "2025-09-20 00:50 KST",
    "gpu": 2,
    "pid": 41,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Zoning Restrictions Again\n\nYou are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.\n\n## Input\nThe first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$) — the number of spots, the maximum height, and the number of restrictions.Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$) — left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.\n\n## Output\nPrint a single integer, the maximum profit you can make.\n\n## Example\n### Input\n['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n### Output\n['14', '262']\n\n## Note\nIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Since n, m, h are at most 50, we can use a dynamic programming (DP) or even try to use state compression by considering the restrictions.\n However, note: the restrictions are given as intervals and specify that in [l_i, r_i] the maximum height must be <= x_i.\n\n Alternate idea: since the number of restrictions is small (<=50) but the spots are only 50, we can consider iterating over possible assignments for each spot?\n But the state space would be too large (each spot from 0 to h, and h<=50, so 51^50 states) which is too big.\n\n Instead, we can use the following:\n\n Observation: The profit function is separable (each house's profit is independent) but the constraints are on contiguous segments.\n\n We can also note that the square function is convex, so we might want to set as high as possible without violating the restrictions.\n\n But there are multiple restrictions. We must satisfy all restrictions.\n\n Approach:\n\n We can combine all restrictions for each spot? Actually, for a given spot i, what are the constraints?\n For each restriction j that covers spot i, we have that the height at i must be <= x_j.\n\n Therefore, for each spot i, let max_allowed[i] = min( {x_j for each restriction j such that i in [l_j, r_j]} ) \n However, wait: note that the restriction says the tallest house in the interval must be <= x_j. This does not necessarily force the individual house at i to be <= x_j if there's another house in the interval that is higher? \n\n But actually, if the entire interval must have maximum <= x_j, then each house in the interval must be <= x_j. So yes, the condition for a single house i is that it must be <= the minimum x_j among all restrictions that cover i.\n\n However, caution: There might be multiple restrictions, and they might not be independent. But note: if a house is covered by several restrictions, then it must satisfy the one with the smallest x_j.\n\n So we can precompute for each spot i:\n   allowed[i] = min{ x_j | restriction j applies to spot i }   OR if no restriction applies, then allowed[i] = h (since the global maximum is h)\n\n But wait: what if two restrictions apply, one says <=3 and another says <=5, then the house must be <=3.\n\n However, what if we have two restrictions that do not directly restrict the same house but together form a constraint that requires the house to be lower? Actually, the above is correct because the house must be <= the minimum x_j of any restriction covering it.\n\n But note: the problem does not say that the house must be <= the minimum x_j of the restrictions covering it. It says that for each restriction j, the entire interval must have maximum <= x_j. So the house i must be <= x_j for every restriction j that covers i. Therefore, it must be <= the minimum x_j of the covering restrictions.\n\n However, is that sufficient? Yes, because if we set each house i to at most min_{j covering i} x_j, then for any restriction j, the entire interval [l_j, r_j] has houses <= x_j (because each house in the interval is <= the restriction j's x_j, and also <= the minimum of all restrictions covering that house). But note: the minimum of the restrictions covering a house might be larger than x_j? No, because the minimum is taken over the set of x_j that include j, so the minimum is <= x_j.\n\n However, there's a catch: we must also satisfy the condition that the entire interval has maximum <= x_j. The above condition (each house <= min_{covering} x_j) ensures that the entire interval [l_j, r_j] has maximum <= x_j because the maximum of the interval is at most the minimum x_j that covers the entire interval? Actually, no: consider two restrictions. Suppose we have two restrictions: one [1,2] with x=3 and one [2,3] with x=2. Then for spot 2, we set it to <= min(3,2)=2. Then the entire [1,2] has maximum <=2 (which is <=3) and [2,3] has maximum <=2 (which is <=2). But what if we have two restrictions [1,2] with x=3 and [1,3] with x=2? Then for spot1: min(3,2)=2; spot2: min(3,2)=2; spot3: min(2,?)=2. Now the entire [1,3] has maximum 2 which is <=2, and [1,2] has maximum 2<=3. So that works.\n\n But wait, what if we have two restrictions that don't overlap? Then each house is constrained by the restrictions that cover it. However, the condition of the problem is that all restrictions must be satisfied independently. And our condition (each house i set to at most the minimum x_j of the covering restrictions) is necessary and sufficient.\n\n However, is it optimal? We wish to maximize the sum of squares. The square function is increasing for nonnegative numbers, so we want to set each house as high as possible. Therefore, for each house i, we set it to the minimum value between h and the minimum x_j of the covering restrictions? Actually, no: we set it to the minimum of the covering restrictions (if that minimum is less than h, then we set to that minimum, otherwise h). But note: the problem says the house can be built with an integer height between 0 and h. And the restrictions only impose upper bounds.\n\n However, wait: there might be a case where we can set a house higher than the minimum x_j of the covering restrictions if we can ensure that the entire interval doesn't exceed the restriction's x_j? But no, because the restriction j requires the entire interval to have maximum <= x_j, so if the house is set to a value greater than x_j, then restriction j is violated. Therefore, we must set the house to at most the minimum x_j of the covering restrictions.\n\n But note: what if the minimum x_j is negative? The problem says x_i>=0, so we are safe.\n\n However, there's a twist: the above reasoning sets each house independently. But is that always optimal? Consider: if we set a house to the maximum allowed by the restrictions, then we get the highest contribution from that house without violating any restriction. Because the profit is the square, which is increasing. Therefore, we would set each house i to the minimum between h and the minimum x_j (over restrictions covering i). Then the total profit is the sum of (min(h, min_covering_x_j))^2 for each house.\n\n But wait: is that always correct? Let me test with the example.\n\n Example 1:\n   Input: \"3 3 3\\n1 1 1\\n2 2 3\\n3 3 2\"\n   For house1: covered by [1,1] -> min x_j=1 -> set to 1.\n   For house2: covered by [2,2] -> min x_j=3 -> set to min(3,3)=3.\n   For house3: covered by [3,3] -> min x_j=2 -> set to 2.\n   Profit = 1^2 + 3^2 + 2^2 = 1+9+4=14.\n\n Example 2:\n   Input: \"4 10 2\\n2 3 8\\n3 4 7\"\n   House1: no restriction? Actually, the first restriction [2,3] does not cover house1, the second [3,4] does not cover house1. So house1: min_covering_x_j = ? (no restriction) -> then we set to h=10.\n   House2: covered by [2,3] -> x_j=8 -> set to min(10,8)=8.\n   House3: covered by [2,3] and [3,4] -> min(8,7)=7 -> set to 7.\n   House4: covered by [3,4] -> set to min(10,7)=7.\n   Profit = 10^2 + 8^2 + 7^2 + 7^2 = 100+64+49+49 = 262.\n\n However, wait: the example input says:\n        \"4 10 2\\n2 3 8\\n3 4 7\"\n\n And our method gives 10,8,7,7 -> 100+64+49+49=262.\n\n But the example output is 262.\n\n However, consider this alternative: what if we set house1 to 10, but maybe the second restriction [3,4] might require house3 and house4 to be <=7, but house1 is independent. This seems correct.\n\n But wait: what if there are overlapping restrictions that might allow a higher setting in some houses? Actually, the above method sets each house to the minimum of the restrictions that cover it (and h). However, the problem is that the restrictions are on intervals. The above method does not consider that a restriction might be broken if we set a house too high even if that house is not the only one in the interval? Actually, no: the condition for a restriction is that the entire interval must have maximum <= x_i. Our method sets every house in the interval to <= x_i, so the maximum in the interval is at most x_i.\n\n However, is it possible that by setting a house lower than the minimum x_i covering it, we could set another house higher? No, because the other house is constrained by its own restrictions. Moreover, the objective function is separable and the constraints are independent per house (via the covering restrictions). Therefore, the optimal solution is to set each house to the minimum of h and the minimum x_i of the covering restrictions.\n\n But wait, let me think again: what if two adjacent houses are both constrained by two different restrictions and by setting one house higher we can relax the constraint on the other? Actually, no: because the constraints are independent per house. Each house's maximum allowed value is determined solely by the restrictions that cover it.\n\n However, consider: two restrictions that cover two adjacent houses and the same house. For example, two restrictions: [1,2] with x=3 and [2,3] with x=4. Then:\n   House1: min_covering_x_j = 3 -> set to 3.\n   House2: min(3,4)=3 -> set to 3.\n   House3: min(4)=4 -> set to 4.\n\n But what if we set house2 to 4? Then the first restriction [1,2] would have maximum = max(3,4)=4 which violates the restriction (which requires <=3). So we cannot set house2 to 4. Similarly, we cannot set house2 above 3.\n\n Therefore, the above method is correct.\n\n However, wait: what if we have two restrictions: [1,2] with x=3 and [1,3] with x=4. Then:\n   House1: min(3,4)=3 -> 3\n   House2: min(3,4)=3 -> 3\n   House3: min(4)=4 -> 4\n\n The first restriction [1,2] is satisfied (max=3<=3) and the second [1,3] is satisfied (max=4<=4).\n\n But note: the second restriction [1,3] requires the entire interval [1,3] to have maximum <=4, and we have set house1 and house2 to 3 and house3 to 4 -> maximum is 4, which is okay.\n\n Now, what if we set house1 to 3, house2 to 3, and house3 to 4. But what if we set house1 to 2? Then we could set house3 to 4 and house2 to 3. But then the profit would be 2^2+3^2+4^2 = 4+9+16=29, which is less than 3^2+3^2+4^2=9+9+16=34. So we want the maximum.\n\n But note: we are allowed to set any integer from 0 to the maximum allowed. The square is increasing, so we set each house to the maximum allowed (which is the minimum between h and the minimum x_j of the covering restrictions).\n\n However, wait: the problem does not require that the entire interval has maximum exactly equal to the restriction's x_j. We just need to be <=. And since the square is increasing, we set to the maximum allowed.\n\n Therefore, the solution is:\n\n Step 1: Precompute for each spot i (from 1 to n) the minimum x_j among all restrictions j that cover i. If no restriction covers i, then the constraint is only h (so the house can go up to h). Therefore, let allowed[i] = min( h, min_{j: i in [l_j, r_j]} x_j ) if there is at least one restriction, else h.\n\n But wait: actually, the problem says the house can be built with height between 0 and h. And the restrictions are additional: they say that in an interval, the maximum must be <= x_j. Therefore, the effective maximum for house i is the minimum between h and the minimum x_j of the covering restrictions (if any). So if there are no covering restrictions, then we set the house to h (maximizing the square).\n\n Step 2: For each house i, set its height to allowed[i] (the maximum allowed) and compute the profit.\n\n However, wait: what if we set a house to a value lower than allowed[i]? Then the profit decreases. Therefore, we set it to allowed[i].\n\n But wait: what if we set a house to allowed[i], and then a restriction that covers that house is satisfied? Yes, because allowed[i] is at most the restriction's x_j.\n\n However, is that always the maximum profit? Consider: the square function is convex and increasing, so yes, we want the highest value allowed.\n\n But wait: the problem does not say that the restrictions are the only constraints. The house must be at most h, and the restrictions give additional constraints (upper bounds). So the house can be set to any integer from 0 to min(h, min_covering_x_j). To maximize the square, we choose the highest integer: min(h, min_covering_x_j).\n\n Therefore, the program is:\n\n   Read n, h, m.\n   Initialize an array `allowed` of length n+1 (indexed 1 to n) with zeros. We'll set each to h initially (if no restriction, then we can use h). Then, for each restriction, update the houses in the interval [l, r] to the minimum between the current allowed value and x.\n\n   Alternatively, we can do:\n\n   allowed = [h]*(n+1)   # 1-indexed, index 0 unused.\n\n   For each of the m restrictions (l, r, x):\n        for i from l to r:\n            allowed[i] = min(allowed[i], x)\n\n   Then, profit = 0\n        for i from 1 to n:\n            profit += allowed[i]*allowed[i]\n\n   Print profit.\n\n Let me test with example1:\n\n   n=3, h=3, m=3\n   Initially: allowed = [3,3,3] (for indices 1,2,3)\n\n   First restriction: [1,1] with x=1 -> allowed[1]=min(3,1)=1.\n   Second: [2,2] with x=3 -> allowed[2]=min(3,3)=3.\n   Third: [3,3] with x=2 -> allowed[3]=min(3,2)=2.\n\n   Profit = 1^2 + 3^2 + 2^2 = 1+9+4=14.\n\n Example2:\n\n   n=4, h=10, m=2\n   Initially: allowed = [10,10,10,10]\n   First restriction: [2,3] with x=8 -> set allowed[2]=min(10,8)=8, allowed[3]=min(10,8)=8.\n   Second restriction: [3,4] with x=7 -> set allowed[3]=min(8,7)=7, allowed[4]=min(10,7)=7.\n\n   Then: \n        house1: 10\n        house2: 8\n        house3: 7\n        house4: 7\n\n   Profit = 10^2+8^2+7^2+7^2 = 100+64+49+49 = 262.\n\n But wait, the example input says the first restriction is [2,3] with 8 and the second is [3,4] with 7. This matches.\n\n However, consider a more complex example:\n\n   n=2, h=10, m=2\n   Restriction1: [1,2] with x=5\n   Restriction2: [1,1] with x=3\n\n   Then: \n        Initially: [10,10]\n        After restriction1: [min(10,5)=5, min(10,5)=5]\n        After restriction2: [min(5,3)=3, 5]\n\n   Profit = 3^2 + 5^2 = 9+25=34.\n\n   Is that correct? \n        The first restriction [1,2] requires the maximum in [1,2] to be <=5 -> we set house1=3, house2=5 -> max=5 -> valid.\n        The second restriction [1,1] requires house1<=3 -> valid.\n\n   What if we set house1=3 and house2=5? Then profit 34.\n\n   Alternatively, if we set house1=2 and house2=5, then profit=4+25=29 <34.\n   Or house1=3 and house2=4, then profit=9+16=25<34.\n\n   So 34 is the maximum.\n\n Therefore, the algorithm is correct.\n\n However, wait: what if we have a restriction that is not the tightest one? The above loop updates the allowed value for each restriction one by one, so the final allowed[i] is the minimum of h and all x_j for which the restriction j covers i.\n\n But note: the problem says there are m restrictions, and each restriction j must be satisfied. So the house i must be <= x_j for every j that covers i. Therefore, the minimum x_j (over j covering i) is the tightest constraint.\n\n However, we must consider that the initial allowed[i] is h, and then we take the min with each x_j. So the final allowed[i] = min( h, min_{j: i in [l_j, r_j]} x_j )\n\n But note: what if a restriction j has x_j > h? Then min(x_j, h) is h, so it doesn't change the allowed value. But the problem says x_j is between 0 and h, so x_j <= h. Therefore, we can ignore the h in the min? Actually, the problem says 0<=x_i<=h, so the min( h, x_j ) is just x_j. So we can simply set:\n\n   allowed[i] = min( {x_j for all j such that i in [l_j, r_j]} )   (without the h) because x_j is at most h.\n\n But wait, what if there are no restrictions? Then we should set allowed[i] = h. In our code, if there are no restrictions, then the initial value h remains.\n\n However, the above update does not set to h if no restriction is present. But note: we initialize with h, and then if there are no restrictions, we never update. So that's correct.\n\n But note: the problem says the house can be built with height up to h. And the restrictions only add upper bounds (which are <= h). So without restrictions, the house can be h.\n\n However, the problem says: \"In each spot, you can build a house with an integer height between 0 and h.\" and the restrictions are additional. So without restrictions, the house can be h.\n\n Therefore, we can simplify: since x_j <= h, then min(h, x_j) = x_j. So we can do:\n\n   allowed = [h]*(n+1)\n   for each restriction (l, r, x):\n        for i from l to r:\n            allowed[i] = min(allowed[i], x)\n\n   Then, the allowed[i] will be the minimum x_j for the covering restrictions, and if there are none, it remains h.\n\n But wait: what if x_j is greater than h? The problem says 0<=x_i<=h, so we don't have to worry.\n\n Therefore, the code is:\n\n   n, h, m = map(int, input().split())\n   allowed = [h] * (n+1)   # 1-indexed, index 0 unused.\n\n   for _ in range(m):\n        data = input().split()\n        l = int(data[0]); r = int(data[1]); x = int(data[2])\n        for i in range(l, r+1):\n            if x < allowed[i]:\n                allowed[i] = x\n\n   total = 0\n   for i in range(1, n+1):\n        total += allowed[i] * allowed[i]\n\n   print(total)\n\n However, wait: the example input format: the first line is n, h, m, then m lines.\n\n But the sample input is given as:\n\n        ['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n This is two examples. But the problem reads from stdin. So we should read until EOF.\n\n But the problem says: \"The following is a competitive programming problem\" and the input format is standard.\n\n However, the example input is provided as two strings. In a real competition, the input would be from stdin.\n\n But note: the sample input has two separate examples. The problem expects to read from stdin and output to stdout.\n\n Since the problem says \"Print a single integer\", meaning one test case at a time.\n\n However, the input might contain multiple test cases? The problem statement does not specify. But the constraints say n, h, m up to 50, and the example input is two separate test cases.\n\n But wait, the example input is provided as:\n\n        Input: \n          ['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n        Output:\n          ['14', '262']\n\n So it looks like two test cases.\n\n But the problem statement says: \"The first line contains three integers n, h, m\", and then m lines. This implies one test case.\n\n However, the sample input is two test cases. This is confusing.\n\n Looking at the problem statement again: \"You are planning to build housing on a street.\" and then describes the input. There's no mention of multiple test cases.\n\n But the example input is two separate test cases.\n\n I must check the actual input format. The problem says: \"Each of the next m lines\" meaning one test case.\n\n Therefore, the sample input provided in the example is two separate test cases, but the problem likely expects one test case per run.\n\n However, the problem statement says: \"The following is a competitive programming problem\", and the example input is given as two strings. This might be because the problem is designed to have multiple test cases? Or perhaps the example input is two examples.\n\n But note: the constraints say n, h, m <=50 and m>=1, and the input format is fixed.\n\n Since the problem says \"the first line\" and then m lines, it is one test case.\n\n But the example input is two test cases. This is a discrepancy.\n\n Clarification: the problem says \"Determine the maximum profit possible.\" (singular). So it is one test case.\n\n However, the sample input is two test cases. This might be an error in the example.\n\n But wait, the example output is two numbers: 14 and 262.\n\n So the problem might be that the input consists of multiple test cases. How many? The problem statement doesn't say.\n\n Let me re-read: \"The first line contains three integers n, h, m\". Then m lines. This is one test case.\n\n But the example input is two test cases. This suggests that the example input is two separate instances of the problem.\n\n In competitive programming, sometimes there are multiple test cases. The problem statement often specifies the number of test cases.\n\n However, here the problem statement does not specify. But the sample input is given as two strings.\n\n Since the problem constraints are small (n, m, h <=50) and the sample input has two test cases, we must handle multiple test cases.\n\n But wait, the problem says: \"The following is a competitive programming problem\", and the input format is described. The description does not say \"one test case\" or \"multiple\".\n\n However, the example input is two test cases. \n\n I think the intended format is: \n        The first line of input is n, h, m.\n        Then m lines of restrictions.\n\n        Then the next test case? Or the end?\n\n But the problem does not specify. However, the sample input is provided as two separate test cases, and we are expected to output two answers.\n\n How can we know the number of test cases? The problem says \"The first line contains three integers n, h, m\", so each test case is independent.\n\n Therefore, we must read until EOF.\n\n Steps:\n\n   while True:\n        try:\n            n, h, m = map(int, input().split())\n        except EOFError:\n            break\n        # process the test case\n\n But wait, the sample input is given as two strings. If we run the program and paste one string, we get one test case. If we paste two, we get two.\n\n However, the problem says: \"Print a single integer\", meaning for one test case.\n\n But the example input has two test cases. Therefore, we must output two integers.\n\n Since the problem statement does not specify the number of test cases, and the input format is given per test case, we assume that there may be multiple test cases.\n\n Alternatively, the problem might have intended one test case, but the example input is two.\n\n After checking the example input: \n\n        Input: \n          3 3 3\n          1 1 1\n          2 2 3\n          3 3 2\n          4 10 2\n          2 3 8\n          3 4 7\n\n        Then we would have two test cases.\n\n But note: the first test case has n=3, h=3, m=3 -> then 3 restrictions.\n        Then the second test case starts with n=4, h=10, m=2.\n\n Therefore, the input is multiple test cases.\n\n However, the problem statement does not say \"There are multiple test cases\". But the sample input is multiple.\n\n Let me look at the problem statement: \"The first line contains three integers n, h, m\". Then the next m lines. \n\n But if we have two test cases, then the first line is for the first test case, then the next 3 lines (m=3) for the first test case, then the next three lines (first line of the next test case) is n=4, h=10, m=2, then two lines.\n\n So the input format is: \n        [test_case1: n, h, m, followed by m lines] \n        [test_case2: n, h, m, followed by m lines] \n        ...\n\n How to handle?\n\n We can read until EOF.\n\n But note: the problem says \"The following is a competitive programming problem\", and the example input is two test cases.\n\n Therefore, we assume there can be multiple test cases.\n\n Revised code:\n\n   import sys\n\n   data = sys.stdin.read().strip().splitlines()\n   if not data: \n        exit(0)\n\n   index = 0\n   results = []\n\n   while index < len(data):\n        n, h, m = map(int, data[index].split())\n        index += 1\n        allowed = [h] * (n+1)   # 1-indexed, index0 unused.\n\n        for i in range(m):\n            # Each restriction is on the next line\n            parts = data[index].split()\n            index += 1\n            l = int(parts[0]); r = int(parts[1]); x = int(parts[2])\n            for j in range(l, r+1):\n                if x < allowed[j]:\n                    allowed[j] = x\n\n        total = 0\n        for i in range(1, n+1):\n            total += allowed[i] * allowed[i]\n\n        results.append(str(total))\n\n   print(\"\\n\".join(results))\n\n But wait, the example input is two test cases. However, the example input is given as two strings, but in reality, the input would be:\n\n        \"3 3 3\\n1 1 1\\n2 2 3\\n3 3 2\\n4 10 2\\n2 3 8\\n3 4 7\"\n\n So we split into lines:\n\n        data = [\"3 3 3\", \"1 1 1\", \"2 2 3\", \"3 3 2\", \"4 10 2\", \"2 3 8\", \"3 4 7\"]\n\n Then the first test case: \n        n=3, h=3, m=3 -> then we read the next 3 lines: \n            \"1 1 1\"\n            \"2 2 3\"\n            \"3 3 2\"\n\n Then the second test case: \n        n=4, h=10, m=2 -> then we read the next 2 lines: \n            \"2 3 8\"\n            \"3 4 7\"\n\n This matches.\n\n However, what if m=0? Then we don't read any restrictions and just set each house to h.\n\n Example: \n        Input: \n           1 10 0\n\n        Then allowed = [10] (for index1) -> profit 100.\n\n But the problem says: the first line has n, h, m. Then m lines. So if m=0, then no restrictions.\n\n This is acceptable.\n\n But note: the problem says \"There are m zoning restrictions\", so m can be zero.\n\n However, the constraints say m>=1? Actually, the constraints: \"1<=n,h,m<=50\", so m>=1.\n\n Wait, the constraints: \"1<=n,h,m<=50\", so m is at least 1. So we don't have to handle m=0.\n\n Therefore, we can rely on m>=1.\n\n But wait, the problem says: \"Each of the next m lines\", so if m=0, there are no next lines. But the constraints say m>=1, so we are safe.\n\n However, the constraints say \"1<=n,h,m<=50\", so we don't have to handle m=0.\n\n Therefore, we can write the code accordingly.\n\n But wait: the sample input example1 has m=3, example2 has m=2, which are >=1.\n\n So the code above is correct.\n\n However, note: the example input is provided as two separate test cases. But in the problem statement, the example input is shown as two strings. We must output the answer for each test case.\n\n But the problem says: \"Print a single integer\", meaning one test case. However, if there are multiple test cases, we should output multiple integers.\n\n Since the problem statement does not specify the number of test cases, but the example input is two, we assume multiple test cases until EOF.\n\n Alternatively, the problem might be designed for one test case. But the example input has two.\n\n Since the problem is from a competition and the example input is two, we assume multiple test cases.\n\n But wait, the problem statement says: \"The following is a competitive programming problem\", and the input format is described. There is no indication of multiple test cases.\n\n However, the example input is two test cases. This is ambiguous.\n\n Let me check the official problem statement if available. But since I don't have it, I rely on the sample.\n\n Since the sample input has two test cases, and the problem does not specify the number, we must read until EOF.\n\n But note: the constraints say n, h, m from 1 to 50. And the input format is fixed per test case.\n\n Therefore, we output the code that handles multiple test cases.\n\n However, after re‐reading the problem statement, it does not mention multiple test cases, but the example input is two. \n\n Another possibility: the example input is just two examples, but the judge provides one test case at a time.\n\n But the problem says: \"The first line contains three integers n, h, m\", so each test case is independent.\n\n I think the intended format is one test case, but the example input is two. \n\n But wait, the problem says: \"You would like to build houses to maximize your profit. Determine the maximum profit possible.\"\n\n This is for one scenario.\n\n Therefore, I think the sample input was provided as two separate examples, but the actual input to the program is one test case.\n\n However, the example input is given as two strings. This might be because the problem was tested with two examples.\n\n To be safe, we can read until EOF and output each result on a new line.\n\n But the problem says: \"Print a single integer\", meaning one integer per test case.\n\n So if the input has two test cases, we output two integers (each on its own line).\n\n Since the problem statement does not specify the number of test cases, we follow the sample input format.\n\n Final code:\n\n   We read lines until EOF.\n\n   For each test case:\n        Read n, h, m.\n        Initialize allowed array of size n+1 with h.\n        For the next m lines (each restriction), update the allowed array.\n\n        Compute the total profit and output it.\n\n But note: the problem constraints say n, m, h up to 50, and the worst-case m=50, and each restriction can cover up to 50 houses, so we do at most 50*50=2500 updates, which is acceptable.\n\n However, we can optimize the update by not iterating over every house in the restriction? But n, m are small (<=50) so 50*50 is 2500, which is acceptable.\n\n But note: the input might have multiple test cases, and the total number of restrictions is at most 50 per test case, and the total n is at most 50, so worst-case 50*50 per test case, and the number of test cases is not specified. But the constraints say n, h, m <=50, and the total input size is (number_of_test_cases)*(1+ m*(3)) which is bounded by (number_of_test_cases)* (1+50*3) = (number_of_test_cases)*151. Since the total input is small, we are safe.\n\n However, the problem does not specify the number of test cases, but the constraints are small.\n\n But wait: the constraints say \"1<=n,h,m<=50\", but the total number of test cases is not bounded. However, the problem says \"The following is a competitive programming problem\", and the input is from stdin. We must assume that the total number of test cases is not too large (since the input is small, the total test cases might be at most a few hundred?).\n\n But note: the input size is at most 50*50 (for the restrictions) per test case, and the total test cases is the number of lines divided by (1+m) and m>=1, so the total test cases is at most (total_lines) / (1+m_min) = total_lines/51. The problem does not specify the total input size, but the constraints are small.\n\n We'll go with reading until EOF.\n\n However, the problem says: \"The first line contains three integers n, h, m\", so we read until we have processed the entire input.\n\n Code:\n\n   import sys\n\n   def main():\n        data = sys.stdin.read().splitlines()\n        if not data:\n            return\n        index = 0\n        out_lines = []\n        while index < len(data):\n            parts = data[index].split()\n            index += 1\n            if not parts:\n                continue\n            n = int(parts[0])\n            h_val = int(parts[1])   # h is the maximum height\n            m_count = int(parts[2])\n            # Create an allowed list for n+1 houses (index 1 to n)\n            allowed = [h_val] * (n+1)   # 0-indexed we don't use 0, but we use 1..n\n\n            # Read the next m_count lines\n            for i in range(m_count):\n                # Each line: l, r, x\n                parts2 = data[index].split()\n                index += 1\n                if not parts2:\n                    continue\n                l = int(parts2[0])\n                r = int(parts2[1])\n                x = int(parts2[2])\n                # Update the allowed values for houses from l to r\n                for j in range(l, r+1):\n                    if x < allowed[j]:\n                        allowed[j] = x\n\n            total_profit = 0\n            for i in range(1, n+1):\n                total_profit += allowed[i] * allowed[i]\n\n            out_lines.append(str(total_profit))\n\n        # Output each result",
    "response": "\nTo solve this problem, we need to maximize the profit from building houses on a street while adhering to zoning restrictions. The profit is calculated as the sum of the squares of the heights of the houses built on each spot. The constraints specify that within certain intervals, the maximum height of any house must not exceed a given value. \n\n### Approach\n1. **Problem Analysis**: The goal is to determine the optimal height for each house such that all zoning restrictions are satisfied, and the total profit (sum of squares of heights) is maximized. Each house's height is constrained by the minimum value among all restrictions that include it, or the global maximum height if no restrictions apply.\n2. **Insight**: For each house, the maximum allowable height is the smallest value among all restrictions covering that house. Since the profit function is convex (squares increase with height), setting each house to its maximum allowable height will yield the highest possible profit.\n3. **Algorithm Selection**: We process each test case by first reading the number of spots, the global maximum height, and the number of restrictions. For each restriction, we update the maximum allowable height for each house in the specified interval. After processing all restrictions, we compute the profit by summing the squares of the heights for all houses.\n4. **Complexity Analysis**: The algorithm efficiently processes each restriction by iterating over the affected houses, resulting in a time complexity of O(m * n) per test case, where m is the number of restrictions and n is the number of houses. Given the constraints (n, m ≤ 50), this approach is optimal.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    index = 0\n    out_lines = []\n    \n    while index < len(data):\n        parts = data[index].split()\n        index += 1\n        if not parts:\n            continue\n        n = int(parts[0])\n        h_val = int(parts[1])\n        m_count = int(parts[2])\n        \n        allowed = [h_val] * (n + 1)\n        \n        for _ in range(m_count):\n            parts2 = data[index].split()\n            index += 1\n            if not parts2:\n                continue\n            l = int(parts2[0])\n            r = int(parts2[1])\n            x = int(parts2[2])\n            for j in range(l, r + 1):\n                if x < allowed[j]:\n                    allowed[j] = x\n                    \n        total_profit = 0\n        for i in range(1, n + 1):\n            total_profit += allowed[i] * allowed[i]\n            \n        out_lines.append(str(total_profit))\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read all at once for efficiency, especially given the constraints. The data is split into lines for processing.\n2. **Processing Each Test Case**: For each test case, the number of spots (n), global maximum height (h_val), and number of restrictions (m_count) are read.\n3. **Updating Allowable Heights**: For each restriction, the code updates the maximum allowable height for each house in the specified interval [l, r] to the minimum value between the current allowable height and the restriction's height (x).\n4. **Calculating Profit**: After processing all restrictions, the profit is calculated by summing the squares of the heights of all houses. The result for each test case is stored and printed at the end.\n\nThis approach ensures that all constraints are respected while maximizing the profit by leveraging the properties of the square function and efficient iteration over the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    index = 0\n    out_lines = []\n    \n    while index < len(data):\n        parts = data[index].split()\n        index += 1\n        if not parts:\n            continue\n        n = int(parts[0])\n        h_val = int(parts[1])\n        m_count = int(parts[2])\n        \n        allowed = [h_val] * (n + 1)\n        \n        for _ in range(m_count):\n            parts2 = data[index].split()\n            index += 1\n            if not parts2:\n                continue\n            l = int(parts2[0])\n            r = int(parts2[1])\n            x = int(parts2[2])\n            for j in range(l, r + 1):\n                if x < allowed[j]:\n                    allowed[j] = x\n                    \n        total_profit = 0\n        for i in range(1, n + 1):\n            total_profit += allowed[i] * allowed[i]\n            \n        out_lines.append(str(total_profit))\n    \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 814,
        "completion_token_count": 782,
        "thoughts_token_count": 8191
    }
}