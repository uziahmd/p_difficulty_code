{
    "start": 1758294354.0873518,
    "end": 1758294637.1744251,
    "start-formatted": "2025-09-20 00:05 KST",
    "end-formatted": "2025-09-20 00:10 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given up to 10 spaceships and 10 bases. We need to check if there is a perfect matching (i.e., a bijection) between the R spaceships and B bases such that the straight lines connecting each spaceship to its base do not intersect.\n\n Observation: Since the points are in general position (no three collinear) and the assignment must be a perfect matching, we can think of this as a bipartite graph matching problem with an additional geometric condition: the edges (straight lines) must not cross.\n\n However, note that the problem does not require the entire set of edges to be non-intersecting? Actually, the problem states: \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\". This means that if we draw all the edges (the matching), then no two edges should intersect (except at endpoints, but since no three points are collinear, endpoints won't cause intersection in the interior).\n\n But note: The problem does not say that the edges are drawn as straight lines and must not cross. It says \"any two (straight) paths\" (which are the straight lines) do not intersect.\n\n However, in a matching, edges only meet at the endpoints (if they share an endpoint). But note that two edges from two different pairs (one spaceship-base pair) might cross if the four endpoints are in alternating order.\n\n How to approach?\n\n Since R and B are at most 10, we can try to use brute-force: enumerate all perfect matchings? But wait, the total number of points is R+B (at most 20) and we are matching R bases (or R rebels) to B bases (or B rebels). Actually, we have two sets: R rebels and B bases. We need a matching of size min(R, B) but the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so we require R = B for a perfect matching? \n\n Actually, the problem states: \"assign R Rebel spaceships to guard B bases\" and \"every base has exactly one guardian and each spaceship has exactly one assigned base\". This implies that we must have R = B, because otherwise we cannot have a bijection (each base gets one and each spaceship gets one). \n\n But wait: the input example has first case: 3 spaceships and 3 bases. Second case: 2 spaceships and 1 base. Then the second example output is 'No'. However, the second example input: \n   \"2 1\\n1 0\\n2 2\\n3 1\"\n\n Here, R=2, B=1. So we cannot assign both spaceships to the single base because then one base would have two guardians. Similarly, the condition requires a perfect matching which by definition is a bijection. Therefore, we must have R = B for a solution to exist.\n\n So first check: if R != B, then output 'No'.\n\n Now, if R == B, then we have a set of R points (rebels) and R points (bases) and we want a perfect matching (a permutation) such that the edges (from rebel to base) do not cross.\n\n How to check for crossing edges? Note: Two edges (a-b) and (c-d) cross if the four points are distinct and the points are interleaved: meaning that when we consider the ordering of the two endpoints of one edge and the other, they alternate.\n\n However, note that the edges are between two sets: rebels and bases. We are free to assign any rebel to any base.\n\n We can use the following:\n\n For a set of edges (the matching) to be non-crossing, the arrangement must be such that if we draw the edges, they do not cross.\n\n There is a known fact: In a complete bipartite graph with two sets of points (say left and right) and we want a non-crossing matching, the problem reduces to checking if the convex hulls of the two sets are disjoint? Not exactly.\n\n Alternatively, we can use a recursive backtracking (since R, B <= 10, but actually R=B and maximum 10, so 10! is about 3.6 million, which is acceptable in worst-case for Python if implemented carefully). However, worst-case 10! is 3.6e6, which is acceptable.\n\n But note: the problem does not require the matching to be between two sets of points arbitrarily placed. The condition for non-crossing: two edges (p1, q1) and (p2, q2) cross if the two segments intersect.\n\n However, note: the problem says \"any two (straight) paths\" (edges) do not intersect. So we must ensure that for every pair of edges, they do not intersect.\n\n But wait: two edges that do not share a common endpoint might cross. How to check for segment intersections? We can",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the straight lines connecting each spaceship to its base do not intersect. The solution involves checking for a valid bipartite matching where no two edges cross each other.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijection) between R spaceships and B bases, where R must equal B for a solution to exist. If R ≠ B, the answer is immediately \"No\".\n2. **Geometric Condition**: For any two edges (lines connecting a spaceship to a base), they should not intersect. This can be checked using the orientation of points around a common point.\n3. **Backtracking Algorithm**: Since the constraints are small (R and B up to 10), a brute-force approach using backtracking is feasible. We generate all possible permutations of matching spaceships to bases and check for non-intersecting edges in each permutation.\n4. **Edge Intersection Check**: For each pair of edges, we verify if they intersect by checking the orientation of their endpoints. If any pair of edges intersects, the permutation is invalid.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    rebels = []\n    index = 2\n    for i in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for i in range(b):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    def orientation(a, b, c):\n        val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return -1\n            \n    def do_segments_intersect(a, b, c, d):\n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        if o1 == 0 and on_segment(a, b, c):\n            return True\n        if o2 == 0 and on_segment(a, b, d):\n            return True\n        if o3 == 0 and on_segment(c, d, a):\n            return True\n        if o4 == 0 and on_segment(c, d, b):\n            return True\n            \n        return False\n        \n    def on_segment(a, b, c):\n        if min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1]):\n            return True\n        return False\n\n    from itertools import permutations\n    bases_perm = list(permutations(bases))\n    \n    for perm in bases_perm:\n        valid = True\n        for i in range(r):\n            seg1 = (rebels[i], perm[i])\n            for j in range(i + 1, r):\n                seg2 = (perm[i], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of spaceships (R) and bases (B), followed by their respective coordinates.\n2. **Initial Check**: If R ≠ B, the solution is impossible, so output \"No\".\n3. **Orientation and Intersection Checks**: The `orientation` function determines the relative position of three points. The `do_segments_intersect` function checks if two line segments intersect by verifying their orientations and whether endpoints lie on segments.\n4. **Permutation Check**: Using `itertools.permutations`, all possible matchings between spaceships and bases are generated. For each permutation, the code checks if any pair of edges intersects. If a valid permutation is found, it prints \"Yes\" and exits; otherwise, after checking all permutations, it prints \"No\".\n\nThis approach efficiently checks all possible matchings while leveraging geometric properties to ensure non-intersecting edges, providing the correct solution within feasible computational limits.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    rebels = []\n    index = 2\n    for i in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for i in range(b):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    def orientation(a, b, c):\n        val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return -1\n            \n    def do_segments_intersect(a, b, c, d):\n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        if o1 == 0 and on_segment(a, b, c):\n            return True\n        if o2 == 0 and on_segment(a, b, d):\n            return True\n        if o3 == 0 and on_segment(c, d, a):\n            return True\n        if o4 == 0 and on_segment(c, d, b):\n            return True\n            \n        return False\n        \n    def on_segment(a, b, c):\n        if min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1]):\n            return True\n        return False\n\n    from itertools import permutations\n    bases_perm = list(permutations(bases))\n    \n    for perm in bases_perm:\n        valid = True\n        for i in range(r):\n            seg1 = (rebels[i], perm[i])\n            for j in range(i + 1, r):\n                seg2 = (perm[i], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 479,
        "completion_token_count": 1053,
        "thoughts_token_count": 1023
    }
}