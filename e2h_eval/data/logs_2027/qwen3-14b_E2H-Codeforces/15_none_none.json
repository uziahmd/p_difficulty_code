{
    "start": 1757842792.129736,
    "end": 1757842806.0392847,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:40 KST",
    "gpu": 2,
    "pid": 15,
    "thought": "",
    "response": "```python\nimport sys\nimport threading\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n\n    # We need to direct the edges such that:\n    # - The flow is a maximum flow.\n    # - For each vertex (except source and sink), in-flow == out-flow.\n    # - No cycles in the directed graph.\n\n    # We can model this as a directed acyclic graph (DAG) with flow conservation.\n    # One way to achieve this is to build a DAG by performing a topological sort\n    # on the underlying undirected graph. But since the graph is connected and undirected,\n    # we can use DFS to assign directions based on discovery order.\n\n    # We will perform DFS from the source (vertex 1) and assign directions such that\n    # all edges go from parent to child in the DFS tree. This ensures no cycles and\n    # flow conservation if we treat the flow as a tree.\n\n    # However, the problem requires that the resulting directed graph has no cycles.\n    # So we can build a DAG using a DFS-based approach.\n\n    visited = [False] * (n + 1)\n    direction = [0] * m  # 0 means ai -> bi, 1 means bi -> ai\n\n    def dfs(u):\n        visited[u] = True\n        for v, idx in graph[u]:\n            if not visited[v]:\n                # Direct the edge from u to v\n                a, b, c = edges[idx]\n                if a == u and b == v:\n                    direction[idx] = 0\n                elif b == u and a == v:\n                    direction[idx] = 1\n                else:\n                    # This should not happen because we built the graph correctly\n                    pass\n                dfs(v)\n\n    dfs(1)\n\n    for d in direction:\n        print(d)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n\n    # We need to direct the edges such that:\n    # - The flow is a maximum flow.\n    # - For each vertex (except source and sink), in-flow == out-flow.\n    # - No cycles in the directed graph.\n\n    # We can model this as a directed acyclic graph (DAG) with flow conservation.\n    # One way to achieve this is to build a DAG by performing a topological sort\n    # on the underlying undirected graph. But since the graph is connected and undirected,\n    # we can use DFS to assign directions based on discovery order.\n\n    # We will perform DFS from the source (vertex 1) and assign directions such that\n    # all edges go from parent to child in the DFS tree. This ensures no cycles and\n    # flow conservation if we treat the flow as a tree.\n\n    # However, the problem requires that the resulting directed graph has no cycles.\n    # So we can build a DAG using a DFS-based approach.\n\n    visited = [False] * (n + 1)\n    direction = [0] * m  # 0 means ai -> bi, 1 means bi -> ai\n\n    def dfs(u):\n        visited[u] = True\n        for v, idx in graph[u]:\n            if not visited[v]:\n                # Direct the edge from u to v\n                a, b, c = edges[idx]\n                if a == u and b == v:\n                    direction[idx] = 0\n                elif b == u and a == v:\n                    direction[idx] = 1\n                else:\n                    # This should not happen because we built the graph correctly\n                    pass\n                dfs(v)\n\n    dfs(1)\n\n    for d in direction:\n        print(d)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 689,
        "completion_token_count": 477,
        "thoughts_token_count": 0
    }
}