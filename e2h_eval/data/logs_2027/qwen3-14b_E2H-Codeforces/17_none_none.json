{
    "start": 1757842742.0341618,
    "end": 1757842765.5501106,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 17,
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    weight1 = []\n    weight2 = []\n    weight3 = []\n    \n    index = 2\n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            weight1.append(c)\n        elif w == 2:\n            weight2.append(c)\n        else:\n            weight3.append(c)\n    \n    # Sort the lists in descending order of cost\n    weight1.sort(reverse=True)\n    weight2.sort(reverse=True)\n    weight3.sort(reverse=True)\n    \n    # Calculate prefix sums\n    prefix1 = []\n    sum1 = 0\n    for c in weight1:\n        sum1 += c\n        prefix1.append(sum1)\n    \n    prefix2 = []\n    sum2 = 0\n    for c in weight2:\n        sum2 += c\n        prefix2.append(sum2)\n    \n    prefix3 = []\n    sum3 = 0\n    for c in weight3:\n        sum3 += c\n        prefix3.append(sum3)\n    \n    max_cost = 0\n    \n    # Try all possible combinations of weight3 and weight2\n    len3 = len(prefix3)\n    len2 = len(prefix2)\n    \n    # For each possible number of weight3 items, find best combination of weight2 and weight1\n    for i in range(len3 + 1):\n        w3 = i * 3\n        if w3 > m:\n            break\n        rem = m - w3\n        # Now try all possible number of weight2 items\n        j = 0\n        while j < len2 and j * 2 <= rem:\n            w2 = j * 2\n            rem2 = rem - w2\n            # Take as many weight1 items as possible\n            k = min(len1, rem2)\n            total = (prefix3[i - 1] if i > 0 else 0) + (prefix2[j - 1] if j > 0 else 0) + (prefix1[k - 1] if k > 0 else 0)\n            if total > max_cost:\n                max_cost = total\n            j += 1\n    \n    # Also try combinations with only weight1 and weight2\n    len1 = len(prefix1)\n    for i in range(len2 + 1):\n        w2 = i * 2\n        if w2 > m:\n            break\n        rem = m - w2\n        k = min(len1, rem)\n        total = (prefix2[i - 1] if i > 0 else 0) + (prefix1[k - 1] if k > 0 else 0)\n        if total > max_cost:\n            max_cost = total\n    \n    # Also try combinations with only weight1 and weight3\n    for i in range(len3 + 1):\n        w3 = i * 3\n        if w3 > m:\n            break\n        rem = m - w3\n        k = min(len1, rem)\n        total = (prefix3[i - 1] if i > 0 else 0) + (prefix1[k - 1] if k > 0 else 0)\n        if total > max_cost:\n            max_cost = total\n    \n    print(max_cost)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    weight1 = []\n    weight2 = []\n    weight3 = []\n    \n    index = 2\n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            weight1.append(c)\n        elif w == 2:\n            weight2.append(c)\n        else:\n            weight3.append(c)\n    \n    # Sort the lists in descending order of cost\n    weight1.sort(reverse=True)\n    weight2.sort(reverse=True)\n    weight3.sort(reverse=True)\n    \n    # Calculate prefix sums\n    prefix1 = []\n    sum1 = 0\n    for c in weight1:\n        sum1 += c\n        prefix1.append(sum1)\n    \n    prefix2 = []\n    sum2 = 0\n    for c in weight2:\n        sum2 += c\n        prefix2.append(sum2)\n    \n    prefix3 = []\n    sum3 = 0\n    for c in weight3:\n        sum3 += c\n        prefix3.append(sum3)\n    \n    max_cost = 0\n    \n    # Try all possible combinations of weight3 and weight2\n    len3 = len(prefix3)\n    len2 = len(prefix2)\n    \n    # For each possible number of weight3 items, find best combination of weight2 and weight1\n    for i in range(len3 + 1):\n        w3 = i * 3\n        if w3 > m:\n            break\n        rem = m - w3\n        # Now try all possible number of weight2 items\n        j = 0\n        while j < len2 and j * 2 <= rem:\n            w2 = j * 2\n            rem2 = rem - w2\n            # Take as many weight1 items as possible\n            k = min(len1, rem2)\n            total = (prefix3[i - 1] if i > 0 else 0) + (prefix2[j - 1] if j > 0 else 0) + (prefix1[k - 1] if k > 0 else 0)\n            if total > max_cost:\n                max_cost = total\n            j += 1\n    \n    # Also try combinations with only weight1 and weight2\n    len1 = len(prefix1)\n    for i in range(len2 + 1):\n        w2 = i * 2\n        if w2 > m:\n            break\n        rem = m - w2\n        k = min(len1, rem)\n        total = (prefix2[i - 1] if i > 0 else 0) + (prefix1[k - 1] if k > 0 else 0)\n        if total > max_cost:\n            max_cost = total\n    \n    # Also try combinations with only weight1 and weight3\n    for i in range(len3 + 1):\n        w3 = i * 3\n        if w3 > m:\n            break\n        rem = m - w3\n        k = min(len1, rem)\n        total = (prefix3[i - 1] if i > 0 else 0) + (prefix1[k - 1] if k > 0 else 0)\n        if total > max_cost:\n            max_cost = total\n    \n    print(max_cost)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 501,
        "completion_token_count": 750,
        "thoughts_token_count": 0
    }
}