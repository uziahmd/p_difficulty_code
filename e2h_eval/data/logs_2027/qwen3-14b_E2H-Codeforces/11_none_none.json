{
    "start": 1757842723.33746,
    "end": 1757842744.284185,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 11,
    "thought": "",
    "response": "```python\nimport sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    index = 2\n    \n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        cost = int(data[index + 2])\n        vouchers.append((l, r, cost))\n        index += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: for each possible duration d, store the minimum cost of vouchers with that duration\n    # and sorted by their end date\n    from collections import defaultdict\n    duration_to_vouchers = defaultdict(list)\n    \n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_to_vouchers[duration].append((r, cost))\n    \n    # For each duration d, we want to find a voucher with duration x - d\n    min_cost = float('inf')\n    \n    for d in duration_to_vouchers:\n        if (x - d) in duration_to_vouchers:\n            # Get all vouchers with duration d\n            v1_list = duration_to_vouchers[d]\n            # Get all vouchers with duration x - d\n            v2_list = duration_to_vouchers[x - d]\n            \n            # For each voucher in v1_list, find the earliest voucher in v2_list that starts after v1 ends\n            # Since v2_list is sorted by end date, we can use binary search\n            for r1, cost1 in v1_list:\n                # We need to find the first voucher in v2_list with start > r1\n                # Since v2_list is sorted by end date, we can binary search on the end date\n                # But we need to ensure that the start date of v2 is > r1\n                # So we can't directly binary search on end date, but we can use a trick\n                # Since v2_list is sorted by end date, and start <= end, we can use the end date as an approximation\n                # To find the first voucher where start > r1, we can binary search on the end date\n                # and check if the start is > r1\n                \n                # Extract the end dates for binary search\n                end_dates = [v[0] for v in v2_list]\n                # Find the first index where end_date > r1\n                idx = bisect.bisect_right(end_dates, r1)\n                \n                # Check from idx onwards\n                for i in range(idx, len(v2_list)):\n                    r2, cost2 = v2_list[i]\n                    # Since v2 starts at some l2 <= r2, and we know l2 > r1\n                    # So the two vouchers do not overlap\n                    total_cost = cost1 + cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    index = 2\n    \n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        cost = int(data[index + 2])\n        vouchers.append((l, r, cost))\n        index += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: for each possible duration d, store the minimum cost of vouchers with that duration\n    # and sorted by their end date\n    from collections import defaultdict\n    duration_to_vouchers = defaultdict(list)\n    \n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_to_vouchers[duration].append((r, cost))\n    \n    # For each duration d, we want to find a voucher with duration x - d\n    min_cost = float('inf')\n    \n    for d in duration_to_vouchers:\n        if (x - d) in duration_to_vouchers:\n            # Get all vouchers with duration d\n            v1_list = duration_to_vouchers[d]\n            # Get all vouchers with duration x - d\n            v2_list = duration_to_vouchers[x - d]\n            \n            # For each voucher in v1_list, find the earliest voucher in v2_list that starts after v1 ends\n            # Since v2_list is sorted by end date, we can use binary search\n            for r1, cost1 in v1_list:\n                # We need to find the first voucher in v2_list with start > r1\n                # Since v2_list is sorted by end date, we can binary search on the end date\n                # But we need to ensure that the start date of v2 is > r1\n                # So we can't directly binary search on end date, but we can use a trick\n                # Since v2_list is sorted by end date, and start <= end, we can use the end date as an approximation\n                # To find the first voucher where start > r1, we can binary search on the end date\n                # and check if the start is > r1\n                \n                # Extract the end dates for binary search\n                end_dates = [v[0] for v in v2_list]\n                # Find the first index where end_date > r1\n                idx = bisect.bisect_right(end_dates, r1)\n                \n                # Check from idx onwards\n                for i in range(idx, len(v2_list)):\n                    r2, cost2 = v2_list[i]\n                    # Since v2 starts at some l2 <= r2, and we know l2 > r1\n                    # So the two vouchers do not overlap\n                    total_cost = cost1 + cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 644,
        "completion_token_count": 662,
        "thoughts_token_count": 0
    }
}