{
    "start": 1757842746.715322,
    "end": 1757842755.128461,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 15,
    "thought": "Could not extract thought.",
    "response": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    a = [0]*m\n    b = [0]*m\n    c = [0]*m\n    adj = [[] for _ in range(n+1)]\n    for i in range(m):\n        ai = int(next(it)); bi = int(next(it)); ci = int(next(it))\n        a[i]=ai; b[i]=bi; c[i]=ci\n        adj[ai].append((bi, ci, i))\n        adj[bi].append((ai, ci, i))\n    need_in = [0]*(n+1)\n    for i in range(m):\n        need_in[a[i]] += c[i]\n        need_in[b[i]] += c[i]\n    # For internal vertices v (not 1 or n), desired incoming = desired outgoing, but algorithm uses processing:\n    # We will treat indeg_needed as total incoming sum required to be fixed: for v != 1 and v != n, target incoming = total/2\n    target_in = [0]*(n+1)\n    for v in range(1, n+1):\n        if v==1:\n            target_in[v]=0\n        elif v==n:\n            target_in[v]=need_in[v]  # sink should have all incoming, no outgoing\n        else:\n            target_in[v]=need_in[v]//2\n    cur_in = [0]*(n+1)\n    used = [False]*m\n    ans = [0]*m\n    q = deque()\n    for v in range(1, n+1):\n        if cur_in[v]==target_in[v]:\n            q.append(v)\n    # However initially cur_in=0 so push vertices with target_in==0: includes source and maybe others\n    while q:\n        v = q.popleft()\n        for to, w, idx in adj[v]:\n            if used[idx]:\n                continue\n            # decide direction: if v -> to means flow goes from v to to: for edge (a[idx],b[idx]) we output 0 if a->b\n            # We are processing v when its current incoming equals target, so we must send edges out of v.\n            used[idx]=True\n            if v == a[idx] and to == b[idx]:\n                ans[idx]=0\n            else:\n                ans[idx]=1\n            # This edge gives incoming flow to 'to'\n            cur_in[to] += w\n            if cur_in[to]==target_in[to]:\n                q.append(to)\n    out = '\\n'.join(str(x) for x in ans)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    a = [0]*m\n    b = [0]*m\n    c = [0]*m\n    adj = [[] for _ in range(n+1)]\n    for i in range(m):\n        ai = int(next(it)); bi = int(next(it)); ci = int(next(it))\n        a[i]=ai; b[i]=bi; c[i]=ci\n        adj[ai].append((bi, ci, i))\n        adj[bi].append((ai, ci, i))\n    need_in = [0]*(n+1)\n    for i in range(m):\n        need_in[a[i]] += c[i]\n        need_in[b[i]] += c[i]\n    # For internal vertices v (not 1 or n), desired incoming = desired outgoing, but algorithm uses processing:\n    # We will treat indeg_needed as total incoming sum required to be fixed: for v != 1 and v != n, target incoming = total/2\n    target_in = [0]*(n+1)\n    for v in range(1, n+1):\n        if v==1:\n            target_in[v]=0\n        elif v==n:\n            target_in[v]=need_in[v]  # sink should have all incoming, no outgoing\n        else:\n            target_in[v]=need_in[v]//2\n    cur_in = [0]*(n+1)\n    used = [False]*m\n    ans = [0]*m\n    q = deque()\n    for v in range(1, n+1):\n        if cur_in[v]==target_in[v]:\n            q.append(v)\n    # However initially cur_in=0 so push vertices with target_in==0: includes source and maybe others\n    while q:\n        v = q.popleft()\n        for to, w, idx in adj[v]:\n            if used[idx]:\n                continue\n            # decide direction: if v -> to means flow goes from v to to: for edge (a[idx],b[idx]) we output 0 if a->b\n            # We are processing v when its current incoming equals target, so we must send edges out of v.\n            used[idx]=True\n            if v == a[idx] and to == b[idx]:\n                ans[idx]=0\n            else:\n                ans[idx]=1\n            # This edge gives incoming flow to 'to'\n            cur_in[to] += w\n            if cur_in[to]==target_in[to]:\n                q.append(to)\n    out = '\\n'.join(str(x) for x in ans)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 643,
        "completion_token_count": 589,
        "thoughts_token_count": 0
    }
}