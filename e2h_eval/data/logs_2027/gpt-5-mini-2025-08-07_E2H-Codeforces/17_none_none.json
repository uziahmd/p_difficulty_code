{
    "start": 1757842729.6563573,
    "end": 1757842740.6653926,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 17,
    "thought": "Could not extract thought.",
    "response": "import sys\nimport threading\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        w = int(next(it)); c = int(next(it))\n        if w == 1:\n            w1.append(c)\n        elif w == 2:\n            w2.append(c)\n        else:\n            w3.append(c)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1: pref1.append(pref1[-1]+v)\n    pref2 = [0]\n    for v in w2: pref2.append(pref2[-1]+v)\n    pref3 = [0]\n    for v in w3: pref3.append(pref3[-1]+v)\n    # Precompute best using weights 1 and 2 up to capacity m\n    best12 = [0]*(m+1)\n    # Greedy: try k twos then fill ones\n    # For k from 0..len(w2)\n    len2 = len(w2)\n    len1 = len(w1)\n    # initialize with zeros\n    for k in range(len2+1):\n        w_used = 2*k\n        if w_used > m: break\n        val2 = pref2[k]\n        rem = m - w_used\n        take1 = min(len1, rem)\n        val = val2 + pref1[take1]\n        # store at index w_used; but we want best for capacity rem? Instead we'll update best12 for capacity = w_used + t where t from 0..take1\n        # Simpler: We will update an array temp of size m+1 with choose of ones only later. Alternate approach: build best12 by trying number of twos and ones counts.\n        # Iterate t from 0..take1\n        for t in range(take1+1):\n            cap = w_used + t\n            if cap <= m:\n                cand = val2 + pref1[t]\n                if cand > best12[cap]:\n                    best12[cap] = cand\n    # Also consider using only ones (k=0 already covered)\n    # Now make best12 monotonic: for capacity i, best12[i] = max over <=i\n    for i in range(1, m+1):\n        if best12[i-1] > best12[i]:\n            best12[i] = best12[i-1]\n    ans = 0\n    # try using t weight-3 items\n    for t in range(0, len(w3)+1):\n        w_used3 = 3*t\n        if w_used3 > m: break\n        val3 = pref3[t]\n        rem = m - w_used3\n        cand = val3 + best12[rem]\n        if cand > ans:\n            ans = cand\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        w = int(next(it)); c = int(next(it))\n        if w == 1:\n            w1.append(c)\n        elif w == 2:\n            w2.append(c)\n        else:\n            w3.append(c)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1: pref1.append(pref1[-1]+v)\n    pref2 = [0]\n    for v in w2: pref2.append(pref2[-1]+v)\n    pref3 = [0]\n    for v in w3: pref3.append(pref3[-1]+v)\n    # Precompute best using weights 1 and 2 up to capacity m\n    best12 = [0]*(m+1)\n    # Greedy: try k twos then fill ones\n    # For k from 0..len(w2)\n    len2 = len(w2)\n    len1 = len(w1)\n    # initialize with zeros\n    for k in range(len2+1):\n        w_used = 2*k\n        if w_used > m: break\n        val2 = pref2[k]\n        rem = m - w_used\n        take1 = min(len1, rem)\n        val = val2 + pref1[take1]\n        # store at index w_used; but we want best for capacity rem? Instead we'll update best12 for capacity = w_used + t where t from 0..take1\n        # Simpler: We will update an array temp of size m+1 with choose of ones only later. Alternate approach: build best12 by trying number of twos and ones counts.\n        # Iterate t from 0..take1\n        for t in range(take1+1):\n            cap = w_used + t\n            if cap <= m:\n                cand = val2 + pref1[t]\n                if cand > best12[cap]:\n                    best12[cap] = cand\n    # Also consider using only ones (k=0 already covered)\n    # Now make best12 monotonic: for capacity i, best12[i] = max over <=i\n    for i in range(1, m+1):\n        if best12[i-1] > best12[i]:\n            best12[i] = best12[i-1]\n    ans = 0\n    # try using t weight-3 items\n    for t in range(0, len(w3)+1):\n        w_used3 = 3*t\n        if w_used3 > m: break\n        val3 = pref3[t]\n        rem = m - w_used3\n        cand = val3 + best12[rem]\n        if cand > ans:\n            ans = cand\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 444,
        "completion_token_count": 678,
        "thoughts_token_count": 0
    }
}