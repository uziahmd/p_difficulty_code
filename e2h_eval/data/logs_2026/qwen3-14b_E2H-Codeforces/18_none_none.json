{
    "start": 1757842757.7988012,
    "end": 1757842774.311276,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 18,
    "thought": "",
    "response": "```python\nimport sys\nimport heapq\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    from collections import defaultdict\n    \n    tree = defaultdict(list)\n    index = 2\n    for _ in range(n - 1):\n        a = int(data[index])\n        b = int(data[index + 1])\n        tree[a].append(b)\n        tree[b].append(a)\n        index += 2\n    \n    # We will use a priority queue to select which nodes to remove\n    # We want to keep the nodes with the highest 2^i values\n    # So we will remove the nodes with the smallest 2^i values first\n    # But we must ensure that the remaining nodes form a connected component\n    \n    # We need to find the subtree with the maximum sum of 2^i values\n    # This is equivalent to finding the subtree with the maximum number of high-numbered nodes\n    # We can do this using a greedy approach with DFS and a priority queue\n    \n    # We'll perform a DFS starting from node 1, and for each node, we'll keep track of the size of the subtree\n    # and the total value of the subtree. We'll use a priority queue to decide which subtrees to prune\n    \n    # We'll use a max-heap (simulated with negative values) to keep track of the best subtrees to keep\n    # We'll use a list to store the nodes to remove\n    \n    removed = []\n    \n    def dfs(node, parent):\n        total = 2 ** node\n        size = 1\n        heap = []\n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            child_total, child_size = dfs(neighbor, node)\n            total += child_total\n            size += child_size\n            heapq.heappush(heap, (-child_total, -child_size, neighbor))\n        \n        # Now, we try to remove up to k nodes\n        while len(removed) < k and heap:\n            neg_total, neg_size, child = heapq.heappop(heap)\n            total -= (-neg_total)\n            size -= (-neg_size)\n            removed.append(child)\n        \n        return total, size\n    \n    dfs(1, -1)\n    \n    # Sort the removed nodes in increasing order\n    removed.sort()\n    print(' '.join(map(str, removed)))\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport heapq\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    from collections import defaultdict\n    \n    tree = defaultdict(list)\n    index = 2\n    for _ in range(n - 1):\n        a = int(data[index])\n        b = int(data[index + 1])\n        tree[a].append(b)\n        tree[b].append(a)\n        index += 2\n    \n    # We will use a priority queue to select which nodes to remove\n    # We want to keep the nodes with the highest 2^i values\n    # So we will remove the nodes with the smallest 2^i values first\n    # But we must ensure that the remaining nodes form a connected component\n    \n    # We need to find the subtree with the maximum sum of 2^i values\n    # This is equivalent to finding the subtree with the maximum number of high-numbered nodes\n    # We can do this using a greedy approach with DFS and a priority queue\n    \n    # We'll perform a DFS starting from node 1, and for each node, we'll keep track of the size of the subtree\n    # and the total value of the subtree. We'll use a priority queue to decide which subtrees to prune\n    \n    # We'll use a max-heap (simulated with negative values) to keep track of the best subtrees to keep\n    # We'll use a list to store the nodes to remove\n    \n    removed = []\n    \n    def dfs(node, parent):\n        total = 2 ** node\n        size = 1\n        heap = []\n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            child_total, child_size = dfs(neighbor, node)\n            total += child_total\n            size += child_size\n            heapq.heappush(heap, (-child_total, -child_size, neighbor))\n        \n        # Now, we try to remove up to k nodes\n        while len(removed) < k and heap:\n            neg_total, neg_size, child = heapq.heappop(heap)\n            total -= (-neg_total)\n            size -= (-neg_size)\n            removed.append(child)\n        \n        return total, size\n    \n    dfs(1, -1)\n    \n    # Sort the removed nodes in increasing order\n    removed.sort()\n    print(' '.join(map(str, removed)))",
    "score": -1,
    "metadata": {
        "prompt_token_count": 532,
        "completion_token_count": 529,
        "thoughts_token_count": 0
    }
}