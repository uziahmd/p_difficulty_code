{
    "start": 1757842723.5242968,
    "end": 1757842741.2298014,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 11,
    "thought": "",
    "response": "```python\nimport sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        cost = int(data[idx+2])\n        vouchers.append((l, r, cost))\n        idx += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort(key=lambda v: v[1])\n    \n    # Preprocess: For each voucher, store the minimum cost for each duration\n    # We will use two arrays:\n    # left_min: min cost for a voucher ending at or before day i with duration d\n    # right_min: min cost for a voucher starting at or after day i with duration d\n    \n    max_day = 2 * 10**5 + 2\n    left_min = [float('inf')] * (max_day + 2)\n    right_min = [float('inf')] * (max_day + 2)\n    \n    # Fill left_min\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration > x:\n            continue\n        if left_min[r] > cost:\n            left_min[r] = cost\n    \n    # Fill right_min\n    for l, r, cost in reversed(vouchers):\n        duration = r - l + 1\n        if duration > x:\n            continue\n        if right_min[l] > cost:\n            right_min[l] = cost\n    \n    # Now, for each voucher, check if there's a compatible voucher on the other side\n    min_cost = float('inf')\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration > x:\n            continue\n        \n        needed_duration = x - duration\n        # Check for a voucher that starts after r\n        start = r + 1\n        if start <= max_day and right_min[start] != float('inf'):\n            total_cost = cost + right_min[start]\n            if total_cost < min_cost:\n                min_cost = total_cost\n        \n        # Check for a voucher that ends before l\n        end = l - 1\n        if end >= 0 and left_min[end] != float('inf'):\n            total_cost = cost + left_min[end]\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        cost = int(data[idx+2])\n        vouchers.append((l, r, cost))\n        idx += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort(key=lambda v: v[1])\n    \n    # Preprocess: For each voucher, store the minimum cost for each duration\n    # We will use two arrays:\n    # left_min: min cost for a voucher ending at or before day i with duration d\n    # right_min: min cost for a voucher starting at or after day i with duration d\n    \n    max_day = 2 * 10**5 + 2\n    left_min = [float('inf')] * (max_day + 2)\n    right_min = [float('inf')] * (max_day + 2)\n    \n    # Fill left_min\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration > x:\n            continue\n        if left_min[r] > cost:\n            left_min[r] = cost\n    \n    # Fill right_min\n    for l, r, cost in reversed(vouchers):\n        duration = r - l + 1\n        if duration > x:\n            continue\n        if right_min[l] > cost:\n            right_min[l] = cost\n    \n    # Now, for each voucher, check if there's a compatible voucher on the other side\n    min_cost = float('inf')\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration > x:\n            continue\n        \n        needed_duration = x - duration\n        # Check for a voucher that starts after r\n        start = r + 1\n        if start <= max_day and right_min[start] != float('inf'):\n            total_cost = cost + right_min[start]\n            if total_cost < min_cost:\n                min_cost = total_cost\n        \n        # Check for a voucher that ends before l\n        end = l - 1\n        if end >= 0 and left_min[end] != float('inf'):\n            total_cost = cost + left_min[end]\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 644,
        "completion_token_count": 559,
        "thoughts_token_count": 0
    }
}