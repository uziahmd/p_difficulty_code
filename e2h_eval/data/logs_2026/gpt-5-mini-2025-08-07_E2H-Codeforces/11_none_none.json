{
    "start": 1757842711.568958,
    "end": 1757842722.7245471,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:38 KST",
    "gpu": 2,
    "pid": 11,
    "thought": "Could not extract thought.",
    "response": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    maxR = 0\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); c = int(next(it))\n        vouchers.append((l, r, c))\n        if r > maxR: maxR = r\n    MAX = max(200000, maxR) + 5\n    # group by duration\n    by_len = [[] for _ in range(MAX)]\n    for l, r, c in vouchers:\n        d = r - l + 1\n        if d < MAX:\n            by_len[d].append((l, r, c))\n    INF = 10**30\n    # For each length d, build best cost ending at or before position p (for right side) and starting at or after p (for left side)\n    # We'll build best_right[d][p]: minimal cost of interval of length d that ends at or before p (i.e., r<=p)\n    # and best_left[d][p]: minimal cost of interval of length d that starts at or after p (i.e., l>=p)\n    # But storing for all d is heavy. Instead, for each d that has intervals, build arrays.\n    best_right = dict()\n    best_left = dict()\n    for d in range(1, MAX):\n        if not by_len[d]:\n            continue\n        arrR = [INF] * (MAX)\n        for l, r, c in by_len[d]:\n            if arrR[r] > c:\n                arrR[r] = c\n        # prefix min over r\n        for i in range(1, MAX):\n            if arrR[i] > arrR[i-1]:\n                arrR[i] = arrR[i-1]\n        best_right[d] = arrR\n        arrL = [INF] * (MAX + 2)\n        for l, r, c in by_len[d]:\n            if arrL[l] > c:\n                arrL[l] = c\n        # suffix min over l\n        for i in range(MAX-1, 0, -1):\n            if arrL[i] > arrL[i+1]:\n                arrL[i] = arrL[i+1]\n        best_left[d] = arrL\n    ans = INF\n    # iterate each voucher as first, try complement length\n    for l, r, c in vouchers:\n        d1 = r - l + 1\n        d2 = x - d1\n        if d2 <= 0 or d2 >= MAX:\n            continue\n        # need disjoint: other ends before l-1 (r' < l) or starts after r+1 (l' > r)\n        # check best_right[d2] up to l-1\n        br = best_right.get(d2)\n        if br is not None:\n            idx = l-1\n            if idx >= 0:\n                cost2 = br[idx]\n                if cost2 < INF:\n                    if c + cost2 < ans:\n                        ans = c + cost2\n        bl = best_left.get(d2)\n        if bl is not None:\n            idx = r+1\n            if idx < len(bl):\n                cost2 = bl[idx]\n                if cost2 < INF:\n                    if c + cost2 < ans:\n                        ans = c + cost2\n    if ans >= INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    maxR = 0\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); c = int(next(it))\n        vouchers.append((l, r, c))\n        if r > maxR: maxR = r\n    MAX = max(200000, maxR) + 5\n    # group by duration\n    by_len = [[] for _ in range(MAX)]\n    for l, r, c in vouchers:\n        d = r - l + 1\n        if d < MAX:\n            by_len[d].append((l, r, c))\n    INF = 10**30\n    # For each length d, build best cost ending at or before position p (for right side) and starting at or after p (for left side)\n    # We'll build best_right[d][p]: minimal cost of interval of length d that ends at or before p (i.e., r<=p)\n    # and best_left[d][p]: minimal cost of interval of length d that starts at or after p (i.e., l>=p)\n    # But storing for all d is heavy. Instead, for each d that has intervals, build arrays.\n    best_right = dict()\n    best_left = dict()\n    for d in range(1, MAX):\n        if not by_len[d]:\n            continue\n        arrR = [INF] * (MAX)\n        for l, r, c in by_len[d]:\n            if arrR[r] > c:\n                arrR[r] = c\n        # prefix min over r\n        for i in range(1, MAX):\n            if arrR[i] > arrR[i-1]:\n                arrR[i] = arrR[i-1]\n        best_right[d] = arrR\n        arrL = [INF] * (MAX + 2)\n        for l, r, c in by_len[d]:\n            if arrL[l] > c:\n                arrL[l] = c\n        # suffix min over l\n        for i in range(MAX-1, 0, -1):\n            if arrL[i] > arrL[i+1]:\n                arrL[i] = arrL[i+1]\n        best_left[d] = arrL\n    ans = INF\n    # iterate each voucher as first, try complement length\n    for l, r, c in vouchers:\n        d1 = r - l + 1\n        d2 = x - d1\n        if d2 <= 0 or d2 >= MAX:\n            continue\n        # need disjoint: other ends before l-1 (r' < l) or starts after r+1 (l' > r)\n        # check best_right[d2] up to l-1\n        br = best_right.get(d2)\n        if br is not None:\n            idx = l-1\n            if idx >= 0:\n                cost2 = br[idx]\n                if cost2 < INF:\n                    if c + cost2 < ans:\n                        ans = c + cost2\n        bl = best_left.get(d2)\n        if bl is not None:\n            idx = r+1\n            if idx < len(bl):\n                cost2 = bl[idx]\n                if cost2 < INF:\n                    if c + cost2 < ans:\n                        ans = c + cost2\n    if ans >= INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 597,
        "completion_token_count": 776,
        "thoughts_token_count": 0
    }
}