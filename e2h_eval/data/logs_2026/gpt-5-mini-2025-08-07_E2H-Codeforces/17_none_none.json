{
    "start": 1757842722.7985022,
    "end": 1757842734.379432,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:38 KST",
    "gpu": 2,
    "pid": 17,
    "thought": "Could not extract thought.",
    "response": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        w = int(next(it)); c = int(next(it))\n        if w == 1:\n            w1.append(c)\n        elif w == 2:\n            w2.append(c)\n        else:\n            w3.append(c)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    # Precompute best using weight 1 and 2 only: for capacity up to m, best value\n    # We can try using k weight-1 items and t weight-2 items\n    # For faster, for each possible number of weight-2 items t, compute value and available capacity for weight1.\n    maxv = 0\n    # Precompute best value using only w1 and w2 for each capacity c up to m? Instead iterate t.\n    # But counts limited by lengths and capacity.\n    len1 = len(w1); len2 = len(w2); len3 = len(w3)\n    # For t from 0..min(len2, m//2)\n    best_w12 = [0] * (m+1)  # optional not needed\n    # Instead iterate t and k\n    # Precompute best of w1 for any k up to len1, using pref1\n    # Iterate t from 0..min(len2, m//2):\n    max_w12_for_cap = 0\n    # We'll compute best using only w1 and w2 for each possible weight used, but simpler:\n    # For t in range 0..min(len2, m//2):\n    #   weight2 = 2*t, value2 = pref2[t]\n    #   remaining = m - weight2\n    #   take k = min(len1, remaining)\n    #   value = value2 + pref1[k]\n    # Track maximum for each possible capacity when later adding w3.\n    # However when adding w3 items of weight 3*s, remaining capacity changes; easier to compute for each possible number of w3 used.\n    # So precompute best value for any capacity cap using w1 and w2 greedily: dynamic: for cap from 0..m compute max\n    # We'll compute dp_cap where we try t weight2 items and fill with weight1.\n    dp_cap = [0] * (m+1)\n    # initialize with take 0 weight2: for cap c, dp = pref1[min(len1, c)]\n    for c in range(m+1):\n        k = c if c < len1 else len1\n        dp_cap[c] = pref1[k]\n    # now consider adding weight2 items greedily: for t from 1..len2\n    for t in range(1, len2+1):\n        w2_weight = 2*t\n        if w2_weight > m:\n            break\n        val2 = pref2[t]\n        # for capacities c from w2_weight..m, candidate = val2 + pref1[min(len1, c - w2_weight)]\n        for c in range(w2_weight, m+1):\n            rem = c - w2_weight\n            k = rem if rem < len1 else len1\n            cand = val2 + pref1[k]\n            if cand > dp_cap[c]:\n                dp_cap[c] = cand\n    # Now consider taking s weight3 items\n    res = 0\n    # s from 0..len3 and 3*s <= m\n    for s in range(0, len3+1):\n        w3_weight = 3*s\n        if w3_weight > m:\n            break\n        val3 = pref3[s]\n        rem_cap = m - w3_weight\n        cand = val3 + dp_cap[rem_cap]\n        if cand > res:\n            res = cand\n    print(res)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        w = int(next(it)); c = int(next(it))\n        if w == 1:\n            w1.append(c)\n        elif w == 2:\n            w2.append(c)\n        else:\n            w3.append(c)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    # Precompute best using weight 1 and 2 only: for capacity up to m, best value\n    # We can try using k weight-1 items and t weight-2 items\n    # For faster, for each possible number of weight-2 items t, compute value and available capacity for weight1.\n    maxv = 0\n    # Precompute best value using only w1 and w2 for each capacity c up to m? Instead iterate t.\n    # But counts limited by lengths and capacity.\n    len1 = len(w1); len2 = len(w2); len3 = len(w3)\n    # For t from 0..min(len2, m//2)\n    best_w12 = [0] * (m+1)  # optional not needed\n    # Instead iterate t and k\n    # Precompute best of w1 for any k up to len1, using pref1\n    # Iterate t from 0..min(len2, m//2):\n    max_w12_for_cap = 0\n    # We'll compute best using only w1 and w2 for each possible weight used, but simpler:\n    # For t in range 0..min(len2, m//2):\n    #   weight2 = 2*t, value2 = pref2[t]\n    #   remaining = m - weight2\n    #   take k = min(len1, remaining)\n    #   value = value2 + pref1[k]\n    # Track maximum for each possible capacity when later adding w3.\n    # However when adding w3 items of weight 3*s, remaining capacity changes; easier to compute for each possible number of w3 used.\n    # So precompute best value for any capacity cap using w1 and w2 greedily: dynamic: for cap from 0..m compute max\n    # We'll compute dp_cap where we try t weight2 items and fill with weight1.\n    dp_cap = [0] * (m+1)\n    # initialize with take 0 weight2: for cap c, dp = pref1[min(len1, c)]\n    for c in range(m+1):\n        k = c if c < len1 else len1\n        dp_cap[c] = pref1[k]\n    # now consider adding weight2 items greedily: for t from 1..len2\n    for t in range(1, len2+1):\n        w2_weight = 2*t\n        if w2_weight > m:\n            break\n        val2 = pref2[t]\n        # for capacities c from w2_weight..m, candidate = val2 + pref1[min(len1, c - w2_weight)]\n        for c in range(w2_weight, m+1):\n            rem = c - w2_weight\n            k = rem if rem < len1 else len1\n            cand = val2 + pref1[k]\n            if cand > dp_cap[c]:\n                dp_cap[c] = cand\n    # Now consider taking s weight3 items\n    res = 0\n    # s from 0..len3 and 3*s <= m\n    for s in range(0, len3+1):\n        w3_weight = 3*s\n        if w3_weight > m:\n            break\n        val3 = pref3[s]\n        rem_cap = m - w3_weight\n        cand = val3 + dp_cap[rem_cap]\n        if cand > res:\n            res = cand\n    print(res)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 444,
        "completion_token_count": 969,
        "thoughts_token_count": 0
    }
}