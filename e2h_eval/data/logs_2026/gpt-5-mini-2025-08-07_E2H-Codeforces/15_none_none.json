{
    "start": 1757842741.3915248,
    "end": 1757842750.000885,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 15,
    "thought": "Could not extract thought.",
    "response": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    edges = []\n    adj = [[] for _ in range(n+1)]\n    deg = [0]*(n+1)\n    for i in range(1, m+1):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        edges.append((a,b,c))\n        adj[a].append((b,c,i-1))\n        adj[b].append((a,c,i-1))\n        deg[a] += c\n        deg[b] += c\n    need = [0]*(n+1)\n    for v in range(1, n+1):\n        if v==1 or v==n:\n            need[v]=0\n        else:\n            need[v]=deg[v]//2\n    res = [-1]*m\n    q = deque()\n    # push vertices whose current outflow assigned reaches need? Standard approach: start from source 1.\n    # We simulate draining from 1: process nodes whose required outgoing assigned equals need by pushing edges.\n    # Instead use: maintain remaining need rem[v]=need[v]; when rem[v]==0 push v.\n    rem = need[:]\n    q.append(1)\n    visited = [False]*(n+1)\n    visited[1]=True\n    while q:\n        v = q.popleft()\n        for to,c,idx in adj[v]:\n            if res[idx]!=-1:\n                continue\n            a,b,_ = edges[idx]\n            # if edge between v and to, and v is a -> to direction should be 0 if a==v\n            if v==a and to==b:\n                res[idx]=0\n            else:\n                res[idx]=1\n            # assign contributes c to the other vertex's rem\n            if to!=1 and to!=n:\n                rem[to] -= c\n                if rem[to]==0 and not visited[to]:\n                    visited[to]=True\n                    q.append(to)\n    # For any unassigned edges (towards n), direct them towards n (flow into n). For edges still -1, they must be from some node processed later; but ensure assign.\n    for idx in range(m):\n        if res[idx]==-1:\n            a,b,c = edges[idx]\n            # direct so that flow goes into n maybe. If a==n then direction a->b? We want flow into n, so make direction towards n: if b==n then a->b (0), if a==n then b->a (1). Otherwise arbitrary: choose 0.\n            if b==n:\n                res[idx]=0\n            elif a==n:\n                res[idx]=1\n            else:\n                res[idx]=0\n    out = '\\n'.join(str(x) for x in res)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    edges = []\n    adj = [[] for _ in range(n+1)]\n    deg = [0]*(n+1)\n    for i in range(1, m+1):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        edges.append((a,b,c))\n        adj[a].append((b,c,i-1))\n        adj[b].append((a,c,i-1))\n        deg[a] += c\n        deg[b] += c\n    need = [0]*(n+1)\n    for v in range(1, n+1):\n        if v==1 or v==n:\n            need[v]=0\n        else:\n            need[v]=deg[v]//2\n    res = [-1]*m\n    q = deque()\n    # push vertices whose current outflow assigned reaches need? Standard approach: start from source 1.\n    # We simulate draining from 1: process nodes whose required outgoing assigned equals need by pushing edges.\n    # Instead use: maintain remaining need rem[v]=need[v]; when rem[v]==0 push v.\n    rem = need[:]\n    q.append(1)\n    visited = [False]*(n+1)\n    visited[1]=True\n    while q:\n        v = q.popleft()\n        for to,c,idx in adj[v]:\n            if res[idx]!=-1:\n                continue\n            a,b,_ = edges[idx]\n            # if edge between v and to, and v is a -> to direction should be 0 if a==v\n            if v==a and to==b:\n                res[idx]=0\n            else:\n                res[idx]=1\n            # assign contributes c to the other vertex's rem\n            if to!=1 and to!=n:\n                rem[to] -= c\n                if rem[to]==0 and not visited[to]:\n                    visited[to]=True\n                    q.append(to)\n    # For any unassigned edges (towards n), direct them towards n (flow into n). For edges still -1, they must be from some node processed later; but ensure assign.\n    for idx in range(m):\n        if res[idx]==-1:\n            a,b,c = edges[idx]\n            # direct so that flow goes into n maybe. If a==n then direction a->b? We want flow into n, so make direction towards n: if b==n then a->b (0), if a==n then b->a (1). Otherwise arbitrary: choose 0.\n            if b==n:\n                res[idx]=0\n            elif a==n:\n                res[idx]=1\n            else:\n                res[idx]=0\n    out = '\\n'.join(str(x) for x in res)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 643,
        "completion_token_count": 637,
        "thoughts_token_count": 0
    }
}