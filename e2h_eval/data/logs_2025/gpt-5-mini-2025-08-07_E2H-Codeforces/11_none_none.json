{
    "start": 1757842711.5035803,
    "end": 1757842722.8918576,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:38 KST",
    "gpu": 2,
    "pid": 11,
    "thought": "Could not extract thought.",
    "response": "import sys\nimport threading\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it)); x = int(next(it))\n    maxT = 200000\n    intervals_by_len = [[] for _ in range(maxT+2)]\n    intervals = []\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); c = int(next(it))\n        d = r - l + 1\n        if d <= maxT:\n            intervals_by_len[d].append((l, r, c))\n        intervals.append((l, r, c, d))\n    INF = 10**30\n    # For each length, build arrays min_cost_end_at_or_before[pos] for right endpoints\n    # and min_cost_start_at_or_after[pos] for left endpoints\n    # We'll need for lengths from 1..maxT only if list non-empty\n    # Precompute for each length two arrays of size maxT+3 (positions 0..maxT+2)\n    min_cost_left = dict()  # for length -> array best ending at <= pos (by right)\n    min_cost_right = dict() # for length -> array best starting at >= pos (by left)\n    for d in range(1, maxT+1):\n        lst = intervals_by_len[d]\n        if not lst: continue\n        best_end = [INF] * (maxT + 3)  # index by position of right endpoint\n        best_start = [INF] * (maxT + 3)  # index by position of left endpoint\n        # For ends: for each interval (l,r,c), at position r store min cost\n        for l,r,c in lst:\n            if c < best_end[r]:\n                best_end[r] = c\n            if c < best_start[l]:\n                best_start[l] = c\n        # prefix min for ends: up to pos\n        for pos in range(1, maxT+1):\n            if best_end[pos-1] < best_end[pos]:\n                best_end[pos] = best_end[pos-1]\n        # suffix min for starts: from pos\n        for pos in range(maxT, 0, -1):\n            if best_start[pos+1] < best_start[pos]:\n                best_start[pos] = best_start[pos+1]\n        min_cost_left[d] = best_end\n        min_cost_right[d] = best_start\n    ans = INF\n    # For each interval i, consider partner length y = x - d\n    for l,r,c,d in intervals:\n        y = x - d\n        if y <= 0 or y > maxT: continue\n        # partner before: end < l -> best_end at position l-1\n        arr_end = min_cost_left.get(y)\n        if arr_end is not None:\n            val = arr_end[l-1]\n            if val < INF:\n                total = c + val\n                if total < ans: ans = total\n        # partner after: start > r -> best_start at position r+1\n        arr_start = min_cost_right.get(y)\n        if arr_start is not None:\n            val = arr_start[r+1]\n            if val < INF:\n                total = c + val\n                if total < ans: ans = total\n    if ans >= INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it)); x = int(next(it))\n    maxT = 200000\n    intervals_by_len = [[] for _ in range(maxT+2)]\n    intervals = []\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); c = int(next(it))\n        d = r - l + 1\n        if d <= maxT:\n            intervals_by_len[d].append((l, r, c))\n        intervals.append((l, r, c, d))\n    INF = 10**30\n    # For each length, build arrays min_cost_end_at_or_before[pos] for right endpoints\n    # and min_cost_start_at_or_after[pos] for left endpoints\n    # We'll need for lengths from 1..maxT only if list non-empty\n    # Precompute for each length two arrays of size maxT+3 (positions 0..maxT+2)\n    min_cost_left = dict()  # for length -> array best ending at <= pos (by right)\n    min_cost_right = dict() # for length -> array best starting at >= pos (by left)\n    for d in range(1, maxT+1):\n        lst = intervals_by_len[d]\n        if not lst: continue\n        best_end = [INF] * (maxT + 3)  # index by position of right endpoint\n        best_start = [INF] * (maxT + 3)  # index by position of left endpoint\n        # For ends: for each interval (l,r,c), at position r store min cost\n        for l,r,c in lst:\n            if c < best_end[r]:\n                best_end[r] = c\n            if c < best_start[l]:\n                best_start[l] = c\n        # prefix min for ends: up to pos\n        for pos in range(1, maxT+1):\n            if best_end[pos-1] < best_end[pos]:\n                best_end[pos] = best_end[pos-1]\n        # suffix min for starts: from pos\n        for pos in range(maxT, 0, -1):\n            if best_start[pos+1] < best_start[pos]:\n                best_start[pos] = best_start[pos+1]\n        min_cost_left[d] = best_end\n        min_cost_right[d] = best_start\n    ans = INF\n    # For each interval i, consider partner length y = x - d\n    for l,r,c,d in intervals:\n        y = x - d\n        if y <= 0 or y > maxT: continue\n        # partner before: end < l -> best_end at position l-1\n        arr_end = min_cost_left.get(y)\n        if arr_end is not None:\n            val = arr_end[l-1]\n            if val < INF:\n                total = c + val\n                if total < ans: ans = total\n        # partner after: start > r -> best_start at position r+1\n        arr_start = min_cost_right.get(y)\n        if arr_start is not None:\n            val = arr_start[r+1]\n            if val < INF:\n                total = c + val\n                if total < ans: ans = total\n    if ans >= INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 597,
        "completion_token_count": 740,
        "thoughts_token_count": 0
    }
}