{
    "start": 1757842781.0864365,
    "end": 1757842797.67513,
    "start-formatted": "2025-09-14 18:39 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 15,
    "thought": "",
    "response": "```python\nimport sys\nimport threading\nfrom collections import defaultdict, deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = defaultdict(list)\n    edge_index = {}\n    \n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n        edge_index[(a, b)] = i\n        edge_index[(b, a)] = i\n\n    # We need to assign directions to edges such that:\n    # - The flow is valid (conservation of flow at intermediate nodes)\n    # - Source has no incoming edges\n    # - The directed graph is acyclic\n\n    # To ensure acyclicity and correct flow, we can build a directed tree rooted at source (node 1)\n    # and direct all edges away from the root.\n\n    # Use BFS to build a tree starting from node 1\n    parent = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n\n    while q:\n        u = q.popleft()\n        for v, idx in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                q.append(v)\n\n    # Now assign directions based on the tree\n    result = [0] * m\n\n    for i in range(m):\n        a, b, c = edges[i]\n        if parent[b] == a:\n            result[i] = 0  # direction a -> b\n        elif parent[a] == b:\n            result[i] = 1  # direction b -> a\n        else:\n            # This edge is not part of the tree; we can choose any direction\n            # But we need to make sure it doesn't create a cycle.\n            # Since the tree is built with BFS, we can safely direct it from parent to child\n            # If neither is parent of other, then it's a back edge. We can direct it from lower to higher node to avoid cycles\n            if a < b:\n                result[i] = 0\n            else:\n                result[i] = 1\n\n    for d in result:\n        print(d)\n        \nthreading.Thread(target=solve).start()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import defaultdict, deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = defaultdict(list)\n    edge_index = {}\n    \n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n        edge_index[(a, b)] = i\n        edge_index[(b, a)] = i\n\n    # We need to assign directions to edges such that:\n    # - The flow is valid (conservation of flow at intermediate nodes)\n    # - Source has no incoming edges\n    # - The directed graph is acyclic\n\n    # To ensure acyclicity and correct flow, we can build a directed tree rooted at source (node 1)\n    # and direct all edges away from the root.\n\n    # Use BFS to build a tree starting from node 1\n    parent = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n\n    while q:\n        u = q.popleft()\n        for v, idx in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                q.append(v)\n\n    # Now assign directions based on the tree\n    result = [0] * m\n\n    for i in range(m):\n        a, b, c = edges[i]\n        if parent[b] == a:\n            result[i] = 0  # direction a -> b\n        elif parent[a] == b:\n            result[i] = 1  # direction b -> a\n        else:\n            # This edge is not part of the tree; we can choose any direction\n            # But we need to make sure it doesn't create a cycle.\n            # Since the tree is built with BFS, we can safely direct it from parent to child\n            # If neither is parent of other, then it's a back edge. We can direct it from lower to higher node to avoid cycles\n            if a < b:\n                result[i] = 0\n            else:\n                result[i] = 1\n\n    for d in result:\n        print(d)\n        \nthreading.Thread(target=solve).start()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 689,
        "completion_token_count": 535,
        "thoughts_token_count": 0
    }
}