{
    "start": 1757842723.3774433,
    "end": 1757842745.169237,
    "start-formatted": "2025-09-14 18:38 KST",
    "end-formatted": "2025-09-14 18:39 KST",
    "gpu": 2,
    "pid": 11,
    "thought": "",
    "response": "```python\nimport sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        cost = int(data[idx + 2])\n        vouchers.append((l, r, cost))\n        idx += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: For each voucher, store the minimum cost for a given duration\n    # We'll use two dictionaries:\n    # - left_duration: maps duration to min cost for vouchers ending before a certain day\n    # - right_duration: maps duration to min cost for vouchers starting after a certain day\n    \n    # First pass: build left_duration\n    left_duration = {}\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration not in left_duration or cost < left_duration[duration]:\n            left_duration[duration] = cost\n    \n    # Second pass: build right_duration\n    right_duration = {}\n    for l, r, cost in reversed(vouchers):\n        duration = r - l + 1\n        if duration not in right_duration or cost < right_duration[duration]:\n            right_duration[duration] = cost\n    \n    # Now, for each voucher, check if there's another voucher that can pair with it\n    min_cost = float('inf')\n    for l, r, cost in vouchers:\n        duration1 = r - l + 1\n        duration2 = x - duration1\n        \n        # Check if duration2 is valid\n        if duration2 <= 0:\n            continue\n        \n        # Check if there is a voucher that starts after r and has duration2\n        # Use binary search to find the first voucher with l > r\n        # Since vouchers are sorted by r, we need to find the first voucher where l > r\n        # So we can binary search on l of vouchers\n        # Extract all l's from vouchers for binary search\n        l_list = [v[0] for v in vouchers]\n        i = bisect.bisect_right(l_list, r)\n        if i < n:\n            # Check if there is a voucher starting after r with duration2\n            if duration2 in right_duration:\n                total_cost = cost + right_duration[duration2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n        \n        # Check if there is a voucher that ends before l and has duration2\n        # Use binary search to find the last voucher with r < l\n        r_list = [v[1] for v in vouchers]\n        j = bisect.bisect_left(r_list, l) - 1\n        if j >= 0:\n            # Check if there is a voucher ending before l with duration2\n            if duration2 in left_duration:\n                total_cost = cost + left_duration[duration2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        cost = int(data[idx + 2])\n        vouchers.append((l, r, cost))\n        idx += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: For each voucher, store the minimum cost for a given duration\n    # We'll use two dictionaries:\n    # - left_duration: maps duration to min cost for vouchers ending before a certain day\n    # - right_duration: maps duration to min cost for vouchers starting after a certain day\n    \n    # First pass: build left_duration\n    left_duration = {}\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration not in left_duration or cost < left_duration[duration]:\n            left_duration[duration] = cost\n    \n    # Second pass: build right_duration\n    right_duration = {}\n    for l, r, cost in reversed(vouchers):\n        duration = r - l + 1\n        if duration not in right_duration or cost < right_duration[duration]:\n            right_duration[duration] = cost\n    \n    # Now, for each voucher, check if there's another voucher that can pair with it\n    min_cost = float('inf')\n    for l, r, cost in vouchers:\n        duration1 = r - l + 1\n        duration2 = x - duration1\n        \n        # Check if duration2 is valid\n        if duration2 <= 0:\n            continue\n        \n        # Check if there is a voucher that starts after r and has duration2\n        # Use binary search to find the first voucher with l > r\n        # Since vouchers are sorted by r, we need to find the first voucher where l > r\n        # So we can binary search on l of vouchers\n        # Extract all l's from vouchers for binary search\n        l_list = [v[0] for v in vouchers]\n        i = bisect.bisect_right(l_list, r)\n        if i < n:\n            # Check if there is a voucher starting after r with duration2\n            if duration2 in right_duration:\n                total_cost = cost + right_duration[duration2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n        \n        # Check if there is a voucher that ends before l and has duration2\n        # Use binary search to find the last voucher with r < l\n        r_list = [v[1] for v in vouchers]\n        j = bisect.bisect_left(r_list, l) - 1\n        if j >= 0:\n            # Check if there is a voucher ending before l with duration2\n            if duration2 in left_duration:\n                total_cost = cost + left_duration[duration2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 644,
        "completion_token_count": 689,
        "thoughts_token_count": 0
    }
}