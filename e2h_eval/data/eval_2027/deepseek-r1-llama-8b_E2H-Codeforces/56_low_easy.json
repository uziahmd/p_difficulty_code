{
    "start": 1758278101.7432983,
    "end": 1758278312.4837673,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. Each base must have exactly one spaceship, and each spaceship must be assigned to exactly one base. So, it's a perfect matching between R rebels and B bases.\n\nBut there's an additional condition: the straight paths from each base to its assigned spaceship shouldn't intersect. So, no two paths can cross each other in the galaxy plane.\n\nHmm. So, I need to determine if such a matching exists.\n\nLet me think about how to approach this.\n\nFirst, the input consists of R spaceships and B bases. The coordinates are given, and no three points are colinear, which probably helps because it reduces some cases where lines could overlap.\n\nThe output is \"Yes\" or \"No\" based on whether a valid matching exists.\n\nSo, the steps I need to take:\n\n1. Read the input correctly.\n2. Generate all possible perfect matchings between the spaceships and bases.\n3. For each matching, check if any two paths intersect.\n4. If any matching satisfies that no paths intersect, output \"Yes\".\n5. If none do after checking all possibilities, output \"No\".\n\nWait, but wait. The number of matchings depends on the minimum of R and B. Oh, wait no, since R and B can be up to 10 each. But if R != B, then it's impossible to have a perfect matching. So first, I should check if R == B. Because each spaceship must assign to a base, and vice versa.\n\nWait, the problem says R and B are the numbers of spaceships and bases. So for a perfect matching, R must equal B. Otherwise, it's impossible.\n\nWait, looking back at the problem statement: It says \"R Rebel spaceships to guard B bases\", so the assignment is a perfect matching only if R = B. So in the code, the first thing to check is whether R equals B. If not, output \"No\" immediately.\n\nWait no, the problem says, \"assign R Rebel spaceships to guard B bases\". Wait, that's confusing. Wait, the assignment is a perfect matching, which requires that R equals B. So if R is not equal to B, then it's impossible. So in that case, the answer is \"No\".\n\nSo the first step is: if R != B, output \"No\".\n\nOtherwise, proceed.\n\nSo assuming R == B.\n\nNow, the next part is to find a perfect matching (bijection) between the R spaceships and B bases such that no two paths intersect.\n\nHow to model this? It feels like a problem that can be modeled as a graph, perhaps using bipartite matching, but with constraints on the edges beyond just the matching.\n\nWait, the problem is similar to finding a non-crossing perfect matching between two sets of points. So the question is whether such a matching exists.\n\nI remember that for points in convex position, the non-crossing matching can be found via certain algorithms, but I'm not sure about the general case.\n\nAlternatively, perhaps we can model this as a problem where each possible matching is a permutation, and for each permutation, check if all the connecting lines are non-intersecting.\n\nBut for R=10, the number of permutations is 10! which is around 3.6 million. That's manageable, but maybe there's a smarter way.\n\nWait, but for R=10, 10! is about 3.6e6, which is feasible for a brute-force approach, especially since each permutation needs to be checked for intersections.\n\nBut perhaps even better: instead of generating all permutations, maybe use some backtracking approach where we choose assignments step by step and check for crossings incrementally.\n\nBut for R=10, even 3.6e6 is manageable, as each check isn't too computationally heavy.\n\nSo, let's plan the steps.\n\nStep 1: Check if R == B. If not, output \"No\".\n\nStep 2: For each possible permutation P of the spaceships to bases, where P[i] is the i-th base assigned to the i-th spaceship (but wait, no, the order may vary).\n\nWait, no. Wait, the assignment is a bijection between the spaceships and the bases. So for each possible permutation of the bases, we can assign each spaceship to a base in some order.\n\nWait, no, perhaps not. Because the spaceships are given in a certain order, but the bases are also given in a certain order. So perhaps the permutation is the mapping from spaceships to bases.\n\nWait, perhaps the correct way is: the i-th spaceship is assigned to the j-th base, for some permutation j of 0..R-1.\n\nWait, no. The permutation would be a bijection from the set of spaceships to the set of bases. So, for example, if the spaceships are S_0,",
    "response": "To solve this problem, we need to determine if it is possible to assign each Rebel spaceship to a base such that no two paths connecting a spaceship to its assigned base intersect. This requires checking all possible perfect matchings between the spaceships and bases for non-intersecting paths.\n\n### Approach\n1. **Check Perfect Matching Feasibility**: First, check if the number of spaceships (R) equals the number of bases (B). If they are not equal, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate All Possible Matchings**: For R up to 10, generate all permutations of the bases to check each possible assignment of spaceships to bases.\n3. **Check for Non-Intersecting Paths**: For each permutation, check if the lines connecting the spaceships to their assigned bases do not intersect. This is done by ensuring that no two line segments cross each other in the galaxy plane.\n\n### Solution Code\n```python\nimport sys\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    # Read input\n    data = []\n    R_B = readints()\n    R = R_B[0]\n    B = R_B[1]\n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Now, check all possible permutations of bases for assignment\n    from itertools import permutations\n    for perm in permutations(range(B)):\n        # Check if the current permutation leads to a valid non-crossing assignment\n        valid = True\n        for i in range(R):\n            ship = ships[i]\n            base = bases[perm[i]]\n            # Check all previous edges for intersection\n            for j in range(i):\n                prev_ship = ships[j]\n                prev_base = bases[perm[j]]\n                # Check if the line segment between j's prev_ship and prev_base intersects with i's edge\n                if segments_intersect(prev_ship, prev_base, ship, base):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    # If none found\n    print(\"No\")\n\ndef segments_intersect(p1, p2, p3, p4):\n    # Check if line segment p1-p2 intersects with p3-p4\n    # Using the cross product method\n    def ccw(a, b, c):\n        return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n    \n    a, b = p1, p2\n    c, d = p3, p4\n    \n    if ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0:\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Perfect Matching Check**: If the number of spaceships does not equal the number of bases, output \"No\".\n3. **Permutations of Bases**: Generate all permutations of the bases to consider every possible assignment of spaceships to bases.\n4. **Intersection Check**: For each permutation, check if any line segment connecting a spaceship to its assigned base intersects with another. If an intersection is found, discard the permutation.\n5. **Output Result**: If a valid permutation is found, print \"Yes\". If no valid permutation is found after checking all, print \"No\".\n\nThis approach ensures that we efficiently check all possible assignments and verify the non-intersecting condition using geometric properties.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    # Read input\n    data = []\n    R_B = readints()\n    R = R_B[0]\n    B = R_B[1]\n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Now, check all possible permutations of bases for assignment\n    from itertools import permutations\n    for perm in permutations(range(B)):\n        # Check if the current permutation leads to a valid non-crossing assignment\n        valid = True\n        for i in range(R):\n            ship = ships[i]\n            base = bases[perm[i]]\n            # Check all previous edges for intersection\n            for j in range(i):\n                prev_ship = ships[j]\n                prev_base = bases[perm[j]]\n                # Check if the line segment between j's prev_ship and prev_base intersects with i's edge\n                if segments_intersect(prev_ship, prev_base, ship, base):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    # If none found\n    print(\"No\")\n\ndef segments_intersect(p1, p2, p3, p4):\n    # Check if line segment p1-p2 intersects with p3-p4\n    # Using the cross product method\n    def ccw(a, b, c):\n        return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n    \n    a, b = p1, p2\n    c, d = p3, p4\n    \n    if ccw(a, b, c) * ccw(a, b, d) <= 0 and ccw(c, d, a) * ccw(c, d, b) <= 0:\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 462,
        "completion_token_count": 847,
        "thoughts_token_count": 1025
    }
}