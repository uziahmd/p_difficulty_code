{
    "start": 1758284078.5704267,
    "end": 1758286422.9893713,
    "start-formatted": "2025-09-19 21:14 KST",
    "end-formatted": "2025-09-19 21:53 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about Vitaly and cycles in graphs. The task is to find two things: t, the minimum number of edges needed to add to form a simple cycle of odd length (more than one vertex), and w, the number of ways to do that with exactly t edges.\n\nHmm. So, what's a simple cycle here? It's a cycle where each vertex appears at most once. So, it's a cycle without any repeated nodes.\n\nThe input gives an undirected graph with n vertices and m edges. No loops or parallel edges. The graph might not be connected.\n\nSo, how do I approach this?\n\nFirst, I think about what conditions allow a cycle to exist. For a cycle, each node in the cycle must have degree at least 2. Wait, no, because if you have a triangle (3-node cycle), each node has degree 2. So, in general, any cycle requires that all nodes in the cycle have at least degree 1, but for the cycle itself, each must have at least degree 2.\n\nWait, but when adding edges, maybe we can create such a structure.\n\nLet me think about the possible cases.\n\nCase 1: The graph already has a cycle of odd length. Then t=0 and w=1, since no edges need to be added.\n\nBut wait, the problem says \"more than one vertex\". So a cycle must have at least 3 nodes. So, if there's already such a cycle, t=0 and w=1.\n\nCase 2: The graph doesn't have any cycle, but adding some edges can create one.\n\nWait, but the problem is about forming a cycle of odd length, which is more than one vertex. So, what's the minimal way to create such a cycle?\n\nI think the minimal number of edges to add would depend on the existing structure.\n\nAnother approach: perhaps the problem can be broken down into checking certain components.\n\nFirst, check if the graph has any cycles. If it does, then find the smallest odd-length cycle. But wait, the problem isn't just about finding the minimal t; it's also about whether the existing graph has any cycles. Because if it does, then t could be zero, depending on whether the existing cycles meet the criteria.\n\nWait, no. Because the existing cycles may consist of even lengths, so we'd have to add edges to make an odd-length cycle.\n\nWait, no. Suppose the graph has a cycle of even length. Then, perhaps adding zero edges won't help. So, the presence of any cycles doesn't directly imply that t is zero.\n\nWait, no. The problem requires us to form a cycle of odd length, regardless of the current state of the graph. So, if the graph has any existing odd-length cycles, then t is zero and w is the number of such cycles.\n\nBut if the graph has no cycles, then we need to find the minimal number of edges to add to form an odd-length cycle.\n\nSo, first step: check if the graph has any cycles of odd length. If yes, then t=0 and w is the count of such cycles.\n\nIf the graph has no cycles, then we need to find the minimal number of edges to add.\n\nBut wait, how do we determine if the graph has any cycles at all, regardless of parity? We can perform a cycle detection using BFS or DFS.\n\nAlternatively, perhaps it's better to compute the number of existing odd-length cycles, and if there are any, set t=0 and w accordingly.\n\nIf there are no cycles, then we have to find the minimal t.\n\nSo, let's outline the steps:\n\n1. Compute all existing cycles in the graph.\n\n   For each cycle found, note its length. If any cycle has an odd length ≥3, then t=0, and w is the number of such cycles.\n\n   If no such cycles exist, proceed to step 2.\n\n2. Find the minimal number of edges t required to form a new odd-length cycle by adding edges.\n\n   Also, calculate the number of ways to achieve this.\n\nSo, first, how to detect existing cycles and their lengths.\n\nWait, but the graph could be disconnected. So, each connected component can contribute cycles or not.\n\nBut for the initial part, we only care about whether any connected component has an odd-length cycle.\n\nSo, the plan is:\n\n- For each connected component, perform a BFS/DFS to find cycles.\n\n- For each cycle found, record its length.\n\n- If any cycle has length ≥3 and is odd, then t=0, w is the count of such cycles.\n\nIf no such cycles exist, then proceed to find the minimal t and w.\n\nNow, the second part is more challenging.\n\nWe need to find the minimal number of edges to add to the graph so that the resulting graph has a simple cycle of odd length, and the number of ways to do this.\n\nWhat's the minimal number of edges needed?\n\nLet's think about the structure that allows adding the least edges to form an odd cycle.\n\nIn a tree, adding one edge creates exactly one cycle. But in our case, the graph may not be a tree. But for the minimal case, perhaps considering trees or components that are close to trees could be useful.\n\nWait, but the problem allows adding edges anywhere in the graph.\n\nHmm.\n\nLet's think: to create an odd-length cycle, perhaps the minimal way is to connect two paths in such a way that the combined path forms an odd cycle.\n\nAlternatively, perhaps the minimal t is 1, but only under certain conditions.\n\nWait, for example, consider a graph that is a tree. Adding one edge between two leaves would create a single cycle. If that cycle is of even length, perhaps adding another edge somewhere else could create an odd cycle.\n\nWait, perhaps I should think about the structure of the graph after adding t edges.\n\nSo, what is the minimal possible t? It can't be less than 1, because the graph may have no cycles. Wait, no. Wait, if the graph is connected and has a cycle, then t is zero.\n\nWait, no, earlier steps have already handled that. So, in the scenario where no cycles exist, we have to add edges.\n\nWhat's the minimal number of edges to add to create an odd-length cycle?\n\nWell, let's think about the simplest case.\n\nSuppose we have a graph with a single edge connecting two nodes A and B. Adding one edge between A and C will form a triangle if there's another edge. Wait, no.\n\nWait, perhaps the minimal case is when we have a chain of three nodes, like A-B-C. Adding an edge between A and C creates a triangle (length 3). So, t=1, and w=1.\n\nBut wait, maybe the graph is more complex. For example, suppose the graph is a star with four nodes, each connected to a central node. To create an odd cycle, perhaps we can connect two leaves via a new edge, creating a cycle of length 3.\n\nAlternatively, perhaps the minimal t is 1, but in some cases, it's higher.\n\nWait, no. Think again: if the graph is a tree, adding one edge creates exactly one cycle. The length of that cycle is equal to the distance between the two nodes plus one. For a tree, the distance between two nodes is the number of edges on the path between them.\n\nSo, for example, if the tree is a straight line: A-B-C-D-E.\n\nAdding an edge between A and E would create a cycle of length 5, which is odd.\n\nSo, t=1.\n\nSo, in a tree, adding one edge can create a cycle of odd length.\n\nBut wait, what if the tree is such that all possible cycles formed by adding one edge are even-length? Is that possible?\n\nNo, because the length of the cycle is determined by the path between the two connected nodes in the tree. Since the tree is acyclic, the path between any two nodes is unique.\n\nSo, the length of the cycle formed is the length of that path plus one.\n\nFor example, in a straight line of 4 nodes: A-B-C-D.\n\nAdding edge A-D creates a cycle of length 4 (even). So, that's bad.\n\nHmm. So, in this case, adding one edge wouldn't give an odd-length cycle.\n\nSo, in this case, the minimal t is not 1. We need to add more edges.\n\nSo, perhaps in this scenario, adding two edges would create a cycle.\n\nWait, let's see: in the 4-node line, adding edges A-B and B-D would create cycles of length 3 (A-B-D) and 4 (A-B-C-D). So, the minimal t is 2.\n\nWait, but that's adding two edges, but maybe there's a way to form a cycle of odd length with t=2.\n\nWait, perhaps in this example, adding edges A-C and C-D would create a cycle A-C-D-A, which has length 3, which is odd. So, in that case, t=2.\n\nSo, the minimal t can vary based on the initial structure.\n\nThis suggests that the problem is not straightforward. So, perhaps the approach is to find the minimal t for each connected component, and then take the overall minimal.\n\nWait, but perhaps the minimal t is 1 in some cases, and higher in others.\n\nSo, perhaps the process is as follows:\n\nFor each connected component in the graph:\n\n   If the component has any cycle (already has an odd-length cycle): contribute nothing, since t=0.\n\n   Else:\n\n      The component is a tree (or a forest, but each component is a tree).\n\n      Then, for each possible pair of nodes in the component, compute the minimal number of edges needed to form an odd-length cycle.\n\n      The minimal across all components is t.\n\nSo, for each component, find the minimal number of edges required to create an odd cycle.\n\nThen, among all components, find the minimal t.\n\nThen, sum up all the ways across all components, but only for those that contribute to this minimal t.\n\nWait, but the problem statement says that the entire graph must have at least one cycle of odd length. So, we can choose any component, add edges to it, and thus form the required cycle.\n\nSo, perhaps the approach is:\n\nFor each connected component:\n\n   If it contains an odd cycle: then t=0, and w is the number of such components.\n\n   Else:\n\n      Find the minimal number of edges t_i needed to add to this component to form an odd cycle.\n\n      And the number of ways to do this for this component, w_i.\n\nThen, overall, the minimal t is the minimal t_i across all components, and the total w is the sum of w_i for components whose t_i equals the minimal t.\n\nSo, the steps are:\n\n1. For each connected component:\n\n   a. Check if it has any odd-length cycles.\n\n   b. If yes: add t=0, and w increases by the number of such cycles.\n\n2. Else:\n\n   a. For this component, find the minimal number of edges t_i needed to form an odd cycle.\n\n   b. For each such t_i, compute the number of ways to do this.\n\n3. Now, among all components, find the minimal t.\n\n   If any component has t=0, then overall t=0.\n\n   Else, the minimal t is the minimal t_i across all components.\n\n   w is the sum of w_i for components whose t_i is equal to this minimal t.\n\nSo, now, the problem is to compute for each tree (since if the component is not cyclic, it's a tree) the minimal t_i and w_i.\n\nSo, the question reduces to, for each tree, what is the minimal number of edges to add to create an odd-length cycle, and how many ways can this be done.\n\nHow to model this?\n\nIn a tree, any additional edge creates exactly one cycle. The length of this cycle is equal to the number of edges on the path between the two nodes plus one.\n\nSo, for a tree, adding an edge between u and v creates a cycle of length d(u, v) + 1, where d is the distance between u and v in the tree.\n\nWe need to find the minimal t such that there exists a pair of nodes u, v where d(u, v) + 1 is odd, and then determine the minimal number of edges to add (t=1), unless all possible pairs u, v have d(u, v)+1 even.\n\nIn that case, we need to add more edges.\n\nWait, for example, in a straight line of 4 nodes: A-B-C-D.\n\nAdding an edge between A and D gives a cycle of length 4 (even), which is not acceptable.\n\nBut if we add two edges: say, A-B and B-D, then the cycles are A-B-D (length 3) and A-B-C-D (length 4). So, adding two edges can create an odd cycle.\n\nWait, but in this case, t=2. So, perhaps the minimal t for some trees is 2.\n\nBut wait, maybe adding two edges can create multiple odd cycles, but perhaps adding one edge is sufficient in other trees.\n\nSo, the key is to find for each tree the minimal number of edges to add to create at least one odd cycle.\n\nSo, for each tree, we need to compute the minimal t_i and the number of ways to achieve it.\n\nLet me think about how to find t_i and w_i for a given tree.\n\nCase 1: There exists a pair of nodes u, v in the tree such that the distance between them is even. Then, adding an edge between u and v creates a cycle of length (d(u, v) + 1), which is odd. So, t_i = 1, and w_i is the number of such pairs.\n\nCase 2: All pairs of nodes have even distances. Then, any edge added will create a cycle of even length. So, we need to add at least two edges.\n\nBut wait, is that possible? Let's see.\n\nIn a tree, the parity of the distances between nodes depends on the structure.\n\nWait, for example, in a star-shaped tree with center node O connected to A, B, C.\n\nThe distance between A and B is 2 (through O). So, adding an edge between A and B creates a cycle of length 3 (odd). So, in this case, t_i=1.\n\nBut what about a tree that's a straight line with 5 nodes: A-B-C-D-E.\n\nThe distance between A and E is 4, which is even. Adding an edge between A and E would create a cycle of length 5 (odd). So, t_i=1.\n\nAnother example: a straight line of 3 nodes: A-B-C.\n\nDistance between A and C is 2, which is even. Adding the edge creates a cycle of length 3 (odd). So, t_i=1.\n\nWait, what about a tree that's a straight line of 4 nodes: A-B-C-D.\n\nDistances:\n\nA-B: 1 (odd)\nA-C: 2 (even)\nA-D: 3 (odd)\nB-C: 1 (odd)\nB-D: 2 (even)\nC-D: 1 (odd)\n\nSo, adding an edge between A and D creates a cycle of length 4 (even), which is not desired.\n\nAdding an edge between B and D creates a cycle of length 3 (B-C-D-B), which is odd. So, t_i=1.\n\nWait, why? Because the distance between B and D is 2 (B-C-D), so adding the edge creates a cycle of 3.\n\nAh, right. So, in this case, t_i=1.\n\nSo, perhaps the earlier thought about needing two edges is incorrect.\n\nWait, perhaps the only case where t_i=2 is when the tree is a straight line of even length, but perhaps that's not correct.\n\nWait, let's think of a tree that's a straight line of 5 nodes: A-B-C-D-E.\n\nThe distances between various nodes:\n\nA to E: 4, even → adding A-E would create a cycle of 5 (odd).\nB to D: 2, even → adding B-D creates a cycle of 3 (odd).\nSo, t_i=1.\n\nSo, when is t_i=2 necessary?\n\nPerhaps in a tree where all possible pairs have even distances.\n\nIs that possible?\n\nWait, let's think about a tree that is a star with four leaves. Each leaf is at distance 2 from any other leaf.\n\nWait, no. For a star with center O and leaves A, B, C, D.\n\nThe distance between A and B is 2 (A-O-B). So, adding an edge between A and B creates a cycle of length 3, which is odd. So, t_i=1.\n\nSo, again, t_i=1.\n\nHmm, maybe it's impossible to have a tree where all pairs of nodes have even distances.\n\nWait, in a tree, the parity of the distance between any two nodes is the same as the parity of their levels in the tree, assuming a root is chosen.\n\nWait, perhaps not. Let me think: suppose the tree is a chain of even length.\n\nWait, for example, a chain of 3 nodes: A-B-C. The distances are 1, 2, 1.\n\nSo, A and C are at even distance (2), but A and B are at odd.\n\nSo, adding an edge between B and C creates a cycle of length 2, but that's not a cycle of more than one vertex. Wait, no, a cycle must have at least three nodes. So, in this case, adding B-C would create a cycle of length 2, but that's invalid.\n\nWait, no. Wait, the original tree is A-B-C. Adding B-C would form a cycle of length 2, but the problem requires a cycle of length more than one vertex, which is allowed? Or is a cycle of length two considered invalid because it's a single edge?\n\nWait, the problem says, \"a simple cycle of an odd length consisting of more than one vertex.\"\n\nWait, a cycle of length 2 is a loop, which is not allowed. So, the cycle must have at least three nodes.\n\nSo, in the example above, adding B-C would create a cycle of length 2, which is invalid. So, to create a valid cycle, the added edge must form a cycle of length 3 or more.\n\nSo, in the previous example, adding an edge between A and C would create a cycle of length 3.\n\nSo, for the chain of 3 nodes, t_i=1.\n\nSo, perhaps, for any tree, adding a single edge can create a cycle of odd length, provided that the two nodes are at an even distance apart.\n\nSo, perhaps, the minimal t is 1 for all trees except when the tree is a single node or has no edges.\n\nWait, but what about a tree with two nodes connected by one edge.\n\nAdding an edge between them is forbidden because it's a loop.\n\nWait, but the original graph doesn't have loops. So, adding an edge between two nodes that are already connected would create a cycle of length 2, which is invalid.\n\nSo, in that case, the minimal t is 2.\n\nWait, no. Because the tree with two nodes can't form a cycle of length 3 by adding any edge. Because adding an edge between them creates a cycle of length 2, which is invalid.\n\nSo, in this case, the minimal t is 2.\n\nSo, for a tree with two nodes, t_i=2.\n\nSimilarly, for a tree with a single node (n=1), it's impossible to form a cycle, so t_i is infinity (but in reality, it's impossible, so we can ignore it since the problem requires a cycle of more than one vertex).\n\nSo, the plan is:\n\nFor each connected component:\n\n   If it's a tree and has no cycles:\n\n      Compute the minimal number of edges t_i needed to create an odd-length cycle.\n\n      If it's a single node: t_i is infinity.\n\n      Else if it's a tree with two nodes: t_i is 2.\n\n      Else:\n\n         Check if there exists a pair of nodes u, v in the tree such that the distance between u and v is even.\n\n         If yes: then t_i=1, and w_i is the number of such pairs.\n\n         If no: then we need to add two edges.\n\n            How?\n\n            For example, in a chain of 4 nodes: A-B-C-D.\n\n            Adding an edge between A and B creates a cycle of length 3 (A-B-C-D is a cycle of 4, but wait, adding A-B would create a cycle of 3: A-B-C-D-A is length 4, which is even. Hmm, no.\n\n            Wait, in this example, the distance between A and D is 3 (odd). Adding an edge between A and D creates a cycle of length 4 (even).\n\n            So, in this case, is there any pair u, v where the distance is even?\n\n            Yes, for example, the distance between B and D is 2 (even). So, adding B-D would create a cycle of length 3, which is odd.\n\n            So, in this case, t_i=1.\n\n            So, perhaps it's impossible to have a tree where all pairs have odd distances.\n\n            Wait, perhaps I'm missing something.\n\n            Let me think about a tree where all node pairs have odd distances.\n\n            Maybe a star-shaped tree with four leaves: O is the center, connected to A, B, C, D.\n\n            The distance between any two leaves is 2 (even). So, adding an edge between any two leaves creates a cycle of length 3 (odd).\n\n            So, in this case, t_i=1.\n\n            Another example: a chain of 5 nodes: A-B-C-D-E.\n\n            The distance between A and E is 4 (even), so adding that edge creates a cycle of length 5 (odd).\n\n            So, t_i=1.\n\n            What about a chain of 6 nodes: A-B-C-D-E-F.\n\n            The distance between A and F is 5 (odd), so adding that edge creates a cycle of length 6 (even), which is not good.\n\n            But what about adding an edge between B and E. The distance is 4 (even), so adding that creates a cycle of length 5 (odd). So, t_i=1.\n\n            Hmm, seems like in all cases except when the tree is a single node or a two-node tree, t_i=1.\n\n            So, the only cases where t_i>1 are:\n\n            - When the tree has two nodes (t_i=2).\n\n            - Or, when the tree is a single node (impossible to form a cycle, so t_i is infinity).\n\n            So, perhaps for all other trees, t_i=1.\n\n            So, the steps for a tree component:\n\n               If the component is a single node: skip (can't form a cycle).\n\n               Else if the component has two nodes:\n\n                  t_i=2, w_i=0 (since adding one edge is a loop, which is invalid).\n\n               Else:\n\n                  Check if there exists at least one pair of nodes with even distance.\n\n                  If yes: t_i=1, w_i is the number of such pairs.\n\n                  Else: t_i=2, w_i=0 (since adding two edges is needed, but how?)\n\n                  Wait, but in the two-node case, adding two edges is impossible (as per the problem statement, we can't add loops or parallel edges). So, for the two-node case, the only way is to add one edge, but it creates a cycle of length 2, which is invalid. So, in that case, it's impossible to form a valid cycle, so t_i is infinity.\n\n                  So, for the two-node case, t_i is infinity.\n\n                  Wait, but according to the problem statement, the graph is initially connected, but if a component is a single node, it can't form any cycle, and adding edges can't help.\n\n                  So, for each tree component:\n\n                     if size < 3: can't form a cycle, so t_i is infinity.\n\n                     elif size == 2: t_i is 2.\n\n                     else: check if any pair has even distance.\n\n                          if yes: t_i=1, w_i=count of such pairs.\n\n                          else: t_i=2, but how?\n\n                          Wait, but in a tree with size >=3, can all pairs have odd distances?\n\n                          Let me think: suppose the tree is a chain of 3 nodes: A-B-C.\n\n                          Distances: A-B=1 (odd), A-C=2 (even). So, yes, there's a pair with even distance.\n\n                          So, for any tree with size >=3, there exists at least one pair of nodes with even distance.\n\n                          Because in a tree with more than two nodes, the diameter is at least 2.\n\n                          So, in that case, for any tree with size >=3, t_i=1.\n\n                          So, the only cases where t_i>1 are:\n\n                             - Trees with size <3: t_i is infinity.\n\n                             - Trees with size 2: t_i=2.\n\n                          So, for all other trees, t_i=1.\n\nSo, putting it all together:\n\nFor each connected component:\n\n   if the component has a cycle of odd length:\n\n      contribute t=0, and w is the number of such cycles.\n\n   else:\n\n      if the component is a tree:\n\n         if size <3: t_i is infinity.\n\n         elif size == 2: t_i=2, but wait, adding one edge creates a cycle of length 2, which is invalid. So, in this case, it's impossible to form a valid cycle. So, t_i is infinity.\n\n         else: t_i=1, and w_i is the number of pairs of nodes in the tree with even distance.\n\n      else: the component is not a tree, but has cycles. So, it's already been considered in the first condition.\n\nSo, for each component that is a tree and has size >=3:\n\n   t_i=1, w_i=count of pairs of nodes with even distance.\n\nFor components that are trees with size <3: t_i is infinity.\n\nSo, now, the algorithm is:\n\nCompute for each component:\n\n   if component has an odd cycle: add to w.\n\nElse:\n\n   if component is a tree:\n\n      if size <3: continue (can't contribute to t).\n\n      elif size ==2: t_i=2, but since adding one edge creates a cycle of length 2, which is invalid, we can't form a cycle. So, this component can't contribute to the solution.\n\n      else: t_i=1, w_i=number of node pairs with even distance.\n\nThen, among all components, find the minimal t. If any component has t=0, then overall t=0.\n\nElse, the minimal t is the minimal t_i across all contributing components.\n\nThe total w is the sum of w_i for all components where t_i equals the minimal t.\n\nBut wait, what about components that are trees with size >=3: their t_i is 1. So, if any such component exists, the overall minimal t is 1, unless there's a component with t=0.\n\nSo, putting it all together.\n\nNow, the problem is to implement this.\n\nSo, the steps are:\n\n1. Read the graph.\n\n2. For each connected component:\n\n   a. Check if it has any cycles of odd length.\n\n   b. If yes: add 0 to t, and accumulate the number of such cycles into w.\n\n3. Else:\n\n   a. Check if the component is a tree.\n\n      i. If not a tree: continue (because it's a component that has cycles, but possibly even-length ones, which aren't considered in step 2).\n\n   b. Else:\n\n      i. If component size <3: continue.\n\n      ii. If component size ==2: it's a tree with two nodes. So, adding one edge creates a cycle of length 2, which is invalid. So, this component can't contribute to the solution. So, continue.\n\n      iii. Else: compute the number of pairs of nodes in the component with even distance. Add 1 to t, and add this count to w.\n\n4. Now, after processing all components:\n\n   a. If any component has t=0: output t=0 and w=sum of such components' w.\n\n   b. Else:\n\n      i. Among all components, find the minimal t_i (which is 1 for each component that contributes).\n\n      ii. Sum the number of ways for these components (each contributes their own w_i).\n\n      iii. Output t=1 and w=sum.\n\nWait, but step 3.b.iii is only for components that are trees with size >=3. Each such component contributes t_i=1, and w_i is the number of node pairs with even distance.\n\nBut wait, in step 3.b.iii, the component is a tree, so any added edge creates exactly one cycle. So, for each such pair (u, v) with even distance, adding the edge u-v will create a cycle of odd length. So, the number of ways to add edges is equal to the number of such pairs.\n\nSo, for each such component, the number of ways is the number of pairs with even distance.\n\nThus, the total w for the minimal t is the sum of w_i for all such components.\n\nSo, the code needs to:\n\n- For each connected component:\n\n   - Determine if it has any odd-length cycles. If yes, add to the global t=0 and w.\n\n- Else, for each component that is a tree:\n\n   - if size <3: skip.\n\n   - elif size ==2: skip (can't form a valid cycle).\n\n   - else: compute the number of pairs (u, v) in the tree where the distance between u and v is even.\n\nSo, the main challenges are:\n\n   a. Efficiently checking for the presence of any odd-length cycles in a component.\n\n   b. Efficiently computing the number of node pairs with even distance in a tree.\n\nFor part a, we can perform a BFS or DFS for each component and look for cycles. For each cycle found during BFS, check its length. If any cycle is odd, mark the component as having an odd cycle.\n\nBut BFS-based cycle detection may not directly give the cycle length. Alternatively, using a depth-first search and keeping track of the path can help in detecting cycles and their lengths.\n\nBut for large n (up to 1e5?), this could be time-consuming.\n\nWait, the constraints of the problem are not given, but for programming competition problems, it's likely that n can be up to 1e5 or 1e6. So, the solution must be efficient.\n\nBut since the problem requires finding whether any component has an odd cycle, perhaps we can use the property that a graph has an odd cycle if and only if it has a vertex of odd degree in the condensation of the graph.\n\nWait, no. That's for bipartite graphs. Oh, wait, the bipartition theorem states that a bipartite graph cannot contain any odd-length cycles. So, if the graph is bipartite, it has no odd cycles. Conversely, if the graph is not bipartite, it has at least one odd cycle.\n\nYes! So, the presence of any odd cycle can be determined by checking if the graph is bipartite. If it's not bipartite, then it has an odd cycle.\n\nSo, for each connected component, we can check if it's bipartite. If it's not bipartite, then it has an odd cycle.\n\nThat's a much more efficient way.\n\nSo, the steps become:\n\nFor each connected component:\n\n   Check if it's bipartite.\n\n   If not, then it has an odd cycle. So, add to the global t=0 and w.\n\nElse:\n\n   Proceed to check if it's a tree.\n\nSo, this simplifies the process.\n\nNow, for part b: for each tree component (size >=3), compute the number of pairs of nodes with even distance.\n\nHow to compute this efficiently.\n\nAn approach is to perform BFS or DFS and compute the distance from each node to all others, then for each pair, check if the distance is even.\n\nBut for a tree with n nodes, this is O(n^2), which is not feasible for large n.\n\nSo, we need a smarter way.\n\nAlternative approach: find the number of pairs of nodes (u, v) such that the path from u to v has even length.\n\nSince the tree is unweighted, the distance between u and v is the number of edges in the path.\n\nWe need to count the number of pairs where the distance is even.\n\nSo, the problem reduces to counting the number of unordered pairs of nodes in the tree with even distance.\n\nThis is equivalent to the sum over all u < v of (distance(u, v) mod 2 == 0).\n\nWe can model this as:\n\nEach node can be assigned a level (depth) from the root. Then, the distance between u and v is depth[u] + depth[v] - 2*depth[lca(u, v)], where lca is the lowest common ancestor.\n\nBut perhaps that's complicating things.\n\nAlternatively, we can note that in a tree, the parity of the distance between u and v is equal to the XOR of the parities of their depths from a root.\n\nBecause the distance between u and v is (depth[u] - depth[lca]) + (depth[v] - depth[lca]).\n\nWhich is equal to depth[u] + depth[v] - 2*depth[lca].\n\nThe term 2*d can be ignored modulo 2.\n\nSo, distance(u, v) mod 2 = (depth[u] + depth[v]) mod 2.\n\nThus, the parity of the distance between u and v is equal to the sum of the parities of their depths modulo 2.\n\nSo, if we assign to each node a binary value (0 or 1) based on its depth's parity, then for any pair (u, v), their distance is even iff the binary values of u and v are the same.\n\nThus, the number of pairs (u, v) with even distance is equal to the number of pairs of nodes with the same binary value.\n\nSo, let's compute for each tree component:\n\n- Assign to each node a value: 0 or 1, based on the parity of their depth from a chosen root.\n\n- Count the number of nodes with value 0 (c0) and those with value 1 (c1).\n\n- The number of pairs with even distance is c0*(c0-1)/2 + c1*(c1-1)/2.\n\nBecause for each group (same binary value), the pairs within the group have even distance.\n\nThus, for each tree component, the number of such pairs is (c0 choose 2) + (c1 choose 2).\n\nThis can be computed in O(n) time.\n\nSo, the plan is:\n\nFor each tree component (size >=3):\n\n   Compute the binary values of each node based on their depth's parity.\n\n   Count c0 and c1.\n\n   The number of pairs is (c0 * (c0 - 1)) // 2 + (c1 * (c1 - 1)) // 2.\n\n   This is the w_i for this component.\n\nSo, the code can proceed as:\n\nRead the graph.\n\nFor each connected component:\n\n   Check if it's bipartite. If not, add to the global w_0 (w_total) and set t=0.\n\nOnce all components are processed:\n\n   If t=0 is found (i.e., any component is non-bipartite), output t=0 and w_total.\n\nElse:\n\n   For each component that is a tree and size >=3:\n\n      Compute the number of pairs as (c0 choose 2) + (c1 choose 2).\n\n      Sum these across all such components.\n\n   The minimal t is 1.\n\n   So, output t=1 and w=sum.\n\nWait, but what about components that are trees with size >=3, but are bipartite (so they don't have any odd cycles). These are the ones that contribute to the t=1 case.\n\nSo, the code outline is:\n\nRead n and m.\n\nBuild the adjacency list.\n\nInitialize:\n\n   has_odd_cycle = False\n\n   total_ways = 0\n\nFor each component in the graph:\n\n   if component is bipartite:\n\n      continue\n\n   else:\n\n      has_odd_cycle = True\n\n      total_ways += 1\n\n      continue\n\nSo, after processing all components, if has_odd_cycle is True:\n\n   print 0 and total_ways.\n\nElse:\n\n   For each component:\n\n      if it's a tree and size >=3:\n\n         compute c0 and c1.\n\n         ways += (c0*(c0-1)//2) + (c1*(c1-1)//2)\n\n   if no such components: output t=inf, but according to the problem statement, the graph can't have any cycles, but for trees with size <3, it's impossible.\n\n   else:\n\n      output t=1 and ways.\n\nWait, but in the else case, if there are no tree components with size >=3, then it's impossible to form a cycle, so t would be infinity.\n\nBut according to the problem statement, the graph may not have any cycles, but in that case, the minimal t is to form a cycle of odd length.\n\nWait, but the problem requires that the cycle consists of more than one vertex, which implies a cycle of length at least 3.\n\nSo, if the graph is a collection of trees, some of which are single nodes, some are two-node trees, and others are larger trees.\n\nFor the larger trees (size >=3), they are bipartite (since they are trees and hence bipartite), but for those trees, we can add edges to form an odd cycle.\n\nBut if there are no such trees, i.e., all components are either single nodes or two-node trees, then it's impossible to form a cycle of odd length. So, in that case, the answer is t=infinity.\n\nBut according to the problem statement, it's guaranteed that the graph can be modified to form such a cycle. Or perhaps not.\n\nWait, the problem statement says that it's possible to add edges to form a simple cycle of odd length. So, perhaps in some cases, it's possible, and in others not.\n\nWait, for example, a graph with four single nodes: n=4,",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to form a simple cycle of odd length and the number of ways to achieve this. The solution involves checking each connected component of the graph for cycles and using properties of bipartite graphs to efficiently determine the presence of odd-length cycles.\n\n### Approach\n1. **Check for Odd-Length Cycles**: Use the property that a graph has an odd-length cycle if and only if it is not bipartite. For each connected component, check if it is bipartite. If it is not, it contains an odd-length cycle.\n2. **Count Ways for Odd-Length Cycles**: If any component contains an odd-length cycle, note the number of such cycles.\n3. **Handle Bipartite Trees**: For each tree component (which are bipartite), determine if it can be modified by adding edges to form an odd-length cycle. Specifically, for each tree with size >= 3, compute the number of pairs of nodes that can form an odd-length cycle when an edge is added between them.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    total_ways = 0\n\n    # Check if any component is not bipartite\n    is_bipartite = [True] * (n + 1)\n    color = [-1] * (n + 1)\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            queue = deque()\n            queue.append(u)\n            visited[u] = True\n            color[u] = 0\n            is_bipartite_u = True\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = 1 - color[current]\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite_u = False\n                            break\n                if not is_bipartite_u:\n                    break\n            if not is_bipartite_u:\n                total_ways += 1\n\n    if total_ways > 0:\n        print(\"0\", total_ways)\n        return\n\n    # Now, process each component as trees\n    visited = [False] * (n + 1)\n    components = []\n    for u in range(1, n + 1):\n        if not visited[u]:\n            stack = [(u, -1)]\n            visited[u] = True\n            component = []\n            while stack:\n                node, parent = stack.pop()\n                component.append(node)\n                for neighbor in adj[node]:\n                    if not visited[neighbor] and neighbor != parent:\n                        visited[neighbor] = True\n                        stack.append((neighbor, node))\n            components.append(component)\n\n    total_ways = 0\n    for comp in components:\n        if len(comp) < 3:\n            continue\n        # It's a tree, check if it's bipartite\n        # Since it's a tree, it's bipartite, so no odd cycles\n        # But we need to count the number of node pairs with even distance\n        root = comp[0]\n        depth = {root: 0}\n        q = deque()\n        q.append(root)\n        visited_depth = {root}\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if v not in visited_depth:\n                    depth[v] = depth[u] + 1\n                    visited_depth.add(v)\n                    q.append(v)\n        # Assign binary values based on depth parity\n        c0 = 0\n        c1 = 0\n        for node in comp:\n            if depth[node] % 2 == 0:\n                c0 += 1\n            else:\n                c1 += 1\n        ways = (c0 * (c0 - 1)) // 2 + (c1 * (c1 - 1)) // 2\n        total_ways += ways\n\n    if total_ways == 0:\n        print(\"0 0\")\n    else:\n        print(\"1\", total_ways)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices and edges, followed by the adjacency list representation of the graph.\n2. **Bipartite Check**: Each connected component is checked for being bipartite. If any component is not bipartite, it indicates the presence of an odd-length cycle.\n3. **Component Processing**: For each tree component (determined by BFS/DFS), the number of pairs of nodes that can form an odd-length cycle is computed using depth parity.\n4. **Result Calculation**: If any odd-length cycle exists, the result is immediately determined. Otherwise, the minimum number of edges required and the number of ways to form an odd-length cycle are computed based on the tree components.\n\nThis approach efficiently determines the solution using properties of bipartite graphs and tree structures, ensuring optimal performance even for large graphs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    total_ways = 0\n\n    # Check if any component is not bipartite\n    is_bipartite = [True] * (n + 1)\n    color = [-1] * (n + 1)\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            queue = deque()\n            queue.append(u)\n            visited[u] = True\n            color[u] = 0\n            is_bipartite_u = True\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = 1 - color[current]\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite_u = False\n                            break\n                if not is_bipartite_u:\n                    break\n            if not is_bipartite_u:\n                total_ways += 1\n\n    if total_ways > 0:\n        print(\"0\", total_ways)\n        return\n\n    # Now, process each component as trees\n    visited = [False] * (n + 1)\n    components = []\n    for u in range(1, n + 1):\n        if not visited[u]:\n            stack = [(u, -1)]\n            visited[u] = True\n            component = []\n            while stack:\n                node, parent = stack.pop()\n                component.append(node)\n                for neighbor in adj[node]:\n                    if not visited[neighbor] and neighbor != parent:\n                        visited[neighbor] = True\n                        stack.append((neighbor, node))\n            components.append(component)\n\n    total_ways = 0\n    for comp in components:\n        if len(comp) < 3:\n            continue\n        # It's a tree, check if it's bipartite\n        # Since it's a tree, it's bipartite, so no odd cycles\n        # But we need to count the number of node pairs with even distance\n        root = comp[0]\n        depth = {root: 0}\n        q = deque()\n        q.append(root)\n        visited_depth = {root}\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if v not in visited_depth:\n                    depth[v] = depth[u] + 1\n                    visited_depth.add(v)\n                    q.append(v)\n        # Assign binary values based on depth parity\n        c0 = 0\n        c1 = 0\n        for node in comp:\n            if depth[node] % 2 == 0:\n                c0 += 1\n            else:\n                c1 += 1\n        ways = (c0 * (c0 - 1)) // 2 + (c1 * (c1 - 1)) // 2\n        total_ways += ways\n\n    if total_ways == 0:\n        print(\"0 0\")\n    else:\n        print(\"1\", total_ways)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 1189,
        "thoughts_token_count": 8193
    }
}