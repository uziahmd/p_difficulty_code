{
    "start": 1758278108.6621,
    "end": 1758278328.239336,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. Each base must have exactly one spaceship, and each spaceship must be assigned to exactly one base. So, it's a perfect matching between R rebels and B bases.\n\nBut there's an additional condition: the paths from each base to its assigned spaceship shouldn't intersect. The paths are straight lines in the galaxy plane (2D). So, no two paths can cross each other.\n\nHmm, how do I model this? It feels like a graph problem where edges represent possible assignments, but with the constraint on non-intersecting paths.\n\nLet me think about the steps:\n\n1. **Input Reading**: Read R and B. Then read R spaceship coordinates, then B base coordinates.\n2. **Check for Perfect Matching**: First, check if R equals B because otherwise, a perfect matching isn't possible. If not, immediately output 'No'.\n3. **Generate All Possible Assignments**: For all possible ways to assign R ships to B bases, ensuring each ship is assigned to exactly one base and vice versa. This is like finding all permutations of size min(R,B), but since R and B can be up to 10, that's manageable (10! is around 3.6 million, which is acceptable for Python).\n4. **Check Path Intersection for Each Assignment**: For each permutation (each possible assignment), check if any two paths cross. If none cross, return 'Yes'.\n\nWait, but how to check if two line segments intersect? Oh right, that's a classic computational geometry problem. So I need a function that takes two line segments and returns True if they intersect, including at the endpoints.\n\nSo first, I need to implement that function. How?\n\nI remember that two line segments AB and CD intersect if the points A and B are on opposite sides of CD, and C and D are on opposite sides of AB. Or if any point lies on the other segment.\n\nSo the steps for the function:\n\n- Check if any of the four points are colinear and lie on the other segment. Like, if point A is on CD, or B is on CD, etc.\n- Otherwise, compute the orientation of each point with respect to the other segment. If the orientations are such that they form a cross, then the segments intersect.\n\nAlternatively, use the cross product method to determine the relative positions.\n\nLet me outline the function:\n\ndef segments_intersect(a1, a2, b1, b2):\n    # Check if line segment a1a2 intersects with b1b2\n    # Using the standard algorithm.\n\nBut wait, the points are given as tuples of integers. So, perhaps represent each point as (x, y).\n\nFirst, let's write a helper function to compute the orientation of three points.\n\nOrientation function:\ndef orientation(p, q, r):\n    # Returns:\n    # 0 if colinear,\n    # 1 if clockwise (right turn),\n    # 2 if counter-clockwise (left turn)\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\nThen, the segments_intersect function can proceed as follows:\n\ndef on_segment(a, b, c):\n    # Check if point c lies on segment ab.\n    return (min(a[0], b[0]) <= c[0] <= max(a[0], b[0])) and (min(a[1], b[1]) <= c[1] <= max(a[1], b[1]))\n\ndef segments_intersect(a, b, c, d):\n    # a and b are endpoints of the first segment, c and d of the second.\n    # Check if the segments intersect.\n    if on_segment(a, b, c):\n        return True\n    if on_segment(a, b, d):\n        return True\n    if on_segment(c, d, a):\n        return True\n    if on_segment(c, d, b):\n        return True\n\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    # General case\n    if ((o1 != o2) and (o3 != o4)):\n        return True\n\n    return False\n\nWait, no. Wait, the general case for two segments intersecting is when the orientations of (a,b,c) and (a,b,d) are different, and the orientations of (c,d,a) and (c,d,b) are different. Because that implies that the two segments cross each other.\n\nSo the function should return True in that case.\n\n",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian, each spaceship has exactly one assigned base, and no two paths from a base to its assigned spaceship intersect in the galaxy plane.\n\n### Approach\n1. **Input Reading**: Read the number of Rebel spaceships (R) and bases (B). Then read the coordinates of each spaceship and base.\n2. **Check for Perfect Matching**: If R is not equal to B, output \"No\" immediately since a perfect matching is impossible.\n3. **Generate All Possible Assignments**: For each permutation of assigning R spaceships to B bases, check if the assignment forms a valid perfect matching.\n4. **Check Path Intersection**: For each valid permutation, use computational geometry to check if any two paths intersect. If a valid permutation without intersections exists, output \"Yes\"; otherwise, output \"No\".\n\n### Solution Code\n```python\nimport sys\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef on_segment(a, b, c):\n    return (min(a[0], b[0]) <= c[0] <= max(a[0], b[0])) and (min(a[1], b[1]) <= c[1] <= max(a[1], b[1]))\n\ndef segments_intersect(a, b, c, d):\n    if on_segment(a, b, c):\n        return True\n    if on_segment(a, b, d):\n        return True\n    if on_segment(c, d, a):\n        return True\n    if on_segment(c, d, b):\n        return True\n\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if ((o1 != o2) and (o3 != o4)):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    R = int(input[idx])\n    idx += 1\n    B = int(input[idx])\n    idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x = int(input[idx])\n        y = int(input[idx+1])\n        ships.append((x, y))\n        idx += 2\n\n    bases = []\n    for _ in range(B):\n        x = int(input[idx])\n        y = int(input[idx+1])\n        bases.append((x, y))\n        idx += 2\n\n    # Generate all permutations of assigning ships to bases\n    from itertools import permutations\n    for perm in permutations(range(R), B):\n        assignment = [None] * B\n        ship_used = [False] * R\n        valid = True\n        for i in range(B):\n            ship_idx = perm[i]\n            if ship_used[ship_idx]:\n                valid = False\n                break\n            assignment[i] = (ships[ship_idx][0], ships[ship_idx][1])\n            ship_used[ship_idx] = True\n        if not valid:\n            continue\n\n        # Check all pairs of segments for intersection\n        conflict = False\n        for i in range(B):\n            a, b = assignment[i]\n            for j in range(i+1, B):\n                c, d = assignment[j]\n                if segments_intersect(a, b, c, d):\n                    conflict = True\n                    break\n            if conflict:\n                break\n        if not conflict:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution involves reading the input, checking for a perfect matching, generating all possible assignments, and using computational geometry to ensure no paths intersect. The `orientation` and `on_segment` functions help determine if line segments intersect, ensuring that each path is non-intersecting. If any valid permutation is found, the answer is \"Yes\"; otherwise, it is \"No\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef on_segment(a, b, c):\n    return (min(a[0], b[0]) <= c[0] <= max(a[0], b[0])) and (min(a[1], b[1]) <= c[1] <= max(a[1], b[1]))\n\ndef segments_intersect(a, b, c, d):\n    if on_segment(a, b, c):\n        return True\n    if on_segment(a, b, d):\n        return True\n    if on_segment(c, d, a):\n        return True\n    if on_segment(c, d, b):\n        return True\n\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if ((o1 != o2) and (o3 != o4)):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    R = int(input[idx])\n    idx += 1\n    B = int(input[idx])\n    idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x = int(input[idx])\n        y = int(input[idx+1])\n        ships.append((x, y))\n        idx += 2\n\n    bases = []\n    for _ in range(B):\n        x = int(input[idx])\n        y = int(input[idx+1])\n        bases.append((x, y))\n        idx += 2\n\n    # Generate all permutations of assigning ships to bases\n    from itertools import permutations\n    for perm in permutations(range(R), B):\n        assignment = [None] * B\n        ship_used = [False] * R\n        valid = True\n        for i in range(B):\n            ship_idx = perm[i]\n            if ship_used[ship_idx]:\n                valid = False\n                break\n            assignment[i] = (ships[ship_idx][0], ships[ship_idx][1])\n            ship_used[ship_idx] = True\n        if not valid:\n            continue\n\n        # Check all pairs of segments for intersection\n        conflict = False\n        for i in range(B):\n            a, b = assignment[i]\n            for j in range(i+1, B):\n                c, d = assignment[j]\n                if segments_intersect(a, b, c, d):\n                    conflict = True\n                    break\n            if conflict:\n                break\n        if not conflict:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 921,
        "thoughts_token_count": 1025
    }
}