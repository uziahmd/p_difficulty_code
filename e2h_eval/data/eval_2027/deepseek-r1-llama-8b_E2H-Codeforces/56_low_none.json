{
    "start": 1758278115.0457993,
    "end": 1758278334.308289,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. Each base must have exactly one spaceship, and each spaceship must be assigned to exactly one base. So, it's a perfect matching between R rebels and B bases.\n\nBut there's an additional condition: the straight paths from each base to its assigned spaceship shouldn't intersect. So, no two paths can cross each other in the galaxy plane.\n\nHmm. So, I need to determine if such a matching exists.\n\nLet me think about how to approach this.\n\nFirst, the input consists of R spaceships and B bases. The coordinates are given, and no three points are colinear, which probably helps because it reduces the cases where lines could overlap in more complex ways.\n\nSo, the key steps are:\n\n1. Find a perfect matching between R and B (so R must equal B, right? Because each spaceship is assigned to a base, but wait, the problem says R and B can be up to 10, but maybe R equals B? Because otherwise, it's impossible to have a perfect matching if R != B. Oh, wait, the first line says R and B, then the next R lines are the spaceships, followed by B lines for the bases. So R is the number of spaceships, B the number of bases. Wait, the problem statement says that the assignment is a perfect matching. So R must equal B, right? Otherwise, it's impossible. Because perfect matching requires the same number of nodes on each side.\n\nWait, yes! So first, I should check if R equals B. If not, output No immediately.\n\nSo the first step is to check if R == B. If not, return 'No'.\n\nOtherwise, proceed.\n\nNow, for the case when R = B, we need to find a bijection between the spaceships and the bases such that no two connecting lines cross.\n\nHow to model this?\n\nThis sounds like a problem that can be modeled with bipartite graphs, but with some geometric constraints.\n\nEach spaceship is on one side, each base on the other. Edges connect a spaceship to a base if the line segment between them doesn't cross any other such line segments in the final matching.\n\nWait, but since the matching is a set of edges without common vertices, the problem reduces to whether there's a perfect matching in the bipartite graph where edges are allowed only if the two points' connecting line doesn't cross any others in the matching.\n\nWait, but how to model the non-crossing condition. Because it's possible that two edges in the matching cross each other, so we can't just consider all possible matchings.\n\nSo, perhaps the problem is to find a non-crossing bipartitioned matching.\n\nThis reminds me of the concept of planar bipartite graphs or the non-crossing bipartite matching problem.\n\nWait, but how do I check for such a matching?\n\nI remember that for convex polygons, a non-crossing matching can be found using certain algorithms, but here the points aren't necessarily arranged in a convex way.\n\nAlternatively, perhaps the problem can be approached by considering the arrangement of the points and trying to find a non-crossing perfect matching.\n\nBut for R=10, checking all possible permutations would be computationally expensive. Since 10! is around 3.6 million, which is manageable for a Python solution.\n\nWait, but even 3.6 million is manageable, especially since each permutation can be checked quickly.\n\nSo the plan is:\n\n- Check if R != B. If so, output 'No'.\n- Else, generate all possible permutations of the bases for the spaceships.\n- For each permutation, check if all the connecting line segments are non-crossing.\n- If any permutation satisfies this, output 'Yes'. Otherwise, 'No'.\n\nWait, but how to represent the spaceships and bases as a list of points, and for a permutation, assign each spaceship to a base, then check all pairs of edges for intersections.\n\nYes.\n\nSo, let's outline the steps.\n\n1. Read the input: R and B. Then read R spaceship points and B base points.\n\n2. If R != B, output 'No'.\n\n3. Else, for all possible perfect matchings (i.e., all possible bijections between spaceships and bases), check if the corresponding edges form a non-crossing set.\n\n4. If any such bijection exists, output 'Yes'; else, 'No'.\n\nNow, the challenge is to implement this efficiently.\n\nBut for R up to 10, generating all permutations is feasible. Because 10! is about 3.6e6, which is manageable.\n\nWait, wait. Wait, the problem has R spaceships and B bases, but R and B can be different. But earlier reasoning shows that R must equal B for a perfect matching to exist. So, the first thing is to check R == B. Otherwise, output 'No'.\n\n",
    "response": "To solve this problem, we need to determine if it is possible to assign each Rebel spaceship to a base such that no two paths connecting a spaceship to its assigned base intersect. This requires finding a perfect matching between the spaceships and bases without any crossing paths.\n\n### Approach\n1. **Check for Perfect Matching Feasibility**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" immediately as a perfect matching is impossible.\n2. **Generate All Possible Matchings**: For each permutation of bases, assign spaceships to bases in the order specified by the permutation.\n3. **Check for Non-Crossing Paths**: For each permutation, check if all connecting line segments between spaceships and their assigned bases are non-crossing.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    R_B = sys.stdin.readline().strip().split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    \n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    # Now, generate all possible bijections and check for non-crossing\n    for perm in permutations(range(B)):\n        match = {}\n        for i in range(R):\n            match[i] = perm[i]\n        \n        # Now, create the edges and check for intersections\n        edges = []\n        for i in range(R):\n            ship = ships[i]\n            base = bases[perm[i]]\n            edges.append((ship, base))\n        \n        # Check for any crossing pairs\n        ok = True\n        for i in range(R):\n            for j in range(i+1, R):\n                s1, b1 = edges[i]\n                s2, b2 = edges[j]\n                # Compute the cross product to check if lines intersect\n                # Line segment from s1 to b1 and s2 to b2\n                # The cross product of (b1 - s1) and (s2 - s1) should be zero for colinear points, but since no three are colinear, it's safe\n                # Using vector cross product\n                def ccw(a, b, c):\n                    return (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0])\n                \n                a = s1\n                b = b1\n                c = s2\n                val1 = ccw(a, b, c)\n                a = s1\n                b = b1\n                c = b2\n                val2 = ccw(a, b, c)\n                a = s2\n                b = b2\n                c = b1\n                val3 = ccw(a, b, c)\n                a = s2\n                b = b2\n                c = b1\n                val4 = ccw(a, b, c)\n                \n                if (val1 * val2 < 0) or (val3 * val4 < 0):\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Perfect Matching Check**: If the number of spaceships does not match the number of bases, output \"No\".\n3. **Permutations**: Generate all possible permutations of bases to check each potential assignment of spaceships to bases.\n4. **Non-Crossing Check**: For each permutation, use the cross product to ensure no two connecting line segments intersect. If any permutation satisfies the condition, output \"Yes\". If none do, output \"No\".\n\nThis approach efficiently checks all possible assignments and ensures that no paths cross, providing a solution that works within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    R_B = sys.stdin.readline().strip().split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    \n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    # Now, generate all possible bijections and check for non-crossing\n    for perm in permutations(range(B)):\n        match = {}\n        for i in range(R):\n            match[i] = perm[i]\n        \n        # Now, create the edges and check for intersections\n        edges = []\n        for i in range(R):\n            ship = ships[i]\n            base = bases[perm[i]]\n            edges.append((ship, base))\n        \n        # Check for any crossing pairs\n        ok = True\n        for i in range(R):\n            for j in range(i+1, R):\n                s1, b1 = edges[i]\n                s2, b2 = edges[j]\n                # Compute the cross product to check if lines intersect\n                # Line segment from s1 to b1 and s2 to b2\n                # The cross product of (b1 - s1) and (s2 - s1) should be zero for colinear points, but since no three are colinear, it's safe\n                # Using vector cross product\n                def ccw(a, b, c):\n                    return (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0])\n                \n                a = s1\n                b = b1\n                c = s2\n                val1 = ccw(a, b, c)\n                a = s1\n                b = b1\n                c = b2\n                val2 = ccw(a, b, c)\n                a = s2\n                b = b2\n                c = b1\n                val3 = ccw(a, b, c)\n                a = s2\n                b = b2\n                c = b1\n                val4 = ccw(a, b, c)\n                \n                if (val1 * val2 < 0) or (val3 * val4 < 0):\n                    ok = False\n                    break\n            if not ok:\n                break\n        if ok:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 454,
        "completion_token_count": 916,
        "thoughts_token_count": 1025
    }
}