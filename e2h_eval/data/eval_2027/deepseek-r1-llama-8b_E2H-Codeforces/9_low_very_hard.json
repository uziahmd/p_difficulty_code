{
    "start": 1758103866.9356997,
    "end": 1758103993.813527,
    "start-formatted": "2025-09-17 19:11 KST",
    "end-formatted": "2025-09-17 19:13 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about selecting souvenirs such that their total weight doesn't exceed m, and the total cost is maximized. The constraints are that each souvenir has a weight wi which is either 1, 2, or 3. And n can be up to 10^5, which is 100,000, while m can be up to 3*10^5.\n\nHmm. So, for each item, we have three possible weights, and we need to pick a subset where the sum of weights is <= m, and the sum of costs is as large as possible.\n\nI remember that for knapsack problems, when the items are large in number but with small weights, certain approaches become feasible. Since here the weights are only 1,2,3, maybe we can group them by weight and find an efficient way to compute the maximum cost.\n\nLet me think about how to approach this. Since the weights are small, perhaps we can precompute for each possible remainder modulo the least common multiple of the weights, but wait, the weights are 1,2,3. Their LCM is 6. But considering the sum of weights, maybe grouping into mod 6 would help. Or maybe we can model it differently.\n\nAlternatively, since the maximum m is 3e5, which is manageable, perhaps we can use dynamic programming where dp[i] represents the maximum cost achievable with total weight i.\n\nBut for n=1e5 and m=3e5, a standard 0-1 knapsack approach would be O(nm), which is 3e10 operations—way too slow. So that's not feasible.\n\nSo we need a smarter approach. Let's think about how to handle each weight class separately.\n\nEach item is either weight 1, 2, or 3. So let's collect all items by their weight. Let's say:\n\n- For w=1: items sorted in descending order of cost.\n- For w=2: same.\n- For w=3: same.\n\nThen, for each weight group, we can precompute the prefix sums, which represent the maximum cost for taking k items from that group, ordered by cost.\n\nOnce we have these prefix sums, the problem reduces to choosing a certain number of items from each group such that the total weight (1*a + 2*b + 3*c) is <= m, and the sum of the prefix sums a, b, c is maximized.\n\nWait, yes! So the plan is:\n\n1. Separate the items into groups by their weight (w=1, w=2, w=3).\n2. For each group, sort the items in descending order of cost, then compute the prefix sums. The prefix sum for k items in a group is the maximum possible cost for taking exactly k items from that group.\n3. Then, the problem becomes choosing a, b, c (number of items taken from each group) such that a + 2b + 3c <= m, and the sum of the prefix sums is as large as possible.\n\nNow, the challenge is to efficiently find the best a, b, c.\n\nGiven that the sum can be up to 3e5, we need a way to iterate over possible values of a, b, c without exceeding time limits.\n\nLet's think about the constraints:\n\nWe can iterate over c, the number of items taken from w=3. For each c, we can iterate over b, the number from w=2, and then compute the remaining weight for a.\n\nBut even with that, the complexity might be high. We need a smarter way.\n\nAlternatively, since the weights are small, maybe we can use a 3D DP approach, but that's probably not feasible because m is up to 3e5.\n\nWait, but maybe we can model it in terms of the possible remainders modulo something. Or perhaps find a way to iterate through the possible combinations.\n\nAnother idea: For each possible c, determine the maximum possible a and b that fit within the remaining weight.\n\nLet's structure it as follows:\n\nFor each possible c (from 0 up to max_c where 3c <= m), we calculate the remaining weight rem = m - 3c. Now, rem must be >=0.\n\nWithin rem, we can take any combination of a and b such that a + 2b <= rem.\n\nSo for each c, we can compute the maximum possible a and b, given the rem.\n\nBut how do we compute the maximum a and b quickly?\n\nWe can precompute for each possible rem, the maximum sum from w=2 and w=1.\n\nWait, but rem can be up to m (3e5). So for each c, rem can be up to 3e5, which is manageable if we can process it quickly.\n\nWait, perhaps for each possible c, we can compute the best",
    "response": "To solve this problem, we need to maximize the total cost of souvenirs Petya can carry without exceeding a given weight limit. Given the constraints on the number of souvenirs and their weights, an efficient approach is necessary.\n\n### Approach\n1. **Categorize Souvenirs by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, or 3). This allows us to handle each group separately.\n2. **Sort and Compute Prefix Sums**: For each weight group, sort the souvenirs in descending order of their cost and compute prefix sums. The prefix sum for `k` items in a group represents the maximum cost achievable by taking exactly `k` items from that group.\n3. **Iterate Over Possible Combinations**: For each possible number of souvenirs taken from the weight 3 group, calculate the remaining weight capacity. Then, determine the optimal number of souvenirs to take from the weight 2 and 1 groups within this remaining capacity to maximize the total cost.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, m = int(input[ptr]), int(input[ptr+1])\n    ptr += 2\n\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        wi = int(input[ptr])\n        ci = int(input[ptr+1])\n        ptr += 2\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums for each group\n    prefix1 = [0]\n    s = 0\n    for c in w1:\n        s += c\n        prefix1.append(s)\n    \n    prefix2 = [0]\n    s = 0\n    for c in w2:\n        s += c\n        prefix2.append(s)\n    \n    prefix3 = [0]\n    s = 0\n    for c in w3:\n        s += c\n        prefix3.append(s)\n    \n    max_cost = 0\n    \n    # Iterate over possible c (number of items from w=3)\n    for c in range(len(prefix3)-1):\n        current_weight = 3 * c\n        if current_weight > m:\n            break\n        rem = m - current_weight\n        # Now, find best a and b such that a + 2b <= rem\n        # We can iterate over b and find the best a\n        max_rem_for_b = rem // 2\n        max_b = min(max_rem_for_b, len(prefix2)-1)\n        for b in range(max_b + 1):\n            current_b_weight = 2 * b\n            if current_b_weight > rem:\n                continue\n            a_max = rem - current_b_weight\n            a_max = min(a_max, len(prefix1)-1)\n            current_total = prefix3[c] + prefix2[b + 1] + prefix1[a_max]\n            if current_total > max_cost:\n                max_cost = current_total\n    \n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Categorization and Sorting**: Souvenirs are categorized by their weights into three lists. Each list is then sorted in descending order of cost to prioritize higher-value items.\n2. **Prefix Sums Calculation**: For each weight group, prefix sums are computed to quickly determine the maximum cost for taking any number of items from that group.\n3. **Iterative Combination Check**: By iterating over possible numbers of souvenirs from the weight 3 group, the solution efficiently checks all feasible combinations of souvenirs from the other groups to find the optimal total cost within the weight limit.\n\nThis approach ensures that we efficiently explore all possible valid combinations while keeping the computational complexity manageable.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, m = int(input[ptr]), int(input[ptr+1])\n    ptr += 2\n\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        wi = int(input[ptr])\n        ci = int(input[ptr+1])\n        ptr += 2\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums for each group\n    prefix1 = [0]\n    s = 0\n    for c in w1:\n        s += c\n        prefix1.append(s)\n    \n    prefix2 = [0]\n    s = 0\n    for c in w2:\n        s += c\n        prefix2.append(s)\n    \n    prefix3 = [0]\n    s = 0\n    for c in w3:\n        s += c\n        prefix3.append(s)\n    \n    max_cost = 0\n    \n    # Iterate over possible c (number of items from w=3)\n    for c in range(len(prefix3)-1):\n        current_weight = 3 * c\n        if current_weight > m:\n            break\n        rem = m - current_weight\n        # Now, find best a and b such that a + 2b <= rem\n        # We can iterate over b and find the best a\n        max_rem_for_b = rem // 2\n        max_b = min(max_rem_for_b, len(prefix2)-1)\n        for b in range(max_b + 1):\n            current_b_weight = 2 * b\n            if current_b_weight > rem:\n                continue\n            a_max = rem - current_b_weight\n            a_max = min(a_max, len(prefix1)-1)\n            current_total = prefix3[c] + prefix2[b + 1] + prefix1[a_max]\n            if current_total > max_cost:\n                max_cost = current_total\n    \n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 451,
        "completion_token_count": 860,
        "thoughts_token_count": 1025
    }
}