{
    "start": 1758278802.246693,
    "end": 1758279211.637912,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about reconstructing the number of laughy mushrooms on each lawn based on some given roads. Each road connects two lawns and has two numbers: the GCD and LCM of the mushrooms on those two lawns. The task is to determine if such an arrangement exists, and if so, find any possible configuration.\n\nHmm. So the input gives me n lawns and m known roads. For each road, I know the two endpoints (lawn IDs), and the GCD and LCM of the mushrooms on those lawns.\n\nWait, but how do I model this? It feels like a graph problem where each edge represents constraints between two variables (the mushroom counts). So this might be similar to a system of equations or constraints that we need to solve.\n\nEach edge (u, v) gives us that GCD(u_mushrooms, v_mushrooms) = g and LCM(u_mushrooms, v_mushrooms) = l. But wait, for any two numbers, the product of their GCD and LCM is equal to the product of the numbers. So u * v = g * l. That's a crucial relationship.\n\nSo for each edge, the product of u and v must equal g * l. Also, since g divides both u and v, and l is a multiple of both, we can represent this as:\n\nu = g * a\nv = g * b\n\nwhere a and b are coprime integers because their GCD is 1. Because, after factoring out the GCD g, the remaining parts must have an LCM of l/g. Wait, let's think: the LCM of u and v is l, which is equal to (g*a) and (g*b). Since a and b are coprime, the LCM is g*a*b. So l = g*a*b. Therefore, a*b = l / g.\n\nSo substituting back, u = g*a and v = g*b, with a and b being coprime, and a*b = l/g.\n\nThis seems like a useful way to model the problem. Each variable (mushroom count) is a multiple of the GCD of its edges. But since the GCDs can vary per edge, perhaps the variables are connected in a way that forms a tree or a graph with cycles, and we need to assign values accordingly.\n\nBut how do I model all these constraints?\n\nI think the approach here is to model this as a system of equations and variables, and then perform some kind of constraint satisfaction. Maybe using a Union-Find data structure with additional information, or perhaps a BFS approach to assign variables in a way that satisfies all constraints.\n\nWait, another thought: each connected component in the graph can be processed independently. Because if two lawns are not connected via any known roads, their mushroom counts can be set arbitrarily (as long as they satisfy any constraints from their own connected component).\n\nSo perhaps I should first build the graph, and for each connected component, process it separately.\n\nNow, for each edge, the variables u and v are related by u = g * a, v = g * b, with a and b coprime, and a*b = l/g.\n\nBut how do I handle this in code? Because the variables can be part of a system where multiple edges impose constraints on the same variables.\n\nLet me think about how to represent the variables. Maybe each node can have a value, which is initially unknown. But as I process the edges, I can assign possible values based on the constraints.\n\nWait, but since each edge imposes that u and v are multiples of g and that their product is g*l, perhaps each variable is determined by the product of certain primes.\n\nAlternatively, perhaps the problem can be modeled using a system where each variable is represented as a product of primes raised to certain exponents, and the constraints define equations on these exponents.\n\nBut that might get complicated quickly.\n\nAnother angle: for each connected component, the variables are linked through a series of edges. We can represent each variable as a multiple of a base value, perhaps starting from a root node.\n\nFor example, pick a root node, say node 1. Then, for each edge connected to node 1, express the other node's value in terms of node 1's value. Then, proceed to other edges, ensuring that all constraints are satisfied.\n\nBut this might lead to conflicts if the constraints aren't consistent.\n\nSo the plan could be:\n\n1. For each connected component:\n   a. Assign a variable (like x) to each node, representing the number of mushrooms.\n   b. For each edge in the component, express the constraints in terms of these variables.\n   c. Check for consistency; if any contradiction arises, the system is impossible.\n   d. If consistent, assign values based on the constraints.\n\nBut how exactly to model the",
    "response": "To solve this problem, we need to determine if it's possible to reconstruct the number of laughy mushrooms on each lawn based on given roads and their respective GCD and LCM values. If possible, we should output any valid configuration; otherwise, we should indicate that it's not possible.\n\n### Approach\n1. **Graph Representation**: Represent the problem as a graph where each node is a lawn and each edge contains the GCD and LCM values for the mushrooms on the connected lawns.\n2. **Connected Components**: Since the graph can be split into connected components, we process each component independently. This allows us to handle each part of the graph separately.\n3. **Constraints Handling**: For each edge, express the mushrooms on the connected lawns in terms of their GCD and LCM. Use the relationship that the product of the GCD and LCM of two numbers equals the product of the numbers themselves.\n4. **Union-Find with Constraints**: Use a Union-Find data structure augmented with additional information to track the constraints. This helps in efficiently merging sets and checking for consistency.\n5. **Breadth-First Search (BFS)**: For each connected component, use BFS to assign values to each node based on the constraints derived from the edges. Ensure that all constraints are satisfied during the assignment.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1  # Convert to 0-based\n        v = int(input[idx+1])-1\n        g = int(input[idx+2])\n        l = int(input[idx+3])\n        edges.append((u, v, g, l))\n        idx +=4\n\n    parent = list(range(n))\n    rank = [1]*n\n    val = [1]*n\n    possible = True\n    for u, v, g, l in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, val, u, v, g, l)\n        else:\n            if g * l != val[u] * val[v]:\n                possible = False\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    for i in range(n):\n        if find(parent, i) == i:\n            q = deque()\n            q.append(i)\n            while q:\n                current = q.popleft()\n                for neighbor, g, l in adj[current]:\n                    if find(parent, neighbor) != find(parent, current):\n                        continue\n                    if val[current] * val[neighbor] != g * l:\n                        possible = False\n                        break\n                    if val[neighbor] == 0:\n                        val[neighbor] = l // g\n                        if val[neighbor] % g != 0:\n                            possible = False\n                            break\n                        parent[neighbor] = current\n                        rank[current] += rank[neighbor]\n                        q.append(neighbor)\n                if not possible:\n                    break\n            if not possible:\n                break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(' '.join(map(str, val)))\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, val, x, y, g, l):\n    x_root = find(parent, x)\n    y_root = find(parent, y)\n    if x_root == y_root:\n        return\n    if rank[x_root] < rank[y_root]:\n        x_root, y_root = y_root, x_root\n    parent[y_root] = x_root\n    if rank[x_root] == rank[y_root]:\n        rank[x_root] +=1\n    if val[y_root] != 0:\n        g_x = g\n        l_x = l\n        if val[x_root] * val[y_root] != g_x * l_x:\n            return False\n        if val[y_root] == 0:\n            val[y_root] = l_x // g_x\n            if val[y_root] % g_x != 0:\n                return False\n    elif val[x_root] == 0:\n        val[x_root] = l_x // g_x\n        if val[x_root] % g_x !=0:\n            return False\n    return True\n\ndef build_adjacency_list(edges, n):\n    adj = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        adj[u].append( (v, g, l) )\n        adj[v].append( (u, g, l) )\n    return adj\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns, roads, and the details of each road.\n2. **Union-Find Initialization**: Initialize the Union-Find data structure to manage connected components and constraints.\n3. **Processing Edges**: For each edge, check if the connected components are already part of the same set. If they are, ensure the constraints are satisfied; otherwise, merge the sets and update the values.\n4. **BFS for Value Assignment**: For each connected component, use BFS to assign values to each node based on the constraints derived from the edges. Ensure all constraints are met during this process.\n5. **Output Result**: After processing all edges, output \"YES\" along with the mushroom counts if possible, or \"NO\" if it's not possible to satisfy the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1  # Convert to 0-based\n        v = int(input[idx+1])-1\n        g = int(input[idx+2])\n        l = int(input[idx+3])\n        edges.append((u, v, g, l))\n        idx +=4\n\n    parent = list(range(n))\n    rank = [1]*n\n    val = [1]*n\n    possible = True\n    for u, v, g, l in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, val, u, v, g, l)\n        else:\n            if g * l != val[u] * val[v]:\n                possible = False\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    for i in range(n):\n        if find(parent, i) == i:\n            q = deque()\n            q.append(i)\n            while q:\n                current = q.popleft()\n                for neighbor, g, l in adj[current]:\n                    if find(parent, neighbor) != find(parent, current):\n                        continue\n                    if val[current] * val[neighbor] != g * l:\n                        possible = False\n                        break\n                    if val[neighbor] == 0:\n                        val[neighbor] = l // g\n                        if val[neighbor] % g != 0:\n                            possible = False\n                            break\n                        parent[neighbor] = current\n                        rank[current] += rank[neighbor]\n                        q.append(neighbor)\n                if not possible:\n                    break\n            if not possible:\n                break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(' '.join(map(str, val)))\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, val, x, y, g, l):\n    x_root = find(parent, x)\n    y_root = find(parent, y)\n    if x_root == y_root:\n        return\n    if rank[x_root] < rank[y_root]:\n        x_root, y_root = y_root, x_root\n    parent[y_root] = x_root\n    if rank[x_root] == rank[y_root]:\n        rank[x_root] +=1\n    if val[y_root] != 0:\n        g_x = g\n        l_x = l\n        if val[x_root] * val[y_root] != g_x * l_x:\n            return False\n        if val[y_root] == 0:\n            val[y_root] = l_x // g_x\n            if val[y_root] % g_x != 0:\n                return False\n    elif val[x_root] == 0:\n        val[x_root] = l_x // g_x\n        if val[x_root] % g_x !=0:\n            return False\n    return True\n\ndef build_adjacency_list(edges, n):\n    adj = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        adj[u].append( (v, g, l) )\n        adj[v].append( (u, g, l) )\n    return adj\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1198,
        "thoughts_token_count": 1025
    }
}