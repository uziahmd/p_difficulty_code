{
    "start": 1758285754.7898183,
    "end": 1758288052.239251,
    "start-formatted": "2025-09-19 21:42 KST",
    "end-formatted": "2025-09-19 22:20 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about Polycarp solving problems over k days. Each day he must solve a contiguous sequence of problems from the list, and he can't skip any. So all the problems are divided into exactly k consecutive groups. The profit for each day is the maximum difficulty in that group, and the total profit is the sum of these maxima. Our goal is to maximize this total profit.\n\nHmm, right. So how do we approach this?\n\nFirst, let's think about what determines the profit. For each group (day), the profit is the maximum of the elements in that group. To maximize the total, we need to arrange the groups such that as many high-value elements as possible contribute to the sum.\n\nBut the constraints are that each group must be a contiguous block, and all groups together cover all n problems. So, how can we model this?\n\nDynamic Programming comes to mind. Because the problem has overlapping subproblems and optimal substructure. Maybe we can define a DP state where dp[i][j] represents the maximum total profit when considering the first i problems, divided into j days.\n\nWait, but what's the transition? Let's see.\n\nFor dp[i][j], the last day could have ended at some position m, and then the rest is split into j-1 days. But considering all possible m might be too slow because n is up to 2000 and k up to 2000, so O(n^2*k) could be acceptable, but maybe there's a smarter way.\n\nAlternatively, another approach: since each day contributes the maximum of a contiguous segment, perhaps the optimal strategy is to include as many high elements as possible in their own day. But since the segments have to be contiguous, it's not straightforward.\n\nWait, but maybe the maximums can be selected in a way that each day's maximum is as large as possible, without overlapping with others. So perhaps the optimal solution is to select certain points as the end of each day, ensuring that each selected point's a_i is as large as possible.\n\nBut how to formalize this.\n\nLet me think about the structure of the problem. Since all segments must be contiguous and cover the entire array, the problem reduces to selecting k-1 split points between the n-1 possible positions. Each split divides the array into k contiguous parts.\n\nEach part's contribution is its maximum. So the sum of these maxima is what we need to maximize.\n\nSo the problem becomes choosing the best k-1 split points to maximize the sum of the maxima of each resulting segment.\n\nYes, that makes sense. So our task is to find the optimal split points.\n\nNow, how to compute this efficiently.\n\nThe naive approach would be to consider all possible ways to split the array into k segments and compute the sum for each, then choose the maximum. But this is O(2^(n/k)) time, which is way too slow for n=2000.\n\nSo we need a dynamic programming approach.\n\nLet me think about the DP state. Let's define dp[i][j] as the maximum total profit for the first i problems using j days.\n\nHow do we compute dp[i][j]?\n\nWell, for each j, to compute dp[i][j], we can consider adding the i-th problem to a previous segment in j-1 days. So for each m < i, we can take the maximum of the segment from m+1 to i, and add it to dp[m][j-1].\n\nBut wait, that would require checking all possible m for each i and j, leading to O(n^2k) time, which is 2000^3 = 8e10 operations—way too slow.\n\nThat's not feasible. We need a better approach.\n\nHmm, perhaps we can precompute for each position i and possible j, the best place to split before i.\n\nWait, another idea: the maximum in a segment is determined by the highest element in that segment. So perhaps for a given segment, the maximum is known once you know the endpoints.\n\nWait, perhaps we can model the problem by keeping track of the current maximum as we extend the segment.\n\nAlternatively, here's an insight: when building the segments, the maximum of a segment can only stay the same or increase as the segment grows. So for a given starting point, the maximum of the segment increases as we include more elements to the right.\n\nWait, maybe that's useful. So for each position i, the maximum in the segment ending at i is a certain value. So when building the DP, perhaps for each j, we can track the best way to split the array into j segments, considering the maximum up to each position.\n\nWait, another angle: the maximum for each segment is fixed once the segment is decided. So for each possible split into k segments, the sum is the sum of the maxima of each segment.\n\nWe need to find the splits that maximize this sum.\n\nThis sounds similar to some kind of interval partitioning problem, but with the specific cost function being the maximum of each interval.\n\nAnother thought: if we can find the optimal places to split such that each split occurs before a local maximum, then the sum could be maximized.\n\nBut I'm not sure.\n\nAlternatively, perhaps we can model the problem using DP where dp[j] represents the maximum total profit when splitting the array into j segments. Then, for each j, we can track the best way to split.\n\nWait, but that's vague. Let me think more concretely.\n\nLet's think of dp[i][j] as the maximum profit for the first i elements split into j days.\n\nThen, for dp[i][j], we can look back to some m < i. The last segment is from m+1 to i, and the maximum in that segment is max(m+1, i). Then, dp[i][j] = dp[m][j-1] + max(m+1, i).\n\nSo the recurrence is:\n\ndp[i][j] = max( dp[m][j-1] + max(a[m+1..i]) ) for all m in 0..i-1.\n\nBut calculating max(a[m+1..i]) for every possible m and i is O(n^2), which is 4e6 for n=2000, but multiplied by k=2000, gives 8e9 operations—way too slow.\n\nSo we need a way to compute max(m+1, i) quickly.\n\nWait, but for each i, the maximum of the segment ending at i can be built incrementally.\n\nWait, for each i, the maximum of a[m+1..i] is the maximum of a[m+1..i-1] and a[i]. So perhaps for each j, we can track the maximum as we iterate through i.\n\nWait, let's restructure the DP.\n\nLet’s think of dp[j] as a dictionary where for each j, we store the best possible way to split into j segments, along with the maximum value for each possible position.\n\nAlternatively, perhaps we can use a 1D DP array where dp[j] represents the maximum profit when splitting into j segments, and also track the maximums of each segment.\n\nWait, perhaps that's not directly applicable.\n\nWait, another approach: for each j, when considering the j-th split, the maximum of the current segment can be maintained as we go.\n\nWait, perhaps for each j, we can compute the best way to split the array into j segments by finding for each possible end of the j-th segment, the maximum of that segment, and adding it to the best way to split the previous segments.\n\nLet me try to formalize this.\n\nWe can precompute for each possible segment [l, r], the maximum a_i in that segment. But again, precomputing all possible l and r is O(n^2), which is manageable for n=2000.\n\nOnce we have that, perhaps the DP can be optimized.\n\nSo let's create a 2D array max_val where max_val[l][r] is the maximum of a[l..r]. Computing this can be done with a sliding window approach.\n\nWait, no, for each l, we can compute the maximum from l to r for each r >= l. That's O(n^2), which is acceptable.\n\nOnce we have max_val, then the DP can proceed as:\n\ndp[j][i] = max over m < i of ( dp[j-1][m] + max_val[m+1][i] )\n\nBut even with max_val precomputed, the DP would still be O(n^2k), which is 2000^3 = 8e10 operations—way too slow.\n\nHmm, that's a problem. We need a better approach.\n\nWait, perhaps the problem can be transformed into finding the best way to select the positions where the maximum is taken for each segment. Because the sum is the sum of the maxima of each segment.\n\nWait, another observation: the maximum of a segment can't decrease as the segment grows. So for a given starting point, the maximum is non-decreasing as the segment extends.\n\nSo for each position i, when considering the end of a segment, the maximum can be tracked efficiently.\n\nWait, perhaps we can model the DP as follows:\n\nFor each j, and for each i, dp[j][i] is the maximum profit for the first i elements in j days. Then, for j days, to compute dp[j][i], we can look for all possible m < i, where the last segment starts at m+1 and ends at i. The maximum of this segment is known as max_val[m+1][i], and the best dp[j-1][m] plus this maximum is considered.\n\nBut again, this leads to O(n^2k) time.\n\nHmm. Wait, perhaps we can optimize the inner loop.\n\nFor each j, and for each i, instead of trying all possible m, perhaps we can find the best m in a clever way.\n\nWait, perhaps for each j, as we process i in increasing order, we can keep track of the best possible m for each possible maximum value.\n\nWait, let's think about j fixed. We want to compute dp[j][i] for all i.\n\nWhen considering dp[j][i], the last segment is from m+1 to i, and the maximum is max_val[m+1][i]. So for each i, dp[j][i] = max( dp[j-1][m] + max_val[m+1][i] ) for all m < i.\n\nBut how to compute this efficiently.\n\nAlternative Idea: For each j, and each possible starting point s, we can track the best possible m and the corresponding max_val.\n\nWait, perhaps for each j, we can iterate through the array, and for each possible end position i, track the best m for which the segment [m+1, i] has the maximum possible (dp[j-1][m] + max_val[m+1][i]).\n\nWait, but how?\n\nWait, let's think about for each j, we process the array from left to right. For each i, we can consider all possible m < i, and the term is dp[j-1][m] + max_val[m+1][i].\n\nWe need to find the maximum of this over m < i.\n\nBut how to compute this quickly.\n\nWait, note that max_val[m+1][i] is the maximum of a[m+1..i]. So for a fixed i, as m decreases, the max_val can change in a certain way.\n\nWait, perhaps for each j, we can maintain a variable that tracks the current maximum possible value for the segment ending at i.\n\nWait, perhaps for each j, as we process i from 1 to n, we can keep track of the maximum of (dp[j-1][m] + max_val[m+1][i}) for m < i.\n\nBut how?\n\nAlternative Idea: For each j, let's process i in order. As we move i to the right, the possible m's can vary. For each i, the best m could be determined based on the previous state.\n\nWait, perhaps for each j, we can maintain a variable that keeps track of the best possible value up to i-1, and for each new i, update this.\n\nWait, perhaps for each j, we can track a variable 'current_max' that represents the maximum of (dp[j-1][m] + max_val[m+1][i]) for m < i.\n\nBut I'm not sure how to update this as i increases.\n\nWait, perhaps for each j, we can process i from 1 to n, and for each i, compute the best m to split before i.\n\nWait, here's an alternative approach inspired by the convex hull trick or other optimization techniques used in DP. But I'm not sure if it applies here.\n\nAlternatively, perhaps for each j, we can process the array and for each i, find the best m in O(1) time, using some precomputed information.\n\nWait, let's think about the term we're trying to maximize for each i and j:\n\nterm = dp[j-1][m] + max_val[m+1][i]\n\nWe can rewrite this as:\n\nterm = dp[j-1][m] + max(a[m+1..i])\n\nBut for each i, as m decreases from i-1 to 0, the max_val[m+1][i] is non-decreasing because adding elements to the left can't decrease the maximum.\n\nWait, no. Adding elements to the left could potentially introduce a larger element, thus increasing the maximum. So for a fixed i, as m decreases (moving to the left), the max_val[m+1][i] is non-decreasing.\n\nSo for each i, the function max_val[m+1][i] is a non-decreasing function of m.\n\nHmm, interesting. So for a fixed j and varying i, the term dp[j-1][m] is added to a non-decreasing function of m.\n\nWait, but the term dp[j-1][m] can vary in any way. So the sum may not have a clear trend.\n\nBut perhaps for each i, we can find the best m that maximizes term, and track that.\n\nWait, perhaps we can model this for each j and i.\n\nLet me think about for j fixed. We need to compute dp[j][i], which is the maximum over m < i of (dp[j-1][m] + max_val[m+1][i}).\n\nNow, for each i, the maximum is achieved by some m. Suppose for each j, as we process i from 1 to n, we can track for each possible m, the value of dp[j-1][m] + max_val[m+1][i}.\n\nBut again, with m varying, this seems tricky.\n\nAlternative Idea: For each j, and for each i, the maximum is achieved when m is chosen such that the max_val[m+1][i] is as large as possible, and dp[j-1][m] is as large as possible.\n\nBut how to find the optimal m for each i.\n\nWait, perhaps for each j, we can precompute the best m for each possible starting position.\n\nAlternatively, perhaps the problem can be transformed into a different form. Let's think about the maximum for each segment. Since the segments are contiguous, the maximum for a segment is determined by the elements within it.\n\nWait, perhaps for each possible segment, we can compute its maximum, and then the problem becomes selecting k segments that cover the entire array, and maximizing the sum of their maxima.\n\nBut how to model this selection optimally.\n\nWait, another Idea: The optimal selection of segments will have their maxima arranged in a way that higher values are included as often as possible.\n\nSo perhaps the best way is to make each segment as small as possible, but include the next highest element.\n\nWait, but I'm not sure.\n\nAlternatively, perhaps the optimal solution is to split the array such that each segment's maximum is as high as possible, and the sum is maximized.\n\nBut how to formalize this.\n\nWait, perhaps the optimal way is to split the array into segments where each segment's maximum is the next highest element in the array.\n\nWait, for example, if the array is sorted in non-decreasing order, the optimal is to have each segment consist of a single element, which is the next maximum. But since the array isn't sorted, this may not hold.\n\nHmm.\n\nWait, perhaps the problem can be modeled as follows: select k-1 split points such that the sum of the maxima of the resulting k segments is maximized.\n\nTo model this, perhaps for each possible split into k segments, compute the sum and choose the maximum.\n\nBut with n=2000, this approach is impossible as it's O(n choose k), which is way too big.\n\nThus, back to the DP approach.\n\nLet me think again about the DP state.\n\nDefine dp[j][i] as the maximum profit when considering the first i elements and j days.\n\nThen, the transition is dp[j][i] = max_{m < i} ( dp[j-1][m] + max(a[m+1..i]) )\n\nBut calculating max(a[m+1..i}) for each m and i is expensive.\n\nSo, to optimize, perhaps we can precompute the maximum for all possible intervals [l, r], which is O(n^2) time.\n\nYes, that's manageable.\n\nOnce we have max_val[l][r], then the transition becomes:\n\ndp[j][i] = max( dp[j-1][m] + max_val[m+1][i] ) for all m < i.\n\nBut even with that, the inner loop is O(n) per i and j, which for 2000 * 2000 * 2000 is 8e10 operations—too slow.\n\nSo we need a smarter way.\n\nAlternative Idea: For each j, when processing i, can we find the optimal m quickly?\n\nWait, for each j, as we process i from 1 to n, perhaps we can maintain some data structure that allows us to query the best m efficiently.\n\nWait, for each j, let's process i from 1 to n, and for each i, we can track the maximum of ( dp[j-1][m] + max_val[m+1][i} ), for m < i.\n\nBut how?\n\nWait, for each j, and for each i, the term is dp[j-1][m] + max_val[m+1][i}.\n\nBut max_val[m+1][i} is the maximum of a[m+1 ... i}.\n\nAs i increases, for each m, max_val[m+1][i} is the maximum of a[m+1 ... i}, which is non-decreasing as i increases.\n\nSo for a fixed j, as i increases, the term dp[j-1][m] + max_val[m+1][i} is non-decreasing for m <= current i.\n\nWait, but perhaps not. Because dp[j-1][m} can vary arbitrarily.\n\nHmm.\n\nWait, but for each j, when we process i from left to right, for each i, the possible m's are from 0 to i-1.\n\nBut for each i, the term depends on m. So the question is, for each i, what is the best m to choose to maximize dp[j-1][m} + max_val[m+1][i}.\n\nBut for each i, the max_val[m+1][i} is the maximum of a[m+1..i}. So for each m, as i increases, max_val[m+1][i} can only increase or stay the same.\n\nWait, perhaps for each j and i, the best m is somewhere in the range 0 to i-1, and perhaps for a given j, we can find the best m in a way that allows us to compute it in O(1) time per i.\n\nBut I'm not seeing it.\n\nAlternative Idea: Let's consider that for each j, the problem is to split the array into j segments, and for each possible end position i, we track the maximum possible profit.\n\nBut perhaps for each j, we can find a way to compute dp[j][i} incrementally, keeping track of some variables that help us compute the maximum quickly.\n\nWait, for each j, let's think about how the maximum can be updated as we process i from 1 to n.\n\nFor j=1, dp[1][i} is simply the maximum of the first i elements.\n\nFor j>1, dp[j][i} is the maximum of (dp[j-1][m} + max_val[m+1..i}) for m < i.\n\nHmm.\n\nWait, let's think about j=2.\n\ndp[2][i} = max over m < i of (dp[1][m} + max_val[m+1..i} )\n\nSince dp[1][m} is the maximum of the first m elements, and max_val[m+1..i} is the maximum of the elements from m+1 to i.\n\nSo for j=2, for each i, we can compute this as:\n\nmax_m (dp[1][m} + max(a[m+1..i} )) \n\nWhich can be rewritten as:\n\nmax_m (max_first_m + max_from_m_plus_1_to_i)\n\nHmm.\n\nWait, perhaps for j=2, we can compute for each i the maximum between m=0 to i-1.\n\nBut again, it's O(n^2) for j=2.\n\nSo, perhaps the problem is not tractable with standard DP approaches due to the O(n^2k) complexity.\n\nWait, but wait—what's the maximum n and k? 2000 each. So 2000^3 is 8e9 operations—probably too slow for Python, which can handle around 1e8 operations per second.\n\nSo we need a better approach.\n\nAlternative Idea: Greedy Approach.\n\nIs there a way to choose the split points greedily to maximize the sum of maxima?\n\nBut greedy approaches are tricky because choosing a certain split point early might prevent better options later.\n\nBut perhaps we can find a way to choose the optimal split points by selecting the positions where including a certain element as a maximum gives the best possible gain.\n\nWait, perhaps the optimal solution is to select the k largest elements as the maxima of the segments, and arrange the segments such that each contains one of these maxima, and covers the required elements.\n\nBut how to ensure that the segments are contiguous.\n\nThis is similar to the problem of arranging intervals to cover the array, with each interval containing exactly one of the top k elements as its maximum.\n\nBut I'm not sure.\n\nWait, for example, in the sample input:\n\na = [5,4,2,6,5,1,9,2], n=8, k=3.\n\nThe top 3 elements are 9,6,5 (but wait, 9 is the maximum, then 6, then 5, etc.)\n\nWait, in the sample solution, the maxima are 5,6,9.\n\nWait, the three segments are [5,4,2], [6,5], [1,9,2]. Their maxima are 5,6,9.\n\nSo the sum is 20.\n\nBut another possible distribution could be [5,4,2,6], [5,1], [9,2], with maxima 6,5,9. Sum is 20.\n\nSo, the selection of the maxima includes the highest possible elements.\n\nSo perhaps the optimal approach is to select the k largest elements as the maxima of the segments, and arrange the segments such that each contains exactly one of them, and the rest of the elements are covered.\n\nBut how to model this.\n\nWait, let's think of the problem as selecting k elements from the array as the maxima of each segment, such that they are in increasing order of their positions, and the sum is maximized.\n\nWait, but that's not necessarily the case. Because a segment's maximum could be anywhere in the array.\n\nBut perhaps the optimal selection is to have the k largest elements as the maxima of the segments.\n\nSo, the plan is:\n\n1. Select the k largest elements in the array.\n\n2. Assign each of them to be the maximum of a segment.\n\n3. Arrange the segments such that each selected maximum is contained in a distinct segment, and the segments are contiguous and cover the entire array.\n\nBut how to do this.\n\nBut wait, the array is processed in order. So each segment must start after the previous segment ends.\n\nHmm.\n\nWait, perhaps for each of the k largest elements, we can assign them to be the maximum of a segment, and then arrange the segments to cover the array.\n\nBut this is getting a bit vague.\n\nAlternative Idea: Since each segment's maximum is one of the elements, perhaps the optimal sum is the sum of the k largest elements. But this is not always possible because the segments have to be contiguous.\n\nWait, for example, suppose the array is [9, 1, 2, 3, 4, 5, 6, 7, 8], and k=2. The two largest elements are 9 and 8. Can we split into two segments where each has one of these as their maximum? Yes: [9,1,2,3,4,5,6,7,8] is one segment, but that's not helpful. Alternatively, [9], [1,2,3,4,5,6,7,8]—sum is 9 +8=17.\n\nBut the sum of the two largest is 9+8=17, which is indeed the maximum possible.\n\nIn the sample, the sum is 5+6+9=20, which is the sum of the top 3 elements.\n\nSo perhaps the optimal solution is to have each of the top k elements be the maximum of their respective segments.\n\nIf this is the case, then the problem reduces to selecting the top k elements, and ensuring that each is the maximum of a segment, and the segments are contiguous.\n\nBut how to model this.\n\nSo, the algorithm could be:\n\n- Find the indices of the top k elements in the array.\n\n- Sort these indices in increasing order.\n\n- Then, assign each element to a segment, such that each segment is as small as possible.\n\nWait, perhaps the steps are:\n\n1. Sort the array in descending order, and pick the top k elements.\n\n2. Record their indices in the original array.\n\n3. Sort these indices in increasing order.\n\n4. Split the array into k segments, each starting after the previous index and ending at or before the next index.\n\nWait, no. Let's think with an example.\n\nSuppose the array is [5,4,2,6,5,1,9,2], and the top 3 elements are 9,6,5.\n\nTheir indices are 6, 3, 4 (0-based? Or 1-based? Let's assume 0-based for now).\n\nSo the indices in order are 6,3,4.\n\nWait, but 3 is before 4, which is before 6.\n\nSo the segments would be:\n\n- From 0 to 2: [5,4,2], max 5.\n\n- From 3 to 3: [6], max 6.\n\n- From 4 to 6: [5,1,9], max 9.\n\nWait, but 9 is in the third segment.\n\nWait, but in the sample solution, the third segment is [1,9,2], which is from 5 to 7 (if 0-based). So the split points are after 2, after 5, and the end.\n\nHmm, perhaps my initial approach is not correct.\n\nAlternatively, perhaps the problem is that the top k elements may not be positioned in such a way that their segments can be formed without overlapping.\n\nSo perhaps the optimal approach is to select the top k elements and form segments that each contain exactly one of them, ensuring that the segments are contiguous and cover the entire array.\n\nBut how to ensure that.\n\nWait, perhaps the optimal sum is indeed the sum of the top k elements, but only if it's possible to split the array into k segments, each containing exactly one of these elements as their maximum, and the segments are contiguous.\n\nBut how to confirm this.\n\nIn the sample, the sum is 5 +6 +9=20. The top 3 elements are 9,6,5, but their sum is 20. So that matches.\n\nAnother example: in the third sample, the array is [1,2000,2000,2], n=4, k=2.\n\nThe top 2 elements are 2000 and 2000.\n\nSum is 4000.\n\nThe optimal split is [1,2000], [2000,2]. Maxima are 2000 and 2000. Sum 4000.\n\nWhich is the sum of the two 2000's.\n\nSo, perhaps the optimal sum is always the sum of the top k elements, provided that the array can be split into k segments each containing exactly one of the top k elements as their maximum, and the segments are contiguous.\n\nBut how to prove this.\n\nWait, suppose that we have the top k elements. Then, each of them can be the maximum of a segment. If the segments can be arranged such that each is a contiguous block, and their union is the entire array, then the sum is the sum of the top k elements.\n\nOtherwise, it's not possible, and we have to choose the next best option.\n\nBut how to determine whether the top k elements can be used as the maxima of k contiguous segments covering the array.\n\nI think this is a crucial point. If the top k elements can be arranged in a way that allows their segments to be formed without overlapping and cover the entire array, then the sum is the sum of these elements.\n\nOtherwise, we have to adjust.\n\nBut how to model this.\n\nWait, perhaps the top k elements can always be arranged in such a way.\n\nBecause, the top k elements can be sorted in the order of their occurrence in the array, and then the segments can be formed between their indices.\n\nFor example, sort the top k elements in the order of their positions, then create segments between each consecutive pair, and the first segment starts from the beginning to the first element, the next from the first element's index +1 to the next, and so on, until the last element.\n\nWait, but this might not cover the entire array.\n\nWait, for example, suppose the array is [9, 8, 7, 6, 5], and k=2.\n\nTop 2 elements are 9 and 8.\n\nThey are at positions 0 and 1.\n\nSo the segments would be [9], [8,7,6,5]. Maxima are 9 and 8. Sum is 17.\n\nWhich is indeed the sum of top 2 elements.\n\nAnother example: array [5,4,2,6,5,1,9,2], n=8, k=3.\n\nTop 3 elements are 9,6,5.\n\nIndices (assuming 0-based): 6,3,4.\n\nSorted indices: 3,4,6.\n\nSo the segments would be:\n\n- 0-2: [5,4,2], max 5.\n\n- 3-3: [6], max 6.\n\n- 4-6: [5,1,9], max 9.\n\nWait, but 9 is the maximum of the entire segment 4-6.\n\nWait, but in the sample solution, the third segment is [1,9,2], which is from 5 to 7 (if 0-based). So perhaps the initial approach is incorrect.\n\nWait, perhaps the segments are formed by placing the top elements as the maximum of their respective segments, but not necessarily the entire segment up to the next top element.\n\nHmm, perhaps the approach is to find the earliest possible segments that allow each top element to be the maximum.\n\nWait, perhaps the correct way is to include each top element as the maximum of a segment, and the segments are formed in a way that each starts just after the previous segment ends.\n\nBut how.\n\nAlternatively, perhaps the optimal approach is to select the top k elements, sort them, and then for each consecutive pair, form a segment that starts from the end of the previous segment to the position of the next top element.\n\nWait, let's see.\n\nTake the sample array: [5,4,2,6,5,1,9,2]\n\nTop 3 elements are 9,6,5.\n\nSort them by their positions: 6 (index 3), 5 (index 4), 9 (index 6).\n\nSo the segments would be:\n\n- 0 to 2: [5,4,2], max 5.\n\n- 3 to 3: [6], max 6.\n\n- 4 to 6: [5,1,9], max 9.\n\nBut the third segment's maximum is 9, which is correct.\n\nBut the third segment in the sample is from 5 to 7: [1,9,2], which also has a max of 9.\n\nSo both options are valid.\n\nWait, but the sum remains the same.\n\nSo perhaps the way the segments are formed doesn't matter as long as the sum is the sum of the top k elements.\n\nThus, perhaps the key insight is that the maximum possible sum is the sum of the top k elements, provided that the array can be split into k contiguous segments, each containing exactly one of these top k elements as their maximum.\n\nIf that's always possible, then the problem reduces to selecting the top k elements, summing them, and then outputting the corresponding segments.\n\nBut how to confirm that it's always possible.\n\nIn the sample, yes. In the third sample, it's possible.\n\nWhat about a case where the top k elements are not in order, making it impossible to split into k segments.\n\nWait, for example, n=5, k=2.\n\nArray: [3, 1, 4, 2, 5].\n\nTop 2 elements are 5 and4.\n\nThey are at indices 4 and 2.\n\nSo sorted indices: 2,4.\n\nSegments would be:\n\n0-1: [3,1], max 3.\n\n2-2: [4], max4.\n\n3-4: [2,5], max5.\n\nSum is 3+4+5=12, but wait, k=2, so sum is 3+5=8? No, wait, no, the segments should be 2.\n\nWait, in this case, the top 2 elements are 5 and4.\n\nSo the sum should be 5+4=9.\n\nBut how to split the array into 2 segments, each containing one of these as maximum.\n\nSegment 1: [3,1,4,2], max4.\n\nSegment 2: [5], max5.\n\nYes, this is possible.\n\nSo the sum is 4+5=9.\n\nWhich is the sum of the top 2 elements.\n\nSo, it seems that it's always possible to split the array into k segments, each containing exactly one of the top k elements as their maximum.\n\nThus, the maximum sum is the sum of the top k elements.\n\nTherefore, the problem reduces to selecting the top k elements, sum them, and then find a way to split the array into k segments, each containing exactly one of these elements as their maximum.\n\nSo, the steps to solve the problem are:\n\n1. Identify the top k elements in the array.\n\n2. Compute their sum as the maximum total profit.\n\n3. Determine how to split the array into k segments, each containing exactly one of these top elements as their maximum, and the segments are contiguous.\n\nNow, the challenge is to implement step 3: find the split points.\n\nSo, how to split the array into k segments, each containing exactly one of the top k elements as their maximum.\n\nApproach:\n\n- Sort the top k elements in the order of their positions.\n\n- The first segment starts from the beginning of the array and ends just before the first top element's index.\n\nWait, no. Let's think.\n\nWe need to create k segments, each containing exactly one top element.\n\nSo, the first segment must include the first top element in the order of positions, the second segment must include the second, and so on.\n\nWait, for example, the top elements are sorted by their indices in increasing order: e1, e2, ..., ek.\n\nThe first segment is from the start to the position of e1 minus 1.\n\nThe second segment is from e1's position to e2's position minus 1.\n\nThe third segment is from e2's position to e3's position minus 1.\n\nAnd so on.\n\nWait, but this may not capture all elements.\n\nWait, perhaps the correct approach is:\n\nThe segments are:\n\n[0, e1.index -1], [e1.index, e2.index -1], ..., [ek.index, n-1]\n\nWait, but this would mean that the first segment is from 0 to e1.index-1, which may not include any elements beyond that.\n\nWait, perhaps that's not correct.\n\nAlternatively, the segments are:\n\nstart from the previous segment's end +1 to the current top element's index.\n\nWait, perhaps the steps are:\n\n1. Sort the top k elements in the order of their positions (ascending).\n\n2. The first segment starts at 0 and ends at e1.index -1.\n\n3. The second segment starts at e1.index, ends at e2.index -1.\n\n4. Continue until the k-th segment starts at ek.index and ends at n-1.\n\nBut this would result in k segments, each containing exactly one top element as the maximum.\n\nBut wait, in the sample, the top 3 elements are 9,6,5.\n\nTheir indices are 6,3,4.\n\nAfter sorting by index: 3 (6),4 (5),6 (9).\n\nSo the segments would be:\n\n0-2: [5,4,2] (max5)\n\n3-3: [6] (max6)\n\n4-6: [5,1,9] (max9)\n\nWhich is correct.\n\nBut in the sample, the third segment is [1,9,2], which starts at 5, but according to this approach, it's from 4 to 6.\n\nWait, perhaps the approach is correct, but the exact way the segments are formed may vary.\n\nBut regardless, the sum is correct.\n\nSo, the steps are:\n\n- Find the top k elements.\n\n- Sort them by their positions.\n\n- Split the array into k segments as described.\n\nThus, the code can proceed as follows:\n\nImplement steps:\n\n1. Read n, k, and the array a.\n\n2. Create a list of tuples (value, index) for each element in a.\n\n",
    "response": "To solve this problem, we need to maximize the total profit Polycarp can achieve by solving problems over k days. Each day, he solves a contiguous sequence of problems, and the profit for each day is the maximum difficulty of the problems solved that day. The goal is to distribute the problems into k days such that the sum of these maxima is maximized.\n\n### Approach\nThe key insight is that the optimal strategy involves selecting the top k elements as the maximum values for each day's work. This ensures that the sum of these maxima is maximized. Here are the steps to achieve this:\n\n1. **Identify the Top k Elements**: Select the top k elements from the array, as each will contribute to the maximum profit.\n2. **Sort the Top k Elements**: Sort these elements based on their positions in the original array to determine how to split the array into contiguous segments.\n3. **Form Segments**: Create k contiguous segments such that each segment contains exactly one of the top k elements as its maximum. This is done by splitting the array at the positions of these top elements.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    # Get indices of top k elements\n    elements = [(val, i) for i, val in enumerate(a)]\n    elements.sort(reverse=True, key=lambda x: x[0])\n    top_k = elements[:k]\n    \n    # Sort top_k by their positions\n    top_k_sorted = sorted(top_k, key=lambda x: x[1])\n    \n    # Split points\n    splits = [0] * (k + 1)\n    for i in range(k):\n        splits[i+1] = top_k_sorted[i][1]\n    \n    # Calculate the total profit\n    total = sum(val for val, idx in top_k)\n    print(total)\n    \n    # Output the split points\n    print(' '.join(map(str, splits[1:])))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of the number of problems `n`, the number of days `k`, and the list of problem difficulties.\n2. **Selecting Top k Elements**: We create a list of tuples where each tuple contains an element and its index. This list is sorted in descending order to easily pick the top k elements.\n3. **Sorting by Position**: The top k elements are then sorted by their positions in the original array to determine how to split the array into contiguous segments.\n4. **Creating Segments**: We create k segments starting from the beginning of the array, ending just before the next top element's position, ensuring each segment contains exactly one of the top k elements as its maximum.\n5. **Output**: The total profit is the sum of the top k elements, and the segments are printed as the required split points.\n\nThis approach ensures that we maximize the total profit by leveraging the highest possible values in the array while maintaining the constraints of contiguous segments.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    # Get indices of top k elements\n    elements = [(val, i) for i, val in enumerate(a)]\n    elements.sort(reverse=True, key=lambda x: x[0])\n    top_k = elements[:k]\n    \n    # Sort top_k by their positions\n    top_k_sorted = sorted(top_k, key=lambda x: x[1])\n    \n    # Split points\n    splits = [0] * (k + 1)\n    for i in range(k):\n        splits[i+1] = top_k_sorted[i][1]\n    \n    # Calculate the total profit\n    total = sum(val for val, idx in top_k)\n    print(total)\n    \n    # Output the split points\n    print(' '.join(map(str, splits[1:])))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 910,
        "completion_token_count": 643,
        "thoughts_token_count": 8193
    }
}