{
    "start": 1758103527.2069435,
    "end": 1758103655.6738346,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about selecting two vouchers such that their durations add up exactly to x, and they don't overlap in time. Also, among all possible pairs, I need to find the one with the minimal total cost. If there are no such pairs, I should return -1.\n\nHmm. So each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1.\n\nI need to select two vouchers, say i and j (i != j), where either ri < lj or rj < li. So they can't overlap at all. Also, the sum of their durations must be exactly x.\n\nSo the plan is: for all possible pairs of vouchers, check if their durations sum to x, and they don't overlap. Among those pairs, find the one with the smallest total cost.\n\nBut wait, n can be up to 2e5, so checking all O(n^2) pairs is impossible because that would be 4e10 operations, which is way too slow.\n\nSo I need a smarter approach.\n\nLet me think about the constraints:\n\nEach voucher's duration is d1 = r1 - l1 + 1, d2 = r2 - l2 + 1. We need d1 + d2 = x.\n\nAlso, the vouchers must not overlap. So the end of one is before the start of the other.\n\nSo for each voucher, I can precompute its duration and see what kind of other voucher would complement it to sum x.\n\nFor example, if a voucher has duration d, then the other must have duration x - d. So for each voucher, I can look for another voucher with duration x - d and non-overlapping.\n\nBut how do I efficiently find such vouchers?\n\nAn alternative approach is to group the vouchers by their duration. For each duration d, we can keep track of all vouchers with that duration.\n\nThen, for each voucher i with duration d, we can look into the group for duration x - d and find all vouchers j that don't overlap with i and have the minimal cost.\n\nWait, but even within a group, finding non-overlapping vouchers could take some time. But perhaps we can structure the data in a way that allows efficient queries.\n\nAnother idea: for each voucher, find all possible vouchers that have duration x - d and whose time ranges do not overlap with it. Then, among these, find the one with the minimal cost and add to the current voucher's cost.\n\nBut again, checking for each voucher all others is O(n^2), which isn't feasible.\n\nHmm, perhaps we can sort the vouchers based on their end times and start times, and for each voucher, find the best possible candidate in the required duration group quickly.\n\nWait, let's think about the non-overlapping condition. For two vouchers i and j, i comes before j, meaning r_i < l_j. Or j comes before i, meaning r_j < l_i.\n\nSo for each voucher, perhaps we can split into two cases: either it's the first part of the pair (ends before the second starts) or the second part (starts after the first ends).\n\nSo for each voucher i, we can consider:\n\nCase 1: i is the first voucher. We need a voucher j with duration x - d_i, and l_j > r_i. We want the j with minimal cost.\n\nCase 2: i is the second voucher. We need a voucher j with duration x - d_i, and r_j < l_i. So j must end before i starts. We need the j with minimal cost.\n\nWait, but in case 2, since i is the second voucher, j must have duration x - d_i, and end before i's start.\n\nSo for each voucher i, we can compute the required duration for the other voucher, which is target = x - d_i.\n\nIf target is negative, skip.\n\nWe need to find all vouchers j where either:\n\n- j's duration is target, and j ends before i starts (r_j < l_i). Then, i is the second voucher.\n\nOR\n\n- j's duration is target, and j starts after i ends (l_j > r_i). Then, i is the first voucher.\n\nWait, no. Wait, if j is the other voucher, then for case 1, j comes after i. So for i as the first, j's duration is target, and j starts after i ends. So j's l_j >= i's r_i + 1.\n\nFor case 2, j is the first voucher, and i comes after, so j's r_j <= i's l_i - 1.\n\nSo for each i, we need to find the minimal cost j in two groups:\n\nGroup A: j's duration is target, and j ends before i starts (r_j < l_i).\n\nGroup B: j's duration is target",
    "response": "To solve this problem, we need to select two non-overlapping vouchers such that their total duration equals exactly x days and their combined cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Problem Analysis**: Each voucher has a start day, end day, and cost. The goal is to find two vouchers whose durations sum to x and do not overlap in time. The key insight is to group vouchers by their duration and efficiently find the best possible non-overlapping pairs.\n\n2. **Grouping by Duration**: Group all vouchers by their duration. This allows us to quickly look for vouchers with a specific required duration when paired with another voucher.\n\n3. **Efficient Search**: For each voucher, determine the required duration of the second voucher needed to sum up to x. Then, check two cases:\n   - Vouchers where the second voucher ends before the current voucher starts.\n   - Vouchers where the second voucher starts after the current voucher ends.\n\n4. **Binary Search Optimization**: Use binary search to efficiently find the minimal cost voucher in the required duration group that meets the non-overlapping condition.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, x = int(input[ptr]), int(input[ptr+1])\n    ptr += 2\n    vouchers = []\n    for _ in range(n):\n        l = int(input[ptr])\n        r = int(input[ptr+1])\n        c = int(input[ptr+2])\n        ptr += 3\n        vouchers.append((l, r, c))\n    \n    # Precompute duration and group by duration\n    duration_groups = {}\n    for voucher in vouchers:\n        d = voucher[1] - voucher[0] + 1\n        if d not in duration_groups:\n            duration_groups[d] = []\n        duration_groups[d].append(voucher)\n    \n    min_total = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i + 1\n        target = x - d_i\n        if target < 0:\n            continue\n        \n        if target not in duration_groups:\n            continue\n        \n        group = duration_groups[target]\n        # Case 1: j comes after i (j's l_j > r_i)\n        # Find j where l_j > r_i, minimal cost\n        # Binary search for the first l_j > r_i\n        # All such j are in the suffix of the sorted list\n        # Since we can't modify the group, sort once\n        if not group:\n            continue\n        # Sort group by l_j\n        sorted_group = sorted(group, key=lambda x: x[0])\n        # Find the first index where l_j > r_i\n        idx = bisect.bisect_right(sorted_group, (r_i, -1, -1), key=lambda x: x[0])\n        if idx < len(sorted_group):\n            min_cost = sorted_group[idx][2]\n            if min_cost < min_total:\n                min_total = min_cost\n        \n        # Case 2: j comes before i (j's r_j < l_i)\n        # Find j where r_j < l_i, minimal cost\n        # So among group, we need j's r_j < l_i\n        # To find this, perhaps we can pre-sort by r_j and use bisect\n        # Alternatively, since the group is already sorted by l_j, maybe not efficient\n        # Alternative approach: create a list sorted by r_j\n        sorted_r = sorted(group, key=lambda x: x[1])\n        pos = bisect.bisect_left(sorted_r, (l_i, -1, -1), key=lambda x: x[1])\n        if pos > 0:\n            min_cost = sorted_r[pos-1][2]\n            if min_cost < min_total:\n                min_total = min_cost\n    \n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookup.\n3. **Iterating Over Vouchers**: For each voucher, the required duration of the complementary voucher is calculated.\n4. **Binary Search**: Efficiently find the minimal cost voucher that either starts after the current voucher ends or ends before the current voucher starts using binary search.\n5. **Result Calculation**: Track the minimum cost of valid pairs and print the result or -1 if no valid pairs exist.\n\nThis approach ensures we efficiently find the optimal solution without checking all possible pairs, making it suitable for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, x = int(input[ptr]), int(input[ptr+1])\n    ptr += 2\n    vouchers = []\n    for _ in range(n):\n        l = int(input[ptr])\n        r = int(input[ptr+1])\n        c = int(input[ptr+2])\n        ptr += 3\n        vouchers.append((l, r, c))\n    \n    # Precompute duration and group by duration\n    duration_groups = {}\n    for voucher in vouchers:\n        d = voucher[1] - voucher[0] + 1\n        if d not in duration_groups:\n            duration_groups[d] = []\n        duration_groups[d].append(voucher)\n    \n    min_total = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i + 1\n        target = x - d_i\n        if target < 0:\n            continue\n        \n        if target not in duration_groups:\n            continue\n        \n        group = duration_groups[target]\n        # Case 1: j comes after i (j's l_j > r_i)\n        # Find j where l_j > r_i, minimal cost\n        # Binary search for the first l_j > r_i\n        # All such j are in the suffix of the sorted list\n        # Since we can't modify the group, sort once\n        if not group:\n            continue\n        # Sort group by l_j\n        sorted_group = sorted(group, key=lambda x: x[0])\n        # Find the first index where l_j > r_i\n        idx = bisect.bisect_right(sorted_group, (r_i, -1, -1), key=lambda x: x[0])\n        if idx < len(sorted_group):\n            min_cost = sorted_group[idx][2]\n            if min_cost < min_total:\n                min_total = min_cost\n        \n        # Case 2: j comes before i (j's r_j < l_i)\n        # Find j where r_j < l_i, minimal cost\n        # So among group, we need j's r_j < l_i\n        # To find this, perhaps we can pre-sort by r_j and use bisect\n        # Alternatively, since the group is already sorted by l_j, maybe not efficient\n        # Alternative approach: create a list sorted by r_j\n        sorted_r = sorted(group, key=lambda x: x[1])\n        pos = bisect.bisect_left(sorted_r, (l_i, -1, -1), key=lambda x: x[1])\n        if pos > 0:\n            min_cost = sorted_r[pos-1][2]\n            if min_cost < min_total:\n                min_total = min_cost\n    \n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 678,
        "completion_token_count": 1020,
        "thoughts_token_count": 1025
    }
}