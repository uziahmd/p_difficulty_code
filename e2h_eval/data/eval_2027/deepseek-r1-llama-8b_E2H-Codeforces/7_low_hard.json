{
    "start": 1758103653.961057,
    "end": 1758103772.1490033,
    "start-formatted": "2025-09-17 19:07 KST",
    "end-formatted": "2025-09-17 19:09 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about determining whether a certain number of vertices n can form a snowflake graph as defined by Rudolf. The snowflake graph has specific construction rules. \n\nHmm, let me try to understand the structure. So, the snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices, where k is greater than 1. Then, each vertex that has only one edge (so degree 1) must be connected to k new vertices. And importantly, this step has to be done at least once.\n\nWait, right. So the initial step adds k children. Then, each of those children will add k more, but only if they are leaves (degree 1). But wait, after adding the first layer, each of the k nodes becomes a parent with k children. So for each such node, we add k children, which are leaves. So in the next step, each of these new leaves also needs to add k children, but since the problem says the step should be done at least once, that implies that after the initial addition, there's another step where all leaves (the ones added in the previous step) add their own k children.\n\nSo the snowflake graph is built in layers. The first layer is the root, then the second layer has k nodes. The third layer has k^2 nodes, and so on, depending on how many steps are taken.\n\nWait, no. Because each step applies to all current leaves. So for each step, the number of leaves increases. Let me model this.\n\nLet me think recursively. Each time, every leaf (those with only one connection) adds k new children. So each such leaf becomes a parent and adds k new nodes. So for each existing leaf, after the step, it has k+1 edges: one to its parent and k to its children.\n\nWait, no. Wait, when a node is a leaf, it has degree 1. After adding k children, it now has degree 1 + k = k+1. So the new nodes are all leaves.\n\nSo the process is:\n\n- Start with 1 node.\n- Step 1: Add k children to the root. Now total nodes is 1 + k.\n- Step 2: For each of the k leaves, add k children each. So each contributes k nodes. So total added is k * k = k². So total nodes becomes 1 +k +k².\n- Step 3: Now, each of the k² leaves adds k children, adding k³ nodes. Total is 1 +k +k² +k³.\nAnd so on.\n\nWait, but according to the problem statement, the step where each leaf adds k children must be done at least once. So the minimal case is when step 1 is done, and step 2 is done once.\n\nSo the minimal possible snowflake is when after the initial root, each of the k children adds k children. So the minimal structure has 1 +k +k² nodes.\n\nBut wait, maybe not. Because perhaps step 2 isn't done. Oh, no. The problem says that each vertex that is connected by only one edge must be connected to k new vertices, and this step should be done at least once. So the initial step is step 0: 1 node. Then step 1: add k children. Then, step 2: each of the k children adds k, so k² added. So the minimal is 1 +k +k².\n\nWait, but perhaps the step could be done multiple times. Like, each time all leaves add k children. So the number of steps can vary.\n\nWait, but what determines the total number of nodes? It depends on how many times the step is applied beyond the initial.\n\nWait, perhaps it's better to model the total nodes as a geometric series.\n\nLet me denote m as the number of steps performed after the initial. So initially, we have 1 node. Then step 1 adds k nodes, making 1 +k. Then, each step adds k^m, where m is the number of times we perform the step.\n\nWait, no. Wait, the initial root is 1 node. Then, the first step (step 1) adds k nodes, making 1 +k. Then, step 2 adds k*k nodes, because each of the k leaves adds k nodes. So total is 1 +k +k². Then step 3 would add k^3 nodes, leading to 1 +k +k² +k³. So in general, after s steps, the total is 1 +k(1 +k +k² + ... +k^{s-1}).\n\nWait, no. Because the initial step is step 1: adds k nodes, so 1 +k. Then step 2: adds k^",
    "response": "To solve this problem, we need to determine if a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in a specific way, and our task is to check if such a structure can exist for the given \\( n \\).\n\n### Approach\nThe snowflake graph is built in layers, starting from a single root node. Each layer expands the graph by adding new nodes based on specific rules:\n1. The initial node is connected to \\( k \\) new nodes.\n2. Each leaf node (a node with only one edge) must then connect to \\( k \\) new nodes, and this step must be performed at least once.\n\nThe total number of nodes in the snowflake graph after \\( m \\) steps (including the initial step) can be expressed as a geometric series. Specifically, for each \\( k > 1 \\), the total number of nodes \\( n \\) must fit the form:\n\\[ n = 1 + k + k^2 + k^3 + ... + k^m \\]\nwhere \\( m \\) is the number of steps taken beyond the initial root.\n\nTo determine if \\( n \\) can form a snowflake graph, we need to check if \\( n \\) can be written in the form of a geometric series sum for some \\( k > 1 \\) and some number of steps \\( m \\geq 1 \\).\n\n### Solution Code\n```python\nimport sys\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Check if n-1 is a sum of a geometric series.\n    s = n - 1  # subtract the root\n    # We need s = k*(k^m - 1)/(k-1)\n    # Or s = 1 + k + k^2 + ... + k^{m}\n    # So s should be equal to (k^{m+1} - 1)/(k-1)\n    max_k = int((s)**0.5) + 2\n    for k in range(2, max_k + 1):\n        if k == 1:\n            continue\n        # We need to find m such that s = (k^{m+1} - 1)/(k-1)\n        target = s\n        current_sum = 0\n        m = 0\n        while True:\n            current_sum += k**m\n            if current_sum > target:\n                break\n            if current_sum == target:\n                return True\n            m += 1\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline().strip())\n    if n == 1:\n        print(\"NO\")\n        continue\n    if is_snowflake(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```\n\n### Explanation\n1. **Reading Input:** We read the number of test cases and each test case value \\( n \\).\n2. **Check for Small Values:** If \\( n \\) is less than 3, it cannot form a valid snowflake graph.\n3. **Geometric Series Check:** For each \\( n \\), we check if \\( n-1 \\) can be expressed as a sum of a geometric series starting from \\( k=2 \\) up to a reasonable maximum value of \\( k \\).\n4. **Sum Calculation:** For each \\( k \\), we iteratively compute the sum of the series until it either matches \\( n-1 \\) or exceeds it. If a match is found, \\( n \\) can form a snowflake graph.\n\nThis approach efficiently checks each possible \\( k \\) and determines if a valid snowflake structure can be formed, ensuring correctness and handling large values of \\( n \\) up to \\( 10^{18} \\).",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Check if n-1 is a sum of a geometric series.\n    s = n - 1  # subtract the root\n    # We need s = k*(k^m - 1)/(k-1)\n    # Or s = 1 + k + k^2 + ... + k^{m}\n    # So s should be equal to (k^{m+1} - 1)/(k-1)\n    max_k = int((s)**0.5) + 2\n    for k in range(2, max_k + 1):\n        if k == 1:\n            continue\n        # We need to find m such that s = (k^{m+1} - 1)/(k-1)\n        target = s\n        current_sum = 0\n        m = 0\n        while True:\n            current_sum += k**m\n            if current_sum > target:\n                break\n            if current_sum == target:\n                return True\n            m += 1\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline().strip())\n    if n == 1:\n        print(\"NO\")\n        continue\n    if is_snowflake(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 534,
        "completion_token_count": 800,
        "thoughts_token_count": 1025
    }
}