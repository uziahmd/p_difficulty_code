{
    "start": 1758142319.4032428,
    "end": 1758143843.584593,
    "start-formatted": "2025-09-18 05:51 KST",
    "end-formatted": "2025-09-18 06:17 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about selecting souvenirs such that their total weight doesn't exceed m, and the total cost is maximized. The constraints are that each souvenir has a weight between 1 and 3, inclusive. So, n can be up to 100,000 and m up to 300,000. Hmm, that's a pretty big size, so we need an efficient solution.\n\nWait, the sample input shows that for each test case, there are three outputs. Oh right, because the possible weights are 1, 2, or 3, so each test case corresponds to one of those. So, the idea is to compute for each possible weight (1, 2, 3) the maximum cost possible without exceeding the weight limit m.\n\nSo, for each weight w (1,2,3), we need to select items with total weight <= m - w, but no, wait, maybe not. Wait, no, the selection is based on the sum of the chosen items' weights being <= m. But since some items have different weights, perhaps it's better to precompute for each possible capacity the maximum cost achievable.\n\nWait, but how do we approach this? Since n is large, we can't do a straightforward dynamic programming approach for each possible weight combination, as that might be too slow.\n\nAlternative approach: group the items by their weight. For example, collect all items with weight 1, 2, and 3 into separate lists. Then, for each possible subset of these groups, calculate the maximum cost.\n\nBut even that might be tricky because the number of subsets is 2^3=8, which is manageable. Because for each of the 8 combinations of including certain numbers of 1, 2, and 3-weight items, we can find the maximum cost.\n\nWait, but that's not entirely accurate because the number of 1, 2, 3-weight items can vary, and for each combination, we have to choose how many of each to take, ensuring that the total weight doesn't exceed m.\n\nSo here's an outline of the plan:\n\n1. Separate the items into three groups: w1, w2, w3, where each group contains the items of that weight.\n2. Sort each group in descending order of cost, so that we can pick the most valuable items first.\n3. For each possible combination of taking x items from w1, y from w2, and z from w3, compute if x + 2y + 3z <= m. Among all valid combinations, find the one with the maximum cost.\n4. We need to consider all possible x, y, z within the limits of each group's sizes and the total weight constraint.\n\nBut considering all possible x, y, z could be computationally intensive, especially since the group sizes can be up to 1e5 each. That would lead to O(1e15) operations, which is impossible.\n\nHmm, so we need a smarter way. Maybe for each possible count of 3-weight items, find the best possible combination of 2 and 1-weight items that fit the remaining weight.\n\nAlternatively, think about the problem as a variation of the knapsack problem, but with specific constraints on item weights (only 1, 2, 3). This allows us to find an efficient solution.\n\nWait, another approach: use dynamic programming for each possible weight, but considering that the maximum weight is 3, perhaps we can model the DP in a way that handles each weight class efficiently.\n\nLet me think about the dynamic programming approach. Normally, for the 0-1 knapsack problem, the DP state is dp[i][w] = maximum value with the first i items and total weight <=w. But with n up to 1e5 and m up to 3e5, a standard DP would be O(nm) which is 3e10—way too slow.\n\nSo, we need a way to optimize this. Since the weights are small (only 1, 2, 3), perhaps we can exploit that.\n\nLet me try to structure the DP as follows: for each possible remainder modulo 3, keep track of the maximum cost achievable for each possible weight.\n\nWait, here's an alternative idea inspired by the fact that the weights are 1, 2, and 3. We can model the problem using multiple layers of DP, each representing the current modulo of the total weight when divided by 3. This way, each step can process the items of a particular weight and update the DP accordingly.\n\nLet me explain. The total weight can be up to 3e5. For each possible weight mod 3 (i.e., 0, 1, 2), we can track the maximum cost achievable for a weight equal to that mod. For example, dp[r] represents the maximum cost when the total weight is congruent to r modulo 3.\n\nInitially, dp[0] = 0, and dp[1] and dp[2] might be set to negative infinity or something, as they are initially unreachable.\n\nThen, for each item, depending on its weight, we can update the DP:\n\nFor example, suppose we have an item with weight 1 and cost c. For each possible state r, adding this item would transition to (r+1) mod 3, and add c to the cost if it's better than the existing state.\n\nWait, but since items are processed one by one, and each can be taken or not, perhaps we can model this as a sliding window approach for each possible mod.\n\nBut I'm not sure. Alternatively, since each item can only contribute to certain mod states, perhaps we can represent the DP as an array of size 3, where each element holds the maximum cost for that mod.\n\nWait, let me think about this more clearly.\n\nEach item has a weight w_i and a cost c_i. For each possible mod r (0, 1, 2), we can see what adding this item would do.\n\nFor example, if the item's weight is 1, then for any current state s, adding this item would transition to (s + 1) mod 3. So, for each state s, the new state is (s+1)%3, and the cost increases by c_i if we take this item.\n\nBut wait, the issue is that when adding an item, the previous state could have been s, and adding the item's weight would make it s + w_i. But since the modulus is 3, we can model this as transitions between the mod states.\n\nWait, perhaps the approach is as follows:\n\nWe maintain a DP array where dp[r] represents the maximum cost achievable with a total weight that is congruent to r modulo 3. So for each item, we can process it and update the DP.\n\nFor each item with weight w and cost c:\n\n- For each possible current mod state s (0, 1, 2), we can choose whether to take the item or not.\n- If we don't take it, the state remains s.\n- If we take it, the new weight becomes (s + w) mod 3, and the cost increases by c.\n- However, we need to consider that taking the item may change the weight beyond just the mod. But since the weight can be up to m, which is 3e5, it's not feasible to track every possible weight.\n\nAh, right. So, the key insight is that for any weight, the mod 3 gives us the necessary information to manage transitions. But the actual weight could be higher than 3, so we need a way to track the maximum cost for each possible mod and for each possible weight in that mod.\n\nWait, perhaps another approach is needed. Let me think about the problem differently.\n\nSince the weights are small, perhaps the optimal solution can be found by trying all possible numbers of 3-weight items, and for each, find the best combination of 2 and 1-weight items that fit within the remaining weight.\n\nSo, for each possible z (number of 3-weight items), we can compute the maximum possible x (number of 1-weight items) and y (number of 2-weight items) such that 3z + x + 2y <= m.\n\nBut z can range up to min(m //3, len(w3)). Similarly for x and y.\n\nBut again, for each z, how do we efficiently find the best x and y?\n\nAnother thought: the 1, 2, and 3-weight items can be handled as three separate knapsacks. So, for each possible z (number of 3s taken), the remaining weight is m_remaining = m - 3z. Then, the problem reduces to solving a 2D knapsack with items of weight 1 and 2, and total weight <= m_remaining.\n\nWait, but even that could be time-consuming if not optimized.\n\nWait, perhaps for each possible z, the maximum number of 3s we can take is min(k, m//3), where k is the number of 3s available. Then, for each z, we can compute the maximum possible sum of 2s and 1s that fit into m' = m - 3z.\n\nBut even that could be expensive if done naively. So, perhaps we can precompute prefix sums for 2s and 1s, sorted in descending order.\n\nYes, that makes sense.\n\nSo, steps:\n\n1. Separate the items into three groups: w1, w2, w3. Each group will be sorted in descending order of cost. So, for w1, we sort in such a way that the highest cost comes first. Same for w2 and w3.\n\n2. Precompute prefix sums for each group. For each i, prefix_w1[i] is the sum of the top i items in w1. Similarly for prefix_w2 and prefix_w3.\n\n3. Now, for each possible z (number of 3s taken), we can iterate over z from 0 to min(z_max, len(w3)), where z_max is the maximum number of 3s that can fit into m (i.e., m//3). For each z, the remaining weight is m_rem = m - 3*z. Then, we need to find the maximum number of 2s and 1s that can fit into m_rem.\n\nBut how do we compute this efficiently?\n\nThe problem now reduces to, given a list of 2s and a list of 1s, each sorted by cost, find the maximum sum of costs such that the total weight is at most m_rem.\n\nThis is similar to the classic unbounded knapsack problem, except that each item can be taken at most once.\n\nWait, no, it's the 0-1 knapsack problem for two groups: 2s and 1s, with their own counts.\n\nSo, for a given m_rem, the maximum sum is the maximum of all possible (a + b), where a is the number of 2s taken, b is the number of 1s, such that 2a + b <= m_rem.\n\nBut how to compute this quickly.\n\nHmm, perhaps for each possible z, we can precompute the maximum possible sum for the 2s and 1s that fit into m_rem.\n\nWait, but for each z, m_rem can be up to 3e5, which is manageable.\n\nBut computing this for each z would still take O(n) per z, which is 1e5 * 1e5 = 1e10 operations, which is way too slow.\n\nSo, we need a better way.\n\nWait, perhaps we can model this as a two-dimensional problem.\n\nFor the 2s and 1s, the maximum cost for a given weight limit can be computed using a dynamic programming approach, but considering that each item can be taken only once.\n\nWait, but for each possible m_rem, the maximum cost is the sum of the top 2s and 1s that fit into m_rem.\n\nSo, for each possible m_rem, the maximum cost is the maximum of all possible a and b where 2a + b <= m_rem, and a is up to the size of w2, and b up to the size of w1.\n\nTo compute this efficiently, perhaps we can precompute for all possible m_rem (up to 3e5) the maximum cost achievable by combining 2s and 1s.\n\nWait, that seems feasible.\n\nSo, here's the plan:\n\n- Preprocess the 2s and 1s into their prefix sums, sorted in descending order.\n\n- For all possible m_rem from 0 to m, compute the maximum cost achievable by taking some 2s and 1s.\n\nOnce we have this, for each possible z, we can look up the maximum cost for m_rem = m - 3z, and keep track of the overall maximum across all z.\n\nBut how to compute this for all m_rem efficiently.\n\nHmm.\n\nThe 2s and 1s are two separate groups. So, for each possible m_rem, the maximum cost is the sum of the top a 2s and top b 1s, where 2a + b <= m_rem.\n\nWe can model this as a two-step process: for each possible a, find the maximum b such that 2a + b <= m_rem, and take the sum of the top a 2s and top b 1s.\n\nBut doing this for each a and each m_rem is O(1e5 * 3e5) = 3e10 operations—way too slow.\n\nAlternative idea: for each a, compute the maximum possible b for any m_rem, and precompute the cumulative cost for each a and b.\n\nWait, perhaps the following approach:\n\nCompute the prefix sums for 2s and 1s.\n\nThen, for each possible a (number of 2s taken), the maximum possible b is floor( (m_rem - 2a) / 1 ). So for each a, the maximum b is m_rem - 2a, but cannot exceed the size of w1.\n\nThus, for a fixed a, the maximum possible b is min( (m_rem - 2a), len(w1) ).\n\nSimilarly, for each a, the total cost is prefix_w2[a] + prefix_w1[b], where b is the maximum possible given a.\n\nBut even this approach requires, for each m_rem, to loop through all possible a and find the best a that maximizes the sum.\n\nBut this is again O(1e5) per m_rem, which is 3e5 * 1e5 = 3e10 operations—way too slow.\n\nSo, that's not feasible.\n\nAnother idea: for each m_rem, the optimal a is such that 2a is as large as possible without exceeding m_rem, but also considering the trade-off between the cost of 2s and 1s.\n\nBut I'm not sure how to model this.\n\nWait, perhaps we can model this as a two-dimensional problem where for each possible a, the maximum possible cost is known, and then for each m_rem, the maximum is the maximum over a of (prefix_w2[a] + prefix_w1[ min( (m_rem - 2a), len(w1) ) ]).\n\nBut again, for each m_rem, this is O(1e5) operations, which is not feasible.\n\nSo, perhaps another angle: the problem is a variation of the unbounded knapsack but with items of two different types (2 and 1), each with their own counts.\n\nWait, but 2s and 1s are both 0-1 items, so it's a 0-1 knapsack with two groups.\n\nI recall that there's a way to handle two groups together in the knapsack using a more efficient approach.\n\nAnother idea: the 2s and 1s can be combined into a single list of items, but that's not helpful because 2 and 1 are different.\n\nAlternatively, perhaps for each possible a (number of 2s taken), the maximum b is determined, and then the total cost is the sum of the top a 2s and top b 1s.\n\nBut again, the challenge is to compute this for all possible m_rem efficiently.\n\nWait, perhaps for each a, the maximum b is determined as (m_rem - 2a), but constrained by the number of 1s available. So, for each a, the maximum cost is prefix_w2[a] + prefix_w1[ min( (m_rem - 2a), len(w1) ) ].\n\nBut how do we find the a that maximizes this sum for each m_rem.\n\nHmm.\n\nWait, perhaps for each m_rem, the optimal a is somewhere around m_rem / 2, but that's not necessarily the case because the 2s may have lower cost per unit weight than 1s.\n\nSo, perhaps for each m_rem, the optimal a is the one that gives the maximum (prefix_w2[a] + prefix_w1[ (m_rem - 2a) ] ), but we have to cap (m_rem - 2a) at the length of w1.\n\nBut again, computing this for each m_rem is O(1e5) per m_rem, which is too slow.\n\nSo, perhaps instead of processing each m_rem individually, we can precompute for each a the maximum possible cost for a given m_rem, and then for each m_rem, find the best a.\n\nBut I'm not seeing a clear way forward.\n\nAlternative approach: realize that the maximum m_rem is 3e5, which is manageable for a 1D DP.\n\nLet me model this as a 1D DP for the 2s and 1s.\n\nWe can create a DP array where dp[m] is the maximum cost achievable with a total weight of exactly m.\n\nBut since the items are 0-1, perhaps we can use a standard 0-1 knapsack approach.\n\nWait, but the standard 0-1 knapsack approach for two groups (2s and 1s) can be optimized by handling the items in a certain order.\n\nHere's a plan:\n\n- Sort the 2s in descending order of cost.\n- Sort the 1s in descending order of cost.\n\n- For each possible weight from high to low, update the dp array by considering whether to include the next 2 or 1.\n\nBut this might work as follows:\n\nInitialize dp[0] = 0, and others as -infinity or zero.\n\nThen, for each 2 in w2:\n    for j from m down to 2:\n        if j >= 2 and dp[j - 2] + c2 > dp[j]:\n            dp[j] = dp[j - 2] + c2\n\nThen, for each 1 in w1:\n    for j from m down to 1:\n        if j >=1 and dp[j -1] + c1 > dp[j]:\n            dp[j] = dp[j -1] + c1\n\nWait, but that's for the 0-1 knapsack. But considering that the items are processed one by one, and for each item, the DP is updated in reverse.\n\nBut in this case, the problem is that the 2s and 1s are both processed as individual items. So, the order of processing (2s first or 1s first) doesn't matter as long as each is considered in a way that prevents reusing items.\n\nWait, but in this setup, each 2 and 1 is considered once, and the DP is built accordingly.\n\nBut wait, for the 2s, each 2 can be taken or not, and similarly for the 1s.\n\nSo, processing all 2s first, then all 1s, should correctly model the 0-1 knapsack for the combination of 2s and 1s.\n\nBut the problem is that the order in which the 2s are processed may affect the outcome. So, we need to process them in a way that takes the most valuable first.\n\nYes, so the plan is:\n\n- Sort the 2s in descending order of cost.\n- Sort the 1s in descending order of cost.\n- Process the 2s first, then the 1s, updating the DP accordingly.\n\nThis way, for each possible weight, the DP keeps track of the maximum cost achievable.\n\nOnce the DP is filled, for each possible z (number of 3s taken), the maximum cost is dp[m_rem] + prefix_w3[z], where m_rem = m - 3*z.\n\nSo, putting it all together:\n\nSteps:\n\n1. Read all items and separate into w1, w2, w3.\n\n2. Sort each group in descending order of cost.\n\n3. Compute prefix sums for each group.\n\n4. Initialize a DP array where dp[w] represents the maximum cost for weight w using only 2s and 1s.\n\n   - Initialize dp[0] = 0, and all other dp[w] = 0 (since initial state is empty).\n\n5. Process the 2s in descending order:\n\n   For each c in w2:\n       for w from m down to 2:\n           if dp[w - 2] + c > dp[w]:\n               dp[w] = dp[w - 2] + c\n\n6. Process the 1s in descending order:\n\n   For each c in w1:\n       for w from m down to 1:\n           if dp[w - 1] + c > dp[w]:\n               dp[w] = dp[w -1] + c\n\n7. Compute the prefix sums for the 3s:\n\n   prefix_w3[0] = 0\n   for i in 1 to len(w3):\n       prefix_w3[i] = prefix_w3[i-1] + w3[i-1].cost\n\n8. For each possible z (number of 3s taken), from 0 to min(len(w3), m //3):\n\n   a. Compute m_rem = m - 3*z\n\n   b. If m_rem <0: skip\n\n   c. The maximum cost for this z is prefix_w3[z] + dp[m_rem]\n\n   d. Keep track of the overall maximum cost.\n\n9. The answer is the maximum cost found across all z.\n\nWait, but wait: the DP for 2s and 1s is for exactly m_rem weight. But in reality, the total weight can be up to m_rem. So, for m_rem, the maximum cost is dp[m_rem].\n\nBut what if m_rem is less than the maximum possible weight for 2s and 1s? Like, perhaps taking fewer than m_rem weight would yield a higher cost.\n\nWait, no. Because we want the maximum cost, which could require taking any weight up to m_rem. So, for example, if taking a total weight of w <= m_rem, the maximum cost is the maximum dp[w] for w <= m_rem.\n\nSo, the initial approach only considers dp[m_rem], which may not capture the best case where a weight less than m_rem gives a higher cost.\n\nThat's a problem. So, the approach above is incorrect.\n\nSo, we need to find the maximum dp[w] for all w <= m_rem.\n\nHmm, that complicates things.\n\nSo, the correct approach is, for each m_rem, to find the maximum dp[w] where w ranges from 0 to m_rem.\n\nHow can we compute this quickly for all possible m_rem?\n\nWell, after building the dp array, which represents the maximum cost for each exact weight, we can precompute a max array, where max_cost[w] is the maximum dp value from 0 to w.\n\nThen, for a given m_rem, the maximum cost is max_cost[m_rem].\n\nSo, the steps become:\n\nAfter step 6, compute the max_cost array:\n\nmax_cost[0] = dp[0]\nfor w from 1 to m:\n    max_cost[w] = max(max_cost[w-1], dp[w])\n\nThen, for each z, m_rem = m - 3z. If m_rem >=0, the cost is prefix_w3[z] + max_cost[m_rem].\n\nThis way, we're considering all possible weights up to m_rem.\n\nSo, the revised steps are:\n\n7. Compute the prefix sums for the 3s.\n\n8. Compute max_cost array for 2s and 1s.\n\n9. For each z, calculate m_rem = m - 3z. If m_rem >=0, the current cost is prefix_w3[z] + max_cost[m_rem]. Track the maximum.\n\nThis seems correct.\n\nNow, let's think about the computational steps and their efficiency.\n\n- Sorting each group: O(n log n) for each group, which is acceptable for n=1e5.\n\n- Prefix sums: O(n) per group.\n\n- Processing 2s and 1s in the DP: O(m) for 2s, and O(m) for 1s. Since m is up to 3e5, this is manageable.\n\n- Computing max_cost: O(m) time.\n\n- Then, for each z (up to 1e5), it's O(1) per z to get the cost, and O(1) to compare to the maximum.\n\nSo, the total time should be acceptable.\n\nNow, let's think about the initial DP setup.\n\nWait, the initial DP is initialized to zero for all weights. But this isn't correct because taking nothing gives zero cost. But when you process the 2s and 1s, you can have various combinations that may give a higher cost than zero.\n\nWait, but the initial DP should be set to -infinity except for dp[0] = 0, right? Because otherwise, you might accidentally take items that sum to a higher weight but lower cost than just not taking anything.\n\nWait, for example, if an item with weight 2 and cost 1 is added, and m_rem is 2, then dp[2] would be 1. Which is better than not taking it (which is zero). So the initial setup should be that dp starts with all zeros, but during the processing, higher costs are added.\n\nNo, that's not correct. Because initially, without any items, the maximum cost for any weight is zero. So, when processing the items, you can only increase the cost.\n\nWait, no. Because, for example, if you have a 2-weight item with cost 5, then for m_rem=2, the cost is 5, which is better than zero. So the initial DP must be correctly initialized to zero.\n\nWait, perhaps the initial DP should be set to -infinity except for dp[0] = 0. Because for all other weights, you can't achieve a cost higher than zero unless you take some items.\n\nWait, no, that's not correct either. Because when you process the items, you can add their costs to the dp array.\n\nWait, perhaps the initial DP should be all -infinity, except dp[0] = 0. Because before processing any items, the maximum cost is zero (taking nothing). Then, as items are processed, the dp array is filled with the maximum cost achievable for each weight.\n\nYes, that's correct. So, the initial setup is:\n\ndp = [-infinity] * (m + 1)\ndp[0] = 0\n\nThen, for each 2 and 1, we update the dp array in the standard 0-1 knapsack way.\n\nSo, let's proceed with that.\n\nNow, implementing this in Python.\n\nFirst, let's read the input.\n\nRead n and m.\n\nThen, read n lines, each with wi and ci.\n\nGroup them into w1, w2, w3.\n\nSort each group in descending order of ci.\n\nCompute prefix sums for each group.\n\nProcess the 2s and 1s into a DP array.\n\nCompute the max_cost array for the 2s and 1s.\n\nCompute the prefix sums for the 3s.\n\nIterate over z from 0 to min(len(w3), m//3), and for each, compute the current cost as prefix_w3[z] + max_cost[m_rem], where m_rem = m -3*z.\n\nKeep track of the maximum.\n\nFinally, output the maximum for each of the three possible weights (but wait, the problem expects three outputs corresponding to the maximum for each possible weight, but the question says that the output is three numbers. Wait, no, looking back at the problem statement, the sample output shows three numbers, but in the problem description, it's stated that Petya wants to choose a subset whose total weight is not greater than m, and the maximum cost.\n\nWait, no, the problem says to output the maximum possible total cost, regardless of the weight. So, why does the sample have three outputs?\n\nWait, looking back, the sample input is:\n\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\nAnd the output is ['0', '3', '10'].\n\nWait, perhaps each test case is grouped by the weight of the items, but that's not the case. No, I think the sample is for three test cases, each with different parameters.\n\nWait, the problem statement says that the input is followed by n lines of wi and ci, so the sample input is showing three test cases, each with different n and m.\n\nSo, the output is three lines, each for a different test case.\n\nSo, in our code, after processing each test case, we output one line.\n\nSo, the code needs to process each test case, compute the maximum cost, and print it.\n\nSo, the code structure is:\n\nRead the entire input, split into test cases.\n\nFor each test case:\n\n   read n and m\n\n   read n lines, group into w1, w2, w3.\n\n   process as described.\n\n   output the maximum cost.\n\nSo, now, in the code.\n\nImplementing the steps:\n\nRead n and m.\n\nRead the next n lines, each as wi and ci.\n\nGroup them into w1, w2, w3.\n\nSort each group in descending order of ci.\n\nCompute prefix sums:\n\nprefix_w1: prefix_w1[i] is sum of first i elements.\n\nSame for w2 and w3.\n\nProcess the 2s and 1s into the DP:\n\nInitialize dp = [ -inf for _ in range(m+1) ]\n\ndp[0] = 0\n\nFor each c in w2:\n\n   for w in range(m, 2-1, -1):\n\n       if dp[w-2] + c > dp[w]:\n\n           dp[w] = dp[w-2] + c\n\nThen, for each c in w1:\n\n   for w in range(m, 0, -1):\n\n       if dp[w-1] + c > dp[w]:\n\n           dp[w] = dp[w-1] + c\n\nCompute max_cost array:\n\nmax_cost[0] = dp[0]\n\nfor w in 1 to m:\n\n   max_cost[w] = max( max_cost[w-1], dp[w] )\n\nCompute the prefix_w3:\n\nprefix_w3[0] =0\n\nfor i in 1..len(w3):\n\n   prefix_w3[i] = prefix_w3[i-1] + w3[i-1].ci\n\nNow, for each z in 0 to min( len(w3), m//3 ):\n\n   m_rem = m - 3*z\n\n   if m_rem <0: continue\n\n   current_cost = prefix_w3[z] + max_cost[m_rem]\n\n   if current_cost > global_max:\n\n       global_max = current_cost\n\nAlso, consider not taking any 3s:\n\nWait, yes, because z can be zero.\n\nSo, the maximum is the maximum among all possible z.\n\nAdditionally, we need to consider the case where we don't take any 3s.\n\nSo, after computing all possible z, the global_max will hold the maximum cost.\n\nNow, let's think about edge cases.\n\nCase 1: m is zero. Then, no items can be taken, so the cost is zero.\n\nCase 2: All items have weight higher than m. Then, the cost is zero.\n\nCase 3: Some items can fit, but the best combination is all 3s, or all 2s and 1s.\n\nWhat about when m is very small, like 1? Then, only 1-weight items can be considered.\n\nAnother edge case: when m is 0, regardless of other factors, the cost is zero.\n\nNow, in the code, after processing all z, the global_max will be the correct answer.\n\nSo, putting it all together.\n\nPotential issues:\n\n- The DP arrays can be very large (3e5 +1 elements), but in Python, this is manageable.\n\n- The initial DP is correctly set to -infinity, except for 0.\n\n- The processing of 2s and 1s must be done in the correct order (2s first, then 1s), and in reverse order for the loops.\n\nTesting the code with the sample input.\n\nSample Input:\n\n3 test cases.\n\nFirst test case:\n\nn=1, m=1\n\nItem: 1 1.\n\nSo, w1 has [1], w2 and w3 are empty.\n\nProcessing 2s: none.\n\nProcessing 1s: take 1.\n\nSo, dp[0] =0, dp[1]=1.\n\nmax_cost for m_rem=1 is 1.\n\nThen, for 3s: can't take any (m=1, 3>1). So z=0.\n\nTotal cost is prefix_w3[0] + max_cost[1] =0+1=1.\n\nBut the sample output for this case is 0. Wait, no, the sample output in the problem is 0,3,10.\n\nWait, the first test case in the sample input is:\n\nInput:\n1 1\n1 1\n\nOutput: 0.\n\nWait, why?\n\nBecause the total weight is 1, but the cost is 1. So why is the output 0?\n\nWait, no, perhaps I misread the sample input.\n\nLooking back:\n\nIn the problem statement, the sample input is written as:\n\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\nWait, perhaps it's three test cases, each represented as a string.\n\nSo, the first test case is:\n\nn=1, m=1.\n\nItem: 1 1.\n\nSo, the maximum cost is 1, but the sample output for the first test case is 0. Hmm, that suggests that perhaps the code is missing something.\n\nWait, perhaps the sample output is for each possible weight (mod 3) separately, but the problem statement says to output the maximum cost regardless of the weight.\n\nWait, the problem statement says: \"print one number — maximum possible total cost\".\n\nBut the sample output has three numbers. Oh, perhaps the sample is wrong, or perhaps I misunderstood the problem.\n\nWait, looking back at the problem statement:\n\nSample Input:\n\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\nSample Output:\n\n['0', '3', '10']\n\nHmm, perhaps each test case is for each possible weight (1, 2, 3) separately.\n\nWait, no. Looking at the problem statement, the output is the maximum possible total cost, regardless of the weight. So, the sample output's three numbers must correspond to the maximum for each possible weight.\n\nBut that's unclear. Or perhaps the sample input is presented as three separate test cases.\n\nWait, perhaps the problem statement is mistyped, and the sample is three separate test cases, each with their own output.\n\nYes, that makes sense.\n\nSo, the first test case in the sample input is:\n\nn=1, m=1.\n\nItems: 1 1.\n\nSo, the maximum cost is 1.\n\nBut the sample output is 0,3,10.\n\nWait, perhaps the sample is for three test cases, each with different n and m.\n\nWait, perhaps the first test case is:\n\nn=2, m=2.\n\nItems:\n\n1 1\n\n2 1.\n\nSo, the maximum cost is 1 (take either the 1 or the 2).\n\nBut the sample output is 0.\n\nHmm, this is confusing.\n\nAlternatively, perhaps the sample input is not well-formatted. Maybe the sample is a bit misrepresented.\n\nAlternatively, perhaps I made a mistake in understanding the problem.\n\nWait, the problem statement says that the output is three numbers, but that's probably a mistake, and the actual output is one number per test case.\n\nBut in the sample, the output is three lines, each for a different test case.\n\nSo, perhaps the first test case in the sample is:\n\nn=2, m=2.\n\nItems:\n\n1 1\n\n2 1.\n\nThen, the maximum cost is 1, but sample output is 0.\n\nWait, perhaps I'm misunderstanding the grouping.\n\nWait, perhaps the sample is for three test cases, each with different n and m, and the output is their respective maximum costs.\n\nBut I'm not sure. Perhaps I should focus on the code, as per the problem statement.\n\nSo, the code should process each test case and output the maximum cost.\n\nNow, let's proceed to implement this.\n\nPotential issues in code:\n\n- Handling the DP correctly, initializing it to -infinity except for 0.\n\n- Properly sorting the groups.\n\n- Correctly computing the prefix sums.\n\n- Correctly handling the max_cost array.\n\nNow, let's write the code.\n\nFirst, read the input.\n\nIn Python, reading from stdin can be done via input(), but for multiple test cases, it's better to read all at once.\n\nBut in this problem, each test case is processed independently.\n\nSo, the code structure is:\n\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    t = int(input[ptr])\n    ptr +=1\n    for _ in range(t):\n        n = int(input[ptr])\n        m = int(input[ptr+1])\n        ptr +=2\n        w1 = []\n        w2 = []\n        w3 = []\n        for __ in range(n):\n            wi = int(input[ptr])\n            ci = int(input[ptr+1])\n            ptr +=2\n            if wi ==1:\n                w1.append(ci)\n            elif wi ==2:\n                w2.append(ci)\n            else:\n                w3.append(ci",
    "response": "To solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs can have weights of 1, 2, or 3, and each has a specific cost. The goal is to maximize the total cost while keeping the total weight within the limit.\n\n### Approach\n1. **Group Souvenirs by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Compute Prefix Sums**: Sort each group in descending order of cost and compute prefix sums for each group. This helps in efficiently calculating the maximum cost for any given number of items taken from each group.\n3. **Dynamic Programming for 0-1 Knapsack**: Use dynamic programming to solve a 0-1 knapsack problem for the combined groups of weights 1 and 2. This will help in determining the maximum cost for any given weight limit.\n4. **Maximize Cost with 3-Weight Items**: For each possible number of 3-weight items taken, compute the remaining weight capacity and use the precomputed values from the 0-1 knapsack solution to find the maximum cost for the remaining weight. Track the overall maximum cost across all possible numbers of 3-weight items.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    t = int(input[ptr])\n    ptr += 1\n    for _ in range(t):\n        n = int(input[ptr])\n        m = int(input[ptr+1])\n        ptr += 2\n        w1 = []\n        w2 = []\n        w3 = []\n        for __ in range(n):\n            wi = int(input[ptr])\n            ci = int(input[ptr+1])\n            ptr += 2\n            if wi == 1:\n                w1.append(ci)\n            elif wi == 2:\n                w2.append(ci)\n            else:\n                w3.append(ci)\n        \n        # Sort each group in descending order of cost\n        w1.sort(reverse=True)\n        w2.sort(reverse=True)\n        w3.sort(reverse=True)\n        \n        # Compute prefix sums for each group\n        prefix_w1 = [0]\n        current_sum = 0\n        for c in w1:\n            current_sum += c\n            prefix_w1.append(current_sum)\n        \n        prefix_w2 = [0]\n        current_sum = 0\n        for c in w2:\n            current_sum += c\n            prefix_w2.append(current_sum)\n        \n        prefix_w3 = [0]\n        current_sum = 0\n        for c in w3:\n            current_sum += c\n            prefix_w3.append(current_sum)\n        \n        # Initialize DP for 2s and 1s\n        dp = [-float('inf')] * (m + 1)\n        dp[0] = 0\n        \n        # Process 2s\n        for c in w2:\n            for w in range(m, 1, -1):\n                if w >= 2 and dp[w - 2] + c > dp[w]:\n                    dp[w] = dp[w - 2] + c\n        \n        # Process 1s\n        for c in w1:\n            for w in range(m, 0, -1):\n                if w >= 1 and dp[w - 1] + c > dp[w]:\n                    dp[w] = dp[w - 1] + c\n        \n        # Compute max_cost array\n        max_cost = [0] * (m + 1)\n        max_cost[0] = dp[0]\n        for w in range(1, m + 1):\n            max_cost[w] = max(max_cost[w - 1], dp[w])\n        \n        # Now consider taking z 3s\n        max_total = 0\n        max_z = min(len(w3), m // 3)\n        for z in range(0, max_z + 1):\n            remaining = m - 3 * z\n            if remaining < 0:\n                continue\n            current = prefix_w3[z] + max_cost[remaining]\n            if current > max_total:\n                max_total = current\n        \n        print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and split into individual components. Each souvenir's weight and cost are categorized into groups based on their weights.\n2. **Sorting and Prefix Sums**: Each group is sorted by cost in descending order, and prefix sums are computed to quickly get the maximum cost for any number of items taken from each group.\n3. **Dynamic Programming for 1 and 2 Weights**: A dynamic programming approach is used to solve the 0-1 knapsack problem for the combined groups of weights 1 and 2, allowing us to efficiently compute the maximum cost for any given weight limit.\n4. **Maximizing Cost with 3-Weight Items**: For each possible number of 3-weight items taken, the remaining weight capacity is calculated. Using the precomputed values from the 0-1 knapsack solution, the maximum cost for the remaining weight is determined, and the overall maximum cost is tracked.\n\nThis approach ensures that we efficiently handle the constraints and compute the maximum possible total cost within the given weight limit.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    t = int(input[ptr])\n    ptr += 1\n    for _ in range(t):\n        n = int(input[ptr])\n        m = int(input[ptr+1])\n        ptr += 2\n        w1 = []\n        w2 = []\n        w3 = []\n        for __ in range(n):\n            wi = int(input[ptr])\n            ci = int(input[ptr+1])\n            ptr += 2\n            if wi == 1:\n                w1.append(ci)\n            elif wi == 2:\n                w2.append(ci)\n            else:\n                w3.append(ci)\n        \n        # Sort each group in descending order of cost\n        w1.sort(reverse=True)\n        w2.sort(reverse=True)\n        w3.sort(reverse=True)\n        \n        # Compute prefix sums for each group\n        prefix_w1 = [0]\n        current_sum = 0\n        for c in w1:\n            current_sum += c\n            prefix_w1.append(current_sum)\n        \n        prefix_w2 = [0]\n        current_sum = 0\n        for c in w2:\n            current_sum += c\n            prefix_w2.append(current_sum)\n        \n        prefix_w3 = [0]\n        current_sum = 0\n        for c in w3:\n            current_sum += c\n            prefix_w3.append(current_sum)\n        \n        # Initialize DP for 2s and 1s\n        dp = [-float('inf')] * (m + 1)\n        dp[0] = 0\n        \n        # Process 2s\n        for c in w2:\n            for w in range(m, 1, -1):\n                if w >= 2 and dp[w - 2] + c > dp[w]:\n                    dp[w] = dp[w - 2] + c\n        \n        # Process 1s\n        for c in w1:\n            for w in range(m, 0, -1):\n                if w >= 1 and dp[w - 1] + c > dp[w]:\n                    dp[w] = dp[w - 1] + c\n        \n        # Compute max_cost array\n        max_cost = [0] * (m + 1)\n        max_cost[0] = dp[0]\n        for w in range(1, m + 1):\n            max_cost[w] = max(max_cost[w - 1], dp[w])\n        \n        # Now consider taking z 3s\n        max_total = 0\n        max_z = min(len(w3), m // 3)\n        for z in range(0, max_z + 1):\n            remaining = m - 3 * z\n            if remaining < 0:\n                continue\n            current = prefix_w3[z] + max_cost[remaining]\n            if current > max_total:\n                max_total = current\n        \n        print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 450,
        "completion_token_count": 1137,
        "thoughts_token_count": 8193
    }
}