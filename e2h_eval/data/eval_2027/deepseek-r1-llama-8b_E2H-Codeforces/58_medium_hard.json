{
    "start": 1758284127.500438,
    "end": 1758286528.972229,
    "start-formatted": "2025-09-19 21:15 KST",
    "end-formatted": "2025-09-19 21:55 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about finding the minimum number of edges to add to a graph to form a simple cycle of odd length, and also counting the number of ways to do this. The cycle must have more than one vertex, and each vertex in the cycle can appear at most once. Also, we can't add any loops or parallel edges.\n\nHmm. So the first thing I need to do is think about what conditions allow us to form such a cycle with the least edges added.\n\nLet me break it down:\n\n1. **Graph Structure**: The given graph has n vertices and m edges. It's undirected, no loops, no multiple edges.\n\n2. **Cycle Requirements**:\n   - The cycle must be odd-length.\n   - It's a simple cycle (no repeated vertices).\n   - The cycle must consist of more than one vertex, so the minimal cycle we're looking for is a triangle (3 nodes).\n\n3. **Adding Edges**: We can add edges, but only between existing vertices, without creating loops or duplicates.\n\n4. **Objective**:\n   - Find t: the minimal number of edges needed to create such a cycle.\n   - Find w: the number of ways to add these t edges to achieve such a cycle.\n\nSo, the approach is to find all possible ways to form an odd-length cycle with the least edges added and count how many such ways exist.\n\nLet me think about the possible scenarios.\n\nFirst, the graph might already have cycles that meet the criteria. But if not, we need to find the minimal way to form such a cycle.\n\nWait, but even if the graph has some cycles, perhaps adding fewer edges could create a new cycle that meets the odd length condition.\n\nWait, but the problem says \"must form\" a cycle. So maybe the existing graph already contains such a cycle, but perhaps not. So our approach should consider both possibilities.\n\nBut wait, the problem says 'add' edges. So if the graph already has such a cycle, then t would be zero, and w is 1 because you don't add any edges.\n\nBut let's think about the sample input.\n\nIn the first sample input, the graph is 4 nodes and 4 edges. The edges are 1-2, 1-3, 4-2, 4-3. So the graph is two disconnected components: one is a triangle (nodes 1-2-4-3?), wait no. Wait, node 1 is connected to 2 and 3, node 2 is connected to 4, node 3 is connected to 4. So the component including 1 is 1-2-4-3, which is a square, but the other component is just 1? Or wait, no. Wait, the nodes are 1,2,3,4. So 1 is connected to 2 and 3. 2 is connected to 4. 3 is connected to 4. So 1 is in a component with 2,3,4.\n\nWait, no, 1 is connected to 2 and 3, but 2 is connected to 4, and 3 is connected to 4. So all four nodes are in the same component.\n\nIn this case, the graph is a square plus the edge 1-2 and 1-3, making it a complete graph on 4 nodes minus some edges? Not sure.\n\nBut in any case, in the sample input, the output is t=1 and w=2. So adding one edge creates a cycle of odd length.\n\nLooking at the note, the output is three lines, probably for each test case. Oh right, the input seems to have multiple test cases, as in each line after the initial line represents a separate test case.\n\nWait, the input format says the first line has n and m, followed by m lines describing the edges. So for example, the sample input shows three test cases.\n\nWait, the sample input is written as:\n\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\nWhich suggests three test cases. The first is 4 nodes and 4 edges, second is 3 nodes and 3 edges (a triangle), third is 3 nodes and 0 edges.\n\nSo for each test case, we need to compute t and w.\n\nSo let's see the first test case: n=4, m=4.\n\nWe need to find the minimal edges to add to form a cycle of odd length (>=3). So possible options:\n\nIf we can find a triangle (cycle of 3), then t=1.\n\nIn the first test case, perhaps the graph doesn't contain a triangle. Because the edges are 1-2, 1-3, 4-2, 4-3.\n\nSo the edges present are:\n\n1-2\n\n1-3\n\n2-4\n\n3-4\n\nSo nodes 1,2,4 form a cycle of length 3 via 1-2-4, but wait, that's length 3, but does that form a triangle? Wait, 1-2 is present, 2-4 is present, but 1-4 is not. So that's a path, not a cycle.\n\nWait, no, a cycle requires all nodes in a closed loop. So the existing edges may not form a cycle.\n\nSo in this case, adding one edge between two nodes that would form a triangle.\n\nPossible options:\n\nAdd 1-4: Now, 1-2-4 is a triangle? No, because 1-4 is now present. So 1-2-4-1 is a cycle of length 3, which is odd. So yes.\n\nAlternatively, add 2-3: Then 1-2-3-1 is a cycle of length 3.\n\nSo in this case, adding either 1-4 or 2-3 will create a triangle. So two ways, hence w=2.\n\nSo t=1, w=2.\n\nIn the second test case: n=3, m=3. It's a triangle already. So t=0, because the graph already has a cycle of odd length. So w is 1, because there's exactly one way to have no edges added.\n\nThird test case: n=3, m=0. So no edges. We need to form a cycle of length >=3. The minimal cycle is a triangle. How many edges do we need to add?\n\nWell, a triangle requires 3 edges. So t=3, and w=1 because the only way is to add all three edges.\n\nSo the outputs for the three test cases are:\n\nTest case 1: 1 2\n\nTest case 2: 0 1\n\nTest case 3: 3 1\n\nWhich matches the sample output.\n\nSo now, the problem is to find, for each connected component (or each component in the graph) whether it can contribute to forming such a cycle, and determine the minimal edges required across all possibilities.\n\nWait, but the graph can have multiple components. So for each component, we need to see what's the minimal edges needed to form an odd cycle within that component, and then overall choose the component that gives the minimal t.\n\nWait, but the cycle can consist of nodes from different components? No, because if a component is disconnected, adding edges between components won't help in forming a cycle within a single component.\n\nBecause a cycle must consist of a single connected path. So adding edges between components won't create a cycle unless the components themselves can form a cycle when connected.\n\nWait, but adding edges between two components doesn't directly form a cycle unless those edges can connect in a way that forms a cycle.\n\nBut perhaps the minimal t is achieved by combining two components into a single component, and then adding edges within that combined component to form a cycle.\n\nBut that might require more edges than necessary.\n\nSo perhaps the minimal t comes from within a single component.\n\nWait, let me think.\n\nSuppose there are two components, A and B. Component A is a tree with k nodes, and component B is a tree with l nodes. To form a cycle, perhaps the minimal way is to form a cycle within A or B, whichever requires less edges.\n\nBut if neither A nor B can form a cycle on their own, perhaps combining them and adding edges within the combined component can form a cycle.\n\nBut that might require more edges than just considering individual components.\n\nSo perhaps the minimal t can come from either:\n\n1. Adding edges within a single component to form an odd cycle.\n\n2. Adding edges to connect two or more components, and then adding edges within the merged component to form an odd cycle.\n\nBut considering all possibilities might complicate things.\n\nSo perhaps the approach is to consider each connected component separately and find the minimal edges needed for that component, and then take the minimal across all components.\n\nWait, but what if combining two components allows for a smaller t? For example, perhaps a component A has a lot of edges, but another component B is small enough that combining them and adding a few edges can form a cycle.\n\nBut I'm not sure. Maybe it's better to process each component independently first.\n\nSo, let's first find for each connected component, what is the minimal number of edges needed to form an odd cycle in that component.\n\nThen, among all components, find the minimal t across all such possibilities.\n\nAdditionally, for each component, we can calculate how many ways to add edges to form an odd cycle within that component, and sum these across all components to get the total w.\n\nWait, no. Because the cycle can only consist of nodes from a single component, since adding edges between components doesn't form a cycle within the combined graph unless the edges are arranged in a way that connects back to form a cycle.\n\nBut that's getting complicated. Maybe the optimal way is to consider each component and see what's the minimal t for that component, then pick the minimal across all components.\n\nSo, let's proceed under this assumption.\n\nNow, the question is, for each connected component, what is the minimal number of edges to add to form an odd cycle, and how many ways can that be done.\n\nSo, for each component, we need to compute:\n\n- The minimal t_i for that component.\n\n- The number of ways w_i for that component.\n\nThen, the overall t is the minimum of all t_i, and w is the sum of w_i where t_i equals the overall t.\n\nWait, no. Because if a component can form a cycle with t_i = t_min, and another component can form a cycle with a higher t_i, but t_min is already achieved, then the overall w is the sum of the w_i's for all components that can achieve t_min.\n\nBecause each such component contributes its own number of ways.\n\nSo, for example, if two components can form a cycle with t=1, then the total w is the sum of their respective w_i's.\n\nYes, that makes sense.\n\nSo, the plan is:\n\n1. For each connected component in the graph:\n\n   a. Compute the minimal number of edges needed to form an odd cycle (t_i).\n\n   b. Compute the number of ways to achieve this (w_i).\n\n2. Collect all t_i and w_i for each component.\n\n3. The overall t is the minimal t_i across all components.\n\n4. The overall w is the sum of w_i for all components where t_i == t.\n\nBut wait, what about cases where combining components can result in a lower t? For example, suppose component A can form a cycle with t=2, and component B is a single node, but adding an edge between A and B allows for a cycle of t=1. Hmm, not sure.\n\nWait, but the cycle must be a simple cycle. So, for example, if component A is a tree with 3 nodes (A1, A2, A3), and component B is a single node, then connecting A3 and B, and adding edges within A to form a cycle. But I'm not sure if that would form a cycle of odd length.\n\nAlternatively, perhaps it's better to ignore the inter-component possibilities and focus on intra-component cases, as inter-component combinations would likely require more edges than considering individual components.\n\nBut I'm not entirely sure.\n\nWait, let's think of a scenario where a component is a chain of 5 nodes, and another is a single node.\n\nComponent A is a chain: 1-2-3-4-5. So, to form a cycle, we can add edges 1-5 and 2-4, but that's even. Alternatively, perhaps it's impossible to form an odd cycle without adding more edges.\n\nWait, perhaps in this case, the minimal t for component A is 2: add edges to form a cycle of length 5, but that's odd. Or wait, adding 1-5 would create a cycle of length 4 (even), so perhaps adding 2 edges to make a cycle of length 5.\n\nWait, perhaps not. I'm getting stuck here.\n\nAlternatively, perhaps the minimal t for a component is determined by whether it's possible to form an odd cycle within it.\n\nSo, perhaps for each component, the minimal t_i is either 0, 1, or some other value.\n\nWait, let's think about the various cases for a connected component.\n\nCase 1: The component is already has an odd cycle.\n\nIn this case, t_i is 0, w_i is 1.\n\nCase 2: The component is a tree.\n\nA tree has no cycles. So to form a cycle, we need to add at least one edge. But what kind of cycle?\n\nIf the tree can be turned into a cycle by adding one edge, but that would form a cycle of even length, depending on the structure.\n\nWait, for example, a tree is a straight line. Adding an edge between two non-consecutive nodes can create a cycle. The length depends on the distance between the nodes.\n\nSo, for a tree, adding one edge may create a cycle, but the length could be either even or odd.\n\nSo, for a tree, the minimal t_i is 1 if it's possible to create a cycle of odd length by adding a single edge.\n\nOtherwise, perhaps t_i is 1, but the cycle is even.\n\nWait, but in that case, the cycle isn't acceptable. So, for a tree, can we always form a cycle of odd length by adding one edge? Or is it sometimes not possible?\n\nWait, for a tree, adding one edge creates exactly one cycle. The length of that cycle is equal to the number of nodes on the path between the two nodes you're adding, plus one (for the new edge).\n\nSo, for example, in a straight line tree like 1-2-3-4, adding an edge between 1 and 3 creates a cycle of length 3 (edges 1-2-3 and 1-3). So that's a triangle, which is an odd cycle.\n\nSo, in this case, t_i is 1, and w_i is 1.\n\nBut what about a star-shaped tree, like node 1 connected to 2,3,4.\n\nAdding an edge between 2 and 3 creates a triangle (length 3, odd). So again, t_i is 1, w_i is 1.\n\nWhat about a tree with 4 nodes arranged as a star (1 connected to 2,3,4). Adding 2-3 creates a triangle, which is odd. So t_i is 1.\n\nSo, for trees, adding a single edge can create a cycle of odd length.\n\nThus, for a tree, t_i is 1, and w_i is 1.\n\nWait, but wait: what about a tree with 5 nodes in a chain: 1-2-3-4-5. Adding an edge between 2 and 4 would create a cycle of length 4 (even). But adding an edge between 1 and 3 creates a cycle of length 3 (odd). So yes, adding a single edge can create an odd cycle.\n\nSo, for any tree, t_i is 1, and w_i is the number of possible pairs of nodes at even distance? Or wait, no. Wait, for a tree, each edge addition creates exactly one cycle. The length of that cycle is the number of nodes along the path between the two nodes (excluding the added edge) plus one.\n\nWait, for example, in a chain 1-2-3-4-5, adding 1-3 creates a cycle of length 3. Adding 1-4 creates a cycle of length 4. So, the way to form an odd cycle is to add an edge between two nodes that are at an even distance apart? Or wait, no.\n\nWait, the cycle length is the number of edges in the path between the two nodes, plus the new edge.\n\nSo, for nodes u and v, the distance is d. Adding the edge u-v will create a cycle of length d+1.\n\nWe want this cycle length to be odd. So d+1 must be odd → d is even.\n\nSo, for a tree, the number of ways to add a single edge to create an odd cycle is equal to the number of pairs of nodes at even distance.\n\nWait, but in a tree, the number of such pairs is equal to the number of possible edges that can be added to create an odd cycle.\n\nSo, for each pair of nodes at even distance, adding that edge will create an odd cycle.\n\nSo, the number of such pairs is the number of ways.\n\nBut how to compute this efficiently for a tree.\n\nHmm. For a general tree, this is a bit tricky.\n\nAlternatively, perhaps for a tree, the number of ways to add a single edge to form an odd cycle is equal to the number of pairs of nodes with even distance. But computing this for each tree is non-trivial.\n\nBut perhaps there's a pattern.\n\nWait, in a tree, the number of pairs of nodes with even distance can be found by considering the parity of their paths.\n\nWait, but I'm not sure. Maybe it's easier to model each component.\n\nBut perhaps for the problem, we can model each component as follows:\n\nFor each connected component:\n\n- If it's already has an odd cycle → t_i=0, w_i=1.\n\n- Else, if it's a tree:\n\n   - Check if it's possible to add a single edge to form an odd cycle.\n\n   - Then, t_i=1, w_i is the number of ways to choose such an edge.\n\n- Else, it's a cyclic graph but without any odd cycle.\n\n   - Then, to form an odd cycle, perhaps we can add some edges.\n\n   - For example, if the component is even, then adding one edge may not help, but perhaps adding two edges could.\n\nWait, for example, if the component is a square (even cycle), adding an edge between two opposite vertices can create a smaller cycle, but perhaps of even length.\n\nWait, no. Let's say we have a square 1-2-3-4-1. Adding an edge 1-3 creates a triangle (1-2-3-1 and 1-3), which is a cycle of length 3, which is odd. So in this case, adding one edge can form an odd cycle.\n\nWait, so in a square, which is an even cycle, adding an edge between two nodes at distance 2 (like 1-3) creates an odd cycle.\n\nSo, for a component that is an even cycle, adding one edge can create an odd cycle.\n\nSo, for such a component, t_i is 1.\n\nBut wait, in that case, the component is a cycle of even length. So, in that case, the minimal t_i is 1.\n\nSo, what about a component that is a cycle but even-length.\n\nWe can add an edge between any two nodes that are two steps apart, which would form a triangle.\n\nSo, for a cycle of length k (even), the number of ways to add an edge to form a triangle is k, because for each node, you can connect it to the next-next node.\n\nWait, no. For a cycle of 4 nodes, 1-2-3-4-1. Adding 1-3 creates a triangle (1-2-3-1 and 1-3). So, how many ways are there to add one edge to form an odd cycle?\n\nEach edge addition that forms a triangle counts as one way.\n\nIn a 4-node cycle, how many edges can be added to form a triangle?\n\nEach node has two possible edges to add: the one two steps ahead and the one two steps behind. But wait, in a 4-node cycle, each node has exactly two nodes that are two steps away. But adding each such edge forms a triangle.\n\nSo, for a 4-node cycle, the number of such edges is 4, because each edge can be considered in both directions. Wait, no: for each node, two options, but that would count each edge twice.\n\nWait, no: in a 4-node cycle, the possible edges that can form a triangle are 1-3 and 2-4, but 1-3 is the same as 3-1. So in a 4-node cycle, the number of such edges is 2.\n\nSo, adding any of these two edges will form a triangle.\n\nThus, for a 4-node cycle, t_i is 1, and w_i is 2.\n\nSimilarly, for a 6-node cycle, each node can add an edge to the node two steps ahead, but each such edge is unique. So, the number of such edges is 6.\n\nSo, for a cycle of length k (even), the number of edges that can form a triangle is k, because each node has exactly one such edge (connecting to the node two steps ahead in the cycle). Wait, but for k=4, each edge is counted once, but in the case of k=4, there are two such edges.\n\nWait, no, for k=4, each node can connect to the node two steps ahead, but that's equivalent to two edges (since for 4 nodes, 1-3 and 2-4 are the two edges that form triangles).\n\nWait, perhaps I'm overcomplicating. Let me think differently.\n\nIn a cycle of even length, any chord that skips exactly one node will form a triangle. So for a cycle of length k, each such chord corresponds to a possible edge addition.\n\nBut each chord is uniquely determined by its endpoints, but for each node, there's exactly one such chord that can be added.\n\nWait, for a cycle of length 4: each node has two chords, but adding either 1-3 or 2-4 will form a triangle. So, there are two such edges.\n\nSo, in a cycle of even length, the number of edges that can be added to form a triangle is equal to k/2, where k is the length of the cycle.\n\nWait, no. For k=4, it's 2 edges. For k=6, it's 3 edges.\n\nSo, yes, for a cycle of even length k, the number of possible edges to add to form a triangle is k/2.\n\nSo, for such a component, t_i is 1, w_i is k/2.\n\nBut wait, what about cycles of larger even lengths. Like 8 nodes.\n\nEach node can connect to the node two steps ahead, forming a triangle.\n\nSo, for each node, that's one possible edge. So, 8 edges in total. Wait, no: because 1-3, 3-5, etc., but each edge is unique.\n\nWait, for k=8, the edges that form triangles are 1-3, 2-4, 3-5, 4-6, 5-7, 6-8, 7-1, 8-2.\n\nWait, but that's 8 edges, each connecting a node to the one two steps ahead.\n\nSo, for a cycle of even length k, the number of such edges is k.\n\nWait, but for k=4, adding 1-3 and 2-4 gives two edges, which is k/2.\n\nHmm, this suggests that my previous conclusion is incorrect.\n\nAlternatively, perhaps for a cycle of even length k, the number of possible edges to add to form a triangle is k, because for each node, there's exactly one edge to add (to the node two steps ahead), but each such edge is counted once. However, this leads to k edges, but each edge is shared between two nodes, leading to k/2 unique edges.\n\nWait, perhaps I'm getting confused here. Let's think for specific examples.\n\nk=4: edges are 1-2, 2-3, 3-4, 4-1.\n\nPossible edges to add: 1-3 and 2-4. So, two edges.\n\nk=6: edges are 1-2, 2-3, 3-4, 4-5, 5-6, 6-1.\n\nPossible edges to add: 1-3, 2-4, 3-5, 4-6, 5-1, 6-2. That's six edges.\n\nWait, but in a 6-node cycle, adding 1-3 would form a triangle 1-2-3-1, and 1-3.\n\nSo, each such edge is unique and adds a triangle.\n\nSo, for k=4, two edges; for k=6, six edges.\n\nSo, the number of edges is k.\n\nWait, but for k=4, the number is 2, which is k/2. So, perhaps for even k, the number of possible edges is k/2.\n\nWait, that's conflicting.\n\nHmm. Maybe I should think differently. For a cycle of length k, the number of possible edges that can be added to form a triangle is k.\n\nBecause for each node i, there's exactly one node j (i+2 mod k) such that adding i-j forms a triangle.\n\nBut each such edge is considered once, but since it's undirected, each edge is counted once for each node it connects.\n\nWait, perhaps for a cycle of length k, the number of such edges is k.\n\nBut for k=4, that would suggest 4 edges, which is not correct.\n\nWait, I'm getting stuck here. Maybe it's better to proceed under the assumption that for a cycle of even length, the number of edges that can be added to form a triangle is k, but that in reality, it's k/2.\n\nWait, perhaps the actual number is k/2.\n\nBecause for each edge added, it's the same as adding its reverse.\n\nBut in a cycle, for each node, adding an edge to the next node after two steps is the same as adding an edge two steps before.\n\nSo, for k=4, each edge is being considered from both ends, so the total number is 2.\n\nWhich is k/2.\n\nSimilarly, for k=6, it's 3.\n\nSo, the formula is k/2.\n\nSo, for a cycle of even length k, the number of ways to add an edge to form a triangle is k/2.\n\nThus, for such a component, t_i is 1, w_i is k/2.\n\nBut wait, in the first test case, the component is a square (4 nodes), but the sample output says that adding one edge creates a triangle, and there are two ways (adding 1-4 or 2-3). So in this case, for k=4, the number of ways is 2, which is k/2=4/2=2. So that aligns.\n\nSo, for a cycle of even length, t_i is 1, w_i is k/2.\n\nBut wait, what if the component is a cycle of odd length? Then, it's already an odd cycle, so t_i is 0, w_i is 1.\n\nSo, putting this together, for each connected component:\n\n- If the component has an odd cycle (contains at least one cycle of odd length), then t_i is 0, w_i is 1.\n\n- Else, if the component is a tree, then t_i is 1, and w_i is the number of pairs of nodes at even distance.\n\n   - But calculating the number of such pairs in a tree is non-trivial.\n\n- Else, the component is a cycle of even length. Then, t_i is 1, w_i is k/2, where k is the length of the cycle.\n\nWait, but what about a component that is a cycle of even length, but also has trees attached (like a unicyclic graph with even cycle and trees attached)?\n\nIn that case, perhaps the component can form an odd cycle by adding one edge.\n\nBut I'm not sure.\n\nAlternatively, perhaps the presence of an even cycle in the component allows for adding an edge to form an odd cycle, regardless of other parts.\n\nSo, for such components, t_i is 1, w_i is k/2, where k is the length of the even cycle.\n\nBut I'm not sure if that's correct.\n\nHmm, perhaps it's better to model the component as:\n\n- If the component has any cycle (whether even or odd), then:\n\n   - If it has an odd cycle → t_i=0.\n\n   - Else, it's a single even cycle → t_i=1, w_i=k/2.\n\nBut I'm not certain.\n\nAnother approach is to model the component as:\n\n- If the component is a tree → t_i=1, w_i=the number of pairs of nodes at even distance.\n\n- Else, if the component has any cycle (even or odd):\n\n   - If there's an odd cycle in the component → t_i=0.\n\n   - Else, the component is made up of an even cycle and possibly trees attached → then, t_i=1, w_i=k/2, where k is the length of the even cycle.\n\nBut again, I'm not sure.\n\nAlternatively, perhaps the key is to find, for each component, whether it's bipartite.\n\nBecause bipartite graphs cannot have odd-length cycles.\n\nWait, that's a crucial observation.\n\nIn graph theory, a bipartite graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex from one set to the other; that is, the graph contains no odd-length cycles.\n\nSo, if a component is bipartite, it cannot contain any odd-length cycles.\n\nThus, for a bipartitioned component, the minimal t_i is the minimal number of edges to add to make it non-bipartitioned, thus allowing for an odd cycle.\n\nBut how?\n\nWait, for a bipartite component, adding an edge that connects two nodes in the same partition will create an odd cycle.\n\nSo, for a bipartite component, the minimal t_i is 1.\n\nAnd the number of ways to add such an edge is equal to the number of possible edges that connect two nodes in the same partition.\n\nIn a bipartitioned graph, the partitions are U and V. So any edge within U or within V is forbidden. So, the number of edges that can be added is the number of possible edges between nodes in U and the number between nodes in V.\n\nBut wait, no. Because the original graph doesn't have any edges within U or V, as it's bipartite.\n\nSo, the number of possible edges to add is the number of possible edges within U plus the number within V.\n\nWait, but adding any such edge will create an odd cycle.\n\nSo, for a bipartitioned component with partitions of size u and v, the number of possible edges to add is C(u,2) + C(v,2).\n\nWhere C(n,2) is the number of ways to choose two nodes from n.\n\nThus, for a bipartite component, t_i is 1, and w_i is C(u,2) + C(v,2), where u and v are the sizes of the two partitions.\n\nBut wait, in the first test case, the component is a square, which is bipartite. So, partitions are size 2 and 2.\n\nC(2,2) is 1, so 1+1=2 ways. Which matches the sample.\n\nSo, for a bipartite component, t_i is 1, w_i is (u choose 2) + (v choose 2).\n\nSo, the approach is:\n\nFor each connected component:\n\n1. Determine if it's bipartite.\n\n   a. If it's not bipartite → it has an odd cycle. So, t_i=0, w_i=1.\n\n2. If it is bipartite:\n\n   a. Then, the minimal t_i is 1.\n\n   b. The number of ways is (u choose 2) + (v choose 2), where u and v are the sizes of the two partitions.\n\nBut wait, what about a component that is a tree? Trees are bipartite, right?\n\nYes, trees are bipartite. So, for a tree component, which is bipartite, t_i=1, and w_i=(u choose 2) + (v choose 2).\n\nSo, that's manageable.\n\nAnother case: a component that is a cycle of even length. It's bipartite. So, same as above.\n\nAnother case: a component that is a cycle of odd length. It's not bipartite. So, t_i=0, w_i=1.\n\nSo, this seems to cover all cases.\n\nSo, the plan is:\n\nFor each connected component:\n\n- Check if it's bipartite.\n\n- If it's not bipartite → t_i=0, w_i=1.\n\n- If it is bipartite:\n\n   - Compute u and v, the sizes of the two partitions.\n\n   - t_i=1.\n\n   - w_i = (u * (u-1)) // 2 + (v * (v-1)) // 2.\n\nThen, for each component, compute t_i and w_i.\n\nThen, find the minimal t across all components.\n\nThen, sum the w_i's for all components where t_i is equal to the minimal t.\n\nSo, the algorithm steps are:\n\n1. Read the graph.\n\n2. For each connected component:\n\n   a. Determine if it's bipartite.\n\n      i. Perform BFS to check bipartition, and record the two partitions.\n\n   b. Based on whether it's bipartite, compute t_i and w_i.\n\n3. Collect all t_i and w_i.\n\n4. Find the minimal t across all components.\n\n5. Sum the w_i's for all components where t_i equals the minimal t.\n\n6. Output t and the sum.\n\nWait, but what about the case where a component is a tree and a bipartitioned component. Then, according to the above approach, the t_i is 1, and w_i is the number of possible edges within each partition.\n\nYes, that seems correct.\n\nSo, the main challenge is to implement this correctly.\n\nNow, how to implement this in Python.\n\nFirst, for each component, perform BFS to determine if it's bipartite and find the partitions.\n\nImplementing Bipartite Check:\n\nWe can represent each node's color (partition) as 0 or 1. Initially, all are -1 (unvisited). For each node in the component, if it's not visited, start BFS.\n\nIn BFS:\n\n- Assign color 0 to the starting node.\n\n- For each neighbor, if not visited, assign the opposite color.\n\n- If a neighbor is already visited and has the same color as current, then the graph is not bipartite.\n\nElse, continue.\n\nOnce the BFS is done, the graph is bipartite, and the two partitions can be tracked.\n\nSo, for each component:\n\n- If during BFS, a conflict is found → not bipartite.\n\n   → t_i = 0, w_i = 1.\n\n- Else:\n\n   → t_i = 1, w_i = (u choose 2) + (v choose 2).\n\nThus, the code outline is:\n\nRead n, m.\n\nedges = read m edges, build adjacency list.\n\nvisited = [False] * (n+1)\n\ncomponents = []\n\nfor each node from 1 to n:\n\n   if not visited:\n\n      perform BFS to find the component.\n\n      during BFS, check if the component is bipartite.\n\n      record whether it's bipartite, and the sizes of the two partitions.\n\n      add to components.\n\nOnce all components are processed:\n\nCompute the minimal t across all components.\n\nsum_w = 0\n\nfor each component in components:\n\n   if component.t_i < min_t:\n\n      min_t = component.t_i\n\n      sum_w = 0\n\n   elif component.t_i == min_t:\n\n      sum_w += component.w_i\n\nThus, the code needs to collect all components, compute their t and w, then find the minimal t and sum the corresponding w.\n\nWait, no. Because for each component, it may have t_i less than the current min. So, we need to track the overall min t and sum all w_i where t_i is equal to the overall min.\n\nSo, the steps are:\n\nInitialize min_t to a large value.\n\nsum_w = 0\n\nfor each component in components:\n\n   if component.t_i < min_t:\n\n      min_t = component.t_i\n\n      sum_w = 0\n\n   elif component.t_i == min_t:\n\n      sum_w += component.w_i\n\nThus, after processing all components, min_t is the minimal t, and sum_w is the sum of w_i for components with t_i = min_t.\n\nBut wait, what about when a component has t_i=0 (it's not bipartite)? Then, for such components, their t_i is 0, which is the minimal possible. So, the overall min_t is 0, and sum_w is the sum of all w_i where t_i=0.\n\nBut according to the problem statement, the cycle must have more than one vertex, but a component that is not bipartite (has an odd cycle) has t_i=0, w_i=1.\n\nThus, for each such component, if it's non-bipartite, adding zero edges is sufficient.\n\nSo, the minimal t is zero if any component is non-bipartite.\n\nThus, the code should find the minimal t as the minimal t_i across all components, which can be zero.\n\nSo, let's proceed.\n\nNow, implementing Bipartition:\n\nWe'll use a BFS-based approach for each",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length, and count the number of ways to achieve this. The solution involves analyzing each connected component of the graph to determine if it can form such a cycle either on its own or by combining components.\n\n### Approach\n1. **Graph Representation**: Represent the graph using an adjacency list for efficient traversal.\n2. **Bipartite Check**: For each connected component, check if it is bipartite. A bipartite graph cannot have any odd-length cycles.\n3. **Component Analysis**:\n   - If a component is not bipartite, it already contains an odd-length cycle, so no edges need to be added (t=0, w=1).\n   - If a component is bipartite, determine the minimum edges needed to form an odd-length cycle. This is always 1 edge, and the number of ways to do this is calculated based on the sizes of the two partitions in the bipartition.\n4. **Result Calculation**: For each component, compute the minimum edges required and the number of ways. Sum the number of ways across all components that achieve the minimum edges required.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    components = []\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            is_bipartite = True\n            color = [-1] * (n + 1)\n            q = deque()\n            q.append(node)\n            color[node] = 0\n            partition_size = [0, 0]\n            partition_size[0] += 1\n            while q:\n                current = q.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        if color[neighbor] == 0:\n                            partition_size[0] += 1\n                        else:\n                            partition_size[1] += 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[current]:\n                        is_bipartite = False\n                        break\n                if not is_bipartite:\n                    break\n            if not is_bipartite:\n                components.append((False, 1, 1))\n            else:\n                components.append((True, 1, (partition_size[0] * (partition_size[0]-1)) // 2 + (partition_size[1] * (partition_size[1]-1)) // 2))\n\n    min_t = float('inf')\n    total_w = 0\n\n    for comp in components:\n        is_bipartite, t_i, w_i = comp\n        if t_i < min_t:\n            min_t = t_i\n            total_w = 0\n        elif t_i == min_t:\n            total_w += w_i\n\n    print(f\"{min_t} {total_w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices and edges, followed by the edges themselves.\n2. **Graph Construction**: The graph is represented using an adjacency list.\n3. **Component Traversal**: Each node is processed to find connected components using BFS. During BFS, we check if the component is bipartite.\n4. **Bipartite Check**: For each component, if it is bipartite, we calculate the minimum edges needed and the number of ways to form an odd cycle. If it is not bipartite, it already contains an odd cycle.\n5. **Result Calculation**: We determine the minimum number of edges required across all components and sum the number of ways for each component contributing to this minimum.\n\nThis approach efficiently handles each component and ensures we find the optimal solution with minimal computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    components = []\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            is_bipartite = True\n            color = [-1] * (n + 1)\n            q = deque()\n            q.append(node)\n            color[node] = 0\n            partition_size = [0, 0]\n            partition_size[0] += 1\n            while q:\n                current = q.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        if color[neighbor] == 0:\n                            partition_size[0] += 1\n                        else:\n                            partition_size[1] += 1\n                        q.append(neighbor)\n                    elif color[neighbor] == color[current]:\n                        is_bipartite = False\n                        break\n                if not is_bipartite:\n                    break\n            if not is_bipartite:\n                components.append((False, 1, 1))\n            else:\n                components.append((True, 1, (partition_size[0] * (partition_size[0]-1)) // 2 + (partition_size[1] * (partition_size[1]-1)) // 2))\n\n    min_t = float('inf')\n    total_w = 0\n\n    for comp in components:\n        is_bipartite, t_i, w_i = comp\n        if t_i < min_t:\n            min_t = t_i\n            total_w = 0\n        elif t_i == min_t:\n            total_w += w_i\n\n    print(f\"{min_t} {total_w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 926,
        "thoughts_token_count": 8193
    }
}