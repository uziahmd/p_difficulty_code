{
    "start": 1758278819.497622,
    "end": 1758279216.65287,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about reconstructing the number of laughy mushrooms on each lawn based on some given roads. Each road connects two lawns and has two numbers: the GCD and LCM of the mushrooms on those two lawns. The task is to determine if such an arrangement exists, and if so, find any possible configuration.\n\nHmm. So the input gives me n lawns and m known roads. For each road, I know the two endpoints (lawn IDs), and the GCD and LCM of the mushrooms on those lawns.\n\nWait, but how do I model this? It feels like a graph problem where each edge represents constraints between two variables (the mushroom counts). So this might be similar to a system of equations or constraints that we need to solve.\n\nEach edge (u, v) gives us two equations:\n1. gcd(u_mushrooms, v_mushrooms) = g\n2. lcm(u_mushrooms, v_mushrooms) = l\n\nBut wait, isn't there a relationship between GCD and LCM? Oh right! For any two integers a and b, the product of their GCD and LCM is equal to the product of the numbers themselves. So, gcd(a,b) * lcm(a,b) = a*b.\n\nSo for each edge, we have g * l = u * v. Which means that u and v must satisfy this equation. But since u and v are positive integers, perhaps we can model this as a graph where each node's value is a multiple of certain primes, subject to the constraints from the edges.\n\nThis makes me think that the problem can be approached using Union-Find (Disjoint Set Union) with some additional information. Because each connected component will have its own constraints, and within each component, the values must be consistent.\n\nLet me think about the structure of the solution.\n\nEach connected component forms a system where all nodes must have values that are compatible with all the edges in the component.\n\nSo, the plan is:\n\n1. For each connected component, assign a variable to represent the base value. Then, each node in the component can be expressed as a multiple of this base value, adjusted by some factors based on the edges.\n\nWait, but how? Because the edges impose both GCD and LCM constraints.\n\nAnother approach: Since the GCD and LCM are known for each edge, maybe we can model the possible values of u and v as pairs that satisfy these two conditions. Then, for each edge, the possible pairs (u, v) must satisfy that their GCD is g and LCM is l.\n\nBut considering that u and v are variables that could be connected through multiple edges, this seems complex. How do we handle cycles?\n\nWait, let's consider that for each connected component, all the nodes must form a tree where the constraints are consistent. If during the process, a conflict is found (like a node being assigned a value that contradicts previous assignments), then it's impossible.\n\nSo, the steps I'm thinking are:\n\n- Treat each connected component separately.\n- For each component, perform a BFS or DFS to assign values to nodes based on the constraints.\n- For each edge, when visiting it, compute what the possible values for the two nodes must be, based on the current state of the nodes.\n- If at any point, the constraints are violated, output NO.\n\nBut how exactly to assign the values? Maybe for each component, we can represent the possible values as multiples of a common factor, ensuring that all edges' constraints are satisfied.\n\nWait, perhaps each connected component can have a 'base' value. All nodes in the component will have values that are multiples of this base. Or perhaps not—maybe each node has its own value, but they must be related via the edges' constraints.\n\nAlternatively, perhaps for each edge, the pair (a, b) must satisfy that GCD(a, b) = g and LCM(a, b) = l. So, for each edge, a and b can be written as multiples of g, and also as divisors of l multiplied by something.\n\nWait, more precisely, since GCD(a, b) = g, both a and b must be multiples of g. Let’s set a = g * x and b = g * y. Then, the LCM condition becomes LCM(gx, gy) = l. Since LCM(gx, gy) = g * LCM(x, y), this implies that g * LCM(x, y) = l. So, LCM(x, y) must be l / g.\n\nBut also, since x and y are coprime (because GCD(a, b) is g, which is factored out), because any common divisor of x and y would contribute to the GCD of a and b, which is already accounted for by g.\n\nWait, no. Wait,",
    "response": "To solve this problem, we need to determine if it's possible to reconstruct the number of laughy mushrooms on each lawn based on given roads and their respective GCD and LCM values. If possible, we should output any valid configuration; otherwise, we should indicate that it's impossible.\n\n### Approach\n1. **Graph Representation**: Treat the lawns as nodes and the roads as edges in a graph.\n2. **Constraints Handling**: Each road provides constraints in the form of GCD and LCM between two nodes (lawns). These constraints can be translated into equations involving the values of the nodes.\n3. **Union-Find Data Structure**: Use Union-Find with additional information (like the greatest common divisor) to manage connected components and ensure consistency across all constraints.\n4. **Breadth-First Search (BFS)**: For each connected component, perform BFS to propagate constraints and assign values to nodes based on the given GCD and LCM conditions.\n5. **Cycle Check**: During BFS, check for cycles that might cause contradictions in constraints. If a contradiction is found, output \"NO\".\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n\n    parent = list(range(n + 1))\n    rank = [1] * (n + 1)\n    g_values = defaultdict(int)\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v, g):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            if g_values[u_root] != g:\n                return False\n            return True\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            g_values[v_root] = g\n        else:\n            parent[v_root] = u_root\n            if rank[u_root] == rank[v_root]:\n                rank[u_root] += 1\n            g_values[u_root] = g\n        return True\n\n    for u, v, g, l in edges:\n        if not union(u, v, g):\n            print(\"NO\")\n            return\n\n    res = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            res[i] = 1\n            while q:\n                u = q.popleft()\n                for edge in edges:\n                    if edge[0] == u:\n                        v = edge[1]\n                        if not visited[v]:\n                            visited[v] = True\n                            res[v] = res[u] * edge[2] * edge[3] // (edge[2] * edge[3] // gcd(res[u], res[v]))\n                            q.append(v)\n                        else:\n                            g_current = gcd(res[u], res[v])\n                            l_current = lcm(res[u], res[v])\n                            if g_current != edge[2] or l_current != edge[3]:\n                                print(\"NO\")\n                                return\n\n    result = [res[i] for i in range(1, n + 1)]\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns, roads, and the details of each road.\n2. **Union-Find Initialization**: Initialize the Union-Find data structure to manage connected components and track the GCD values for each component.\n3. **Union Operation**: For each road, attempt to union the two lawns with the given GCD. If a conflict arises, output \"NO\".\n4. **BFS for Value Assignment**: For each unvisited lawn, perform BFS to assign values based on the constraints. If a contradiction is found during BFS, output \"NO\".\n5. **Result Construction**: If all constraints are satisfied, construct and print the result. Otherwise, print \"NO\".\n\nThis approach ensures that we efficiently check for consistency across all constraints and propagate values correctly through the graph.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        edges.append((u, v, g, l))\n\n    parent = list(range(n + 1))\n    rank = [1] * (n + 1)\n    g_values = defaultdict(int)\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v, g):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            if g_values[u_root] != g:\n                return False\n            return True\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            g_values[v_root] = g\n        else:\n            parent[v_root] = u_root\n            if rank[u_root] == rank[v_root]:\n                rank[u_root] += 1\n            g_values[u_root] = g\n        return True\n\n    for u, v, g, l in edges:\n        if not union(u, v, g):\n            print(\"NO\")\n            return\n\n    res = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            res[i] = 1\n            while q:\n                u = q.popleft()\n                for edge in edges:\n                    if edge[0] == u:\n                        v = edge[1]\n                        if not visited[v]:\n                            visited[v] = True\n                            res[v] = res[u] * edge[2] * edge[3] // (edge[2] * edge[3] // gcd(res[u], res[v]))\n                            q.append(v)\n                        else:\n                            g_current = gcd(res[u], res[v])\n                            l_current = lcm(res[u], res[v])\n                            if g_current != edge[2] or l_current != edge[3]:\n                                print(\"NO\")\n                                return\n\n    result = [res[i] for i in range(1, n + 1)]\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 545,
        "completion_token_count": 1052,
        "thoughts_token_count": 1025
    }
}