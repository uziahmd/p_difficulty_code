{
    "start": 1758286518.1845965,
    "end": 1758288614.8803422,
    "start-formatted": "2025-09-19 21:55 KST",
    "end-formatted": "2025-09-19 22:30 KST",
    "gpu": 2,
    "pid": 59,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Happy Sets\n\nDefine a set $$$A$$$ as a child of set $$$B$$$ if and only if for each element of value $$$x$$$ that is in $$$A$$$, there exists an element of value $$$x+1$$$ that is in $$$B$$$.Given integers $$$N$$$ and $$$K$$$. In order to make Chaneka happy, you must find the number of different arrays containing $$$N$$$ sets $$$[S_1, S_2, S_3, \\ldots, S_N]$$$ such that: - Each set can only contain zero or more different integers from $$$1$$$ to $$$K$$$. - There exists a way to rearrange the order of the array of sets into $$$[S'_1, S'_2, S'_3, \\ldots, S'_N]$$$ such that $$$S'_i$$$ is a child of $$$S'_{i+1}$$$ for each $$$1\\leq i\\leq N-1$$$.Print the answer modulo $$$998\\,244\\,353$$$.Two sets are considered different if and only if there is at least one value that only occurs in one of the two sets.Two arrays of sets are considered different if and only if there is at least one index $$$i$$$ such that the sets at index $$$i$$$ in the two arrays are different.\n\n## Input\nThe only line contains two integers $$$N$$$ and $$$K$$$ ($$$1 \\leq N,K \\leq 2\\cdot10^5$$$) — the number of sets in the array and the maximum limit for the values in the sets.\n\n## Output\nAn integer representing the number of different arrays of sets that satisfy the problem condition, modulo $$$998\\,244\\,353$$$.\n\n## Example\n### Input\n['2 2', '1 3', '3 1']\n\n### Output\n['11', '8', '4']\n\n## Note\nIn the first example, there are $$$11$$$ different arrays of sets possible, which are:   $$$[\\{\\}, \\{\\}]$$$  $$$[\\{\\}, \\{1\\}]$$$  $$$[\\{\\}, \\{1, 2\\}]$$$  $$$[\\{\\}, \\{2\\}]$$$  $$$[\\{1\\}, \\{\\}]$$$  $$$[\\{1\\}, \\{1, 2\\}]$$$  $$$[\\{1\\}, \\{2\\}]$$$  $$$[\\{1, 2\\}, \\{\\}]$$$  $$$[\\{1, 2\\}, \\{1\\}]$$$  $$$[\\{2\\}, \\{\\}]$$$  $$$[\\{2\\}, \\{1\\}]$$$ \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about counting the number of arrays of sets that satisfy certain conditions. The main idea is that each set in the array must be a \"child\" of the next one when the array is rearranged. So, for S'_i to be a child of S'_{i+1}, every element x in S'_i must also have x+1 present in S'_{i+1}.\n\nHmm, let's break it down. Each set is a subset of {1, 2, ..., K}. The array has N such sets. And after rearrangement, each consecutive pair must satisfy the child condition.\n\nWait, but the arrangement can be any permutation of the original array. So, the array itself must be such that when ordered correctly, each set is a parent of the next.\n\nI think the key here is to model the structure of the sets in a way that allows us to count all valid possibilities.\n\nLet me think about what the condition implies. For two sets A and B, if A is a child of B, then every element x in A must have x+1 in B. So, for example, if A contains 2, B must contain 3. If A contains 1, B must contain 2, etc.\n\nThis seems like a kind of dependency or ordering between elements. Maybe we can model the sets as being built upon each other in a way that their elements are \"connected\" via the x+1 relationships.\n\nAnother thought: perhaps the sets can be represented as intervals or sequences where each next set adds some new elements that are exactly one higher than the previous. But I'm not sure yet.\n\nWait, but each set in the array can be arranged in any order. So the array is a multiset of sets, and we need to find all possible multisets (allowing duplicates) such that they can be ordered into a sequence where each consecutive pair satisfies the child condition.\n\nBut how do we model this? It might help to think in terms of the required properties of the sets in the array.\n\nLet me consider the minimal case. Suppose N=1: then there's no ordering needed. Any single set is acceptable. So the count is the total number of possible sets, which is 2^K (since each element can be present or not).\n\nWait, wait. No, the sets can be any size, including empty. So for K=2, there are 4 possible sets. So yes, for N=1, the answer is 2^K.\n\nFor N=2, the situation is more complex. We need two sets S_1 and S_2 such that, when arranged as S_1, S_2, S_1 is a child of S_2. Or perhaps S_2 is a child of S_1 if we arrange them in the opposite order. Wait, but the problem requires that there exists a rearrangement where each consecutive pair satisfies the condition. So the array could have any order, but the specific arrangement must be such that each consecutive pair is a parent-child pair.\n\nWait, no. The problem says that the array must be rearrangeable into a sequence where each S'_i is a child of S'_{i+1}. So the array is a collection of sets where some ordering exists that makes the chain of children. So the array itself can have any subsets, but when you permute them, they form a chain.\n\nSo for the array, regardless of the order, there must exist an ordering where each consecutive pair satisfies the condition.\n\nSo for example, for N=2, the two sets must be compatible in that either the first can be a child of the second or vice versa. Because if neither is true, then no matter how you arrange them, the condition fails.\n\nWait, but for two sets, if neither is a child of the other, then any ordering would not satisfy the condition. So in that case, such pairs would not contribute to the count.\n\nSo for N=2, the total number of valid pairs (S1, S2) is the number of pairs where either S1 is a child of S2 or S2 is a child of S1.\n\nWait, no. Because when you arrange them, you can choose either order. So for any two sets where at least one is a child of the other, the pair is valid because you can arrange them in the appropriate order.\n\nSo the problem reduces to counting the number of arrays of N sets where the multiset of sets can be arranged into a chain where each consecutive pair is a parent-child relationship.\n\nNow, how do we model the structure of these sets?\n\nPerhaps we can model the sets as being part of a chain where each set is a superset of the previous plus some additional elements. But that might not capture all possibilities.\n\nAlternatively, maybe we can represent each set by the maximum element it contains. Because, for a set to be a child of another, its maximum element must be less than that of the parent. Because suppose the parent set has a maximum element m, then any child set can have at most m-1 as its maximum.\n\nWait, that's a crucial point. Because if a set A is a child of B, then every x in A must have x+1 in B. So the maximum element in A must be less than the maximum element in B. Because, the maximum element in A is x, and then B must have x+1. So the maximum of B is at least x+1, but since B cannot have elements beyond K, the maximum of B is >= x+1 and <= K.\n\nWait, but if B's maximum is greater than x+1, that's allowed as long as it includes x+1. For example, A has max 2, B has max 3, which includes 2+1=3. So yes, B's max is 3.\n\nSo, for a set A to be a child of B, the maximum of A must be less than the maximum of B, and B must include all elements of A plus possibly higher ones.\n\nWait, no. Because suppose A has elements {1,2}, and B has elements {2,3}. Then A is a child of B, since 1 is in A, and 2 is in B; 2 is in A, and 3 is in B. So the max of A is 2, the max of B is 3. So yes, the max of B is higher.\n\nSo, the condition that A is a child of B is equivalent to:\n\nmax(A) < max(B), and for every x in A, x+1 is in B.\n\nWhich can be restated as: B includes all elements of A, and B's max is higher than A's.\n\nSo, the maximums must form a strictly increasing sequence when ordered along the chain.\n\nBecause when you arrange the sets in an order S_1, S_2, ..., S_N, each S_i must have a lower maximum than S_{i+1}.\n\nTherefore, the entire array's sets must be such that their maximum elements can be ordered in a strictly increasing sequence.\n\nBut since the array can be rearranged, the condition is that the maximum elements of the sets can be arranged in a strictly increasing order. Therefore, the maximums must form a multiset where all elements are distinct and can be arranged in increasing order.\n\nWait, no. Because when you have multiple sets with the same maximum, can they be arranged in a way that each is a child of the next?\n\nSuppose two sets have the same maximum, say 3. Then, for one to be a child of the other, the first must have all elements present in the second. But since their maximums are equal, the second must include all elements of the first, but since the maximum is 3, both have the same maximum. So for the first to be a child of the second, the second must include all elements of the first, and their maximums are the same. But that's only possible if the first set is a subset of the second. But since their maxima are equal, the second can have elements up to 3, and the first must have all elements of the first, but then their maxima are the same. So in that case, the first set must be a subset of the second. But for the first to be a child of the second, every element in the first must have x+1 in the second. Since the maximum is the same, the second can't have any elements beyond that. So, the second set must include all elements of the first, but the maximum is the same. So the second set must be the same as the first. Wait, no.\n\nWait, let's take an example. Suppose A is {1,3}, B is {1,2,3}.\n\nThen, the maximum of A is 3, maximum of B is 3. So for A to be a child of B, every element in A must have x+1 in B.\n\nIn A, 1 is present, 2 is in B. 3 is present, 4 is not in B, but that's okay because 4 is beyond K. Wait, but K could be 3, so 4 is not allowed.\n\nWait, sorry, perhaps K is fixed. So in the problem, K is given, and the sets can only contain elements from 1 to K.\n\nSo, in the case where A is {1,3}, B is {1,2,3}.\n\nCheck if A is a child of B: for each x in A, x+1 must be in B.\n\nx=1: 2 is in B → yes.\n\nx=3: 4 is not in B. But since K=3, 4 is beyond. So does that mean that 3+1 is not in B, which would imply that A cannot be a child of B?\n\nYes. Because the condition is that for each x in A, x+1 must be present in B. So in this case, x=3 is in A, but 4 is not in B. So A is not a child of B.\n\nThus, two sets with the same maximum cannot be in a parent-child relationship because the maximum is same, and thus x+1 would be beyond K, which is not allowed.\n\nSo, for two sets to be in a parent-child relationship, their maxima must be strictly increasing. So, for the array of sets, the maxima of the sets must form a strictly increasing sequence when arranged in the correct order.\n\nTherefore, the array's sets must have their maxima sorted in strictly increasing order. So, when you rearrange the array, the maxima must form a strictly increasing sequence.\n\nThis suggests that the problem can be transformed into choosing N sets whose maxima are all distinct and can be arranged in increasing order. Moreover, each set's maximum must be greater than the previous in the chain.\n\nWait, but the array can have any multiset of sets as long as their maxima can be arranged in a strictly increasing sequence. So, for example, if you have multiple sets with the same maximum, but when arranged, each must have a higher maximum than the previous. But this is impossible if their maxima are the same, as we saw earlier.\n\nSo, in conclusion, the array's sets must have their maxima forming a strictly increasing sequence when arranged properly. Therefore, the maxima must be distinct and can be ordered in an increasing fashion.\n\nSo, the problem reduces to: count the number of arrays of N sets where the maxima can be arranged in a strictly increasing sequence.\n\nWait, but the maxima can be arranged in any order as long as they form a strictly increasing sequence. So, the counts are based on the possible combinations of sets with unique maxima.\n\nBut wait, what defines the maximum of a set? It's the largest element in it. So, for each set, its maximum can be from 0 to K. Wait, no: the maximum can be 0 if the set is empty. But wait, the elements are from 1 to K, so the maximum of an empty set is undefined. Hmm, but in the problem statement, the sets can be empty. So, what's the maximum of an empty set? Maybe we can treat it as -infinity or 0, but I think in our problem, the empty set's maximum doesn't affect the conditions because, for the empty set, there are no elements, so the condition is trivially satisfied.\n\nWait, but when the empty set is involved in a parent-child relationship, the condition is automatically satisfied because there are no elements in the first set. So, the empty set can be placed anywhere in the chain.\n\nSo, considering that, perhaps the empty set can be part of the array, but when it's the first set in the chain, the next set can have any elements, including none.\n\nWait, but the empty set can only be followed by sets whose elements are such that every x in the empty set is in the next set, which is always true.\n\nSo, the presence of the empty set complicates things a bit, but perhaps it can be handled separately.\n\nBut back to the main problem: the maxima of the sets in the array must form a strictly increasing sequence.\n\nSo, for the array of N sets, each set has a maximum m_i, and when arranged in order, m_1 < m_2 < ... < m_N.\n\nMoreover, each set S'_i has m_i = max(S'_i), and m_i < m_{i+1}.\n\nSo, the problem is now to count the number of N-length sequences of sets where the maxima are strictly increasing, and each set is a subset of [1..K].\n\nBut the array is a list of sets, and the order can be rearranged. So, the array can be any multiset of sets that includes at least one set for each m in some increasing sequence.\n\nWait, no. Because the array is a list, but the order can be rearranged. So, the array can consist of any combination of sets, provided that there exists an ordering where the maxima are strictly increasing.\n\nSo, the problem is equivalent to counting the number of multisets of N sets where the sets can be ordered in such a way that their maxima form a strictly increasing sequence.\n\nBut how can we model this? Perhaps we can think of the sets as being grouped by their maximum value. For each possible maximum m, we can have some number of sets with maximum m.\n\nBut for the sets to be arranged in a strictly increasing order, each m must appear at most once in the chain. So, for the entire array, the sum of the counts for each m across all groups must be at least 1 for each m in the chain.\n\nWait, maybe not. Because the array can have multiple sets with the same maximum, but when arranging them, they can't be consecutive because their maxima are the same, which breaks the strictly increasing condition.\n\nWait, that's a problem. Because if two sets have the same maximum m, then placing them consecutively would require one to be a child of the other, which is impossible unless they are identical and their maxima are same, which isn't allowed as per earlier reasoning.\n\nWait, no. As before, two sets with the same maximum cannot be a parent-child pair because the parent's maximum would have to be less than the child's, which is not the case. So, two sets with the same maximum cannot be arranged consecutively in the chain.\n\nTherefore, the array can have at most one set with a particular maximum m.\n\nWait, is that correct? Let's see.\n\nSuppose the array has two sets with maximum m. Then, when trying to arrange them in a chain, say A comes before B. Then A must be a child of B. But since both have maximum m, for A to be a child of B, all elements in A must have x+1 in B. But since their maxima are m, B must have m+1, which is beyond K. So, for m = K, B cannot have m+1. Thus, such a pair is invalid.\n\nTherefore, the array cannot have more than one set with the same maximum m for any m.\n\nSo, each maximum m can appear at most once in the array.\n\nTherefore, the array must consist of sets with distinct maxima, arranged in an increasing order.\n\nSo, the problem reduces to selecting N sets with distinct maxima m_1 < m_2 < ... < m_N, and for each set, the elements must be a subset of {1, 2, ..., K}.\n\nMoreover, the sets can be in any order in the array, as long as their maxima can be arranged in strictly increasing order.\n\nWait, but since the array can be reordered, the selection of the sets is such that the array can be rearranged into a chain where each set is a child of the next. So, the array must consist of sets with distinct maxima, and each set must be a subset of the next set's elements.\n\nWait, no. Because the condition is that for each consecutive pair in the rearranged array, the first is a child of the second. Which, as we established earlier, requires that the maximum of the first is less than the maximum of the second. Also, for every x in the first set, x+1 must be present in the second set.\n\nSo, the sets must form a chain where each set is a subset of the next set, and the next set's maximum is exactly one higher than the current. Or is that necessary?\n\nNo. Because the next set could have a maximum higher than the current by more than one. For example, current set has max 2, next has max 4. Then, the next set must include all elements of the current set. So, for x=1 and 2 in the current, the next set must include 2 and 3, but if its maximum is 4, then 3 is included, but 4 is not necessarily related to 2.\n\nWait, perhaps the next set must include all elements of the current set, but their maximum is higher.\n\nSo, the condition is that the current set is a subset of the next set, and the next set's maximum is higher.\n\nWait, is that sufficient?\n\nLet me think: suppose A is a subset of B, and max(A) < max(B). Then, for each x in A, x+1 is in B? Not necessarily.\n\nFor example, A is {1,3}, B is {1,2,3,4}, max(A)=3 < max(B)=4. But x=3 in A, x+1=4 is in B. So yes.\n\nAnother example: A is {1,2}, B is {1,3}. Max(A)=2 < 3. Does B include 2+1=3? Yes. So yes, A is a child of B.\n\nWait, but what if A is {1,3}, B is {2,3}? Then, max(A)=3, which is not less than B's max of 3. So, this case is invalid.\n\nSo, perhaps the condition that A is a subset of B and max(A) < max(B) is sufficient for A to be a child of B.\n\nBecause, since A is a subset of B, all elements of A are in B. Now, for each x in A, x+1 must be in B. Because B's maximum is higher than A's, and A is a subset of B. So, the maximum of A is m, and B includes all elements up to at least m+1.\n\nWait, no. Suppose A is {1, 2}, B is {1, 3}. Then, B does not include 2, but A is a subset of B. Wait, no, because 2 is in A and 2 is not in B. So in that case, A is not a subset of B. So, for A to be a subset of B, all elements of A must be in B.\n\nSo, if A is a subset of B and max(A) < max(B), then for any x in A, x+1 must be in B.\n\nBecause, since A is a subset of B, x is in B. The max of A is m, which is less than the max of B, say M. So, M > m.\n\nSince M is the maximum of B, and B includes all elements up to M, then for any x in A (which is <= m), x+1 is <= M. So, x+1 is in B.\n\nSo yes, if A is a subset of B and max(A) < max(B), then A is a child of B.\n\nAh! That's a crucial insight. So, the condition that A is a child of B is equivalent to A being a subset of B and the maximum of A being less than the maximum of B.\n\nThat simplifies things a lot.\n\nSo, the problem is now to find the number of arrays of N sets S_1, S_2, ..., S_N such that there exists a permutation of the array where each consecutive pair S_i, S_j satisfies S_i is a subset of S_j and max(S_i) < max(S_j).\n\nSo, the array can be any collection of N sets where the maximums can be arranged in a strictly increasing sequence, and for each consecutive pair in that arrangement, the earlier set is a subset of the later.\n\nThus, the array must consist of sets with strictly increasing maxima, and each set must be a subset of the next.\n\nWait, but the next set may not necessarily be a subset of the current, but in the chain arrangement, each set must be a subset of the next. So, the sets must form a chain where each is a subset of the next, and the maxima are strictly increasing.\n\nSo, the problem reduces to counting the number of chains of length N in the subset lattice, where each step increases the maximum by at least 1, and the subsets are nested.\n\nWait, no. Because the chain can have any subsets as long as each is a subset of the next, and their maxima are strictly increasing.\n\nSo, each step in the chain can add some elements, but the maximum must increase.\n\nSo, the chain is a sequence of sets S_1 ⊆ S_2 ⊆ ... ⊆ S_n, where max(S_i) < max(S_{i+1}).\n\nBut wait, no. Because the sets don't have to be in order in the array. The array can be any permutation, but the chain must be arranged in a way that each consecutive pair is a parent-child. So the array can have any number of sets, but they must be able to be arranged into such a chain.\n\nSo, the problem is equivalent to finding the number of multisets of N sets such that the sets can be ordered into a chain where each is a subset of the next and their maxima are strictly increasing.\n\nBut how do we model this?\n\nAn alternative approach is to model the problem as a graph where each node represents a possible maximum m (ranging from 0 to K). The edges represent possible transitions from m to m+1, m+2, etc., up to K.\n\nWait, perhaps the problem can be approached using dynamic programming. Let's consider dp[i] as the number of ways to choose i sets such that their maxima are in a certain configuration.\n\nWait, but what defines the state? Maybe the current maximum. Because, when building the chain, each step adds a new set with a higher maximum.\n\nSo, for each possible maximum m, we can track the number of ways to build a chain ending with m.\n\nSo, let's define dp[m] as the number of ways to have a chain of length t, ending with a set whose maximum is m.\n\nWait, but how do we model the fact that each step can add any number of sets as long as their maxima are in order?\n\nHmm, perhaps the state should be the current maximum, and the number of ways to have a chain that ends at that maximum.\n\nWait, but the chain can have varying lengths. So, for each m, dp[m] represents the number of chains that end with a set of maximum m, of any length.\n\nBut since we need exactly N sets, perhaps we can model it differently.\n\nAnother idea: for each m, compute the number of ways to have a chain of exactly k steps, ending at m.\n\nBut since the chain can have any number of steps up to K, perhaps we can precompute for each m the number of ways to have a chain of length l ending at m.\n\nBut I'm not sure.\n\nWait, perhaps the problem can be viewed as a product of choices for each possible m.\n\nEach step in the chain can involve adding a set with a new maximum, which is higher than the previous.\n\nSo, for each m from 0 to K, we can compute the number of ways to have a chain that starts at some m' < m, and ends at m, with any number of steps in between.\n\nWait, perhaps the solution involves combinatorics and multiplicative principles.\n\nLet me think: for each m, the number of sets that can be used as the last set in the chain (with maximum m) is 2^{m-1}, because the set must include all elements up to m, but can include any subset of the lower elements.\n\nWait, no. Because the set's maximum is m, so it must include m, and can include any subset of {1, 2, ..., m-1}.\n\nSo, the number of sets with maximum m is 2^{m-1}.\n\nWait, yes. Because for each element from 1 to m-1, it can be present or not. Element m must be present.\n\nSo, for m >= 1, the number is 2^{m-1}.\n\nWhat about m=0? Well, the empty set has maximum 0, but in our problem, the maximum is determined by the elements. So, the empty set has no elements, so its maximum is undefined. However, in the context of the problem, the empty set can be considered as having a maximum of -infinity, but that's probably not useful. Alternatively, perhaps we can treat the empty set as having a maximum of 0, which is less than any other maximum.\n\nWait, but according to the earlier analysis, the maximum of a set is the largest element in it. So, the empty set has no elements, so it's not clear. However, in the problem statement, the sets can be empty, and the condition for the empty set being a child of another set is automatically satisfied.\n\nSo, perhaps for the purpose of this problem, the empty set can be treated as having a maximum of 0, which is less than any other maximum (from 1 to K).\n\nSo, for m=0, the number of sets is 1 (the empty set).\n\nSo, the number of sets with maximum m is:\n\n- 1 for m=0,\n- 2^{m-1} for m >=1.\n\nBut wait, for m=0, the maximum is 0, but the elements are from 1 to K. So, the empty set is the only set with maximum 0.\n\nSo, the initial state is that the empty set can be part of the chain.\n\nNow, considering that, perhaps the problem can be modeled as follows:\n\nWe need to select a sequence of N sets, each with a strictly increasing maximum. Each set must be a subset of the next.\n\nWait, no. Because each set in the chain must be a subset of the next, and the maximum must be strictly increasing.\n\nSo, the chain is a sequence of sets S_1 ⊆ S_2 ⊆ ... ⊆ S_N, where max(S_1) < max(S_2) < ... < max(S_N).\n\nWait, no, because the chain is S_1 is a child of S_2, which means S_1 is a subset of S_2 and max(S_1) < max(S_2). Similarly, S_2 is a child of S_3, and so on.\n\nSo, the entire chain forms a nested sequence of sets where each is a subset of the next and their maxima are strictly increasing.\n\nSo, the problem is equivalent to counting the number of such chains of length N, where each step increases the maximum.\n\nSo, the question is: how many such chains are there, considering that the order can be arbitrary, but the chain can be arranged in a way that forms the required sequence.\n\nWait, but the array can have any order, as long as a permutation exists where the chain is formed. So, the array is a multiset of sets, and the order can be rearranged into a chain.\n\nSo, the problem is to count the number of multisets of N sets where the sets can be ordered into a chain as described.\n\nBut this seems challenging. So, perhaps it's better to model the problem by considering the multiplicity of each maximum m in the chain.\n\nSince each maximum can appear at most once, the chain must consist of a sequence of N distinct maxima, arranged in increasing order.\n\nSo, the problem reduces to choosing a subset of m_1, m_2, ..., m_N where m_1 < m_2 < ... < m_N, and for each consecutive pair, the set with m_i is a subset of the set with m_{i+1}.\n\nThus, the problem is equivalent to counting the number of sequences of N subsets, each with a unique maximum, forming a chain of subsets in inclusion, and the maxima are strictly increasing.\n\nSo, the problem is now to count all possible such sequences.\n\nNow, how can we compute this?\n\nAn important observation is that each step in the chain can have any number of added elements, as long as the maximum increases.\n\nSo, for a chain of length N, starting at some m_1 and ending at m_N, where m_1 < m_2 < ... < m_N, each step from m_i to m_{i+1} can add any elements, but the next set must include all elements of the previous set and can include others, but the maximum must increase.\n\nBut this seems difficult to model directly.\n\nAnother approach is to realize that the number of ways to choose such a chain is the product over the steps of the number of choices for each step.\n\nWait, perhaps the multiplicative property can help here. Because for each step from m to m', the number of ways to transition from a set S with maximum m to a set T with maximum m' is equal to the number of supersets T of S, where T's maximum is m'.\n\nBut since the chain is a sequence of subsets, each step must add elements, but the next set must have a higher maximum.\n\nBut the exact computation is unclear.\n\nWait, perhaps the problem can be approached using generating functions or combinatorial mathematics.\n\nLet me think about the problem as a state machine. Each state is a possible maximum m. For each state m, the number of ways to reach it is the sum over all possible previous states m' < m of the number of ways to reach m' multiplied by the number of ways to go from m' to m.\n\nWait, but what is the transition from m' to m?\n\nWhen moving from m' to m, where m > m', the next set must be a superset of the previous set and have a maximum of m.\n\nSo, for each m' < m, the number of ways to transition is equal to the number of subsets S with maximum m that are supersets of some subset with maximum m'.\n\nWait, but that depends on the specific subsets chosen in each step.\n\nAlternatively, perhaps we can model the problem with dynamic programming, where dp[m] represents the number of ways to have a chain ending with a set of maximum m. Then, for each m, the number of ways to reach m is the sum over all m' < m of dp[m'] multiplied by the number of ways to choose a set with maximum m that is a superset of any set with maximum m'.\n\nBut this seems computationally intensive, especially since K can be up to 2e5.\n\nAlternatively, perhaps there's a mathematical formula that can express the total number of valid arrays.\n\nLet me think about the problem for small values of N.\n\nCase N=1: The answer is the sum over all possible sets, which is 2^K. But wait, no: the array can have any single set, which can be any subset of [1..K]. So, the count is indeed 2^K.\n\nWait, but earlier analysis suggested that the number of sets is 2^m for each m, but perhaps I was mistaken. Wait, for each m, the number of sets with maximum m is 2^{m-1} for m >=1, and 1 for m=0. So, the total is 2^0 + 2^1 + ... + 2^{K} } = 2^{K+1} - 1. But that's the total number of non-empty subsets. Including the empty set, the total is 2^{K} (since the empty set is 1).\n\nWait, no: the empty set is counted as 1, and for m >=1, the number of sets with maximum m is 2^{m-1}. So, the total is 1 + sum_{m=1 to K} 2^{m-1} } = 1 + (2^K -1) ) = 2^K.\n\nYes, that's correct. So for each m, the number of sets with maximum m is 2^{m-1}, and the empty set is 1.\n\nSo, for N=1, the count is 2^K.\n\nFor N=2: we need to choose two sets S1 and S2 such that S1 is a subset of S2, and max(S1) < max(S2).\n\nWait, but the array can be arranged as [S2, S1], but that wouldn't work because S2 would have a higher max than S1, so S2 is a child of S1 only if S2 is a subset of S1, which it's not. So, for N=2, the array must consist of two sets where one is a subset of the other, and the maxima are in order.\n\nBut the array can be arranged in any order as long as such a chain exists. So, the two sets must be in a parent-child relationship.\n\nSo, for N=2, the count is the number of ordered pairs (S1, S2) where S1 is a subset of S2, and max(S1) < max(S2).\n\nWait, but the array is a list of two sets, and the order can be swapped if needed. So, the array can have any two sets where either S1 is a child of S2 or S2 is a child of S1.\n\nSo, for N=2, the count is the number of unordered pairs {S1, S2} where S1 is a subset of S2 and max(S1) < max(S2), plus the number of ordered pairs where S1 is not a subset of S2 but S2 is a subset of S1.\n\nWait, no, that's not right. Because the array can have any two sets, as long as there exists an ordering where the chain is satisfied.\n\nSo, the pair (S1, S2) is valid if either S1 is a child of S2 or S2 is a child of S1.\n\nThus, the total count is the number of ordered pairs where either condition holds.\n\nBut how to compute this?\n\nAlternatively, for N=2, the total number of valid arrays is the sum over all possible m1 < m2 of the number of ways to choose S1 with maximum m1, S2 with maximum m2, and S1 is a subset of S2.\n\nBut again, this seems complicated.\n\nWait, perhaps for N=2, the total count is equal to the sum over all possible pairs (m1, m2) with m1 < m2 of (number of subsets S1 with maximum m1) * (number of subsets S2 with maximum m2) * (probability that S1 is a subset of S2).\n\nBut this seems tricky to compute.\n\nAlternatively, perhaps the total number of valid arrays for general N can be computed as the product of (sum for each m of f(m)) over the chain of maxima.\n\nWait, perhaps for each m, the number of ways to include a set with maximum m in the chain is 2^{m-1}, and the total is the product of these for each m in the chain.\n\nBut I'm not sure.\n\nWait, another approach: for a chain of N sets, each with a unique maximum m_1 < m_2 < ... < m_N, the number of such chains is the product of the number of ways to choose the sets for each m_i.\n\nBut each set must be a subset of the next. So, for a chain from m_i to m_{i+1}, the number of ways is the number of subsets of {1..m_{i+1}} that include all elements of a subset with maximum m_i and have maximum m_{i+1}.\n\nWait, but that's not correct. Because the sets in the chain can have any elements as long as each is a subset of the next and their maxima are strictly increasing.\n\nWait, perhaps the multiplicative property applies here. Because for each step from m to m', the number of ways to choose a set with maximum m' that is a superset of any set with maximum m is 2^{m' - m -1}.\n\nWait, why? Because the set with maximum m' must include all elements of the previous set, and can include any elements between m+1 and m'-1. So, the number of elements that can vary is (m' - (m+1)) = m' - m -1. So, the number of ways is 2^{m' - m -1}.\n\nBut this depends on the previous set. Hmm.\n\nAlternatively, perhaps for each possible m, the number of ways to have a chain ending at m is the sum over all m' < m of dp[m'] * 2^{m - m' -1}.\n\nBut then, the initial condition is dp[0] = 1 (empty set).\n\nLet me test this for N=2.\n\nCompute dp[m] for m from 0 to K.\n\ndp[0] = 1.\n\nFor m=1: dp[1] = dp[0] * 2^{1-0-1} = 1 * 2^0 =1.\n\nFor m=2: dp[2] = dp[0] * 2^{2-0-1} + dp[1] * 2^{2-1-1} = 1*2^(1) + 1*2^0 =",
    "response": "To solve this problem, we need to count the number of valid arrays of sets such that each set in the array can be rearranged into a sequence where each consecutive pair satisfies the parent-child condition. The solution involves dynamic programming and combinatorial mathematics to efficiently compute the result.\n\n### Approach\n1. **Problem Analysis**: Each set in the array must be able to form a chain where each set is a subset of the next and their maxima are strictly increasing. This reduces the problem to counting the number of valid chains of subsets with strictly increasing maxima.\n2. **Dynamic Programming Insight**: Define `dp[m]` as the number of ways to form a chain ending with a set whose maximum element is `m`. The transitions between states are computed based on the number of ways to extend the chain from lower maxima to higher maxima.\n3. **Combinatorial Counting**: For each possible maximum `m`, the number of valid sets is `2^(m-1)` for non-zero maxima and 1 for the empty set (maxima 0). This helps in computing the transitions efficiently.\n4. **Modulo Operation**: Since the result can be very large, all computations are done modulo `998244353`.\n\n### Solution Code\n```python\nMOD = 998244353\n\ndef main():\n    import sys\n    N, K = map(int, sys.stdin.readline().split())\n    if N == 0:\n        print(1)\n        return\n    \n    dp = [0] * (K + 2)  # m can be up to K\n    dp[0] = 1  # empty set\n    \n    for m in range(1, K + 1):\n        total = 0\n        for m_prev in range(m):\n            ways = pow(2, m - m_prev - 1, MOD)\n            total = (total + dp[m_prev] * ways) % MOD\n        dp[m] = total\n    \n    result = 0\n    for m in range(N, K + 1):\n        if m >= N:\n            result = (result + dp[m]) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Dynamic Programming Initialization**: We initialize `dp[0]` to 1 because there's exactly one way to have an empty set.\n- **Transition Computation**: For each possible maximum `m`, we compute the number of ways to form valid chains ending at `m` by summing over all previous maxima `m_prev` and multiplying by the number of ways to transition from `m_prev` to `m`.\n- **Result Calculation**: The final result is the sum of `dp[m]` for all `m` from `N` to `K`, representing the number of valid chains of length `N`.\n\nThis approach efficiently computes the number of valid arrays using dynamic programming and modular arithmetic, ensuring it handles large values of `N` and `K` within acceptable time limits.",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 998244353\n\ndef main():\n    import sys\n    N, K = map(int, sys.stdin.readline().split())\n    if N == 0:\n        print(1)\n        return\n    \n    dp = [0] * (K + 2)  # m can be up to K\n    dp[0] = 1  # empty set\n    \n    for m in range(1, K + 1):\n        total = 0\n        for m_prev in range(m):\n            ways = pow(2, m - m_prev - 1, MOD)\n            total = (total + dp[m_prev] * ways) % MOD\n        dp[m] = total\n    \n    result = 0\n    for m in range(N, K + 1):\n        if m >= N:\n            result = (result + dp[m]) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 656,
        "completion_token_count": 621,
        "thoughts_token_count": 8193
    }
}