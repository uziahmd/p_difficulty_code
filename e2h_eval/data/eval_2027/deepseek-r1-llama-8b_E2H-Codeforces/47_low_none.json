{
    "start": 1758278294.7229104,
    "end": 1758278549.099436,
    "start-formatted": "2025-09-19 19:38 KST",
    "end-formatted": "2025-09-19 19:42 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about finding the smallest non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. If there are multiple k's that give the same minimal LCM, we choose the smallest k.\n\nHmm, let's think about this. The LCM of two numbers is equal to (product of the two numbers) divided by their greatest common divisor (GCD). So, LCM(x, y) = x*y / GCD(x, y). \n\nWait, but in our case, both numbers are a +k and b +k. Let's denote d = GCD(a, b). Then, since a and b can be written as a = d * m and b = d * n, where m and n are coprime (their GCD is 1). \n\nSo when we add k to both, a +k = d*m +k and b +k = d*n +k. Let's factor this: d*(m) +k = k + d*m, and similarly for the other term. Let me think about the GCD of these two terms.\n\nWait, what's the GCD of (a +k) and (b +k)? Let's compute GCD(a +k, b +k). Since a +k - (b +k) = a - b. So the GCD of (a +k) and (b +k) is the same as GCD(d*m +k, d*n +k). Hmm, maybe I can find a way to express this.\n\nAlternatively, since a and b have a GCD of d, their difference is d*(m -n), assuming m > n without loss of generality. But I'm not sure if that helps directly.\n\nWait, another approach: Let's consider the expression (a +k) and (b +k). Their difference is a - b. So, GCD(a +k, b +k) = GCD(a - b + 2k, a +k). Wait, no, because the difference between (a +k) and (b +k) is a - b. So the GCD must divide a - b. So the GCD can only be a divisor of |a - b|.\n\nAh! That's a key insight. Because the GCD of (a +k) and (b +k) must divide their difference, which is (a - b) or (b -a), depending on which is larger. So the GCD can only be one of the divisors of |a - b|. That's useful because it limits the possible values we need to check.\n\nSo the plan is: find all possible divisors of the difference between a and b, and then for each possible divisor g, see what k would make (a +k) and (b +k) both multiples of g, and then compute the LCM.\n\nBut wait, how does that help? Let's think. The GCD of a +k and b +k must be a divisor of |a - b|. So for each possible g that divides |a - b|, we can try to find a k such that g is the GCD of (a +k) and (b +k). Then, for each such g, compute the minimal LCM achievable, and keep track of the best k.\n\nWait, but perhaps the minimal LCM occurs when the GCD is as large as possible, because LCM is (x*y)/g. So higher g might lead to lower LCM. But it's not necessarily the case because x and y could be larger.\n\nAlternatively, perhaps the minimal LCM is achieved when the product (a +k)(b +k) is minimized, given that their GCD is maximized.\n\nHmm, but this is getting a bit complicated. Let's think differently.\n\nSuppose d = GCD(a, b). Let’s write a = d * x, b = d * y, where x and y are coprime. Then, adding k to both gives us a +k = d*x +k and b +k = d*y +k.\n\nThe GCD of these two is the same as GCD(d*x +k, d*y +k). Let's subtract them: (d*x +k) - (d*y +k) = d*(x - y). So the GCD is a divisor of d*(x - y). But since x and y are coprime, x - y and y are also coprime, etc. Maybe this can help.\n\nWait, perhaps another way: Let’s factor out d from a and b. Then, a +k = d * x +k, and b +k = d * y +k. So the GCD is GCD(d*x +k, d*y +",
    "response": "To solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Understanding the Problem**: The LCM of two numbers is given by the formula \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\). For \\( a + k \\) and \\( b + k \\), their difference is constant, which implies their GCD must be a divisor of the absolute difference of \\( a \\) and \\( b \\).\n\n2. **Key Insight**: The GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of \\( |a - b| \\). Therefore, we can iterate over all divisors of \\( |a - b| \\) to find potential values of \\( k \\) that minimize the LCM.\n\n3. **Efficient Calculation**: For each divisor \\( g \\) of \\( |a - b| \\), compute the corresponding \\( k \\) that makes both \\( a + k \\) and \\( b + k \\) multiples of \\( g \\). Track the \\( k \\) that results in the smallest LCM, breaking ties by choosing the smallest \\( k \\).\n\n### Solution Code\n```python\nimport math\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    diff = abs(a - b)\n    divisors = set()\n    for i in range(1, int(math.isqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    min_lcm = float('inf')\n    best_k = 0\n    for g in divisors:\n        # We need to find k such that a +k ≡ 0 mod g and b +k ≡ 0 mod g\n        # Which means k ≡ (-a) mod g and k ≡ (-b) mod g\n        # So, k must satisfy k ≡ (-a) mod g and k ≡ (-b) mod g\n        # Let's compute the required k\n        # Since a +k ≡ 0 mod g => k ≡ (-a) mod g\n        # Similarly, b +k ≡ 0 mod g => k ≡ (-b) mod g\n        # So, (-a) ≡ (-b) mod g => a ≡ b mod g\n        # Which is true since g divides |a - b|\n        # So, we can find k as follows:\n        # We need to find the smallest k >=0 such that k ≡ (-a) mod g\n        # But since a +k must be divisible by g, let's compute the required k\n        # The remainder when a is divided by g is r = a % g\n        # So, k must be congruent to (g - r) mod g\n        # Wait, no: a +k ≡ 0 mod g => k ≡ (-a) mod g\n        # So, k = m * g - (a % g), but we have to adjust for negative values\n        # Alternatively, the minimal positive k is (g - (a % g)) % g\n        # Let me compute the required k\n        rem_a = a % g\n        required_k = (g - rem_a) % g\n        # Now, check if this k works\n        x = a + required_k\n        y = b + required_k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and required_k < best_k):\n            min_lcm = current_lcm\n            best_k = required_k\n    return best_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))\n```\n\n### Explanation\n1. **Divisor Calculation**: Compute all divisors of the absolute difference between \\( a \\) and \\( b \\). These divisors are potential candidates for the GCD of \\( a + k \\) and \\( b + k \\).\n\n2. **Finding \\( k \\)**: For each divisor \\( g \\), determine the smallest \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are multiples of \\( g \\). This \\( k \\) is derived from ensuring \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\).\n\n3. **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\). Track the smallest LCM and the corresponding \\( k \\), ensuring the smallest \\( k \\) is chosen in case of ties.\n\nThis approach efficiently narrows down the possible values of \\( k \\) by leveraging the properties of divisors and GCD, ensuring an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    diff = abs(a - b)\n    divisors = set()\n    for i in range(1, int(math.isqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    min_lcm = float('inf')\n    best_k = 0\n    for g in divisors:\n        # We need to find k such that a +k ≡ 0 mod g and b +k ≡ 0 mod g\n        # Which means k ≡ (-a) mod g and k ≡ (-b) mod g\n        # So, k must satisfy k ≡ (-a) mod g and k ≡ (-b) mod g\n        # Let's compute the required k\n        # Since a +k ≡ 0 mod g => k ≡ (-a) mod g\n        # Similarly, b +k ≡ 0 mod g => k ≡ (-b) mod g\n        # So, (-a) ≡ (-b) mod g => a ≡ b mod g\n        # Which is true since g divides |a - b|\n        # So, we can find k as follows:\n        # We need to find the smallest k >=0 such that k ≡ (-a) mod g\n        # But since a +k must be divisible by g, let's compute the required k\n        # The remainder when a is divided by g is r = a % g\n        # So, k must be congruent to (g - r) mod g\n        # Wait, no: a +k ≡ 0 mod g => k ≡ (-a) mod g\n        # So, k = m * g - (a % g), but we have to adjust for negative values\n        # Alternatively, the minimal positive k is (g - (a % g)) % g\n        # Let me compute the required k\n        rem_a = a % g\n        required_k = (g - rem_a) % g\n        # Now, check if this k works\n        x = a + required_k\n        y = b + required_k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and required_k < best_k):\n            min_lcm = current_lcm\n            best_k = required_k\n    return best_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))",
    "score": 1,
    "metadata": {
        "prompt_token_count": 383,
        "completion_token_count": 1104,
        "thoughts_token_count": 1025
    }
}