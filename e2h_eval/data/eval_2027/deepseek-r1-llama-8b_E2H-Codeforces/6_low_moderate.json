{
    "start": 1758103527.401143,
    "end": 1758103640.5827253,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about selecting two vouchers such that their durations add up exactly to x and they don't overlap. Also, the total cost should be as minimal as possible. If it's impossible, we return -1.\n\nHmm, let me think about how to approach this.\n\nFirst, each voucher has a start (li), end (ri), and cost (costi). The duration is ri - li + 1. So for two vouchers i and j, their durations must add up to x. Also, they shouldn't intersect, meaning either voucher i ends before voucher j starts or vice versa.\n\nSo, the steps I need to take are:\n\n1. For each voucher, calculate its duration.\n2. Find all pairs of vouchers where the sum of their durations is x.\n3. Among those pairs, check if they are non-overlapping.\n4. Among all valid pairs, find the one with the minimum total cost.\n5. Return the minimum cost, or -1 if no such pair exists.\n\nBut wait, checking all possible pairs directly might not be efficient, especially since n can be up to 2000. Because 2000 choose 2 is about 2 million, which is manageable, but maybe there's a smarter way.\n\nLet me outline the steps in more detail.\n\nFirst, process all vouchers:\n\nFor each voucher, store li, ri, costi, and duration (duration = ri - li + 1).\n\nNow, for each possible pair (i, j), i != j, check if duration_i + duration_j == x.\n\nIf yes, check if they are non-overlapping.\n\nIf both conditions are met, compute the sum of costs and track the minimum.\n\nBut considering that n is up to 2000, the number of pairs is around 2e6, which is acceptable for Python, right? Because 2e6 iterations are manageable in Python.\n\nWait, but 2000 * 2000 is 4 million, which is okay, but perhaps we can optimize by grouping vouchers by their duration.\n\nBecause for a voucher of duration d, another voucher must have duration x - d. So for each voucher, we can look for other vouchers with duration x - d, and then check if they are non-overlapping.\n\nThis reduces the problem because for each voucher, we only look for specific durations.\n\nSo, let's proceed with this approach.\n\nSteps:\n\n- Preprocess all vouchers into a list, each entry containing li, ri, cost, duration.\n\n- Create a dictionary where the key is the duration, and the value is a list of tuples (li, ri, cost) of vouchers with that duration.\n\nThen, for each voucher in the list, we compute required_duration = x - current_voucher.duration. If required_duration is negative, skip. Else, check if required_duration exists in the dictionary.\n\nFor each voucher i:\n\n   d_i = voucher_i.duration\n   needed_d = x - d_i\n   if needed_d < 0: continue\n   else:\n       for each voucher j in the list of needed_d:\n           if j is not i (since i != j)\n               check if i and j are non-overlapping.\n\nWait, but in this case, the same voucher can be considered multiple times, like when i is processed, and j is the same as i. So perhaps, we need to ensure that j comes after i in some ordering, or we just check if j is not the same index as i.\n\nWait, but for each pair (i, j), i and j could be in any order. But to avoid duplicates, perhaps we can process each i and for each j in the needed_d group, where j comes after i, or something like that. Or maybe not, because the cost is added regardless of the order.\n\nWait, no. Because the cost is additive. So whether i comes first or j comes first doesn't affect the total cost. So perhaps, for each pair (i, j) where i and j have the correct durations, we check if they are non-overlapping, and if so, consider their combined cost.\n\nBut this could lead to considering the same pair twice. For example, when i is in the group for d and j is in the group for x-d, and when j is processed, i is again considered. So to avoid double-counting, perhaps we can process each pair once, but that's tricky.\n\nAlternatively, just process all possible pairs, even if it means considering (i, j) and (j, i), but when they are the same pair, just compute the cost once.\n\nBut that could be inefficient, but for n=2000, it's manageable.\n\nSo perhaps the approach is:\n\n- Iterate over all possible pairs of vouchers (i, j), i < j.\n\n- For each pair, check if their durations sum to x.\n\n- Then, check if they are non-overlapping.\n\n- If both",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly x days and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Input Reading and Initialization**: Read the input values and store each voucher's details including start day, end day, cost, and duration.\n2. **Grouping by Duration**: Use a dictionary to group vouchers by their duration. This helps in quickly finding pairs of vouchers that sum up to the required duration x.\n3. **Check All Pairs**: For each voucher, check against all other vouchers (including those with the complementary duration) to find pairs whose combined duration is x. Ensure these pairs do not overlap.\n4. **Track Minimum Cost**: Keep track of the minimum total cost among all valid pairs.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n, x = int(input[idx]), int(input[idx+1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        c = int(input[idx+2])\n        idx +=3\n        duration = r - l + 1\n        vouchers.append((l, r, c, duration))\n    \n    # Group vouchers by their duration\n    from collections import defaultdict\n    duration_groups = defaultdict(list)\n    for v in vouchers:\n        d = v[3]\n        duration_groups[d].append(v)\n    \n    min_cost = float('inf')\n    found = False\n    \n    for i in range(n):\n        l_i, r_i, c_i, d_i = vouchers[i]\n        needed_d = x - d_i\n        if needed_d < 0:\n            continue\n        if needed_d not in duration_groups:\n            continue\n        # Iterate through all possible j in the needed_d group\n        for j in duration_groups[needed_d]:\n            if j == vouchers[i]:  # same voucher, skip\n                continue\n            # Check if they are non-overlapping\n            if r_i < j[0] or j[1] < l_i:\n                total_cost = c_i + j[2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    found = True\n    if found:\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into variables representing the number of vouchers and the required vacation duration. Each voucher is then stored with its details.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary. This allows efficient lookup of vouchers that can potentially form the required duration x when paired.\n3. **Checking Pairs**: For each voucher, we determine the required complementary duration and check against all vouchers in the corresponding group. We ensure that each pair does not overlap and calculate their total cost.\n4. **Tracking Minimum Cost**: The minimum cost of valid pairs is tracked and updated as we iterate through all possible pairs. If no valid pair is found, the result is -1.\n\nThis approach efficiently narrows down the search space using duration grouping and ensures that we only consider non-overlapping pairs, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n, x = int(input[idx]), int(input[idx+1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        c = int(input[idx+2])\n        idx +=3\n        duration = r - l + 1\n        vouchers.append((l, r, c, duration))\n    \n    # Group vouchers by their duration\n    from collections import defaultdict\n    duration_groups = defaultdict(list)\n    for v in vouchers:\n        d = v[3]\n        duration_groups[d].append(v)\n    \n    min_cost = float('inf')\n    found = False\n    \n    for i in range(n):\n        l_i, r_i, c_i, d_i = vouchers[i]\n        needed_d = x - d_i\n        if needed_d < 0:\n            continue\n        if needed_d not in duration_groups:\n            continue\n        # Iterate through all possible j in the needed_d group\n        for j in duration_groups[needed_d]:\n            if j == vouchers[i]:  # same voucher, skip\n                continue\n            # Check if they are non-overlapping\n            if r_i < j[0] or j[1] < l_i:\n                total_cost = c_i + j[2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    found = True\n    if found:\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 703,
        "thoughts_token_count": 1025
    }
}