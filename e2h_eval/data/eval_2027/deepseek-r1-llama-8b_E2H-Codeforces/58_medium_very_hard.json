{
    "start": 1758283912.723147,
    "end": 1758286211.9969332,
    "start-formatted": "2025-09-19 21:11 KST",
    "end-formatted": "2025-09-19 21:50 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about finding the minimum number of edges to add to a graph to form a simple cycle of odd length, and also counting the number of ways to do this. The cycle must have more than one vertex, and each vertex in the cycle can appear at most once. Also, we can't add any loops or parallel edges.\n\nHmm. So the first thing I need to do is think about what conditions allow us to form such a cycle with the least edges added.\n\nLet me break it down:\n\n1. **Graph Structure**: The given graph has n vertices and m edges. It's undirected, no loops, no multiple edges.\n\n2. **Cycle Requirements**:\n   - The cycle must be odd-length.\n   - It's a simple cycle (no repeated vertices).\n   - The cycle must consist of more than one vertex, so the minimal cycle we're looking for is a triangle (3 nodes).\n\n3. **Adding Edges**: We can add edges, but they must not create loops or duplicates. So each new edge connects two distinct, previously disconnected vertices.\n\nOur goal is to find the minimal t, the number of edges needed to be added, and w, the number of ways to add t edges to form such a cycle.\n\nSo, how do I approach this?\n\nI think the key is to look for connected components in the graph because adding edges within a component might not help as much as connecting different components.\n\nWait, but adding an edge between two components could create a cycle. But we need it to be odd-length.\n\nLet me think about the components:\n\nEach connected component is a subgraph that is connected. For each component, perhaps we can compute some information that helps determine whether adding certain edges will lead to forming the desired cycle.\n\nBut maybe it's better to consider all possible scenarios where adding edges can form an odd cycle.\n\nLet me think about the overall structure:\n\nThe problem requires forming a cycle of odd length. So, the cycle must have an odd number of edges, which implies an odd number of vertices.\n\nSo, what are the possibilities for the cycle? It could be a triangle (3 nodes, 3 edges), pentagon (5 nodes, 5 edges), etc.\n\nBut since we're trying to minimize the number of edges to add, the smallest possible cycle is a triangle. So, perhaps the minimal t is either 0, 1, or something else depending on the current graph.\n\nWait, but the current graph might already have a cycle of odd length. Then t would be zero and w would be 1 (since you don't need to add any edges). Or, if there are multiple existing cycles, then w could be higher.\n\nBut wait, no: the problem states that we need to form a cycle by adding edges. If the graph already contains an odd-length cycle, then t is zero and w is 1, because we can choose that existing cycle without adding any edges.\n\nSo, the first step is to check if there's already any existing odd-length cycle. If yes, then t=0 and w=1.\n\nIf not, then we need to compute the minimal t and w based on the components.\n\nSo, the steps could be:\n\n- Check if the graph has an odd-length cycle. If yes, output t=0 and w=1.\n- Else, proceed to compute the minimal t and w.\n\nNow, when the graph doesn't have any odd-length cycles, what can we do?\n\nWe need to find the minimal number of edges to add to form such a cycle.\n\nLet me think about the components. Suppose the graph is split into several connected components.\n\nEach component can contribute to forming a cycle.\n\nFor example, if two components have even degrees, perhaps connecting them could form an odd cycle.\n\nWait, but how?\n\nWait, perhaps I should model this based on the parity (even or odd) of the number of vertices in each component.\n\nBecause the presence of a cycle depends on the degrees of the vertices, but for an undirected graph, the existence of a cycle is determined by the number of vertices in a component and their degrees.\n\nWait, perhaps the key is to look at the connected components and their sizes (number of vertices) modulo something.\n\nWait, another approach: for a cycle to be formed, the component must have certain properties.\n\nLet me think about the necessary conditions for a connected component to form a cycle when adding edges.\n\nIn a connected component, if the number of vertices is k, then the minimal cycle requires (k-1) +1 =k edges, but that's only if it's a tree plus one edge, which forms a single cycle.\n\nWait, no. A tree has k-1 edges. Adding one edge creates exactly one cycle. The length of the cycle depends on the tree's structure.\n\nBut if the initial component is a tree, adding an edge creates a single cycle. So, for a component that is a tree, adding one edge would create a cycle. But the length of the cycle could be even or odd.\n\nSo, perhaps the way to find the minimal t is to find two components such that their combination can form an odd-length cycle when connected via one edge.\n\nWait, let's think: if we have two components, C1 and C2.\n\nIf C1 has an even number of vertices, and C2 has an even number, then connecting them with an edge adds one edge, but the total number of vertices is even, so any cycle involving both would require an even number of edges, leading to an even-length cycle. Not useful.\n\nAlternatively, if one component has an even number of vertices and the other has an odd, then connecting them with an edge would result in a cycle that includes both components. The total number of nodes in the path from the added edge would be even + odd = odd, so the cycle length would be odd.\n\nWait, but the cycle is formed by the path through the added edge and a path within each component. Hmm.\n\nWait, suppose C1 has size a, C2 has size b.\n\nIf a is even and b is even: adding an edge between them creates a cycle of length a + 1 + b. Since a and b are even, a + b is even, a+1 +b is odd. So the cycle length is odd.\n\nWait, but that's not necessarily the case. Because the path from u to v (the added edge) in C1 and C2 may have varying lengths.\n\nWait, no, the cycle created is the sum of the path from u to v in C1, the edge u-v, and the path from v to u in C2. So the total length is (length in C1) + 1 + (length in C2). The sum of these two paths plus one gives the cycle length.\n\nWait, but the exact lengths depend on the structure of the components. So perhaps the parity of the cycle depends on the parities of the component sizes.\n\nWait, perhaps the sum of the parities of the two component sizes.\n\nBecause, for example, if a component has an even number of vertices, then any cycle inside it is even-length. Similarly, an odd-sized component can have cycles of odd or even length depending on the structure.\n\nBut that's not necessarily true. Wait, a component with an odd number of vertices can have cycles of various lengths, including even or odd. So perhaps the parity of the component's size isn't directly indicative of the possible cycle lengths.\n\nHmm, this complicates things.\n\nAlternative approach: perhaps the minimal way to create an odd cycle is to connect two components in such a way that the combined component has an odd number of vertices, and the number of edges added is minimized.\n\nWait, but adding one edge between two components can create a cycle whose length depends on the sum of their diameters or something, but perhaps the parity is determined by the sum of their vertices.\n\nWait, I'm getting stuck here.\n\nLet me think differently. Let's consider the entire graph and its connected components.\n\nEach connected component can be characterized by the parity of the number of its vertices. Let me denote the count of components with even number of vertices as E, and those with odd as O.\n\nSo, for each connected component, count whether the number of vertices is even or odd.\n\nThen, the minimal t can be found by considering the following possibilities:\n\nCase 1: There exists a connected component with an odd number of vertices and the component has a cycle. Wait, no, because if the component itself has an odd cycle, then the entire graph already has such a cycle, which would have been handled earlier.\n\nWait, no. Because if a component has an odd cycle, then adding edges to it won't affect the presence of that cycle. So, the initial step would have already found that the graph has an odd cycle, and thus output t=0, w=1.\n\nSo, assuming the graph doesn't have any odd cycles, let's see.\n\nIn this scenario, every connected component is a tree or has no cycles. Because otherwise, the initial condition would have been met.\n\nWait, no. Because if a component is a tree, it's acyclic. So, for a component to have a cycle, it's possible, but that cycle must be even-length.\n\nSo, in the initial check, if any component has an odd-length cycle, then the graph already has an odd cycle, and t=0, w=1.\n\nOtherwise, the graph is such that all cycles are even-length.\n\nSo now, our task is to add edges to form an odd-length cycle.\n\nSo, the way to do this is to connect two components in a way that the new component has an odd number of vertices, and the cycle is of odd length.\n\nSo, how can we achieve that?\n\nWe need to connect two components such that their combined number of vertices is odd. Because an odd-length cycle requires an odd number of vertices.\n\nSo, the sum of the sizes of the two components must be odd.\n\nWhich means one component has an even number of vertices, the other has an odd.\n\nSo, we need to find pairs of components where one is even, the other is odd.\n\nEach such pair can form a cycle when connected by an edge.\n\nThe minimal t in this case is 1, because we add just one edge.\n\nSo, the minimal t is 1.\n\nBut wait, is that always possible?\n\nWhat if the graph has multiple components, but none are even and odd pairs?\n\nNo, because if all components are even or all are odd, then adding edges between them wouldn't give a sum that is odd.\n\nWait, no. Because if all components are even, then adding an edge between any two even components would result in a sum that's even. Similarly, if all are odd, adding an edge between any two would give a sum that's even.\n\nWait, but that's a problem. Because then, there's no way to form an odd-length cycle by adding edges.\n\nWait, but that's impossible. Because the problem statement says that the graph may not contain any cycles, but the problem requires us to form a cycle by adding edges.\n\nSo, perhaps in some cases, it's impossible to form such a cycle, but according to the problem statement, the output expects t to be the minimal number of edges required, which could be zero if already present, but in other cases, perhaps it's not possible.\n\nWait, but the problem says \"it is prohibited to add loops or parallel edges\". So, perhaps the graph can be modified to form a cycle, but sometimes it's impossible.\n\nWait, but the problem says \"find t — the minimum number of edges that must be added to the graph in order to form a simple cycle of an odd length consisting of more than one vertex.\"\n\nSo, perhaps t is zero if the graph already has such a cycle. Otherwise, t is the minimal number of edges to add.\n\nBut in some cases, it's impossible to form such a cycle. For example, if all components are even-sized, then any cycle formed by connecting components will have an even total number of vertices. So, the cycle length would be even.\n\nWait, no. Because the sum of the sizes is even, but the actual cycle could be longer. Hmm, perhaps not.\n\nWait, no. Because the cycle would involve traversing through both components, but the path would form a loop, which would have a length equal to the sum of the diameters or something like that. But the parity is determined by the sum of the component sizes plus one (the added edge).\n\nWait, maybe I'm overcomplicating this.\n\nLet me think about this: when you add an edge between two components, the cycle created includes that edge and the two paths from the endpoints to some common point. So, the length of the cycle is (path length in component 1) + 1 + (path length in component 2).\n\nThe sum of the path lengths plus one is the cycle length.\n\nNow, if component 1 has an even number of vertices, component 2 has an odd number, then the sum of their sizes is odd. So, adding an edge between them creates a cycle of length (a + 1 + b), where a is the path length in component 1, and b is the path length in component 2.\n\nThe sum a + b is even (since a is the path between two points in component 1, which is even-sized—so the path lengths have certain parities).\n\nWait, perhaps it's better to model this in terms of parity.\n\nSuppose component 1 has an even number of vertices. Any path between two points in component 1 has an even or odd length, depending on the distance.\n\nBut in an even-sized component, perhaps the parity of the path length between two nodes depends on the parity of their distance.\n\nBut I'm not sure.\n\nAlternatively, perhaps the cycle length's parity is determined by the sum of the sizes of the two components.\n\nWait, because the cycle includes all the nodes in component 1 and component 2.\n\nSo, the number of nodes in the cycle is (size of component 1) + (size of component 2) minus 2 (since the two endpoints are counted in both), plus 1 for the added edge. Wait, no, perhaps not.\n\nAlternatively, the cycle includes all the nodes in both components except the two endpoints, connected via the added edge.\n\nSo, the number of nodes is (size1 + size2 - 2) + 2 (since the two endpoints are included once each?), no, that's unclear.\n\nWait, perhaps the cycle's length is (distance between u and v in component 1) + 1 (the added edge) + (distance between v and u in component 2). So the total is (d1 + d2 + 1).\n\nThe sum d1 + d2 is the sum of the distances in each component.\n\nBut regardless of the individual distances, the sum plus one is the cycle length.\n\nThe parity of the cycle length is (d1 + d2 + 1) mod 2.\n\nWhich is equal to (d1 + d2) mod 2 + 1 mod 2, which is (d1 + d2 + 1) mod 2.\n\nWait, perhaps that's not helpful.\n\nAlternatively, since the sum (d1 + d2) can be even or odd, adding 1 will flip the parity.\n\nSo, if d1 + d2 is even, the cycle length is odd.\n\nIf d1 + d2 is odd, the cycle length is even.\n\nSo, the cycle's parity depends on whether d1 + d2 is even or odd.\n\nBut how can we ensure that the cycle is odd?\n\nWe need to choose a pair of components where d1 + d2 is even.\n\nBecause then, adding 1 (the edge) makes the total odd.\n\nSo, the question is: for a pair of components (A and B), is there a way to connect them with an edge such that d1 (the distance between the two chosen points in A) and d2 (the distance between the same two points in B) have the same parity?\n\nBecause d1 + d2 even would require that d1 and d2 are both even or both odd.\n\nWait, but how can we find that?\n\nAlternatively, perhaps for each pair of components, if one is even and the other is odd, then it's possible to connect them with an edge such that the cycle is of odd length.\n\nBecause:\n\nSuppose component A has even size, component B has odd size.\n\nIf A has a pair of nodes u and v such that the distance between them is even, and B has a pair of nodes u' and v' such that the distance between them is even, then connecting u to u' and v to v' would form a cycle of length (even + 1 + even) = odd.\n\nAlternatively, if both distances are odd, then (odd + 1 + odd) = odd.\n\nSo, regardless of the parity of the distances, as long as the two components have sizes with opposite parities, connecting them can result in an odd cycle.\n\nSo, the conclusion is that if the graph has at least one component with even size and at least one component with odd size, then adding one edge between them will create an odd cycle.\n\nThus, in such cases, t=1 and w is the number of such pairs multiplied by the product of the number of ways to choose the edge in each component.\n\nWait, but how?\n\nWait, the number of ways to choose the two components is E * O, where E is the number of even-sized components and O is the number of odd-sized components.\n\nBut for each such pair, how many ways are there to add an edge between them?\n\nFor each even component, the number of available nodes is size_even. For each odd component, the number of available nodes is size_odd.\n\nThe number of ways to choose a node from the even component and a node from the odd component is (even_size) * (odd_size).\n\nSo, for each pair of even and odd components, the number of possible edges is even_size * odd_size.\n\nThus, the total number of ways is the sum over all pairs (E_i, O_j) of (E_i.size * O_j.size) multiplied by 1 (since each such edge addition forms a unique cycle of odd length).\n\nWait, but wait. Because for each pair of even and odd components, there are (E_i.size) * (O_j.size) possible edges between them. Each such edge, when added, creates a unique odd-length cycle.\n\nSo, the total number of ways is the sum for all even components and odd components of (E_i.size * O_j.size).\n\nSo, the minimal t is 1, and the number of ways is the sum of (E_i.size * O_j.size) for all i, j.\n\nBut wait, what if the graph has more than two components, and some are even and some are odd.\n\nYes, because adding an edge between any even and any odd component can form an odd cycle.\n\nSo, the minimal t is 1, and the number of ways is the product of the counts of even and odd components, multiplied by the sum of (E_i.size * O_j.size) across all pairs.\n\nWait, no. Because for each even component E and odd component O, the number of possible edges between E and O is (size_E) * (size_O). So, the total number of ways is the sum over all E and O of (size_E * size_O).\n\nSo, the plan is:\n\n- If the graph already has an odd cycle, output t=0 and w=1.\n\n- Else:\n\n   - Compute the number of even and odd components.\n\n   - If there are both even and odd components, then t=1 and w is the sum over all E and O of (E.size * O.size).\n\n   - Else, if all components are even or all are odd:\n\n      - If all are even: any cycle formed by connecting two components will have a sum of even sizes, which is even. So, adding edges won't help, but wait, no—because the sum is even, but the cycle length is (d1 + d2 +1). So, if d1 + d2 is even, the cycle length is odd. Wait, no, if the two components are even, then their sizes are even. So, the sum of their sizes is even, but the cycle's length is (d1 + d2 + 1). So, the parity depends on d1 + d2.\n\nHmm, perhaps my earlier reasoning was incorrect.\n\nWait, perhaps it's better to model the cycle's parity as follows: the cycle will be of odd length if and only if the sum of the sizes of the two components is odd, which is only possible if one is even and the other is odd.\n\nBecause adding an edge between two even components would create a cycle whose length is (a + 1 + b), where a and b are even. So, a + 1 + b = even + 1 + even = odd. So, the cycle length is odd.\n\nWait, wait! That's a crucial point.\n\nWait, if both components are even, then adding an edge between them creates a cycle whose length is (path_in_component_1) + 1 + (path_in_component_2).\n\nSince component 1 is even, any path in it between two nodes has an even length. Similarly for component 2.\n\nSo, path1 + path2 is even + even = even.\n\nAdding 1 gives even + 1 = odd. So, the cycle length is odd.\n\nOh! So, if you connect two even components, the cycle's length is odd.\n\nSimilarly, connecting two odd components: path1 is odd, path2 is odd. Sum is even. Adding 1: even +1 = odd. So, the cycle length is odd.\n\nSo, in this case, any pair of components, regardless of their parity, when connected by an edge, will form an odd cycle.\n\nWait, that's a big revelation.\n\nSo, the cycle's length will be odd if and only if the sum of the path lengths in the two components is even, which is the case when both path lengths are even (components are even) or both are odd (components are odd).\n\nSo, regardless of whether the components are even or odd, connecting them with an edge will create an odd-length cycle.\n\nSo, this changes everything.\n\nSo, the minimal t is 1.\n\nBut how does the parity of the components affect the number of ways?\n\nWait, no. Because for any two components, regardless of their parity, adding an edge between them will create an odd-length cycle.\n\nSo, the minimal t is 1.\n\nAnd the number of ways is the sum for all possible pairs of components (i,j) of (size_i * size_j), multiplied by the number of possible edges between them.\n\nWait, no. Because for each pair of components, the number of edges we can add is (size_i) * (size_j). Because each node in component i can connect to each node in component j.\n\nSo, the total number of ways is the sum over all i < j of (size_i * size_j).\n\nBut wait, each such edge addition is considered a separate way. So, the number of ways is the sum of (size_i * size_j) for all i < j.\n\nWait, no. Because for each pair of components, the number of possible edges is (size_i * size_j). So, the total number of possible edges is the sum of (size_i * size_j) for all i < j.\n\nSo, the minimal t is 1, and the number of ways is the sum over all i < j of (size_i * size_j).\n\nBut wait, that can't be right because when you have multiple pairs, adding any of their edges would form a cycle. But in reality, each such edge is a separate way, so the count is additive.\n\nSo, the approach is:\n\n- If the graph already has an odd cycle, t=0, w=1.\n\n- Else, if the number of connected components is less than 2, then it's impossible to form a cycle by adding edges (since a cycle requires at least two edges and three nodes). So, for n >=3, but if the graph is a single component (but without an odd cycle), then we need to see if we can form a cycle by adding edges within the same component.\n\nWait, wait, no. Because in a single component, adding an edge would create a cycle. But the component's structure determines whether the cycle is even or odd.\n\nBut since the initial component is acyclic (as otherwise, the initial condition would have been triggered), it's a tree. So, adding any edge to the tree will create exactly one cycle.\n\nThe cycle's length depends on the structure of the tree.\n\nBut in a tree, adding an edge between two nodes u and v will create a cycle whose length is equal to the distance between u and v in the tree plus one (for the added edge).\n\nSo, the parity of the cycle's length is determined by the distance between u and v.\n\nIf the distance is even, the cycle length is even.\n\nIf the distance is odd, the cycle length is odd.\n\nSo, in a single component (which is a tree), adding one edge can create an odd-length cycle if there exist two nodes u and v with an odd distance between them.\n\nIs that possible?\n\nWell, in a tree, it's possible to have nodes with even and odd distances.\n\nFor example, in a straight line tree: 1-2-3-4-5.\n\nThe distance between 1 and 3 is 2 (even), 1 and 4 is 3 (odd).\n\nSo, adding an edge between 1 and 4 would create a cycle of length 3 (since the distance is 3, which is odd).\n\nSo, in such a case, adding one edge can create an odd-length cycle.\n\nSo, in this scenario, the minimal t is 1, and the number of ways is the number of pairs of nodes u, v in the tree such that the distance between u and v is odd.\n\nSo, the initial approach must consider this case.\n\nSo, putting it all together:\n\nThe overall algorithm is:\n\n1. Check if the graph has any odd-length cycles. If yes, output t=0, w=1.\n\n2. Else:\n\n   a. If the graph has at least two connected components, then the minimal t is 1, and the number of ways is the sum of (size_i * size_j) for all i < j.\n\n   b. Else (single component):\n\n      i. The component is a tree, since it's connected and has no cycles.\n\n      ii. Find the number of pairs of nodes u, v in the tree such that the distance between u and v is odd.\n\n      iii. The minimal t is 1.\n\n      iv. The number of ways is the count from step ii.\n\nSo, this complicates the problem because for the single-component case, we need to calculate the number of node pairs with an odd distance.\n\nThis seems computationally expensive for large n, but perhaps manageable with BFS for each node.\n\nBut given that n can be up to 1e5, this approach may not be feasible. Wait, but the problem constraints aren't specified. Let me assume n is up to 1e5.\n\nWait, but for n=1e5, performing BFS 1e5 times is impossible. So, perhaps we need a smarter approach.\n\nSo, the key challenge is to compute, for a tree, the number of pairs of nodes with an odd distance.\n\nHmm. How can we compute that efficiently?\n\nWell, the distance between two nodes is the sum of the parities of the edges along the path. So, the distance is even if the number of edges in the path is even, which depends on the path's parity.\n\nSo, for each node, we can compute the number of other nodes that are at an odd distance from it.\n\nThen, the total number of such pairs is sum over all nodes of the count of nodes at odd distance, divided by 2 (since each pair is counted twice).\n\nSo, how to compute, for each node u, the number of nodes v where the distance between u and v is odd.\n\nIn a tree, each node can be assigned a level (depth) starting from root. Then, the parity of the depth can be used to track the parity of the distance.\n\nWait, perhaps using BFS to assign levels and compute the parity.\n\nLet me explain:\n\nFor each node, compute its depth (the number of edges from the root). The distance between two nodes u and v is the sum of their depths minus 2* the depth of their LCA (lowest common ancestor). So, the parity of the distance is (depth[u] + depth[v] - 2*d_lca) mod 2.\n\nWhich simplifies to (depth[u] + depth[v]) mod 2, because 2*d_lca is even.\n\nSo, the parity of the distance between u and v is equal to (depth[u] + depth[v]) mod 2.\n\nSo, for each node u, the number of nodes v where (depth[u] + depth[v]) is odd is equal to the number of nodes v with depth[v] ≡ (1 - depth[u]) mod 2.\n\nSo, for each node, if it has c_even nodes at even depth and c_odd nodes at odd depth, then the number of nodes v where the distance is odd is c_even if depth[u] is odd, or c_odd if depth[u] is even.\n\nWait, let's clarify:\n\nIf depth[u] is even:\n\nThen, for v to have (depth[u] + depth[v]) mod 2 = 1, depth[v] must be odd.\n\nSo, the number of such v is the number of nodes with odd depth.\n\nIf depth[u] is odd:\n\nThen, v must have even depth for the sum to be odd.\n\nSo, for each node u, the number of nodes v with distance[u][v] odd is:\n\nif u's depth is even → count_odd\n\nelse → count_even\n\nWhere count_even is the number of nodes with even depth, and count_odd is the number with odd depth.\n\nSo, the total number of such pairs is:\n\nsum over all nodes u of (if u.depth is even: count_odd else count_even)\n\nBut since each pair is counted twice (u to v and v to u), the total number of unordered pairs is this sum divided by 2.\n\nSo, the approach is:\n\n1. Compute the depth of each node from a root (say, node 1).\n\n2. Count the number of nodes with even depth (count_even) and odd depth (count_odd).\n\n3. For each node u, if u's depth is even, add count_odd to the total.\n\n   Else, add count_even.\n\n4. The total is the sum, but each pair is counted twice, so divide by 2.\n\nSo, this gives the number of pairs (u, v) where the distance between u and v is odd.\n\nThus, the number of ways for the single component case is (sum) / 2.\n\nSo, putting it all together:\n\nThe steps are:\n\n- Check if the graph has any odd-length cycles. If yes, output t=0, w=1.\n\n- Else:\n\n   a. If there are at least two connected components:\n\n      i. t=1.\n\n      ii. w is the sum of (size_i * size_j) for all i < j.\n\n   b. Else (only one component):\n\n      i. Compute count_even and count_odd as described.\n\n      ii. The number of ways is (sum_even_contribution + sum_odd_contribution) // 2.\n\n         Where sum_even_contribution is count_odd * number_of_even_depth_nodes.\n\n         And sum_odd_contribution is count_even * number_of_odd_depth_nodes.\n\nWait, no:\n\nFor each node u:\n\nif u's depth is even → contributes count_odd.\n\nelse → contributes count_even.\n\nSo, sum = (count_even_nodes * count_odd) + (count_odd_nodes * count_even).\n\nWhich can be written as count_even * count_odd + count_odd * count_even = 2 * (count_even * count_odd).\n\nWait, no:\n\nWait, for each node u:\n\nif u is even → add count_odd.\n\nif u is odd → add count_even.\n\nSo, the total is:\n\n(count_even) * count_odd + (count_odd) * count_even = 2 * (count_even * count_odd).\n\nThus, the total is 2 * (count_even * count_odd).\n\nBut since each pair is counted twice, we divide by 2, giving (count_even * count_odd).\n\nWait, yes:\n\nTotal sum before division is 2 * (count_even * count_odd).\n\nAfter dividing by 2, it's count_even * count_odd.\n\nSo, the number of ways is count_even * count_odd.\n\nWait, that's a neat result.\n\nSo, for the single component case, the number of ways is (count_even) * (count_odd).\n\nSo, the algorithm becomes:\n\nCheck for existing odd cycle → t=0, w=1.\n\nElse:\n\nIf the number of connected components is ≥ 2:\n\nt=1, w is sum_{i < j} (size_i * size_j).\n\nElse:\n\nt=1, w is (count_even * count_odd).\n\nSo, this greatly simplifies the problem.\n\nNow, the steps are:\n\n1. Determine if the graph has an odd-length cycle.\n\n2. If not:\n\n   a. Compute the number of connected components.\n\n   b. If the number is ≥2:\n\n      i. Compute the sum of size_i * size_j for all i < j → this is (sum_sizes)^2 - sum(size_i^2) ) / 2.\n\n      Because sum_{i < j} size_i size_j = (sum size_i)^2 - sum size_i^2 ) / 2.\n\n   c. Else:\n\n      i. Compute the count_even and count_odd as described.\n\n      ii. w is count_even * count_odd.\n\nSo, the next step is to implement this.\n\nBut how to check if the graph has an odd-length cycle?\n\nTo detect whether a graph has an odd-length cycle, we can use the bipartition method.\n\nA graph is bipartite if and only if all cycles are of even length.\n\nSo, if the graph is bipartite, then there are no odd-length cycles.\n\nThus, the presence of any non-bipartite component indicates the graph has an odd-length cycle.\n\nSo, the steps to check for the presence of an odd cycle:\n\n- For each connected component, check if it's bipartite.\n\n- If any component is not bipartite, then the graph has an odd cycle.\n\nThus, the approach is:\n\nFor each connected component, perform a BFS to check for bipartiteness. If any component is not bipartite, mark the graph as having an odd cycle.\n\nSo, the plan is:\n\nImplement BFS-based bipartition checking for each component.\n\nNow, the code outline:\n\nRead n and m.\n\nBuild adjacency list.\n\nCompute connected components.\n\nFor each component:\n\n   Perform BFS.\n\n   Try to color the nodes in bipartition.\n\n   If during BFS, a conflict is found, mark the graph as non-bipartite.\n\nIf any component is non-bipartite → graph has an odd cycle.\n\nProceed accordingly.\n\nOnce that's done, proceed to compute the rest.\n\nSo, the code structure is:\n\nRead n, m.\n\nBuild adjacency list.\n\nFind connected components.\n\nCheck for any non-bipartite component.\n\nIf found → t=0, w=1.\n\nElse:\n\n   Compute the number of connected components.\n\n   If components ≥ 2:\n\n      Compute sum_sizes = sum of all component sizes.\n\n      Compute sum_sq = sum of (size^2) for all components.\n\n      w = (sum_sizes^2 - sum_sq) // 2.\n\n      t=1.\n\n   Else:\n\n      Compute count_even and count_odd.\n\n      w = count_even * count_odd.\n\n      t=1.\n\nOutput t and w.\n\nWait, but wait:\n\nWait, the sum of size_i * size_j for i < j is equal to (sum_i size_i)^2 - sum_i (size_i^2) ) / 2.\n\nYes, because (sum_i size_i)^2 = sum_i size_i^2 + 2*sum_{i<j} size_i size_j.\n\nSo, rearranged, sum_{i<j} size_i size_j = [ (sum size_i)^2 - sum size_i^2 ] / 2.\n\nSo, that's correct.\n\nThus, the code can compute sum_sizes and sum_sq, then compute w as (sum_sizes^2 - sum_sq) // 2.\n\nNow, the code can be structured as follows.\n\nBut first, the implementation details.\n\nImplementing Bipartition Check:\n\nWe'll represent the graph as an adjacency list.\n\nFor each component, we'll perform BFS, assigning colors. If during BFS, we find a neighbor with the same color, the component is not bipartite.\n\nConnected Components:\n\nWe can implement this using BFS or DFS, tracking visited nodes.\n\nOnce we have the connected components, proceed.\n\nSo, let's outline the code:\n\nRead n, m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n   u, v = map(int, input().split())\n\n   adj[u].append(v)\n\n   adj[v].append(u)\n\nvisited = [False]*(n+1)\n\ncomponents = []\n\nis_bipartite = True\n\nfor u in range(1, n+1):\n\n   if not visited[u]:\n\n      # BFS to find component\n\n      q = deque()\n\n      q.append(u)\n\n      visited[u] = True\n\n      color = [-1]*(n+1)\n\n      color[u] = 0\n\n      component = [u]\n\n      is_bipart = True\n\n      while q:\n\n          current = q.popleft()\n\n          for neighbor in adj[current]:\n\n              if not visited[neighbor]:\n\n                  visited[neighbor] = True\n\n                  color[neighbor] = color[current] ^ 1\n\n                  component.append(neighbor)\n\n                  q.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipart = False\n\n      if not is_bipart:\n\n          is_bipartite = False\n\n      components.append(component)\n\nSo, wait, no. Because in this code, for each component, we perform BFS and check if it's bipartitioned.\n\nBut the way it's written, the 'is_bipart' variable is set based on each component. But in the code above, 'is_bipart' is reset to True at each component, and if any component is not bipartitioned, 'is_bipartite' is set to False.\n\nWait, no. Because the outer loop runs for each unvisited u. So, for each component, the BFS is performed, and 'is_bipart' is checked.\n\nIf any component is not bipartitioned, 'is_bipartite' is set to False.\n\nBut the code",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length, and count the number of ways to achieve this. The solution involves checking if the graph already contains an odd-length cycle, and if not, determining the minimal edges required based on the connected components of the graph.\n\n### Approach\n\n1. **Check for Existing Odd-Length Cycles**:\n   - Use a BFS-based bipartite check for each connected component. If any component is non-bipartite, it indicates the presence of an odd-length cycle. If found, the result is `t=0` and `w=1`.\n\n2. **Connected Components Analysis**:\n   - If the graph does not contain an odd-length cycle, analyze the connected components. If there are at least two components, the minimum number of edges required (`t`) is 1. The number of ways (`w`) is calculated as the sum of the product of sizes of all pairs of components.\n\n3. **Single Component Case**:\n   - If the graph is a single component (a tree), compute the number of nodes at even and odd depths using BFS. The number of ways to form an odd-length cycle is the product of the counts of nodes at even and odd depths.\n\n### Solution Code\n\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * (n + 1)\n    components = []\n    has_odd_cycle = False\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            color = [-1] * (n + 1)\n            queue = deque()\n            queue.append(u)\n            visited[u] = True\n            color[u] = 0\n            is_bipart = True\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[current] ^ 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipart = False\n            if not is_bipart:\n                has_odd_cycle = True\n                break\n            components.append(len(color) - color[u].__lt__(0))\n    \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n    \n    num_components = len(components)\n    if num_components >= 2:\n        sum_sizes = sum(components)\n        sum_sq = sum(x * x for x in components)\n        w = (sum_sizes * sum_sizes - sum_sq) // 2\n        print(f\"1 {w}\")\n    else:\n        if num_components == 1:\n            root = components[0]\n            count_even = 0\n            count_odd = 0\n            depth = [0] * (n + 1)\n            visited_depth = [False] * (n + 1)\n            q = deque()\n            q.append(root)\n            visited_depth[root] = True\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited_depth[v]:\n                        depth[v] = depth[u] + 1\n                        visited_depth[v] = True\n                        q.append(v)\n            for i in range(1, n + 1):\n                if depth[i] % 2 == 0:\n                    count_even += 1\n                else:\n                    count_odd += 1\n            w = count_even * count_odd\n            print(f\"1 {w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n- **Bipartite Check**: Each connected component is checked for bipartiteness using BFS. If any component is non-bipartite, it indicates an odd-length cycle.\n- **Connected Components**: For multiple components, the minimum edges required is 1, and the number of ways is computed by considering all pairs of component sizes.\n- **Single Component**: For a single tree component, the number of nodes at even and odd depths is counted to determine the number of valid node pairs that form an odd-length cycle when connected by an additional edge.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * (n + 1)\n    components = []\n    has_odd_cycle = False\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            color = [-1] * (n + 1)\n            queue = deque()\n            queue.append(u)\n            visited[u] = True\n            color[u] = 0\n            is_bipart = True\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[current] ^ 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipart = False\n            if not is_bipart:\n                has_odd_cycle = True\n                break\n            components.append(len(color) - color[u].__lt__(0))\n    \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n    \n    num_components = len(components)\n    if num_components >= 2:\n        sum_sizes = sum(components)\n        sum_sq = sum(x * x for x in components)\n        w = (sum_sizes * sum_sizes - sum_sq) // 2\n        print(f\"1 {w}\")\n    else:\n        if num_components == 1:\n            root = components[0]\n            count_even = 0\n            count_odd = 0\n            depth = [0] * (n + 1)\n            visited_depth = [False] * (n + 1)\n            q = deque()\n            q.append(root)\n            visited_depth[root] = True\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if not visited_depth[v]:\n                        depth[v] = depth[u] + 1\n                        visited_depth[v] = True\n                        q.append(v)\n            for i in range(1, n + 1):\n                if depth[i] % 2 == 0:\n                    count_even += 1\n                else:\n                    count_odd += 1\n            w = count_even * count_odd\n            print(f\"1 {w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 933,
        "thoughts_token_count": 8193
    }
}