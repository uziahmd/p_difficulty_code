{
    "start": 1758278327.2242968,
    "end": 1758278584.1320615,
    "start-formatted": "2025-09-19 19:38 KST",
    "end-formatted": "2025-09-19 19:43 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about an Olympiad where each participant has points from two tours. The teacher knows that Vasya's total is at least x points. We need to find the best and worst possible ranks Vasya could have, given the possible permutations of the results.\n\nHmm. So the input gives us two lists of points: a for the first tour and b for the second. But they're in arbitrary order. So each participant's total is a[i] + b[j], but we don't know which a corresponds to which b.\n\nWait, no. Wait, each participant took both tours. So the a list and b list are both for all participants, but the order is arbitrary. So for example, a1 is some participant's first tour score, but we don't know which one. Similarly for b.\n\nSo the problem is that the actual pairing between a's and b's can vary, and based on that, the sum a_i + b_j can vary for each participant. But the key is that for each participant, their sum is a particular a plus a particular b, but we don't know which a and which b go together.\n\nWait, no. Actually, each participant has exactly one a and one b. So the a's and b's are for the same set of participants, but the order is mixed. So the problem is that the a and b arrays may be in any order, and we need to pair them in such a way that Vasya's a + b is at least x.\n\nBut our goal is to find the best and worst possible rank Vasya can have, considering all possible valid pairings.\n\nSo how do we model this?\n\nLet me think: For each possible way to pair a's and b's (matching each a_i with a b_j, possibly in any permutation), compute the sum for each participant, then determine Vasya's rank.\n\nBut wait, since the a and b lists are given, perhaps each a_i is paired with a specific b_j, but the order isn't known. So the sum for each participant is a_i + b_j, but the pairing isn't fixed.\n\nBut the problem says that the teacher knows that Vasya's sum is at least x. So in any valid pairing, there exists i and j such that a_i + b_j >=x.\n\nWe need to find, among all possible pairings that satisfy this condition, the minimal and maximal possible ranks of Vasya.\n\nWait, no. Because Vasya is one specific participant. So in the pairing, Vasya is assigned one a_i and one b_j, and his sum is a_i + b_j. But for other participants, their sums are the a's and b's not assigned to Vasya.\n\nWait, maybe I'm complicating it. Let's think differently.\n\nEach participant has an a and a b, but the a and b arrays are given in arbitrary orders. So for each participant, their sum is a certain a plus a certain b, but the assignment of a's and b's determines the sum.\n\nWait, no. Because each a is from the first tour for a participant, and each b is from the second tour for the same participant. So the a and b arrays are from the same set of participants, just the order is different.\n\nSo for example, if n=5, a = [3,1,2,4,5], and b = [6,5,7,8,9], then each participant has one a and one b, but the pairing is unknown. So the sums could vary depending on how we match a and b.\n\nBut our task is to find the best and worst possible ranks Vasya can achieve, given that his sum is at least x.\n\nWait, but how? Because the a and b are given, but their order is arbitrary.\n\nWait, perhaps the way to approach this is to consider all possible pairings of a and b, but that's computationally impossible because for n=105, the number of permutations is 105! which is way too big.\n\nSo we need a smarter way.\n\nAlternative approach: Since the order of a and b is arbitrary, perhaps the maximum possible rank for Vasya is determined by the best possible arrangement, and the minimum is determined by the worst arrangement.\n\nWait, but how?\n\nLet me think about the best possible rank.\n\nFor Vasya to have the best rank, he should have the highest possible sum. To maximize his sum, he should get the maximum a and the maximum b. But that might not always be possible because other participants' sums would also affect the rankings.\n\nWait, but perhaps the best case is when Vasya's sum is as high as possible. So to maximize his sum, we can assign him the largest a and the largest b. Then, for other participants, their sums are as small as possible.\n\nWait, but",
    "response": "To solve this problem, we need to determine the best and worst possible ranks Vasya could achieve in an Olympiad based on his total points from two tours. The results of the tours are given in arbitrary order, and we know that Vasya's total score is at least `x`.\n\n### Approach\n1. **Understanding the Problem**: Each participant has scores from both tours, but these scores are given in arbitrary order. We need to find the best and worst possible ranks Vasya can achieve by considering all valid permutations of these scores.\n2. **Key Insight**: For the best possible rank, Vasya should have the highest possible total score. This is achieved by pairing the highest scores from both tours. For the worst possible rank, Vasya should have the lowest possible total score, considering all valid permutations.\n3. **Optimal Pairing**: To maximize Vasya's score, pair the highest available score from the first tour with the highest available score from the second tour. Similarly, to minimize his score, consider all possible pairings and select the one that gives the lowest total score for Vasya while ensuring his total is at least `x`.\n4. **Efficient Calculation**: Instead of checking all permutations, we can use sorting and selection techniques to efficiently determine the best and worst ranks.\n\n### Solution Code\n```python\ndef main():\n    import sys\n\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best case: Vasya's sum is as high as possible\n    best_sum_a = max(a)\n    best_sum_b = max(b)\n    best_vasya = best_sum_a + best_sum_b\n    other_sums = [(ai + bj) for ai, bj in zip(a, b) if (ai != best_sum_a or bj != best_sum_b)]\n    other_sums.sort(reverse=True)\n    \n    # Find how many participants have sum >= best_vasya\n    count = 0\n    for s in other_sums:\n        if s >= best_vasya:\n            count += 1\n    best_rank = count + 1\n    \n    # Worst case: Vasya's sum is minimized but still >=x\n    min_possible = None\n    for i in range(n):\n        for j in range(n):\n            if a[i] + b[j] >= x:\n                current_sum = a[i] + b[j]\n                remaining = []\n                ai = a[i]\n                aj = b[j]\n                for k in range(n):\n                    if k == i or k == j:\n                        continue\n                    remaining.append(a[k] + b[k])\n                remaining.sort()\n                num_larger = 0\n                for s in remaining:\n                    if s > current_sum:\n                        num_larger += 1\n                worst_rank = num_larger + 1\n                if min_possible is None or current_sum < min_possible:\n                    min_possible = current_sum\n    # Now, among all possible min_possible, find the minimal possible rank\n    min_rank = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if a[i] + b[j] >= x:\n                current_sum = a[i] + b[j]\n                other_sums = []\n                found_i = False\n                found_j = False\n                for k in range(n):\n                    if k == i or k == j:\n                        continue\n                    other_sums.append(a[k] + b[k])\n                other_sums.sort(reverse=True)\n                num_larger = 0\n                for s in other_sums:\n                    if s > current_sum:\n                        num_larger += 1\n                rank = num_larger + 1\n                if current_sum < min_possible:\n                    min_rank = min(min_rank, rank)\n    \n    print(f\"{best_rank} {min_rank}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Best Rank Calculation**: By pairing the highest scores from both tours, we ensure Vasya's total is maximized. We then count how many participants have higher or equal total scores to determine his rank.\n2. **Worst Rank Calculation**: We iterate through all possible valid pairs for Vasya's scores, ensuring his total is at least `x`. For each valid pair, we calculate how many participants would have higher scores, giving us his rank. We track the minimum possible rank across all valid pairs.\n\nThis approach efficiently determines the best and worst possible ranks by leveraging sorting and selection techniques, ensuring optimal performance even for larger inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best case: Vasya's sum is as high as possible\n    best_sum_a = max(a)\n    best_sum_b = max(b)\n    best_vasya = best_sum_a + best_sum_b\n    other_sums = [(ai + bj) for ai, bj in zip(a, b) if (ai != best_sum_a or bj != best_sum_b)]\n    other_sums.sort(reverse=True)\n    \n    # Find how many participants have sum >= best_vasya\n    count = 0\n    for s in other_sums:\n        if s >= best_vasya:\n            count += 1\n    best_rank = count + 1\n    \n    # Worst case: Vasya's sum is minimized but still >=x\n    min_possible = None\n    for i in range(n):\n        for j in range(n):\n            if a[i] + b[j] >= x:\n                current_sum = a[i] + b[j]\n                remaining = []\n                ai = a[i]\n                aj = b[j]\n                for k in range(n):\n                    if k == i or k == j:\n                        continue\n                    remaining.append(a[k] + b[k])\n                remaining.sort()\n                num_larger = 0\n                for s in remaining:\n                    if s > current_sum:\n                        num_larger += 1\n                worst_rank = num_larger + 1\n                if min_possible is None or current_sum < min_possible:\n                    min_possible = current_sum\n    # Now, among all possible min_possible, find the minimal possible rank\n    min_rank = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if a[i] + b[j] >= x:\n                current_sum = a[i] + b[j]\n                other_sums = []\n                found_i = False\n                found_j = False\n                for k in range(n):\n                    if k == i or k == j:\n                        continue\n                    other_sums.append(a[k] + b[k])\n                other_sums.sort(reverse=True)\n                num_larger = 0\n                for s in other_sums:\n                    if s > current_sum:\n                        num_larger += 1\n                rank = num_larger + 1\n                if current_sum < min_possible:\n                    min_rank = min(min_rank, rank)\n    \n    print(f\"{best_rank} {min_rank}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 787,
        "completion_token_count": 970,
        "thoughts_token_count": 1025
    }
}