{
    "start": 1758103524.4406195,
    "end": 1758103647.8946066,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about selecting two vouchers such that their durations add up exactly to x, and they don't overlap in time. Also, among all possible pairs, I need to find the one with the minimal total cost. If there are no such pairs, I should return -1.\n\nHmm. So each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1.\n\nI need to select two vouchers, say i and j (i != j), where either ri < lj or rj < li. So they can't overlap at all. Also, the sum of their durations must be exactly x.\n\nSo the plan is: for all possible pairs of vouchers, check if their durations sum to x, and they don't overlap. Among those pairs, find the one with the smallest total cost.\n\nBut wait, n can be up to 2e5, so checking all O(n^2) pairs is impossible because that would be 4e10 operations, which is way too slow.\n\nSo I need a smarter approach.\n\nLet me think about the conditions:\n\nEach voucher has a duration d1 and d2. We need d1 + d2 = x.\n\nSo perhaps I can group vouchers by their duration, and for each possible pair of durations that sum to x, look for vouchers in those groups and find compatible pairs.\n\nFor example, if x is 10, then possible pairs are (d=3 and d=7, d=4 and d=6, etc.), as long as d1 + d2 = x.\n\nWait, but maybe I should process each voucher and see what other duration is needed to sum up to x. For each voucher with duration d, we need another voucher with duration (x - d).\n\nSo the idea is:\n\n- Create a dictionary where the key is the duration, and the value is a list of vouchers with that duration, along with their end times and costs.\n\nThen, for each voucher v1, we look for vouchers v2 in the list for duration (x - v1.duration). But also, we need to ensure that v1 and v2 do not overlap.\n\nBut even this might be expensive if done naively, because for each voucher, you might have to scan a lot of others.\n\nSo how can we optimize this?\n\nAlternative approach: For each voucher, precompute all possible vouchers that could come after it (start after its end) or before it (end before its start), depending on the required duration.\n\nWait, perhaps for each voucher i, we can find all vouchers j that have duration x - di, and are either entirely before i or entirely after i.\n\nSo for each voucher i:\n\n1. Find all vouchers j with duration (x - di) and rj < li. For these j's, since j ends before i starts, the pair (j, i) is valid.\n\n2. Find all vouchers j with duration (x - di) and lj > ri. For these j's, since j starts after i ends, the pair (i, j) is valid.\n\nWait, but in this case, when considering j's that are before i, we can take j and i as a pair, and vice versa. So perhaps for each i, we can collect all j's that have the complementary duration and are either before or after.\n\nBut again, for large n, this approach may be too slow unless optimized.\n\nSo let's think about the data structures.\n\nWe can create a dictionary, say duration_map, where for each duration d, we have a list of all vouchers with that duration, stored in a way that allows quick querying.\n\nAdditionally, for vouchers that end before a certain time, perhaps we can sort them by their end time, so that when given a voucher i, we can quickly find all vouchers j that end before li.\n\nSimilarly, for vouchers starting after a certain time, perhaps we can sort them by their start time, so that when given a voucher i, we can quickly find all j's that start after ri.\n\nSo here's a plan:\n\n1. Preprocess all vouchers into the duration_map. For each d, store the list of vouchers with duration d. Then, for each d in duration_map, sort the vouchers in that list by their end time and also by their start time.\n\n2. For each voucher v in the list:\n\n   a. Compute the required duration d_required = x - v.duration.\n\n   b. Check if d_required exists in duration_map.\n\n   c. For the required duration, look for vouchers j that can form a non-overlapping pair with v.\n\n   d. Split this into two cases:\n\n      i. j ends before v starts: rj < li.\n\n         So among all j's in duration_map[d_required], find those where rj < li.\n\n         Since the j's are sorted by end time, we can binary search to find the",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly x days and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Data Structure Setup**: Use a dictionary to group vouchers by their duration. Each entry in the dictionary will store a list of vouchers along with their end times and costs.\n2. **Sorting**: For each duration group, sort the vouchers by their end times and start times to facilitate efficient searching.\n3. **Pair Search**: For each voucher, determine the required complementary duration that would sum up to x. Check for vouchers in this complementary group that either end before the current voucher starts or start after the current voucher ends. Use binary search to efficiently find these valid pairs.\n4. **Cost Calculation**: Track the minimum cost of valid pairs found during the search.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    x = int(input[idx + 1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        li = int(input[idx])\n        ri = int(input[idx + 1])\n        cost = int(input[idx + 2])\n        idx += 3\n        vouchers.append((li, ri, cost))\n    \n    # Group vouchers by duration\n    duration_map = {}\n    for l, r, c in vouchers:\n        d = r - l + 1\n        if d not in duration_map:\n            duration_map[d] = []\n        duration_map[d].append((r, c))\n    \n    # Sort each group by end time and start time\n    for d in duration_map:\n        # Sort by end time for binary search\n        duration_map[d].sort(key=lambda x: x[0])\n        # Sort by start time for binary search\n        duration_map[d].sort(key=lambda x: x[1])\n    \n    min_cost = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i + 1\n        required_d = x - d_i\n        \n        if required_d not in duration_map:\n            continue\n        \n        j_list = duration_map[required_d]\n        # Case 1: j ends before i starts (r_j < l_i)\n        # Binary search for the largest r_j <= l_i -1\n        target = l_i - 1\n        left = 0\n        right = len(j_list) - 1\n        best = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if j_list[mid][0] <= target:\n                best = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best != -1:\n            min_cost = min(min_cost, j_list[best][1] + c_i)\n        \n        # Case 2: j starts after i ends (l_j > r_i)\n        # We need l_j > r_i, so we can look for j's with l_j > r_i\n        # Binary search for the first j where l_j > r_i\n        target = r_i + 1\n        left = 0\n        right = len(j_list) - 1\n        best = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if j_list[mid][1] >= target:\n                best = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best != -1:\n            min_cost = min(min_cost, j_list[best][1] + c_i)\n    \n    print(min_cost if min_cost != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: Vouchers are grouped by their duration and sorted to allow efficient binary search operations.\n2. **Binary Search for Non-overlapping Pairs**: For each voucher, we check for valid pairs in the complementary duration group using binary search to quickly find non-overlapping vouchers either ending before the current voucher starts or starting after it ends.\n3. **Efficiency**: The approach ensures that we efficiently find valid pairs without checking all possible pairs, making the solution feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    x = int(input[idx + 1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        li = int(input[idx])\n        ri = int(input[idx + 1])\n        cost = int(input[idx + 2])\n        idx += 3\n        vouchers.append((li, ri, cost))\n    \n    # Group vouchers by duration\n    duration_map = {}\n    for l, r, c in vouchers:\n        d = r - l + 1\n        if d not in duration_map:\n            duration_map[d] = []\n        duration_map[d].append((r, c))\n    \n    # Sort each group by end time and start time\n    for d in duration_map:\n        # Sort by end time for binary search\n        duration_map[d].sort(key=lambda x: x[0])\n        # Sort by start time for binary search\n        duration_map[d].sort(key=lambda x: x[1])\n    \n    min_cost = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i + 1\n        required_d = x - d_i\n        \n        if required_d not in duration_map:\n            continue\n        \n        j_list = duration_map[required_d]\n        # Case 1: j ends before i starts (r_j < l_i)\n        # Binary search for the largest r_j <= l_i -1\n        target = l_i - 1\n        left = 0\n        right = len(j_list) - 1\n        best = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if j_list[mid][0] <= target:\n                best = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best != -1:\n            min_cost = min(min_cost, j_list[best][1] + c_i)\n        \n        # Case 2: j starts after i ends (l_j > r_i)\n        # We need l_j > r_i, so we can look for j's with l_j > r_i\n        # Binary search for the first j where l_j > r_i\n        target = r_i + 1\n        left = 0\n        right = len(j_list) - 1\n        best = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if j_list[mid][1] >= target:\n                best = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best != -1:\n            min_cost = min(min_cost, j_list[best][1] + c_i)\n    \n    print(min_cost if min_cost != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 937,
        "thoughts_token_count": 1025
    }
}