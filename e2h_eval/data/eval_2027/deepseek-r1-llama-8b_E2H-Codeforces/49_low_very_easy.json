{
    "start": 1758278836.3452015,
    "end": 1758279274.5288002,
    "start-formatted": "2025-09-19 19:47 KST",
    "end-formatted": "2025-09-19 19:54 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about reconstructing the number of laughy mushrooms on each lawn based on some given roads. Each road has two numbers: the GCD and LCM of the two lawns it connects. My task is to determine if there's a possible arrangement of the mushroom counts that satisfies all these roads, and if so, output any one such arrangement.\n\nHmm. So the input gives me n lawns and m roads. Each road is between two lawns, say u and v, and has GCD(g) and LCM(l). The constraints are that for each pair u-v, the GCD of their mushroom counts must be g, and their LCM must be l.\n\nWait, but what's the relationship between GCD and LCM? Oh right, for any two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So if I know the GCD and LCM for a pair, I can compute a and b up to a multiple.\n\nBut since I'm trying to find possible values for a and b, I need to model this as a system of equations where each equation is a_i * a_j = g_ij * l_ij (since g_ij is the GCD and l_ij is the LCM, so a_i * a_j = g_ij * l_ij).\n\nWait, no. Wait, for any two numbers a and b:\n\na * b = GCD(a, b) * LCM(a, b)\n\nYes, that's correct. So for each pair of connected nodes, their product equals g_ij * l_ij.\n\nSo each edge gives an equation: a_u * a_v = g_uv * l_uv.\n\nBut wait, the GCD and LCM could be from different edges, but they might not all agree on the same a values. So the problem reduces to solving a system of multiplicative equations.\n\nThis feels like a problem that can be modeled using Union-Find with some additional data structures, perhaps. Because each edge imposes a constraint between two variables.\n\nLet me think about how to model this. For each node, we can track its value, but since it's multiplicative, perhaps we can represent each variable as a product of primes, but that might get complicated. Alternatively, maybe we can model each variable in terms of a ratio or logarithm, but that could lead to precision issues.\n\nAlternatively, since each equation is a_u * a_v = k, where k is known, perhaps we can model this as a graph where each edge represents a ratio. For example, a_u / a_v = k / (a_u * a_v) ? No, wait, perhaps a_u = k/(a_v), but that's only if a_v is known. Hmm, maybe not.\n\nWait, let's think differently. Each edge between u and v gives us a_u * a_v = g * l, where g is the GCD and l is the LCM. But wait, isn't the GCD the greatest common divisor of a_u and a_v, and the LCM is the least common multiple? So the GCD is the largest number that divides both a_u and a_v, and the LCM is the smallest number that is a multiple of both.\n\nBut given that, perhaps for each pair u-v, the product is fixed as g * l, which is also equal to a_u * a_v. So for each edge, a_u * a_v = g * l.\n\nBut how do I model this for all edges?\n\nAnother approach: For each node, assign a value x_i, representing the number of mushrooms. Then for each edge (u, v, g, l), we have x_u * x_v = g * l.\n\nWait, but that's not entirely accurate because the GCD is part of the problem. Because the GCD of x_u and x_v is g, which implies that x_u and x_v are multiples of g, and their quotient is co-prime.\n\nWait, let's see: Let’s denote a = x_u and b = x_v. Then GCD(a, b) = g, and LCM(a, b) = l.\n\nSo a = g * m, b = g * n, where GCD(m, n) = 1. Then LCM(a, b) = g * m * n, because when m and n are coprime, the LCM is the product.\n\nSo the product a*b = g^2 * m*n. But we also have a*b = g*l, so:\n\ng*l = g^2 * m*n → l = g * m *n → So m *n = l/g.\n\nSince m and n are coprime, m and n must be divisors of l/g, and their product is l/g.\n\nSo for each edge, the product x_u *x_v must be g*l,",
    "response": "To solve this problem, we need to determine if it's possible to reconstruct the number of laughy mushrooms on each lawn based on given roads and their respective GCD and LCM values. If possible, we should output any valid arrangement; otherwise, we should indicate that it's not possible.\n\n### Approach\n1. **Problem Analysis**: Each road connects two lawns and provides a GCD and an LCM. The key insight is that for any two numbers, the product of their GCD and LCM equals the product of the numbers themselves. This gives us a system of multiplicative equations to solve.\n\n2. **Graph Representation**: We can model the problem using a graph where each node represents a lawn and each edge represents a road with its GCD and LCM. The goal is to assign values to each node such that all edge constraints are satisfied.\n\n3. **Union-Find Data Structure**: We use Union-Find (Disjoint Set Union) to manage connected components of the graph. For each component, we track the product of values assigned to nodes in terms of a common base value.\n\n4. **Equation Solving**: For each edge, we derive an equation based on the given GCD and LCM. If the edge forms a cycle, we check if the derived equations are consistent. If inconsistent, the problem has no solution.\n\n5. **Consistency Check**: For each component, we ensure that the derived values from edges are consistent. If any inconsistency is found, we output \"NO\". Otherwise, we compute the values for each node.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        parts = sys.stdin.readline().split()\n        u = int(parts[0])\n        v = int(parts[1])\n        g = int(parts[2])\n        l = int(parts[3])\n        edges.append((u, v, g, l))\n    \n    parent = list(range(n+1))\n    rank = [1]*(n+1)\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v, k):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] *= k\n        else:\n            parent[v_root] = u_root\n            rank[u_root] *= k\n        return True\n    \n    possible = True\n    x = [1]*(n+1)\n    for u, v, g, l in edges:\n        if find(u) != find(v):\n            union(u, v, g * l // (g * l))\n        else:\n            current_gcd = g\n            current_lcm = l\n            a = x[u]\n            b = x[v]\n            actual_gcd = a * b // max(a, b)\n            if actual_gcd != current_gcd:\n                possible = False\n                break\n            if (a * b) != (current_gcd * current_lcm):\n                possible = False\n                break\n            if a > current_lcm or b > current_lcm:\n                possible = False\n                break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    components = defaultdict(list)\n    for i in range(1, n+1):\n        root = find(i)\n        components[root].append(i)\n    \n    for comp in components.values():\n        if len(comp) == 1:\n            continue\n        base = x[comp[0]]\n        for node in comp[1:]:\n            expected = (g * l) // (base * x[node])\n            if expected != 1:\n                possible = False\n                break\n            if x[node] > (g * l) // x[comp[0]]:\n                possible = False\n                break\n            if x[node] > (g * l) // base:\n                possible = False\n                break\n            if base > (g * l) // x[node]:\n                possible = False\n                break\n            if x[node] < (g * l) // (base * x[node]):\n                possible = False\n                break\n            if base > (g * l) // x[node]:\n                possible = False\n                break\n            if x[node] < (g * l) // base:\n                possible = False\n                break\n        if not possible:\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    for u, v, g, l in edges:\n        a = x[u]\n        b = x[v]\n        if a * b != g * l:\n            possible = False\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    for i in range(1, n+1):\n        if x[i] <= 0:\n            possible = False\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(' '.join(map(str, x[1:])))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution uses a Union-Find data structure to manage connected components and solve the system of multiplicative equations derived from the given edges. Each edge imposes a constraint on the product of the values of the connected nodes. By checking consistency within each component, we determine if a valid assignment of mushroom counts exists. If so, we output the values; otherwise, we indicate that it's impossible.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        parts = sys.stdin.readline().split()\n        u = int(parts[0])\n        v = int(parts[1])\n        g = int(parts[2])\n        l = int(parts[3])\n        edges.append((u, v, g, l))\n    \n    parent = list(range(n+1))\n    rank = [1]*(n+1)\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v, k):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] *= k\n        else:\n            parent[v_root] = u_root\n            rank[u_root] *= k\n        return True\n    \n    possible = True\n    x = [1]*(n+1)\n    for u, v, g, l in edges:\n        if find(u) != find(v):\n            union(u, v, g * l // (g * l))\n        else:\n            current_gcd = g\n            current_lcm = l\n            a = x[u]\n            b = x[v]\n            actual_gcd = a * b // max(a, b)\n            if actual_gcd != current_gcd:\n                possible = False\n                break\n            if (a * b) != (current_gcd * current_lcm):\n                possible = False\n                break\n            if a > current_lcm or b > current_lcm:\n                possible = False\n                break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    components = defaultdict(list)\n    for i in range(1, n+1):\n        root = find(i)\n        components[root].append(i)\n    \n    for comp in components.values():\n        if len(comp) == 1:\n            continue\n        base = x[comp[0]]\n        for node in comp[1:]:\n            expected = (g * l) // (base * x[node])\n            if expected != 1:\n                possible = False\n                break\n            if x[node] > (g * l) // x[comp[0]]:\n                possible = False\n                break\n            if x[node] > (g * l) // base:\n                possible = False\n                break\n            if base > (g * l) // x[node]:\n                possible = False\n                break\n            if x[node] < (g * l) // (base * x[node]):\n                possible = False\n                break\n            if base > (g * l) // x[node]:\n                possible = False\n                break\n            if x[node] < (g * l) // base:\n                possible = False\n                break\n        if not possible:\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    for u, v, g, l in edges:\n        a = x[u]\n        b = x[v]\n        if a * b != g * l:\n            possible = False\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    for i in range(1, n+1):\n        if x[i] <= 0:\n            possible = False\n            break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(' '.join(map(str, x[1:])))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 545,
        "completion_token_count": 1204,
        "thoughts_token_count": 1025
    }
}