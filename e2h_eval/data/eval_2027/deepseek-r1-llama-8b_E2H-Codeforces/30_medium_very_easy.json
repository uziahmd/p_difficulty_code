{
    "start": 1758288482.513927,
    "end": 1758290903.220368,
    "start-formatted": "2025-09-19 22:28 KST",
    "end-formatted": "2025-09-19 23:08 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about a game where two players, Homer and Marge, take turns picking digits from a number A, which has 2n digits. Each player makes exactly n moves. The goal is to maximize the sum of their prizes, which are the numbers they build by taking the digits in order. The output should be a string of 'H' and 'M' indicating whose turn it was each step.\n\nHmm, right. So the task is to find the sequence of moves that maximizes S1 + S2, where S1 is the number Homer gets and S2 is Marge's. But wait, no—wait, the problem says \"maximizing their total prize.\" Oh, wait, wait: the sum of S1 and S2? Or maybe the maximum between them? No, looking back, the problem says \"their total prize.\" So it's the sum.\n\nWait no, the problem says Homer and Marge want to maximize their total prize. So S1 + S2 should be as large as possible.\n\nWait, but what defines the prize? The prize is S1 for Homer and S2 for Marge. So the total is S1 + S2.\n\nSo our aim is to arrange the choices such that when we add all the digits taken by both, the sum is maximized.\n\nBut how do the choices affect this? Because each choice affects both S1 and S2. For example, if a high digit is given to S1 early on, it contributes more because it's multiplied by a higher place value.\n\nWait, but let's think: each digit is used exactly once in either S1 or S2. So the total sum S1 + S2 is just the sum of all digits in A. Because S1 is the concatenation of some digits, S2 the others; their sum is the sum of all digits. Wait, no: for example, if A is 99, n=1, then the total would be 9+9=18 regardless of who takes which. So the sum is fixed. Wait, is that correct?\n\nWait, yes. Because each digit is added to either S1 or S2. So S1 + S2 is equal to the sum of all digits of A. So the total is fixed. So the problem is to maximize the individual values of S1 and S2, but their sum is fixed. Hmm, but the problem statement says they want to maximize their total prize. So perhaps the problem is to maximize the sum of the two numbers, but since the sum is fixed, perhaps the problem is to choose the order such that the individual numbers are as large as possible. Or maybe I'm misunderstanding.\n\nWait, wait. Let me re-read the problem statement.\n\nThey want to find a sequence that maximizes their total prize. The prize is S1 dollars for the first player, S2 for the second. So the total is S1 + S2. But as each digit is used exactly once, the sum is fixed. So why does the problem mention anything about maximizing the sum? It must be that the problem is actually to maximize the individual maximum between S1 and S2, or perhaps the product, but the problem says 'total prize' which suggests sum.\n\nWait, perhaps I'm missing something. Oh, wait, the problem says 'maximize their total prize.' So perhaps the sum is not fixed. Wait, no, because each digit is added to either S1 or S2. So the sum S1 + S2 is the sum of all the digits. So regardless of how you assign the digits, the total is fixed. So the problem reduces to assigning the digits to S1 and S2 in a way that each player makes exactly n moves, and the sum is fixed. Therefore, perhaps the problem is to maximize the minimum of S1 and S2, or something else. Or maybe it's to arrange the digits in such a way that the sum of their places in their respective numbers is maximized.\n\nWait, perhaps I'm misunderstanding. Let me think differently.\n\nEach move, a player takes the leftmost digit. So the order of digits in A is crucial. For example, if A is 1234, n=2, then each player will take two digits.\n\nThe initial A is 1,2,3,4. The first player (Homer) takes the first digit, then the second, third, etc., but each player alternates. Wait, no: the players take turns, and each makes exactly n moves. So for n=2, each will make two moves.\n\nWait, the process is:\n\n- The players decide who goes first. But in the problem statement, it says that each player makes exactly n moves. So the order is determined by the initial choice of who starts.\n\nWait, but the problem asks us to find the sequence of moves (the H and M's) that gives the maximum total prize. So the initial decision is part of the problem.\n\nWait, but how does the initial decision affect the outcome? For example, if Homer starts first, he can get the first digit, then Marge the next, etc. Or if Marge starts first.\n\nSo the problem is to arrange the assignment of digits to S1 and S2, with exactly n digits each, such that the sum S1 + S2 is as large as possible. But as we've established, the sum is fixed, so perhaps the problem is to maximize the individual S1 and S2, but since their sum is fixed, perhaps the problem is to choose the arrangement that allows S1 and S2 to be as large as possible.\n\nWait, but wait: the sum is fixed. So the problem might be to maximize the maximum of S1 and S2, or perhaps to distribute the digits in a way that both S1 and S2 are as large as possible. But the problem statement says \"maximize their total prize\", which is S1 + S2. But since that's fixed, perhaps the problem is to maximize the individual maximum of S1 and S2, but that's not stated.\n\nAlternatively, perhaps I'm misunderstanding the problem. Maybe the prize is S1 multiplied by S2, but that's not what the problem says.\n\nWait, perhaps the problem is to maximize the sum of S1 and S2, but since that's fixed, perhaps the problem is to arrange the digits such that both S1 and S2 are as large as possible in their own right.\n\nBut that doesn't make sense either. So perhaps I need to re-examine the problem statement.\n\nLooking back: the output is a sequence of 'H' and 'M's, which represents the order of moves. Each move, the current player takes the first digit of A, appends it to their number, and then the digit is removed from A.\n\nSo the key is to decide, at each step, whether the current player is H or M.\n\nBut the goal is to maximize the total prize, which is S1 + S2.\n\nBut as each digit is used exactly once, S1 + S2 is equal to the sum of all digits in A. So the sum is fixed. Therefore, perhaps the problem is not to maximize the sum, but to choose the order of digits in S1 and S2 such that both numbers are as large as possible.\n\nWait, but how does the order affect the numbers? Because the digits are taken in the order of A, and each is added to either S1 or S2.\n\nWait, for example, if A is 321, n=1. Then:\n\nIf Homer starts, he takes 3, then Marge takes 2, then Homer takes 1. So S1 is 31, S2 is 2. Sum is 33.\n\nAlternatively, if Marge starts, she takes 3, then Homer takes 2, then Marge takes 1. S1 is 21, S2 is 31. Sum is same, 52.\n\nWait, but the sum is fixed. So why would the problem ask for the maximum sum? It must be that I'm misunderstanding the problem.\n\nWait, perhaps the prize is S1 multiplied by S2. Or perhaps the problem is to maximize the maximum of S1 and S2.\n\nBut the problem says \"total prize.\" Hmm.\n\nWait, perhaps the problem is to maximize the sum of S1 and S2, but that's fixed. So perhaps the problem is to arrange the digits so that S1 and S2 are as balanced as possible. Like, if one is very large, the other is small, but perhaps the sum is fixed.\n\nWait, but in the sample input, for example:\n\nSample Input:\nn=2\nA=9911\n\nWait, no, the sample input in the example shows:\n\nWait, the user provided:\n\n['2\\n1234', '2\\n9911']\n\nBut the output is ['HHMM', 'HMHM'].\n\nWait, perhaps the sample explanation can help. Let's see:\n\nIn the first case, the A is '1234' (so 4 digits, n=2). So each player makes two moves.\n\nSample Output is 'HHMM' meaning H, H, M, M.\n\nSo the steps are:\n\nTurn 1: H takes 1 → S1 = 1.\n\nA becomes '234'.\n\nTurn 2: H takes 2 → S1 = 12.\n\nA becomes '34'.\n\nTurn 3: M takes 3 → S2 = 3.\n\nA becomes '4'.\n\nTurn 4: M takes 4 → S2 = 34.\n\nTotal S1 is 12, S2 is 34. Sum is 46.\n\nAlternatively, another possible arrangement could be 'HMHM'?\n\nWait, perhaps the sample isn't directly relevant. Let's try to think differently.\n\nAnother approach: the problem is to arrange the selection of digits into S1 and S2 such that when we consider the contribution of each digit to S1 and S2 based on their position, the sum S1 + S2 is maximized.\n\nWait, but each digit is added to only one of the numbers. So the sum S1 + S2 is the sum of all digits, which is fixed. So why is the problem asking for the maximum? There must be a different interpretation.\n\nAh! Wait, perhaps the prize is the maximum of S1 and S2. Because the problem says, \"maximize their total prize.\" So perhaps the goal is to maximize the larger of the two. But that's not clear.\n\nWait, looking back at the problem statement: it says \"which gives them maximum possible total prize.\" So the total prize is S1 + S2. So the sum is fixed. So the problem is a bit confusing.\n\nAlternatively, perhaps the prize is the maximum of S1 and S2. Or perhaps the product.\n\nWait, perhaps the problem is to maximize S1 * S2. That could be a possibility. Because if that's the case, then the arrangement of digits would matter a lot. For example, if all high digits are given to one player, their product would be lower than distributing them to both.\n\nBut the problem statement says \"their total prize,\" which implies addition. So perhaps the problem is indeed to maximize S1 + S2, which is fixed, but perhaps the problem is miswritten.\n\nAlternatively, perhaps the prize is the sum of the digits, but the problem wants the maximum of S1 and S2. But I'm not sure.\n\nWait, perhaps I should re-express the problem in terms of the actual goal.\n\nLet me think about the sample input:\n\nSample Input:\nn=2\nA=9911\n\nWait, A is '9911' → digits are 9,9,1,1.\n\nThe output is 'HMHM' → which is H, M, H, M.\n\nSo the steps are:\n\nTurn 1: H takes 9 → S1=9.\n\nA becomes '911'.\n\nTurn 2: M takes 9 → S2=9.\n\nA becomes '11'.\n\nTurn 3: H takes 1 → S1=91.\n\nA becomes '1'.\n\nTurn 4: M takes 1 → S2=91.\n\nSo S1 is 91, S2 is 91. Sum is 182.\n\nAnother possible arrangement could be 'HMHM':\n\nTurn 1: H takes 9 → S1=9.\n\nA is '911'.\n\nTurn 2: M takes 1 → S2=1.\n\nA is '91'.\n\nTurn 3: H takes 9 → S1=99.\n\nA is '1'.\n\nTurn 4: M takes 1 → S2=11.\n\nSum is 99 + 11 = 110, which is less than 182.\n\nSo clearly, in this case, giving the two 9s to the two players gives a higher sum.\n\nSo perhaps the optimal strategy is to assign the highest available digits alternately to H and M, starting with whichever gives the higher overall sum.\n\nBut how?\n\nWait, perhaps the optimal strategy is to assign the largest remaining digit to the player who can contribute the most to the sum.\n\nBut I'm not sure.\n\nAlternatively, perhaps the optimal strategy is to alternate the assignment of the largest available digits, but choosing which player takes the next digit based on whether that would lead to a higher sum.\n\nBut this seems vague.\n\nWait, perhaps the key is to model this as a dynamic programming problem.\n\nBecause the state depends on which digits have been taken so far, and which player is to take the next digit.\n\nBut with 2n digits and n up to 18, the state space is manageable.\n\nWait, n can be up to 18, so 2n is 36. So the state can be represented by a bitmask indicating which digits have been taken, along with the current player.\n\nBut even for 36 digits, the bitmask is 2^36, which is around 7e10, which is way too big.\n\nSo that approach isn't feasible.\n\nAlternative approach: perhaps the optimal strategy is to always assign the next largest digit to the player who benefits the most from it.\n\nWait, perhaps for each digit, we assign it to the player whose current number is larger, so that adding the digit to the larger number would maximize the sum.\n\nBut that might not always work.\n\nWait, for example, suppose we have two digits: 9 and 8. Assigning 9 to H and 8 to M gives S1=9, S2=8, sum 17. Alternatively, assign 8 to H and 9 to M: S1=8, S2=9, sum 17. Same.\n\nBut what about three digits: 9,9,8.\n\nIf n=2, then each player takes two digits.\n\nOption 1: H takes 9, M takes 9, H takes 8 → S1=98, S2=9. Sum 107.\n\nOption 2: H takes 9, M takes 8, H takes 9 → S1=99, S2=8. Sum 107.\n\nSame.\n\nSo perhaps the order doesn't matter for the sum, but for the individual values.\n\nBut the problem requires to choose the order that leads to maximum sum, which is fixed. So perhaps the problem is to choose any order that leads to a particular distribution of digits between the players, but the sum is fixed.\n\nWait, perhaps I'm misunderstanding the problem completely. Let me re-read.\n\nThe problem says that each player makes exactly n moves, and the prize is S1 and S2. So the sequence of H and M determines how the digits are assigned to each player. The goal is to choose this sequence to maximize the sum S1 + S2.\n\nBut since each digit is used exactly once, the sum is fixed as the sum of all digits. So the problem is perhaps to choose any sequence that assigns the digits, but perhaps the problem is to arrange the digits in a way that S1 and S2 are as large as possible individually. Or perhaps the problem is to choose the order of moves that maximizes the individual maximum of S1 and S2.\n\nBut that's not stated.\n\nAlternatively, perhaps the problem is to maximize the product of S1 and S2. But again, the problem says 'sum.'\n\nThis is confusing.\n\nWait, perhaps the problem is to find the sequence of moves that gives the maximum possible sum of the two numbers, but the sum is fixed. So the problem is trivial, as any sequence would give the same sum. But that can't be, because the sample shows different outputs with the same sum.\n\nWait, in the sample input, the output is 'HMHM' which gives S1=91 and S2=91, sum 182. If another arrangement gives S1=99 and S2=11, sum 110, which is smaller. So perhaps the sum is not fixed. Oh, wait no, the sum of the digits is 9+9+1+1=20. So the sum of S1 and S2 is 20, but 91+91=182, which is much larger than 20.\n\nWait, that can't be right. How is that possible?\n\nWait, wait, wait. I think I made a mistake earlier. The numbers S1 and S2 are built by appending digits, not adding their numerical values. So S1 is the number formed by the digits taken by Homer, and S2 is the number formed by Marge's digits.\n\nAh! So S1 is the integer formed by the digits in the order they were taken, same for S2. So the sum S1 + S2 is not the sum of the digits, but the sum of the numbers built by those digits.\n\nOh, okay, that changes everything.\n\nSo the problem is to arrange the digits into two numbers, each of length n, such that the sum S1 + S2 is as large as possible.\n\nAnd the way the digits are arranged is by taking the leftmost digit of A in each turn. Each player takes exactly n digits, and the order of taking is determined by the sequence of H and M.\n\nSo the goal is to choose the sequence of H and M so that the sum of the two numbers is maximized.\n\nSo now, the problem makes sense.\n\nSo the problem is to split the digits of A into two groups, each of size n, such that when each group is arranged in the order they were taken (i.e., the order of the original A), the sum of the two numbers is as large as possible.\n\nWait, but wait: the order of the digits is determined by the original A. So the first digit is taken first, then the next, etc. So the sequence of H and M determines which player takes each digit, but the order of the digits in S1 and S2 is fixed as per their positions in A.\n\nWait, no. For example, the first digit is taken by the first player, the second by the next player, etc. So S1 and S2 are built by taking the first, third, fifth, etc. digits, in that order.\n\nWait, no: each turn, the leftmost digit is taken. So for the sequence H, M, H, M, the first digit is taken by H, the second by M, third by H, fourth by M. So S1 is the first, third, fifth, etc. digits in order, concatenated. Similarly for S2.\n\nSo the problem is to choose the order of players (H or M) for each step, such that the sum of the two numbers built by the digits assigned to each player is maximized.\n\nSo the key is to arrange the digits into two sequences, each of length n, taken in the order of A, such that the sum of the two numbers is as large as possible.\n\nThe way to do this is to assign the earliest possible high-value digits to the players in a way that their contributions to the sum are maximized.\n\nSo the question is, for each position in the sequence, decide whether it's H or M, such that the sum of the two numbers is maximized.\n\nHmm. So the approach is to model this as a dynamic programming problem where the state represents the current position in the string and the number of digits each player has taken so far.\n\nWait, yes. Let's think about it.\n\nWe can model the problem using DP, where dp[i][h] represents the maximum sum achievable after processing the first i digits, with h digits assigned to H so far, and (i - h) digits assigned to M.\n\nWait, but since each player must take exactly n digits, the state needs to track how many digits each has taken.\n\nSo for each position i (from 0 to 2n-1), and for h in 0..n, m in 0..n, where h + m = i, we can represent the state as (i, h), and the value is the maximum sum achievable up to that point.\n\nBut wait, for each position i, the number of digits taken by H is h, and by M is i - h.\n\nWait, perhaps the state is (i, h), representing that we've processed i digits, and H has taken h digits, so M has taken i - h.\n\nAt each step, we can decide to assign the (i+1)-th digit to H or M, provided that neither exceeds n.\n\nSo the transition is:\n\nFor state (i, h), when processing the (i+1)-th digit, we can assign it to H if h < n, leading to state (i+1, h+1), and the digit contributes its value multiplied by 10^{n - (h + 1)} } to S1, and similarly for assigning to M.\n\nWait, no. Because S1 is the number formed by the digits taken by H, in the order they appear. Similarly for S2. So the position of the digit in the overall string determines its place value in S1 or S2.\n\nSo for example, the first digit in the overall string is the first digit of S1 or S2, depending on who took it. The second digit is the second digit of the respective number, and so on.\n\nSo the place value for each digit depends on when it's taken. For instance, if a digit is taken as the k-th digit in the overall string, it contributes 10^{(n - (k // 2))} * digit to the respective number (if it's H's turn) or to M's.\n\nWait, perhaps not. Let's think: the first digit is the first digit of S1 or S2, the second is the second digit, etc.\n\nWait, for S1 and S2, their digits are taken in the order they appear in A. So for example, if the first digit is taken by H, it's the first digit of S1. The second digit, if taken by M, is the first digit of S2. The third digit, taken by H, is the second digit of S1. The fourth, taken by M, is the second digit of S2, and so on.\n\nSo the place value of each digit in S1 or S2 depends on its position in the overall string.\n\nWait, for example:\n\nSuppose A is d1, d2, d3, d4, ..., d_{2n}.\n\nWhen a digit dk is taken by H, it is the (k+1)th digit in the overall string. So, in S1, the position of this digit is (number of digits H has already taken + 1). Similarly for M.\n\nWait, perhaps it's better to model the contribution of each digit as follows:\n\nEach digit is added to either S1 or S2. Its position in S1 is determined by how many digits H has taken before it. For example, if the first digit is taken by H, it's the first digit of S1. If the third digit is taken by H, it's the second digit of S1.\n\nSimilarly, for M, the digits are taken in the order of their positions in A, but only when it's M's turn.\n\nSo for each digit dk, when it's assigned to H, it contributes dk * 10^{p}, where p is the number of digits already assigned to H before this one. Similarly for M.\n\nWait, that's a good way to model it.\n\nSo for each digit, the place value in the respective number depends on when it's taken relative to the previous assignments.\n\nThus, the problem is to assign each digit to either H or M, ensuring that exactly n are assigned to each, and the sum of their numbers is maximized.\n\nBut how to model this.\n\nHmm. So the dynamic programming approach would track the number of digits assigned to H and M so far, and for each digit, decide which player to assign it to, considering the place value.\n\nWait, but the place value depends on the order in which digits are assigned. For example, the first digit assigned to H is the first digit of S1, contributing 10^{n-1}, the next is 10^{n-2}, etc.\n\nWait, no. Because S1 has exactly n digits, so the first digit assigned to H is the most significant digit, followed by the next, etc. So for H's k-th digit, it's multiplied by 10^{n - k}.\n\nSimilarly, for M's digits, each is multiplied by 10^{n - (m)}, where m is the position in M's number (1-based).\n\nWait, perhaps the key is to model for each digit, the current length of S1 and S2.\n\nSo for each step i (processing the i-th digit in A), and for counts h and m (number of digits assigned to H and M so far, respectively), we can compute the maximum sum achievable.\n\nBut this would require a 3-dimensional DP: i, h, m. However, since h + m = i, we can reduce it to 2 dimensions.\n\nLet me think: for each i (0 <= i <= 2n), and for each h (0 <= h <= n), the corresponding m is i - h. So the DP state can be (i, h), representing that we've processed the first i digits, and H has h digits, M has i - h.\n\nAt each step, for the (i+1)-th digit (d_i+1), we can decide to assign it to H or M, provided that h < n or m < n, respectively.\n\nWait, but the digit is in position i+1 of A. So, the place value in H's number would be 10^{h} (since h is the count of digits assigned to H before this step; adding one more makes it h+1, so the new digit is multiplied by 10^{h}).\n\nSimilarly, for M, the place value is 10^{i - h}.\n\nWait, perhaps I'm getting confused.\n\nWait, for H's number, the first digit is the first time H takes a digit, say at position k in A. Then, in S1, it's the (h_prev + 1)-th digit, so multiplied by 10^{n - (h_prev + 1)}.\n\nSimilarly, for M's number, the first digit taken by M is at position l in A. It is the (m_prev + 1)-th digit, so multiplied by 10^{n - (m_prev + 1)}.\n\nWait, perhaps it's easier to think of each digit's contribution as follows:\n\nFor each digit at position i (0-based?), when assigned to H, it's the (h+1)-th digit in S1, so its contribution is d * 10^{n - (h + 1)}.\n\nSimilarly, if assigned to M, it's the (m+1)-th digit in S2, so contribution is d * 10^{n - (m + 1)}.\n\nYes, this seems correct.\n\nSo, for each digit in A, when processing it, if we assign it to H, its contribution is d * 10^{n - (h + 1)}. If assigned to M, it's d * 10^{n - (m + 1)}.\n\nThus, the DP state can be represented as (i, h), where i is the current position in A, and h is the number of digits assigned to H so far.\n\nThe DP transition would be, for each state (i, h), and for each possible assignment (H or M), update the next state accordingly.\n\nThe initial state is (0, 0), with a sum of 0.\n\nFor each state (i, h), if the next digit (i) is assigned to H, then the new state is (i+1, h+1), and the sum increases by d_i * 10^{n - (h + 1)}.\n\nSimilarly, if assigned to M, the new state is (i+1, h), and the sum increases by d_i * 10^{n - (m + 1)}, where m = i - h.\n\nWait, but m = i - h because h + m = i.\n\nSo for each state (i, h), when processing the i-th digit (assuming 0-based?), we can choose to assign it to H or M, provided h < n or (i - h) < n.\n\nThus, the recurrence is:\n\ndp[i+1][h+1] = max(dp[i+1][h+1], dp[i][h] + (digit * 10^{n - (h+1)}))\n\nand \n\ndp[i+1][h] = max(dp[i+1][h], dp[i][h] + (digit * 10^{n - (i - h)}))\n\nWait, but i is the current position, which is 0-based. So digit i is the (i+1)-th digit in 1-based terms.\n\nWait, perhaps I should index the digits as 0-based, from 0 to 2n-1.\n\nSo for i in 0..2n-1, digit is A[i].\n\nThen, for state (i, h), which represents that we've processed the first i digits, and H has h digits, M has i - h digits.\n\nAt each step, for digit i, we can assign it to H (if h < n) or to M (if (i - h) < n).\n\nSo the transition is:\n\nIf assign to H:\n\nnew_h = h + 1\n\ncontribution = A[i] * 10^{n - new_h}\n\nso dp[i+1][new_h] = max(dp[i+1][new_h], dp[i][h] + contribution)\n\nIf assign to M:\n\nnew_m = (i - h) + 1\n\ncontribution = A[i] * 10^{n - new_m}\n\nso dp[i+1][h] = max(dp[i+1][h], dp[i][h] + contribution)\n\nWait, but in this case, new_m = i - h + 1.\n\nBecause after adding this digit to M, M's count becomes (i - h) + 1.\n\nYes.\n\nSo the DP will proceed as follows:\n\nInitialize dp[0][0] = 0.\n\nFor each i from 0 to 2n-1:\n\n   for each h in 0..n:\n\n      if dp[i][h] is not infinity:\n\n          // assign to H if possible\n\n          if h < n:\n\n              new_h = h + 1\n\n              power = 10^(n - new_h)\n\n              contribution = digit * power\n\n              if dp[i+1][new_h] < dp[i][h] + contribution:\n\n                  update dp[i+1][new_h]\n\n          // assign to M if possible\n\n          m = i - h\n\n          if m < n:\n\n              new_m = m + 1\n\n              power = 10^(n - new_m)\n\n              contribution = digit * power\n\n              if dp[i+1][h] < dp[i][h] + contribution:\n\n                  update dp[i+1][h]\n\nOnce filled, the maximum sum is dp[2n][n], since h must be exactly n.\n\nOnce we have the maximum sum, we need to reconstruct the path to get the sequence of H and M.\n\nSo the plan is:\n\n1. Precompute the powers of 10 up to 10^18.\n\n2. Initialize the DP table, which is a 2D array of size (2n+1) x (n+1), filled with -infinity, except dp[0][0] = 0.\n\n3. Iterate over each digit, and for each possible h, update the next states.\n\n4. After filling the DP table, backtrack from dp[2n][n] to determine the sequence of H and M.\n\nNow, considering the constraints:\n\nn can be up to 18, so 2n is 36. So the DP table is 37 x 19, which is manageable.\n\nEach transition involves 2 possibilities (assign to H or M), so the total number of transitions is O(36*19*2) = about 1380, which is acceptable.\n\nNow, the challenge is to implement this correctly.\n\nBut for the backtracking part, we need to store the path taken to reach dp[2n][n]. So perhaps during the DP, we can keep track of the parent pointers, i.e., for each state (i, h), store which decision (H or M) was taken to reach it, and from which state.\n\nAlternatively, during the backtracking, we can simulate the process: starting from (2n, n), for each step, decide whether the last digit was assigned to H or M.\n\nSo, for each state (i, h), to find the previous state, we can look for all possible previous states that could have led to it.\n\nWait, but for the backtracking, perhaps it's easier to reconstruct the path by checking, for each state, which decision (H or M) was taken to reach it.\n\nSo, for each state (i, h), if it was reached by assigning the i-th digit to H, then the previous state is (i-1, h-1). Otherwise, it was assigned to M, and the previous state is (i-1, h).\n\nThus, the backtracking can proceed by starting at (2n, n) and moving backwards, determining whether the last digit was assigned to H or M.\n\nThus, the steps are:\n\n- Read n and the string A.\n\n- Compute the digits as integers.\n\n- Precompute the powers of 10.\n\n- Initialize the DP table.\n\n- Fill the DP table.\n\n- Backtrack from (2n, n) to construct the sequence.\n\nNow, let's think about how to implement the backtracking.\n\nWe'll start at (2n, n). We'll check if the previous state was (2n-1, n) (meaning the last digit was assigned to H) or (2n-1, n-1) (assigned to M).\n\nWait, for state (i, h), the previous state is (i-1, h') where h' is h if the last digit was assigned to M, or h-1 if assigned to H.\n\nSo, for state (i, h):\n\nprev_h = h if (i-1)th digit was assigned to M.\n\nprev_h = h-1 if (i-1)th digit was assigned to H.\n\nWait, but for i=2n, it's the last digit, and we need to know whether it was assigned to H or M.\n\nBut perhaps it's better to process from i=2n down to 0.\n\nSo, starting at i=2n, h=n.\n\nWe can then loop from i=2n down to 0:\n\nfor each step, determine whether the i-th digit was assigned to H or M.\n\nWait, perhaps in code, the backtracking can be implemented as follows:\n\npath = []\ncurrent_i = 2n\ncurrent_h = n\n\nwhile current_i > 0:\n\n   if current_i == 0:\n       break\n\n   if current_i-1 >=0 and h' = h-1 is valid (h' >=0):\n\n       if dp[current_i][current_h] > dp[current_i-1][current_h -1] + contribution:\n\n           assigned to H.\n\n           path.append('H')\n\n           current_i -=1\n\n           current_h -=1\n\n   else:\n\n       assigned to M.\n\n       path.append('M')\n\n       current_i -=1\n\n       current_h remains same.\n\nWait, perhaps not. Let's think.\n\nAt each step, the current digit is at position i-1, and we're trying to determine whether it was assigned to H or M.\n\nWait, perhaps the backtracking function can be:\n\ndef backtrack(i, h):\n\n    if i == 0 and h ==0:\n\n        return []\n\n    if i ==0:\n\n        # invalid, but probably won't happen.\n\n        return None\n\n    # Determine if the last digit was assigned to H or M.\n\n    max_val = -inf\n\n    best_choice = None\n\n    if h >0:\n\n        # could have been assigned to H.\n\n        prev_i = i-1\n\n        prev_h = h-1\n\n        if prev_i >=0:\n\n            val = dp[prev_i][prev_h]\n\n            # the digit is A[i-1], and its contribution is A[i-1] * 10^{n - h}.\n\n            # because when it's assigned to H, h is h-1 +1 = h, so the exponent is n - h.\n\n            # wait, in the DP, when we assign to H, the exponent is n - (h_new) = n - (h-1 +1) = n - h.\n\n            # So the contribution is A[i-1] * 10^{n - h}.\n\n            contribution = A[i-1] * (10 ** (n - h))\n\n            total = val + contribution\n\n            if total > max_val:\n\n                max_val = total\n\n                best_choice = 'H'\n\n    if (i-1 - h) < n:\n\n        # could have been assigned to M.\n\n        prev_i = i-1\n\n        prev_m = (i-1 - h) \n\n        # prev_m +1 is (i-1 - h) +1 = i - h.\n\n        # the exponent is n - (i - h).\n\n        # since the digit is assigned to M, m = i-1 -h, so new m is m+1 = i-h.\n\n        # contribution is A[i-1] * 10^{n - (i - h)}\n\n        exponent = n - (i - h)\n\n        contribution = A[i-1] * (10 ** exponent)\n\n        prev_val = dp[prev_i][h]\n\n        total = prev_val + contribution\n\n        if total > max_val:\n\n            max_val = total\n\n            best_choice = 'M'\n\n    if best_choice is None:\n\n        # impossible, but shouldn't happen.\n\n        return None\n\n    path.append",
    "response": "To solve this problem, we need to determine the sequence of moves for two players, Homer and Marge, in a TV game such that their total prize is maximized. The prize is determined by the numbers they form by taking digits from a given string in turns.\n\n### Approach\n1. **Problem Analysis**: The goal is to maximize the sum of the numbers formed by Homer (S1) and Marge (S2). Each player must take exactly `n` digits from a string of `2n` digits. The key insight is that each digit's contribution to the final sum depends on its position in the resulting numbers.\n\n2. **Dynamic Programming (DP) Approach**: We use a DP table where `dp[i][h]` represents the maximum sum achievable after processing the first `i` digits, with `h` digits assigned to Homer. The state transitions consider assigning each digit to either Homer or Marge, ensuring neither exceeds `n` digits.\n\n3. **Backtracking for Path Reconstruction**: After filling the DP table, we backtrack from the final state to determine the sequence of moves. This involves checking whether each digit was assigned to Homer or Marge based on the DP values.\n\n### Solution Code\n```python\nn = int(input())\nA = list(map(int, list(input().strip())))\n\nlength = len(A)\nmax_h = n\n\n# Precompute powers of 10\npower = [1] * (n + 1)\nfor i in range(1, n + 1):\n    power[i] = power[i - 1] * 10\n\n# Initialize DP table\nINF = float('-inf')\ndp = [[INF] * (n + 1) for _ in range(length + 1)]\ndp[0][0] = 0\n\nfor i in range(length):\n    current_digit = A[i]\n    for h in range(n + 1):\n        if dp[i][h] == INF:\n            continue\n        # Assign to H\n        if h < n:\n            new_h = h + 1\n            contribution = current_digit * power[n - new_h]\n            if dp[i + 1][new_h] < dp[i][h] + contribution:\n                dp[i + 1][new_h] = dp[i][h] + contribution\n        # Assign to M\n        m = i - h\n        if m < n:\n            new_m = m + 1\n            contribution = current_digit * power[n - new_m]\n            if dp[i + 1][h] < dp[i][h] + contribution:\n                dp[i + 1][h] = dp[i][h] + contribution\n\n# Backtrack to find the sequence\nresult = []\ncurrent_i = length\ncurrent_h = n\n\nwhile current_i > 0:\n    max_val = -1\n    best_choice = None\n    # Check if it could have been assigned to H\n    if current_h > 0:\n        prev_i = current_i - 1\n        prev_h = current_h - 1\n        if prev_h >= 0:\n            prev_sum = dp[prev_i][prev_h]\n            digit = A[prev_i]\n            exponent = n - current_h\n            contribution = digit * power[exponent]\n            total = prev_sum + contribution\n            if total > max_val:\n                max_val = total\n                best_choice = 'H'\n    # Check if it could have been assigned to M\n    if current_i - current_h < n:\n        prev_i = current_i - 1\n        m_prev = current_i - current_h - 1\n        if m_prev >= 0:\n            prev_sum = dp[prev_i][current_h]\n            digit = A[prev_i]\n            exponent = n - (current_i - current_h)\n            contribution = digit * power[exponent]\n            total = prev_sum + contribution\n            if total > max_val:\n                max_val = total\n                best_choice = 'M'\n    \n    if best_choice is not None:\n        result.append(best_choice)\n        if best_choice == 'H':\n            current_h -= 1\n        current_i -= 1\n    else:\n        # This should not happen as per the problem constraints\n        break\n\n# The moves are collected in reverse order, so reverse them\nresult.reverse()\nprint(''.join(result))\n```\n\n### Explanation\n1. **Precompute Powers of 10**: This helps in quickly calculating the contribution of each digit based on its position in the resulting numbers.\n2. **DP Table Initialization**: The table is initialized to store the maximum sum achievable for each state.\n3. **Filling the DP Table**: For each digit, we consider both possible assignments (to Homer or Marge) and update the DP table accordingly.\n4. **Backtracking**: Starting from the final state, we determine the sequence of moves by checking which assignment led to the maximum sum at each step.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves using dynamic programming and then reconstruct the path to determine the exact sequence of turns.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\nA = list(map(int, list(input().strip())))\n\nlength = len(A)\nmax_h = n\n\n# Precompute powers of 10\npower = [1] * (n + 1)\nfor i in range(1, n + 1):\n    power[i] = power[i - 1] * 10\n\n# Initialize DP table\nINF = float('-inf')\ndp = [[INF] * (n + 1) for _ in range(length + 1)]\ndp[0][0] = 0\n\nfor i in range(length):\n    current_digit = A[i]\n    for h in range(n + 1):\n        if dp[i][h] == INF:\n            continue\n        # Assign to H\n        if h < n:\n            new_h = h + 1\n            contribution = current_digit * power[n - new_h]\n            if dp[i + 1][new_h] < dp[i][h] + contribution:\n                dp[i + 1][new_h] = dp[i][h] + contribution\n        # Assign to M\n        m = i - h\n        if m < n:\n            new_m = m + 1\n            contribution = current_digit * power[n - new_m]\n            if dp[i + 1][h] < dp[i][h] + contribution:\n                dp[i + 1][h] = dp[i][h] + contribution\n\n# Backtrack to find the sequence\nresult = []\ncurrent_i = length\ncurrent_h = n\n\nwhile current_i > 0:\n    max_val = -1\n    best_choice = None\n    # Check if it could have been assigned to H\n    if current_h > 0:\n        prev_i = current_i - 1\n        prev_h = current_h - 1\n        if prev_h >= 0:\n            prev_sum = dp[prev_i][prev_h]\n            digit = A[prev_i]\n            exponent = n - current_h\n            contribution = digit * power[exponent]\n            total = prev_sum + contribution\n            if total > max_val:\n                max_val = total\n                best_choice = 'H'\n    # Check if it could have been assigned to M\n    if current_i - current_h < n:\n        prev_i = current_i - 1\n        m_prev = current_i - current_h - 1\n        if m_prev >= 0:\n            prev_sum = dp[prev_i][current_h]\n            digit = A[prev_i]\n            exponent = n - (current_i - current_h)\n            contribution = digit * power[exponent]\n            total = prev_sum + contribution\n            if total > max_val:\n                max_val = total\n                best_choice = 'M'\n    \n    if best_choice is not None:\n        result.append(best_choice)\n        if best_choice == 'H':\n            current_h -= 1\n        current_i -= 1\n    else:\n        # This should not happen as per the problem constraints\n        break\n\n# The moves are collected in reverse order, so reverse them\nresult.reverse()\nprint(''.join(result))",
    "score": 0,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 1051,
        "thoughts_token_count": 8194
    }
}