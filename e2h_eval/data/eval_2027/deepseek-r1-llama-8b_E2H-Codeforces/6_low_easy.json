{
    "start": 1758103528.5579927,
    "end": 1758103646.8614848,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about selecting two vouchers such that their durations add up exactly to x and they don't overlap. Also, the total cost should be as minimal as possible. If it's impossible, we return -1.\n\nHmm, let's break down the requirements.\n\nEach voucher has a start day (li), end day (ri), and cost (costi). The duration of each voucher is ri - li + 1. So for two vouchers i and j, the sum of their durations must be exactly x. Also, they can't overlap. So either voucher i ends before voucher j starts or vice versa.\n\nOur goal is to find the pair (i,j) where i≠j, their durations add up to x, they don't overlap, and their total cost is minimized.\n\nFirst, I need to think about how to approach this efficiently, especially since n can be up to 2e5, which is quite large. So an O(n^2) approach is definitely out of the question. We need something smarter.\n\nLet me think about the steps:\n\n1. For each voucher, calculate its duration. Then, for each voucher, we need to find another voucher whose duration is x minus the current one's duration. So for each voucher with duration d, we look for vouchers with duration x - d.\n\nBut wait, since x can be up to 2e5*2 (since each voucher's duration can be up to 2e5), but perhaps more accurately, x can be up to 4e5? Not sure, but in any case, for each voucher, we need to find other vouchers that fit certain criteria.\n\nSo the plan is:\n\n- Precompute all vouchers and their durations.\n- Group them by duration. For each duration d, have a list of vouchers with that duration.\n- Then, for each voucher, check if there exists another voucher with duration x-d, and that these two don't overlap.\n\nBut even this approach might not be efficient because for each voucher, we may have to process many others.\n\nWait, but perhaps we can pre-sort the vouchers based on their end times. That way, for a given voucher i, any voucher j that comes after i's end time can be checked quickly using binary search.\n\nAlternatively, for each possible duration d, we can keep track of the earliest ending vouchers. Or maybe, for each possible duration d, have the vouchers sorted by their end times, so that when looking for a non-overlapping voucher, we can perform a binary search.\n\nLet me outline the steps:\n\n1. Read all vouchers, compute their durations, and store all of them along with their end times and costs.\n\n2. For each voucher, compute its duration d. Then, the required duration for another voucher is x_d = x - d. So for each voucher, we need to find another voucher with duration x_d, and that voucher either ends before this voucher starts or starts after this voucher ends.\n\n3. To do this efficiently, for each duration, we can keep the list of vouchers sorted by their end times. Then, for a given voucher i, we can look into the list of vouchers with duration x_d, and find those that end before li or start after ri.\n\nWait, but how to structure this. Maybe for each possible duration, we have a list of vouchers sorted by their end time. Then, for each voucher i, when we are looking for a voucher j with duration x_d, we can query in the j's list for vouchers that end before li or start after ri.\n\nBut how do we handle both cases?\n\nAlternatively, for each duration d, we can sort the vouchers by their end time. Then, for a voucher i with duration d_i, and looking for x_d = x - d_i, we can consider the following:\n\n- Vouchers j with duration x_d that end before i's start: So for j's list, we can perform a binary search to find all j where rj < li. The minimal cost among those would be our candidate.\n\n- Vouchers j with duration x_d that start after i's end: For this, we can find all j where lj > ri. Again, find the minimal cost.\n\nWait, no. Because for j to end before i, we need rj < li. For j to start after i, we need lj > ri.\n\nBut wait, the condition for non-overlapping is that either rj < li or lj > ri.\n\nSo for a voucher i, we can find all vouchers j where duration is x - d_i, and either rj < li or lj > ri.\n\nSo for each voucher i, we can:\n\na) Look for vouchers j with duration x_d = x - d_i, and rj < li. Among these, find the one with the smallest cost.\n\nb) Look for vouchers j with duration x_d = x - d_i, and lj > ri. Among",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly x days and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Data Preprocessing**: Read all vouchers and compute their durations. Store each voucher along with its start day, end day, and cost.\n2. **Grouping by Duration**: Group vouchers by their duration. For each duration, maintain a list of vouchers sorted by their end times.\n3. **Efficient Search**: For each voucher, determine the required duration for another voucher to sum up to x. Check if there exists a voucher with the required duration that either ends before the current voucher starts or starts after the current voucher ends.\n4. **Binary Search**: Use binary search on the sorted lists of vouchers to efficiently find valid pairs and compute the minimum cost.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    index = 2\n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        c = int(data[index + 2])\n        index += 3\n        duration = r - l + 1\n        vouchers.append((l, r, c, duration))\n    \n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        l, r, c, d = v\n        duration_map[d].append((r, c))\n    \n    min_cost = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i, d_i = vouchers[i]\n        needed_d = x - d_i\n        if needed_d not in duration_map:\n            continue\n        \n        # Case 1: j ends before i starts (r_j < l_i)\n        j_list_r = duration_map[needed_d]\n        pos = bisect.bisect_left([r for r, c in j_list_r], l_i)\n        if pos > 0:\n            min_c = min(c for r, c in j_list_r[:pos])\n            if min_c < min_cost:\n                min_cost = min_c\n        \n        # Case 2: j starts after i ends (l_j > r_i)\n        j_list_l = [(l, c) for l, c in j_list_r]\n        pos = bisect.bisect_right([l for l, c in j_list_l], r_i)\n        if pos < len(j_list_l):\n            min_c = min(c for l, c in j_list_l[pos:])\n            if min_c < min_cost:\n                min_cost = min_c\n    \n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with its start day, end day, cost, and duration.\n2. **Grouping Vouchers**: Vouchers are grouped by their duration using a dictionary where each key is a duration and the value is a list of tuples containing the end day and cost of vouchers with that duration.\n3. **Iterating Over Vouchers**: For each voucher, we check if there exists another voucher with the required duration to sum up to x. We use binary search to efficiently find valid pairs.\n4. **Binary Search**: For each voucher, we use binary search to find vouchers that end before it starts or start after it ends, ensuring they do not overlap. We keep track of the minimum cost found.\n5. **Output Result**: After processing all vouchers, if a valid pair is found, the minimum cost is printed; otherwise, -1 is printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    index = 2\n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        c = int(data[index + 2])\n        index += 3\n        duration = r - l + 1\n        vouchers.append((l, r, c, duration))\n    \n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        l, r, c, d = v\n        duration_map[d].append((r, c))\n    \n    min_cost = float('inf')\n    \n    for i in range(n):\n        l_i, r_i, c_i, d_i = vouchers[i]\n        needed_d = x - d_i\n        if needed_d not in duration_map:\n            continue\n        \n        # Case 1: j ends before i starts (r_j < l_i)\n        j_list_r = duration_map[needed_d]\n        pos = bisect.bisect_left([r for r, c in j_list_r], l_i)\n        if pos > 0:\n            min_c = min(c for r, c in j_list_r[:pos])\n            if min_c < min_cost:\n                min_cost = min_c\n        \n        # Case 2: j starts after i ends (l_j > r_i)\n        j_list_l = [(l, c) for l, c in j_list_r]\n        pos = bisect.bisect_right([l for l, c in j_list_l], r_i)\n        if pos < len(j_list_l):\n            min_c = min(c for l, c in j_list_l[pos:])\n            if min_c < min_cost:\n                min_cost = min_c\n    \n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 686,
        "completion_token_count": 815,
        "thoughts_token_count": 1025
    }
}