{
    "start": 1758103640.5830543,
    "end": 1758103815.1304598,
    "start-formatted": "2025-09-17 19:07 KST",
    "end-formatted": "2025-09-17 19:10 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about determining whether a certain number of vertices n can form a snowflake graph as defined by Rudolf. The snowflake graph has specific construction rules. \n\nHmm, let me try to understand the structure. So, the snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices, where k is greater than 1. Then, each vertex that has only one edge (so degree 1) must be connected to k new vertices. And importantly, this step has to be done at least once.\n\nWait, right. So the initial step adds k children. Then, each of those children will add k more, but only if they are leaves (degree 1). But wait, after adding the first layer, each of the k nodes becomes a parent with k children. So for each such node, we add k children, which are leaves. So in the next step, each of these will have to add their own k children.\n\nSo the structure is a rooted tree where the root has k children, each of those has k children, and this continues for at least two levels. Because the initial step is level 1: root. Then level 2: k nodes. Then level 3: each of those adds k, so k² nodes. And so on.\n\nBut the problem allows for more layers. So the total number of nodes is calculated based on how many layers there are.\n\nLet me think about the formula for the number of nodes.\n\nEach layer m contributes k^{m} nodes. Wait, no, because each node in layer m has k children in layer m+1. So the total nodes would be the sum from m=0 to m=d of k^m, where d is the depth.\n\nWait, maybe it's better to model the snowflake as a tree where each node except the leaves has exactly k children. So the root has k children, each of those has k children, etc., for some number of steps.\n\nWait, no, the snowflake is built by adding layers. The initial step is the root. Then, it adds a layer of k nodes. Then, for each existing leaf (nodes with degree 1), it adds k children. So the process can continue for multiple layers.\n\nSo the total number of nodes in the snowflake is the sum of k^m for m from 0 to h, where h is the number of layers. But wait, no. Because the initial step is the root (1 node), then the first expansion adds k nodes. Then, each of those adds k nodes, leading to k² nodes added, etc.\n\nWait, perhaps the structure is that each time you perform an expansion step, you go one layer deeper. So the initial root is one node. Then, after the first expansion (step 1), you have 1 + k nodes. Then, after the second expansion (step 2), you have 1 + k + k² nodes. And so on, until you perform at least two expansions.\n\nWait, no. Because according to the problem statement, the initial step is the root, then the first expansion adds k nodes. Then, each of those is expanded (each adds k nodes, making k²), but this step is done at least once. So the minimal snowflake has the root, plus k nodes in the first expansion, plus each of those having k nodes in the second expansion. So the minimal total is 1 + k + k².\n\nBut the problem says that the expansion step should be done at least once. So the minimal case is when the root is expanded once. Or wait, perhaps the expansion is done once, meaning that the root has k children, each of which is expanded once, adding their own k children. So the minimal case has 1 + k + k² = (k³ -1)/(k-1) when h=3? Wait, maybe I'm getting confused.\n\nAlternatively, perhaps the snowflake is a tree where every internal node has exactly k children. So the tree is a k-ary tree of height h, where h >= 2. Because the root is at height 0, and each expansion step increases the height by 1.\n\nSo the total number of nodes is (k^(h+1) - 1)/(k-1). Because the sum from m=0 to h of k^m is (k^(h+1)-1)/(k-1).\n\nWait, yes, because for a k-ary tree of height h, the number of nodes is 1 + k + k² + ... + k^h = (k^{h+1} -1)/(k-1).\n\nSo, for a snowflake to exist, n must equal (k^{h+1} - 1)/(k-1) for some k>1 and h>=2.\n\nBecause the expansion step must be done at",
    "response": "To solve this problem, we need to determine if a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in a specific way, and our task is to check if such a structure can exist for the given \\( n \\).\n\n### Approach\nThe snowflake graph is built by repeatedly expanding each leaf node (a node with only one edge) by adding \\( k \\) new nodes, where \\( k > 1 \\). This expansion must occur at least once beyond the initial root node. \n\nThe key insight is that the total number of nodes in a snowflake graph after \\( h \\) expansions (where \\( h \\geq 2 \\)) can be represented by the formula:\n\n\\[ n = \\frac{k^{h+1} - 1}{k - 1} \\]\n\nThis formula comes from the sum of a geometric series where each term represents the nodes added at each level of the tree.\n\nTo solve the problem, we need to:\n1. Iterate through each test case.\n2. For each \\( n \\), check if it can be expressed in the form of the formula above for some \\( k > 1 \\) and \\( h \\geq 2 \\).\n3. If such \\( k \\) and \\( h \\) exist, output \"YES\"; otherwise, output \"NO\".\n\n### Solution Code\n```python\nimport sys\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # We need to find k>1 and h>=2 such that n = (k^(h+1)-1)/(k-1)\n    # Let's try all possible h starting from 2 up to log2(n) +1\n    max_h = 60  # since 2^60 is about 1e18, which covers the constraints\n    for h in range(2, max_h+1):\n        # Solve for k: (k^(h+1)-1)/(k-1) = n\n        # Rearranged: k^h * (k/(k-1)) + k^{h-1}/(k-1) + ... + 1/(k-1) = n\n        # Alternatively, using the formula: n*(k-1) = k^h + k^{h-1} + ... + 1\n        # So, n*(k-1) = (k^{h+1} - 1)/(k-1)\n        # So, k^{h+1} - 1 = n*(k-1)^2\n        # But this might not be easy to solve directly.\n        # Another approach: binary search for k\n        left = 2\n        right = n-1  # since k must be less than n\n        while left <= right:\n            mid = (left + right) // 2\n            # Compute s = (mid^(h+1) -1)/(mid-1)\n            # But calculating mid^(h+1) could be too big, so we need to check for overflow\n            try:\n                numerator = mid ** (h + 1) - 1\n                denominator = mid - 1\n                if denominator == 0:\n                    continue  # avoid division by zero, but mid >=2, so no\n                s = numerator // denominator\n            except OverflowError:\n                s = float('inf')\n            if s == n:\n                return True\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    if n == 1:\n        print(\"NO\")\n        continue\n    found = False\n    # Check for h starting from 2 upwards\n    max_h = 60  # since 2^60 is about 1e18\n    for h in range(2, max_h + 1):\n        left = 2\n        right = n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # Calculate (mid^(h+1) -1)/(mid -1)\n            # To avoid overflow, compute step by step\n            power = 1\n            for _ in range(h + 1):\n                power *= mid\n                if power > n * (mid - 1):\n                    break\n            if power > n * (mid - 1):\n                right = mid - 1\n                continue\n            total = (power - 1) // (mid - 1)\n            if total == n:\n                found = True\n                break\n            elif total < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if found:\n            break\n    print(\"YES\" if found else \"NO\")\n\n# Alternative optimized approach using binary search for k\ndef check(n):\n    max_k = n - 1  # since k must be at least 2\n    for h in range(2, 60):\n        left = 2\n        right = max_k\n        while left <= right:\n            mid = (left + right) // 2\n            # Compute s = (mid^(h+1) -1)/(mid-1)\n            # To prevent overflow, compute in a way that stops early if possible\n            s = 0\n            current = 1\n            for _ in range(h + 1):\n                current *= mid\n                if current > n * (mid - 1):\n                    break\n                s += current\n            if s > n * (mid - 1):\n                right = mid - 1\n                continue\n            if s == n * (mid - 1):\n                return True\n            elif s < n * (mid - 1):\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    if n < 3:\n        print(\"NO\")\n        continue\n    found = False\n    max_h = 60\n    for h in range(2, max_h + 1):\n        left = 2\n        right = n - 1  # since k >=2\n        while left <= right:\n            mid = (left + right) // 2\n            # Calculate s = (mid^(h+1) - 1) / (mid - 1)\n            # To prevent overflow, compute step by step\n            s_num = mid ** (h + 1) - 1\n            s_den = mid - 1\n            if s_den == 0:\n                continue  # mid is 1, but k>1 so skip\n            if s_num > s_den * n:\n                right = mid - 1\n                continue\n            s = s_num // s_den\n            if s == n:\n                found = True\n                break\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if found:\n            break\n    print(\"YES\" if found else \"NO\")\n```\n\n### Explanation\nThe solution involves checking for each test case whether the given number of vertices \\( n \\) can form a snowflake graph. This is done by iterating over possible values of \\( h \\) (the depth of the tree) and performing a binary search for \\( k \\) (the number of children each node has). The formula used to check if \\( n \\) can be represented as the sum of a geometric series is crucial. If such \\( k \\) and \\( h \\) exist, the answer is \"YES\"; otherwise, it is \"NO\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # We need to find k>1 and h>=2 such that n = (k^(h+1)-1)/(k-1)\n    # Let's try all possible h starting from 2 up to log2(n) +1\n    max_h = 60  # since 2^60 is about 1e18, which covers the constraints\n    for h in range(2, max_h+1):\n        # Solve for k: (k^(h+1)-1)/(k-1) = n\n        # Rearranged: k^h * (k/(k-1)) + k^{h-1}/(k-1) + ... + 1/(k-1) = n\n        # Alternatively, using the formula: n*(k-1) = k^h + k^{h-1} + ... + 1\n        # So, n*(k-1) = (k^{h+1} - 1)/(k-1)\n        # So, k^{h+1} - 1 = n*(k-1)^2\n        # But this might not be easy to solve directly.\n        # Another approach: binary search for k\n        left = 2\n        right = n-1  # since k must be less than n\n        while left <= right:\n            mid = (left + right) // 2\n            # Compute s = (mid^(h+1) -1)/(mid-1)\n            # But calculating mid^(h+1) could be too big, so we need to check for overflow\n            try:\n                numerator = mid ** (h + 1) - 1\n                denominator = mid - 1\n                if denominator == 0:\n                    continue  # avoid division by zero, but mid >=2, so no\n                s = numerator // denominator\n            except OverflowError:\n                s = float('inf')\n            if s == n:\n                return True\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    if n == 1:\n        print(\"NO\")\n        continue\n    found = False\n    # Check for h starting from 2 upwards\n    max_h = 60  # since 2^60 is about 1e18\n    for h in range(2, max_h + 1):\n        left = 2\n        right = n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # Calculate (mid^(h+1) -1)/(mid -1)\n            # To avoid overflow, compute step by step\n            power = 1\n            for _ in range(h + 1):\n                power *= mid\n                if power > n * (mid - 1):\n                    break\n            if power > n * (mid - 1):\n                right = mid - 1\n                continue\n            total = (power - 1) // (mid - 1)\n            if total == n:\n                found = True\n                break\n            elif total < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if found:\n            break\n    print(\"YES\" if found else \"NO\")\n\n# Alternative optimized approach using binary search for k\ndef check(n):\n    max_k = n - 1  # since k must be at least 2\n    for h in range(2, 60):\n        left = 2\n        right = max_k\n        while left <= right:\n            mid = (left + right) // 2\n            # Compute s = (mid^(h+1) -1)/(mid-1)\n            # To prevent overflow, compute in a way that stops early if possible\n            s = 0\n            current = 1\n            for _ in range(h + 1):\n                current *= mid\n                if current > n * (mid - 1):\n                    break\n                s += current\n            if s > n * (mid - 1):\n                right = mid - 1\n                continue\n            if s == n * (mid - 1):\n                return True\n            elif s < n * (mid - 1):\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    if n < 3:\n        print(\"NO\")\n        continue\n    found = False\n    max_h = 60\n    for h in range(2, max_h + 1):\n        left = 2\n        right = n - 1  # since k >=2\n        while left <= right:\n            mid = (left + right) // 2\n            # Calculate s = (mid^(h+1) - 1) / (mid - 1)\n            # To prevent overflow, compute step by step\n            s_num = mid ** (h + 1) - 1\n            s_den = mid - 1\n            if s_den == 0:\n                continue  # mid is 1, but k>1 so skip\n            if s_num > s_den * n:\n                right = mid - 1\n                continue\n            s = s_num // s_den\n            if s == n:\n                found = True\n                break\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if found:\n            break\n    print(\"YES\" if found else \"NO\")",
    "score": -1,
    "metadata": {
        "prompt_token_count": 535,
        "completion_token_count": 1650,
        "thoughts_token_count": 1025
    }
}