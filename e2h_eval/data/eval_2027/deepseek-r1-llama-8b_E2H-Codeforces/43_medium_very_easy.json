{
    "start": 1758283921.3224404,
    "end": 1758286121.6082933,
    "start-formatted": "2025-09-19 21:12 KST",
    "end-formatted": "2025-09-19 21:48 KST",
    "gpu": 2,
    "pid": 43,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Check the string\n\nA has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.B now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.You have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print \"YES\", otherwise print \"NO\" (without the quotes).\n\n## Input\nThe first and only line consists of a string $$$S$$$ ($$$ 1 \\le |S| \\le 5\\,000 $$$). It is guaranteed that the string will only consist of the lowercase English letters 'a', 'b', 'c'.\n\n## Output\nPrint \"YES\" or \"NO\", according to the condition.\n\n## Example\n### Input\n['aaabccc', 'bbacc', 'aabc']\n\n### Output\n['YES', 'NO', 'YES']\n\n## Note\nConsider first example: the number of 'c' is equal to the number of 'a'. Consider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.Consider third example: the number of 'c' is equal to the number of 'b'.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, I need to solve this problem where I have to check if a given string could have been formed by the process described. Let's break down the problem.\n\nSo, the process is as follows:\n\n1. A creates a string of some 'a's.\n2. B appends some 'b's to the end. So after this step, there's at least one 'a' and one 'b'.\n3. C then appends some 'c's. The number of 'c's must be equal to either the number of 'a's or 'b's in the string before C added them. It can also be equal to both.\n\nSo the string should consist of a sequence of 'a's, followed by 'b's, followed by 'c's. But wait, noâ€”because B appends 'b's to the end of A's string, which already has 'a's. Then C appends 'c's to the end of that, so the entire string is a bunch of 'a's, then 'b's, then 'c's. So the order is important.\n\nSo first, I need to check that the string is structured as all 'a's first, then all 'b's, then all 'c's. If there are any other characters out of order, it's automatically \"NO\".\n\nSecond, I need to check the counts:\n\nLet the counts be:\n- count_a = number of 'a's\n- count_b = number of 'b's\n- count_c = number of 'c's\n\nAfter B appends his 'b's, the string has count_a 'a's and count_b 'b's. Then C appends 'c's such that count_c equals either count_a or count_b (or both).\n\nWait, but when C appends, he adds exactly the number of 'c's equal to either the current count of 'a's or 'b's. So the total 'c's in the final string must be equal to either the count of 'a's or 'b's in the string after B's step.\n\nWait, but in the string after B appends, the counts are count_a and count_b. So when C appends, the count of 'c's becomes c_count = a_count or b_count.\n\nSo in the final string, the 'c's should be equal to either a_count or b_count.\n\nWait, let me think again. Suppose after A and B, the string has a certain number of 'a's and 'b's. Then C adds some 'c's. The number of 'c's must be equal to the number of 'a's at that point OR the number of 'b's at that point. So, for example, if after B's step, there are 3 'a's and 4 'b's, then C can add 3 'c's (equal to 'a's) or 4 'c's (equal to 'b's). Or even both, but it's just that the 'c's count must match either.\n\nWait, but the problem statement says that C appends some number of 'c's equal to the number of 'a's or 'b's. So the count of 'c's must be exactly equal to either count_a or count_b.\n\nSo, putting it all together:\n\nThe string must have the form aaa...bbb...ccc..., without any interleaving. Also, the counts must satisfy:\n\ncount_c == count_a OR count_c == count_b.\n\nAdditionally, after B appends, the string has at least one 'a' and one 'b'. So in the final string, count_a >=1, count_b >=1, and count_c >=1 (since C appends some letters).\n\nWait, but what about the counts? For example, if count_c is equal to count_a, then the 'c's are count_c = count_a. But count_a could be less than count_b, right?\n\nSo, the steps are:\n\n1. Check the structure: the string must be composed of only 'a's, followed by 'b's, followed by 'c's. No other characters in between.\n\n   For this, we can iterate through the string and ensure that once we encounter a character that is not part of the current allowed sequence, the string is invalid.\n\n   Alternatively, we can split the string into three parts: a's, then b's, then c's.\n\n   How to do this? We can loop through each character and see if the order is correct.\n\n   For example, for the string s:\n\n   - The first part is all 'a's until the first non-'a' character.\n   - Then, the next part must be all 'b's until the first non-'b' character.\n   - Then, the remaining must be all 'c's.\n\n   So, code-wise:\n\n   Initialize state to 'a'.\n\n   For each character in s:\n      if current state is 'a':\n          if char is 'a': continue\n          elif char is 'b': state changes to 'b'\n          else: invalid (return NO)\n      elif state is 'b':\n          if char is 'b': continue\n          elif char is 'c': state changes to 'c'\n          else: invalid (return NO)\n      elif state is 'c':\n          if char is 'c': continue\n          else: invalid (return NO)\n\n   Also, if the state never progresses beyond 'a' or 'b', then it's invalid because C must have added some 'c's. So, the state must reach 'c' eventually.\n\n   Wait, no. Because C appends some 'c's, so the final part must be non-empty. So the string must have all three parts present.\n\n   So, if the string has 'a's followed by 'b's and then 'c's, but the 'c's part is empty (i.e., after 'b's comes nothing), then it's invalid because C must have appended some 'c's.\n\n   So the structure must have at least one 'a', then at least one 'b', then at least one 'c'.\n\n   So, during the checking, if after processing all characters, the state hasn't reached 'c', it's invalid.\n\n   Also, the initial state is 'a', and must transition correctly.\n\n   So, code-wise, let's outline this:\n\n   state = 'a'\n   for char in s:\n       if state == 'a':\n           if char == 'a':\n               continue\n           elif char == 'b':\n               state = 'b'\n           else:\n               # invalid\n               return False\n       elif state == 'b':\n           if char == 'b':\n               continue\n           elif char == 'c':\n               state = 'c'\n           else:\n               # invalid\n               return False\n       elif state == 'c':\n           if char != 'c':\n               # invalid\n               return False\n   # After processing, check if state is 'c' and all parts are present\n   if state != 'c' or len(c_part) ==0:\n       # invalid\n       return False\n\n   Wait, but the way to track this is via the state transitions. So, for example, if the string is 'aabbbcc', that's okay. But if it's 'aaabbbc', that's also okay, because the 'c's start after 'b's.\n\n   But how to handle cases where after 'a's come 'c's without 'b's? That's invalid because B must have appended some 'b's.\n\n   So, for example, 'aaaccc' would fail because after the 'a's, the next is 'c's, but no 'b's. So the state would go from 'a' to 'c' directly, skipping 'b's, which is invalid.\n\n   So the code must ensure that the state goes 'a' -> 'b' -> 'c' in order, without skipping any.\n\n   So, during the iteration:\n\n   - Once the state moves to 'b', it can't go back to 'a'.\n   - Once the state moves to 'c', it can't go back to 'a' or 'b'.\n\n   So, for the string 'aabba', the state would change to 'b' at the second 'a', but then when it encounters another 'a' after that, it's invalid because state is 'b' now.\n\n   So, the code correctly returns false for that.\n\n   So, the first condition is that the string is in the form a+b+c, with each part non-empty, and in the correct order.\n\n   Now, the second condition is that the count of 'c's is equal to the count of 'a's or 'b's.\n\n   So, after the structure check, we can compute the counts.\n\n   So, for the string, after structure is valid:\n\n   count_a = number of 'a's\n   count_b = number of 'b's\n   count_c = number of 'c's\n\n   Then, check whether count_c is equal to count_a or count_b.\n\n   Also, since after B appends, the counts of 'a' and 'b' are count_a and count_b respectively. Then C appends count_c which is equal to either of them.\n\n   So, yes, the condition is count_c == count_a or count_c == count_b.\n\n   So, putting it all together:\n\n   Steps to solve the problem:\n\n   1. Check that the string is in the form a^+ b^+ c^+, i.e., all 'a's, then 'b's, then 'c's, each part non-empty. If not, output NO.\n\n   2. Compute count_a, count_b, count_c.\n\n   3. Check if count_c is equal to count_a OR count_c is equal to count_b. If yes, output YES; else, NO.\n\n   So, let's think about the sample inputs.\n\n   Sample 1: 'aaabccc'\n\n   Structure: 'aaa' + 'b' + 'ccc' â†’ valid.\n\n   count_a=3, count_b=1, count_c=3.\n\n   So, count_c = count_a â†’ valid. Output YES.\n\n   Sample 2: 'bbacc'\n\n   Structure: 'b's first? No, because the first character is 'b' and state starts as 'a'. So the string is invalid because it starts with 'b' when state is 'a'. So the structure check fails, output NO.\n\n   Wait, no. Wait, the string is 'bbacc'. Let's process each character.\n\n   state is 'a' initially.\n\n   First character is 'b' â†’ state changes to 'b'.\n\n   Next character is 'b' â†’ state remains 'b'.\n\n   Next is 'a' â†’ in state 'b', 'a' is invalid. So structure check fails, output NO.\n\n   Which matches the sample.\n\n   Sample 3: 'aabc'\n\n   Structure: 'aa' â†’ state 'a', then 'b' â†’ state 'b', then 'c' â†’ state 'c'. So structure is valid.\n\n   count_a=2, count_b=1, count_c=1.\n\n   So count_c = 1, which equals count_b=1 â†’ valid. So output YES.\n\n   Another test case: 'ac' â†’ structure invalid, because after 'a' comes 'c' without 'b's. So output NO.\n\n   Another test case: 'abbc' â†’ structure is a, then bb, then c â†’ valid.\n\n   count_a=1, count_b=2, count_c=1.\n\n   So count_c =1 is not equal to 1 (count_a) nor 2 (count_b). So condition fails, output NO.\n\n   Another test case: 'aabbbc' â†’ count_a=2, count_b=3, count_c=1.\n\n   1 is not equal to either 2 or 3 â†’ output NO.\n\n   Another test case: 'abc' â†’ structure valid. count_a=1, count_b=1, count_c=1. So count_c is equal to both, so output YES.\n\n   Another test case: 'aabba' â†’ structure check fails, as after 'a's, 'b's, but then another 'a' comes, which is invalid in state 'b'. So output NO.\n\n   So, the plan is:\n\n   - Read the input string.\n\n   - Check the structure: a's, then b's, then c's, in order, each part non-empty.\n\n   - If structure is invalid, output NO.\n\n   - Else, calculate counts.\n\n   - Check if count_c equals count_a or count_b.\n\n   - If yes, output YES; else, NO.\n\n   Now, implement this in Python.\n\n   So, the code:\n\n   Read the string.\n\n   Check the structure:\n\n   state = 'a'\n\n   for each char in S:\n\n       if state is 'a':\n\n           if char == 'a': continue\n\n           elif char == 'b': state = 'b'\n\n           else: structure is invalid.\n\n       elif state is 'b':\n\n           if char == 'b': continue\n\n           elif char == 'c': state = 'c'\n\n           else: invalid.\n\n       elif state is 'c':\n\n           if char != 'c': invalid.\n\n   After processing all chars, check if state is 'c' (meaning we have all three parts) and that the 'c' part is non-empty.\n\n   Wait, but in the code above, the state will become 'c' only if we have at least one 'c' after 'b's.\n\n   So, after processing all chars, the state must be 'c' and the 'c' part must be non-empty.\n\n   So, in code:\n\n   structure_valid = True\n\n   state = 'a'\n\n   for c in s:\n\n       if state == 'a':\n\n           if c == 'a':\n\n               continue\n\n           elif c == 'b':\n\n               state = 'b'\n\n           else:\n\n               structure_valid = False\n\n               break\n\n       elif state == 'b':\n\n           if c == 'b':\n\n               continue\n\n           elif c == 'c':\n\n               state = 'c'\n\n           else:\n\n               structure_valid = False\n\n               break\n\n       elif state == 'c':\n\n           if c != 'c':\n\n               structure_valid = False\n\n               break\n\n   # Now, check if all parts are present.\n\n   if not structure_valid:\n\n       print(\"NO\")\n\n   else:\n\n       # Check if state is 'c' and that the 'c' part is non-zero.\n\n       # Also, check that all parts are non-zero.\n\n       # Since the process requires at least one 'a' and 'b' before C appends.\n\n       # So, count_a >0, count_b>0, count_c>0.\n\n       # How to get the counts?\n\n       # Maybe during the structure check, count each part.\n\n       # Or, better, create separate lists for each part.\n\n       # Alternative approach:\n\n       # Split the string into three parts: a_part, b_part, c_part.\n\n       # a_part is all leading 'a's.\n\n       # b_part is all 'b's after a_part.\n\n       # c_part is all 'c's after b_part.\n\n       # So, let's try that.\n\n       # Re-implement the structure check, but also collect the counts.\n\n       # So, perhaps, instead of using state, we can have variables a_end, b_end, c_start.\n\n       # Initialize a_end = 0, b_end=0, c_start=0.\n\n       # Then, for each index, find where a ends, then where b ends, then the rest is c.\n\n       # So, code:\n\n       a_end = 0\n\n       while a_end < len(s) and s[a_end] == 'a':\n\n           a_end +=1\n\n       if a_end == 0:\n\n           # no 'a's, invalid.\n\n           structure_valid = False\n\n       else:\n\n           b_end = a_end\n\n           while b_end < len(s) and s[b_end] == 'b':\n\n               b_end +=1\n\n           if b_end == a_end:\n\n               # no 'b's, invalid.\n\n               structure_valid = False\n\n           else:\n\n               c_start = b_end\n\n               while c_start < len(s) and s[c_start] == 'c':\n\n                   c_start +=1\n\n               if c_start != len(s):\n\n                   # c_part is non-empty.\n\n                   pass\n\n               else:\n\n                   # no 'c's, invalid.\n\n                   structure_valid = False\n\n       if not structure_valid:\n\n           print(\"NO\")\n\n       else:\n\n           count_a = a_end - a_start\n\n           count_b = b_end - a_end\n\n           count_c = len(s) - b_end\n\n           if count_c == count_a or count_c == count_b:\n\n               print(\"YES\")\n\n           else:\n\n               print(\"NO\")\n\n   Hmm, perhaps this approach is better. Let me think.\n\n   So, the code:\n\n   Read the string s.\n\n   Initialize a_end to 0.\n\n   Loop while a_end < len(s) and s[a_end] == 'a': increment a_end.\n\n   If a_end is 0, then no 'a's â†’ invalid.\n\n   Else, check that the next characters are 'b's until b_end.\n\n   So, set b_end = a_end.\n\n   Loop while b_end < len(s) and s[b_end] == 'b': increment b_end.\n\n   If b_end == a_end â†’ no 'b's â†’ invalid.\n\n   Then, check that the remaining are 'c's.\n\n   Set c_start = b_end.\n\n   While c_start < len(s) and s[c_start] == 'c': increment c_start.\n\n   If c_start != len(s): 'c's present â†’ okay.\n\n   Else: no 'c's â†’ invalid.\n\n   So, if any of these steps fail, structure is invalid.\n\n   Else, compute counts:\n\n   count_a = a_end - 0 (assuming a_start is 0?)\n\n   Wait, a_end is the index after the last 'a'. So count_a = a_end.\n\n   count_b = b_end - a_end.\n\n   count_c = len(s) - b_end.\n\n   Then, check if count_c is equal to count_a or count_b.\n\n   So, in code:\n\n   s = input().strip()\n\n   # Check structure.\n\n   a_end = 0\n\n   while a_end < len(s) and s[a_end] == 'a':\n\n       a_end += 1\n\n   if a_end == 0:\n\n       print(\"NO\")\n\n       exit()\n\n   b_end = a_end\n\n   while b_end < len(s) and s[b_end] == 'b':\n\n       b_end +=1\n\n   if b_end == a_end:\n\n       print(\"NO\")\n\n       exit()\n\n   c_start = b_end\n\n   while c_start < len(s) and s[c_start] == 'c':\n\n       c_start +=1\n\n   if c_start != len(s):\n\n       # No 'c's? Or some 'c's but not all.\n\n       # Wait, no: c_start is the first index beyond the 'c's.\n\n       # So, if c_start == len(s), then all remaining are 'c's.\n\n       # Wait, no. Because in the loop, we only proceed if the character is 'c'.\n\n       # So, if the remaining are all 'c's, c_start will reach len(s). If any are not, the loop breaks.\n\n       # So, to have 'c's, the c_start must reach len(s).\n\n       # So, if c_start != len(s), it means that after the 'b's, there are no 'c's â†’ invalid.\n\n       # Or wait: if the remaining are 'c's, then the loop runs until the end. So, c_start will be len(s) only if all remaining are 'c's.\n\n       # So, in the code, after the loop, c_start may be less than len(s), meaning that after the 'b's, there are non-'c' characters â†’ invalid.\n\n       # So, if c_start != len(s), it's invalid.\n\n       print(\"NO\")\n\n       exit()\n\n   # Now, structure is valid.\n\n   count_a = a_end\n\n   count_b = b_end - a_end\n\n   count_c = len(s) - b_end\n\n   if count_c == count_a or count_c == count_b:\n\n       print(\"YES\")\n\n   else:\n\n       print(\"NO\")\n\n   Let's test this logic with the samples.\n\n   Sample 1: 'aaabccc'\n\n   a_end is 3.\n\n   b_end is 4.\n\n   c_start is 5, which is len(s) (7?), no: wait, 'aaabccc' has length 7.\n\n   Wait, 'aaabccc' is 3 'a's, 1 'b', 3 'c's: total 7.\n\n   So a_end is 3, b_end is 4.\n\n   c_start is 4, and the next three are 'c's. So c_start becomes 7, which is len(s). So structure is valid.\n\n   count_a =3, count_b=1, count_c=3.\n\n   count_c == count_a â†’ yes. So output YES.\n\n   Sample 2: 'bbacc' â†’ s[0] is 'b', so a_end is 0. So structure invalid. Output NO.\n\n   Sample 3: 'aabc' â†’ a_end is 2, then b_end is 3, then c_start is 4, which is len(s) (4). So structure valid.\n\n   count_a=2, count_b=1, count_c=1.\n\n   count_c == count_b â†’ yes. Output YES.\n\n   Another test case: 'ac' â†’ a_end is 1, then b_end is 1 (no 'b's after 'a'). So structure invalid. Output NO.\n\n   Another test case: 'abc' â†’ a_end=1, b_end=2, c_start=3 (len(s)=3). count_a=1, count_b=1, count_c=1. So condition holds. Output YES.\n\n   Another test case: 'aabbbc' â†’ a_end=2, b_end=5, c_start=6. count_c=1. count_a=2, count_b=3. So 1 is neither 2 nor 3 â†’ output NO.\n\n   Another test case: 'abbbc' â†’ a_end=1, b_end=4, c_start=5. count_c=1. count_a=1, count_b=3. So 1 equals count_a â†’ output YES.\n\n   So the logic seems to work.\n\n   What about a string like 'aabba'? Let's see.\n\n   a_end is 3, then b_end starts at 3.\n\n   s[3] is 'b', then s[4] is 'a'. So b_end will stop at 4 (since s[4] is 'a' not 'b').\n\n   So in the code, after the b_end loop, if b_end == a_end (3 vs 3?), no, because in this case, b_end is 4.\n\n   Wait, a_end is 3, b_end starts at 3.\n\n   s[3] is 'b' â†’ b_end increments to 4.\n\n   s[4] is 'a' â†’ loop stops. So b_end is 4, which is greater than a_end=3. So structure is invalid? Because after 'a's, the 'b's are present, but then an 'a' comes. So during the b_end loop, when s[b_end] is 'a', the loop breaks. So structure is invalid.\n\n   So the code correctly returns NO.\n\n   So, the code seems to handle all cases.\n\n   Now, let's write the code.\n\n   Edge Cases:\n\n   - All 'a's: but B must add 'b's and C must add 'c's. So string must have at least one 'b' and 'c'. So, the code correctly returns NO for a string like 'aaaa'.\n\n   - String is 'abc': valid.\n\n   - String is 'aabbc': count_c is 1, count_a is 2, count_b is 2. 1 != 2 â†’ output NO.\n\n   - String is 'abbbc': count_c=1, count_a=1 â†’ yes.\n\n   So, the code should handle all these.\n\n   Potential issues:\n\n   - What if the string has 'a's, then 'c's without 'b's? Like 'aaaccc'.\n\n   Then, a_end is 3, b_end is 3 (no 'b's after 'a's), so structure invalid.\n\n   So code returns NO.\n\n   So, the code correctly handles that.\n\n   Another edge case: string is 'aabbc' â†’ count_c is 1. count_a is 2, count_b is 2. So 1 is not equal to either â†’ output NO.\n\n   So the code is correct.\n\n   Now, implementing this in Python.\n\n   Read the string, perform the checks as above.\n\n   So, the code:\n\n   s = input().strip()\n\n   a_end = 0\n\n   while a_end < len(s) and s[a_end] == 'a':\n\n       a_end += 1\n\n   if a_end == 0:\n\n       print(\"NO\")\n\n       exit()\n\n   b_end = a_end\n\n   while b_end < len(s) and s[b_end] == 'b':\n\n       b_end +=1\n\n   if b_end == a_end:\n\n       print(\"NO\")\n\n       exit()\n\n   c_start = b_end\n\n   while c_start < len(s) and s[c_start] == 'c':\n\n       c_start +=1\n\n   if c_start != len(s):\n\n       print(\"NO\")\n\n       exit()\n\n   count_a = a_end\n\n   count_b = b_end - a_end\n\n   count_c = len(s) - b_end\n\n   if count_c == count_a or count_c == count_b:\n\n       print(\"YES\")\n\n   else:\n\n       print(\"NO\")\n\n   So, that's the code.\n\n   Let's test it against the samples.\n\n   Sample 1: 'aaabccc' â†’ YES.\n\n   Sample 2: 'bbacc' â†’ a_end is 0 â†’ NO.\n\n   Sample 3: 'aabc' â†’ YES.\n\n   All correct.\n\n   So, this should be the solution.\n",
    "response": "To solve this problem, we need to determine if a given string could have been formed by a specific sequence of operations involving appending certain characters in a specific order. The string must be constructed by first appending 'a's, then 'b's, and finally 'c's, with the number of 'c's being equal to either the number of 'a's or 'b's.\n\n### Approach\n1. **Check the Structure**: The string must be structured such that it consists of a sequence of 'a's followed by 'b's and ending with 'c's. Each part (a's, b's, c's) must be non-empty.\n2. **Count Validation**: After confirming the structure, we need to check if the number of 'c's is equal to either the number of 'a's or the number of 'b's.\n\n### Solution Code\n```python\ns = input().strip()\n\na_end = 0\nwhile a_end < len(s) and s[a_end] == 'a':\n    a_end += 1\n\nif a_end == 0:\n    print(\"NO\")\n    exit()\n\nb_end = a_end\nwhile b_end < len(s) and s[b_end] == 'b':\n    b_end += 1\n\nif b_end == a_end:\n    print(\"NO\")\n    exit()\n\nc_start = b_end\nwhile c_start < len(s) and s[c_start] == 'c':\n    c_start += 1\n\nif c_start != len(s):\n    print(\"NO\")\n    exit()\n\ncount_a = a_end\ncount_b = b_end - a_end\ncount_c = len(s) - b_end\n\nif count_c == count_a or count_c == count_b:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```\n\n### Explanation\n1. **Structure Check**:\n   - We start by checking how many 'a's are present at the beginning of the string.\n   - Next, we check for 'b's following the 'a's.\n   - Finally, we ensure that all remaining characters are 'c's.\n\n2. **Count Validation**:\n   - After verifying the structure, we count the number of 'a's, 'b's, and 'c's.\n   - We then check if the number of 'c's matches either the number of 'a's or 'b's.\n\nThis approach ensures that we efficiently verify both the structure and the required conditions for the string, providing the correct result based on the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "s = input().strip()\n\na_end = 0\nwhile a_end < len(s) and s[a_end] == 'a':\n    a_end += 1\n\nif a_end == 0:\n    print(\"NO\")\n    exit()\n\nb_end = a_end\nwhile b_end < len(s) and s[b_end] == 'b':\n    b_end += 1\n\nif b_end == a_end:\n    print(\"NO\")\n    exit()\n\nc_start = b_end\nwhile c_start < len(s) and s[c_start] == 'c':\n    c_start += 1\n\nif c_start != len(s):\n    print(\"NO\")\n    exit()\n\ncount_a = a_end\ncount_b = b_end - a_end\ncount_c = len(s) - b_end\n\nif count_c == count_a or count_c == count_b:\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 503,
        "completion_token_count": 516,
        "thoughts_token_count": 5566
    }
}