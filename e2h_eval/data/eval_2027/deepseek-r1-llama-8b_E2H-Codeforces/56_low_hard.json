{
    "start": 1758278117.6065702,
    "end": 1758278343.3406901,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:39 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. Each base must have exactly one spaceship, and each spaceship must be assigned to exactly one base. So, it's a perfect matching between R rebels and B bases.\n\nBut there's an additional condition: the straight paths from each base to its assigned spaceship shouldn't intersect. So, no two paths can cross each other in the galaxy plane.\n\nHmm. So, I need to determine if such a matching exists.\n\nLet me think about how to approach this.\n\nFirst, the input consists of R spaceships and B bases. The coordinates are given, and no three points are colinear, which probably helps because it reduces some cases where lines could overlap.\n\nThe output is \"Yes\" or \"No\" based on whether a valid matching exists.\n\nSo, the steps I need to take:\n\n1. Read the input correctly.\n2. Generate all possible perfect matchings between the spaceships and bases.\n3. For each matching, check if any two paths (from base to spaceship) intersect.\n   - If a matching doesn't have any intersecting paths, output \"Yes\".\n4. If none of the matchings satisfy the condition, output \"No\".\n\nBut wait, the number of matchings could be high, especially when R is 10 and B is 10, but since R and B are up to 10, maybe it's manageable.\n\nWait, but R and B can be up to 10, so for example, if R=10 and B=5, but that's impossible because then R != B. Wait, no: the problem says R and B can be any values, but the assignment requires that R equals B, right? Because it's a perfect matching—each base has exactly one, each ship exactly one. So, the first thing to check is whether R equals B. Otherwise, it's impossible.\n\nWait, looking back at the problem statement: the assignment must be a perfect matching, meaning each base is matched to exactly one ship, and each ship to exactly one base. So yes, R must equal B. So the first thing in code: if R != B, output \"No\".\n\nWait, but looking at the sample input:\n\nIn the second example, the first line is '3 3' followed by 3 ships and 3 bases. But the output is \"No\". So that's because even though R=B, the matching isn't possible due to intersections.\n\nSo, step zero: if R != B, output \"No\".\n\nOtherwise, proceed.\n\nNow, for the case when R = B, we need to find a permutation of the bases such that when each base is connected to its assigned spaceship, the lines don't intersect.\n\nWait, but how do we represent the lines? Each path is a line segment from the base to the spaceship. So, for the matching, we have to consider all pairs (ship i to base j), and ensure that no two such segments cross each other.\n\nSo, for each possible permutation of the bases (since each base must be matched to exactly one ship), we can represent the matching as a list of (base, ship) pairs, and then check if any two segments (from base to ship) intersect.\n\nIf any permutation exists where none of the segments intersect, output \"Yes\". Else, \"No\".\n\nBut generating all permutations might be computationally feasible because R can be up to 10, leading to 10! = 3.6 million possibilities. That's manageable for Python.\n\nWait, 10! is about 3.6 million. For each permutation, checking all pairs of segments for intersection. For each permutation, how many pairs of segments do we have?\n\nFor a permutation of size R, there are R*(R-1)/2 pairs of segments. For R=10, that's 45 per permutation. So 3.6e6 * 45 is about 162 million operations. Hmm, that's a lot, but perhaps manageable with optimizations.\n\nWait, but 162 million operations might be a bit slow for Python, which is typically slower than C++ for such tasks. However, given that R and B are small (up to 10), perhaps it's acceptable.\n\nAlternatively, can we find a way to reduce the number of permutations we need to check?\n\nWell, perhaps not, so let's think about optimizing the checking process.\n\nAnother approach: for a given permutation (matching), we can collect all the line segments, and then for every pair of segments, determine if they intersect. If any pair intersects, the permutation is invalid.\n\nSo, the key is to implement an efficient line segment intersection check.\n\nHow to check if two line segments AB and CD intersect?\n\nI remember that the standard approach is to use the cross product to determine orientation and then apply the separating axis theorem (SAT) to see if the segments overlap.\n\nSo, here's the plan for the line segment intersection",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian, each spaceship has exactly one assigned base, and no two paths from a base to its assigned spaceship intersect in the galaxy plane.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of spaceships (R) equals the number of bases (B). If they are not equal, output \"No\" because a perfect matching is impossible.\n2. **Generate Permutations**: For the case where R equals B, generate all possible permutations of the bases. Each permutation represents a potential assignment of spaceships to bases.\n3. **Check for Intersections**: For each permutation, check if any two paths (segments) from a base to its assigned spaceship intersect. This involves:\n   - Representing each path as a line segment.\n   - Using the cross product to determine the orientation of points relative to each other.\n   - Applying the Separating Axis Theorem (SAT) to check for intersections between line segments.\n4. **Output Result**: If any permutation results in non-intersecting paths, output \"Yes\". If none do, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n\n    ccw1 = ccw(A, B, C)\n    ccw2 = ccw(A, B, D)\n    ccw3 = ccw(C, D, A)\n    ccw4 = ccw(C, D, B)\n\n    if (ccw1 == 0 and ccw2 == 0) or (ccw3 == 0 and ccw4 == 0):\n        return False\n\n    if (ccw1 * ccw2 < 0) or (ccw3 * ccw4 < 0):\n        return True\n\n    def on_segment(p, q, r):\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n\n    if on_segment(A, C, B) or on_segment(A, D, B):\n        return True\n    if on_segment(C, A, D) or on_segment(D, A, C):\n        return True\n\n    return False\n\ndef main():\n    data = []\n    R_B = readints()\n    R = R_B[0]\n    B = R_B[1]\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n\n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n\n    ship_indices = list(range(R))\n    base_indices = list(range(B))\n\n    for perm in permutations(base_indices):\n        match = {}\n        for i in range(R):\n            match[i] = perm[i]\n\n        segments = []\n        valid = True\n        for i in range(R):\n            ship_i = ships[i]\n            base_i = bases[perm[i]]\n            segments.append((ship_i, base_i))\n\n        for j in range(len(segments)):\n            sj = segments[j]\n            for k in range(j + 1, len(segments)):\n                sk = segments[k]\n                if segments_intersect(sj, sk):\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        if valid:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into lists of spaceship and base coordinates.\n- **Perfect Matching Check**: If the number of spaceships does not equal the number of bases, immediately output \"No\".\n- **Permutations Generation**: Generate all permutations of bases to test every possible assignment.\n- **Intersection Check**: For each permutation, represent each assignment as a line segment and check for intersections using the cross product and SAT.\n- **Efficiency**: The solution efficiently checks each permutation and uses geometric properties to determine if any valid assignment exists.\n\nThis approach ensures that we explore all possible assignments and check for the required conditions efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n\n    ccw1 = ccw(A, B, C)\n    ccw2 = ccw(A, B, D)\n    ccw3 = ccw(C, D, A)\n    ccw4 = ccw(C, D, B)\n\n    if (ccw1 == 0 and ccw2 == 0) or (ccw3 == 0 and ccw4 == 0):\n        return False\n\n    if (ccw1 * ccw2 < 0) or (ccw3 * ccw4 < 0):\n        return True\n\n    def on_segment(p, q, r):\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n\n    if on_segment(A, C, B) or on_segment(A, D, B):\n        return True\n    if on_segment(C, A, D) or on_segment(D, A, C):\n        return True\n\n    return False\n\ndef main():\n    data = []\n    R_B = readints()\n    R = R_B[0]\n    B = R_B[1]\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n\n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n\n    ship_indices = list(range(R))\n    base_indices = list(range(B))\n\n    for perm in permutations(base_indices):\n        match = {}\n        for i in range(R):\n            match[i] = perm[i]\n\n        segments = []\n        valid = True\n        for i in range(R):\n            ship_i = ships[i]\n            base_i = bases[perm[i]]\n            segments.append((ship_i, base_i))\n\n        for j in range(len(segments)):\n            sj = segments[j]\n            for k in range(j + 1, len(segments)):\n                sk = segments[k]\n                if segments_intersect(sj, sk):\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        if valid:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 462,
        "completion_token_count": 1007,
        "thoughts_token_count": 1025
    }
}