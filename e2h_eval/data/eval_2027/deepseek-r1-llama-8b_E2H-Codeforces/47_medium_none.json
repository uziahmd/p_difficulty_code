{
    "start": 1758281981.3030753,
    "end": 1758283570.3263755,
    "start-formatted": "2025-09-19 20:39 KST",
    "end-formatted": "2025-09-19 21:06 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about finding the smallest non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. If there are multiple k's that give the same minimal LCM, we choose the smallest k.\n\nHmm, let's think about this. The LCM of two numbers is equal to (product of the two numbers) divided by their greatest common divisor (GCD). So, LCM(x, y) = x*y / GCD(x, y). \n\nWait, but in our case, both numbers are a +k and b +k. Let's denote d = GCD(a, b). Then, since a and b can be written as a = d * m and b = d * n, where m and n are coprime (their GCD is 1). \n\nSo when we add k to both, a +k = d*m +k and b +k = d*n +k. Let's factor this: d*(m) +k = k + d*m, and similarly for the other term. Let me think about the GCD of these two terms.\n\nWait, what's the GCD of (a +k) and (b +k)? Let's compute GCD(a +k, b +k). Since a +k - (b +k) = a - b. So the GCD of (a +k) and (b +k) is the same as GCD(d*m +k, d*n +k). Hmm, maybe I can find a way to express this.\n\nAlternatively, since a and b have a GCD of d, their difference is d*(m -n), assuming m > n without loss of generality. But I'm not sure if that helps directly.\n\nWait, another approach: Let's consider the expression (a +k) and (b +k). Their difference is a - b. So, GCD(a +k, b +k) = GCD(a - b + 2k, a +k). Wait, no, because the difference between (a +k) and (b +k) is a - b. So, GCD(a +k, b +k) must divide a - b. Let me denote g = GCD(a - b, ...). Wait, maybe it's better to express it differently.\n\nLet me denote g = GCD(a +k, b +k). Then, g divides (a +k) - (b +k) = a - b. So g divides a - b. So g must be a divisor of a - b.\n\nWait, that's a crucial point. So the GCD of a +k and b +k is a divisor of |a - b|. Let's call delta = |a - b|. So all possible values of g must divide delta.\n\nSo, the possible values of g are the divisors of delta. For each possible g, which is a divisor of delta, we can see if there exists a k such that g divides both a +k and b +k. Because if g divides a +k and g divides b +k, then their GCD is at least g.\n\nBut wait, since g is a divisor of a - b, perhaps the maximum possible g is delta. So, the plan is to iterate over all possible divisors g of delta, and for each g, find the minimal k such that both a +k and b +k are multiples of g. Then, compute the corresponding LCM and choose the one with the minimal value, and in case of ties, the smallest k.\n\nWait, but how does g relate to the LCM? Because the LCM of two numbers x and y is (x*y)/gcd(x,y). So, if we can maximize the GCD, then the LCM would be minimized.\n\nSo, for each possible g (divisor of delta), we need to find a k such that g divides both a +k and b +k. Then, the LCM would be (a +k)*(b +k)/(g). We want this to be as small as possible.\n\nSo the steps could be:\n\n1. Compute delta = |a - b|.\n   If delta is zero, then a == b. So adding k to both gives the same number, whose LCM is itself. So the minimal LCM is achieved when a +k is as small as possible. So k=0 is the answer.\n   \n   So first, handle the case when a == b.\n\n2. Else, for each possible g that divides delta, do the following:\n   a. Check if g is a possible candidate for the GCD of a +k and b +k.\n   b. Find the minimal k for this g that satisfies (a +k) mod g == 0 and (b +k) mod g == 0.\n   c. For each such k, compute the LCM as (a +k)*(b +k) / g.\n   d. Keep track of the minimal LCM and the corresponding k. If multiple k's yield the same LCM, choose the smallest k.\n\n3. The minimal LCM across all possible g's is the answer.\n\nSo, the key is to find all possible g's (divisors of delta) and for each, compute the minimal k, then evaluate the resulting LCM.\n\nNow, the question is, how to efficiently find all the divisors of delta, and for each, find the minimal k.\n\nFirst, compute delta. Then, generate all divisors of delta.\n\nWait, but delta can be up to 1e9, so computing all its divisors may take O(sqrt(delta)) time, which is manageable because sqrt(1e9) is about 3e4, which is acceptable.\n\nOnce we have all the divisors, for each g, we need to find the minimal k >=0 such that (a +k) mod g == 0 and (b +k) mod g == 0.\n\nWait, let's see: (a +k) mod g ==0 implies k ≡ (-a) mod g.\n\nSimilarly, (b +k) mod g ==0 implies k ≡ (-b) mod g.\n\nSo, for a given g, the required k must satisfy both congruences. So:\n\nWe have k ≡ (-a) mod g\n\nand\n\nk ≡ (-b) mod g.\n\nSo, for the system of congruences to have a solution, (-a) mod g must be congruent to (-b) mod g.\n\nWhich is equivalent to (a - b) mod g == 0. But since g is a divisor of a - b, this condition is automatically satisfied.\n\nBecause a - b is divisible by g, so (a - b) mod g is 0.\n\nSo, the system has a solution.\n\nTherefore, for each g dividing delta, the required k is:\n\nk ≡ (-a) mod g.\n\nBut also, since (b +k) mod g must be 0, and since a -b is divisible by g, this will hold.\n\nWait, let's see: Since (a -b) is divisible by g, a ≡ b mod g. So (-a) mod g is equal to (-b) mod g. So yes, both congruences require the same k mod g.\n\nThus, the solution is unique modulo g.\n\nSo, the minimal non-negative k for a particular g is k = (-a) mod g.\n\nWait, but let's make sure.\n\nFor example, suppose g is 5, a is 6, b is 11. Then delta is 5. So a -b is -5, which is divisible by 5.\n\nThen, for g=5: k must be ≡ (-6) mod5 → (-6) mod5 is 4. So k=4.\n\nCheck:\n\na +k =6+4=10, which is 10 mod5 is 0.\n\nb +k=11+4=15 mod5 is 0. So yes.\n\nAnother example: a=6, b=10. delta is4.\n\ng=2: k must be (-6) mod2= 0 mod2. So k=0.\n\nCheck: 6+0=6, 10+0=10. GCD(6,10) is 2.\n\nYes.\n\nAnother example from the sample input: a=6, b=10. delta=4.\n\nPossible g's are 1,2,4.\n\nFor g=1: k can be anything, but the minimal is 0.\n\nCompute LCM(6,10)=60.\n\nFor g=2: k=0. a+k=6, b+k=10. LCM is (6*10)/2=30.\n\nFor g=4: check if 4 divides a and b? Wait, a=6, which mod4 is 2. So k must be (4 -2) mod4 =2.\n\nSo k=2. a +k=8, b +k=12. GCD(8,12)=4. LCM is (8*12)/4=24.\n\nWhich is better than previous options.\n\nSo the minimal LCM is 24, achieved at k=2.\n\nThus, in the sample, g=4 is the best option.\n\nSo the approach is:\n\nFor each divisor g of delta:\n\n   compute k = (-a) mod g.\n\n   Then, compute x = a +k, y = b +k.\n\n   Compute current_lcm = (x * y) // g.\n\n   Keep track of the minimal current_lcm and the smallest k.\n\nBut wait, for some g, maybe the k computed is negative? No, because mod is always positive.\n\nWait, in Python, (-6) %5 is 4, which is correct.\n\nSo for each g, we compute k = (-a) %g.\n\nThen, x = a +k, y = b +k.\n\nBut wait, since a and b could be in any order, perhaps we should compute delta as the absolute difference.\n\nWait, in the initial step, delta is |a -b|.\n\nSo, for each g in the divisors of delta, proceed as above.\n\nNow, the next step is to collect all the possible candidates and select the one with the smallest LCM, and minimal k if tied.\n\nBut, wait, how do I process the divisors? Because for each divisor g, including both positive and negative? No, because divisors are always positive.\n\nWait, in the code, the function to get all the divisors of delta will return all positive divisors. Because any divisor is positive.\n\nSo, the steps are:\n\nCompute delta = abs(a - b).\n\nIf delta is zero, output 0.\n\nElse:\n\n   Generate all the divisors of delta.\n\n   For each divisor g in the divisors:\n\n      compute k = (-a) mod g.\n\n      compute x = a +k, y = b +k.\n\n      compute current_gcd = g.\n\n      current_lcm = (x * y) // current_gcd.\n\n      keep track of the minimal current_lcm, and the corresponding k.\n\n   After processing all divisors, select the k with the smallest current_lcm, and if multiple, the smallest k.\n\nBut wait, what about g being larger than delta? No, because g is a divisor of delta, so it's <= delta.\n\nWait, no. For example, delta=4, g can be 4, which is equal to delta.\n\nSo, that's fine.\n\nNow, the problem is to generate all the divisors of delta.\n\nHow to do that efficiently?\n\nWell, I can write a function that finds all the divisors of a number by checking up to sqrt(n), and adding each divisor and its complement.\n\nFor example, for n=4, the divisors are 1,2,4.\n\nSo, the function would loop from 1 to sqrt(n), and for each i that divides n, add i and n/i to the list, then sort them.\n\nBut since delta can be up to 1e9, the function needs to be efficient.\n\nSo, in code:\n\ndef get_divisors(n):\n\n    divisors = set()\n\n    for i in range(1, int(math.sqrt(n)) +1):\n\n        if n %i ==0:\n\n            divisors.add(i)\n\n            divisors.add(n//i)\n\n    return sorted(divisors)\n\nBut wait, when n is zero, but in our problem, when a==b, delta is zero, and we handle that as a special case.\n\nSo, in the code, after handling a==b, we proceed to compute delta = abs(a-b), and generate the divisors.\n\nBut wait, what if delta is zero? That's handled already.\n\nSo, in code:\n\nimport math\n\na, b = map(int, input().split())\n\nif a == b:\n\n    print(0)\n\nelse:\n\n    delta = abs(a - b)\n\n    # find all divisors of delta\n\n    def get_divisors(n):\n\n        if n ==0:\n\n            return []\n\n        divisors = set()\n\n        for i in range(1, int(math.isqrt(n)) +1):\n\n            if n %i ==0:\n\n                divisors.add(i)\n\n                divisors.add(n//i)\n\n        return sorted(divisors)\n\n    divisors = get_divisors(delta)\n\n    min_lcm = float('inf')\n\n    best_k = None\n\n    for g in divisors:\n\n        # compute k = (-a) mod g\n\n        k = (-a) %g\n\n        x = a +k\n\n        y = b +k\n\n        current_gcd = g\n\n        current_lcm = (x * y) // current_gcd\n\n        # compare to current best\n\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n\n            min_lcm = current_lcm\n\n            best_k = k\n\n    print(best_k)\n\nWait, but let's test this with the sample inputs.\n\nSample Input 1: 6 10\n\ndelta is 4. Divisors are 1,2,4.\n\nFor g=1:\n\nk = (-6) mod 1 =0.\n\nx=6, y=10. LCM is 30.\n\nFor g=2:\n\nk = (-6) mod2 =0.\n\nx=6, y=10. GCD is 2, LCM is 30.\n\nFor g=4:\n\nk=(-6) mod4 = 2.\n\nx=8, y=12. GCD is 4. LCM is 24.\n\nSo the minimal is 24, so best_k is 2.\n\nWhich matches the sample.\n\nAnother sample input: 21 31.\n\ndelta is 10.\n\nDivisors of 10: 1,2,5,10.\n\nFor each g:\n\ng=1: k= (-21) mod1=0. x=21, y=31. LCM=21*31=651.\n\ng=2: k= (-21) mod2=1.\n\nx=22, y=32. GCD is 2. LCM= (22*32)/2= 352.\n\ng=5: k= (-21) mod5 =4. Because 21 mod5 is 1, so -1 mod5 is 4.\n\nx=21+4=25, y=31+4=35. GCD is 5. LCM= (25*35)/5= 175.\n\ng=10: k= (-21) mod10=9.\n\nx=30, y=40. GCD is 10. LCM= (30*40)/10=120.\n\nSo comparing the LCMs:\n\ng=1:651, g=2:352, g=5:175, g=10:120.\n\nThe minimal is 120, achieved at g=10, k=9.\n\nWhich is the sample's second output.\n\nThird sample: 5 10.\n\na=5, b=10.\n\ndelta=5.\n\ndivisors: 1,5.\n\nFor g=1:\n\nk= (-5) mod1=0.\n\nx=5, y=10. LCM=10.\n\nFor g=5:\n\nk= (-5) mod5=0.\n\nx=5, y=10. LCM=10.\n\nSo both g=1 and g=5 give LCM=10. But the k's are 0 and 0. So the minimal k is 0.\n\nWhich is the sample's third output.\n\nSo the code seems to handle these cases correctly.\n\nBut wait, what about when delta is 1?\n\nLike a=2, b=3. delta=1.\n\ndivisors are 1.\n\ng=1: k= (-2) mod1=0.\n\nx=2, y=3. LCM=6.\n\nIs that the minimal possible?\n\nYes, because any other k would give x and y as consecutive integers, which have LCM equal to their product, which is bigger.\n\nSo the code returns 0.\n\nAnother test case: a=3, b=7. delta=4.\n\ndivisors: 1,2,4.\n\ng=1: k= (-3) mod1=0. LCM=3*7=21.\n\ng=2: k= (-3) mod2=1.\n\nx=4, y=8. GCD=4. LCM=(32)/4=8.\n\ng=4: k= (-3) mod4=1.\n\nx=4, y=8. same as before.\n\nSo for g=2 and 4, k is 1 and 1 respectively. Both give LCM 8. So the minimal k is 1.\n\nSo the code would choose k=1.\n\nBut wait, let's compute for g=4.\n\nk=1: a +k=4, b +k=8. LCM is 8.\n\nSame as g=2.\n\nSo both give same LCM, but same k. So no problem.\n\nSo code correctly chooses k=1.\n\nAnother edge case: a=1, b=1000000000.\n\ndelta is 999999999.\n\ndivisors include 1, 3, 9, etc., up to 999999999.\n\nBut for each g, compute k, and find the minimal LCM.\n\nBut the code handles this.\n\nWait, what about when a is larger than b? Like a=10, b=5.\n\ndelta is 5.\n\ndivisors are 1,5.\n\nFor g=5:\n\nk = (-10) mod5=0.\n\nx=10, y=5. LCM is 10.\n\nWhich is better than g=1, which gives x=10, y=5, LCM 10.\n\nSo same as before.\n\nWait, but when a and b are swapped, the code still works.\n\nSo the code is correct.\n\nWhat about when a=0? Well, the problem states that a and b are at least 1, so that's not a concern.\n\nAnother test case: a=4, b=8.\n\ndelta=4. divisors 1,2,4.\n\ng=4: k= (-4) mod4=0.\n\nx=4, y=8. LCM=8.\n\nOther g's would result in higher LCM.\n\nThus, the code returns 0, which is correct.\n\nSo the code seems correct.\n\nBut wait, what about when a=0 and b=0? According to the problem statement, a and b are at least 1, so that's not possible.\n\nThus, the code is correct.\n\nNow, let's think about the implementation.\n\nIn Python, for handling large numbers, using integers is fine.\n\nBut wait, in the code, when a and b are very large, the computation for (a +k) and (b +k) might lead to integer overflows? But in Python, integers can be arbitrarily large, so no problem.\n\nSo, the code seems solid.\n\nBut wait, what about when delta is zero? As per the problem statement, when a ==b, the minimal LCM is a +k, and since k can't be negative, the minimal is when k=0.\n\nThus, the code correctly handles that.\n\nAnother edge case: a=1, b=1. Output is 0.\n\nAnother case: a=2, b=4.\n\ndelta=2. divisors 1,2.\n\ng=1: k= (-2) mod1=0. x=2, y=4. LCM=4.\n\ng=2: k= (-2) mod2=0. x=2, y=4. LCM=4.\n\nSo the minimal LCM is 4, achieved at k=0.\n\nThus, the code outputs 0.\n\nAnother test case: a=3, b=6. delta=3.\n\ndivisors 1,3.\n\ng=1: k=0. LCM 18.\n\ng=3: k=0. x=3, y=6. LCM 6.\n\nThus, the code would choose k=0.\n\nWhich is better.\n\nSo, code seems correct.\n\nThus, the final code should implement this logic.\n",
    "response": "To solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**:\n   - The goal is to minimize the LCM of two numbers formed by adding \\( k \\) to both \\( a \\) and \\( b \\).\n   - The LCM of two numbers can be minimized by maximizing their greatest common divisor (GCD). Therefore, we need to explore possible values of GCDs that can be formed by adding \\( k \\) to both \\( a \\) and \\( b \\).\n\n2. **Key Insight**:\n   - The difference between \\( a \\) and \\( b \\) (denoted as \\( \\delta \\)) plays a crucial role. The GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of \\( \\delta \\).\n   - By considering all divisors of \\( \\delta \\), we can determine the optimal \\( k \\) for each divisor and then select the best one.\n\n3. **Algorithm**:\n   - Compute \\( \\delta \\) as the absolute difference between \\( a \\) and \\( b \\).\n   - Generate all divisors of \\( \\delta \\).\n   - For each divisor \\( g \\), compute the smallest non-negative \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are multiples of \\( g \\).\n   - Calculate the LCM for each valid \\( k \\) and keep track of the smallest LCM and corresponding \\( k \\).\n\n4. **Complexity Consideration**:\n   - Generating divisors of \\( \\delta \\) involves iterating up to \\( \\sqrt{\\delta} \\), which is efficient even for large values of \\( \\delta \\) (up to \\( 10^9 \\)).\n\n### Solution Code\n```python\nimport math\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    delta = abs(a - b)\n    \n    def get_divisors(n):\n        if n == 0:\n            return []\n        divisors = set()\n        for i in range(1, int(math.isqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(divisors)\n    \n    divisors = get_divisors(delta)\n    \n    min_lcm = float('inf')\n    best_k = None\n    \n    for g in divisors:\n        k = (-a) % g\n        x = a + k\n        y = b + k\n        current_gcd = g\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    \n    print(best_k)\n```\n\n### Explanation\n- **Handling Special Case**: If \\( a \\) equals \\( b \\), the answer is immediately \\( k = 0 \\) since adding any \\( k \\) will result in the same value for both, minimizing the LCM.\n- **Divisor Calculation**: The function `get_divisors` efficiently computes all divisors of \\( \\delta \\) by iterating up to its square root.\n- **Iterating Over Divisors**: For each divisor \\( g \\) of \\( \\delta \\), compute the smallest \\( k \\) that makes both \\( a + k \\) and \\( b + k \\) multiples of \\( g \\). This ensures the GCD is at least \\( g \\), helping to minimize the LCM.\n- **LCM Calculation**: For each valid \\( k \\), compute the LCM and track the minimum value, updating \\( k \\) whenever a smaller LCM is found or the same LCM with a smaller \\( k \\) is encountered.\n\nThis approach ensures that we efficiently explore all potential values of \\( k \\) to find the optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    delta = abs(a - b)\n    \n    def get_divisors(n):\n        if n == 0:\n            return []\n        divisors = set()\n        for i in range(1, int(math.isqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(divisors)\n    \n    divisors = get_divisors(delta)\n    \n    min_lcm = float('inf')\n    best_k = None\n    \n    for g in divisors:\n        k = (-a) % g\n        x = a + k\n        y = b + k\n        current_gcd = g\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    \n    print(best_k)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 383,
        "completion_token_count": 884,
        "thoughts_token_count": 4477
    }
}