{
    "start": 1758278297.8552828,
    "end": 1758278548.3690724,
    "start-formatted": "2025-09-19 19:38 KST",
    "end-formatted": "2025-09-19 19:42 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about finding the smallest non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. If there are multiple k's that give the same minimal LCM, we choose the smallest k.\n\nHmm, let's think about this. The LCM of two numbers is equal to (product of the two numbers) divided by their greatest common divisor (GCD). So, LCM(x, y) = x*y / GCD(x, y). \n\nWait, but in our case, both numbers are a +k and b +k. Let's denote d = GCD(a, b). Then, since a and b can be written as a = d * m and b = d * n, where m and n are coprime (their GCD is 1). \n\nSo when we add k to both, a + k = d*m + k and b +k = d*n + k. Let's factor this: d*(m) + k = k + d*m, and similarly for the other term. Let me think about the GCD of these two terms.\n\nWait, what's the GCD of (a + k) and (b +k)? Let's compute GCD(a +k, b +k). Since a +k - (b +k) = a - b. So the GCD of (a +k) and (b +k) is the same as GCD(d*m +k, d*n +k). Hmm, maybe I can find a way to express this.\n\nAlternatively, since a and b have a GCD of d, their difference is d*(m -n), assuming m > n without loss of generality. But I'm not sure if that helps directly.\n\nWait, another approach: Let's consider the expression (a +k) and (b +k). Their difference is a - b. So, GCD(a +k, b +k) = GCD(a - b + 2k, a +k). Wait, no, because the difference between (a +k) and (b +k) is a - b. So, GCD(a +k, b +k) must divide a - b. Let me denote g = GCD(a - b, ...). Wait, maybe it's better to express this differently.\n\nLet me denote g = GCD(a +k, b +k). Then, g divides (a +k) - (b +k) = a - b. So g divides a - b. So g must be a divisor of a - b.\n\nWait, that's a crucial point. So the GCD of a +k and b +k must be a divisor of |a - b|. Because the difference between the two numbers is a - b, which is fixed once a and b are given.\n\nSo, for all possible k, the GCD of (a +k) and (b +k) is a divisor of |a - b|. Therefore, to minimize the LCM, perhaps we should look at the divisors of d = GCD(a, b), but wait, no, because d is the GCD of a and b, but the GCD of a +k and b +k is a divisor of a - b. Oh right, because a -b is a fixed value.\n\nWait, no, wait. Let me re-express this. Let's compute the GCD of (a +k) and (b +k). Let me subtract them: (a +k) - (b +k) = a - b. So any common divisor of (a +k) and (b +k) must also divide a - b. So the GCD is a divisor of a - b.\n\nWait, that makes sense. So the GCD of (a +k) and (b +k) is a divisor of |a - b|.\n\nSo, to find the minimal LCM of (a +k) and (b +k), perhaps the strategy is to find all possible divisors of |a - b|, and then for each possible divisor g, find the minimal k that allows g to be the GCD of (a +k) and (b +k), and then compute the LCM.\n\nWait, but how do I find the k that maximizes the GCD? Because higher GCDs would lead to lower LCMs.\n\nSo, the plan is:\n\n1. Compute the absolute difference between a and b, call it D = |a - b|. If D is zero, then a equals b. In that case, adding k to both doesn't change their value, so the LCM is a (or b). So k can be zero, which is the minimal choice.\n\n2. If D is not zero, then find all the",
    "response": "To solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Understanding the Problem**: The LCM of two numbers \\( x \\) and \\( y \\) can be expressed as \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\). Here, \\( x = a + k \\) and \\( y = b + k \\).\n2. **Key Insight**: The greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must be a divisor of the absolute difference \\( D = |a - b| \\). This is because \\( (a + k) - (b + k) = a - b \\), so any common divisor of \\( a + k \\) and \\( b + k \\) must divide \\( D \\).\n3. **Finding Optimal \\( k \\)**: We need to find the \\( k \\) that maximizes the GCD of \\( a + k \\) and \\( b + k \\), which in turn minimizes the LCM. This involves checking all divisors of \\( D \\) and determining the corresponding \\( k \\) for each divisor.\n4. **Efficient Calculation**: By iterating over all divisors of \\( D \\) and computing the required \\( k \\) for each divisor, we can efficiently find the optimal \\( k \\) without excessive computation.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef main():\n    a, b = map(int, sys.stdin.readline().split())\n    if a == b:\n        print(0)\n        return\n    \n    D = abs(a - b)\n    g = math.gcd(a, b)\n    \n    min_lcm = float('inf')\n    best_k = 0\n    \n    # Find all divisors of D\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(math.isqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(divisors)\n    \n    divisors = get_divisors(D)\n    \n    for d in divisors:\n        # We want (a + k) mod d == 0 and (b + k) mod d == 0\n        # Since d divides a - b, let's see:\n        # a + k ≡ 0 mod d → k ≡ (-a) mod d\n        # b + k ≡ 0 mod d → k ≡ (-b) mod d\n        # So, (-a) mod d must be equal to (-b) mod d → (a - b) mod d == 0, which it is since d divides D.\n        \n        # So, k must be congruent to (-a) mod d. Let's compute the required k.\n        k_candidate = (-a) % d\n        \n        # Compute the current lcm\n        x = a + k_candidate\n        y = b + k_candidate\n        current_gcd = math.gcd(x, y)\n        current_lcm = x * y // current_gcd\n        \n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n    \n    # Also check k=0 case\n    x = a\n    y = b\n    current_gcd = math.gcd(x, y)\n    current_lcm = x * y // current_gcd\n    if current_lcm < min_lcm or (current_lcm == min_lcm and 0 < best_k):\n        min_lcm = current_lcm\n        best_k = 0\n    \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the optimal \\( k \\) is 0 since adding any \\( k \\) will not change the value.\n3. **Divisor Calculation**: Compute all divisors of the absolute difference \\( D = |a - b| \\).\n4. **Iterate Over Divisors**: For each divisor, compute the corresponding \\( k \\) that makes \\( a + k \\) and \\( b + k \\) multiples of the divisor. Track the \\( k \\) that results in the smallest LCM.\n5. **Check Zero Case**: Ensure to consider \\( k = 0 \\) as it might yield the minimal LCM without any changes.\n6. **Output Result**: Print the optimal \\( k \\) found.\n\nThis approach efficiently narrows down the possible values of \\( k \\) by leveraging the properties of divisors and GCD, ensuring an optimal solution within feasible computation limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef main():\n    a, b = map(int, sys.stdin.readline().split())\n    if a == b:\n        print(0)\n        return\n    \n    D = abs(a - b)\n    g = math.gcd(a, b)\n    \n    min_lcm = float('inf')\n    best_k = 0\n    \n    # Find all divisors of D\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(math.isqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(divisors)\n    \n    divisors = get_divisors(D)\n    \n    for d in divisors:\n        # We want (a + k) mod d == 0 and (b + k) mod d == 0\n        # Since d divides a - b, let's see:\n        # a + k ≡ 0 mod d → k ≡ (-a) mod d\n        # b + k ≡ 0 mod d → k ≡ (-b) mod d\n        # So, (-a) mod d must be equal to (-b) mod d → (a - b) mod d == 0, which it is since d divides D.\n        \n        # So, k must be congruent to (-a) mod d. Let's compute the required k.\n        k_candidate = (-a) % d\n        \n        # Compute the current lcm\n        x = a + k_candidate\n        y = b + k_candidate\n        current_gcd = math.gcd(x, y)\n        current_lcm = x * y // current_gcd\n        \n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n    \n    # Also check k=0 case\n    x = a\n    y = b\n    current_gcd = math.gcd(x, y)\n    current_lcm = x * y // current_gcd\n    if current_lcm < min_lcm or (current_lcm == min_lcm and 0 < best_k):\n        min_lcm = current_lcm\n        best_k = 0\n    \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 392,
        "completion_token_count": 1088,
        "thoughts_token_count": 1025
    }
}