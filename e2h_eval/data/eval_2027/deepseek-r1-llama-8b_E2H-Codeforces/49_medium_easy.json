{
    "start": 1758285956.9611053,
    "end": 1758288182.9458947,
    "start-formatted": "2025-09-19 21:45 KST",
    "end-formatted": "2025-09-19 22:23 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about reconstructing the number of laughy mushrooms on each lawn based on some given roads. Each road has two numbers: the GCD and LCM of the two lawns it connects. My task is to determine if there's a possible arrangement of the mushroom counts that satisfies all these roads, and if so, output one such arrangement.\n\nHmm. So the input gives me n (number of lawns) and m (number of known roads). Then for each road, I have four numbers: u, v, g, l. These represent that the edge connects lawn u to v, and the GCD of their mushroom counts is g, LCM is l.\n\nWait, but wait—no, wait: the problem says that each edge between two lawns has two numbers written: GCD and LCM of the numbers on those two lawns. So for each edge, when you look at the two endpoints, their mushroom counts must have GCD equal to g and LCM equal to l.\n\nWait, but that can't be right because GCD and LCM are related in a specific way. For two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So for each edge, the product of the GCD and LCM must equal the product of the two mushrooms.\n\nSo for each edge, the mushrooms at u and v must satisfy:\n\ng * l = x * y, where x is the count at u and y at v.\n\nBut also, g must divide both x and y, and l must be a multiple of both.\n\nSo for each edge, we have constraints on x and y.\n\nThe challenge is to assign values x_1, x_2, ..., x_n such that all edges' constraints are satisfied.\n\nHow can I model this? It seems like a system of equations with constraints, which suggests that a graph-based approach, perhaps using Union-Find with some additional information, might work.\n\nWait, but since the constraints involve pairs of variables (x and y for each edge), this might form a system of equations that can be solved by building a graph where each node has certain relationships.\n\nAlternatively, perhaps this can be modeled as a system of constraints that can be solved with some kind of BFS or DFS approach, determining the possible values for each node step by step.\n\nLet me think about the structure. For each edge, we have:\n\ng = gcd(x, y)\nl = lcm(x, y)\n\nWhich implies that x = g * a, y = g * b, where a and b are coprime integers, and l = g * a * b.\n\nBecause GCD(a,b) must be 1.\n\nSo for each edge, x and y can be represented as multiples of the GCD, scaled by coprime factors whose product gives the LCM divided by the GCD.\n\nSo for each edge, given g and l, we can compute a and b as:\n\na = l / g / b ?\n\nWait, no. Wait, since GCD(x,y) = g, and LCM(x,y) = l, then x = g * a, y = g * b, with a and b being coprime, and a*b = l/g.\n\nYes, because x*y = g^2 a b, and LCM(x,y) is g*a*b, because a and b are coprime. So yes, l = g * a * b.\n\nSo for each edge, the possible values for x and y are determined by choosing a and b such that a * b = l/g, and a and b are coprime.\n\nBut since the problem requires that any valid assignment is acceptable, perhaps we can model this as a system where each connected component can be assigned a value, and the constraints propagate through the graph.\n\nWait, but how?\n\nAnother approach: Each connected component can be considered as a set of variables that are connected via these edges. For each connected component, I need to assign values to each node such that all edges' constraints are satisfied.\n\nThis feels like a problem that can be modeled with a graph where each edge adds constraints between two nodes. So perhaps the solution involves building a system of constraints and checking for consistency.\n\nBut how to represent this in code?\n\nHmm. Maybe using a Union-Find data structure, but with some modifications to track the relationships between variables. Alternatively, think of this as a bipartition problem, but that might not directly apply here.\n\nAlternatively, perhaps each connected component can be treated as a tree, and during a BFS, we can assign the values step by step, ensuring that all constraints are met.\n\nWait, another thought: For each node, its value is determined by the constraints from its connected edges. So for example, if a node is part of a tree, each edge from the root to the node imposes certain constraints on the node's value.\n\nBut how do these constraints interact? Because each edge may impose different constraints on the same node.\n\nSo perhaps each connected component can be represented as a directed graph where the constraints propagate from one node to another, and any inconsistency would make the entire setup impossible.\n\nSo the plan is:\n\n1. For each connected component, perform a BFS or DFS to assign values to each node based on the constraints.\n2. During this process, if any contradiction is found (e.g., a node's value is determined to be both x and y, which are different), output 'NO'.\n3. If all components are processed without contradictions, output 'YES' and the assigned values.\n\nBut how to represent the possible values for each node? Since each edge imposes constraints, the value of a node may be determined relative to its parent in the BFS tree.\n\nWait, perhaps each node can have a variable that represents its value in terms of a base variable. For example, if a node is connected via an edge to a parent, the child's value is determined as a multiple of the parent's value, considering the edge's GCD and LCM.\n\nWait, let's think about this: For a node u and its parent v, if the edge between them has GCD g and LCM l, then u's value is x_u and v's is x_v.\n\nWe know that x_u = g * a, x_v = g * b, where a*b = l/g, and a and b are coprimes.\n\nSo suppose during BFS, we assign a value to v. Then, when processing u, we can compute x_u based on x_v and the edge's parameters.\n\nBut how does this scale when the graph has cycles? Because if there's a cycle, the constraints along the cycle must agree for the entire cycle, otherwise it's impossible.\n\nSo, for each connected component, we can choose a root and assign a value to it. Then, for each other node, we can express its value in terms of the root's value.\n\nWait, but the root's value can be arbitrary? Or is it determined by the constraints?\n\nNo, because for each connected component, the root's value can be chosen as any integer, but all other nodes' values are determined based on the root's value and the edges.\n\nWait, but in reality, the root's value is determined by the constraints. Because when you process the edges, the root's value might be constrained by multiple edges.\n\nWait, perhaps not. Because the root could be part of multiple edges, each of which could impose different constraints on the root's value.\n\nFor example, if the root has two edges: one edge says that the root's value is 5, and another edge says it's 10, that's a conflict.\n\nSo the root's value must be consistent across all edges it's part of.\n\nSo during BFS, when assigning the root's value, we need to make sure that all edges incident to the root don't impose conflicting constraints.\n\nIf the root is a leaf node, then no problem. But if it's part of multiple edges, each edge imposes that the root's value must be a multiple of the edge's GCD and that the LCM must be as given.\n\nWait, perhaps I'm complicating things. Let's think of each edge as a constraint between two variables.\n\nEach variable can be expressed as a multiple of the GCD of the edge, scaled by coprimes.\n\nSo for each node, its value is determined by the path from the root, considering all the edges along that path.\n\nTherefore, the idea is to model each node's value as a function of the root's value. For each node, we can write x_i = k_i * root_value, where k_i is some integer derived from the path.\n\nWait, but maybe it's better to model each node's value in terms of a base variable. So for each node, we can represent it as x_i = c_i * d, where d is the value of the root, and c_i is a constant determined by the path from the root to i.\n\nBut how do the constraints come into play?\n\nLet me think: For each edge between u and v, with GCD g and LCM l.\n\nIn terms of the root, suppose u has x_u = c_u * d, and v has x_v = c_v * d.\n\nThen, according to the edge, GCD(x_u, x_v) must be g, and LCM(x_u, x_v) must be l.\n\nBut substituting, GCD(c_u d, c_v d) = d * GCD(c_u, c_v) = g.\n\nSimilarly, LCM(c_u d, c_v d) = d * LCM(c_u, c_v) = l.\n\nSo, for each edge, the following must hold:\n\nd * GCD(c_u, c_v) = g\n\nd * LCM(c_u, c_v) = l\n\nWhich implies that:\n\nGCD(c_u, c_v) = g / d\n\nLCM(c_u, c_v) = l / d\n\nBut since GCD(c_u, c_v) must divide both c_u and c_v, and LCM(c_u, c_v) must be a multiple of both, this gives us constraints on d.\n\nAlso, since LCM(c_u, c_v) = (c_u * c_v) / GCD(c_u, c_v), we have:\n\nl / d = (c_u * c_v) / (g / d)\n\nMultiply both sides by d:\n\nl = (c_u * c_v * d) / (g / d) ) \n\nWait, simplifying:\n\nl = (c_u * c_v * d^2) / g\n\nBut from earlier, d must be a divisor of g, because GCD(c_u, c_v) = g/d must be an integer.\n\nSo, for each edge, d must be a divisor of g.\n\nFurthermore, for each edge, after choosing d, the values of c_u and c_v are determined.\n\nWait, perhaps the approach is as follows:\n\n1. For each connected component, choose a root. Let's say the root is assigned a value d.\n\n2. For all edges incident to the root, check if they are consistent with d.\n\n   For each such edge, the other node's value is determined by the edge's GCD and LCM.\n\n   For example, for an edge (u, v), if u is the root (d), then v's value is determined by the edge's GCD and LCM.\n\n3. Once the root's value is fixed, the rest of the component's values are determined based on the edges.\n\nBut the problem is that the root's value d may not be fixed—it could vary, leading to different possible assignments. However, since we only need to find one possible assignment, perhaps we can fix d to a particular value and see if it works.\n\nWait, but how to choose d? Because d can be any value that satisfies all the constraints imposed by the edges.\n\nAlternatively, perhaps the root's value is determined by the constraints of the edges.\n\nWait, perhaps each connected component can have its root's value determined based on the edges. For example, for the root, all edges incident to it must have their GCD and LCM compatible with the same d.\n\nSo, for the root, the value d must satisfy that for each edge (root, v), the GCD of d and x_v is g, and LCM is l.\n\nBut since x_v is determined by the edge, perhaps the root's d must be a common multiple of all such g's, but I'm not sure.\n\nThis is getting a bit complicated.\n\nMaybe I should try a different approach.\n\nEach edge can be represented as a constraint between two variables. The variables are the x_i's.\n\nEach edge enforces that x_u and x_v satisfy:\n\ngcd(x_u, x_v) = g\nlcm(x_u, x_v) = l\n\nWhich implies that:\n\ng = gcd(x_u, x_v)\nl = lcm(x_u, x_v)\n\nAnd since g * l = x_u * x_v, we have:\n\nx_u * x_v = g * l.\n\nSo, for each edge, the product of x_u and x_v is fixed as g*l.\n\nBut since the graph is made up of these edges, each connected component forms a system where the variables are interconnected.\n\nSo the problem reduces to solving a system of equations where for each edge, x_u * x_v = g * l, and the variables are all positive integers.\n\nWait, but that's not the case because the GCD and LCM also impose that x_u and x_v are multiples of g, and their LCM is l.\n\nSo, in addition to x_u * x_v = g*l, we have:\n\nx_u = g * a\nx_v = g * b\n\nwhere a and b are coprime positive integers.\n\nAnd l = g * a * b.\n\nSo, for each edge, x_u = g * a, x_v = g * b, with a and b coprimes and a*b = l/g.\n\nSo, for each edge, the pair (x_u, x_v) must be a multiple of g, scaled by coprimes whose product is l/g.\n\nSo, the problem becomes finding a way to assign to each node a value such that for every edge, x_u and x_v are of the form g*a and g*b, with a and b coprimes and a*b = l/g.\n\nThis suggests that the variables are linked in a way that propagates through the graph.\n\nOne approach is to model this as a graph where each node's value is a multiple of a certain base value, and edges enforce the constraints between these bases.\n\nWait, perhaps for each connected component, we can assign a base variable, say, s, and express all other variables in terms of s.\n\nBut how?\n\nSuppose we have a connected component, and we pick a root node r. We can express the value of each other node in terms of r's value.\n\nFor example, for each edge (r, u), the value of u is determined as:\n\nx_u = (g * a) where a is such that a is coprime with (x_r / g).\n\nWait, perhaps more precisely:\n\nSince x_r = g * a_r (from the root's perspective), then for an edge (r, u), x_u must be g * b, where b is coprime with a_r, and a_r * b = (l / g) for that edge.\n\nSo, for each edge, once the root's value is known, the other node's value is determined.\n\nBut wait, if the root's value is fixed, then each edge connected to the root determines the value of the other node.\n\nOnce the root's value is determined, the rest of the component can be filled in accordingly.\n\nSo the problem breaks down into:\n\n- For each connected component, determine if there exists a value for the root such that all edges from the root to its children are satisfied, and all other edges within the component are also satisfied.\n\nIf so, assign the values accordingly.\n\nBut how to choose the root's value?\n\nPerhaps the root can be assigned any value that satisfies all the edges connected to it.\n\nEach edge connected to the root (r) will impose constraints on x_r.\n\nSpecifically, for each edge (r, u), x_r must be such that:\n\nx_r * x_u = g * l, where g and l are the edge's GCD and LCM.\n\nBut x_u is determined by the other edges.\n\nWait, this seems circular.\n\nAlternative approach: For each connected component, the root's value must be a value such that for each edge connected to the root, x_u is determined as per the edge's constraints.\n\nMoreover, for each edge not connected to the root, the values of u and v must be determined based on their parents in the BFS tree, and these must satisfy the edge's constraints.\n\nSo the steps I can take are:\n\n1. Build the graph, noting for each edge the GCD and LCM.\n\n2. For each connected component:\n\n   a. Choose a root (say, node 1 in the component).\n\n   b. Assign a value to the root. How? Well, the root's value must satisfy all edges connected to it. For each edge from the root to a child, the root's value must be compatible with that edge's GCD and LCM.\n\n   c. For each edge connected to the root, compute what the child's value must be based on the root's value.\n\n   d. Proceed to assign values to the rest of the component, ensuring that each edge's constraints are met.\n\n   e. If any inconsistency is found (like a node's value being determined in two different ways), mark the configuration as impossible.\n\n3. If all components are processed successfully, output the values. Otherwise, output \"NO\".\n\nBut the problem is, how to choose the root's value? Because the root's value could be any value that satisfies all edges connected to it.\n\nWait, but for each edge connected to the root, the root's value must be such that when multiplied by the child's value, equals g * l, and the child's value is determined by the edge's GCD and LCM.\n\nWait, perhaps the root's value can be determined by the constraints of its edges.\n\nFor each edge (r, u), the root's x_r and u's x_u must satisfy:\n\ngcd(x_r, x_u) = g\nlcm(x_r, x_u) = l\n\nWhich implies:\n\nx_r * x_u = g * l\n\nBut x_u is determined by the edge as x_u = g * a, x_r = g * b, where a and b are coprimes and a*b = l/g.\n\nSo, x_r must be a multiple of g, and so must x_u.\n\nThus, for the root, all edges connected to it must agree on the same value of x_r.\n\nWait, but that's not necessarily the case. For example, suppose the root is connected to two different edges with different GCDs. Then, the root's x_r must be a common multiple of those GCDs, but also satisfy that for each edge, the product x_r * x_u equals g * l.\n\nWait, this is getting quite involved.\n\nAnother approach: Treat each connected component as a system of equations. Each equation is x_u * x_v = g * l for each edge (u, v). This forms a system that can be represented as a graph where each node's value is determined relative to others.\n\nBut solving such a system for all variables is non-trivial, especially for large n.\n\nWait, but perhaps for each connected component, the values can be determined up to a multiplicative constant. So, for a component, the variables are determined by choosing a root and then expressing all other variables in terms of the root's value.\n\nBut how?\n\nLet me think about this:\n\nEach node can be represented as x_i = k_i * d, where d is the value of the root, and k_i is a constant determined by the path from the root to node i.\n\nFor each edge (u, v), the value x_u * x_v must equal g * l.\n\nSubstituting, (k_u d) * (k_v d) = g l → k_u k_v d² = g l.\n\nSo, for each edge, this equation must hold.\n\nAdditionally, for each edge, the GCD of x_u and x_v must be g, and the LCM must be l.\n\nBut since x_u = k_u d and x_v = k_v d, the GCD(k_u d, k_v d) = d * GCD(k_u, k_v) = g.\n\nSimilarly, the LCM is d * LCM(k_u, k_v) = l.\n\nSo, for each edge:\n\nd * GCD(k_u, k_v) = g → GCD(k_u, k_v) = g / d.\n\nd * LCM(k_u, k_v) = l → LCM(k_u, k_v) = l / d.\n\nAlso, since k_u and k_v are coprimes (because their GCD is g/d, which must divide both k_u and k_v, but in our case, the GCD is already accounted for by the scaling factor d), but wait no—wait, the GCD of k_u and k_v is (g/d), which must be an integer. So, (g/d) must be a divisor of both k_u and k_v.\n\nWait, but wait: GCD(k_u, k_v) = g/d → which is an integer, so d must divide g.\n\nSo, d must be a divisor of g for each edge in the component.\n\nWait, but in a connected component, all edges must have d dividing g. So for all edges in the component, d must be a divisor of their g.\n\nHmm. So, for the entire component, d must be a common divisor of all the g's in the edges.\n\nWait, but what if the component has multiple edges, each with different g's? Then d must divide all of them.\n\nSo, the maximum possible d is the greatest common divisor (gcd) of all the g's in the component.\n\nWait, because d must divide each g in the component. So the maximum possible d is the gcd of all g's in the component.\n\nWait, perhaps. Because if the component has edges with various g's, d must be a common divisor of all of them. So the largest possible d is the gcd of all the g's.\n\nBut in practice, d could be any divisor of this overall gcd.\n\nSo, for each component, the possible d's are the divisors of the gcd of all the g's in the component.\n\nWait, but wait: for a component with no edges (like a single node), the d can be any value. But in our case, the problem says that the initial map had edges with g >=1, but for a single node, there are no edges, so any value is acceptable.\n\nWait, but for a single node, it's allowed to have any value, including zero? No, because the problem states that the initial numbers on the edges were at least 1. So the initial map may have had edges, but the remaining map Pasha has has m roads, possibly including single-node components.\n\nWait, no: the problem statement says, \"the numbers on the roads on the initial map were no less than 1 and did not exceed 106.\"\n\nWait, but for a component with a single node, there are no edges, so the value can be any positive integer. So in that case, we can assign any value, perhaps 1 for simplicity.\n\nBut for a component with multiple nodes, each edge's g must be divisible by d.\n\nSo, the steps for each component are:\n\n1. Compute the gcd of all g's in the component. Let's call this D.\n\n   For example, if the component has edges with g=2, g=4, then D=2.\n\n   So, d must be a divisor of D.\n\n2. For each possible d (divisor of D), check if the component can be consistently assigned with that d.\n\n   If any d allows a consistent assignment, proceed with that d.\n\n3. Once d is chosen, compute the k_i's for each node in the component.\n\n   For the root, k_root = 1 (since x_root = d * 1).\n\n   For each edge from the root to a child, compute the k_child based on the edge's g and l.\n\n   Then, propagate these k_i's through the component, checking for consistency.\n\nBut wait, how to compute the k_i's for each node.\n\nWait, for a node u, when visiting it from its parent p, the edge (p, u) has g_pu and l_pu.\n\nWe have:\n\nx_p = d * k_p\n\nx_u = d * k_u\n\nSo, for the edge (p, u):\n\ngcd(d*k_p, d*k_u) = g_pu → d * gcd(k_p, k_u) = g_pu → since d divides g_pu (as per D being the overall gcd), let's define h = g_pu / d.\n\nSo, h = gcd(k_p, k_u).\n\nSimilarly, lcm(d*k_p, d*k_u) = l_pu → d * lcm(k_p, k_u) = l_pu → lcm(k_p, k_u) = l_pu / d.\n\nBut since h = gcd(k_p, k_u), we have:\n\nlcm(k_p, k_u) = (k_p * k_u) / h.\n\nSo:\n\n(k_p * k_u) / h = l_pu / d.\n\nBut since h = g_pu / d, substituting:\n\n(k_p * k_u) / (g_pu / d) = l_pu / d.\n\nMultiply both sides by (g_pu / d):\n\nk_p * k_u = (l_pu / d) * (g_pu / d).\n\nSo:\n\nk_p * k_u = (g_pu * l_pu) / (d²).\n\nBut also, since h = gcd(k_p, k_u) = g_pu / d.\n\nHmm. So, the product k_p * k_u must be equal to (g_pu * l_pu) / d².\n\nSo, for each edge, given the parent's k_p, the child's k_u can be computed as:\n\nk_u = (g_pu * l_pu) / (d² * k_p) ?\n\nWait, but that would require that (g_pu * l_pu) is divisible by d squared.\n\nBut since d is a divisor of g_pu, which is part of the component's D, which is the gcd of all g's in the component, then d² divides g_pu * ... well, perhaps.\n\nWait, perhaps I can model this as follows:\n\nOnce d is chosen as a divisor of D, for each edge, the product k_p * k_u must be equal to (g * l) / (d²).\n\nSo, for each edge, we can compute the required product of k_p and k_u.\n\nMoreover, since h = gcd(k_p, k_u) = g / d, the product must be a multiple of h.\n\nWait, perhaps the way to proceed is:\n\n1. For each component, collect all the edges.\n\n2. Compute D, the gcd of all g's in the component.\n\n3. Enumerate all possible d's that are divisors of D.\n\n4. For each d, check if all edges in the component can be satisfied with this d.\n\n   For each edge, compute the required k_p and k_u such that:\n\n   k_p * k_u = (g * l) / (d²)\n\n   and\n\n   gcd(k_p, k_u) = g / d.\n\n5. If all edges in the component can be satisfied with this d, then proceed with this d.\n\n6. Once a valid d is found, assign the k_i's and compute the x_i's.\n\nBut how to implement this?\n\nThis seems computationally intensive, especially for large D.\n\nBut considering that D can be up to 1e6 (since g is up to 1e6?), enumerating all divisors of D for each component may be manageable if the number of components is small.\n\nWait, but in the worst case, D can be 1e6, which has about 100 divisors, and for each component, we'd have to test each divisor.\n\nBut perhaps in practice, the number of components is manageable.\n\nSo, the plan is:\n\nFor each connected component:\n\na. Compute D as the GCD of all g's in the component.\n\nb. Enumerate all divisors of D.\n\nc. For each divisor d in the list:\n\n   i. Check if for all edges in the component, (g * l) is divisible by d².\n\n   ii. For each edge, compute the required k_p * k_u = (g * l) / (d²).\n\n   iii. Also, ensure that the gcd(k_p, k_u) = g / d.\n\n   iv. Propagate these k's through the component, starting from the root.\n\n   v. If all edges are satisfied with this d, proceed to assign values.\n\nd. If any d works, assign the values and proceed.\n\ne. If no d works, output 'NO'.\n\nNow, how to implement this?\n\nImplementing this would require:\n\n- Representing each component as a graph.\n\n- For each component, performing a BFS or DFS to assign k's.\n\nBut how to manage the assignment of k's, especially since for each edge, the k's are determined based on their parent.\n\nWait, perhaps for each component:\n\n- Choose a root node (say, the first node in the component).\n\n- Assign k_root = 1.\n\n- For each edge from the root to a child, compute the child's k based on the edge's g and l, and the current root's k.\n\n- Then, proceed to assign the k's for the child nodes, ensuring that each edge is satisfied.\n\nBut how?\n\nLet's think of this as a tree. For each edge, the child's k is determined based on the parent's k and the edge's g and l.\n\nSo, for each edge (p, u), with g and l:\n\nWe have:\n\nk_p * k_u = (g * l) / (d²)\n\nand\n\ngcd(k_p, k_u) = g / d.\n\nSo, for each edge, given the parent's k_p, the child's k_u can be computed.\n\nBut how?\n\nWe can compute the required product as (g*l)/(d²), and the required GCD as g/d.\n\nLet me denote:\n\nproduct = (g * l) / (d²)\n\nh = g / d.\n\nSo, for the edge, k_p and k_u must satisfy:\n\nk_p * k_u = product\n\ngcd(k_p, k_u) = h.\n\nSo, the possible pairs (k_p, k_u) are such that:\n\nk_p = h * a\n\nk_u = h * b\n\nwhere a and b are coprime integers, and a * b = product / h².\n\nBecause:\n\nk_p * k_u = h² a b = product → a b = product / h².\n\nAnd since h is the GCD of k_p and k_u, a and b must be coprimes.\n\nSo, for each edge, given h and product, we can find all possible pairs (a, b) that are coprimes and multiply to product/h².\n\nBut how do we choose between them? Because for the same edge, the same pair must be used regardless of the path taken to reach the child.\n\nWait, but in a BFS, each node is visited once, so the way we compute k_u is based on the parent's k_p.\n\nSo, for the edge (p, u), the k_u is determined based on k_p.\n\nSo, for each edge, given k_p, the k_u can be calculated as (product / k_p) / ... wait, no:\n\nWait, k_p * k_u = product → k_u = product / k_p.\n\nBut also, since h = gcd(k_p, k_u) = g/d, which must divide both k_p and k_u.\n\nSo, for each edge, once k_p is known, k_u can be computed as product / k_p, but it must be that h divides k_p and k_u.\n\nSo, perhaps for each edge, given the parent's k_p, the child's k_u is product / k_p, and then we check whether the GCD(k_p, k_u) is indeed h.\n\nIf it is, then proceed; else, this d is invalid.\n\nSo, during the BFS, for each edge (p, u):\n\nCompute k_u_candidate = (g * l) / (d²) / k_p.\n\nCheck if gcd(k_p, k_u_candidate) == h.\n\nIf yes, proceed to assign k_u = k_u_candidate.\n\nElse, this d is invalid.\n\nSo, for each component and each d, the algorithm proceeds as:\n\n1. Compute D as the GCD of all g's in the component.\n\n2. For each d in divisors of D:\n\n   a. For each edge in the component, compute product = (g * l) / (d²).\n\n   b. Check if product is an integer. If any edge's product is not integer, skip this d.\n\n   c. Now, for each edge, the child's k_u is product / k_p.\n\n   d. For the root, k_p is 1.\n\n   e. For each edge from the root to its children:\n\n      i. Compute k_u_candidate = product_edge / k_p.\n\n      ii. Check if gcd(k_p, k_u_candidate) == g_root_edge / d.\n\n      iii. If not, this d is invalid.\n\n   f. Then, perform a BFS/DFS to assign k's to all nodes, computing each child's k based on the parent's k.\n\n      For each edge, compute k_u_candidate, and check if the GCD condition holds.\n\n      If any edge fails, this d is invalid.\n\n   g. If all edges are satisfied for this d, then assign the k's and proceed.\n\n3. If a valid d is found, assign the x_i's as d * k_i.\n\n4. Else, output 'NO'.\n\nBut this seems computationally heavy, but perhaps manageable.\n\nNow, considering the code:\n\nWe can represent the graph as an adjacency list, where each edge contains the other node, g, l.\n\nWe'll process each component separately.\n\nFor each component:\n\n- Collect all edges.\n\n- Compute D as the GCD of all g's in the component.\n\n- Enumerate all divisors of D.\n\n- For each divisor d:\n\n   - For each edge in the component, compute (g*l) / (d²). Must be integer.\n\n   - For the root (say, node 1), set k_root = 1.\n\n   - For each child of the root, compute k_child = (g * l) / (d²) / k_root.\n\n   - Check if the GCD of k_root and k_child is (g / d).\n\n   - Then, perform BFS/DFS to assign k's to all nodes.\n\n   - For each edge (parent, child), compute k_child_candidate = (g * l) / (d²) / k_parent.\n\n   - Check if GCD(k_parent, k_child_candidate) == (g / d).\n\n   - If all edges pass, assign x_i = d * k_i.\n\n   - Return the component's x_i's.\n\nIf any component cannot find a valid d, output 'NO'.\n\nOtherwise, output 'YES' and the x_i's.\n\nSo, the key steps are:\n\n- Enumerate all divisors of D.\n\n- For each d, check if all edges can be satisfied.\n\n- Once a valid d is found, assign the x's.\n\nNow, the question is: how to implement this efficiently.\n\nFirst, for each component, compute D.\n\nThen, for each d in the divisors of D, sorted in increasing or decreasing order, check whether it's possible.\n\nBut how to compute the divisors of D?\n\nWell, D can be up to 1e6, as each g is up to 1e6.\n\nSo, factorizing D into primes and generating all possible divisors is feasible.\n\nAlternatively, we can compute all divisors by checking up to sqrt(D).\n\nOnce the divisors are generated, proceed.\n\nNow, for each d, for each edge, compute product = (g * l) / (d²).\n\nIf any product is not an integer, skip this d.\n\nThen, for the root, set k_root = 1.\n\nThen, for each edge connected to the root, compute k_child = product / k_root.\n\nCheck if GCD(k_root, k_child) is equal to (g / d).\n\nIf any edge fails this, skip this d.\n\nThen, perform BFS:\n\nInitialize a queue with the root.\n\nMark the root as visited.\n\nFor each node in the queue:\n\n   For each neighbor:\n\n      If not visited:\n\n         Compute product = (g * l) / (d²).\n\n         k_child_candidate = product / k_parent.\n\n         If GCD(k_parent, k_child_candidate) != (g / d):\n\n             Invalid, break.\n\n         Else:\n\n             Assign k_child = k_child_candidate.\n\n             Add to queue.\n\nIf all edges are processed correctly, then assign the x's.\n\nBut wait, for each edge, the direction matters. So, when processing an edge (u, v), which way do we process it? Because when u is processed, v's k is determined based on u's k, but when v is processed, u's k is already determined.\n\nWait, perhaps the BFS should process each edge only once.\n\nAlternatively, perhaps it's better to represent the graph as an undirected graph, but during BFS, track the parent to avoid revisiting.\n\nSo, for each edge, when processing u, we visit v if it's not the parent.\n\nThus, each edge is processed once.\n\nSo, in code:\n\nFor each component:\n\n   Compute D as the GCD of all g's in the component.\n\n   Generate all divisors of D.\n\n   For each d in divisors:\n\n      For each edge in the component:\n\n          product = (g * l) // (d*d)\n\n          if (g*l) % (d*d) != 0:\n\n              continue to next d.\n\n      Now, build a BFS tree.\n\n      Assign k_root = 1.\n\n      Create a dictionary to store k for each node.\n\n      Initialize a queue with root.\n\n      k[root] = 1.\n\n      For each node in the queue:\n\n          for each neighbor in adj[node]:\n\n              if neighbor is parent: continue.\n\n              if neighbor is not in k:\n\n                  product = (g * l) // (d*d) → but wait, for this edge, what is g and l?\n\n                  Oh, wait, for each edge, it's part of the component.",
    "response": "To solve this problem, we need to determine if it's possible to reconstruct the number of laughy mushrooms on each lawn based on the given roads, which include the GCD and LCM of the mushroom counts at the endpoints. If possible, we should output any valid arrangement of these counts.\n\n### Approach\n1. **Graph Representation**: Represent the lawns as nodes and the roads as edges in a graph. Each edge has two values: the GCD and LCM of the mushroom counts at its endpoints.\n\n2. **Connected Components**: Identify all connected components in the graph. For each component, we will determine if there is a valid assignment of mushroom counts that satisfies all edges.\n\n3. **Divisors of GCD**: For each connected component, compute the GCD of all GCD values (g) from its edges. Enumerate all divisors of this GCD value. These divisors are potential values for the root node in the component.\n\n4. **Breadth-First Search (BFS)**: For each divisor, use BFS to propagate the values through the component. Start from an arbitrary root node and assign values to other nodes based on the constraints imposed by each edge.\n\n5. **Consistency Check**: During BFS, ensure that the assigned values satisfy all edge constraints (GCD and LCM). If any inconsistency is found, discard the current divisor and try the next one.\n\n6. **Output Result**: If a valid assignment is found for all components, output the results. Otherwise, output \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom math import gcd\nfrom collections import deque\n\ndef input():\n    return sys.stdin.read()\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx+1])\n    idx += 2\n    edges = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u = int(data[idx])\n        v = int(data[idx+1])\n        g = int(data[idx+2])\n        l = int(data[idx+3])\n        edges[u].append( (v, g, l) )\n        edges[v].append( (u, g, l) )\n        idx +=4\n    \n    visited = [False] * (n+1)\n    possible = True\n    ans = [0]*(n+1)\n    \n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            component = []\n            edges_component = []\n            while q:\n                u = q.popleft()\n                component.append(u)\n                for (v, g, l) in edges[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                        edges_component.append( (u, v, g, l) )\n            D = 0\n            for (u, v, g, l) in edges_component:\n                D = gcd(D, g)\n            if D == 0:\n                D = 1\n            divisors = get_divisors(D)\n            found = False\n            for d in divisors:\n                valid = True\n                k = {}\n                for (u, v, g, l) in edges_component:\n                    product = (g * l) \n                    if d*d > product:\n                        valid = False\n                        break\n                    if product % (d*d) != 0:\n                        valid = False\n                        break\n                if not valid:\n                    continue\n                \n                k[i] = 1\n                q = deque()\n                q.append(i)\n                while q and valid:\n                    u = q.popleft()\n                    for (v, g, l) in edges[u]:\n                        if v == u:\n                            continue\n                        if v not in k:\n                            product = (g * l) // (d * d)\n                            if product % k[u] != 0:\n                                valid = False\n                                break\n                            candidate = product // k[u]\n                            if math.gcd(k[u], candidate) != (g // d):\n                                valid = False\n                                break\n                            k[v] = candidate\n                            q.append(v)\n                if valid:\n                    for node in component:\n                        ans[node] = d * k[node]\n                    found = True\n                    break\n            if not found:\n                possible = False\n                break\n    if possible:\n        print(\"YES\")\n        print(' '.join(map(str, ans[1:])))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\nThe solution involves identifying connected components in the graph and determining if a valid assignment of mushroom counts exists for each component. For each component, we compute the GCD of all edge GCD values and check all divisors of this GCD to find a consistent assignment using BFS. If a valid assignment is found, it is printed; otherwise, \"NO\" is printed. This approach ensures that all constraints are satisfied efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom math import gcd\nfrom collections import deque\n\ndef input():\n    return sys.stdin.read()\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx+1])\n    idx += 2\n    edges = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u = int(data[idx])\n        v = int(data[idx+1])\n        g = int(data[idx+2])\n        l = int(data[idx+3])\n        edges[u].append( (v, g, l) )\n        edges[v].append( (u, g, l) )\n        idx +=4\n    \n    visited = [False] * (n+1)\n    possible = True\n    ans = [0]*(n+1)\n    \n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            component = []\n            edges_component = []\n            while q:\n                u = q.popleft()\n                component.append(u)\n                for (v, g, l) in edges[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                        edges_component.append( (u, v, g, l) )\n            D = 0\n            for (u, v, g, l) in edges_component:\n                D = gcd(D, g)\n            if D == 0:\n                D = 1\n            divisors = get_divisors(D)\n            found = False\n            for d in divisors:\n                valid = True\n                k = {}\n                for (u, v, g, l) in edges_component:\n                    product = (g * l) \n                    if d*d > product:\n                        valid = False\n                        break\n                    if product % (d*d) != 0:\n                        valid = False\n                        break\n                if not valid:\n                    continue\n                \n                k[i] = 1\n                q = deque()\n                q.append(i)\n                while q and valid:\n                    u = q.popleft()\n                    for (v, g, l) in edges[u]:\n                        if v == u:\n                            continue\n                        if v not in k:\n                            product = (g * l) // (d * d)\n                            if product % k[u] != 0:\n                                valid = False\n                                break\n                            candidate = product // k[u]\n                            if math.gcd(k[u], candidate) != (g // d):\n                                valid = False\n                                break\n                            k[v] = candidate\n                            q.append(v)\n                if valid:\n                    for node in component:\n                        ans[node] = d * k[node]\n                    found = True\n                    break\n            if not found:\n                possible = False\n                break\n    if possible:\n        print(\"YES\")\n        print(' '.join(map(str, ans[1:])))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1106,
        "thoughts_token_count": 8193
    }
}