{
    "start": 1758292039.0540023,
    "end": 1758292133.392117,
    "start-formatted": "2025-09-19 23:27 KST",
    "end-formatted": "2025-09-19 23:28 KST",
    "gpu": 2,
    "pid": 41,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Zoning Restrictions Again\n\nYou are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.\n\n## Input\nThe first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$) — the number of spots, the maximum height, and the number of restrictions.Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$) — left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.\n\n## Output\nPrint a single integer, the maximum profit you can make.\n\n## Example\n### Input\n['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n### Output\n['14', '262']\n\n## Note\nIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.tree = [[float('-inf')] * (n + 1) for _ in range(4)]\n        self.lazy = [0] * (n + 1)\n\n    def apply(self, idx, value):\n        self.tree[0][idx] += value\n        self.tree[1][idx] += 2 * value * idx\n        self.tree[2][idx] += value * idx ** 2\n        self.tree[3][idx] += value * idx\n\n    def push(self, idx):\n        if self.lazy[idx]:\n            self.apply(idx << 1, self.lazy[idx])\n            self.apply((idx << 1) | 1, self.lazy[idx])\n            self.lazy[idx] = 0\n\n    def merge(self, left, right):\n        result = [0] * 4\n        result[0] = max(left[0], right[0])\n        result[1] = max(left[1], right[1])\n        result[2] = max(left[2], right[2])\n        result[3] = max(left[3], right[3])\n        return result\n\n    def update_range(self, start, end, value):\n        self._update_range(1, 1, len(self.tree[0]) - 1, start, end, value)\n\n    def _update_range(self, node, node_start, node_end, start, end, value):\n        if start > node_end or end < node_start:\n            return\n        if start <= node_start and node_end <= end:\n            self.apply(node, value)\n            return\n        self.push(node)\n        mid = (node_start + node_end) // 2\n        self._update_range(node << 1, node_start, mid, start, end, value)\n        self._update_range((node << 1) | 1, mid + 1, node_end, start, end, value)\n        self.tree[node] = self.merge(self.tree[node << 1], self.tree[(node << 1) | 1])\n\n    def query(self, start, end):\n        return self._query(1, 1, len(self.tree[0]) - 1, start, end)\n\n\n    def _query(self, node, node_start, node_end, start, end):\n        if start > node_end or end < node_start:\n            return float('-inf'), float('-inf'), float('-inf'), float('-inf')\n        if start <= node_start and node_end <= end:\n            return tuple(self.tree[node])\n        self.push(node)\n        mid = (node_start + node_end) // 2\n        left = self._query(node << 1, node_start, mid, start, end)\n        right = self._query((node << 1) | 1, mid + 1, node_end, start, end)\n        return self.merge(left, right)\n\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    index = 0\n    def readline():\n        nonlocal index\n        line = input_lines[index]\n        index += 1\n        return line\n\n    n, h, m = map(int, readline().split())\n    restrictions = []\n    for _ in range(m):\n        l, r, x = map(int, readline().split())\n        restrictions.append((l - 1, r - 1, x))\n\n    st = SegmentTree(n)\n    for l, r, x in restrictions:\n        st.update_range(l, r, -x ** 2)\n\n    dp = [[-float('inf')] * (h + 1) for _ in range(n)]\n    for i in range(h + 1):\n        dp[0][i] = i ** 2\n\n    for i in range(1, n):\n        for j in range(h + 1):\n            for k in range(j, -1, -1):\n                val = dp[i - 1][k] + j ** 2\n                new_val = st.query(i, i)[3] + val\n                if new_val > dp[i][j]:\n                    dp[i][j] = new_val\n\n    ans = 0\n    for i in range(h + 1):\n        ans = max(ans, dp[n - 1][i])\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nThis code reads the input from standard input, processes it, and prints the maximum profit to standard output. The code uses a segment tree to efficiently handle the updates and queries related to the zoning restrictions. The dynamic programming approach is used to find the maximum profit by considering all possible heights of houses at each spot.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.tree = [[float('-inf')] * (n + 1) for _ in range(4)]\n        self.lazy = [0] * (n + 1)\n\n    def apply(self, idx, value):\n        self.tree[0][idx] += value\n        self.tree[1][idx] += 2 * value * idx\n        self.tree[2][idx] += value * idx ** 2\n        self.tree[3][idx] += value * idx\n\n    def push(self, idx):\n        if self.lazy[idx]:\n            self.apply(idx << 1, self.lazy[idx])\n            self.apply((idx << 1) | 1, self.lazy[idx])\n            self.lazy[idx] = 0\n\n    def merge(self, left, right):\n        result = [0] * 4\n        result[0] = max(left[0], right[0])\n        result[1] = max(left[1], right[1])\n        result[2] = max(left[2], right[2])\n        result[3] = max(left[3], right[3])\n        return result\n\n    def update_range(self, start, end, value):\n        self._update_range(1, 1, len(self.tree[0]) - 1, start, end, value)\n\n    def _update_range(self, node, node_start, node_end, start, end, value):\n        if start > node_end or end < node_start:\n            return\n        if start <= node_start and node_end <= end:\n            self.apply(node, value)\n            return\n        self.push(node)\n        mid = (node_start + node_end) // 2\n        self._update_range(node << 1, node_start, mid, start, end, value)\n        self._update_range((node << 1) | 1, mid + 1, node_end, start, end, value)\n        self.tree[node] = self.merge(self.tree[node << 1], self.tree[(node << 1) | 1])\n\n    def query(self, start, end):\n        return self._query(1, 1, len(self.tree[0]) - 1, start, end)\n\n\n    def _query(self, node, node_start, node_end, start, end):\n        if start > node_end or end < node_start:\n            return float('-inf'), float('-inf'), float('-inf'), float('-inf')\n        if start <= node_start and node_end <= end:\n            return tuple(self.tree[node])\n        self.push(node)\n        mid = (node_start + node_end) // 2\n        left = self._query(node << 1, node_start, mid, start, end)\n        right = self._query((node << 1) | 1, mid + 1, node_end, start, end)\n        return self.merge(left, right)\n\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    index = 0\n    def readline():\n        nonlocal index\n        line = input_lines[index]\n        index += 1\n        return line\n\n    n, h, m = map(int, readline().split())\n    restrictions = []\n    for _ in range(m):\n        l, r, x = map(int, readline().split())\n        restrictions.append((l - 1, r - 1, x))\n\n    st = SegmentTree(n)\n    for l, r, x in restrictions:\n        st.update_range(l, r, -x ** 2)\n\n    dp = [[-float('inf')] * (h + 1) for _ in range(n)]\n    for i in range(h + 1):\n        dp[0][i] = i ** 2\n\n    for i in range(1, n):\n        for j in range(h + 1):\n            for k in range(j, -1, -1):\n                val = dp[i - 1][k] + j ** 2\n                new_val = st.query(i, i)[3] + val\n                if new_val > dp[i][j]:\n                    dp[i][j] = new_val\n\n    ans = 0\n    for i in range(h + 1):\n        ans = max(ans, dp[n - 1][i])\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 842,
        "completion_token_count": 996,
        "thoughts_token_count": 0
    }
}