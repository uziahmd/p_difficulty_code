{
    "start": 1758282348.835267,
    "end": 1758284247.8008635,
    "start-formatted": "2025-09-19 20:45 KST",
    "end-formatted": "2025-09-19 21:17 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about finding the smallest non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. If there are multiple k's that give the same minimal LCM, we choose the smallest k.\n\nHmm, let's think about this. The LCM of two numbers is equal to (product of the two numbers) divided by their greatest common divisor (GCD). So, LCM(x, y) = x*y / GCD(x, y). \n\nWait, but in our case, both numbers are a +k and b +k. Let's denote d = GCD(a, b). Then, since a and b can be written as a = d * m and b = d * n, where m and n are coprime (their GCD is 1). \n\nSo when we add k to both, a +k = d*m +k and b +k = d*n +k. Let's factor this: d*(m) +k = k + d*m, and similarly for the other term. Let me think about the GCD of these two terms.\n\nWait, what's the GCD of (a +k) and (b +k)? Let's compute GCD(a +k, b +k). Since a +k - (b +k) = a - b. So the GCD of (a +k) and (b +k) is the same as GCD(d*m +k, d*n +k). Hmm, maybe I can find a way to express this.\n\nAlternatively, since a and b have a GCD of d, their difference is d*(m -n), assuming m > n without loss of generality. But I'm not sure if that helps directly.\n\nWait, another approach: Let's consider the expression (a +k) and (b +k). Their difference is a - b. So, GCD(a +k, b +k) = GCD(a - b, a +k). Because GCD(x, y) = GCD(x, y - x) when y > x. So here, since (a +k) and (b +k) differ by (a - b), the GCD is the same as GCD(a +k, |a - b|).\n\nWait, that's an interesting point. So GCD(a +k, b +k) = GCD(a +k, |a - b|). Let's denote g = GCD(a +k, |a -b|). Then, the LCM of (a +k) and (b +k) is (a +k)*(b +k)/g. \n\nBut how does this help us find the optimal k?\n\nAlternatively, perhaps it's better to think in terms of the difference between a and b. Let me assume that a >= b. So, a = b + d, where d is some positive integer.\n\nWait, no. Because a and b could be in any order. So, perhaps let me set s = a - b. Wait, but s could be negative. Maybe it's better to compute the absolute difference. Let me denote delta = |a - b|. So, delta is a non-negative integer.\n\nSo, the key observation might be that the optimal k is related to delta. Because, for any k, the two terms a +k and b +k will have a difference of delta. So, their GCD depends on delta and k.\n\nWait, perhaps the minimal LCM occurs when the GCD is as large as possible, because the LCM is (x * y) / gcd(x,y). So, to minimize the LCM, we need to maximize the GCD.\n\nSo, the strategy is to maximize the GCD of (a +k) and (b +k), which is the same as GCD(a +k, delta). Because, as before, GCD(a +k, b +k) = GCD(a +k, (a +k) - (b +k)) = GCD(a +k, delta).\n\nTherefore, the maximum possible GCD is the maximum divisor of delta that divides a +k. So, to maximize the GCD, we should choose k such that a +k is divisible by as large a divisor of delta as possible.\n\nWait, but how do we find the optimal k? Let's think about it step by step.\n\nLet me suppose that delta is zero. Then, a = b. So, the LCM is a +k, which is minimized when k is zero. So, in this case, output 0.\n\nIf delta is non-zero, then the problem becomes more interesting.\n\nSo, for delta != 0, the idea is to find a k such that a +k is divisible by a large divisor of delta. Because that would make the GCD as large as possible, thus minimizing the LCM.\n\nSo, the plan is:\n\n1. Compute delta = |a - b|. If delta is zero, return k=0.\n\n2. Otherwise, find all the divisors of delta. For each divisor g, find the smallest k such that (a +k) mod g == 0 and (b +k) mod g == 0. Wait, but wait: since (a +k) mod g == 0 implies (b +k) mod g == 0? Because (b +k) = (a +k) - (a - b) = (a +k) - delta. So, since g divides delta, (a +k) mod g == 0 implies that (delta) mod g == 0. So, (b +k) = (a +k) - delta. Since (a +k) is divisible by g, and delta is also divisible by g, then (b +k) mod g is (a +k mod g) minus (delta mod g) which is 0 - 0 = 0. So yes, both are divisible by g.\n\n3. So, for each divisor g of delta, we can compute the required k as (g - (a mod g)) mod g. Because a +k must be divisible by g. So k = (g - (a mod g)) % g. Because if a mod g is zero, then k is zero; otherwise, k is g - (a mod g). But wait, this is only if (a +k) is divisible by g. But since delta is a multiple of g, (b +k) will also be divisible by g.\n\n4. Once we have all possible k's corresponding to each divisor g of delta, we can compute the LCM for each k and choose the one with the smallest LCM. If there are ties, choose the smallest k.\n\nBut wait, that might not be efficient because the number of divisors of delta can be up to O(sqrt(delta)), which for delta up to 1e9 is manageable.\n\nBut wait, perhaps the optimal g is the largest possible. Because larger g leads to higher GCD, which could lead to smaller LCM.\n\nBut is that always the case? Let's see.\n\nSuppose delta has a divisor g1 and another divisor g2 where g1 > g2. We want to see whether choosing g1 gives a better (smaller) LCM than g2.\n\nThe LCM is (a +k) * (b +k) / g.\n\nSince a +k is divisible by g1, and b +k is also divisible by g1, the LCM is (a +k) * (b +k) / g1.\n\nSimilarly, for g2, it's (a +k') * (b +k') / g2.\n\nWe need to compare these two.\n\nBut a +k' is a multiple of g2, but may not be a multiple of g1 unless g1 is a multiple of g2. So, which one is larger is unclear.\n\nSo, perhaps the maximum g is the best, but perhaps not necessarily.\n\nWait, but maybe considering that for a fixed g, the minimal k is determined, but the LCM could vary.\n\nBut given that the LCM is (x * y) / g, where x = a +k and y = b +k, and g is the GCD, perhaps the minimal LCM occurs when g is as large as possible, but even then, the product x*y may vary.\n\nWait, but the product x*y is equal to (a +k)(b +k) = ab + (a + b)k + kÂ².\n\nNot sure if that helps.\n\nAlternatively, perhaps the minimal LCM is achieved when the GCD is as large as possible. Because, for a given product x*y, the LCM is minimized when the GCD is maximized.\n\nBecause LCM(x, y) = x*y / GCD(x, y). So, for fixed x*y, a larger GCD would lead to a smaller LCM.\n\nBut in our case, for each g, x and y are multiples of g, so x = g * x', y = g * y', and GCD(x, y) = g * GCD(x', y'). So, the minimal LCM is achieved when GCD(x', y') is as small as possible. Which would happen when x' and y' are coprime.\n\nBut in this problem, since x' = (a +k)/g and y' = (b +k)/g, and x' and y' are integers, their GCD is at least 1. So, the minimal possible is 1.\n\nWait, but perhaps the minimal LCM is achieved when the GCD is as large as possible, because that reduces the LCM.\n\nWait, perhaps the strategy is to find the largest possible g (divisor of delta) such that (a +k) and (b +k) are multiples of g, and among those, find the one that leads to the minimal LCM.\n\nBut how to find which g gives the minimal LCM.\n\nAlternatively, perhaps the minimal LCM is achieved when g is as large as possible. But I'm not sure.\n\nSo, perhaps the approach is to:\n\n- Enumerate all possible divisors of delta.\n\n- For each divisor g, compute the minimal k that makes (a +k) divisible by g. Then compute the LCM for that k, and track the minimal LCM and the corresponding k.\n\n- Additionally, we need to consider the case when g is zero, which is when delta is zero, but that's already handled.\n\nWait, but what about the case when the delta is 0? That's when a = b, so the LCM is a +k, which is minimized when k is zero.\n\nSo, steps:\n\n1. Compute delta = |a - b|.\n\n   - If delta is zero, return k = 0.\n\n2. Else, find all the divisors of delta.\n\n3. For each divisor g of delta, compute the minimal k such that (a +k) is divisible by g.\n\n   - k = (g - (a % g)) % g\n\n4. For each such k, compute the LCM of (a +k) and (b +k).\n\n5. Among all these k's, find the one with the smallest LCM. If there are multiple k's with the same minimal LCM, choose the smallest k.\n\nBut wait, is that all the possible candidates? Or are there other possible k's that could lead to a better LCM?\n\nFor example, perhaps k is not making (a +k) divisible by any of the divisors of delta, but leads to a higher GCD than any of the considered g's.\n\nWait, but the GCD(a +k, b +k) is always a divisor of delta. So, any g that is a divisor of delta is a candidate. Because the GCD can't be larger than delta.\n\nWait, no. The GCD of (a +k) and (b +k) is a divisor of delta, but it can be any divisor. So, to cover all possibilities, we need to consider all divisors of delta.\n\nSo, for each divisor g of delta, the minimal k that makes (a +k) divisible by g is a candidate. Then, for each such k, compute the LCM.\n\nBut wait, what if a +k is divisible by a larger g than any divisor of delta? No, because the GCD is a divisor of delta, and the maximum possible is delta itself.\n\nWait, delta is the maximum possible GCD, because (a +k) - (b +k) = a - b = delta or -delta, so their GCD can't be larger than delta.\n\nSo, the maximum possible GCD is delta. So, for each possible divisor g of delta, including delta, we compute the k that makes (a +k) divisible by g, and then compute the LCM.\n\nSo, the steps are:\n\nCompute all the divisors of delta.\n\nFor each g in divisors, compute k_g = (g - (a mod g)) % g.\n\nThen, compute the LCM for (a +k_g) and (b +k_g).\n\nFind the g that gives the minimal LCM, and among those, the smallest k_g.\n\nAdditionally, we need to include the case where k is zero. Because sometimes, the initial a and b may have a certain GCD which is a divisor of delta, but adding zero may not give the minimal LCM.\n\nWait, but when delta is not zero, then when k is zero, the GCD is GCD(a, b) = d. So, for example, if a is 6 and b is 10, delta is 4. The GCD is 2. So, for k=2, a+k is 8, b +k is 12. GCD(8, 12) is 4, which is a divisor of 4 (delta is 4). So, that's one of the candidates.\n\nWait, in the sample input, 6 and 10: delta is 4. The divisors of 4 are 1, 2, 4.\n\nSo, for each g in {1, 2, 4}:\n\ng=1:\n\nk = (1 - 6%1) mod 1 = (1-0) mod 1 = 0. So, a+0=6, b+0=10. LCM is 30.\n\ng=2:\n\nk = (2 - 6%2) mod 2 = (2-0) mod 2 = 0. So, a+0=6, b+0=10. Same as above.\n\nWait, that's not right. Wait, wait, perhaps I made a mistake here.\n\nWait, for g=2:\n\na mod 2 is 0, so k = (2 - 0) mod 2 is 0.\n\nSo, a +k =6, b +k =10. Their GCD is 2, which is correct.\n\nSo, the LCM is (6*10)/2=30.\n\ng=4:\n\na mod 4 is 6 mod4=2. So, k= (4-2)=2.\n\na+2=8, b+2=12. GCD is 4, so LCM is (8*12)/4=24.\n\nWhich is better. So, the minimal LCM is 24, achieved at k=2.\n\nSo, in this case, the algorithm correctly finds that.\n\nAnother example: when a=5, b=10.\n\ndelta is 5. Divisors are 1,5.\n\nFor g=1:\n\nk= (1 -5%1) mod 1 =0. a=5, b=10. LCM 10.\n\ng=5:\n\na mod5=0, so k=0. a=5, b=10. LCM is 10.\n\nSo, both g=1 and g=5 give the same LCM. So, the minimal is 10. But since the LCM is the same, we choose the smallest k, which is 0.\n\nWhich matches the sample.\n\nAnother test case: a=21, b=31. delta=10.\n\nDivisors of 10 are 1,2,5,10.\n\nFor each g:\n\ng=1: k=0. a=21, b=31. LCM is 21*31=651.\n\ng=2: 21 mod2=1. k=2-1=1. a=22, b=32. LCM=(22*32)/2= 352.\n\ng=5: 21 mod5=1. k=5-1=4. a=25, b=35. LCM= (25*35)/5=175.\n\ng=10: 21 mod10=1. k=10-1=9. a=30, b=40. LCM= 1200/10= 120.\n\nSo the minimal is 120, achieved at k=9.\n\nWhich matches the sample.\n\nSo, the approach seems to work.\n\nBut wait, what about cases where delta is not the maximum possible GCD?\n\nWait, for example, let a=4, b=6. delta=2.\n\nDivisors are 1,2.\n\ng=1: k=0. LCM= (4*6)/2=12.\n\ng=2: a mod2=0, k=0. LCM=12.\n\nSo, both options give same LCM. So, choose k=0.\n\nBut wait, is there a k that could give a lower LCM? Let's see:\n\nWhat about k=2? a+2=6, b+2=8. LCM is 24, which is larger.\n\nk=1: a+1=5, b+1=7. LCM is 35.\n\nSo, indeed, the initial approach works.\n\nAnother example: a=3, b=6. delta=3.\n\nDivisors: 1,3.\n\ng=1: k=0. a=3, b=6. LCM is 6.\n\ng=3: a mod3=0, k=0. LCM is 6.\n\nSo, same result.\n\nBut what if a=8, b=15. delta=7.\n\nDivisors of 7: 1,7.\n\ng=1: k=0. a=8, b=15. LCM= 120.\n\ng=7: a mod7=1. k=7-1=6. a+6=14, b+6=21. GCD is 7, so LCM is 14*21 /7=42.\n\nWhich is better.\n\nSo, the approach works.\n\nSo, the plan is:\n\n- Compute delta = |a - b|.\n\n- If delta is zero, return 0.\n\n- Else, find all the divisors of delta.\n\n- For each divisor g, compute k_g = (g - (a mod g)) mod g.\n\n- Compute the LCM for (a +k_g) and (b +k_g).\n\n- Find the minimal LCM, and among those, the minimal k.\n\nAdditionally, we need to consider the possibility that k can be chosen such that (a +k) and (b +k) are 0. But wait, since a and b are positive integers, adding k can't make them zero unless a and b are zero, which they are not.\n\nSo, that's not an issue.\n\nNow, the problem is to implement this.\n\nSo, first, I need a function to find all the divisors of a given number delta.\n\nHow to find all the divisors efficiently?\n\nAn efficient way is to iterate up to sqrt(delta), and for each i that divides delta, add i and delta/i to the list of divisors. Also, handle the case when delta is a square.\n\nBut for delta up to 1e9, this is manageable.\n\nSo, the steps are:\n\nImplement a function get_divisors(n) that returns all divisors of n, sorted in increasing order.\n\nOnce we have all the divisors, process each one.\n\nBut wait, in code, for a given delta, the function would generate all possible divisors.\n\nNow, after generating all divisors, for each g, compute k.\n\nOnce all k's are computed, compute the LCM for each, and select the minimal.\n\nBut wait, what about the case when the minimal k is not among these? For example, perhaps choosing a k that doesn't align with any divisor of delta could give a better result.\n\nBut earlier reasoning suggests that the GCD is a divisor of delta, so all possible k's that affect the GCD are covered by the divisors of delta.\n\nWait, but suppose that delta is 6, and a is 7.\n\nSo, delta = |7 - ...|, say, a=7, b=1, delta=6.\n\nSo, for g=2, which is a divisor of 6.\n\nk = (2 -7 mod 2) mod2.\n\n7 mod2 is 1. So, 2-1=1 mod2 is 1.\n\nSo, k=1.\n\nThen, a +k =8, b +k=2.\n\nTheir GCD is 2, which is a divisor of 6.\n\nSo, the approach includes all possible g's.\n\nSo, I think that all possible candidates are covered.\n\nThus, the plan is solid.\n\nNow, implementing this.\n\nFirst, the function to find all divisors.\n\nIn Python:\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n//i)\n    return sorted(divisors)\n\nWait, but for n=0, this would cause issues. But in our case, delta is non-zero, so n is at least 1.\n\nSo, that's okay.\n\nNow, for each a and b, compute delta.\n\nIf delta is zero, output 0.\n\nElse, compute all divisors of delta.\n\nFor each divisor g, compute k = (g - (a %g)) %g.\n\nThen, compute (a +k) and (b +k), compute their GCD, then compute LCM as (a +k)*(b +k) // GCD.\n\nWait, but wait: the GCD is the same as the GCD of (a +k) and delta. Because, as before, GCD(a +k, b +k) = GCD(a +k, delta).\n\nBut in code, perhaps it's better to compute it as math.gcd(a_plus_k, b_plus_k), but for large numbers, that's acceptable.\n\nBut for very large a and b, like 1e9, adding k could still be 1e9, and computing GCD is manageable.\n\nSo, in code:\n\nimport math\n\nCompute delta = abs(a - b)\n\nif delta ==0:\n    print(0)\nelse:\n    divisors = get_divisors(delta)\n    min_lcm = infinity\n    best_k = None\n    for g in divisors:\n        a_mod_g = a % g\n        k = (g - a_mod_g) % g\n        a_plus_k = a + k\n        b_plus_k = b + k\n        current_gcd = math.gcd(a_plus_k, b_plus_k)\n        current_lcm = (a_plus_k * b_plus_k) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    # Now, check if best_k is the minimal possible.\n    # But wait, could there be a k that's not generated by any of the divisors?\n    # No, because for any k, the GCD is a divisor of delta, so it's covered.\n\n    # Also, need to compare with the case when k is not from any of the divisors.\n\n    # Wait, but no, because any k that produces a higher GCD than any of the divisors would imply that the GCD is a larger divisor than delta, which is impossible.\n\n    # So, the minimal is found among the generated candidates.\n\n    print(best_k)\n\nWait, but in the sample input:\n\nCase 1: a=6, b=10. delta=4.\n\ndivisors are 1,2,4.\n\nfor g=4: k= (4-6%4) mod4. 6 mod4 is 2. 4-2=2 mod4=2. So, k=2.\n\nWhich is correct.\n\nAnother case: a=21, b=31. delta=10.\n\ndivisors are 1,2,5,10.\n\ng=10: k=10 -21 mod10=10-1=9 mod10=9.\n\nWhich is correct.\n\nBut what about the case when delta is 1?\n\nSay a=5, b=6. delta=1.\n\ndivisors are 1.\n\ng=1: k= (1 -5%1) mod1=0.\n\nSo, a_plus_k=5, b_plus_k=6.\n\nLCM is 30.\n\nBut is there a better k?\n\nWhat if k=1: a+1=6, b+1=7. LCM is 42>30.\n\nk=2: a+2=7, b+2=8. LCM 56.\n\nNo, so the initial approach is correct.\n\nAnother test case: a=2, b=4. delta=2.\n\ndivisors:1,2.\n\ng=1: k=0. a=2, b=4. LCM=4.\n\ng=2: k= (2 -2%2) mod2=0. a=2, b=4. LCM=4.\n\nSo, same result. Choose k=0.\n\nWhich is correct.\n\nSo, the code seems to handle all cases.\n\nWait, but what about when a=3, b=5. delta=2.\n\ndivisors are 1,2.\n\ng=1: k=0. a=3, b=5. LCM=15.\n\ng=2: 3 mod2=1. k= (2-1)=1 mod2=1.\n\na+1=4, b+1=6. GCD is 2. LCM is 12.\n\nWhich is better.\n\nSo code correctly selects k=1.\n\nAnother test: a=8, b=11. delta=3.\n\ndivisors:1,3.\n\ng=3: a mod3=8 mod3=2. k= (3-2)=1 mod3=1.\n\na+1=9, b+1=12. GCD is 3. LCM is (9*12)/3=36.\n\ng=1: k=0. LCM is 8*11=88.\n\nSo 36 is better.\n\nSo, code selects k=1.\n\nYes.\n\nSo, the code seems correct.\n\nBut now, what about the case when delta is zero? Like a=5, b=5. Then, delta is zero, and we output 0.\n\nWhich is correct.\n\nAnother edge case: a=1, b=1e9. delta=999999999.\n\ndivisors include 1 and 999999999.\n\nBut processing all the divisors may take some time. However, for 1e9, the number of divisors is manageable.\n\nWait, what about a=1e9, b=2e9. delta=1e9.\n\nThe number of divisors is 101 (since 1e9 = 2^9 *5^9, so number of divisors is (9+1)*(9+1) = 100).\n\nSo, it's manageable.\n\nSo, the code should be efficient enough.\n\nAnother consideration: when delta is a perfect square.\n\nFor example, delta=16, the divisors would include 1,2,4,8,16.\n\nSo, the code handles that.\n\nNow, the code in Python.\n\nImplement the get_divisors function.\n\nBut wait, in Python, the function needs to handle n=0, but in our case, delta is non-zero, so n is at least 1.\n\nNow, code:\n\nRead a and b.\n\nCompute delta.\n\nIf delta is zero: print 0.\n\nElse:\n\nCompute all divisors.\n\nFor each g in divisors:\n\ncompute a mod g.\n\nk = (g - (a mod g)) %g.\n\nCompute a_plus_k and b_plus_k.\n\nCompute current_gcd = math.gcd(a_plus_k, b_plus_k).\n\ncurrent_lcm = (a_plus_k * b_plus_k) // current_gcd.\n\nCompare to find the minimal lcm, and minimal k.\n\nWait, but what about the case where the same k is generated for different g's?\n\nLike, when two different g's produce the same k.\n\nBut in that case, the LCM could be the same or different.\n\nBut the code compares each possible k and keeps the best.\n\nNow, the code:\n\nImplement the helper function.\n\nBut wait, the function 'get_divisors' should return all the divisors, including 1 and delta.\n\nNow, in code:\n\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) +1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n//i)\n    return sorted(divisors)\n\nThen, read a and b.\n\na, b = map(int, input().split())\n\ndelta = abs(a - b)\n\nif delta ==0:\n    print(0)\nelse:\n    divisors = get_divisors(delta)\n    min_lcm = float('inf')\n    best_k = None\n    for g in divisors:\n        a_mod = a % g\n        k = (g - a_mod) % g\n        a_plus = a +k\n        b_plus = b +k\n        current_gcd = math.gcd(a_plus, b_plus)\n        current_lcm = (a_plus * b_plus) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    print(best_k)\n\nWait, but wait, what about when delta is 1?\n\nFor example, a=1, b=2.\n\ndelta=1.\n\ndivisors: 1.\n\ng=1:\n\na mod1=0.\n\nk= (1-0) mod1=0.\n\na_plus=1, b_plus=2. LCM is 2.\n\nWhich is correct.\n\nBut what if k=1?\n\na+1=2, b+1=3. LCM is 6>2. So, no better.\n\nThus, the code is correct.\n\nAnother test case: a=3, b=5.\n\ndelta=2.\n\ndivisors: 1, 2.\n\ng=1: k=0. LCM=15.\n\ng=2: a mod2=1. k=1. a+1=4, b+1=6. GCD=2. LCM= (4*6)/2=12.\n\nSo, code picks k=1.\n\nWhich is correct.\n\nAnother case: a=4, b=7. delta=3.\n\ndivisors:1,3.\n\ng=3:\n\na mod3=1. k=3-1=2.\n\na_plus=6, b_plus=9. GCD=3. LCM=18.\n\ng=1:\n\nk=0. a=4, b=7. LCM=28.\n\nSo, code picks k=2.\n\nWhich is correct.\n\nSo, the code should work.\n\nTesting the sample inputs:\n\nSample Input 1: 6 10 â Output 2.\n\nAs discussed.\n\nSample Input 2: 21 31 â Output 9.\n\nAs discussed.\n\nSample Input 3:5 10 â Output 0.\n\nYes.\n\nAnother test case: a=8, b=11. delta=3.\n\ndivisors:1,3.\n\ng=3: a mod3=2. k=1.\n\na+1=9, b+1=12. LCM=36.\n\ng=1: k=0. a=8, b=11. LCM=88.\n\nSo, code chooses k=1.\n\nThus, code works.\n\nSo, the final code is as written.\n",
    "response": "To solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**:\n   - The goal is to minimize the LCM of two numbers formed by adding \\( k \\) to both \\( a \\) and \\( b \\).\n   - The LCM of two numbers can be minimized by maximizing their greatest common divisor (GCD). Therefore, we need to find \\( k \\) such that the GCD of \\( a + k \\) and \\( b + k \\) is as large as possible.\n\n2. **Key Insight**:\n   - The difference between \\( a \\) and \\( b \\) (denoted as \\( \\delta \\)) is crucial. The GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of \\( \\delta \\).\n   - By finding all divisors of \\( \\delta \\), we can determine potential values of \\( k \\) that maximize the GCD of \\( a + k \\) and \\( b + k \\).\n\n3. **Algorithm**:\n   - Compute \\( \\delta = |a - b| \\).\n   - If \\( \\delta \\) is zero, return \\( k = 0 \\) since \\( a \\) and \\( b \\) are equal.\n   - Generate all divisors of \\( \\delta \\).\n   - For each divisor \\( g \\), compute the smallest \\( k \\) such that \\( a + k \\) is divisible by \\( g \\).\n   - Calculate the LCM for each candidate \\( k \\) and track the minimum LCM and the corresponding \\( k \\).\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\na, b = map(int, input().split())\ndelta = abs(a - b)\n\nif delta == 0:\n    print(0)\nelse:\n    divisors = get_divisors(delta)\n    min_lcm = float('inf')\n    best_k = None\n    for g in divisors:\n        a_mod = a % g\n        k = (g - a_mod) % g\n        a_plus = a + k\n        b_plus = b + k\n        current_gcd = math.gcd(a_plus, b_plus)\n        current_lcm = (a_plus * b_plus) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    print(best_k)\n```\n\n### Explanation\n- **Divisor Calculation**: The function `get_divisors` efficiently computes all divisors of a given number \\( n \\) by iterating up to the square root of \\( n \\) and adding both the divisor and its complement.\n- **Delta Handling**: If \\( a \\) and \\( b \\) are equal, \\( \\delta \\) is zero, and we immediately return \\( k = 0 \\).\n- **Optimal \\( k \\) Calculation**: For each divisor \\( g \\) of \\( \\delta \\), compute the smallest \\( k \\) such that \\( a + k \\) is divisible by \\( g \\). This \\( k \\) is derived from \\( (g - (a \\% g)) \\% g \\).\n- **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\) and track the minimum LCM and the corresponding \\( k \\).\n\nThis approach ensures that we efficiently find the optimal \\( k \\) by leveraging the properties of divisors and the relationship between LCM and GCD.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\na, b = map(int, input().split())\ndelta = abs(a - b)\n\nif delta == 0:\n    print(0)\nelse:\n    divisors = get_divisors(delta)\n    min_lcm = float('inf')\n    best_k = None\n    for g in divisors:\n        a_mod = a % g\n        k = (g - a_mod) % g\n        a_plus = a + k\n        b_plus = b + k\n        current_gcd = math.gcd(a_plus, b_plus)\n        current_lcm = (a_plus * b_plus) // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    print(best_k)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 392,
        "completion_token_count": 863,
        "thoughts_token_count": 6912
    }
}