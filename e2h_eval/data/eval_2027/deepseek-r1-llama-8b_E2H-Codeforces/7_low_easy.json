{
    "start": 1758103646.8617969,
    "end": 1758103759.720239,
    "start-formatted": "2025-09-17 19:07 KST",
    "end-formatted": "2025-09-17 19:09 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about determining whether a certain number of vertices n can form a snowflake graph as defined by Rudolf. The snowflake graph has specific construction rules. \n\nHmm, let me try to understand the structure. So initially, there's one vertex. Then, we add k new vertices connected to it, where k is greater than 1. Then, for each vertex that has only one edge (the leaves), we connect each to k new vertices. And importantly, this last step must be done at least once.\n\nSo the snowflake graph grows in layers. The first layer is the root with degree k. Each subsequent layer adds more nodes, each branching into k children.\n\nWait, maybe it's better to model this mathematically. Let's think about how the total number of vertices grows.\n\nLet me consider the process step by step. \n\nThe initial step has 1 node.\n\nStep 1: Add k children to the root. Total nodes = 1 + k.\n\nStep 2: For each of those k nodes (since they are leaves), add k children each. So each adds k, leading to k*k nodes. So total becomes 1 + k + k^2.\n\nBut wait, the problem says that each step where a node has only one edge (a leaf) must add k children, and this step must be done at least once. So the minimal case is when after adding the first layer, you perform another step.\n\nWait, perhaps I should model the snowflake as a tree. It seems like the structure is a rooted tree where each non-leaf node has exactly k children. So it's a k-ary tree of some depth.\n\nWait, but the initial steps are:\n\n- Level 0: 1 node.\n\n- Level 1: k nodes added, connected to level 0.\n\nTotal nodes so far: 1 + k.\n\nThen, for each node in level 1, add k children each. That adds k^2 nodes. Now total is 1 +k +k².\n\nBut the problem says that this step must be done at least once. Wait, no—the initial step is adding the first layer, then each leaf (those k nodes) must each add k children. So the minimal structure is when after the initial step, we do the expansion once. So the minimal snowflake has levels 0, 1, 2: 1 +k +k² nodes.\n\nAlternatively, perhaps the process is such that the initial step is adding the first layer (k nodes). Then, each node that was just added (the leaves) must add their own k children. So the minimal structure is two expansions beyond the initial node.\n\nWait, no. Let's re-examine the problem statement:\n\n\"Initially, the graph has only one vertex. Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices (k>1). Each vertex that is connected by only one edge is connected by edges to k new vertices. This step should be done at least once.\"\n\nAh, okay. So the initial step is adding k children to the root. Then, any vertex that is a leaf (degree 1) must undergo this process again, adding k children. And this step must be done at least once.\n\nSo the initial step is level 1. Then, each leaf (level 1 nodes) must have their own children. So the minimal case is that after the initial step, we perform this expansion on all leaves at least once.\n\nSo the minimal snowflake has levels 0 (root), 1, and 2. So the total nodes are 1 +k +k².\n\nWait, but what if after adding the first layer, we don't add any more? No, because the problem states that the step of adding to leaves must be done at least once. So the minimal case is 1 +k +k².\n\nSo for example, in the sample input, when n=6, the output is YES. Let's see: 6-1=5. So 5 must equal k*(1 +k). Because 1 +k +k² =6 → 1 +k +k²=6 → k² +k -5=0. Solving this gives k=( -1 + sqrt(21))/2 ≈ 2. something. But since k must be an integer >1, let's see possible values.\n\nWait, maybe I'm approaching this wrong. Let's think about the formula for n.\n\nEach time we perform an expansion, every current leaf adds k children. So the total number of nodes can be represented as a sum.\n\nLet me model the total nodes after m expansions.\n\nWait, the initial step is 1 node. Then, each expansion adds a layer.\n\nWait, the initial step is adding the first layer: 1 +k nodes.\n\nEach subsequent expansion adds a",
    "response": "To solve this problem, we need to determine if a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph has a specific structure where each node (except the root) branches into exactly \\( k \\) new nodes, and this branching must occur at least once beyond the initial setup.\n\n### Approach\n1. **Problem Analysis**: The snowflake graph is constructed in layers. The root is the first layer, followed by its \\( k \\) children as the second layer. Each subsequent layer adds \\( k \\) children to every leaf node from the previous layer.\n2. **Mathematical Insight**: The total number of nodes in a snowflake graph after \\( m \\) expansions can be represented as \\( 1 + k + k^2 + ... + k^m \\). This is a geometric series sum which can be simplified.\n3. **Check for Valid Snowflake**: For a given \\( n \\), we need to check if it fits the form \\( 1 + k(1 + k + k^2 + ... + k^{m}) \\) for some \\( k > 1 \\) and \\( m \\geq 1 \\).\n\n### Solution Code\n```python\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # We need to find if n - 1 can be expressed as k * (1 + k + ... +k^m)\n    # Let s = 1 + k + ... +k^m = (k^(m+1) - 1)/(k-1)\n    # So n-1 = k*s => (n-1) = k * (k^(m+1)-1)/(k-1)\n    # We can try possible values of k starting from 2 up to cube root of (n-1)\n    max_k = int((n-1)**(1/3)) + 2\n    for k in range(2, max_k + 1):\n        s = (k ** (m+1) - 1) // (k - 1)\n        if (n-1) % k != 0:\n            continue\n        total = k * s\n        if total == n-1:\n            return True\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    for i in range(1, t+1):\n        n = int(input[i])\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into individual test cases.\n2. **Checking Each Test Case**: For each \\( n \\), we check if it can be expressed in the form required for a snowflake graph.\n3. **Mathematical Check**: For each potential \\( k \\), we compute the sum of the geometric series and check if it matches the required structure.\n4. **Output Result**: Based on the check, we output \"YES\" or \"NO\" for each test case.\n\nThis approach efficiently narrows down the possible values of \\( k \\) and checks each possibility using mathematical properties of geometric series, ensuring the solution is both correct and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # We need to find if n - 1 can be expressed as k * (1 + k + ... +k^m)\n    # Let s = 1 + k + ... +k^m = (k^(m+1) - 1)/(k-1)\n    # So n-1 = k*s => (n-1) = k * (k^(m+1)-1)/(k-1)\n    # We can try possible values of k starting from 2 up to cube root of (n-1)\n    max_k = int((n-1)**(1/3)) + 2\n    for k in range(2, max_k + 1):\n        s = (k ** (m+1) - 1) // (k - 1)\n        if (n-1) % k != 0:\n            continue\n        total = k * s\n        if total == n-1:\n            return True\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    for i in range(1, t+1):\n        n = int(input[i])\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 534,
        "completion_token_count": 702,
        "thoughts_token_count": 1025
    }
}