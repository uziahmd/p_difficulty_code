{
    "start": 1758278116.559284,
    "end": 1758278328.921661,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 41,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Zoning Restrictions Again\n\nYou are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.\n\n## Input\nThe first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$) — the number of spots, the maximum height, and the number of restrictions.Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$) — left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.\n\n## Output\nPrint a single integer, the maximum profit you can make.\n\n## Example\n### Input\n['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n### Output\n['14', '262']\n\n## Note\nIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about building houses on a street with certain restrictions and maximizing the profit. Each house can be built on a spot, and each spot has a height between 0 and h. The profit for each spot is the square of its height. But there are m restrictions that limit the maximum height in specific ranges of spots. My goal is to find the maximum possible total profit while satisfying all these restrictions.\n\nHmm, the constraints are small: n, h, m are up to 50. So maybe a brute-force approach is feasible here. Because even 50 spots, each with 50 options (heights), that's 50^50 possibilities, which is way too big. Wait, no, that's way beyond anything. So I need a smarter approach.\n\nWait, but n is 50, and for each spot, the choices are limited by the restrictions. So perhaps we can model this as a graph problem where each spot's height is a variable, and the constraints are based on the restrictions.\n\nAlternatively, think of this as an optimization problem with constraints. Since the variables are the heights of each spot, and the objective is to maximize the sum of squares, subject to the constraints imposed by the restrictions.\n\nBut how do I model the constraints? For each restriction, the tallest house in [l_i, r_i] must be <= x_i. So for each such interval, the maximum of the heights from l_i to r_i must be <= x_i.\n\nThis sounds like an integer programming problem, but since n is small (up to 50), perhaps a dynamic programming approach is possible.\n\nWait, but another idea: for each spot, the maximum possible height is min of all the x_i's that cover it plus the overall h. Because each spot is part of some intervals in the restrictions. So for each spot i, the maximum allowed height is the minimum of x_j for all j where i is in [l_j, r_j], and also the overall h.\n\nWait, no, that's not correct. Because a particular spot could be covered by multiple restrictions, each of which imposes a maximum. So the actual maximum height allowed for that spot is the minimum of all x_j where the spot is in their interval, because each restriction says that the max in their interval can't exceed x_j. So if a spot is in two overlapping intervals, both x values apply.\n\nSo for spot i, the maximum height allowed is the minimum x_j among all restrictions that include i in their interval, or h if none.\n\nWait, not exactly. Because the restrictions are about the maximum in the interval, but for a spot i, any restriction that includes i may impose a maximum on the height of i. So for example, if i is in two intervals with x=3 and x=2, then the maximum possible height for i is 2, because otherwise, the first interval would have a maximum taller than 3.\n\nAh, right! So for each spot i, its height can't exceed any x_j where i is in [l_j, r_j]. So the maximum height allowed for spot i is the minimum of all x_j for which l_j <= i <= r_j, or h if there are no such restrictions.\n\nSo the first step is to precompute for each spot i the maximum possible height it can have, considering all applicable restrictions. Then, each spot's height can be at most this value, and at least 0.\n\nOnce we have this per spot maximum, the problem reduces to choosing for each spot a height between 0 and this maximum, such that the sum of squares is maximized.\n\nWait, but wait! That's not entirely accurate. Because the initial reasoning assumes that the maximum of each spot is determined by all the restrictions that cover it. However, the problem requires that for each interval [l_j, r_j], the maximum height in that interval is at most x_j. So just taking the minimum of all x_j for each spot may not capture all constraints, because it's possible that a spot i has a higher x_j in some interval, but when combined with other spots, the maximum in that interval could exceed x_j.\n\nFor example, suppose you have two spots, 1 and 2. Restriction 1: l=1, r=2, x=3. So the maximum of spots 1 and 2 must be <=3. Suppose spot 1's maximum is 3, spot 2's maximum is also 3. Then the maximum in the interval is 3, which is acceptable. But if spot 1's maximum is min(3, something else) and spot 2's maximum is min(3, ...). So yes, the initial approach seems correct.\n\nWait, no. Suppose you have two restrictions: one covering spot 1-2 with x=3, and another covering spot 2-3 with x=2. So spot",
    "response": "To solve this problem, we need to maximize the profit from building houses on a street while adhering to given zoning restrictions. Each house's height contributes to the total profit based on its square, and each restriction limits the maximum height within a specific range of spots.\n\n### Approach\n1. **Identify Constraints for Each Spot**: For each spot on the street, determine the maximum height it can have based on all applicable restrictions. This maximum height is the minimum value of all restrictions that cover the spot, or the overall maximum height if no restrictions apply.\n2. **Dynamic Programming for Optimization**: Use dynamic programming to explore all possible heights for each spot, starting from the first spot and moving to the last. For each spot, consider all possible heights up to the determined maximum and update the total profit accordingly, ensuring all restrictions are satisfied.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx]); idx +=1\n    h = int(input[idx]); idx +=1\n    m = int(input[idx]); idx +=1\n\n    spots_max = [h] * (n+1)  # 1-based indexing\n\n    for _ in range(m):\n        l = int(input[idx]); idx +=1\n        r = int(input[idx]); idx +=1\n        x = int(input[idx]); idx +=1\n        for i in range(l, r+1):\n            if x < spots_max[i]:\n                spots_max[i] = x\n\n    # Now, for each spot i, the max allowed is spots_max[i]\n\n    # Let's precompute for each spot the min x across all intervals that include it, then take min with h\n    # But that's what spots_max already represents.\n\n    # Now, model the problem as choosing heights a_i where 0 <= a_i <= spots_max[i]\n    # The constraints are automatically satisfied because the max in any interval [l..r] will be <= min of x_j for j covering [l..r], which is <= spots_max[i] for each i.\n\n    # Now, the problem reduces to: choose a_1, a_2, ..., a_n, each 0<=a_i<=spots_max[i], to maximize sum(a_i^2).\n\n    # Since n is small, we can model this with DP.\n\n    dp = [0]*(n+1)\n    for i in range(1, n+1):\n        current_max = spots_max[i]\n        new_dp = []\n        for a in range(0, current_max +1):\n            # For each possible a, the maximum profit up to spot i is a^2 + dp[i-1][prev_a]\n            # But since prev_a can be anything up to spots_max[i-1], we need to track the maximum for each possible a.\n            # So for each a, we take the maximum of dp[i-1][prev_a] + a^2 for all prev_a.\n            max_prev = 0\n            for prev_a in range(0, spots_max[i-1]+1):\n                if dp[i-1][prev_a] > max_prev:\n                    max_prev = dp[i-1][prev_a]\n            new_dp.append(max_prev + a*a)\n        dp[i] = new_dp\n\n    print(int(dp[n][spots_max[n]]))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of spots, maximum height, and number of restrictions.\n2. **Determine Maximum Height per Spot**: For each spot, compute the maximum allowable height considering all applicable restrictions.\n3. **Dynamic Programming Setup**: Use dynamic programming to keep track of the maximum profit achievable up to each spot, considering all possible heights for that spot.\n4. **Compute Maximum Profit**: By iterating through each spot and considering all possible heights, the solution ensures all constraints are met while maximizing the total profit.\n\nThis approach efficiently handles the constraints and ensures the optimal solution by leveraging dynamic programming to explore all feasible height configurations.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx]); idx +=1\n    h = int(input[idx]); idx +=1\n    m = int(input[idx]); idx +=1\n\n    spots_max = [h] * (n+1)  # 1-based indexing\n\n    for _ in range(m):\n        l = int(input[idx]); idx +=1\n        r = int(input[idx]); idx +=1\n        x = int(input[idx]); idx +=1\n        for i in range(l, r+1):\n            if x < spots_max[i]:\n                spots_max[i] = x\n\n    # Now, for each spot i, the max allowed is spots_max[i]\n\n    # Let's precompute for each spot the min x across all intervals that include it, then take min with h\n    # But that's what spots_max already represents.\n\n    # Now, model the problem as choosing heights a_i where 0 <= a_i <= spots_max[i]\n    # The constraints are automatically satisfied because the max in any interval [l..r] will be <= min of x_j for j covering [l..r], which is <= spots_max[i] for each i.\n\n    # Now, the problem reduces to: choose a_1, a_2, ..., a_n, each 0<=a_i<=spots_max[i], to maximize sum(a_i^2).\n\n    # Since n is small, we can model this with DP.\n\n    dp = [0]*(n+1)\n    for i in range(1, n+1):\n        current_max = spots_max[i]\n        new_dp = []\n        for a in range(0, current_max +1):\n            # For each possible a, the maximum profit up to spot i is a^2 + dp[i-1][prev_a]\n            # But since prev_a can be anything up to spots_max[i-1], we need to track the maximum for each possible a.\n            # So for each a, we take the maximum of dp[i-1][prev_a] + a^2 for all prev_a.\n            max_prev = 0\n            for prev_a in range(0, spots_max[i-1]+1):\n                if dp[i-1][prev_a] > max_prev:\n                    max_prev = dp[i-1][prev_a]\n            new_dp.append(max_prev + a*a)\n        dp[i] = new_dp\n\n    print(int(dp[n][spots_max[n]]))\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 803,
        "completion_token_count": 853,
        "thoughts_token_count": 1025
    }
}