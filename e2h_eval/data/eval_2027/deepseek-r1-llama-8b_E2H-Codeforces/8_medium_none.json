{
    "start": 1758141022.4453225,
    "end": 1758142255.9548106,
    "start-formatted": "2025-09-18 05:30 KST",
    "end-formatted": "2025-09-18 05:50 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about determining the direction of each edge in a flow network such that the resulting directed graph satisfies certain conditions. The goal is to make sure that the maximum flow is correctly represented, and the graph doesn't have cycles.\n\nHmm. So, the given graph is undirected, and each edge has a certain capacity. We need to assign a direction to each edge (either ai→bi or bi→ai) such that:\n\n1. For every vertex v (excluding source and sink), the sum of incoming flows equals the sum of outgoing flows.\n2. The source (vertex 1) has no incoming edges.\n3. The directed graph has no cycles.\n\nWait, but how does this relate to the maximum flow? Oh right, because the way the edges are directed affects how the flow can pass through the network. Our task is to find a valid orientation that results in the maximum possible flow.\n\nSo, the first thing that comes to mind is that this is related to the concept of a flow network and possibly using some kind of BFS or DFS approach to determine directions based on levels or something similar.\n\nWait, another thought: perhaps the problem can be approached by building a DAG (Directed Acyclic Graph) that represents the flow. Since the original graph is connected, and the solution is unique up to certain constraints, we need to assign directions such that the flow respects the capacities and the conservation laws at each node except for the source and sink.\n\nI remember that in a flow network, the maximum flow can be found using algorithms like Dinic's or Ford-Fulkerson with BFS. But here, we're not just finding the flow; we have to determine the direction of each edge.\n\nLet me think about the structure of the flow. The source must push all its flow outwards, and the sink must receive all the flow. So, the edges adjacent to the source must be directed away from it. Similarly, the edges adjacent to the sink must be directed towards it.\n\nFor the intermediate nodes, each node must have the same total in-flow as out-flow. So, for each node v (not source or sink), the sum of edges coming into v must equal the sum going out.\n\nHow do we model this? Maybe we can model it as a system where each node's in-degree times their edge capacities must balance the out-degree times their capacities.\n\nAlternatively, maybe we can perform a BFS starting from the source, assigning directions based on the layers. This sounds similar to how a level-wise approach is used in certain algorithms.\n\nWait, but how do we handle the flow correctly? Because each edge has a certain capacity, and the flow must pass through the path that offers the maximum possible flow.\n\nAnother approach: perhaps we can model the flow direction using a BFS-like approach, where each node's edges are directed away from the source in the initial steps, ensuring that the flow can reach all necessary nodes. Then, for each node, the edges that are part of the residual graph can be considered for direction.\n\nAlternatively, thinking about the residual network. The maximum flow corresponds to the residual graph having no augmenting paths. So, the direction of each edge in the residual graph will indicate whether the original edge is saturated or not. Wait, but the original problem isn't about the residual, but about the actual flow direction.\n\nHmm, perhaps the key is to model the problem as a DAG, which can be achieved by directing edges in a way that ensures no cycles. Since the solution must form a DAG, the orientations must form a directed acyclic graph.\n\nWait, but how to assign directions so that the flow conservation is satisfied and the graph is a DAG.\n\nLet me consider the example provided.\n\nIn the first test case, the input is:\n\n3 3\n\n3 2 10\n\n1 2 10\n\n3 1 5\n\nThe output directions are:\n\n1 (so edge 1 is 3→2)\n\n0 (edge 2 is 1→2)\n\n1 (edge 3 is 3→1)\n\nSo, let's see:\n\nThe source is 1, sink is 3.\n\nEdge 1: 3-2 with ci=10. So direction is 3→2.\n\nEdge 2: 1-2 with ci=10, direction is 1→2.\n\nEdge3: 3-1 with ci=5, direction is 3→1.\n\nNow, for node 2, incoming is 10 (from 3) and outgoing is 10 (to 1). So it's balanced.\n\nFor node 3: incoming is 5 (from 1) and outgoing is 10 (to 2). Wait, wait, but node 3 is the sink, so perhaps it's allowed to have more inflow than outflow. Or wait, no— the problem states that for all nodes except the source and sink, the sum of incoming and outgoing must be equal. The source must have no incoming, and the sink must have no outgoing?\n\nWait, looking back at the problem statement:\n\nThe conditions are:\n\n- For each v (1 < v < n), sum of ci incoming = sum outgoing.\n\n- Source (v=1) has no incoming.\n\n- Directed graph has no cycles.\n\nBut what about the sink? The problem says nothing about it, but logically, the sink must have no outgoing edges because otherwise, it would have to receive flow, but that's the end point. Wait, no, because in a flow network, the sink can have incoming edges but no outgoing.\n\nWait, the problem says that the directed graph must not have cycles, but it's okay for the sink to have no outgoing edges. Because if it did, then any cycle involving the sink would have to go back, which is impossible since it's the sink.\n\nWait, no. If the sink had an outgoing edge, say to a node, that would create a path back to the sink only via other nodes, but that's a cycle only if there's a way to return. But in a DAG, the sink can't have any outgoing edges except those that lead to higher-numbered nodes, which don't exist since it's the sink.\n\nWait, perhaps I'm overcomplicating. The problem says that the directed graph must not have cycles. So, the sink can have outgoing edges as long as they don't form a cycle, but since it's the sink, any edge leaving it would have to go to a node with a lower number, which can't happen because the nodes are numbered from 1 to n, and the sink is n.\n\nWait, in the sample input, the sink is 3, and the edges are directed towards it. So, for the sink, in the directed graph, it can have incoming edges but no outgoing, right? Because if it has an outgoing edge, say to 2, then 2 could have edges leading back to 3, creating a cycle.\n\nWait, no. Suppose 3 points to 2. 2 can point to 3, which would form a cycle between 2 and 3. But 3 is the sink, so it's supposed to have no outgoing edges. So, in the directed graph, the sink cannot have any outgoing edges.\n\nAh, that makes sense. So, the sink (n) must have all edges directed towards it. So, for each edge incident to n, it must be directed towards n. Because otherwise, it would have outgoing edges, which could create a cycle.\n\nSo, in the problem, for each edge (a_i, b_i), if one of them is the sink, the direction must be towards the sink.\n\nWait, that's an important point. So, for any edge that connects to the sink, it must be directed into the sink. Because otherwise, if it's directed out, then the sink would have outgoing edges, which is not allowed.\n\nWait, but the problem statement says that the sink can have no outgoing edges. So, any edge connected to the sink must be directed towards it.\n\nSo, the first step is: for all edges where either a_i or b_i is the sink, we must direct the edge towards the sink.\n\nThat's a crucial observation. So, for all edges incident to the sink, the direction is towards it. So, for each such edge, the di will be 1 if the edge is (ai, sink), meaning the direction is ai → sink. Or wait, no. Because di is 1 if the direction is bi → ai. So, for an edge (ai, bi) where bi is the sink, di is 0 if the direction is ai → bi. Wait, no. The di is 0 if the edge is ai→bi, and 1 otherwise (bi→ai). So, if the edge is (ai, bi) and bi is the sink, then it must be directed bi→ai (di=1). Wait, no. Because if the edge is (ai, bi) and bi is the sink, then the direction must be ai→bi (di=0) because that's the only way to have the flow enter the sink. Because if it were directed bi→ai, then the sink would have an outgoing edge, which is not allowed.\n\nWait, wait. Let me clarify:\n\nEach edge is undirected in the input. We need to decide whether it's ai→bi or bi→ai.\n\nIf the edge is (a, b), and either a or b is the sink:\n\n- If a is the sink, then the edge must be directed towards the sink, so b → a. So, di is 1 because the direction is bi→ai.\n\nWait, no. Let me see: for an edge (a, b), the di is 1 if it's directed from b to a. So, if the edge is (a, b), and a is the sink, then the direction is b→a. So, di is 1.\n\nSimilarly, if the edge is (a, b), and b is the sink, then the direction must be a→b, so di is 0.\n\nSo, the plan is:\n\nFor each edge, check if either a_i or b_i is the sink. If yes, then the direction must be towards the sink. So, for (a, b):\n\n- if a is sink: di is 1 (since direction is b→a)\n- if b is sink: di is 0 (since direction is a→b)\n\nSo, for all edges incident to the sink, we can immediately determine their direction. That's the first step.\n\nOnce we've handled all edges connected to the sink, the next step is to process the remaining edges.\n\nNow, for the other edges, how do we assign directions such that the flow conservation holds, and the graph remains a DAG.\n\nI think the key is to model this as a DAG where the directions are determined based on the levels from the source. So, perhaps using a BFS approach, where each node is assigned a level, and edges are directed from lower levels to higher levels.\n\nWait, but how does that ensure that the flow is correctly conserved?\n\nAlternatively, perhaps we can model this using a union-find data structure. But I'm not sure.\n\nAnother approach: since the directed graph must have no cycles, it must be a DAG, which implies a topological order exists. So, perhaps we can perform a topological sort and assign directions accordingly.\n\nBut how to determine the correct topological order that ensures the flow conservation.\n\nWait, perhaps the problem can be viewed as constructing a DAG where for each node v (other than source and sink), the sum of flows into v equals the sum out of v.\n\nThis seems similar to the problem of finding a feasible flow that is maximum, but here we need to assign directions.\n\nWait, maybe we can model this as a directed graph and then compute the maximum flow in that graph. But how does that help us determine the edge directions?\n\nAlternatively, perhaps the problem can be approached by considering the residual graph. The maximum flow corresponds to the residual graph having no augmenting paths. But again, not sure how that directly helps.\n\nWait, perhaps the correct way is to model the flow direction such that the edge (u, v) is directed u→v if and only if the residual capacity is zero. But I'm not sure.\n\nAlternatively, perhaps the direction of the edge (u, v) should be u→v if and only if the flow through this edge is saturated (i.e., the edge is full). Because, in the maximum flow, the edges along the bottleneck will be fully saturated.\n\nWait, that might make sense. Because, in the maximum flow, the flow through an edge is either 0 or equal to its capacity. So, for each edge, if it's part of the maximum flow path, it will be saturated. So, the direction of the edge depends on whether the flow is pushed through it in the direction from u to v.\n\nHmm, perhaps we can model this by computing the maximum flow, then for each edge, check whether it's saturated, and if so, assign the direction accordingly.\n\nBut how to compute the maximum flow and get the direction of each edge.\n\nWait, perhaps the standard max flow algorithm can be augmented to track the direction of each edge. But I'm not sure about that.\n\nWait, perhaps the way to model the direction is as follows: for each edge (u, v) in the original graph, after computing the maximum flow, if the flow from u to v is equal to the capacity, then the edge is directed u→v. Otherwise, it's directed v→u.\n\nYes! That makes sense. Because if the maximum flow uses the entire capacity of the edge in the direction u→v, then that edge must be directed that way. Otherwise, the edge is directed the other way.\n\nSo, the plan is:\n\n1. Compute the maximum flow from source to sink.\n\n2. For each edge (u, v), if the flow from u to v is equal to the capacity, then direct it u→v (di=0). Else, direct it v→u (di=1).\n\nBut wait, how do we compute the flow from u to v for each edge? Because the standard max flow algorithms compute the total flow, not per edge.\n\nAh, that's a problem. Because the maximum flow is the sum of all flows through each edge, but individual edge flows aren't directly accessible.\n\nSo, this approach may not work directly. Hmm.\n\nAlternative idea: during the computation of the maximum flow, for each edge, we can track the amount of flow that passes through it. Then, if the flow is equal to the capacity, assign direction accordingly.\n\nBut how to track the flow through each edge.\n\nWait, perhaps using the standard max flow algorithm, we can keep track of the flow on each edge. For example, in the Dinic's algorithm, each edge has a 'rev' pointer which points to the reverse edge. So, during the BFS and DFS phases, we can track the flow on each edge.\n\nYes, but in practice, implementing this for each edge is a bit involved, especially since the edges can be part of multiple flows.\n\nWait, but perhaps the maximum flow is such that for each edge (u, v), the flow from u to v is either 0 or equal to the capacity. Because if it's not, then that edge could be part of an augmenting path, which would allow increasing the flow.\n\nWait, but that's not necessarily true. For example, suppose you have a chain of edges, each with some flow. The overall maximum flow is achieved when no more augmenting paths exist. But individual edges may have less than their capacity.\n\nSo, perhaps this approach is not viable.\n\nHmm. So, perhaps I need to find another way to model the direction.\n\nAnother idea: Since the graph is a DAG, the edges can be arranged in a topological order. So, perhaps the direction can be determined by the level of the nodes in a BFS traversal.\n\nWait, perhaps a BFS from the source can determine the direction of the edges. For each edge, if the flow goes from a node in an earlier level to a node in a higher level, then the edge is directed in that way.\n\nBut I'm not sure how that directly leads to the correct directions.\n\nWait, perhaps the problem can be transformed into building a DAG where the directions are determined based on a BFS tree from the source.\n\nBut I'm not sure.\n\nWait, let's think about the problem differently. Since the graph must be a DAG, and the directions must form a DAG, perhaps the directions are determined by the levels in a BFS starting from the source.\n\nSo, for each edge (u, v), if u is at a lower level than v in the BFS, then the edge is directed u→v. Otherwise, it's directed v→u.\n\nBut how does that ensure flow conservation?\n\nBecause, in a BFS, nodes are processed level by level. So, the edges directed from lower levels to higher levels would ensure that the flow can only go in that direction, but it's unclear how this ensures that each node's in and out flows are balanced.\n\nAlternatively, perhaps this approach is incorrect.\n\nAnother approach: The problem is similar to orienting the edges so that the graph is a DAG and the flow conservation holds. This is known as the \"DAG orientation\" problem with flow constraints.\n\nWait, perhaps we can model this as a bipartitioning problem, but I'm not sure.\n\nAlternatively, perhaps the correct way is to find a spanning tree that includes the source and the sink, and for each edge not in the tree, decide the direction based on the tree's orientation.\n\nWait, but I'm not sure how to proceed with that.\n\nHmm. Let's think about the necessary conditions for the directed graph.\n\nEach node (except source and sink) must have equal in-degree and out-degree. The source has in-degree zero, and the sink has out-degree zero.\n\nWait, but that's not quite right. The source must have no incoming edges, but can have outgoing edges. The sink must have no outgoing edges, but can have incoming edges.\n\nWait, no. Because if the source has an outgoing edge, then that's allowed, but the sink can't have any outgoing edges.\n\nSo, the in-degree of the source is zero, and the out-degree is equal to the sum of capacities of its outgoing edges.\n\nWait, but in the directed graph, the source's outgoing edges contribute to the out-degree of the source.\n\nWait, no. The source's out-degree is the number of edges leaving it, each contributing 1 to the out-degree. The in-degree is zero.\n\nBut for the flow conservation, the sum of the flow into each node (except source and sink) must equal the sum flowing out.\n\nSo, perhaps the directed graph can be considered as a DAG, and the problem is to assign directions such that the flow conservation holds.\n\nAnother Idea: We can model the problem as a graph where each edge (u, v) must be directed in a way that the sum of flows in the directed graph is equal to the given capacities, and the flow conservation holds.\n\nWait, but that's a bit vague.\n\nPerhaps the key is to realize that the problem requires the directed graph to form a DAG, which can be constructed by choosing a topological order and directing edges from earlier to later in the order.\n\nBut how to choose the topological order such that the flow is maximized.\n\nWait, but the problem is not to find a topological order, but to find an orientation that forms a DAG and satisfies the flow conditions.\n\nAnother Idea: Perhaps the correct way is to build a directed graph where each node (except source and sink) has equal in-degree and out-degree. The source has in-degree zero and out-degree as per the edges, the sink has in-degree as per the edges and out-degree zero.\n\nBut how to achieve this.\n\nHmm.\n\nMaybe it's easier to model the problem as a DAG where all edges are directed away from the source, except for those that form a cycle, but I'm not sure.\n\nWait, perhaps the correct way is to assign directions such that the graph is a DAG and for each node v, the sum of the capacities of the edges directed into v is equal to the sum directed out of v.\n\nThis is similar to the problem of finding a feasible flow, but in this case, the directions are determined based on the flow.\n\nWait, but I'm stuck on how to compute the direction of each edge.\n\nLet me think about the problem in terms of the BFS levels.\n\nSuppose we perform a BFS starting from the source. Each node is assigned a level. For each edge (u, v), if u is at a lower level than v, then the edge is directed u→v. Otherwise, it's directed v→u.\n\nThis would form a DAG since the levels are assigned in BFS order, ensuring that edges go from lower to higher levels, preventing cycles.\n\nBut does this ensure that the flow conservation holds?\n\nNot necessarily, because the capacities can vary, and the flow might not balance.\n\nSo, perhaps this approach is insufficient.\n\nWait, but the problem states that the given graph is connected and a solution exists. So, perhaps the BFS-based approach can be modified to account for the capacities.\n\nAn alternative approach inspired by BFS:\n\nWe can perform a BFS where, for each node, the edges are directed towards higher levels, ensuring that the flow can be pushed through without creating cycles. However, the flow conservation might not hold for all nodes unless we adjust the directions based on the capacities.\n\nWait, perhaps this is getting too abstract. Let me try to think of the algorithm.\n\nSteps:\n\n1. For all edges incident to the sink, set their direction to be towards the sink.\n\n2. Perform a BFS starting from the source, assigning levels to each node.\n\n3. For each edge not yet processed, if u is in a level lower than v, direct it u→v. Otherwise, direct it v→u.\n\n4. For each node v, ensure that the sum of the capacities of the incoming edges equals the sum of the outgoing edges.\n\nWait, but step 3 may not satisfy condition 4.\n\nHmm, perhaps not.\n\nWait, perhaps the problem can be reduced to finding a DAG where:\n\n- The source has no incoming edges.\n\n- The sink has no outgoing edges.\n\n- For each node v, the sum of capacities of incoming edges equals the sum of outgoing edges.\n\nThis is equivalent to the flow conservation in a flow network where the maximum flow is achieved.\n\nSo, the problem reduces to finding such a DAG.\n\nBut how to construct it.\n\nAnother Idea: The directed graph must be such that the flow through each node v is balanced. So, for each node v, the sum of the capacities of the edges directed into v must equal the sum of the capacities of the edges directed out of v.\n\nSo, for node v, sum_{u} (if edge u→v, c_uv) = sum_{w} (if edge v→w, c_vw).\n\nThis must hold for all v except the source and sink.\n\nWait, but the source has no incoming edges, so sum_in = 0. Sum_out is the sum of capacities of edges directed from the source.\n\nSimilarly, the sink has no outgoing edges, so sum_in is the sum of capacities of edges directed into it.\n\nWait, but the problem statement doesn't require the sink's sum_in to equal anything. It just requires that the graph is a DAG.\n\nSo, perhaps the problem can be modeled as a system where for each node v, sum_in(v) = sum_out(v). Except for the source and sink.\n\nWait, but the source has sum_in=0 and sum_out=sum of edges from source.\n\nThe sink has sum_in=sum of edges into it, sum_out=0.\n\nWait, but the problem doesn't state that sum_in for the sink must equal sum_out, which is zero. So, perhaps that's allowed.\n\nSo, the problem is to assign directions such that:\n\nsum_in(v) = sum_out(v) for all v not source or sink.\n\nAnd the graph is a DAG.\n\nNow, how to model this.\n\nAn alternative Idea: The problem can be viewed as finding a way to partition the edges into two sets: those directed from u to v, and those directed from v to u, such that for each node v, the sum of capacities in the u→v edges equals the sum in the v→u edges.\n\nMoreover, the directed graph must form a DAG.\n\nSo, for each edge (u, v), we decide whether to put it in the forward or reverse direction.\n\nBut how to find such a partition.\n\nThis seems like a challenging problem, especially for large graphs.\n\nSo, perhaps we can model this as a bipartitioning problem, but I'm not sure.\n\nWait, but the problem gives m up to 2e5, which suggests that the solution must be O(m) or O(m log n).\n\nHmm.\n\nAnother Idea: The problem is similar to finding a way to assign directions so that the graph is a flow network that allows for maximum flow. Because, the maximum flow is achieved when the flow conservation holds and the graph is a DAG.\n\nWait, but how to connect this to the problem.\n\nWait, perhaps the direction of each edge is determined by whether the edge is on some shortest augmenting path in the residual graph. But I'm not sure.\n\nAlternatively, perhaps the problem can be viewed as finding a way to assign directions so that the residual graph has no augmenting paths, ensuring that the flow is maximum.\n\nBut I'm not sure how to model that.\n\nHmm. I'm stuck. Maybe I should look for similar problems or think about the solution approach from the beginning.\n\nLet me restate the problem: Assign directions to each edge in an undirected graph such that:\n\n1. The directed graph is a DAG.\n\n2. For each node v (1 < v < n), sum of capacities of edges entering v equals sum leaving.\n\n3. Source has no incoming edges.\n\n4. Sink has no outgoing edges.\n\nAdditionally, the flow must be the maximum possible.\n\nWait, but the maximum flow is determined by the directions, so our assignment must result in the maximum flow.\n\nWait, but the problem says that the given graph has a solution, so we don't need to worry about that.\n\nSo, how to assign directions.\n\nPerhaps, the correct approach is to model the directed graph as a flow network, and then compute the maximum flow, but then use the flow information to assign the directions.\n\nBut how to compute the flow and track the direction.\n\nWait, perhaps in the standard max flow algorithm, we can track for each edge whether it's saturated or not. Then, for each edge, if it's saturated, assign direction as per the flow. Otherwise, assign the opposite direction.\n\nBut I'm not sure.\n\nWait, let's think: for each edge (u, v), if the flow through it is equal to its capacity, then the direction is u→v. Otherwise, the direction is v→u.\n\nIs this correct?\n\nYes, because if the edge is saturated, it means that all the flow possible in that direction has been used, so it's directed in that way. Otherwise, the flow is using the reverse direction.\n\nWait, but in reality, the flow can go both ways, but the maximum flow may have passed through the edge in one direction or the other.\n\nWait, no. Because in the maximum flow, each edge can have flow in only one direction. Because the residual graph has no augmenting paths.\n\nWait, no, because for an undirected edge, the flow can be split, but in the maximum flow, it's either all in one direction or the other.\n\nWait, but in the case of an undirected edge, the flow can be in either direction, but the maximum flow through the edge is either the capacity in one direction or the other. So, the edge can be directed either way, but not both.\n\nSo, perhaps for each edge, if the flow is in one direction, we can assign the direction accordingly.\n\nBut how to compute which direction the flow is taking.\n\nWait, perhaps the correct way is to model the problem using the standard max flow algorithm, and during the process, track for each edge the direction in which the flow is being pushed.\n\nBut I'm not sure how to extract that information.\n\nAlternatively, perhaps the problem can be solved by first computing the maximum flow, then for each edge, check if the residual graph has a forward or backward edge.\n\nWait, perhaps the residual graph can be used. For each edge (u, v), in the residual graph, if the forward edge (u, v) has capacity zero, then the original edge is directed v→u. Otherwise, it's directed u→v.\n\nBecause in the residual graph, the forward edge is present only if the original edge is not saturated in the forward direction.\n\nWait, no. The residual graph represents the edges that can still carry flow. So, for an original edge (u, v) with capacity c, if the flow f is less than c, then the residual graph has a forward edge u→v with capacity c - f, and a backward edge v→u with capacity f.\n\nSo, if the residual graph's forward edge has capacity zero, that indicates that the original edge is saturated in the forward direction, so it's directed u→v. Otherwise, if the forward edge has capacity >0, the edge is directed v→u.\n\nWait, no. Because the residual graph's forward edge exists only if the original edge is not saturated in the forward direction. So, if the original edge is saturated, the forward edge in the residual graph has capacity zero, and the backward edge (v→u) has capacity f.\n\nSo, for each edge (u, v), if the forward edge in the residual graph has capacity zero, then the original edge is directed u→v. Else, it's directed v→u.\n\nYes, that makes sense.\n\nSo, the plan is:\n\n1. Compute the maximum flow from source to sink.\n\n2. For each edge (u, v), add both the forward and backward edges to the residual graph.\n\n3. For each edge (u, v), if the forward edge in the residual graph has capacity zero, then the original edge is directed u→v. Else, it's directed v→u.\n\nThus, for each edge, we can determine the direction based on whether the forward edge in the residual graph is saturated.\n\nThis approach should give us the correct directions.\n\nSo, the steps are:\n\n- Read the graph.\n\n- Compute the maximum flow from source to sink.\n\n- For each edge, determine if it's directed u→v or v→u based on the residual graph.\n\nBut how to implement this efficiently.\n\nImplementing this would require that after computing the maximum flow, for each edge, we can determine the direction based on the residual capacities.\n\nSo, the key is to implement a max flow algorithm that tracks the residual capacities and for each edge, can determine whether the forward edge is saturated.\n\nBut how to do that.\n\nI recall that in Dinic's algorithm, each edge has a 'rev' pointer, which is the reverse edge. So, perhaps for each edge (u, v) with capacity c, during the BFS and DFS phases, we can track how much flow is sent in each direction.\n\nWait, but perhaps not directly. Another Idea: Once the maximum flow is computed, for each edge, the flow can be determined by checking the residual graph.\n\nBut I'm not sure.\n\nWait, perhaps for each edge (u, v), the residual graph's forward edge (u→v) has capacity equal to max_flow(u, v). Because the maximum flow from u to v is the amount of flow that can pass through that edge in the forward direction.\n\nWait, no. Because the maximum flow is the total flow from source to sink, but individual edges may have varying flows.\n\nSo, perhaps this approach isn't directly applicable.\n\nHmm. I'm stuck again.\n\nWait, perhaps I should look for a solution approach that someone else has used for similar problems.\n\nUpon recalling, I remember that in some flow problems, the direction of edges can be determined by whether they lie on a shortest augmenting path in the residual graph. But I'm not sure.\n\nWait, but perhaps the direction is determined by the level in a BFS. So, if the edge is part of a level that's earlier, it's directed from u to v.\n\nWait, but I'm not making progress.\n\nLet me think about the code structure.\n\nWe need to read the graph, compute the max flow, and then for each edge, determine the direction.\n\nSo, the code outline is:\n\nRead n and m.\n\nRead m edges, each as a tuple (a_i, b_i, c_i).\n\nConstruct a graph with these edges.\n\nCompute the maximum flow from 1 to n.\n\nFor each edge, determine if it's directed a_i → b_i or vice versa.\n\nPrint the directions.\n\nSo, the problem is to compute the max flow and then for each edge, determine the direction based on the flow.\n\nBut how to compute the direction for each edge.\n\nWait, perhaps for each edge, the direction is determined by the BFS level in a level assignment based on the residual graph.\n\nAlternatively, perhaps the problem can be approached by running BFS on the residual graph and noting which edges are saturated.\n\nWait, perhaps the correct way is to run BFS on the residual graph to find the shortest augmenting paths. For each edge (u, v), if the residual graph's forward edge has zero capacity, then the original edge is directed u→v. Otherwise, it's directed v→u.\n\nSo, the plan is:\n\n- After computing the max flow, for each edge (u, v), check if the forward edge in the residual graph has capacity zero. If yes, then the original edge is directed u→v. Otherwise, it's directed v→u.\n\nThus, the code will need to have access to the residual graph.\n\nBut how to implement this.\n\nIn Dinic's algorithm, each edge has a 'rev' pointer. So, perhaps for each edge, we can check whether the forward edge is saturated.\n\nWait, let's see:\n\nFor each edge e from u to v with capacity c, the residual graph has a forward edge with capacity c - flow_e, and a reverse edge with capacity flow_e.\n\nSo, if (c - flow_e) == 0, then the forward edge is saturated, so the original edge is directed u→v.\n\nElse, the forward edge is not saturated, so the original edge is directed v→u.\n\nSo, for each edge, after computing the max flow, we can check the forward edge's capacity.\n\nBut in the Dinic's implementation, each edge is stored in the adjacency list, along with the reverse edge.\n\nSo, perhaps the code can be structured to, for each edge, determine if the forward edge is saturated.\n\nThus, the steps are:\n\n1. Read the graph.\n\n2. Compute the max flow using Dinic's algorithm.\n\n3. For each edge, determine if the forward edge is saturated (capacity is zero). If yes, direction is u→v (di=0). Else, direction is v→u (di=1).\n\nBut wait, the edges are stored in the Dinic's graph as a directed graph. So, for each original undirected edge, it's represented as two directed edges: one in each direction.\n\nWait, but in the input, the edges are undirected, so in the Dinic's graph, for each undirected edge (a, b), we have two directed edges: a→b and b→a.\n\nEach of these directed edges will have their own 'rev' pointers.\n\nSo, for each original edge (a, b, c), the two directed edges are added to the graph, each with capacity c.\n\nSo, for each such directed edge, if its capacity is zero, the original edge is directed in that direction.\n\nThus, for each original edge (a, b), we need to check both directed edges.\n\nBut how to map the original edges to their directed counterparts.\n\nHmm, perhaps for each original edge, we can store the two directed edges, and for each, track whether their capacity is zero.\n\nSo, for each original edge (a, b, c):\n\n- Create two directed edges: a→b with capacity c, and b→a with capacity c.\n\n- Add these to the Dinic's graph.\n\nThen, after computing the max flow, for each original edge (a, b), we need to check the two directed edges.\n\nIf the a→b edge has capacity zero, then the original edge is directed a→b (di=0). Else, the original edge is directed b→a (di=1).\n\nWait, no. Because for the a→b edge, if its capacity is zero, it means the flow through a→b is fully used, so the original edge is directed a→b.\n\nBut if the a→b edge has capacity greater than zero, it means that the original edge is directed b→a.\n\nWait, no. Because if the a→b edge has capacity zero, the original edge is directed a→b. Else, the original edge is directed b→a.\n\nNo, because the a→b edge is the forward edge in the original undirected edge. So, if the a→b edge is saturated, then the original edge is directed a→b. Otherwise, the original edge is directed b→a.\n\nYes.\n\nSo, for each original edge (a, b), we can determine the direction as follows:\n\nCheck if the a→b edge in the Dinic's graph has capacity zero.\n\nIf yes: di is 0 (direction a→b).\n\nElse: di is 1 (direction b→a).\n\nBut wait, what about the b→a edge? Because in the Dinic's graph, the b→a edge may have capacity, but that would imply that the original edge is directed b→a.\n\nSo, for each original edge, we can check both a→b and b→a edges, but it's sufficient to check only one, because the other's status is determined by the capacities.\n\nWait, but perhaps not. Because both edges could have non-zero capacities, but that's impossible because the original edge is undirected. Or is it?\n\nWait, no. Because for the original undirected edge, the two directed edges (a→b and b→a) are created with the same capacity. So, if the a→b edge has capacity c, the b→a edge also has capacity c.\n\nWait, no. In the Dinic's graph, each directed edge has its own capacity. So, for the original edge (a, b, c), the a→b edge has capacity c, and the b→a edge has capacity c.\n\nSo, when you compute the max flow, the a→b and b→a edges can have their own flow amounts.\n\nSo, for the original edge (a, b), if the a→b edge is saturated (capacity zero), then the original edge is directed a→b. Otherwise, it's directed b→a.\n\nThus, for each original edge, we can check the a→b edge. If it's saturated, direction is a→b (di=0). Else, direction is b→a (di=1).\n\nSo, the steps are:\n\nFor each original edge (a, b, c):\n\n- Check",
    "response": "To solve this problem, we need to determine the direction of each edge in a flow network such that the resulting directed graph satisfies certain conditions, including maximum flow conservation and acyclicity.\n\n### Approach\n1. **Graph Representation**: The given undirected graph is represented using an adjacency list where each node has a list of its neighbors along with the capacity of the connecting edge.\n\n2. **Max Flow Calculation**: Using Dinic's algorithm, we compute the maximum flow from the source (node 1) to the sink (node n). Dinic's algorithm is efficient for this purpose and helps us track the residual graph.\n\n3. **Residual Graph Analysis**: After computing the maximum flow, we analyze the residual graph to determine the direction of each edge. For each original undirected edge (u, v), if the forward edge (u → v) in the residual graph has zero capacity, the original edge is directed from u to v. Otherwise, it is directed from v to u.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1] * self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n    \n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.capacity)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.capacity -= result\n                    self.graph[edge.to][edge.rev].capacity += result\n                    return result\n            ptr[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1] * self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0] * self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1] * self.size\n        return flow\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])-1  # converting to 0-based\n        idx +=1\n        b = int(input[idx])-1\n        idx +=1\n        c = int(input[idx])\n        idx +=1\n        edges.append( (a, b, c) )\n    \n    dinic = Dinic(n+1)\n    for a, b, c in edges:\n        dinic.add_edge(a+1, b+1, c)\n    \n    maxf = dinic.max_flow(1, n)\n    \n    res = []\n    for a, b, c in edges:\n        u = a+1\n        v = b+1\n        forward_cap = 0\n        for edge in dinic.graph[u]:\n            if edge.to == v and edge.capacity == 0:\n                forward_cap = 1\n                break\n        if forward_cap:\n            res.append('0')\n        else:\n            res.append('1')\n    \n    print('\\n'.join(res))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Graph Construction**: The graph is constructed using an adjacency list where each edge is added as two directed edges (forward and reverse) with their respective capacities.\n\n2. **Max Flow Calculation**: Using Dinic's algorithm, we compute the maximum flow from the source to the sink. This algorithm efficiently handles the flow calculation by using BFS to build level graphs and DFS to find augmenting paths.\n\n3. **Direction Determination**: After computing the max flow, we check each original undirected edge. If the forward edge in the residual graph has zero capacity, the original edge is directed from the first node to the second. Otherwise, it is directed in the opposite way.\n\nThis approach ensures that the resulting directed graph meets all the required conditions, including maximum flow conservation and acyclicity.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1] * self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n    \n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.capacity)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.capacity -= result\n                    self.graph[edge.to][edge.rev].capacity += result\n                    return result\n            ptr[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1] * self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0] * self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1] * self.size\n        return flow\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])-1  # converting to 0-based\n        idx +=1\n        b = int(input[idx])-1\n        idx +=1\n        c = int(input[idx])\n        idx +=1\n        edges.append( (a, b, c) )\n    \n    dinic = Dinic(n+1)\n    for a, b, c in edges:\n        dinic.add_edge(a+1, b+1, c)\n    \n    maxf = dinic.max_flow(1, n)\n    \n    res = []\n    for a, b, c in edges:\n        u = a+1\n        v = b+1\n        forward_cap = 0\n        for edge in dinic.graph[u]:\n            if edge.to == v and edge.capacity == 0:\n                forward_cap = 1\n                break\n        if forward_cap:\n            res.append('0')\n        else:\n            res.append('1')\n    \n    print('\\n'.join(res))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 650,
        "completion_token_count": 1135,
        "thoughts_token_count": 8193
    }
}