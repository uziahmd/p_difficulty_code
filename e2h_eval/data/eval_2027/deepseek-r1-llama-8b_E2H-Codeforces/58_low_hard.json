{
    "start": 1758278566.1389325,
    "end": 1758278875.4851599,
    "start-formatted": "2025-09-19 19:42 KST",
    "end-formatted": "2025-09-19 19:47 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's try to understand it step by step.\n\nThe problem is about finding the minimum number of edges to add to a graph to form a simple cycle of odd length, and also counting the number of ways to do this. The cycle must have more than one vertex, and each vertex in the cycle can appear at most once. Also, we can't add any loops or parallel edges.\n\nHmm. So the first thing I need to do is think about what conditions the graph must satisfy for such a cycle to exist after adding edges. Let me break down the problem.\n\nFirst, let's consider the components of the graph. The graph isn't necessarily connected, but each connected component can be analyzed separately because cycles are formed within connected components.\n\nWait, no. Because if you add edges between different components, you might create a cycle that spans multiple components. But in this problem, since we're looking for a simple cycle (no repeated vertices), the added edges must connect existing components in a way that forms a cycle.\n\nBut maybe it's easier to handle each connected component first and see what each contributes, then combine the results.\n\nSo, perhaps the approach is to:\n\n1. For each connected component, determine whether it can contribute to forming an odd-length cycle when edges are added.\n2. Then, figure out how these components can be connected to form a cycle.\n\nBut wait, perhaps the minimal t is determined by the connected components' properties. Let's think about the possible cases.\n\nAn odd-length cycle requires that the cycle has an odd number of vertices. Since the graph is undirected, any cycle in a connected component will have even or odd length based on the structure.\n\nWait, but in a connected component, the parity of the number of vertices in any cycle depends on the bipartiteness of the graph. Oh right! Because in a bipartite graph, all cycles are of even length. So if a connected component is bipartite, then any cycle it has is even-length. If it's not bipartite, it has at least one odd-length cycle.\n\nSo, the key is: for each connected component, determine if it's bipartite. If it's not bipartite, then it already has an odd-length cycle, which is what we need. But if it's bipartite, then we can't form an odd-length cycle just by adding edges within that component. We'd have to connect it with another component that has an odd cycle.\n\nWait, no. Wait, suppose we have two bipartite components. When we connect them with an edge, does that allow the formation of an odd-length cycle? Let me think.\n\nSuppose component A is bipartite and has no odd cycles, component B is bipartite as well. If we add an edge between a node in A and a node in B, can that form an odd-length cycle?\n\nWell, let's say A has nodes u and v in different partitions, and B has nodes x and y in different partitions. Adding an edge u-x would form a cycle if u is connected back through some path to x, but that depends on the specific paths. Hmm, maybe not directly.\n\nAlternatively, perhaps the minimal way is to find two components that are both bipartite, and then connect them with an edge. Then, the combined component may have an odd cycle. Or wait, perhaps not. Because the union of two bipartite graphs is not necessarily bipartite. But in any case, connecting two bipartite components may allow for an odd-length cycle if their bipartitions align correctly.\n\nWait, perhaps it's better to model the problem by considering the number of connected components that are bipartite. Because to form an odd cycle, we need to have at least one component that is non-bipartite, or have at least two bipartite components.\n\nBecause:\n\n- If there's at least one non-bipartite component (i.e., it has an odd cycle already), then we can choose any such component, and possibly add 0 edges if it already has a cycle longer than one vertex (but wait, a cycle must have at least three vertices). So if a component has an odd cycle, then adding zero edges could suffice, but only if the component already has a cycle of odd length with more than one vertex.\n\nWait, but the problem says \"the minimum number of edges that must be added to the graph to form a simple cycle of an odd length, consisting of more than one vertex.\" So if the graph already contains such a cycle, then t=0 and w=1.\n\nSo, the first step is to check if the graph already has at least one such cycle. If yes, then output t=0 and w=1.\n\nIf not, then we need to find the minimal edges to add.\n\nSo, the overall plan is:\n\n1. Check if the graph already contains a simple cycle of odd length (length >=3). If",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length, and count the number of ways to achieve this. The cycle must consist of more than one vertex and each vertex can appear at most once.\n\n### Approach\n1. **Check for Existing Cycles**: First, we check if the graph already contains a simple cycle of odd length. If it does, the answer is immediately `t=0` and `w=1`.\n\n2. **Graph Components Analysis**: If no such cycle exists, we analyze each connected component of the graph:\n   - A connected component is bipartite if its vertices can be divided into two sets such that every edge connects a vertex from one set to the other. Bipartite graphs cannot have odd-length cycles.\n   - Non-bipartite components (those with odd-length cycles) are identified.\n\n3. **Determine Minimum Edges**:\n   - If there is at least one non-bipartite component, the minimum edges required (`t`) is 0 because such a component already has an odd-length cycle.\n   - If all components are bipartite, we need to connect at least two components to form an odd-length cycle. The minimum edges required is 1, and the number of ways to do this is determined by counting the pairs of bipartite components.\n\n4. **Count Ways**: The number of ways to form an odd-length cycle is the product of the counts of non-bipartite components and the ways to connect bipartite components.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(n, adj):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[ptr])\n        ptr +=1\n        b = int(input[ptr])\n        ptr +=1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Check if any cycle of odd length exists\n    has_odd_cycle = False\n    for comp in get_connected_components(adj):\n        if not is_bipartite(len(comp), adj_sub):\n            has_odd_cycle = True\n            break\n    \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n    \n    # Now, all components are bipartite\n    # Need to connect at least two components\n    non_bipartite_count = 0\n    bipartite_count = 0\n    for comp in get_connected_components(adj):\n        if is_bipartite(len(comp), adj_sub):\n            bipartite_count +=1\n        else:\n            non_bipartite_count +=1\n    \n    if non_bipartite_count > 0:\n        print(\"0 1\")\n        return\n    \n    if bipartite_count < 2:\n        print(\"0 1\")\n        return\n    \n    # We need to connect two bipartite components with one edge\n    # Each component is bipartite, so each has a partition\n    # For each pair of components, the number of possible edges between their partitions is the product of the sizes of the two partitions\n    total_ways = 0\n    for i in range(bipartite_count):\n        comp1 = connected_components[i]\n        for j in range(i+1, bipartite_count):\n            comp2 = connected_components[j]\n            part1_a = 0\n            part1_b = len(comp1) - part1_a\n            part2_a = 0\n            part2_b = len(comp2) - part2_a\n            total_ways += part1_a * part2_b + part1_b * part2_a\n    \n    print(f\"1 {total_ways}\")\n\ndef get_connected_components(adj):\n    visited = [False] * (n+1)\n    components = []\n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque([i])\n            visited[i] = True\n            component = []\n            while q:\n                u = q.popleft()\n                component.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(component)\n    return components\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Bipartite Check**: The function `is_bipartite` uses BFS to check if a graph can be colored using two colors, indicating it is bipartite.\n- **Connected Components**: The function `get_connected_components` identifies all connected components in the graph.\n- **Cycle Detection**: The main function first checks for existing odd-length cycles. If found, it outputs `t=0` and `w=1`.\n- **Component Analysis**: If no odd cycles exist, it counts bipartite and non-bipartite components. If there are non-bipartite components, it outputs `t=0` and `w=1`.\n- **Connecting Components**: If all components are bipartite, it calculates the minimum edges needed to form an odd cycle by connecting two bipartite components and counts the number of ways to do this.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef is_bipartite(n, adj):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[ptr])\n        ptr +=1\n        b = int(input[ptr])\n        ptr +=1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Check if any cycle of odd length exists\n    has_odd_cycle = False\n    for comp in get_connected_components(adj):\n        if not is_bipartite(len(comp), adj_sub):\n            has_odd_cycle = True\n            break\n    \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n    \n    # Now, all components are bipartite\n    # Need to connect at least two components\n    non_bipartite_count = 0\n    bipartite_count = 0\n    for comp in get_connected_components(adj):\n        if is_bipartite(len(comp), adj_sub):\n            bipartite_count +=1\n        else:\n            non_bipartite_count +=1\n    \n    if non_bipartite_count > 0:\n        print(\"0 1\")\n        return\n    \n    if bipartite_count < 2:\n        print(\"0 1\")\n        return\n    \n    # We need to connect two bipartite components with one edge\n    # Each component is bipartite, so each has a partition\n    # For each pair of components, the number of possible edges between their partitions is the product of the sizes of the two partitions\n    total_ways = 0\n    for i in range(bipartite_count):\n        comp1 = connected_components[i]\n        for j in range(i+1, bipartite_count):\n            comp2 = connected_components[j]\n            part1_a = 0\n            part1_b = len(comp1) - part1_a\n            part2_a = 0\n            part2_b = len(comp2) - part2_a\n            total_ways += part1_a * part2_b + part1_b * part2_a\n    \n    print(f\"1 {total_ways}\")\n\ndef get_connected_components(adj):\n    visited = [False] * (n+1)\n    components = []\n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque([i])\n            visited[i] = True\n            component = []\n            while q:\n                u = q.popleft()\n                component.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(component)\n    return components\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 1244,
        "thoughts_token_count": 1025
    }
}