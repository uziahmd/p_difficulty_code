{
    "start": 1758278120.3431509,
    "end": 1758278364.065032,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:39 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read through it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. Each base must have exactly one spaceship, and each spaceship must be assigned to exactly one base. So, it's a perfect matching between R rebels and B bases.\n\nBut there's an additional condition: the straight paths from each base to its assigned spaceship shouldn't intersect. So, no two paths can cross each other in the galaxy plane.\n\nHmm. So, I need to determine if such a matching exists.\n\nLet me think about how to approach this.\n\nFirst, the input consists of R spaceships and B bases. The coordinates are given, and no three points are colinear, which probably helps because it reduces some cases where lines could overlap.\n\nThe output is \"Yes\" or \"No\" based on whether a valid matching exists.\n\nSo, the steps I need to take:\n\n1. Read the input correctly.\n2. Generate all possible perfect matchings between the spaceships and bases.\n3. For each matching, check if any two paths (from base to spaceship) intersect.\n   - If a matching doesn't have any intersecting paths, output \"Yes\".\n4. If none of the matchings satisfy the condition, output \"No\".\n\nBut wait, the number of matchings could be high, especially when R is 10 and B is 10, but since R and B are up to 10, maybe it's manageable.\n\nWait, but R and B can be up to 10, so for example, if R=10 and B=5, but that's impossible because then R != B. Wait, no: the problem says R and B can be any values, but the assignment requires that R equals B, right? Because it's a perfect matching—each base has exactly one, each ship exactly one. So, the first thing to check is whether R equals B. Otherwise, it's impossible.\n\nWait, looking back at the problem statement: the assignment is a perfect matching, which implies R must equal B. Because a perfect matching is a bijection between two sets of equal size. So, if R != B, the answer is automatically \"No\".\n\nSo, step zero: if R != B, output \"No\".\n\nOtherwise, proceed.\n\nSo, the plan is:\n\n- Check if R != B. If yes, output \"No\".\n- Else, generate all possible permutations of the bases assigning to the ships.\n- For each permutation:\n   - For each ship i, draw a line from (x_i, y_i) to the assigned base point.\n   - Check if any two lines intersect except possibly at their endpoints.\n- If any permutation passes this check, output \"Yes\". Otherwise, \"No\".\n\nBut generating all permutations might be computationally intensive when R is 10, as 10! is 3.6 million, which is manageable.\n\nWait, for R=10, 10! is about 3.6 million, which is acceptable for Python.\n\nSo, for each permutation, we need to:\n\n1. Assign the i-th ship to the j-th base in the permutation.\n2. Then, for all pairs of ships (i, k), check if the lines connecting ship i to base j and ship k to base l intersect, where l is the image of k under the permutation.\n\nBut wait, that's O(R^2) checks per permutation, which for 10 is 100, and multiplied by 3.6e6 gives 3.6e8 operations. That's a bit high, but maybe manageable with optimizations.\n\nAlternatively, perhaps we can find a smarter way, but for the given constraints, it's acceptable.\n\nBut let's think about how to represent the lines and check for intersections.\n\nEach line is between two points: the ship's position and the base's position.\n\nWe need to check for any pair of lines (line1 connects ship A to base B; line2 connects ship C to base D) whether they intersect somewhere in the middle, not just at their endpoints.\n\nSo, for two lines defined by points p1-p2 and p3-p4, do they intersect?\n\nWe can represent each line as a pair of points and use the standard line-line intersection algorithm.\n\nBut wait, the problem states that no three points are colinear. So, any four points (two ships and two bases) will form a convex quadrilateral, meaning that the lines can either intersect or not, but not have multiple intersections.\n\nWait, but that's not necessarily true. Two lines can still cross each other even if they are part of the same convex quadrilateral.\n\nSo, the steps for each permutation:\n\nFor each pair of ships i and k, check if the lines from i to base j and k to base l intersect.\n\nIf any such pair in the permutation leads to an intersection, this permutation is invalid.\n\nSo, for each permutation, we need to iterate over all possible pairs of ships and see if their assigned",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian, each spaceship has exactly one assigned base, and no two paths from a base to its assigned spaceship intersect in the galaxy plane.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" immediately because a perfect matching is impossible.\n2. **Generate Permutations**: If R equals B, generate all possible permutations of assigning bases to spaceships. Each permutation represents a potential assignment.\n3. **Check for Intersections**: For each permutation, check if any two paths (from a base to its assigned spaceship) intersect. If a permutation exists where no paths intersect, output \"Yes\". If all permutations result in intersections, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr += 1\n    B = int(data[ptr])\n    ptr += 1\n\n    ships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ships.append((x, y))\n        ptr += 2\n\n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        bases.append((x, y))\n        ptr += 2\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Now, try all possible matchings\n    for perm in permutations(range(R)):\n        # Assign each ship to a base based on the permutation index\n        valid = True\n        ship_to_base = {i: bases[p] for i, p in enumerate(perm)}\n        for i in range(R):\n            for j in range(i+1, R):\n                # Get the lines for ships i and j\n                s1 = ships[i]\n                b1 = ship_to_base[i]\n                s2 = ships[j]\n                b2 = ship_to_base[j]\n\n                # Check if the lines s1-b1 and s2-b2 intersect\n                def ccw(A, B, C):\n                    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\n                # Compute orientation\n                o1 = ccw(s1, b1, s2)\n                o2 = ccw(s1, b1, b2)\n                o3 = ccw(s2, b2, s1)\n                o4 = ccw(s2, b2, b1)\n\n                # General case: lines cross if (o1 != o2) and (o3 != o4)\n                if ((o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0)) and \\\n                   ((o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0)):\n                    valid = False\n                    break\n\n            if not valid:\n                break\n\n        if valid:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Perfect Matching Check**: If the number of spaceships does not match the number of bases, output \"No\".\n- **Permutations**: Generate all permutations of bases for spaceships to explore every possible assignment.\n- **Intersection Check**: For each permutation, check if any two paths intersect using the CCW (Counter-Clockwise) method to determine the orientation of points. If any permutation avoids intersections, print \"Yes\"; otherwise, print \"No\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr += 1\n    B = int(data[ptr])\n    ptr += 1\n\n    ships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ships.append((x, y))\n        ptr += 2\n\n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        bases.append((x, y))\n        ptr += 2\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Now, try all possible matchings\n    for perm in permutations(range(R)):\n        # Assign each ship to a base based on the permutation index\n        valid = True\n        ship_to_base = {i: bases[p] for i, p in enumerate(perm)}\n        for i in range(R):\n            for j in range(i+1, R):\n                # Get the lines for ships i and j\n                s1 = ships[i]\n                b1 = ship_to_base[i]\n                s2 = ships[j]\n                b2 = ship_to_base[j]\n\n                # Check if the lines s1-b1 and s2-b2 intersect\n                def ccw(A, B, C):\n                    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\n                # Compute orientation\n                o1 = ccw(s1, b1, s2)\n                o2 = ccw(s1, b1, b2)\n                o3 = ccw(s2, b2, s1)\n                o4 = ccw(s2, b2, b1)\n\n                # General case: lines cross if (o1 != o2) and (o3 != o4)\n                if ((o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0)) and \\\n                   ((o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0)):\n                    valid = False\n                    break\n\n            if not valid:\n                break\n\n        if valid:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 857,
        "thoughts_token_count": 1025
    }
}