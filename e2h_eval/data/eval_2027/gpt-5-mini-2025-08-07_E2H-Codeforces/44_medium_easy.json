{
    "start": 1758290654.7022052,
    "end": 1758290902.7112281,
    "start-formatted": "2025-09-19 23:04 KST",
    "end-formatted": "2025-09-19 23:08 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Analyzing maximum positions**\n\nI’m thinking about using dynamic programming (DP) for the positions of maxima. Turning points appear at places where new maxima occur. For a segment ending at i, the maximum is one of the elements in that segment. If I fix i, I can count distinct maxima by scanning backwards. I’m considering that the number of updates will be limited by distinct greater-than values, which could be up to 2000. This means the overall complexity ends up being O(n*V), around 4 million. Then I’ll need to consider how to approach further with j.",
    "response": "```unknown\nimport sys\nfrom array import array\n\nsys.setrecursionlimit(10000)\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\nit = iter(data)\nn = int(next(it)); k = int(next(it))\na = [0] + [int(next(it)) for _ in range(n)]  # 1-based\n\nINFNEG = -(10**18)\n\n# Segment tree with range add and range max query (stores index of max)\nsize = n\nseg_max = [INFNEG] * (4 * size + 10)\nseg_idx = [0] * (4 * size + 10)\nseg_lazy = [0] * (4 * size + 10)\n\ndef build(node, l, r, base):\n    if l == r:\n        seg_max[node] = base[l]\n        seg_idx[node] = l\n    else:\n        mid = (l + r) >> 1\n        build(node<<1, l, mid, base)\n        build(node<<1|1, mid+1, r, base)\n        if seg_max[node<<1] >= seg_max[node<<1|1]:\n            seg_max[node] = seg_max[node<<1]\n            seg_idx[node] = seg_idx[node<<1]\n        else:\n            seg_max[node] = seg_max[node<<1|1]\n            seg_idx[node] = seg_idx[node<<1|1]\n\ndef apply(node, val):\n    seg_max[node] += val\n    seg_lazy[node] += val\n\ndef push(node):\n    v = seg_lazy[node]\n    if v != 0:\n        apply(node<<1, v)\n        apply(node<<1|1, v)\n        seg_lazy[node] = 0\n\ndef range_add(node, l, r, ql, qr, val):\n    if ql > r or qr < l:\n        return\n    if ql <= l and r <= qr:\n        apply(node, val)\n        return\n    push(node)\n    mid = (l + r) >> 1\n    if ql <= mid:\n        range_add(node<<1, l, mid, ql, qr, val)\n    if qr > mid:\n        range_add(node<<1|1, mid+1, r, ql, qr, val)\n    if seg_max[node<<1] >= seg_max[node<<1|1]:\n        seg_max[node] = seg_max[node<<1]\n        seg_idx[node] = seg_idx[node<<1]\n    else:\n        seg_max[node] = seg_max[node<<1|1]\n        seg_idx[node] = seg_idx[node<<1|1]\n\ndef range_query(node, l, r, ql, qr):\n    if ql > r or qr < l:\n        return (INFNEG, -1)\n    if ql <= l and r <= qr:\n        return (seg_max[node], seg_idx[node])\n    push(node)\n    mid = (l + r) >> 1\n    left = (INFNEG, -1)\n    right = (INFNEG, -1)\n    if ql <= mid:\n        left = range_query(node<<1, l, mid, ql, qr)\n    if qr > mid:\n        right = range_query(node<<1|1, mid+1, r, ql, qr)\n    if left[0] >= right[0]:\n        return left\n    else:\n        return right\n\n# parents: store as array('H') for compactness, index j from 1..k, each stores parents for i=0..n\nparents = [None] * (k + 1)  # parents[j] is array of size n+1\n# dp_prev for p = 0..n-1\ndp_prev = [INFNEG] * n\ndp_prev[0] = 0  # using 0 segments for first 0 elements\n# for p>0 dp_prev is -inf for j=1 initial\n\nfor j in range(1, k+1):\n    # build segment tree from dp_prev[0..n-1]\n    build(1, 0, n-1, dp_prev)\n    st = []\n    pos = [0] * (n + 1)\n    parent = array('H', [0] * (n + 1))\n    dp_curr = [INFNEG] * (n + 1)\n    for i in range(1, n+1):\n        l = i - 1\n        # remove contributions of popped smaller-or-equal elements\n        while st and a[st[-1]] <= a[i]:\n            idx = st.pop()\n            left_pos = pos[idx]\n            # remove a[idx] contribution from its range\n            if left_pos <= idx-1:\n                range_add(1, 0, n-1, left_pos, idx-1, -a[idx])\n            l = left_pos\n        pos[i] = l\n        st.append(i)\n        if pos[i] <= i-1:\n            range_add(1, 0, n-1, pos[i], i-1, a[i])\n        # query best p in [0..i-1]\n        if i-1 >= 0:\n            best_val, best_p = range_query(1, 0, n-1, 0, i-1)\n            dp_curr[i] = best_val\n            parent[i] = best_p\n        else:\n            dp_curr[i] = INFNEG\n            parent[i] = 0\n    parents[j] = parent\n    # prepare dp_prev for next layer: dp_prev[p] = dp_curr[p] for p=0..n-1\n    dp_prev = [INFNEG] * n\n    for p in range(0, n):\n        dp_prev[p] = dp_curr[p]\n# result dp_prev[n] is dp_curr[n] after last layer? actually after last iteration dp_prev = dp_curr[0..n-1]\n# dp value for first n elements is dp_curr[n], which is stored in dp_prev[n-1]? No, dp_curr[n] kept in last parent loop variable.\n# Let's retrieve final dp value from last dp_curr stored implicitly: it's dp_prev for index n? We kept dp_curr local; but after loop ends j=k we can get dp_curr from dp_prev? Simpler recompute final dp value:\n# But we can obtain final dp value as parents[k] yields parent index for i=n and we can also query dp value from dp_prev? We didn't store dp_curr array after last iteration.\n# To get final dp value, we can compute it from parents and dp arrays by re-running small backtrack? However easiest is to keep last dp_curr value in variable last_dp_curr.\n# Let's recompute dp_curr for last j quickly: it's dp_prev (before assignment) not available. To fix, modify loop to keep last_dp_curr.\n\n# To avoid confusion, redo last loop slightly: We'll recompute final dp value by rebuilding dp for last j from parents[k].\n# We can simply run the DP one more time for j=k to get dp_curr (but that's duplicate). Instead, store dp_curr in variable during last iteration.\n# To implement minimal change, we recompute dp_curr now using stored dp_prev from previous step? But dp_prev currently corresponds to dp_curr of layer k, because at end of last iteration we set dp_prev = dp_curr. So dp_prev array holds dp_curr[0..n-1] for j=k.\n# dp value for first n elements is dp_curr[n] which was the value computed in last iteration for i=n; it equals dp_prev[n]?? dp_prev only has indices 0..n-1. dp_curr[n] isn't in dp_prev.\n# But dp_curr[n] equals best_val returned when i==n in last iteration; we can recompute it by querying parents[k] to get best_p and then look up dp_prev_before? Hard.\n# Simpler: recompute dp_curr_n by backtracking using parents arrays and base dp values.\n# However easiest is to recompute dp for last layer quickly by re-running the loop for j=k but only computing dp_curr[n]. Given constraints small, acceptable.\n\n# Recompute dp_curr for last j to get final value. We need dp_prev_base which is dp for j-1 segments: that's parents[k-1] chain? But we lost dp_prev for j-1. Simpler approach: reconstruct final answer by backtracking using parents arrays and dp values stored in leaves:\n# We can reconstruct partition points using parents arrays alone by backtracking:\ncur = n\nres = [0] * (k + 1)\nfor j in range(k, 0, -1):\n    p = parents[j][cur]\n    res[j] = cur - p\n    cur = p\n\n# To get total profit, compute sum of maxima per segment according to partition we found\nparts = []\nidx = 1\nfor seg_len in res[1:]:\n    parts.append((idx, idx+seg_len-1))\n    idx += seg_len\ntotal = 0\nfor l, r in parts:\n    total += max(a[l:r+1])\n\n# Output\nout = []\nout.append(str(total))\nout.append(\" \".join(str(x) for x in res[1:]))\nprint(\"\\n\".join(out))\n```",
    "ground_truth": "N/A",
    "extracted_answer": "unknown\nimport sys\nfrom array import array\n\nsys.setrecursionlimit(10000)\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\nit = iter(data)\nn = int(next(it)); k = int(next(it))\na = [0] + [int(next(it)) for _ in range(n)]  # 1-based\n\nINFNEG = -(10**18)\n\n# Segment tree with range add and range max query (stores index of max)\nsize = n\nseg_max = [INFNEG] * (4 * size + 10)\nseg_idx = [0] * (4 * size + 10)\nseg_lazy = [0] * (4 * size + 10)\n\ndef build(node, l, r, base):\n    if l == r:\n        seg_max[node] = base[l]\n        seg_idx[node] = l\n    else:\n        mid = (l + r) >> 1\n        build(node<<1, l, mid, base)\n        build(node<<1|1, mid+1, r, base)\n        if seg_max[node<<1] >= seg_max[node<<1|1]:\n            seg_max[node] = seg_max[node<<1]\n            seg_idx[node] = seg_idx[node<<1]\n        else:\n            seg_max[node] = seg_max[node<<1|1]\n            seg_idx[node] = seg_idx[node<<1|1]\n\ndef apply(node, val):\n    seg_max[node] += val\n    seg_lazy[node] += val\n\ndef push(node):\n    v = seg_lazy[node]\n    if v != 0:\n        apply(node<<1, v)\n        apply(node<<1|1, v)\n        seg_lazy[node] = 0\n\ndef range_add(node, l, r, ql, qr, val):\n    if ql > r or qr < l:\n        return\n    if ql <= l and r <= qr:\n        apply(node, val)\n        return\n    push(node)\n    mid = (l + r) >> 1\n    if ql <= mid:\n        range_add(node<<1, l, mid, ql, qr, val)\n    if qr > mid:\n        range_add(node<<1|1, mid+1, r, ql, qr, val)\n    if seg_max[node<<1] >= seg_max[node<<1|1]:\n        seg_max[node] = seg_max[node<<1]\n        seg_idx[node] = seg_idx[node<<1]\n    else:\n        seg_max[node] = seg_max[node<<1|1]\n        seg_idx[node] = seg_idx[node<<1|1]\n\ndef range_query(node, l, r, ql, qr):\n    if ql > r or qr < l:\n        return (INFNEG, -1)\n    if ql <= l and r <= qr:\n        return (seg_max[node], seg_idx[node])\n    push(node)\n    mid = (l + r) >> 1\n    left = (INFNEG, -1)\n    right = (INFNEG, -1)\n    if ql <= mid:\n        left = range_query(node<<1, l, mid, ql, qr)\n    if qr > mid:\n        right = range_query(node<<1|1, mid+1, r, ql, qr)\n    if left[0] >= right[0]:\n        return left\n    else:\n        return right\n\n# parents: store as array('H') for compactness, index j from 1..k, each stores parents for i=0..n\nparents = [None] * (k + 1)  # parents[j] is array of size n+1\n# dp_prev for p = 0..n-1\ndp_prev = [INFNEG] * n\ndp_prev[0] = 0  # using 0 segments for first 0 elements\n# for p>0 dp_prev is -inf for j=1 initial\n\nfor j in range(1, k+1):\n    # build segment tree from dp_prev[0..n-1]\n    build(1, 0, n-1, dp_prev)\n    st = []\n    pos = [0] * (n + 1)\n    parent = array('H', [0] * (n + 1))\n    dp_curr = [INFNEG] * (n + 1)\n    for i in range(1, n+1):\n        l = i - 1\n        # remove contributions of popped smaller-or-equal elements\n        while st and a[st[-1]] <= a[i]:\n            idx = st.pop()\n            left_pos = pos[idx]\n            # remove a[idx] contribution from its range\n            if left_pos <= idx-1:\n                range_add(1, 0, n-1, left_pos, idx-1, -a[idx])\n            l = left_pos\n        pos[i] = l\n        st.append(i)\n        if pos[i] <= i-1:\n            range_add(1, 0, n-1, pos[i], i-1, a[i])\n        # query best p in [0..i-1]\n        if i-1 >= 0:\n            best_val, best_p = range_query(1, 0, n-1, 0, i-1)\n            dp_curr[i] = best_val\n            parent[i] = best_p\n        else:\n            dp_curr[i] = INFNEG\n            parent[i] = 0\n    parents[j] = parent\n    # prepare dp_prev for next layer: dp_prev[p] = dp_curr[p] for p=0..n-1\n    dp_prev = [INFNEG] * n\n    for p in range(0, n):\n        dp_prev[p] = dp_curr[p]\n# result dp_prev[n] is dp_curr[n] after last layer? actually after last iteration dp_prev = dp_curr[0..n-1]\n# dp value for first n elements is dp_curr[n], which is stored in dp_prev[n-1]? No, dp_curr[n] kept in last parent loop variable.\n# Let's retrieve final dp value from last dp_curr stored implicitly: it's dp_prev for index n? We kept dp_curr local; but after loop ends j=k we can get dp_curr from dp_prev? Simpler recompute final dp value:\n# But we can obtain final dp value as parents[k] yields parent index for i=n and we can also query dp value from dp_prev? We didn't store dp_curr array after last iteration.\n# To get final dp value, we can compute it from parents and dp arrays by re-running small backtrack? However easiest is to keep last dp_curr value in variable last_dp_curr.\n# Let's recompute dp_curr for last j quickly: it's dp_prev (before assignment) not available. To fix, modify loop to keep last_dp_curr.\n\n# To avoid confusion, redo last loop slightly: We'll recompute final dp value by rebuilding dp for last j from parents[k].\n# We can simply run the DP one more time for j=k to get dp_curr (but that's duplicate). Instead, store dp_curr in variable during last iteration.\n# To implement minimal change, we recompute dp_curr now using stored dp_prev from previous step? But dp_prev currently corresponds to dp_curr of layer k, because at end of last iteration we set dp_prev = dp_curr. So dp_prev array holds dp_curr[0..n-1] for j=k.\n# dp value for first n elements is dp_curr[n] which was the value computed in last iteration for i=n; it equals dp_prev[n]?? dp_prev only has indices 0..n-1. dp_curr[n] isn't in dp_prev.\n# But dp_curr[n] equals best_val returned when i==n in last iteration; we can recompute it by querying parents[k] to get best_p and then look up dp_prev_before? Hard.\n# Simpler: recompute dp_curr_n by backtracking using parents arrays and base dp values.\n# However easiest is to recompute dp for last layer quickly by re-running the loop for j=k but only computing dp_curr[n]. Given constraints small, acceptable.\n\n# Recompute dp_curr for last j to get final value. We need dp_prev_base which is dp for j-1 segments: that's parents[k-1] chain? But we lost dp_prev for j-1. Simpler approach: reconstruct final answer by backtracking using parents arrays and dp values stored in leaves:\n# We can reconstruct partition points using parents arrays alone by backtracking:\ncur = n\nres = [0] * (k + 1)\nfor j in range(k, 0, -1):\n    p = parents[j][cur]\n    res[j] = cur - p\n    cur = p\n\n# To get total profit, compute sum of maxima per segment according to partition we found\nparts = []\nidx = 1\nfor seg_len in res[1:]:\n    parts.append((idx, idx+seg_len-1))\n    idx += seg_len\ntotal = 0\nfor l, r in parts:\n    total += max(a[l:r+1])\n\n# Output\nout = []\nout.append(str(total))\nout.append(\" \".join(str(x) for x in res[1:]))\nprint(\"\\n\".join(out))",
    "score": -1,
    "metadata": {
        "prompt_token_count": 938,
        "completion_token_count": 13240,
        "thoughts_token_count": 11264
    }
}