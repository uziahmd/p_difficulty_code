{
    "start": 1758308195.0130486,
    "end": 1758311722.1134157,
    "start-formatted": "2025-09-20 03:56 KST",
    "end-formatted": "2025-09-20 04:55 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n We need to assign each digit in the original number (from left to right) to either Homer (H) or Marge (M) for exactly n moves each.\n\n The catch: the total prize is the sum of two numbers S1 and S2 (each built by taking the leftmost available digit and appending it to their own number).\n\n Since the assignment must be exactly n moves for each, we are effectively partitioning the 2n-digit string into two strings of length n.\n\n However, note that the order of moves is fixed: we take the leftmost digit at each step. So the assignment is sequential.\n\n How do we think about it?\n\n Let's denote:\n   A = d0 d1 d2 ... d_{2n-1}\n\n In the game, at step i (0-indexed from 0 to 2n-1), we assign the digit d_i to either Homer or Marge.\n\n But note: the move of a player is determined by the entire sequence of digits they have collected so far.\n\n The value for Homer (S1) is the number formed by his digits in the order he received them, similarly for Marge.\n\n However, note that the problem does not require the maximum individual prize but the maximum total prize (S1 + S2). And also we must output the sequence of moves (a string of length 2n of 'H' and 'M').\n\n Observation:\n\n The total prize is the sum of two numbers. We can write:\n\n   S1 = h0 * 10^(n-1) + h1 * 10^(n-2) + ... + h_{n-1} * 10^0\n   S2 = m0 * 10^(n-1) + m1 * 10^(n-2) + ... + m_{n-1} * 10^0\n\n But note: the digits are taken from the original string in order. However, the assignment is arbitrary as long as each gets exactly n digits.\n\n But wait: the assignment is sequential. At step i, we decide whether to assign d_i to Homer or Marge. The catch is that the value of a digit in the final number depends on how many digits are assigned to that player after it.\n\n Actually, the first digit assigned to a player will be the most significant (multiplied by 10^(n-1)), then the next one by 10^(n-2), etc.\n\n However, note: the assignment is done in the order of the digits. So if we assign the j-th digit (0-indexed) to a player, then that digit will be placed at position (k) in that player's number, where k = (total number of digits assigned to that player so far) but actually we are building the number by appending at the end? \n\n Let me clarify: \n   Initially, both players have empty numbers (which we consider as 0).\n   On the first move, the first digit goes to the current player, so that player's number becomes that digit (so it's the most significant digit, multiplied by 10^(n-1)).\n   Then the next digit: if assigned to the same player, then it becomes the second most significant (so multiplied by 10^(n-2)), and so on.\n\n Therefore, the value of a player's number is determined by the order of assignment (the position in the sequence of assignments to that player) and the digit itself.\n\n However, note: the assignment is interleaved. But the entire set of digits is fixed.\n\n Alternate view:\n\n Let the entire assignment be represented by a string T of length 2n, with T[i] being either 'H' or 'M' for the i-th digit.\n\n Then, for Homer:\n   His digits are at positions i where T[i]=='H'. Let these positions (in increasing order) be i0, i1, ..., i_{n-1}. Then his number is:\n\n      S1 = d_{i0} * 10^(n-1 - (# of digits assigned to Homer before i0?)) ... \n\n Actually, no. The value of a digit in Homer's number is determined by when it was assigned relative to the other digits assigned to Homer. Specifically, the first time Homer is assigned (at index i0) is the most significant, then the next one (at index i1) is the next, etc.\n\n So the exponent for the digit at index i_k (the k-th digit assigned to Homer) is 10^(n-1-k).\n\n Similarly for Marge.\n\n Then the total prize is:\n\n   S1 + S2 = [sum_{k=0}^{n-1} (digit at the k-th Homer move) * (10^(n-1-k))] \n            + [sum_{k=0}^{n-1} (digit at the k-th Marge move) * (10^(n-1-k))]\n\n But note: the digits are taken from the fixed string A in order. The assignment T must be such that there are exactly n H's and n M's.\n\n However, the problem is asking for the sequence of moves (the string T) that maximizes the total prize.\n\n How to solve?\n\n Since n is at most 18 (so 2n <= 36), we cannot iterate over all C(36,18) possibilities (which is about 9e9) without dynamic programming.\n\n We can use DP with state (i, j, k) where:\n   i: the index we are processing (from 0 to 2n-1)\n   j: the number of moves Homer has made so far (from 0 to n)\n   k: the number of moves Marge has made so far (from 0 to n)\n\n But wait, we also need to know the current \"place values\" for the remaining moves? Actually, the total prize is additive and the contribution of a digit depends on how many moves the same player will make later (because that determines the power of 10 for that digit).\n\n Alternatively, we can consider:\n\n   Let F(i, j, k) be the maximum total prize we can achieve from the prefix up to index i, having assigned j moves to Homer and k moves to Marge.\n\n   But then we need to account for the fact that a digit assigned now will have a certain multiplier. The multiplier for a digit is 10^(remaining moves in the same player - 1) for the first assignment, then 10^(remaining moves - 2) for the next, etc.\n\n Actually, we can precompute the multiplier for a digit based on the total moves the player will make from that point onward.\n\n However, note: the total moves for Homer will be j (so far) plus (n - j) remaining. The digit we assign to Homer now will be the (j+1)-th digit for Homer, so its multiplier is 10^(n - (j+1)) because there will be (n - (j+1)) digits after it (so it will be the (j+1)-th most significant, meaning exponent = n - (j+1) - 1? Actually, let's see:\n\n   If we assign a digit to Homer when he has already j moves, then this digit will be the (j)-th digit (0-indexed) in his number. Then the multiplier for his j-th digit (0-indexed) is 10^(n-1-j).\n\n Similarly for Marge.\n\n Then the recurrence:\n\n   At state (i, j, k), we have processed i digits, and we have j moves for Homer and k for Marge.\n\n   Then the remaining moves for Homer: n - j, for Marge: n - k.\n\n   Now, if we assign the next digit (the i-th digit, which is A[i]) to Homer, then the contribution of this digit is: int(A[i]) * (10^(n-1-j)) [because j will become j+1, so the next digit will be the j-th (0-indexed) for Homer, and the exponent is n-1 - j? Actually, wait: j is the count so far, so if we assign this one, then it's the j-th digit (if we count from 0) and the exponent should be 10^(n-1 - j) because:\n\n        j=0: first digit -> 10^(n-1)\n        j=1: second digit -> 10^(n-2)\n        ...\n\n   So the exponent is 10^(n-1 - j) for the next move (if we assign to Homer, then j increases by 1, so the exponent is 10^(n-1 - j) for the current move).\n\n   Similarly, if we assign to Marge, the exponent is 10^(n-1 - k).\n\n   Then:\n\n      F(i, j, k) = max {\n          (if j < n) then F(i+1, j+1, k) + (digit_value * (10^(n-1-j))) else -infinity,\n          (if k < n) then F(i+1, j, k+1) + (digit_value * (10^(n-1-k))) else -infinity }\n\n   Base case: when i = 2n, then we have used all digits and j must be n and k must be n. Then the value is 0.\n\n   However, note: we are building the entire number, but the above recurrence adds the digit at the moment we assign it. This is correct because the multiplier for a digit is fixed once we know the total moves the player will make (and the order of assignment).\n\n   But wait: the multiplier for a digit assigned to Homer at the j-th move (so far j moves including this one) is 10^(n-1 - j) because there are j-1 digits already assigned and n-j digits to come, so the current digit is the j-th and will be multiplied by 10^(n-j) (if we count the total length as n, then the first digit is multiplied by 10^(n-1)). Actually, let's break down:\n\n        Example: n=2, then the multipliers for Homer's digits (if he gets two digits) are:\n          First digit: 10^1 (which is 10^(2-1) = 10^1)\n          Second digit: 10^0 (which is 10^(2-2) = 10^0)\n\n        So the exponent is (n - j) - 1? No, wait: the first digit (j=0) is at exponent 1 (which is n-1). The second (j=1) is at exponent 0 (n-1-1 = 1). So yes, the exponent is (n-1 - j) for the j-th assignment (0-indexed) for the same player.\n\n   Therefore, the recurrence is correct.\n\n   However, the state space is (2n+1) * (n+1) * (n+1) = 37 * 19 * 19 ~ 13000 states, which is acceptable.\n\n   But wait: we have to compute 10^(n-1-j) for exponents from 0 to n-1. Since n<=18, we can precompute the powers.\n\n   Steps:\n\n     1. Read n and A.\n     2. Precompute a list `powers` for exponents from 0 to n (actually from 0 to n-1) but we need exponents from 0 to n-1 (max exponent is n-1).\n     3. Use memoization (or DP table) to compute F(i, j, k).\n\n   However, note: the problem asks for the sequence of moves (the string T) that achieves the maximum total prize. We need to output the sequence.\n\n   We can store in the DP state the actual path (but that would be too heavy). Alternatively, we can do:\n\n        dp[i][j][k] = (max_total_prize, move_sequence)   [but storing string of length i is too heavy]\n\n   Alternatively, we can store the decision (whether the last move was H or M) and then backtrack.\n\n   We can do:\n\n        dp[i][j][k] = (max_total, last_move)   # but we need to remember the entire sequence.\n\n   Actually, we can store:\n\n        dp[i][j][k] = (max_total, prev_move)   # but then we don't know the whole sequence.\n\n   Instead, we can use backtracking: after computing the entire dp table, we start from state (0,0,0) and then go to (2n, n, n). Then we reconstruct the sequence.\n\n   Alternatively, we can store the entire sequence in the state, but that is 2^(2n) states which is too big.\n\n   Another idea: we only store the best value and then backtrack by knowing which move led to the maximum.\n\n   We can have:\n\n        dp[i][j][k] = maximum total prize from state (i, j, k) to the end.\n\n        Then, we also keep a separate table: choice[i][j][k] = either 'H' or 'M' that achieved the maximum.\n\n   Then, we can reconstruct the sequence from the end.\n\n   Steps for DP:\n\n        Let dp[i][j][k] = maximum total prize from the i-th digit onward, given that we have already assigned j moves to Homer and k moves to Marge.\n\n        Base: dp[2*n][n][n] = 0.\n\n        For i from 2*n-1 down to 0, and for j from 0 to n, k from 0 to n (with j+k <= 2*n-i? Actually, we are processing sequentially so we know i, j, k must satisfy j<=n, k<=n, and j+k <= i+1? Actually, we process one digit per step, so at step i, we have processed i+1 digits? Let me define:\n\n            i: the index we are about to process (0-indexed, from 0 to 2n-1). Then we have processed i digits.\n\n            Then state (i, j, k): we have processed i digits, and assigned j to Homer and k to Marge. Then j+k = i.\n\n        So actually, j+k == i.\n\n        Then the state is (i, j, k) with j+k == i, and j in [0, n], k in [0, n].\n\n        Then we can reduce the state to (i, j) since k = i - j.\n\n        Then the recurrence:\n\n            dp[i][j] = maximum total prize from the prefix [0:i] and we have j moves for Homer, so k = i - j for Marge.\n\n            Then, for the next digit (the i-th digit, which is A[i]), we can assign to Homer if j < n, then:\n\n                add = int(A[i]) * (10**(n-1-j))   [because j is the count of Homer's moves so far (not including this one), so if we assign this one, it's the (j)-th move (0-indexed) for Homer, and the exponent is n-1-j.\n\n                Then: candidate_H = dp[i+1][j+1] + add\n\n            Similarly for Marge: candidate_M = dp[i+1][j] (but then k becomes k+1, so j remains j, and k becomes i-j+1) but note: k = i-j, then after assigning to Marge, k_new = k+1, so the next state is (i+1, j) but then k_new = i+1 - j. Actually, we can use the same reduction: state (i+1, j) implies that the number of Marge moves is (i+1) - j.\n\n            Then: candidate_M = dp[i+1][j] + (int(A[i]) * (10**(n-1 - (i-j))))   [because for Marge, the count of moves so far is k = i-j, so the exponent is n-1 - (i-j)]\n\n        However, wait: the exponent for Marge's move is based on the count of Marge moves so far (which is k = i-j). So if we assign the i-th digit to Marge, then the exponent is 10^(n-1 - (i-j)).\n\n        Then:\n\n            dp[i][j] = max( candidate_H, candidate_M )   [if both are valid]\n\n        But note: we must check that j < n for candidate_H and (i-j) < n (i.e., j > i-n) for candidate_M.\n\n        However, note that j must be at least 0 and at most n, and k = i-j must be between 0 and n. So conditions:\n\n            For candidate_H: j < n\n            For candidate_M: i-j < n  => j > i-n\n\n        Also, we must ensure that we don't exceed n for either.\n\n        Then base condition: when i = 2*n, then j must be n and k must be n (i.e., j = 2*n - j => j = n). Then dp[2*n][n] = 0.\n\n        Then we traverse i from 2*n-1 down to 0, and for each i, j from max(0, i-n+1) to min(n, i) [since k = i-j must be <= n, so j>= i-n, and j<=n, and j>=0 and j<=i].\n\n        Then we can store:\n\n            dp[i][j] = maximum total prize from state (i, j) to the end.\n\n            and we also store a choice[i][j] = the move we made at step i (either 'H' or 'M')\n\n        Then, after filling the dp table, we can reconstruct the sequence:\n\n            Start at i=0, j=0.\n            For i from 0 to 2*n-1:\n                if choice[i][j] == 'H':\n                    then next state is (i+1, j+1)\n                else:\n                    then next state is (i+1, j)\n\n            But wait, we stored the choice at step i (processing the i-th digit) for the state (i, j). Then we can build the string.\n\n        However, note: we are storing the choice for state (i, j) as the move for the i-th digit.\n\n        Steps:\n\n            Precompute powers: \n                Let power_table = { exponent: 10**exponent }\n                We need exponents from 0 to n-1.\n\n            Then:\n\n                dp = 2D array for i in range(0, 2*n+1) and j in range(0, n+1)\n                dp[2*n][n] = 0   (only state (2*n, n) is valid)\n\n                Then for i from 2*n-1 down to 0, and for j from max(0, i-n) to min(n, i) [because k = i-j must be between 0 and n, so j from max(0, i-n) to min(i, n)].\n\n                Then:\n\n                    candidate_H = -10**20\n                    candidate_M = -10**20\n\n                    If j < n:\n                        exponent_H = n - 1 - j   # because j is the current count for Homer (so far, without this digit) and the next move (if we choose H) will be the j-th move (0-indexed) for Homer, so exponent is n-1-j.\n                        add_H = int(A[i]) * (10 ** exponent_H)\n                        candidate_H = dp[i+1][j+1] + add_H\n\n                    If i - j < n:   # meaning Marge has less than n moves so far (so we can assign one more)\n                        exponent_M = n - 1 - (i - j)   # because the current count for Marge is (i-j) (so far, without this digit) and we are going to assign one more, so the exponent is n-1 - (i-j)\n                        add_M = int(A[i]) * (10 ** exponent_M)\n                        candidate_M = dp[i+1][j] + add_M   # note: in the next state, the count for Homer remains j, and the count for Marge becomes (i-j)+1, but we store state by (i+1, j) and then k = (i+1)-j, so that is consistent.\n\n                    Then dp[i][j] = max(candidate_H, candidate_M)   [if one candidate is invalid, skip it]\n\n                    And set choice[i][j] = 'H' if candidate_H >= candidate_M and candidate_H != -10**20, otherwise 'M'\n\n            Then, to reconstruct:\n\n                s = []\n                i = 0\n                j = 0\n                while i < 2*n:\n                    if choice[i][j] == 'H':\n                        s.append('H')\n                        j += 1\n                    else:\n                        s.append('M')\n                    i += 1\n\n                Then output ''.join(s)\n\n        However, wait: in the state (i, j) we are processing the i-th digit (0-indexed) and we have j moves for Homer so far (from the first i digits). Then the exponent for Homer's move is n-1-j (because j is the count so far, and if we assign this one, it becomes the j-th move (0-indexed) for Homer, so the exponent is n-1-j.\n\n        But note: the total moves for Homer is j (so far) and the remaining moves are n - j. The digit we are assigning now will be the (j)-th digit (so far) and will be multiplied by 10^(n-1-j). This is correct.\n\n        But wait: what if we assign a digit to Marge? Then the exponent is n-1 - (i-j) because the current count for Marge is (i-j) (so far) and we are going to assign one more, so the new count for Marge is (i-j)+1, but the exponent is determined by the current count (before adding) for Marge? Actually, no: the exponent for Marge's next move is n-1 minus the current count (which is i-j). Because the next move for Marge will be the (i-j)-th move (0-indexed) for Marge (if we consider that the next move is the (i-j+1)-th in total, but wait: we are using the count so far (without the current) to determine the exponent.\n\n        This is consistent: the first move for Marge (when the current count is 0) gets exponent n-1. The second (current count is 1) gets exponent n-2, etc.\n\n        However, note: the current count for Marge is (i-j). Then the next move (if we assign to Marge) will be the (i-j)-th move (0-indexed) for Marge, so the exponent is n-1 - (i-j). But wait, if we assign the digit to Marge, then we are making the (i-j+1)-th move for Marge? Actually, no: the count we are using is the number of Marge moves so far (before this one). Then the next one is the (i-j+1)-th move? But then the exponent for the (i-j+1)-th move should be n - (i-j+1) - 1? \n\n        Let me clarify with example: n=2, and we are at i=0, j=0, then k=0. Then if we assign to Marge, then her count becomes 1. The exponent for her first move is 10^(2-1-0)=10^1. Then if we are at i=1, j=0, k=1, and we assign the next digit to Marge again, then her count becomes 2, and the exponent is 10^(2-1-1)=10^0.\n\n        But wait, the second digit assigned to Marge is the second digit in her number, so it should be the least significant. That matches.\n\n        However, note: the example input:\n\n            Input: ['2\\n1234', '2\\n9911']\n\n        For \"1234\", n=2, A=\"1234\".\n\n        Let's simulate:\n\n            Step0: i=0, j=0, k=0. Digit '1'\n                Option H: exponent = n-1-0 = 1 -> 1*10 = 10\n                Option M: exponent = n-1-0 = 1 -> 1*10 = 10\n\n            Step1: i=1, j=1, k=0 (if we chose H at step0) or j=0, k=1 (if we chose M at step0). Then we continue.\n\n        But the example output for \"1234\" is \"HHMM\". \n\n        How does \"HHMM\" work?\n\n            Homer gets the first two digits: \"12\", so his number is 12.\n            Marge gets the last two: \"34\", so her number is 34.\n\n            Total prize = 12 + 34 = 46.\n\n        Now, if we choose \"HMHM\":\n\n            Step0: H -> 1 * 10^1 = 10\n            Step1: M -> 2 * 10^1 (because for Marge: current count is 0, so exponent=1) -> 20, total=30\n            Step2: H -> 3 * 10^0 (because for Homer: current count is 1, so exponent=0) -> 3, total=33\n            Step3: M -> 4 * 10^0 (because for Marge: current count is 1, so exponent=0) -> 4, total=37.\n\n        But wait, 37 is greater than 46? \n\n        Actually, wait: the example input provided two examples:\n\n            Input: \n                2\n                1234\n            Output: \n                HHMM\n\n            Input:\n                2\n                9911\n            Output:\n                HMHM\n\n        But note: the example output for the first input is 'HHMM', and for the second is 'HMHM'. \n\n        Why is 46 the maximum for \"1234\"? \n\n        Let's try all possibilities for n=2, A=\"1234\":\n\n            Possibilities: all sequences of two H and two M.\n\n            HHMM: 12 + 34 = 46\n            HMHM: 13 + 24 = 37\n            HMMH: 14 + 23 = 37\n            MHMH: 21 + 34 = 55 -> wait, 21+34=55, which is even higher?\n            MHHM: 23 + 14 = 37\n            MMHH: 24 + 13 = 37\n\n        Actually, I see: the example output says for input \"1234\" output \"HHMM\", but according to my calculation, \"MHMH\" gives 55, which is better.\n\n        But wait, let's break down \"MHMH\":\n\n            Step0: assign the first digit '1' to Marge -> Marge gets '1', then her number is 1 (which is 1*10^(1) = 10) -> no, wait the multiplier for the first move (for Marge) is 10^(2-1-0)=10^1, so 1*10 = 10.\n\n            Step1: assign the second digit '2' to Homer -> Homer gets '2', then his number is 2 (which is 2*10^(2-1-0)=2*10^1=20) -> wait, but Homer hasn't had any move before? \n\n            Actually, in our recurrence, for Homer at step1 (i=1, j=1) the exponent is n-1-1 = 2-1-1 = 0? \n\n            Let me recalc the recurrence:\n\n                For Homer at state (i, j): the exponent is n-1 - j (where j is the number of moves Homer has made so far, not including the current one).\n\n            Then for \"MHMH\":\n\n                Step0: i=0, j=0, k=0 -> assign to M: j remains 0, k becomes 1. Exponent for M: n-1 - (i-j) = n-1-0 = 1 -> 1*10 = 10.\n\n                Step1: i=1, j=0, k=1 -> assign to H: exponent for H: n-1 - j = 2-1-0 = 1 -> 2*10 = 20.\n\n                Step2: i=2, j=1, k=1 -> assign to M: exponent for M: n-1 - (i-j) = 2-1 - (2-1) = 1 - 1 = 0 -> 3*1 = 3.\n\n                Step3: i=3, j=1, k=2 -> assign to H: exponent for H: n-1 - j = 2-1-1 = 0 -> 4*1 = 4.\n\n                Total = 10+20+3+4 = 37.\n\n            Wait, that doesn't match my manual calculation.\n\n        Let me do manually:\n\n            MHMH: \n                Marge: first and third digits: '1' and '3' -> the number is 13 (because the first digit is the most significant and the third digit is the next) -> 1*10 + 3 = 13.\n                Homer: second and fourth digits: '2' and '4' -> 2*10 + 4 = 24.\n                Total = 13+24 = 37.\n\n        But wait, the example I did earlier for \"MHMH\" was 21+34=55, which is incorrect. I must have swapped the digits.\n\n        Actually, the assignment is:\n\n            Step0: first digit '1' -> M -> Marge gets '1'\n            Step1: second digit '2' -> H -> Homer gets '2'\n            Step2: third digit '3' -> M -> Marge gets '3' (so now Marge's number is 13)\n            Step3: fourth digit '4' -> H -> Homer gets '4' (so Homer's number is 24)\n\n        So total 13+24=37.\n\n        Now, why did I think 21 and 34? \n\n        Let me try \"MHMH\" again but with a different interpretation: \n\n            The problem says: \"On its turn i-th player takes the leftmost digit of A and appends it to his or her number Si.\"\n\n            The sequence of moves: \n                Start: A = \"1234\"\n                Move0: M -> remove the leftmost, so A becomes \"234\", and Marge's number is \"1\".\n                Move1: H -> remove the leftmost, so A becomes \"34\", and Homer's number is \"2\".\n                Move2: M -> remove the leftmost, so A becomes \"4\", and Marge's number is \"13\".\n                Move3: H -> remove the leftmost, so A becomes \"\", and Homer's number is \"24\".\n\n        So indeed, Marge's number is \"13\", not \"31\". \n\n        The digits are appended in the order of removal, so the first digit Marge gets is the first one, then the third, etc.\n\n        Therefore, the exponent for a digit is determined by the order in which they are assigned (the first assigned is the most significant).\n\n        Now, let's recalc for \"HHMM\":\n\n            Step0: H -> Homer's number becomes \"1\", A becomes \"234\"\n            Step1: H -> Homer's number becomes \"12\", A becomes \"34\"\n            Step2: M -> Marge's number becomes \"3\", A becomes \"4\"\n            Step3: M -> Marge's number becomes \"34\", A becomes \"\"\n\n            Total: 12 + 34 = 46.\n\n        Now, what about \"MMHH\"?\n\n            Step0: M -> Marge: \"1\", A=\"234\"\n            Step1: M -> Marge: \"12\", A=\"34\"\n            Step2: H -> Homer: \"3\", A=\"4\"\n            Step3: H -> Homer: \"34\", A=\"\"\n\n            Total: 12 + 34 = 46.\n\n        And \"HMMH\": \n            Step0: H -> \"1\", A=\"234\"\n            Step1: M -> \"2\", Marge: \"2\", A=\"34\"\n            Step2: M -> \"3\", Marge: \"23\", A=\"4\"\n            Step3: H -> \"4\", Homer: \"14\", A=\"\"\n            Total: 14 + 23 = 37.\n\n        And \"MHHM\":\n            Step0: M -> \"1\", A=\"234\"\n            Step1: H -> \"2\", Homer: \"2\", A=\"34\"\n            Step2: H -> \"3\", Homer: \"23\", A=\"4\"\n            Step3: M -> \"4\", Marge: \"14\", A=\"\"\n            Total: 23 + 14 = 37.\n\n        And \"HMHM\":\n            Step0: H -> \"1\", A=\"234\"\n            Step1: M -> \"2\", Marge: \"2\", A=\"34\"\n            Step2: H -> \"3\", Homer: \"13\", A=\"4\"\n            Step3: M -> \"4\", Marge: \"24\", A=\"\"\n            Total: 13 + 24 = 37.\n\n        So the maximum is 46, achieved by \"HHMM\", \"MMHH\", and also note: what about \"HMHM\" and others? They are 37.\n\n        But wait, there are two sequences that yield 46: \"HHMM\" and \"MMHH\".\n\n        The problem says: \"If there are several solutions, output any of them.\"\n\n        So we can output \"HHMM\".\n\n        However, note: our DP computed:\n\n            dp[0][0] = max( candidate_H, candidate_M ) \n            candidate_H = dp[1][1] + 1 * 10^(1) = dp[1][1] + 10\n            candidate_M = dp[1][0] + 1 * 10^(1) = dp[1][0] + 10\n\n            Now, what is dp[1][1]? (i=1, j=1) -> \n                candidate_H: j=1 <2 -> dp[2][2] + 2 * 10^(2-1-1)=2 * 10^0 = 2, and dp[2][2]=0 -> 2.\n                candidate_M: i=1, j=1 -> k=0, and 0<2 -> dp[2][1] + 2 * 10^(2-1-0)=2 * 10^1=20. But wait, dp[2][1] is the state (i=2, j=1) -> then k=1, and we haven't computed that.\n\n            We need to compute for i=2, j from max(0,2-2)=0 to min(2,2)=2.\n\n            Let me compute for i=2:\n\n                j=0: k=2 -> only candidate: assign the third digit (A[2]=='3') to H (if j<2) and M (if k<2) -> but k=2, so cannot assign to M. \n                    candidate_H: dp[3][1] + 3 * 10^(2-1-0)=3*10^1=30.\n\n                j=1: k=1 -> both allowed.\n                    candidate_H: dp[3][2] + 3 * 10^(2-1-1)=3*10^0=3.\n                    candidate_M: dp[3][1] + 3 * 10^(2-1-1)=3*10^0=3.\n\n                j=2: k=0 -> only candidate_M: dp[3][2] + 3 * 10^(2-1-0)=3*10^1=30.\n\n            Then for i=1, j=1: \n                candidate_H = 2 + 2 = 4\n                candidate_M = dp[2][1] + 20 -> dp[2][1] = max( candidate_H for j=1 at i=2: 3, candidate_M for j=1 at i=2: 3 ) = 3, so candidate_M = 3+20=23.\n\n                Then dp[1][1] = max(4,23) = 23, and choice[1][1]='M'\n\n            Then for i=0, j=0:\n                candidate_H = dp[1][1] + 10 = 23+10=33.\n                candidate_M = dp[1][0]",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns selecting digits from a given number A. The players alternately pick the leftmost digit of A, appending it to their respective numbers. The goal is to partition the digits of A into two subsequences of length n each (since each player makes exactly n moves) such that the sum of the two resulting numbers is maximized.\n\n### Approach\n1. **Dynamic Programming (DP) Setup**: We use a DP approach where the state `dp[i][j]` represents the maximum total prize achievable from the first `i` digits of A, with `j` moves assigned to Homer so far. The remaining moves for Marge would then be `i - j`.\n\n2. **State Transition**: For each state `(i, j)`, we consider two choices:\n   - **Assign the next digit to Homer**: The digit's value is multiplied by `10^(n-1-j)` (since it will be the `j-th` digit in Homer's number). The next state is `(i+1, j+1)`.\n   - **Assign the next digit to Marge**: The digit's value is multiplied by `10^(n-1-(i-j))` (since it will be the `(i-j)-th` digit in Marge's number). The next state is `(i+1, j)`.\n\n3. **Base Case**: When all digits are processed (`i = 2n`), the total prize is zero if exactly `n` moves have been made by each player (`j = n`).\n\n4. **Reconstruction**: After filling the DP table, we backtrack from the initial state `(0, 0)` to construct the sequence of moves (either 'H' or 'M') that achieves the maximum prize.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0].strip())\n    A = data[1].strip()\n    \n    total_digits = 2 * n\n    dp = [[-1] * (n+1) for _ in range(total_digits+1)]\n    choice = [[''] * (n+1) for _ in range(total_digits+1)]\n    \n    dp[total_digits][n] = 0\n    \n    for i in range(total_digits-1, -1, -1):\n        for j in range(max(0, i - n + 1), min(n, i) + 1):\n            candidate_H = -1\n            candidate_M = -1\n            \n            if j < n:\n                exponent_H = n - 1 - j\n                add_H = int(A[i]) * (10 ** exponent_H)\n                next_state_H = i + 1\n                next_j_H = j + 1\n                if dp[next_state_H][next_j_H] != -1:\n                    candidate_H = dp[next_state_H][next_j_H] + add_H\n                    \n            if (i - j) < n:\n                exponent_M = n - 1 - (i - j)\n                add_M = int(A[i]) * (10 ** exponent_M)\n                next_state_M = i + 1\n                next_j_M = j\n                if dp[next_state_M][next_j_M] != -1:\n                    candidate_M = dp[next_state_M][next_j_M] + add_M\n                    \n            best_val = -1\n            if candidate_H == -1 and candidate_M == -1:\n                dp[i][j] = -1\n                continue\n                \n            if candidate_H == -1:\n                dp[i][j] = candidate_M\n                choice[i][j] = 'M'\n            elif candidate_M == -1:\n                dp[i][j] = candidate_H\n                choice[i][j] = 'H'\n            else:\n                if candidate_H > candidate_M:\n                    dp[i][j] = candidate_H\n                    choice[i][j] = 'H'\n                else:\n                    dp[i][j] = candidate_M\n                    choice[i][j] = 'M'\n                    \n    seq = []\n    i = 0\n    j = 0\n    while i < total_digits:\n        if choice[i][j] == 'H':\n            seq.append('H')\n            j += 1\n        else:\n            seq.append('M')\n        i += 1\n        \n    print(''.join(seq))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` (number of moves per player) and a string `A` (the number with 2n digits).\n2. **DP Initialization**: The DP table `dp[i][j]` is initialized to store the maximum prize achievable from the first `i` digits with `j` moves for Homer. The `choice` table keeps track of whether the next move was 'H' or 'M'.\n3. **Backward DP Fill**: Starting from the end (all digits processed), the DP table is filled by considering both possible moves (Homer or Marge) for each digit, calculating the contribution to the total prize based on the digit's position in the respective player's number.\n4. **Backtracking**: The solution reconstructs the sequence of moves by following the choices stored in the `choice` table from the initial state `(0, 0)` to the end.\n5. **Output**: The reconstructed sequence of 'H' and 'M' characters is printed, representing the optimal moves for Homer and Marge to maximize their combined prize.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0].strip())\n    A = data[1].strip()\n    \n    total_digits = 2 * n\n    dp = [[-1] * (n+1) for _ in range(total_digits+1)]\n    choice = [[''] * (n+1) for _ in range(total_digits+1)]\n    \n    dp[total_digits][n] = 0\n    \n    for i in range(total_digits-1, -1, -1):\n        for j in range(max(0, i - n + 1), min(n, i) + 1):\n            candidate_H = -1\n            candidate_M = -1\n            \n            if j < n:\n                exponent_H = n - 1 - j\n                add_H = int(A[i]) * (10 ** exponent_H)\n                next_state_H = i + 1\n                next_j_H = j + 1\n                if dp[next_state_H][next_j_H] != -1:\n                    candidate_H = dp[next_state_H][next_j_H] + add_H\n                    \n            if (i - j) < n:\n                exponent_M = n - 1 - (i - j)\n                add_M = int(A[i]) * (10 ** exponent_M)\n                next_state_M = i + 1\n                next_j_M = j\n                if dp[next_state_M][next_j_M] != -1:\n                    candidate_M = dp[next_state_M][next_j_M] + add_M\n                    \n            best_val = -1\n            if candidate_H == -1 and candidate_M == -1:\n                dp[i][j] = -1\n                continue\n                \n            if candidate_H == -1:\n                dp[i][j] = candidate_M\n                choice[i][j] = 'M'\n            elif candidate_M == -1:\n                dp[i][j] = candidate_H\n                choice[i][j] = 'H'\n            else:\n                if candidate_H > candidate_M:\n                    dp[i][j] = candidate_H\n                    choice[i][j] = 'H'\n                else:\n                    dp[i][j] = candidate_M\n                    choice[i][j] = 'M'\n                    \n    seq = []\n    i = 0\n    j = 0\n    while i < total_digits:\n        if choice[i][j] == 'H':\n            seq.append('H')\n            j += 1\n        else:\n            seq.append('M')\n        i += 1\n        \n    print(''.join(seq))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 1189,
        "thoughts_token_count": 8190
    }
}