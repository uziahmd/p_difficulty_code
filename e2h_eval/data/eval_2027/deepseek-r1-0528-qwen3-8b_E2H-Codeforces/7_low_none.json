{
    "start": 1758089056.1962433,
    "end": 1758090354.2178469,
    "start-formatted": "2025-09-17 15:04 KST",
    "end-formatted": "2025-09-17 15:25 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\n We are given a number of test cases. For each test case, an integer `n` (from 1 to 10^18) is provided.\n\n We need to determine if there exists an integer `k > 1` such that a snowflake graph with `n` vertices can be constructed.\n\n The snowflake construction:\n\n   Step 0: Start with one vertex (the center).\n\n   Step 1: Add k new vertices, each connected to the center. Now we have 1 + k vertices.\n\n   Step 2: Then, each vertex that currently has degree 1 (i.e., the leaves from step 1) will be used to add k new vertices (unless we stop at some point). However, note that the process must be done at least once (so we do step 1 at minimum).\n\n But note: the problem says \"Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\" \n\n However, the example for k=4 shows a snowflake that has a center and then four arms, and in each arm there are 3 levels (so 1 center, then 4, then 4*3, then 4*3*3). Actually, wait: the example says the smallest for k=4? Let me clarify:\n\n Actually, the problem says the smallest for k=4 is shown. The smallest for k=4 would be just two steps? Or one step?\n\n Let me re-read: \n   - Initially, one vertex.\n   - Then, connect to k new vertices (so we have 1+k).\n   - Then, each leaf (which now are connected only to the center) is connected to k new vertices. But note: if we do this step at least once, then the minimal snowflake for k=4 would have 1 + 4 + 4*4 = 1+4+16 = 21 vertices? \n\n Actually, wait: the problem says \"This step should be done at least once\", meaning we do the second step at least once. So the minimal snowflake for k=4 has two layers: center, then k, then k*k. So total vertices: 1 + k + k*k.\n\n However, note: the problem says \"Each vertex that is connected to only one other vertex\" is connected to k more. In the first step, the center has degree k, so it's not connected to only one. The leaves (the k ones) have degree 1. Then we add k new vertices for each leaf, so each leaf becomes of degree 1 (from the center) + k (from its children) -> so then they become non-leaf. Then the new leaves are the ones we just added. But the process is done at least once, meaning we must have at least two layers (center and two rings: the first ring of k and the second ring of k*k).\n\n However, note: the problem doesn't specify how many times we do the expansion. We can do it multiple times. But the condition is that we do the expansion step (the one that adds k new vertices per leaf) at least once. So the minimal is two layers (center and one ring of leaves, then one more expansion). But we can do more than one expansion beyond the first.\n\n Therefore, the snowflake can have any number of layers (at least two: center and one expansion, then possibly more). \n\n How to model the total number of vertices?\n\n Let the number of expansions (layers) be `r`. Then the number of vertices is:\n\n   n = 1 + k + k*k + ... + k^r   [if we do r expansions, then we have r+1 layers: the center (layer0), layer1: k, layer2: k^2, ...]\n\n But note: the problem says the first expansion (step 1) is mandatory, and then the next expansion (step 2) is also mandatory (at least once). So we must have at least two layers: so r>=1 (meaning we do the expansion at least once, so two layers: center and the first ring, but wait: the initial expansion is step1 (which gives k) and then step2 is the expansion for the leaves (which gives k^2). So the minimal expansion is two layers (center and two rings) but actually:\n\n   Layer0: 1\n   After step1: Layer1: k -> total 1+k\n   After step2: Layer2: k*k -> total 1+k+k*k\n\n But note: the problem says \"Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices (k>1). Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done",
    "response": "\nTo solve this problem, we need to determine if a given number of vertices `n` can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in layers, starting from a central vertex and expanding outward in a specific manner. The key observation is that the total number of vertices in such a graph must satisfy certain mathematical conditions based on the expansion parameter `k` (where `k > 1`).\n\n### Approach\n1. **Problem Analysis**: The snowflake graph is built in layers. The first layer (center) has 1 vertex. Each subsequent layer adds `k` vertices for each vertex in the previous layer that has only one connection (a leaf). The minimal snowflake requires at least two layers (center plus one expansion), but more layers are possible. The total number of vertices after `r` expansions is given by the geometric series sum: \\( n = 1 + k + k^2 + \\ldots + k^r \\).\n\n2. **Key Insight**: For `n` to be expressible as the sum of a geometric series with base `k > 1`, it must satisfy \\( n = \\frac{k^{r+1} - 1}{k - 1} \\) for some integers `k > 1` and `r >= 1`. However, directly checking all possible `k` values up to `n` is infeasible for large `n` (up to \\(10^{18}\\)).\n\n3. **Optimization**: Instead of iterating over all possible `k`, we recognize that for a fixed `r`, `k` must be a root of the equation \\( k^{r+1} = n(k-1) + 1 \\). Since `r` can vary, we consider small values of `r` (from 2 to a maximum where \\( k^{r+1} \\) remains manageable). For each `r`, we solve for `k` and check if it is an integer greater than 1.\n\n4. **Edge Cases**: \n   - If `n` is 1, the only possible snowflake is the trivial case with no expansions, which is invalid (since `k > 1` is required).\n   - For other small values of `n`, we check if they can be expressed as the sum of a geometric series with integer `k > 1`.\n\n### Solution Code\n```python\nimport math\n\ndef solve_case(n):\n    if n < 7:\n        return \"NO\"\n    \n    r = 2\n    while True:\n        low = 2\n        high = 10**6 + 100000\n        found = False\n        while high - low > 1:\n            mid = (low + high) // 2\n            total = (mid ** (r+1) - 1) // (mid - 1)\n            if total == n:\n                return \"YES\"\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid\n        \n        if (low ** (r+1) - 1) // (low - 1) == n:\n            return \"YES\"\n        r += 1\n        if r > 100:\n            break\n            \n    return \"NO\"\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    out_lines = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index]); index += 1\n        res = solve_case(n)\n        out_lines.append(res)\n        \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Initial Check**: For small values of `n` (less than 7), the answer is immediately \"NO\" because the minimal snowflake requires at least 7 vertices (for example, with `k=2` and two expansions: \\(1 + 2 + 4 = 7\\)).\n\n2. **Binary Search for `k`**: For each possible number of expansions `r` (starting from 2), the code performs a binary search to find an integer `k > 1` such that the sum of the geometric series \\(1 + k + k^2 + \\ldots + k^r\\) equals `n`. \n\n3. **Termination Condition**: The loop terminates if no valid `k` is found after checking a reasonable number of expansions (`r` up to 100), ensuring efficiency even for very large `n`.\n\n4. **Output**: For each test case, the solution checks if `n` can be expressed as the sum of a geometric series with integer base `k > 1` and outputs \"YES\" or \"NO\" accordingly.\n\nThis approach efficiently narrows down the possible values of `k` and `r` using mathematical insights and binary search, making it feasible to handle the large input constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve_case(n):\n    if n < 7:\n        return \"NO\"\n    \n    r = 2\n    while True:\n        low = 2\n        high = 10**6 + 100000\n        found = False\n        while high - low > 1:\n            mid = (low + high) // 2\n            total = (mid ** (r+1) - 1) // (mid - 1)\n            if total == n:\n                return \"YES\"\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid\n        \n        if (low ** (r+1) - 1) // (low - 1) == n:\n            return \"YES\"\n        r += 1\n        if r > 100:\n            break\n            \n    return \"NO\"\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    out_lines = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index]); index += 1\n        res = solve_case(n)\n        out_lines.append(res)\n        \n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 548,
        "completion_token_count": 1046,
        "thoughts_token_count": 1023
    }
}