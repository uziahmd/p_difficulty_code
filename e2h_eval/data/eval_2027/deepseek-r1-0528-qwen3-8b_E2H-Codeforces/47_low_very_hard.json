{
    "start": 1758296004.403214,
    "end": 1758298840.2244408,
    "start-formatted": "2025-09-20 00:33 KST",
    "end-formatted": "2025-09-20 01:20 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k give the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, we can assume a >= b by swapping if needed? Actually, note: we have two numbers: (a+k) and (b+k). The LCM is symmetric in the two numbers, but note: if we swap a and b, then k must also be adjusted? Actually, note that the problem doesn't specify order, so we can consider:\n\nBut note: if we let x = a+k and y = b+k, then x-y = a-b is fixed. So without loss of generality, we can assume a>=b, otherwise we swap the roles. However, note that k is the same offset for both. Alternatively, we can note that the LCM of two numbers x and y is |x*y| / GCD(x,y). Since x*y = (a+k)*(b+k) and GCD(x,y) = GCD(a+k, b+k) = GCD(a+k, (b+k)-(a+k)) = GCD(a+k, b-a). Similarly, if we define g = |b-a|, then GCD(a+k, b+k) divides g.\n\nSo, the key observation: Let d = |a-b|. Then, the GCD(a+k, b+k) must divide d. Therefore, the GCD is a divisor of d.\n\nWe are to minimize LCM(x,y) = (x*y) / GCD(x,y). Since x*y = (a+k)*(b+k) = (a+k)*(a+k + d) [if a>=b, then d = a-b, else d = b-a] but actually we can set d = abs(a-b). Then, note:\n\nLet d = |a-b|. Then, we have:\n  LCM((a+k), (b+k)) = ((a+k)*(b+k)) / GCD(a+k, b+k)\n\nBut note: GCD(a+k, b+k) = GCD(a+k, d). So, for a fixed divisor g of d, we want to find the smallest k>=0 such that g divides both (a+k) and (b+k). This condition is equivalent to: g divides (a+k) and g divides (b+k). Since (a+k) - (b+k) = d, and g divides d, then if g divides (a+k) then it automatically divides (b+k) because (b+k) = (a+k) - d, and d is divisible by g.\n\nActually, the condition is that (a+k) mod g == 0. Then, we require k to be at least the smallest non-negative solution to (a+k) ≡ 0 (mod g). That is, k ≡ (-a) mod g, i.e., k_min = (g - a % g) % g, but note: if a % g == 0, then k_min=0.\n\nBut wait, what if we consider divisors? The idea is that for each divisor g of d, we can set k to be the smallest non-negative integer such that g divides (a+k). Then, we compute the LCM for that k (which is (a+k)*(b+k)/g). Then, we compare the LCM for all divisors g of d and take the one with the smallest LCM, and if there are multiple, the smallest k.\n\nHowever, note: the problem says that k must be chosen so that the LCM is minimized. But note that k might not be unique for a divisor g? Actually, for each divisor g, we get one candidate k (the smallest k that makes g divide (a+k)). Then, we must check all divisors of d (including negative divisors? No, we consider positive divisors, since GCD is positive).\n\nBut note: d = |a-b|, and divisors of d (positive) will give the possible GCD values.\n\nHowever, note: the GCD might not necessarily be exactly one of the divisors of d? Actually, the GCD must divide d, so it is a divisor of d. But note: the GCD might be any divisor of d. So we consider all divisors.\n\nBut wait: what if d=0? Then a==b. Then the problem becomes: we have two equal numbers. Then, the LCM of (a+k) and (a+k) is (a+k)^2. We want to minimize (a+k)^2, so the smallest k is 0. However, note: d=0, and divisors of 0 are undefined. So we",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a+k \\) and \\( b+k \\) must divide the absolute difference between \\( a \\) and \\( b \\). This means we can consider all divisors of the absolute difference \\( d = |a - b| \\) to determine potential values of \\( k \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( d \\), we find the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is derived by solving the congruence \\( (a + k) \\equiv 0 \\mod g \\), which simplifies to \\( k \\equiv (-a) \\mod g \\). The solution \\( k \\) for each divisor \\( g \\) is the smallest non-negative integer satisfying this condition.\n\n3. **Algorithm Selection**: The algorithm involves:\n   - Calculating \\( d = |a - b| \\).\n   - Finding all positive divisors of \\( d \\).\n   - For each divisor \\( g \\), compute the corresponding \\( k \\) as \\( (g - a \\% g) \\% g \\).\n   - Compute the LCM for each candidate \\( k \\) using the formula \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\).\n   - Track the candidate \\( k \\) that results in the smallest LCM. If multiple \\( k \\) values yield the same minimal LCM, select the smallest \\( k \\).\n\n4. **Edge Cases**: Handle cases where \\( a = b \\) separately, as the LCM is simply \\( (a + k)^2 \\), minimized when \\( k = 0 \\).\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.readline().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    candidates = {}\n    \n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k = 0\n        else:\n            k = g - remainder\n        x = a + k\n        y = b + k\n        gcd_val = math.gcd(x, y)\n        lcm_val = (x * y) // gcd_val\n        if lcm_val not in candidates:\n            candidates[k] = lcm_val\n        elif candidates.get(k, float('inf')) > lcm_val:\n            candidates[k] = lcm_val\n            \n    best_k = None\n    best_lcm = None\n    \n    for k, lcm_val in candidates.items():\n        if best_lcm is None or lcm_val < best_lcm:\n            best_lcm = lcm_val\n            best_k = k\n        elif lcm_val == best_lcm and best_k > k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the answer is immediately \\( 0 \\) since the LCM of two identical numbers is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For \\( d = |a - b| \\), compute all positive divisors. These divisors help in determining potential \\( k \\) values.\n4. **Candidate Generation**: For each divisor \\( g \\), compute the smallest \\( k \\) such that \\( g \\) divides \\( a + k \\). The LCM of \\( a + k \\) and \\( b + k \\) is then calculated.\n5. **Optimal \\( k \\) Selection**: Track the smallest \\( k \\) that yields the minimal LCM. If multiple \\( k \\) values yield the same LCM, the smallest \\( k \\) is chosen.\n\nThis approach efficiently narrows down the problem to considering only relevant divisors and their corresponding \\( k \\) values, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.readline().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    candidates = {}\n    \n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k = 0\n        else:\n            k = g - remainder\n        x = a + k\n        y = b + k\n        gcd_val = math.gcd(x, y)\n        lcm_val = (x * y) // gcd_val\n        if lcm_val not in candidates:\n            candidates[k] = lcm_val\n        elif candidates.get(k, float('inf')) > lcm_val:\n            candidates[k] = lcm_val\n            \n    best_k = None\n    best_lcm = None\n    \n    for k, lcm_val in candidates.items():\n        if best_lcm is None or lcm_val < best_lcm:\n            best_lcm = lcm_val\n            best_k = k\n        elif lcm_val == best_lcm and best_k > k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1042,
        "thoughts_token_count": 1023
    }
}