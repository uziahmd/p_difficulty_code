{
    "start": 1758296828.33805,
    "end": 1758300207.6404524,
    "start-formatted": "2025-09-20 00:47 KST",
    "end-formatted": "2025-09-20 01:43 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, assume a <= b, so we can set d = b - a (but note: if a > b, then we can swap and adjust accordingly). However, let's consider:\n\nWe have two numbers: x = a+k and y = b+k, and we know that:\n  LCM(x, y) = (x * y) / GCD(x, y)\n\nNote that the GCD of x and y must divide (x-y) = (a-b). So, let g be a divisor of |a-b| (or more precisely, a divisor of the absolute difference). Then, we can set:\n  x = g * m, y = g * n, with GCD(m, n)=1, and then the LCM is g*m*n.\n\nBut note: x = a+k, y = b+k, so x-y = a-b (if a>=b) or negative. The difference is fixed: d = |a-b|. However, we can write:\n  Let d = |a-b|. Then, for any k, the difference between the two numbers is d. The GCD of x and y must divide d.\n\nTherefore, we can think: for each divisor g of d (where d = |a-b|), we can set up equations.\n\nBut note: we are adding k to both. We require:\n  x = a+k, y = b+k, and we require that g divides both (a+k) and (b+k). This implies that g divides (a-b) (which it does, because g divides d). Then, we can set:\n  k ≡ -a (mod g)   and   k ≡ -b (mod g). But since a ≡ b (mod g) (because g divides a-b), then these congruences are consistent.\n\nActually, the condition is that k ≡ (-a) mod g, and since a ≡ b mod g, then (-a) ≡ (-b) mod g.\n\nSo, for a divisor g (positive) of d, we can set k as the smallest non-negative integer such that:\n  k >= 0 and k ≡ (-a) mod g   => k = (-a) mod g? Actually, we can define k0 as the smallest non-negative solution to k ≡ (-a) mod g, which is k0 = (g - a % g) % g? \n\nBut note: we have two expressions: \n  Let k0 = (-a) mod g, but in positive terms: \n  k0 = (g - (a % g)) % g   [if a % g !=0, then k0 = g - (a % g); if a%g==0, then k0=0]\n\nHowever, we must also satisfy that the GCD(x,y)=g. But note: the GCD might be a multiple of g? Actually, we are iterating over divisors g of d, and then we set k such that g divides both (a+k) and (b+k). But the GCD might be greater than g? \n\nWait, we are trying to minimize the LCM. The LCM is (x * y) / g0, where g0 = GCD(x,y). Since g divides both, g divides g0. Therefore, the minimal LCM we can achieve for a fixed divisor g is not necessarily when GCD(x,y)=g, because maybe the GCD is larger.\n\nAlternatively, we can note that the GCD(x,y) must be a divisor of d. So we can iterate over all divisors of d (including 1 and d) and for each divisor g, we consider the candidate k that satisfies k ≡ (-a) mod g (and similarly for b) and then compute the LCM for (a+k, b+k) and then take the minimum.\n\nBut note: the problem constraints: a, b up to 10^9. The number of divisors of d is at most around 1300 (for highly composite numbers). So we can factorize d and iterate over all divisors.\n\nSteps:\n\n1. Read a and b.\n2. Let d = abs(a-b). If d==0, then we have a==b. Then the problem becomes: we want to minimize LCM(a+k, a+k) = a+k. So we want the smallest k such that a+k is as small as possible? But note: the minimal LCM is achieved at k=0 (since a+k increases with k). However, if a==b, then we can choose k=0.\n\nBut wait: the example input includes '5 10' -> output '0'. Actually, when a=5, b=10, then d=5. \n\nBut note: what if a==b? Then the answer is k=0.\n\n3. If a==b, then we output 0.\n\n4. Otherwise, we factorize d (the absolute difference) and get all divisors. Then, for each divisor g (positive) of d, we compute:\n\n   Let r = (-a) % g. Then k0 = r if r != 0, but if r==0 then k0=0. Actually, we can compute k0 = (g - (a % g)) % g. But note: if a % g ==0, then (g - (a % g)) % g = (g-0)%g = 0. So that formula works.\n\n   However, note: we require that the GCD(a+k0, b+k0) is at least g. But actually, we are only ensuring that g divides (a+k0) and (b+k0). It might be that the GCD is a multiple of g. But our goal is to consider all divisors, and then we will naturally cover the case when the GCD is a divisor of d.\n\n   But note: the LCM is (x*y)/gcd(x,y). Since we are iterating over divisors of d, and the GCD must divide d, we can consider that the minimal LCM might occur for some divisor g that is the actual GCD. However, we are also allowed to have k that makes the GCD larger? Actually, no: if we fix g (a divisor of d) and set k0, then the GCD(x,y) must be a multiple of g. But we are iterating over every divisor. Alternatively, we can consider that the GCD(x,y) must divide d, so we are covering all possibilities.\n\n   However, there is a catch: we are only considering divisors of d. But note: the GCD(x,y) must divide (a-b) (so d). Therefore, we are iterating over all possible GCD divisors. But note: the k we choose for a divisor g might not yield GCD exactly g, but a multiple of g (that is also a divisor of d). However, we are going to consider every divisor, so we will also consider the multiple of g that is the actual GCD.\n\n   But wait: if we choose k0 for a divisor g, then the GCD(x,y) might be larger than g. Then the LCM would be (x*y)/gcd, which is smaller than (x*y)/g (because gcd>g). So we are missing the possibility that a divisor g might lead to an even better LCM if the actual GCD is larger?\n\n   Actually, we are not. Because if we consider a divisor h (a multiple of g) of d, then when we iterate over h, we will get a candidate k1 that satisfies the condition for h (which is a stronger condition). And then we compute the LCM for that candidate k1. So we don't need to worry about the fact that k0 (from divisor g) might yield a higher GCD.\n\n   However, we must consider: the candidate k0 from divisor g might be different from the candidate k1 from divisor h (if h is a divisor of d that is a multiple of g). But note: the condition for h is stronger: k must be ≡ -a mod h. Since h is a multiple of g, then the condition for h implies the condition for g. Therefore, the candidate k1 (from h) is also a candidate for g. But we are going to consider all divisors, so we are safe.\n\n   But note: the minimal k for divisor g is k0, and for divisor h (multiple of g) is k1, which might be larger than k0. We are looking for the smallest k that minimizes LCM. Therefore, we must consider all divisors.\n\n   However, there is a caveat: the same k might be generated by multiple divisors. But we are going to collect all candidate k's from divisors and then check the LCM for each k, then choose the minimal LCM and then the minimal k.\n\n   But the number of divisors is O(sqrt(d)), and d can be up to 10^9, so the number of divisors is about 1344 (max for numbers near 10^9). Then we have to compute the LCM for each candidate k. But note: k0 can be very large? Actually, k0 is computed modulo g, so k0 is in [0, g-1]. Then we can have k0 as a candidate. However, note: we are iterating over divisors of d, and d = |a-b|, which can be up to 10^9. But the divisors we get are factors of d, so g is a divisor of d, and k0 is the smallest non-negative solution modulo g, so k0 < g. Then we have at most ~1344 candidates.\n\n   However, we must also consider: is it possible that the minimal LCM occurs for a k that is not the minimal solution for any divisor? \n\n   Let me think: the GCD(x,y) must divide d. Therefore, the condition for the GCD being g (a divisor of d) is necessary. But note: the LCM is (x*y)/g0, and we want to minimize that. The value of x and y are increasing with k. However, the GCD g0 might be a divisor of d, so we are covering all possibilities.\n\n   But note: we must consider that k is non-negative and the same k might be generated by multiple divisors. However, we are generating one candidate per divisor (the smallest k for that divisor). But is that candidate the only one? Actually, for divisor g, the set of k that satisfy k ≡ (-a) mod g is {k0, k0+g, k0+2g, ...}. We are taking the smallest non-negative one, which is k0.\n\n   However, note: sometimes we might get a lower LCM by choosing a larger k for the same divisor? But note: the LCM depends on x and y, and they increase with k. However, the GCD might change arbitrarily? Actually, the GCD must divide d, but the value of the GCD might change as k increases. But note: we are iterating over divisors of d, and the condition for a divisor g is that g divides (a+k) and (b+k). For a fixed divisor g, the minimal k is k0, and then the next one is k0+g, etc. But the LCM for k0 and k0+g might be different.\n\n   However, observe: \n      LCM(x, y) = (x * y) / GCD(x, y)\n   For k0, we have GCD(x, y) is at least g. But what if we use k0 + t*g (t>=1)? Then the GCD(x, y) must be a divisor of d and also divides (a+k0+t*g) and (b+k0+t*g). Since (a+k0+t*g) = (a+k0) + t*g, and (a+k0) is divisible by g, then (a+k0+t*g) is divisible by g. Similarly for (b+k0+t*g). But the GCD might be larger than g.\n\n   However, we are already iterating over divisors (including divisors that are multiples of g) so we are going to consider the candidate k0 (for divisor g) and k1 (for divisor h, which might be a multiple of g) and also k0 + t*g (for t>=1) might be the candidate for divisor h (if h divides d and h is a multiple of g, then the minimal k for h is k1, which is less than or equal to k0 + something? Actually, no: the minimal k for h (a multiple of g) is computed independently.\n\n   But note: the minimal k for divisor h (which is a multiple of g) must be congruent to (-a) mod h. Since h is a multiple of g, then (-a) mod h is determined by h. And note: k0 (from g) is the solution modulo g, but modulo h, we require a stronger condition. Therefore, k0 might not satisfy the condition for h. So we cannot simply take k0 + t*g to get the candidate for h.\n\n   Therefore, we must generate for each divisor g (of d) the candidate k0 (the smallest non-negative solution to k ≡ (-a) mod g). Then, we compute the LCM for (a+k0, b+k0) and record the k0 and the LCM.\n\n   However, note: there might be multiple k for the same divisor g (like k0, k0+g, k0+2g, ...) but we are only taking the smallest one. Why is that sufficient? Because the LCM is a function of x and y (which are increasing with k). The LCM might first decrease and then increase? Actually, the LCM is the product divided by the GCD. As k increases, the product (a+k)*(b+k) increases, but the GCD might change (and might become larger, which would reduce the LCM). However, we are iterating over all divisors, so we are covering all potential GCDs.\n\n   But note: the minimal LCM might occur for a k that is not the minimal solution for any divisor? \n\n   Let me try with the example: a=6, b=10, d=4. Divisors: 1,2,4.\n\n   For g=1: k0 = (1 - (6%1)) % 1 -> 0. Then x=6, y=10, GCD=2, LCM=30.\n   For g=2: k0 = (2 - (6%2)) % 2 = (2-0)%2=0. Then x=6, y=10, same as above, LCM=30.\n   For g=4: k0 = (4 - (6%4)) % 4 = (4-2)%4=2. Then x=8, y=12, GCD=4, LCM=24.\n\n   So we found k=2.\n\n   Now, what if we consider k=2 for g=2? Actually, k=2 is the same candidate as for g=4. But note: for g=2, k0=0, but k=2 is a solution for g=2? Yes, because 2 mod2=0, and (-6) mod2=0, so 2≡0 mod2. So k=2 is also a candidate for g=2. But we are only storing the candidate k0=0 for g=2. Then we would compute the LCM for k=0 (which is 30) and for k=2 (from g=4) we get 24. Then we choose k=2.\n\n   But why didn't we get k=2 from g=2? Because we only stored the minimal solution for g=2 (which is 0). However, we must consider that the same k (like 2) might be generated by multiple divisors. But we are generating one candidate per divisor (the minimal k for that divisor). But note: the problem asks for the smallest k that minimizes the LCM. We are generating k0 for each divisor, but we are not generating all k's that are solutions for that divisor.\n\n   However, note: the LCM for k0 and k0+g, k0+2g, ... might be different. In the example, k=0 gives LCM=30, k=2 (which is 0+2 for g=2) gives LCM=24. So we must consider k=2 for divisor g=2 as well.\n\n   How do we account for that?\n\n   Observation: the condition for a divisor g is that g divides (a+k) and (b+k). The set of k satisfying that condition is periodic with period g. Therefore, for each divisor g, the candidate k's are k0, k0+g, k0+2g, ... until ... but we cannot go to infinity.\n\n   However, note: the LCM(x,y) = (x*y)/gcd(x,y). As k increases, the product x*y increases. The GCD(x,y) is at least g (the divisor we started with) and may change. But the minimal LCM for a fixed divisor g might occur at the minimal k (k0) or at a later k? \n\n   Actually, the LCM might be minimized at a particular k for a divisor g. But note: the minimal k for divisor g is k0, and then the next candidate is k0+g. However, we don't know if k0+g yields a better LCM.\n\n   But note: we are iterating over all divisors (including divisors that are multiples of g). Therefore, if a divisor h (a multiple of g) exists and yields a candidate k1 (which is the minimal solution for h) and if k1 is less than k0+g, then we consider k1. However, k1 might be the same as k0+g? Not necessarily.\n\n   However, the problem is that we are only storing the minimal k for each divisor. But the minimal k for divisor g is k0, and the minimal k for divisor h (a multiple of g) is k1, which is independent.\n\n   But we cannot store an infinite number of k's. We must find a way to bound the k's.\n\n   Alternative approach:\n\n   We know that the LCM must be minimized. Note that the LCM is (x*y)/g0, and x = a+k, y = b+k, so x*y = (a+k)*(b+k) = (a+k)*(a+k+d) (if we let d = b-a, assuming b>=a). Then the LCM is ((a+k)*(b+k))/g0.\n\n   Also note: g0 divides d, so g0 is one of the divisors of d.\n\n   Therefore, we can iterate over the divisors of d (as the potential GCD) and for each divisor g0, we set up the condition that g0 divides (a+k) and (b+k). Then k must satisfy k ≡ (-a) mod g0 (and also k ≡ (-b) mod g0, which is consistent). Then the smallest non-negative k for this divisor is k0 (as above). Then we compute the LCM for k0. However, we must also consider that the GCD might be a divisor of d that is not necessarily g0, but we are iterating over all divisors so we are covering the actual GCD.\n\n   But wait: the GCD of (a+k, b+k) might be a divisor of d, but we are forcing the condition that the divisor g0 divides the numbers, and then the GCD might be a multiple of g0? Actually, no: the GCD must divide d, and we are considering all divisors. However, the GCD might be a divisor of d that is not g0, but then we are already considering that divisor separately.\n\n   However, the key is: the LCM is (x*y)/g0, but if the actual GCD is g1 (which is a divisor of d and divides both x and y) then we should use g1. But note: the condition for g1 is independent. And we are iterating over all divisors, so we are effectively considering all possibilities.\n\n   But the issue is: the same k might be the solution for multiple divisors, and we want the minimal k that minimizes the LCM.\n\n   However, the above approach (iterating over divisors and taking the minimal k for that divisor) might not be sufficient because:\n\n   Example: a=2, b=4, d=2. Divisors: 1,2.\n\n   For divisor 1: k0 = 0. Then x=2, y=4, GCD=2, LCM=4.\n   For divisor 2: k0 = (2- (2%2))%2 = (2-0)%2=0. Then same as above.\n\n   But wait, what if we take k=1?\n      x=3, y=5, GCD=1, LCM=15 -> worse.\n\n   What if we take k=2?\n      x=4, y=6, GCD=2, LCM=12.\n\n   So the minimal LCM is 4 (at k=0). \n\n   But now consider: a=2, b=4, and we try divisor 1: k0=0 -> LCM=4, divisor2: k0=0 -> same.\n\n   Now, consider a=2, b=5, d=3. Divisors:1,3.\n\n   divisor1: k0=0 -> x=2,y=5, LCM=10.\n   divisor3: k0 = (3- (2%3))%3 = (3-2)%3=1. Then x=3,y=6, GCD=3, LCM=6.\n\n   So k=1 is the candidate.\n\n   But what if we try k=4? \n        x=6, y=9, GCD=3, LCM=18 -> worse.\n\n   So the minimal k for divisor3 is 1, and that gives the minimal LCM.\n\n   However, note that the GCD of (2+k,5+k) must divide 3. So the GCD can only be 1 or 3. We've considered both.\n\n   Therefore, the plan is:\n\n   Step 1: If a==b, output 0.\n\n   Step 2: Let d = abs(a-b). Factorize d and get all divisors.\n\n   Step 3: For each divisor g of d (positive divisors only), compute:\n        k0 = (g - a % g) % g   [This gives the smallest non-negative k such that (a+k0) % g == 0]\n\n   Step 4: But note: k0 is the smallest non-negative solution. However, we must ensure that k0 is at least 0.\n\n   Step 5: Then, we compute:\n        x = a + k0\n        y = b + k0\n        g0 = gcd(x, y)   # But note: the GCD might be a multiple of g? Actually, the GCD must divide d, and we know g divides d, but the GCD might be any divisor of d. However, we are iterating over divisors of d, so we are going to consider the actual GCD separately.\n\n   But wait: we are not forced to have the GCD equal to g. The GCD might be a divisor of d that is not necessarily g. Therefore, we cannot assume that the GCD is g.\n\n   However, note: the condition we set (k0 ≡ -a mod g) ensures that g divides both x and y. Therefore, the GCD must be at least g (if g>0). But the LCM is (x*y)/g0, and g0 is the GCD. We are iterating over divisors, so we are going to consider the divisor that is the actual GCD.\n\n   But here's the catch: we are generating a candidate k0 for divisor g, but the actual GCD might be larger than g (and we are going to consider that divisor separately). So we are going to consider the same k0 in the iteration for the divisor that is the actual GCD. Therefore, we don't need to worry about the actual GCD being larger.\n\n   However, we must compute the LCM for (a+k0, b+k0) and compare. But note: the LCM depends on the actual GCD, not just g.\n\n   Therefore, we should compute the actual GCD for the candidate k0 and then compute the LCM.\n\n   But note: the GCD of (a+k0, b+k0) must divide d, so we can compute it with Euclidean algorithm.\n\n   However, we are iterating over divisors of d, and d is fixed. The candidate k0's are independent. The total number of candidates is the number of divisors (say, D). Then we compute D GCDs and D LCMs.\n\n   But note: k0 is the smallest non-negative solution for the congruence, and we are only storing one candidate per divisor. However, as argued earlier, the same k might appear for multiple divisors. But we are going to consider each divisor independently, and then we will choose the k that minimizes the LCM, and if multiple k's have the same LCM we choose the smallest k.\n\n   But wait: what if the same k appears for two different divisors? Then we are going to compute the LCM for that k twice. But that's okay because we are going to compare the LCM values and choose the minimal k.\n\n   However, there is a problem: the candidate k0 for divisor g might be very large? Actually, k0 is in the range [0, g-1]. Since g divides d, and d<=10^9, then g<=10^9, so k0 can be up to 10^9-1. But the number of divisors is at most 1344, so we can store up to 1344 candidates.\n\n   But note: the problem says a,b up to 10^9, so k0 might be up to 10^9, but we are storing k0 and then computing (a+k0) and (b+k0). These numbers could be up to 2e9, which is acceptable in Python for gcd and LCM computation? \n\n   However, the LCM might be huge (up to about (2e9 * 2e9) / 1 which is 4e18, which is within Python's integer range but we are comparing them. But note: we are only storing the LCM for the candidate k0, and then we choose the minimal one.\n\n   But wait: there is another candidate: what if we don't take the minimal k for divisor g, but a larger one? \n\n   Consider: for divisor g, the set of k is k0, k0+g, k0+2g, ... and the LCM might be minimized at a particular multiple.\n\n   However, note: the LCM = (x*y)/g0, and x and y are increasing with k. The product (x*y) is increasing, but the GCD (g0) might be increasing (if we hit a divisor that divides both more times). However, the minimal LCM might occur at the minimal k (k0) for divisor g, or at a later k? \n\n   Example: a=1, b=3, d=2. Divisors:1,2.\n\n   divisor1: k0=0 -> x=1,y=3, LCM=3.\n   divisor2: k0= (2-1%2)%2 = (2-1)%2=1 -> x=2,y=4, GCD=2, LCM=4.\n\n   But wait, what about k=2 for divisor1?\n        x=3,y=5, GCD=1, LCM=15 -> worse.\n\n   k=1 for divisor1: \n        x=2,y=4, GCD=2, LCM=4.\n\n   But note: k=1 is also the candidate for divisor2. So we are capturing k=1 from divisor2.\n\n   Now, consider a=1, b=4, d=3. Divisors:1,3.\n\n   divisor1: k0=0 -> x=1,y=4, LCM=4.\n   divisor3: k0= (3-1%3)%3 = (3-1)%3=2 -> x=3,y=6, GCD=3, LCM=6.\n\n   But what if we take k=1? \n        x=2,y=5, GCD=1, LCM=10.\n   k=2: from divisor3, LCM=6.\n\n   k=3: \n        x=4,y=7, GCD=1, LCM=28.\n\n   Now, consider a=1, b=5, d=4. Divisors:1,2,4.\n\n   divisor1: k0=0 -> x=1,y=5, LCM=5.\n   divisor2: k0= (2-1%2)%2= (2-1)%2=1 -> x=2,y=6, GCD=2, LCM=6.\n   divisor4: k0= (4-1%4)%4= (4-1)%4=3 -> x=4,y=8, GCD=4, LCM=8.\n\n   But what if we take k=4?\n        x=5,y=9, GCD=1, LCM=45.\n\n   Now, what if we take k=2? \n        x=3,y=7, GCD=1, LCM=21.\n\n   k=3: already done (divisor4).\n\n   k=1: done.\n\n   k=0: done.\n\n   So the minimal LCM is 5 at k=0.\n\n   However, note: the minimal k is 0.\n\n   But what if we have a=2, b=8, d=6. Divisors:1,2,3,6.\n\n   divisor1: k0=0 -> x=2,y=8, GCD=2, LCM=8.\n   divisor2: k0= (2-2%2)%2=0 -> same as above, LCM=8.\n   divisor3: k0= (3-2%3)%3= (3-2)%3=1 -> x=3,y=9, GCD=3, LCM=9.\n   divisor6: k0= (6-2%6)%6= (6-2)%6=4 -> x=6,y=12, GCD=6, LCM=12.\n\n   But wait, is there a k that gives a lower LCM? \n\n   k=1: GCD(3,9)=3, LCM=9.\n   k=2: GCD(4,10)=2, LCM=20.\n   k=3: GCD(5,11)=1, LCM=55.\n   k=4: GCD(6,12)=6, LCM=12.\n\n   So the minimal is 8 at k=0.\n\n   However, note: the condition for divisor1 and divisor2 both gave k0=0, and that was the minimal k.\n\n   But consider: k=5 (for divisor1: k0=0, then k=5 is 5 mod1=0, so yes, but we don't consider k=5 because we only take the minimal k for divisor1). However, the LCM at k=5 is (7*13)/1 = 91, which is worse.\n\n   Therefore, the minimal k for each divisor is the only candidate we need to consider? \n\n   Why? Because the LCM is increasing with k (if we ignore the effect of increasing GCD) and the GCD can only help by increasing (making the denominator bigger) but the numerator (product) is increasing. However, sometimes the GCD increases and the product doesn't increase as much? \n\n   Actually, the LCM is (x*y)/g0. The product x*y is quadratic in k, while the GCD g0 is linear in k? Not exactly: the GCD is bounded by d (the divisor) and the product is quadratic. Therefore, as k increases, the product grows faster than the GCD. So the minimal LCM for a fixed divisor g might occur at the smallest k (k0) because if we increase k, the product increases and the GCD might not change (or even if it changes, the product increases too much).\n\n   However, consider: a=1, b=2, d=1. Divisors: [1]\n        k0=0: x=1,y=2, GCD=1, LCM=2.\n\n   Now, k=1: x=2,y=3, GCD=1, LCM=6 -> worse.\n\n   But consider: a=3, b=5, d=2. Divisors:1,2.\n\n   divisor1: k0=0 -> x=3,y=5, LCM=15.\n   divisor2: k0= (2-3%2)%2= (2-1)%2=1 -> x=4,y=6, GCD=2, LCM=12.\n\n   Now, k=2: x=5,y=7, GCD=1, LCM=35.\n\n   k=3: x=6,y=8, GCD=2, LCM=24.\n\n   Wait, why at k=3 the LCM is 24, which is worse than 12 (at k=1). So the minimal LCM is 12 at k=1.\n\n   Now, consider a=3, b=5, and k=1: LCM=12, k=3: LCM=24. So the LCM is not necessarily decreasing with k.\n\n   But note: the minimal k for divisor2 is k0=1. Then k0+g=3, which is the next candidate. We did not consider k=3 in our initial set. However, we are only storing k0 for each divisor.\n\n   Therefore, we must consider all k that are solutions for some divisor? \n\n   But note: the set of k that yield a GCD that divides d is the union of arithmetic progressions. Each divisor g gives an arithmetic progression: k0, k0+g, k0+2g, ... \n\n   We cannot iterate over all k in these progressions because g can be as large as 10^9 and k0 can be large.\n\n   However, note: the LCM is (x*y)/g0, and x and y are increasing. The LCM is minimized at a particular k. How can we find the minimal k without enumerating all arithmetic progressions?\n\n   Alternative Insight:\n\n   We know that the GCD(x,y) must divide d. Then, the LCM(x,y) = (x*y) / g0, and x = a+k, y = b+k, so:\n\n   LCM(x,y) = (a+k)*(b+k) / g0\n\n   But g0 divides d, so g0 is a divisor of d. Then, we can write:\n\n   (a+k)*(b+k) = (a+k)*(a+k+d)   [if we let d=b-a, assuming b>a]\n\n   Then, we are to minimize (a+k)*(a+k+d) / g0, with the condition that g0 divides (a+k) and (b+k) (i.e., g0 divides (a+k) and (a+k+d)).\n\n   But note: the condition that g0 divides (a+k) and (a+k+d) is equivalent to g0 divides d (which it does) and k ≡ -a (mod g0).\n\n   Therefore, for each divisor g0, we have a candidate k_min = the smallest non-negative integer such that k_min ≡ -a (mod g0). Then, we compute the LCM for k_min, k_min+g0, k_min+2*g0, ... until the LCM starts to increase? \n\n   However, note: the LCM is (a+k)*(a+k+d)/g0. The numerator is quadratic and the denominator is fixed (g0). Therefore, as k increases, the numerator increases. So the minimal LCM for a fixed divisor g0 occurs at the smallest k (k_min). \n\n   But wait: what if g0 is not the actual GCD? Then the denominator is not g0, but a divisor of g0? No, the actual GCD must be at least g0 (if we set k_min, then g0 divides the numbers, so the GCD is at least g0). But then we are using g0 as the denominator, but the actual denominator (GCD) might be larger. Then the LCM would be (a+k)*(a+k+d)/g1, where g1>=g0. Then the LCM is even smaller than (a+k)*(a+k+d)/g0? \n\n   Example: a=3, b=5, d=2, g0=2. Then k_min=1, and the actual GCD is 2 (so the denominator is 2). Then LCM= (4*6)/2=12.\n\n   But if we consider g0=1, then k_min=0, and the actual GCD is 1 (so",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a+k \\) and \\( b+k \\) must divide the absolute difference between \\( a \\) and \\( b \\). This means we can limit our search for possible GCD values to the divisors of \\( |a - b| \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a - b| \\), we find the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is computed as \\( k = (-a) \\mod g \\). Once we have all candidate \\( k \\) values from all divisors, we compute the LCM for each \\( k \\) and select the \\( k \\) that gives the smallest LCM.\n\n3. **Algorithm Selection**:\n   - **Divisor Enumeration**: Factorize \\( |a - b| \\) to find all its divisors.\n   - **Candidate Generation**: For each divisor \\( g \\), compute the smallest \\( k \\) that satisfies the congruence \\( k \\equiv -a \\mod g \\).\n   - **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a+k \\) and \\( b+k \\).\n   - **Optimal Selection**: Track the candidate \\( k \\) with the smallest LCM. If multiple \\( k \\) values yield the same LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{d}) \\), where \\( d = |a - b| \\). For \\( d \\leq 10^9 \\), the maximum number of divisors is around 1344, making the approach feasible.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 1:\n        return {1}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    best_k = 0\n    best_lcm = float('inf')\n    \n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n        x = a + k0\n        y = b + k0\n        g0 = gcd(x, y)\n        current_lcm = (x * y) // g0\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm:\n            if k0 < best_k:\n                best_k = k0\n                \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Divisor Enumeration**: The function `get_divisors` computes all divisors of \\( |a - b| \\) by checking each integer up to \\( \\sqrt{d} \\) and collecting pairs of divisors.\n2. **Candidate Generation**: For each divisor \\( g \\), the smallest non-negative \\( k \\) is found using the formula \\( k0 = (g - (a \\% g)) \\% g \\). This ensures \\( g \\) divides both \\( a+k0 \\) and \\( b+k0 \\).\n3. **LCM Calculation**: For each candidate \\( k0 \\), the LCM of \\( a+k0 \\) and \\( b+k0 \\) is calculated using their product divided by their GCD.\n4. **Optimal Selection**: The algorithm keeps track of the smallest LCM encountered and the corresponding \\( k0 \\). If multiple \\( k0 \\) values yield the same LCM, the smallest \\( k0 \\) is chosen.\n\nThis approach efficiently narrows down the search space to relevant divisors and ensures the solution is both optimal and correct.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 1:\n        return {1}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    best_k = 0\n    best_lcm = float('inf')\n    \n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n        x = a + k0\n        y = b + k0\n        g0 = gcd(x, y)\n        current_lcm = (x * y) // g0\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm:\n            if k0 < best_k:\n                best_k = k0\n                \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 987,
        "thoughts_token_count": 8191
    }
}