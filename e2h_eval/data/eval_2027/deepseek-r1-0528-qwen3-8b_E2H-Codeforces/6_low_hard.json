{
    "start": 1758088067.9946513,
    "end": 1758090099.7467084,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:21 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (l, r, cost)\n We need two vouchers i and j such that:\n   (1) They don't intersect: either r_i < l_j or r_j < l_i.\n   (2) The sum of their durations is exactly x: (r_i - l_i + 1) + (r_j - l_j + 1) = x.\n\n We are to minimize the total cost (cost_i + cost_j).\n\n Steps:\n\n 1. Note: The duration of a voucher i is d_i = r_i - l_i + 1.\n\n 2. We are looking for two vouchers with durations d1 and d2 such that d1 + d2 = x.\n\n 3. The condition of non-intersection: \n        Condition 1: if we take voucher i first and then j (so i is [l_i, r_i] and j is [l_j, r_j]), then we require r_i < l_j OR r_j < l_i.\n\n    But note: the two vouchers are not ordered in time necessarily. So we have two cases:\n        Case A: [l_i, r_i] ends before [l_j, r_j] starts -> r_i < l_j.\n        Case B: [l_j, r_j] ends before [l_i, r_i] starts -> r_j < l_i.\n\n 4. We can break down the problem by grouping the vouchers by their duration.\n\n    Let's define:\n        Let D = set of all durations that appear.\n\n    Then for each duration d (from 1 to max_d, which is up to 200000), we want to consider the other duration x-d.\n\n    However, note: the same duration might be represented by multiple vouchers, but we must also check non-intersection.\n\n 5. We need an efficient way to check for two vouchers (with given durations d1 and d2) whether there exists a pair (i from d1, j from d2) that satisfies non-intersection.\n\n    Conditions for non-intersection between two vouchers i and j (with durations d1 and d2, and x = d1+d2):\n        Either:\n            r_i < l_j   OR   r_j < l_i\n\n    This is equivalent to: the two intervals do not overlap.\n\n 6. How to approach?\n\n    We can precompute for each duration d, the set of vouchers (each voucher is (l, r, cost)) that have duration d.\n\n    Then, for each d1, we consider d2 = x - d1. If d2 is not present, skip.\n\n    Now, we have two sets: set1 for duration d1, set2 for duration d2.\n\n    We wish to find two vouchers i from set1 and j from set2 such that either:\n        (a) r_i < l_j, OR\n        (b) r_j < l_i.\n\n    And we want the minimal cost (cost_i + cost_j).\n\n 7. But note: the constraints (n, x, and the day values up to 200000) so we cannot iterate over all pairs.\n\n 8. Alternate idea:\n\n    We can preprocess the vouchers by storing them in two ways:\n\n    Idea 1: For each duration, we store the vouchers by their start day (l) and end day (r). Then for two sets (set1 and set2), we want to know if there's a voucher in set1 that ends before the start of some voucher in set2, or vice versa.\n\n    However, we cannot iterate over both sets because the sets could be large.\n\n 9. Another idea: Instead of grouping by duration, we can use two arrays (or dictionaries) for the two durations and then do a sweep.\n\n    But note: we are iterating over d1 from 1 to max_d, and for each d1, d2 = x-d1. Then we have two groups: group[d1] and group[d2].\n\n    For each group, we can store:\n        - The list of (l, r, cost) for that duration.\n\n    Then, we want to check for non-intersection between the two groups.\n\n    Specifically, for two intervals (a1, a2) and (b1, b2) from the two groups, they don't intersect if a2 < b1 OR b2 < a1.\n\n    We can try to find the minimum cost in group[d1] that ends before the start of some voucher in group[d2]. Similarly, the minimum cost in group[d2] that ends before the start of some voucher in group[d1].\n\n    Actually, we can break it into two parts:\n\n        Part 1: Consider all vouchers in group[d1] and group[d2] and check if there is a voucher in group[d1] that ends (r",
    "response": "\nTo solve this problem, we need to find two non-intersecting travel vouchers such that the sum of their durations equals exactly `x` and their total cost is minimized. The solution involves efficiently grouping the vouchers by their durations and then checking for compatible pairs between these groups.\n\n### Approach\n1. **Grouping by Duration**: First, we group all vouchers by their duration. For each voucher, the duration is calculated as `ri - li + 1`. We store all vouchers with the same duration in a list.\n2. **Checking Valid Pairs**: For each duration `d`, we check if there exists another duration `x - d` such that the sum of their durations equals `x`. If such a duration exists, we proceed to find pairs of vouchers from the two groups (one with duration `d` and the other with duration `x - d`) that do not intersect.\n3. **Non-intersection Check**: Two vouchers do not intersect if one ends before the other starts. To efficiently check this, we preprocess each group of vouchers by sorting them based on their start and end days. We then use binary search to quickly find valid pairs where one voucher ends before the other starts.\n4. **Cost Minimization**: For each valid pair found, we keep track of the minimum total cost. If no valid pairs are found after all checks, we return `-1`.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    \n    vouchers = []\n    max_day = 0\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost = int(next(it))\n        vouchers.append((l, r, cost))\n        max_day = max(max_day, r)\n    \n    d_to_vouchers = {}\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        if dur not in d_to_vouchers:\n            d_to_vouchers[dur] = []\n        d_to_vouchers[dur].append((l, r, cost))\n    \n    all_durations = list(d_to_vouchers.keys())\n    \n    # Precompute for each duration: sort by l and also by r, and prepare lists of costs for valid intervals.\n    # But we will also create two structures for each duration:\n    #   One sorted by l (start) and one sorted by r (end)\n    # However, we can do: for each duration, we have two sorted lists: one by start and one by end.\n    # Actually, we'll create for each duration a list of tuples (l, r, cost) and sort them by l and by r separately.\n    \n    # But note: we need to check two conditions: \n    #   Condition 1: A voucher from group d ends before a voucher from group (x-d) starts.\n    #   Condition 2: A voucher from group (x-d) ends before a voucher from group d starts.\n    \n    # Instead, we can precompute for each duration the following:\n    #   By start: sorted by l, and then extract the minimal cost for a given range [l_min, l_max] but actually we need to know the minimal cost for a voucher that starts at or above a certain point? Not exactly.\n    #\n    # Alternatively, we can precompute for each duration:\n    #   Let's have:\n    #       starts[d] = sorted list of (l, cost) for vouchers of duration d.\n    #       ends[d] = sorted list of (r, cost) for vouchers of duration d.\n    #\n    # Then, for two durations d1 and d2 (where d1 + d2 == x), we want to find:\n    #   Case 1: A voucher in d1 with end < start of a voucher in d2.\n    #   Case 2: A voucher in d2 with end < start of a voucher in d1.\n    #\n    # For Case 1:\n    #   We can take all vouchers in d1 (each has an end time r1) and find the minimal cost among those with r1 < some start s2 of a voucher in d2.\n    #   Similarly, for Case 2.\n    #\n    # How to do it efficiently?\n    #   Precompute for each duration d:\n    #       sorted_ends = sorted(ends[d])   # by r\n    #       and also a prefix minimum array for the costs in sorted_ends so that we can quickly get the minimal cost for any prefix.\n    #\n    # Steps for each duration d:\n    #   Let's create:\n    #       starts[d] = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]])\n    #       ends[d] = sorted([(r, cost) for (l, r, cost) in d_to_vouchers[d]])\n    #\n    #   Then for starts[d], we can create a Fenwick tree or segment tree for costs, but since the start values can be up to 200000, we can use a sorted list and bisect.\n    #\n    # However, note: the condition for non-intersection in Case 1 is r1 < s2. We can iterate over all possible d1 and d2, but that would be O(n^2) which is too slow.\n    #\n    # Instead, we can do:\n    #   For each duration d, let d2 = x - d.\n    #   If d2 not in d_to_vouchers, skip.\n    #   Then, we consider two cases:\n    #       Case A: Find a voucher in d with r < s (s is the start of a voucher in d2).\n    #       Case B: Find a voucher in d2 with r < s (s is the start of a voucher in d).\n    #\n    #   For Case A:\n    #       We need to consider all vouchers in d (each has an end time r) and for each such voucher, we look for a voucher in d2 with start time > r. Then, we take the minimal cost from d and d2 that satisfy this.\n    #\n    #   But doing this naively would be O(n1 * n2). We need a better way.\n    #\n    # Alternative approach:\n    #   Precompute for each duration d:\n    #       A sorted list of starts (l) and a sorted list of ends (r) along with their costs.\n    #       Also, build a structure that allows us to quickly query the minimal cost in d2 for vouchers with start > some value (for Case A) and similarly for d (for Case B).\n    #\n    #   We can use two separate dictionaries for starts and ends for each duration, but then how to combine?\n    #\n    # Another idea: Instead of iterating over every d1 and d2, we can precompute for each duration d the minimal cost for a voucher that ends at a certain time or starts at a certain time. But note the constraints (n, x up to 200000) and the day values up to 200000.\n    #\n    # Let's reframe: We want to find two vouchers i and j such that:\n    #   d_i + d_j = x, and either r_i < l_j or r_j < l_i.\n    #   And minimize cost_i + cost_j.\n    #\n    # We can precompute two arrays:\n    #   For each duration d, we have a list of (l, r, cost). We sort these by l and by r.\n    #   Then, for each d, we can create an array of minimal costs for vouchers that start at or above a certain day (for Case A) and similarly for ending below a certain day (for Case B).\n    #\n    # However, note that the condition for Case A is that the end of voucher i is less than the start of voucher j. So if we fix voucher i (from duration d), then we need a voucher j (from duration d2) with l_j > r_i. We can preprocess the vouchers for each duration d2 by creating a sorted list of starts and a prefix minimum cost array for those starts.\n    #\n    # Steps:\n    #   1. Group vouchers by duration and for each duration, create two lists:\n    #         starts[d] = sorted list of starts (l) for vouchers of duration d.\n    #         ends[d] = sorted list of ends (r) for vouchers of duration d.\n    #   2. For each duration d, we also create a list of costs and then build a prefix minimum array for the starts and suffix minimum array for the ends.\n    #   3. For each d from 1 to max_duration (which is up to 200000), set d2 = x - d. If d2 is not in d_to_vouchers, skip.\n    #   4. For Case A: For each voucher in d (with end time r), we need to find in d2 a voucher with start time > r. We can use the starts[d2] list and binary search to find the first start time greater than r, then use the prefix minimum array of d2 to get the minimal cost for vouchers starting after r.\n    #   5. Similarly, for Case B: For each voucher in d2 (with end time r), find in d a voucher with start time > r, and use the prefix minimum array of d to get the minimal cost.\n    #   6. Take the minimum of the results from both cases.\n    #\n    # But note: the number of vouchers per duration might be large, and iterating over each voucher in d for Case A could be O(n^2). We need to optimize further.\n    #\n    # We can instead for each duration d, precompute the minimal cost for all vouchers that end before a certain time. Specifically, for each duration d, we can create an array of end times and then a suffix minimum array (from high to low end time) so that for a given end time r, we can quickly get the minimal cost among vouchers in d that end <= r (but actually for Case A we need vouchers that end < some start, so we need the minimal cost among vouchers ending before a given start).\n    #\n    # Actually, let's define:\n    #   For each duration d, we have a list of (l, r, cost). We can sort by r (end time). Then, we can create an array min_cost_from_end[d] where min_cost_from_end[d][i] is the minimal cost among the first i+1 vouchers (the ones with smallest end times). Then, for a given start time s, we can find the largest end time that is < s, and then get the minimal cost from the prefix up to that index.\n    #\n    # Similarly, for starts: we can create a sorted list of starts and a prefix minimum array for costs based on start times.\n    #\n    # However, note: In Case A, we have a voucher from d1 (duration d) with end time r1, and we need a voucher from d2 (duration d2) with start time > r1. So we can use the starts[d2] list to find the minimal cost voucher in d2 that has start time > r1.\n    #\n    # Steps for Case A for a fixed d and d2:\n    #   - Get all vouchers in d (each has an end time r1).\n    #   - For each r1, we need to find in d2 the minimal cost among vouchers with start time > r1.\n    #   - But instead of iterating over each voucher in d, we can precompute for d2 a structure that allows us to query the minimal cost for vouchers with start time > r1 quickly.\n    #\n    # We can precompute for each duration d2:\n    #   starts_sorted = sorted(starts[d2])\n    #   prefix_min_start = [0] * len(starts_sorted)\n    #   For i in range(len(starts_sorted)):\n    #       if i == 0:\n    #           prefix_min_start[i] = starts_sorted[i][1]  # but wait, starts_sorted is just the start times? Actually, we stored (l, cost) for each voucher.\n    #       else:\n    #           prefix_min_start[i] = min(prefix_min_start[i-1], starts_sorted[i][1])\n    #\n    #   Then, for a given r1, we find the position pos = bisect_right(starts_sorted, r1)  # first index where start > r1 is pos.\n    #   If pos == len(starts_sorted): no voucher in d2 has start > r1.\n    #   Else, the minimal cost for d2 vouchers with start > r1 is prefix_min_start[pos-1] if we did prefix_min_start for the entire array? Actually, our prefix_min_start should be built from the beginning to the end, so if we want the minimal cost for vouchers starting at or above a certain point, we need to reverse the array or build a suffix minimum array.\n    #\n    # Alternatively, we can build a suffix minimum array for d2's starts:\n    #   Sort d2's starts by l (increasing), then compute an array suffix_min[i] which is the minimal cost from i to the end.\n    #   Then, find the first index i such that starts_sorted[i][0] > r1, then the minimal cost is suffix_min[i].\n    #\n    # But note: we have stored the starts as (l, cost) and we want to sort by l. Then, we can do:\n    #   starts_sorted = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]], key=lambda x: x[0])\n    #   Then, create an array of just the start times and an array of costs, and then a suffix minimum array for costs.\n    #\n    # Similarly for Case B, but for duration d and d2, we need to find in d a voucher with start time > r2 (where r2 is the end time of a voucher in d2).\n    #\n    # However, note: the total number of durations is at most 200000, but the sum of the sizes of all groups might be large (n up to 200000). But note that the same duration might appear many times, so we have to be careful.\n    #\n    # But the total number of vouchers is n, so the total work over all durations is O(n) if we process each voucher once. However, for each duration d, we might be processing each voucher in d against the entire group of d2. That could be O(n^2) in the worst case.\n    #\n    # We need to avoid that. Instead, we can precompute for each duration d the following:\n    #   Let starts_list = sorted list of (l, cost) for d.\n    #   Let ends_list = sorted list of (r, cost) for d.\n    #   Then, for each d, we can also precompute:\n    #       starts_prefix_min = [...]   # not directly useful for Case A\n    #       starts_suffix_min = [...]   # from right to left, minimal cost for starts >= current start\n    #       ends_prefix_min = [...]      # minimal cost for vouchers ending <= some value (for Case B)\n    #       ends_suffix_min = [...]      # minimal cost for vouchers ending >= some value (not needed)\n    #\n    # Actually, for Case A (voucher from d ends before voucher from d2 starts):\n    #   We need to find in d2: the minimal cost voucher with start > r (where r is the end of a voucher in d).\n    #   So for d2, we can precompute:\n    #       starts_sorted = sorted(starts_list, key=lambda x: x[0])\n    #       Then, create an array of start times and a suffix minimum array for the costs (from the last element to the first).\n    #\n    #   Similarly, for Case B (voucher from d2 ends before voucher from d starts):\n    #       We need to find in d: the minimal cost voucher with start > r (where r is the end of a voucher in d2).\n    #       So for d, we can precompute:\n    #           starts_sorted = sorted(starts_list, key=lambda x: x[0])\n    #           Then, create an array of start times and a suffix minimum array for the costs.\n    #\n    # Now, for each duration d, we can precompute:\n    #   starts_suffix_min[d] = an array where for each index i (in the sorted starts of d by l) the minimal cost from i to the end.\n    #   Similarly, for each duration d, we can precompute ends_prefix_min[d] = an array where for each index i (in the sorted ends of d by r) the minimal cost from start to i.\n    #\n    # But note: for Case A, we are looking in d2 for a voucher with start > r (the end of a voucher in d). We can use the starts_suffix_min for d2: \n    #   Find the smallest start in d2 that is > r, then the minimal cost from that position onward is the answer for d2 for that r.\n    #\n    # However, we must do this for every voucher in d? That would be O(n1 * log(n2)) for each d, which might be acceptable if the total number of durations is small, but note: the durations range from 1 to 200000, and we only consider d and d2 = x-d, so the number of pairs (d, d2) is at most 200000. But the total number of vouchers is 200000, so the sum over all d of the size of d is 200000. Therefore, if we iterate over each voucher in d for each d, the total complexity would be O(n^2) in the worst case, which is not acceptable.\n    #\n    # We need to reverse the thinking: Instead of iterating over each duration d and then over each voucher in d, we can precompute for each duration d the minimal cost for vouchers that end below a certain start time (or start above a certain end time) and then combine these precomputed values.\n    #\n    # Alternative efficient approach:\n    #   We can iterate over all vouchers once and record their (l, r, cost, duration) and then use dynamic programming or two pointers. But the condition involves two vouchers with specific durations.\n    #\n    # After careful thought, here's a more efficient plan:\n    #   Step 1: Group vouchers by duration as before.\n    #   Step 2: For each duration d, we create two sorted lists:\n    #           starts[d] = sorted list of starts (l) for vouchers in d.\n    #           ends[d] = sorted list of ends (r) for vouchers in d.\n    #   Step 3: For each duration d, we also create a list of costs and then build:\n    #           starts_suffix_min[d] = an array where starts_suffix_min[i] is the minimal cost among the vouchers from i to the end (when starts[d] is sorted).\n    #           ends_prefix_min[d] = an array where ends_prefix_min[i] is the minimal cost among the vouchers from start to i (when ends[d] is sorted).\n    #\n    #   Step 4: For each duration d, and for each d2 = x - d (if d2 exists and d2 >= d to avoid double counting? Actually, we must consider both orders because d and d2 are distinct unless d = x/2, then we consider pairs within the same group):\n    #           Case A: Voucher in d ends before voucher in d2 starts.\n    #                   For each voucher in d, we have an end time r. We need to find the minimal cost in d2 for a voucher with start > r.\n    #                   We can use the starts_suffix_min for d2: find the first index in starts[d2] where the start is > r, then the minimal cost is starts_suffix_min[d2][index].\n    #           Case B: Voucher in d2 ends before voucher in d starts.\n    #                   Similarly, for each voucher in d2, we have an end time r. We need to find the minimal cost in d for a voucher with start > r.\n    #                   Use starts_suffix_min for d.\n    #\n    #   But again, iterating over each voucher in d and d2 would be too slow.\n    #\n    # We need to avoid iterating over each voucher. Instead, we can precompute for each duration d the minimal cost for a voucher with start > some value, and then for a given end time r (from the other duration), we can quickly retrieve the minimal cost from d2 that has start > r.\n    #\n    # Let's define for each duration d:\n    #   starts_sorted = sorted(starts[d])\n    #   starts_suffix_min = [0]*len(starts_sorted)\n    #   We'll create an array of (start, cost) for d, then sort by start. Then, from the last element to the first, we compute the minimal cost from that position to the end.\n    #\n    #   Similarly, for ends_sorted = sorted(ends[d])\n    #   ends_prefix_min = [0]*len(ends_sorted)\n    #   Compute from the first element to the last the minimal cost for vouchers ending <= a given value.\n    #\n    # Then, for Case A (voucher in d ends before voucher in d2 starts):\n    #   We have a voucher in d with end time r. We need to find the minimal cost in d2 for a voucher with start > r.\n    #   In d2, we have starts_sorted_d2 and starts_suffix_min_d2.\n    #   Find the smallest start in starts_sorted_d2 that is > r. Let idx = bisect_right(starts_sorted_d2, r) -> the insertion position, so the first index with start > r is idx.\n    #   If idx >= len(starts_sorted_d2), then no voucher in d2 satisfies the condition.\n    #   Otherwise, the minimal cost from d2 for start > r is starts_suffix_min_d2[idx].\n    #\n    # But note: we cannot iterate over each voucher in d because that would be O(n^2). Instead, we can precompute for each duration d the minimal cost for all possible end times, but the end times can be up to 200000.\n    #\n    # Actually, we can precompute for each duration d a function f_d(r) = minimal cost in d for a voucher with start > r. But note, the start of a voucher in d is independent of its end. However, we have the starts_sorted and starts_suffix_min for d, so f_d(r) is simply starts_suffix_min_d2[idx] where idx is the position in starts_sorted_d2 for r.\n    #\n    # But then how do we combine with the ends of d? We want to consider all vouchers in d and for each, use f_{d2}(r) where r is the end of that voucher. This still requires iterating over each voucher in d.\n    #\n    # However, note that the total number of vouchers is 200000, and the sum over all durations of the sizes of the groups is 200000. But the number of pairs (d, d2) is about the number of distinct durations, which is at most 200000. For each duration d, we would iterate over all vouchers in d and for each, do a binary search in d2's starts_sorted. The total work would be the sum over all d of |d| * log(|d2|). Since the sum of |d| over all d is 200000, and the logarithm is at most 18, the total operations would be around 200000 * 18 = 3.6e6, which is acceptable.\n    #\n    # Similarly for Case B.\n    #\n    # Steps for the algorithm:\n    #   1. Read input and group vouchers by duration.\n    #   2. For each duration d that exists, do:\n    #           starts_sorted[d] = sorted(list of starts for vouchers in d)\n    #           ends_sorted[d] = sorted(list of ends for vouchers in d)\n    #           starts_suffix_min[d] = array for starts_sorted: from the last element to the first, the minimal cost.\n    #           ends_prefix_min[d] = array for ends_sorted: from the first element to the last, the minimal cost.\n    #   3. Initialize ans = a very large number.\n    #   4. For each duration d from 1 to max_duration (or for each key in d_to_vouchers):\n    #           d2 = x - d\n    #           If d2 not in d_to_vouchers, continue.\n    #           If d == d2:\n    #               Consider pairs within the same group. But note: the condition is two different vouchers (so we must pick two distinct vouchers). However, the problem does not require the two vouchers to be distinct in the sense of being different vouchers, but they must be two different ones. In the same duration group, we need two non-overlapping vouchers.\n    #               But note: two vouchers in the same duration might overlap or not. We need to find two vouchers i and j in d such that either r_i < l_j or r_j < l_i.\n    #               We can do:\n    #                   For each voucher i in d, find a voucher j in d (j != i) that does not intersect.\n    #               But this is similar to the previous cases, but now d2 = d.\n    #           Else:\n    #               Case A: For each voucher in d (each has an end time r), find the minimal cost in d2 for a voucher with start > r.\n    #                       Let candidate = starts_suffix_min[d2][position] (after binary search in starts_sorted[d2])\n    #                       Then, the total cost is cost_i + candidate. But note: we don't have the cost_i stored separately in the suffix_min for d2. Actually, we have to store the cost along with the start.\n    #               Correction: Our starts_suffix_min[d] should be computed from the list of (start, cost) for d, sorted by start.\n    #               So, for each duration d, we have:\n    #                   starts_with_cost = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]], key=lambda x: x[0])\n    #                   Then, starts_sorted = [l for (l, cost) in starts_with_cost]\n    #                   costs = [cost for (l, cost) in starts_with_cost]\n    #                   Then, starts_suffix_min = [0]*len(starts_sorted)\n    #                   starts_suffix_min[-1] = costs[-1]\n    #                   for i in range(len(starts_sorted)-2, -1, -1):\n    #                       starts_suffix_min[i] = min(starts_suffix_min[i+1], costs[i])\n    #\n    #               Then, for a given end time r from a voucher in d, we do:\n    #                   pos = bisect_right(starts_sorted[d2], r)\n    #                   if pos < len(starts_sorted[d2]):\n    #                       candidate_cost = starts_suffix_min[d2][pos]\n    #                   else:\n    #                       candidate_cost = None\n    #               Then, for the voucher in d with cost c, the total cost is c + candidate_cost.\n    #               But wait, we lost the cost of the voucher in d! We only have the cost from d2. We need to associate the cost of the voucher in d with its end time.\n    #\n    #           We must store the cost of each voucher in d. So when we iterate over vouchers in d, we have to consider each voucher individually.\n    #\n    #   Revised plan for Case A:\n    #       For a fixed duration d and d2 = x - d, we want to find the minimal total cost from:\n    #           min_{i in d, j in d2} { cost_i + cost_j }  subject to r_i < l_j.\n    #       We can do:\n    #           Let A = list of (r, cost) for vouchers in d.\n    #           Let B = starts_with_cost for d2 (sorted by start, with suffix_min array for costs).\n    #           Then, for each (r, cost_i) in A, we find the minimal cost_j in B such that start_j > r.\n    #           Then, candidate = cost_i + minimal_cost_j (if exists)\n    #           Then, ans = min(ans, candidate)\n    #\n    #       Similarly for Case B:\n    #           Let A = starts_with_cost for d (sorted by start, with suffix_min array for costs).\n    #           Let B = list of (r, cost) for vouchers in d2.\n    #           For each (r, cost_j) in B, find minimal cost_i in A such that start_i > r.\n    #           Then, candidate = cost_i + cost_j (but note: cost_j is fixed, and cost_i is minimal from A)\n    #           Then, ans = min(ans, candidate)\n    #\n    #   5. But note: the same voucher might be used twice? No, because d and d2 are different durations (or if same, then we are considering two different vouchers in the same duration group). In the same duration group, we must ensure that the two vouchers are distinct. However, the problem states \"two vouchers i and j (i ≠ j)\", so we must avoid using the same voucher twice. But in our grouping, if d == d2, then we are considering the same group. In that case, when we iterate over each voucher in d and then look for a voucher in d2 (which is the same group) with start > r, we might pick the same voucher? \n    #\n    #       Example: voucher i and j in the same group, and we require r_i < l_j. If the same voucher is used twice, then we would have r_i < l_i? That is impossible because l_i <= r_i. So the same voucher cannot satisfy the condition. Therefore, we are automatically picking two different vouchers.\n    #\n    #   6. Implementation details:\n    #       - We need to precompute for each duration d:\n    #             starts_sorted[d] = sorted list of starts (l) for vouchers in d.\n    #             starts_suffix_min[d] = suffix minimum array for the costs corresponding to starts_sorted[d].\n    #             ends_sorted[d] = sorted list of ends (r) for vouchers in d.\n    #             ends_prefix_min[d] = prefix minimum array for the costs corresponding to ends_sorted[d].\n    #\n    #       But for Case A, we need the starts_sorted and starts_suffix_min for d2, and for Case B, we need the starts_sorted and starts_suffix_min for d.\n    #\n    #       However, note: for Case A, we are iterating over vouchers in d (each has an end time r) and we need to query d2's starts_suffix_min. For Case B, we are iterating over vouchers in d2 (each has an end time r) and querying d's starts_suffix_min.\n    #\n    #       But wait, in Case B, the condition is that the voucher from d2 ends before the voucher from d starts. So we need to find in d a voucher with start > r (where r is the end of the voucher in d2). This is exactly what starts_suffix_min[d] is for: given a start threshold, find the minimal cost voucher in d with start > threshold.\n    #\n    #       However, note: the voucher in d must have a start time > the end time of the voucher in d2. But the start time of the voucher in d is not related to its end time. We have stored the start times of d in starts_sorted[d], which is independent of the end times. This is correct because the condition only depends on the start of the voucher in d.\n    #\n    #   7. Edge: When d2 is not present, skip.\n    #   8. Also, when d == d2, we are considering the same group. We must ensure that we are not using the same voucher twice, but as reasoned, the condition r_i < l_j cannot hold for the same voucher, so it's safe.\n    #\n    #   9. We must also consider that a voucher might have multiple attributes (l, r, cost), and we are storing starts and ends separately. But that's okay.\n    #\n    #   10. Finally, if we find no valid pair, output -1.\n    #\n    # Let's code accordingly, but note: the total number of distinct durations might be up to 200000, but most durations might not appear. We only need to consider durations that are in the input and for which d2 = x - d is also in the input.\n    #\n    # Steps in code:\n    #   - Read input and group vouchers by duration.\n    #   - Build a dictionary: d_to_vouchers, mapping duration -> list of (l, r, cost)\n    #   - Build dictionaries for starts_sorted and starts_suffix_min for each duration that appears.\n    #   - Also build ends_sorted and ends_prefix_min if needed (but for Case A and Case B, we only need starts_sorted and starts_suffix_min for the other duration).\n    #   - But note: in Case B, we are using the starts_suffix_min of d, so we don't need ends_sorted for d in Case A, but we do need ends_sorted for d in Case B? Actually, no: in Case B, we are iterating over vouchers in d2 and for each, we query d's starts_suffix_min. The voucher in d2 has an end time r, and we need to find in d a voucher with start > r.\n    #       This only requires d's starts_sorted and starts_suffix_min.\n    #\n    #   However, wait: in Case B, the condition is that the voucher from d2 ends before the voucher from d starts. So we are using the end time of d2's voucher to query d's starts. We do not need the end times of d's vouchers for Case B.\n    #\n    #   Similarly, in Case A, we are using the end time of d's voucher to query d2's starts. We do not need the start times of d's vouchers for Case A.\n    #\n    #   Therefore, we only need to precompute for each duration d:\n    #         starts_sorted[d] = sorted list of starts (l) for vouchers in d.\n    #         starts_suffix_min[d] = suffix minimum array for the costs corresponding to starts_sorted[d].\n    #   And for Case A, we also need the end times of the vouchers in d? Actually, no: we are iterating over each voucher in d, so we need to know the end time of each voucher in d. But the end time is part of the voucher. So we must store the list of vouchers for d, not just starts and ends separately.\n    #\n    #   Revised: For each duration d, we have a list of vouchers = [(l1, r1, cost1), (l2, r2, cost2), ...]\n    #   Then, we can extract:\n    #         starts_list = [l for (l, r, cost) in vouchers]\n    #         ends_list = [r for (l, r, cost) in vouchers]\n    #         costs_list = [cost for (l, r, cost) in vouchers]\n    #\n    #   Then, for starts_sorted, we sort by l, and for starts_suffix_min, we use the costs in the same order as starts_sorted.\n    #\n    #   But note: the voucher's cost is fixed, and we are using the start time to sort. The cost is not necessarily tied to the start time. But that's fine.\n    #\n    #   Steps for each duration d:\n    #       vouchers = d_to_vouchers[d]\n    #       starts = sorted([l for (l, r, cost) in vouchers])\n    #       costs = [cost for (l, r, cost) in vouchers]\n    #       But wait, we lose the association between start and cost. We must keep the costs in the order of starts_sorted.\n    #       So: \n    #           temp = [(l, cost) for (l, r, cost) in vouchers]\n    #           temp_sorted = sorted(temp, key=lambda x: x[0])\n    #           starts_sorted = [t[0] for t in temp_sorted]\n    #           costs_sorted = [t[1] for t in temp_sorted]\n    #       Then, starts_suffix_min = [0]*len(starts_sorted)\n    #       starts_suffix_min[-1] = costs_sorted[-1]\n    #       for i in range(len(starts_sorted)-2, -1, -1):\n    #           starts_suffix_min[i] = min(starts_suffix_min[i+1], costs_sorted[i])\n    #\n    #   Then, for Case A (when d2 = x-d exists):\n    #       For each voucher in d (each has an end time r and cost c):\n    #           pos = bisect_right(starts_sorted[d2], r)  # gives the index of the first start in d2 that is > r\n    #           if pos < len(starts_sorted[d2]):\n    #               total = c + starts_suffix_min[d2][pos]\n    #               ans = min(ans, total)\n    #\n    #       Similarly, for Case B (when d2 exists):\n    #           For each voucher in d2 (each has an end time r and cost c):\n    #           pos = bisect_right(starts_sorted[d], r)  # first start in d that is > r\n    #           if pos < len(starts_sorted[d]):\n    #               total = c + starts_suffix_min[d][pos]\n    #               ans = min(ans, total)\n    #\n    #   But note: the above does not work for the same duration group (d == d2). In that case, we are iterating over the same list for both Case A and Case B, but that's okay because we are using the same starts_sorted and starts_suffix_min for d (which is d2). However, we must ensure that we are not accidentally using the same voucher twice. But as discussed, the condition ensures they are different.\n    #\n    #   However, there's a catch: In Case A, we are using the end time of a voucher in d and the start time of d2's vouchers. In Case B, we are using the end time of a voucher in d2 and the start time of d's vouchers. When d == d2, the two conditions are symmetric, but we are essentially checking the same thing twice? Actually, no: Case A and Case B are two different conditions. But note: if two vouchers don't intersect, then one of the two conditions must hold. So we need to check both.\n    #\n    #   But in the same group, a pair (i, j) can be considered in Case A (if r_i < l_j) or Case B (if r_j < l_i). But note that if they don't intersect, exactly one of these holds. So we are covering all non-intersecting pairs.\n    #\n    #   However, we must be cautious: the above nested loops (over d and then over each voucher in d) might be heavy if the same duration appears many times. But the total number of vouchers is 200000, so the worst-case is one duration with 200000 vouchers, then d2 = x - d might also have many vouchers. But the outer loop runs for each distinct duration d, and the inner loop runs for the number of vouchers in d. The total work is the sum over all d of |d| * log(|d2|). Since the sum of |d| is 200000, and the logarithm is at most 18, the total operations are about 200000 * 18 = 3.6e6, which is acceptable.\n    #\n    #   But note: the binary search for each voucher in d is O(log n), and we do that for each voucher in d. So for a duration d with k vouchers, we do k * log(k2) operations, where k2 is the size of d2.\n    #\n    #   However, worst-case scenario: if x is even and d = x/2, then d2 = d, and the group d might have many vouchers. But the worst-case total work is still bounded by the sum over d of (|d| * log(|d2|)).\n    #\n    #   Implementation:\n    #       Let ans = a large number (like 10**18)\n    #       Let d_set = set of all durations that appear.\n    #       For each duration d in d_set:\n    #           d2 = x - d\n    #           if d2 not in d_set: continue\n    #           If d == d2:\n    #               # Process Case A and Case B for the same group.\n    #               # But note: the same group is used for both cases, so we can do:\n    #               #   For each voucher in d, do Case A (using d2 = d) and Case B (using d = d2) but wait, Case A and Case B are defined differently.\n    #               # Actually, we can do:\n    #               #   Case A: use d2 = d, so we need starts_sorted[d] and starts_suffix_min[d] for d.\n    #               #   Case B: same.\n    #               # But note: the voucher in d has an end time r, and we need to find in d a voucher with start > r (for Case A) and also for Case B we use the same.\n    #               # Actually, for the same group, we are doing the same thing twice? No: Case A and Case B are two different ways to check non-intersection.\n    #               # But in fact, for two vouchers in the same group, if they don't intersect, then either the first ends before the second starts or the second ends before the first starts. So we need to check both.\n    #               # However, note: if we do Case A for a voucher i (with end r_i), we find a voucher j in d with start > r_i. This covers the condition that i ends before j starts.\n    #               # Similarly, Case B for a voucher j (with end r_j), we find a voucher i in d with start > r_j, which covers j ends before i starts.\n    #               # But note: if we do Case A for i and Case B for j, we might count the same pair twice? Actually, no: Case A for i finds j, and Case B for j finds i, but the total cost is the same (cost_i + cost_j). And we are taking the minimum, so it doesn't matter.\n    #               # But we must ensure that we don't use the same voucher twice. In Case A for i, we find j (which is different from i because the condition r_i < l_j cannot hold for j=i). Similarly for Case B.\n    #               #\n    #               # However, we can combine the two cases: we only need to consider each unordered pair once. But the problem does not require that; we can count the same pair twice (once in Case A and once in Case B) but the total cost is the same.\n    #               #\n    #               # So for the same group, we can do:\n    #                   for each voucher in d:\n    #                       # Case A: use this voucher's end to query d (same group) for start > end\n    #                   and separately:\n    #                   for each voucher in d:\n    #                       # Case B: use this voucher's end to query d (same group) for start > end\n    #               # But that's redundant: Case A and Case B are symmetric. Actually, we can simply do one of them and it will cover all non-intersecting pairs. Because if two vouchers i and j don't intersect, then either r_i < l_j (Case A) or r_j < l_i (Case B). But note: if we only do Case A (using the end of i to find j), then we might miss the pair if it is covered by Case B. However, the pair (i, j) is found in Case A if r_i < l_j, and in Case B if r_j < l_i. But if we only do Case A for all i, then we will find all pairs where the first voucher's end is less than the second's start. But the problem does not specify an order. However, note that the condition is symmetric: we are allowed to assign either voucher as the first. But in our iteration, we are iterating over each voucher and checking against the other group. For the same group, we are effectively checking both orders.\n    #               #\n    #               # Actually, for the same group, we must check both conditions. But note: if we do Case A for voucher i, we find j such that r_i < l_j. Then, the pair (i, j) is found. Similarly, if we do Case B for voucher i, we find j such that r_i < l_j? No: Case B is defined as finding a voucher in the other group (or same group) with start > the end of the current voucher. In the same group, Case A and Case B are identical in terms of the query: we are querying the same group's starts_suffix_min with the current voucher's end.\n    #               #\n    #               # Let me clarify:\n    #               #   Case A: For voucher i in d, query d2 (which is d) for a voucher with start > r_i.\n    #               #   Case B: For voucher i in d, query d (which is d2) for a voucher with start > r_i.\n    #               #   They are the same query!\n    #               #\n    #               #   But wait, the definition of Case B was: \"voucher from d2 ends before voucher from d starts\". In the same group, d2 = d, so we are querying d for a voucher with start > r_i (where r_i is the end of a voucher in d2). So yes, the query is the same.\n    #               #\n    #               #   Therefore, for the same group, we are doing the same thing twice. We can simply do one of them and it will cover all pairs.\n    #               #\n    #               #   But note: the condition for non-intersection is satisfied if either the first voucher ends before the second starts OR the second ends before the first starts. However, if we only check the condition \"voucher i ends before voucher j starts\" (Case A) for every ordered pair (i, j) (with i and j in the same group), then we will find all non-intersecting pairs. But note: we are not generating all ordered pairs; we are generating each pair twice: once as (i, j) and once as (j, i). But that's okay because the total cost is the same.\n    #               #\n    #               #   However, we must ensure that we are not using the same voucher twice. But the condition r_i < l_j ensures that i and j are distinct.\n    #               #\n    #               #   But there's a catch: the query for a voucher i is: find a voucher j in d with start > r_i. This j might be the same as i? No, because for the same voucher, we have l_i <= r_i, so start_i is not > r_i. Therefore, j is always different from i.\n    #               #\n    #               #   So for the same group, we can do:\n    #                   for each voucher in d:\n    #                       r_i = voucher's end\n    #                       find in d a voucher with start > r_i, and update ans = min(ans, cost_i + minimal_cost_found)\n    #               #   This will find every non-intersecting pair (i, j) where i is fixed and j is any voucher that starts after i ends.\n    #               #\n    #               #   But note: a pair (i, j) might be found when i is the one with the larger end time. However, if we only do this, we might miss the reverse condition? Actually, no: the condition is symmetric. The non-intersection condition is satisfied if either one ends before the other starts. But in our query, we are only checking one direction: that the current voucher i ends before some voucher j starts. We are not checking that some voucher j ends before i starts. But note: if two vouchers i and j do not intersect, then exactly one of the two conditions holds. However, in our query for i, we find j only if i ends before j starts. But if j ends before i starts, then when we query for j, we will find i. So we will eventually find the pair (i, j) when we process the voucher with the larger end time.\n    #               #\n    #               #   However, consider two vouchers: \n    #               #       i: [1, 3], cost = 10\n    #               #       j: [4, 6], cost = 20\n    #               #   Here, i ends at 3 < 4 (j's start), so when processing i, we find j and get cost 10+20=30.\n    #               #   Now, if we had only processed j first:\n    #               #       j: [4, 6], cost = 20\n    #               #       Query for j: find a voucher with start > 6. There is none, so no update.\n    #               #   But the pair (i, j) is found only once.\n    #               #\n    #               #   Now, consider two vouchers that are non-intersecting but in the other order:\n    #               #       i: [4, 6], cost = 20\n    #               #       j: [1, 3], cost = 10\n    #               #   Processing i: query for start > 6 -> nothing.\n    #               #   Processing j: query for start > 3 -> finds i (start 4 > 3), so update with 10+20=30.\n    #               #\n    #               #   So indeed, we find the pair in the reverse order.\n    #               #\n    #               #   Therefore, for the same group, we can simply do one query (Case A or Case B) for each voucher.\n    #               #\n    #               #   But note: the definition of Case A and Case B are slightly different in the general case (when d != d2). In the general case, Case A uses d's end to query d2's start, and Case B uses d2's end to query d's start. But in the same group, d2 = d, so both are the same.\n    #               #\n    #               #   So, to simplify, we can do:\n    #                   if d == d2:\n    #                       for each voucher in d:\n    #                           r_i = voucher's end\n    #                           pos = bisect_right(starts_sorted[d], r_i)\n    #                           if pos < len(starts_sorted[d]):\n    #                               candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                               ans = min(ans, candidate)\n    #                   else:\n    #                       # Case A: d and d2 are different\n    #                       for each voucher in d:\n    #                           r_i = voucher's end\n    #                           pos = bisect_right(starts_sorted[d2], r_i)\n    #                           if pos < len(starts_sorted[d2]):\n    #                               candidate = voucher's cost + starts_suffix_min[d2][pos]\n    #                               ans = min(ans, candidate)\n    #                       # Case B: d and d2 are different\n    #                       for each voucher in d2:\n    #                           r_i = voucher's end\n    #                           pos = bisect_right(starts_sorted[d], r_i)\n    #                           if pos < len(starts_sorted[d]):\n    #                               candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                               ans = min(ans, candidate)\n    #\n    #   However, wait: in the general case (d != d2), we are doing two separate iterations: one for d and one for d2. But note that d and d2 are distinct, so we are covering both directions.\n    #\n    #   But note: the problem asks for two distinct vouchers. In the same group, we are already ensuring they are distinct. In different groups, they are distinct by virtue of being in different groups.\n    #\n    #   However, there is a possibility that the same voucher appears in both groups if the same voucher has two different interpretations? No, each voucher has one duration. So if d != d2, then the vouchers are from different groups and hence distinct.\n    #\n    #   11. We must also consider that x might be odd and d = (x+1)/2 and d2 = (x-1)/2, but then d != d2, so we handle them separately.\n    #\n    #   12. Finally, if we never update ans (or ans remains the initial large value), then output -1.\n    #\n    #   However, note: there might be cases where d and d2 are the same, but the group has only one voucher. Then, we cannot form a pair. But the problem requires two distinct vouchers. In that case, the loop for the same group will not find any pair because each voucher's query will not find a matching voucher (since there's only one). So it's okay.\n    #\n    #   Let's test with the provided examples.\n    #\n    #   Example 1:\n    #       Input: \n    #           4 5\n    #           1 3 4\n    #           1 2 5\n    #           5 6 1\n    #           1 2 4\n    #       Durations: \n    #           voucher1: 3 (1-3+1)\n    #           voucher2: 2 (1-2+1)\n    #           voucher3: 2 (5-6+1)\n    #           voucher4: 2 (1-2+1)\n    #       x = 5, so we need durations that sum to 5: possibilities: (2,3) or (3,2).\n    #       d=2, d2=3: present.\n    #       For d=2, d2=3:\n    #           Case A: Iterate over vouchers in d=2 (vouchers2,3,4)\n    #               voucher2: (1,2,5) -> end=2, query d2=3: starts_sorted[3] = [1, 3] (from voucher1: (1,3,4))\n    #                   pos = bisect_right([1,3], 2) -> index=1, so starts_suffix_min[3][1] = 4 (the cost of voucher1)\n    #                   candidate = 5 + 4 = 9.\n    #               voucher3: (5,6,1) -> end=6, query d2=3: starts_sorted[3] = [1,3]; pos = bisect_right([1,3],6) -> 2, which is out of bounds, so no candidate.\n    #               voucher4: (1,2,4) -> end=2, same as voucher2: candidate = 4+4=8.\n    #           Case B: Iterate over vouchers in d2=3 (only voucher1: (1,3,4))\n    #               voucher1: end=3, query d=2: starts_sorted[2] = sorted starts of vouchers2,3,4: [1,1,5]\n    #                   pos = bisect_right([1,1,5], 3) -> index=3, out of bounds -> no candidate.\n    #           So the minimal candidate is 8.\n    #       But the expected answer is 5.\n    #       What's the issue? \n    #           The example says: choose first and third vouchers. \n    #           First voucher: (1,3,4) -> duration=3\n    #           Third voucher: (5,6,1) -> duration=2\n    #           Total duration=5, cost=4+1=5.\n    #       In our Case A for d=2 and d2=3, we should have considered the third voucher (duration2) and found the first voucher (duration3) because 6 (end of third) > 5 (start of first)? No, wait: the condition for Case A is that the voucher from d (duration2) ends before the voucher from d2 (duration3) starts. But the third voucher ends at 6, and the first voucher starts at 1. 6 is not < 1. So the condition fails.\n    #       But the non-intersection condition is satisfied because the first voucher ends at 3 and the third voucher starts at 5, and 3 < 5. So they don't intersect.\n    #       In our Case A, we used the end of the voucher from d (third voucher: end=6) to query d2 (first voucher) for a start > 6. But the first voucher starts at 1, which is not >6. \n    #       What went wrong? \n    #           The condition for non-intersection is: either r_i < l_j OR r_j < l_i.\n    #           In this case, we have r_i (6) and l_j (1): 6 < 1 is false.\n    #           And r_j (3) and l_i (5): 3 < 5 is true -> this is Case B, not Case A.\n    #       In our code for Case A, we only considered the condition that the voucher from d ends before the voucher from d2 starts. But in this example, the non-intersection is due to the voucher from d2 ending before the voucher from d starts. \n    #       Therefore, we must have handled it in Case B.\n    #       In Case B for d2=3 (voucher1: (1,3,4)) we query d=2 for a voucher with start > 3. \n    #           d=2 has starts_sorted=[1,1,5]. \n    #           We need a start > 3. The smallest start > 3 is 5 (from the third voucher). \n    #           starts_suffix_min for d=2: \n    #               starts_sorted = [1,1,5] -> sorted is [1,1,5]\n    #               costs_sorted = [5,4,1] -> but wait, we must associate costs with starts.\n    #               Actually, we built starts_suffix_min from the sorted starts and the corresponding costs.\n    #               So for d=2, the vouchers are:\n    #                   voucher2: (1,2,5)\n    #                   voucher3: (5,6,1)\n    #                   voucher4: (1,2,4)\n    #               Sorted by start: [1,1,5] with costs [5,4,1] -> but wait, the costs are not sorted. \n    #               We must sort by start and then take the costs in that order.\n    #               So: \n    #                   starts_sorted = [1,1,5]\n    #                   costs_sorted = [5,4,1]   -> but this is incorrect because the costs are not reordered by start.\n    #               Actually, we should do:\n    #                   temp = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]])\n    #                   Then, starts_sorted = [t[0] for t in temp]\n    #                   costs_sorted = [t[1] for t in temp]\n    #               For d=2, temp = [(1,5), (1,4), (5,1)] -> sorted by start: [ (1,5), (1,4), (5,1) ]\n    #               So costs_sorted = [5,4,1]\n    #               Then, starts_suffix_min[0] = min(5,4,1)=1\n    #               starts_suffix_min[1] = min(4,1)=1\n    #               starts_suffix_min[2] = 1\n    #               Now, for voucher1 (d2=3) with end=3, we query d=2 for start >3: \n    #                   pos = bisect_right(starts_sorted[2], 3) = bisect_right([1,1,5], 3) -> index=2 (because 3 is between 1 and 5, so insertion position is 2, and bisect_right returns the insertion position, which is 2).\n    #               Then, starts_suffix_min[2] = 1.\n    #               candidate = cost of voucher1 (4) + 1 = 5.\n    #       So we get 5, which is the expected answer.\n    #\n    #   Therefore, the mistake was in the example explanation: the non-intersection is due to the second voucher (d2=3) ending before the third voucher (d=2) starts. We handled it in Case B.\n    #\n    #   Example 2:\n    #       Input: \n    #           3 2\n    #           4 6 3\n    #           2 4 1\n    #           3 5 4\n    #       Each voucher has duration 3, so x=2 requires durations (1,1). But there is no duration 1. So we output -1.\n    #\n    #   Code Implementation:\n    #       We'll use sys.stdin to read input.\n    #       We'll create a dictionary d_to_vouchers.\n    #       Then, for each duration in d_to_vouchers, we build:\n    #           starts_sorted = sorted list of starts (l) for that duration.\n    #           But we need to keep the costs associated with the starts. We'll create a list of (l, cost) and sort by l, then extract starts_sorted and costs_sorted.\n    #       Then, build starts_suffix_min: an array where starts_suffix_min[i] = min(costs_sorted[i:])\n    #       Then, for each duration d in d_to_vouchers:\n    #           d2 = x - d\n    #           if d2 not in d_to_vouchers: continue\n    #           if d == d2:\n    #               for each voucher in d_to_vouchers[d]:\n    #                   r = voucher's end\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                       ans = min(ans, candidate)\n    #           else:\n    #               for each voucher in d_to_vouchers[d]:\n    #                   r = voucher's end\n    #                   pos = bisect_right(starts_sorted[d2], r)\n    #                   if pos < len(starts_sorted[d2]):\n    #                       candidate = voucher's cost + starts_suffix_min[d2][pos]\n    #                       ans = min(ans, candidate)\n    #               for each voucher in d_to_vouchers[d2]:\n    #                   r = voucher's end\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                       ans = min(ans, candidate)\n    #\n    #       Finally, if ans is still the initial large value, print -1, else print ans.\n    #\n    #   However, note: the above approach might be inefficient if there are many durations. But the total number of distinct durations is at most 200000, and the sum of the sizes of all groups is 200000. The worst-case is when there are many distinct durations, each with few vouchers. The outer loop runs for each distinct duration, and for each, we do a constant-time check (if d2 exists) and then iterate over the vouchers in that duration. The total work is O(total_vouchers) * O(log(size of other group)) for the binary search, which is acceptable.\n    #\n    #   But note: the starts_sorted for a duration might be large, but the binary search is O(log n) per voucher, and the total number of vouchers is 200000, so the total binary searches is 200000 * (number of times each voucher is processed). In the worst-case, a voucher in duration d might be processed twice (once in Case A and once in Case B) if d and d2 are different. But the total number of times a voucher is processed is equal to the number of durations d such that d + d_voucher_duration = x. But the voucher_duration is fixed for a voucher, say d0. Then, d must be x - d0. So each voucher is processed exactly once (either in Case A or Case B, depending on whether d0 and d = x-d0 exist). \n    #\n    #   Actually, no: if d0 is the duration of the voucher, then the condition d + d0 = x means d = x - d0. So for a voucher with duration d0, it is processed only when we consider duration d = x - d0. And then it is processed either in Case A (if d0 < d) or in Case B (if d0 > d) or in the same group if d0 == d.\n    #   Therefore, each voucher is processed at most once. The total number of vouchers processed is the total number of vouchers, 200000.\n    #\n    #   But wait, in the same group (d0 == d = x-d0), we process the voucher twice: once in the same-group branch and once in the different-group branch? No, in the same-group branch, we only consider the same duration. In the different-group branch, we consider durations d and d2 (different). So a voucher is processed once: when we consider its own duration d0, and if d2 = x-d0 exists, then it is processed in the different-group branch. If d2 does not exist, then it is not processed. But if d0 == d2, then we are in the same-group branch.\n    #\n    #   Therefore, the total work is O(n log m) where n is the total number of vouchers and m is the maximum size of any group (for the binary search). Since n is 200000 and m is at most 200000, the binary search is O(log(200000)) which is about 18, so total operations around 200000 * 18 = 3.6e6, which is acceptable.\n    #\n    #   Let's code accordingly.\n\n    # However, note: the above plan does not account for the fact that the same duration d might appear multiple times, but our grouping is by duration, so we are okay.\n\n    # Steps in code:\n\n    #   1. Read input.\n    #   2. Group by duration.\n    #   3. For each duration d in the dictionary, build:\n    #           starts_sorted[d] = sorted list of starts (l) for vouchers in d.\n    #           But we need to keep the costs, so:\n    #               temp = []\n    #               for (l, r, cost) in d_to_vouchers[d]:\n    #                   temp.append((l, cost))\n    #               temp_sorted = sorted(temp, key=lambda x: x[0])\n    #               starts_sorted[d] = [t[0] for t in temp_sorted]\n    #               costs_sorted[d] = [t[1] for t in temp_sorted]\n    #           Then, starts_suffix_min[d] = [0]*len(starts_sorted[d])\n    #           starts_suffix_min[d][-1] = costs_sorted[d][-1]\n    #           for i in range(len(starts_sorted[d])-2, -1, -1):\n    #               starts_suffix_min[d][i] = min(starts_suffix_min[d][i+1], costs_sorted[d][i])\n    #\n    #   4. Initialize ans = 10**18.\n    #   5. Let d_set = set of keys in d_to_vouchers.\n    #   6. For each d in d_set:\n    #           d2 = x - d\n    #           if d2 not in d_set: continue\n    #           if d == d2:\n    #               # Process the same group\n    #               for (l, r, cost) in d_to_vouchers[d]:\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = cost + starts_suffix_min[d][pos]\n    #                       if candidate < ans:\n    #                           ans = candidate\n    #           else:\n    #               # Case A: d and d2 are different\n    #               for (l, r, cost) in d_to_vouchers[d]:\n    #                   pos = bisect_right(starts_sorted[d2], r)\n    #                   if pos < len(starts_sorted[d2]):\n    #                       candidate = cost + starts_suffix_min[d2][pos]\n    #                       if candidate < ans:\n    #                           ans = candidate\n    #               # Case B: d and d2 are different\n    #               for (l, r, cost) in d_to_vouchers[d2]:\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = cost + starts_suffix_min[d][pos]\n    #                       if candidate < ans:\n    #                           ans = candidate\n    #\n    #   7. If ans is still 10**18, print -1, else print ans.\n\n    # However, note: the above builds starts_sorted and starts_suffix_min for each duration only once, outside the loop. But in the loop, we need to access starts_sorted[d] and starts_sorted[d2]. We must build these structures for all durations that appear.\n\n    # But wait, the above step 3 builds these structures for each duration. Then, in the loop, we use them.\n\n    # Let's do:\n\n    #   d_to_vouchers: dictionary mapping duration -> list of (l, r, cost)\n    #   d_to_starts_sorted = {}  # duration -> sorted list of starts\n    #   d_to_costs_sorted = {}    # duration -> sorted list of costs corresponding to starts_sorted\n    #   d_to_starts_suffix_min = {} # duration -> suffix minimum array for costs_sorted\n\n    #   for d in d_to_vouchers:\n    #       temp = [(l, cost) for (l, r, cost) in d_to_vouchers[d]]\n    #       temp_sorted = sorted(temp, key=lambda x: x[0])\n    #       starts_sorted = [t[0] for t in temp_sorted]\n    #       costs_sorted = [t[1] for t in temp_sorted]\n    #       d_to_starts_sorted[d] = starts_sorted\n    #       d_to_costs_sorted[d] = costs_sorted\n    #       n_d = len(starts_sorted)\n    #       suffix_min = [0]*n_d\n    #       if n_d > 0:\n    #           suffix_min[-1] = costs_sorted[-1]\n    #           for i in range(n_d-2, -1, -1):\n    #               suffix_min[i] = min(suffix_min[i+1], costs_sorted[i])\n    #       d_to_starts_suffix_min[d] = suffix_min\n\n    #   Then, in the main loop, we use these dictionaries.\n\n    # But note: the duration d might be very large (up to 200000) but we are only iterating over the durations that appear.\n\n    # Let's code accordingly.\n\n    # However, note: the duration d might be negative? No, because li, ri >=1, so duration>=1.\n\n    # Also, d2 = x - d might be negative or greater than the maximum duration present. But our d_set only contains positive durations that appear.\n\n    # We assume x is at least 2 and up to 400000 (2*200000).\n\n    # But if d2 is not in d_set, we skip.\n\n    # Let's code accordingly.\n\n    # Note: We must import bisect.\n\n    # Edge: if there are no vouchers for a particular duration, then d_to_starts_sorted[d] is empty. But we only build for durations that appear.\n\n    # Let's run through the example 1 again with this code.\n\n    # Example 1: \n    #   n=4, x=5\n    #   vouchers = [\n    #       (1,3,4),\n    #       (1,2,5),\n    #       (5,6,1),\n    #       (1,2,4)\n    #   ]\n    #   d_to_vouchers:\n    #       3: [(1,3,4)]\n    #       2: [(1,2,5), (5,6,1), (1,2,4)]\n    #   d_set = {2,3}\n    #   For d=2:\n    #       d2 = 5-2=3, which is in d_set.\n    #       Since d!=d2, do Case A and Case B.\n    #       Case A: for each voucher in d=2:\n    #           voucher (1,2,5): r=2, query d2=3: starts_sorted[3]=[1], costs_sorted[3]=[4], suffix_min[3]=[4]\n    #               pos = bisect_right([1], 2) -> 1 (since 2>1, so insertion at end, index=1)\n    #               1 >= len(starts_sorted[3])? 1==1, so no candidate.\n    #           voucher (5,6,1): r=6, query d2=3: pos = bisect_right([1],6)=1 -> no candidate.\n    #           voucher (1,2,4): r=2, same as above: no candidate.\n    #       Case B: for each voucher in d2=3:\n    #           voucher (1,3,4): r=3, query d=2: starts_sorted[2]= [1,1,5] (sorted starts: [1,1,5]), costs_sorted[2]=[5,4,1] (sorted by start), suffix_min[2]=[min(5,4,1)=1, min(4,1)=1, 1]\n    #               pos = bisect_right([1,1,5], 3) -> 2 (because 3 is between 1 and 5, so insertion at index2)\n    #               if 2 < 3: yes, candidate = 4 + suffix_min[2][2] = 4+1 = 5.\n    #       ans = 5.\n    #   Then, for d=3:\n    #       d2=5-3=2, which is in d_set.\n    #       Since d!=d2, do Case A and Case B (which is the same as above, so we'll get the same candidate 5 again, but it doesn't matter).\n    #   So ans=5.\n\n    #   Example 2:\n    #       n=3, x=2\n    #       vouchers = [\n    #           (4,6,3),\n    #           (2,4,1),\n    #           (3,5,4)\n    #       ]\n    #       durations: each is 3.\n    #       d_set = {3}\n    #       For d=3: d2=2-3=-1 -> not in d_set, skip.\n    #       So no candidates, output -1.\n\n    #   It matches.\n\n    #   One more edge: what if x is very large, say 400000, and the durations are up to 200000? Then d2 = x-d might be up to 400000, which is beyond the maximum duration present (max is 200000). But our d_set only contains durations from 1 to 200000, so d2 will not be in d_set. So we skip.\n\n    #   Let's code accordingly.\n\n    #   However, note: the duration d is at most 200000, and x is at most 400000, so d2 = x-d might be negative or greater than 200000. We only consider d2 if it is in d_set, which contains durations from 1 to 200000.\n\n    #   We assume that the maximum day is 200000, so the maximum duration is 200000.\n\n    #   Code Implementation:\n\n    import sys\n    from bisect import bisect_right\n\n    def main():\n        data = sys.stdin.read().split()\n        it = iter(data)\n        n = int(next(it)); x = int(next(it))\n        vouchers = []\n        for i in range(n):\n            l = int(next(it)); r = int(next(it)); cost = int(next(it))\n            vouchers.append((l, r, cost))\n        \n        d_to_vouchers = {}\n        for (l, r, cost) in vouchers:\n            dur = r - l + 1\n            if dur not in d_to_vouchers:\n                d_to_vouchers[dur] = []\n            d_to_vouchers[dur].append((l, r, cost))\n        \n        # Build dictionaries for starts_sorted, costs_sorted, and starts_suffix_min for each duration that appears.\n        d_to_starts_sorted = {}\n        d_to_costs_sorted = {}\n        d_to_starts_suffix_min = {}\n        \n        for dur, voucher_list in d_to_vouchers.items():\n            temp = []\n            for (l, r, cost) in voucher_list:\n                temp.append((l, cost))\n            temp_sorted = sorted(temp, key=lambda x: x[0])\n            starts_sorted = [t[0] for t in temp_sorted]\n            costs_sorted = [t[1] for t in temp_sorted]\n            d_to_starts_sorted[dur] = starts_sorted\n            d_to_costs_sorted[dur] = costs_sorted\n            \n            n_d = len(starts_sorted)\n            suffix_min = [0] * n_d\n            if n_d == 0:\n                continue\n            suffix_min[-1] = costs_sorted[-1]\n            for i in range(n_d-2, -1, -1):\n                suffix_min[i] = min(suffix_min[i+1], costs_sorted[i])\n            d_to_starts_suffix_min[dur] = suffix_min\n        \n        ans = 10**18\n        d_set = set(d_to_vouchers.keys())\n        \n        # Iterate over each duration d that appears\n        for d in d_set:\n            d2 = x - d\n            if d2 not in d_set:\n                continue\n            if d == d2:\n                # Same group\n                for (l, r, cost) in d_to_vouchers[d]:\n                    # Query the starts_sorted[d] for the first index where start > r\n                    pos = bisect_right(d_to_starts_sorted[d], r)\n                    if pos < len(d_to_starts_sorted[d]):\n                        candidate = cost + d_to_starts_suffix_min[d][pos]\n                        if candidate < ans:\n                            ans = candidate\n            else:\n                # Different groups: Case A and Case B\n                # Case A: use d's vouchers, query d2's starts_suffix_min\n                for (l, r, cost) in d_to_vouchers[d]:\n                    pos = bisect_right(d_to_starts_sorted[d2], r)\n                    if pos < len(d_to_starts_sorted[d2]):\n                        candidate = cost + d_to_starts_suffix_min[d2][pos]\n                        if candidate < ans:\n                            ans = candidate\n                # Case B: use d2's vouchers, query d's starts_suffix_min\n                for (l, r, cost) in d_to_vouchers[d2]:\n                    pos = bisect_right(d_to_starts_sorted[d], r)\n                    if pos < len(d_to_starts_sorted[d]):\n                        candidate = cost + d_to_starts_suffix_min[d][pos]\n                        if candidate < ans:\n                            ans = candidate\n        \n        if ans == 10**18:\n            print(-1)\n        else:\n            print(ans)\n\n    if __name__ == '__main__':\n        main()\n```\n\n### Explanation\nThe solution involves grouping travel vouchers by their duration and then efficiently checking for pairs of non-intersecting vouchers whose durations sum to exactly `x`. For each duration `d`, we check if there exists another duration `d2 = x - d`. Using binary search and suffix minimum arrays, we quickly determine the minimal cost for valid pairs without explicitly iterating over all possible combinations, ensuring optimal performance. The algorithm handles edge cases such as no valid pairs by initializing the answer to a large value and checking if it remains unchanged.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    \n    vouchers = []\n    max_day = 0\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost = int(next(it))\n        vouchers.append((l, r, cost))\n        max_day = max(max_day, r)\n    \n    d_to_vouchers = {}\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        if dur not in d_to_vouchers:\n            d_to_vouchers[dur] = []\n        d_to_vouchers[dur].append((l, r, cost))\n    \n    all_durations = list(d_to_vouchers.keys())\n    \n    # Precompute for each duration: sort by l and also by r, and prepare lists of costs for valid intervals.\n    # But we will also create two structures for each duration:\n    #   One sorted by l (start) and one sorted by r (end)\n    # However, we can do: for each duration, we have two sorted lists: one by start and one by end.\n    # Actually, we'll create for each duration a list of tuples (l, r, cost) and sort them by l and by r separately.\n    \n    # But note: we need to check two conditions: \n    #   Condition 1: A voucher from group d ends before a voucher from group (x-d) starts.\n    #   Condition 2: A voucher from group (x-d) ends before a voucher from group d starts.\n    \n    # Instead, we can precompute for each duration the following:\n    #   By start: sorted by l, and then extract the minimal cost for a given range [l_min, l_max] but actually we need to know the minimal cost for a voucher that starts at or above a certain point? Not exactly.\n    #\n    # Alternatively, we can precompute for each duration:\n    #   Let's have:\n    #       starts[d] = sorted list of (l, cost) for vouchers of duration d.\n    #       ends[d] = sorted list of (r, cost) for vouchers of duration d.\n    #\n    # Then, for two durations d1 and d2 (where d1 + d2 == x), we want to find:\n    #   Case 1: A voucher in d1 with end < start of a voucher in d2.\n    #   Case 2: A voucher in d2 with end < start of a voucher in d1.\n    #\n    # For Case 1:\n    #   We can take all vouchers in d1 (each has an end time r1) and find the minimal cost among those with r1 < some start s2 of a voucher in d2.\n    #   Similarly, for Case 2.\n    #\n    # How to do it efficiently?\n    #   Precompute for each duration d:\n    #       sorted_ends = sorted(ends[d])   # by r\n    #       and also a prefix minimum array for the costs in sorted_ends so that we can quickly get the minimal cost for any prefix.\n    #\n    # Steps for each duration d:\n    #   Let's create:\n    #       starts[d] = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]])\n    #       ends[d] = sorted([(r, cost) for (l, r, cost) in d_to_vouchers[d]])\n    #\n    #   Then for starts[d], we can create a Fenwick tree or segment tree for costs, but since the start values can be up to 200000, we can use a sorted list and bisect.\n    #\n    # However, note: the condition for non-intersection in Case 1 is r1 < s2. We can iterate over all possible d1 and d2, but that would be O(n^2) which is too slow.\n    #\n    # Instead, we can do:\n    #   For each duration d, let d2 = x - d.\n    #   If d2 not in d_to_vouchers, skip.\n    #   Then, we consider two cases:\n    #       Case A: Find a voucher in d with r < s (s is the start of a voucher in d2).\n    #       Case B: Find a voucher in d2 with r < s (s is the start of a voucher in d).\n    #\n    #   For Case A:\n    #       We need to consider all vouchers in d (each has an end time r) and for each such voucher, we look for a voucher in d2 with start time > r. Then, we take the minimal cost from d and d2 that satisfy this.\n    #\n    #   But doing this naively would be O(n1 * n2). We need a better way.\n    #\n    # Alternative approach:\n    #   Precompute for each duration d:\n    #       A sorted list of starts (l) and a sorted list of ends (r) along with their costs.\n    #       Also, build a structure that allows us to quickly query the minimal cost in d2 for vouchers with start > some value (for Case A) and similarly for d (for Case B).\n    #\n    #   We can use two separate dictionaries for starts and ends for each duration, but then how to combine?\n    #\n    # Another idea: Instead of iterating over every d1 and d2, we can precompute for each duration d the minimal cost for a voucher that ends at a certain time or starts at a certain time. But note the constraints (n, x up to 200000) and the day values up to 200000.\n    #\n    # Let's reframe: We want to find two vouchers i and j such that:\n    #   d_i + d_j = x, and either r_i < l_j or r_j < l_i.\n    #   And minimize cost_i + cost_j.\n    #\n    # We can precompute two arrays:\n    #   For each duration d, we have a list of (l, r, cost). We sort these by l and by r.\n    #   Then, for each d, we can create an array of minimal costs for vouchers that start at or above a certain day (for Case A) and similarly for ending below a certain day (for Case B).\n    #\n    # However, note that the condition for Case A is that the end of voucher i is less than the start of voucher j. So if we fix voucher i (from duration d), then we need a voucher j (from duration d2) with l_j > r_i. We can preprocess the vouchers for each duration d2 by creating a sorted list of starts and a prefix minimum cost array for those starts.\n    #\n    # Steps:\n    #   1. Group vouchers by duration and for each duration, create two lists:\n    #         starts[d] = sorted list of starts (l) for vouchers of duration d.\n    #         ends[d] = sorted list of ends (r) for vouchers of duration d.\n    #   2. For each duration d, we also create a list of costs and then build a prefix minimum array for the starts and suffix minimum array for the ends.\n    #   3. For each d from 1 to max_duration (which is up to 200000), set d2 = x - d. If d2 is not in d_to_vouchers, skip.\n    #   4. For Case A: For each voucher in d (with end time r), we need to find in d2 a voucher with start time > r. We can use the starts[d2] list and binary search to find the first start time greater than r, then use the prefix minimum array of d2 to get the minimal cost for vouchers starting after r.\n    #   5. Similarly, for Case B: For each voucher in d2 (with end time r), find in d a voucher with start time > r, and use the prefix minimum array of d to get the minimal cost.\n    #   6. Take the minimum of the results from both cases.\n    #\n    # But note: the number of vouchers per duration might be large, and iterating over each voucher in d for Case A could be O(n^2). We need to optimize further.\n    #\n    # We can instead for each duration d, precompute the minimal cost for all vouchers that end before a certain time. Specifically, for each duration d, we can create an array of end times and then a suffix minimum array (from high to low end time) so that for a given end time r, we can quickly get the minimal cost among vouchers in d that end <= r (but actually for Case A we need vouchers that end < some start, so we need the minimal cost among vouchers ending before a given start).\n    #\n    # Actually, let's define:\n    #   For each duration d, we have a list of (l, r, cost). We can sort by r (end time). Then, we can create an array min_cost_from_end[d] where min_cost_from_end[d][i] is the minimal cost among the first i+1 vouchers (the ones with smallest end times). Then, for a given start time s, we can find the largest end time that is < s, and then get the minimal cost from the prefix up to that index.\n    #\n    # Similarly, for starts: we can create a sorted list of starts and a prefix minimum array for costs based on start times.\n    #\n    # However, note: In Case A, we have a voucher from d1 (duration d) with end time r1, and we need a voucher from d2 (duration d2) with start time > r1. So we can use the starts[d2] list to find the minimal cost voucher in d2 that has start time > r1.\n    #\n    # Steps for Case A for a fixed d and d2:\n    #   - Get all vouchers in d (each has an end time r1).\n    #   - For each r1, we need to find in d2 the minimal cost among vouchers with start time > r1.\n    #   - But instead of iterating over each voucher in d, we can precompute for d2 a structure that allows us to query the minimal cost for vouchers with start time > r1 quickly.\n    #\n    # We can precompute for each duration d2:\n    #   starts_sorted = sorted(starts[d2])\n    #   prefix_min_start = [0] * len(starts_sorted)\n    #   For i in range(len(starts_sorted)):\n    #       if i == 0:\n    #           prefix_min_start[i] = starts_sorted[i][1]  # but wait, starts_sorted is just the start times? Actually, we stored (l, cost) for each voucher.\n    #       else:\n    #           prefix_min_start[i] = min(prefix_min_start[i-1], starts_sorted[i][1])\n    #\n    #   Then, for a given r1, we find the position pos = bisect_right(starts_sorted, r1)  # first index where start > r1 is pos.\n    #   If pos == len(starts_sorted): no voucher in d2 has start > r1.\n    #   Else, the minimal cost for d2 vouchers with start > r1 is prefix_min_start[pos-1] if we did prefix_min_start for the entire array? Actually, our prefix_min_start should be built from the beginning to the end, so if we want the minimal cost for vouchers starting at or above a certain point, we need to reverse the array or build a suffix minimum array.\n    #\n    # Alternatively, we can build a suffix minimum array for d2's starts:\n    #   Sort d2's starts by l (increasing), then compute an array suffix_min[i] which is the minimal cost from i to the end.\n    #   Then, find the first index i such that starts_sorted[i][0] > r1, then the minimal cost is suffix_min[i].\n    #\n    # But note: we have stored the starts as (l, cost) and we want to sort by l. Then, we can do:\n    #   starts_sorted = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]], key=lambda x: x[0])\n    #   Then, create an array of just the start times and an array of costs, and then a suffix minimum array for costs.\n    #\n    # Similarly for Case B, but for duration d and d2, we need to find in d a voucher with start time > r2 (where r2 is the end time of a voucher in d2).\n    #\n    # However, note: the total number of durations is at most 200000, but the sum of the sizes of all groups might be large (n up to 200000). But note that the same duration might appear many times, so we have to be careful.\n    #\n    # But the total number of vouchers is n, so the total work over all durations is O(n) if we process each voucher once. However, for each duration d, we might be processing each voucher in d against the entire group of d2. That could be O(n^2) in the worst case.\n    #\n    # We need to avoid that. Instead, we can precompute for each duration d the following:\n    #   Let starts_list = sorted list of (l, cost) for d.\n    #   Let ends_list = sorted list of (r, cost) for d.\n    #   Then, for each d, we can also precompute:\n    #       starts_prefix_min = [...]   # not directly useful for Case A\n    #       starts_suffix_min = [...]   # from right to left, minimal cost for starts >= current start\n    #       ends_prefix_min = [...]      # minimal cost for vouchers ending <= some value (for Case B)\n    #       ends_suffix_min = [...]      # minimal cost for vouchers ending >= some value (not needed)\n    #\n    # Actually, for Case A (voucher from d ends before voucher from d2 starts):\n    #   We need to find in d2: the minimal cost voucher with start > r (where r is the end of a voucher in d).\n    #   So for d2, we can precompute:\n    #       starts_sorted = sorted(starts_list, key=lambda x: x[0])\n    #       Then, create an array of start times and a suffix minimum array for the costs (from the last element to the first).\n    #\n    #   Similarly, for Case B (voucher from d2 ends before voucher from d starts):\n    #       We need to find in d: the minimal cost voucher with start > r (where r is the end of a voucher in d2).\n    #       So for d, we can precompute:\n    #           starts_sorted = sorted(starts_list, key=lambda x: x[0])\n    #           Then, create an array of start times and a suffix minimum array for the costs.\n    #\n    # Now, for each duration d, we can precompute:\n    #   starts_suffix_min[d] = an array where for each index i (in the sorted starts of d by l) the minimal cost from i to the end.\n    #   Similarly, for each duration d, we can precompute ends_prefix_min[d] = an array where for each index i (in the sorted ends of d by r) the minimal cost from start to i.\n    #\n    # But note: for Case A, we are looking in d2 for a voucher with start > r (the end of a voucher in d). We can use the starts_suffix_min for d2: \n    #   Find the smallest start in d2 that is > r, then the minimal cost from that position onward is the answer for d2 for that r.\n    #\n    # However, we must do this for every voucher in d? That would be O(n1 * log(n2)) for each d, which might be acceptable if the total number of durations is small, but note: the durations range from 1 to 200000, and we only consider d and d2 = x-d, so the number of pairs (d, d2) is at most 200000. But the total number of vouchers is 200000, so the sum over all d of the size of d is 200000. Therefore, if we iterate over each voucher in d for each d, the total complexity would be O(n^2) in the worst case, which is not acceptable.\n    #\n    # We need to reverse the thinking: Instead of iterating over each duration d and then over each voucher in d, we can precompute for each duration d the minimal cost for vouchers that end below a certain start time (or start above a certain end time) and then combine these precomputed values.\n    #\n    # Alternative efficient approach:\n    #   We can iterate over all vouchers once and record their (l, r, cost, duration) and then use dynamic programming or two pointers. But the condition involves two vouchers with specific durations.\n    #\n    # After careful thought, here's a more efficient plan:\n    #   Step 1: Group vouchers by duration as before.\n    #   Step 2: For each duration d, we create two sorted lists:\n    #           starts[d] = sorted list of starts (l) for vouchers in d.\n    #           ends[d] = sorted list of ends (r) for vouchers in d.\n    #   Step 3: For each duration d, we also create a list of costs and then build:\n    #           starts_suffix_min[d] = an array where starts_suffix_min[i] is the minimal cost among the vouchers from i to the end (when starts[d] is sorted).\n    #           ends_prefix_min[d] = an array where ends_prefix_min[i] is the minimal cost among the vouchers from start to i (when ends[d] is sorted).\n    #\n    #   Step 4: For each duration d, and for each d2 = x - d (if d2 exists and d2 >= d to avoid double counting? Actually, we must consider both orders because d and d2 are distinct unless d = x/2, then we consider pairs within the same group):\n    #           Case A: Voucher in d ends before voucher in d2 starts.\n    #                   For each voucher in d, we have an end time r. We need to find the minimal cost in d2 for a voucher with start > r.\n    #                   We can use the starts_suffix_min for d2: find the first index in starts[d2] where the start is > r, then the minimal cost is starts_suffix_min[d2][index].\n    #           Case B: Voucher in d2 ends before voucher in d starts.\n    #                   Similarly, for each voucher in d2, we have an end time r. We need to find the minimal cost in d for a voucher with start > r.\n    #                   Use starts_suffix_min for d.\n    #\n    #   But again, iterating over each voucher in d and d2 would be too slow.\n    #\n    # We need to avoid iterating over each voucher. Instead, we can precompute for each duration d the minimal cost for a voucher with start > some value, and then for a given end time r (from the other duration), we can quickly retrieve the minimal cost from d2 that has start > r.\n    #\n    # Let's define for each duration d:\n    #   starts_sorted = sorted(starts[d])\n    #   starts_suffix_min = [0]*len(starts_sorted)\n    #   We'll create an array of (start, cost) for d, then sort by start. Then, from the last element to the first, we compute the minimal cost from that position to the end.\n    #\n    #   Similarly, for ends_sorted = sorted(ends[d])\n    #   ends_prefix_min = [0]*len(ends_sorted)\n    #   Compute from the first element to the last the minimal cost for vouchers ending <= a given value.\n    #\n    # Then, for Case A (voucher in d ends before voucher in d2 starts):\n    #   We have a voucher in d with end time r. We need to find the minimal cost in d2 for a voucher with start > r.\n    #   In d2, we have starts_sorted_d2 and starts_suffix_min_d2.\n    #   Find the smallest start in starts_sorted_d2 that is > r. Let idx = bisect_right(starts_sorted_d2, r) -> the insertion position, so the first index with start > r is idx.\n    #   If idx >= len(starts_sorted_d2), then no voucher in d2 satisfies the condition.\n    #   Otherwise, the minimal cost from d2 for start > r is starts_suffix_min_d2[idx].\n    #\n    # But note: we cannot iterate over each voucher in d because that would be O(n^2). Instead, we can precompute for each duration d the minimal cost for all possible end times, but the end times can be up to 200000.\n    #\n    # Actually, we can precompute for each duration d a function f_d(r) = minimal cost in d for a voucher with start > r. But note, the start of a voucher in d is independent of its end. However, we have the starts_sorted and starts_suffix_min for d, so f_d(r) is simply starts_suffix_min_d2[idx] where idx is the position in starts_sorted_d2 for r.\n    #\n    # But then how do we combine with the ends of d? We want to consider all vouchers in d and for each, use f_{d2}(r) where r is the end of that voucher. This still requires iterating over each voucher in d.\n    #\n    # However, note that the total number of vouchers is 200000, and the sum over all durations of the sizes of the groups is 200000. But the number of pairs (d, d2) is about the number of distinct durations, which is at most 200000. For each duration d, we would iterate over all vouchers in d and for each, do a binary search in d2's starts_sorted. The total work would be the sum over all d of |d| * log(|d2|). Since the sum of |d| over all d is 200000, and the logarithm is at most 18, the total operations would be around 200000 * 18 = 3.6e6, which is acceptable.\n    #\n    # Similarly for Case B.\n    #\n    # Steps for the algorithm:\n    #   1. Read input and group vouchers by duration.\n    #   2. For each duration d that exists, do:\n    #           starts_sorted[d] = sorted(list of starts for vouchers in d)\n    #           ends_sorted[d] = sorted(list of ends for vouchers in d)\n    #           starts_suffix_min[d] = array for starts_sorted: from the last element to the first, the minimal cost.\n    #           ends_prefix_min[d] = array for ends_sorted: from the first element to the last, the minimal cost.\n    #   3. Initialize ans = a very large number.\n    #   4. For each duration d from 1 to max_duration (or for each key in d_to_vouchers):\n    #           d2 = x - d\n    #           If d2 not in d_to_vouchers, continue.\n    #           If d == d2:\n    #               Consider pairs within the same group. But note: the condition is two different vouchers (so we must pick two distinct vouchers). However, the problem does not require the two vouchers to be distinct in the sense of being different vouchers, but they must be two different ones. In the same duration group, we need two non-overlapping vouchers.\n    #               But note: two vouchers in the same duration might overlap or not. We need to find two vouchers i and j in d such that either r_i < l_j or r_j < l_i.\n    #               We can do:\n    #                   For each voucher i in d, find a voucher j in d (j != i) that does not intersect.\n    #               But this is similar to the previous cases, but now d2 = d.\n    #           Else:\n    #               Case A: For each voucher in d (each has an end time r), find the minimal cost in d2 for a voucher with start > r.\n    #                       Let candidate = starts_suffix_min[d2][position] (after binary search in starts_sorted[d2])\n    #                       Then, the total cost is cost_i + candidate. But note: we don't have the cost_i stored separately in the suffix_min for d2. Actually, we have to store the cost along with the start.\n    #               Correction: Our starts_suffix_min[d] should be computed from the list of (start, cost) for d, sorted by start.\n    #               So, for each duration d, we have:\n    #                   starts_with_cost = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]], key=lambda x: x[0])\n    #                   Then, starts_sorted = [l for (l, cost) in starts_with_cost]\n    #                   costs = [cost for (l, cost) in starts_with_cost]\n    #                   Then, starts_suffix_min = [0]*len(starts_sorted)\n    #                   starts_suffix_min[-1] = costs[-1]\n    #                   for i in range(len(starts_sorted)-2, -1, -1):\n    #                       starts_suffix_min[i] = min(starts_suffix_min[i+1], costs[i])\n    #\n    #               Then, for a given end time r from a voucher in d, we do:\n    #                   pos = bisect_right(starts_sorted[d2], r)\n    #                   if pos < len(starts_sorted[d2]):\n    #                       candidate_cost = starts_suffix_min[d2][pos]\n    #                   else:\n    #                       candidate_cost = None\n    #               Then, for the voucher in d with cost c, the total cost is c + candidate_cost.\n    #               But wait, we lost the cost of the voucher in d! We only have the cost from d2. We need to associate the cost of the voucher in d with its end time.\n    #\n    #           We must store the cost of each voucher in d. So when we iterate over vouchers in d, we have to consider each voucher individually.\n    #\n    #   Revised plan for Case A:\n    #       For a fixed duration d and d2 = x - d, we want to find the minimal total cost from:\n    #           min_{i in d, j in d2} { cost_i + cost_j }  subject to r_i < l_j.\n    #       We can do:\n    #           Let A = list of (r, cost) for vouchers in d.\n    #           Let B = starts_with_cost for d2 (sorted by start, with suffix_min array for costs).\n    #           Then, for each (r, cost_i) in A, we find the minimal cost_j in B such that start_j > r.\n    #           Then, candidate = cost_i + minimal_cost_j (if exists)\n    #           Then, ans = min(ans, candidate)\n    #\n    #       Similarly for Case B:\n    #           Let A = starts_with_cost for d (sorted by start, with suffix_min array for costs).\n    #           Let B = list of (r, cost) for vouchers in d2.\n    #           For each (r, cost_j) in B, find minimal cost_i in A such that start_i > r.\n    #           Then, candidate = cost_i + cost_j (but note: cost_j is fixed, and cost_i is minimal from A)\n    #           Then, ans = min(ans, candidate)\n    #\n    #   5. But note: the same voucher might be used twice? No, because d and d2 are different durations (or if same, then we are considering two different vouchers in the same duration group). In the same duration group, we must ensure that the two vouchers are distinct. However, the problem states \"two vouchers i and j (i ≠ j)\", so we must avoid using the same voucher twice. But in our grouping, if d == d2, then we are considering the same group. In that case, when we iterate over each voucher in d and then look for a voucher in d2 (which is the same group) with start > r, we might pick the same voucher? \n    #\n    #       Example: voucher i and j in the same group, and we require r_i < l_j. If the same voucher is used twice, then we would have r_i < l_i? That is impossible because l_i <= r_i. So the same voucher cannot satisfy the condition. Therefore, we are automatically picking two different vouchers.\n    #\n    #   6. Implementation details:\n    #       - We need to precompute for each duration d:\n    #             starts_sorted[d] = sorted list of starts (l) for vouchers in d.\n    #             starts_suffix_min[d] = suffix minimum array for the costs corresponding to starts_sorted[d].\n    #             ends_sorted[d] = sorted list of ends (r) for vouchers in d.\n    #             ends_prefix_min[d] = prefix minimum array for the costs corresponding to ends_sorted[d].\n    #\n    #       But for Case A, we need the starts_sorted and starts_suffix_min for d2, and for Case B, we need the starts_sorted and starts_suffix_min for d.\n    #\n    #       However, note: for Case A, we are iterating over vouchers in d (each has an end time r) and we need to query d2's starts_suffix_min. For Case B, we are iterating over vouchers in d2 (each has an end time r) and querying d's starts_suffix_min.\n    #\n    #       But wait, in Case B, the condition is that the voucher from d2 ends before the voucher from d starts. So we need to find in d a voucher with start > r (where r is the end of the voucher in d2). This is exactly what starts_suffix_min[d] is for: given a start threshold, find the minimal cost voucher in d with start > threshold.\n    #\n    #       However, note: the voucher in d must have a start time > the end time of the voucher in d2. But the start time of the voucher in d is not related to its end time. We have stored the start times of d in starts_sorted[d], which is independent of the end times. This is correct because the condition only depends on the start of the voucher in d.\n    #\n    #   7. Edge: When d2 is not present, skip.\n    #   8. Also, when d == d2, we are considering the same group. We must ensure that we are not using the same voucher twice, but as reasoned, the condition r_i < l_j cannot hold for the same voucher, so it's safe.\n    #\n    #   9. We must also consider that a voucher might have multiple attributes (l, r, cost), and we are storing starts and ends separately. But that's okay.\n    #\n    #   10. Finally, if we find no valid pair, output -1.\n    #\n    # Let's code accordingly, but note: the total number of distinct durations might be up to 200000, but most durations might not appear. We only need to consider durations that are in the input and for which d2 = x - d is also in the input.\n    #\n    # Steps in code:\n    #   - Read input and group vouchers by duration.\n    #   - Build a dictionary: d_to_vouchers, mapping duration -> list of (l, r, cost)\n    #   - Build dictionaries for starts_sorted and starts_suffix_min for each duration that appears.\n    #   - Also build ends_sorted and ends_prefix_min if needed (but for Case A and Case B, we only need starts_sorted and starts_suffix_min for the other duration).\n    #   - But note: in Case B, we are using the starts_suffix_min of d, so we don't need ends_sorted for d in Case A, but we do need ends_sorted for d in Case B? Actually, no: in Case B, we are iterating over vouchers in d2 and for each, we query d's starts_suffix_min. The voucher in d2 has an end time r, and we need to find in d a voucher with start > r.\n    #       This only requires d's starts_sorted and starts_suffix_min.\n    #\n    #   However, wait: in Case B, the condition is that the voucher from d2 ends before the voucher from d starts. So we are using the end time of d2's voucher to query d's starts. We do not need the end times of d's vouchers for Case B.\n    #\n    #   Similarly, in Case A, we are using the end time of d's voucher to query d2's starts. We do not need the start times of d's vouchers for Case A.\n    #\n    #   Therefore, we only need to precompute for each duration d:\n    #         starts_sorted[d] = sorted list of starts (l) for vouchers in d.\n    #         starts_suffix_min[d] = suffix minimum array for the costs corresponding to starts_sorted[d].\n    #   And for Case A, we also need the end times of the vouchers in d? Actually, no: we are iterating over each voucher in d, so we need to know the end time of each voucher in d. But the end time is part of the voucher. So we must store the list of vouchers for d, not just starts and ends separately.\n    #\n    #   Revised: For each duration d, we have a list of vouchers = [(l1, r1, cost1), (l2, r2, cost2), ...]\n    #   Then, we can extract:\n    #         starts_list = [l for (l, r, cost) in vouchers]\n    #         ends_list = [r for (l, r, cost) in vouchers]\n    #         costs_list = [cost for (l, r, cost) in vouchers]\n    #\n    #   Then, for starts_sorted, we sort by l, and for starts_suffix_min, we use the costs in the same order as starts_sorted.\n    #\n    #   But note: the voucher's cost is fixed, and we are using the start time to sort. The cost is not necessarily tied to the start time. But that's fine.\n    #\n    #   Steps for each duration d:\n    #       vouchers = d_to_vouchers[d]\n    #       starts = sorted([l for (l, r, cost) in vouchers])\n    #       costs = [cost for (l, r, cost) in vouchers]\n    #       But wait, we lose the association between start and cost. We must keep the costs in the order of starts_sorted.\n    #       So: \n    #           temp = [(l, cost) for (l, r, cost) in vouchers]\n    #           temp_sorted = sorted(temp, key=lambda x: x[0])\n    #           starts_sorted = [t[0] for t in temp_sorted]\n    #           costs_sorted = [t[1] for t in temp_sorted]\n    #       Then, starts_suffix_min = [0]*len(starts_sorted)\n    #       starts_suffix_min[-1] = costs_sorted[-1]\n    #       for i in range(len(starts_sorted)-2, -1, -1):\n    #           starts_suffix_min[i] = min(starts_suffix_min[i+1], costs_sorted[i])\n    #\n    #   Then, for Case A (when d2 = x-d exists):\n    #       For each voucher in d (each has an end time r and cost c):\n    #           pos = bisect_right(starts_sorted[d2], r)  # gives the index of the first start in d2 that is > r\n    #           if pos < len(starts_sorted[d2]):\n    #               total = c + starts_suffix_min[d2][pos]\n    #               ans = min(ans, total)\n    #\n    #       Similarly, for Case B (when d2 exists):\n    #           For each voucher in d2 (each has an end time r and cost c):\n    #           pos = bisect_right(starts_sorted[d], r)  # first start in d that is > r\n    #           if pos < len(starts_sorted[d]):\n    #               total = c + starts_suffix_min[d][pos]\n    #               ans = min(ans, total)\n    #\n    #   But note: the above does not work for the same duration group (d == d2). In that case, we are iterating over the same list for both Case A and Case B, but that's okay because we are using the same starts_sorted and starts_suffix_min for d (which is d2). However, we must ensure that we are not accidentally using the same voucher twice. But as discussed, the condition ensures they are different.\n    #\n    #   However, there's a catch: In Case A, we are using the end time of a voucher in d and the start time of d2's vouchers. In Case B, we are using the end time of a voucher in d2 and the start time of d's vouchers. When d == d2, the two conditions are symmetric, but we are essentially checking the same thing twice? Actually, no: Case A and Case B are two different conditions. But note: if two vouchers don't intersect, then one of the two conditions must hold. So we need to check both.\n    #\n    #   But in the same group, a pair (i, j) can be considered in Case A (if r_i < l_j) or Case B (if r_j < l_i). But note that if they don't intersect, exactly one of these holds. So we are covering all non-intersecting pairs.\n    #\n    #   However, we must be cautious: the above nested loops (over d and then over each voucher in d) might be heavy if the same duration appears many times. But the total number of vouchers is 200000, so the worst-case is one duration with 200000 vouchers, then d2 = x - d might also have many vouchers. But the outer loop runs for each distinct duration d, and the inner loop runs for the number of vouchers in d. The total work is the sum over all d of |d| * log(|d2|). Since the sum of |d| is 200000, and the logarithm is at most 18, the total operations are about 200000 * 18 = 3.6e6, which is acceptable.\n    #\n    #   But note: the binary search for each voucher in d is O(log n), and we do that for each voucher in d. So for a duration d with k vouchers, we do k * log(k2) operations, where k2 is the size of d2.\n    #\n    #   However, worst-case scenario: if x is even and d = x/2, then d2 = d, and the group d might have many vouchers. But the worst-case total work is still bounded by the sum over d of (|d| * log(|d2|)).\n    #\n    #   Implementation:\n    #       Let ans = a large number (like 10**18)\n    #       Let d_set = set of all durations that appear.\n    #       For each duration d in d_set:\n    #           d2 = x - d\n    #           if d2 not in d_set: continue\n    #           If d == d2:\n    #               # Process Case A and Case B for the same group.\n    #               # But note: the same group is used for both cases, so we can do:\n    #               #   For each voucher in d, do Case A (using d2 = d) and Case B (using d = d2) but wait, Case A and Case B are defined differently.\n    #               # Actually, we can do:\n    #               #   Case A: use d2 = d, so we need starts_sorted[d] and starts_suffix_min[d] for d.\n    #               #   Case B: same.\n    #               # But note: the voucher in d has an end time r, and we need to find in d a voucher with start > r (for Case A) and also for Case B we use the same.\n    #               # Actually, for the same group, we are doing the same thing twice? No: Case A and Case B are two different ways to check non-intersection.\n    #               # But in fact, for two vouchers in the same group, if they don't intersect, then either the first ends before the second starts or the second ends before the first starts. So we need to check both.\n    #               # However, note: if we do Case A for a voucher i (with end r_i), we find a voucher j in d with start > r_i. This covers the condition that i ends before j starts.\n    #               # Similarly, Case B for a voucher j (with end r_j), we find a voucher i in d with start > r_j, which covers j ends before i starts.\n    #               # But note: if we do Case A for i and Case B for j, we might count the same pair twice? Actually, no: Case A for i finds j, and Case B for j finds i, but the total cost is the same (cost_i + cost_j). And we are taking the minimum, so it doesn't matter.\n    #               # But we must ensure that we don't use the same voucher twice. In Case A for i, we find j (which is different from i because the condition r_i < l_j cannot hold for j=i). Similarly for Case B.\n    #               #\n    #               # However, we can combine the two cases: we only need to consider each unordered pair once. But the problem does not require that; we can count the same pair twice (once in Case A and once in Case B) but the total cost is the same.\n    #               #\n    #               # So for the same group, we can do:\n    #                   for each voucher in d:\n    #                       # Case A: use this voucher's end to query d (same group) for start > end\n    #                   and separately:\n    #                   for each voucher in d:\n    #                       # Case B: use this voucher's end to query d (same group) for start > end\n    #               # But that's redundant: Case A and Case B are symmetric. Actually, we can simply do one of them and it will cover all non-intersecting pairs. Because if two vouchers i and j don't intersect, then either r_i < l_j (Case A) or r_j < l_i (Case B). But note: if we only do Case A (using the end of i to find j), then we might miss the pair if it is covered by Case B. However, the pair (i, j) is found in Case A if r_i < l_j, and in Case B if r_j < l_i. But if we only do Case A for all i, then we will find all pairs where the first voucher's end is less than the second's start. But the problem does not specify an order. However, note that the condition is symmetric: we are allowed to assign either voucher as the first. But in our iteration, we are iterating over each voucher and checking against the other group. For the same group, we are effectively checking both orders.\n    #               #\n    #               # Actually, for the same group, we must check both conditions. But note: if we do Case A for voucher i, we find j such that r_i < l_j. Then, the pair (i, j) is found. Similarly, if we do Case B for voucher i, we find j such that r_i < l_j? No: Case B is defined as finding a voucher in the other group (or same group) with start > the end of the current voucher. In the same group, Case A and Case B are identical in terms of the query: we are querying the same group's starts_suffix_min with the current voucher's end.\n    #               #\n    #               # Let me clarify:\n    #               #   Case A: For voucher i in d, query d2 (which is d) for a voucher with start > r_i.\n    #               #   Case B: For voucher i in d, query d (which is d2) for a voucher with start > r_i.\n    #               #   They are the same query!\n    #               #\n    #               #   But wait, the definition of Case B was: \"voucher from d2 ends before voucher from d starts\". In the same group, d2 = d, so we are querying d for a voucher with start > r_i (where r_i is the end of a voucher in d2). So yes, the query is the same.\n    #               #\n    #               #   Therefore, for the same group, we are doing the same thing twice. We can simply do one of them and it will cover all pairs.\n    #               #\n    #               #   But note: the condition for non-intersection is satisfied if either the first voucher ends before the second starts OR the second ends before the first starts. However, if we only check the condition \"voucher i ends before voucher j starts\" (Case A) for every ordered pair (i, j) (with i and j in the same group), then we will find all non-intersecting pairs. But note: we are not generating all ordered pairs; we are generating each pair twice: once as (i, j) and once as (j, i). But that's okay because the total cost is the same.\n    #               #\n    #               #   However, we must ensure that we are not using the same voucher twice. But the condition r_i < l_j ensures that i and j are distinct.\n    #               #\n    #               #   But there's a catch: the query for a voucher i is: find a voucher j in d with start > r_i. This j might be the same as i? No, because for the same voucher, we have l_i <= r_i, so start_i is not > r_i. Therefore, j is always different from i.\n    #               #\n    #               #   So for the same group, we can do:\n    #                   for each voucher in d:\n    #                       r_i = voucher's end\n    #                       find in d a voucher with start > r_i, and update ans = min(ans, cost_i + minimal_cost_found)\n    #               #   This will find every non-intersecting pair (i, j) where i is fixed and j is any voucher that starts after i ends.\n    #               #\n    #               #   But note: a pair (i, j) might be found when i is the one with the larger end time. However, if we only do this, we might miss the reverse condition? Actually, no: the condition is symmetric. The non-intersection condition is satisfied if either one ends before the other starts. But in our query, we are only checking one direction: that the current voucher i ends before some voucher j starts. We are not checking that some voucher j ends before i starts. But note: if two vouchers i and j do not intersect, then exactly one of the two conditions holds. However, in our query for i, we find j only if i ends before j starts. But if j ends before i starts, then when we query for j, we will find i. So we will eventually find the pair (i, j) when we process the voucher with the larger end time.\n    #               #\n    #               #   However, consider two vouchers: \n    #               #       i: [1, 3], cost = 10\n    #               #       j: [4, 6], cost = 20\n    #               #   Here, i ends at 3 < 4 (j's start), so when processing i, we find j and get cost 10+20=30.\n    #               #   Now, if we had only processed j first:\n    #               #       j: [4, 6], cost = 20\n    #               #       Query for j: find a voucher with start > 6. There is none, so no update.\n    #               #   But the pair (i, j) is found only once.\n    #               #\n    #               #   Now, consider two vouchers that are non-intersecting but in the other order:\n    #               #       i: [4, 6], cost = 20\n    #               #       j: [1, 3], cost = 10\n    #               #   Processing i: query for start > 6 -> nothing.\n    #               #   Processing j: query for start > 3 -> finds i (start 4 > 3), so update with 10+20=30.\n    #               #\n    #               #   So indeed, we find the pair in the reverse order.\n    #               #\n    #               #   Therefore, for the same group, we can simply do one query (Case A or Case B) for each voucher.\n    #               #\n    #               #   But note: the definition of Case A and Case B are slightly different in the general case (when d != d2). In the general case, Case A uses d's end to query d2's start, and Case B uses d2's end to query d's start. But in the same group, d2 = d, so both are the same.\n    #               #\n    #               #   So, to simplify, we can do:\n    #                   if d == d2:\n    #                       for each voucher in d:\n    #                           r_i = voucher's end\n    #                           pos = bisect_right(starts_sorted[d], r_i)\n    #                           if pos < len(starts_sorted[d]):\n    #                               candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                               ans = min(ans, candidate)\n    #                   else:\n    #                       # Case A: d and d2 are different\n    #                       for each voucher in d:\n    #                           r_i = voucher's end\n    #                           pos = bisect_right(starts_sorted[d2], r_i)\n    #                           if pos < len(starts_sorted[d2]):\n    #                               candidate = voucher's cost + starts_suffix_min[d2][pos]\n    #                               ans = min(ans, candidate)\n    #                       # Case B: d and d2 are different\n    #                       for each voucher in d2:\n    #                           r_i = voucher's end\n    #                           pos = bisect_right(starts_sorted[d], r_i)\n    #                           if pos < len(starts_sorted[d]):\n    #                               candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                               ans = min(ans, candidate)\n    #\n    #   However, wait: in the general case (d != d2), we are doing two separate iterations: one for d and one for d2. But note that d and d2 are distinct, so we are covering both directions.\n    #\n    #   But note: the problem asks for two distinct vouchers. In the same group, we are already ensuring they are distinct. In different groups, they are distinct by virtue of being in different groups.\n    #\n    #   However, there is a possibility that the same voucher appears in both groups if the same voucher has two different interpretations? No, each voucher has one duration. So if d != d2, then the vouchers are from different groups and hence distinct.\n    #\n    #   11. We must also consider that x might be odd and d = (x+1)/2 and d2 = (x-1)/2, but then d != d2, so we handle them separately.\n    #\n    #   12. Finally, if we never update ans (or ans remains the initial large value), then output -1.\n    #\n    #   However, note: there might be cases where d and d2 are the same, but the group has only one voucher. Then, we cannot form a pair. But the problem requires two distinct vouchers. In that case, the loop for the same group will not find any pair because each voucher's query will not find a matching voucher (since there's only one). So it's okay.\n    #\n    #   Let's test with the provided examples.\n    #\n    #   Example 1:\n    #       Input: \n    #           4 5\n    #           1 3 4\n    #           1 2 5\n    #           5 6 1\n    #           1 2 4\n    #       Durations: \n    #           voucher1: 3 (1-3+1)\n    #           voucher2: 2 (1-2+1)\n    #           voucher3: 2 (5-6+1)\n    #           voucher4: 2 (1-2+1)\n    #       x = 5, so we need durations that sum to 5: possibilities: (2,3) or (3,2).\n    #       d=2, d2=3: present.\n    #       For d=2, d2=3:\n    #           Case A: Iterate over vouchers in d=2 (vouchers2,3,4)\n    #               voucher2: (1,2,5) -> end=2, query d2=3: starts_sorted[3] = [1, 3] (from voucher1: (1,3,4))\n    #                   pos = bisect_right([1,3], 2) -> index=1, so starts_suffix_min[3][1] = 4 (the cost of voucher1)\n    #                   candidate = 5 + 4 = 9.\n    #               voucher3: (5,6,1) -> end=6, query d2=3: starts_sorted[3] = [1,3]; pos = bisect_right([1,3],6) -> 2, which is out of bounds, so no candidate.\n    #               voucher4: (1,2,4) -> end=2, same as voucher2: candidate = 4+4=8.\n    #           Case B: Iterate over vouchers in d2=3 (only voucher1: (1,3,4))\n    #               voucher1: end=3, query d=2: starts_sorted[2] = sorted starts of vouchers2,3,4: [1,1,5]\n    #                   pos = bisect_right([1,1,5], 3) -> index=3, out of bounds -> no candidate.\n    #           So the minimal candidate is 8.\n    #       But the expected answer is 5.\n    #       What's the issue? \n    #           The example says: choose first and third vouchers. \n    #           First voucher: (1,3,4) -> duration=3\n    #           Third voucher: (5,6,1) -> duration=2\n    #           Total duration=5, cost=4+1=5.\n    #       In our Case A for d=2 and d2=3, we should have considered the third voucher (duration2) and found the first voucher (duration3) because 6 (end of third) > 5 (start of first)? No, wait: the condition for Case A is that the voucher from d (duration2) ends before the voucher from d2 (duration3) starts. But the third voucher ends at 6, and the first voucher starts at 1. 6 is not < 1. So the condition fails.\n    #       But the non-intersection condition is satisfied because the first voucher ends at 3 and the third voucher starts at 5, and 3 < 5. So they don't intersect.\n    #       In our Case A, we used the end of the voucher from d (third voucher: end=6) to query d2 (first voucher) for a start > 6. But the first voucher starts at 1, which is not >6. \n    #       What went wrong? \n    #           The condition for non-intersection is: either r_i < l_j OR r_j < l_i.\n    #           In this case, we have r_i (6) and l_j (1): 6 < 1 is false.\n    #           And r_j (3) and l_i (5): 3 < 5 is true -> this is Case B, not Case A.\n    #       In our code for Case A, we only considered the condition that the voucher from d ends before the voucher from d2 starts. But in this example, the non-intersection is due to the voucher from d2 ending before the voucher from d starts. \n    #       Therefore, we must have handled it in Case B.\n    #       In Case B for d2=3 (voucher1: (1,3,4)) we query d=2 for a voucher with start > 3. \n    #           d=2 has starts_sorted=[1,1,5]. \n    #           We need a start > 3. The smallest start > 3 is 5 (from the third voucher). \n    #           starts_suffix_min for d=2: \n    #               starts_sorted = [1,1,5] -> sorted is [1,1,5]\n    #               costs_sorted = [5,4,1] -> but wait, we must associate costs with starts.\n    #               Actually, we built starts_suffix_min from the sorted starts and the corresponding costs.\n    #               So for d=2, the vouchers are:\n    #                   voucher2: (1,2,5)\n    #                   voucher3: (5,6,1)\n    #                   voucher4: (1,2,4)\n    #               Sorted by start: [1,1,5] with costs [5,4,1] -> but wait, the costs are not sorted. \n    #               We must sort by start and then take the costs in that order.\n    #               So: \n    #                   starts_sorted = [1,1,5]\n    #                   costs_sorted = [5,4,1]   -> but this is incorrect because the costs are not reordered by start.\n    #               Actually, we should do:\n    #                   temp = sorted([(l, cost) for (l, r, cost) in d_to_vouchers[d]])\n    #                   Then, starts_sorted = [t[0] for t in temp]\n    #                   costs_sorted = [t[1] for t in temp]\n    #               For d=2, temp = [(1,5), (1,4), (5,1)] -> sorted by start: [ (1,5), (1,4), (5,1) ]\n    #               So costs_sorted = [5,4,1]\n    #               Then, starts_suffix_min[0] = min(5,4,1)=1\n    #               starts_suffix_min[1] = min(4,1)=1\n    #               starts_suffix_min[2] = 1\n    #               Now, for voucher1 (d2=3) with end=3, we query d=2 for start >3: \n    #                   pos = bisect_right(starts_sorted[2], 3) = bisect_right([1,1,5], 3) -> index=2 (because 3 is between 1 and 5, so insertion position is 2, and bisect_right returns the insertion position, which is 2).\n    #               Then, starts_suffix_min[2] = 1.\n    #               candidate = cost of voucher1 (4) + 1 = 5.\n    #       So we get 5, which is the expected answer.\n    #\n    #   Therefore, the mistake was in the example explanation: the non-intersection is due to the second voucher (d2=3) ending before the third voucher (d=2) starts. We handled it in Case B.\n    #\n    #   Example 2:\n    #       Input: \n    #           3 2\n    #           4 6 3\n    #           2 4 1\n    #           3 5 4\n    #       Each voucher has duration 3, so x=2 requires durations (1,1). But there is no duration 1. So we output -1.\n    #\n    #   Code Implementation:\n    #       We'll use sys.stdin to read input.\n    #       We'll create a dictionary d_to_vouchers.\n    #       Then, for each duration in d_to_vouchers, we build:\n    #           starts_sorted = sorted list of starts (l) for that duration.\n    #           But we need to keep the costs associated with the starts. We'll create a list of (l, cost) and sort by l, then extract starts_sorted and costs_sorted.\n    #       Then, build starts_suffix_min: an array where starts_suffix_min[i] = min(costs_sorted[i:])\n    #       Then, for each duration d in d_to_vouchers:\n    #           d2 = x - d\n    #           if d2 not in d_to_vouchers: continue\n    #           if d == d2:\n    #               for each voucher in d_to_vouchers[d]:\n    #                   r = voucher's end\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                       ans = min(ans, candidate)\n    #           else:\n    #               for each voucher in d_to_vouchers[d]:\n    #                   r = voucher's end\n    #                   pos = bisect_right(starts_sorted[d2], r)\n    #                   if pos < len(starts_sorted[d2]):\n    #                       candidate = voucher's cost + starts_suffix_min[d2][pos]\n    #                       ans = min(ans, candidate)\n    #               for each voucher in d_to_vouchers[d2]:\n    #                   r = voucher's end\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = voucher's cost + starts_suffix_min[d][pos]\n    #                       ans = min(ans, candidate)\n    #\n    #       Finally, if ans is still the initial large value, print -1, else print ans.\n    #\n    #   However, note: the above approach might be inefficient if there are many durations. But the total number of distinct durations is at most 200000, and the sum of the sizes of all groups is 200000. The worst-case is when there are many distinct durations, each with few vouchers. The outer loop runs for each distinct duration, and for each, we do a constant-time check (if d2 exists) and then iterate over the vouchers in that duration. The total work is O(total_vouchers) * O(log(size of other group)) for the binary search, which is acceptable.\n    #\n    #   But note: the starts_sorted for a duration might be large, but the binary search is O(log n) per voucher, and the total number of vouchers is 200000, so the total binary searches is 200000 * (number of times each voucher is processed). In the worst-case, a voucher in duration d might be processed twice (once in Case A and once in Case B) if d and d2 are different. But the total number of times a voucher is processed is equal to the number of durations d such that d + d_voucher_duration = x. But the voucher_duration is fixed for a voucher, say d0. Then, d must be x - d0. So each voucher is processed exactly once (either in Case A or Case B, depending on whether d0 and d = x-d0 exist). \n    #\n    #   Actually, no: if d0 is the duration of the voucher, then the condition d + d0 = x means d = x - d0. So for a voucher with duration d0, it is processed only when we consider duration d = x - d0. And then it is processed either in Case A (if d0 < d) or in Case B (if d0 > d) or in the same group if d0 == d.\n    #   Therefore, each voucher is processed at most once. The total number of vouchers processed is the total number of vouchers, 200000.\n    #\n    #   But wait, in the same group (d0 == d = x-d0), we process the voucher twice: once in the same-group branch and once in the different-group branch? No, in the same-group branch, we only consider the same duration. In the different-group branch, we consider durations d and d2 (different). So a voucher is processed once: when we consider its own duration d0, and if d2 = x-d0 exists, then it is processed in the different-group branch. If d2 does not exist, then it is not processed. But if d0 == d2, then we are in the same-group branch.\n    #\n    #   Therefore, the total work is O(n log m) where n is the total number of vouchers and m is the maximum size of any group (for the binary search). Since n is 200000 and m is at most 200000, the binary search is O(log(200000)) which is about 18, so total operations around 200000 * 18 = 3.6e6, which is acceptable.\n    #\n    #   Let's code accordingly.\n\n    # However, note: the above plan does not account for the fact that the same duration d might appear multiple times, but our grouping is by duration, so we are okay.\n\n    # Steps in code:\n\n    #   1. Read input.\n    #   2. Group by duration.\n    #   3. For each duration d in the dictionary, build:\n    #           starts_sorted[d] = sorted list of starts (l) for vouchers in d.\n    #           But we need to keep the costs, so:\n    #               temp = []\n    #               for (l, r, cost) in d_to_vouchers[d]:\n    #                   temp.append((l, cost))\n    #               temp_sorted = sorted(temp, key=lambda x: x[0])\n    #               starts_sorted[d] = [t[0] for t in temp_sorted]\n    #               costs_sorted[d] = [t[1] for t in temp_sorted]\n    #           Then, starts_suffix_min[d] = [0]*len(starts_sorted[d])\n    #           starts_suffix_min[d][-1] = costs_sorted[d][-1]\n    #           for i in range(len(starts_sorted[d])-2, -1, -1):\n    #               starts_suffix_min[d][i] = min(starts_suffix_min[d][i+1], costs_sorted[d][i])\n    #\n    #   4. Initialize ans = 10**18.\n    #   5. Let d_set = set of keys in d_to_vouchers.\n    #   6. For each d in d_set:\n    #           d2 = x - d\n    #           if d2 not in d_set: continue\n    #           if d == d2:\n    #               # Process the same group\n    #               for (l, r, cost) in d_to_vouchers[d]:\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = cost + starts_suffix_min[d][pos]\n    #                       if candidate < ans:\n    #                           ans = candidate\n    #           else:\n    #               # Case A: d and d2 are different\n    #               for (l, r, cost) in d_to_vouchers[d]:\n    #                   pos = bisect_right(starts_sorted[d2], r)\n    #                   if pos < len(starts_sorted[d2]):\n    #                       candidate = cost + starts_suffix_min[d2][pos]\n    #                       if candidate < ans:\n    #                           ans = candidate\n    #               # Case B: d and d2 are different\n    #               for (l, r, cost) in d_to_vouchers[d2]:\n    #                   pos = bisect_right(starts_sorted[d], r)\n    #                   if pos < len(starts_sorted[d]):\n    #                       candidate = cost + starts_suffix_min[d][pos]\n    #                       if candidate < ans:\n    #                           ans = candidate\n    #\n    #   7. If ans is still 10**18, print -1, else print ans.\n\n    # However, note: the above builds starts_sorted and starts_suffix_min for each duration only once, outside the loop. But in the loop, we need to access starts_sorted[d] and starts_sorted[d2]. We must build these structures for all durations that appear.\n\n    # But wait, the above step 3 builds these structures for each duration. Then, in the loop, we use them.\n\n    # Let's do:\n\n    #   d_to_vouchers: dictionary mapping duration -> list of (l, r, cost)\n    #   d_to_starts_sorted = {}  # duration -> sorted list of starts\n    #   d_to_costs_sorted = {}    # duration -> sorted list of costs corresponding to starts_sorted\n    #   d_to_starts_suffix_min = {} # duration -> suffix minimum array for costs_sorted\n\n    #   for d in d_to_vouchers:\n    #       temp = [(l, cost) for (l, r, cost) in d_to_vouchers[d]]\n    #       temp_sorted = sorted(temp, key=lambda x: x[0])\n    #       starts_sorted = [t[0] for t in temp_sorted]\n    #       costs_sorted = [t[1] for t in temp_sorted]\n    #       d_to_starts_sorted[d] = starts_sorted\n    #       d_to_costs_sorted[d] = costs_sorted\n    #       n_d = len(starts_sorted)\n    #       suffix_min = [0]*n_d\n    #       if n_d > 0:\n    #           suffix_min[-1] = costs_sorted[-1]\n    #           for i in range(n_d-2, -1, -1):\n    #               suffix_min[i] = min(suffix_min[i+1], costs_sorted[i])\n    #       d_to_starts_suffix_min[d] = suffix_min\n\n    #   Then, in the main loop, we use these dictionaries.\n\n    # But note: the duration d might be very large (up to 200000) but we are only iterating over the durations that appear.\n\n    # Let's code accordingly.\n\n    # However, note: the duration d might be negative? No, because li, ri >=1, so duration>=1.\n\n    # Also, d2 = x - d might be negative or greater than the maximum duration present. But our d_set only contains positive durations that appear.\n\n    # We assume x is at least 2 and up to 400000 (2*200000).\n\n    # But if d2 is not in d_set, we skip.\n\n    # Let's code accordingly.\n\n    # Note: We must import bisect.\n\n    # Edge: if there are no vouchers for a particular duration, then d_to_starts_sorted[d] is empty. But we only build for durations that appear.\n\n    # Let's run through the example 1 again with this code.\n\n    # Example 1: \n    #   n=4, x=5\n    #   vouchers = [\n    #       (1,3,4),\n    #       (1,2,5),\n    #       (5,6,1),\n    #       (1,2,4)\n    #   ]\n    #   d_to_vouchers:\n    #       3: [(1,3,4)]\n    #       2: [(1,2,5), (5,6,1), (1,2,4)]\n    #   d_set = {2,3}\n    #   For d=2:\n    #       d2 = 5-2=3, which is in d_set.\n    #       Since d!=d2, do Case A and Case B.\n    #       Case A: for each voucher in d=2:\n    #           voucher (1,2,5): r=2, query d2=3: starts_sorted[3]=[1], costs_sorted[3]=[4], suffix_min[3]=[4]\n    #               pos = bisect_right([1], 2) -> 1 (since 2>1, so insertion at end, index=1)\n    #               1 >= len(starts_sorted[3])? 1==1, so no candidate.\n    #           voucher (5,6,1): r=6, query d2=3: pos = bisect_right([1],6)=1 -> no candidate.\n    #           voucher (1,2,4): r=2, same as above: no candidate.\n    #       Case B: for each voucher in d2=3:\n    #           voucher (1,3,4): r=3, query d=2: starts_sorted[2]= [1,1,5] (sorted starts: [1,1,5]), costs_sorted[2]=[5,4,1] (sorted by start), suffix_min[2]=[min(5,4,1)=1, min(4,1)=1, 1]\n    #               pos = bisect_right([1,1,5], 3) -> 2 (because 3 is between 1 and 5, so insertion at index2)\n    #               if 2 < 3: yes, candidate = 4 + suffix_min[2][2] = 4+1 = 5.\n    #       ans = 5.\n    #   Then, for d=3:\n    #       d2=5-3=2, which is in d_set.\n    #       Since d!=d2, do Case A and Case B (which is the same as above, so we'll get the same candidate 5 again, but it doesn't matter).\n    #   So ans=5.\n\n    #   Example 2:\n    #       n=3, x=2\n    #       vouchers = [\n    #           (4,6,3),\n    #           (2,4,1),\n    #           (3,5,4)\n    #       ]\n    #       durations: each is 3.\n    #       d_set = {3}\n    #       For d=3: d2=2-3=-1 -> not in d_set, skip.\n    #       So no candidates, output -1.\n\n    #   It matches.\n\n    #   One more edge: what if x is very large, say 400000, and the durations are up to 200000? Then d2 = x-d might be up to 400000, which is beyond the maximum duration present (max is 200000). But our d_set only contains durations from 1 to 200000, so d2 will not be in d_set. So we skip.\n\n    #   Let's code accordingly.\n\n    #   However, note: the duration d is at most 200000, and x is at most 400000, so d2 = x-d might be negative or greater than 200000. We only consider d2 if it is in d_set, which contains durations from 1 to 200000.\n\n    #   We assume that the maximum day is 200000, so the maximum duration is 200000.\n\n    #   Code Implementation:\n\n    import sys\n    from bisect import bisect_right\n\n    def main():\n        data = sys.stdin.read().split()\n        it = iter(data)\n        n = int(next(it)); x = int(next(it))\n        vouchers = []\n        for i in range(n):\n            l = int(next(it)); r = int(next(it)); cost = int(next(it))\n            vouchers.append((l, r, cost))\n        \n        d_to_vouchers = {}\n        for (l, r, cost) in vouchers:\n            dur = r - l + 1\n            if dur not in d_to_vouchers:\n                d_to_vouchers[dur] = []\n            d_to_vouchers[dur].append((l, r, cost))\n        \n        # Build dictionaries for starts_sorted, costs_sorted, and starts_suffix_min for each duration that appears.\n        d_to_starts_sorted = {}\n        d_to_costs_sorted = {}\n        d_to_starts_suffix_min = {}\n        \n        for dur, voucher_list in d_to_vouchers.items():\n            temp = []\n            for (l, r, cost) in voucher_list:\n                temp.append((l, cost))\n            temp_sorted = sorted(temp, key=lambda x: x[0])\n            starts_sorted = [t[0] for t in temp_sorted]\n            costs_sorted = [t[1] for t in temp_sorted]\n            d_to_starts_sorted[dur] = starts_sorted\n            d_to_costs_sorted[dur] = costs_sorted\n            \n            n_d = len(starts_sorted)\n            suffix_min = [0] * n_d\n            if n_d == 0:\n                continue\n            suffix_min[-1] = costs_sorted[-1]\n            for i in range(n_d-2, -1, -1):\n                suffix_min[i] = min(suffix_min[i+1], costs_sorted[i])\n            d_to_starts_suffix_min[dur] = suffix_min\n        \n        ans = 10**18\n        d_set = set(d_to_vouchers.keys())\n        \n        # Iterate over each duration d that appears\n        for d in d_set:\n            d2 = x - d\n            if d2 not in d_set:\n                continue\n            if d == d2:\n                # Same group\n                for (l, r, cost) in d_to_vouchers[d]:\n                    # Query the starts_sorted[d] for the first index where start > r\n                    pos = bisect_right(d_to_starts_sorted[d], r)\n                    if pos < len(d_to_starts_sorted[d]):\n                        candidate = cost + d_to_starts_suffix_min[d][pos]\n                        if candidate < ans:\n                            ans = candidate\n            else:\n                # Different groups: Case A and Case B\n                # Case A: use d's vouchers, query d2's starts_suffix_min\n                for (l, r, cost) in d_to_vouchers[d]:\n                    pos = bisect_right(d_to_starts_sorted[d2], r)\n                    if pos < len(d_to_starts_sorted[d2]):\n                        candidate = cost + d_to_starts_suffix_min[d2][pos]\n                        if candidate < ans:\n                            ans = candidate\n                # Case B: use d2's vouchers, query d's starts_suffix_min\n                for (l, r, cost) in d_to_vouchers[d2]:\n                    pos = bisect_right(d_to_starts_sorted[d], r)\n                    if pos < len(d_to_starts_sorted[d]):\n                        candidate = cost + d_to_starts_suffix_min[d][pos]\n                        if candidate < ans:\n                            ans = candidate\n        \n        if ans == 10**18:\n            print(-1)\n        else:\n            print(ans)\n\n    if __name__ == '__main__':\n        main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 734,
        "completion_token_count": 17634,
        "thoughts_token_count": 1023
    }
}