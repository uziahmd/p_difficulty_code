{
    "start": 1758094067.5411732,
    "end": 1758095869.7902005,
    "start-formatted": "2025-09-17 16:27 KST",
    "end-formatted": "2025-09-17 16:57 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given up to 100000 items, each with weight in {1,2,3} and cost up to 10^9.\n The total weight m is up to 300000.\n\n Since the weights are only 1, 2, or 3, we can break down the problem by grouping the items by their weight.\n\n Let:\n   A = list of costs for items with weight 1\n   B = list of costs for items with weight 2\n   C = list of costs for items with weight 3\n\n Then, we can use the following idea:\n\n We are going to consider taking k1 items of weight 1, k2 items of weight 2, k3 items of weight 3, such that:\n   k1 + 2*k2 + 3*k3 <= m\n\n And we want to maximize: (sum of top k1 items from A) + (sum of top k2 items from B) + (sum of top k3 items from C)\n\n However, note that the total number of items is large (up to 100000) and the total weight m is up to 300000.\n\n We can precompute prefix sums for each group:\n\n   Sort each group in descending order, then compute the prefix sums.\n\n Then, the problem becomes: choose non-negative integers k1, k2, k3 (with k1<=|A|, k2<=|B|, k3<=|C|) such that:\n   k1 + 2*k2 + 3*k3 <= m\n   and we maximize: prefixA[k1] + prefixB[k2] + prefixC[k3]\n\n But note: the constraints on m (300000) and the fact that k1, k2, k3 can be large (each up to about 100000) means we cannot iterate over all triples.\n\n Alternative approach:\n\n Since the weights are small (only 1,2,3), we can iterate over the number of weight3 items (k3) and then for each k3, we have a remaining weight: m - 3*k3.\n\n Then, we need to allocate the remaining weight between weight1 and weight2. Let R = m - 3*k3.\n\n Now, we can use at most R//3 for weight3? Actually, no: we have fixed k3. Then we have two types: weight1 and weight2.\n\n We can also note that the problem is similar to having two coins: 1 and 2 (with two separate sets of items). But note: we have two independent sets (for weight1 and weight2) and we want to maximize the sum.\n\n However, we cannot take more than |A| items from A and |B| from B.\n\n For fixed k3, we have R = m - 3*k3 (if R<0, skip). Then we need to choose k1 and k2 (non-negative integers) such that:\n   k1 + 2*k2 <= R, and k1 <= |A|, k2 <= |B|.\n\n We want to maximize: prefixA[k1] + prefixB[k2].\n\n How to do that for a fixed R?\n\n We can precompute for the two groups A and B the prefix sums (for A: from 0 to len(A), similarly for B).\n\n Then, we can consider iterating over k2 from 0 to min(R//2, |B|), and then set k1 = min(|A|, R - 2*k2) [because k1 <= R - 2*k2] but wait: actually k1 = min(|A|, R - 2*k2) but note we are allowed to not use all the remaining weight? However, since we are maximizing the sum and the items are positive, we would always take as many as we can (until we run out of items). But note: it might be that we don't want to take all the remaining weight if the next item is too small? Actually, we are taking the best items first, so we should take the best k1 items from A and best k2 items from B.\n\n However, we must consider that we are constrained by the remaining weight R. The condition is k1 + 2*k2 <= R.\n\n But note: we are allowed to use less than R. However, since the items are positive, we would take as many as we can (until the next item would exceed the remaining weight). But our prefix arrays are computed for the sorted (descending) items, so we want to take the top k1 and top k2.\n\n So for fixed k3, we can let:\n   k2 can go from 0 to min(|B|, R//2) (since each weight2 item uses 2 units).\n  ",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry without exceeding a given weight limit. The souvenirs have weights of either 1, 2, or 3 units, and each has a specific cost. The challenge is to select a subset of these souvenirs such that their combined weight does not exceed the limit, and their total cost is as high as possible.\n\n### Approach\n1. **Grouping by Weight**: First, we group all souvenirs by their weights (1, 2, or 3). This allows us to handle each weight category separately.\n2. **Sorting and Prefix Sums**: For each group, we sort the items in descending order of their costs. We then compute prefix sums for each group. These prefix sums help in quickly determining the maximum cost achievable by selecting the top `k` items from any group.\n3. **Iterate Over Possible Weight Combinations**: For each possible number of weight-3 items (k3), we calculate the remaining weight available (R = m - 3*k3). Using this remaining weight, we determine the optimal combination of weight-1 and weight-2 items. Specifically, for each possible count of weight-2 items (k2), we compute the corresponding maximum number of weight-1 items (k1) that can be carried without exceeding the remaining weight. The total cost is the sum of the prefix sums from all three groups.\n4. **Maximization**: We keep track of the maximum total cost encountered during the iteration over all possible combinations of k1, k2, and k3.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    A = []\n    B = []\n    C = []\n    \n    for i in range(n):\n        w = int(data[index]); c = int(data[index+1]); index += 2\n        if w == 1:\n            A.append(c)\n        elif w == 2:\n            B.append(c)\n        elif w == 3:\n            C.append(c)\n            \n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    \n    prefixA = [0]\n    for i in range(len(A)):\n        prefixA.append(prefixA[-1] + A[i])\n        \n    prefixB = [0]\n    for i in range(len(B)):\n        prefixB.append(prefixB[-1] + B[i])\n        \n    prefixC = [0]\n    for i in range(len(C)):\n        prefixC.append(prefixC[-1] + C[i])\n        \n    best = 0\n    \n    max_k3 = min(len(C), m // 3)\n    for k3 in range(0, max_k3 + 1):\n        rem = m - 3 * k3\n        if rem < 0:\n            break\n            \n        max_k2 = min(len(B), rem // 2)\n        for k2 in range(0, max_k2 + 1):\n            k1 = min(len(A), rem - 2 * k2)\n            total_cost = prefixC[k3] + prefixB[k2] + prefixA[k1]\n            if total_cost > best:\n                best = total_cost\n                \n    print(best)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum weight capacity `m`. Each souvenir's weight and cost are stored in separate lists based on their weight (1, 2, or 3).\n2. **Sorting and Prefix Sums**: Each list of costs (for weights 1, 2, and 3) is sorted in descending order. Prefix sums are computed for each list to facilitate quick lookup of the maximum cost for selecting the top `k` items.\n3. **Iterating Over Weight Combinations**: For each possible number of weight-3 items (from 0 to the maximum possible given the weight limit), the remaining weight is calculated. For each possible number of weight-2 items (up to the maximum allowed by the remaining weight), the corresponding number of weight-1 items is determined. The total cost is computed by summing the prefix sums of the selected items from all three groups.\n4. **Tracking Maximum Cost**: The highest total cost encountered during the iterations is printed as the result.\n\nThis approach efficiently narrows down the problem by leveraging the constraints on item weights and using prefix sums for quick cost calculations, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    A = []\n    B = []\n    C = []\n    \n    for i in range(n):\n        w = int(data[index]); c = int(data[index+1]); index += 2\n        if w == 1:\n            A.append(c)\n        elif w == 2:\n            B.append(c)\n        elif w == 3:\n            C.append(c)\n            \n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    \n    prefixA = [0]\n    for i in range(len(A)):\n        prefixA.append(prefixA[-1] + A[i])\n        \n    prefixB = [0]\n    for i in range(len(B)):\n        prefixB.append(prefixB[-1] + B[i])\n        \n    prefixC = [0]\n    for i in range(len(C)):\n        prefixC.append(prefixC[-1] + C[i])\n        \n    best = 0\n    \n    max_k3 = min(len(C), m // 3)\n    for k3 in range(0, max_k3 + 1):\n        rem = m - 3 * k3\n        if rem < 0:\n            break\n            \n        max_k2 = min(len(B), rem // 2)\n        for k2 in range(0, max_k2 + 1):\n            k1 = min(len(A), rem - 2 * k2)\n            total_cost = prefixC[k3] + prefixB[k2] + prefixA[k1]\n            if total_cost > best:\n                best = total_cost\n                \n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 988,
        "thoughts_token_count": 1023
    }
}