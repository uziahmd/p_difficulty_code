{
    "start": 1758294634.7889807,
    "end": 1758297415.3263288,
    "start-formatted": "2025-09-20 00:10 KST",
    "end-formatted": "2025-09-20 00:56 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, assume a <= b, so we can set d = b - a (but note: if a > b, then we can swap and adjust accordingly). However, let's consider:\n\nWe have:\n  x = a + k\n  y = b + k\n\nThen, note that y - x = (b - a) is constant.\n\nLet g = gcd(x, y). Then, we know that LCM(x, y) = (x * y) / g.\n\nBut note: x = a+k, y = b+k, so we can write:\n  Let d = b - a (if we assume b>=a, then d>=0; if not, we can consider absolute value but then adjust signs)\n\nActually, we can consider the difference d = |a-b|. But note: the problem doesn't specify which is bigger.\n\nAlternatively, we can set:\n  Let g = gcd(a+k, b+k). Then, note that any common divisor of x and y must divide (y-x) = (b-a). So g divides |b-a|.\n\nSo the idea is that for each divisor g of |b-a| (if a != b; if a==b, then k=0 is trivial), we can set up equations:\n\nWe require that g divides both (a+k) and (b+k). Then, there exists integers m, n such that:\n  a+k ≡ 0 (mod g)\n  b+k ≡ 0 (mod g)\n\nBut note that (b+k) - (a+k) = b - a, so if g divides both, then g divides (b-a).\n\nMoreover, we can set k ≡ (-a) mod g, and also k ≡ (-b) mod g. Since (-a) mod g and (-b) mod g must be consistent, we have that g divides (b-a). \n\nNow, if we fix a divisor g of |b-a|, then we can compute k as the smallest non-negative solution to:\n  k ≡ (-a) mod g   [i.e., k ≡ (g - a % g) % g, but if a % g == 0 then k=0?]\n\nHowever, note: we are considering divisors of |b-a|. But what if |b-a| is 0? Then a=b, so we only have one candidate k=0.\n\nBut wait: the problem says if there are multiple k with the same minimal LCM, choose the smallest k. Also, note that k can be zero.\n\nHowever, note that the LCM when k=0 is LCM(a,b). But sometimes increasing k might lead to a smaller LCM?\n\nWait, let me think: Consider k=0: LCM(a,b) = (a*b)/gcd(a,b). What if we take k such that a+k and b+k share more factors? \n\nBut note: the LCM is (a+k)*(b+k) / gcd(a+k, b+k). The product (a+k)*(b+k) increases as k increases, but the gcd might also change. However, the key is that the gcd must divide |b-a|, so we only need to consider divisors of |b-a|.\n\nBut note: there is a caveat. The equation for k modulo g must hold. For a fixed divisor g of |b-a|, the condition is that k ≡ (-a) mod g. However, we must also have that g divides (b+k) and (a+k). \n\nBut note: since g divides |b-a|, and k ≡ (-a) mod g, then (a+k) is divisible by g. Similarly, (b+k) = (a+k) + (b-a). Since g divides (b-a) and divides (a+k), it divides (b+k). So the condition is sufficient.\n\nSo the candidate k for divisor g is: \n  k0 = (-a) mod g, but we want non-negative k. Actually, we can set k_min = (g - (a % g)) % g, but note: if a % g == 0 then k_min=0.\n\nBut wait: we also have to consider the possibility that the same k might be generated by multiple divisors? And we are to choose the smallest k that minimizes the LCM.\n\nHowever, note: the LCM for a given divisor g (which is the gcd) is (a+k)*(b+k) / g. But note: the gcd might not necessarily be exactly g? Actually",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( b + k \\) and \\( a + k \\) is constant (\\( b - a \\)). The greatest common divisor (gcd) of \\( a + k \\) and \\( b + k \\) must be a divisor of this difference. Therefore, we can consider all divisors of the absolute difference \\( |a - b| \\) to determine potential candidates for \\( k \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a - b| \\), we compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is derived from the congruence relation \\( k \\equiv (-a) \\mod g \\). \n\n3. **Algorithm Selection**: \n   - If \\( a = b \\), the solution is trivially \\( k = 0 \\).\n   - Otherwise, iterate over all divisors \\( g \\) of \\( |a - b| \\). For each divisor, compute the corresponding \\( k \\) as the smallest non-negative solution to the congruence \\( k \\equiv (-a) \\mod g \\).\n   - Among all computed \\( k \\) values, select the one that minimizes the LCM of \\( a + k \\) and \\( b + k \\). If multiple \\( k \\) values yield the same LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The algorithm's efficiency hinges on the number of divisors of \\( |a - b| \\), which in the worst case is \\( O(\\sqrt{|a - b|}) \\). Given the constraints \\( 1 \\leq a, b \\leq 10^9 \\), this approach is feasible because the number of divisors is manageable.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    n = abs(a - b)\n    divisors_set = get_divisors(n)\n    \n    candidate_k = []\n    for g in divisors_set:\n        remainder = a % g\n        if remainder == 0:\n            k_val = 0\n        else:\n            k_val = g - (a % g)\n        candidate_k.append(k_val)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidate_k:\n        num1 = a + k\n        num2 = b + k\n        current_gcd = gcd(num1, num2)\n        current_lcm = (num1 * num2) // current_gcd\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is immediately \\( k = 0 \\) since the LCM of two identical numbers is the number itself.\n3. **Divisor Calculation**: The absolute difference \\( |a - b| \\) is computed, and all its divisors are found using a helper function `get_divisors`.\n4. **Candidate Generation**: For each divisor \\( g \\), the corresponding \\( k \\) is calculated as the smallest non-negative integer satisfying \\( k \\equiv (-a) \\mod g \\).\n5. **LCM Evaluation**: For each candidate \\( k \\), the LCM of \\( a + k \\) and \\( b + k \\) is computed. The smallest LCM is tracked, and in case of ties, the smallest \\( k \\) is chosen.\n6. **Output**: The optimal \\( k \\) is printed, which minimizes the LCM of \\( a + k \\) and \\( b + k \\).\n\nThis approach efficiently narrows down potential candidates for \\( k \\) by leveraging mathematical properties of divisors and modular arithmetic, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    n = abs(a - b)\n    divisors_set = get_divisors(n)\n    \n    candidate_k = []\n    for g in divisors_set:\n        remainder = a % g\n        if remainder == 0:\n            k_val = 0\n        else:\n            k_val = g - (a % g)\n        candidate_k.append(k_val)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidate_k:\n        num1 = a + k\n        num2 = b + k\n        current_gcd = gcd(num1, num2)\n        current_lcm = (num1 * num2) // current_gcd\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 388,
        "completion_token_count": 1054,
        "thoughts_token_count": 1023
    }
}