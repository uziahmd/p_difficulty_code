{
    "start": 1758299955.6189706,
    "end": 1758303864.1004784,
    "start-formatted": "2025-09-20 01:39 KST",
    "end-formatted": "2025-09-20 02:44 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000) and we need to output two integers: \n   n = minimum number of nodes required to have exactly p pairs (u, v) with u < v and mutual reachability.\n   m = maximum number of unidirectional pairs (over all edges in the graph) in such a graph with n nodes.\n\n Note: The condition for p-reachable is that the graph must contain exactly p ordered pairs (u, v) (with u < v) such that u and v are mutually reachable.\n\n Observation:\n In a directed graph, mutual reachability forms equivalence classes (strongly connected components). However, note that the problem counts only pairs (u, v) with u < v.\n\n Let the graph have k strongly connected components (SCCs). Then, within each SCC, every pair (u, v) with u != v is mutually reachable. So the number of mutual pairs inside one SCC of size s is C(s,2) = s*(s-1)//2.\n\n But note: the problem says \"exactly p\" ordered pairs (u, v) with u < v and mutual reachability.\n\n Also, there might be edges between different SCCs? However, if we have a DAG of SCCs, then there are no mutual reachabilities across different SCCs (by definition). Therefore, the total mutual pairs is the sum over each SCC of C(s_i,2).\n\n Moreover, we can arrange the graph as a directed acyclic graph (DAG) of these SCCs, and we can even choose the edges arbitrarily as long as we don't create cycles. However, note that the problem does not require the graph to be connected. But we want the minimum number of nodes.\n\n How do we form p mutual pairs?\n We need to break p into a sum of triangular numbers (i.e., the sum of combinations of sizes of the SCCs). However, we can also note:\n\n We are allowed to have multiple SCCs. The minimal number of nodes is achieved by having the entire graph as one big SCC? Not necessarily.\n\n Actually, we can represent the graph as a set of complete SCCs (each being a strongly connected component) and then connect them in a linear order (like a tournament) so that there are no cycles between the SCCs. \n\n But note: the problem does not specify that the graph must be connected. However, we are to minimize the total number of nodes.\n\n We want to form exactly p mutual pairs. Since the mutual pairs are the sum of C(s_i,2) for each SCC, we need to partition p into a sum of triangular numbers (each triangular number being from a complete graph of s_i nodes). However, note that we can use any set of SCCs.\n\n Example: \n   p=3: \n        We can have one SCC of size 3: then C(3,2)=3. So n=3.\n        Alternatively, we could have two SCCs: one of size 2 and one of size 2: then C(2,2)*2 = 1+1 = 2, which is less than 3. So we cannot break 3 into two triangular numbers? \n        Actually, 3 = 3 (from one triangle) or 3 = 1+1+1 (three triangles, i.e., three SCCs of size 2). But note: three SCCs of size 2 would require 6 nodes and yield 3 mutual pairs (each has 1). So why is the answer 3?\n\n So the minimal node configuration is to use one SCC of size 3 (because 3 is the smallest n such that the triangular number T(n) = n*(n-1)//2 >= p? Not exactly: we can use multiple SCCs.\n\n Actually, we can use multiple SCCs. The problem is: we want to represent p as the sum of some triangular numbers (each triangular number T(s_i) = s_i*(s_i-1)//2) and we want to minimize the total nodes, which is the sum of the s_i.\n\n However, note: we are allowed to break p arbitrarily as long as the triangular numbers add up to p. But we cannot use fractional SCCs. \n\n But wait, the problem says: \"exactly p\", so we need the sum of the triangular numbers to be exactly p.\n\n However, the example input p=4 gives output 5. Why 5? \n   If we try to form 4 mutual pairs: \n     Option 1: one SCC of size 3: T(3)=3, then we need 1 more. But we cannot have an SCC of size 2 because that adds 1, so total 4. Then we have two SCCs: one of size 3 and one of size 2. Total nodes = 3+2=5.\n\n     Alternatively, four SCCs of size 2: each gives 1, so 4*1=4, but that requires 8 nodes, which is more.\n\n So the minimal node configuration is achieved by using as few and as large SCCs as possible? Actually, we want to minimize the total nodes, so we want to use large SCCs because a triangular number grows quadratically. But note: we are constrained by the fact that we must get exactly p.\n\n Steps:\n\n 1. Find the smallest n (total nodes) such that there exists a sequence of positive integers s_1, s_2, ..., s_k (each at least 1) with:\n        sum_{i} [s_i*(s_i-1)//2] = p\n    and sum_{i} s_i = n, and we want to minimize n.\n\n However, note: the problem does not require that we use only complete SCCs (each being a complete graph). Actually, in a directed graph, an SCC doesn't have to be a complete graph. But the minimal number of edges to make an SCC of size s is s (if we use a cycle) but that doesn't matter for the mutual pairs: the mutual pairs in an SCC of size s is always C(s,2). \n\n Therefore, the problem reduces to: represent p as a sum of triangular numbers (each triangular number is T(s_i) = s_i*(s_i-1)//2) and we want to minimize the total nodes, which is the sum of the s_i.\n\n But note: we can also have SCCs of size 1 (which contribute 0). So we can ignore them.\n\n Actually, we can consider the following: we can break p into a sum of triangular numbers (without repetition and without ordering). This is similar to the classic coin problem but with coins being triangular numbers.\n\n However, note: the triangular numbers are not arbitrary: they are T(1)=0, T(2)=1, T(3)=3, T(4)=6, T(5)=10, etc. And we can use each value at most once (since each SCC is distinct and we are just adding the triangular numbers). But wait, we can have multiple SCCs of the same size? Yes, because we can have multiple components of the same size.\n\n However, if we use two SCCs of size 2, then we have two triangular numbers T(2)=1, so total 2. Similarly, we can use as many as we want of the same triangular number.\n\n Therefore, we are allowed to use any triangular number T(s) for s>=1 (but T(1)=0) arbitrarily many times.\n\n Now, the problem becomes: represent p as a sum of triangular numbers (each T(s) = s*(s-1)//2, and s>=2 because s=1 gives 0 and doesn't help) and we wish to minimize the total nodes (which is the sum of the s_i, not the number of terms).\n\n However, note: we are allowed to use s=1 (which contributes 0) but that doesn't help in increasing p. So we can ignore s=1.\n\n But wait, sometimes we might need to use s=1 to adjust the representation? Actually, if we have a representation without s=1, then we can ignore s=1. \n\n But note: we are only concerned with the triangular numbers for s>=2.\n\n The minimal total nodes is the minimal sum of s_i (each s_i>=2) such that the sum of T(s_i) = p.\n\n However, we can also use s=1 (which adds 0) arbitrarily, but that would increase the total nodes without helping p, so we don't use s=1.\n\n But wait: the problem says we have exactly p mutual pairs. So we must account for exactly p. \n\n Alternatively, we can think: we are going to have k SCCs (each of size at least 1). Then the total mutual pairs is the sum_{i=1}^{k} T(s_i) = p, and the total nodes is n = sum_{i=1}^{k} s_i.\n\n We wish to minimize n, and then for the same minimal n, maximize the number of unidirectional pairs.\n\n However, note: the problem says \"minimum number of nodes required\", so we need the smallest n such that there exists a way to break p into triangular numbers (each at least T(2)=1) and the sum of the bases (the s_i) is n.\n\n How to compute the minimal n?\n\n We can use dynamic programming? But p can be up to 200000.\n\n Alternatively, note that we can use greedy: use as large triangular numbers as possible? Because a larger triangular number uses fewer nodes per unit of p? \n\n Example: \n   T(2)=1, uses 2 nodes.\n   T(3)=3, uses 3 nodes -> efficiency 3/3=1 node per unit.\n   T(4)=6, uses 4 nodes -> efficiency 4/6 ~ 0.666.\n   T(5)=10, uses 5 nodes -> efficiency 0.5.\n\n So actually, the larger the SCC, the more efficient (in terms of p per node) we are. Therefore, to minimize the total nodes for a fixed p, we should use as large triangular numbers as possible.\n\n However, we must represent p exactly. \n\n Steps for minimal nodes:\n\n 1. Find the largest triangular number <= p, say T(x) = x*(x-1)//2 <= p, then we can use one SCC of size x, and then represent p - T(x) with the remaining nodes.\n\n But we have to consider that we can use multiple SCCs.\n\n However, we are allowed to use any triangular numbers. We can use the greedy method: take the largest triangular number <= p, subtract it, and then take the next largest, etc.\n\n But is that optimal for minimizing the total nodes? \n\n Consider: we have two ways to represent p:\n   Option 1: Use one SCC of size a and one SCC of size b, then p = T(a)+T(b), and total nodes = a+b.\n   Option 2: Use one SCC of size c and one SCC of size d, then p = T(c)+T(d), and total nodes = c+d.\n\n We want to minimize a+b (or c+d). \n\n However, we know that T(a) = a*(a-1)//2. The efficiency (p per node) is (a-1)/(2) per node. But note: we are not trying to maximize p for a fixed n, but to minimize n for a fixed p.\n\n Actually, we want to use the triangular numbers that are as large as possible (so that we cover more p with fewer nodes). \n\n But note: the triangular numbers are increasing. However, the function T(x) is quadratic. \n\n Algorithm for minimal n:\n\n   Let n_min = 0, and current_p = p.\n   While current_p > 0:\n        Let x be the largest integer such that T(x) <= current_p.\n        Then, subtract T(x) from current_p, and add x to n_min.\n\n   Then n_min is the minimal number of nodes.\n\n But wait: is that correct? Let's test with p=4.\n\n   Step 1: largest x such that T(x) <=4 -> T(3)=3<=4, so subtract 3, current_p=1, n_min=3.\n   Step 2: largest x such that T(x)<=1 -> T(2)=1<=1, subtract 1, current_p=0, n_min=3+2=5.\n\n   So we get n_min=5, which matches the example.\n\n   Test with p=3: \n        Step 1: largest x with T(x)<=3 -> x=3, subtract 3, current_p=0, n_min=3.\n\n   Test with p=0: \n        n_min=0.\n\n   Test with p=1: \n        Step 1: x=2, T(2)=1<=1, subtract 1, current_p=0, n_min=2.\n\n   Test with p=2:\n        Step 1: largest x with T(x)<=2 -> T(2)=1<=2, subtract 1, current_p=1.\n        Step 2: then x=2 again, subtract 1, current_p=0, n_min=2+2=4.\n\n        Alternatively, is there a way to represent 2? \n            We can use two SCCs of size 2: then T(2)+T(2)=1+1=2, and n=4.\n            Is there a way with 3 nodes? \n                One SCC of size 3: T(3)=3 -> too big.\n                One SCC of size 2 and one of size 1: T(2)+T(1)=1+0=1 -> not enough.\n                Two SCCs of size 2: n=4.\n\n        So n_min=4.\n\n   However, wait: what if we use an SCC of size 3? Then T(3)=3>2, so we cannot. \n\n   Another test: p=5.\n        Step 1: largest x with T(x)<=5 -> T(3)=3<=5, subtract 3, current_p=2, n_min=3.\n        Then for 2: as above, we use two SCCs of size 2, so n_min=3+2+2=7.\n\n        Alternatively: \n            We could use one SCC of size 3 (3) and one of size 2 (1) -> total 4, but then p=4, not 5.\n            Or two SCCs of size 3: T(3)+T(3)=3+3=6>5, too big.\n\n        How else? \n            We could use one SCC of size 4: T(4)=6>5 -> too big.\n            Or one SCC of size 3 and one of size 2: gives 3+1=4, then we need 1 more. \n            Then we need to break the remaining 1: so another SCC of size 2: then p=3+1+1=5, and nodes=3+2+2=7.\n\n        Alternatively, we can use three SCCs: two of size 3 and one of size 1? That gives 3+3+0=6, too much.\n\n        So minimal nodes is 7.\n\n   But wait, is there a better way? \n        We can use one SCC of size 4: too big (6>5).\n        Or one SCC of size 3 and two SCCs of size 2: 3+1+1=5, and nodes=3+2+2=7.\n\n   So the algorithm gives 7.\n\n   However, let me check: is there a way to represent 5 as a sum of triangular numbers with total nodes less than 7?\n        Triangular numbers: 1,3,6,... \n        We need 5 = 3+1+1 -> 3+1+1 is the only way (since 5 is odd and the next triangular number after 3 is 6 which is too big). \n\n   So yes, 7 is minimal.\n\n But note: the example p=0 -> 0 nodes, p=1 -> 2 nodes, p=2 -> 4 nodes, p=3 -> 3 nodes, p=4->5 nodes, p=5->7 nodes.\n\n However, we must be cautious: the greedy algorithm for representing p as a sum of triangular numbers (allowing repetitions) is known to work for the entire range? \n\n Actually, the representation of numbers as sums of triangular numbers is a classic problem. It is known that every nonnegative integer is representable as the sum of at most three triangular numbers (Gauss proved for triangular numbers that every natural number is the sum of three triangular numbers, but here we allow repetition and we are not limited to three). However, we are breaking p arbitrarily (any number of triangular numbers) and we wish to minimize the total base (the sum of the indices).\n\n But note: we are allowed to use the same triangular number multiple times.\n\n However, our greedy algorithm (take the largest triangular number not exceeding p, then repeat) minimizes the number of terms? Not necessarily the total base (which is the sum of the indices). \n\n But note: we are minimizing the total nodes (the sum of the indices). \n\n Example: p=2. \n        Greedy: use two T(2)'s: total nodes 4.\n        But is there a representation with a triangular number T(3)=3 which is too big, so no.\n\n        What about p=6? \n            Greedy: T(4)=6, so one term: nodes=4.\n            Alternatively: two T(3)'s: 3+3=6, nodes=3+3=6 -> worse.\n\n        p=7:\n            Greedy: T(4)=6, then remainder 1: so two terms: T(4) and T(2): nodes=4+2=6.\n            Alternatively: T(3)+T(3)+T(2)=3+3+1=7, nodes=3+3+2=8 -> worse.\n\n        p=8:\n            Greedy: T(4)=6, then 8-6=2 -> two T(2)'s: nodes=4+2+2=8.\n            Alternatively: two T(3)'s: 3+3=6, then 2 left -> two T(2)'s: same 8.\n\n        p=9:\n            Greedy: T(4)=6, then 9-6=3 -> T(4) and T(3): nodes=4+3=7.\n            Alternatively: three T(3)'s: 3+3+3=9, nodes=3+3+3=9 -> worse.\n\n        p=10:\n            Greedy: T(5)=10, nodes=5.\n\n        So the greedy algorithm (taking the largest triangular number at each step) minimizes the total nodes.\n\n Why? Because the triangular numbers grow as T(x) ~ x^2/2, so the base x is about sqrt(2*T(x)). Therefore, to cover a given p, we want to use as few terms as possible and each term should be as large as possible. However, note that the total nodes is the sum of the bases (x_i) and not the number of terms.\n\n But observe: the base x_i is the minimal integer such that T(x_i) >= the remaining p? Actually, we take the largest triangular number <= p. Then the base is x_i, and we subtract T(x_i) and add x_i to the total nodes.\n\n The key is that the triangular numbers are the complete set {0,1,3,6,10,...}. We can use any of them arbitrarily. \n\n However, we must verify if this greedy algorithm is optimal for minimizing the total nodes.\n\n Claim: Using the greedy algorithm (at each step, take the largest triangular number <= p) minimizes the total nodes.\n\n Proof sketch: \n   Consider that we have two triangular numbers: T(a) and T(b) with a>=b. Then T(a) + T(b) is the same as T(b) + T(a). But note, if we have two triangular numbers, we can combine them? \n\n   However, note that the total nodes is the sum of the bases. And the base for a triangular number T(x) is x. \n\n   We wish to minimize the sum of the bases. \n\n   We know that the triangular numbers are increasing and the bases are increasing. \n\n   Suppose we have a representation R1: T(x1) + T(x2) + ... + T(xk) = p, and the greedy representation R2: T(y1) + T(y2) + ... + T(ym) = p.\n\n   We want to show that the sum of the bases in R2 is <= the sum of the bases in R1.\n\n   Since the greedy algorithm takes the largest triangular number at each step, we can use the fact that the triangular numbers are the most \"efficient\" (in terms of covering p) with the smallest base per unit p? \n\n   Actually, the efficiency (p per base) is (x*(x-1)//2) / x = (x-1)/2. So the efficiency increases with x. Therefore, we want to use as large x as possible to cover as much p as possible with fewer bases.\n\n   However, note: the greedy algorithm does not necessarily minimize the total bases. \n\n   Example: p=2. \n        Greedy: two T(2)'s: bases=2+2=4.\n        But wait, is there a representation with a base less than 4? \n            We can use one T(3)=3, but 3>2 -> not allowed.\n            So 4 is minimal.\n\n   Example: p=5. \n        Greedy: T(3)=3, then T(2)=1, then T(2)=1: bases=3+2+2=7.\n        Alternatively: can we use two T(3)'s? 3+3=6, which is greater than 5, so no.\n        Or one T(4)=6 -> too big.\n\n        So 7 is minimal.\n\n   Example: p=11.\n        Greedy: T(4)=6, then p=5 -> T(3)=3, then p=2 -> two T(2)=1: so bases=4+3+2+2=11.\n        Alternatively: T(5)=10, then p=1 -> T(2)=1: bases=5+2=7 -> better.\n\n        But wait, in the greedy step we did: \n            First, largest triangular number <=11 is T(5)=10, then remainder 1, then T(2)=1: so bases=5+2=7.\n\n        Why did I initially say T(4) for p=11? Actually, we must take the largest triangular number <=11. T(5)=10, so that's correct.\n\n        So the greedy algorithm must be corrected: we take the largest triangular number <= p, not the next one.\n\n        Correction: the greedy algorithm: \n            while p:\n                x = floor((sqrt(8*p+1)-1)/2)  # because T(x) = x*(x-1)//2 <= p, so x = floor((sqrt(8*p+1)-1)/2)\n                Then subtract T(x) and add x to n.\n\n        For p=11: \n            x = floor((sqrt(8*11+1)-1)/2) = floor((sqrt(89)-1)/2) ~ (9.43-1)/2 ~ 8.43/2 ~ 4.215 -> floor gives 4, but wait, T(4)=6<=11, but T(5)=10<=11, and 5>4 so we want 5.\n\n        Actually, the formula for x is: \n            x*(x-1)//2 <= p < (x+1)*x//2\n\n        But wait, we want the maximum x such that T(x)<=p.\n\n        The inverse of T(x)=x*(x-1)//2 is approximately x = ceil((1+sqrt(1+8p))/2) ??? \n\n        Actually, to find the largest x such that T(x)<=p:\n\n            x^2 - x - 2p <=0\n            x = floor((1+sqrt(1+8p))/2)\n\n        Let me check: \n            p=11: sqrt(1+8*11)=sqrt(89) ~9.43, (1+9.43)/2=5.215, floor is 5. So x=5, T(5)=10<=11.\n\n        So the formula: x = floor((1+sqrt(1+8p))/2) doesn't give 5 because (1+sqrt(89)) is about 10.43, divided by 2 is 5.215, then floor is 5.\n\n        Actually, the standard way: \n            Solve x^2-x-2p=0: x=(1+sqrt(1+8p))/2. Then the largest integer x with T(x)<=p is floor((1+sqrt(1+8p))/2) ? \n\n        But note: \n            T(5)=10, T(6)=15. For p=10, x=5, for p=10, (1+sqrt(81))/2=(1+9)/2=5 -> correct.\n\n        However, for p=11, (1+sqrt(89))~10.43, then (10.43)/2=5.215, floor is 5. Correct.\n\n        So the greedy algorithm for p=11: \n            Step1: x=floor((1+sqrt(89))/2)=5, subtract 10, p=1, then x=floor((1+sqrt(9))/2)=floor((1+3)/2)=2, subtract 1, p=0. Total nodes=5+2=7.\n\n        Now, is 7 minimal? \n            We used one SCC of size 5 (10 pairs) and one SCC of size 2 (1 pair): total pairs=11, nodes=7.\n\n        Alternative: \n            Two SCCs of size 4: T(4)=6, two of them: 6+6=12>11 -> too big.\n            One SCC of size 4 and two SCCs of size 2: 6+1+1=8, nodes=4+2+2=8>7.\n            Three SCCs: one of size 4 and one of size 3 and one of size 2: 6+3+1=10, then we need 1 more: so one more SCC of size 2: 6+3+1+1=11, nodes=4+3+2+2=11 -> worse.\n\n        So 7 is minimal.\n\n   Therefore, the greedy algorithm (using the largest triangular number at each step) minimizes the total nodes.\n\n 2. Now, we have the minimal nodes n. But the problem also asks: among all graphs with n nodes that are p-reachable, what is the maximum number of unidirectional pairs?\n\n What is an unidirectional pair?\n   An ordered pair (u, v) (with u != v) such that:\n        There is a path from u to v, but no path from v to u.\n\n   Note: the graph must be p-reachable, meaning it has exactly p mutual pairs (for u < v). \n\n How to count unidirectional pairs?\n\n   In a directed graph, we can decompose it into strongly connected components (SCCs) and then form a DAG on these components. \n\n   Within an SCC, every ordered pair (u, v) (with u != v) is bidirectional (mutual reachability) and hence not unidirectional. \n\n   Between two different SCCs, say A and B, we can have edges from A to B but not from B to A (if the DAG is acyclic). Then, for every u in A and v in B, the edge from u to v (if present) would be a unidirectional pair? \n\n   But note: the problem does not specify that the graph is a DAG. However, we are free to choose any graph as long as the mutual pairs (the ones that form the p) are exactly the ones we set.\n\n   However, note: if we have two different SCCs, and there is an edge from A to B, then there must be no path from B to A (otherwise they would be merged). So the DAG condition is inherent.\n\n   But note: we can have multiple edges between two SCCs? Actually, we can have any set of edges that does not create cycles.\n\n   How to maximize the number of unidirectional pairs?\n\n   We know that the graph is partitioned into k SCCs (with total n nodes). The mutual pairs are fixed: p = sum_{i} T(s_i) (where s_i is the size of the i-th SCC).\n\n   The unidirectional pairs come from two sources:\n\n     a) Within an SCC: none (because if u and v are in the same SCC, then both directions exist).\n\n     b) Between two different SCCs: \n          For two SCCs A and B (A != B), we can have edges from A to B or from B to A, but not both (to avoid creating a cycle). \n\n        However, note: the problem does not require the entire graph to be connected (as a DAG). We can have a DAG that is not complete.\n\n        The unidirectional pairs from A to B: \n          Every node in A and every node in B: if there is an edge from A to B, then for every u in A and v in B, the pair (u, v) is unidirectional (because there is a path from u to v (via the edge) but no path from v to u (because otherwise they would be in the same SCC)).\n\n        But note: the graph might have multiple edges? However, we are counting ordered pairs (u, v) and the condition is about existence of a path. \n\n        However, the problem does not specify that the graph is simple. But note: the definition of unidirectional requires a path from u to v and no path from v to u. \n\n        But if we have multiple edges from A to B, that doesn't change the reachability: there is still a path from A to B and no path from B to A (unless we have an edge from B to A, then they would be connected and the SCCs would merge).\n\n        So the condition for unidirectional pairs between two SCCs is independent of the multiplicity of edges: as long as there is at least one edge from A to B, then (u,v) for u in A and v in B is unidirectional. Similarly, if there is an edge from B to A, then (v,u) for v in B and u in A is unidirectional.\n\n        However, note: the problem counts ordered pairs (u, v) (and u != v). \n\n        But note: the graph is directed and we are allowed to choose any set of edges (as long as the mutual pairs are fixed). \n\n        To maximize the unidirectional pairs, we should maximize the edges between the SCCs. \n\n        However, we cannot have both edges between two SCCs (because that would make them mutually reachable, merging the two SCCs). \n\n        Therefore, between two SCCs, we can have either all edges from A to B or all edges from B to A, or none. \n\n        But note: we are allowed to have any set of edges as long as the mutual pairs (within the SCCs) are fixed. \n\n        However, the mutual pairs are fixed by the SCCs. The edges between SCCs do not affect the mutual pairs (since they are defined by the absence of a path in the opposite direction). \n\n        Therefore, we can independently choose the edges between the SCCs to maximize the unidirectional pairs.\n\n        How many unidirectional pairs from two SCCs A and B (with |A|=a, |B|=b)?\n\n          If we choose to direct the edges from A to B, then we get a * b unidirectional pairs (from A to B). Similarly, if we choose from B to A, we get b * a unidirectional pairs.\n\n        But note: we cannot have both. So the maximum we can get from the pair (A,B) is max(a*b, b*a) = a*b.\n\n        However, wait: we are allowed to have a mix? No, because if we have any edge from A to B, then we cannot have any edge from B to A (otherwise the two SCCs would be connected in both directions and thus merge). \n\n        So for each unordered pair of distinct SCCs, we can choose one direction (either A->B or B->A) and then we get a*b unidirectional pairs, or we can choose no edges and get 0.\n\n        Therefore, to maximize the total unidirectional pairs, we should choose for every unordered pair (A,B) the direction that gives the maximum (which is a*b, and that's symmetric) and then we get a*b for that pair.\n\n        However, note: the DAG condition: we must have a topological order on the SCCs. So we can direct the edges from the earlier components to the later ones (or vice versa) without cycles.\n\n        The maximum unidirectional pairs we can get is the sum over every unordered pair of distinct SCCs (A,B) of a*b.\n\n        But note: we are allowed to choose the direction arbitrarily for each pair, so we can choose the direction that gives a*b for each pair. \n\n        Therefore, the total unidirectional pairs is:\n\n            Sum_{i < j} (s_i * s_j)\n\n        However, wait: is that the case? \n\n        Example: two SCCs A and B. Then the total unidirectional pairs from A and B is s_A * s_B, regardless of the direction we choose (since both directions are symmetric in count, but we choose one). \n\n        But note: the entire graph must be acyclic. We can assign a topological order to the SCCs (say, a linear order). Then we choose to direct edges from left to right. Then for every pair (A,B) with A to the left of B, we have edges from A to B (and not the reverse). Then the unidirectional pairs from A to B are s_A*s_B, and from B to A we don't have any (because we don't put edges from B to A). \n\n        However, note: we can also choose to direct edges from right to left? Then we would get s_B*s_A from B to A, but then we cannot have edges from A to B.\n\n        But the total is the same: s_A*s_B.\n\n        Therefore, the total unidirectional pairs is independent of the direction chosen for each unordered pair, and is simply the sum_{i<j} s_i*s_j.\n\n        Now, note: the entire graph has n nodes (the SCCs are disjoint). The total number of ordered pairs (u, v) with u != v is n*(n-1). \n\n        And the mutual pairs (within the same SCC) are p = sum_i T(s_i) = sum_i [s_i*(s_i-1)//2].\n\n        Then the unidirectional pairs (which are the pairs (u,v) that are in different SCCs and for which there is a path from u to v but not from v to u) is:\n\n            total_ordered_pairs (excluding self-loops) = n*(n-1) \n            minus the mutual pairs (which are the pairs (u,v) that are in the same SCC and mutual) \n            minus the pairs (u,v) that are in different SCCs but have no path in either direction? \n\n        But note: the definition of unidirectional requires a path in one direction and not the other. \n\n        However, in our construction (with a DAG of SCCs and edges only from left to right, say), for two nodes in different SCCs, there is always a path from the left SCC to the right SCC (if we have edges from left to right, but note: we might not have a direct edge, but we can have a path through multiple SCCs? \n\n        Actually, we are free to choose the edges arbitrarily as long as we don't form cycles. \n\n        But note: the condition for unidirectional pairs is based on the existence of a path. \n\n        In our decomposition, the graph is a DAG of SCCs. Then, for two nodes u and v in different SCCs, if u is in an SCC that is topologically before v, then we can have a path from u to v (by including edges from each consecutive SCC) and no path from v to u (because the topological order is reversed). \n\n        However, we are not forced to have a complete DAG (every edge from an earlier component to a later one). We can choose a subset of the edges. \n\n        But note: to maximize the unidirectional pairs, we want as many pairs (u,v) (with u in an earlier component and v in a later component) to have a path from u to v. \n\n        However, the definition requires a path, not necessarily a direct edge.\n\n        But if we do not put edges from an earlier component to a later one, then there might be no path from u to v. \n\n        Therefore, to ensure that every pair (u,v) with u in an earlier component and v in a later component has a path, we must have a directed path. \n\n        The minimal way to ensure that is to have a complete DAG (with edges from every node in an earlier component to every node in a later component). \n\n        However, we don't have to: we can have a single chain of edges that connects the entire DAG. But note: the condition for unidirectional pairs is that there exists a path. \n\n        But if we don't put any edge from an earlier component to a later one, then there is no path from u to v, so that pair",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, meaning it contains exactly p ordered pairs of nodes (u, v) where u < v and u and v are mutually reachable. Additionally, among all such graphs with the minimum number of nodes, we need to find the maximum number of unidirectional pairs (pairs where there is a path from u to v but not from v to u).\n\n### Approach\n1. **Problem Analysis**:\n   - **p-Reachable Graph**: The graph must have exactly p mutual reachability pairs (u, v) where u < v. Mutual reachability implies that u and v are in the same strongly connected component (SCC). The number of mutual pairs in an SCC of size s is given by the triangular number \\( T(s) = s*(s-1)/2 \\).\n   - **Unidirectional Pairs**: These are pairs (u, v) where there is a path from u to v but no path from v to u. To maximize these, we consider the graph decomposed into SCCs and form a DAG where edges between SCCs are directed in a way that maximizes the count.\n\n2. **Key Insight**:\n   - **Minimal Nodes Calculation**: The minimal number of nodes is found by greedily selecting the largest possible triangular numbers (corresponding to the largest SCCs) that sum up to p. Each triangular number \\( T(s) \\) corresponds to an SCC of size s, contributing \\( T(s) \\) mutual pairs.\n   - **Maximizing Unidirectional Pairs**: Once the SCC sizes are determined, the maximum number of unidirectional pairs is the sum of products of the sizes of all pairs of distinct SCCs. This is because each node in one SCC can form a unidirectional pair with each node in another SCC if edges are directed appropriately.\n\n3. **Algorithm Selection**:\n   - **Greedy Algorithm**: For each step, subtract the largest triangular number less than or equal to the remaining p, and add the corresponding base size to the total nodes.\n   - **Sum of Products**: After determining the SCC sizes, compute the sum of products of their sizes for all pairs to get the maximum unidirectional pairs.\n\n4. **Complexity Analysis**:\n   - The algorithm processes each triangular number in \\( O(\\sqrt{p}) \\) time per step, leading to an overall complexity of \\( O(n) \\), where n is the number of steps (which is logarithmic in p). This is efficient for the given constraints (p ≤ 2×10^5).\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    p_val = int(input().strip())\n    \n    if p_val == 0:\n        print(\"0 0\")\n        return\n        \n    n_nodes = 0\n    current_p = p_val\n    components = []\n    \n    while current_p > 0:\n        x = math.floor((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        tri_val = x * (x - 1) // 2\n        components.append(x)\n        n_nodes += x\n        current_p -= tri_val\n        \n    k = len(components)\n    total_unidirectional = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            total_unidirectional += components[i] * components[j]\n            \n    print(f\"{n_nodes} {total_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is a single integer p, representing the number of mutual reachability pairs required.\n2. **Special Case Handling**: If p is 0, the output is \"0 0\" since no nodes are needed.\n3. **Greedy Calculation**:\n   - For each iteration, the largest triangular number ≤ current_p is found using the formula derived from solving the quadratic equation for triangular numbers.\n   - The corresponding base size (SCC size) is added to the total nodes, and the triangular value is subtracted from the remaining p.\n4. **Unidirectional Pairs Calculation**:\n   - After determining all SCC sizes, the maximum number of unidirectional pairs is computed by summing the products of the sizes of all pairs of distinct SCCs. This leverages the fact that edges between SCCs can be directed to ensure all inter-SCC pairs are unidirectional.\n5. **Output**: The minimal number of nodes and the maximum number of unidirectional pairs are printed.\n\nThis approach efficiently decomposes the problem into manageable steps, leveraging mathematical insights to minimize computational complexity while ensuring correctness.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    p_val = int(input().strip())\n    \n    if p_val == 0:\n        print(\"0 0\")\n        return\n        \n    n_nodes = 0\n    current_p = p_val\n    components = []\n    \n    while current_p > 0:\n        x = math.floor((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        tri_val = x * (x - 1) // 2\n        components.append(x)\n        n_nodes += x\n        current_p -= tri_val\n        \n    k = len(components)\n    total_unidirectional = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            total_unidirectional += components[i] * components[j]\n            \n    print(f\"{n_nodes} {total_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 466,
        "completion_token_count": 981,
        "thoughts_token_count": 8191
    }
}