{
    "start": 1758296420.1715024,
    "end": 1758299388.7690692,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k give the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, assume a <= b, so we can set d = b - a (but note: if a > b, then we can swap and adjust accordingly). However, let's consider:\n\nWe have two numbers: x = a+k and y = b+k, and we know that:\n  LCM(x, y) = (x * y) / GCD(x, y)\n\nNote that the GCD of x and y must divide (x-y) = (a+k) - (b+k) = a-b (a constant). So the GCD must be a divisor of |a-b|.\n\nLet g be a divisor of |a-b|. Then we can write:\n  x = g * u, y = g * v, where gcd(u,v)=1, and note that x-y = g*(u-v) = a-b.\n\nBut note: x-y = (a+k) - (b+k) = a-b, so g must divide (a-b). Also, we can express k in terms of g.\n\nAlternatively, we can think: for a fixed divisor g of |a-b|, we want to find k such that:\n  (a+k) mod g == 0 and (b+k) mod g == 0.\n\nBut note: since (a+k) - (b+k) = a-b, if g divides both (a+k) and (b+k), then g must divide (a-b). So we are looking at divisors of |a-b|.\n\nHowever, note: if a==b, then the problem becomes simple: then we have two identical numbers, and we want to minimize LCM(a+k, a+k) = a+k. The minimal value is when k=0.\n\nBut what if a != b? Let d = abs(a-b). Then the divisors of d are the candidates for the GCD of (a+k) and (b+k). However, note that the GCD might not necessarily be exactly one of the divisors of d? Actually, the GCD must divide d, so yes.\n\nNow, for a divisor g (which we will consider as the GCD) of d, we can set:\n  We require that g divides (a+k) and (b+k). Since (a+k) - (b+k) = a-b, then g divides a-b. This is already satisfied.\n\nBut note: the GCD of (a+k) and (b+k) is actually a multiple of g? Not necessarily. But wait, the GCD must divide d, so we consider all divisors.\n\nActually, we are going to consider all divisors of d (if d>0). For each divisor g (positive) of d, we can set:\n  k ≡ (-a) mod g   and   k ≡ (-b) mod g.\n\nBut since a-b is divisible by g, then these two congruences are consistent. In fact, we can set:\n  k ≡ (-a) mod g   (then automatically k ≡ (-b) mod g because a-b is divisible by g).\n\nSo for a divisor g, we are looking for the smallest non-negative k such that k >= max( ceil((-a)/g) , ceil((-b)/g) )? Actually, we can solve for k:\n\nWe require:\n  k >= -a (mod g) and k >= -b (mod g). But note k is non-negative.\n\nAlternatively, we can write:\n  k = t*g - a, for some integer t such that k>=0 and also k = s*g - b for some integer s (then t*g - a = s*g - b => (t-s)*g = a-b, which holds because g divides a-b).\n\nBut note: we require k to be the same. Alternatively, we can compute k from the condition on a+k and b+k.\n\nActually, we can set k_min(g) = the smallest non-negative k such that g divides (a+k) and (b+k). Since g divides (a+k) and (b+k), we have:\n  k ≡ (-a) mod g, and k ≡ (-b) mod g.\n\nBut note: because g divides (a-b), the two congruences are equivalent. So we can take k_min(g) = (-a) mod g? Actually, the smallest non-negative k satisfying k ≡ (-a) mod g is:\n  k0 = (g - a % g) % g   [if a % g != 0, else 0]\n\nBut",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. The solution involves leveraging mathematical insights about divisors and modular arithmetic to efficiently determine the optimal \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a+k \\) and \\( b+k \\) must be a divisor of the absolute difference between \\( a \\) and \\( b \\). This is because \\( (a+k) - (b+k) = a - b \\), so any common divisor of \\( a+k \\) and \\( b+k \\) must divide \\( a - b \\).\n\n2. **Insight**: For each divisor \\( g \\) of \\( |a - b| \\), we can find the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). The LCM of \\( a+k \\) and \\( b+k \\) will then be \\( \\frac{(a+k)(b+k)}{g} \\). Since \\( g \\) is a divisor of \\( |a - b| \\), we only need to consider these divisors to minimize the LCM.\n\n3. **Algorithm Selection**: \n   - If \\( a \\) and \\( b \\) are equal, the answer is \\( 0 \\) because the LCM of two identical numbers is the number itself, and \\( k = 0 \\) minimizes it.\n   - Otherwise, compute all divisors of \\( |a - b| \\). For each divisor \\( g \\), compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is given by \\( (-a) \\mod g \\), adjusted to be non-negative.\n   - Among all computed \\( k \\) values, select the one that results in the smallest LCM. If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The algorithm's efficiency depends on the number of divisors of \\( |a - b| \\). For numbers up to \\( 10^9 \\), the maximum number of divisors is around 1344 (for highly composite numbers), making this approach feasible within time constraints.\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nfrom math import gcd\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    \n    candidate_k = {}\n    for g in divisors:\n        k_val = (-a) % g\n        candidate_k[k_val] = True\n        \n    possible_ks = [k_val for k_val in candidate_k.keys()]\n    best_k = None\n    best_lcm = None\n    \n    for k in possible_ks:\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm:\n            if k < best_k:\n                best_k = k\n                \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The program reads two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, it immediately outputs \\( 0 \\) since the LCM of two identical numbers is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For the difference \\( d = |a - b| \\), the program computes all its divisors. These divisors are potential candidates for the GCD of \\( a+k \\) and \\( b+k \\).\n4. **Finding Valid \\( k \\)**: For each divisor \\( g \\), the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\) is found using modular arithmetic.\n5. **LCM Calculation**: For each valid \\( k \\), the LCM of \\( a+k \\) and \\( b+k \\) is computed. The smallest LCM encountered determines the optimal \\( k \\). If multiple \\( k \\) values yield the same minimal LCM, the smallest \\( k \\) is chosen.\n6. **Output**: The optimal \\( k \\) is printed.\n\nThis approach efficiently narrows down the problem to considering only relevant divisors and leverages modular arithmetic to find the minimal \\( k \\) without exhaustive search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    \n    candidate_k = {}\n    for g in divisors:\n        k_val = (-a) % g\n        candidate_k[k_val] = True\n        \n    possible_ks = [k_val for k_val in candidate_k.keys()]\n    best_k = None\n    best_lcm = None\n    \n    for k in possible_ks:\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm:\n            if k < best_k:\n                best_k = k\n                \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1117,
        "thoughts_token_count": 1023
    }
}