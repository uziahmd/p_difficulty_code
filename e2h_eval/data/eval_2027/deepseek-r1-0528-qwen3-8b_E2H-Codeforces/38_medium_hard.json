{
    "start": 1758300209.5133107,
    "end": 1758304067.6625354,
    "start-formatted": "2025-09-20 01:43 KST",
    "end-formatted": "2025-09-20 02:47 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000) and we need to output two integers: \n   n = minimum number of nodes required to have exactly p pairs (u, v) with u < v and mutual reachability.\n   m = maximum number of unidirectional pairs (over all edges in the graph) in such a graph with n nodes.\n\n Note: The condition for p-reachable is that the graph must contain exactly p ordered pairs (u, v) (with u < v) such that u and v are mutually reachable.\n\n Observation:\n In a directed graph, mutual reachability forms equivalence classes (strongly connected components). However, note that the problem counts only pairs (u, v) with u < v.\n\n Let the graph have k strongly connected components (SCCs). Then, within each SCC, every pair (u, v) with u != v is mutually reachable. So the number of mutual pairs inside one SCC of size s is C(s,2) = s*(s-1)//2.\n\n But note: the problem says \"exactly p\" ordered pairs (u, v) with u < v and mutual reachability.\n\n Also, there might be edges between different SCCs? However, if we have a DAG of SCCs, then there are no mutual reachabilities across different SCCs (by definition). Therefore, the total mutual pairs is the sum over each SCC of C(s_i,2).\n\n Now, we want to represent the graph with as few nodes as possible (n) such that the total mutual pairs (from all SCCs) is exactly p.\n\n Let the graph have n nodes. We can form k SCCs (k from 1 to n) and distribute the n nodes into these k SCCs. The condition is:\n\n   Sum_{i=1}^{k} [C(s_i,2)] = p\n\n and the sum of all s_i is n.\n\n How to minimize n? We can use the following idea:\n\n Consider that if we use k SCCs, then the minimal n to get at least p mutual pairs is when we form k components and we assign the nodes optimally.\n\n But note: the problem does not require that the entire graph is strongly connected. We just need the total mutual pairs (the sum of mutual pairs in each SCC) to be exactly p.\n\n However, we are allowed to have more than p? Actually, the problem says \"exactly p\". So we must have the sum of C(s_i,2) equal to p.\n\n But note: we are free to choose the sizes s_1, s_2, ..., s_k (positive integers) such that they sum to n, and then the total mutual pairs is the sum of C(s_i,2).\n\n Alternatively, we can think of the entire graph as having n nodes and being partitioned into k SCCs. The minimal n for which there exists a decomposition of n into k positive integers (each >=1) such that the sum of C(s_i,2) is p?\n\n However, note that the problem does not require the graph to be connected in any way. We can also have multiple SCCs.\n\n But note: the problem asks for the minimum number of nodes required to create a p-reachable directed graph.\n\n Let F(n) = maximum total mutual pairs (i.e., the maximum value of the sum of C(s_i,2)) we can get by partitioning n nodes into some number of SCCs (each SCC being a set of nodes, and the graph structure will be such that within an SCC we have a complete directed graph? Actually, to maximize mutual pairs, we would make each SCC as large as possible? But wait, we are constrained by the fact that we need exactly p. However, we are trying to find the minimal n such that we can form a graph (with n nodes) that has exactly p mutual pairs.\n\n Alternate approach:\n\n We note that the total mutual pairs is the sum_{i} [C(s_i,2)]. And the sum of s_i is n.\n\n We know that the function f(s) = C(s,2) is convex. Therefore, to minimize n for a fixed p, we should try to form the graph with as few SCCs as possible? Actually, we can also consider the maximum mutual pairs we can get with n nodes.\n\n But note: we are not forced to use all nodes in the SCCs? Actually, the graph must use all n nodes because we are creating a graph with n nodes.\n\n However, note that we can have isolated nodes (SCCs of size 1). For an SCC of size 1, the mutual pairs is 0.\n\n So we are to represent p as a sum of triangular numbers (each triangular number T(x) = x*(x-1)//2) and we want to minimize n = s_1 + s_2 + ... + s_k, where the triangular numbers are the ones we use.\n\n But note: the triangular numbers are nonnegative and we can use the same triangular number multiple times (since we can have multiple SCCs of the same size).\n\n However, we are not limited to distinct triangular numbers.\n\n But note: the problem says \"exactly p\", so we must use a multiset of triangular numbers (each corresponding to an SCC) that sum to p.\n\n The goal: find the smallest n (which is the sum of the bases s_i) such that p can be represented as the sum of k triangular numbers (each s_i>=1, so T(s_i)=0 for s_i=1, T(2)=1, T(3)=3, etc.).\n\n But note: we can also break an SCC into smaller ones? However, if we break an SCC of size s into two SCCs (say of sizes a and b, a+b=s), then the total mutual pairs change from T(s) to T(a)+T(b). Since T(s) = s*(s-1)//2, and T(a)+T(b) = a*(a-1)//2 + b*(b-1)//2, and by convexity, breaking a larger component into two smaller ones always reduces the total mutual pairs? Actually, no: breaking a component of size 4 (which gives 6 mutual pairs) into two components of size 2 and 2: T(2)+T(2)=1+1=2, which is less. So to maximize the mutual pairs we want to use as few SCCs as possible (or rather, use as large SCCs as possible). But here we are trying to achieve exactly p and minimize n.\n\n Actually, we are allowed to form the graph arbitrarily (with the constraint of being a directed graph and having exactly p mutual pairs). The minimal n must be at least the minimal base such that we can represent p as the sum of triangular numbers (each triangular number corresponds to an SCC) and the sum of the bases is n.\n\n However, note that we are free to assign the nodes arbitrarily to form SCCs. The key is: what is the minimal n such that we can write p as a sum of triangular numbers (each T(s) for s>=1) and the sum of the s's is n?\n\n But note: the same node cannot be split. Each node belongs to exactly one SCC.\n\n So we are looking for a representation of p as a sum of triangular numbers (each T(s) for s>=1) and we wish to minimize the sum of the bases (the s_i's). \n\n However, we can also use multiple representations: we can have several SCCs with the same size.\n\n This becomes a coin change-like problem: we have coins of denominations T(s) for s>=1 (which are 0,1,3,6,10,...) and we wish to represent p as a sum of coins (any number of each coin) and minimize the total value (in terms of the base s) of the coins. But note: the value of a coin T(s) = s*(s-1)//2, and the base s is the number of nodes in that SCC. Then the total number of nodes is the sum of the s_i's.\n\n Alternatively, we can note: if we use an SCC of size s, then we get T(s) = s*(s-1)//2 and we use s nodes. We wish to minimize the total nodes (sum of s_i) for a given p (the sum of T(s_i)).\n\n This is equivalent to: we want to cover p using the most efficient (in terms of node count) triangular numbers. \n\n How efficient is a triangular number? The ratio of T(s) to s is (s-1)/2. So a larger s gives more T(s) per node? Actually, the efficiency (T(s) per node) is (s-1)/(2) per node. So the larger the s, the better the efficiency.\n\n Therefore, to minimize the total nodes for a given p, we should use as many large triangular numbers as possible.\n\n However, we cannot exceed p.\n\n But note: we are allowed to use any combination. We can use dynamic programming? But p up to 200000, and the triangular numbers grow as O(n^2). We cannot iterate over all triangular numbers.\n\n Another idea: we can consider the minimal n such that the maximum mutual pairs we can get from n nodes is at least p? Actually, we need exactly p. But note: we can break a component arbitrarily. \n\n Alternatively, we can think: what is the maximum mutual pairs we can get from n nodes? That would be achieved by having one big SCC (if we are allowed to have only one component) but wait, we can have multiple components. Actually, the maximum mutual pairs from n nodes is achieved by having one SCC of size n, which gives T(n) = n*(n-1)//2.\n\n Then, we can represent p as the sum of some triangular numbers (each <= T(n)) and the total nodes used is the sum of the bases (s_i) of those triangular numbers.\n\n We wish to minimize n (the total nodes) such that p is representable as the sum of triangular numbers (each T(s) for s>=1) and the sum of the s_i (the bases) is n.\n\n But note: we are not forced to use all n nodes? Actually, the graph must have exactly n nodes. However, we can leave nodes as isolated (SCC of size 1) which contribute 0 to p. So if we use k SCCs, the total mutual pairs is the sum of T(s_i) for the non-isolated ones, and the rest are isolated (size 1). Therefore, we can also use zeros (isolated nodes) arbitrarily.\n\n So the problem reduces to: represent p as the sum of some triangular numbers (each T(s) for s>=2, because T(1)=0 and we don't need to use them for increasing p) and then the total nodes is the sum of the s_i (for the non-zero triangular parts) plus the isolated nodes (if any). But note, we can have isolated nodes without affecting p.\n\n However, we want the minimal n. We can use as many isolated nodes as we want (they don't contribute to p) so we can ignore them until we fix the non-isolated part.\n\n But note: we are allowed to have a graph with n nodes and we can choose which nodes to put in SCCs (and which to leave as isolated). The condition is that the total mutual pairs (from the non-isolated part) must be exactly p.\n\n So the minimal n is: the minimal value of (sum_{i} s_i) + (number of isolated nodes) such that the sum_{i} T(s_i) = p, and the s_i are at least 2 (because if s_i=1, T(s_i)=0 and we don't need to use them for p) and the isolated nodes can be arbitrarily many.\n\n Actually, we can combine the isolated nodes: we can use the representation of p as a sum of triangular numbers (each from s_i>=2) and then the total nodes is the sum of the s_i (the non-isolated) and we can set the isolated nodes to 0 (so we don't add any extra node). But wait, we are going to use exactly n nodes. We must use n nodes. The graph must have n nodes. Therefore, we must use all n nodes. However, we can assign some nodes to SCCs (with size>=2) and the rest to isolated nodes (size 1). \n\n But note: if we use an SCC of size s, then we use s nodes. The rest (n - sum_i s_i) nodes must be isolated (each is an SCC of size 1). \n\n So the condition is: we need to represent p as the sum of some triangular numbers (each T(s) for s>=2) and the sum of the s_i (the non-isolated nodes) must be <= n, and the remaining nodes (n - sum_i s_i) are isolated (each contributing 0). However, we wish to minimize n.\n\n Therefore, the minimal n is the minimal integer such that we can represent p as the sum of some triangular numbers (each T(s) for s>=2) and the sum of the bases (s_i) is at most n, but note: we are forced to use exactly n nodes, so we can have isolated nodes. But we are minimizing n, so we take the minimal n for which there exists a representation of p (using triangular numbers) and the sum of the bases (non-isolated nodes) is <= n. However, we can also use the same n: we are going to use the non-isolated nodes (with total sum S) and then the rest (n-S) nodes are isolated. Then the condition is that we must have S <= n, and we can choose n arbitrarily as long as n >= S. But we wish to minimize n, so we set n = S (we don't need to use more nodes than necessary for the non-isolated part, because the isolated nodes don't help in achieving p). \n\n Therefore, we are looking for the minimal S (the sum of the bases of the triangular numbers) such that p can be represented as the sum of triangular numbers (each T(s) for s>=2) and the sum of the s_i (the bases) is S. Then the minimal n is S (since we can have S non-isolated nodes and the rest (if any) we set to zero, but we are minimizing n, so we don't want extra nodes).\n\n However, wait: we must use exactly n nodes. But note: the problem does not require that we use all n nodes? Actually, the graph must have n nodes. But we are allowed to have isolated nodes. So we can use S nodes for the non-isolated part and the rest (n - S) nodes as isolated. Then the condition is that we can represent p by the non-isolated part (with total nodes S) and then we can set n to be any integer >= S. But we wish to minimize n, so we set n = S (if we can represent p with a set of triangular numbers that sum to p and whose base sum is S, then we can use n=S, and then we have S nodes in non-isolated and 0 isolated). \n\n However, note: the problem says \"minimum number of nodes required\". We can also use more than S nodes, but we want the minimal n.\n\n But wait: maybe we can represent p with a set of triangular numbers that uses more nodes (larger S) but then we can set n = S, and that is the minimal n. \n\n However, we want the minimal n. Therefore, we are looking for the minimal S (the total nodes used in non-isolated components) such that p is the sum of triangular numbers (each T(s) for s>=2) and the sum of the s_i is S. Then the answer for the first integer is S.\n\n But note: we are allowed to use the same triangular number multiple times? Yes.\n\n However, there is a catch: the triangular numbers are defined for s>=2. The triangular numbers are: 1, 3, 6, 10, 15, ... \n\n We wish to minimize S (the sum of the bases) for representing p as a sum of triangular numbers.\n\n This is similar to the classic coin change problem but with coins being triangular numbers (which are sparse) and we wish to minimize the total base (not the number of coins). \n\n But note: the base s for a triangular number T(s) is s, and T(s) = s*(s-1)//2.\n\n Example: p=3. \n   We can use one triangular number: T(3)=3 -> base=3, then S=3.\n   Alternatively, we could use three triangular numbers of T(2)=1: 1+1+1=3, then base=2+2+2=6 -> so S=6 is worse.\n\n Therefore, we want to use as few and as large triangular numbers as possible.\n\n How to compute this?\n\n We can use dynamic programming for small p, but p can be up to 200000.\n\n Alternatively, we can use a greedy method: since the triangular numbers are increasing, and the largest triangular number <= p is T(k) where k is the maximal integer such that k*(k-1)//2 <= p.\n\n Then, we can try to use as many large triangular numbers as possible.\n\n But note: we are minimizing the total base (S) and not the number of coins.\n\n However, the base for a triangular number T(s) is s. The efficiency (T(s) per base) is (s-1)/2. So we want to use the largest triangular numbers first because they give more T(s) per base.\n\n Steps:\n\n 1. Find the minimal S (the total base) such that p is the sum of some triangular numbers (each T(s) for s>=2) and the sum of the bases is S.\n\n 2. Then the first integer is S.\n\n 3. Now, the second part: among all graphs with n nodes (n=S) that are p-reachable (exactly p mutual pairs) and have the minimal n, we wish to maximize the number of unidirectional pairs.\n\n What is a unidirectional pair?\n   An ordered pair (u, v) (u != v) such that there is a path from u to v but not from v to u.\n\n In our graph, we have k SCCs (the non-isolated ones) and the rest are isolated (but if n=S, then there are no isolated nodes). The entire graph is the disjoint union of these k SCCs? Actually, no: the graph must be such that the SCCs form a DAG. However, the problem does not specify the structure beyond the mutual reachability.\n\n How do we count the unidirectional pairs?\n\n In the graph, we have edges. The unidirectional pairs occur between two nodes in different SCCs. \n\n Consider two nodes u and v in two different SCCs. There are two possibilities: \n   - If there is an edge from u's SCC to v's SCC but not the reverse, then (u, v) is a unidirectional pair.\n   - But note: the graph is arbitrary. However, we are allowed to design the graph arbitrarily as long as the mutual reachability condition (within SCCs) holds and the total mutual pairs (the sum of the internal mutual pairs) is p.\n\n To maximize the number of unidirectional pairs, we must consider:\n\n   Total ordered pairs of distinct nodes: n*(n-1)\n\n   Minus the mutual pairs (which are counted only for pairs (u,v) with u<v and mutual reachability, but note: the problem says for the entire graph, the mutual pairs are exactly p. However, note that the mutual pairs (for u<v) is p, but in the entire graph the mutual pairs (for unordered pairs) is 2p? Actually, no: the mutual pairs (for unordered pairs) would be 2p? But wait: the problem counts (u,v) for u<v. For each unordered pair {u,v} that is mutually reachable, it is counted once (as (u,v) if u<v). But note: the problem does not count (v,u) separately because the condition is u<v. \n\n However, for unidirectional pairs, we consider ordered pairs (u,v) and (v,u) separately.\n\n The total number of ordered pairs (u,v) with u != v is n*(n-1). \n\n The mutual pairs (both ways) for a pair (u,v) (with u != v) is either 0 or 2 (if there is a mutual path, then both (u,v) and (v,u) are paths). But note: the condition for mutual reachability is that both directions exist. \n\n Therefore, for a pair (u,v):\n   - If u and v are in the same SCC, then both (u,v) and (v,u) are present. So this pair contributes 0 unidirectional pairs.\n   - If u and v are in different SCCs, then we can choose to have edges in one direction or the other or both or none? \n\n But note: the graph is built from the SCCs. In the standard construction, we have a DAG of SCCs. In a DAG, for two distinct SCCs A and B, we can have edges from A to B or from B to A or both or none. However, we cannot have cycles between SCCs (by definition). \n\n But note: the problem does not require the graph to be a DAG? Actually, the definition of SCC is such that the condensation of the graph is a DAG. So we assume the graph is built from a DAG of SCCs.\n\n Now, how to maximize the unidirectional pairs?\n\n The unidirectional pairs come from edges between two SCCs in one direction only.\n\n However, note: we are free to design the edges arbitrarily as long as the mutual reachability is preserved (i.e., within each SCC we have a complete directed graph? Actually, no: the problem doesn't specify the internal structure of the SCCs. But to have mutual reachability, we must have a strongly connected component. The minimal way to make an SCC is to have a cycle that covers all nodes? Actually, we can have any strongly connected graph.\n\n But note: we are counting the mutual pairs (u<v) and we already accounted for that (the internal mutual pairs). For the unidirectional pairs, we are concerned with edges between different SCCs.\n\n The total number of edges between two SCCs can be arbitrary. However, we are not constrained by the mutual pairs condition for inter-component edges.\n\n The unidirectional pairs are the edges that go in one direction and not the other.\n\n However, note: the graph must be a DAG of SCCs. Then, for two distinct SCCs, we can have edges in one direction, the other, both, or none. But if we have both, then there would be a mutual reachability? Actually, no: because if we have edges from A to B and from B to A, then A and B would form one SCC (unless they are already connected in both ways via other components). But wait, we are building the graph from SCCs. The condensation is a DAG, so there cannot be cycles in the DAG. Therefore, we cannot have edges in both directions between two distinct SCCs.\n\n Therefore, for two distinct SCCs A and B, we can have edges from A to B, or from B to A, or none. \n\n Then, for two nodes u in A and v in B, the ordered pair (u,v) is unidirectional if there is an edge from A to B (so from u to v) but not from B to A (so from v to u). Similarly, (v,u) would be unidirectional if there is an edge from B to A but not from A to B.\n\n Now, to maximize the total unidirectional pairs, we should arrange the edges between the SCCs appropriately.\n\n Let the graph have k SCCs (with sizes s_1, s_2, ..., s_k). Then the total number of ordered pairs of distinct nodes is n*(n-1). The mutual pairs (both ways) are accounted for by the internal edges (which we have fixed by the SCC decomposition). \n\n The remaining pairs are the ones between two different SCCs. The total number of such ordered pairs is: \n   For each unordered pair (A,B) of distinct SCCs, we have |A| * |B| * 2 (because (u,v) and (v,u)).\n\n However, in our DAG, we cannot have both (u->v) and (v->u) for any two nodes in different SCCs. So for each unordered pair (A,B), we can have edges in one direction or the other, but not both. \n\n Then, for the two directions (A->B and B->A) we can choose one. \n\n Therefore, for the entire graph, the total unidirectional pairs (from inter-component edges) is:\n\n   For each unordered pair (A,B) of distinct SCCs, we can choose the direction (either A->B or B->A). Then, the number of unidirectional pairs contributed by the edges between A and B is |A|*|B| (if we choose A->B) and 0 (if we choose B->A) for the direction A->B, and similarly for the opposite? Actually, no: if we choose A->B, then the pair (u,v) for u in A and v in B is present and (v,u) is absent, so we get |A|*|B| unidirectional pairs (all the pairs from A to B). Similarly, if we choose B->A, then we get |B|*|A| unidirectional pairs (from B to A). \n\n But note: we cannot choose both. So for each unordered pair (A,B) we have two options:\n\n   Option 1: Add edges from A to B. Then we get |A|*|B| unidirectional pairs (from A to B).\n   Option 2: Add edges from B to A. Then we get |B|*|A| unidirectional pairs (from B to A).\n\n But wait, is that correct? Actually, no: the unidirectional pairs are defined for an ordered pair (u,v) (with u != v). When we choose the direction from A to B, then for every u in A and v in B, the pair (u,v) is present and (v,u) is absent, so we get |A|*|B| unidirectional pairs (from A to B). Similarly, if we choose the direction from B to A, then we get |B|*|A| unidirectional pairs (from B to A). \n\n However, note: the problem counts unidirectional pairs (u,v) (with u != v) and the condition is that there is a path from u to v and not from v to u. In the DAG structure, if we choose the direction from A to B, then from any node in A we can reach any node in B, and vice versa? No, because the DAG only has edges from A to B, so from B we cannot reach A (unless there is a path via other components, but in a DAG the edges are acyclic). Actually, the entire graph is the DAG of SCCs, so the reachability between two SCCs is determined by the DAG: if there is a path from A to B then we cannot have a path from B to A. Therefore, the direction we choose for the edge between A and B (if any) must be consistent with the DAG ordering.\n\n However, note: the problem does not require the graph to be connected. We can have a DAG that is not a total order. But the condensation is a DAG, so we can arrange the SCCs arbitrarily (we can choose the topological order). \n\n But note: we are free to choose the edges arbitrarily as long as the mutual reachability condition holds (which is already satisfied by the SCC decomposition). \n\n However, to maximize the unidirectional pairs, we want to maximize the total number of edges that go in one direction and not the other. \n\n But note: the problem does not require the graph to be a DAG? Actually, the definition of SCC requires that the condensation is a DAG. So we must have a DAG.\n\n Now, in a DAG, we can assign a topological order to the SCCs. Then, we can have edges only from an earlier node (in the topological order) to a later node. Then, for two SCCs A and B, if A comes before B, then we can have edges from A to B (so we get |A|*|B| unidirectional pairs) but not from B to A. \n\n Therefore, the maximum unidirectional pairs we can get from the inter-component edges is the sum over all pairs of SCCs (A, B) with A before B (in the topological order) of |A|*|B|.\n\n But note: we can choose the topological order arbitrarily (since we are constructing the graph). Therefore, we can arrange the SCCs in an order that maximizes the sum of |A|*|B| for A before B.\n\n However, the sum of |A|*|B| for A before B is independent of the order? Actually, no: the total sum over all unordered pairs (A,B) is fixed: it is (n^2 - sum_i (s_i)^2) / 2. But wait, the total number of ordered pairs between distinct SCCs is n*(n-1) minus the internal edges (which are the mutual pairs). However, we are counting the unidirectional pairs from inter-component edges.\n\n Actually, the total inter-component ordered pairs is n*(n-1) - (sum_i [s_i*(s_i-1)]).\n\n But note: the mutual pairs are the internal ones (the ones within the same SCC). The rest (inter-component) are unidirectional? Not necessarily: if we choose the edges arbitrarily, we might end up having some inter-component pairs that are bidirectional? But wait, we cannot have bidirectional edges between two distinct SCCs (because then they would be in the same SCC). Therefore, every inter-component ordered pair is either:\n\n   - Present in one direction only (then it is unidirectional)\n   - Or absent in both directions (then it is not an edge, so not unidirectional)\n\n But note: the problem does not require that we put edges between every pair of SCCs. We can choose to put edges in one direction or the other or none. \n\n However, to maximize the unidirectional pairs, we would put as many edges as possible in one direction (without creating a cycle). But note: we are constrained by the DAG structure. The maximum number of edges we can put without creating a cycle is the complete DAG: for every pair of SCCs, we put edges in one direction (from the earlier to the later). \n\n Then, the total unidirectional pairs from inter-component edges is the total number of edges we put, which is the number of ordered pairs (u in A, v in B) for every pair (A,B) with A before B. \n\n And that is: sum_{i<j} (s_i * s_j) [if we order the SCCs arbitrarily] but note: we can choose the order arbitrarily. The total is fixed: the sum of |A|*|B| for all unordered pairs (A,B) is ( (sum_i s_i)^2 - sum_i s_i^2 ) / 2, and then we take the entire set (because we are putting edges for every inter-component pair in one direction). \n\n However, wait: the problem does not require to put edges in every possible inter-component pair. But to maximize the unidirectional pairs, we should put as many edges as possible in the chosen direction (without creating cycles). The maximum is achieved by a complete DAG: we put an edge from every node in an earlier SCC to every node in a later SCC (in the topological order). Then, the total unidirectional pairs from inter-component edges is the total number of edges we put, which is the sum_{i<j} (s_i * s_j) (if we order the SCCs arbitrarily, but note: the ordering we choose must be fixed and we can choose the ordering arbitrarily to maximize the sum? Actually, the sum of s_i*s_j for i<j is independent of the ordering? \n\n Let T = (n^2 - sum_i s_i^2) / 2.\n\n Why? Because the total number of inter-component ordered pairs is n*(n-1) - (sum_i [s_i*(s_i-1)]). But note: the mutual pairs (internal) are counted as the internal edges? Actually, the problem counts the mutual pairs (u<v) as the condition for p, but the graph can have more edges? \n\n However, the mutual pairs (for u<v) is p, but the graph may have more edges? Actually, no: the condition is that the graph must contain exactly p mutual pairs (meaning that there are exactly p unordered pairs {u,v} (with u<v) that are mutually reachable). The graph can have other edges? Actually, the problem does not restrict the graph to have only the edges needed for the mutual reachability. \n\n But note: the definition of unidirectional pairs requires the existence of a path. Having an edge is sufficient to have a path (if the graph is built appropriately). \n\n However, the problem says \"Find the maximum number of unidirectional pairs\". \n\n We have two parts:\n\n   Part 1: The minimal n (the total nodes) is the minimal S (the sum of the bases of the triangular numbers) such that p is the sum of triangular numbers (each T(s) for s>=2) and the sum of the bases is S.\n\n   Part 2: Then, the maximum number of unidirectional pairs (edges) is the total number of edges in the complete DAG on the SCCs (with the chosen ordering) which is the sum_{i<j} (s_i * s_j). \n\n But wait, is that correct? \n\n Example: p=3, n=3 (one SCC of size 3). Then, the graph has 3 nodes and one SCC. Then, the inter-component edges: there are no inter-component edges (since k=1). So the unidirectional pairs are 0.\n\n Example: p=0. Then, we can have n=0? But the problem says 0<=p<=200000. For p=0, we need 0 mutual pairs. We can have 0 nodes, but the problem probably considers n>=1? Or n=0? The example input '0' gives output '0 0'. So for p=0, n=0 and the unidirectional pairs=0.\n\n But note: the problem says \"ordered pair of nodes (u, v)\" and if there are 0 nodes, there are no pairs. So that matches.\n\n Now, let's test p=1. Then, we need one mutual pair. The minimal representation: one SCC of size 2 (T(2)=1) -> n=2. Then, the graph has two nodes and one SCC (so a cycle of length 2). Then, the inter-component edges: none (only one component). So the unidirectional pairs are 0.\n\n Now, p=4. \n   Option 1: two SCCs of size 2: T(2)+T(2)=1+1=2 -> not enough.\n   Option 2: one SCC of size 3 (T(3)=3) and one SCC of size 1 (T(1)=0) -> but wait, we are allowed to have isolated nodes. But the minimal n is the sum of the bases (non-isolated) plus the isolated? Actually, we can use the representation: two SCCs of size 2 and one isolated node? Then the representation of p=4: we need 4 mutual pairs. But T(2)=1, so 1+1+1+1=4 (four SCCs of size 2) -> but that would be 8 nodes. Alternatively, one SCC of size 3 (3) and one SCC of size 2 (1) -> total mutual pairs=4, and total nodes=5. \n\n   So the minimal n is 5.\n\n   Then, the graph has two SCCs: one of size 3 and one of size 2. The total unidirectional pairs is the complete DAG: we order the two SCCs (say A and B). Then the number of edges from A to B is 3*2=6. But note: the graph is directed, so we can only have edges from A to B (if A is earlier) or from B to A (if B is earlier). Either way, we get 3*2=6 edges. But wait, the problem counts unidirectional pairs (u,v) (with u != v). These 6 edges are unidirectional because from the earlier SCC we can reach the later, but not vice versa.\n\n   However, note: the problem does not require that we put edges from every node to every node. But to maximize the unidirectional pairs, we put all possible edges in one direction (so the entire bipartite graph from A to B). Then, the unidirectional pairs from inter-component edges is 6.\n\n   But wait: the total unidirectional pairs: are there any other unidirectional pairs? The internal edges (within the SCCs) are bidirectional (so they are not unidirectional). The inter-component edges (from A to B) are unidirectional. There are no edges from B to A. So the total unidirectional pairs is 6.\n\n   However, the example input includes: \n        Input: 4 -> Output: 5 6\n\n   So the second part is 6.\n\n   But note: the example input also includes:\n        Input: 3 -> Output: 3 0\n        Input: 0 -> Output: 0 0\n\n   Now, let's check p=2: \n        We can use two SCCs of size 2: T(2)+T(2)=2, so n=4 (two SCCs, each size 2). Then, the total unidirectional pairs: we have two components. We can arrange the order arbitrarily. The complete DAG: we have two components A and B. Then the edges: from A to B: 2*2=4, or from B to A: 2*2=4. Either way, 4 edges. But note: the",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, meaning it contains exactly p ordered pairs of nodes (u, v) where u < v and u and v are mutually reachable. Additionally, among all such graphs with the minimum number of nodes, we need to find the maximum number of unidirectional pairs (pairs where there is a path from u to v but not from v to u).\n\n### Approach\n1. **Problem Analysis**:\n   - **Mutual Reachability**: Nodes u and v form a mutual pair if they can reach each other. In graph terms, these nodes must belong to the same strongly connected component (SCC). The number of mutual pairs in an SCC of size s is given by the triangular number \\( T(s) = s*(s-1)/2 \\).\n   - **p-Reachable Graph**: The graph must have exactly p mutual pairs. This means the sum of \\( T(s_i) \\) for all SCCs must equal p.\n   - **Minimizing Nodes**: To minimize the number of nodes, we should use as few SCCs as possible, each as large as possible, because larger SCCs contribute more mutual pairs per node.\n\n2. **Key Insight**:\n   - The minimal number of nodes \\( n \\) is the smallest sum of the sizes of SCCs whose combined \\( T(s_i) \\) sums to p. This is analogous to finding a combination of triangular numbers that sum to p with the minimal total base (sum of s_i).\n\n3. **Algorithm Selection**:\n   - **Greedy Selection**: We start with the largest possible triangular numbers (largest SCCs) and work our way down to smaller ones until the sum of their values equals p. This ensures we use the fewest nodes possible.\n   - **Dynamic Programming**: For efficiency, especially given the constraint \\( p \\leq 2 \\cdot 10^5 \\), we precompute the minimal node counts for all possible values up to 200,000.\n\n4. **Maximizing Unidirectional Pairs**:\n   - Once the minimal node count \\( n \\) is determined, the maximum number of unidirectional pairs is calculated by considering all ordered pairs between different SCCs. Specifically, for any two distinct SCCs, edges are directed from the earlier to the later in a topological order, contributing \\( |A| \\times |B| \\) unidirectional pairs for each pair of SCCs.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    max_tri_val = 0\n    s = 2\n    while max_tri_val < p:\n        tri_val = s * (s - 1) // 2\n        max_tri_val = tri_val\n        s += 1\n        \n    max_tri_val = max_tri_val\n    \n    dp = [10**9] * (p + 1)\n    dp[0] = 0\n    for tri in range(2, s):\n        t_val = tri * (tri - 1) // 2\n        if t_val > p:\n            break\n        for i in range(p, t_val - 1, -1):\n            if dp[i - t_val] != 10**9:\n                dp[i] = min(dp[i], dp[i - t_val] + tri)\n                \n    n_nodes = dp[p]\n    \n    comp_sizes = []\n    temp = p\n    tri_list = []\n    tri_used = {}\n    t = 2\n    while temp > 0:\n        t_val = t * (t - 1) // 2\n        if t_val > temp:\n            t -= 1\n            continue\n        if dp[temp] == t + dp[temp - t_val]:\n            count_here = (dp[temp] - (t-1)) // t if t-1 >= 0 else 1\n            count_here = (dp[temp] - (t-1)) // t\n            comp_sizes.extend([t] * count_here)\n            tri_used[t] = count_here\n            temp -= t_val * count_here\n        t += 1\n        \n    comp_sizes.sort(reverse=True)\n    \n    total_unidirectional = 0\n    n_val = sum(comp_sizes)\n    for i in range(len(comp_sizes)):\n        for j in range(i + 1, len(comp_sizes)):\n            total_unidirectional += comp_sizes[i] * comp_sizes[j]\n            \n    print(f\"{n_nodes} {total_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer \\( p \\), which is the number of mutual pairs required.\n2. **Special Case Handling**: If \\( p = 0 \\), the solution is trivial: no nodes are needed, and there are no unidirectional pairs.\n3. **Triangular Number Calculation**: We compute the largest triangular number less than or equal to \\( p \\) to determine the range of possible SCC sizes.\n4. **Dynamic Programming Setup**: We initialize a DP array where `dp[i]` stores the minimal node count required to achieve \\( i \\) mutual pairs.\n5. **DP Array Population**: For each triangular number, we update the DP array to reflect the minimal node count needed by considering whether including this triangular number reduces the node count.\n6. **Backtracking for Component Sizes**: Using the DP results, we backtrack to determine the sizes of the SCCs that sum to \\( p \\) with minimal node count.\n7. **Unidirectional Pairs Calculation**: For the determined SCC sizes, we calculate the maximum number of unidirectional pairs by summing the products of the sizes of all pairs of distinct SCCs, assuming edges are directed from smaller to larger components in a topological order.\n8. **Output**: The minimal node count and the maximum number of unidirectional pairs are printed.\n\nThis approach efficiently solves the problem by leveraging dynamic programming to minimize node usage and combinatorial mathematics to maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    max_tri_val = 0\n    s = 2\n    while max_tri_val < p:\n        tri_val = s * (s - 1) // 2\n        max_tri_val = tri_val\n        s += 1\n        \n    max_tri_val = max_tri_val\n    \n    dp = [10**9] * (p + 1)\n    dp[0] = 0\n    for tri in range(2, s):\n        t_val = tri * (tri - 1) // 2\n        if t_val > p:\n            break\n        for i in range(p, t_val - 1, -1):\n            if dp[i - t_val] != 10**9:\n                dp[i] = min(dp[i], dp[i - t_val] + tri)\n                \n    n_nodes = dp[p]\n    \n    comp_sizes = []\n    temp = p\n    tri_list = []\n    tri_used = {}\n    t = 2\n    while temp > 0:\n        t_val = t * (t - 1) // 2\n        if t_val > temp:\n            t -= 1\n            continue\n        if dp[temp] == t + dp[temp - t_val]:\n            count_here = (dp[temp] - (t-1)) // t if t-1 >= 0 else 1\n            count_here = (dp[temp] - (t-1)) // t\n            comp_sizes.extend([t] * count_here)\n            tri_used[t] = count_here\n            temp -= t_val * count_here\n        t += 1\n        \n    comp_sizes.sort(reverse=True)\n    \n    total_unidirectional = 0\n    n_val = sum(comp_sizes)\n    for i in range(len(comp_sizes)):\n        for j in range(i + 1, len(comp_sizes)):\n            total_unidirectional += comp_sizes[i] * comp_sizes[j]\n            \n    print(f\"{n_nodes} {total_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 1314,
        "thoughts_token_count": 8191
    }
}