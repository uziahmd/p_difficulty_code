{
    "start": 1758296866.0419374,
    "end": 1758300284.51261,
    "start-formatted": "2025-09-20 00:47 KST",
    "end-formatted": "2025-09-20 01:44 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, assume a <= b, so we can set d = b - a (but note: if a > b, then we can swap and adjust accordingly). However, let's consider:\n\nWe have:\n  x = a + k\n  y = b + k\n\nThen, note that y - x = (b - a) is constant.\n\nLet g = gcd(x, y). Then, we know that LCM(x, y) = (x * y) / g.\n\nBut note: x = a+k, y = b+k, so we have y = x + (b - a). Let d = b - a. Then, we can write:\n  y = x + d.\n\nThen, we are to minimize LCM(x, x+d) = (x * (x+d)) / gcd(x, x+d).\n\nAlternatively, note that gcd(x, x+d) = gcd(x, d). So, we can express the LCM as (x*(x+d)) / gcd(x, d).\n\nBut note: we are free to choose x (by choosing k) such that x >= max(a, b) if k>=0? Actually, if a<=b, then when k=0, x=a, y=b; and for k increasing, both increase by the same amount.\n\nHowever, note that if a > b, then d = b - a is negative. So it's better to let d = |a-b|, but then we have two cases. Alternatively, we can do:\n\nLet g = gcd(x, y) = gcd(a+k, b+k) = gcd(a+k, b-a) [if b>=a] or gcd(b+k, a-b) [if a>b].\n\nActually, without loss of generality, let d = abs(a-b). Then, note that gcd(a+k, b+k) = gcd(a+k, d). Why?\nBecause: gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a) = gcd(a+k, d).\n\nSo the problem reduces to: we want to minimize LCM(a+k, b+k) = ( (a+k)*(b+k) ) / gcd(a+k, d)\n\nBut note: the LCM is also ( (a+k)*(b+k) ) / gcd(a+k, b+k) = ( (a+k)*(b+k) ) / gcd(a+k, d)\n\nNow, note that k must be chosen such that a+k and b+k are positive (which they are since a,b>=1 and k>=0).\n\nHow can we approach this? The key is that the gcd divides d. Therefore, the gcd must be a divisor of d.\n\nSo, one idea is to consider all divisors of d (if d != 0). But note: if d=0, then a==b. Then, we are minimizing LCM(a+k, a+k) = a+k. The smallest k would be 0 because then a+k = a, which is the smallest value.\n\nBut wait: if a == b, then for any k, we have two identical numbers, and LCM(a+k, a+k) = a+k. So we want the smallest a+k, which is when k=0.\n\nSo, if a == b, answer is 0.\n\nNow, if d != 0, then we are going to consider divisors of d. However, note that we are not limited to divisors of d only? Actually, the gcd must divide d, so the gcd is one of the divisors of d (including negative divisors? but gcd is positive). So we can consider positive divisors.\n\nBut note: we are trying to minimize the LCM. Since LCM(x,y) = (x*y)/g, and g divides d, we can try to fix g as a divisor of d. Then, we require that g divides (a+k) and g divides d (so g is a divisor). Then, k must satisfy: (a+k) mod g == 0, i.e., k â‰¡ (-a) mod g.\n\nBut note: we are also free to choose k non-negative. So for each divisor g of d, we can set k_min(g) = (g - a % g) % g, but wait: we require k_min(g) to be the smallest non-negative k such that (a+k) % g == 0.\n\nHowever, note: we are actually considering g = gcd(a+k, d). But note that we cannot fix g arbitrarily because the gcd might not be exactly g, but at least we know that the gcd divides d and also divides a+k. But note: the condition for having gcd(a+k, d) = g is not just that g divides a+k and g divides d, but also that gcd((a+k)/g, d/g) = 1.\n\nBut wait, actually, we don't require the gcd to be exactly g, but we can use the divisor g to get a candidate k. Then, for that candidate k, the actual gcd might be larger than g? Actually, no: the gcd must divide d, but it could be any divisor. However, we are iterating over divisors of d, so we will consider the divisor g. Then, for a fixed divisor g, we set k0 = the smallest non-negative k such that g divides (a+k). Then, for that k0, we have that g divides (a+k0) and g divides d. Then, the actual gcd(a+k0, d) might be a multiple of g? Actually, no: the gcd is the greatest common divisor, so if g is a divisor and we set k0, then the gcd might be greater than g (if there is a larger divisor that also divides a+k0). \n\nBut note: we are not requiring the gcd to be exactly g, we are using g to set a candidate. However, we are going to consider every divisor of d, and then for each divisor we set a candidate k. Then, we compute the LCM for that candidate k and then take the minimum.\n\nBut wait: is that sufficient? Consider: the LCM depends on the actual gcd, which might be a divisor of d (and we are iterating over all divisors). However, if we fix g (a divisor) and set k0, then the gcd(a+k0, d) might be a divisor of d that is greater than g (if (a+k0) and d share more factors). Then, the LCM would be ( (a+k0)*(b+k0) ) / gcd(a+k0, d). But note: we are not forcing the gcd to be g, so we might get a different LCM.\n\nBut here's the catch: the LCM is determined by the actual gcd. And the actual gcd must be a divisor of d. Therefore, we can consider for each divisor g of d, the candidate k0 (smallest k>=0 such that g divides (a+k0)) and then compute the LCM for that k0. Then, we compare these LCMs.\n\nBut wait: what if for a divisor g, the candidate k0 leads to an actual gcd = g'? Then, we are effectively considering the divisor g' in our iteration, so we would have considered k0' (the candidate for divisor g') as well. However, note that for divisor g', the candidate k0' might be different from k0 (for divisor g). Therefore, we must consider all divisors.\n\nBut note: the candidate k0 for divisor g is the smallest k>=0 such that (a+k) is divisible by g. Then, for that k0, the gcd(a+k0, d) might be a multiple of g (and hence a divisor of d). Then, we are effectively considering the divisor g' (which is the actual gcd) in the next step? Not necessarily, because the candidate k0 for divisor g' might be different.\n\nHowever, note: the problem is that we are required to minimize the LCM. The LCM is (a+k)*(b+k) / g'. Since g' is a divisor of d, we can iterate over all divisors and then for each divisor, we compute the candidate k0 (the smallest k such that g' divides (a+k)) and then the LCM for that k0. Then, we take the candidate k0 that minimizes the LCM. But note: for a fixed divisor g', the candidate k0 is the smallest k such that (a+k) is divisible by g'. Then, we compute the LCM for that k0. However, note: the actual gcd might be g' (if g' is the gcd) or even larger? Actually, the gcd is defined as the greatest common divisor, so it might be a divisor of d that is greater than g' (if g' is not the greatest). But wait, we are iterating over all divisors, so the candidate k0 for divisor g' gives a k that makes g' divide (a+k) and d. Then, the gcd(a+k0, d) is at least g'. But it might be a multiple of g'? However, note that the gcd must divide d, and we are iterating over all divisors. But the candidate k0 for divisor g' is independent of the fact that the gcd might be larger. However, the LCM computed with k0 (with gcd being the actual gcd) is the correct LCM. So we don't need to worry: we are going to consider the candidate k0 for each divisor g' (each divisor of d) and then the actual gcd (which might be a divisor of d, and we are covering all divisors) will be considered.\n\nBut wait: what if the gcd is g' (a divisor) but we set k0 for divisor g'? Then, we are computing the LCM for that k0. However, if the same k0 satisfies the condition for a larger divisor (say g'') then we would also have considered k0 for divisor g''. But note: the candidate k0 for divisor g'' is the smallest k such that g'' divides (a+k). It might be that the same k0 satisfies multiple divisors? Then we are going to consider the same k0 multiple times. That's okay because we are comparing the LCMs.\n\nBut note: the LCM depends on the actual gcd. However, we are computing the LCM for candidate k0 (from divisor g') as (a+k0)*(b+k0)/gcd(a+k0,d). But we don't know the gcd until we compute it. However, note that we are iterating over divisors, and we are not forced to use the divisor g' to compute the LCM. We are just using g' to set the candidate k0.\n\nBut here's an important point: the candidate k0 for divisor g' is the smallest k such that g' divides (a+k). Then, the gcd(a+k0, d) must be a multiple of g'. However, we don't know the exact gcd. But note: the LCM formula is (a+k0)*(b+k0) / gcd(a+k0, d). We can compute the gcd(a+k0, d) by Euclidean algorithm.\n\nBut note: the problem constraints: a, b up to 10^9. The number of divisors of d is at most around 1344 (for highly composite numbers). So we can factorize d (if d !=0) and iterate over all divisors.\n\nSteps:\n\n1. If a == b, output 0.\n\n2. Let d = abs(a-b). Then, we are going to consider all divisors of d (positive and negative? No, divisors are positive because gcd is positive). So we consider positive divisors.\n\n3. For each divisor g of d (including 1 and d), we compute:\n   k0 = the smallest non-negative integer k such that (a+k) is divisible by g.\n        k0 = (g - a % g) % g   [This formula: if a % g == 0, then k0=0, else k0 = g - (a % g)]\n\n4. Then, we compute the actual gcd_val = gcd(a+k0, d). Note: since d is divisible by g, and g divides (a+k0), then the gcd_val is at least g, but we don't know. Actually, we can compute it with Euclidean algorithm.\n\n5. Then, we compute the LCM for k0: \n        lcm_val = ( (a+k0) * (b+k0) ) // gcd_val\n\n6. We then compare this lcm_val with the current best, and record the k0 that gives the minimal LCM. If two k0 give the same LCM, we choose the smallest k0.\n\nBut note: there might be other k values that are not captured by these divisors? \n\nWait, note that the gcd must divide d. Therefore, the candidate k0 we get from divisors of d are the only candidates that can possibly yield a gcd (because the gcd must divide d). However, note that k0 is the smallest k for divisor g, but maybe a larger k (for the same divisor g) would yield the same LCM? Actually, no: for a fixed divisor g, the candidate k0 is the smallest k that satisfies the condition. However, note that the LCM function is defined for all k, but we are trying to minimize it. But the problem is: is it possible that a k that is not of the form (g - a%g)%g for some divisor g of d might yield a smaller LCM? \n\nConsider: the LCM for a given k is (a+k)*(b+k)/gcd(a+k, d). The gcd(a+k, d) must divide d, so it is one of the divisors. However, note that for a given k, the gcd(a+k, d) is a divisor of d, say g0. Then, the candidate k0 for divisor g0 is the smallest k that achieves g0 (or at least that g0 divides a+k). But note: if we take k0 for divisor g0, then we are getting a k that is minimal for divisor g0. However, what if we take a larger k (for divisor g0) that still makes the gcd(a+k, d)=g0? Then, the LCM would be (a+k)*(b+k)/g0. Since k is larger, the product (a+k)*(b+k) is larger, so the LCM would be larger. Therefore, the minimal LCM for a fixed divisor g0 is achieved at the smallest k (k0) that makes g0 divide (a+k). \n\nBut wait: the gcd might be a divisor of d, but note that the same divisor g0 might appear from a k that is not the minimal one? However, the minimal k for divisor g0 is k0, and for k>=k0, the condition is satisfied (if we add multiples of g0). But then the LCM increases as k increases. So the minimal LCM for divisor g0 is achieved at k0.\n\nTherefore, we only need to consider k0 for each divisor g0 (divisor of d).\n\nBut wait: what if there is a divisor g0 that does not divide d? Then, we wouldn't consider it. However, the gcd must divide d, so that's okay.\n\nHowever, note: the above reasoning only holds if we are considering the gcd being a divisor of d. But what if the gcd is not a divisor of d? Actually, the gcd must divide d because it divides d (since gcd(a+k, d) = gcd(a+k, b-a) and d = b-a). So yes, the gcd must divide d.\n\nBut wait: what if d=0? Then a==b, and we handled that separately.\n\nBut note: there's another possibility: what if k is chosen such that the gcd is 0? But note: gcd(0, d) is |d|, but k>=0 and a+k and b+k are positive (unless a=0 and k=0, but a>=1). So we are safe.\n\nHowever, note: the above method only considers divisors of d. But what if d is very large? The number of divisors is about O(sqrt(d)), which for d up to 10^9 is about 10^4.5 worst-case, which is acceptable.\n\nBut wait: there's a catch. What if d=0? Then we skip, because we handled a==b.\n\nBut note: if a==b, we output 0.\n\nBut wait: what if a != b, but d is 1? Then divisors are [1]. Then, k0 = (1 - a%1)%1. But note: modulo operation with 1: a%1 is always 0, so k0=0. Then we compute the LCM for k=0.\n\nBut let me test with the example: \"6 10\" -> d=4.\n\nDivisors of 4: 1,2,4.\n\nFor divisor 1: k0 = (1 - 6%1)%1 -> but 6%1 is 0, so k0=0. Then, gcd(6,4)=2. Then, LCM(6,10)= (6*10)//2 = 30.\n\nBut wait, the example output is 2, meaning k=2.\n\nSo what's wrong?\n\nWait, the example: \nInput: 6 10 -> d=4.\nWe are to find k such that LCM(6+k,10+k) is minimized.\n\nk=0: LCM(6,10)=30\nk=1: LCM(7,11)=77\nk=2: LCM(8,12)=24\nk=3: LCM(9,13)=117\n\nSo the minimal LCM is 24 at k=2.\n\nBut in our method for divisor 1: k0=0, then we computed LCM=30.\n\nFor divisor 2: k0 = (2 - 6%2)%2 = (2-0)%2 = 0. Then, gcd(6,4)=2, then LCM= (6*10)//2 = 30.\n\nFor divisor 4: k0 = (4 - 6%4)%4 = (4-2)%4 = 2. Then, gcd(8,4)=4, then LCM=(8*12)//4 = 96//4=24.\n\nSo we found k0=2 for divisor 4, which gives LCM=24.\n\nBut why didn't we get k=2 from divisor 2? Because for divisor 2, the minimal k was 0. But note: the condition for divisor 2 is that (a+k) is divisible by 2. At k=0, 6 is divisible by 2, so we used k=0. However, k=2 also satisfies divisor 2 (because 8 is divisible by 2) but we are only taking the minimal k for divisor 2.\n\nSo our method is correct: for each divisor, we take the minimal k that satisfies the divisibility condition for that divisor.\n\nBut then, we compute the LCM for that minimal k. Then, we compare across divisors.\n\nBut wait: what if the minimal k for divisor g is k0, but there exists a divisor g' (which is the actual gcd) that is larger than g and requires a k0' that is less than k0? Then, we would have considered k0' from divisor g' and it would be the minimal k for divisor g'. \n\nBut note: the actual gcd might be a divisor that we haven't considered? Actually, no: we iterate over all divisors of d.\n\nBut wait: the gcd(a+k0, d) might be a divisor of d that is not necessarily the divisor we used to set k0. In fact, for divisor 2, we set k0=0 and then the actual gcd was 2 (which is the divisor we used). For divisor 4, we set k0=2 and the actual gcd was 4.\n\nBut what if the actual gcd is 1? Then we would have considered divisor 1 and set k0=0, and then the LCM was 30.\n\nBut note: the actual gcd might be a divisor that is not necessarily the divisor we used to set k0, but we are iterating over all divisors. However, the LCM for k0 is computed with the actual gcd (which we compute by Euclidean algorithm). \n\nBut wait: for divisor 2, we set k0=0 and then the actual gcd was 2, so we computed LCM= (6*10)//2 = 30.\n\nBut what if we consider divisor 1 and divisor 2 and divisor 4, and then pick the minimal LCM? Then, we have:\n\ndivisor 1: k0=0, LCM=30\ndivisor 2: k0=0, LCM=30\ndivisor 4: k0=2, LCM=24\n\nSo we choose k=2.\n\nSo the algorithm:\n\n1. Read a, b.\n2. If a == b: print 0 and exit.\n3. Let d = abs(a-b)\n4. Factorize d and get all divisors (positive).\n5. Initialize:\n   best_k = None\n   best_lcm = None   (we'll use a very large number, but note: the LCM can be very big, so we use a variable to store the minimal LCM and corresponding k)\n\n6. For each divisor g in divisors:\n   a. Compute k0 = (g - a % g) % g   [Note: if a % g == 0, then k0=0, else k0 = g - (a % g)]\n   b. Then, x = a + k0, y = b + k0\n   c. Compute g_val = gcd(x, d)   [Note: but note, we know that g divides d and g divides x, so g_val might be >=g, but we compute it by Euclidean algorithm.]\n   d. Actually, we can compute g_val = gcd(x, y) but note that gcd(x,y)=gcd(x, d) because y = x+d. But we already know d, so we can use gcd(x, d). But note: we can compute gcd(x, d) by Euclidean algorithm.\n\n   e. Then, LCM = (x * y) // g_val\n\n   f. Compare LCM with best_lcm. If LCM < best_lcm, update best_lcm and best_k = k0. If LCM == best_lcm, then update best_k to the minimum between the current best_k and k0.\n\n7. Print best_k.\n\nBut wait: is it possible that the same k0 appears from two different divisors? Then, we are updating best_k with the same k0, which is fine.\n\nHowever, note: k0 is defined by the divisor g. Different divisors might yield the same k0? For example, if g and g' are divisors and the condition (a+k0 divisible by g) and (a+k0 divisible by g') hold. Then, k0 is the same. Then, we compute the same LCM twice. But that's okay.\n\nBut note: we must consider that the divisor g must be a divisor of d, and d might have repeated factors, but the divisors are distinct.\n\nBut wait: what if d is 0? We handled a==b.\n\nHowever, there is a potential issue: the divisor g must be positive. We are only taking positive divisors.\n\nBut note: the modulus operation in Python for positive numbers is well-defined.\n\nBut wait: what if a % g is 0? Then k0=0.\n\nBut note: what if g is greater than a? Then, a % g is a (if a < g). Then, k0 = g - a % g = g - a. Then, k0 = g - a, which is positive.\n\nBut note: we must consider that the divisor g must divide d, and d = abs(a-b). The divisors are positive and we consider all divisors.\n\nBut wait: what if d is negative? We set d = abs(a-b), so d is non-negative. Then, if d==0, we handled separately. Otherwise, d>0.\n\nBut note: there's an alternative way to think: the condition is that (a+k) and (b+k) have a gcd that divides d. So we are correct.\n\nBut wait: the example \"21 31\": expected output is 9.\n\nLet me test with our algorithm:\n\na=21, b=31, d=10.\n\nDivisors of 10: [1,2,5,10]\n\nCompute for each divisor:\n\ng=1: k0 = (1 - 21%1)%1 -> 0 (since 21%1=0). Then, gcd(21+0,10)=gcd(21,10)=1. LCM=(21*31)//1 = 651.\n\ng=2: k0 = (2-21%2)%2 = (2-1)%2 = 1. Then, x=22, y=32. gcd(22,10)=2. LCM=(22*32)//2 = 352.\n\ng=5: k0 = (5-21%5)%5 = (5-1)%5 = 4. Then, x=25, y=35. gcd(25,10)=5. LCM=(25*35)//5 = 175.\n\ng=10: k0 = (10-21%10)%10 = (10-1)%10 = 9. Then, x=30, y=40. gcd(30,10)=10. LCM=(30*40)//10 = 120.\n\nThe minimal LCM is 120 at k0=9.\n\nSo we output 9.\n\nAnother example: \"5 10\", expected output 0.\n\na=5, b=10, d=5.\n\nDivisors: 1,5.\n\ng=1: k0=0. Then, x=5, y=10, gcd(5,5)=5. Then, LCM=(5*10)//5=10.\n\ng=5: k0=(5-5%5)%5=0. Then, same.\n\nBut wait, the example output is 0.\n\nBut note: the example input \"5 10\" is provided, and expected output is 0.\n\nBut wait, is k=0 allowed? Yes. Then, LCM(5,10)=10.\n\nIs there any k that gives LCM less than 10? \n\nk=0: 5,10 -> LCM=10\nk=1: 6,11 -> LCM=66\nk=2: 7,12 -> LCM=84\n...\n\nSo indeed, k=0 is the answer.\n\nBut wait, in our calculation for divisor 1: we got k0=0 and then the actual gcd was 5, so we computed LCM=10.\n\nBut wait, how did we compute the gcd? We computed gcd(5,5)=5. Then, LCM= (5*10)//5=10.\n\nBut note: the divisor 1: we set k0=0, then we computed the actual gcd (which was 5). Then, we computed the LCM. \n\nBut note: the divisor 1 is a divisor of d=5, and we set k0=0 (which is the minimal k for divisor 1). Then, the actual gcd was 5, not 1. But that's okay because we are not forcing the gcd to be 1, we are just using 1 to set k0. Then, we compute the LCM with the actual gcd.\n\nBut wait, is that correct? Yes, because the LCM is defined as (x*y)/gcd(x,y). We are using the actual gcd.\n\nBut note: the divisor 5: we set k0=0, and then the actual gcd was 5, and then LCM=10.\n\nSo we get the same result.\n\nBut wait: what if we consider divisor 1 and divisor 5, and we get the same k0=0 for both? Then, we compute the same LCM twice, but that's okay.\n\nBut wait: is there any divisor that we missed? \n\nWhat if we consider divisor 5 and divisor 1, but note: the divisors of 5 are [1,5]. So we covered.\n\nBut wait, what if d is negative? We set d = abs(a-b), so we avoid negative.\n\nBut note: the divisor iteration: we consider positive divisors.\n\nBut wait: what if a and b are swapped? Then d = abs(a-b) is the same.\n\nBut note: the problem says a and b can be up to 10^9, so we must be careful with performance.\n\nHow to factorize d (up to 10^9)? \n\nWe can factorize d by trial division in O(sqrt(d)), which is about 10^4.5, which is acceptable.\n\nSteps for factorization:\n\ndef factorize(n):\n    factors = {}\n    temp = n\n    d = 2\n    while d*d <= temp:\n        while temp % d == 0:\n            factors[d] = factors.get(d,0)+1\n            temp //= d\n        d += 1\n    if temp > 1:\n        factors[temp] = factors.get(temp,0)+1\n    return factors\n\nThen, generate divisors from factors.\n\nBut note: d can be 0? We handled a==b.\n\nBut note: if a==b, we output 0 and exit.\n\nBut wait: what if a and b are negative? The problem states: \"1 <= a, b <= 10^9\", so non-negative and at least 1.\n\nSo we don't need to handle negatives.\n\nBut note: the example \"5 10\" is handled.\n\nBut wait: what if d is 1? Then divisors=[1]. Then, k0 = (1 - a%1)%1 -> but modulo 1 is 0, so k0=0.\n\nBut then, we compute the actual gcd(a+0, d)=gcd(a,1)=1. Then, LCM = (a*(a+1))//1 = a*(a+1). \n\nBut note: the minimal LCM might not be at k=0? \n\nWait, no: because the gcd must divide d=1, so the gcd is 1. Then, the LCM is (a+k)*(b+k). We are minimizing (a+k)*(b+k) for k>=0. This is minimized when k=0.\n\nBut wait: is that true? (a+k)*(b+k) is a quadratic that opens upwards. The minimal value is at k=- (a+b)/2, but k>=0. So the minimal value for k>=0 is at k=0.\n\nBut wait, what if a and b are different? For example, a=2, b=4, then d=2. Then divisors=[1,2]. \n\nk0 for divisor1:0 -> LCM=(2*4)//gcd(2,2)= (8)//2=4.\nk0 for divisor2: (2-2%2)%2 = (2-0)%2=0 -> same.\n\nBut wait, what if we choose k=1: then (3,5) -> gcd(3,2)=1, LCM=15, which is worse.\n\nBut wait, what if we choose k=2: (4,6) -> gcd(4,2)=2, LCM=(4*6)//2=12.\n\nSo the minimal LCM is at k=0.\n\nBut wait, what if a=2, b=5? Then d=3. Divisors=[1,3].\n\nk0 for divisor1:0 -> LCM=(2*5)//gcd(2,3)=10//1=10.\nk0 for divisor3: (3-2%3)%3 = (3-2)%3=1 -> k0=1, then LCM=(3*6)//gcd(3,3)=18//3=6.\n\nSo the minimal LCM is 6 at k=0? Wait no: k0=1 gives 6, which is less than 10. So we choose k=1.\n\nBut wait, the example: a=2, b=5, k=0: LCM(2,5)=10, k=1: LCM(3,6)=6, k=2: LCM(4,7)=28, k=3: LCM(5,8)=40. So yes, k=1 is the answer.\n\nBut wait, the problem says: if there are multiple k with the same minimal LCM, choose the smallest k. \n\nBut note: what if two different divisors lead to the same k0? Then we don't need to worry because we are storing the k0 and updating the best_k only if the LCM is strictly less or equal (and then take the smallest k0 in case of tie). \n\nBut wait, we are iterating over divisors, and we are storing the best LCM and the k0 that achieved it. However, if two divisors lead to the same k0 and same LCM, then we update best_k to the minimum k0, but they are the same so it doesn't change.\n\nBut note: we are comparing the LCMs. If two divisors lead to different k0 and same LCM, then we choose the smallest k0.\n\nBut wait, the problem says: if there are multiple k with the same minimal LCM, choose the smallest k. So we must compare k0 even if the LCM is the same.\n\nBut note: we are storing the best_k and best_lcm. We update best_k only if the current k0 gives a strictly smaller LCM, or if the LCM is equal and k0 is smaller than the stored best_k.\n\nBut wait, we are iterating over divisors, and we might get the same LCM from two different k0. Then, we must update best_k to the minimal k0 that achieves the minimal LCM.\n\nBut note: the minimal LCM might be achieved by multiple k0. Then, we choose the smallest k0.\n\nSo we should do:\n\nInitialize:\n   best_k = None\n   best_lcm = None\n\nFor each divisor g:\n   compute k0\n   compute LCM_val\n\n   if best_lcm is None or LCM_val < best_lcm or (LCM_val == best_lcm and k0 < best_k):\n        best_lcm = LCM_val\n        best_k = k0\n\nBut wait, initially best_k is None, so we have to set best_k to k0 for the first divisor.\n\nAlternatively, we can set best_lcm to a very large number, but note the LCM can be very large (a,b up to 1e9, then LCM can be up to (1e9+...)^2, which is 1e18, so we can set best_lcm = None and then update.\n\nBut note: we are iterating over divisors, and the divisors are positive. There is at least one divisor (1) so we will update.\n\nBut wait: what if d=0? We handled a==b.\n\nBut wait: what if d=0 and a==b, then we output 0. But we already handled.\n\nBut note: we must compute the gcd correctly. We can use math.gcd, but note: we are computing gcd(x, d). But x and d might be very large (x = a+k0, and k0 can be up to d, so x up to 2e9, which is acceptable for math.gcd).\n\nBut wait: the problem constraints: a, b up to 10^9, then d = abs(a-b) up to 10^9. Then, k0 is at most d (which is 10^9) so x = a+k0 can be up to 2e9, which is acceptable for gcd.\n\nBut note: the Euclidean algorithm for two numbers up to 2e9 is efficient (O(log n)).\n\nBut wait: we are iterating over divisors (about O(sqrt(d)) divisors). For each divisor, we do:\n\n   k0 = (g - a % g) % g   [This is O(1)]\n   x = a + k0\n   y = b + k0\n   g_val = gcd(x, d)   [But note: we know that g divides d and g divides x (because k0 is chosen so that g divides x). Then, the gcd(x,d) is at least g. But we don't know the exact value, so we compute it by Euclidean algorithm.\n\nBut note: we can compute gcd(x, d) by Euclidean algorithm. However, we can also compute gcd(x, d) without knowing the divisors? But we are already using math.gcd.\n\nBut note: we can use math.gcd(x, d) but wait: d is fixed (abs(a-b)). However, we can also use the fact that gcd(x, d) = gcd(x, d) and we know that x is divisible by g (and g divides d). But the actual gcd might be a multiple of g. However, we don't know, so we compute it.\n\nBut note: the Euclidean algorithm for numbers up to 2e9 is fast.\n\n",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest one.\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) is constant (\\( |a - b| \\)). The LCM of two numbers \\( x \\) and \\( y \\) can be expressed as \\( \\frac{x \\times y}{\\text{gcd}(x, y)} \\). Given that \\( y = x + d \\) (where \\( d = |a - b| \\)), the GCD of \\( x \\) and \\( y \\) must divide \\( d \\). This insight allows us to consider all divisors of \\( d \\) to find potential candidates for \\( k \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( d \\), we compute the smallest \\( k \\) such that \\( g \\) divides \\( a + k \\). This \\( k \\) ensures that the GCD of \\( a + k \\) and \\( b + k \\) is at least \\( g \\). By evaluating the LCM for each such \\( k \\), we can determine the minimal LCM across all divisors.\n\n3. **Algorithm Selection**:\n   - **Case Handling**: If \\( a = b \\), the answer is trivially \\( 0 \\) since the LCM of \\( a \\) and \\( a \\) is minimized at \\( k = 0 \\).\n   - **Divisor Enumeration**: For \\( d = |a - b| \\), enumerate all positive divisors. For each divisor \\( g \\), compute the minimal \\( k \\) such that \\( g \\) divides \\( a + k \\).\n   - **LCM Calculation**: For each computed \\( k \\), calculate the actual GCD of \\( a + k \\) and \\( b + k \\), then compute the LCM. Track the minimal LCM and the corresponding smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( d \\) is \\( O(\\sqrt{d}) \\). For each divisor, operations like modulo and GCD computation are \\( O(1) \\) or \\( O(\\log(\\text{max}(a, b))) \\), making the overall complexity feasible even for large \\( d \\) (up to \\( 10^9 \\)).\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef factorize(n):\n    factors = {}\n    temp = n\n    d = 2\n    while d * d <= temp:\n        while temp % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp //= d\n        d += 1\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    return factors\n\ndef get_divisors_from_factors(factors):\n    divisors = [1]\n    for prime, exp in factors.items():\n        new_divs = []\n        for power in range(1, exp + 1):\n            factor_power = prime ** power\n            for d in divisors:\n                new_divs.append(d * factor_power)\n        divisors += new_divs\n    return set(divisors)\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d_val = abs(a - b)\n    \n    if d_val == 0:\n        print(0)\n        return\n        \n    factors_dict = factorize(d_val)\n    divisors_set = get_divisors_from_factors(factors_dict)\n    \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors_set:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n            \n        x = a + k0\n        y = b + k0\n        \n        g_val = math.gcd(x, d_val)\n        \n        lcm_val = (x * y) // g_val\n        \n        if best_lcm is None:\n            best_lcm = lcm_val\n            best_k = k0\n        else:\n            if lcm_val < best_lcm:\n                best_lcm = lcm_val\n                best_k = k0\n            elif lcm_val == best_lcm:\n                if k0 < best_k:\n                    best_k = k0\n                    \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is immediately \\( 0 \\) because the LCM of two identical numbers is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For \\( d = |a - b| \\), factorize \\( d \\) into its prime factors and generate all positive divisors.\n4. **Finding Minimal \\( k \\)**: For each divisor \\( g \\), compute the smallest \\( k \\) such that \\( g \\) divides \\( a + k \\). This \\( k \\) ensures that \\( g \\) is a candidate for the GCD of \\( a + k \\) and \\( b + k \\).\n5. **LCM Evaluation**: For each \\( k \\), compute the actual GCD and then the LCM. Track the minimal LCM and the smallest \\( k \\) that achieves it.\n6. **Output**: Print the smallest \\( k \\) that minimizes the LCM, or the first such \\( k \\) encountered if multiple values yield the same minimal LCM.\n\nThis approach efficiently narrows down the search space to divisors of \\( |a - b| \\), leveraging mathematical properties to minimize the LCM without exhaustive checks.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef factorize(n):\n    factors = {}\n    temp = n\n    d = 2\n    while d * d <= temp:\n        while temp % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp //= d\n        d += 1\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    return factors\n\ndef get_divisors_from_factors(factors):\n    divisors = [1]\n    for prime, exp in factors.items():\n        new_divs = []\n        for power in range(1, exp + 1):\n            factor_power = prime ** power\n            for d in divisors:\n                new_divs.append(d * factor_power)\n        divisors += new_divs\n    return set(divisors)\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d_val = abs(a - b)\n    \n    if d_val == 0:\n        print(0)\n        return\n        \n    factors_dict = factorize(d_val)\n    divisors_set = get_divisors_from_factors(factors_dict)\n    \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors_set:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n            \n        x = a + k0\n        y = b + k0\n        \n        g_val = math.gcd(x, d_val)\n        \n        lcm_val = (x * y) // g_val\n        \n        if best_lcm is None:\n            best_lcm = lcm_val\n            best_k = k0\n        else:\n            if lcm_val < best_lcm:\n                best_lcm = lcm_val\n                best_k = k0\n            elif lcm_val == best_lcm:\n                if k0 < best_k:\n                    best_k = k0\n                    \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1305,
        "thoughts_token_count": 8191
    }
}