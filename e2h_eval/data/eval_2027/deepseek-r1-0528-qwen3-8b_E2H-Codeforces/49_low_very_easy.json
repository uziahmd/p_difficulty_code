{
    "start": 1758302820.2874184,
    "end": 1758306574.9789844,
    "start-formatted": "2025-09-20 02:27 KST",
    "end-formatted": "2025-09-20 03:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given n, m and then m lines each with four numbers: a, b, gcd, lcm (the two lawns and the gcd and lcm for that edge)\n\n We know: \n   For an edge between u and v with given gcd = g and lcm = l, we must have:\n     Let the number of mushrooms at lawn u be x, and at lawn v be y.\n     Then, we must have:\n        gcd(x, y) = g, and lcm(x, y) = l.\n\n Also, note that for any two numbers x and y, we have:\n        x * y = gcd(x,y) * lcm(x,y)   [because gcd(x,y)*lcm(x,y) = x*y]\n\n Steps:\n\n 1. Check consistency for each edge: \n      - The gcd must divide both x and y, so it must divide the product? Actually, from the equation x*y = g*l, and the gcd condition, we can derive more.\n\n 2. However, note that the problem is about restoring numbers on the vertices (lawns) such that for every given edge the gcd and lcm conditions hold.\n\n How to approach?\n\n Observation: \n   Since the graph might not be connected, we have to consider each connected component separately.\n\n Steps:\n\n  a. For each edge (u, v, g, l):\n        Condition 1: g must divide l (since g divides x and y, and then divides any linear combination, and in particular, the lcm which is a multiple of both)\n        Condition 2: The product g*l must be divisible by the square of g? Not exactly. But note: x and y must be multiples of g, and their product is g*l. Moreover, we can write x = g * a, y = g * b, then we have:\n            gcd(a, b) = 1, and lcm(a, b) = l / g^2? Wait, let me check:\n\n        Actually, since x = g * a, y = g * b, then:\n            gcd(x, y) = g * gcd(a, b) = g   => gcd(a, b) = 1.\n            lcm(x, y) = (g*a * g*b) / gcd(x,y) = (g^2 * a * b) / g = g * (a*b) = l.\n\n        So we have: a*b = l / g.\n\n        Therefore, the product of the two numbers (a and b) must be (l/g). And they must be coprime.\n\n        Also, note that the same vertex may appear in multiple edges.\n\n  b. We can try to assign a value to each vertex. Alternatively, we can set up equations for each vertex.\n\n Another idea:\n\n   For each vertex, we want to assign a number. But note that the entire graph must satisfy the conditions on edges.\n\n   However, we can use the following:\n\n      Let x_i be the number of mushrooms at lawn i.\n\n      For an edge (u, v, g, l):\n          We must have:\n            x_u * x_v = g * l\n            gcd(x_u, x_v) = g\n\n      This implies that x_u and x_v must be of the form:\n          x_u = g * a\n          x_v = g * b\n          where gcd(a, b) = 1, and a*b = (l // g)\n\n      But note: l must be divisible by g (Condition 1 above). So if not, we output \"NO\".\n\n      Now, the same vertex might be constrained by multiple edges.\n\n  c. We can do:\n\n      Step 1: Check for each edge that g divides l.\n\n      Step 2: For each edge, compute the candidate pairs (a, b) such that a*b = l//g and gcd(a,b)=1.\n\n      But note: the graph has many edges and the numbers can be large (up to 10^6). We don't want to factorize l//g for each edge if there are many edges.\n\n  d. Alternatively, we can think of the entire graph as having constraints that the product of two adjacent vertices must be the same (g*l) and the gcd condition. \n\n  e. Another observation: \n        Since x_u * x_v = g*l for an edge (u, v, g, l), and also x_u and x_v must be multiples of g, then the value of x_u must divide (g*l) and be a multiple of g.\n\n        Moreover, the gcd condition tells us that if we let x_u = g * a, then x_v = (g*l) / x_u, and then we must have gcd(x_u, x_v) = g.\n\n        But note: gcd(g*a, (g*l)//(g*a)) = g * gcd(a, l//(g*a)) = g. So we",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a graph such that for every given edge, the greatest common divisor (GCD) and least common multiple (LCM) of the numbers on the connected vertices match the provided values. The solution involves checking the consistency of the given edges and then assigning values to vertices based on these constraints.\n\n### Approach\n1. **Edge Consistency Check**: For each edge, verify that the GCD divides the LCM. If not, the arrangement is impossible.\n2. **Vertex Value Assignment**: For each vertex, maintain a set of possible values derived from the edges incident to it. The value must satisfy both the product condition (x_u * x_v = GCD * LCM) and the GCD condition (gcd(x_u, x_v) = given GCD) for all adjacent edges.\n3. **Graph Processing**: Process the graph by considering each connected component separately. For each vertex, the assigned value must be consistent across all its incident edges.\n4. **Result Determination**: After processing all edges, check if all vertices have a unique value. If any vertex has no valid value or conflicting values, the arrangement is impossible.\n\n### Solution Code\n```python\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for i in range(m):\n        a = int(data[index]); b = int(data[index+1]); g = int(data[index+2]); l = int(data[index+3])\n        index += 4\n        edges.append((a-1, b-1, g, l))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    candidate = [set() for _ in range(n)]\n    product_map = {}\n    \n    for u, v, g, l in edges:\n        base = l // g\n        if base * g != l:\n            print(\"NO\")\n            return\n            \n        factors = factorize(base)\n        divisors = get_divisors(factors)\n        for d in divisors:\n            if base % d == 0:\n                other = base // d\n                if math.gcd(d, other) == 1:\n                    candidate_u_val = g * d\n                    candidate_v_val = g * other\n                    candidate[u].add(candidate_u_val)\n                    candidate[v].add(candidate_v_val)\n                    \n    for i in range(n):\n        if len(candidate[i]) == 0:\n            print(\"NO\")\n            return\n            \n    ans = [0] * n\n    visited = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [i]\n        comp_nodes = []\n        while stack:\n            node = stack.pop()\n            if visited[node]:\n                continue\n            visited[node] = True\n            comp_nodes.append(node)\n            for neighbor, g, l in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n                    \n        if len(comp_nodes) == 1:\n            node = comp_nodes[0]\n            vals = sorted(candidate[node])\n            if len(vals) > 1:\n                print(\"NO\")\n                return\n            ans[node] = vals[0]\n            continue\n            \n        for node in comp_nodes:\n            if len(candidate[node]) == 1:\n                base_val = next(iter(candidate[node]))\n                ans[node] = base_val\n                q = deque([node])\n                visited_comp = {node}\n                while q:\n                    cur = q.popleft()\n                    for neighbor, g, l in graph[cur]:\n                        if neighbor in visited_comp:\n                            continue\n                        if ans[neighbor] == 0:\n                            if len(candidate[neighbor]) > 1:\n                                print(\"NO\")\n                                return\n                            ans[neighbor] = candidate[neighbor].pop()\n                        else:\n                            if ans[neighbor] != candidate[neighbor].pop():\n                                print(\"NO\")\n                                return\n                        visited_comp.add(neighbor)\n                        q.append(neighbor)\n            else:\n                break\n                \n        if any(ans[node] == 0 for node in comp_nodes):\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n    \ndef factorize(n):\n    factors = {}\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            n //= d\n        d += 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef get_divisors(factors):\n    divisors = [1]\n    for prime, exp in factors.items():\n        new_divs = []\n        for power in range(1, exp+1):\n            factor_power = prime ** power\n            for d in divisors:\n                new_divs.append(d * factor_power)\n        divisors += new_divs\n    divisors = list(set(divisors))\n    divisors.sort()\n    return divisors\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Edge Consistency Check**: The code first checks if the GCD divides the LCM for each edge. If not, it immediately outputs \"NO\".\n2. **Candidate Values Calculation**: For each edge, it calculates possible values for the vertices by factorizing the quotient (LCM/GCD) and finding pairs of coprime factors. These values are stored in sets for each vertex.\n3. **Graph Processing**: The graph is processed by connected components. Each component is handled separately to ensure consistency in vertex values.\n4. **Value Assignment**: Vertices with single candidate values are assigned those values first, propagating these values to adjacent vertices. If any vertex has multiple candidates or conflicts arise during propagation, the solution outputs \"NO\".\n5. **Output**: If all vertices are successfully assigned values without conflicts, the solution outputs \"YES\" followed by the assigned values. Otherwise, it outputs \"NO\".\n\nThis approach efficiently checks for the feasibility of the mushroom arrangement and ensures the solution adheres to all given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for i in range(m):\n        a = int(data[index]); b = int(data[index+1]); g = int(data[index+2]); l = int(data[index+3])\n        index += 4\n        edges.append((a-1, b-1, g, l))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    candidate = [set() for _ in range(n)]\n    product_map = {}\n    \n    for u, v, g, l in edges:\n        base = l // g\n        if base * g != l:\n            print(\"NO\")\n            return\n            \n        factors = factorize(base)\n        divisors = get_divisors(factors)\n        for d in divisors:\n            if base % d == 0:\n                other = base // d\n                if math.gcd(d, other) == 1:\n                    candidate_u_val = g * d\n                    candidate_v_val = g * other\n                    candidate[u].add(candidate_u_val)\n                    candidate[v].add(candidate_v_val)\n                    \n    for i in range(n):\n        if len(candidate[i]) == 0:\n            print(\"NO\")\n            return\n            \n    ans = [0] * n\n    visited = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [i]\n        comp_nodes = []\n        while stack:\n            node = stack.pop()\n            if visited[node]:\n                continue\n            visited[node] = True\n            comp_nodes.append(node)\n            for neighbor, g, l in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n                    \n        if len(comp_nodes) == 1:\n            node = comp_nodes[0]\n            vals = sorted(candidate[node])\n            if len(vals) > 1:\n                print(\"NO\")\n                return\n            ans[node] = vals[0]\n            continue\n            \n        for node in comp_nodes:\n            if len(candidate[node]) == 1:\n                base_val = next(iter(candidate[node]))\n                ans[node] = base_val\n                q = deque([node])\n                visited_comp = {node}\n                while q:\n                    cur = q.popleft()\n                    for neighbor, g, l in graph[cur]:\n                        if neighbor in visited_comp:\n                            continue\n                        if ans[neighbor] == 0:\n                            if len(candidate[neighbor]) > 1:\n                                print(\"NO\")\n                                return\n                            ans[neighbor] = candidate[neighbor].pop()\n                        else:\n                            if ans[neighbor] != candidate[neighbor].pop():\n                                print(\"NO\")\n                                return\n                        visited_comp.add(neighbor)\n                        q.append(neighbor)\n            else:\n                break\n                \n        if any(ans[node] == 0 for node in comp_nodes):\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n    \ndef factorize(n):\n    factors = {}\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            n //= d\n        d += 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef get_divisors(factors):\n    divisors = [1]\n    for prime, exp in factors.items():\n        new_divs = []\n        for power in range(1, exp+1):\n            factor_power = prime ** power\n            for d in divisors:\n                new_divs.append(d * factor_power)\n        divisors += new_divs\n    divisors = list(set(divisors))\n    divisors.sort()\n    return divisors\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1365,
        "thoughts_token_count": 1023
    }
}