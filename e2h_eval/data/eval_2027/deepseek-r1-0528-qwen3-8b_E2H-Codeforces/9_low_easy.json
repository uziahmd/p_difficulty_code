{
    "start": 1758093944.2321048,
    "end": 1758095830.2238603,
    "start-formatted": "2025-09-17 16:25 KST",
    "end-formatted": "2025-09-17 16:57 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n The total weight m is up to 300000.\n\n Since the weights are only 1, 2, or 3, we can separate the souvenirs into three groups:\n   group1: weight 1, cost c1\n   group2: weight 2, cost c2\n   group3: weight 3, cost c3\n\n Then, we want to choose a nonnegative number x (from group1), y (from group2), z (from group3) such that:\n   x + 2y + 3z <= m\n   and the total cost = x * (max cost for one item from group1?) ... but note: we have multiple items and we can choose any subset.\n\n However, note: the items in each group are independent and we are allowed to take any number of items as long as the total weight constraint holds.\n\n But wait: we are not forced to take the same cost for each item. We can take different items with different costs.\n\n However, within a group, if we are going to use an item, we would prefer the one with higher cost. So we can preprocess:\n\n For each group i, we can sort the costs in descending order and then form an array where the j-th largest element is the best cost for taking j items from that group.\n\n But note: we are allowed to take any subset, so we might not take the top j items. However, because we are maximizing the total cost, we would always take the most expensive items first.\n\n Approach:\n\n Step 1: Separate the items into three lists: [w=1], [w=2], [w=3]\n\n Step 2: Sort each list in descending order.\n\n Step 3: Precompute prefix sums for each group:\n\n   Let A1[k] = sum of the top k items in group1 (for k from 1 to len(group1))\n   Similarly, A2[k] for group2, A3[k] for group3.\n\n Step 4: We need to consider combinations (x, y, z) such that x + 2y + 3z <= m.\n\n But note: n can be up to 100000, and m up to 300000. We cannot iterate over all x, y, z.\n\n Alternative approach:\n\n Since the weights are small (only 1,2,3) and the total weight is up to 300000, we can use dynamic programming with state (a, b, c) but that is too high-dimensional.\n\n Another idea: since the weights are small, we can consider iterating over the number of items taken from the heaviest group (group3) and then use two pointers or greedy for the remaining.\n\n However, note that the total weight is linear and we have three independent groups. We can do:\n\n   Let F(w) be the maximum total cost we can achieve with total weight exactly w? But m can be up to 300000, and we have three groups, so we can do:\n\n   But note: the problem is similar to unbounded knapsack but with bounded counts and small weights.\n\n Actually, we can use the following:\n\n   We note that the total weight is the sum of three components: x (from group1) which is the count of group1 items (each weight 1), y (count of group2, each weight 2) and z (count of group3, each weight 3).\n\n   We can fix z (the number of group3 items) from 0 to floor(m/3). Then the remaining weight is R = m - 3*z.\n\n   Now we need to choose x (from group1) and y (from group2) such that x + 2*y <= R.\n\n   How to combine group1 and group2 for a fixed R?\n\n   We can precompute for group1 and group2:\n\n     Let B[y] = maximum total cost from group2 when taking y items (from the sorted group2, we take the top y items). Similarly, we can precompute for group1.\n\n   Then, for a fixed R, we want to maximize:\n        x + 2*y <= R\n        and the total cost = (cost from group1 for x items) + (cost from group2 for y items)\n\n   But note: we can also take any combination of x and y as long as x+2*y<=R.\n\n   However, we have two independent sets. We can break it down:\n\n        Let T(y) = (max cost from group1 for up to (R - 2*y) items) + (max cost from group2 for y items)\n\n        Then we want max_{y=",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs are categorized by their weights, which can only be 1, 2, or 3. This allows us to break down the problem into handling three separate groups of items, each with their own weight and cost.\n\n### Approach\n1. **Categorize Items**: Separate the souvenirs into three groups based on their weights (1, 2, or 3).\n2. **Sort and Prefix Sums**: For each group, sort the items in descending order of their costs. Then, compute prefix sums for each group to quickly access the maximum cost achievable by selecting the top `k` items in that group.\n3. **Iterate Over Possible Combinations**: For each possible number of items taken from the heaviest group (group3), calculate the remaining weight capacity. Then, determine the optimal combination of items from the remaining two groups (group1 and group2) that fits within the remaining weight while maximizing the total cost.\n4. **Maximize Total Cost**: Use the prefix sums from the two lighter groups to efficiently compute the maximum cost for the remaining weight after selecting items from the heaviest group.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    group1 = []\n    group2 = []\n    group3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        elif w == 3:\n            group3.append(c)\n            \n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n    \n    len1 = len(group1)\n    len2 = len(group2)\n    len3 = len(group3)\n    \n    A1 = [0]*(len1+1)\n    for i in range(1, len1+1):\n        A1[i] = A1[i-1] + group1[i-1]\n        \n    A2 = [0]*(len2+1)\n    for i in range(1, len2+1):\n        A2[i] = A2[i-1] + group2[i-1]\n        \n    A3 = [0]*(len3+1)\n    for i in range(1, len3+1):\n        A3[i] = A3[i-1] + group3[i-1]\n        \n    best = 0\n    \n    max_z = min(len3, m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3*z\n        if rem < 0:\n            continue\n            \n        y_max = min(len2, rem // 2)\n        x_max = rem - 2*y_max\n        \n        if x_max > len1:\n            x_max = len1\n            \n        total_cost = A3[z] + A2[y_max] + A1[x_max]\n        if total_cost > best:\n            best = total_cost\n            \n        for y in range(y_max, -1, -1):\n            rem_y = rem - 2*y\n            if rem_y < 0:\n                continue\n            x_count = min(rem_y, len1)\n            total_cost = A3[z] + A2[y] + A1[x_count]\n            if total_cost > best:\n                best = total_cost\n                \n    print(best)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Categorization**: The input is read and items are separated into three groups based on their weights (1, 2, or 3).\n2. **Sorting and Prefix Sums**: Each group is sorted in descending order of cost, and prefix sums are computed to store the cumulative maximum cost achievable by selecting the top `k` items in each group.\n3. **Combination Calculation**: For each possible number of items from the heaviest group (group3), the remaining weight is calculated. The algorithm then checks all possible combinations of items from the lighter groups (group1 and group2) that fit within the remaining weight, using the precomputed prefix sums to quickly determine the maximum cost.\n4. **Result Determination**: The algorithm keeps track of the highest total cost encountered during the iteration over all possible combinations and prints this value as the result.\n\nThis approach efficiently narrows down the problem by leveraging the small weight values (1, 2, or 3) and uses sorting and prefix sums to handle large input sizes within feasible computational limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    group1 = []\n    group2 = []\n    group3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        elif w == 3:\n            group3.append(c)\n            \n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n    \n    len1 = len(group1)\n    len2 = len(group2)\n    len3 = len(group3)\n    \n    A1 = [0]*(len1+1)\n    for i in range(1, len1+1):\n        A1[i] = A1[i-1] + group1[i-1]\n        \n    A2 = [0]*(len2+1)\n    for i in range(1, len2+1):\n        A2[i] = A2[i-1] + group2[i-1]\n        \n    A3 = [0]*(len3+1)\n    for i in range(1, len3+1):\n        A3[i] = A3[i-1] + group3[i-1]\n        \n    best = 0\n    \n    max_z = min(len3, m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3*z\n        if rem < 0:\n            continue\n            \n        y_max = min(len2, rem // 2)\n        x_max = rem - 2*y_max\n        \n        if x_max > len1:\n            x_max = len1\n            \n        total_cost = A3[z] + A2[y_max] + A1[x_max]\n        if total_cost > best:\n            best = total_cost\n            \n        for y in range(y_max, -1, -1):\n            rem_y = rem - 2*y\n            if rem_y < 0:\n                continue\n            x_count = min(rem_y, len1)\n            total_cost = A3[z] + A2[y] + A1[x_count]\n            if total_cost > best:\n                best = total_cost\n                \n    print(best)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 476,
        "completion_token_count": 1028,
        "thoughts_token_count": 1023
    }
}