{
    "start": 1758304486.4041193,
    "end": 1758308411.1795056,
    "start-formatted": "2025-09-20 02:54 KST",
    "end-formatted": "2025-09-20 04:00 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given n, m and then m lines each with four numbers: a, b, gcd, lcm (the two lawns and the gcd and lcm for that edge)\n\n We know: \n   For an edge between u and v with given gcd = g and lcm = l, we must have:\n     g = gcd(x_u, x_v) and l = lcm(x_u, x_v)\n\n Also note the identity: for any two positive integers a and b, we have \n     a * b = gcd(a,b) * lcm(a,b)\n\n So for edge (u, v): \n     x_u * x_v = g * l\n\n Moreover, note that the gcd must divide both numbers and the lcm must be divisible by both.\n\n Approach:\n\n 1. Check consistency of the input: \n      - The gcd must divide the lcm (because g divides x_u and x_v, and hence divides any multiple of either, so divides the lcm). \n        Actually, from the identity: x_u and x_v must be divisors of g*l. And note that g divides g*l, and also the lcm must be divisible by g.\n\n      - Also, for an edge (u, v): the gcd must divide both x_u and x_v, and the lcm must be the least common multiple.\n\n 2. We can think of assigning a value to each node. However, note that the entire graph might not be connected.\n\n Steps:\n\n We are going to use the following idea:\n\n   Let the number at node i be x_i.\n\n   For each edge (u, v) with gcd g and lcm l, we know:\n        x_u * x_v = g * l.\n\n   Also, we know that g must divide both x_u and x_v.\n\n   Therefore, we can set up:\n\n        Let d_i = the product of all the prime factors that appear in any edge incident to node i? \n\n   Alternatively, note:\n\n        Since x_u * x_v = g * l, and g is the gcd, then we can write:\n\n        Let x_u = g * a, x_v = g * b, then we must have gcd(a, b) = 1, and the lcm would be g * a * b (since gcd(a,b)=1).\n\n        Then: g * a * b = l  => a * b = l / g.\n\n        Therefore, we require that l % g == 0.\n\n   So first, for every edge, check if l % g != 0 -> then output \"NO\".\n\n   Now, if we have an edge (u, v) with gcd g and lcm l, then the two numbers at u and v must be multiples of g, and their ratio must multiply to l/g.\n\n   But note: the same node may appear in multiple edges. So we need to assign a value to each node such that for every edge (u, v) with gcd g and lcm l:\n\n        Let x_u = g * a, x_v = g * b, and then a and b must be coprime and a*b = (l // g).\n\n   However, we cannot independently assign a for each node because the same node must satisfy all its edges.\n\n   Alternate approach:\n\n   We can set the value for a node as the product of some base factors. But note: the entire graph might have multiple connected components.\n\n   Let's consider:\n\n        For each edge (u, v): \n            x_u * x_v = g * l   ... (1)\n\n        And we know that the gcd is g, so the common factors of x_u and x_v must be exactly g. This implies that the part of x_u and x_v that is not g must be coprime.\n\n        How about we factorize g and l? But note that the numbers can be up to 10^6 and we have up to 10^5 edges? Maybe too heavy.\n\n   Another idea:\n\n        We can assign a base value for each node. Notice that if we fix a node, we can express all other nodes connected to it in terms of that node.\n\n        However, we have constraints that are multiplicative and also divisibility.\n\n   Insight:\n\n        Consider that the entire graph's values must satisfy:\n\n            For edge (u, v): \n                x_u * x_v = g * l.\n\n        Also, for two edges sharing a node, say:\n\n            Edge1: (u, v) -> x_u * x_v = g1 * l1\n            Edge2: (u, w) -> x_u * x_w = g2 * l2\n\n        Then, from these two, we can get:\n\n            x_v = (g1 * l1) / x_u\n            x_w = (g2 * l2) / x_u\n\n        But then we must ensure that the gcd(x_u, x_v) = g1 and gcd(x_u, x_w)=g2, and also gcd(x_v, x_w)=gcd((g1*l1)/x_u, (g2*l2)/x_u) must equal the gcd given for the edge (v, w) if exists.\n\n   However, we don't know x_u. But note: the value of x_u must be such that it divides both (g1*l1) and (g2*l2). \n\n   Alternatively, we can try to assign a value to one node arbitrarily? But wait, the problem says the original numbers were at least 1 and at most 10^6.\n\n   But note: the product x_u * x_v = g * l, so if we let x_u be a divisor of g*l, then we can set x_u = d, and then x_v = (g*l)//d.\n\n   However, we have multiple edges. So we need to assign one value for each node.\n\n   We can do:\n\n        Step 1: Build the graph.\n\n        Step 2: For each edge, we know the product of the two nodes must be g*l. But also, the gcd condition must hold.\n\n        Let's denote by d[i] the value assigned to node i.\n\n        Constraints for an edge (u, v): \n            d[u] * d[v] = g * l, and \n            gcd(d[u], d[v]) = g.\n\n        Since d[u] and d[v] must be multiples of g, we can set:\n\n            d[u] = g * a, d[v] = g * b, then a and b are coprime and a*b = (g*l) // (g*g) = l // g.\n\n        So the condition is equivalent to: \n            d[u] * d[v] = g * l, and the gcd(d[u], d[v]) = g.\n\n        But note: if we set d[u] and d[v] as above, then the gcd condition is automatically satisfied if a and b are coprime.\n\n        However, we have to assign d[u] consistently across edges.\n\n   We can use the following:\n\n        Let's choose an arbitrary node (say node 0) and set d[0] = g0 (from one edge incident to it?) but wait, we don't know which edge to use.\n\n   Actually, we can set:\n\n        Let d[u] = (some divisor of (g*l)) but that might be too many.\n\n   Alternatively, we can use the following method:\n\n        For each node, we can keep track of the product of the base g (but note: different edges might have different g). \n\n   However, note: the entire graph must be consistent. The key is to notice that the value at a node must be the same no matter which edge we use.\n\n   Steps:\n\n        We can use BFS/DFS to propagate the value.\n\n        Let's define:\n\n            For node u, we will store a candidate value d[u]. Initially, we don't know.\n\n        We start by fixing one node. But which one? We can pick a node and set it to a value that is compatible with one of its edges.\n\n        However, note: the value must be a divisor of the product of the edge? Actually, from an edge (u, v): \n            d[u] * d[v] = g * l.\n\n        We can set d[u] = g * a, where a is a divisor of (l//g) and then d[v] = (l//g) // a (if we set a from the equation). But we don't know a.\n\n        Alternatively, we can set the entire system relative to a base.\n\n        Idea: Factorize the gcd and lcm for each edge. But that might be heavy.\n\n   Another known fact:\n\n        In the entire graph, the value at a node must be the same for all paths. \n\n        How about we compute the value of each node as the product of the base primes raised to exponents? \n\n        But note: the condition for an edge is multiplicative and divisibility.\n\n   Let me consider a simpler way:\n\n        For each edge, we know that the two numbers must be divisors of the product (g*l) and they must multiply to g*l.\n\n        Moreover, the gcd condition: the gcd of the two numbers is g. \n\n        Now, consider two edges sharing a node: \n\n            Edge1: (u, v): g1, l1 -> d[u] * d[v] = g1 * l1, and gcd(d[u], d[v]) = g1.\n            Edge2: (u, w): g2, l2 -> d[u] * d[w] = g2 * l2, and gcd(d[u], d[w]) = g2.\n\n        Then, from these two, we can express d[v] and d[w] in terms of d[u]:\n\n            d[v] = (g1 * l1) / d[u]\n            d[w] = (g2 * l2) / d[u]\n\n        Then the gcd condition for the two edges must hold for d[u] and the respective d[v] and d[w].\n\n        Additionally, if there is an edge between v and w, then we have a third equation: gcd(d[v], d[w]) = g3, and d[v]*d[w]=g3*l3.\n\n        We can set d[u] as a common divisor of (g1*l1) and (g2*l2). But note: d[u] must divide both g1*l1 and g2*l2.\n\n        However, we are free to choose d[u] as long as it divides both products and the gcd conditions hold.\n\n        But note: the value d[u] must be a divisor of the product of all edges? \n\n   However, the problem does not require a unique solution, only one.\n\n   Proposed algorithm:\n\n        Step 1: Check for each edge that l % g == 0. If not, output \"NO\".\n\n        Step 2: We'll build an undirected graph.\n\n        Step 3: We'll use a dictionary to store for each node, the candidate value. Initially, we don't have any candidate.\n\n        Step 4: We can start from a node and set its value arbitrarily? But what value?\n\n        Actually, we can set the value of a node by an edge: from an edge (u, v) we know d[u] * d[v] = g*u*v. But we don't know the individual values.\n\n        Alternatively, we can set:\n\n            Let d[u] = g * k, and then d[v] = (g * l) / (g * k) = l / k.\n\n        But then we must have that k divides l (since d[v] must be integer). Also, from the gcd condition, we have that gcd(k, l/k) must be 1.\n\n        However, we don't know k.\n\n        But note: the same node u might be connected to another node w via a different edge (u, w) with gcd g' and lcm l'. Then:\n\n            d[u] * d[w] = g' * l'\n            => g*k * d[w] = g'*l'\n\n            => d[w] = (g'*l')/(g*k)\n\n        And this must be an integer and the gcd condition must hold.\n\n        We can set k as the product of the \"coprime parts\" from each edge. But note: the coprime part for edge (u, v) is k (which must be a divisor of l/g) and must be coprime with l/(k*g).\n\n        This seems complicated.\n\n   Another idea: use the fact that the entire graph must satisfy the multiplicative condition and the gcd condition.\n\n   We can assign the value for each node as the product of the gcds of all edges incident to that node? Not necessarily.\n\n   Known trick in problems like this: \n\n        In a graph, if we have edges with conditions on the product, we can take logarithms and turn into linear equations? But then we have integer constraints.\n\n   Alternatively, we can use the following:\n\n        For each node, we can keep a set (or a multiset) of prime factors that are forced by the edges.\n\n        However, note the constraints: the numbers are up to 10^6, and the graph has up to 10^5 edges, but the nodes are up to 10^5.\n\n   After reading the problem statement again, note that the original numbers were at least 1 and at most 10^6. So we can assign values in the range [1, 10^6].\n\n   We can try to assign the value for a node as follows:\n\n        We know that for an edge (u, v): \n            d[u] * d[v] = g * l.\n\n        And d[u] must be divisible by the gcd of all edges incident to u? Actually, for each edge incident to u, the gcd for that edge must divide d[u]. \n\n        But note: the gcd for an edge is the gcd of the two adjacent nodes. So d[u] must be divisible by the gcd from every edge incident to u? \n\n        Actually, no: the gcd for an edge (u, v) is the gcd of d[u] and d[v]. So d[u] must be divisible by the gcd of the edge (u, v) and similarly for d[v]. However, the same node u appears in multiple edges and the gcd for each edge must divide d[u]. Therefore, d[u] must be divisible by the least common multiple (LCM) of all the gcds of the edges incident to u? Not exactly: the gcd for each edge must divide d[u]. But note: the gcd for an edge is the gcd of two numbers, so it doesn't have to divide the other edges' gcds. However, we have to satisfy all edges.\n\n        Actually, d[u] must be divisible by the gcd from every edge it is incident to. Therefore, d[u] must be divisible by the LCM of all the gcds of the edges incident to u? \n\n        Let me test: \n            Suppose node u is connected to v and w.\n            Edge (u, v): gcd = g1, so d[u] must be divisible by g1.\n            Edge (u, w): gcd = g2, so d[u] must be divisible by g2.\n            Then d[u] must be divisible by LCM(g1, g2)? \n\n        Example: \n            g1 = 2, g2 = 3 -> then d[u] must be divisible by 6.\n\n        However, consider: \n            d[u] = 6, then for edge (u, v): we require that gcd(6, d[v]) = 2. Then d[v] must be even (divisible by 2) and 6 and d[v] should have no common factor beyond 2. Similarly, for edge (u, w): gcd(6, d[w])=3, so d[w] must be divisible by 3 and 6 and d[w] should have no common factor beyond 3.\n\n        But wait, is 6 divisible by LCM(2,3)=6? Yes.\n\n        However, the condition for the edge (u, v) is: \n            d[u] * d[v] = g1 * l1 = 2 * l1.\n\n        So d[v] = (2 * l1) / 6 = l1 / 3.\n\n        Then we require that l1 is divisible by 3, and then d[v] = l1/3.\n\n        Then we must have gcd(6, l1/3) = 2.\n\n        Similarly, for edge (u, w): d[w] = (3 * l2) / 6 = l2/2, and gcd(6, l2/2)=3.\n\n        So the idea is:\n\n            For node u, let G[u] = LCM of all gcds of edges incident to u.\n\n            Then d[u] must be divisible by G[u].\n\n            Now, for an edge (u, v) with gcd g and lcm l, we have:\n\n                d[u] * d[v] = g * l.\n\n            And since d[u] is divisible by G[u] (which includes g, because g is one of the gcds incident to u) and similarly d[v] is divisible by G[v] (which includes g, because g is one of the gcds incident to v), then:\n\n                d[u] >= G[u], d[v] >= G[v]\n\n            Then, the product d[u]*d[v] must be at least G[u] * G[v]. \n\n            But note: g * l = d[u]*d[v] must be divisible by G[u]*G[v] (since d[u] is divisible by G[u] and d[v] by G[v]). \n\n            However, we also have the condition that the gcd(d[u], d[v]) = g.\n\n        We can set:\n\n            Let d[u] = G[u] * k, and d[v] = (g * l) / (G[u] * k)\n\n            Then, we require that (g * l) is divisible by G[u] (because d[u] is divisible by G[u]), and similarly (g * l) must be divisible by G[v] (from the other side). \n\n            But wait, we already know that g divides (g*l) and G[u] is a multiple of g (because G[u] is the LCM of the gcds and g is one of them), so G[u] is divisible by g. Then (g*l) / G[u] is an integer? Not necessarily: because G[u] might have factors that are not in g*l.\n\n        Example: \n            Suppose an edge (u, v): g=2, l=8, then g*l=16.\n            Now, if node u is also incident to another edge with gcd=4, then G[u] = LCM(2,4)=4.\n            Then d[u] must be divisible by 4. Then d[u] = 4*k, and d[v] = 16/(4*k)=4/k.\n\n            Then k must divide 4. And d[v] must be integer, so k must be a divisor of 4.\n\n            Then, the gcd condition: gcd(4*k, 4/k) = 2.\n\n            Let k=1: then d[u]=4, d[v]=4 -> gcd(4,4)=4 -> not 2.\n            k=2: d[u]=8, d[v]=2 -> gcd(8,2)=2 -> works.\n\n            Then we set d[u]=8, d[v]=2.\n\n            But note: the LCM for the edge (u, v) is lcm(8,2)=8, which matches.\n\n        So the steps:\n\n            Step 1: Precompute for each node u, the LCM of all gcds of edges incident to u. Let this be G[u].\n\n            Step 2: For each edge (u, v) with gcd g and lcm l, we require that (g * l) is divisible by G[u] and by G[v]. (Because d[u] is divisible by G[u] and d[v] by G[v], and d[u]*d[v]=g*l, so g*l must be divisible by G[u] and by G[v].) \n\n            Step 3: Then, we can set d[u] = G[u] * k, and d[v] = (g*l) / (G[u] * k). But note: the same node u must have the same k for all edges? \n\n            Actually, we want to set d[u] once. We can set d[u] = G[u] * k, but what k? \n\n            We can set k=1 for all nodes? Then d[u] = G[u] and d[v] = (g*l) / G[u]. Then we must check the gcd condition for the edge (u, v): \n\n                gcd(G[u], (g*l)/G[u]) must equal g.\n\n            But is that always true? \n\n            Example: \n                Edge (u, v): g=2, l=8 -> g*l=16.\n                G[u] = 4 (from above) -> d[u]=4, d[v]=4 -> gcd(4,4)=4 != 2 -> fails.\n\n            So we cannot set k=1.\n\n        How about setting k such that the gcd condition holds?\n\n            Condition: gcd(d[u], d[v]) = g.\n\n            d[u] = G[u] * k, d[v] = (g*l) / (G[u]*k)\n\n            Then, gcd(G[u]*k, (g*l)/(G[u]*k)) = g.\n\n            Note: G[u] is a multiple of g (since G[u] is the LCM of the gcds and one of them is g). Let G[u] = g * a.\n\n            Then d[u] = g*a*k, and d[v] = (g*l) / (g*a*k) = (l) / (a*k)\n\n            Then gcd(g*a*k, l/(a*k)) = g * gcd(a*k, l/(a*k)) / gcd(a*k, ...) ??? \n\n            Actually, we can break down:\n\n                gcd(g*a*k, l/(a*k)) = g * gcd(a*k, l/(a*k))   [provided that a*k divides l]\n\n            But note: we require that a*k divides l, because d[v] must be integer.\n\n            Then, the condition becomes: gcd(a*k, l/(a*k)) = 1.\n\n            Because if we let d1 = a*k and d2 = l/(a*k), then we require gcd(d1, d2)=1.\n\n            Now, note that from the edge (u, v): \n                l is the lcm of d[u] and d[v] = lcm(g*a*k, l/(a*k)) = (g*a*k * l/(a*k)) / gcd(g*a*k, l/(a*k)) = (g*l) / g = l, which is correct.\n\n            So the condition is that a*k and l/(a*k) are coprime.\n\n            But note: a = G[u] / g. And G[u] is the LCM of all gcds incident to u, so a is an integer.\n\n            Then we need to choose k such that:\n\n                (a*k) divides l, and \n                gcd(a*k, l/(a*k)) = 1.\n\n            Also, note that the same node u must have the same k for all edges? \n\n            Actually, we are trying to set d[u] = G[u] * k. Then for every edge (u, v) we have:\n\n                d[u] = G[u] * k, and d[v] = (g*l) / (G[u]*k) = (g*l) / (g*a*k) = (l) / (a*k)\n\n            But then the same d[u] must be used for all edges incident to u.\n\n        Therefore, we must choose k such that for every edge (u, v):\n\n            (a*k) divides l (for that edge) and gcd(a*k, l/(a*k)) = 1.\n\n        However, note that a = G[u]/g, and g is the gcd of that edge. But different edges incident to u have different g, so a changes per edge? \n\n        Actually, no: a = G[u] / g, and G[u] is fixed for node u (the LCM of all incident gcds). But note: for an edge (u, v) we use g = gcd(u,v). Then a = G[u] / g. But if the same node u is incident to multiple edges, then the value of a depends on the edge.\n\n        This complicates things.\n\n   Let me reframe:\n\n        We have:\n\n            d[u] = (value) must be divisible by G[u] (the LCM of all gcds incident to u).\n\n            For an edge (u, v) with gcd g and lcm l:\n\n                d[u] * d[v] = g * l.\n\n                and gcd(d[u], d[v]) = g.\n\n            Write d[u] = G[u] * k_u, then d[v] = (g * l) / (G[u] * k_u)\n\n            But then the same node u must have the same k_u for all edges? \n\n            However, if we use the same k_u for all edges, then for two edges (u, v) and (u, w):\n\n                d[u] = G[u] * k_u\n\n                d[v] = (g1 * l1) / (G[u] * k_u)\n                d[w] = (g2 * l2) / (G[u] * k_u)\n\n            Then we require that k_u divides both (g1*l1) and (g2*l2). \n\n        But note: G[u] is the LCM of the gcds (each gcd is g1, g2, ...). Then k_u must be chosen so that d[u] is the same for all edges.\n\n        Now, the condition for the edge (u, v) is:\n\n            gcd(G[u]*k_u, (g*l)/(G[u]*k_u)) = g.\n\n            As above, let a = G[u] / g (this a is fixed for this edge? Actually, no: for this edge, g is fixed, but G[u] is fixed for the node, so a = G[u] / g is fixed for this edge).\n\n            Then, we require that (G[u]*k_u) divides (g*l) (so that d[v] is integer) and that:\n\n                gcd(G[u]*k_u, (g*l)/(G[u]*k_u)) = g.\n\n            We can factor out g: \n\n                Let d1 = G[u]*k_u = (g * a) * k_u = g*(a*k_u)\n                Let d2 = (g*l) / (g*a*k_u) = l/(a*k_u)\n\n                Then gcd(d1, d2) = g * gcd(a*k_u, l/(a*k_u)) = g   =>  gcd(a*k_u, l/(a*k_u)) = 1.\n\n        Therefore, for each edge (u, v), we require:\n\n            Condition 1: (G[u] * k_u) divides (g*l)   [which means a*k_u divides l, because g*l / (G[u]*k_u) = l/(a*k_u) must be integer]\n\n            Condition 2: gcd(a*k_u, l/(a*k_u)) = 1.\n\n        But note: the same k_u is used for all edges incident to u.\n\n        How to choose k_u? \n\n            We require that for every edge (u, v) incident to u:\n\n                k_u divides (l / a)   [where a = G[u] / g, and g is the gcd of that edge]\n\n            Since a = G[u]/g, then l / a = l * g / G[u].\n\n            But note: we also have the global condition that k_u must be chosen such that the value d[u] = G[u] * k_u is within [1, 10^6] (as per the problem, the original numbers did not exceed 10^6).\n\n        Alternatively, we can set k_u = 1. Then:\n\n            Condition 1: a divides l (i.e., (G[u]/g) divides l) -> which is required because d[v] = l/(a) must be integer.\n\n            Condition 2: gcd(a, l/a) = 1.\n\n        But wait, in our example above: \n            Edge (u, v): g=2, l=8, G[u]=4 -> a = 4/2=2, then Condition1: 2 divides 8 -> yes. Condition2: gcd(2,8/2)=gcd(2,4)=2 -> not 1 -> fails.\n\n        So k_u=1 does not work.\n\n        Then, what if we set k_u to a divisor of l/(a) that is coprime to l/(a)? \n\n            We require that k_u divides (l/(a)) and that gcd(k_u, l/(a))=1.\n\n            Then, Condition1: a*k_u divides l? Actually, Condition1 requires that a*k_u divides l. But we have k_u divides (l/a) (because l/(a*k_u) must be integer). Then Condition1 is automatically satisfied.\n\n            Condition2: gcd(a*k_u, l/(a*k_u)) = gcd(a*k_u, (l/a)/k_u) = ? \n\n            We know that k_u and (l/a) are coprime (by choice). But we also require that a and (l/a) are coprime? \n\n            Actually, note: the entire number l must be factored. And a = G[u]/g. \n\n        Alternatively, we can choose k_u = 1, but then the condition fails. So we must choose a k_u that is coprime to l/(a) and such that a*k_u divides l.\n\n        But note: if we choose k_u=1 and the condition fails, then we try k_u being a divisor of l/(a) that is coprime to l/(a). However, the condition gcd(a*k_u, l/(a*k_u)) = 1 is equivalent to: \n            gcd(a, l/(a*k_u)) = 1 and gcd(k_u, l/(a*k_u)) = 1.\n\n        But we chose k_u to be coprime to (l/a), and note that l/(a*k_u) = (l/a)/k_u. Then:\n\n            gcd(k_u, (l/a)/k_u) = 1 (because k_u and (l/a) are coprime, and (l/a)/k_u is an integer).\n\n            Now, we also need gcd(a, (l/a)/k_u)=1.\n\n        So we require that a and (l/a)/k_u are coprime.\n\n        However, note: a = G[u]/g, and l is given. This seems complex.\n\n   Given the complexity, maybe we should try a different approach.\n\n   Let me consider starting from one node and propagating the value.\n\n        Step 1: For each edge, check that l % g == 0. If not, \"NO\".\n\n        Step 2: Build the graph.\n\n        Step 3: For each node, we will store the current value (initially 1 or None). We'll use a queue/stack.\n\n        Step 4: Choose a node (say node 0) and set its value to a candidate. But what candidate?\n\n        Note: the value of a node must be divisible by the gcd of every edge incident to it. \n\n        Let g_min[u] = the minimum gcd among edges incident to u? Not necessarily.\n\n        Actually, the value must be divisible by the LCM of the gcds of the edges. Let G[u] be defined as above.\n\n        Then, we can set d[u] = G[u] (with k=1) and then for each edge (u, v) we set d[v] = (g * l) / d[u]. But then we must check that d[v] is divisible by G[v] and that the gcd(d[u],d[v])=g.\n\n        However, if that fails, we can try to multiply d[u] by some factor? \n\n        But note: d[u] must be divisible by G[u], and then d[v] is determined. \n\n        Alternatively, we can set d[u] = G[u] * k, and then d[v] = (g*l) / (G[u]*k). Then we require that (g*l) is divisible by G[u] and by G[v] (from symmetry). \n\n        Then, we can set k to be 1 initially, and then if the gcd condition fails, we might need to adjust k. But note: the same k is used for all edges.\n\n   Another idea: \n\n        We know that for an edge (u, v): \n            d[u] = g * a, d[v] = g * b, with a and b coprime and a*b = (l//g).\n\n        Then, the value d[u] must be divisible by g, and d[v] by g.\n\n        Moreover, the entire graph must be consistent.\n\n        We can set the value for a node as the product of the gcds of the edges incident to it raised to some power? Not exactly.\n\n   After some thought, there is a known solution for this type of problem:\n\n        We can use the following:\n\n            Let d[u] = the product of the gcds of all edges incident to u, but then adjust by the coprime part? \n\n        Actually, there is a standard way:\n\n            In a tree, we can assign arbitrarily one node a value = g (from one edge) and then set the adjacent node to (g*l)/g = l. But then we must check the gcd condition.\n\n        However, we have a graph that might not be a tree.\n\n   Let me read the example inputs:\n\n        Example 1: \"1 0\" -> n=1, m=0 -> output \"YES\\n1\"\n\n        Example 2: \"2 1\\n1 2 1 3\" -> \n            n=2, m=1, edge: between 1 and 2, gcd=1, lcm=3.\n            Then d1 * d2 = 1*3 = 3.\n            And gcd(d1,d2)=1.\n            Possibilities: (1,3) -> gcd(1,3)=1 -> works.\n\n        Example 3: \"3 2\\n3 2\\n3 2 1 2\\n3 1 1 10\"\n            This means: \n                n=3, m=2\n                Edge1: 3 2 -> wait, the input format: \n                    Each line: lawn1, lawn2, gcd, lcm.\n                The example input is given as:\n                    '3 2\\n3 2 1 2\\n3 1 1 10'\n\n                Actually, the sample input format in the problem is:\n\n                    Input:\n                        ['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n                So the third example is:\n\n                    n=3, m=2\n                    First edge: connects lawn3 and lawn2, with gcd=1, lcm=2.\n                    Second edge: connects lawn3 and lawn1, with gcd=1, lcm=10.\n\n                Then, for edge1: d3*d2 = 1*2 = 2, and gcd(d3,d2)=1.\n                For edge2: d3*d1 = 1*10=10, and gcd(d3,d1)=1.\n\n                Possibilities: \n                    From edge1: possibilities for (d3, d2): (1,2) or (2,1).\n                    From edge2: possibilities for (d3, d1): (1,10), (2,5), (5,2), (10,1).\n\n                We must have d3 being either 1,2,5,10.\n\n                But from edge1, d3 can be 1 or 2.\n\n                If d3=1, then d2=2, d1=10 -> then check edge1: gcd(1,2)=1 -> ok, edge2: gcd(1,10)=1 -> ok.\n                If d3=2, then d2=1, d1=5 -> then edge1: gcd(2,1)=1 -> ok, edge2: gcd(2,5)=1 -> ok.\n\n                The example output is \"YES\\n5 1 2\" -> meaning d1=5, d2=1, d3=2.\n\n        So we can do:\n\n            We'll assign an initial value to a node arbitrarily, but then we must ensure consistency.\n\n        Steps for a BFS-like assignment:\n\n            Let's assume we have a graph. We'll start from node 0 (index 0) and set d[0] = some value.\n\n            But what value? We know that for an edge (0, v) with gcd=g0, lcm=l0, then d[0] * d[v] = g0 * l0.\n\n            And d[0] must be divisible by the gcd of all edges incident to 0. Let G[0] = LCM of all g_i for edges incident to 0.\n\n            Then d[0] must be divisible by G[0]. \n\n            We can set d[0] = G[0] * k0, but then we don't know k0.\n\n        Alternatively, we can set d[0] = the product of the gcds of the edges incident to 0? Not necessarily.\n\n   Given the time, I propose the following simpler method:\n\n        Step 1: Check for each edge: if lcm % gcd != 0, return \"NO\".\n\n        Step 2: For each node, let base[u] = the LCM of all gcds of edges incident to u. If there are no edges, base[u]=1.\n\n        Step 3: For each edge (u, v) with gcd=g and lcm=l, we require",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a graph based on given edges, where each edge provides the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying the consistency of the given GCD and LCM values across all edges and assigning mushroom counts that satisfy these conditions.\n\n### Approach\n1. **Initial Checks**: For each edge, verify that the LCM is divisible by the GCD. If not, it's impossible to satisfy the conditions, and we return \"NO\".\n2. **Graph Construction**: Build an adjacency list for the graph where each edge stores its GCD and LCM.\n3. **Base Value Calculation**: For each node, compute the base value as the least common multiple (LCM) of all GCDs of edges incident to it. This base value ensures that the node's mushroom count is divisible by all relevant GCDs.\n4. **Consistency Check**: For each edge, ensure that the product of the base values of the two nodes matches the product of the edge's GCD and LCM. If not, return \"NO\".\n5. **Mushroom Count Assignment**: Assign mushroom counts to nodes using their base values and adjust them to meet the GCD and LCM conditions for all edges. If adjustments are needed, propagate changes through the graph to maintain consistency.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\nfrom collections import defaultdict, deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"YES\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g_val = int(next(it))\n        l_val = int(next(it))\n        edges.append((u, v, g_val, l_val))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n    \n    for (u, v, g_val, l_val) in edges:\n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n            \n    base = [1] * n\n    for i in range(n):\n        g_list = []\n        for (v, g_val, l_val) in graph[i]:\n            g_list.append(g_val)\n        if g_list:\n            base[i] = reduce(lambda a, b: (a * b) // gcd(a, b), g_list)\n        else:\n            base[i] = 1\n            \n    for (u, v, g_val, l_val) in edges:\n        if (base[u] * base[v]) != (g_val * l_val):\n            print(\"NO\")\n            return\n            \n    d = [1] * n\n    q = deque()\n    for i in range(n):\n        if len(graph[i]) > 0:\n            d[i] = base[i]\n            q.append(i)\n            \n    changed = [False] * n\n    while q:\n        u = q.popleft()\n        for (v, g_val, l_val) in graph[u]:\n            if changed[v]:\n                continue\n            prod_uv = g_val * l_val\n            d_v = prod_uv // d[u]\n            if d[v] != d_v:\n                d[v] = d_v\n                changed[v] = True\n                q.append(v)\n                \n    for i in range(n):\n        if changed[i]:\n            for (u, g_val, l_val) in graph[i]:\n                if changed[u]:\n                    continue\n                    prod_ui = g_val * l_val\n                    d_u = prod_ui // d[i]\n                    if d[u] != d_u:\n                        d[u] = d_u\n                        changed[u] = True\n                        q.append(u)\n                        \n    for i in range(n):\n        if changed[i]:\n            for (u, g_val, l_val) in graph[i]:\n                if changed[u]:\n                    continue\n                    prod_ui = g_val * l_val\n                    d_u = prod_ui // d[i]\n                    if d[u] != d_u:\n                        d[u] = d_u\n                        changed[u] = True\n                        q.append(u)\n                        \n    for i in range(n):\n        if d[i] < 1 or d[i] > 1000000:\n            print(\"NO\")\n            return\n            \n    for (u, v, g_val, l_val) in edges:\n        if gcd(d[u], d[v]) != g_val or (d[u] * d[v]) != (g_val * l_val):\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(\" \".join(map(str, d)))\n    \nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Initial Checks**: The code first checks if the LCM for any edge is divisible by its GCD. If not, it immediately outputs \"NO\".\n2. **Graph Construction**: The graph is built using an adjacency list where each entry stores connected nodes along with their respective GCD and LCM values.\n3. **Base Value Calculation**: For each node, the base value is computed as the LCM of all GCDs from its incident edges. This ensures the node's mushroom count will be divisible by all relevant GCDs.\n4. **Consistency Check**: The code verifies that the product of the base values of connected nodes matches the product of the edge's GCD and LCM. If not, it outputs \"NO\".\n5. **Mushroom Count Assignment**: Using a BFS approach, the code assigns mushroom counts to nodes, ensuring all edges' GCD and LCM conditions are met. If any node's assigned count is out of bounds (1 to 10^6), it outputs \"NO\".\n6. **Final Verification**: The solution checks all edges to ensure the assigned mushroom counts meet the GCD and LCM conditions. If all checks pass, it prints \"YES\" followed by the mushroom counts for each lawn.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\nfrom functools import reduce\nfrom collections import defaultdict, deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"YES\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g_val = int(next(it))\n        l_val = int(next(it))\n        edges.append((u, v, g_val, l_val))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n    \n    for (u, v, g_val, l_val) in edges:\n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n            \n    base = [1] * n\n    for i in range(n):\n        g_list = []\n        for (v, g_val, l_val) in graph[i]:\n            g_list.append(g_val)\n        if g_list:\n            base[i] = reduce(lambda a, b: (a * b) // gcd(a, b), g_list)\n        else:\n            base[i] = 1\n            \n    for (u, v, g_val, l_val) in edges:\n        if (base[u] * base[v]) != (g_val * l_val):\n            print(\"NO\")\n            return\n            \n    d = [1] * n\n    q = deque()\n    for i in range(n):\n        if len(graph[i]) > 0:\n            d[i] = base[i]\n            q.append(i)\n            \n    changed = [False] * n\n    while q:\n        u = q.popleft()\n        for (v, g_val, l_val) in graph[u]:\n            if changed[v]:\n                continue\n            prod_uv = g_val * l_val\n            d_v = prod_uv // d[u]\n            if d[v] != d_v:\n                d[v] = d_v\n                changed[v] = True\n                q.append(v)\n                \n    for i in range(n):\n        if changed[i]:\n            for (u, g_val, l_val) in graph[i]:\n                if changed[u]:\n                    continue\n                    prod_ui = g_val * l_val\n                    d_u = prod_ui // d[i]\n                    if d[u] != d_u:\n                        d[u] = d_u\n                        changed[u] = True\n                        q.append(u)\n                        \n    for i in range(n):\n        if changed[i]:\n            for (u, g_val, l_val) in graph[i]:\n                if changed[u]:\n                    continue\n                    prod_ui = g_val * l_val\n                    d_u = prod_ui // d[i]\n                    if d[u] != d_u:\n                        d[u] = d_u\n                        changed[u] = True\n                        q.append(u)\n                        \n    for i in range(n):\n        if d[i] < 1 or d[i] > 1000000:\n            print(\"NO\")\n            return\n            \n    for (u, v, g_val, l_val) in edges:\n        if gcd(d[u], d[v]) != g_val or (d[u] * d[v]) != (g_val * l_val):\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(\" \".join(map(str, d)))\n    \nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1325,
        "thoughts_token_count": 8191
    }
}