{
    "start": 1758294378.2419596,
    "end": 1758296554.839133,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:42 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers R and B (each between 1 and 10) so we can use combinatorial methods.\n\n The problem is to check if there exists a perfect matching (i.e., a bijection) between R rebels (spaceships) and B bases such that:\n   - Each base gets one spaceship and each spaceship gets one base.\n   - The straight lines connecting the base to its assigned spaceship do not intersect (except at endpoints).\n\n However, note: The example input has two test cases. The first one has R=3, B=3 and the second has R=2, B=1.\n\n But wait: the problem says \"assign R Rebel spaceships to guard B bases\" and \"every base has exactly one guardian and each spaceship has exactly one assigned base\". This implies that we require a perfect matching from R to B, but note: if R != B then there is no perfect matching. Actually, the problem states: \"the assignment is a perfect matching\", so R must equal B? \n\n Let me read again: \"every base has exactly one guardian and each spaceship has exactly one assigned base\". This means that the number of bases must equal the number of spaceships. So if R != B, then it's impossible.\n\n However, looking at the example input: \n   Input: \"2 1\\n1 0\\n2 2\\n3 1\"\n   Output: \"No\"\n\n In this case, R=2, B=1. Since 2 != 1, there's no way to assign two spaceships to one base (each base must have one and each spaceship must have one). So indeed, we must have R == B for a perfect matching.\n\n But wait: the problem says \"assign R Rebel spaceships to guard B bases\" and then the condition is that every base has exactly one guardian. That implies that if R != B, then we cannot have a bijection. Therefore, the first condition is that R == B.\n\n However, the problem statement says: \"It is guaranteed that no two points coincide and that no three points are on the same line.\"\n\n Steps:\n\n 1. If R != B, output 'No'.\n\n 2. If R == B, then we have a set of R+B points (R spaceships and B bases). We need to assign each base to one spaceship and vice versa such that the straight lines (from base to spaceship) do not cross.\n\n Important: The condition is that any two (straight) paths (from a base to its assigned spaceship) do not intersect (in the galaxy plane, in 2D). \n\n How to think about non-intersecting paths?\n\n Note: The entire set of points (spaceships and bases) is given. The matching is a set of lines connecting a base to a spaceship. The condition is that these lines do not cross.\n\n However, note: the problem does not require that the entire drawing is planar, but only that the assigned lines (the matching) do not cross.\n\n Observation: The problem is equivalent to: given 2*R points (R bases and R spaceships), can we partition them into R pairs (each pair being a base and a spaceship) such that the straight line segments connecting the pairs do not cross.\n\n But wait: the input separates the points into two sets: the first R points are spaceships and the next B (which is R) are bases. However, note the example input format:\n\n Example 1:\n   Input: \"3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2\"\n\n So the first line is \"3 3\", then three lines for spaceships, then three lines for bases.\n\n However, the problem says: \"For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases.\"\n\n So we know which points are bases and which are spaceships.\n\n But note: the problem does not specify that the bases and spaceships are given in separate groups. It says the first R+1 to 2*B+1 lines: the first R lines after the first line are spaceships, then the next B are bases.\n\n However, the condition for non-intersection: we are free to assign any spaceship to any base. So we are to match the two sets (spaceships and bases) arbitrarily.\n\n How to check for non-intersecting matching?\n\n We can use the following idea:\n\n Since the number is small (R, B <= 10, and actually R=B so total points 2*R <= 20), we can consider using backtracking (generate all permutations) but 10",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between R Rebel spaceships and B bases such that the straight lines connecting each base to its assigned spaceship do not intersect. The solution involves checking two main conditions: whether the number of spaceships equals the number of bases (R = B), and if all possible matchings exist where the connecting lines do not intersect.\n\n### Approach\n1. **Check for Perfect Matching Condition**: The first step is to verify if the number of spaceships (R) equals the number of bases (B). If they are not equal, it's impossible to form a perfect matching, and the answer is immediately \"No\".\n2. **Check Non-Intersecting Lines**: If R equals B, we proceed to check all possible permutations of matching each spaceship to a base. For each permutation, we need to ensure that no two connecting lines intersect. To check for line intersections, we use the orientation method which determines the relative position of three points (whether they are collinear, clockwise, or counter-clockwise).\n\n### Solution Code\n```python\ndef orientation(A, B, C):\n    val = (B.y - A.y) * (C.x - B.x) - (B.x - A.x) * (C.y - B.y)\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return -1\n\ndef do_intersect(seg1, seg2):\n    A, B = seg1\n    C, D = seg2\n    \n    o1 = orientation(A, B, C)\n    o2 = orientation(A, B, D)\n    o3 = orientation(C, D, A)\n    o4 = orientation(C, D, B)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n        \n    if o1 == 0 and on_segment(A, B, C):\n        return True\n    if o2 == 0 and on_segment(A, B, D):\n        return True\n    if o3 == 0 and on_segment(C, D, A):\n        return True\n    if o4 == 0 and on_segment(C, D, B):\n        return True\n        \n    return False\n\ndef on_segment(A, B, C):\n    if min(A.x, B.x) <= C.x <= max(A.x, B.x) and min(A.y, B.y) <= C.y <= max(A.y, B.y):\n        return True\n    return False\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nimport sys\nfrom itertools import permutations\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        print(\"No\")\n        return\n        \n    first_line = data[0].split()\n    R = int(first_line[0])\n    B = int(first_line[1])\n    \n    if R != B:\n        print(\"No\")\n        return\n        \n    spaceships = []\n    bases = []\n    \n    for i in range(1, R+1):\n        parts = data[i].split()\n        x = int(parts[0])\n        y = int(parts[1])\n        spaceships.append(Point(x, y))\n        \n    for i in range(R+1, R+B+1):\n        parts = data[i].split()\n        x = int(parts[0])\n        y = int(parts[1])\n        bases.append(Point(x, y))\n        \n    n = R\n    base_permutations = list(permutations(range(n)))\n    \n    for perm in base_permutations:\n        segments = []\n        valid = True\n        for i in range(n):\n            spaceship_idx = i\n            base_idx = perm[i]\n            segments.append((spaceships[spaceship_idx], bases[base_idx]))\n            \n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                seg1 = segments[i]\n                seg2 = segments[j]\n                if do_intersect(seg1, seg2):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read from standard input, where the first line contains R and B. The subsequent lines contain the coordinates of the spaceships and bases.\n2. **Perfect Matching Check**: If R does not equal B, the solution immediately outputs \"No\" since a perfect matching is impossible.\n3. **Line Intersection Check**: For each permutation of base-spaceship assignments, the solution checks if any two connecting lines intersect. The `orientation` function determines the relative position of three points, and the `do_intersect` function uses this to check if two line segments intersect.\n4. **Output Result**: If any permutation results in non-intersecting lines, the solution outputs \"Yes\". If no such permutation exists, it outputs \"No\".\n\nThis approach efficiently checks all possible matchings by leveraging permutations and geometric properties to ensure non-intersecting lines, providing the correct solution within feasible computational limits given the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "def orientation(A, B, C):\n    val = (B.y - A.y) * (C.x - B.x) - (B.x - A.x) * (C.y - B.y)\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return -1\n\ndef do_intersect(seg1, seg2):\n    A, B = seg1\n    C, D = seg2\n    \n    o1 = orientation(A, B, C)\n    o2 = orientation(A, B, D)\n    o3 = orientation(C, D, A)\n    o4 = orientation(C, D, B)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n        \n    if o1 == 0 and on_segment(A, B, C):\n        return True\n    if o2 == 0 and on_segment(A, B, D):\n        return True\n    if o3 == 0 and on_segment(C, D, A):\n        return True\n    if o4 == 0 and on_segment(C, D, B):\n        return True\n        \n    return False\n\ndef on_segment(A, B, C):\n    if min(A.x, B.x) <= C.x <= max(A.x, B.x) and min(A.y, B.y) <= C.y <= max(A.y, B.y):\n        return True\n    return False\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nimport sys\nfrom itertools import permutations\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        print(\"No\")\n        return\n        \n    first_line = data[0].split()\n    R = int(first_line[0])\n    B = int(first_line[1])\n    \n    if R != B:\n        print(\"No\")\n        return\n        \n    spaceships = []\n    bases = []\n    \n    for i in range(1, R+1):\n        parts = data[i].split()\n        x = int(parts[0])\n        y = int(parts[1])\n        spaceships.append(Point(x, y))\n        \n    for i in range(R+1, R+B+1):\n        parts = data[i].split()\n        x = int(parts[0])\n        y = int(parts[1])\n        bases.append(Point(x, y))\n        \n    n = R\n    base_permutations = list(permutations(range(n)))\n    \n    for perm in base_permutations:\n        segments = []\n        valid = True\n        for i in range(n):\n            spaceship_idx = i\n            base_idx = perm[i]\n            segments.append((spaceships[spaceship_idx], bases[base_idx]))\n            \n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                seg1 = segments[i]\n                seg2 = segments[j]\n                if do_intersect(seg1, seg2):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 1088,
        "thoughts_token_count": 1023
    }
}