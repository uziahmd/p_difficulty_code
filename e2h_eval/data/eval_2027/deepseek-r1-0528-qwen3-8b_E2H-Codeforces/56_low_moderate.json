{
    "start": 1758294354.1973014,
    "end": 1758294620.7957752,
    "start-formatted": "2025-09-20 00:05 KST",
    "end-formatted": "2025-09-20 00:10 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers R and B (each between 1 and 10) so the total points are at most 20.\n Then R lines for rebels, then B lines for bases.\n\n Conditions: We need a perfect matching (one-to-one) between the R rebels and B bases, but note that the problem says \"assign R Rebel spaceships to guard B bases\" such that every base has exactly one guardian and each spaceship has exactly one assigned base. So we require R = B? Actually, wait: the problem says \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\". But note: if there are more bases than rebels, then some bases would not have a guardian? Similarly, if rebels are more, then some rebels don't get a base? However, the example input has R=3, B=3 and the second example has R=2, B=1. The second example output is 'No'. \n\n But wait, the problem says: \"the assignment is a perfect matching\". In graph theory, perfect matching requires same number of nodes in two parts. So we must have R = B.\n\n However, note the problem statement: \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\". This implies that we are assigning all R rebels and all B bases? Only if R=B. Otherwise, it's an incomplete matching. The problem says \"perfect matching\", so we must have R=B.\n\n Let me check the example input: \n   Example 1: R=3, B=3 -> Yes.\n   Example 2: R=2, B=1 -> No.\n\n Therefore, if R != B, we can immediately output \"No\".\n\n But wait: what if R > B or R < B? The problem says \"assign R Rebel spaceships to guard B bases\", meaning we are only allowed to assign at most min(R, B) rebels? However, the condition of perfect matching requires that the graph is bipartite and the matching covers all nodes. So if R != B, then we cannot have a perfect matching.\n\n Therefore, we can first check:\n   if R != B: then output \"No\"\n\n However, note: the problem does not explicitly say that the matching must cover all bases and all rebels. But the definition of perfect matching in a bipartite graph with two sets of size n and m requires n=m. \n\n But wait, the problem says: \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\". This implies that we are matching all the bases and all the spaceships. So if there are 2 spaceships and 1 base, then one spaceship will be left without a base, and the base will be guarded by one of the two. But then the condition for the base is satisfied (one guardian) but the condition for the spaceship is not (each spaceship must have one base). Therefore, we require that the assignment is a bijection. So R must equal B.\n\n Steps:\n\n 1. Read R and B.\n 2. If R != B, output \"No\".\n 3. Else, we have a set of R rebels and R bases (since R=B, and we read R rebels and then B=R bases).\n\n Now, we need to check if there is a one-to-one assignment from the rebels to the bases such that the straight line segments (from base to its assigned rebel) do not intersect.\n\n However, note: the problem says \"any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane\". Since the bases and rebels are fixed, we are going to draw R non-intersecting segments from the rebels to the bases.\n\n How to check for non-intersecting segments?\n\n Observation: The problem says no three points are collinear, so we don't have to worry about degenerate cases.\n\n We can model this as a geometric matching problem. Since R and B are at most 10, we can try to use a combinatorial approach: we have R! possibilities. But 10! is about 3.6 million which might be acceptable in worst-case, but note that we have two sets: we are matching rebels (set A) to bases (set B). So we are looking for a permutation p of [0..R-1] such that the segments (base_i, rebel_p[i]) do not intersect.\n\n However, note: the problem does not specify the order of the bases. We are free to assign any base to any rebel.\n\n But note: the problem says \"any two (straight) paths\" do not intersect. So the entire set of segments must be non-intersecting.\n\n How to check if two segments (a-b) and (c-d) intersect? We can use the standard method: check if the two segments cross.\n\n However, note: the segments are from a base to a rebel. We are not drawing arbitrary",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking all possible permutations of assignments between the spaceships and bases to see if any permutation results in non-intersecting segments.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijective assignment) between R spaceships and B bases where R must equal B for a perfect matching to exist. If R ≠ B, the answer is immediately \"No\".\n2. **Geometric Intersection Check**: For each possible permutation of assignments (which is feasible since R ≤ 10), we check if the segments connecting the bases to their assigned spaceships intersect. Two segments (p1, q1) and (p2, q2) intersect if the points are ordered such that one point lies on either side of the other segment's line.\n3. **Algorithm Selection**: Given the small constraint (R, B ≤ 10), a brute-force approach using permutations is practical. We generate all possible permutations of assigning bases to spaceships and check for non-intersecting segments using the cross product method to determine point orientation.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    from itertools import permutations\n\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    \n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    def ccw(A, B, C):\n        return (B[0] - A[0]) * (C[1] - A[1]) >= (B[1] - A[1]) * (C[0] - A[0])\n        \n    def do_segments_intersect(a, b, c, d):\n        return (ccw(a, b, c) != ccw(a, b, d)) and (ccw(a, c, b) != ccw(a, d, b))\n        \n    n = r\n    found = False\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                base_i = bases[perm[i]]\n                rebel_i = rebels[i]\n                base_j = bases[perm[j]]\n                rebel_j = rebels[j]\n                if do_segments_intersect(base_i, rebel_i, base_j, rebel_j):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into two lists: one for the coordinates of the spaceships and another for the bases.\n2. **Initial Check**: If the number of spaceships (R) does not equal the number of bases (B), the answer is \"No\" because a perfect matching is impossible.\n3. **Cross Product Calculation**: The `ccw` function checks the orientation of three points (counter-clockwise, clockwise, or collinear). This helps determine if two segments intersect by verifying if points lie on opposite sides of each other's lines.\n4. **Segment Intersection Check**: The `do_segments_intersect` function uses the cross product results to determine if two segments intersect.\n5. **Permutation Check**: All permutations of base assignments to spaceships are generated. For each permutation, the code checks if all segments (from bases to their assigned spaceships) do not intersect. If any permutation satisfies this condition, the answer is \"Yes\"; otherwise, it's \"No\".\n\nThis approach efficiently checks all possible assignments due to the small constraints, ensuring correctness while leveraging geometric properties to verify non-intersecting segments.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    from itertools import permutations\n\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    \n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    def ccw(A, B, C):\n        return (B[0] - A[0]) * (C[1] - A[1]) >= (B[1] - A[1]) * (C[0] - A[0])\n        \n    def do_segments_intersect(a, b, c, d):\n        return (ccw(a, b, c) != ccw(a, b, d)) and (ccw(a, c, b) != ccw(a, d, b))\n        \n    n = r\n    found = False\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                base_i = bases[perm[i]]\n                rebel_i = rebels[i]\n                base_j = bases[perm[j]]\n                rebel_j = rebels[j]\n                if do_segments_intersect(base_i, rebel_i, base_j, rebel_j):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 911,
        "thoughts_token_count": 1023
    }
}