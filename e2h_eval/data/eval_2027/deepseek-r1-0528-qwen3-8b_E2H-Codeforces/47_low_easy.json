{
    "start": 1758296450.9552352,
    "end": 1758299381.9473255,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k give the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, assume a <= b, so we can set d = b - a (but note: if a > b, then we can swap and adjust accordingly). However, let's consider:\n\nWe have two numbers: x = a+k and y = b+k, and we know that LCM(x, y) = (x * y) / GCD(x, y).\n\nNote that the difference between x and y is fixed: x - y = a - b (constant for all k). Let d = a - b. Then x = y + d (if d is negative, then y = x + |d|). Alternatively, we can write the two numbers as (a+k) and (b+k) and their difference is |a-b|.\n\nBut note: if we let g = gcd(a+k, b+k), then g must divide (a+k) - (b+k) = a-b. So g divides |a-b|.\n\nTherefore, the gcd of (a+k, b+k) must be a divisor of |a-b|.\n\nLet D = |a-b|. Then the gcd can only be one of the divisors of D.\n\nNow, note that we want to minimize LCM(x,y) = (x*y)/g. Since x*y = (a+k)*(b+k) and k is non-negative, we cannot iterate over all k from 0 to ... because k can be very large (and D can be up to 10^9).\n\nAlternative approach:\n\nWe know that the LCM is minimized when the product (a+k)*(b+k) is minimized? Not exactly, because the gcd may vary. But note: the LCM = (a+k)*(b+k)/gcd(a+k, b+k). Since the gcd is at least 1, the product must be considered together with the gcd.\n\nHowever, note that the difference is fixed. Let g be a divisor of D. Then we can set:\n   a+k = g * u\n   b+k = g * v\n\nThen we have:\n   g*u - g*v = D   => g*(u-v) = D.\n\nAlso, note that k = g*u - a, and also k = g*v - b, and these must be equal. So we have the condition: g divides D, and then u = (a+k)/g, v = (b+k)/g, and u - v = D/g.\n\nBut note: since k must be non-negative, we require that g*u >= a and g*v >= b.\n\nMoreover, the LCM becomes g * u * v.\n\nBut note: the problem asks for the smallest k that minimizes the LCM. We cannot iterate over all divisors of D (which can be up to 10^9) and then over all multiples? But the divisors of D are at most around 1344 (for highly composite numbers) so that is acceptable.\n\nHowever, note: if D=0, then a=b. Then we are looking for k such that LCM(a+k, a+k) = a+k. So we want the smallest k (non-negative) that minimizes a+k. The minimum is at k=0, so answer 0.\n\nBut wait: what if D != 0?\n\nWe can do:\n\nStep 1: If a == b, output 0.\n\nStep 2: Let D = abs(a-b). Then factorize D? Actually, we don't need to factorize D necessarily. We can iterate over all divisors of D.\n\nBut note: the divisors of D are not too many (about O(sqrt(D))). However, D can be up to 10^9, so sqrt(D) is about 10^4.5, which is 31622. That might be acceptable if we do it for each test case, but note: the input is only one line (two integers). However, worst-case D is 10^9, and the number of divisors is about 1344 (as mentioned). So we can do:\n\nApproach:\n\n1. If a == b: print(0) and return.\n\n2. Let g0 be the set of divisors of D = abs(a-b).\n\nBut note: we are going to consider divisors g of D. Then for each divisor g, we can set:\n\n   Let d = D (so d = |a-b|). Then we have g divides d, so d = g * t, where t = d // g.\n\nThen we have two",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant (\\( |a - b| \\)). The GCD of \\( a+k \\) and \\( b+k \\) must be a divisor of this difference. Therefore, we can consider all divisors of \\( |a - b| \\) to determine potential values of \\( k \\).\n\n2. **Insight**: For each divisor \\( g \\) of \\( |a - b| \\), we can derive a candidate \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). The LCM for these values is given by \\( \\frac{(a+k)(b+k)}{g} \\). We need to find the \\( k \\) that minimizes this LCM.\n\n3. **Algorithm Selection**: \n   - **Case 1**: If \\( a = b \\), the answer is trivially \\( k = 0 \\).\n   - **Case 2**: For \\( a \\neq b \\), compute all divisors of \\( |a - b| \\). For each divisor \\( g \\), solve for \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This involves solving linear congruences to ensure \\( k \\) is non-negative and minimal.\n   - **Optimization**: Among all candidate \\( k \\) values derived from the divisors, select the one that minimizes the LCM. If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{D}) \\), where \\( D = |a - b| \\). For \\( D \\) up to \\( 10^9 \\), this approach efficiently handles the constraints by leveraging divisor enumeration and solving linear equations.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    D = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= D:\n        if D % i == 0:\n            divisors.add(i)\n            divisors.add(D // i)\n        i += 1\n        \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors:\n        d_val = D // g\n        x = (g - a % g) % g\n        k_candidate = x\n        if k_candidate < 0:\n            k_candidate += g\n            \n        num1 = a + k_candidate\n        num2 = b + k_candidate\n        g_val = gcd(num1, num2)\n        current_lcm = (num1 * num2) // g_val\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k_candidate < best_k):\n            best_k = k_candidate\n            best_lcm = current_lcm\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), it immediately outputs \\( 0 \\) since the LCM of any number with itself is the number itself, minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For \\( a \\neq b \\), the code calculates all divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\).\n4. **Candidate Generation**: For each divisor \\( g \\), the code computes a candidate \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This involves solving for \\( k \\) using modular arithmetic.\n5. **LCM Calculation**: For each candidate \\( k \\), the code computes the LCM of \\( a+k \\) and \\( b+k \\) and keeps track of the minimal LCM and corresponding smallest \\( k \\).\n6. **Output**: The smallest \\( k \\) that minimizes the LCM is printed.\n\nThis approach efficiently narrows down potential candidates for \\( k \\) by leveraging mathematical properties of divisors and GCD, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    D = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= D:\n        if D % i == 0:\n            divisors.add(i)\n            divisors.add(D // i)\n        i += 1\n        \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors:\n        d_val = D // g\n        x = (g - a % g) % g\n        k_candidate = x\n        if k_candidate < 0:\n            k_candidate += g\n            \n        num1 = a + k_candidate\n        num2 = b + k_candidate\n        g_val = gcd(num1, num2)\n        current_lcm = (num1 * num2) // g_val\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k_candidate < best_k):\n            best_k = k_candidate\n            best_lcm = current_lcm\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 1043,
        "thoughts_token_count": 1023
    }
}