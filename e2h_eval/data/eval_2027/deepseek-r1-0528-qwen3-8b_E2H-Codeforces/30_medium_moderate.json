{
    "start": 1758307885.7895055,
    "end": 1758311460.6787848,
    "start-formatted": "2025-09-20 03:51 KST",
    "end-formatted": "2025-09-20 04:51 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n We need to assign each digit in A (from left to right) to either Homer (H) or Marge (M) for exactly n moves each.\n The goal is to maximize the total prize: S1 (the number formed by Homer's digits) + S2 (the number formed by Marge's digits).\n\n However, note that the problem does not require to output the actual numbers but the sequence of moves (a string of length 2n with n 'H' and n 'M').\n\n Important: The moves happen by taking the leftmost digit of A and appending it to the respective player's number. So the first move uses the first digit, second move uses the second, etc.\n\n Let's denote:\n   Let S1 be the number from Homer's moves (which are the digits assigned to H in order of occurrence) and S2 from Marge.\n\n But note: the digits are taken in the order they appear, so the first digit is the most significant for the first move.\n\n However, the catch: we have two players and we can choose which one takes the next available digit.\n\n The total prize is S1 + S2.\n\n How to think?\n Since the digits are fixed and the assignment is over the entire string, we can consider:\n\n Let the entire sequence of digits be d0, d1, ... , d_{2n-1}.\n\n We assign each digit to either H or M. Then:\n   S1 = d_i0 * 10^{k0} + d_i1 * 10^{k1} + ... \n   S2 = d_j0 * 10^{k0} + d_j1 * 10^{k1} + ...\n\n But note: the positions (powers of 10) depend on the order of assignment. Actually, the first digit assigned to a player becomes the most significant for that player.\n\n However, the assignment order is fixed (we assign the digits in the order they appear). So the i-th digit (0-indexed) is assigned to a player and then that player's number gets a digit that will be placed at a position determined by how many digits they have already taken? Actually, no: because the entire process goes from left to right, and each time we take the leftmost digit.\n\n But wait: the number S1 is built by the digits assigned to H, in the order they were taken. Similarly for S2.\n\n Example: n=2, A = \"1234\"\n   If we assign as \"HHMM\":\n        Homer's moves: first digit '1', then third digit '3'\n        Marge's moves: second digit '2', then fourth digit '4'\n        Then S1 = 1 * 10 + 3 = 13, S2 = 2 * 10 + 4 = 24, total = 37.\n\n   If we assign as \"HMHM\":\n        Homer: first digit '1', then fourth digit '4' -> 14\n        Marge: second digit '2', then third digit '3' -> 23, total = 37.\n\n   Another possibility: \"HM HM\" (same as above) or \"MMHH\": \n        S1 = 3*10+4 = 34, S2=1*10+2=12, total=46? Wait, let me check:\n\n        Actually, if we assign as \"MMHH\", then:\n          First move: M takes '1' -> M has 1\n          Second move: M takes '2' -> M has 12\n          Third move: H takes '3' -> H has 3\n          Fourth move: H takes '4' -> H has 34\n          Then S1 = 34, S2 = 12, total=46.\n\n But wait, the example input was ['2\\n1234'] and the example output was ['HHMM'].\n\n Why is that? The example output says HHMM gives 37, but MMHH gives 46 which is higher. \n\n However, the example output provided was only one of the possibilities: \n   Input: ['2\\n1234'] -> Output: ['HHMM']\n   Input: ['2\\n9911'] -> Output: ['HMHM']\n\n This indicates that the example outputs might be just one correct answer, but there could be multiple.\n\n But wait, the problem says: \"If there are several solutions, output any of them.\"\n\n However, the example input \"9911\" leads to output \"HMHM\", meaning that we are not necessarily outputting the maximum total prize? Or did I miscalculate?\n\n Let me recalculate for A=\"9911\", n=2:\n\n Option 1: HHMM -> \n   H: 9 and 1 -> 91\n   M: 9 and 1 -> 91\n   Total: 182\n\n Option 2: HM interest: HM HM: \n   H: 9 and 1 -> 91\n   M: 9 and 1 -> 91\n   Same.\n\n Option 3: HM MH: \n   H: 9 and 1 -> 91\n   M: 9 and 1 -> 91\n   Same.\n\n Option 4: MM HH: \n   M: 9 and 1 -> 91\n   H: 9 and 1 -> 91\n   Same.\n\n Option 5: MH MH: same as above.\n\n Actually, wait: the assignment must use exactly n moves for each. The digits are fixed and the order is fixed.\n\n But note: the digits are assigned in order. For \"9911\", the four digits are [9,9,1,1]. \n\n How about:\n\n   HHMM: \n      H takes first 9 -> then the number becomes 9, and then the remaining is \"911\"\n      Then H takes the next 9? No, wait: the next leftmost is the second 9? Then the remaining after first two digits is \"11\". Then M takes two ones.\n\n   Actually, the assignment is:\n\n      Move1: H takes the first digit -> A becomes \"911\"\n      Move2: H takes the next digit (which is the second digit of original, now the first) -> A becomes \"11\"\n      Then M takes two: first of \"11\" then the next.\n\n   So S1 = 9*10 + 9 = 99, S2 = 1*10 + 1 = 11, total = 110.\n\n   Alternatively, if we assign as \"HMHM\":\n\n      Move1: H takes first 9 -> A becomes \"911\"\n      Move2: M takes the next 9 -> A becomes \"11\"\n      Move3: H takes the next 1 -> A becomes \"1\"\n      Move4: M takes the last 1.\n\n      Then S1 = 9*10 + 1 = 91, S2 = 9*10 + 1 = 91, total = 182.\n\n   And if we assign as \"MMHH\":\n\n      Move1: M takes first 9 -> A becomes \"911\"\n      Move2: M takes second 9 -> A becomes \"11\"\n      Move3: H takes first 1 -> A becomes \"1\"\n      Move4: H takes last 1.\n\n      Then S1 = 1*10 + 1 = 11, S2 = 9*10 + 9 = 99, total = 110.\n\n   So the maximum total is 182, and the assignment that achieves that is when we alternate: H then M then H then M.\n\n   Why is the example output for \"9911\" \"HMHM\"? Because that assignment gives 182.\n\n   Now, why for \"1234\" the example output is \"HHMM\" (which gives 37) but we saw that \"MMHH\" gives 46? That is higher. \n\n   But wait, let me recalculate for \"1234\" with assignment \"MMHH\":\n\n      Assignment \"MMHH\" means:\n        Move1: M takes the first digit '1' -> M's number starts with 1, remaining A = \"234\"\n        Move2: M takes the next digit '2' -> M's number becomes 12, remaining A = \"34\"\n        Move3: H takes the next digit '3' -> H's number becomes 3, remaining A = \"4\"\n        Move4: H takes the last digit '4' -> H's number becomes 34.\n\n      Then S1 = 34, S2 = 12, total = 46.\n\n   But wait, the example input was \"1234\", and the example output was \"HHMM\", which gives 37. However, 46 is larger. \n\n   There seems to be a misunderstanding. The problem says: \"They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize.\"\n\n   Therefore, we must maximize the total prize. In the example \"1234\", the maximum total prize is 46, not 37.\n\n   Then why the example output is \"HHMM\"? \n\n   Let me check the example again: the example input is given as:\n\n        ['2\\n1234', '2\\n9911']\n\n   and the output is:\n\n        ['HHMM', 'HMHM']\n\n   But wait, the example output for the first case is 'HHMM' and the second is 'HMHM'. \n\n   However, our calculation shows that for the first case, the assignment \"MMHH\" gives a higher total (46 vs 37). \n\n   This implies that the example outputs are not necessarily achieving the maximum total? Or did I misinterpret the problem?\n\n   Let me reread the problem statement: \n\n        \"Output the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize.\"\n\n   So we must output a sequence that maximizes the total prize.\n\n   Therefore, the example output for the first case should be a sequence that yields 46, not 37.\n\n   But wait, let me check the example again: the example input is provided as two separate examples.\n\n   Actually, the example input format is:\n\n        ['2\\n1234', '2\\n9911']\n\n   and the output is:\n\n        ['HHMM', 'HMHM']\n\n   This might be two separate test cases. The problem says the first line is n, the second is A.\n\n   So the first test case: n=2, A=\"1234\", and the answer is \"HHMM\" (but we found a better one). \n\n   There must be an error in the example.\n\n   Alternatively, maybe I misunderstood the game mechanics? \n\n   The problem says: \"On its turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A.\"\n\n   So the entire process is fixed: we remove the leftmost digit each time, and assign the digit to the current player.\n\n   But note: the players are alternating in their turns? Actually, the problem says: \"Before each turn players determine who will make the next move.\" and \"Each player should make exactly n moves.\"\n\n   So the assignment of turns is under our control. We can choose the order arbitrarily as long as each player makes exactly n moves.\n\n   However, the example output for \"1234\" is \"HHMM\", meaning that Homer goes twice and then Marge twice.\n\n   What if we do \"HHMM\" for \"1234\":\n        Homer: first two digits: '1' and '2' -> no, wait: \n\n        Actually, the moves are:\n\n            Initially: A = \"1234\", S1 = \"\", S2 = \"\"\n            Turn1: Homer takes the first digit '1' -> A becomes \"234\", S1 = \"1\"\n            Turn2: Homer takes the next first digit '2' -> A becomes \"34\", S1 = \"12\"\n            Turn3: Marge takes the next first digit '3' -> A becomes \"4\", S2 = \"3\"\n            Turn4: Marge takes the next first digit '4' -> A becomes \"\", S2 = \"34\"\n\n        Then S1 = 12, S2 = 34, total = 46.\n\n   Wait, that is the same as \"MMHH\" but with the roles reversed? \n\n        In \"MMHH\": \n            M takes first two: '1','2' -> M's number is 12, then H takes the last two: '3','4' -> 34, total 46.\n\n        In \"HHMM\": \n            H takes first two: 12, then M takes last two: 34, total 46.\n\n        In \"HMHM\":\n            H takes first: '1' -> then M takes second: '2' -> then H takes third: '3' -> then M takes fourth: '4'\n            S1 = 1*10+3 = 13, S2 = 2*10+4 = 24, total 37.\n\n        In \"HM HM\" (i.e., H then M then H then M) is 37.\n\n        In \"MH MH\" (M then H then M then H): \n            M takes first: '1', H takes second: '2', M takes third: '3', H takes fourth: '4'\n            S1 = 2*10+4 = 24, S2 = 1*10+3 = 13, total 37.\n\n        So the maximum total is 46, achieved by assignments where the first two moves are by one player and the last two by the other.\n\n   Now, why did the example output say \"HHMM\" for the first example? Because it's one of the optimal solutions.\n\n   Similarly, for the second example \"9911\", the optimal solution is 182, achieved by alternating (HMHM or MHMH). \n\n   So the problem is: we can choose any sequence of 2n moves with n H and n M, and we wish to maximize S1+S2.\n\n   How to solve?\n\n   We have to assign each digit to either H or M, and the assignment must be contiguous in the sense of the order (the first digit is always assigned, then the next, etc.). However, the assignment can be interleaved arbitrarily.\n\n   The total prize is:\n\n        S1 = sum_{i in H} (digit_i) * (10^{position_i})\n        S2 = sum_{i in M} (digit_i) * (10^{position_i})\n\n   But note: the position (power of 10) for a digit depends on how many digits that player has already taken. Specifically, if a player has k digits at the time of assigning a new digit, then that new digit is multiplied by 10^(k).\n\n   However, we don't know the assignment until the end. We have to decide the entire sequence.\n\n   Alternate view: \n\n        Let the entire sequence of digits be D[0], D[1], ..., D[2n-1].\n\n        We assign each digit to either H or M. Then:\n\n        For H: The digits assigned to H are taken in the order of appearance. The first digit assigned to H (at position i) will be multiplied by 10^(count_H-1), the next by 10^(count_H-2), etc.\n\n        Similarly for M.\n\n   We can write:\n\n        Let x_i be 0 if the i-th digit is assigned to H, and 1 if to M.\n\n        Then the total prize is:\n\n          T = sum_{i=0}^{2n-1} [ (digit_i) * (10^{k_i}) ]\n\n        where k_i = (number of digits already assigned to the same player that appeared before this digit) [because the digit is appended to the existing number, so the power is the number of digits that player has already]\n\n        But note: the digits are taken in order, so the assignment for the first n or n/2 moves might be mixed.\n\n   We can use dynamic programming. However, n can be up to 18 (so 2n=36). We have 36 moves, and we have to assign n moves to H and n moves to M.\n\n   Alternatively, we can consider that the total prize can be broken down by the positions (the power of 10). The first digit (most significant) of the entire number (if assigned to a player) will be multiplied by 10^(2n-1) for that player? \n\n   Actually, for a player, the first digit they take will be multiplied by 10^(n-1) (if they take n digits) because they take n digits and the last one is multiplied by 10^0. But wait, the entire process is sequential and the same digit might be more significant than others.\n\n   However, note: the entire number A is of 2n digits. The first digit is the most significant (multiplied by 10^(2n-1)), the second by 10^(2n-2), etc.\n\n   But when we assign a digit to a player, it is appended to their own number. So the first digit a player takes becomes the most significant of their own number, and the next becomes the next, etc.\n\n   Therefore, the entire prize T can be expressed as:\n\n        T = (digit_0 * 10^(n-1)) + (digit_1 * 10^(n-1)) ? \n\n   Not exactly. The assignment is arbitrary. But note: the first digit (digit_0) is always the most significant for whoever takes it. Then the second digit (digit_1) is the next most significant for the taker, unless the first digit was taken by the other player, then the second digit becomes the most significant for the taker of the second digit? \n\n   Actually, no. The first digit is always the most significant for the first move. Then the second digit is the next most significant for the second move, regardless of which player took the first. \n\n   But wait, consider two players: \n\n        Suppose we assign the first two digits to the same player. Then that player's number is (first_digit)(second_digit). The first_digit is multiplied by 10, and the second by 1.\n\n        Now, if we assign the first digit to one and the second to the other, then the first_digit is the most significant for the first player, and the second_digit is the most significant for the second player.\n\n   Therefore, the value of a digit depends on when it is taken and by whom.\n\n   We can also note: the total prize T is independent of the assignment? Actually no, because the same digit might be multiplied by a different power depending on the assignment.\n\n   However, we can break down the prize by the position of the digit and the number of digits that player will take after it.\n\n   For a digit at position i (0-indexed), if it is assigned to a player, then the power of 10 it gets is 10^( (number of moves that player will have after this digit) ).\n\n   But wait: the player's number is built by the digits they take in order. The digit at position i is appended at the time of the move, and then the subsequent moves of the same player will add more digits (to the right). Therefore, the digit at position i is the j-th digit of that player (where j is the count of moves that player has taken so far, including this one). Then the power is 10^( (n - j) )? Actually, no: the j-th digit (0-indexed) of the player's number is the most significant being the first, so the first digit is multiplied by 10^(n-1) and the last by 10^0.\n\n   But note: we don't know the total number of moves the player will take? Actually, each player takes exactly n moves.\n\n   However, the digit at position i is the (j)-th digit for that player, so the multiplier is 10^(n - 1 - j) (if j counts from 0 to n-1). But j is the index (0-indexed) in the player's sequence.\n\n   But we don't know j until we know the entire assignment.\n\n   Alternatively, we can consider the entire assignment and then compute the power for each digit.\n\n   We can use DP with state (i, h, m) where i is the current index (from 0 to 2n-1), h is the number of moves Homer has made, m is the number of moves Marge has made.\n\n   Then the state (i, h, m) represents that we have processed the first i digits, and Homer has h moves and Marge has m moves (with h+m=i).\n\n   Then we consider the next digit (at index i) and assign it to either H or M, if we haven't exceeded n moves.\n\n   Then the contribution of this digit is:\n\n        If assigned to H: digit_i * (10^(n - h - 1))? \n\n        But wait: when we assign a digit to H, then in H's number, this digit will be the (h)-th digit (0-indexed) and therefore will be multiplied by 10^(n-1-h). However, note: we have already taken h digits for H, so this is the (h)-th digit (so the exponent is n-1-h). \n\n        Similarly for M: digit_i * (10^(n-1-m))\n\n   However, this is incorrect because the exponent depends on the entire assignment. But note: the assignment of the remaining digits does not change the fact that the current digit's position in the player's number is fixed by the number of moves the player has already made (including this one).\n\n   But wait: the entire number of moves for each player is fixed (n). So for a digit assigned to H at step i (when H has already h moves), then in the final number, this digit will be the (h)-th digit (so it will be shifted by (n-1-h) zeros). However, we cannot know the exact exponent until we know the entire assignment? \n\n   Actually, we can: because the entire assignment is known by the time we finish. But in DP we are building the assignment.\n\n   However, note: the digit at position i is assigned to H, then the remaining digits for H (n-h-1) will be appended to the right. Therefore, the digit at position i is indeed multiplied by 10^(n-h-1) (because we have n-h-1 digits to put to the right).\n\n   Similarly for M: 10^(n-m-1).\n\n   Therefore, the recurrence:\n\n        dp[i][h][m] = maximum total prize we can achieve from the first i digits, with h moves for H and m moves for M.\n\n        Then, if we assign the i-th digit (0-indexed, so the digit at index i) to H, then:\n\n            new_state = (i+1, h+1, m)\n            value = dp[i][h][m] + int(A[i]) * (10**(n-1-h))\n\n        Similarly, if we assign to M (and m < n):\n\n            value = dp[i][h][m] + int(A[i]) * (10**(n-1-m))\n\n        Then dp[i][h][m] = max( value from H, value from M )\n\n   But note: the base state: dp[0][0][0] = 0.\n\n   Then we iterate i from 0 to 2n-1, and h from 0 to n, m from 0 to n, with h+m=i.\n\n   However, the state space is (2n+1) * (n+1) * (n+1) = 36 * 19 * 19 ~ 13000 states, which is acceptable for n<=18 (so 2n=36).\n\n   But the exponents: 10**(n-1-h) for n up to 18, so the exponents go up to 10^17. We are dealing with integers that are very big, but Python can handle big integers. However, the problem says the number A has 2n digits, and n<=18, so the numbers are up to 36-digit numbers, which is within the range of Python integers.\n\n   However, we are asked to output the sequence of moves (the string of length 2n) that achieves the maximum total prize.\n\n   We can store the decision (whether we assigned the i-th digit to H or M) in the DP state.\n\n   Steps:\n\n        n = int(input().strip())\n        A_str = input().strip()\n\n        Let dp[i][h][m] = maximum total prize from the first i digits, with h moves by H and m moves by M.\n\n        We'll use a 3D DP array, and we also keep a 3D array (or dictionary) for the choice (whether the last move was H or M) so we can backtrack.\n\n        Alternatively, we can do:\n\n            dp[i][h][m] = (max_value, last_move)   but then we have to store the last move? Actually, we want the entire sequence.\n\n        Instead, we can store:\n\n            dp[i][h][m] = the maximum total prize for the first i digits, and we record the move at the i-th digit (if we are going forward) or we can do backward.\n\n        Actually, we can do:\n\n            dp[i][h][m] = maximum prize from the prefix [0:i] with h moves for H and m for M.\n\n            Then we also store a table:\n\n                choice[i][h][m] = either 'H' or 'M' (if we assigned the i-th digit to H or M) OR None if not reached.\n\n            Then we can backtrack from (2n, n, n) to (0,0,0).\n\n        Steps:\n\n            Initialize dp[0][0][0] = 0.\n\n            For i in range(0, 2*n):\n                for h in range(0, n+1):\n                    for m in range(0, n+1):\n                        if h+m != i: continue   # not a valid state\n\n                        if h < n:\n                            # Assign the i-th digit to H\n                            exp = n - 1 - h   # because after this move, H will have h+1 moves, so the current digit is the h-th (0-indexed) and will be followed by (n - h - 1) digits? \n                            # But wait, the exponent is the number of digits that will be placed to the right of this one by the same player. Since the player will take n moves, and we are at the h-th (0-indexed) move, then there are (n - h - 1) digits to the right, so the exponent is (n - h - 1) zeros? Actually, the digit is the (h)th (0-indexed) so the place is 10^(n-1-h) because the last digit is 10^0, the one before last is 10^1, ... the first is 10^(n-1).\n\n                            # But note: the entire number has n digits. The first digit (index0) is at 10^(n-1), the second at 10^(n-2), ... the last at 10^0.\n\n                            value = dp[i][h][m] + int(A_str[i]) * (10**(n-1-h))\n\n                            Then set dp[i+1][h+1][m] = max(dp[i+1][h+1][m], value)\n\n                        Similarly for M.\n\n            Then we backtrack from i=2*n, h=n, m=n to 0.\n\n        However, note: the digit we are assigning is the i-th (0-indexed). In the exponent, for H, we use (n-1-h) where h is the current count (before adding the current digit). Then after adding, the count becomes h+1, but the exponent for the current digit is computed based on the current count (h) because the current digit is the h-th (so there will be (n-1-h) digits to the right).\n\n        But wait, if we assign the i-th digit to H, then the exponent for that digit is 10^(n-1-h) because:\n\n            In the final number for H, there will be n digits. The current digit is the (h+1)-th? No, because we are going to assign n digits for H. The current digit is the (h)th digit (if we count from 0) and then there will be (n - h - 1) more digits. Therefore, the current digit is the (n-1 - (n-h-1))-th? \n\n        Let me reframe: \n\n            The final number for H is built by the digits assigned to H, in the order they were taken. The first digit taken by H is the most significant (multiplied by 10^(n-1)), the second by 10^(n-2), etc.\n\n            Now, if we are at the (h+1)-th digit for H (so we have already taken h digits), then the current digit (which is the (h+1)-th) will be multiplied by 10^(n-1-h) because there are (n-1-h) digits to the right.\n\n        Yes, that matches.\n\n        However, note: the exponent base is 10, and we are using powers that are large. But since n is at most 18, 10^(n-1) is 10^17, which is a 18-digit number. But the digits are multiplied by that, and we are adding for all digits. This is acceptable.\n\n        But note: the total prize is the sum of the two numbers. However, we are adding the contributions of the digits to the two numbers independently. This is correct.\n\n        Example: A=\"12\", n=1.\n\n            Then we have two moves: one for each player.\n\n            Possibilities: \n                H then M: \n                    H: first digit '1' -> 1 * 10^(0) = 1\n                    M: second digit '2' -> 2 * 10^(0) = 2\n                    Total = 3.\n\n                M then H:\n                    M: first digit '1' -> 1 * 10^(0) = 1\n                    H: second digit '2' -> 2 * 10^(0) = 2\n                    Total = 3.\n\n            Now, what if we try to assign the first digit to H and the second to M: that's one of the two.\n\n            Our DP:\n\n                i=0: \n                    h=0, m=0 -> state (0,0,0) with value 0.\n                    Assign first digit to H: \n                        h_new = 1, m_new = 0, i_new = 1\n                        value = 0 + 1 * (10^(1-1-0)) = 1 * 10^0 = 1.\n\n                    Assign first digit to M:\n                        value = 0 + 1 * (10^(1-1-0)) = 1.\n\n                Then for i=1, we have two states: (1,1,0) and (1,0,1).\n\n                For state (1,1,0): we have assigned the first digit to H, now we assign the second to M:\n                    value = 1 + 2 * (10^(1-1-0)) = 1 + 2 = 3.\n\n                For state (1,0,1): we have assigned the first digit to M, now we assign the second to H:\n                    value = 1 + 2 * (10^(1-1-0)) = 1 + 2 = 3.\n\n            Then the maximum is 3.\n\n        Example: A=\"12\", n=1, and we can output either \"HM\" or \"MH\".\n\n        However, the problem says: output the sequence of moves. We have to output the entire string of length 2n.\n\n        We can store the choices in a 3D array:\n\n            choice[i][h][m] = the move made at the i-th digit (i.e., the digit at index i) to get to state (i, h, m) from (i-1, h_prev, m_prev). Then we backtrack.\n\n        Steps for backtracking:\n\n            Start at i=2*n, h=n, m=n.\n\n            Then for each step backwards, we look at the choice at (i, h, m) to know whether the last move was H or M.\n\n            Then we subtract the digit's contribution and update the state.\n\n        Alternatively, we can store the entire sequence by doing DP and storing the parent state and the move.\n\n        Implementation:\n\n            Let dp[i][h][m] = maximum total prize from the first i digits.\n\n            We'll create a 3D array (or list of lists of lists) of size (2*n+1) x (n+1) x (n+1) for dp.\n\n            And we'll create a 3D array (or list) called move_decision of the same dimensions, storing either None, 'H', or 'M'. For the initial state (0,0,0) we don't have a move.\n\n            Then, for each state (i, h, m):\n\n                if i==0: skip (base state)\n\n                else:\n                    if we came from (i-1, h_prev, m_prev) by a move, then we know the move at i-1 (the (i-1)-th digit) was either H or M.\n\n            Actually, we are processing the i-th digit (0-indexed) at state (i, h, m). Then the move for the i-th digit is stored in move_decision[i][h][m].\n\n            We can do:\n\n                dp[i][h][m] = max(\n                    (dp[i-1][h-1][m] + int(A_str[i-1]) * (10**(n-1-(h-1))) ) if h>=1 else -inf,\n                    (dp[i-1][h][m-1] + int(A_str[i-1]) * (10**(n-1-(m-1))) ) if m>=1 else -inf\n                )\n\n            But wait, the digit we are assigning is the (i-1)-th digit (if we index from 0). Alternatively, we can index the string from 0 to 2n-1, and the i in the state goes from 0 to 2n.\n\n            Let me change: we process the i-th digit (0-indexed) at state (i, h, m). Then the digit is A_str[i].\n\n            Then the recurrence:\n\n                dp[i][h][m] = maximum of:\n\n                  Option1: from state (i-1, h-1, m) and then assign A_str[i] to H, if h>=1.\n                      value1 = dp[i-1][h-1][m] + int(A_str[i]) * (10**(n-1-(h-1)))\n\n                  Option2: from state (i-1, h, m-1) and then assign A_str[i] to M, if m>=1.\n                      value2 = dp[i-1][h][m-1] + int(A_str[i]) * (10**(n-1-(m-1)))\n\n            Then we store the move_decision[i][h][m] as the move that gave the maximum value.\n\n        However, note: the exponent for H: the current digit is the (h-1+1)=h-th digit (0-indexed) for H, so the exponent is 10^(n-1-h). But wait, we defined:\n\n            For H: exponent = n-1 - (current count of H moves - 1) ?\n\n            Actually, when we are at state (i, h, m) and we are assigning the i-th digit to H, then the current count of H moves (before this assignment) is h-1. Then the exponent is 10^(n-1 - (h-1))? \n\n            But note: we have n moves for H. The current digit is the (h-1+1)=h-th digit (0-indexed) and there are n-h digits left for H (including this one). Actually, after this assignment, H will have h moves. The current digit is the (h-1)-th digit (if we count from 0) and then there are n-h moves (including this) so the exponent is 10^(n-1 - (h-1))? \n\n            Let me clarify:\n\n                We have a player who will eventually have n moves. The first move (the first digit they take) is multiplied by 10^(n-1). The second by 10^(n-2), ... the k-th by 10^(n-k).\n\n                So the k-th move (0-indexed) is multiplied by 10^(n-1-k).\n\n                In the state (i, h, m), if we are about to assign a digit to H, then this digit will be the (h)-th move for H (if we count from 0, then the first move is",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns selecting digits from a given number A. The players alternately pick digits from the leftmost end of A, with each player making exactly n moves. The total prize is the sum of the numbers formed by each player's selected digits. The challenge is to determine the optimal sequence of moves that maximizes this sum.\n\n### Approach\n1. **Dynamic Programming (DP) Setup**: We use a 3D DP array where `dp[i][h][m]` represents the maximum total prize achievable after processing the first `i` digits of A, with Homer having made `h` moves and Marge having made `m` moves. The dimensions of the DP array are `(2n+1) x (n+1) x (n+1)`.\n\n2. **State Transition**: For each state `(i, h, m)`, we consider two possibilities:\n   - **Assign the current digit to Homer**: The digit is appended to Homer's number, contributing `digit * 10^(n-1-h)` to the total prize. Here, `h` is the number of moves Homer has already made before this assignment.\n   - **Assign the current digit to Marge**: Similarly, the digit contributes `digit * 10^(n-1-m)` to the total prize, where `m` is the number of moves Marge has already made.\n\n3. **Backtracking for Solution**: After filling the DP table, we backtrack from the state `(2n, n, n)` to determine the optimal sequence of moves. Starting from the final state, we check whether the last move was by Homer or Marge based on the DP transitions and build the solution string accordingly.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    A_str = data[1].strip()\n    total_digits = 2 * n\n\n    dp = [[[None for _ in range(n+1)] for _ in range(n+1)] for __ in range(total_digits+1)]\n    move_decision = [[[None for _ in range(n+1)] for _ in range(n+1)] for __ in range(total_digits+1)]\n    \n    dp[0][0][0] = 0\n    \n    for i in range(1, total_digits+1):\n        for h in range(n+1):\n            for m in range(n+1):\n                if h + m != i:\n                    continue\n                val1 = None\n                val2 = None\n                if h >= 1:\n                    prev_dp = dp[i-1][h-1][m]\n                    if prev_dp is not None:\n                        exp = n - 1 - (h - 1)\n                        digit_val = int(A_str[i-1])\n                        add_val = digit_val * (10 ** exp)\n                        new_val = prev_dp + add_val\n                        val1 = new_val\n                if m >= 1:\n                    prev_dp = dp[i-1][h][m-1]\n                    if prev_dp is not None:\n                        exp = n - 1 - (m - 1)\n                        digit_val = int(A_str[i-1])\n                        add_val = digit_val * (10 ** exp)\n                        new_val = prev_dp + add_val\n                        val2 = new_val\n                \n                best_val = None\n                if val1 is not None and val2 is not None:\n                    best_val = max(val1, val2)\n                    if best_val == val1:\n                        move_decision[i][h][m] = 'H'\n                    else:\n                        move_decision[i][h][m] = 'M'\n                elif val1 is not None:\n                    best_val = val1\n                    move_decision[i][h][m] = 'H'\n                elif val2 is not None:\n                    best_val = val2\n                    move_decision[i][h][m] = 'M'\n                dp[i][h][m] = best_val\n\n    seq = []\n    i = total_digits\n    h = n\n    m = n\n    while i > 0:\n        move_here = move_decision[i][h][m]\n        seq.append(move_here)\n        if move_here == 'H':\n            h -= 1\n        else:\n            m -= 1\n        i -= 1\n\n    seq.reverse()\n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Initialization**: The code reads the input values for `n` and the number `A`. It initializes a 3D DP array to store the maximum prize achievable at each state and a `move_decision` array to record the optimal move at each state.\n\n2. **DP Table Population**: The nested loops iterate over all possible states `(i, h, m)`. For each state, it checks whether assigning the current digit to Homer or Marge yields a higher total prize. The contribution of each digit is calculated based on its position in the respective player's number.\n\n3. **Backtracking**: Starting from the final state `(2n, n, n)`, the code backtracks through the `move_decision` array to construct the sequence of moves. Each decision (Homer or Marge) is appended to the result list, which is then reversed to form the final sequence.\n\n4. **Output**: The constructed sequence, consisting of 'H' and 'M' characters, is printed as the solution. This sequence ensures both players make exactly `n` moves and maximizes their combined prize.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    A_str = data[1].strip()\n    total_digits = 2 * n\n\n    dp = [[[None for _ in range(n+1)] for _ in range(n+1)] for __ in range(total_digits+1)]\n    move_decision = [[[None for _ in range(n+1)] for _ in range(n+1)] for __ in range(total_digits+1)]\n    \n    dp[0][0][0] = 0\n    \n    for i in range(1, total_digits+1):\n        for h in range(n+1):\n            for m in range(n+1):\n                if h + m != i:\n                    continue\n                val1 = None\n                val2 = None\n                if h >= 1:\n                    prev_dp = dp[i-1][h-1][m]\n                    if prev_dp is not None:\n                        exp = n - 1 - (h - 1)\n                        digit_val = int(A_str[i-1])\n                        add_val = digit_val * (10 ** exp)\n                        new_val = prev_dp + add_val\n                        val1 = new_val\n                if m >= 1:\n                    prev_dp = dp[i-1][h][m-1]\n                    if prev_dp is not None:\n                        exp = n - 1 - (m - 1)\n                        digit_val = int(A_str[i-1])\n                        add_val = digit_val * (10 ** exp)\n                        new_val = prev_dp + add_val\n                        val2 = new_val\n                \n                best_val = None\n                if val1 is not None and val2 is not None:\n                    best_val = max(val1, val2)\n                    if best_val == val1:\n                        move_decision[i][h][m] = 'H'\n                    else:\n                        move_decision[i][h][m] = 'M'\n                elif val1 is not None:\n                    best_val = val1\n                    move_decision[i][h][m] = 'H'\n                elif val2 is not None:\n                    best_val = val2\n                    move_decision[i][h][m] = 'M'\n                dp[i][h][m] = best_val\n\n    seq = []\n    i = total_digits\n    h = n\n    m = n\n    while i > 0:\n        move_here = move_decision[i][h][m]\n        seq.append(move_here)\n        if move_here == 'H':\n            h -= 1\n        else:\n            m -= 1\n        i -= 1\n\n    seq.reverse()\n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 420,
        "completion_token_count": 1192,
        "thoughts_token_count": 8191
    }
}