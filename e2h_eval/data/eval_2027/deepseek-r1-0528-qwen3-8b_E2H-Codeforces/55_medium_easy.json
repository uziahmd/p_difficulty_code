{
    "start": 1758308353.7077618,
    "end": 1758311798.5276856,
    "start-formatted": "2025-09-20 03:59 KST",
    "end-formatted": "2025-09-20 04:56 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. This means that:\n - '0's can be moved arbitrarily (because they can be swapped with '1's, and '1's can be swapped with '2's, so effectively a '0' can pass through a sequence of '1's and '2's until it reaches the front).\n - However, note that we cannot swap '0' and '2' directly. But since we can use '1' as an intermediary, we can think of the relative order of the digits.\n\n Actually, let us consider the allowed swaps: \n   Operation 1: Swap '0' and '1' (adjacent) -> so '0' and '1' can move past each other.\n   Operation 2: Swap '1' and '2' (adjacent) -> so '1' and '2' can move past each other.\n\n Therefore, we can see that:\n   - A '0' can move leftwards until it hits the beginning (because to move left, we can swap with '1' and then if there's a '2' to the left, we can't directly swap with '2', but note: we can move the '0' to the left by swapping with '1's and then we cannot go through a '2' without a '1'? Actually, the presence of '1's allows the '0' to bypass the '2's? \n\n However, note that the allowed swaps only allow adjacent swaps for '01' and '12'. This is similar to having three types of elements with two independent transpositions. In fact, we can model this as having two independent orders:\n\n Observation: The relative order of the three types is constrained: \n   - We can freely rearrange the '0's and '1's arbitrarily (since adjacent swaps of '0' and '1' allow any permutation of zeros and ones). Similarly, we can rearrange the '1's and '2's arbitrarily. But note: the '1's are common in both.\n\n However, we cannot swap '0' and '2' directly, but we can use the '1's as intermediaries. For example, to move a '0' past a '2', we must have a '1' between them? Actually, consider:\n\n   Initially: \"02\" -> not allowed to swap. But if we have \"012\", then:\n        Start: \"012\"\n        Swap the '0' and '1': becomes \"102\"\n        Then swap the '1' and '2': becomes \"120\"\n\n   Now, from \"120\", we can swap the '2' and '0'? No, because the adjacent pairs are '1' and '2' (which we can swap) and then '2' and '0' (which we cannot). But wait, we already moved the '0' to the right? Actually, we wanted to move the '0' to the left. \n\n Alternatively, consider moving the '0' to the left through a '2':\n\n   Example: \"20\" -> cannot swap.\n\n   Example: \"210\": \n        Step1: swap the '1' and '0' (allowed because they are adjacent and form \"10\") -> \"201\"\n        Now, we have \"201\". Then we can swap the '2' and '0'? Not directly. So we cannot move the '0' from the middle to the front in one step? But wait, we can also move the '0' backwards by swapping with the '1' again? Actually, we want to move the '0' to the left.\n\n   Alternatively, let me try to break down the problem:\n\n We note that:\n   - The swaps allowed are only for adjacent pairs that are either ('0','1') or ('1','2').\n   - This means that the relative order of the zeros and ones can be changed arbitrarily (like bubble sort), and similarly for ones and twos. However, the zeros and twos cannot be swapped directly.\n\n Another way: Consider the entire string as composed of three types, and the allowed swaps mean that we can independently sort the zeros and ones, and the ones and twos, but note that the zeros and twos are separated by the ones.\n\n Actually, we can think of the positions of the ones as fixed relative to the zeros and twos, but we can interleave the zeros and twos through the ones. However, we cannot change the relative order of zeros and twos without the ones? \n\n Let me try with a small example: \"02\"\n   We cannot change it.\n\n \"012\":\n   We can do:\n        \"012\" -> swap the '0' and '1' -> \"102\"\n        Then swap the '1' and ' '2' -> \"120\"\n\n   Now, we have \"120\". What if we try to get \"012\" to \"021\"? \n        \"012\" -> swap the '1' and '2' -> \"021\" (allowed because adjacent '1' and '2')\n\n   So actually, we can also swap the '1' and '2' in \"012\" to get \"021\", and then swap the '0' and '2'? No, because \"02\" is not allowed. But wait, after getting \"021\", we can swap the '0' and '2'? No. But note: we can also swap the '0' and '1' in \"021\": \n        \"021\": adjacent pairs are '0' and '2' (not allowed) and '2' and '1' (allowed). So we can swap the '2' and '1' to get \"012\" again? Actually, we don't need to.\n\n   The key is: we can rearrange the entire string by having the following:\n\n   We can independently arrange the zeros and ones, and the ones and twos. But note: the zeros and twos cannot be rearranged arbitrarily without affecting the ones.\n\n   How about thinking of the entire string as having three independent sequences for '0', '1', '2'? Actually, no, because the swaps are adjacent and only for specific pairs.\n\n   Alternate Insight:\n\n   Notice that the allowed swaps generate a partial order on the three letters. Specifically, we can say:\n\n   - '0' < '1' < '2' in terms of movement? Actually, we can move a '0' to the left arbitrarily (by swapping with '1's) and to the right we can't (without '1' to the right). Similarly, a '2' can move to the right arbitrarily (by swapping with '1's) and to the left we can't.\n\n   But wait, we can also move a '1' anywhere because it can swap with both '0' and '2'.\n\n   Therefore, we can consider that:\n\n   - All the zeros can be moved to the very left (if we ignore the ones and twos). Similarly, we can move all the twos to the very right (if we ignore the ones). And the ones will end up in the middle.\n\n   However, note: the movement of zeros to the left: we can pass zeros through ones, but not through twos. Similarly, we can pass twos through ones, but not zeros. \n\n   So the process:\n\n   We can separate the string into three parts: zeros, ones, and twos, but the catch is that we can reorder the zeros and ones arbitrarily, and the ones and twos arbitrarily, but the zeros and twos must maintain their relative order (because we cannot swap them directly, and the ones are used to bypass, but the bypass doesn't change the relative order of zeros and twos).\n\n   Why? Because when we move a zero past a two, we must have a one in between? Actually, we can only move a zero to the left through ones, and a two to the right through ones. But what if we have two zeros and two twos? \n\n   Example: \"0022\" -> we cannot swap zeros and twos. But note, we can use the ones as intermediaries. However, in \"0022\", there are no ones. So we cannot do anything.\n\n   Example with ones: \"001222\"\n\n   We can move the zeros to the left and the twos to the right, and the ones to the middle. But the relative order of zeros and twos must remain the same? \n\n   Let me try: \"02\" -> cannot change.\n   \"012\": We can change the zeros and the twos? Actually, we have one zero and one two. We can form \"012\", \"021\", \"102\", \"120\", \"201\", \"210\"?\n        We did \"012\" -> \"102\", \"120\", \"021\", and \"201\" (from \"210\" we can swap the '1' and '0' to get \"201\"). \n\n   But note: \n        \"012\" -> swap first two: \"102\"\n        \"102\" -> swap last two: \"120\"\n        \"012\" -> swap last two: \"021\"\n\n   How about \"201\": \n        From \"012\", we can also: \n            swap the middle two: \"021\", then swap the first two? But wait, in \"021\", the first two are '0' and '2', which cannot be swapped. So \"021\" is stuck.\n\n   Actually, from \"021\", we can only swap the last two (the '2' and '1') to get \"012\", or from \"012\" we can swap the middle two to get \"021\", and then from \"021\" we can swap the middle two again to get \"012\".\n\n   What about \"210\": \n        We can swap the last two (the '1' and '0') to get \"201\", and then we can swap the first two? They are '2' and '0' -> not allowed.\n\n   So the set of achievable strings from \"012\" (with one '0', one '1', one '2') are: \n        \"012\", \"021\", \"102\", \"120\", \"201\", \"210\"\n\n   But wait, we have 6 permutations. However, note that the relative order of the zeros and twos is preserved? In \"012\", the zero comes before the two. In \"021\", the zero comes before the two. In \"102\", the zero comes before the two. In \"120\", the zero comes before the two. In \"201\", the two comes before the zero! In \"210\", the two comes before the zero.\n\n   So the relative order of zeros and twos is not preserved.\n\n   Then what is the invariant?\n\n   Actually, note that the allowed swaps do not change the relative order of zeros and twos that are separated by ones. But when we have multiple zeros and twos, we can change the relative order of zeros and twos if we have ones to help? \n\n   Let me consider two zeros and one two: \"002\"\n\n   Steps:\n        \"002\": We cannot swap the last two (0 and 2). But we can swap the first two (0 and 0) -> no, because we cannot swap two zeros? Wait, the operation is defined for swapping '0' and '1' or '1' and '2'. So swapping two zeros is not allowed. Similarly, swapping two ones or two twos is not allowed.\n\n   So we can only swap adjacent pairs that are different and in the set {('0','1'), ('1','2')}.\n\n   Now, \"002\": \n        We can swap the first two zeros? No. Then how to move the two to the front? We cannot.\n\n   Similarly, \"020\": \n        Adjacent pairs: [0,2] (not allowed) and [2,0] (not allowed). So we cannot change \"020\".\n\n   Therefore, the relative order of the zeros and twos is not arbitrary. \n\n   Let me reexamine the moves:\n\n   We can view the entire string as being broken by the ones. The zeros and twos are separated by the ones, and within each segment (between ones) we can only move zeros and ones together (but zeros and twos are separated by ones). \n\n   Actually, the key is to note that the swaps are reversible and generate a group. The minimal lexicographical string would be obtained by:\n\n   - Pushing all zeros to the left as much as possible.\n   - Then pushing all ones to the middle as much as possible.\n   - Then pushing all twos to the right.\n\n   But wait, the operations allow zeros and ones to swap, and ones and twos to swap, so zeros and ones can be rearranged arbitrarily, and ones and twos can be rearranged arbitrarily. However, zeros and twos cannot be rearranged arbitrarily.\n\n   Actually, we can consider that the zeros and twos must preserve their relative order. Why?\n\n   Consider two characters: if we have a '0' and then a '2', then we can never put the '2' before the '0' because to do that we would have to swap the '0' and the '2', which is not allowed, and we cannot bypass the '2' by going around because the '0' can only move through ones, and the '2' can only move through ones, but when they meet without a one, they are stuck.\n\n   However, note the example above: \"012\" -> \"201\" (which has the two before the zero). So what happened? \n\n   Actually, in \"012\", the zero and two are separated by a one. We were able to use the one to swap the zero to the right of the one and then the two to the left of the one? \n\n   But wait, in \"012\" we did:\n        Step1: swap '0' and '1' -> \"102\"\n        Step2: swap '1' and '2' -> \"120\"\n\n   But note: in \"120\", the zero is at the end, and the two is at the middle. The two is now after the one and before the zero. \n\n   However, the original string was \"012\": the two was at the end. After two swaps, we put the two in the middle and the zero at the end.\n\n   Now, the relative order of the two zeros and twos: originally the zero was at index0 and the two at index2. Then we ended up with the two at index1 and the zero at index2. So the two passed the zero? \n\n   But note: we did not have the two and zero adjacent until the second swap. In the intermediate state \"102\", the two was at index2 and the zero at index1 (so the zero was between the one and the two). Then we swapped the one and the two, putting the two at index1 and the one at index2. Then the zero remains at index1? Actually, no: \"102\" becomes \"120\" by swapping the adjacent pair at indices1 and2: the '0' and '2' are swapped? Wait, no: the operation is defined for swapping '1' and '2'. In \"102\", the adjacent pairs are: \n        index0: '1', index1: '0' -> this is not a '1' and '2', so we cannot swap the first two. But we can swap the last two: the '0' and '2' are not allowed. \n\n   Wait, I made a mistake: the operation is defined for adjacent pairs that are either \"01\" or \"12\". In \"102\", we have:\n        [1,0] -> this is \"10\", which is the reverse of \"01\", but the operation allows swapping \"01\" to \"10\" and vice versa. So yes, we can swap \"10\" (which is the same as swapping '1' and '0')? Actually, the problem says: swap \"01\" with \"10\" or vice versa. So indeed, swapping \"10\" is the same as swapping \"01\" (it's an adjacent swap of '0' and '1'). \n\n   But wait, the problem says: \"any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa)\". So swapping \"10\" is allowed because it is the vice versa of \"01\". So the operation is symmetric for '0' and '1'. Similarly, for '1' and '2'.\n\n   Therefore, in \"102\", we can swap the first two (which are '1' and '0') to become \"012\", and we can swap the last two (which are '0' and '2')? No, because the last two are '0' and '2', which is not one of the allowed pairs (only '0' and '1', or '1' and '2').\n\n   Correction: the operation is only for adjacent pairs that are either \"01\" or \"12\". So in \"102\", we can only swap the first two (because they are \"10\", which is allowed) and we can swap the last two if they were \"12\" or \"21\", but they are \"02\", which is not allowed.\n\n   So the correct steps for \"012\" are:\n        Option1: swap the first two (0 and 1) -> \"102\"\n        Then from \"102\", we can only swap the first two again (to get \"012\") or ... wait, from \"102\", the adjacent pairs are:\n            [1,0] -> allowed (swap to get \"012\")\n            [0,2] -> not allowed.\n\n        Option2: from \"012\", swap the last two (1 and 2) -> \"021\"\n\n        Then from \"021\", we can swap the last two (2 and 1) -> \"012\", or swap the first two? The first two are \"02\", not allowed.\n\n        Option3: from \"012\", we can do two swaps: first swap the last two to get \"021\", then we cannot swap the first two. So we are stuck with \"021\".\n\n        Then how did I get \"120\" earlier? I thought: \n            \"012\" -> swap first two -> \"102\", then swap the last two? But wait, in \"102\", the last two are \"02\", which is not allowed.\n\n   So actually, from \"102\", we cannot swap the last two. Then how do we get \"120\"?\n\n   Let me check: \n        \"012\" -> swap first two: \"102\"\n        Then, in \"102\", we have two adjacent pairs: \n            [1,0] and [0,2]. \n        We can only swap the first pair (because the second is not allowed). So we cannot get \"120\".\n\n   Then how did the example output say that we can get \"120\"?\n\n   Example input: \"010210\" can be transformed to \"010201\", etc.\n\n   But note the example transformation: \n        \"010210\" -> \"100210\" (swapped the first two: \"01\" to \"10\")\n        Then \"010210\" -> \"001210\" (swapped the second and third: \"10\" to \"01\" -> wait, no: the second and third in \"010210\" are '1' and '0', so swapping gives \"001210\")\n        Then \"010210\" -> \"010120\" (swapped the fourth and fifth: \"21\" to \"12\") -> allowed because it's '1' and '2'\n\n   So we are allowed to swap any adjacent pair that is \"01\" or \"12\", regardless of the order (so \"10\" and \"21\" are the results, but the operation is defined for the two-character set).\n\n   Now, back to \"012\": \n        We can do:\n            Swap the first two (0 and 1) to get \"102\".\n            Then, in \"102\", we can swap the last two? The last two are \"02\" -> not allowed. \n        Alternatively, we can swap the last two (1 and 2) first: \n            \"012\" -> swap the last two (which is \"12\") to get \"021\".\n            Then, in \"021\", we can swap the last two? They are \"21\" -> allowed, so swap to get \"012\" again.\n            Or we can swap the first two? They are \"02\", not allowed.\n\n        Another possibility: \n            \"012\" -> swap the first two to get \"102\", then from \"102\", we cannot swap the last two, but wait, is there another swap? \n\n        Actually, we can also swap the same pair again? \n\n   But wait, there's a third possibility: we can swap the first two again to get back to \"012\", or we can consider a different path.\n\n   Alternatively, note that we can do:\n\n        \"012\" -> swap the first two: \"102\"\n        Then, we cannot swap the last two. But then we can swap the first two again: \"012\".\n\n        Or, we can do:\n\n        \"012\" -> swap the last two: \"021\"\n        Then, we can swap the first two? No, because \"02\" is not allowed.\n\n        So the only achievable strings from \"012\" are \"012\" and \"021\".\n\n   But wait, the example output for the sample input includes:\n\n        Input: ['100210', '11222121', '20']\n\n        Output: ['001120', '11112222', '20']\n\n   So for the first sample, the input is \"100210\", and the output is \"001120\".\n\n   How do we get \"001120\" from \"100210\"?\n\n        Original: \"100210\"\n\n        We want to push zeros to the front. There are three zeros.\n\n        Steps (one way):\n            Start: \"100210\"\n            Swap the first two: \"10\" -> \"01\": becomes \"010210\"\n            Then, swap the next two: \"10\" -> \"01\": becomes \"001210\"\n            Then, swap the next two: \"21\" -> \"12\": becomes \"001120\"\n\n        So we did three swaps: two swaps of \"10\" to \"01\", and one swap of \"21\" to \"12\".\n\n        Now, why did we not get stuck with a '0' and a '2' adjacent? Because we avoided making \"02\" adjacent until the last step? Actually, we never had a \"02\" adjacent until the last swap? \n\n        In \"001210\", the adjacent pairs are:\n            \"00\", \"01\", \"12\", \"21\", \"10\"\n\n        We swapped the \"21\" (at positions 3 and4) to \"12\", so the string becomes \"001120\".\n\n        Now, the resulting string is \"001120\", which is lexicographically smaller than the original \"100210\".\n\n        How about the relative order of zeros and twos? \n\n        In the original string \"100210\", the zeros are at indices 1,2,5 and the two is at index3.\n        In the result \"001120\", the zeros are at indices0,1,4 and the two is at index3.\n\n        The two moved from index3 to index3? Actually, no: in the original, the two was at index3, and in the result, the two is at index3? Let me write:\n\n        Original: \n            index0: '1'\n            index1: '0'\n            index2: '0'\n            index3: '2'\n            index4: '1'\n            index5: '0'\n\n        Result:\n            index0: '0'\n            index1: '0'\n            index2: '1'\n            index3: '1'\n            index4: '2'\n            index5: '0'\n\n        So the two moved from index3 to index4. \n\n        But note: we did a swap of \"21\" to \"12\", so the two moved one position to the right. However, we also moved zeros to the left.\n\n        The key is: we can use the ones to help move zeros to the left and twos to the right.\n\n        Algorithm:\n\n        We can note that the zeros can be moved to the left arbitrarily (by swapping with ones and zeros can also be swapped with ones, but zeros cannot be swapped with twos). Similarly, the twos can be moved to the right arbitrarily (by swapping with ones). The ones can be moved arbitrarily (because they can swap with zeros and twos).\n\n        However, the relative order of zeros and twos is not fixed? \n\n        In the example, the two moved from index3 to index4, meaning that a zero that was originally at index5 (after the two) moved to index5 in the result, but the two moved forward? Actually, the two moved from index3 to index4, and the zero at index5 remained. But wait, the zeros at indices1 and2 were moved to the front, and the zero at index5 was moved to the back.\n\n        What is the invariant?\n\n        Actually, consider the positions of zeros and twos: \n            We can move zeros to the left and twos to the right, and the ones fill the gaps. \n\n        But note: when we move a zero to the left, we are effectively taking zeros that are behind a two and moving them to the left, while the two remains. Similarly, we can move zeros that are in front of a two to the left, and that two then moves right relative to the zeros.\n\n        However, we cannot change the relative order of two zeros, nor the relative order of two twos, nor the relative order of a zero and a two that are separated by ones? \n\n        But wait, in the example, we moved a zero that was after a two (the last zero) to the front, and the two moved to the middle. That changed the relative order of the two and the last zero.\n\n        So what is the invariant?\n\n        After careful thought, note that:\n\n        The allowed swaps are equivalent to being able to independently sort the zeros and ones, and the ones and twos. But the zeros and twos are not directly comparable. However, the entire string can be seen as a sequence where we can rearrange the zeros arbitrarily among themselves (they are identical) and similarly the ones and twos. But the zeros and twos can be interleaved arbitrarily by the ones.\n\n        Actually, we can consider the following:\n\n        We can break the string into segments of consecutive zeros, ones, and twos, but the key is that we can push zeros to the left and twos to the right, and the ones can be placed arbitrarily.\n\n        However, we cannot change the relative order of zeros and twos that are separated by ones? \n\n        But wait, we did change the relative order of the two and the last zero. In the original, the last zero was at index5 and the two at index3 -> so the two was before the zero. In the result, the two is at index4 and the zero at index5 -> still the two is before the zero. \n\n        Actually, the relative order of the two and the last zero was already two then zero, and we kept that.\n\n        What if we have two zeros and one two, and the zeros are on both sides of the two? \n\n        Example: \"020\"\n\n        We cannot change it. So the two is between two zeros, and we cannot move the two to the left or the zeros to the right of the two.\n\n        What if we have \"002\" (two zeros then a two)? \n            We can move the two to the right? \n                \"002\" -> cannot swap the last two (0 and 2) -> so we cannot move the two to the right.\n\n        What if we have \"200\" (two then two zeros)? \n            We can move the two to the left? \n                \"200\": swap the first two? \"20\" -> not allowed.\n\n        What if we have \"02\" (zero then two)? \n            We cannot swap.\n\n        What if we have \"20\" (two then zero)? \n            We cannot swap.\n\n        What if we have \"0022\" (two zeros then two twos)? \n            We cannot swap any adjacent pair because the adjacent pairs are \"00\" (not allowed), \"02\" (not allowed), and \"22\" (not allowed). So we cannot change.\n\n        Therefore, the invariant is: the relative order of the zeros and twos (ignoring the ones) must remain the same? \n\n        Actually, consider: \n            Original: \"02\" -> cannot change.\n            Original: \"20\" -> cannot change.\n\n        But wait, we saw that in \"012\", we could change the relative order of the zero and the two? Actually, no: in \"012\", the zero was originally at the beginning and the two at the end. We could only achieve \"012\" and \"021\", which are the same relative order (zero before two) and the reversed (two before zero) respectively. \n\n        But wait, we achieved \"021\" which has the two before the zero. So the relative order changed.\n\n        However, note that in \"012\", the two was originally after the zero. Then we got \"021\", where the two is before the zero. So we did change the relative order.\n\n        But wait, in the example \"010210\", we changed the relative order of the two and the last zero (which was originally after the two) to keep the two before the zero.\n\n        What is the difference?\n\n        In \"012\", the zero and the two are separated by a one. In \"010210\", the two is followed by a one and then a zero. \n\n        The rule: we can swap zeros with ones and ones with twos, but we cannot swap zeros with twos.\n\n        This means that the zeros and twos can only be rearranged if they are separated by ones. Specifically, we can move a zero to the left across a one, and a two to the right across a one, and these movements can be done independently.\n\n        Therefore, the minimal lexicographical string is obtained by:\n\n          - Collecting all the zeros and putting them at the beginning (as far left as possible)\n          - Then, putting the ones (but wait, we can also move the ones arbitrarily)\n          - Then, putting the twos at the end.\n\n        However, we cannot change the relative order of the zeros and twos arbitrarily. Specifically, the relative order of the zeros and twos (when ignoring the ones) must be the same as in the original string.\n\n        But wait, in \"012\", the original relative order (ignoring ones) is: [0,2] -> so we should be able to have zeros at the beginning and twos at the end. But we did get \"012\" and \"021\". In \"012\", the two is at the end, and in \"021\", the two is in the middle and the zero is at the end. \n\n        However, the relative order of the zeros and twos (ignoring ones) is not well-defined if there are multiple. \n\n        Actually, we can consider the entire string and remove the ones. Then the remaining sequence of zeros and twos must be a subsequence of the original string (in the same order). \n\n        Example \"012\": removing ones -> \"02\", so the subsequence must be \"02\" (meaning zero then two) or \"20\"? \n\n        But wait, we achieved \"021\", which has the two then the zero. \n\n        However, note: the removal of ones does not necessarily give the relative order of zeros and twos. \n\n        Let me define: the relative order of zeros and twos is the order in which they appear, ignoring ones. \n\n        In \"012\": \n            Without ones: [0,2] -> so the zeros come before the twos.\n        In \"021\":\n            Without ones: [0,2] -> but wait, in \"021\", the two is at index1 and the zero at index2, so the zero comes after the two. \n\n        Actually, when we remove ones, we get the sequence of non-one characters. In \"021\", removing the one leaves \"02\", but wait, the one is in the middle? \n\n        We have to be careful: the relative order of the zeros and twos is defined by their original positions. \n\n        In the original string \"012\", the zero is at position0 and the two at position2, so the zero comes before the two.\n\n        In the string \"021\", the zero is at position2 and the two at position1, so the two comes before the zero.\n\n        But wait, the operation allowed us to change the relative order. \n\n        Therefore, the invariant is not the relative order of zeros and twos ignoring the ones. \n\n        Another idea: \n\n        Since we can swap zeros with ones and ones with twos, we can think of the string as having three independent runs (for zeros, ones, and twos) but the catch is that the ones can be used to separate zeros and twos arbitrarily.\n\n        Actually, the minimal lexicographical string is the one with all zeros at the beginning, then all ones, then all twos? \n\n        But wait, we cannot necessarily put all ones in the middle because we might have a zero that is after a one and then a two, and we can move the zero to the front and the two to the back, but we cannot change the relative order of the zeros and twos that are separated by ones.\n\n        However, consider the following: \n\n        We can simulate the process by:\n\n          We know that a zero can be moved to the left until it hits the beginning or a two (because we cannot swap zero and two). Similarly, a two can be moved to the right until it hits the end or a zero.\n\n        But note: we can move zeros through ones and twos through ones. \n\n        Therefore, the minimal string is obtained by:\n\n          - Moving all zeros to the left (each zero can move left until it encounters a two that is not preceded by a one that would block it? Actually, no: the two can be bypassed if there's a one in between? \n\n        Actually, we can use the ones to move zeros and twos arbitrarily, so the only constraint is the relative order of zeros and twos that are adjacent or separated by ones. \n\n        After reading a known solution for similar problems (e.g., CodeForces problems involving adjacent swaps with restrictions), we can solve this by:\n\n          We can use a greedy algorithm: \n\n          We know that the final string must have the following property: \n\n          - All zeros must appear before any two, or not? \n\n        But wait, we can achieve \"021\" from \"012\", which has a two before a zero. \n\n        However, note that in \"021\", the two is not at the very beginning; there's a zero at the end. \n\n        The minimal lexicographical string is the smallest string in dictionary order.\n\n        Lexicographical order: \n          '0' < '1' < '2'\n\n        Therefore, we want to push zeros to the front, then ones, then twos.\n\n        But is that always possible? \n\n        Example: \"012\" -> we can get \"012\" (which is zeros then ones then twos) and \"021\" (zeros then twos then ones) and \"102\" (ones then zeros then twos) and \"120\" (ones then twos then zeros) and \"201\" (twos then zeros then ones) and \"210\" (twos then ones then zeros).\n\n        The lexicographically smallest is \"012\".\n\n        But wait, in the sample input \"100210\", the output is \"001120\", which is:\n\n            '0','0','1','1','2','0'\n\n        This is not zeros then ones then twos. It has a '0' at the end.\n\n        However, \"001120\" is lexicographically smaller than \"000112\" (which would be zeros then ones then twos) because:\n\n            Compare:\n                \"001120\" and \"000112",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing a series of adjacent swaps on a ternary string consisting of characters '0', '1', and '2'. The allowed swaps are between '0' and '1' (adjacent) or '1' and '2' (adjacent). \n\n### Approach\n1. **Problem Analysis**: The key observation here is that '0's can be moved to the leftmost positions by swapping with '1's, and '2's can be moved to the rightmost positions by swapping with '1's. The '1's can be used as intermediaries to facilitate the movement of '0's and '2's. However, '0's and '2's cannot be swapped directly unless separated by '1's.\n2. **Insight**: The minimal lexicographical string is achieved by placing all '0's first, followed by '1's, and then '2's. However, since '0's and '2's can only be moved through '1's, their relative order when separated by '1's can be adjusted. Specifically, '0's should appear before '2's in the final string if they originally were separated by '1's.\n3. **Algorithm Selection**: We can use a greedy approach where we iterate through the string and collect all '0's and '1's into a separate list. The '2's are placed after all '0's and '1's. This ensures that all '0's come before any '2's in the final string, which is crucial for achieving the lexicographically smallest string.\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    zeros_ones = []\n    twos_count = 0\n    result = []\n    \n    for char in s:\n        if char == '0' or char == '1':\n            zeros_ones.append(char)\n        else:  # char is '2'\n            twos_count += 1\n            \n    zeros_ones.sort()\n    result = zeros_ones + ['2'] * twos_count\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input string is read from standard input.\n2. **Separating Characters**: The string is processed to separate '0's and '1's into a list (`zeros_ones`) and count the number of '2's (`twos_count`).\n3. **Sorting**: The list `zeros_ones` is sorted to ensure all '0's come before '1's. This sorted list is then combined with the counted '2's to form the result string.\n4. **Output**: The resulting string is printed, which is the lexicographically smallest string achievable by the allowed swaps.\n\nThis approach efficiently leverages the allowed swaps to position '0's and '1's optimally, ensuring the smallest lexicographical order by placing all '0's before '1's and all '1's before '2's, while respecting the constraints of the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    zeros_ones = []\n    twos_count = 0\n    result = []\n    \n    for char in s:\n        if char == '0' or char == '1':\n            zeros_ones.append(char)\n        else:  # char is '2'\n            twos_count += 1\n            \n    zeros_ones.sort()\n    result = zeros_ones + ['2'] * twos_count\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 588,
        "completion_token_count": 646,
        "thoughts_token_count": 8191
    }
}