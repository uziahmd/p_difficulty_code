{
    "start": 1758088079.4222686,
    "end": 1758089241.2047722,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (l, r, cost)\n We need two vouchers i and j such that:\n   (1) They don't intersect: either r_i < l_j or r_j < l_i.\n   (2) The sum of their durations is exactly x: (r_i - l_i + 1) + (r_j - l_j + 1) = x.\n\n Let d_i = r_i - l_i + 1 (duration of voucher i)\n\n Then we require d_i + d_j = x.\n\n We want to minimize cost_i + cost_j.\n\n Approach:\n\n Since the total duration is fixed (x), for each voucher i with duration d_i, we are looking for a voucher j with duration d_j = x - d_i.\n\n However, the condition of non-intersection must hold. Moreover, the two vouchers must be disjoint.\n\n Conditions for non-intersection: \n   Condition 1: voucher i ends before voucher j starts: r_i < l_j.\n   Condition 2: voucher j ends before voucher i starts: r_j < l_i.\n\n So we can precompute two arrays (or dictionaries) for all vouchers:\n\n   For a given duration d, we want to store information about the vouchers that have duration d, but we also need to know their time intervals (l and r).\n\n But note: the problem constraints: \n   n, x, and the days (l and r) up to 200000.\n\n Steps:\n\n 1. Group vouchers by their duration. Since the duration d can be at most 200000, we can use an array (or dictionary) for durations from 1 to max_d (which is <= 200000).\n\n 2. For each duration d, we have a list of vouchers (each voucher is (l, r, cost)). But we don't need all, because we are going to look for pairs (d, x-d). \n\n 3. However, we cannot iterate over all pairs because n can be up to 200000 and the number of distinct durations might be large.\n\n Alternative idea:\n\n We are only interested in pairs (i, j) such that d_i + d_j = x.\n\n For each voucher i (with duration d_i), we consider j with duration d_j = x - d_i.\n\n But how to check the non-intersection condition quickly?\n\n We can break the problem into two parts:\n\n   a. Precompute for each duration d, a sorted list of the vouchers by their starting day (or ending day) and also keep track of the minimum cost for a given interval? \n\n However, note: the non-intersection condition requires one of two things:\n\n   Option 1: i ends before j starts -> r_i < l_j.\n   Option 2: j ends before i starts -> r_j < l_i.\n\n So for a fixed pair (i, j) with d_i and d_j = x-d_i, we need to check either r_i < l_j or r_j < l_i.\n\n We can try to preprocess for each duration d:\n\n   Let's create two arrays for each duration d:\n\n     - One sorted by l (start) and store (l, r, cost) and we might want to know the minimal cost for a voucher with a given start and end?\n     - Similarly, sorted by r (end) ?\n\n But note: the two conditions are symmetric. We can also consider storing:\n\n   For a given duration d, we can store:\n        list1: sorted by l (start day) and then we can get the minimal cost for any voucher in this list with l <= some value? Actually, for condition 1: we require r_i < l_j. So if we fix a voucher i (with duration d_i) and we are looking for a voucher j (with duration d_j = x-d_i) such that l_j > r_i, then we want the minimal cost among all j with duration d_j and l_j > r_i.\n\n   Similarly, for condition 2: we require r_j < l_i. Then for a fixed j (with duration d_j) we look for i (with duration d_i) such that r_j < l_i.\n\n But wait, we are going to consider pairs (i, j) and (j, i) as the same? Actually, the two conditions are independent and we must consider both. However, note that if we consider i and j, then condition 1 and condition 2 are two different ways the two vouchers can be disjoint.\n\n However, note: the two conditions are not symmetric in terms of which voucher is which. But we can structure the solution to consider each unordered pair once.\n\n Alternatively, we can do:\n\n   For each duration d, we store two things:\n\n     A: A list of all vouchers (l, r, cost) with duration d.\n\n   Then,",
    "response": "\nTo solve this problem, we need to find two non-intersecting travel vouchers such that the sum of their durations equals exactly `x` and their combined cost is minimized. The solution involves efficiently grouping and querying vouchers based on their durations and intervals.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration (i.e., `r_i - l_i + 1`). This allows us to quickly access all vouchers that can potentially form a pair with a given duration.\n2. **Precompute Minimum Costs**: For each duration, we precompute two sorted lists:\n   - **By Start Day (`l_i`)**: A list of vouchers sorted by their start day, along with the minimum cost encountered up to each start day.\n   - **By End Day (`r_i`)**: A list of vouchers sorted by their end day, along with the minimum cost encountered up to each end day.\n3. **Query for Valid Pairs**: For each voucher, we determine the complementary duration (`x - d_i`). Using the precomputed lists, we then check if there exists a voucher with the complementary duration that does not intersect with the current voucher. This is done by leveraging binary search on the sorted lists to find the minimal cost voucher that meets the non-intersection condition.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    max_day = 200000\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        \n    max_d = 200000\n    by_duration = [None] * (max_d + 1)\n    \n    for dur in range(1, max_d + 1):\n        by_duration[dur] = []\n        \n    for (l, r, cost_val) in vouchers:\n        dur = r - l + 1\n        if dur <= max_d:\n            by_duration[dur].append((l, r, cost_val))\n            \n    def build_lists(vouchers_list):\n        starts = []\n        ends = []\n        for (l, r, cost_val) in vouchers_list:\n            starts.append((l, cost_val))\n            ends.append((r, cost_val))\n        starts.sort(key=lambda x: x[0])\n        ends.sort(key=lambda x: x[0])\n        min_costs_start = []\n        min_costs_end = []\n        cur_min = float('inf')\n        for s in starts:\n            if s[1] < cur_min:\n                cur_min = s[1]\n            min_costs_start.append((s[0], cur_min))\n        cur_min = float('inf')\n        for e in ends:\n            if e[1] < cur_min:\n                cur_min = e[1]\n            min_costs_end.append((e[0], cur_min))\n        return starts, min_costs_start, ends, min_costs_end\n    \n    def get_min_cost_by_duration(dur, side):\n        if dur > max_d or dur < 1 or by_duration[dur] is None or len(by_duration[dur]) == 0:\n            return None, float('inf')\n        if side == 'start':\n            return build_lists(by_duration[dur])\n        else:\n            return build_lists(by_duration[dur])\n    \n    def query_complementary(dur, bound, side):\n        if dur < 1 or dur > max_d:\n            return float('inf')\n        comp_dur = x - dur\n        if comp_dur < 1 or comp_dur > max_d:\n            return float('inf')\n        if by_duration[comp_dur] is None or len(by_duration[comp_dur]) == 0:\n            return float('inf')\n        starts, min_start, ends, min_end = build_lists(by_duration[comp_dur])\n        ans = float('inf')\n        if side == 'start':\n            pos = bisect.bisect_right(min_start, (bound, float('inf')))\n            if pos > 0:\n                candidate_l, candidate_cost = min_start[pos-1]\n                if candidate_cost < ans:\n                    ans = candidate_cost\n            return ans\n        elif side == 'end':\n            pos = bisect.bisect_left(min_end, (bound, float('inf')))\n            if pos < len(min_end):\n                candidate_r, candidate_cost = min_end[pos]\n                if candidate_cost < ans:\n                    ans = candidate_cost\n            return ans\n        \n    best = float('inf')\n    \n    for (l, r, cost_val) in vouchers:\n        dur = r - l + 1\n        if dur >= x:\n            continue\n        comp_dur = x - dur\n        if comp_dur < 1:\n            continue\n            \n        cand1 = query_complementary(dur, r, 'start')\n        cand2 = query_complementary(dur, l, 'end')\n        total = cost_val + cand1 if cand1 != float('inf') else float('inf')\n        total2 = cost_val + cand2 if cand2 != float('inf') else float('inf')\n        if total < best:\n            best = total\n        if total2 < best:\n            best = total2\n            \n    if best == float('inf'):\n        print(-1)\n    else:\n        print(best)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into a list of tuples, each representing a voucher's start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped into an array where each index corresponds to a duration, holding all vouchers of that duration.\n3. **Building Sorted Lists**: For each duration, we create two sorted lists: one sorted by start day and another by end day. These lists also keep track of the minimum cost up to each day to facilitate quick queries.\n4. **Querying Complementary Vouchers**: For each voucher, we determine the complementary duration (`x - current_duration`). Using binary search on the precomputed lists, we find the cheapest voucher that does not intersect with the current voucher (either ending before it starts or starting after it ends).\n5. **Result Calculation**: The minimal total cost of valid pairs is tracked and printed. If no valid pair is found, `-1` is printed.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    max_day = 200000\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        \n    max_d = 200000\n    by_duration = [None] * (max_d + 1)\n    \n    for dur in range(1, max_d + 1):\n        by_duration[dur] = []\n        \n    for (l, r, cost_val) in vouchers:\n        dur = r - l + 1\n        if dur <= max_d:\n            by_duration[dur].append((l, r, cost_val))\n            \n    def build_lists(vouchers_list):\n        starts = []\n        ends = []\n        for (l, r, cost_val) in vouchers_list:\n            starts.append((l, cost_val))\n            ends.append((r, cost_val))\n        starts.sort(key=lambda x: x[0])\n        ends.sort(key=lambda x: x[0])\n        min_costs_start = []\n        min_costs_end = []\n        cur_min = float('inf')\n        for s in starts:\n            if s[1] < cur_min:\n                cur_min = s[1]\n            min_costs_start.append((s[0], cur_min))\n        cur_min = float('inf')\n        for e in ends:\n            if e[1] < cur_min:\n                cur_min = e[1]\n            min_costs_end.append((e[0], cur_min))\n        return starts, min_costs_start, ends, min_costs_end\n    \n    def get_min_cost_by_duration(dur, side):\n        if dur > max_d or dur < 1 or by_duration[dur] is None or len(by_duration[dur]) == 0:\n            return None, float('inf')\n        if side == 'start':\n            return build_lists(by_duration[dur])\n        else:\n            return build_lists(by_duration[dur])\n    \n    def query_complementary(dur, bound, side):\n        if dur < 1 or dur > max_d:\n            return float('inf')\n        comp_dur = x - dur\n        if comp_dur < 1 or comp_dur > max_d:\n            return float('inf')\n        if by_duration[comp_dur] is None or len(by_duration[comp_dur]) == 0:\n            return float('inf')\n        starts, min_start, ends, min_end = build_lists(by_duration[comp_dur])\n        ans = float('inf')\n        if side == 'start':\n            pos = bisect.bisect_right(min_start, (bound, float('inf')))\n            if pos > 0:\n                candidate_l, candidate_cost = min_start[pos-1]\n                if candidate_cost < ans:\n                    ans = candidate_cost\n            return ans\n        elif side == 'end':\n            pos = bisect.bisect_left(min_end, (bound, float('inf')))\n            if pos < len(min_end):\n                candidate_r, candidate_cost = min_end[pos]\n                if candidate_cost < ans:\n                    ans = candidate_cost\n            return ans\n        \n    best = float('inf')\n    \n    for (l, r, cost_val) in vouchers:\n        dur = r - l + 1\n        if dur >= x:\n            continue\n        comp_dur = x - dur\n        if comp_dur < 1:\n            continue\n            \n        cand1 = query_complementary(dur, r, 'start')\n        cand2 = query_complementary(dur, l, 'end')\n        total = cost_val + cand1 if cand1 != float('inf') else float('inf')\n        total2 = cost_val + cand2 if cand2 != float('inf') else float('inf')\n        if total < best:\n            best = total\n        if total2 < best:\n            best = total2\n            \n    if best == float('inf'):\n        print(-1)\n    else:\n        print(best)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1414,
        "thoughts_token_count": 1023
    }
}