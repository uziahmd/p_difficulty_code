{
    "start": 1758304286.2466693,
    "end": 1758308202.2187245,
    "start-formatted": "2025-09-20 02:51 KST",
    "end-formatted": "2025-09-20 03:56 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge, we are given two numbers: GCD and LCM of the two adjacent nodes (lawns).\n We know that for two numbers a and b, we have:\n   gcd(a, b) * lcm(a, b) = a * b.\n\n Moreover, from the edge (u, v) with gcd = g and lcm = l, we can deduce that both a and b must be multiples of g, and they must divide l? \n Actually, note: \n   Let a = g * a', b = g * b'. Then we have:\n        lcm(a, b) = g * a' * b' / gcd(a', b') = l.\n   So, a' * b' must be divisible by gcd(a', b') and then multiplied by g gives l.\n\n Alternatively, we can set:\n   a = g * x, b = g * y, and then the condition is that gcd(x, y) must divide (l // g^2) because:\n        lcm(a,b) = g * (x*y) / gcd(x,y) = l  =>  x*y / gcd(x,y) = l // g.\n\n But note: the condition on the edge is that the GCD must be exactly g and the LCM must be exactly l.\n\n However, there is an alternative way: the two numbers must be divisors of the LCM and must have GCD equal to g. Moreover, note that the product of the two numbers must be g * l.\n\n Therefore, for an edge (u, v): \n   Let the numbers at u and v be A and B respectively.\n   Then we have: \n        A * B = g * l   [because gcd(A,B)*lcm(A,B)=A*B]\n   and \n        gcd(A, B) = g.\n\n Also, we know that A and B must be divisors of l (since lcm(A,B)=l, so both A and B must divide l).\n\n Steps:\n\n 1. We are going to try to assign values to each node. We are given constraints from edges.\n\n 2. Note: The problem does not require the unique solution, just any one.\n\n 3. Observation: From an edge (u, v) with (g, l), the two numbers A and B must satisfy:\n        A * B = g * l, and gcd(A, B) = g.\n\n    Then, we can write A = g * a, B = g * b, and then we must have gcd(a, b) = 1, and a*b = l//g (if we assume that g divides l). But note: it must hold that g divides l (because the GCD divides the LCM). \n\n    Conditions for existence of an edge:\n        - g must divide l (otherwise, no solution for that edge).\n        - Then, we can factorize l//g and look for two coprime factors (a, b) such that a*b = l//g. But note: the assignment to A and B must be consistent across the entire graph.\n\n 4. However, the entire graph might have multiple edges and we need to assign one number per node that satisfies all the edges incident to it.\n\n 5. Approach:\n\n    We can use the following:\n\n      For an edge (u, v, g, l):\n          Condition 1: g must divide l, otherwise output \"NO\".\n\n          Then, the two numbers at u and v must be divisors of l (since LCM is l, and the numbers must divide the LCM). Moreover, their product must be g*l and GCD must be g.\n\n    But note: It is also known that the GCD must divide both numbers and the LCM must be divisible by both. The product condition is necessary.\n\n 6. Another observation: Since the product of the two numbers is fixed (g*l) and the GCD is fixed, then the two numbers must be of the form:\n        A = g * a, B = g * b, with a and b coprime and a*b = (l // g)\n\n    However, note that the same node may appear in multiple edges, so the value we assign to a node must satisfy all the edges incident to it.\n\n 7. How to assign?\n\n    We can think of the following:\n\n        Let x_i be the value at node i.\n\n        For each edge (u, v) with (g, l):\n            x_u * x_v = g * l\n            and gcd(x_u, x_v) = g\n\n        This implies that if we let y_u = x_u / g, then for the edge (u, v): \n            y_u * y_v = (l // g) and gcd(y_u, y_v) = 1.\n\n        Then, the entire graph's node values are determined by the base value g (for the edge) but note that different edges incident to the same node might have different g's.\n\n    But wait: the base g for an edge is fixed, but what if the same node appears in two edges with different g's? Then the value assigned to the node must be a multiple of both g's? \n\n    Actually, consider two edges incident to node u: \n        Edge1: (u, v1) -> (g1, l1)\n        Edge2: (u, v2) -> (g2, l2)\n\n    Then, the value x_u must be a multiple of both g1 and g2? Not necessarily, because the GCD for edge1 is g1 and for edge2 is g2. But note, the GCD for edge1 is the GCD of x_u and x_{v1}. Similarly for edge2.\n\n    However, note that the GCD of two numbers is the greatest common divisor. So, the GCD for edge1 is g1, which must divide x_u. Similarly, g2 must divide x_u. Therefore, x_u must be a multiple of the least common multiple (LCM) of all the g's from the edges incident to u? \n\n    But wait: actually, the GCD for an edge (u, v) is the GCD of x_u and x_v. So, for edge (u, v1): g1 = gcd(x_u, x_v1). This does not necessarily imply that g1 divides x_u? Actually, yes, because the GCD divides both numbers.\n\n    Therefore, x_u must be divisible by every g_i for every edge (u, v_i). \n\n    Similarly, x_u must divide the LCM of the entire graph? Actually, for an edge (u, v) with LCM l, then x_u must divide l. But note: the LCM of two numbers is the maximum exponents in prime factorizations. However, the LCM of the entire graph is not necessarily given, but for each edge, the LCM is given.\n\n    However, we can combine the conditions:\n\n        Condition for node u:\n          Let G = LCM{ g_i for every edge incident to u }? Actually, no. The GCDs are for pairs. But note: the value x_u must be divisible by every g_i (from the edges). Why? Because for edge (u, v_i): g_i divides x_u (and x_v_i). So x_u must be divisible by every g_i. Then, x_u must be divisible by the LCM of the g_i's? Actually, no: the condition is that each g_i divides x_u, so x_u must be divisible by the LCM of the set {g_i}? \n\n        Example: if we have two edges from u: (g1, l1) and (g2, l2). Then x_u must be divisible by g1 and by g2. Then x_u must be divisible by LCM(g1, g2). \n\n        Similarly, for each edge (u, v) with (g, l), we have x_u divides l (the LCM of that edge). But note: the LCM of an edge is the LCM of x_u and x_v. So x_u must divide the LCM of the entire graph? Actually, no, because the LCM of the entire graph isn't given. But for each edge, the LCM is given, and x_u must divide the LCM of that edge? Not necessarily: the LCM of the two numbers is the maximum exponents, so x_u must divide the LCM of the two numbers? Actually, yes: because the LCM is a multiple of each number.\n\n        So, for edge (u, v): \n            x_u divides l (the LCM of the edge) and x_v divides l.\n\n    Therefore, we can set:\n\n        Let base[u] = the value x_u (the number of mushrooms at lawn u).\n\n        Steps:\n\n        a) Check for each edge: \n            - g divides l. If not, output \"NO\".\n\n        b) For each node, let G_u = the LCM of all the g's from edges incident to u (but note: the condition is that x_u must be divisible by each g_i, so x_u must be divisible by the LCM of the g_i's? Actually, the LCM is the minimal value that is divisible by all g_i's. So we can set a candidate for x_u as the LCM of all the g_i's from its edges? \n\n        However, we cannot simply set x_u to the LCM of the g_i's because then we have to satisfy the product condition with the neighbors.\n\n    Alternative approach:\n\n        We know that the entire graph must satisfy for each edge (u, v):\n            base[u] * base[v] = g * l\n\n        and base[u] is divisible by g (from the edge) and base[v] is divisible by g.\n\n        Also, base[u] must divide the LCM of the entire graph? Actually, we don't have a global LCM, but per edge.\n\n        We can use the following idea:\n\n          Let d[u] be the value at node u.\n\n          For each edge (u, v, g, l):\n              d[u] * d[v] = g * l\n              and d[u] % g == 0, d[v] % g == 0.\n\n        How about setting:\n\n          Let D = the graph with edges having the product constraint and divisibility constraint.\n\n        Since the product is fixed, we can try to assign the same base value for all nodes? Not necessarily.\n\n        Notice: In fact, we can set:\n\n          Let H = the graph where each edge (u, v) has two numbers: g and l, and we know that d[u] * d[v] = g*l.\n\n        Then, if we let d[u] = k * (some value), then the product condition must hold.\n\n        But note: the product condition is multiplicative, and the divisibility condition is additive (in terms of exponents).\n\n    Another known fact: The numbers d[u] must be divisors of the LCM of all the edges' LCMs? Actually, no.\n\n    However, we can use the following:\n\n        For each node, we can set d[u] to be the product of the g_i's raised to some exponents? \n\n    Alternatively, we can do:\n\n        Step 1: Check for each edge that g divides l. If not, return \"NO\".\n\n        Step 2: For each edge, set the product p = g * l. Then, the two numbers (d[u], d[v]) must be a pair of divisors of p (actually, divisors of l) such that d[u]*d[v]=p and gcd(d[u],d[v])==g.\n\n        But note: the same node might appear in multiple edges, so we have to assign a fixed value for the node.\n\n        How to assign? We can use a BFS/DFS to propagate the value from one node to others.\n\n        Idea:\n\n          We can fix one node arbitrarily. But note: the product condition is multiplicative. \n\n        Let's consider: if we have two edges from a node u: \n            edge1: (u, v1) -> (g1, l1) => d[u] * d[v1] = g1*l1\n            edge2: (u, v2) -> (g2, l2) => d[u] * d[v2] = g2*l2\n\n        Then, d[u] must divide both g1*l1 and g2*l2? Actually, no: d[u] must divide g1*l1 and g2*l2? Not necessarily, because the product condition is multiplicative. But note, d[u] must be a divisor of g1*l1 and also a divisor of g2*l2? \n\n        Actually, from the edge conditions, d[u] must be a divisor of (g1*l1) and (g2*l2) only if the other node's value is an integer? Actually, the product is fixed, so d[u] must be a divisor of g1*l1 and g2*l2? \n\n        However, note: d[u] * d[v1] = g1*l1, so d[u] must divide g1*l1. Similarly, d[u] must divide g2*l2.\n\n        So, d[u] must be a common divisor of g1*l1 and g2*l2.\n\n        But note: we have multiple edges, so we can set d[u] to be the greatest common divisor (GCD) of all the products (g_i * l_i) for edges incident to u? \n\n        Actually, we want d[u] to be a divisor of each g_i * l_i. Then we can set d[u] to be the GCD of all the g_i * l_i for edges incident to u? \n\n        Then, from an edge (u, v) with (g, l), we would set d[v] = (g*l) / d[u]. Then check that d[v] is divisible by g and that gcd(d[u], d[v]) == g.\n\n        However, we have to do this for the entire graph. We can start from an arbitrary node and then propagate the values.\n\n        Steps for propagation:\n\n          Let d[u] = the product of the g_i's? Actually, we have multiple edges.\n\n        Better:\n\n          We can set d[u] = the product of the primes in the entire graph? No.\n\n        Instead, we can use:\n\n          Let d[u] = the GCD of all the products (g_i * l_i) for edges incident to u. Then, for an edge (u, v) with (g, l):\n              d[u] * d[v] = (g*l)   ??? Not necessarily.\n\n        Actually, the product condition must be satisfied for every edge.\n\n        We can do:\n\n          Let d[u] be a divisor that divides every g_i * l_i for edges incident to u. Then, for each edge (u, v) we set d[v] = (g*l) / d[u]. Then, we must check that d[v] is an integer and that d[u] is divisible by g (the edge's GCD) and d[v] is divisible by g, and gcd(d[u], d[v]) == g.\n\n        But note: the same node u might have multiple edges. We need to assign d[u] once.\n\n        Algorithm:\n\n          Step 1: Precompute for each node u, the set S[u] = { g_i * l_i for each edge (u, v_i) }.\n\n          Step 2: Let candidate[u] = GCD of all the products in S[u]. However, is that correct?\n\n          Consider: We require that d[u] divides every g_i * l_i. The GCD of the set S[u] is the largest number that divides every element of S[u]. So candidate[u] = gcd(S[u]) is a candidate.\n\n          Then, for an edge (u, v) with (g, l), we set d[v] = (g*l) / candidate[u]. Then, we must check:\n\n            - candidate[u] divides g*l (which is true because candidate[u] is a divisor of g*l from the set S[u] and g*l is one of the products? Actually, no: the set S[u] contains the products for edges incident to u, and the edge (u,v) is one of them, so candidate[u] divides g*l.\n\n          However, we have to assign d[u] and then use it to assign d[v]. But the same node u is used in multiple edges. We must assign d[u] first.\n\n        But note: the graph might be disconnected. We should process connected components.\n\n        Steps:\n\n          - Build the graph.\n\n          - For each node u, collect the products from all edges incident to u (call this list P[u]).\n\n          - Then, set d[u] = gcd(P[u]) (if P[u] is non-empty). If P[u] is empty, then we have no constraint, so we can set d[u] arbitrarily (say 1).\n\n          - Then, traverse the graph (BFS/DFS) and for each edge (u, v) with (g, l):\n\n                expected_d_v = (g*l) / d[u]\n\n                But wait: from the edge (u, v), we also have d[u] * d[v] = g*l, so d[v] = (g*l) / d[u] must be an integer.\n\n                Then, we set d[v] = expected_d_v.\n\n          - However, we must ensure that the value we set for d[v] is consistent with the constraints from other edges incident to v.\n\n          - Additionally, we must check for each edge (u, v) that:\n                d[u] % g == 0, d[v] % g == 0, and gcd(d[u], d[v]) == g.\n\n          - Also, note: if we set d[u] = gcd(P[u]), then we must ensure that d[u] divides g*l for every edge (u, v) (which it does, because P[u] includes g*l for edge (u, v)).\n\n        But wait: what if the graph is not connected? Then we have multiple components. We can assign independently.\n\n        However, there is a catch: the candidate d[u] = gcd(P[u]) might not be the only candidate. There could be multiple divisors. But we choose the gcd of all the products. \n\n        Why is that valid? Because we require d[u] to be a common divisor of all the products (so that when we use d[u] to compute d[v] for every neighbor, the result is an integer). The GCD is the maximal such divisor, but we could choose any common divisor. However, we choose the maximal one to minimize the chance of fractional d[v]? \n\n        But note: the product condition requires that d[u] * d[v] = g*l. So if we choose a smaller divisor, then d[v] becomes larger. However, we must also satisfy that d[u] is divisible by g (the edge's GCD) and d[v] is divisible by g.\n\n        Let me test with the example: \n            Input: \"2 1\\n1 2 1 3\"\n\n            Nodes: 2, m=1, edge (1,2) with g=1, l=3.\n\n            For node1: P[1] = [1*3] = [3] -> candidate d[1] = 3.\n            Then, d[2] = (1*3)/3 = 1.\n\n            Now, check edge (1,2): \n                d[1]=3, d[2]=1.\n                GCD(3,1)=1 -> matches g=1.\n                LCM(3,1)=3 -> matches l=3.\n\n            Output: [3, 1] -> but the example output is \"YES\\n1 3\" or \"YES\\n3 1\"? \n\n            Example output: \"YES\\n1 3\"\n\n            So they assigned node1=1, node2=3.\n\n            Why did we get the opposite? Because we set node1 to the candidate and then node2 is computed. \n\n            Actually, the problem does not specify which node gets which value. So we can assign arbitrarily. \n\n            But note: the example output is \"1 3\", meaning node1=1, node2=3.\n\n            How can we achieve that?\n\n            Alternatively, we can set the candidate for a node as the GCD of the products, but then we have two possibilities: we can swap the assignment? \n\n            However, note: the product condition is symmetric: d[u]*d[v]=g*l. So if we assign d[u] = candidate and d[v] = (g*l)/candidate, then the roles are fixed.\n\n            But why did the example output assign node1=1 and node2=3? \n\n            In our method, we set node1 to 3 and node2 to 1. That is a valid assignment. But the problem says \"any one\". \n\n            However, the example output is \"1 3\", so we must output the same as the example? \n\n            The problem says: \"If the answer is 'YES', print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\"\n\n            So we can output either [3,1] or [1,3] as long as it satisfies the conditions.\n\n            But wait: the example input was \"2 1\\n1 2 1 3\", and the output was \"YES\\n1 3\".\n\n            Our method produced [3,1] for nodes 1 and 2. But the problem indexes the lawns from 1 to n. \n\n            The example input says: \n                \"2 1\"\n                \"1 2 1 3\"\n\n            So node1 and node2. \n\n            Our output would be: \n                \"YES\"\n                \"3 1\"\n\n            But the example output is \"1 3\". \n\n            However, the problem does not specify the order of the nodes. The output should be n numbers for the corresponding lawns. The lawns are numbered 1 to n. \n\n            The input order of the nodes: the first lawn is node1, second node2.\n\n            So we must output the value for node1 first, then node2.\n\n            In the example, the input edge is between node1 and node2. \n\n            Our assignment: \n                node1: 3, node2: 1.\n\n            But the example output is node1:1, node2:3.\n\n            Why is that acceptable? Because the edge condition is symmetric: \n                For edge (1,2): \n                    With (1,3): \n                        If node1=1, node2=3: \n                            GCD(1,3)=1, LCM(1,3)=3 -> matches.\n                        If node1=3, node2=1: \n                            GCD(3,1)=1, LCM(3,1)=3 -> matches.\n\n            So both are valid.\n\n            Therefore, we can choose either. But note: our candidate for node1 was 3, which is the GCD of the product (3). Then node2 became 1.\n\n            How can we get the other assignment? \n\n            We can decide arbitrarily. The problem does not require a particular assignment.\n\n            However, there is a problem: the candidate for a node is the GCD of the products of the edges incident to it. But if we have multiple edges, then the candidate is fixed. Then the entire assignment is fixed by the choice of the starting node.\n\n            But note: the graph might be connected, and we are propagating from one node. \n\n            What if we start from node2? \n\n            For node2: P[2] = [3] -> candidate d[2] = 3, then node1 = (1*3)/3 = 1.\n\n            Then we get [1,3]. \n\n            So the assignment depends on the starting node. \n\n            We can do:\n\n                Do a BFS/DFS and for each connected component, pick an arbitrary node and set its candidate as the GCD of the products of its incident edges. Then, for each neighbor, set d[neighbor] = (g*l) / d[node].\n\n            But note: if the graph is connected, we can start from any node. However, if we start from node1, we set node1 to 3 and then node2 to 1. Then, if we try to go from node2, we have no other edges so we don't check again.\n\n            But what if we have a cycle? \n\n            Example: \n                \"3 2\\n1 2 1 3\\n2 3 1 3\"\n\n            Now, we have a triangle? Actually, two edges: (1,2) and (2,3). Then node3 is connected only to node2.\n\n            Step 1: \n                Node1: P[1] = [3] -> candidate1=3.\n                Node2: P[2] = [3,3] (from edge1 and edge2) -> candidate2 = gcd(3,3)=3.\n                Node3: P[3] = [3] -> candidate3=3.\n\n            Then, from node1: \n                d[1]=3, then d[2] = (1*3)/3 = 1. \n                Then, from node2: \n                    d[2]=1, then for edge (2,3): d[3] = (1*3)/1 = 3.\n\n            Then, check edge (1,2): (3,1) -> valid.\n            Check edge (2,3): (1,3) -> valid.\n\n            But now, the assignment is: [3,1,3]\n\n            However, we can also start from node2: \n                candidate2 = 3, then node1 = 3/3=1, node3=3/3=1.\n\n            Then, check edge (1,2): (1,3) -> valid.\n            Check edge (2,3): (3,1) -> valid.\n\n            So we have two assignments: [3,1,3] and [1,3,1]. \n\n            But wait, is [1,3,1] valid for the entire graph?\n                Edge1: (1,2): 1*3=3, GCD(1,3)=1, LCM(1,3)=3 -> valid.\n                Edge2: (2,3): 3*1=3, GCD(3,1)=1, LCM(3,1)=3 -> valid.\n\n            So both are valid.\n\n            Therefore, the algorithm is:\n\n                Step 1: Read n, m and the edges.\n\n                Step 2: Build graph: for each edge (u, v, g, l), store the edge and the reverse.\n\n                Step 3: For each node, compute the list of products (g_i * l_i) for each incident edge.\n\n                Step 4: For each connected component (using BFS/DFS), pick a starting node. Then:\n\n                    Let d[start] = the GCD of all the products for the edges incident to start. If the node has no edge, then we set d[start]=1 (arbitrary, because no constraint).\n\n                    Then, for each neighbor of start, set d[neighbor] = (g*l) / d[start] (for the edge (start, neighbor)).\n\n                    Then, for the next level, do the same: for a node, if we have multiple edges, we must check that the value we set from one edge is consistent with the others.\n\n                Step 5: After assigning the entire component, check every edge (u, v) to make sure:\n\n                    - d[u] * d[v] == g*u * l*u   (the product for the edge)\n                    - d[u] % g == 0 and d[v] % g == 0\n                    - gcd(d[u], d[v]) == g\n\n                Step 6: If any check fails, output \"NO\" and return.\n\n                Step 7: Otherwise, output \"YES\" and the list of d[i] for i from 1 to n.\n\n            However, note: we set d[u] for a node only once (from the BFS). But what if a node has two edges and we set it twice? \n\n            We are doing BFS: we start from a node and set its value. Then, when we process its neighbors, we set the neighbors' values. Then, when we meet a node again (like in a cycle) we don't set it again because we mark visited.\n\n            But what if the graph is not a tree? Then we must check consistency.\n\n            Example: the triangle above. We set node1=3, node2=1, node3=3. Then, we check the edge (1,2): ok, (2,3): ok, and also the edge (1,3) if existed? But in the example above we didn't have the third edge.\n\n            Now, what if we have a cycle and the product condition forces an inconsistency?\n\n            Example: \n                n=3, m=3: edges (1,2): (1,2,1,2); (2,3): (1,3,1,6); (1,3): (1,6,1,6)\n\n            Then, for node1: \n                P[1] = [1*2, 1*6] = [2,6] -> gcd=2.\n                Then, d[1]=2.\n\n            Then, from edge (1,2): d[2] = (1*2)/2 = 1.\n            Then, from edge (1,3): d[3] = (1*6)/2 = 3.\n\n            Then, check edge (2,3): \n                d[2]=1, d[3]=3 -> product=3, but the edge (2,3) requires product=1*6=6 -> 1*3 !=6 -> fails.\n\n            So we must check the edges. \n\n            Therefore, after assigning the entire component, we must check every edge in the component.\n\n            But note: during BFS we set the neighbors, but we haven't checked the edges that are not used in the BFS tree? \n\n            We can do:\n\n                During BFS, we assign the parent-child relationship. Then, when we assign a node from a parent, we set the value. Then, when we visit the node, we check all edges (including the one that leads back to the parent) to ensure consistency.\n\n            Alternatively, we can do:\n\n                Step 4: For a connected component, we set the starting node's value (the GCD of the products).\n\n                Then, for each edge (u, v) in the component, we can check:\n\n                    d[u] * d[v] == g*u * l*u   (the product for the edge) and gcd(d[u],d[v])==g.\n\n                But note: the product for the edge is g*u * l*u, but wait: the input for edge (u, v) is given as (g, l). So we need to store the edges.\n\n            We can store the graph with edges: for each edge (u, v, g, l), store (g, l) along with the edge.\n\n            Steps for BFS:\n\n                Let d = [0]*(n+1)   (1-indexed)\n\n                For each node, if not visited, set d[node] = gcd of the products (g_i * l_i) for its edges. If the node has no edge, set d[node]=1.\n\n                Then, queue the node.\n\n                While queue not empty:\n                    pop node u.\n                    For each neighbor v (via edge (u, v, g, l)):\n                        If v not visited, then d[v] = (g*l) / d[u]   (must be integer, else invalid)\n\n                Then, after BFS, we must check all edges in the component (both tree edges and non-tree edges) for the conditions.\n\n            However, the non-tree edges might not have been used to set the value, but we must check that the product and GCD conditions hold.\n\n            We can do: \n\n                After assigning the entire component, iterate over every edge (u, v) in the component and check:\n\n                    Condition1: d[u] * d[v] == g*u * l*u   (where (g*u, l*u) is the edge's (g, l))\n                    Condition2: d[u] % g*u == 0 and d[v] % g*u == 0\n                    Condition3: gcd(d[u], d[v]) == g*u\n\n            But note: we stored the original edges.\n\n            However, we must be cautious: the product condition must hold for the edge.\n\n            Implementation:\n\n                Step 1: Read input.\n\n                Step 2: Build graph: for each edge, store (v, g, l, product) for both directions.\n\n                Step 3: For each node, we have a list of edges (with g, l, product).\n\n                Step 4: Compute for each node the GCD of all the products (if no edge, then product list is empty -> then we set candidate to 0? But then division by zero. Instead, if no edge, set candidate to 1.\n\n                Step 5: Use BFS/DFS to assign:\n\n                    visited = [False]*(n+1)\n                    d = [0]*(n+1)\n\n                    For i from 1 to n:\n                        if not visited[i]:\n                            # BFS starting from i\n                            q = deque([i])\n                            visited[i] = True\n                            # Compute candidate for i: if the node has no edge, then candidate = 1.\n                            if len(edges[i]) == 0:\n                                d[i] = 1\n                            else:\n                                # Compute the gcd of all the products in edges[i]\n                                cand = edges[i][0][2]   # product for the first edge\n                                for j in range(1, len(edges[i])):\n                                    cand = gcd(cand, edges[i][j][2])\n                                d[i] = cand\n\n                            while q:\n                                u = q.popleft()\n                                for edge in graph[u]:\n                                    v = edge[0]\n                                    g_val = edge[1]\n                                    l_val = edge[2]\n                                    product_val = edge[3]\n                                    if not visited[v]:\n                                        visited[v] = True\n                                        # Check that cand (which is d[u]) divides product_val (which is g_val * l_val)\n                                        if product_val % d[u] != 0:\n                                            print(\"NO\")\n                                            exit(0)\n                                        d[v] = product_val // d[u]\n                                        q.append(v)\n\n                Step 6: Now, we have an array d[1..n] for the entire graph (only for connected components). Then, we must check every edge (whether in the BFS tree or not) for the three conditions.\n\n                    For each edge (u, v, g_val, l_val) in the original list of edges:\n                        product_val = g_val * l_val\n                        # Condition 1: d[u] * d[v] == product_val\n                        if d[u] * d[v] != product_val:\n                            print(\"NO\")\n                            exit(0)\n                        # Condition 2: d[u] % g_val == 0 and d[v] % g_val == 0\n                        if d[u] % g_val != 0 or d[v] % g_val != 0:\n                            print(\"NO\")\n                            exit(0)\n                        # Condition 3: gcd(d[u], d[v]) == g_val\n                        if math.gcd(d[u], d[v]) != g_val:\n                            print(\"NO\")\n                            exit(0)\n\n                Step 7: If all edges pass, output \"YES\" and then d[1..n] (each d[i] for i from 1 to n).\n\n            However, there is an issue: the candidate we set for a node might be too large and then when we assign the neighbor, the product might not be divisible? \n\n            We already checked that d[u] divides product_val (which is g*l) in the BFS step. But note: the product_val for the edge (u, v) is the same as the product_val used in the candidate computation for u? \n\n            But wait: the candidate for u is the GCD of all the products (including the one for edge (u, v)). So d[u] divides product_val (g*l). Therefore, d[v] = product_val // d[u] is an integer.\n\n            However, we did not check the divisibility condition (by g) and the GCD condition until step 6.\n\n            Also, note: the candidate for u is the GCD of all the products (including the ones for edges not traversed first). Then, when we set d[v] = (g*l)/d[u], we rely on d[u] being the same throughout the entire component.\n\n            But what if the candidate for u is set from a product that doesn't involve the edge (u, v)? \n\n            Example: \n                Two edges from u: (u, v1) with (g1, l1) and (u, v2) with (g2, l2). Then candidate u = gcd(g1*l1, g2*l2). Then, when processing edge (u, v1): we set d[v1] = (g1*l1) // candidate_u. Then, when processing edge (u, v2): we set d[v2] = (g2*l2) // candidate_u.\n\n            This is consistent.\n\n            But note: the candidate_u is the same for all edges from u.\n\n            However, what if the candidate_u is not the same as the GCD of the entire set? Actually, we computed it that way.\n\n            One more issue: the candidate_u must divide every product (g_i*l_i). Then, when we use one product (g1*l1) to set d[v1] = (g1*l1)//candidate_u, then for the edge (u, v1) the product condition is satisfied. But what about the other edges from u? \n\n            We don't use the candidate_u to set the value for v1 from the other edges, but we must ensure that for the other edges, the product condition holds? \n\n            Actually, the product condition for edge (u,",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a graph based on given edges, where each edge provides the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on its connected lawns. The solution involves verifying the consistency of these constraints across the entire graph.\n\n### Approach\n1. **Problem Analysis**: The problem requires assigning values to each node such that for every edge, the product of the node values equals the product of the edge's GCD and LCM, and the GCD of the node values matches the edge's GCD. Additionally, each node's value must be divisible by the GCD of all edges incident to it.\n\n2. **Key Insights**:\n   - For any edge connecting nodes \\(u\\) and \\(v\\) with GCD \\(g\\) and LCM \\(l\\), the product of the node values \\(d[u] \\times d[v]\\) must equal \\(g \\times l\\).\n   - The GCD of the node values must be exactly \\(g\\).\n   - Node values must be divisors of their respective edge LCMs.\n\n3. **Algorithm Selection**:\n   - **Graph Traversal**: Use BFS to traverse the graph starting from an arbitrary node. For each node, compute the candidate value as the GCD of the products (GCD × LCM) of all edges incident to it.\n   - **Validation**: After assigning values during BFS, verify all edges to ensure they meet the product, divisibility, and GCD conditions.\n\n4. **Complexity Analysis**:\n   - **Time Complexity**: The algorithm involves BFS traversal (\\(O(n + m)\\)) and GCD computations (each GCD computation is \\(O(\\log(\\text{max}(a, b))\\)), leading to an overall complexity of \\(O(n + m \\times \\log(\\text{max}(a, b)))\\).\n   - **Space Complexity**: The space required is \\(O(n + m)\\) to store the graph and node values.\n\n### Solution Code\n```python\nimport math\nfrom collections import deque\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    edges_info = []\n    \n    for _ in range(m):\n        u = int(next(it)); v = int(next(it)); g_val = int(next(it)); l_val = int(next(it))\n        product_val = g_val * l_val\n        edges_info.append((u, v, g_val, l_val, product_val))\n        graph[u].append((v, g_val, l_val, product_val))\n        graph[v].append((u, g_val, l_val, product_val))\n        \n    d = [0] * (n+1)\n    visited = [False] * (n+1)\n    \n    for i in range(1, n+1):\n        if not visited[i]:\n            if len(graph[i]) == 0:\n                d[i] = 1\n                visited[i] = True\n                continue\n            \n            cand = graph[i][0][3]\n            for j in range(1, len(graph[i])):\n                cand = math.gcd(cand, graph[i][j][3])\n            d[i] = cand\n            visited[i] = True\n            q = deque([i])\n            \n            while q:\n                u_node = q.popleft()\n                for edge in graph[u_node]:\n                    v_node, g_val_edge, l_val_edge, prod_val = edge\n                    if not visited[v_node]:\n                        visited[v_node] = True\n                        if prod_val % d[u_node] != 0:\n                            print(\"NO\")\n                            return\n                        d[v_node] = prod_val // d[u_node]\n                        q.append(v_node)\n                        \n    valid = True\n    for (u, v, g_val, l_val, prod_val) in edges_info:\n        if d[u] * d[v] != prod_val:\n            valid = False\n            break\n        if d[u] % g_val != 0 or d[v] % g_val != 0:\n            valid = False\n            break\n        if math.gcd(d[u], d[v]) != g_val:\n            valid = False\n            break\n            \n    if not valid:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        result = []\n        for i in range(1, n+1):\n            result.append(str(d[i]))\n        print(\"\\n\" + \" \".join(result))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of nodes \\(n\\) and edges \\(m\\), followed by the edges' details (connected nodes and their GCD and LCM values).\n2. **Graph Construction**: A graph is built using adjacency lists, storing each edge's GCD, LCM, and their product.\n3. **BFS Traversal**: For each unvisited node, the candidate value is computed as the GCD of the products (GCD × LCM) of all incident edges. During BFS, each neighbor's value is set to the product of the edge divided by the current node's candidate value.\n4. **Validation**: After BFS, all edges are checked to ensure the product of node values matches the edge's product, node values are divisible by the edge's GCD, and their GCD matches the edge's GCD.\n5. **Output**: If all checks pass, \"YES\" is printed along with the node values; otherwise, \"NO\" is printed indicating no valid assignment exists.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom collections import deque\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    edges_info = []\n    \n    for _ in range(m):\n        u = int(next(it)); v = int(next(it)); g_val = int(next(it)); l_val = int(next(it))\n        product_val = g_val * l_val\n        edges_info.append((u, v, g_val, l_val, product_val))\n        graph[u].append((v, g_val, l_val, product_val))\n        graph[v].append((u, g_val, l_val, product_val))\n        \n    d = [0] * (n+1)\n    visited = [False] * (n+1)\n    \n    for i in range(1, n+1):\n        if not visited[i]:\n            if len(graph[i]) == 0:\n                d[i] = 1\n                visited[i] = True\n                continue\n            \n            cand = graph[i][0][3]\n            for j in range(1, len(graph[i])):\n                cand = math.gcd(cand, graph[i][j][3])\n            d[i] = cand\n            visited[i] = True\n            q = deque([i])\n            \n            while q:\n                u_node = q.popleft()\n                for edge in graph[u_node]:\n                    v_node, g_val_edge, l_val_edge, prod_val = edge\n                    if not visited[v_node]:\n                        visited[v_node] = True\n                        if prod_val % d[u_node] != 0:\n                            print(\"NO\")\n                            return\n                        d[v_node] = prod_val // d[u_node]\n                        q.append(v_node)\n                        \n    valid = True\n    for (u, v, g_val, l_val, prod_val) in edges_info:\n        if d[u] * d[v] != prod_val:\n            valid = False\n            break\n        if d[u] % g_val != 0 or d[v] % g_val != 0:\n            valid = False\n            break\n        if math.gcd(d[u], d[v]) != g_val:\n            valid = False\n            break\n            \n    if not valid:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        result = []\n        for i in range(1, n+1):\n            result.append(str(d[i]))\n        print(\"\\n\" + \" \".join(result))\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1214,
        "thoughts_token_count": 8191
    }
}