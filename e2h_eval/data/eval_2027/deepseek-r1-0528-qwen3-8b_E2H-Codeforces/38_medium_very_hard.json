{
    "start": 1758300640.4018269,
    "end": 1758304481.73486,
    "start-formatted": "2025-09-20 01:50 KST",
    "end-formatted": "2025-09-20 02:54 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000) and we need to output two integers: \n   n = minimum number of nodes required to have exactly p pairs (u, v) with u < v and mutual reachability.\n   m = maximum number of unidirectional pairs (over all edges in the graph) in such a graph with n nodes.\n\n However, note that the problem defines:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) [with u < v] such that u and v are mutually reachable.\n\n But note: the condition \"there exists a path from u to v and from v to u\" for u < v. This set of pairs is exactly the set of edges in the condensation graph (the strongly connected components) that form a complete DAG on the SCCs? Actually, the mutual reachability condition is equivalent to being in the same strongly connected component (SCC). So if we have k SCCs, then the mutual reachability pairs are the pairs of nodes that lie in the same SCC and are distinct. However, note that the problem says \"exactly p\" such pairs.\n\n However, wait: the problem states that we are considering ordered pairs (u, v) with u < v. And mutual reachability. So if we have a set of nodes forming an SCC, then the number of pairs (u, v) with u < v in that SCC is C(size,2). Therefore, the entire graph must have SCCs such that the sum of C(size_i, 2) over all SCCs equals p.\n\n But note: the graph is built from these SCCs, and the condensation graph (the DAG of SCCs) has no edges between SCCs that would cause mutual reachability (because by definition, there's no path from an SCC to itself via another SCC). So the only mutual reachability pairs are within each SCC.\n\n Now, we are to find the minimum number of nodes (n) such that we can partition the n nodes into several SCCs (say k SCCs) and the total number of pairs (sum_{i} C(size_i, 2)) is exactly p.\n\n However, note that the problem does not require that the graph is connected or anything. We are free to choose the structure as long as the mutual reachability condition gives exactly p.\n\n But wait: the problem does not say that the graph must be simple? Actually, we are talking about directed graphs. However, the problem doesn't specify multiple edges or self-loops. Since we are counting ordered pairs (u, v) with u != v, and the condition requires no path from v to u when we define unidirectional, we assume no self-loops and probably simple directed graph? The problem does not specify, but typically competitive programming problems assume simple graphs unless stated otherwise.\n\n However, note: the problem asks for the minimum number of nodes. Also, we are allowed to arrange the graph arbitrarily (so we can design the SCCs arbitrarily).\n\n How do we get p mutual reachability pairs?\n We need to represent p as a sum of terms of the form (k*(k-1))//2, where k>=1, and we want to minimize the total number of nodes (which is the sum of the sizes of the SCCs). Additionally, the graph must be built from these SCCs, and the condensation graph must be a DAG.\n\n But note: we are free to choose the sizes of the SCCs arbitrarily. We want to represent p as a sum of some triangular numbers (each term is T_k = k*(k-1)//2) and minimize the total nodes (which is the sum of the k_i's). \n\n Example: p=3.\n   We can use one SCC of size 3: T_3 = 3, so n=3.\n   Alternatively, we could use three SCCs of size 2: T_2+T_2+T_2 = 1+1+1 = 3, then n=2+2+2=6, which is worse.\n\n So the problem reduces to: \n   Represent p as a sum of triangular numbers (allowing repetitions) and minimize the total nodes (the sum of the bases, i.e., the k_i's).\n\n However, note: the triangular numbers are nonnegative and increasing. We want to minimize the total number of nodes, which is the sum of the k_i (since each SCC of size k_i uses k_i nodes).\n\n But note: we cannot use an SCC of size 0. The smallest triangular number is T_1 = 0 (if we allow k_i=1, then T_1=0). Then we can use as many k_i=1 as we want. However, if we use k_i=1, then we are using 1 node per SCC and contributing 0 to p.\n\n Alternatively, we can use larger SCCs. We want to minimize the total nodes. We know that:\n\n   Let the SCCs have sizes s1, s2, ..., sk. Then:\n        p = sum_{i=1}^{k} T_{s_i}   [where T_s = s*(s-1)//2]\n        n = sum_{i=1}^{k} s_i\n\n We wish to minimize n.\n\n How to approach?\n\n Observation: \n   We can use the following fact: \n        T_s = s*(s-1)//2.\n\n   We can also note that the function T_s grows quadratically. To minimize the total nodes, we want to use as few SCCs as possible and with as large sizes as possible, but note: using a large SCC might use more nodes than necessary. \n\n However, we are constrained by the total triangular sum being p.\n\n Alternatively, we can think: we want to cover p using triangular numbers and minimize the sum of the bases (the s_i). \n\n We can use dynamic programming? But p can be up to 200000.\n\n But note: the triangular numbers grow quickly: \n   T_1 = 0\n   T_2 = 1\n   T_3 = 3\n   T_4 = 6\n   T_5 = 10\n   ...\n\n How many distinct triangular numbers do we need? The maximum s such that T_s <= 200000 is about sqrt(400000) ~ 632.\n\n But we are allowed to use any triangular number multiple times? Actually, we can use the same triangular number multiple times because the graph can have multiple SCCs of the same size.\n\n However, note: the problem does not require the graph to be connected, and the condensation graph is a DAG. There is no restriction that we cannot have multiple SCCs of the same size.\n\n But the problem is: we are to minimize the total nodes. We are to find the minimum n (number of nodes) such that we can write p as a sum of triangular numbers (each T_s = s*(s-1)//2) and the sum of the s_i (the bases) is n.\n\n However, note: the same triangular number can be used multiple times. But wait: we are representing p as a sum of triangular numbers (each term is independent). \n\n But note: the triangular numbers are additive. We wish to minimize the total nodes (the sum of the bases) given that the sum of the triangular numbers is p.\n\n Let f(p) = minimal total nodes needed to represent p as a sum of triangular numbers (each term being T_s for s>=1).\n\n Then, we are to compute f(p). \n\n However, note: we can also use the same SCC multiple times? Actually, no: each SCC is defined by its set of nodes. But we are allowed to have multiple SCCs of the same size. So yes, we can use the same triangular number multiple times.\n\n But wait: the problem does not require the graph to be connected, so we can have as many SCCs as we like.\n\n However, the problem says: we are to build a graph with minimum n (nodes). Then, we must maximize the number of unidirectional pairs.\n\n Let me break down:\n\n Step 1: Find the minimum n (total nodes) such that there exists a representation of p as a sum of triangular numbers (each T_s) and the sum of the bases (s_i) is n.\n\n Step 2: Among all graphs with n nodes that are p-reachable (so the sum of T_{s_i} = p), we wish to maximize the number of unidirectional pairs.\n\n What is an unidirectional pair? \n   An ordered pair (u, v) (u != v) such that there is a path from u to v and not from v to u.\n\n Note: In a directed graph, the total number of ordered pairs (u, v) with u != v is n*(n-1). \n\n The graph has two types of edges (in the mutual sense) and unidirectional ones: \n   - Mutual: both directions exist (then they form a cycle, or more generally, they are in the same SCC and there's a cycle). But note: the problem counts only the pairs (u, v) with u < v for mutual reachability. For unidirectional, we are counting (u, v) (without requiring u<v) such that there is a path from u to v but not from v to u.\n\n However, note: the problem says \"an ordered pair (u, v)\" and then specifies u != v, and the conditions. It does not require u < v for unidirectional. But then note: the example input 3 gives output \"3 0\". \n\n Let me check the example: p=3. Then we have a graph with 3 nodes and 3 mutual pairs (so the entire graph is strongly connected). Then there are no unidirectional pairs? Why? Because in a strongly connected graph, for every ordered pair (u, v) (with u != v) there is a path from u to v and from v to u. Therefore, no unidirectional pair.\n\n Now consider p=4. Output is \"5 6\".\n\n How can we represent p=4?\n   We can use one SCC of size 3 (which gives 3) and one SCC of size 2 (which gives 1). Then total mutual pairs = 3+1=4. Total nodes = 3+2=5.\n\n Now, what is the maximum number of unidirectional pairs in a graph with 5 nodes and two SCCs (sizes 3 and 2) and the condensation graph is a DAG (so we can arrange the edges arbitrarily as long as the DAG condition holds).\n\n How many edges are there in the entire graph? The graph is directed, and we are allowed to add any edges that do not create cycles within the SCCs (each SCC is strongly connected, so we must have a cycle inside, but we can add as many edges as we want as long as the condensation graph is a DAG and the SCCs are strongly connected). However, note that the problem does not fix the edges, we just have to satisfy the mutual reachability condition (which is fixed by the SCCs) and then we are free to add any edges that do not change the condensation graph (we can add edges from an SCC to a larger one, but not the reverse).\n\n But note: the problem does not require the graph to be maximal. We are to maximize the number of unidirectional pairs. \n\n How do we count unidirectional pairs?\n\n   Total ordered pairs (u, v) (u != v): 5*4 = 20.\n\n   The mutual pairs (both ways) are counted by the SCCs: \n        In the SCC of size 3: the mutual pairs (for u,v distinct) are 3*2 = 6? But wait, the problem counts only the pairs (u, v) with u < v. However, for mutual reachability, the condition is symmetric. In the SCC of size 3, the number of unordered pairs is 3, and each unordered pair (u, v) corresponds to two ordered pairs (u->v and v->u) that are mutual. But note: the problem's p is defined as the number of pairs (u, v) with u < v and mutual reachability. So for the SCC of size 3, we have 3 mutual pairs (each unordered pair {u, v} with u < v is counted once). Similarly, the SCC of size 2 gives 1 mutual pair.\n\n   However, for the entire graph, the mutual pairs (as defined by the problem) is 3+1=4. But note: the problem does not require the graph to have exactly p mutual pairs (with u < v) and that is fixed. Then the rest of the ordered pairs (u, v) (u != v) are either unidirectional or not mutual at all.\n\n   Actually, for two nodes u and v, there are two possibilities: \n        - They are in the same SCC: then both directions exist -> then the pair (u, v) is mutual (and similarly (v, u) is mutual). But note: the problem counts only (u, v) with u < v for p. For unidirectional, we consider any ordered pair (u, v) (without the u<v condition) that is not symmetric.\n\n   However, note: the definition of unidirectional requires that there is a path from u to v and no path from v to u. \n\n   In our graph, we have two SCCs: A (size 3) and B (size 2). The condensation graph must be a DAG. Without loss of generality, we can have edges from A to B (so that A can reach B, but not vice versa). Then:\n\n        Within A: for any two distinct nodes u, v in A, we have both paths (so the ordered pairs (u, v) and (v, u) are mutual).\n        Within B: for the two nodes in B, we have both paths (so the two ordered pairs (x,y) and (y,x) are mutual).\n        Between A and B: \n            From A to B: for each node in A and each node in B, there is a path from A to B (because the condensation graph has an edge from A to B, and we can make the edges complete from A to B). Then for an ordered pair (a, b) (a in A, b in B): \n                There is a path from a to b, but not from b to a (since the condensation graph goes from A to B, not the other way). So (a, b) is unidirectional.\n            From B to A: no path (because the condensation graph has no edge from B to A). So (b, a) is not even considered as having a path from b to a? Actually, the definition requires \"there exists a path from u to v\", so for (b, a) we don't have a path from b to a. Therefore, (b, a) is not unidirectional (because the condition for unidirectional requires that there is a path from u to v, and no path from v to u). Here, (b, a) fails the first condition.\n\n        So the unidirectional pairs are only the pairs (a, b) for a in A and b in B.\n\n        Number of such pairs: 3 * 2 = 6.\n\n        Also, note: the mutual pairs (as defined by the problem) are the pairs (u, v) with u < v and mutual reachability. That includes:\n            In A: the 3 pairs (each unordered pair in A gives one mutual pair because u < v)\n            In B: the 1 pair (the two nodes, say x and y, then (x,y) if x<y is counted)\n\n        But note: the definition of mutual reachability for two nodes in the same SCC is that they are mutually reachable. However, the problem does not require the graph to have the minimal edges. We can have a complete set of edges within each SCC (so that it is strongly connected) and then edges from A to B (but not the reverse). \n\n        However, the problem does not fix the edges. We are allowed to choose the edges arbitrarily as long as the mutual reachability pairs (the ones with u<v) is exactly p (which is 4). \n\n        But wait: if we have two SCCs, then the mutual reachability pairs are fixed by the SCCs. The problem states: the graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable. \n\n        The mutual reachability condition is defined by the existence of paths in both directions. Therefore, two nodes are mutually reachable if and only if they are in the same SCC. So the mutual pairs are exactly the pairs (u, v) (with u < v) that lie in the same SCC.\n\n        Therefore, the representation of p is fixed by the multiset of SCC sizes.\n\n        Then, to maximize the number of unidirectional pairs, we must arrange the edges (the condensation graph and the edges within the SCCs) appropriately.\n\n        We must ensure that within each SCC, we have a strongly connected component (so we can have all the edges we want, but we must have at least a cycle). However, to maximize unidirectional pairs, we should make the condensation graph a total order (so that between two different SCCs, we have all edges from the earlier SCC to the later one, but none the other way). \n\n        Then, the unidirectional pairs come from:\n          - Between two different SCCs (say from SCC i to SCC j, if there is an edge from i to j and not from j to i, then for every node u in i and v in j, the pair (u, v) is unidirectional).\n          - Also, we can have edges within an SCC? But note: within an SCC, we have mutual reachability, so no unidirectional pairs. However, we can have additional edges? Actually, the definition of SCC is that the node set is maximal. But if we add an edge that creates a cycle that goes through two SCCs, then we might merge them? \n\n        Actually, we must have the condensation graph being a DAG and the SCCs are maximal. Therefore, we cannot have edges from a smaller SCC to a larger one and then back, because that would merge the two SCCs. \n\n        So the standard way is to have a DAG of SCCs, and we can arrange the edges arbitrarily as long as the condensation graph remains a DAG. To maximize the unidirectional pairs, we want to maximize the number of edges between SCCs that go in one direction (from an SCC to a higher one) and avoid the reverse.\n\n        However, note: the problem does not fix the condensation graph. We are free to choose the condensation graph (as long as it is a DAG). \n\n        The maximum number of unidirectional pairs is achieved when the condensation graph is a total order (i.e., a linear extension) and we have all edges from a lower SCC to a higher one (and no edges the other way). \n\n        Then, the unidirectional pairs are only the pairs (u, v) where u is in an earlier SCC and v is in a later SCC (in the topological order) and there is an edge from u's SCC to v's SCC (which we can assume we put all edges from u's SCC to v's SCC, so that every node in u's SCC can reach every node in v's SCC). \n\n        Then, the total number of unidirectional pairs is the sum over all pairs of distinct SCCs (i, j) (with i < j in the topological order) of (size_i * size_j). \n\n        Why? Because for each node in an earlier SCC and each node in a later SCC, the pair (u, v) is unidirectional (since we have a path from u to v, but not from v to u). \n\n        But note: the problem does not require the condensation graph to be complete. However, we can always add edges from an SCC to a later SCC without creating cycles (since the condensation graph is a DAG). And to maximize unidirectional pairs, we want to have as many edges as possible from earlier to later, but without creating cycles. The best is to have a complete DAG (i.e., a total order) and put all edges from earlier to later.\n\n        Then, the total unidirectional pairs is the sum_{i<j} (size_i * size_j).\n\n        But wait, what about edges within an SCC? We must have the SCCs strongly connected. However, we are free to choose the edges within the SCC. But note: the definition of unidirectional pairs is for ordered pairs (u, v) (u != v). Within an SCC, for every distinct pair (u, v) (both orders) we have mutual reachability, so no unidirectional pair within the same SCC.\n\n        Therefore, the total unidirectional pairs is the sum_{i<j} (size_i * size_j).\n\n        Now, note: the total number of ordered pairs (u, v) (u != v) is n*(n-1) = (sum_i size_i)*(sum_i size_i - 1). \n\n        And the mutual pairs (for u<v) is p (which is the sum_i T_{size_i}).\n\n        Also, the mutual pairs (for all ordered pairs) are: for each SCC, we have size_i*(size_i-1) (each unordered pair gives two ordered pairs, but note: the problem counts only u<v). However, the mutual reachability for two nodes in the same SCC gives two ordered pairs (u->v and v->u) that are mutual. But the problem's p is the count for u<v.\n\n        Now, the total number of ordered pairs (u, v) (u != v) is n*(n-1). This breaks down into:\n            Mutual ordered pairs: for each SCC, the number of ordered pairs (u, v) (u != v) that are mutual is size_i*(size_i-1) (because for each unordered pair, two ordered pairs are mutual). But note: the problem's p is the number of unordered pairs (with u<v) that are mutual, which is T_{size_i} = size_i*(size_i-1)//2. Then the total mutual ordered pairs (both directions) is 2*p.\n\n            Then, the rest of the ordered pairs (not mutual) are the unidirectional ones. But wait: are there any ordered pairs that are not mutual and not unidirectional? \n\n        According to the definition: \n            Unidirectional: (u, v) has a path from u to v and no path from v to u.\n            Mutual: both paths exist.\n\n        And if there is no path from u to v and no path from v to u, then it is not unidirectional and not mutual. \n\n        However, in our construction (with the condensation graph being a total order and the SCCs being strongly connected and the edges between SCCs being complete from earlier to later), we have:\n\n            For two nodes in the same SCC: mutual (both ways).\n            For two nodes in different SCCs (say i and j, i<j): then there is a path from i to j, but not from j to i. So the ordered pair (i_node, j_node) is unidirectional, and (j_node, i_node) is not even considered (because the condition for unidirectional requires the path from j_node to i_node, which we don't have). \n\n        But note: the definition of unidirectional does not require that the pair (v, u) is not present? It requires that there is a path from u to v and no path from v to u. \n\n        Therefore, we have two possibilities for two distinct SCCs i and j (with i != j):\n\n            If we have an edge from i to j (and we do, because of the total order), then (i_node, j_node) is unidirectional (since we have a path from i to j, and no path from j to i).\n\n            But what about (j_node, i_node)? We don't have a path from j_node to i_node (because the condensation graph is a DAG and j is after i). So (j_node, i_node) is not unidirectional (because the first condition fails). \n\n        Then, the total unidirectional pairs is the sum_{i<j} (size_i * size_j) (for the edges from i to j) and nothing else.\n\n        However, note: we did not account for the possibility of having edges from j to i? We don't, because the condensation graph is a total order and we don't add edges backwards.\n\n        Therefore, the maximum unidirectional pairs is the sum_{i<j} (size_i * size_j).\n\n        Now, note: the entire set of ordered pairs (u, v) (u != v) is:\n\n            n*(n-1) = (sum_i size_i)*(sum_i size_i - 1)\n\n        This equals: \n            = sum_{i} size_i*(n - size_i)   [by expanding] \n            But we can also split by: \n                = (sum_i size_i^2) + (sum_{i<j} (size_i * size_j)*2)   [Wait, let me expand: \n                    (a+b+c)^2 = a^2+b^2+c^2+2(ab+ac+bc)]\n                Actually, n^2 = (sum_i size_i)^2 = sum_i size_i^2 + 2 * (sum_{i<j} size_i*size_j)\n\n                Then, n*(n-1) = n^2 - n = sum_i size_i^2 + 2*S - (sum_i size_i)   [where S = sum_{i<j} size_i*size_j]\n\n                But note: n = sum_i size_i, so:\n\n                n*(n-1) = (sum_i size_i)^2 - (sum_i size_i) = (sum_i size_i^2) + 2*S - n.\n\n                Then, S = [n^2 - n - (sum_i size_i^2)] / 2.\n\n        Alternatively, we can compute S directly: \n            S = sum_{i<j} size_i*size_j = (n^2 - sum_i size_i^2) / 2.\n\n        Then, the maximum unidirectional pairs is S.\n\n        But wait, how do we relate this to p? \n\n        We know that p = sum_i T_{size_i} = sum_i (size_i*(size_i-1))//2.\n\n        Then, we can express:\n\n            sum_i size_i^2 = 2p + sum_i size_i   [because T_{size_i} = (size_i^2 - size_i)/2, so 2*T_{size_i} = size_i^2 - size_i, then sum_i (size_i^2) = 2p + sum_i size_i]\n\n        Then, S = (n^2 - (2p + n)) / 2.\n\n        However, note: n = sum_i size_i, so:\n\n            S = (n^2 - 2p - n) / 2.\n\n        But wait: is this correct? \n\n            Let me check with p=4 (n=5): \n                Then, S = (25 - 8 - 5) / 2 = (12) / 2 = 6. -> matches.\n\n            Check with p=3 (n=3):\n                Then, S = (9 - 6 - 3) / 2 = (0) / 2 = 0. -> matches.\n\n        Therefore, if we know the representation (the multiset of SCC sizes) and hence n and p, then the maximum unidirectional pairs is (n^2 - 2p - n) // 2.\n\n        However, note: we are to maximize the unidirectional pairs. But is this formula independent of the representation? \n\n        Actually, we derived that the maximum unidirectional pairs is the sum_{i<j} (size_i * size_j) = (n^2 - sum_i size_i^2) / 2, and we also have that p = sum_i (size_i*(size_i-1))//2, so:\n\n            sum_i size_i^2 = 2p + n   (because from p = (sum_i size_i^2 - n)/2, rearranged: sum_i size_i^2 = 2p + n)\n\n        Therefore, S = (n^2 - (2p + n)) / 2.\n\n        So the maximum unidirectional pairs is independent of the representation! \n\n        But wait: is that true? \n\n        Let me try with two representations for p=4:\n\n          Representation 1: one SCC of size 3 and one of size 2: n=5, then S = (25 - 8 - 5)/2 = 12/2 = 6.\n\n          Representation 2: four SCCs of size 2: then p = 4 * 1 = 4, and n = 4*2 = 8. Then S = (64 - 8 - 8)/2 = 48/2 = 24.\n\n          Representation 3: two SCCs of size 3: then p = 3+3 = 6, which is too much. So invalid.\n\n          Representation 4: one SCC of size 4: T_4=6, which is too much.\n\n        But wait, we are fixed to p=4. The representation must give exactly 4. \n\n        Another representation for p=4: \n          Use an SCC of size 4: T_4=6 -> too big.\n          Use an SCC of size 3 and two SCCs of size 1: T_3 + T_1 + T_1 = 3+0+0=3 -> not 4.\n          Use an SCC of size 3 and one SCC of size 1: T_3+T_1=3+0=3 -> not 4.\n          Use four SCCs of size 2: then n=8, and p=4 (each T_2=1, four of them: 4). Then S= (8^2 - 2*4 - 8)/2 = (64-8-8)/2=48/2=24.\n\n        But note: the problem says for p=4, the minimum n is 5. So we are only concerned with the minimal n. \n\n        Therefore, for a fixed p, we first find the minimal n (the minimal total nodes) such that p can be written as a sum of triangular numbers (each T_k = k*(k-1)//2) and the sum of the k_i (the bases) is n.\n\n        Then, once we have n, the maximum unidirectional pairs is (n^2 - 2p - n) // 2.\n\n        However, wait: why is the formula independent of the representation? \n\n        Actually, note: the formula for S uses n and p. And p is fixed (the problem input). But n is the total nodes (minimal). And the representation must use the minimal n. \n\n        But note: the representation we choose must yield the minimal n. However, the formula for S depends only on n and p. \n\n        Why is that? \n\n        We have: \n            p = sum_i T_{k_i} = sum_i (k_i*(k_i-1))//2\n            n = sum_i k_i\n\n        Then, the expression for S is (n^2 - sum_i k_i^2) / 2.\n\n        And we also have: \n            sum_i k_i^2 = 2p + n   [from p = (sum_i (k_i^2 - k_i))/2, so sum_i k_i^2 = 2p + sum_i k_i = 2p+n]\n\n        Therefore, S = (n^2 - (2p+n)) / 2.\n\n        This holds for any representation (any multiset of k_i) that satisfies the equation. \n\n        But note: the minimal n might not be unique? However, the problem says \"minimum number of nodes\", so we are to take the minimal n for which there exists a representation.\n\n        Then, for that minimal n, the maximum unidirectional pairs is fixed by the above formula.\n\n        However, wait: is it always possible to arrange the edges (the condensation graph) to get that many unidirectional pairs? \n\n        Yes, because we can arrange the condensation graph as a total order (linear extension) and put all edges from earlier to later. Then the unidirectional pairs are exactly the sum_{i<j} (k_i * k_j) = (n^2 - 2p - n) // 2.\n\n        Therefore, the problem reduces to:\n\n          Step 1: Find the minimal n such that there exists a multiset of positive integers {k_1, k_2, ..., k_m} (each k_i>=1) satisfying:\n                   sum_i (k_i*(k_i-1)//2) = p\n                   and n = sum_i k_i.\n\n          Step 2: Then, the answer is (n, (n*n - 2*p - n) // 2).\n\n        But note: what if p=0? Then we need no mutual pairs. Then we can use n=0? Or n=1? \n\n        For p=0: \n            We can use n=0: no nodes -> then no mutual pairs (vacuously) and then unidirectional pairs=0.\n            But the problem says: ordered pairs (u, v) with u != v. With 0 nodes, there are no such pairs.\n\n            However, the problem says \"minimum number of nodes\", so n=0 is acceptable.\n\n            Then, the maximum unidirectional pairs is (0 - 0 - 0)//2 = 0.\n\n            But the example: Input '0' -> Output '0 0'\n\n        However, note: the problem says \"ordered pair (u, v) with u < v\", so if there are less than 2 nodes, then no such pairs. \n\n        But the problem does not specify that the graph must be simple, but we assume that n=0 is acceptable.\n\n        Now, how to compute the minimal n for a given p?\n\n        We are to represent p as a sum of triangular numbers (each T_k = k*(k-1)//2) and minimize the total nodes (which is the sum of the k_i).\n\n        Note: we can use the triangular numbers arbitrarily (with repetition). \n\n        This is similar to the coin change problem, but we wish to minimize the total value (here, the base sum) given that the sum of the triangular numbers is p.\n\n        However, note: the triangular numbers are not the usual coins. We can use any triangular number (from T_1=0, T_2=1, T_3=3, T_4=6, ...). \n\n        We can use the following:\n\n          We know that the triangular numbers are increasing. We can use a greedy-like method: use as many large triangular numbers as possible, because a large triangular number gives more p per node? \n\n        But note: the goal is to minimize the total nodes (n) for a fixed p. \n\n        Let T(k) = k*(k-1)//2.\n\n        Consider: to represent a number p, we can use:\n\n          Let k_max be the maximum k such that T(k) <= p.\n\n          Then, we can use one SCC of size k_max, leaving p1 = p - T(k_max). Then we need to represent p1 with the minimal total nodes.\n\n        However, is that optimal? \n\n        Example: p=4.\n\n          k_max: T(3)=3, T(4)=6 -> so k_max=3, then p1=1. Then we use one SCC of size 3 (using 3 nodes) and one SCC of size 2 (T(2)=1, using 2 nodes) -> total nodes=5.\n\n          But is there a better representation? \n\n          Alternatively, we can use four SCCs of size 2: T(2)=1, four times: 4, and total nodes=8. But 8>5, so the first representation is better.\n\n        Another example: p=5.\n\n          k_max: T(3)=3, then p1=2. Then we can use one SCC of size 3 (3 nodes) and then p1=2. How to represent 2? \n            We can use an SCC of size 2: T(2)=1, then we have 3+1=4, which is less than 5 -> not enough.\n            Or we can use two SCCs of size 2: then T(2)+T(2)=2, so total p=3+2=5. Then total nodes=3+2+2=7.\n\n          Alternatively, we can use one SCC of size 4: T(4)=6 -> too big.\n\n          Or two SCCs: one of size 3 and one of size 3: then p=3+3=6 -> too big.\n\n          Or one SCC of size 3 and one of size 2: p=3+1=4 -> not enough.\n\n          Or three SCCs: two of size 2 and one of size 1: p=1+1+0=2 -> not enough.\n\n          Or one SCC of size 3 and two SCCs of size 1: p=3+0+0=3 -> not enough.\n\n          Or one SCC of size 3, one SCC of size 2, and one SCC of size 1: p=3+1+0=4 -> not enough.\n\n          Or one SCC of size 3 and one SCC of size 2: already considered.\n\n          So the representation with two SCCs of size 2 and one SCC of size 3? Wait, that's the same as above (7 nodes). \n\n          Alternatively, we can use five SCCs of size 2: then p=5*1=5, and nodes=10. Worse.\n\n          Or one SCC of",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, meaning it contains exactly p ordered pairs of nodes (u, v) where u < v and u and v are mutually reachable. Additionally, among all such graphs with the minimum number of nodes, we need to find the maximum number of unidirectional pairs (ordered pairs (u, v) where there is a path from u to v but no path from v to u).\n\n### Approach\n1. **Problem Analysis**: The key observation is that mutual reachability between two nodes implies they belong to the same strongly connected component (SCC). The number of mutual pairs (u, v) with u < v in an SCC of size k is given by the triangular number \\( T_k = k*(k-1)/2 \\). The problem reduces to representing p as a sum of triangular numbers while minimizing the total number of nodes (sum of the sizes of all SCCs).\n\n2. **Insight**: To minimize the total number of nodes, we should use the largest possible SCCs first because larger SCCs contribute more to p per node. This greedy approach ensures we use the fewest nodes possible.\n\n3. **Algorithm Selection**: We use a greedy algorithm to decompose p into a sum of triangular numbers. Starting from the largest triangular number less than or equal to p, we subtract it from p and repeat the process until p is reduced to zero. The sum of the bases (sizes) of these triangular numbers gives the minimal number of nodes.\n\n4. **Complexity Analysis**: The algorithm efficiently checks triangular numbers up to a certain limit. The maximum triangular number needed is for \\( k \\approx \\sqrt{2p} \\), making the approach feasible even for large p (up to 200,000).\n\n5. **Unidirectional Pairs Calculation**: Once the minimal number of nodes \\( n \\) is found, the maximum number of unidirectional pairs is calculated using the formula \\( (n^2 - 2p - n) / 2 \\). This formula arises from the fact that all edges between different SCCs (arranged in a total order) contribute to unidirectional pairs, while edges within SCCs do not.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    p = int(sys.stdin.readline().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    k = 1\n    triangular = [0]\n    while True:\n        t_val = k * (k - 1) // 2\n        if t_val > p:\n            break\n        triangular.append(t_val)\n        k += 1\n        \n    n = 0\n    remaining = p\n    sizes = []\n    \n    while remaining > 0:\n        best_k = 0\n        for i in range(len(triangular) - 1, -1, -1):\n            if triangular[i] <= remaining:\n                best_k = i + 1\n                break\n        if best_k == 0:\n            break\n        t_val = triangular[best_k - 1]\n        remaining -= t_val\n        n += best_k\n        sizes.append(best_k)\n        \n    while remaining > 0:\n        n += 1\n        if n*(n-1)//2 >= remaining:\n            break\n            \n    total_nodes = n\n    unidirectional_pairs = (total_nodes * total_nodes - 2 * p - total_nodes) // 2\n    print(f\"{total_nodes} {unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer p, which represents the number of mutual pairs required.\n2. **Special Case Handling**: If p is zero, the solution is trivially zero nodes and zero unidirectional pairs.\n3. **Triangular Number Generation**: The algorithm generates all triangular numbers up to the largest one not exceeding p. Each triangular number corresponds to an SCC of a certain size.\n4. **Greedy Decomposition**: The algorithm decomposes p into a sum of triangular numbers by always selecting the largest possible triangular number at each step. This ensures the minimal number of nodes.\n5. **Node Calculation**: The total nodes used is the sum of the sizes of all SCCs selected during decomposition.\n6. **Unidirectional Pairs Calculation**: Using the derived formula, the maximum number of unidirectional pairs is computed based on the total nodes and the original p value.\n7. **Output**: The results, consisting of the minimal number of nodes and the maximum unidirectional pairs, are printed.\n\nThis approach efficiently addresses the problem by leveraging mathematical insights and greedy decomposition to minimize the number of nodes while maximizing unidirectional pairs in the resulting graph.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    p = int(sys.stdin.readline().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    k = 1\n    triangular = [0]\n    while True:\n        t_val = k * (k - 1) // 2\n        if t_val > p:\n            break\n        triangular.append(t_val)\n        k += 1\n        \n    n = 0\n    remaining = p\n    sizes = []\n    \n    while remaining > 0:\n        best_k = 0\n        for i in range(len(triangular) - 1, -1, -1):\n            if triangular[i] <= remaining:\n                best_k = i + 1\n                break\n        if best_k == 0:\n            break\n        t_val = triangular[best_k - 1]\n        remaining -= t_val\n        n += best_k\n        sizes.append(best_k)\n        \n    while remaining > 0:\n        n += 1\n        if n*(n-1)//2 >= remaining:\n            break\n            \n    total_nodes = n\n    unidirectional_pairs = (total_nodes * total_nodes - 2 * p - total_nodes) // 2\n    print(f\"{total_nodes} {unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 1005,
        "thoughts_token_count": 8191
    }
}