{
    "start": 1758088064.182751,
    "end": 1758089042.058167,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:04 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (l, r, cost)\n We need two vouchers i and j such that:\n   (1) They don't intersect: either r_i < l_j or r_j < l_i.\n   (2) The sum of their durations is exactly x: (r_i - l_i + 1) + (r_j - l_j + 1) = x.\n\n We are to minimize the total cost (cost_i + cost_j).\n\n Steps:\n\n 1. Note: The duration of a voucher i is d_i = r_i - l_i + 1.\n\n 2. We are looking for two vouchers with durations d1 and d2 such that d1 + d2 = x.\n\n 3. We can group the vouchers by their duration. For each duration d, we want to keep the minimal cost for a voucher of that duration, but note: there might be multiple vouchers with the same duration and different costs, and also different intervals.\n\n However, caution: two vouchers must not intersect. So even if we have two vouchers with durations d1 and d2 (with d1+d2=x), we must check non-overlapping condition.\n\n But note: we cannot simply take the cheapest voucher for each duration because even if one is cheap, it might overlap with the other.\n\n Alternative approach:\n\n Let's define:\n   Let A[d] = list of all vouchers (or at least store some information) for duration d.\n\n But note: the constraints: n, x, and days up to 200,000.\n\n We are going to consider:\n\n   We need two durations: d and x-d.\n\n   Then, for each voucher in duration d, we need to find a voucher in duration x-d that does not intersect with it.\n\n   However, we cannot iterate over every voucher in the two groups (which could be up to 200,000 each, and then 200,000 * 200,000 which is 40e9, too slow).\n\n 4. We need a smarter way.\n\n Idea:\n\n   Precompute for each duration d (from 1 to maybe 200000) the minimum cost and also the entire set of intervals? But storing all intervals for each duration would be too heavy.\n\n Alternatively, we can think:\n\n   We are only concerned about two conditions: \n        Condition 1: d1 + d2 = x.\n        Condition 2: Non-overlapping.\n\n   We can break the problem:\n\n   Step 1: Group vouchers by duration. For each duration d, we want to store:\n        - The minimal cost for a voucher of duration d (but wait, we also need to know the interval [l, r] to check non-overlap). \n\n   However, we might have multiple vouchers with the same duration and different intervals. We want to use the cheapest one that doesn't conflict with a voucher of the complementary duration.\n\n   But note: we are allowed to choose two vouchers arbitrarily (not necessarily the cheapest ones independently). However, we want the minimal total cost.\n\n   Alternate idea:\n\n   Let's precompute an array `min_cost` for each duration d: the minimal cost for a voucher of duration d.\n\n   But this is not enough because even if we have a cheap voucher of duration d, if all vouchers of duration x-d that do not overlap with it are expensive, then maybe we should consider a more expensive voucher of duration d that allows a cheaper voucher of duration x-d?\n\n   However, note: the condition of non-overlap depends on the specific intervals.\n\n   We need to consider: for each duration d, we want to quickly query for a voucher in duration d' = x-d that does not overlap with a given voucher (l, r) of duration d, and then update the minimal cost.\n\n   But the problem is that the non-overlap condition is defined by the intervals.\n\n   Another idea: Instead of grouping by duration, we can try to fix the two durations (d and x-d) and then for each voucher in duration d, we look for a voucher in duration x-d that does not overlap.\n\n   However, the total number of vouchers is n (<=200,000) and we have two groups: one for d and one for x-d. But the total number of pairs is the product of the two groups, which in worst-case could be (n/2) * (n/2) = 25e9 which is too high.\n\n   We need to optimize.\n\n   Observation:\n\n   Two vouchers (i and j) do not intersect if:\n        r_i < l_j OR r_j < l_i.\n\n   Without loss of generality, we can assume that we fix the first voucher (i) and then the second voucher (j) must satisfy either:\n        Case 1: j starts after i ends (r_i < l",
    "response": "\nTo solve this problem, we need to find two non-overlapping travel vouchers such that the sum of their durations equals exactly `x` and their total cost is minimized. The solution involves efficiently grouping the vouchers by their durations and then checking for compatible pairs without overlapping intervals.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration (i.e., `r_i - l_i + 1`). For each duration `d`, we store a list of tuples `(l_i, r_i, cost_i)` where the voucher's duration is `d`.\n2. **Check Complementary Durations**: For each duration `d`, we check if there exists a complementary duration `x - d`. If such a duration exists, we proceed to find the minimal cost pair of vouchers from these two groups that do not overlap.\n3. **Efficient Non-overlap Check**: To ensure two vouchers do not overlap, we use the condition that either the first voucher ends before the second starts (`r_i < l_j`) or vice versa (`r_j < l_i`). For each voucher in the first group, we look for the cheapest voucher in the complementary group that satisfies the non-overlap condition.\n4. **Optimization Using Sorting and Binary Search**: For each group of vouchers with the same duration, we sort them by their departure day (`l_i`). Additionally, we maintain a separate list sorted by departure day but also keep track of the minimal cost encountered up to each point. This allows us to perform binary searches to quickly find the cheapest voucher in the complementary group that starts after the current voucher ends.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_left\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        \n    groups = {}\n    for l, r, cost_val in vouchers:\n        d = r - l + 1\n        if d not in groups:\n            groups[d] = []\n        groups[d].append((l, r, cost_val))\n        \n    min_total_cost = float('inf')\n    found = False\n    \n    for d1 in list(groups.keys()):\n        d2 = x - d1\n        if d2 not in groups or d1 == d2 and len(groups[d1]) < 2:\n            continue\n            \n        list1 = groups[d1]\n        list2 = groups[d2]\n        \n        if d1 == d2:\n            list2 = list2.copy()\n            \n        list1_sorted_by_l = sorted(list1, key=lambda x: x[0])\n        list2_sorted_by_l = sorted(list2, key=lambda x: x[0])\n        \n        min_cost_arr2 = [0]*len(list2_sorted_by_l)\n        min_so_far = float('inf')\n        for idx in range(len(list2_sorted_by_l)-1, -1, -1):\n            l2, r2, c2 = list2_sorted_by_l[idx]\n            if c2 < min_so_far:\n                min_so_far = c2\n            min_cost_arr2[idx] = min_so_far\n            \n        for trip in list1_sorted_by_l:\n            l1, r1, c1 = trip\n            pos = bisect_left(list2_sorted_by_l, (r1+1, 0, 0))\n            if pos < len(list2_sorted_by_l):\n                candidate_cost = min_cost_arr2[pos]\n                total_cost = c1 + candidate_cost\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    found = True\n                    \n        if d1 == d2:\n            continue\n            \n        list2_sorted_by_r = sorted(list2, key=lambda x: x[1])\n        min_cost_arr3 = [0]*len(list2_sorted_by_r)\n        min_so_far = float('inf')\n        for idx in range(len(list2_sorted_by_r)-1, -1, -1):\n            l2, r2, c2 = list2_sorted_by_r[idx]\n            if c2 < min_so_far:\n                min_so_far = c2\n            min_cost_arr3[idx] = min_so_far\n            \n        for trip in list1_sorted_by_l:\n            l1, r1, c1 = trip\n            pos = bisect_left(list2_sorted_by_r, (0, r1+1, 0))\n            if pos < len(list2_sorted_by_r):\n                candidate_cost = min_cost_arr3[pos]\n                total_cost = c1 + candidate_cost\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    found = True\n                    \n    if not found:\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into a list of vouchers, each characterized by its start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration (calculated as `end - start + 1`). This helps in efficiently accessing all vouchers of a specific duration.\n3. **Complementary Duration Check**: For each duration `d`, the algorithm checks if there exists a complementary duration `x - d`. If found, it proceeds to find the minimal cost pair between the two groups.\n4. **Non-overlap Check**: For each voucher in the first group, the algorithm uses binary search to find the cheapest voucher in the complementary group that starts after the current voucher ends. This ensures the vouchers do not overlap.\n5. **Cost Calculation**: The total cost of valid pairs is tracked, and the minimal cost is updated whenever a cheaper valid pair is found.\n6. **Output**: If no valid pair is found, `-1` is printed; otherwise, the minimal total cost is printed.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_left\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        \n    groups = {}\n    for l, r, cost_val in vouchers:\n        d = r - l + 1\n        if d not in groups:\n            groups[d] = []\n        groups[d].append((l, r, cost_val))\n        \n    min_total_cost = float('inf')\n    found = False\n    \n    for d1 in list(groups.keys()):\n        d2 = x - d1\n        if d2 not in groups or d1 == d2 and len(groups[d1]) < 2:\n            continue\n            \n        list1 = groups[d1]\n        list2 = groups[d2]\n        \n        if d1 == d2:\n            list2 = list2.copy()\n            \n        list1_sorted_by_l = sorted(list1, key=lambda x: x[0])\n        list2_sorted_by_l = sorted(list2, key=lambda x: x[0])\n        \n        min_cost_arr2 = [0]*len(list2_sorted_by_l)\n        min_so_far = float('inf')\n        for idx in range(len(list2_sorted_by_l)-1, -1, -1):\n            l2, r2, c2 = list2_sorted_by_l[idx]\n            if c2 < min_so_far:\n                min_so_far = c2\n            min_cost_arr2[idx] = min_so_far\n            \n        for trip in list1_sorted_by_l:\n            l1, r1, c1 = trip\n            pos = bisect_left(list2_sorted_by_l, (r1+1, 0, 0))\n            if pos < len(list2_sorted_by_l):\n                candidate_cost = min_cost_arr2[pos]\n                total_cost = c1 + candidate_cost\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    found = True\n                    \n        if d1 == d2:\n            continue\n            \n        list2_sorted_by_r = sorted(list2, key=lambda x: x[1])\n        min_cost_arr3 = [0]*len(list2_sorted_by_r)\n        min_so_far = float('inf')\n        for idx in range(len(list2_sorted_by_r)-1, -1, -1):\n            l2, r2, c2 = list2_sorted_by_r[idx]\n            if c2 < min_so_far:\n                min_so_far = c2\n            min_cost_arr3[idx] = min_so_far\n            \n        for trip in list1_sorted_by_l:\n            l1, r1, c1 = trip\n            pos = bisect_left(list2_sorted_by_r, (0, r1+1, 0))\n            if pos < len(list2_sorted_by_r):\n                candidate_cost = min_cost_arr3[pos]\n                total_cost = c1 + candidate_cost\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    found = True\n                    \n    if not found:\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1319,
        "thoughts_token_count": 1023
    }
}