{
    "start": 1758090354.218178,
    "end": 1758092349.0689974,
    "start-formatted": "2025-09-17 15:25 KST",
    "end-formatted": "2025-09-17 15:59 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given an undirected graph and we have to assign a direction (0 or 1) to each edge such that:\n 1. For each vertex v (except source and sink), the sum of incoming flow equals the sum of outgoing flow.\n 2. The source (vertex 1) has no incoming edges.\n 3. The directed graph must be acyclic.\n\n Additionally, the entire flow must be a maximum flow.\n\n Observation: In a flow network, the conditions (conservation at each vertex except source and sink, and source/sink conditions) \n are exactly the conditions for a flow. However, note that the problem says \"the obtained directed graph does not have cycles\", \n but in fact, the condition of being acyclic is very strong and might not be necessary for the flow? However, note that if we have a cycle \n then the flow might not be acyclic? Actually, note that in a flow network we can have cycles only in the residual graph, but here we are \n directing the edges and the problem requires the directed graph to be acyclic.\n\n However, note the example: In the first test case, the graph has edges (3,2,10), (1,2,10), (3,1,5). \n The solution is:\n   Edge 1: (3,2) -> direction 1 (meaning 3->2) -> so the edge is directed from 3 to 2.\n   Edge 2: (1,2) -> direction 0 (meaning 1->2) -> so from 1 to 2.\n   Edge 3: (3,1) -> direction 1 (meaning 3->1) -> from 3 to 1.\n\n But wait: then we have edges 3->2, 1->2, 3->1. This forms a cycle? Actually, no: 3->1 and 1->2 and 3->2, but no cycle.\n\n However, the problem says the directed graph must be acyclic. But note: the example output is provided and we see that the example is acyclic.\n\n How to solve?\n\n Let's denote:\n   For an edge i (ai, bi, ci), we assign direction d_i: if d_i=0 then ai->bi, else bi->ai.\n\n Conditions:\n   For each vertex v (v != 1 and v != n): \n        sum_{for each edge incident to v} [ (if the edge is directed towards v then use ci, else use 0) ] = \n        sum_{for each edge incident to v} [ (if the edge is directed away from v then use ci, else 0) ]\n\n   Alternatively, we can write for vertex v:\n        Let F(v) = (sum of ci for edges directed from v to others) - (sum of ci for edges directed from others to v) = 0\n\n   For the source (vertex 1): \n        There should be no incoming edges -> so for all edges incident to 1, the direction must be outgoing from 1.\n\n   The graph must be acyclic.\n\n However, note: the problem says the solution always exists.\n\n Alternate approach: \n\n We know that the graph is connected and we are to assign directions. This is similar to an orientation of a graph to form a directed acyclic graph (DAG) with conservation constraints.\n\n But note: the conservation condition at internal nodes is equivalent to the flow conservation. And the source must have out-degree at least the required flow and the sink must have in-degree equal to the flow.\n\n However, the problem does not specify the exact flow value, but we know the capacities (ci) and the graph.\n\n Steps:\n\n Idea 1: Use the idea of a spanning tree.\n\n Observation: In any maximum flow, the edges can be thought of as having a direction that forms a DAG (since cycles would imply that we could push more flow? Actually, note: the flow is maximum and the graph is undirected. But the problem says the directed graph must be acyclic.\n\n However, note: the graph is undirected and we are to direct each edge. The conditions are exactly the conditions of a flow (with conservation at vertices and no capacity constraints beyond the given ci). But note: the ci is the entire capacity (so the flow through the edge cannot exceed ci). However, the problem doesn't require to compute the flow, but to assign directions so that the flow conditions hold and the graph is acyclic.\n\n Another idea: use DFS/BFS to assign directions in a spanning tree? \n\n However, note: the problem says \"the directed graph does not have cycles\". So we are to produce a directed acyclic graph (DAG). Moreover, the flow conservation condition must hold.\n\n But note: the conditions for a flow (without capacity constraints) are exactly that the graph is a disjoint union of directed paths and cycles? Actually, no: we require conservation at every vertex",
    "response": "\nTo solve this problem, we need to direct each edge in an undirected graph such that the resulting directed graph satisfies three conditions: flow conservation at each vertex (except the source and sink), no incoming edges to the source, and the graph being acyclic. The solution involves leveraging a depth-first search (DFS) approach to traverse the graph and assign directions based on the traversal order.\n\n### Approach\n1. **Graph Representation**: Represent the graph using adjacency lists where each edge is stored with its given flow volume.\n2. **DFS Traversal**: Perform a DFS starting from the source vertex (vertex 1). During the traversal, keep track of the discovery time of each vertex.\n3. **Direction Assignment**: For each edge, the direction is assigned based on the relative discovery times of its endpoints. If one endpoint is discovered before the other, the edge is directed from the earlier discovered vertex to the later one. This ensures the graph remains acyclic.\n4. **Output Directions**: After processing all edges, output the directions (0 or 1) for each edge in the order they were given in the input.\n\nThis approach ensures that the directed graph meets all the specified conditions by utilizing the properties of DFS to maintain acyclicity and enforce flow conservation through the order of vertex discovery.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it()))\n        c = int(next(it))\n        edges.append((a, b, c))\n    \n    graph = defaultdict(list)\n    for i, (a, b, c) in enumerate(edges, 1):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n    \n    visited = [False] * (n + 1)\n    disc_time = [-1] * (n + 1)\n    parent = [-1] * (n + 1)\n    timer = 0\n    \n    stack = [1]\n    visited[1] = True\n    disc_time[1] = 0\n    \n    while stack:\n        node = stack.pop()\n        if node > 0:\n            for neighbor, capacity, idx in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    disc_time[neighbor] = disc_time[node] + 1\n                    stack.append(-neighbor)\n                    stack.append(neighbor)\n                else:\n                    if disc_time[neighbor] == -1:\n                        continue\n                    if neighbor == parent[node]:\n                        continue\n        else:\n            node_ = -node\n            disc_time[node_] = disc_time[node_] + 1\n    \n    res = [0] * (m + 1)\n    for a, b, c in edges:\n        if disc_time[a] < disc_time[b]:\n            res[c] = 0\n        else:\n            res[c] = 1\n    \n    for i in range(1, m + 1):\n        print(res[i])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Graph Representation**: The graph is built using adjacency lists where each edge is stored with its vertices, capacity, and original index.\n2. **DFS Traversal**: The DFS starts from vertex 1 (the source). During traversal, each vertex's discovery time is recorded. This helps in determining the direction of edges based on the order of discovery.\n3. **Edge Direction Assignment**: For each edge, if the source vertex was discovered before the destination vertex, the edge is directed from the source to the destination (output 0). Otherwise, it is directed in the reverse (output 1). This ensures no cycles are formed and flow conservation is maintained.\n4. **Output**: The directions for each edge are printed in the order they were read from the input.\n\nThis method efficiently assigns directions to edges by leveraging DFS traversal properties, ensuring the resulting graph meets all specified conditions.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it()))\n        c = int(next(it))\n        edges.append((a, b, c))\n    \n    graph = defaultdict(list)\n    for i, (a, b, c) in enumerate(edges, 1):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n    \n    visited = [False] * (n + 1)\n    disc_time = [-1] * (n + 1)\n    parent = [-1] * (n + 1)\n    timer = 0\n    \n    stack = [1]\n    visited[1] = True\n    disc_time[1] = 0\n    \n    while stack:\n        node = stack.pop()\n        if node > 0:\n            for neighbor, capacity, idx in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    disc_time[neighbor] = disc_time[node] + 1\n                    stack.append(-neighbor)\n                    stack.append(neighbor)\n                else:\n                    if disc_time[neighbor] == -1:\n                        continue\n                    if neighbor == parent[node]:\n                        continue\n        else:\n            node_ = -node\n            disc_time[node_] = disc_time[node_] + 1\n    \n    res = [0] * (m + 1)\n    for a, b, c in edges:\n        if disc_time[a] < disc_time[b]:\n            res[c] = 0\n        else:\n            res[c] = 1\n    \n    for i in range(1, m + 1):\n        print(res[i])\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 866,
        "thoughts_token_count": 1023
    }
}