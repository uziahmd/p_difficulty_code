{
    "start": 1758300453.7650635,
    "end": 1758304108.0060027,
    "start-formatted": "2025-09-20 01:47 KST",
    "end-formatted": "2025-09-20 02:48 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are to find the minimum number of edges t to add to form an odd cycle, and the number of ways w (without adding loops or parallel edges).\n\n Observing:\n  - An odd cycle must have at least 3 edges (triangle) and the length is odd (3,5,7,...).\n\n We are prohibited from adding parallel edges or loops.\n\n Steps:\n\n 1. If the graph already has an odd-length cycle, then t=0 and w=1? But note: the problem says \"form a simple cycle of an odd length\". However, if there is one already, then we don't need to add any edge.\n\n However, note the example: \n   Input: \"3 3\\n1 2\\n2 3\\n3 1\" -> Output: \"0 1\"\n\n But wait, the problem says: \"minimum number of edges that must be added\", so if the graph already has an odd cycle, then we don't need to add any.\n\n However, the problem also says: \"the number of ways to add t edges in order to form a cycle of an odd length\".\n\n Important: The problem does not say that the cycle must be present only by the added edges. It can be formed by the existing edges and the added ones? Actually, note: we are allowed to add edges arbitrarily (without creating parallel or loops) and the goal is to form an odd cycle. So if the graph already has an odd cycle, then we don't need to add any edge, and there is exactly one way: add nothing.\n\n But wait, what if there are multiple odd cycles? Then even if we don't add any edge, we still have an odd cycle. So the condition for t=0 is that the graph already has at least one odd cycle.\n\n However, note: the problem says \"to form a cycle\", meaning that the cycle might be entirely in the original graph or might be formed by some existing edges and some added edges.\n\n But the problem asks for the minimum number of edges to add. So we consider:\n\n Case 1: If the graph already has an odd cycle -> t=0, w=1.\n\n But wait, what if we have multiple odd cycles? The problem doesn't require counting the number of odd cycles, but the number of ways to add t edges (which is 0) that lead to having an odd cycle. However, since the graph already has an odd cycle, then no matter how we add edges (if we add 0 edges) we still have an odd cycle. But note: we are only counting the ways to add exactly t edges (so when t=0, we count the ways to add 0 edges). And the condition is that after adding these edges, the graph must contain an odd cycle. Since the graph already has one, then the set of edges we add (empty) is the only way. So w=1.\n\n Case 2: If the graph has no odd cycle, then we consider:\n\n  We know that in any graph, the absence of odd cycles is equivalent to the graph being bipartite. So we can check if the graph is bipartite.\n\n  But note: even if the graph is not connected, we can check bipartiteness for each connected component.\n\n  However, note: a graph without odd cycles is bipartite. But the converse is also true: if a graph is bipartite, then it has no odd cycles.\n\n  So if the graph is bipartite (i.e., all connected components are bipartite), then we don't have an odd cycle.\n\n  Now, what is the minimum number of edges to add to create an odd cycle?\n\n  We can think:\n\n  Option 1: Add edges within the same part of a bipartite component? Because if we connect two nodes in the same part, then we can form a cycle of odd length? \n\n  Consider: \n    Let the bipartite graph have two colors (say 0 and 1). If we add an edge between two nodes of color 0, then consider a path from one endpoint to the other (which exists because they are in the same connected component, unless they are disconnected). However, the entire graph is bipartite, so the shortest path between two nodes of the same color has even length. Then the cycle formed by the edge and the path is odd (even + 1). \n\n  But wait, what if the two nodes are in different connected components? Then adding an edge between them would merge two bipartite components. However, then we can form an odd cycle only if we can traverse from one to the other via the edge and then use a path in the merged graph? Actually, if we connect two nodes in the same color but from different connected components, then we cannot form an immediate odd cycle because there is no path connecting the two components (until we add the edge). Then the cycle must use the added edge and two paths",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges to add to an undirected graph so that it contains at least one simple cycle of odd length. Additionally, we need to count the number of ways to add these edges without creating any loops or parallel edges.\n\n### Approach\n1. **Check for Existing Odd Cycles**: The graph may already contain an odd-length cycle. If it does, no edges need to be added (t = 0), and there is exactly one way to achieve this (by adding nothing).\n\n2. **Bipartite Check**: If the graph does not contain any odd cycles, it must be bipartite. A graph is bipartite if its vertices can be divided into two sets such that no two vertices within the same set are adjacent. We use a BFS or DFS approach to check bipartiteness for each connected component.\n\n3. **Minimum Edges to Add**: If the graph is bipartite, adding an edge between two vertices in the same set will create an odd cycle. The minimum number of edges required is 1, unless the graph is disconnected, in which case more edges might be needed to connect components and form an odd cycle.\n\n4. **Counting Valid Edges**: For each connected component, count the number of edges that can be added within the same set (same color) to form an odd cycle. The total number of ways to add edges is the product of valid edges across all components, minus any edges already present.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u = int(next(it)); v = int(next(it))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [0] * (n+1)\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n    comp_id = [-1] * (n+1)\n    comp_count = 0\n    \n    for i in range(1, n+1):\n        if visited[i] == 0:\n            comp_count += 1\n            q = deque([i])\n            visited[i] = 1\n            color[i] = 0\n            comp_nodes = [i]\n            comp_id[i] = comp_count\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if visited[neighbor] == 0:\n                        visited[neighbor] = 1\n                        color[neighbor] = color[node] ^ 1\n                        comp_nodes.append(neighbor)\n                        comp_id[neighbor] = comp_count\n                        q.append(neighbor)\n                    elif visited[neighbor] == 1:\n                        if color[neighbor] == color[node]:\n                            is_bipartite = False\n            components.append(comp_nodes)\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_ways = 1\n    t_edges = 0\n\n    for nodes in components:\n        c0 = 0\n        c1 = 0\n        for node in nodes:\n            if color[node] == 0:\n                c0 += 1\n            else:\n                c1 += 1\n                \n        if c0 * c1 == 0:\n            continue\n            \n        same_color_edges = c0*(c0-1)//2 + c1*(c1-1)//2\n        existing_edges = len(graph[nodes[0]])\n        for i in range(1, len(nodes)):\n            existing_edges += len(graph[nodes[i]])\n            existing_edges //= 2\n            break\n            \n        available_edges = same_color_edges - existing_edges\n        if available_edges > 0:\n            t_edges = 1\n            total_ways *= available_edges\n            \n    if t_edges == 0:\n        print(\"0 1\")\n    else:\n        print(f\"1 {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices and edges, followed by the edges themselves.\n2. **Graph Construction**: The graph is represented as an adjacency list.\n3. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness. If any component is found to be non-bipartite, the graph contains an odd cycle, and the answer is `0 1`.\n4. **Edge Calculation**: For each bipartite component, the number of edges that can be added within the same set (to form an odd cycle) is calculated. The product of these values across all components gives the total number of ways to add edges.\n5. **Output**: The result is printed based on whether the graph was already non-bipartite (requiring no edges) or bipartite (requiring at least one edge addition).\n\nThis approach efficiently checks for the presence of odd cycles and calculates the minimal edge additions needed, ensuring optimal performance even for large graphs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u = int(next(it)); v = int(next(it))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [0] * (n+1)\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n    comp_id = [-1] * (n+1)\n    comp_count = 0\n    \n    for i in range(1, n+1):\n        if visited[i] == 0:\n            comp_count += 1\n            q = deque([i])\n            visited[i] = 1\n            color[i] = 0\n            comp_nodes = [i]\n            comp_id[i] = comp_count\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if visited[neighbor] == 0:\n                        visited[neighbor] = 1\n                        color[neighbor] = color[node] ^ 1\n                        comp_nodes.append(neighbor)\n                        comp_id[neighbor] = comp_count\n                        q.append(neighbor)\n                    elif visited[neighbor] == 1:\n                        if color[neighbor] == color[node]:\n                            is_bipartite = False\n            components.append(comp_nodes)\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_ways = 1\n    t_edges = 0\n\n    for nodes in components:\n        c0 = 0\n        c1 = 0\n        for node in nodes:\n            if color[node] == 0:\n                c0 += 1\n            else:\n                c1 += 1\n                \n        if c0 * c1 == 0:\n            continue\n            \n        same_color_edges = c0*(c0-1)//2 + c1*(c1-1)//2\n        existing_edges = len(graph[nodes[0]])\n        for i in range(1, len(nodes)):\n            existing_edges += len(graph[nodes[i]])\n            existing_edges //= 2\n            break\n            \n        available_edges = same_color_edges - existing_edges\n        if available_edges > 0:\n            t_edges = 1\n            total_ways *= available_edges\n            \n    if t_edges == 0:\n        print(\"0 1\")\n    else:\n        print(f\"1 {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 573,
        "completion_token_count": 1109,
        "thoughts_token_count": 1023
    }
}