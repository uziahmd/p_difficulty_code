{
    "start": 1758091965.9321845,
    "end": 1758093365.5938754,
    "start-formatted": "2025-09-17 15:52 KST",
    "end-formatted": "2025-09-17 16:16 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given an undirected graph and we have to assign directions to each edge such that:\n 1. For each vertex v (except source and sink), the sum of incoming flows equals the sum of outgoing flows.\n 2. Vertex 1 has no incoming edges (so all edges incident to vertex 1 must be directed away from it).\n 3. The entire directed graph is acyclic.\n\n However, note that the problem does not require the flow to be maximum in the usual sense (since we are only given the graph and the flow volumes for edges) but the conditions above must hold.\n\n Important: The solution always exists.\n\n Observation:\n We are essentially assigning a direction to each edge with capacity c_i. The conditions imply that the graph must form a directed acyclic graph (DAG) and satisfy conservation at each node (except source and sink). But note: the source (vertex 1) must have no incoming, so we can think of the flow going out from the source.\n\n How to approach?\n\n Idea: We know that the graph must be a DAG and satisfy conservation. One way to ensure conservation is to assign directions so that the entire graph forms a flow from the source to the sink.\n\n However, note that the problem does not specify a particular flow decomposition (like using paths) but only that the conditions hold. Moreover, the capacities are fixed and the same as the original undirected graph.\n\n Another observation: The problem says the graph is connected and has m edges (at least n-1, at most 200000). We are also told that the solution always exists.\n\n Steps:\n\n 1. We note that the condition of having no cycles and satisfying conservation at every vertex (except source and sink) is similar to forming an arborescence (a directed tree with root at source) but we have multiple edges and the graph is not necessarily a tree.\n\n 2. However, note the condition for vertex n (the sink) is that the inflow must equal the outflow? Actually, the condition says: \"for each vertex v (1 < v < n)\" meaning internal vertices. The source (vertex 1) has no incoming, so its outflow must equal its total incident flow (which is the inflow for other vertices). The sink (vertex n) must have no outgoing? Actually, the condition does not explicitly say about the sink, but by the conservation condition, since the sink is not required to have balanced flows (unless it's an internal vertex) — wait, the condition applies only for 1 < v < n. So for the sink (vertex n) we don't have the condition. But note: the entire flow must be from source to sink. Therefore, the sink must have only incoming edges (if we assume the flow goes from source to sink).\n\n However, the problem does not state that the sink must have no outgoing. But note: the graph is a flow network and the flow must go from source to sink. So any flow unit going through a vertex must eventually reach the sink. But the problem doesn't require the graph to have a unique sink? Actually, the graph is connected and we are given one source and one sink.\n\n Conditions for the sink (vertex n): \n   Since the source is 1 and the graph is connected, and we are to direct the edges so that the flow goes from 1 to n, then the sink should only have incoming edges.\n\n But note: the problem does not explicitly require that the sink has no outgoing. However, if we have an outgoing edge from the sink, then that edge would have to be considered as part of the flow? But then how would that flow continue? Actually, the problem says the graph is connected and the solution exists. And note: the condition for conservation applies only to vertices 1 < v < n. For vertex n, we don't require the conservation condition. But wait: what if we have an edge from the sink to somewhere else? Then that edge would have to be directed from the sink to another vertex. Then that other vertex would receive flow from two places: from the source and from the sink. But the sink is the destination, so typically we don't expect flow leaving the sink. However, the problem does not forbid it. \n\n But note: the problem says \"vertex 1 has no incoming\", and for internal vertices (excluding source and sink) we require balance. The sink is excluded from that. However, the condition of being acyclic and having the flow from source to sink might force that the sink only has incoming edges.\n\n However, the problem does not state that the flow must be entirely from source to sink. It just says the conditions on the graph: \n   - Source has no incoming.\n   - Each internal vertex has balanced flow.\n   - The graph is acyclic.\n\n But if we allow edges leaving the sink, then we break the acyclic condition? Not necessarily: we can have a cycle that",
    "response": "\nTo solve this problem, we need to direct each edge in an undirected graph such that the resulting directed graph satisfies specific flow conditions. The conditions are:\n1. For each vertex (except the source and sink), the sum of incoming flows equals the sum of outgoing flows.\n2. The source vertex has no incoming edges.\n3. The entire directed graph is acyclic.\n\n### Approach\n1. **Problem Analysis**: The problem requires transforming an undirected graph into a directed acyclic graph (DAG) where flow conservation is maintained at each internal vertex. The source must have all outgoing edges, and the sink must have all incoming edges. The solution involves determining the direction of each edge based on the graph's structure.\n\n2. **Key Insight**: The solution leverages topological sorting. By performing a topological sort on the graph, we can process vertices in an order that ensures edges are directed from higher-order vertices to lower-order vertices (or vice versa). This ensures the graph remains acyclic.\n\n3. **Algorithm Selection**:\n   - **Topological Sort**: We use Kahn's algorithm for topological sorting, which requires computing in-degrees of vertices. However, since the graph is initially undirected, we first convert it into a directed graph by assuming all edges point towards a particular vertex (in this case, vertex 1).\n   - **Edge Direction Assignment**: After topological sorting, edges are directed based on their positions in the topological order. If an edge connects two vertices, the direction is determined by their ranks in the topological sort.\n\n4. **Complexity Analysis**: The algorithm involves reading the graph, performing a topological sort (O(V + E)), and then processing each edge (O(E)). Thus, the overall complexity is O(V + E), which is efficient for the given constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        c = int(next(it))\n        edges.append((a, b, c))\n        \n    graph = [[] for _ in range(n+1)]\n    for i, (a, b, c) in enumerate(edges):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n        \n    indegree = [0] * (n+1)\n    for i in range(1, n+1):\n        for neighbor, weight, idx in graph[i]:\n            if i == 1:\n                continue\n            indegree[neighbor] += 1\n            \n    q = deque()\n    for i in range(1, n+1):\n        if indegree[i] == 0:\n            q.append(i)\n            \n    topo_order = []\n    while q:\n        node = q.popleft()\n        topo_order.append(node)\n        for neighbor, weight, idx in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n                \n    order_map = {node: idx for idx, node in enumerate(topo_order)}\n    \n    ans = [-1] * m\n    for i, (a, b, c) in enumerate(edges):\n        ra = order_map[a]\n        rb = order_map[b]\n        if ra < rb:\n            ans[i] = 0\n        else:\n            ans[i] = 1\n            \n    for a in ans:\n        print(a)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices `n` and edges `m`, followed by the edges themselves.\n2. **Graph Construction**: An adjacency list is built for the graph, storing each edge along with its index for later reference.\n3. **Topological Sorting**: Using Kahn's algorithm, we perform a topological sort starting from vertices with zero in-degree (initially, only the source vertex 1 is considered, but others are added as their in-degrees drop to zero).\n4. **Edge Direction Assignment**: For each edge, the direction is determined by comparing the topological order indices of its endpoints. If the edge starts at a vertex with a lower index, it is directed from the lower index to the higher one (output `0`); otherwise, it is directed in the opposite way (output `1`).\n5. **Output**: The directions for all edges are printed in the order they were read.\n\nThis approach efficiently transforms the undirected graph into a directed acyclic graph meeting the specified flow conditions by leveraging topological sorting and careful edge direction assignment.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        c = int(next(it))\n        edges.append((a, b, c))\n        \n    graph = [[] for _ in range(n+1)]\n    for i, (a, b, c) in enumerate(edges):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n        \n    indegree = [0] * (n+1)\n    for i in range(1, n+1):\n        for neighbor, weight, idx in graph[i]:\n            if i == 1:\n                continue\n            indegree[neighbor] += 1\n            \n    q = deque()\n    for i in range(1, n+1):\n        if indegree[i] == 0:\n            q.append(i)\n            \n    topo_order = []\n    while q:\n        node = q.popleft()\n        topo_order.append(node)\n        for neighbor, weight, idx in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n                \n    order_map = {node: idx for idx, node in enumerate(topo_order)}\n    \n    ans = [-1] * m\n    for i, (a, b, c) in enumerate(edges):\n        ra = order_map[a]\n        rb = order_map[b]\n        if ra < rb:\n            ans[i] = 0\n        else:\n            ans[i] = 1\n            \n    for a in ans:\n        print(a)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 696,
        "completion_token_count": 1010,
        "thoughts_token_count": 1023
    }
}