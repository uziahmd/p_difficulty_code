{
    "start": 1758304252.7452247,
    "end": 1758308117.9045656,
    "start-formatted": "2025-09-20 02:50 KST",
    "end-formatted": "2025-09-20 03:55 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n We are given: \n   n, k and a list of n integers.\n\n Conditions:\n   - We must use exactly k days to solve n problems (so the last day must end at the last problem).\n   - Each day we solve a contiguous segment from the start (so the segments are non-overlapping and consecutive).\n\n The profit for a day is the maximum difficulty in that day's segment.\n The total profit is the sum of these maxima.\n\n Observation:\n   Since we cannot change the order, we can think greedily: we want to break the sequence into k contiguous segments.\n\n   However, note: the problem asks for the maximum total profit.\n\n   Let dp[i][j] be the maximum total profit we can get from the first i problems (i.e., the prefix) over j days.\n\n   But note: the constraints are n,k <= 2000, so an O(n^2 * k) solution might be borderline in C++ but in Python we need to be careful.\n\n   Alternatively, we can try to use the following idea:\n\n   We know that the entire sequence must be broken into k segments. The last segment must end at n.\n\n   Another observation: the profit for a day is the maximum in that segment. Therefore, if we let the segment boundaries be at positions p1, p2, ... pk-1 (so the segments are [0:p1], [p1:p2], ... [pk-1:n]), then the total profit is the sum of the maximums of each segment.\n\n   How to compute the maximum for a segment? We can precompute the maximums for all contiguous segments ending at a certain point? Actually, we can use the concept of \"next greater element\" to help with the segment boundaries?\n\n   Alternatively, we can use dynamic programming:\n\n   Let dp[j] = maximum total profit for the first j problems (using as many days as needed, but we have fixed k days and n problems). However, we also need to consider the number of days.\n\n   Let's define:\n      dp[i][d] = maximum total profit we can achieve from the prefix a[0..i-1] (i problems) using d days.\n\n   Then we have:\n      dp[0][0] = 0\n\n   For a state (i, d), we consider the last segment (the d-th day) covering from some position j to i-1 (0-indexed, so the segment is [j, i-1]). Then the profit for the last day would be M(j, i-1) = max(a[j...i-1]).\n\n   Then: \n        dp[i][d] = max_{j from 0 to i-1} { dp[j][d-1] + M(j, i-1) }\n\n   And then we require that the entire sequence is broken into k days: we want dp[n][k].\n\n   However, n, k up to 2000 -> 2000*2000 states, and for each state we do up to 2000 operations (j from 0 to i-1) -> worst-case about 8e9 operations which is too slow in Python.\n\n   We need to optimize.\n\n   Idea for optimization: \n\n   We note that the maximum value in the segment [j, i-1] is non-decreasing as j decreases (because we are including more elements). Also, the maximum in [j, i-1] is the same as the maximum in [j+1, i-1] if a[j] <= current maximum? Not necessarily.\n\n   Alternatively, we can precompute the next greater element to the left for each index? Or use a monotonic stack to compute the maximum over intervals.\n\n   However, note: we are iterating i from 1 to n, and for each i we iterate j from 0 to i-1.\n\n   Let's try to fix the last segment [j, i-1]. We can precompute for each ending index i, the maximum value in the segment [j, i-1] for every j. But that is O(i) per i, which is O(n^2) and then we do k layers? Actually, we have two nested loops (i from 1 to n, and j from 0 to i-1) so that is O(n^2). Then multiplied by k (since we have d from 1 to k) we get O(k * n^2) which is 2000 * (2000^2) = 8e9, which is too slow in Python.\n\n   We need a better approach.\n\n   Alternate Insight:\n\n   Notice that the entire sequence must be partitioned into k contiguous segments. The total profit is the sum of the maxima of the segments.\n\n   Consider: the maximum of a segment is at least the maximum of any subsegment. In particular, the global maximum (say M) must appear in one of the segments, and that segment's profit will be at least M. But note: if we have multiple segments that contain M, then we are counting M multiple times? However, the entire sequence has only one occurrence of M (unless there are duplicates, but note: even if there are duplicates, we can only use one occurrence to set the maximum for a segment, but if two segments both contain M then the day that contains M will have profit M, and the other day that contains M also has profit M). However, wait: the problem says the segment is contiguous and we cannot skip, so if the maximum appears in two different segments, then we have two days with profit at least M.\n\n   But note: the entire sequence must be covered and the segments are contiguous. So the maximum element must appear in exactly one segment? Actually, no: if there are duplicates, then two segments might both contain the same maximum value (if the same maximum appears again later). However, the condition is that the segment's profit is the maximum in that segment. If we break the array such that two segments both contain the same maximum (say x) and no segment contains a larger value, then both days will have profit x.\n\n   However, we cannot avoid having the global maximum (the largest value) in exactly one segment. But duplicates are allowed.\n\n   Now, consider: what is the constraint on the segments? The segments must be contiguous and cover the entire array.\n\n   We can use a greedy idea: we want to minimize the negative effect of high values. But note: the high values are beneficial because they add to the total profit. However, if we extend a segment to include a higher value, we might set the maximum for that segment to that higher value, but then we might have to include lower values that don't add anything. \n\n   Another idea: the optimal segmentation must have the property that the maximum of a segment is non-decreasing? Actually, not necessarily. For example, we might have a small maximum then a larger one, but then if we break too early we might get a low maximum for a long segment.\n\n   However, note: we can use the fact that the maximum in the entire array must appear in one segment. Moreover, the segments are contiguous and we are forced to take the entire array. \n\n   We can try to use the following: \n\n   Let's define an array \"next\" for each index i: the next index where a higher value appears (or the next greater element to the right). This can help us determine how far we can extend a segment without including a higher value that would become the new maximum.\n\n   Alternatively, we can use the following known approach for similar problems (like \"Largest Rectangle in Histogram\" or \"Segment Tree\") but here we are breaking the array.\n\n   Known similar problem: \"Sum of Maxima\" for segments, but we have fixed k segments.\n\n   Another idea: \n\n   Let f(i) be the maximum value in the prefix ending at i (but that doesn't directly help).\n\n   We can use a different DP: \n\n   Let dp[i][d] = maximum total profit for the first i problems (with d days) and also keep track of the maximum of the last segment (which we don't explicitly store, but we can use the fact that the last segment's maximum is the maximum in the interval [j, i-1] for the j we choose).\n\n   But we can precompute the maximums for all intervals [j, i] for all j and i. We can use a 2D DP table for the maximums, but that is O(n^2) memory and time.\n\n   Alternatively, we can use the following:\n\n   We know that the maximum in the segment [j, i] can be computed by keeping the next greater element to the left (or right) to limit the segment.\n\n   However, note: we are iterating i from 0 to n-1, and for each i we want to consider j from 0 to i.\n\n   We can use a technique similar to the \"largest rectangle\" problem: we can precompute for each i, the previous greater element (to the left) and the next greater element (to the right) to know the boundaries in which a[i] is the maximum.\n\n   But note: we are breaking the array arbitrarily. \n\n   There is a known problem: \"Dividing an array into k contiguous parts to maximize the sum of minima\", and similarly for maxima. For maxima, it is a bit different.\n\n   Let me think: \n\n   We can consider that the profit for a segment is the maximum in that segment. We want to maximize the sum.\n\n   We can use a greedy algorithm that goes from left to right and whenever we encounter a new high, we break the segment at that high? \n\n   Example: [5,4,2,6,5,1,9,2] with k=3.\n\n   The example solution breaks at indices: [0,2] (3 problems), then [3,4] (2 problems), then [5,7] (3 problems). The maxima are 5,6,9.\n\n   What if we break at the positions of the top k maxima? But note: the entire array must be partitioned and the segments are contiguous.\n\n   We can consider: the k-1 breakpoints must lie between the problems. The highest value must be the maximum of its segment, and we can break the array such that each segment contains at least one of the top k maxima (if we have k segments, then we need at least k maxima? Actually, no: one maximum can be shared by two segments if we break in between? But wait, if we break in the middle of a run of the same maximum, then both segments will have that maximum. However, note: the maximum is the maximum in the segment. \n\n   Another idea: we can use the fact that the total profit is the sum of the maxima of the segments. We can use the following:\n\n   Step 1: Identify the positions of the k largest distinct numbers? But duplicates matter.\n\n   Actually, we can use the following method:\n\n   Let b be an array of length n, and we want to assign a \"breakpoint\" after some positions. We are going to break the array into k segments. The key observation is that the maximum of a segment must be one of the numbers in the array, and the same number can be used in multiple segments (if it appears multiple times).\n\n   We can use a greedy segmentation:\n\n   - Start from the left. We know that the first segment must end at least at the first occurrence of the k-th largest distinct number? \n\n   Alternatively, we can use the following: \n\n   Let m = the array of difficulties.\n\n   We can consider the following: \n\n   The total profit is the sum of the maxima of the segments. The maximum value (say M) must appear in one segment, and that segment's maximum is M. Similarly, the next highest value (that is not M) must appear in one segment, and that segment's maximum is that value. However, if the next highest value appears after M, then we must break after M to get that value as a maximum? \n\n   Actually, we can use the following strategy:\n\n   - Break the array at the positions of the k-1 largest values (excluding duplicates appropriately) but wait, if there are duplicates, we might need to break the ties.\n\n   However, consider the example: [5,4,2,6,5,1,9,2] with k=3.\n\n   The three largest distinct values are 9,6,5. But note: 5 appears twice. \n\n   We can use the following: \n\n   We want to form k segments. We will choose k-1 breakpoints. The best way is to let each segment contain at most one \"peak\" (a value that is at least as large as the ones that follow). \n\n   Another known solution for similar problems (like CodeForces problem \"Array Partition\") is to use the following:\n\n   Let dp[i][d] = the maximum total profit we can get from the first i problems using d days, and also we store the maximum value in the last segment. But that doesn't help.\n\n   Alternatively, we can use the following efficient DP:\n\n   Precomputation: \n     Let M[i][j] be the maximum from i to j (inclusive). But that is O(n^2) space and time.\n\n   Then our recurrence is:\n\n        dp[i][d] = max_{0<=j<i} { dp[j][d-1] + M[j][i-1] }\n\n   But we can precompute M[j][i] for all j<=i. We can do:\n\n        M[i][j] = max(M[i][j-1], a[j])   for j from i to n-1, but we need to compute for all intervals.\n\n   Actually, we can compute a 2D table for the maximums for all intervals, but that is O(n^2) and n=2000 -> 4e6 intervals, which is acceptable in C++ but in Python we can do it.\n\n   However, note: we have k up to 2000, so the state is dp[i][d] for i in range(0, n+1) and d in range(0, k+1). That is 2001*2001 = 4e6 states, and for each state we look at j from 0 to i-1 (which is up to 2000) so total operations 4e6 * 2000 = 8e9, which is too slow in Python.\n\n   We need to optimize the inner loop.\n\n   How to optimize the inner loop?\n\n   We note that the recurrence:\n\n        dp[i][d] = max_{j from 0 to i-1} { dp[j][d-1] + M(j, i-1) }\n\n   We can precompute for each d, and for each i, the value M(j, i-1) for j from 0 to i-1. But note, M(j, i-1) is the maximum from j to i-1.\n\n   We can use a segment tree or a sparse table for range maximum queries? But then we still need to iterate j.\n\n   Alternatively, we can use the following:\n\n   Let's fix d (number of days). Then we want to compute dp[i][d] for increasing i.\n\n   We can use a pointer that moves j from 0 to i-1 and update a data structure that holds dp[j][d-1] + M(j, i-1). But M(j, i-1) is non-decreasing as i increases? For fixed j, as i increases, M(j, i-1) is non-decreasing. \n\n   We can also precompute the next greater element to the left for each position? \n\n   Actually, we can use the following trick:\n\n   Consider that the maximum of [j, i-1] is determined by the last greater element to the left? Not exactly.\n\n   Another idea: use a deque to maintain the maximums for the current i? But we are iterating j from 0 to i-1.\n\n   Alternatively, we can use the following:\n\n   Let's precompute an array \"max_so_far\" for the entire array, but that is not enough.\n\n   We can use the following: \n\n   We know that the maximum in [j, i-1] is the same as the maximum in [j, p] where p is the next greater element to the left? Actually, we can use the concept of \"monotonic stack\" to precompute for each j the next greater element to the left (if any) and then use that to limit the j's that matter.\n\n   However, note: the recurrence depends on j and i. \n\n   Alternate Insight: \n\n   We can reverse the order: instead of iterating i from 1 to n, we can iterate the breakpoint positions. \n\n   There is a well-known problem: \"Maximum Sum of Ranges\" but with k segments.\n\n   Another known problem: \"Breaking a string into k segments to maximize the sum of products\" but not exactly.\n\n   Let me try to reframe:\n\n   We want to break the array into k contiguous segments. The profit for the segment [l, r] is max(l...r). The entire array must be broken.\n\n   We can use a greedy segmentation: \n\n   - The last segment must end at n-1. We can let the last segment start at j, then the maximum of the last segment is the maximum from j to n-1.\n\n   Then the rest of the array [0, j-1] must be broken into k-1 segments.\n\n   Then we can do:\n\n        dp[i][d] = maximum total profit for the prefix [0, i-1] with d days.\n\n        Then, for the last segment [j, i-1] (for j from 0 to i-1) we have:\n\n            candidate = dp[j][d-1] + max_segment(j, i-1)\n\n        and then dp[i][d] = max(candidate for j in [0, i-1])\n\n   But we need to compute max_segment(j, i-1) quickly. We can precompute a 2D array for the maximums, but that is O(n^2). However, we can use a 1D array for the current maximums for the segment starting at j and ending at i-1? \n\n   Actually, we can use a 2D array \"max_val\" for the maximum from j to i, but we can compute it with:\n\n        max_val[j][i] = max(max_val[j][i-1], a[i])\n\n   But that is O(n^2) and 4e6 entries, which is acceptable in terms of memory (each integer 4 bytes -> 16 MB) but the time to compute is O(n^2) which is 4e6 for n=2000, which is acceptable.\n\n   Then the DP:\n\n        dp[0][0] = 0\n        For d from 1 to k:\n            for i from d to n:   # because we need at least d problems (one per day) and we are using d days\n                dp[i][d] = -10**18\n                for j from d-1 to i-1:   # because we need at least one problem per day, so the previous day must have at least d-1 problems, so j>=d-1? Actually, no: the previous day could have been from 0 to j-1, and then we require that the total problems is i, so j must be at least (the start of the last segment) and the previous day ends at j-1, so j-1 >= d-1? Actually, the previous day must cover at least d-1 problems, so j-1 >= d-1 => j>=d. But wait, the first day can have 1 problem, then second day at least 1, etc. So the minimal i for d days is d (each day one problem). \n\n        Actually, we can let j from 0 to i-1, but we must ensure that the previous state dp[j][d-1] is defined. dp[j][d-1] is defined for j from 0 to n, but we require j>=d-1 (since we need d-1 days and each day at least one problem, so the first d-1 days must cover at least d-1 problems, so j must be at least d-1). \n\n        So we can do:\n\n            for d from 1 to k:\n                for i from d to n:\n                    dp[i][d] = max_{j from d-1 to i-1} { dp[j][d-1] + max_val[j][i-1] }\n\n        Then the answer is dp[n][k]\n\n   However, the inner loop for j from d-1 to i-1 is O(i) and i goes from d to n, so total operations is about sum_{d=1}^{k} sum_{i=d}^{n} (i - d+1) ~ O(n^2 * k) which is 4e6 * 2000 = 8e9, which is too slow in Python.\n\n   We need to optimize the inner maximization.\n\n   How to optimize?\n\n   We note that max_val[j][i-1] is non-decreasing in j? Actually, no: if we increase j (move the start to the right), the segment [j, i-1] is a subsegment of [j-1, i-1]. The maximum can either stay the same or decrease.\n\n   Actually, the maximum of [j, i-1] is >= the maximum of [j+1, i-1] if the element at j is greater than the maximum of [j+1, i-1]? Not necessarily. But if we fix i, then as j increases, the maximum of [j, i-1] is non-increasing? Actually, no: consider [1, 3, 2]: \n        j=0: [1,3,2] -> max=3\n        j=1: [3,2] -> max=3\n        j=2: [2] -> max=2\n\n   So non-increasing? Actually, the maximum can stay the same or drop.\n\n   But note: the maximum of [j, i-1] is at least the maximum of [j+1, i-1]. So it is non-decreasing in the sense of being larger or equal? No, it's non-increasing in the sense of the starting index moving right: the segment is getting smaller, so the maximum can only stay the same or drop.\n\n   So the function f(j) = max_val[j][i-1] is non-increasing in j (as j increases, the segment shrinks and the maximum might drop). \n\n   Then the expression we are maximizing is:\n\n        dp[j][d-1] + f(j)\n\n   where f(j) is non-increasing in j.\n\n   We can use a two-pointer or a segment tree? But note: d is fixed and i is fixed. We are iterating i from d to n, and for each i we want to do:\n\n        dp[i][d] = max_{j from d-1 to i-1} { dp[j][d-1] + max_val[j][i-1] }\n\n   and we can precompute the max_val[j][i-1] for all j and i.\n\n   But note: we already precomputed max_val[j][i-1] for all j and i (from 0 to n-1) with:\n\n        max_val[j][i] = max(max_val[j][i-1], a[i])\n\n   Actually, we can compute max_val[j][i] for each row j and column i (with i>=j) with:\n\n        for j in range(n):\n            current_max = -1\n            for i in range(j, n):\n                if a[i] > current_max:\n                    current_max = a[i]\n                max_val[j][i] = current_max\n\n   Then the DP becomes:\n\n        dp = [[0]*(k+1) for _ in range(n+1)]\n        # dp[i][d] for i from 0 to n, d from 0 to k.\n\n        # Initialize dp[0][0] = 0, and for i>0, dp[i][0] = -10**18 (or invalid)\n        # But note: we must use d days, and we have to cover i problems, so for d>i, dp[i][d] is invalid.\n\n        # We'll do:\n        dp = [[-10**18]*(k+1) for _ in range(n+1)]\n        dp[0][0] = 0\n\n        # Precompute max_val: a 2D list of size n x n, but we only need j<=i, and we can use a list of lists.\n        max_val = [[0]*n for _ in range(n)]\n        # But note: we are using 0-indexed for the array a of length n, and our dp uses i from 0 to n (problems 0 to n-1 are the array, and dp[i] corresponds to the first i problems, i.e., indices 0 to i-1)\n\n        Actually, let me redefine: our array a is given as a[0..n-1]. Then the segment from j to i-1 (if we consider the first i problems, then the last problem is at index i-1). \n\n        We want max_val[j][i-1] for j from 0 to i-1.\n\n        We can precompute a 2D table for max_val for intervals [j, i] (with j<=i) for the array a.\n\n        Steps:\n\n          Let M = [[0]*n for _ in range(n)]\n          for i in range(n):\n              cur = 0\n              for j in range(i, n):\n                  if a[j] > cur:\n                      cur = a[j]\n                  M[i][j] = cur\n\n          Then for a segment from j to i-1 (0-indexed, the segment covers indices j to i-1) the maximum is M[j][i-1] (if j<=i-1).\n\n        Then in DP:\n\n          for d in range(1, k+1):\n              for i in range(d, n+1):   # i: number of problems solved (from 0 to n)\n                  # We are considering the first i problems (indices 0 to i-1)\n                  # We break the last segment from j to i-1 (j from d-1 to i-1, because the previous d-1 days must cover j problems, and j>=d-1)\n                  # But note: the previous state is dp[j][d-1] (which is the first j problems, i.e., indices 0 to j-1) and then the last segment is from j to i-1.\n\n                  # However, we must ensure that j>=d-1 (since we need d-1 days for the first j problems, and j must be at least d-1).\n\n                  # But note: the minimal j is d-1 (because we have d-1 days and each day at least one problem, so we need at least d-1 problems for the first d-1 days).\n\n                  # However, our dp[j][d-1] is defined for j from 0 to n, but we only computed for j>=d-1.\n\n                  # So we can do:\n                  best = -10**18\n                  # j from d-1 to i-1 (both inclusive)\n                  for j in range(d-1, i):\n                      # The segment is from j to i-1 (so the last segment has i-j problems)\n                      # The maximum in the segment [j, i-1] is M[j][i-1] (if j<=i-1)\n                      # But note: if j==i, then the segment is empty, but j goes to i-1.\n                      candidate = dp[j][d-1] + M[j][i-1]\n                      if candidate > best:\n                          best = candidate\n                  dp[i][d] = best\n\n        Then answer is dp[n][k]\n\n   However, the inner loop for j from d-1 to i-1 is O(i) and i goes from d to n, so the total operations is:\n\n        sum_{d=1}^{k} sum_{i=d}^{n} (i - d+1) \n\n        ~ (n*(n+1)/2) * k   [but actually for fixed d, the inner loop does about (n-d+1)* (average length) ]\n\n        Actually, for fixed d, the inner loop runs for i from d to n, and for each i, it runs (i - d+1) times.\n\n        So the total for fixed d is: sum_{i=d}^{n} (i-d+1) = 1 + 2 + ... + (n-d+1) = (n-d+1)*(n-d+2)//2\n\n        Then overall: sum_{d=1}^{k} (n-d+1)*(n-d+2)//2\n\n        This is O(n^3) in the worst-case (if k=n, then d from 1 to n, and the inner term is about n^2/2, so total about n^3/2) which for n=2000 is 2000^3/2 = 4e9 * 1000 = 4e12, which is too slow.\n\n   We need to optimize further.\n\n   We can use the following: \n\n   We note that for fixed d, we are doing:\n\n        dp[i][d] = max_{j in [d-1, i-1]} { dp[j][d-1] + M[j][i-1] }\n\n   and M[j][i-1] is the maximum from j to i-1.\n\n   We can precompute for each fixed d, but note that M[j][i-1] depends on i.\n\n   Alternatively, we can change the order: iterate by the end of the segment i, and then use a data structure that stores for each j (>=d-1) the value dp[j][d-1] + M[j][i-1] and updates as i increases.\n\n   But note: as i increases, M[j][i-1] increases for each fixed j (non-decreasing). \n\n   Actually, for fixed j, M[j][i] is non-decreasing in i.\n\n   And j is from d-1 to n-1.\n\n   We can try to use a segment tree or a Fenwick tree? But note that we are iterating i and updating j's.\n\n   Alternatively, we can use the idea of \"line sweep\" and use a stack. \n\n   Let F(i) = { for j in [d-1, i-1]: dp[j][d-1] + M[j][i-1] }\n\n   We want to compute the maximum F(i) for j in [d-1, i-1] for each i.\n\n   But note: M[j][i-1] = max(M[j][i-2], a[i-1]) \n\n   So when we move from i to i+1, the value for each j changes by:\n\n        M[j][i] = max(M[j][i-1], a[i])\n\n   Then the candidate for j is dp[j][d-1] + max(M[j][i-1], a[i])\n\n   But note: the change is only if a[i] > M[j][i-1].\n\n   We can maintain a data structure that holds for each j (in the range [d-1, i-1]) the current value (dp[j][d-1] + M[j][i-1]) and update it when M[j][i-1] increases (when we see a new maximum in the segment [j, i]). \n\n   However, the update happens only for j's that are affected by a[i] (those j for which a[i] is greater than M[j][i-1]). \n\n   And we need to get the maximum value in the data structure for j in [d-1, i-1].\n\n   We can use a Fenwick tree or segment tree for range maximum query, but we also need to update the values for specific j's.\n\n   Steps for fixed d:\n\n        Let A = an array of size n (for j from 0 to n-1) initially, for each j, we set:\n\n            value[j] = dp[j][d-1] + M[j][j]   [if we are at i=j+1, then M[j][j]=a[j]]\n\n        But we are building i from d to n.\n\n        Alternatively, we can initialize for i from d to n, and update the values for j from d-1 to i-1.\n\n        We'll maintain an array `cur` of length n (for j from 0 to n-1) that holds the current value for j (which is dp[j][d-1] + M[j][i-1] for the current i).\n\n        Then, when we move from i-1 to i, we update the values for all j from 0 to i-1 that have M[j][i-1] changed (specifically, if a[i-1] > M[j][i-2] then update). But note: we are at i, and we are updating M[j][i-1] from M[j][i-2] (if i>=2).\n\n        Actually, we can update the value for j by:\n\n            if a[i-1] > M[j][i-2]:\n                cur[j] = dp[j][d-1] + a[i-1]\n            else:\n                cur[j] = dp[j][d-1] + M[j][i-2]\n\n        But wait, M[j][i-1] = max(M[j][i-2], a[i-1])\n\n        However, we don't have M[j][i-2] stored separately.\n\n   Alternatively, we can precompute the next greater element for each j to know the next time the maximum increases.\n\n   But note: the constraints and that we are iterating d from 1 to k and i from d to n.\n\n   This becomes very complex.\n\n   Let me try to find a simpler approach.\n\n   Another known idea: the maximum total profit is the sum of the k largest elements that are \"peaks\" in their segments. But note, we must cover the entire array.\n\n   Insight: \n\n   In the optimal segmentation, the set of maxima for the segments must be exactly the set of the k largest values in the array? Not necessarily: consider [1,2,3,4] and k=2. \n        Option1: [1,2] and [3,4] -> maxima 2 and 4 -> total 6.\n        Option2: [1] and [2,3,4] -> maxima 1 and 4 -> total 5.\n        Option3: [1,2,3] and [4] -> maxima 3 and 4 -> total 7.\n\n   Here, the two largest values are 4 and 3, and the total is 7. So the maxima are the two largest values.\n\n   Another example: [5,4,2,6,5,1,9,2] with k=3. The three largest values are 9,6,5 -> total 20, which matches.\n\n   But consider: [1,2,1,2] with k=2.\n\n        Option1: [1,2] and [1,2] -> maxima 2 and 2 -> total 4.\n        Option2: [1] and [2,1,2] -> maxima 1 and 2 -> total 3.\n        Option3: [1,2,1] and [2] -> maxima 2 and 2 -> total 4.\n\n        The two largest values are 2 and 2.\n\n   So the total is the sum of the k largest values.\n\n   Why is this true?\n\n   Explanation:\n\n   In the segmentation, each segment's profit is the maximum in that segment. The entire array must be partitioned. The global maximum must be included in one segment, and that segment's profit is the global maximum. The next largest value must be included in a segment that does not include the global maximum (or if it does, then we cannot use it as the maximum for two segments) but wait, if the next largest value is after the global maximum, then we must break after the global maximum to include it in another segment.\n\n   In fact, the optimal solution will have the k largest values (with duplicates resolved by the condition of the segmentation) as the maxima for the k segments.\n\n   How to prove?\n\n   Consider that if a segment does not contain one of the k largest values, then we could potentially increase its maximum to a larger value (by extending it to include a larger value) and then adjust the boundaries to include that larger value without decreasing the total.\n\n   However, note: sometimes including a larger value might force us to include a segment that already has a larger value? \n\n   But note: the entire array must be covered. The k largest values must appear in some segment. And if a segment has a maximum that is not among the k largest values, then there is a larger value somewhere else that hasn't been used as a segment maximum. We can try to extend the segment containing that larger value to cover the segment with the smaller maximum, and then the larger value will become the maximum for the merged segment, and the other segment might be adjusted to still have its own maximum (if the larger value was originally the maximum of a segment that is now part of a bigger segment) but wait, the larger value might be in a different segment.\n\n   Actually, a standard result in such problems (like \"Sum of Maxima in Partition\" into k segments) is that the maxima of the segments must be exactly the k largest elements in the array. \n\n   Therefore, the maximum total profit is simply the sum of the k largest elements in the array.\n\n   But wait, let's test with the examples:\n\n   Example 1: [5,4,2,6,5,1,9,2] -> the 3",
    "response": "\nTo solve this problem, we need to maximize the total profit Polycarp gets from solving problems over exactly `k` days, where each day he solves a contiguous segment of problems from the start of his list. The profit for each day is the maximum difficulty of the problems solved that day. \n\n### Approach\n1. **Problem Analysis**: The key observation here is that the optimal solution involves selecting the top `k` largest values from the problem difficulties. These values will be the maxima of their respective segments in the optimal segmentation. The sum of these top `k` values gives the maximum possible total profit.\n2. **Intuition**: By ensuring each of the top `k` values is the maximum in its own segment, we maximize the daily profit. This is because any other segmentation would either include a smaller value as a segment maximum or fail to utilize one of the top `k` values, leading to a lower total profit.\n3. **Algorithm Selection**: \n   - **Step 1**: Identify the top `k` largest values in the problem difficulties. If there are ties (duplicate values), all occurrences must be included to ensure the segmentation covers all necessary segments.\n   - **Step 2**: Once the top `k` values are identified, determine the earliest positions (indices) where these values appear in the original list. These positions help in splitting the problem list into segments such that each segment's maximum is one of the top `k` values.\n4. **Complexity Analysis**: The algorithm involves sorting the problem difficulties and then processing the top `k` values, which dominates with a time complexity of O(n log n) due to the sorting step. The subsequent steps involve linear scans to determine segment boundaries, which is O(n). Thus, the overall complexity is O(n log n), which is efficient for the given constraints (n ≤ 2000).\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    if k == 1:\n        print(sum(a))\n        print(n)\n        return\n        \n    b = a[:]\n    b.sort()\n    threshold = b[n - k]\n    selected = []\n    for num in a:\n        if num > threshold:\n            selected.append(num)\n        elif num == threshold:\n            selected.append(num)\n            \n    count = 0\n    indices = []\n    for i in range(len(selected)):\n        if selected[i] == threshold or selected[i] > threshold:\n            count += 1\n            \n    for i in range(n):\n        if a[i] >= threshold:\n            indices.append(i)\n            \n    while len(indices) < k:\n        indices.append(n-1)\n        \n    indices.sort()\n    segments = [0] * k\n    last_index = -1\n    for i in range(k):\n        if i == k-1:\n            segments[i] = n - 1 - last_index\n        else:\n            segments[i] = indices[i] - last_index\n        last_index = indices[i]\n        \n    total_problems = 0\n    for seg in segments:\n        total_problems += seg\n        \n    total_profit = sum([a[i] for i in indices[:k]])\n    print(total_profit)\n    print(\" \".join(map(str, segments)))\n    \nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of the number of problems `n`, the number of days `k`, and the list of problem difficulties.\n2. **Special Case Handling**: If `k` is 1, the total profit is simply the sum of all problem difficulties, and the output is `n` (since all problems are solved in one day).\n3. **Finding Top `k` Values**: The problem difficulties are sorted, and the threshold is set to the `k`-th largest value. All values greater than or equal to this threshold are collected into a list.\n4. **Segment Determination**: The indices of these top `k` values in the original list are identified. If there are fewer than `k` values (due to duplicates), the remaining segments are filled by extending the last segment to cover the remaining problems.\n5. **Output**: The sum of the top `k` values (total profit) and the sizes of each segment (number of problems per day) are printed.\n\nThis approach efficiently ensures that the segmentation maximizes the daily profits by leveraging the top `k` values and their positions in the problem list.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    if k == 1:\n        print(sum(a))\n        print(n)\n        return\n        \n    b = a[:]\n    b.sort()\n    threshold = b[n - k]\n    selected = []\n    for num in a:\n        if num > threshold:\n            selected.append(num)\n        elif num == threshold:\n            selected.append(num)\n            \n    count = 0\n    indices = []\n    for i in range(len(selected)):\n        if selected[i] == threshold or selected[i] > threshold:\n            count += 1\n            \n    for i in range(n):\n        if a[i] >= threshold:\n            indices.append(i)\n            \n    while len(indices) < k:\n        indices.append(n-1)\n        \n    indices.sort()\n    segments = [0] * k\n    last_index = -1\n    for i in range(k):\n        if i == k-1:\n            segments[i] = n - 1 - last_index\n        else:\n            segments[i] = indices[i] - last_index\n        last_index = indices[i]\n        \n    total_problems = 0\n    for seg in segments:\n        total_problems += seg\n        \n    total_profit = sum([a[i] for i in indices[:k]])\n    print(total_profit)\n    print(\" \".join(map(str, segments)))\n    \nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 930,
        "completion_token_count": 967,
        "thoughts_token_count": 8191
    }
}