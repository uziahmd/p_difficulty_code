{
    "start": 1758304740.8335838,
    "end": 1758308570.1055262,
    "start-formatted": "2025-09-20 02:59 KST",
    "end-formatted": "2025-09-20 04:02 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n We are given: \n   n, k and a list of n integers.\n\n Conditions:\n   - We have to split the list of problems (in order) into exactly k contiguous segments (each segment being consecutive problems from the start).\n   - Each day's profit is the maximum difficulty in the problems solved that day.\n   - We wish to maximize the total profit (sum of the daily profits).\n\n Observation:\n   The entire set of problems must be partitioned. Since the days are contiguous, we can think of making k-1 cuts (after some problems).\n\n   Let dp[i][j] be the maximum total profit we can get from the first i problems over j days.\n\n   However, note that the problem constraints: n, k <= 2000, so an O(n^2*k) might be too heavy (n=2000, k=2000 -> 8e9 states). We need a better way.\n\n Alternative Insight:\n\n   Consider that the profit for a day is the maximum in the contiguous segment. This is similar to the problem of splitting the array and then summing the segment maximums.\n\n   We know that the segment maximums are non-decreasing as we move from left to right? Not necessarily, but note: if we break the array at a point, the segment maximums are computed on contiguous parts.\n\n   Another idea: use the fact that the entire array must be partitioned and the segments are contiguous. The key observation is that the total profit is the sum of the segment maximums.\n\n   We can use dynamic programming with state i (number of problems processed) and j (number of days used) and try to extend by one or more problems until the next segment boundary? But then we have to consider the maximum in the last segment.\n\n   Alternatively, we can precompute the \"next greater element\" to help in knowing what the maximum will be for a segment ending at a certain position.\n\n   However, note: the segments are contiguous and the entire array is fixed. We can also use the following:\n\n   Let f(j) be the minimum index such that the segment j ends at index i and the maximum of the segment is at least x.\n\n   Another known idea: we can break the array at positions where a new segment starts. The challenge is that the maximum of a segment is the maximum element in that contiguous segment.\n\n   Let's define:\n     Let dp[i][j] = maximum total profit for the first i problems in j days, and let seg_max[i][j] be the maximum value in the last segment (from the j-th day) for the state (i,j). Then:\n\n     How do we compute dp[i][j]?\n        We consider the last segment (day j) which ends at problem i (so the segment goes from some index l+1 to i). The maximum value in this segment is M = max(a[l+1..i]).\n\n        Then: dp[i][j] = dp[l][j-1] + M, for all l from j-1 to i-1 (since we must have at least j-1 problems in the previous j-1 days, so l from j-1 to i-1).\n\n        But note: the segment must be contiguous and the entire set is in order.\n\n        However, we cannot iterate over all l from j-1 to i-1 because that would be O(n^2*k) which is 8e9 for n,k=2000.\n\n   We need to optimize the DP.\n\n   We can use a two-pointer or use a monotonic stack to precompute the next greater element and then use segment trees or stacks to update the DP.\n\n   Alternatively, we can use the following:\n\n   Let dp[i][j] = maximum total profit for the first i problems in j days.\n   Then we want to compute:\n        dp[i][j] = max_{l from j-1 to i-1} { dp[l][j-1] + max(a[l+1..i]) }\n\n   Now, how to compute max(a[l+1..i]) quickly? We can precompute a 2D array for range maximum queries? But that would be O(n^2) space and time, and n=2000 -> 4e6 which is acceptable in memory but then the DP would still be O(n^2*k) which is 4e6 * 2000 = 8e9, too slow.\n\n   We need to optimize the inner max query and the dp update.\n\n   Idea: Instead of iterating over every l, we can use the fact that the maximum of the segment [l+1, i] is determined by the maximum in the entire array from l+1 to i. Moreover, we can use a different state: let's consider that the last segment must end at i, and the maximum of the last segment is the same as the maximum from the beginning of the last segment to i.\n\n   Alternatively, we can use the concept of \"monotonicity\" of the maximum in the segment. Notice that if we fix the last segment, the maximum is the maximum between the current maximum and the next greater element to the left.\n\n   We can precompute for each i, the next greater element to the left? Actually, we want to know the last occurrence of the maximum in the segment [l+1, i] and how it changes as l decreases.\n\n   However, note that we are iterating l from j-1 to i-1. We can use a stack to precompute the next greater element to the left (for each i, the next greater element to the left is the first element to the left that is greater than a[i]), but that gives the immediate next greater. \n\n   Alternatively, we can use a sparse table for RMQ, but that doesn't help much.\n\n   Another idea: use the fact that the maximum of [l+1, i] is non-decreasing as l decreases (because as we extend the segment to the left, the maximum can only increase or stay the same). Therefore, we can use a pointer for each i and j and update using a deque or something.\n\n   But note: we are iterating over i and j, and for each i and j, we need to consider l from j-1 to i-1.\n\n   Let's reverse the order: for fixed j, we can let i vary and use a sliding window for the maximum in [l+1, i] and then update dp[i][j] by taking the maximum of dp[l][j-1] for l from j-1 to i-1, but then we have to add the current maximum.\n\n   We can precompute the maximums for all segments ending at i, but that is O(n^2).\n\n   Alternatively, we can use the following:\n\n   Let dp[i][j] = maximum total profit for the first i problems in j days, and let M(i) be the maximum value from the beginning of the last segment to i. But note: the last segment is not necessarily starting from the beginning of the array.\n\n   Actually, we can use the following:\n\n   We know that the entire array must be partitioned. The total number of days is k, so we are going to break the array into k contiguous segments.\n\n   Let's define an array b[1..n] where b[i] is the maximum value in the segment containing the i-th problem. Then the total profit is the sum of the distinct segment maximums? No, wait: each day's profit is the maximum of its own segment. However, note: if the same maximum appears in multiple segments, then we count it multiple times.\n\n   But note: the maximum in a segment is the maximum value in that contiguous part. And the array is fixed.\n\n   Another idea: use the fact that the segments boundaries are chosen arbitrarily (but contiguous). We can use the following greedy: the best way to maximize the total profit is to have as many high numbers as possible, and each high number should be the maximum of its segment and possibly the maximum of the next segments as well? \n\n   Actually, we can use a stack to precompute the next greater element (to the right) and then use that to determine the optimal break points.\n\n   Known technique: the segment maximums in a partition can be optimized by considering the \"breakpoints\" at the positions of the numbers. Specifically, the maximum of a segment containing a particular occurrence of a number x must be at least x, and if there is a larger number to the right, then the segment must extend until that larger number is included to avoid having x as the maximum of two separate segments.\n\n   However, note: the segments are contiguous and the array is fixed.\n\n   Let's consider: the total profit is the sum of the segment maximums. We want to minimize the loss: if we break the array at a point where the current segment maximum is x, then the next segment's maximum is y (which must be >= x if the next segment has a number >= x). Actually, we can break only when we are forced to (we have exactly k days) and we want to maximize the sum.\n\n   We can use the following:\n\n   Step 1: Precompute the next greater element for each position (for the entire array). Then, we can determine the minimal segment that must be taken for a given maximum.\n\n   Step 2: Use DP with state i (current problem index) and j (number of days) and use the next greater element to limit the range of l.\n\n   However, we can use a different approach:\n\n   Let dp[i][j] = maximum total profit for the first i problems in j days, and let the last segment end at i. Then:\n\n        dp[i][j] = max_{p from i_prev to i-1} { dp[p][j-1] + max_value(p+1, i) }\n\n   But we can use the fact that the maximum value in [p+1, i] is the maximum between a[p+1..i]. We can precompute a 2D array for the maximum from p+1 to i, but that is O(n^2) and n=2000, so 4e6 elements, which is acceptable in terms of memory, but then the DP is O(n^2*k) which is 4e6 * 2000 = 8e9, which is too slow in Python.\n\n   We need to optimize the inner max computation and the dp update.\n\n   Alternate Insight:\n\n   Instead, we can use a different state: let dp[i][j] = maximum total profit for the first i problems in j days, and we also keep an auxiliary array to store the maximum value from the beginning of the last segment to i, but that is not enough.\n\n   We can use the following:\n\n   Let's precompute an array \"next_greater\" for each element, but then we can use the idea from \"largest rectangle in histogram\" or \"next greater element\" to break the array.\n\n   Another known technique: the problem of splitting an array into k contiguous segments to maximize the sum of the segment maximums is equivalent to: we can choose k-1 break points, and the profit is the sum of the maximums of the segments.\n\n   We can use the following: the maximum of a segment is the maximum element in that segment. Therefore, the entire array's maximum must appear in one segment and that segment's maximum is that maximum. Then, the next segment must start after that maximum? Actually, no: the segments are contiguous and we can break arbitrarily.\n\n   Let's consider the positions of the top k largest numbers. Why k? Because each segment must have at least one number, and the top k numbers (by value) must appear in distinct segments because if two top numbers fall in the same segment, then that segment's maximum is the higher one, and the other top number (if lower) would be in the same segment and not counted again. However, note: the same maximum can appear in multiple segments if the array has duplicates, but actually if we have two segments, then the maximum of each segment is the maximum in that segment.\n\n   But note: the problem does not require distinct numbers. We can have two segments both with maximum 10, for example.\n\n   However, the optimal solution will always have the k-1 largest distinct values (but wait, duplicates are allowed) as the segment maximums. Actually, the segment maximums must be at least the top k distinct values? Not necessarily: consider [1, 2, 3, 4] and k=2: we can break after the second element: [1,2] and [3,4] -> total profit 2+4=6. Alternatively, we can break after the third: [1,2,3] and [4] -> total profit 3+4=7. So the maximum is 7.\n\n   But note: the top k distinct values are [3,4] for k=2? Actually, we have two segments, so we need two maximums. The two largest numbers in the array are 4 and 3, so they must be the maximums of their respective segments? Yes, because if we don't assign 4 as the maximum of a segment, then the segment containing 4 must have a larger number? There isn't one. Similarly for 3.\n\n   Therefore, we can argue that the optimal total profit is the sum of the k largest numbers in the array. But wait, consider [5,4,2,6,5,1,9,2] and k=3. The three largest numbers are 9,6,5. The example total profit is 5+6+9=20. However, note: there are two 5's. So the three largest distinct numbers? Actually, we take the three largest numbers (with multiplicity) but note: we can only use each occurrence once. But wait: the same number can appear in two segments? Actually, the same number can be the maximum of two segments if it appears twice, but note: the segment maximum is the maximum in that segment, so if we break the array such that the two 5's are in different segments, then we can use 5 twice.\n\n   However, the example: [5,4,2,6,5,1,9,2] -> [5,4,2], [6,5], [1,9,2]: the maximums are 5,6,9. The three largest numbers (by value) are 9,6,5. But note: the array has two 5's. In this example, the two 5's are used: the first segment uses 5, and the second segment uses 6 and 5. The 5 in the second segment is not the maximum (because 6 is larger). So the maximums are 5,6,9.\n\n   Therefore, the total profit is the sum of the k largest numbers in the array? But wait: what if the k largest numbers are not distinct? Then we might have to use the same number multiple times, but note: we can only use a number as the maximum of a segment if it is the maximum in that segment, and the same number can appear in multiple segments (if broken appropriately) but only if the segment doesn't contain a larger number.\n\n   Actually, the condition for a number x to be the maximum of a segment is that the segment does not contain any number greater than x.\n\n   Therefore, the total profit is the sum of the k largest numbers, provided that we can assign each of these k largest numbers to a distinct segment and the segment boundaries are chosen so that the segment containing x does not include any number larger than x.\n\n   How to assign? We can sort the array and take the top k numbers. Then, we must break the array such that each top k number is the maximum in its segment and the segment boundaries are chosen so that the breaks occur appropriately.\n\n   Steps:\n\n   1. Identify the k largest numbers (with duplicates) and note their indices.\n\n   2. Then, we must ensure that the breaks are made so that no two of these top k numbers are in the same segment (unless one is repeated and the repetition is broken by a larger number, but wait: if we have two 5's and no number greater than 5 in between, then we can break so that each 5 is the maximum of its own segment). However, if there is a number larger than 5, then we must break before that larger number.\n\n   Actually, we can use the following greedy: traverse the array and whenever we encounter one of the top k numbers, we break the segment at that point? Not exactly.\n\n   We can do:\n\n   Let b be the sorted list of the k largest numbers (with duplicates) and their indices. Then, we must have a break after the last occurrence of the top k numbers? Actually, the breaks must be placed such that:\n\n   - The first segment must end at or after the first occurrence of the largest number.\n   - The second segment must end at or after the next largest number, and so on.\n\n   However, we can use the following method:\n\n   Step 1: Find the k largest numbers (with duplicates) and record their indices.\n\n   Step 2: Sort these indices (and the corresponding numbers) in increasing order of indices.\n\n   Step 3: Then, the breaks must occur after the last occurrence of each distinct value? Actually, we can use the following:\n\n   We know that the segment containing a particular top k number x (at index i) must not include any number greater than x. Therefore, the segment containing x must end before the next occurrence of a number greater than x (if any) and must start after the previous break.\n\n   But note: the breaks are contiguous and we are moving from left to right.\n\n   Alternate Insight (from known problems):\n\n   There is a known problem: \"Split Array Largest Sum After K Days\" (or similar) but that is for minimum sum. Here we want maximum.\n\n   Another known problem: \"Maximum Sum of Minimums of K Subarrays\", but that is different.\n\n   Actually, we can use the following:\n\n   Let's collect the positions of the top k numbers (each occurrence that is among the top k in the entire array) and then force the breaks to happen at the boundaries of these numbers.\n\n   However, note: the entire array must be partitioned. The minimal requirement is that the breaks must be after the last occurrence of the (k-1)-th largest number? \n\n   Actually, here is a simpler idea:\n\n   The total profit is the sum of the segment maximums, and the segment maximums must be at least the k largest numbers (each segment must have a maximum, and we have k segments). However, we cannot use a number more than once? Actually, we can use a number multiple times (if it appears in multiple segments) but only if the segments are separated by a larger number. \n\n   But wait: if we have two segments and two 5's, and there is no number greater than 5, then we can break between them and get two 5's. But if there is a 6, then the segment containing the first 5 must end before the 6, and the segment containing the second 5 must end before the 6 (if the 6 is after the second 5) or after the 6 (if the 6 is between the two 5's). \n\n   Actually, the optimal strategy is to break the array such that each break is just after a number that is large enough to be the maximum of the next segment.\n\n   We can use the following algorithm:\n\n   Let dp[i][j] = maximum total profit for the first i problems in j days, and we know that the last segment's maximum is the maximum in [l+1, i]. But we can use a different state: let dp[i][j] be defined as above, but we can use a sliding window and a deque to compute the maximum for the segment [l+1, i] for all l in [j-1, i-1] and then take the maximum dp[l][j-1] + max_val(l+1, i). However, the max_val(l+1, i) is the maximum from l+1 to i, and we can update it as we move i.\n\n   We can precompute an array \"max_val_from\" but that is O(n^2). \n\n   Alternatively, we can use a segment tree or a sparse table for range maximum queries, but then the inner loop is still O(n) per state, leading to O(n^2*k) which is too slow.\n\n   We need to optimize the transition.\n\n   Let's define:\n\n        dp[i][j] = max_{l from j-1 to i-1} { dp[l][j-1] + max_range(l+1, i) }\n\n   We can precompute the next greater element to the left for the entire array, and then use the fact that the maximum in [l+1, i] is the same as the maximum in [l+1, r] for r being the next greater element to the left of i, but that doesn't help.\n\n   Another idea: use divide and conquer or convex hull trick? Probably not.\n\n   After some thought, we can use the following:\n\n   We know that the maximum of the segment [l+1, i] is the same as the maximum of [l+1, i'] where i' is the next greater element to the left of i (if any) or i itself. But we can precompute the next greater element to the left for each i, call it left_greater[i]. Then, the maximum in [l+1, i] is at least a[i] and we know that the maximum is the maximum between a[i] and the maximum in [l+1, left_greater[i]] (if left_greater[i] exists) or just a[i] if there is none.\n\n   Actually, we can precompute an array \"max_in_segment\" for each starting point l and ending point i? That is too heavy.\n\n   Another known technique: we can use a stack to compute the next greater element to the left and to the right, and then use that to break the array. But then the DP state transition remains the same.\n\n   Given the constraints n, k <= 2000, we might be able to do an O(n^2*k) solution in C++ but in Python 8e9 operations is too slow.\n\n   We need to find an efficient way.\n\n   Let's try to reframe the problem:\n\n   We want to split the array into k contiguous segments. The total profit is the sum of the segment maximums.\n\n   We can use a greedy observation: the segment maximums must be a set of numbers that are at least the k largest numbers in the array. And the maximum total profit is the sum of the k largest numbers (with duplicates, but note: we can use a number only once if it appears once, but if it appears multiple times and is the maximum in two segments, then we can use it twice?).\n\n   But wait: if we have two 5's and no number greater than 5, then we can break the array so that each 5 is the maximum of its segment, so the total profit is 5+5.\n\n   However, if we have two 5's and a 6, then the 6 must be in a segment by itself (because 6 is larger than 5) and then the two 5's can be in separate segments (if they are separated by the 6) or together (but then the maximum would be 6, not 5). \n\n   Actually, the total profit cannot exceed the sum of the k largest numbers (with duplicates) in the array. But note: if we have more than k numbers that are large, then we have to choose the k largest ones. However, consider: \n\n        [10, 1, 10] and k=2: \n            Break1: [10,1] -> max=10, [10] -> max=10 -> total=20.\n            But the two largest numbers are 10 and 10, so the sum is 20.\n\n        [10, 1, 9] and k=2:\n            Break1: [10,1] -> 10, [9] -> 9 -> total=19.\n            The two largest numbers are 10 and 9, so the sum is 19.\n\n   Therefore, the total profit is the sum of the k largest numbers (with duplicates) in the array. But wait, is that always true?\n\n   Consider: [5, 4, 2, 6, 5, 1, 9, 2] and k=3. The three largest numbers are 9,6,5. The example gives 5+6+9=20.\n\n   Consider: [1,2,3,4,5] and k=3. The three largest are 5,4,3. But the best distribution is [1],[2],[3,4,5] -> profit 1+2+5 = 8. But the sum of the three largest is 5+4+3=12, which is not achievable.\n\n   Why? Because if we want to have 5,4,3 as the segment maximums, then we must break the array such that:\n        Segment1: contains 1 and 2 and 3 -> maximum=3, then segment2: contains 4 -> maximum=4, segment3: contains 5 -> maximum=5. Then total=3+4+5=12.\n        But wait, the array is [1,2,3,4,5]. We cannot break arbitrarily: the breaks must be contiguous. The above break is: [1,2,3], [4], [5] -> which is valid and yields 3+4+5=12.\n\n   But the example I did earlier was [1],[2],[3,4,5] -> which gives 1+2+5=8. But the break [1],[2],[3,4,5] is not the only possibility. The break [1,2,3],[4],[5] is also valid and gives 3+4+5=12.\n\n   So why did I think the best was 8? Because I broke at the wrong places. The optimal break is to put the smallest numbers together and the largest numbers as separate segments. \n\n   Therefore, the total profit is the sum of the k largest numbers (with duplicates) in the array, provided that we can assign each of these k largest numbers to a distinct segment and the segment boundaries are chosen so that no segment contains a number greater than its assigned number.\n\n   How to check if we can assign the k largest numbers to distinct segments? \n\n   We can use a greedy segmentation:\n\n   Step 1: Mark the positions of the k largest numbers (if there are duplicates, we mark every occurrence that is among the top k).\n\n   Step 2: Traverse the array and whenever you encounter a marked number, you must have a break at the end of its segment (or at least after it) and then the next segment must start after that break.\n\n   However, we can also use the following:\n\n   Let the k largest numbers be sorted in descending order: v_1 >= v_2 >= ... >= v_k.\n\n   Then, we can simulate the segmentation:\n\n   - The first segment must cover from the beginning to the first occurrence of v_1 (the largest number) and must include v_1. But wait, actually, the segment containing v_1 must not include any number greater than v_1 (there isn't any), so we can break after v_1 or not? \n\n   Actually, the break after a segment containing a large number is not forced until we need to start the next segment.\n\n   We can use the following greedy segmentation:\n\n   Let breaks = [0] (meaning we break after index 0, so the first segment is from 0 to breaks[0]-1)\n   Then, for each of the k largest numbers (from largest to smallest), we extend the current segment until we hit the next largest number (or the end) and then break after the current largest number.\n\n   But wait, we must ensure that the segment containing a number x does not contain any number greater than x. Since we are processing from largest to smallest, we can break after the occurrence of the current largest number.\n\n   Algorithm for segmentation:\n\n   Let's collect the indices of the k largest numbers (all occurrences that are in the top k).\n\n   Then, sort these indices in increasing order: let these indices be pos[0], pos[1], ..., pos[k-1].\n\n   Then, the breaks will be after the last occurrence of the largest number, then after the last occurrence of the next largest number, etc.? \n\n   Actually, we can do:\n\n   We know that the first segment must include the first occurrence of the largest number. But we can extend the first segment until the last occurrence of the largest number? No, because then the next segment might not get the next largest number.\n\n   Better: we must break the array such that each segment contains exactly one of the k largest numbers (if we have k distinct largest numbers) but if there are duplicates, then we can have multiple segments with the same number.\n\n   However, note: the k largest numbers (with duplicates) are fixed. We can simply break the array at the positions that are the boundaries of these numbers.\n\n   We can do:\n\n   Let breaks = [0]  # we will break after index 0 initially, so we have a segment [0:0] (empty) -> but we need at least one problem per day.\n\n   Actually, we start with no breaks, then we will insert k-1 breaks.\n\n   Steps:\n\n   1. Let selected = sorted list of indices of the k largest numbers (each occurrence that is among the top k).\n\n   2. Then, we must break the array at the end of each selected number, but not necessarily. Actually, we can break anywhere, but the condition is that the segment containing a selected number x must not extend beyond the next greater number.\n\n   But note: we can only break at the gaps between problems. \n\n   After research, there is a known efficient solution for this problem (codeforces style) called \"Polycarp's Practice\" or similar.\n\n   Solution:\n\n   We can use dynamic programming with state i (current problem) and j (number of days) and use a pointer for the next greater element.\n\n   However, after reading online, I recall that a common solution for this problem is to use a greedy segmentation based on the next greater element.\n\n   Here is a known solution for a similar problem (Codeforces): \n\n   Problem: https://codeforces.com/contest/1778/problem/A\n\n   But wait, our problem is different.\n\n   After further thought, let me present a solution:\n\n   Let's define:\n\n        dp[i][j] = maximum total profit for the first i problems in j days.\n\n   Transition:\n\n        We consider the last segment to be from x+1 to i, then the maximum of that segment is M = max(a[x+1..i]). Then:\n\n        dp[i][j] = max_{x from j-1 to i-1} { dp[x][j-1] + M }\n\n   To compute M = max(a[x+1..i]) for each x, we can precompute a 2D array for the maximum in [x+1,i] but that is O(n^2) and n=2000, so 4e6, which is acceptable for precomputation. Then the DP would be O(n^2*k) = 4e6 * 2000 = 8e9, which is too slow in Python.\n\n   We need to optimize the transition.\n\n   We can use a different approach: let's process the array from left to right and use a stack to keep track of the potential segment boundaries.\n\n   Alternatively, we can use a nested loop for i from 0 to n-1, and for j from 1 to min(i+1, k), and then for the inner loop, we can use a pointer that moves and updates the maximum.\n\n   But 8e9 iterations is too many in Python.\n\n   We need to find a better way.\n\n   Insight: the maximum of the segment [x+1, i] is non-decreasing as x decreases (i.e., as the segment grows to the left). Therefore, we can for each i, iterate j from 1 to k, and then let x go from j-1 to i-1, but we can use a pointer and a variable to keep the current maximum and then update the dp[i][j] by checking the best dp[x][j-1] for x in [j-1, i-1] and adding the current maximum.\n\n   But the current maximum depends on x: M(x) = max(a[x+1..i]). We can precompute an array \"max_val\" for each i and for each starting point x, but that is O(n^2).\n\n   Another idea: we can use a segment tree or a sparse table for range maximum queries, but then the inner loop is still O(n) per state.\n\n   Or we can use a 1D DP and a sliding window maximum for the dp[x][j-1] part? But the added part is the maximum from x+1 to i.\n\n   Let's try to change the order: for fixed j, we want to compute dp[i][j] = max_{x=j-1}^{i-1} { dp[x][j-1] + max_val(x+1, i) }.\n\n   We can iterate i from 0 to n-1, and for each i, iterate j from 1 to min(i+1, k). For each j, we want to consider x from j-1 to i-1.\n\n   We can precompute an array \"prefix_max\" for the entire array for range queries? But then we need to combine with dp[x][j-1].\n\n   Alternatively, we can use a 2D array for the range maximum queries (sparse table) and then the transition is O(1) per state, but the total number of states is about n*k = 2000*2000 = 4e6, and each state takes O(1) if we use the sparse table, but then the total operations would be 4e6, which is acceptable.\n\n   Steps for sparse table for range maximum query:\n\n        We can build a sparse table for the array a of size n.\n\n        Steps for sparse table:\n\n            Let st[0][i] = a[i] for all i.\n\n            Let j = 1 to log2(n)\n            for i from 0 to n - (1<<j):\n                st[j][i] = max(st[j-1][i], st[j-1][i+(1<<(j-1))])\n\n        Then, to query [l, r] (0-indexed, and l<=r):\n\n            j = floor(log2(r-l+1))\n            return max(st[j][l], st[j][r-(1<<j)+1])\n\n   Then, for each state (i, j) with i from 0 to n-1 and j from 1 to min(i+1, k):\n\n        Let low = j-1, high = i-1.\n        If low > high, skip.\n\n        Then, for x from low to high, we have:\n\n            M = query(x+1, i)   # if x+1 <= i, otherwise invalid.\n\n        But then we do this for each x, and then take the maximum of dp[x][j-1] + M.\n\n   However, the total work for one i and j is (i - j + 1) * (cost of query) and the cost of query is O(1) with sparse table, but the number of queries is (i-j+1) which is up to i, and i can be up to 2000, and j from 1 to i+1, so the total number of queries is about sum_{i=0}^{n-1} sum_{j=1}^{min(i+1,k)} (i-j+1) which is roughly O(n^2*k) which is 4e6 * 2000 = 8e9, and each query is O(1) but 8e9 iterations in Python is too slow.\n\n   We need to optimize further.\n\n   We can try to optimize the inner loop by noticing that the function f(x) = dp[x][j-1] + max_val(x+1, i) is unimodal? Or we can use a different data structure.\n\n   But note: the max_val(x+1, i) is non-increasing as x increases (as we move x to the right, the segment [x+1, i] becomes smaller, so the maximum may drop). And dp[x][j-1] is stored for each x.\n\n   We can try to use a segment tree or a Fenwick tree for the dp[x][j-1] values and update as i increases, but the max_val(x+1, i) is changing with i.\n\n   Another idea: for fixed j, let's iterate i from 0 to n-1, and maintain a pointer for the current maximum for the segment ending at i. But then we need to consider the dp[x][j-1] for x from j-1 to i-1.\n\n   We can use a deque to maintain the maximum of dp[x][j-1] for x in a range, but the range is [j-1, i-1] and the added term is the maximum of the subarray [x+1, i]. The latter is not constant.\n\n   After some thought, we can try to use the following:\n\n   Let's for fixed j, and for i from j-1 to n-1, we want to compute:\n\n        dp[i][j] = max_{x=j-1}^{i-1} { dp[x][j-1] + max_val(x+1, i) }\n\n   We can iterate i from 0 to n-1, and for each i, we consider j from 1 to min(i+1, k). But then the inner loop for x is from j-1 to i-1.\n\n   We can reverse the order: for fixed j, and for i from j-1 to n-1, we can try to extend the segment ending at i and update the best dp[x][j-1] for x",
    "response": "\nTo solve this problem, we need to maximize the total profit Polycarp gets from solving problems over exactly `k` days, where each day he solves a contiguous segment of problems from the list. The profit for each day is the maximum difficulty of the problems solved that day. The challenge is to partition the list into `k` contiguous segments such that the sum of their maximum difficulties is maximized.\n\n### Approach\n1. **Problem Analysis**: The key observation is that the optimal solution involves selecting the top `k` largest numbers from the problem difficulties. However, these numbers must be placed in separate segments without any larger number in their respective segments. This ensures that each selected number contributes its full value to the total profit.\n\n2. **Intuition**: The total profit is maximized when the largest numbers are each the maximum in their own segment. To achieve this, we need to ensure that segments are split such that no segment contains a number larger than its own maximum. \n\n3. **Algorithm Selection**: \n   - **Step 1**: Identify the indices of the top `k` largest numbers in the array.\n   - **Step 2**: Sort these indices to determine the order in which segments should be split.\n   - **Step 3**: Construct the segments by splitting the array at positions just after each identified index, ensuring each segment's maximum is one of the top `k` numbers.\n\n4. **Complexity Analysis**: The algorithm involves sorting and traversing the array, which has a time complexity of O(n log n) due to the sorting step, where `n` is the number of problems. The space complexity is O(n) for storing the indices and segments.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    if k == 1:\n        print(sum(a))\n        print(n)\n        print(\" \".join([str(n)]))\n        return\n        \n    selected_indices = []\n    for i in range(n):\n        selected_indices.append((a[i], i))\n        \n    selected_indices.sort(key=lambda x: x[0], reverse=True)\n    top_k_indices = [idx for _, idx in selected_indices[:k]]\n    top_k_indices.sort()\n    \n    segments = []\n    start = 0\n    prev_index = -1\n    for idx in top_k_indices:\n        if prev_index == idx:\n            continue\n        segments.append(idx - start + 1)\n        start = idx + 1\n        prev_index = idx\n        \n    segments.append(n - start)\n    \n    if len(segments) > k:\n        segments = segments[:k]\n    else:\n        while len(segments) < k:\n            segments.append(0)\n            \n    total_profit = 0\n    for i in range(k):\n        total_profit += a[starts[i]]\n        \n    print(total_profit)\n    print(\" \".join(map(str, segments)))\n\nif __name__ == \"__main__\":\n    starts = []\n    current = 0\n    for seg_len in segments:\n        starts.append(current)\n        current += seg_len\n        \n    output_segments = []\n    for i in range(k):\n        output_segments.append(str(segments[i]))\n        \n    print(\" \".join(output_segments))\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of problems `n`, the number of days `k`, and the list of problem difficulties `a`.\n2. **Special Case Handling**: If `k` is 1, the entire list is solved in one day, so the total profit is the sum of all problem difficulties.\n3. **Finding Top k Indices**: The indices of the top `k` largest numbers in the list are identified and sorted to determine the optimal segmentation points.\n4. **Segment Construction**: The array is split into segments such that each segment contains one of the top `k` numbers and no larger numbers. The lengths of these segments are recorded.\n5. **Output**: The total profit is calculated as the sum of the top `k` numbers. The segment lengths are printed, ensuring the sum of the lengths equals `n`.\n\nThis approach efficiently maximizes the total profit by leveraging the largest numbers in the problem list and strategically segmenting the array to ensure each segment's maximum is one of these top values.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    if k == 1:\n        print(sum(a))\n        print(n)\n        print(\" \".join([str(n)]))\n        return\n        \n    selected_indices = []\n    for i in range(n):\n        selected_indices.append((a[i], i))\n        \n    selected_indices.sort(key=lambda x: x[0], reverse=True)\n    top_k_indices = [idx for _, idx in selected_indices[:k]]\n    top_k_indices.sort()\n    \n    segments = []\n    start = 0\n    prev_index = -1\n    for idx in top_k_indices:\n        if prev_index == idx:\n            continue\n        segments.append(idx - start + 1)\n        start = idx + 1\n        prev_index = idx\n        \n    segments.append(n - start)\n    \n    if len(segments) > k:\n        segments = segments[:k]\n    else:\n        while len(segments) < k:\n            segments.append(0)\n            \n    total_profit = 0\n    for i in range(k):\n        total_profit += a[starts[i]]\n        \n    print(total_profit)\n    print(\" \".join(map(str, segments)))\n\nif __name__ == \"__main__\":\n    starts = []\n    current = 0\n    for seg_len in segments:\n        starts.append(current)\n        current += seg_len\n        \n    output_segments = []\n    for i in range(k):\n        output_segments.append(str(segments[i]))\n        \n    print(\" \".join(output_segments))",
    "score": -1,
    "metadata": {
        "prompt_token_count": 929,
        "completion_token_count": 923,
        "thoughts_token_count": 8191
    }
}