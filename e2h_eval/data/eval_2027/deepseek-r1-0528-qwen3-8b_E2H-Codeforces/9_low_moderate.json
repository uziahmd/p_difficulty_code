{
    "start": 1758093365.5942888,
    "end": 1758094993.306248,
    "start-formatted": "2025-09-17 16:16 KST",
    "end-formatted": "2025-09-17 16:43 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n The total weight m is up to 300000.\n\n Since the weights are only 1, 2, or 3, we can break down the souvenirs by weight.\n\n Let:\n   type1: all souvenirs with weight 1 (each has cost ci)\n   type2: all souvenirs with weight 2\n   type3: all souvenirs with weight 3\n\n We can sort each type by cost (so that we can take the most expensive ones first).\n\n However, note: we are allowed to choose any subset. The problem resembles a bounded knapsack but with small weights.\n\n We can use dynamic programming for knapsack, but the total weight m is 300000 and n is 100000, and we have only three distinct weights.\n\n Alternatively, we can consider:\n\n Let's denote:\n   Let x1 be the number of type1 items we take (from 0 to count1)\n   Similarly, x2 from 0 to count2, and x3 from 0 to count3.\n\n Then the total weight is: w = x1*1 + x2*2 + x3*3 <= m.\n\n And the total cost is: sum_{i=1}^{x1} (sorted type1[i]) + ... \n\n But note: we cannot try all combinations because the counts might be large.\n\n Instead, we can precompute:\n\n For type1: sort the list and then form an array `a` where a[i] is the maximum total cost we can get by taking i items from type1.\n   Since type1 items have weight 1, we want the largest i costs. So if we sort type1 in descending order, then:\n        a[0] = 0\n        a[i] = a[i-1] + sorted_type1[i-1]   (if sorted_type1 is sorted descending)\n\n But wait: we are going to combine with other types. However, note that we have three independent types.\n\n However, the total weight constraint is linear. We can do:\n\n   Let f(w) be the maximum total cost for weight exactly w? But w up to 300000, which is acceptable.\n\n But note: n can be 100000, and we have three types. We can do:\n\n   Step 1: Break the souvenirs into three lists: L1, L2, L3.\n\n   Step 2: Sort each list in descending order (so that we have the most expensive first).\n\n   Step 3: Precompute the prefix sums for each type for the entire list (for type1, the prefix sum for i items is the sum of the first i largest; similarly for type2 and type3).\n\n   However, note: for type2 and type3, we cannot simply use the same prefix because the items are not necessarily taken in contiguous blocks? Actually, since we can take any subset (and the items are divisible in the sense of being independent and having fixed weight) we can use the idea of \"unbounded knapsack\" but with bounded counts? But note: the counts are the sizes of the lists.\n\n   However, we are going to combine the three types. The total weight equation is:\n\n        x1 + 2*x2 + 3*x3 <= m\n\n   And the total cost is: \n        cost1(x1) + cost2(x2) + cost3(x3)\n\n   We can iterate over x3 from 0 to min(len(L3), m//3). Then, for each fixed x3, we have remaining weight: m - 3*x3.\n\n   Then we need to consider the combination of type1 and type2 for the remaining weight.\n\n   But note: the remaining weight must be nonnegative, and we can use at most (remaining_weight) for type1 and type2, and we can break the remaining weight into two parts: we can assign some weight to type1 and the rest to type2.\n\n   Alternatively, we can precompute:\n\n        dp[w] = maximum total cost for weight <= w using only type1 and type2.\n\n   How to compute dp for type1 and type2?\n\n   Since type1 has weight 1 and type2 has weight 2, and we have limited counts for each, we can do:\n\n        Let A = sorted(L1, reverse=True)   # the top k1 for type1\n        Let B = sorted(L2, reverse=True)   # the top k2 for type2\n\n        Then, we can form an array for type1: for i from 0 to k1, prefix1[i] = sum of the first i items of A.\n\n        Similarly,",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs have weights of either 1, 2, or 3 units, and each souvenir has a specific cost. \n\n### Approach\n1. **Problem Analysis**: The problem is a variation of the classic knapsack problem, but with a constraint that the weights of the items are limited to three possible values (1, 2, or 3). Given the constraints (n ≤ 100,000 and m ≤ 300,000), a dynamic programming approach would be too slow if we consider all possible weights. Instead, we leverage the fact that the weights are small (only 1, 2, or 3) to break down the problem into handling three separate lists of items based on their weights.\n\n2. **Intuition**: By categorizing items into three groups (weight 1, 2, and 3), we can process each group independently. For each group, we sort the items in descending order of cost and compute prefix sums. This allows us to quickly determine the maximum cost achievable by selecting any number of items from a group up to a certain weight.\n\n3. **Algorithm Selection**: \n   - **Categorization**: Split all items into three lists based on their weights.\n   - **Sorting and Prefix Sums**: For each list, sort the items in descending order of cost and compute prefix sums. The prefix sum at index `i` gives the total cost of selecting the top `i` most expensive items from that group.\n   - **Combination**: For each possible number of items from the weight-3 group (which contributes the most to the weight), calculate the remaining weight available for the other two groups. Use the prefix sums of the weight-1 and weight-2 groups to find the optimal combination that maximizes the total cost without exceeding the remaining weight.\n\n4. **Complexity Analysis**: \n   - Sorting each group takes O(n log n) time, where n is the number of items.\n   - Computing prefix sums for each group is O(n).\n   - The main loop runs in O(m/3 * min(len(group1), m)) time, which is feasible given the constraints.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for _ in range(n):\n        w = int(next(it))\n        c = int(next(it))\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        else:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    k1 = len(type1)\n    k2 = len(type2)\n    k3 = len(type3)\n    \n    prefix1 = [0] * (k1 + 1)\n    for i in range(1, k1 + 1):\n        prefix1[i] = prefix1[i-1] + type1[i-1]\n        \n    prefix2 = [0] * (k2 + 1)\n    for i in range(1, k2 + 1):\n        prefix2[i] = prefix2[i-1] + type2[i-1]\n        \n    prefix3 = [0] * (k3 + 1)\n    for i in range(1, k3 + 1):\n        prefix3[i] = prefix3[i-1] + type3[i-1]\n        \n    best = 0\n    for x3 in range(0, k3 + 1):\n        rem_weight = m - 3 * x3\n        if rem_weight < 0:\n            continue\n            \n        max_from_3 = prefix3[x3]\n        rem_weight2 = min(rem_weight, 2 * k2)\n        max_from_2 = prefix2[rem_weight2] if rem_weight2 >= 0 else 0\n        \n        rem_weight1 = rem_weight - 2 * x2_used\n        x2_used = rem_weight2 // 2\n        if x2_used > k2:\n            x2_used = k2\n        else:\n            x2_used = rem_weight2 // 2\n            \n        rem_weight1 = rem_weight - 3 * x3 - 2 * x2_used\n        if rem_weight1 < 0:\n            continue\n            \n        x1_max = min(k1, rem_weight1)\n        total_cost = max_from_3 + max_from_2 + prefix1[x1_max]\n        if total_cost > best:\n            best = total_cost\n            \n    print(best)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of items `n` and the maximum weight `m`. Each item's weight and cost are then categorized into one of three lists based on their weight (1, 2, or 3).\n\n2. **Sorting and Prefix Sums**: Each list of items is sorted in descending order of cost. Prefix sums are computed for each list to quickly access the sum of the top `i` items.\n\n3. **Combination Calculation**: The algorithm iterates over all possible counts of weight-3 items. For each count, it calculates the remaining weight and uses the prefix sums of the weight-1 and weight-2 items to find the optimal combination that maximizes the total cost without exceeding the remaining weight.\n\n4. **Output**: The maximum total cost encountered during the iteration is printed as the result.\n\nThis approach efficiently handles the constraints by leveraging the limited weight values and using prefix sums to optimize the selection of items from each category.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for _ in range(n):\n        w = int(next(it))\n        c = int(next(it))\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        else:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    k1 = len(type1)\n    k2 = len(type2)\n    k3 = len(type3)\n    \n    prefix1 = [0] * (k1 + 1)\n    for i in range(1, k1 + 1):\n        prefix1[i] = prefix1[i-1] + type1[i-1]\n        \n    prefix2 = [0] * (k2 + 1)\n    for i in range(1, k2 + 1):\n        prefix2[i] = prefix2[i-1] + type2[i-1]\n        \n    prefix3 = [0] * (k3 + 1)\n    for i in range(1, k3 + 1):\n        prefix3[i] = prefix3[i-1] + type3[i-1]\n        \n    best = 0\n    for x3 in range(0, k3 + 1):\n        rem_weight = m - 3 * x3\n        if rem_weight < 0:\n            continue\n            \n        max_from_3 = prefix3[x3]\n        rem_weight2 = min(rem_weight, 2 * k2)\n        max_from_2 = prefix2[rem_weight2] if rem_weight2 >= 0 else 0\n        \n        rem_weight1 = rem_weight - 2 * x2_used\n        x2_used = rem_weight2 // 2\n        if x2_used > k2:\n            x2_used = k2\n        else:\n            x2_used = rem_weight2 // 2\n            \n        rem_weight1 = rem_weight - 3 * x3 - 2 * x2_used\n        if rem_weight1 < 0:\n            continue\n            \n        x1_max = min(k1, rem_weight1)\n        total_cost = max_from_3 + max_from_2 + prefix1[x1_max]\n        if total_cost > best:\n            best = total_cost\n            \n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1248,
        "thoughts_token_count": 1023
    }
}