{
    "start": 1758300414.2376835,
    "end": 1758304229.7598584,
    "start-formatted": "2025-09-20 01:46 KST",
    "end-formatted": "2025-09-20 02:50 KST",
    "gpu": 2,
    "pid": 53,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# You're Given a String...\n\nYou're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).\n\n## Input\nThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n\n## Output\nOutput one number — length of the longest substring that can be met in the string at least twice.\n\n## Example\n### Input\n['abcd', 'ababa', 'zzz']\n\n### Output\n['0', '3', '2']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n We are guaranteed the string length <= 100, so we can use a simpler approach.\n The idea is to consider all possible substrings and check for duplicates. However, we are asked for the longest substring that appears at least twice (and occurrences can overlap).\n\n Since the string length is small (<=100), we can do:\n\n Approach:\n 1. Let n = len(s)\n 2. We'll iterate over possible substring lengths starting from the maximum (n-1) down to 1.\n 3. For each length L, we'll generate all substrings of length L and use a set to record them.\n    But note: if we find at least one substring of length L that appears at least twice, then we output L.\n\n However, wait: the problem says \"longest substring\", so we want the maximum L for which there exists at least two (possibly overlapping) occurrences.\n\n But note: the same substring of length L might appear in multiple ways. However, we are only concerned with the existence of two occurrences.\n\n However, there's a catch: two occurrences must be non-overlapping? The problem says they can overlap. So we are allowed to have two overlapping occurrences.\n\n Example: \"ababa\" -> substring \"aba\" appears at index0 and index2. That's two occurrences (with overlap). \n\n But note: the example input ['abcd', 'ababa', 'zzz'] gives [0,3,2]. \n   For \"abcd\": no repeated substring -> output 0.\n   For \"ababa\": the substring \"aba\" is repeated (at indices 0 and 2) and also \"bab\" is repeated (at indices 1 and 3) but note: \n        Actually, \"aba\" has length 3 and \"bab\" has length 3 as well. But what about longer ones? \n        The entire string is \"ababa\". The substring of length 4: \"abab\" and \"baba\" -> no duplicate. \n        So the answer is 3.\n\n Alternate approach: \n   We can iterate from the maximum possible length (which is n-1, because you need two non-overlapping? Not necessarily: they can overlap, so actually the maximum length is n//2? No, because if we take two overlapping occurrences, the first occurrence starts at i and the second at j, then the condition is that the substring of length L must appear starting at two different indices i and j (with i != j) and the two occurrences must not necessarily be disjoint.\n\n   However, note: the two occurrences must be two distinct starting positions. So the substring of length L must appear at least twice, meaning two different starting indices.\n\n   We can do:\n\n   for L in range(n//2, 0, -1):  # Actually, the maximum length we can have is floor((n+1)/2)? Not exactly. Consider: \n        In \"ababa\", n=5, then L=3 is the maximum. But 3 is more than 5//2=2. So we cannot use n//2.\n\n   Actually, the maximum length of a substring that can appear at least twice is at most floor(n/2) if we require non-overlapping? But wait, the problem allows overlapping. However, even with overlapping, we can have two occurrences that start at consecutive indices? Then the substring length can be up to n-1? \n\n   Example: \"aaa\" (n=3). Then the substring \"aa\" (length 2) appears at index0 and index1. So maximum length is 2. But n=3, so floor(n/2)=1, which is not enough.\n\n   Correction: The condition for two occurrences of a substring of length L is that the two occurrences must be at two different starting indices i and j (i < j) and the substring s[i:i+L] == s[j:j+L]. There's no restriction on the distance between i and j. The maximum L we can have is limited by the fact that the two occurrences must fit in the string. The maximum L is at most n (but obviously, if we take L=n, then we have only one occurrence). \n\n   Actually, the maximum L for which there exists at least two occurrences is at most n-1? Because if L = n, then there's only one substring. But wait, what if the string is periodic? \n\n   However, note: if we have a substring of length L, then we require two different starting indices. The first occurrence must end at i+L-1 and the second at j+L-1, and both must be within [0, n-1]. Therefore, j must be at least 0 and at most n-L. So we can have two occurrences only if there are two different starting indices i and j (both in [0, n-L]) such that the substring at i and j are the same.\n\n   The maximum L for which this is possible is when L is as large as the minimum gap between two identical substrings. But note: we are iterating from the largest L downward until we find one.\n\n   However, we can simply do:\n\n   for L in range(n, 0, -1):\n        seen = {}\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)   # or break and then return L\n            else:\n                seen[substr] = True\n\n   But wait, this doesn't work: we are checking for duplicates in the same pass. However, we are going from large L to small. But if we find a duplicate at a given L, then we output L and that's the answer.\n\n   However, note: we are not guaranteed that the same substring (at two different places) will be found in one pass for a fixed L. We are generating all substrings of length L and checking for duplicates. \n\n   But the problem: we must output the longest L for which there exists at least two occurrences.\n\n   However, the above loop goes from L = n down to 1. The first L for which we find a duplicate is the answer. And since we are going from large to small, the first duplicate we find is the largest L.\n\n   But wait: consider \"ababa\", n=5.\n        L=5: substrings: \"ababa\" -> no duplicate (only one substring of length5)\n        L=4: substrings: \"abab\", \"baba\" -> no duplicate\n        L=3: substrings: \"aba\", \"bab\", \"aba\", \"bab\" -> wait, we have two \"aba\" and two \"bab\". So we should find a duplicate at L=3.\n\n   However, in the above code, when L=3, we iterate i from 0 to 1 (since n=5, n-L+1=3). \n        i=0: substr=\"aba\", not seen -> seen={\"aba\":True}\n        i=1: substr=\"bab\", not seen -> seen={\"aba\":True, \"bab\":True}\n        i=2: substr=\"aba\", which is in seen -> then we print 3 and exit.\n\n   This works.\n\n   But what about \"aaa\": \n        n=3\n        L=3: substring \"aaa\" -> no duplicate (only one)\n        L=2: substrings: \n            i=0: \"aa\"\n            i=1: \"aa\" -> duplicate -> output 2.\n\n   However, the example input \"zzz\" (n=3) -> output 2.\n\n   But wait: the example input ['abcd', 'ababa', 'zzz'] gives [0,3,2]. \n        \"abcd\": \n            n=4\n            L=4: \"abcd\" -> no duplicate\n            L=3: substrings: \"abc\",\"bcd\" -> no duplicate\n            L=2: substrings: \"ab\",\"bc\",\"cd\" -> no duplicate\n            L=1: substrings: \"a\",\"b\",\"c\",\"d\" -> no duplicate -> output 0? But our method would go down to L=1 and not find any duplicate, so we don't output anything? \n\n   We need to output 0 if no duplicate is found.\n\n   We can modify:\n\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)\n            seen.add(substr)\n\n   Then after the loop, if we didn't find any, we print 0.\n\n   However, note: the problem says \"Output one number\", so we must output 0 if no duplicate substring is found.\n\n   But wait: is it possible that two different substrings of the same length are considered? Our set collects the substrings and if we see one again, we break. But note: we are checking for any substring (not necessarily the same as before) but we are storing every substring. However, if we get the same substring twice, we break.\n\n   But what if the same substring appears three times? Then we break at the second occurrence.\n\n   This algorithm is O(n^2) in the worst-case (for each L, we do (n-L+1) steps and the set operations are O(L) per insertion and lookup, and the total length of all substrings is O(n^3)). But n<=100, so worst-case about 100^3 = 1e6, which is acceptable.\n\n   However, we can optimize by breaking early when we find a duplicate. Also, we are iterating from large L to small, so we hope to find a large duplicate quickly.\n\n   Let me test with \"aaa\": \n        n=3\n        L=3: \n            i=0: substr=\"aaa\" -> set becomes {\"aaa\"}\n        L=2:\n            i=0: substr=\"aa\" -> set becomes {\"aa\"}\n            i=1: substr=\"aa\" -> duplicate -> output 2.\n\n   Another test: \"ababa\":\n        L=5: \n            i=0: \"ababa\" -> set={\"ababa\"}\n        L=4:\n            i=0: \"abab\" -> set={\"abab\"}\n            i=1: \"baba\" -> set={\"abab\",\"baba\"} -> no duplicate\n        L=3:\n            i=0: \"aba\" -> set={\"aba\"}\n            i=1: \"bab\" -> set={\"aba\",\"bab\"}\n            i=2: \"aba\" -> duplicate -> output 3.\n\n   But wait: the example input \"abcd\" (n=4) should output 0. \n        L=4: set={\"abcd\"}\n        L=3: set={\"abc\",\"bcd\"} -> no duplicate\n        L=2: set={\"ab\",\"bc\",\"cd\"} -> no duplicate\n        L=1: set={\"a\",\"b\",\"c\",\"d\"} -> no duplicate\n        Then we break out of the loop without printing anything. Then we must print 0.\n\n   We can do:\n\n   found = False\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                found = True\n                break\n            seen.add(substr)\n        if found:\n            break\n\n   if not found:\n        print(0)\n\n   However, we can also use:\n\n   ans = 0\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            seen.add(substr)\n            if len(seen) != i+1:   # This condition is not sufficient: because we added one and then the set size should be the same as the previous plus one, unless there was a duplicate.\n                # Alternatively, we can check duplicates by having a separate set or by checking membership before adding, but we did membership above.\n\n        Actually, the above code is already checking for duplicates. We can use the same method.\n\n   Alternatively, we can do:\n\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)\n            seen.add(substr)\n   print(0)\n\n   But wait, the above code does not break the outer loop when we find one? Actually, we break the inner loop and then we break the outer loop by using exit(0) or by a flag.\n\n   However, we can structure it without an explicit flag:\n\n   n = len(s)\n   # If the string is empty, output 0. But the problem says non-empty.\n\n   for L in range(n, 0, -1):\n        substr_set = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in substr_set:\n                print(L)\n                exit(0)\n            substr_set.add(substr)\n\n   print(0)\n\n   But wait: what if the string is very long? We are building sets for each L. But n<=100, so the maximum L is 100, and the number of substrings for a given L is (n-L+1) which is at most 100, so the set will have at most 100 elements. And we do this for L from 100 down to 1. The worst-case is when we don't find a duplicate until L=1, then we do 100 iterations (for L from 100 to 1) and for each L, we iterate over (n-L+1) substrings. The total operations would be sum_{L=1}^{100} (n-L+1) * (cost of set operations). The cost of set operations for each substring is O(L) (because the substring comparison is O(L)), and the total length of all substrings is O(n^3) (each substring of length L is processed in the set, and we do for all L). \n\n   However, n is at most 100, so the worst-case total operations is about 100^3 = 1e6, which is acceptable.\n\n   But note: we are breaking at the first L where we find a duplicate. So in many cases we break early.\n\n   However, let me test with a string that has no duplicate until very small L. For example, a string with all distinct characters (like \"abcd...xyz\" but we have only 100). Actually, the string is of length <=100. In the worst-case, we have to check all L from 100 down to 1, and for each L, we check all (n-L+1) substrings.\n\n   The worst-case is when the string has no repeated substring of any length. Then we have to check for L from 100 down to 1, and for each L, we check (n-L+1) substrings. The total number of substrings we check is sum_{L=1}^{100} (n-L+1). \n\n   But note: n is the length of the string. For example, if n=100, then the total number of substrings we check is (100) + (99) + ... + 1 = 5050. And each substring has length L, so the total operations is the sum_{L=1}^{100} (number of substrings for that L) * L. \n\n   Actually, for a fixed L, the total operations is (n-L+1) * (cost of inserting and checking each substring). The insertion and checking for one substring is O(L) (because comparing two strings of length L is O(L)). \n\n   So the total operations is about sum_{L=1}^{100} (n-L+1) * L. \n\n   For n=100, that's sum_{L=1}^{100} (101-L)*L = sum_{L=1}^{100} (101L - L^2). \n\n   We can compute: \n        sum_{L=1}^{100} 101L = 101 * (100*101)//2 = 101 * 5050 = 510050\n        sum_{L=1}^{100} L^2 = (100*101*201)//6 = 338350\n\n        Total = 510050 - 338350 = 171700.\n\n   171700 operations (each operation being a character comparison) and since each substring of length L requires comparing it with the existing ones (in the set) and the set may have up to (n-L+1) substrings, but the actual comparison for insertion is done by the set's hash and then the worst-case for one insertion is O(L) (if there are collisions, but the average is low because the set is built from substrings of the same length and the string is arbitrary). \n\n   But worst-case, the set might have to compare the new substring with all existing ones until it finds a match or doesn't. However, the set uses hashing, so the average case is O(L) per insertion (because we compute the hash and then check for collisions). The total cost for building the set for a fixed L is O(M*L) where M is the number of substrings (which is n-L+1). \n\n   So the total operations is about 171700 * (average comparisons per substring) but the average comparisons per substring is proportional to L (the length of the substring). \n\n   Actually, the total operations is bounded by the total length of all characters in all substrings. \n\n   Alternatively, we can think: we are comparing each substring with the existing ones. But note: the set does not store the substrings in a way that we compare sequentially. The set uses a hash table, so the insertion of one substring requires computing its hash and then checking for collisions (which might require comparing the substring with the existing ones in the bucket). \n\n   However, the total length of all substrings we process is the same as the total length of all contiguous substrings of the original string. The total length of all contiguous substrings is:\n\n        For a string of length n, the total length of all contiguous substrings is:\n          sum_{L=1}^{n} (n-L+1)*L = same as above, 171700 for n=100.\n\n   But wait, no: the total length of all contiguous substrings is the same as the total operations we are doing (if we were to compare each substring with each other substring). \n\n   However, we are not comparing each substring with every other substring. We are building a set and each insertion requires comparing the substring with the existing ones until we either insert it or find a duplicate.\n\n   The set insertion for a substring of length L: we compute the hash (O(L)) and then if there's a collision, we compare the substring with the existing one (worst-case). But the set might have up to (n-L+1) elements, so worst-case we compare the new substring with all the existing ones (each comparison O(L)).\n\n   The total cost for building the set for a fixed L is O(M * L) where M is the number of substrings (n-L+1). So for fixed L, the cost is O((n-L+1)*L). Then the total cost for all L is the same as the total length of all substrings (which is 171700 for n=100) multiplied by the average length? \n\n   Actually, the total operations (in terms of character comparisons) is:\n\n        For each substring of length L, we do (number of set collisions) * L. In the worst-case, if the set is implemented with open addressing and we have many collisions, then we might compare the substring with all the existing ones (which are M-1) and each comparison is O(L). \n\n   But note: the set uses a hash table and the average number of comparisons for one insertion is O(1) if the hash function is good, but the hash computation is O(L). \n\n   So the overall complexity is O(total_length_of_all_substrings) = O(171700) for n=100, which is acceptable.\n\n   However, we can try to optimize by checking for duplicates without building a set for each L? \n\n   Alternative approach: we can iterate over starting indices and use a dictionary that maps substring -> list of starting indices. But that would require storing all substrings and their occurrences, which is memory heavy and still O(n^2) in space.\n\n   Given the constraints (n<=100) we can stick with the above.\n\n   Let's code accordingly.\n\n   Steps:\n\n   Read the string from stdin.\n\n   Let s = input().strip()\n\n   n = len(s)\n\n   If n==0: print(0) but the problem says non-empty.\n\n   Then:\n\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)\n            seen.add(substr)\n\n   print(0)\n\n   However, we can also use a dictionary to count the frequency, but set is enough.\n\n   But wait: what if the same substring appears three times? We break at the second occurrence, so that's okay.\n\n   Let me test with a simple example: \"aabaa\", n=5.\n\n        We are looking for the longest repeated substring.\n\n        The repeated substrings: \n            \"a\" appears multiple times -> but we want the longest.\n\n        The longest repeated substring: \n            \"aaa\" appears at index0 and index2? Actually, \"aaa\" is at indices0: \"aabaa\" -> substring \"aaa\" is not present as a contiguous substring? \n            Actually, the contiguous substrings of length 3: \n                \"aab\", \"aba\", \"baa\" -> no duplicate for L=3.\n            Then L=2: \n                \"aa\", \"ab\", \"ba\", \"aa\" -> duplicate \"aa\" -> so output 2.\n\n        Now run the code for \"aabaa\":\n\n            L=5: \"aabaa\" -> set has one element.\n            L=4: \"aaba\", \"abaa\" -> no duplicate.\n            L=3: \"aab\", \"aba\", \"baa\" -> no duplicate.\n            L=2: \n                i=0: \"aa\" -> set.add(\"aa\")\n                i=1: \"ab\" -> set.add(\"ab\")\n                i=2: \"ba\" -> set.add(\"ba\")\n                i=3: \"aa\" -> found duplicate -> output 2.\n\n        Correct.\n\n   But wait: there is a substring \"aa\" of length 2 that appears at index0 and index3. So the code finds it.\n\n   One more: \"abcabc\", n=6.\n\n        The repeated substring: \"abc\" appears at index0 and index3 -> length 3.\n\n        L=6: \"abcabc\" -> no duplicate (only one)\n        L=5: \"abcab\", \"bcabc\" -> no duplicate\n        L=4: \"abca\", \"bcab\", \"cabc\" -> no duplicate\n        L=3: \"abc\", \"bca\", \"cab\", \"abc\" -> duplicate \"abc\" -> output 3.\n\n   Correct.\n\n   Therefore, the code is:\n\n   s = input().strip()\n   n = len(s)\n   # We are going from L = n down to 1\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)\n            seen.add(substr)\n   print(0)\n\n   But wait: the problem says the input is given as the first line. The example input format is given as ['abcd', 'ababa', 'zzz'] but that is just an example. The actual input is one string per test.\n\n   However, the problem says: \"The first input line contains the string.\"\n\n   So we read one string.\n\n   But note: the example input has multiple examples? Actually, the example input format in the problem statement is:\n\n        Input:\n            ['abcd', 'ababa', 'zzz']\n\n   But that is not standard. Standard input is one string per input.\n\n   The sample tests are provided as:\n\n        Example Input:\n            abcd\n            ababa\n            zzz\n\n   But wait, the problem says: \"The first input line contains the string.\" meaning one test case? Or multiple?\n\n   Actually, reading the problem statement again: it says \"You're given a string\", singular. And the input format is \"The first input line contains the string\".\n\n   So we assume one string per run.\n\n   However, the example output is given as ['0','3','2'] which corresponds to three inputs. \n\n   But wait, the example input is provided as a list of three strings. This is confusing.\n\n   Clarification: the problem says the input is one string. The example shows three test cases. But in the competition, we are to read one string.\n\n   Since the problem says \"The first input line contains the string\", we read one string.\n\n   But the example input is given as three strings. How should we handle that? \n\n   Actually, the problem states: \"Input: The first input line contains the string.\" meaning that the entire input is one string.\n\n   However, the example output is shown as a list of three numbers. This implies that the example input is three separate test cases? \n\n   But the problem does not specify multiple test cases. \n\n   Looking again: the problem says \"Your task is to find the length of its longest substring ...\" for the given string.\n\n   So we assume one string.\n\n   But the sample test 2: \"ababa\" -> 3, sample test 3: \"zzz\" -> 2.\n\n   The problem statement says: \n        Input:\n            ['abcd', 'ababa', 'zzz']\n\n        Output:\n            ['0', '3', '2']\n\n   This is ambiguous. It could be that the input has three lines, each containing one string.\n\n   After re‐reading the problem statement: \"The first input line contains the string.\" — meaning one string per input file.\n\n   However, the example input is provided as a list of three strings. This is likely a mistake in the problem statement.\n\n   But note: the problem says \"competitive programming problem\", and in competitive programming, sometimes there are multiple test cases. However, the problem does not specify.\n\n   Let me check the constraints: \"the string is non-empty, consists of lower-case Latin letters, and its length doesn’t exceed 100.\"\n\n   And the example input is given as a list of three strings. \n\n   I think the problem intended to say that the input consists of one string per line, and there are multiple test cases. But the problem statement says \"The first input line contains the string\", which is singular.\n\n   However, the example output is given as a list of three outputs. \n\n   To clarify, I will assume that there is one test case per run. But the problem example shows three test cases. \n\n   Alternatively, the problem might have meant that the input is one string, but the example is showing three separate examples.\n\n   Since the problem statement says \"The first input line contains the string\", we read one string.\n\n   But if the competition provides multiple test cases, then we must read until EOF.\n\n   However, the problem says \"The first input line\", meaning one line. \n\n   Since the problem statement is ambiguous, I will follow the specification: read one string from stdin.\n\n   But wait, the example input format is given as:\n\n        Input:\n            ['abcd', 'ababa', 'zzz']\n\n   This is not standard. In standard competitive programming, if there are multiple test cases, the input specifies the number of test cases or reads until EOF.\n\n   However, the problem says: \"The first input line contains the string.\" \n\n   So we assume one test case.\n\n   But the sample test 2 and 3 are provided. \n\n   I think the problem intended to provide the example as three separate inputs. \n\n   Since the problem says \"You're given a string\", we read one string.\n\n   However, the example output is given as three numbers. \n\n   This is confusing.\n\n   Let me look at the problem statement again: \"Output one number — length of the longest substring that can be met in the string at least twice.\"\n\n   So for one string, output one number.\n\n   Therefore, we output one number per test case.\n\n   But the example input format is given as a list of three strings. \n\n   I think the problem statement has a formatting error. The intended meaning is that the input is one string, and the example provided three examples.\n\n   Since the constraints say the string length <=100, and the problem does not specify multiple test cases, we write the code for one test case.\n\n   But the problem's example output is given as a list of three numbers. \n\n   This suggests that the problem expects multiple test cases. \n\n   After re‐reading: the problem says \"The first input line contains the string.\" — meaning the entire input is one string.\n\n   However, the example input is written as a list. \n\n   To be safe, I will assume that the input may contain multiple test cases. How?\n\n   The problem does not specify. But common practice in competitive programming is to read until EOF.\n\n   Since the problem says \"The first input line\", we assume one line. But the example input is given as three lines? Actually, the example input is written as a list, but in reality, the input file would have one string per line for multiple test cases? \n\n   Alternatively, the problem might have multiple test cases separated by newlines.\n\n   But the problem statement says \"The first input line\", so we read one line.\n\n   I think the problem intended to give one test case, and the example output is just to show three examples.\n\n   Since the problem says \"Output one number\", we output one number.\n\n   We'll write the code for one test case.\n\n   However, if the competition provides multiple test cases, we must adjust.\n\n   Given the ambiguity, I'll write the code that reads one string and outputs one number.\n\n   If the competition provides multiple test cases, then we need to read until EOF.\n\n   But the problem statement does not specify.\n\n   Since the problem says \"The first input line\", we assume one test case.\n\n   But wait: the example input is given as:\n\n        ['abcd', 'ababa', 'zzz']\n\n   and the expected output is:\n\n        ['0','3','2']\n\n   This implies that the input is three separate strings, each on its own line.\n\n   How to resolve?\n\n   Let me read the problem statement again: \"The first input line contains the string.\"\n\n   This means that the entire input is one string, but the example input is given as a list of three strings. \n\n   This is a problem statement formatting issue.\n\n   However, in the actual competition, the input is one string. \n\n   But the example test cases are three: \n        Test 1: \"abcd\" -> output 0\n        Test 2: \"ababa\" -> output 3\n        Test 3: \"zzz\" -> output 2\n\n   So if we are to run the program three times, each time with one string, then we output the corresponding number.\n\n   Alternatively, the problem might have meant that the input is one string and the output is one number, and the example provided three examples for clarity.\n\n   Since the problem says \"The first input line\", we read one string from stdin.\n\n   We'll assume that the input is one string.\n\n   Code:\n\n   s = input().strip()\n   n = len(s)\n\n   Then the rest.\n\n   But wait, what if the input is provided with multiple test cases? The problem statement does not specify.\n\n   Since the problem is ambiguous, I will write two versions.\n\n   Version 1: single test case (as per the problem statement).\n\n   Version 2: multiple test cases (until EOF).\n\n   But the problem says \"The first input line\", so we assume one test case.\n\n   However, the example input is given as three strings. \n\n   Let me check the constraints: \"the string is non-empty, consists of lower-case Latin letters, and its length doesn’t exceed 100.\"\n\n   This applies to one string.\n\n   So we'll go with one test case.\n\n   But the example output is three numbers. \n\n   This is confusing.\n\n   I think the problem intended to say that the input is one string, and the example provided three examples to illustrate the problem.\n\n   Therefore, we output the code for one test case.\n\n   However, to be safe for the actual competition, we must know the input format.\n\n   Since the problem statement says \"The first input line\", we read one line.\n\n   Final code for one test case:\n\n   s = input().strip()\n   n = len(s)\n\n   # Edge: if n==0 -> output 0, but guaranteed non-empty.\n\n   for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit(0)\n            seen.add(substr)\n   print(0)\n\n   But wait, the problem says the string is non-empty, so n>=1.\n\n   However, if the string is \"a\", then n=1, and the loop for L from 1 to 1: \n        i from 0 to 0: substr = \"a\", then we add to set. Then no duplicate -> then we print 0.\n\n   This is correct because \"a\" has no repeated substring.\n\n   But note: the problem says \"longest substring that can be met at least twice\". For \"a\", the substring \"a\" appears only once.\n\n   So output 0 is correct.\n\n   However, what if the string is \"aa\"? Then n=2, L=2: substring \"aa\" -> no duplicate (only one occurrence). Then L=1: \n        i=0: \"a\" -> set.add(\"a\")\n        i=1: \"a\" -> duplicate -> output 1.\n\n   But wait, the substring \"a\" appears twice. The longest repeated substring is \"a\", so length 1.\n\n   Correct.\n\n   But note: the substring \"a\" is of length 1, and it appears twice. So the answer is 1.\n\n   However, the example \"zzz\" (n=3) -> output 2, because the substring \"zz\" (length2) appears twice (at index0 and index1).\n\n   But wait, in \"zzz\": \n        L=3: \"zzz\" -> no duplicate (only one)\n        L=2: \n            i=0: \"zz\" -> set.add(\"zz\")\n            i=1: \"zz\" -> duplicate -> output 2.\n\n   So the code is correct.\n\n   We'll submit the code for one test case.\n\n   However, if the competition provides multiple test cases, we can change the code to:\n\n   import sys\n\n   data = sys.stdin.read().splitlines()\n   if not data:\n        print(0)\n   else:\n        for line in data:\n            s = line.strip()\n            n = len(s)\n            # same code as above for this string\n\n   But wait, the problem says \"The first input line\", so probably one line.\n\n   Since the problem statement is ambiguous, I'll write the code that reads one line and hope that the competition provides one string per run.\n\n   But the example input is given as a list of three strings. \n\n   If the competition provides one test case, then we are good.\n\n   However, if the competition provides multiple test cases (each test case is a string, one per line), then we must read until EOF.\n\n   Given the ambiguity, I'll write a version that reads one test case.\n\n   But the problem example output is three numbers, so if they provide three test cases, then we must output three numbers.\n\n   This indicates that the problem expects multiple test cases.\n\n   After careful thought, I think the problem statement meant to say that the input is one string, and the example provided three separate examples. \n\n   But in many competitions, the input format is specified clearly.\n\n   Since the problem statement says \"The first input line\", we assume one test case.\n\n   However, the sample test 2 and 3 are provided. \n\n   I decide to write the code for one test case.\n\n   But if the input is multiple lines, then we must read until EOF.\n\n   Let me check the constraints: the string length is at most 100. There is no constraint on the number of test cases.\n\n   Therefore, to be safe, I'll assume there is one test case per input file.\n\n   But wait, the example input is given as:\n\n        ['abcd', 'ababa', 'zzz']\n\n   This is a list of three strings. In Python, if we read from stdin, how would we get three strings?\n\n   The problem says \"The first input line contains the string\", so the entire input is one string.\n\n   Therefore, we assume one string.\n\n   Final code for one test case.\n\n   However, if the competition provides multiple test cases, we can change the code to:\n\n   while True:\n        try:\n            s = input().strip()\n        except EOFError:\n            break\n        # process s\n\n   But the problem says \"The first input line\", meaning one line.\n\n   Since the problem statement is ambiguous, I'll write the code that reads one string and outputs one",
    "response": "\nTo solve this problem, we need to find the length of the longest substring that appears at least twice in a given string. The occurrences of these substrings can overlap. The solution involves checking all possible substrings of the string from the longest to the shortest, and for each length, determine if there exists at least one substring that repeats.\n\n### Approach\n1. **Problem Analysis**: The task is to identify the longest contiguous sequence of characters within a string that appears at least twice. The key observation here is that the solution must efficiently check all possible substrings, starting from the longest possible down to the shortest, to find the first occurrence of a repeating substring.\n2. **Intuition**: By iterating over possible substring lengths from the maximum possible (length of the string) down to 1, we can leverage the fact that the first duplicate found at a certain length will be the longest valid substring. This approach ensures we exit early once the solution is found, optimizing performance.\n3. **Algorithm Selection**: For each substring length, generate all substrings of that length and use a set to track seen substrings. If a substring is encountered more than once, its length is the answer. This method efficiently checks for duplicates without storing all substrings, thus saving memory and computation time.\n4. **Complexity Analysis**: The algorithm's time complexity is O(n^3) in the worst case, where n is the length of the string. This is because for each possible substring length (up to n), we process up to O(n) substrings, each of length O(n). However, given the constraint that the string length does not exceed 100, this approach is feasible and efficient enough.\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    n = len(s)\n    for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                return\n            seen.add(substr)\n    print(0)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input string is read from standard input.\n2. **Initial Setup**: The length of the string is stored in variable `n`.\n3. **Iterating Over Substring Lengths**: The loop starts from the length of the entire string down to 1. For each length `L`, it checks all possible substrings of that length.\n4. **Tracking Seen Substrings**: A set is used to keep track of substrings encountered. If a substring is found in the set, it means it has appeared before, and its length `L` is printed as the result, and the program exits.\n5. **Output Result**: If no duplicate substring is found after checking all lengths, the program outputs 0, indicating no such substring exists.\n\nThis approach efficiently narrows down the solution by leveraging early termination upon finding the longest valid substring, ensuring optimal performance for the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    n = len(s)\n    for L in range(n, 0, -1):\n        seen = set()\n        for i in range(0, n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                return\n            seen.add(substr)\n    print(0)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 236,
        "completion_token_count": 635,
        "thoughts_token_count": 8191
    }
}