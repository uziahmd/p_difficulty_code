{
    "start": 1758296004.090009,
    "end": 1758298592.4128697,
    "start-formatted": "2025-09-20 00:33 KST",
    "end-formatted": "2025-09-20 01:16 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k give the same minimal LCM, choose the smallest k.\n\nLet d = (a+k) and e = (b+k). Then note that d - e = a - b (constant). So we can set g = gcd(d, e), then d = g * d', e = g * e' and gcd(d', e') = 1. Also, d' - e' = (d - e)/g = (a-b)/g.\n\nAlternatively, we can think of the condition: \n  Let t = k + min(a, b). Then we have two numbers: one starting at a and increasing, and the other at b and increasing. But note: we are adding k to both.\n\nAnother approach is to consider the equation:\n  LCM(a+k, b+k) = (a+k)*(b+k) / GCD(a+k, b+k)\n\nNote that the GCD of (a+k) and (b+k) must divide (a-b) because:\n  GCD(a+k, b+k) = GCD(a+k, (b+k) - (a+k)) = GCD(a+k, b-a)\n\nSo let d = |a-b| (without loss of generality, we can assume a<=b so d = b-a, but note: k is non-negative and we can have a>=b as well). Actually, we can define d = |a-b|. Then the GCD of (a+k) and (b+k) must divide d.\n\nTherefore, the divisors of the GCD are the divisors of d. However, note that k is being added to both, so the GCD must be a divisor of d.\n\nBut note: if we let g = GCD(a+k, b+k), then g divides d = |a-b|. So the candidate divisors for g are the divisors of |a-b|.\n\nNow, we want to minimize LCM(a+k, b+k) = (a+k)*(b+k) / g.\n\nBut note: (a+k)*(b+k) = (b+k)*(a+k) and the denominator is g.\n\nAlternatively, we can consider that the product (a+k)*(b+k) is fixed for a given k? Not exactly. But note that the LCM is determined by the product and the GCD.\n\nWe can also note that the LCM can be written as (a+k)*(b+k) / g, and since g divides (a-b), we can iterate over the divisors of |a-b|.\n\nHowever, note: k must be chosen such that the GCD(a+k, b+k) is a divisor of |a-b|. But wait, actually the GCD(a+k, b+k) must divide |a-b|, but it might not necessarily be one of the divisors of |a-b| in the sense that we can get any divisor? Actually, yes: the GCD must divide |a-b|, so we can consider all divisors of |a-b|.\n\nBut here's an alternative: we can write k in terms of the divisor. Let g be a divisor of |a-b| (and we consider positive divisors). Then we require that g divides (a+k) and g divides (b+k). Since g divides (a+k) and (b+k), then g divides (a-b). \n\nBut note: the condition that g divides (a+k) and (b+k) is equivalent to: k ≡ -a (mod g) and k ≡ -b (mod g). These two congruences are consistent if and only if g divides (a-b) (which it does, because g divides |a-b|). \n\nThen for a fixed divisor g (positive) of |a-b|, we can solve for k: \n   k ≡ (-a) mod g, and k ≡ (-b) mod g.\n\nBut note: (-a) mod g and (-b) mod g must be the same modulo g? Actually, we have (-a) ≡ (-b) mod g because g divides (a-b). Therefore, we can set k_min(g) = the smallest non-negative integer k satisfying k ≡ (-a) mod g (or equivalently k ≡ (-b) mod g).\n\nBut note: we can write k = m*g - a (if we think of the congruence) but we want non-negative k. Alternatively, we can write:\n\nk ≡ (-a) mod g  => k = t*g - a (for some integer t) but then we require k>=0. Alternatively, we can use:\n\nk = (-a) mod g, but if (-",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a+k \\) and \\( b+k \\) must divide the absolute difference between \\( a \\) and \\( b \\). This means we can consider all divisors of \\( |a - b| \\) to determine potential candidates for \\( k \\).\n2. **Insight**: For each divisor \\( g \\) of \\( |a - b| \\), we can find the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is derived from the congruence \\( k \\equiv (-a) \\mod g \\), ensuring \\( k \\) is non-negative.\n3. **Algorithm Selection**: We iterate over all positive divisors of \\( |a - b| \\). For each divisor \\( g \\), we compute the corresponding \\( k \\) that satisfies the congruence. We then compute the LCM for each candidate \\( k \\) and keep track of the minimal LCM encountered, along with the smallest \\( k \\) that achieves it.\n4. **Complexity Analysis**: The algorithm's efficiency hinges on the number of divisors of \\( |a - b| \\), which is manageable even for large numbers (up to \\( 10^9 \\)) because the number of divisors is relatively small.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\nfrom functools import reduce\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d_val = abs(a - b)\n    divisors_list = get_divisors(d_val)\n    \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors_list:\n        rem_a = (-a) % g\n        k_candidate = rem_a\n        while k_candidate < 0:\n            k_candidate += g\n            \n        num1 = a + k_candidate\n        num2 = b + k_candidate\n        current_gcd = gcd(num1, num2)\n        current_lcm = (num1 * num2) // current_gcd\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k_candidate < best_k):\n            best_lcm = current_lcm\n            best_k = k_candidate\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, the solution is trivially \\( k = 0 \\).\n3. **Divisor Calculation**: The absolute difference \\( |a - b| \\) is computed, and all its positive divisors are found.\n4. **Candidate \\( k \\) Generation**: For each divisor \\( g \\), the smallest non-negative \\( k \\) satisfying \\( k \\equiv (-a) \\mod g \\) is calculated.\n5. **LCM Calculation**: For each candidate \\( k \\), the LCM of \\( a+k \\) and \\( b+k \\) is computed using their GCD.\n6. **Tracking Minimum LCM**: The algorithm keeps track of the smallest LCM encountered and the corresponding smallest \\( k \\).\n7. **Output**: The smallest \\( k \\) yielding the minimal LCM is printed.\n\nThis approach efficiently narrows down the problem to considering only relevant divisors, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\nfrom functools import reduce\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d_val = abs(a - b)\n    divisors_list = get_divisors(d_val)\n    \n    best_k = None\n    best_lcm = None\n    \n    for g in divisors_list:\n        rem_a = (-a) % g\n        k_candidate = rem_a\n        while k_candidate < 0:\n            k_candidate += g\n            \n        num1 = a + k_candidate\n        num2 = b + k_candidate\n        current_gcd = gcd(num1, num2)\n        current_lcm = (num1 * num2) // current_gcd\n        \n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k_candidate < best_k):\n            best_lcm = current_lcm\n            best_k = k_candidate\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 907,
        "thoughts_token_count": 1023
    }
}