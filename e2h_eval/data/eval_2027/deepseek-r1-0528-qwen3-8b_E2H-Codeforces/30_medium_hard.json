{
    "start": 1758308040.3230443,
    "end": 1758311582.778047,
    "start-formatted": "2025-09-20 03:54 KST",
    "end-formatted": "2025-09-20 04:53 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n We need to assign each digit in A (from left to right) to either Homer (H) or Marge (M) for exactly n moves each.\n The goal is to maximize the total prize: S1 (the number formed by Homer's digits) + S2 (the number formed by Marge's digits).\n\n However, note that the problem does not require to output the actual numbers but the sequence of moves (a string of length 2n with n 'H' and n 'M').\n\n Important: The moves happen by taking the leftmost digit of A and appending it to the respective player's number. So the first move uses the first digit, second move uses the second, etc.\n\n Let's denote:\n   Let S1 be the number from Homer's moves (which are the digits assigned to H in order of occurrence) and S2 from Marge.\n\n But note: the digits are taken in the order they appear, so the first digit is the most significant for the first move.\n\n However, the catch: we have two players and we can decide arbitrarily who takes the next available digit? Actually, the problem says: \"each player should make exactly n moves\", and the process is:\n\n   Initially: A has 2n digits, S1 and S2 empty.\n   For each turn (each of the 2n moves):\n        The leftmost digit of A is taken.\n        Then we decide (in advance, by the sequence) whether it goes to H or M.\n\n But note: the problem says \"They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize.\"\n\n How to think?\n\n Let the entire sequence of moves be represented by a string of length 2n, containing n 'H' and n 'M'. The i-th digit of A (0-indexed) will be assigned to the player corresponding to the i-th move (i.e., the move that happens at the i-th step).\n\n Now, the total prize is computed as:\n   S1 = sum_{j=0}^{n-1} (digit at position j in the sequence of moves for H) * (10^(n-1-j))\n   Similarly for S2.\n\n Alternatively, we can think of the entire assignment: the first n moves (if we consider the first n moves) might not be all H? Actually, the moves are interleaved arbitrarily.\n\n However, note: the moves are fixed: the first digit is always the first one, then the second, etc. But we can choose the labels (H or M) arbitrarily as long as there are exactly n H's and n M's.\n\n How to maximize S1+S2?\n\n Note: S1 and S2 are two numbers, and the total prize is the sum of these two numbers.\n\n But observe: the entire string A is split into two subsequences (by the positions where we assign to H and M). However, the order of digits in each subsequence is the same as in A (because we are taking the leftmost first). \n\n Therefore, the two numbers are built from the digits in A, but the digits for S1 are the ones we label H and for S2 the ones labeled M, and the relative order of the digits in each number is the same as in A.\n\n Example: \n   Input: n=2, A='1234'\n\n   Option: \"HHMM\": \n        S1 = 12, S2 = 34 -> total = 12 + 34 = 46.\n\n   Option: \"HMHM\":\n        S1 = 13, S2 = 24 -> total = 13 + 24 = 37.\n\n   Option: \"HM HM\" (same as above) but wait, what if we try \"MMHH\":\n        S1 = 34, S2 = 12 -> total = 46.\n\n   What about \"MHMH\":\n        S1 = 24, S2 = 13 -> total = 37.\n\n   What about \"MHHM\":\n        S1 = 23, S2 = 14 -> total = 37.\n\n   What about \"MHMH\" again? We did.\n\n   Actually, let me check all:\n\n   We have 4 moves, n=2. So we have 6 possibilities (C(4,2)=6). We must try all.\n\n   Possibilities (with the sequence of moves):\n\n   1. HHMM: S1 = 12, S2 = 34 -> 12+34=46\n   2. HMHM: S1 = 13, S2 = 24 -> 13+24=37\n   3. HMMH: S1 = 12, S2 = 43 -> 12+43=55 -> wait, no: \n        Actually, the moves: \n            First move: H -> take the first digit '1' for S1, then A becomes '234'\n            Second move: M -> take the second digit '2' for S2, then A becomes '34'\n            Third move: M -> take the third digit '3' for S2, then A becomes '4'\n            Fourth move: H -> take the fourth digit '4' for S1 -> so S1 = 14, S2=23 -> total 37.\n\n        Correction: In the third move, the third digit is the next leftmost, which is the '3' (because after removing the first two, the string is '34'). Then the fourth digit is the remaining '4'. So the sequence \"HMMH\" gives S1 = 14 and S2=23 -> 14+23=37.\n\n   4. MHMH: S1=24, S2=13 -> 37\n   5. MHHM: S1=23, S2=14 -> 37\n   6. MMHH: S1=34, S2=12 -> 46\n\n   Actually, wait: \n        For \"HMMH\": \n            Move1: H -> take '1', S1=\"1\", A=\"234\"\n            Move2: M -> take '2', S2=\"2\", A=\"34\"\n            Move3: M -> take '3', S2=\"23\", A=\"4\"\n            Move4: H -> take '4', S1=\"14\", so S1=14, S2=23 -> total 37.\n\n   And for \"MMHH\":\n            Move1: M -> take '1', S2=\"1\", A=\"234\"\n            Move2: M -> take '2', S2=\"12\", A=\"34\"\n            Move3: H -> take '3', S1=\"3\", A=\"4\"\n            Move4: H -> take '4', S1=\"34\", so S1=34, S2=12 -> total 46.\n\n   So the maximum total prize is 46.\n\n   But wait, how did we get 55 above? That was a miscalculation.\n\n   Now, why did we get 46 for HHMM and MMHH? Actually, these two assignments put the two largest digits together for one player and the two smallest together for the other. However, note that the value of a number is determined by the position (the more significant the earlier). \n\n   Another way: consider the entire assignment.\n\n   We are going to assign each digit to either H or M. The total prize is:\n\n        S1 + S2 = (h0 * 10^(n-1) + h1 * 10^(n-2) + ... + hn-1 * 10^0) \n                 + (m0 * 10^(n-1) + m1 * 10^(n-2) + ... + m_{n-1} * 10^0)\n\n   But note: the digits are taken in order from A. The first digit (index0) is the most significant (multiplied by 10^(2n-1)) in the entire game? Actually, no: because we are building two separate numbers. Each digit's contribution to the total prize depends on the player and the position within that player's number.\n\n   Specifically, the first digit (A[0]) will be the first digit of whichever player gets it, so it is multiplied by 10^(n-1) (if assigned to H) or 10^(n-1) (if assigned to M). Then the second digit (A[1]) will be the second digit for the first move of the next player? Actually, no: the second digit is the next available and will be the second digit of the same player's number if the same player gets two consecutive moves? Or if the other player gets the next move, then it's the first digit of the other player's number.\n\n   Actually, the entire assignment is independent of the interleaving in terms of the positions in the two numbers: the k-th digit assigned to a player will be the k-th digit (from left) of that player's number, and its place value is 10^(n-1-k) for that player's number.\n\n   But note: the entire sequence of digits is fixed. The total prize is:\n\n        Sum_{k=0}^{2n-1} (digit_k) * (10^{n - (position_in_player)})   [but note: the position_in_player is determined by how many times the player has been chosen so far]\n\n   However, we can also note: the total prize is independent of the interleaving? Actually, no. Because the same digit in A might be in a higher or lower place value depending on when it is assigned to a player.\n\n   Consider: \n        A = \"1234\", n=2.\n\n        Assignment HHMM: \n            H gets first two: so the first digit '1' is in the tens place (10^1) and the second digit '2' is in the ones place (10^0) of S1.\n            M gets last two: so the third digit '3' is in the tens place (10^1) and the fourth digit '4' is in the ones place (10^0) of S2.\n\n        Then the total is: 1*10 + 2*1 + 3*10 + 4*1 = 10+2+30+4 = 46.\n\n        Assignment HMMH:\n            H gets first and last: \n                first digit '1': tens place (10^1) for S1.\n                fourth digit '4': ones place (10^0) for S1.\n            M gets second and third:\n                second digit '2': tens place (10^1) for S2.\n                third digit '3': ones place (10^0) for S2.\n            Total: 1*10 + 4*1 + 2*10 + 3*1 = 10+4+20+3 = 37.\n\n   So the total prize is the sum over all digits d_i (from A) of d_i * (10^{p_i}), where p_i is the exponent (n-1 - (the count of digits already assigned to the same player before this one)).\n\n   How to maximize? We have to assign the digits to the two players, and the exponent for a digit depends on the order of assignment to that particular player.\n\n   Since the digits are taken from A in order, we cannot change the order of the digits. We can only decide which player gets which.\n\n   Observation: We have two numbers, each of n digits. The entire set of digits is fixed. The total prize is:\n\n        S1 + S2 = (d0 * (10^{a0}) + d1 * (10^{a1}) + ... ) + (d0' * (10^{b0}) + d1' * (10^{b1}) + ... )\n\n   But note: the exponents for the same digit in A are determined by the time it is assigned to a player. Specifically, the first time a player gets a digit, it is multiplied by 10^(n-1), the next by 10^(n-2), etc.\n\n   However, the entire sequence is fixed, and we are allowed to interleave arbitrarily. The key is: we want to maximize the total.\n\n   Alternate approach: dynamic programming.\n\n   We are going to use DP over the positions (from 0 to 2n-1) and the state being the number of moves left for Homer (or equivalently Marge, since n is fixed) and the current total? But the total can be very large (since digits are up to 2n, and n up to 18, so 18-digit number, which is huge).\n\n   We need to avoid dealing with the actual numeric values because the numbers can be up to 10^18, and we have 2n=36 moves, so state space would be too big.\n\n   But note: the problem does not require us to compute the total, only to output the sequence of moves.\n\n   We can use DP that considers:\n\n        dp[i][j] = the maximum total prize we can achieve from the remaining i+j digits (we are processing the next i+j digits, meaning we have used the first i+j digits) with j being the number of moves Homer has made so far (and thus the number of moves Marge has made is (i+j)/2 - j? Actually, we are processing the string from left to right, and we are at the (i+j)-th digit? Not exactly.\n\n   Alternatively, we can use state (i, h) where i is the current index (from 0 to 2n) and h is the number of moves made by Homer so far (0 to n). Then the moves made by Marge is (i - h) / 2? Actually, we have processed i digits, and the number of moves by Homer is h, then the number of moves by Marge is (i - h) // 1? Wait, no: the total moves so far is i (each digit is a move). And the moves are split: h for Homer and (i - h) for Marge? Actually, no: the total moves so far is i, and each move is either Homer or Marge, so we have h + (i - h) = i. But we require that at the end, h = n and the total moves is 2n.\n\n   Actually, we can define:\n\n        dp[i][h] = the maximum total prize we can achieve from the remaining part (from index i to 2n-1) given that Homer has made h moves so far and Marge has made (i - h) moves so far (because the first i moves have been assigned: h to Homer and i-h to Marge). Then the next move (the i-th move) we can assign to either Homer (if h < n) or Marge (if (i-h) < n).\n\n   However, we cannot easily compute the total prize because it is the sum of two numbers, and the digits are fixed in order. But note: the total prize is:\n\n        = (value from the first i digits) + (value from the remaining 2n-i digits)\n\n   But the value from the first i digits depends on the assignment and the future assignments? Actually, no: the entire assignment is fixed. The value from the first i digits is:\n\n        For each digit in the first i digits, if it was assigned to Homer, then its contribution is digit * (10 raised to the power (n-1 - (position of that digit in Homer's sequence))) but the position in Homer's sequence is the count of H's so far (from the first i digits) for that digit? \n\n   Alternatively, we can precompute the entire value without knowing the future? Actually, we can express the total prize as:\n\n        total = 0\n        For each digit d at position k (0-indexed) in A:\n            if d is assigned to player X, then its exponent is (n-1 - (the number of moves X has had before this one))\n\n   The number of moves X has had before this one is the count of assignments to X in the first k digits.\n\n   This is complex.\n\n   Another idea: we can think greedily.\n\n   Consider: we have two numbers to form, and the total prize is the sum. The most significant digits (earlier in the string) are more important. However, note: the same digit can be in either number, and the position in the number (which is determined by the count of moves the player has taken so far) matters.\n\n   But note: the entire game uses all digits. The total prize is fixed? No, because the assignment to the two players changes the exponents.\n\n   Actually, we can write:\n\n        total = sum_{k=0}^{2n-1} d_k * (10^{exponent})\n\n   where exponent = (n-1 - (number of moves the player got so far at the time of assigning d_k))\n\n   The number of moves the player got so far at the time of assigning d_k is the count of the same player in the prefix (from 0 to k) of the assignment string.\n\n   How to maximize the total? We want to assign the larger digits to the player that has fewer moves so far (so that they get a higher exponent) and the smaller digits to the player that has more moves so far.\n\n   But wait: the exponent is decreasing as the player gets more moves. So we want to assign a large digit to a player that has not taken many moves (so that it gets a high exponent) and a small digit to a player that has already taken many moves (so that even if the digit is small, the exponent is low and we don't lose much).\n\n   However, the catch: the assignment is forced by the entire sequence. We cannot change the order of the digits.\n\n   We can use a greedy strategy that considers the entire sequence and the counts of moves. But note: we have to assign the digits in order.\n\n   Let me consider the following:\n\n        We have two counters for the number of moves each player has made. At each step, we have two choices (if both players still have moves left). The effect of choosing a player is:\n\n            If we choose player X, then the current digit is added to X's number, and the exponent for that digit in X's number is (n-1 - (current count of moves for X)).\n\n        But the total prize is the sum of the two numbers. We can also think: the entire assignment must use exactly n moves per player.\n\n        We can use recursion with memoization (DP) that goes through the 2n digits and at each step decides to assign to H or M (if moves remain). The state is (pos, h_count) where pos is the current digit index (0..2n-1) and h_count is the number of moves Homer has made so far (0 to n). Then the state space is (2n+1) * (n+1) = 37 * 19 = 703 states for n=18 (2n=36). But we have to store the maximum total prize for each state? However, the total prize is a huge number (up to 2 * (10^n) which is too big to store.\n\n   Alternatively, we can use a different state: we don't care about the exact total, but we care about the difference between the two numbers? Actually, we are maximizing the sum, but note: the two numbers are built independently. However, the assignment of a digit to H adds that digit with a certain exponent to the total, and similarly for M.\n\n   But note: the exponents depend on the entire history (how many moves each player has taken so far). Therefore, we must know the counts for both players.\n\n   Actually, we can use state (pos, h_count, m_count) but note: h_count + m_count = pos (because we have processed pos digits). So we can use (pos, h_count) and m_count = pos - h_count.\n\n   Then the transition: at state (pos, h_count), we can assign the current digit to Homer (if h_count < n) or to Marge (if (pos - h_count) < n). \n\n   The total prize is the sum of the two numbers. However, we cannot store the entire number because it is too big.\n\n   But note: the problem doesn't require the total prize, only the sequence. We can use minimax or greedy? Or we can use DFS with memoization and then backtracking the optimal path.\n\n   However, the total prize is a linear combination of the digits with exponents that depend on the order of moves. The exponents for a digit assigned to H at state (pos, h_count) is: (n-1 - (h_count))? Actually, no: because the next move for H is the (h_count)-th move (0-indexed) so the exponent for the digit assigned to H now is (n-1 - h_count). Similarly, for M it is (n-1 - (pos - h_count)).\n\n   But wait, the exponents for the entire number are fixed by the order of the moves. However, the rest of the digits (the future ones) will have exponents that are also determined by the counts at the time they are assigned.\n\n   We can compute the total prize for a complete assignment by:\n\n        total = 0\n        Let H_moves = list of digits assigned to H (in order)\n        Let M_moves = list of digits assigned to M (in order)\n\n        Then S1 = int(''.join(H_moves))   [if the number is empty, then 0]\n        S2 = int(''.join(M_moves))\n\n        But then we have to convert to integers, and n can be up to 18 -> 18-digit number, which is up to 10^18, which is too big for exact integer comparison? Actually, we can use Python integers, but the state space is 703, but we cannot store the total prize as a number for each state because the numbers are huge and we have 703 states, but we can do DP by storing the total prize as a string? No.\n\n   Alternative idea: we can use a DP that stores the difference between the two numbers? Actually, we are maximizing the sum, not the difference.\n\n   But note: the entire assignment is fixed. We can break down the total prize:\n\n        total = sum_{k=0}^{2n-1} d_k * (10^{exponent_k})\n\n   The exponent_k for a digit d_k (assigned to player X) is (n-1 - (count_X_before_k)), where count_X_before_k is the number of times X has been chosen from the first k digits.\n\n   We can precompute the exponents for each digit if we know the entire assignment. But we don't.\n\n   Another idea: we can use a DP that does not store the total prize, but stores the potential for the rest of the digits. However, the exponents are not independent of the assignment.\n\n   Insight: the total prize is independent of the interleaving in terms of which player gets which digit, but the exponent for a digit depends on the entire assignment (specifically, the count of the player's moves so far). \n\n   We can use a state (pos, h_count) and then the total prize so far is:\n\n        For the digits we've assigned, we know the exponents for the digits we've assigned. But wait, the exponents for the digits we haven't assigned are not fixed until we assign the players.\n\n   However, we can compute the total prize from a state by considering:\n\n        The remaining moves for Homer: n - h_count\n        The remaining moves for Marge: n - (pos - h_count)\n\n        For the remaining digits (from pos to 2n-1), we can assign them arbitrarily (but we are building a fixed sequence). The exponent for a digit at position k (when assigned to a player) is (n-1 - (the number of moves that player has taken from the first k digits)).\n\n        But note: the remaining digits are going to be assigned to the two players. The total prize from the remaining digits is:\n\n            For each remaining digit (at index k) and for each player, we know the minimum exponent that digit can get? Actually, no.\n\n   This seems too complicated.\n\n   Let me think differently: the total prize is the sum of two numbers. The two numbers are built from disjoint sets of digits from A, and the relative order of the digits in each number is the same as in A.\n\n   Then the total prize is:\n\n        S1 + S2 = (d0 * (10^(n-1) if d0 is in S1 else 10^(n-1) for S2) + ... \n\n   But note: the same digit cannot be split. And the exponents are fixed by the order of the moves.\n\n   There is a known fact: the total prize is the same as if we assign each digit d_i to one of the two numbers, and the exponent of d_i in the total is:\n\n        If d_i is assigned to a player, then its exponent is (n-1 - (the number of moves that player has taken so far (including this one)) at the time of assignment.\n\n   But we can postpone the decision: the entire assignment is a matching of the 2n digits to two sequences of length n. The total prize is:\n\n        = sum_{i=0}^{n-1} (digit_h_i * (10^(n-1-i))) + sum_{j=0}^{n-1} (digit_m_j * (10^(n-1-j)))\n\n   However, note: the digits_h_i are the digits assigned to Homer and they appear in the order of A, and similarly for Marge.\n\n   But wait, the two numbers are built by taking the digits in the order they appear in A, but only the ones assigned to that player.\n\n   Example: A = \"1234\", n=2, assignment \"HHMM\": \n        Homer: [1,2] -> number 12\n        Marge: [3,4] -> number 34\n\n   Assignment \"HMHM\": \n        Homer: [1,3] -> number 13\n        Marge: [2,4] -> number 24\n\n   We see that the digits assigned to a player are not contiguous in A, but they appear in the same relative order.\n\n   Now, the total prize is the sum of two numbers, each of n digits. The two numbers are built from two disjoint subsets of the digits, preserving the original order.\n\n   And we are free to choose any partition into two subsequences of length n.\n\n   Then the problem reduces to: split the sequence A into two subsequences (each of length n) such that the sum of the two numbers (each number being the integer formed by the subsequence) is maximized.\n\n   Now, note: the entire sequence is fixed. We can use dynamic programming that matches the two players and builds the two numbers.\n\n   State: (i, h_count, m_count) but as before, i = h_count + m_count. We can use (i, h_count) with i from 0 to 2n and h_count from 0 to n.\n\n   But we cannot store the entire number. However, we can store the two numbers? But they are too big.\n\n   Alternatively, we can use a different representation: we want to maximize the total prize, and we know the digits. We can use a state that stores the difference between the two numbers? But we are maximizing the sum, not the difference.\n\n   Let me reframe: the total prize is S1+S2.\n\n   We can also note: S1+S2 = (sum of all digits * 10^something) ? Not exactly.\n\n   Another idea: the entire set of digits is fixed. The total prize can be broken down by the position in the entire sequence and the player's count.\n\n   However, there is a known solution for similar problems (like Taro's vacation) which use state (i, j) where i is the number of moves of player1 and j is the number of moves of player2, and then we iterate over the string.\n\n   But our state is (i, j) where i+j = pos (the current position) and i<=n, j<=n.\n\n   The recurrence:\n\n        dp[i][j] = maximum total prize from the remaining digits (from pos = i+j to 2n-1) given that we have already used i+j digits, and Homer has made i moves and Marge j moves.\n\n        Then at the next digit (at index i+j), we can assign to Homer if i<n, or to Marge if j<n.\n\n        The contribution of this digit (let d = A[i+j]) is:\n\n            If assigned to Homer: d * (10^(n-1-i))   [because Homer's next move will be the i-th move (0-indexed), so the exponent is n-1-i]\n\n            If assigned to Marge: d * (10^(n-1-j))\n\n        But wait, what about the future digits? The future digits will be assigned to the players, and their exponents will depend on the future counts.\n\n        However, the entire total prize is the sum of the contributions from every digit. But the exponent for a digit assigned to a player is fixed by the time it is assigned (the count of moves the player has made at that time).\n\n        But note: the exponent for a digit is not fixed by the state (i,j) alone, because the state (i,j) only tells us the current counts, but the digit's position in the entire sequence is fixed (we are at the (i+j)-th digit). The future digits will be assigned to the players and their exponents will be determined by the counts at the time.\n\n        However, the past digits are fixed. We are at the (i+j)-th digit, and we are about to assign it. The total prize from the digits we've already assigned is fixed (because we know the assignment and hence the exponents for those digits). But the problem is we are trying to maximize the total prize, and we don't know the future.\n\n        We can design the DP to consider the entire assignment. The state (i, j) represents the number of moves made by each player so far, and the position is i+j. Then we can define:\n\n            dp[i][j] = maximum total prize we can achieve from the suffix starting at index (i+j) to the end, given that Homer has made i moves and Marge j moves.\n\n        Then the base case: when i+j == 2n, then dp[i][j] = 0.\n\n        Then, if we are at state (i,j), the next digit is at index k = i+j.\n\n        Option1: assign to Homer (if i < n)\n            Then the current digit d = A[k] is assigned to Homer, and its exponent is (n-1 - i) [because Homer's next move is the i-th move (0-indexed), so the place value is 10^(n-1-i)].\n            Then the future digits will be from k+1 to 2n-1, and the state becomes (i+1, j).\n            The total for this option is: d * (10**(n-1-i)) + dp[i+1][j]\n\n        Option2: assign to Marge (if j < n)\n            Then the current digit d = A[k] is assigned to Marge, and its exponent is (n-1 - j) [because Marge's next move is the j-th move (0-indexed)].\n            Then the total is: d * (10**(n-1-j)) + dp[i][j+1]\n\n        Then dp[i][j] = max(option1, option2) if both options are available, otherwise the available one.\n\n        However, the exponents: the digit d is a character, so we convert to int.\n\n        But the exponents: n-1-i and n-1-j: these are the exponents for the digit's place in the respective player's number. \n\n        But wait: in the entire game, the two numbers are built independently. The digit assigned to Homer now will be the i-th digit (0-indexed) of Homer's number, which is the (n-1-i) exponent (because the most significant digit is the 0-th move, which is exponent n-1).\n\n        This DP formulation seems correct.\n\n        The state space: i from 0 to n, j from 0 to n, and i+j <= 2n. Actually, i+j is the current position, so the state (i,j) must satisfy i+j <= 2n. The total states: (n+1) * (n+1) = (19*19)=361 for n=18.\n\n        However, we have to compute the exponent: 10**(n-1-i) and 10**(n-1-j). But n-1-i can be up to n-1 (if i=0) and down to -n (if i=2n-1). But i goes from 0 to n, so n-1-i goes from n-1 down to n-1-n = -1? Actually, when i=n, we don't use that option. But for i from 0 to n-1, n-1-i is from n-1 down to 0.\n\n        However, note: the exponent for the first move (i=0) is n-1, which is correct.\n\n        But what about the future digits? The future digits will be assigned to the players, and their exponents will be determined by the state (i+1, j) or (i, j+1). And the DP will account for the entire future.\n\n        But wait: the entire future has (2n - (i+j)) digits, and we are assigning them arbitrarily. The DP state (i,j) covers the entire future.\n\n        However, the issue: the exponent for a digit is defined by the count at the time of assignment. The DP state (i,j) captures the counts so far, and then the next digit's exponent is determined by the current count (i or j) and then we update the state.\n\n        But the future digits' exponents are determined by the counts at the time they are assigned, which will be captured by the recursive states.\n\n        Therefore, we can compute dp[i][j] by:\n\n            Let k = i+j\n            If k >= 2n: return 0   [base case]\n\n            Otherwise, if i < n and j < n:\n                option1 = int(A[k]) * (10**(n-1-i)) + dp[i+1][j]\n                option2 = int(A[k]) * (10**(n-1-j)) + dp[i][j+1]\n                dp[i][j] = max(option1, option2)\n\n            If only i < n:\n                option1 = int(A[k]) * (10**(n-1-i)) + dp[i+1][j]\n                dp[i][j] = option1\n\n            If only j < n:\n                option2 = int(A[k]) * (10**(n-1-j)) + dp[i][j+1]\n                dp[i][j] = option2\n\n        Then we want dp[0][0].\n\n        But the problem: we need to recover the sequence of moves. We can store the choice (whether we chose H or M) for each state.\n\n        Alternatively, we can store dp[i][j] and then backtrack the decisions.\n\n        Steps:\n\n            Let dp[i][j] = maximum total prize from state (i,j) to the end.\n\n            Let move[i][j] = either 'H' or 'M' for the choice made at state (i,j) (the next move).\n\n            Then:\n\n                if i < n and j < n:\n                    option1 = int(A[i+j]) * (10**(n-1-i)) + dp[i+1][j]\n                    option2 = int(A[i+j]) * (10**(n-1-j)) + dp[i][j+1]\n                    if option1 > option2:\n                        move[i][j] = 'H'\n                        dp[i][j] = option1\n                    else:\n                        move[i][j] = 'M'\n                        dp[i][j] = option2\n\n                else if i < n:\n                    move[i][j] = 'H'\n                    dp[i][j] = int(A[i+j]) * (10**(n-1-i)) + dp[i+1][j]\n\n                else if j < n:\n                    move[i][j] = 'M'\n                    dp[i][j] = int(A[i+j]) * (10**(n-1-j)) + dp[i][j+1]\n\n            Then, to recover the sequence, we start at (0,0) and follow the move pointers until we reach (n,n).\n\n        However, the state (i,j) must be stored for i in [0..n] and j in [0..n] and i+j from 0 to 2n.\n\n        But note: the exponentiation: 10**(n-1-i) might be expensive if we do it repeatedly, but n is at most 18, and we have at most 361 states. But we have to compute the exponent for each state, and the exponent is an integer. The maximum exponent is 10^(n-1) which is 10^17, which is a 18-digit number, but Python can handle it.\n\n        However, the numbers themselves (dp[i][j]) are very large (up to 2",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns selecting digits from a given number A. The goal is to split the digits of A into two subsequences (each of length n) such that the sum of the two numbers formed by these subsequences is maximized. The challenge lies in determining the optimal sequence of moves where each player selects exactly n digits.\n\n### Approach\n1. **Dynamic Programming (DP) Setup**: We use a DP table `dp[i][j]` where `i` and `j` represent the number of moves made by Homer and Marge, respectively. The value `dp[i][j]` stores the maximum total prize achievable from the remaining digits starting at position `i + j` (0-based index) in the string A.\n2. **State Transition**: For each state `(i, j)`, the next digit can be assigned to either Homer or Marge, provided they haven't exceeded their move limit. The contribution of the current digit depends on which player takes it and their current move count, as the digit's place value in their number is determined by `10^(n-1 - moves_taken)`.\n3. **Backtracking**: After filling the DP table, we backtrack from the state `(n, n)` to `(0, 0)` to construct the sequence of moves (either 'H' or 'M') that achieves the maximum total prize. The choice at each step is based on which option (assigning the current digit to Homer or Marge) yields a higher total prize according to the DP table.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data: \n        return\n    n_line = data[0].strip()\n    n_val = int(n_line)\n    A_str = data[1].strip()\n    total_digits = 2 * n_val\n\n    dp_table = {}\n    move_table = {}\n\n    def get_dp(i, j):\n        key = (i, j)\n        if key in dp_table:\n            return dp_table[key]\n        k = i + j\n        if k >= total_digits:\n            dp_table[key] = 0\n            return 0\n        res = None\n        if i < n_val and j < n_val:\n            d_char = A_str[k]\n            d_int = int(d_char)\n            exp1 = 10**(n_val - 1 - i)\n            val1 = d_int * exp1 + get_dp(i+1, j)\n            val2 = d_int * (10**(n_val - 1 - j)) + get_dp(i, j+1)\n            if val1 > val2:\n                dp_table[key] = val1\n                move_table[key] = 'H'\n            else:\n                dp_table[key] = val2\n                move_table[key] = 'M'\n            return dp_table[key]\n        elif i < n_val:\n            d_char = A_str[k]\n            d_int = int(d_char)\n            exp1 = 10**(n_val - 1 - i)\n            val1 = d_int * exp1 + get_dp(i+1, j)\n            dp_table[key] = val1\n            move_table[key] = 'H'\n            return val1\n        elif j < n_val:\n            d_char = A_str[k]\n            d_int = int(d_char)\n            exp1 = 10**(n_val - 1 - j)\n            val1 = d_int * exp1 + get_dp(i, j+1)\n            dp_table[key] = val1\n            move_table[key] = 'M'\n            return val1\n\n    get_dp(0, 0)\n\n    seq = []\n    i, j = n_val, n_val\n    while i > 0 or j > 0:\n        prev_i = i\n        prev_j = j\n        i -= 1\n        j -= 1\n        key = (prev_i, prev_j)\n        move_char = move_table[key]\n        seq.append(move_char)\n\n    seq.reverse()\n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **DP Table Initialization**: The `dp_table` stores the maximum total prize from each state `(i, j)`, and `move_table` records the optimal move ('H' or 'M') from each state.\n3. **Recursive DP Function**: The function `get_dp(i, j)` computes the maximum prize from the current state by considering both possible moves (assigning the next digit to Homer or Marge) and recursively solving the resulting subproblem.\n4. **Backtracking**: After computing the DP table, the solution backtracks from the state `(n, n)` to `(0, 0)` to construct the sequence of moves. Each step appends 'H' or 'M' based on the optimal move recorded in `move_table`.\n5. **Output**: The constructed sequence is reversed to present it in the correct order and printed.\n\nThis approach efficiently explores all possible move sequences using dynamic programming and backtracking to find the optimal solution, ensuring both players make exactly `n` moves while maximizing their combined prize.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data: \n        return\n    n_line = data[0].strip()\n    n_val = int(n_line)\n    A_str = data[1].strip()\n    total_digits = 2 * n_val\n\n    dp_table = {}\n    move_table = {}\n\n    def get_dp(i, j):\n        key = (i, j)\n        if key in dp_table:\n            return dp_table[key]\n        k = i + j\n        if k >= total_digits:\n            dp_table[key] = 0\n            return 0\n        res = None\n        if i < n_val and j < n_val:\n            d_char = A_str[k]\n            d_int = int(d_char)\n            exp1 = 10**(n_val - 1 - i)\n            val1 = d_int * exp1 + get_dp(i+1, j)\n            val2 = d_int * (10**(n_val - 1 - j)) + get_dp(i, j+1)\n            if val1 > val2:\n                dp_table[key] = val1\n                move_table[key] = 'H'\n            else:\n                dp_table[key] = val2\n                move_table[key] = 'M'\n            return dp_table[key]\n        elif i < n_val:\n            d_char = A_str[k]\n            d_int = int(d_char)\n            exp1 = 10**(n_val - 1 - i)\n            val1 = d_int * exp1 + get_dp(i+1, j)\n            dp_table[key] = val1\n            move_table[key] = 'H'\n            return val1\n        elif j < n_val:\n            d_char = A_str[k]\n            d_int = int(d_char)\n            exp1 = 10**(n_val - 1 - j)\n            val1 = d_int * exp1 + get_dp(i, j+1)\n            dp_table[key] = val1\n            move_table[key] = 'M'\n            return val1\n\n    get_dp(0, 0)\n\n    seq = []\n    i, j = n_val, n_val\n    while i > 0 or j > 0:\n        prev_i = i\n        prev_j = j\n        i -= 1\n        j -= 1\n        key = (prev_i, prev_j)\n        move_char = move_table[key]\n        seq.append(move_char)\n\n    seq.reverse()\n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 419,
        "completion_token_count": 1136,
        "thoughts_token_count": 8191
    }
}