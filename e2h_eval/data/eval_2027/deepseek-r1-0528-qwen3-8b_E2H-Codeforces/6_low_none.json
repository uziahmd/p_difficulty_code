{
    "start": 1758088065.6509645,
    "end": 1758089056.1958632,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:04 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (l, r, cost)\n We need two vouchers i and j such that:\n   (1) They don't intersect: either r_i < l_j or r_j < l_i.\n   (2) The sum of their durations is exactly x: (r_i - l_i + 1) + (r_j - l_j + 1) = x.\n\n Let d_i = r_i - l_i + 1 (duration of voucher i)\n\n Then we require d_i + d_j = x.\n\n We want to minimize cost_i + cost_j.\n\n Approach:\n\n Since the total duration is fixed (x), for each voucher i with duration d, we need a voucher j with duration x-d.\n\n However, we have two conditions for non-overlapping. The condition is: \n   Condition 1: r_i < l_j   OR   Condition 2: r_j < l_i.\n\n Note: Without loss of generality, we can consider the two cases independently.\n\n But note: the condition \"at least one\" is equivalent to saying that the two intervals do not overlap.\n\n We can break down the problem by considering the two cases separately? Actually, the two cases are symmetric.\n\n Alternatively, we can consider ordering the vouchers by their departure days (or arrival days) and then use data structures to query for vouchers of a specific duration.\n\n Steps:\n\n 1. Precompute the duration for each voucher: d = r-l+1.\n\n 2. We are going to group vouchers by duration. For each distinct duration d, we want to store the vouchers (or at least the minimal cost for a given set of intervals that don't conflict) but note: even if two vouchers have the same duration, they might have different time intervals and hence may conflict with each other.\n\n However, note: we are allowed to choose two vouchers arbitrarily as long as they don't intersect and their durations add up to x.\n\n How to handle the non-overlapping condition?\n\n Idea: For each voucher i, we need to find a voucher j such that:\n   (a) d_j = x - d_i, and\n   (b) either (r_i < l_j) or (r_j < l_i)\n\n But note: the condition (b) is about the entire intervals. We cannot simply ignore the time intervals because two vouchers with the same duration might have different time spans.\n\n Alternative approach:\n\n Let's group vouchers by duration. Then for each duration d, we have a list of vouchers (l, r, cost). \n\n However, we cannot simply take the minimum cost for each duration because the same duration might have multiple non-overlapping pairs and also the non-overlapping condition depends on the intervals.\n\n Instead, we can try:\n\n   For each duration d, we store all the vouchers (l, r, cost) and then we want to quickly query for a voucher j in the group [x-d] that does not overlap with a given voucher i.\n\n But note: the condition is either r_i < l_j OR r_j < l_i.\n\n This is equivalent to: the two intervals [l_i, r_i] and [l_j, r_j] are disjoint.\n\n We can split the problem into two parts:\n\n   Part 1: Consider pairs (i, j) such that the first voucher ends before the second starts (r_i < l_j). This corresponds to the first condition.\n\n   Part 2: Consider pairs (i, j) such that the second voucher ends before the first starts (r_j < l_i). This is symmetric to Part 1.\n\n So we can do:\n\n   For each voucher i, we want to consider two sets of vouchers for j:\n        Set A: vouchers j with duration = x - d_i and j has r_j >= r_i+1 (so that they don't overlap by the first condition) but actually the condition is r_i < l_j, so we require l_j > r_i.\n\n        Set B: vouchers j with duration = x - d_i and j has l_j <= r_i, but then we require r_j < l_i (second condition).\n\n However, note: the condition is OR, so we can consider both possibilities.\n\n But note: the two conditions are mutually exclusive? Actually, no: if one voucher is entirely contained in the gap between the two conditions? Actually, the conditions are:\n        Condition 1: r_i < l_j   -> then the first voucher ends before the second starts.\n        Condition 2: r_j < l_i   -> then the second voucher ends before the first starts.\n\n They are not mutually exclusive? Actually, if one condition holds, the other doesn't necessarily hold. But note: the two conditions together would imply that the two intervals are separated by at least one day? Actually, no: they are disjoint by either condition.\n\n However, we can also consider: the two intervals are disjoint if and only if one ends before the other starts. So the",
    "response": "\nTo solve this problem, we need to find two non-overlapping travel vouchers such that the sum of their durations equals exactly `x` and their total cost is minimized. The solution involves efficiently searching through the list of vouchers to identify pairs that meet these criteria.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. This allows us to quickly access all vouchers of a specific duration when needed.\n2. **Sort Intervals by Departure Time**: For each duration group, we sort the vouchers by their departure day (`l`). This helps in efficiently finding non-overlapping vouchers using binary search.\n3. **Binary Search for Non-overlapping Vouchers**: For each voucher, we look for another voucher with a duration equal to `x - current_duration`. Using binary search, we find the earliest voucher that starts after the current voucher ends (to ensure non-overlapping) and the latest voucher that ends before the current voucher starts. The minimal cost from these candidates is recorded.\n4. **Track Minimum Cost**: We keep track of the minimum cost encountered during the search. If no valid pair is found, we return -1.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        \n    d_list = [r - l + 1 for (l, r, cost_val) in vouchers]\n    \n    groups = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        d = r - l + 1\n        groups[d].append((l, r, cost_val))\n        \n    for d in groups:\n        groups[d] = sorted(groups[d], key=lambda t: t[0])\n        \n    min_total_cost = float('inf')\n    \n    for (l, r, cost_val) in vouchers:\n        d1 = r - l + 1\n        d2 = x - d1\n        if d2 < 0 or d2 not in groups:\n            continue\n            \n        lst = groups[d2]\n        low_bound = r + 1\n        high_bound = l - 1\n        \n        cand1 = None\n        left = 0\n        right = len(lst) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            l2, r2, cost2 = lst[mid]\n            if l2 > r:\n                cand1 = (l2, r2, cost2)\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        if cand1:\n            total_cost = cost_val + cand1[2]\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                \n        cand2 = None\n        left = 0\n        right = len(lst) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            l2, r2, cost2 = lst[mid]\n            if r2 < l:\n                cand2 = (l2, r2, cost2)\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        if cand2:\n            total_cost = cost_val + cand2[2]\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of tuples, each representing a voucher's departure day, return day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration (calculated as `return_day - departure_day + 1`). Each group is then sorted by departure day to facilitate efficient searching.\n3. **Finding Valid Pairs**: For each voucher, the algorithm checks if there exists another voucher with a duration equal to `x - current_duration`. Using binary search, it finds the earliest voucher that starts after the current voucher ends and the latest voucher that ends before the current voucher starts. The minimal cost from these candidates is considered.\n4. **Output Result**: After processing all vouchers, the minimal total cost is printed. If no valid pair is found, -1 is printed.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n        \n    d_list = [r - l + 1 for (l, r, cost_val) in vouchers]\n    \n    groups = defaultdict(list)\n    for (l, r, cost_val) in vouchers:\n        d = r - l + 1\n        groups[d].append((l, r, cost_val))\n        \n    for d in groups:\n        groups[d] = sorted(groups[d], key=lambda t: t[0])\n        \n    min_total_cost = float('inf')\n    \n    for (l, r, cost_val) in vouchers:\n        d1 = r - l + 1\n        d2 = x - d1\n        if d2 < 0 or d2 not in groups:\n            continue\n            \n        lst = groups[d2]\n        low_bound = r + 1\n        high_bound = l - 1\n        \n        cand1 = None\n        left = 0\n        right = len(lst) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            l2, r2, cost2 = lst[mid]\n            if l2 > r:\n                cand1 = (l2, r2, cost2)\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        if cand1:\n            total_cost = cost_val + cand1[2]\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                \n        cand2 = None\n        left = 0\n        right = len(lst) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            l2, r2, cost2 = lst[mid]\n            if r2 < l:\n                cand2 = (l2, r2, cost2)\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        if cand2:\n            total_cost = cost_val + cand2[2]\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 726,
        "completion_token_count": 1021,
        "thoughts_token_count": 1023
    }
}