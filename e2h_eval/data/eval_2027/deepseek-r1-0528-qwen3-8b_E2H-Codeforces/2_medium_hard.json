{
    "start": 1758089213.1024597,
    "end": 1758091641.7804706,
    "start-formatted": "2025-09-17 15:06 KST",
    "end-formatted": "2025-09-17 15:47 KST",
    "gpu": 2,
    "pid": 2,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Valera and X\n\nValera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter \"X\". Valera's teacher thinks that the letters on the piece of paper form an \"X\", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.\n\n## Input\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\n## Output\nPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\n## Example\n### Input\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n### Output\n['NO', 'YES', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n We are given an odd integer n, then n lines of n letters.\n Conditions for \"X\":\n 1. On both diagonals, all the letters must be the same (the same letter for the entire diagonal).\n 2. All the other squares (not on the diagonals) must contain the same letter, and that letter is different from the one on the diagonals.\n\n However, note: the example input includes:\n   Example 1: \n        5\n        xooox\n        oxoxo\n        soxoo\n        oxoxo\n        xooox   -> Output 'NO'\n\n   Why? Because the center of the last row (third row) has an 's' which is not the same as the diagonal letter 'x'. \n   But wait: let's break down:\n\n   The diagonals: \n        Main diagonal: (0,0), (1,1), (2,2), (3,3), (4,4) -> 'x','o','s','o','x'\n        Anti-diagonal: (0,4), (1,3), (2,2), (3,1), (4,0) -> 'x','o','s','o','x'\n\n   Condition 1: For the main diagonal, we have two 'x' and three 'o'? Actually, no: the main diagonal is [x, o, s, o, x] -> not all same.\n\n   So the first condition fails. Therefore, the answer is NO.\n\n   Example 2:\n        3\n        wsw\n        sws\n        wsw\n\n   Diagonals:\n        Main: [w, s, w] -> all same? Actually, no: but wait, the main diagonal in a 3x3 is indices (0,0)=w, (1,1)=s, (2,2)=w -> not all same.\n\n   However, the example output is YES. Let me re-read the problem statement.\n\n   The problem says: \n      \"on both diagonals of the square paper all letters are the same\"\n\n   In example 2, the main diagonal has 'w','s','w' — not the same. Similarly, anti-diagonal: (0,2)=w, (1,1)=s, (2,0)=w — not the same.\n\n   But wait, the example input is:\n        3\n        wsw\n        sws\n        wsw\n\n   And the example output is 'YES'.\n\n   This suggests I might have misunderstood the problem.\n\n   Let me read again: \n      \"on both diagonals of the square paper all letters are the same\" — meaning that for the entire diagonal, every letter is the same.\n\n   But in example 2, the diagonals are not all the same. \n\n   However, looking at the example: \n        w s w\n        s s s\n        w s w\n\n   Actually, wait, the example input string is given as:\n        '3\\nwsw\\nsws\\nwsw'\n\n   So the grid is:\n        row0: 'w','s','w'\n        row1: 's','w','s'\n        row2: 'w','s','w'\n\n   But wait, the second row is given as \"sws\", meaning the middle is 'w'? Or wait, no: \n        Second row: index0: 's', index1: 'w', index2: 's'\n\n   Now, the main diagonal: (0,0)='w', (1,1)='w', (2,2)='w' -> same (all 'w')\n   The anti-diagonal: (0,2)='w', (1,1)='w', (2,0)='w' -> same (all 'w')\n\n   Then condition 1 holds.\n\n   Then condition 2: All other squares (non-diagonal) should be the same letter and different from the diagonal letter.\n\n   Non-diagonal elements in this 3x3:\n        (0,1): 's'\n        (1,0): 's'\n        (1,2): 's'\n        (2,1): 's'\n\n   So they are all 's', and 's' is different from 'w'. So condition holds.\n\n   But wait, in the example input provided was: \n        ['3\\nwsw\\nsws\\nwsw', ...]\n\n   So the example input is correct.\n\n   Now, why did my initial reading of the example 2 fail? Because I thought the second row was \"sws\", but then I misread the second row as having 'w' in the middle? \n   Actually, the second row is \"sws\": \n        row0: 'w','s','w'\n        row1: 's','w','s'\n        row2: 'w','s','w'\n\n   So the main diagonal is indeed (0,0): 'w', (1,1): 'w', (2,2): 'w' — same.\n\n   Therefore, the example 2 is correctly handled.\n\n   Now, example 3:\n        3\n        xpx\n        pxp\n        xpe\n\n   Diagonals:\n        Main: (0,0)='x', (1,1)='p', (2,2)='e' -> not same.\n        Anti: (0,2)='x', (1,1)='p', (2,0)='x' -> not same.\n\n   So condition 1 fails. Therefore, NO.\n\n   But wait, what if the diagonals are not the same letter? Then we output NO.\n\n   However, note: the problem says \"on both diagonals of the square paper all letters are the same\". So the entire main diagonal must be one letter, and the entire anti-diagonal must be one letter (which may be the same or different?).\n\n   But the problem also says: \"all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals\".\n\n   So the diagonals can have two different letters? \n\n   Let me read the problem again: \n        \"on both diagonals of the square paper all letters are the same\"\n\n   It doesn't say the two diagonals have to be the same letter. But then the example 2 had the same letter on both diagonals. \n\n   However, consider a case where the main diagonal is 'a' and the anti-diagonal is 'b'. Then the non-diagonal parts must be the same letter (say 'c') and different from both 'a' and 'b'.\n\n   Example: \n        n=3\n        aaa\n        aba\n        aaa\n\n   Here, the main diagonal is ['a','a','a'] -> same, anti-diagonal is ['a','a','a'] -> same. \n   But wait, the non-diagonal: \n        (0,1): 'a' — but wait, the problem says the non-diagonal must be the same letter and different from the diagonal ones. \n        In this example, the non-diagonal has an 'a' (from the first row: positions (0,1) is 'a') which is the same as the diagonal. That fails.\n\n   So the non-diagonal part must be a fixed letter that is not the letter of the main diagonal and not the letter of the anti-diagonal.\n\n   But note: the problem says \"different from the letters on the diagonals\". So if the two diagonals are different, then the non-diagonal letter must be different from both.\n\n   However, what if the two diagonals are the same? Then the non-diagonal must be different from that one letter.\n\n   So the conditions:\n\n   Let d1 = the letter on the main diagonal (must be same for every element on main diagonal)\n   Let d2 = the letter on the anti-diagonal (must be same for every element on anti-diagonal)\n\n   Then, for every cell (i, j) that is not on either diagonal, the letter must be the same (say, c) and c != d1 and c != d2.\n\n   But note: if d1 == d2, then we require that the non-diagonal letter is not equal to d1 (which is same as d2).\n\n   Steps:\n\n   1. Read n.\n   2. Read the grid (list of strings).\n\n   3. Check the main diagonal: \n        for i from 0 to n-1, check grid[i][i] is the same. Let that common letter be d1.\n\n   4. Check the anti-diagonal:\n        for i from 0 to n-1, check grid[i][n-1-i] is the same. Let that common letter be d2.\n\n   5. Check the non-diagonal cells (cells that are not on the main diagonal and not on the anti-diagonal):\n        Let c0 be the letter at the first non-diagonal cell (if exists). Then check that every non-diagonal cell is the same as c0.\n\n   6. Also, ensure that the non-diagonal letter is different from both d1 and d2.\n\n   However, note: a cell that is on both diagonals? Only the center cell (when n is odd) is on both diagonals. But we skip it because we are checking non-diagonal.\n\n   But note: the center cell is included in both diagonals. When we check the main diagonal, we use the center cell. Similarly for anti-diagonal. Then when we check non-diagonal, we skip the center cell.\n\n   Implementation:\n\n   We can do:\n\n   Step 3: \n        d1 = None\n        for i in range(n):\n            if grid[i][i] != grid[0][0]:\n                # But wait, if the first element is not the same as the rest? Then d1 is broken.\n                d1 = grid[i][i]   # Actually, we need to check all are same.\n\n        Alternatively, we can check:\n        for i in range(n):\n            if grid[i][i] != grid[0][0]:\n                print(\"NO\")\n                exit(0)\n\n        Similarly for anti-diagonal.\n\n   However, note: what if the main diagonal has two different letters? Then we break.\n\n   But we need to assign d1 and d2. Actually, we can set:\n\n        d1 = grid[0][0]\n        for i in range(1, n):\n            if grid[i][i] != d1:\n                print(\"NO\")\n                return\n\n        Similarly for anti-diagonal:\n\n        d2 = grid[0][n-1]\n        for i in range(1, n):\n            if grid[i][n-1-i] != d2:\n                print(\"NO\")\n                return\n\n   But wait, what if the main diagonal has a different pattern? For example, if the main diagonal is all 'x', then d1='x'. Then the anti-diagonal must be all the same, but that same letter can be different from 'x'. \n\n   Then we proceed to check the non-diagonal.\n\n   Step 5: Traverse through the grid and for each cell (i, j) that is not on the main diagonal and not on the anti-diagonal, check:\n\n        - They are the same letter (so we can take the first one and then compare with others)\n        - And that letter is not equal to d1 and not equal to d2.\n\n   However, note: a cell might be on the main diagonal OR anti-diagonal, but not both. The center cell is on both, but we skip it.\n\n   We can mark a cell (i,j) as being on diagonal if i==j or i+j==n-1 (since indices go from 0 to n-1, so i+j = n-1 is the anti-diagonal).\n\n   Then, for all (i,j) not satisfying either condition, we check the letter.\n\n   But note: the grid size is up to 300, so we can do a double loop (n^2 ~ 90000) which is acceptable.\n\n   Steps:\n\n   n = int(input().strip())\n   grid = []\n   for i in range(n):\n        grid.append(input().strip())\n\n   # Step 1: Check main diagonal\n   d1 = grid[0][0]\n   for i in range(n):\n        if grid[i][i] != d1:\n            print(\"NO\")\n            exit(0)\n\n   # Step 2: Check anti-diagonal\n   d2 = grid[0][n-1]\n   for i in range(n):\n        if grid[i][n-1-i] != d2:\n            print(\"NO\")\n            exit(0)\n\n   # Now, if we get here, the two diagonals are uniform. But note: what if the entire grid is the same letter? Then d1 and d2 are the same, and then the non-diagonal part would have to be that same letter? \n   # But condition 2 requires the non-diagonal part to be a different letter. So if the entire grid is the same, then the non-diagonal part is the same, so condition 2 fails.\n\n   # Step 3: Check the non-diagonal part.\n\n   # We'll set a variable for the non-diagonal letter, and we can also check if there is at least one non-diagonal cell.\n\n   # First, we need to know the non-diagonal letter. We can look at a cell that is not on any diagonal. For example, the top-left corner is (0,0) and is on the main diagonal. So let's take (0,1) if it exists.\n\n   # But note: if n>=3, then there are non-diagonal cells.\n\n   # We can iterate over every cell and if the cell is not on the main diagonal and not on the anti-diagonal, then record the letter.\n\n   non_diagonal_letter = None\n   valid_non_diagonal = True\n\n   for i in range(n):\n        for j in range(n):\n            # Skip if on main diagonal (i==j) or on anti-diagonal (i+j == n-1)\n            if i == j or i+j == n-1:\n                continue\n\n            if non_diagonal_letter is None:\n                non_diagonal_letter = grid[i][j]\n            else:\n                if grid[i][j] != non_diagonal_letter:\n                    valid_non_diagonal = False\n                    break\n\n        if not valid_non_diagonal:\n            break\n\n   If we didn't find any non-diagonal cell? Then n=1? But n>=3. So we will always have at least one non-diagonal cell.\n\n   Then, we must check that non_diagonal_letter is not equal to d1 and not equal to d2.\n\n   However, what if the non-diagonal part is empty? Then we cannot set non_diagonal_letter. But n>=3, so we have non-diagonal cells.\n\n   But wait: what if the grid is such that the entire grid is the same letter? Then the non-diagonal part is the same, but then condition 2 requires it to be different from d1 and d2. Since d1 and d2 are that same letter, condition 2 fails.\n\n   So after Step 3, we check:\n\n        if non_diagonal_letter == d1 or non_diagonal_letter == d2:\n            print(\"NO\")\n            exit(0)\n\n   But wait, we broke the loop in the above iteration if we found a different non-diagonal letter. However, we also need to check the entire non-diagonal part.\n\n   Alternatively, we can do:\n\n        non_diagonal_set = set()\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                non_diagonal_set.add(grid[i][j])\n\n        Then, if the set has more than one letter, then condition fails.\n\n        And then check that the unique non-diagonal letter is not d1 and not d2.\n\n   But we don't want to use set if we can avoid, because we can break early.\n\n   Alternatively, we can do:\n\n        non_diag_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if non_diag_char is None:\n                    non_diag_char = grid[i][j]\n                elif grid[i][j] != non_diag_char:\n                    print(\"NO\")\n                    exit(0)\n\n        Then, if non_diag_char is not None, check non_diag_char != d1 and non_diag_char != d2.\n\n   However, what if there are no non-diagonal cells? Actually, for n>=3, there are non-diagonal cells. For example, n=3: the center is excluded, but the four corners and the edges are non-diagonal? Actually, in 3x3, the non-diagonal cells are the ones that are not the two diagonals. The two diagonals cover 3 cells each, but the center is shared. So total non-diagonal cells = 9 - (3+3-1) = 9-5 = 4.\n\n   So we can safely assume non_diag_char is set.\n\n   But note: what if the entire grid is empty? No, because n>=3 and we read n lines.\n\n   However, we must consider: what if the two diagonals are the same? Then d1 = d2, and then the non-diagonal letter must be different from that.\n\n   Example: \n        n=3, grid:\n        a b c\n        d e f\n        g h i\n\n        Condition 1: main diagonal: a, e, i must be same -> say 'x'\n        Condition 2: anti-diagonal: c, e, g must be same -> say 'y' (which might be same as 'x' or not)\n\n        Then non-diagonal: b, d, f, h must be same and not equal to 'x' and not equal to 'y'.\n\n   So code:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Check main diagonal\n        d1 = grid[0][0]\n        for i in range(n):\n            if grid[i][i] != d1:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal\n        d2 = grid[0][n-1]\n        for i in range(n):\n            if grid[i][n-1-i] != d2:\n                print(\"NO\")\n                exit(0)\n\n        # Now, check non-diagonal part\n        # Find the first non-diagonal cell and then check all non-diagonal cells are the same and different from d1 and d2.\n        non_diag_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if non_diag_char is None:\n                    non_diag_char = grid[i][j]\n                    # We must ensure that we have at least one non-diagonal cell, so we break out of the inner loop? No, we just set it.\n                else:\n                    if grid[i][j] != non_diag_char:\n                        print(\"NO\")\n                        exit(0)\n\n        # Now, if we found at least one non-diagonal cell (which we did), then check that non_diag_char is not d1 and not d2.\n        if non_diag_char == d1 or non_diag_char == d2:\n            print(\"NO\")\n            exit(0)\n\n        # If everything passed, then:\n        print(\"YES\")\n\n   But wait, what if the two diagonals are the same? Then d1 == d2, and then we require non_diag_char != d1 (which implies != d2). So that's covered.\n\n   However, consider a case where the grid is:\n\n        n=3\n        aaa\n        aab\n        aaa\n\n   Main diagonal: a, a, a -> ok.\n   Anti-diagonal: a, a, a -> ok.\n   Then non-diagonal: \n        (0,1): 'a' -> non_diag_char = 'a'\n        Then we check (0,1) is 'a', then (1,0): 'a' -> matches, (1,2): 'b' -> does not match -> NO.\n\n   Correct, because the non-diagonal part must be the same.\n\n   Another example: \n        n=3\n        xxx\n        xyy\n        xxx\n\n   Main diagonal: x,x,x -> ok.\n   Anti-diagonal: x,y,x -> not all same -> NO.\n\n   But wait, our anti-diagonal check: \n        i=0: grid[0][2] = 'x' (should be d2, which is grid[0][2] initially, so d2='x')\n        i=1: grid[1][1] = 'y' -> fails.\n\n   So we output NO.\n\n   One more example: \n        n=3\n        aba\n        bcb\n        aba\n\n   Main diagonal: a, c, a -> not same -> NO.\n\n   But wait, the main diagonal: \n        (0,0)='a', (1,1)='c', (2,2)='a' -> not same -> NO.\n\n   However, the example input: \n        ['3\\nxpx\\npxp\\nxpe'] -> NO\n\n   Our code for that example:\n\n        n=3\n        grid[0] = \"xpx\"\n        grid[1] = \"pxp\"\n        grid[2] = \"xpe\"\n\n        Main diagonal: \n            grid[0][0] = 'x'\n            grid[1][1] = 'x' -> wait, no: grid[1][1] is the middle of the second row: \"pxp\" -> so grid[1][1] is 'x'? \n            Actually, wait: \n                row0: \"xpx\" -> index0: 'x', index1: 'p', index2: 'x'\n                row1: \"pxp\" -> index0: 'p', index1: 'x', index2: 'p'\n                row2: \"xpe\" -> index0: 'x', index1: 'p', index2: 'e'\n\n            Main diagonal: \n                (0,0): 'x'\n                (1,1): 'x'\n                (2,2): 'e' -> so d1 would be set to 'x' from (0,0), then (1,1) is 'x' -> okay, then (2,2) is 'e' -> fails.\n\n        So we output NO.\n\n   But wait, the example input is: \n        Input: ['3\\nxpx\\npxp\\nxpe']\n\n        Expected: 'NO'\n\n   So our code works.\n\n   However, note: in the example above, the anti-diagonal for the example input:\n\n        n=3\n        grid[0][2] = 'x'\n        grid[1][1] = 'x'\n        grid[2][0] = 'x'\n\n        So the anti-diagonal is all 'x'. But the main diagonal fails. So we break at main diagonal.\n\n   So the code is:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Check main diagonal\n        d1 = grid[0][0]\n        for i in range(n):\n            if grid[i][i] != d1:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal\n        d2 = grid[0][n-1]\n        for i in range(n):\n            if grid[i][n-1-i] != d2:\n                print(\"NO\")\n                exit(0)\n\n        # Check non-diagonal part\n        non_diag_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if non_diag_char is None:\n                    non_diag_char = grid[i][j]\n                else:\n                    if grid[i][j] != non_diag_char:\n                        print(\"NO\")\n                        exit(0)\n\n        # Now, check non_diag_char is not d1 and not d2.\n        if non_diag_char == d1 or non_diag_char == d2:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n   But wait, what if there are no non-diagonal cells? Then non_diag_char remains None. But n>=3, so there is at least one non-diagonal cell.\n\n   However, what if n==1? Then the problem says n>=3, so we are safe.\n\n   Let's test with the provided examples.\n\n   Example 1: \n        Input: \n            5\n            xooox\n            oxoxo\n            soxoo\n            oxoxo\n            xooox\n\n        Main diagonal: \n            row0: 'x'\n            row1: 'o' -> already breaks because d1='x' and next is 'o' -> NO.\n\n        So we output NO.\n\n   Example 2:\n        Input:\n            3\n            wsw\n            sws\n            wsw\n\n        Main diagonal: \n            row0: 'w'\n            row1: 'w' (because the second row is \"sws\", so grid[1][1] is 'w')\n            row2: 'w' (grid[2][2] is 'w') -> so d1='w'\n\n        Anti-diagonal:\n            Start with grid[0][2]='w'\n            row1: grid[1][1]='w'\n            row2: grid[2][0]='w' -> so d2='w'\n\n        Then non-diagonal: \n            (0,1): 's'\n            (0,2) is diagonal -> skip\n            (1,0): 's'\n            (1,2): 's'\n            (2,1): 's'\n\n        non_diag_char = 's'\n\n        Then check: 's' != 'w' and 's' != 'w' -> True, so YES.\n\n   Example 3: \n        Input: \n            3\n            xpx\n            pxp\n            xpe\n\n        Main diagonal: \n            row0: 'x'\n            row1: grid[1][1] -> the second row is \"pxp\", so the middle is 'x' -> okay.\n            row2: grid[2][2] -> 'e' -> not 'x' -> NO.\n\n   So the code outputs NO.\n\n   But wait, the example input was provided as:\n        ['3\\nxpx\\npxp\\nxpe']\n\n   And the expected output is 'NO', so that matches.\n\n   However, note: the example input in the problem statement is given as:\n\n        ['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n   And the expected outputs are: ['NO', 'YES', 'NO']\n\n   So our code produces that.\n\n   But wait, there's a catch: the example 2 has the same letter for both diagonals. What if the two diagonals have different letters?\n\n   Example: \n        n=3\n        aaa\n        aba\n        aaa\n\n   But wait, the main diagonal: a, b, a -> not same. So we break at main diagonal.\n\n   Example with different diagonals:\n\n        n=3\n        aba\n        bbb\n        acb\n\n   Main diagonal: a, b, b -> not same (first two: a and b are different) -> NO.\n\n   Another example:\n\n        n=3\n        aaa\n        abb\n        abb\n\n   Main diagonal: a, b, b -> not same -> NO.\n\n   Example with different diagonals that are uniform:\n\n        n=3\n        aaa\n        aba\n        aaa   -> main diagonal: a, a, a -> same (d1='a')\n        anti-diagonal: a (from [0][2]), then [1][1] is 'a', then [2][0] is 'a' -> same (d2='a')\n\n        Then non-diagonal: \n            (0,1): 'a' -> but wait, the non-diagonal must be different from d1 ('a') and d2 ('a'). \n            But (0,1) is 'a', which is same as d1 -> fails.\n\n        So output NO.\n\n   So the code is as below.\n\n   However, note: the anti-diagonal in the above example is checked by:\n        d2 = grid[0][n-1] = grid[0][2] = 'a'\n\n        Then we check:\n            i=0: grid[0][2]=='a' -> ok\n            i=1: grid[1][1]=='a'? Actually, the second row is \"aba\", so the second row is ['a','b','a'] -> grid[1][1] is 'b' -> so we break at anti-diagonal.\n\n   So the example I intended to have two different diagonals (both uniform) but then non-diagonal same and different from both is actually not possible because if the anti-diagonal is uniform and different from main, then we have:\n\n        n=3\n        a b c\n        d e f\n        g h i\n\n        Main diagonal: a,e,i -> uniform (say 'x')\n        Anti-diagonal: c,e,g -> uniform (say 'y') and y != x.\n\n        Then non-diagonal: b, d, f, h must be the same and not x and not y.\n\n        Example:\n\n        n=3\n        a b c\n        d e f\n        g h i\n\n        Set:\n            a=e=i='x'\n            c=e=g='y'\n\n        Then the grid:\n\n            row0: 'x','b','y'\n            row1: 'd','y','f'\n            row2: 'g','h','x'\n\n        But wait, the anti-diagonal: \n            row0: grid[0][2] = 'y'\n            row1: grid[1][1] = 'y'\n            row2: grid[2][0] = 'g' -> must be 'y'\n\n        So set g='y'. Then the grid becomes:\n\n            row0: 'x','b','y'\n            row1: 'd','y','f'\n            row2: 'y','h','x'\n\n        Now, non-diagonal: \n            (0,1): 'b'\n            (1,0): 'd'\n            (1,2): 'f'\n            (2,1): 'h'\n\n        These must be the same and not 'x' and not 'y'.\n\n        Example: set b=d=f=h='z'\n\n        Then the grid:\n\n            row0: \"x z y\"\n            row1: \"d y f\" -> \"z y z\"\n            row2: \"y h x\" -> \"y z x\"\n\n        Now, check main diagonal: \n            (0,0): 'x'\n            (1,1): 'y' -> wait, but we set the main diagonal to be 'x' and 'y'? \n\n        Correction: the main diagonal is (0,0), (1,1), (2,2). We set (0,0)='x', (1,1)='y', (2,2)='x'. But then the main diagonal is not uniform (has both 'x' and 'y').\n\n        So how do we have a main diagonal uniform and anti-diagonal uniform with two different letters?\n\n        We cannot, because the center cell (1,1) is on both diagonals. So the center cell must be the same for both diagonals. Therefore, d1 must equal d2.\n\n        This is crucial.\n\n        Therefore, the two diagonals must have the same letter at the center, and since the entire main diagonal is one letter and the entire anti-diagonal is one letter, the center cell being common forces d1 == d2.\n\n        So actually, the two diagonals must be the same letter.\n\n        Then we can simplify: the two diagonals must be the same letter, say d.\n\n        Then the non-diagonal part must be the same letter (say c) and c != d.\n\n        Therefore, the condition is:\n\n          1. All the main diagonal letters are the same (and call that letter d).\n          2. All the anti-diagonal letters are the same (and that letter must be d, because the center is common and the rest of the anti-diagonal must be d to match the center and the main diagonal condition? Not exactly: \n\n        Actually, the main diagonal is fixed to d, and the anti-diagonal must be the same d because the center is in both. Then the entire anti-diagonal must be d.\n\n        So the two diagonals must be the same letter.\n\n        Then we can change the code:\n\n          1. Check main diagonal: all same -> d1\n          2. Check anti-diagonal: all same -> d2\n          3. Check that d1 == d2, because the center cell is common and the diagonals must be the same letter? Actually, the center cell is used in both, so if the main diagonal is d1 and anti-diagonal is d2, then the center cell must be both d1 and d2. Therefore, d1 must equal d2.\n\n        But wait, the problem does not explicitly state that the two diagonals must be the same letter. However, from the center cell being common, we deduce that the two diagonals must have the same letter.\n\n        Therefore, we can modify the code:\n\n        After step 1 and 2, we check that d1 == d2.\n\n        Then the non-diagonal part must be the same and different from d1 (which is same as d2).\n\n        So:\n\n        n = int(input().strip())\n        grid = [input().strip() for _ in range(n)]\n\n        # Check main diagonal\n        d1 = grid[0][0]\n        for i in range(n):\n            if grid[i][i] != d1:\n                print(\"NO\")\n                exit(0)\n\n        # Check anti-diagonal\n        d2 = grid[0][n-1]\n        for i in range(n):\n            if grid[i][n-1-i] != d2:\n                print(\"NO\")\n                exit(0)\n\n        # Since the center cell is (n//2, n//2) and lies on both diagonals, then the center cell must be d1 and d2, so d1 must equal d2.\n        if d1 != d2:\n            print(\"NO\")\n            exit(0)\n\n        # Then check non-diagonal part: same letter and different from d1.\n\n        non_diag_char = None\n        for i in range(n):\n            for j in range(n):\n                if i == j or i+j == n-1:\n                    continue\n                if non_diag_char is None:\n                    non_diag_char = grid[i][j]\n                else:\n                    if grid[i][j] != non_diag_char:\n                        print(\"NO\")\n                        exit(0)\n\n        if non_diag_char == d1:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n   But wait, is this condition necessary? The problem says \"on both diagonals of the square paper all letters are the same\", but it doesn't say the two diagonals must be the same. However, the center cell being common forces them to be the same. \n\n   But what if the problem allows the two diagonals to be different? Then the above example with two different diagonals would be allowed, but then the center cell would be the same for both, so they are forced to be the same. \n\n   Therefore, the two diagonals must be the same letter.\n\n   However, the problem statement does not explicitly require the two diagonals to be the same. But note: the center cell is part of both diagonals. So the center cell must be the same for both diagonals. Then the entire anti-diagonal must be the same as the entire main diagonal? \n\n   Actually, no: the anti-diagonal must be the same (by condition 1), and the main diagonal must be the same (by condition 1). And the center cell is the same for both, so the entire anti-diagonal must be the same as the entire main diagonal.\n\n   Therefore, we can add the check d1==d2.\n\n   But note: what if the main diagonal is 'a' and the anti-diagonal is 'b'? Then the center cell is 'a' (from main) and also 'b' (from anti) -> contradiction. So the grid cannot exist.\n\n   So we must have d1 == d2.\n\n   Therefore, the above code is correct.\n\n   However, the problem statement does not explicitly say the two diagonals must be the same. But logically, they must be. \n\n   But wait, the example 2: \n        n=3\n        wsw\n        sws\n        wsw\n\n        Here, the main diagonal is 'w','w','w' and the anti-diagonal is 'w','w','w'. So d1==d2.\n\n   Example: \n        n=3\n        aaa\n        aba\n        aaa   -> main diagonal: a,a,a -> d1='a'; anti-diagonal: a (from [0][2]), then [1][1] is 'b' -> fails, so d2 is set to 'a' (from [0][2]) and then [1][1] is 'b' -> fails.\n\n   So the code above would work.\n\n   But note: the anti-diagonal is defined as the cells (i, n-1-i). In a 3x3, the anti-diagonal is (0,2), (1,1), (2,0). So the center is (1,1). Therefore, the center cell must be the same for both diagonals.\n\n   So we can rely on d1==d2.\n\n   However, the problem does not explicitly require the two diagonals to be the same. But the condition is that both diagonals are uniform. And the center cell",
    "response": "\nTo solve this problem, we need to determine if a given square grid forms the letter \"X\" based on specific conditions. The conditions are that all letters on both diagonals must be the same, and all other letters in the grid must be identical and different from the diagonal letters.\n\n### Approach\n1. **Check Main Diagonal**: Verify that all characters along the main diagonal (from top-left to bottom-right) are the same.\n2. **Check Anti-Diagonal**: Ensure all characters along the anti-diagonal (from top-right to bottom-left) are the same.\n3. **Check Center Cell**: The center cell of the grid (common to both diagonals) must be the same character for both diagonals.\n4. **Check Non-Diagonal Cells**: All cells not on either diagonal must be the same character and different from the diagonal characters.\n\n### Solution Code\n```python\nn = int(input().strip())\ngrid = [input().strip() for _ in range(n)]\n\n# Check main diagonal\nd1 = grid[0][0]\nfor i in range(n):\n    if grid[i][i] != d1:\n        print(\"NO\")\n        exit(0)\n\n# Check anti-diagonal\nd2 = grid[0][n-1]\nfor i in range(n):\n    if grid[i][n-1-i] != d2:\n        print(\"NO\")\n        exit(0)\n\nif d1 != d2:\n    print(\"NO\")\n    exit(0)\n\nnon_diag_char = None\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            continue\n        if non_diag_char is None:\n            non_diag_char = grid[i][j]\n        else:\n            if grid[i][j] != non_diag_char:\n                print(\"NO\")\n                exit(0)\n\nif non_diag_char == d1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n```\n\n### Explanation\n1. **Main Diagonal Check**: The code reads the grid and checks each element along the main diagonal (where row index equals column index). If any element differs from the first element of the diagonal, it immediately outputs \"NO\".\n2. **Anti-Diagonal Check**: Similarly, the code checks each element along the anti-diagonal (where row index plus column index equals `n-1`). If any element differs from the first element of this diagonal, it outputs \"NO\".\n3. **Center Cell Check**: The center cell must be the same for both diagonals. If the main diagonal's character (`d1`) does not match the anti-diagonal's character (`d2`), the output is \"NO\".\n4. **Non-Diagonal Cells Check**: The code then verifies that all non-diagonal cells contain the same character. If any non-diagonal cell differs from the first encountered non-diagonal cell, it outputs \"NO\". Finally, it ensures this character is different from the diagonal characters, printing \"YES\" if all conditions are met, otherwise \"NO\".\n\nThis approach efficiently checks all necessary conditions to determine if the grid forms an \"X\" by leveraging straightforward iteration and conditional checks.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input().strip())\ngrid = [input().strip() for _ in range(n)]\n\n# Check main diagonal\nd1 = grid[0][0]\nfor i in range(n):\n    if grid[i][i] != d1:\n        print(\"NO\")\n        exit(0)\n\n# Check anti-diagonal\nd2 = grid[0][n-1]\nfor i in range(n):\n    if grid[i][n-1-i] != d2:\n        print(\"NO\")\n        exit(0)\n\nif d1 != d2:\n    print(\"NO\")\n    exit(0)\n\nnon_diag_char = None\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            continue\n        if non_diag_char is None:\n            non_diag_char = grid[i][j]\n        else:\n            if grid[i][j] != non_diag_char:\n                print(\"NO\")\n                exit(0)\n\nif non_diag_char == d1:\n    print(\"NO\")\nelse:\n    print(\"YES\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 438,
        "completion_token_count": 660,
        "thoughts_token_count": 8191
    }
}