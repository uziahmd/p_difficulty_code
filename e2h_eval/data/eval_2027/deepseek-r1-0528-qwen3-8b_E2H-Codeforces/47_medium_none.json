{
    "start": 1758296972.1741092,
    "end": 1758300465.057466,
    "start-formatted": "2025-09-20 00:49 KST",
    "end-formatted": "2025-09-20 01:47 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We need to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. If multiple k give the same minimal LCM, choose the smallest k.\n\n Observation:\n Let d = (a+k) and e = (b+k). Then note that (a+k) - (b+k) = a-b is fixed. So we can write:\n   d = (b+k) + (a-b) = e + (a-b)\n\n Alternatively, let g = gcd(a+k, b+k). Then note that:\n   g divides (a+k) - (b+k) = a-b.\n\n Therefore, g must be a divisor of |a-b|.\n\n We can reparameterize: Let d = |a-b|. Then for any divisor g of d, we can set:\n   a+k ≡ 0 (mod g) and b+k ≡ 0 (mod g)  => k ≡ (-a) mod g and k ≡ (-b) mod g.\n\n But note: since g divides d (which is |a-b|), then if we set k to be the smallest non-negative solution to:\n   k ≡ (-a) mod g   (and also k ≡ (-b) mod g, but note that (-a) mod g and (-b) mod g must be congruent modulo g because g divides a-b, so this is consistent)\n\n However, note: if we set g as a divisor of d, then the condition for k is that k >= max(-a mod g? Actually, we need k such that (a+k) % g == 0 and (b+k) % g == 0.\n\n Actually, we can set:\n   k ≡ (-a) mod g   => k = t*g - a   for some integer t, but we require k>=0 and also k ≡ (-b) mod g, which is equivalent to t*g - a ≡ -b (mod g) => t*g ≡ (a-b) mod g, but note that a-b is divisible by g, so this holds.\n\n However, we can also think: \n   Let r = (-a) mod g, then k_min for this modulus is r (if r is negative, we add g until nonnegative). But note: we require k such that (a+k) % g ==0 and (b+k)%g==0.\n\n Alternatively, we can consider: \n   k = (ceil(a/g)*g - a)   [but wait, we want to satisfy both conditions, and note that if g divides (a-b) then the condition on a and b are linked]\n\n Actually, we can set k to be the smallest non-negative integer such that:\n   k ≡ (-a) mod g   and k ≡ (-b) mod g.\n\n Since g divides (a-b), we have (-a) mod g = (-b) mod g? Not exactly: because (a-b) is divisible by g, then (-a) mod g = (-b) mod g? \n   Indeed: (-a) - (-b) = -(a-b) is divisible by g, so yes, they are congruent.\n\n So we only need one condition: k ≡ (-a) mod g, and we take the smallest nonnegative k for that modulus, i.e., k0 = (-a) mod g, but note that in Python the modulus is nonnegative, but we can compute:\n\n   k0 = (g - a % g) % g   [this gives the smallest nonnegative k such that (a+k) % g == 0]\n\n However, note: we want (a+k) divisible by g, so k0 = (g - (a % g)) % g.\n\n But note: if a % g == 0, then k0=0. Otherwise, k0 = g - (a % g).\n\n However, wait: we also have the condition that (b+k) must be divisible by g. Since g divides (a-b), then (a+k) divisible by g implies (b+k) divisible by g? \n   Yes: because (a+k) = (b+k) + (a-b), and if g divides (a-b) and (a+k), then it divides (b+k).\n\n So for each divisor g of |a-b|, we can set k0 = (g - a % g) % g. But note: k0 might not be the only candidate? Actually, the general solution is k = k0 + t*g for t>=0.\n\n However, we are looking for the minimal LCM over k. Also note: we don't know if the minimal LCM will necessarily occur at k being the residue for some divisor g.\n\n Alternate approach:\n\n Note: LCM(x,y) = x*y / GCD(x,y). Here, x = a+k, y = b+k.\n\n We know that GCD(x,y) = GCD(a+k, b+k) = GCD(a+k, |a-b|). And note that |a-b| is fixed.\n\n How does k affect the GCD? The GCD must divide |a-b|, so we can iterate over divisors of |a-b|.\n\n Let d = |a-b|. Then for each divisor g of d, we can set the GCD to be at least g (but actually, we are forcing the GCD to be a divisor of d, and we are considering all divisors).\n\n However, note: the GCD might be greater than g? Actually, no: because we are iterating over divisors of d, and the GCD must divide d. But note: the GCD of (a+k, b+k) is the GCD of (a+k, d). \n\n Now, for a fixed divisor g of d, we can set k such that g divides (a+k) (and hence (b+k)), and then the GCD will be at least g. However, the actual GCD might be a multiple of g? But note: we are iterating over divisors, and the set of divisors includes all factors. But actually, the GCD might be a divisor of d that is larger than g? \n\n However, note: we are iterating over every divisor. We are going to consider every divisor g of d, and then set k to be the smallest nonnegative integer such that g divides (a+k). Then the GCD will be a multiple of g, but we are not restricting it to be exactly g.\n\n But here's the catch: the minimal LCM might not occur at the maximal divisor. \n\n Actually, we can consider: the GCD of (a+k, b+k) must divide d. So the GCD is one of the divisors. Therefore, we can consider for each divisor g (including the entire d) and set k such that g divides (a+k). Then the actual GCD might be a multiple of g (but still divides d). However, note: if we set k so that g divides (a+k), then the GCD is at least g. But the LCM is (a+k)*(b+k)/gcd. \n\n Alternatively, we can consider that the minimal LCM might occur when the GCD is as large as possible (since LCM = product / GCD). However, note: when the GCD increases, the product (a+k)*(b+k) might change as well. \n\n Steps:\n\n 1. If a == b, then we are looking for k such that LCM(2a+k, 2a+k) = 2a+k. Then we want to minimize 2a+k, so k=0. But note: if a==b, then d=0. We have to handle separately.\n\n 2. Let d = abs(a-b). Then factorize d (but d can be up to 10^9, so we need an efficient factorization).\n\n 3. For each divisor g of d (including 1 and d), we can set k0 = (g - a % g) % g. Then, with this k0, the numbers (a+k0) and (b+k0) are divisible by g, so GCD(a+k0, b+k0) is at least g. But note: the GCD might be larger than g, say g' (which is a divisor of d and a multiple of g). However, we cannot assume that the minimal LCM occurs only for the maximum divisor.\n\n But wait: is it true that the GCD must be a divisor of d? Yes. So we can consider the divisors of d, and for each divisor g, we set k0 to be the smallest nonnegative k such that g divides (a+k). Then the GCD is at least g, but actually, the GCD is the GCD(a+k0, d). However, we don't know the exact GCD without computing it.\n\n However, note: the GCD must divide d, and we are iterating over all divisors. But if we consider a divisor g, then the minimal k for which the GCD is at least g is k0. But the actual GCD might be a divisor of d that is larger than g. \n\n But note: if we set k0, then the GCD might be a divisor of d that is a multiple of g? Actually, no: the GCD is a divisor of d and must divide (a+k0). However, we don't know the GCD without further computation.\n\n Alternative Insight:\n\n We know that the LCM is (a+k)*(b+k)/GCD(a+k, b+k). We can express the problem in terms of the GCD. Let g0 = GCD(a+k, b+k). Then g0 divides d. So we can iterate over the divisors of d and set k accordingly, then compute the LCM and then take the minimum.\n\n But note: the same k might be generated by different divisors? Also, there might be k that are not generated by divisors of d? Actually, no: because the GCD must divide d, so the condition is necessary.\n\n However, note: what if we don't fix the divisor? Consider: k can be any nonnegative integer. But the GCD must divide d, so we can restrict our search to k that are generated by divisors of d. But is that sufficient?\n\n Claim: The optimal k must be one of the k0 we get from the divisors.\n\n Why? Because the LCM is minimized when the product (a+k)*(b+k) is small and the GCD is large. However, note that the product is increasing with k (for k large enough) but the GCD can jump. But note: we are allowed to choose any k, but the condition is that the GCD divides d. Therefore, the k that makes the GCD a divisor g must be considered. But note: there might be a k that is not generated by a divisor of d? No, because the GCD must divide d, so the k that minimizes the LCM must have the property that the GCD is a divisor of d, and then k must be chosen so that the GCD is at least that divisor? Actually, no: the GCD is determined by k and d.\n\n But note: the GCD of (a+k, b+k) is the same as the GCD of (a+k, |a-b|). So we can write:\n   GCD(a+k, |a-b|) = g, where g divides |a-b|.\n\n Then, we require that g divides (a+k). So k must be such that (a+k) is divisible by g. Therefore, k must be congruent to (-a) mod g. So for each divisor g, we get a candidate k (the smallest nonnegative k satisfying that). \n\n However, note: k could be larger than k0 (the smallest nonnegative solution) by adding multiples of g. But we are interested in the minimal LCM. We should check for each divisor g, the minimal k (k0) and then also check the next few? Actually, note that the LCM is (a+k)*(b+k)/g0, and g0 might not be g but a divisor of d (and also divides (a+k)). However, we are iterating over all divisors, so we will consider the candidate k0 for each divisor. But note: the same k0 might be produced by multiple divisors? Then we would compute the LCM for that k0 only once.\n\n However, we must consider: the same k might be generated by multiple divisors. But we are only interested in the minimal k that minimizes the LCM. And we are generating k0 for each divisor. But note: there might be a k that is not the minimal for any divisor? \n\n Actually, no: because the GCD must divide d, so the k must satisfy that there exists a divisor g (of d) such that g divides (a+k). Therefore, k must be one of the residues modulo g (for some divisor g). But note: the set of k that are solutions for at least one divisor is the set of k that are solutions to k ≡ (-a) mod g for some divisor g. This set is infinite, but we are taking the smallest nonnegative solution for each divisor.\n\n But note: the minimal LCM might occur at a k that is not the minimal solution for its divisor? For example, if we set k = k0 + t*g, then the GCD might change. However, note that the GCD of (a+k, d) is the same as the GCD of (a+k0, d) because k0 is the smallest solution and adding multiples of g doesn't change the divisibility by g. Actually, the GCD might become larger than g if we choose a larger k? \n\n Example: \n   a=6, b=10, d=4. Divisors: 1,2,4.\n   For g=4: k0 = (4 - 6%4) %4 = (4-2)=2 -> k=2. Then numbers: 8 and 12, GCD(8,12)=4.\n   For g=2: k0 = (2 - 6%2)=0 -> k=0. Then numbers:6 and 10, GCD(6,10)=2.\n   For g=1: k0 = (1-6%1)=0 -> k=0.\n\n But note: k0=0 is the smallest, but at k=0 the LCM is LCM(6,10)=30, at k=2 the LCM is LCM(8,12)=24. So 24 is smaller.\n\n However, what if we take k=4 (which is k0 for g=4 plus one multiple of 4)? Then numbers:10 and 14, GCD(10,14)=2, LCM(10,14)=70. That is worse.\n\n What about k=1? Then numbers:7 and 11, GCD=1, LCM=77 -> worse.\n\n k=3: numbers:9 and 13, GCD=1, LCM=117 -> worse.\n\n So the candidate k values are only the ones we get from the divisors (and then we can consider k0 for each divisor, and maybe k0 + t*g for small t? But note: the problem requires the smallest k that minimizes the LCM. \n\n However, note: the LCM function in k is not necessarily unimodal. But note that the product (a+k)*(b+k) is increasing for k >= max(a,b)-min(a,b) (if a != b). But k is nonnegative and we start from 0.\n\n But note: k must be at least max(0, ...). The minimal k we consider is 0, and then we consider k0 for each divisor.\n\n However, there is a catch: the divisor g must be positive and we consider all divisors. But note: if d=0 (a==b) then we handle separately.\n\n Steps:\n\n  Case 1: a == b\n      Then we are minimizing LCM(2a+k, 2a+k) = 2a+k. So we choose k=0.\n\n  Case 2: a != b\n      Let d = abs(a-b)\n      Factorize d to get all divisors.\n\n      For each divisor g (positive) of d:\n          k0 = (g - a % g) % g   [This gives the smallest nonnegative k such that (a+k) is divisible by g]\n          But note: if a % g == 0, then k0=0. Otherwise, k0 = g - (a % g)\n\n      Then, we must consider that for a fixed divisor g, k can be k0, k0+g, k0+2g, ... but we don't know how many to consider.\n\n      However, note: the LCM for k = k0 + t*g (t>=0) is:\n          LCM(a+k, b+k) = (a+k)*(b+k) / GCD(a+k, b+k)\n\n      But note: GCD(a+k, b+k) = GCD(a+k, d). And since k0 was chosen so that g divides (a+k0), then for k = k0 + t*g, we have (a+k) divisible by g, and also by any common divisor of d and (a+k0). However, the GCD might be larger than g.\n\n      But note: the minimal LCM might occur for the first k (k0) or for a subsequent one? \n\n      However, observe: the product (a+k)*(b+k) is increasing as k increases (because a+k and b+k are both increasing). Therefore, if we have two k's: k1 and k2 (k1 < k2) then (a+k1)*(b+k1) <= (a+k2)*(b+k2). But the GCD is not necessarily increasing. \n\n      But note: the GCD can only decrease as k increases? Not necessarily: the GCD is GCD(a+k, d). As k increases, (a+k) mod d cycles. The GCD(a+k, d) is periodic with period d. \n\n      However, we are iterating over divisors, and we are only considering k that are k0 + t*g. But note: the same k might be represented by multiple divisors? \n\n      How to avoid redundant k? We can collect all candidate k from the divisors (each divisor gives one k0) and then also consider k0 + g, k0+2g, ... until we hit a k that is already covered by a divisor with a larger value? \n\n      But note: the problem says that k is nonnegative and we are to choose the smallest k that minimizes the LCM. \n\n      However, the number of divisors is O(sqrt(d)), and d can be up to 10^9, so the number of divisors is at most around 1344 (for highly composite numbers). Then for each divisor, we consider k0, k0+g, k0+2g, ... until we reach a certain bound? \n\n      But note: the minimal LCM might occur at a very large k? But observe: the LCM is (a+k)*(b+k)/GCD(a+k,b+k). Since GCD(a+k,b+k) divides d (which is fixed), then the LCM is at least (a+k)*(b+k)/d. \n\n      Also, note that the minimal k0 from the divisors is at most d (since k0 < g <= d). But wait, g is a divisor so g<=d, and k0 is less than g, so k0 <= d. However, we are also allowed to consider k0 + t*g. But note: the product (a+k)*(b+k) is increasing, so if we can find the minimal LCM for k in [0, d] (or even [0, d*d]) then we are safe? \n\n      However, note: the minimal LCM might occur at a k beyond d? \n\n      Let's think: the LCM is (a+k)*(b+k)/g0, and g0 divides d. The product (a+k)*(b+k) grows quadratically. Meanwhile, the GCD g0 might be as large as d, then the LCM is (a+k)*(b+k)/d. The minimal value of (a+k)*(b+k)/d is achieved when k is as small as possible (because the denominator d is fixed). But wait, the numerator is increasing. However, note: the GCD might change as k increases, and sometimes a larger GCD (which divides d) might reduce the LCM even if k is larger.\n\n      But note: the minimal LCM must occur for a k that is at most d-1? \n\n      Actually, we can use the following theorem:\n\n        The minimal LCM occurs for a k that is at most d-1.\n\n      Why? Because the equation k ≡ (-a) mod g has a solution k0 in [0, g-1]. Since g divides d, then g <= d, so k0 <= d-1.\n\n      Therefore, we only need to consider k in the range [0, d-1]. \n\n      So for each divisor g, we get k0 in [0, g-1] (so <= d-1). Then we don't need to consider k0 + t*g for t>=1 because k0 + g >= g >= 1 and we are only concerned with k in [0, d-1]. \n\n      However, wait: what if k0 + t*g is still less than d? Then we have to consider it? \n\n      But note: the theorem above says the minimal LCM occurs for a k in [0, d-1]. And we are generating k0 for each divisor, and k0 is the smallest nonnegative k for that divisor. Then the set of candidates is { k0 for each divisor g } and these k0 are all in [0, d-1]. \n\n      But note: the same k0 might be generated by multiple divisors. \n\n      Therefore, we can do:\n\n        Step 1: If a == b, print 0.\n\n        Step 2: Let d = abs(a-b). If d==0, then handled.\n\n        Step 3: Factorize d and get all divisors.\n\n        Step 4: For each divisor g (positive divisor) of d:\n                  k0 = (g - a % g) % g   [Note: if a % g ==0 then k0=0, else k0 = g - (a % g)]\n\n        Step 5: But note: we must also consider k0 from divisors, but wait: is k0 the only candidate for divisor g? According to the theorem, we only need k in [0, d-1], and k0 is the smallest nonnegative solution for g, so we have to consider k0.\n\n        However, note: the GCD of (a+k0, b+k0) might be larger than g. But that is okay because we are iterating over all divisors, and the same k0 might be generated by a divisor h (which is the GCD) and h>=g. But we are generating k0 for every divisor, so we will consider k0 anyway.\n\n        Step 6: Then we compute for each candidate k0 (without duplicates) the LCM of (a+k0) and (b+k0). Then choose the candidate k0 that minimizes the LCM, and if there are multiple, choose the smallest k0.\n\n      But wait: what if the minimal LCM is achieved at a k that is not generated by any divisor? \n\n      However, the GCD must divide d, so the condition for the GCD being h (a divisor) requires that k satisfies k ≡ (-a) mod h. Then the smallest nonnegative k for divisor h is k0_h. Therefore, the minimal LCM must occur at one of these k0_h.\n\n      However, note: the candidate k0_h might be the same for two different divisors h1 and h2. Then we compute the LCM for that k0_h once.\n\n      Example: a=6, b=10, d=4, divisors: [1,2,4]\n          g=1: k0_1 = (1 - 6%1) %1 -> but note: 6%1 is 0, so k0_1=0.\n          g=2: k0_2 = (2 - 6%2)= (2-0)=0? Actually, 6%2=0, so k0_2=0.\n          g=4: k0_4 = (4-6%4)= (4-2)=2.\n\n      Then candidates: k0=0 and k0=2.\n\n      Now, we compute:\n          k=0: LCM(6,10)=30\n          k=2: LCM(8,12)=24\n\n      So we choose k=2.\n\n      But note: what if we don't consider k=0 twice? We should avoid duplicate k0.\n\n      Therefore, we can:\n\n        candidates = {}\n        For each divisor g (positive) of d:\n            k0 = (g - a % g) % g\n            # But note: if g==0, skip, but d!=0 so g>=1.\n\n            Then, we can store candidate k0 and the LCM value.\n\n        Then, we also note: the candidate set is the set of distinct k0 from the divisors.\n\n        However, we must also consider k=0? Actually, k0=0 is generated by divisors that divide a (because then a%g==0). But note: if a divisor g does not divide a, then k0 might be positive.\n\n      But wait: what if d=0? We handled a==b.\n\n      However, there is a catch: the divisors of d include divisors that are greater than d? No, divisors are <= d.\n\n      But note: we must consider that k0 is defined modulo g, and g<=d, so k0 is in [0, g-1] which is <= d-1.\n\n      Implementation:\n\n        Step 1: Read a, b.\n\n        Step 2: If a == b: print(0); exit.\n\n        Step 3: Let d = abs(a-b)\n\n        Step 4: Factorize d to get all divisors.\n\n        Step 5: Create an empty set for candidate_k (to avoid duplicates) and a dictionary to store (k0, lcm_value) for each candidate k0.\n\n        Step 6: For each divisor g in divisors (including 1 and d):\n                k0 = (g - a % g) % g   [This is the smallest nonnegative k such that (a+k0) % g == 0]\n\n                Then, if k0 is already in the candidate_k, skip? Or we can compute the LCM for k0 and then update the best.\n\n                Actually, we don't know the LCM until we compute it, so we can do:\n\n                candidate_set.add(k0)\n\n                Then after collecting, we compute for each candidate k0 the LCM and compare.\n\n        But wait: we must consider that the same k0 might come from multiple divisors, so we can just collect distinct k0.\n\n        However, note: the LCM for a given k0 is independent of the divisor, so we can compute once per distinct k0.\n\n        Step 7: Then, we must also consider k=0? Actually, k0=0 is included because if g divides a, then k0=0. But what if no divisor divides a? Then k0=0 is not generated? \n\n        Example: a=5, b=10, d=5, divisors: 1,5.\n            g=1: k0_1 = (1 - 5%1) %1 -> 5%1 is 0, so k0=0.\n            g=5: k0_5 = (5-5%5)%5 = (5-0)%5=0.\n\n        So k0=0 is generated.\n\n        Another example: a=7, b=10, d=3, divisors:1,3.\n            g=1: k0_1 = (1-7%1)%1 -> 7%1=0 -> k0=0.\n            g=3: k0_3 = (3-7%3)%3 = (3-1)%3=2.\n\n        So k0=0 and 2.\n\n        But what if we don't generate k0=0? Then we miss k=0.\n\n        However, note: k0=0 is generated by divisor 1 (always, because 1 divides everything). So we are safe.\n\n        Step 8: But wait: what if d is very large (like 10^9) and the number of divisors is large? We need to factorize d (which is up to 10^9) and then generate divisors. This is acceptable because the worst-case for factorization is O(sqrt(d)), and the number of divisors is around 1344.\n\n        Step 9: However, note: the candidate k0 must be in [0, d-1]. We are generating k0 for each divisor, and then we take distinct k0. Then we compute the LCM for each distinct k0.\n\n        Step 10: But note: the problem says \"If there are multiple optimal integers k, choose the smallest one\". So if two different k0 give the same LCM, we choose the smallest k0.\n\n        Step 11: Compute the LCM for candidate k0:\n\n            Let x = a + k0, y = b + k0.\n            Then LCM(x,y) = x * y // GCD(x,y)\n\n        Step 12: Compare the LCM for each candidate k0 and choose the candidate with the smallest LCM, and if tie the smallest k0.\n\n        But note: we must consider k=0 is always included (from divisor 1). \n\n        However, wait: what if a and b are very large, and d is very large? Then the candidate set size is the number of distinct k0 from divisors. The maximum distinct k0 is the number of divisors (which is about 1344). Then we do 1344 LCM computations, which is acceptable.\n\n        But note: k0 is the smallest nonnegative solution for divisor g, and we are only generating distinct k0. However, the same k0 might be generated by multiple divisors, so we are not doing extra work.\n\n        However, there is an edge: what if d is 0? Then we handled by a==b.\n\n        But note: d = abs(a-b) and if a==b then we return 0.\n\n        One more example: Input \"5 10\" -> Output \"0\"\n\n        Example: \n            Input: \"5 10\"\n            a=5, b=10, d=5.\n\n            Divisors: [1,5]\n\n            For g=1: k0 = (1-5%1)%1 -> 5%1 is 0, so k0=0.\n            For g=5: k0 = (5-5%5)%5 = (5-0)%5=0.\n\n            Candidates: {0}\n\n            Then compute LCM(5+0, 10+0) = LCM(5,10)=10.\n\n            So output 0.\n\n        But the example input \"5 10\" is provided and expected output is \"0\", which matches.\n\n        Example: \"6 10\" -> d=4, divisors=[1,2,4]\n\n            g=1: k0=(1-6%1)%1 -> 6%1=0 -> k0=0.\n            g=2: k0=(2-6%2)%2 -> 6%2=0 -> k0=0.\n            g=4: k0=(4-6%4)%4 -> 6%4=2 -> k0=2.\n\n            Candidates: {0,2}\n\n            LCM(6,10)=30\n            LCM(8,12)=24\n\n            So answer is 2.\n\n        Example: \"21 31\" -> d=10, divisors=[1,2,5,10]\n\n            g=1: k0=0\n            g=2: k0=(2-21%2)= (2-1)=1\n            g=5: k0=(5-21%5)= (5-1)=4\n            g=10: k0=(10-21%10)= (10-1)=9\n\n            Candidates: {0,1,4,9}\n\n            Now, compute LCM for each:\n\n            k0=0: LCM(21,31)=21*31//1 = 651\n            k0=1: LCM(22,32)= (22*32)//2 = 352\n            k0=4: LCM(25,35)= (25*35)//5 = 175\n            k0=9: LCM(30,40)= (30*40)//10 = 120\n\n            The minimal LCM is 120, so k0=9.\n\n            Therefore, output 9.\n\n        However, the example input \"21 31\" is provided and expected output is \"9\", which matches.\n\n        But wait: why did k0=9 yield LCM=120? Because GCD(30,40)=10, and 30*40/10=120.\n\n        However, note: the example input \"21 31\" is provided and the expected output is \"9\", so that matches.\n\n        But wait: is k0=9 the minimal k that gives LCM=120? Yes, because 9 is the smallest k that gives LCM=120? Actually, we have to check: \n\n            k=0: LCM=651\n            k=1: LCM=352\n            k=4: LCM=175\n            k=9: LCM=120\n\n        And there are no other candidates (since we considered all divisors). \n\n        However, note: what if we consider k=10? Then numbers: 31 and 41, GCD=1, LCM=31*41=1271 -> worse.\n\n        k=2: numbers:23,33 -> GCD=1, LCM=759 -> worse than 120.\n        k=3: 24,34 -> GCD=2, LCM= (24*34)//2=408 -> worse than 120.\n        k=5: 26,36 -> GCD=2, LCM=(26*36)//2=468 -> worse.\n        k=6: 27,37 -> GCD=1, LCM=999 -> worse.\n        k=7: 28,38 -> GCD=2, LCM=(28*38)//2=532 -> worse.\n        k=8: 29,39 -> GCD=1, LCM=1131 -> worse.\n        k=9: 30,40 -> LCM=120.\n\n        So indeed k=9 is the best.\n\n        However, note: the candidate set we built is {0,1,4,9}. We didn't build k=2,3,...,8. But according to our reasoning, the minimal LCM must occur at one of the candidate k0 from the divisors. Why is that?\n\n        Because the GCD must divide d=10, so the GCD must be one of {1,2,5,10}. Then for the GCD to be 10, we require k0=9 (as computed). For the GCD to be 5, we require k0=4. For 2, k0=1. For 1, k0=0. \n\n        But note: the actual GCD for k=9 is 10, which is a divisor. For k=4, the GCD is 5 (divisor). For k=1, the GCD is 1 (but wait: let me check k=1: numbers 22 and 32, GCD(22,32)=2, not 1. So the GCD for k=1 is 2, which is a divisor of 10. Similarly, for k=0: GCD(21,31)=1.\n\n        But note: the condition for a divisor g is that we set k0 so that g divides (a+k0). Then the actual GCD might be a divisor of d that is greater than g. \n\n        However, we are iterating over all divisors. The candidate k0 for divisor g=1 is 0, and the GCD is 1 (which is divisor 1). For divisor g=2, we set k0=1, and the GCD is 2 (which is divisor 2). For divisor g=5, we set k0=4, and the GCD is 5 (divisor 5). For divisor g=10, we set k0=9, and the GCD is 10 (divisor 10). \n\n        But what about k=2? Then GCD(23,33)=1, so divisor 1. But we already considered k0=0 (divisor 1) and that gave a GCD=1.",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of the absolute difference \\( d = |a - b| \\). This insight allows us to limit our search for \\( k \\) to values derived from the divisors of \\( d \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( d \\), we compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is given by \\( k_0 = (g - (a \\% g)) \\% g \\). The LCM for each such \\( k_0 \\) is then computed, and the \\( k \\) with the smallest LCM is selected.\n\n3. **Algorithm Selection**:\n   - **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is trivially \\( k = 0 \\).\n   - **Divisor Enumeration**: For \\( a \\neq b \\), compute all divisors of \\( d = |a - b| \\).\n   - **Candidate Generation**: For each divisor \\( g \\), compute the corresponding \\( k_0 \\) and ensure it is within the range \\([0, d-1]\\).\n   - **LCM Calculation**: For each unique \\( k_0 \\), compute the LCM of \\( a + k_0 \\) and \\( b + k_0 \\).\n   - **Optimal Selection**: Among all candidate \\( k_0 \\) values, select the one with the smallest LCM. If multiple \\( k_0 \\) values yield the same minimal LCM, choose the smallest \\( k_0 \\).\n\n4. **Complexity Analysis**: The factorization of \\( d \\) (up to \\( 10^9 \\)) involves checking divisors up to \\( \\sqrt{d} \\), which is feasible since \\( \\sqrt{10^9} \\) is around \\( 3 \\times 10^4 \\). The number of divisors is typically small (e.g., hundreds at most), making the approach efficient.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    \n    candidate_k = set()\n    \n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n        candidate_k.add(k0)\n    \n    best_k = None\n    best_lcm = None\n    \n    for k_val in candidate_k:\n        x = a + k_val\n        y = b + k_val\n        g_val = gcd(x, y)\n        current_lcm = x * y // g_val\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k_val < best_k):\n            best_lcm = current_lcm\n            best_k = k_val\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Special Case Handling**: The code first checks if \\( a \\) and \\( b \\) are equal. If they are, it immediately returns \\( k = 0 \\) since the LCM of \\( a + 0 \\) and \\( b + 0 \\) is minimized.\n2. **Divisor Calculation**: The function `get_divisors` computes all divisors of \\( d = |a - b| \\) by checking each integer up to \\( \\sqrt{d} \\).\n3. **Candidate Generation**: For each divisor \\( g \\), the smallest non-negative \\( k \\) (denoted \\( k_0 \\)) that makes \\( g \\) divide both \\( a + k \\) and \\( b + k \\) is calculated. This \\( k_0 \\) is derived using modular arithmetic.\n4. **LCM Calculation**: For each unique \\( k_0 \\), the LCM of \\( a + k_0 \\) and \\( b + k_0 \\) is computed. The GCD is used to efficiently determine the LCM.\n5. **Optimal Selection**: The code tracks the \\( k_0 \\) with the smallest LCM. If multiple \\( k_0 \\) values yield the same LCM, the smallest \\( k_0 \\) is chosen. The result is printed as the optimal \\( k \\).\n\nThis approach efficiently narrows down the candidates for \\( k \\) by leveraging mathematical properties of divisors and GCD, ensuring optimal performance even for large values of \\( a \\) and \\( b \\).",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    \n    candidate_k = set()\n    \n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n        candidate_k.add(k0)\n    \n    best_k = None\n    best_lcm = None\n    \n    for k_val in candidate_k:\n        x = a + k_val\n        y = b + k_val\n        g_val = gcd(x, y)\n        current_lcm = x * y // g_val\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k_val < best_k):\n            best_lcm = current_lcm\n            best_k = k_val\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 388,
        "completion_token_count": 1161,
        "thoughts_token_count": 8191
    }
}