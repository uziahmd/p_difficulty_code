{
    "start": 1758093345.0043507,
    "end": 1758094961.5910583,
    "start-formatted": "2025-09-17 16:15 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n The total weight m is up to 300000.\n\n Since the weights are only 1, 2, or 3, we can separate the souvenirs into three groups:\n   group1: weight 1, cost c1\n   group2: weight 2, cost c2\n   group3: weight 3, cost c3\n\n Then, we want to choose a nonnegative number x (from group1), y (from group2), z (from group3) such that:\n   x + 2y + 3z <= m\n   and the total cost = x * (max cost for 1?) but note: we have multiple items in each group.\n\n However, note: we have multiple souvenirs in each group. We need to choose the best ones from each group.\n\n But also note: the problem is similar to unbounded knapsack but with fixed weights (only 1,2,3) and we are allowed to take at most as many as available.\n\n However, the catch: we have multiple items in each group. So we must sort each group by cost per weight? Actually, since the weight is fixed, we can consider:\n\n For each group (with fixed weight w), we want to take the most expensive items first.\n\n Steps:\n 1. Separate the items into three lists: \n      list1: all items with weight 1\n      list2: all items with weight 2\n      list3: all items with weight 3\n\n 2. Sort each list in descending order of cost.\n\n 3. Precompute prefix sums for each list so that we know the maximum cost we can get by taking k items from that list.\n\n 4. Then we have to consider: we can take up to a certain number of items from each group.\n\n Let:\n   Let a = number of items taken from group1 (each weight 1)\n   Let b = number of items taken from group2 (each weight 2)\n   Let c = number of items taken from group3 (each weight 3)\n\n Then condition: a + 2b + 3c <= m.\n\n But note: the number of items in each group is limited (by the count in the input). So we cannot take more than the available items.\n\n How to iterate?\n   Since the total weight m is up to 300000, and the items are separated by weight 1,2,3, we can try:\n\n   Let:\n     Let n1 = len(list1), n2 = len(list2), n3 = len(list3)\n\n   We can precompute:\n     prefix1[i] = sum of the top i items in list1 (i from 0 to n1)\n     prefix2[j] = sum of the top j items in list2 (j from 0 to n2)\n     prefix3[k] = sum of the top k items in list3 (k from 0 to n3)\n\n   Then we need to find nonnegative integers a, b, c (with a<=n1, b<=n2, c<=n3) such that:\n        a + 2b + 3c <= m\n        and total_cost = prefix1[a] + prefix2[b] + prefix3[c] is maximized.\n\n   Alternatively, we can fix the number of items from group3 (c) and then from the remaining weight (m - 3*c) we use group1 and group2.\n\n   But note: we can also fix group2? However, the total weight is linear and the coefficients are small (1,2,3). The total m is 300000, but if we try iterating over one variable, say c, then the remaining weight is m-3*c, which can be up to 300000, and then we need to consider combinations of a and b (a+2b<=remaining) which is too heavy.\n\n Alternate approach:\n\n   We can note that the problem is separable by the three groups, and the constraints are linear. Since the weights are small (only 1,2,3) and the total weight is large, we can use dynamic programming that goes over the groups and accumulates the best cost for a given total weight. However, the state would be the total weight (up to 300000) and we have three groups. The DP state dimension would be 300001, and we do three layers (for three groups). But note: the items are independent and we can take any number (like an unbounded knapsack for each group, but actually bounded by the available items). \n\n   However, we have three distinct groups.",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs are categorized by their weights, which can only be 1, 2, or 3. This allows us to separate the items into three distinct groups and then use dynamic programming to efficiently compute the maximum cost for any given weight.\n\n### Approach\n1. **Group Separation**: Separate all souvenirs into three groups based on their weights (1, 2, or 3). Each group will contain all items with the corresponding weight.\n2. **Sorting and Prefix Sums**: For each group, sort the items in descending order of their costs. Then, compute prefix sums for each group so that we can quickly access the maximum cost achievable by selecting the top `k` items from any group.\n3. **Dynamic Programming**: Use dynamic programming to compute the maximum cost achievable for every possible weight up to `m`. The DP array `dp[i]` will store the maximum cost achievable with a total weight of `i`. We iterate through each group and update the DP array by considering the inclusion of items from each group.\n4. **Result Extraction**: After processing all groups, the answer is found in `dp[m]`, which gives the maximum cost for a total weight not exceeding `m`.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    group1 = []\n    group2 = []\n    group3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        elif w == 3:\n            group3.append(c)\n            \n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for i in range(len(group1)):\n        prefix1.append(prefix1[-1] + group1[i])\n        \n    prefix2 = [0]\n    for i in range(len(group2)):\n        prefix2.append(prefix2[-1] + group2[i])\n        \n    prefix3 = [0]\n    for i in range(len(group3)):\n        prefix3.append(prefix3[-1] + group3[i])\n        \n    dp = [-10**18] * (m+1)\n    dp[0] = 0\n    \n    for c in range(len(group1)):\n        for w_val in range(m, c, -1):\n            if dp[w_val - c] != -10**18:\n                if dp[w_val] < dp[w_val - c] + (prefix1[c] if c < len(prefix1) else prefix1[-1]):\n                    dp[w_val] = dp[w_val - c] + (prefix1[c] if c < len(prefix1) else prefix1[-1])\n                    \n    for c in range(len(group2)):\n        for w_val in range(m, 2*c, -1):\n            if dp[w_val - 2*c] != -10**18:\n                if dp[w_val] < dp[w_val - 2*c] + (prefix2[c] if c < len(prefix2) else prefix2[-1]):\n                    dp[w_val] = dp[w_val - 2*c] + (prefix2[c] if c < len(prefix2) else prefix2[-1])\n                    \n    for c in range(len(group3)):\n        for w_val in range(m, 3*c, -1):\n            if dp[w_val - 3*c] != -10**18:\n                if dp[w_val] < dp[w_val - 3*c] + (prefix3[c] if c < len(prefix3) else prefix3[-1]):\n                    dp[w_val] = dp[w_val - 3*c] + (prefix3[c] if c < len(prefix3) else prefix3[-1])\n                    \n    print(max(dp))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum allowed weight `m`.\n2. **Group Separation**: Souvenirs are divided into three groups based on their weights (1, 2, or 3).\n3. **Sorting and Prefix Sums**: Each group is sorted in descending order of cost, and prefix sums are computed to quickly access cumulative costs for the top `k` items in each group.\n4. **Dynamic Programming Setup**: A DP array `dp` is initialized where `dp[i]` represents the maximum cost achievable with a total weight of `i`. The initial state `dp[0]` is set to 0 (no cost with no weight).\n5. **Processing Each Group**: For each group, the DP array is updated by considering the inclusion of items from that group. The update ensures that for each possible weight, the maximum cost is maintained.\n6. **Result Extraction**: The final result is the maximum value in the DP array, which corresponds to the highest cost achievable without exceeding the weight limit `m`.\n\nThis approach efficiently leverages dynamic programming and the constraints on item weights to solve the problem within feasible time complexity.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    group1 = []\n    group2 = []\n    group3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        elif w == 3:\n            group3.append(c)\n            \n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for i in range(len(group1)):\n        prefix1.append(prefix1[-1] + group1[i])\n        \n    prefix2 = [0]\n    for i in range(len(group2)):\n        prefix2.append(prefix2[-1] + group2[i])\n        \n    prefix3 = [0]\n    for i in range(len(group3)):\n        prefix3.append(prefix3[-1] + group3[i])\n        \n    dp = [-10**18] * (m+1)\n    dp[0] = 0\n    \n    for c in range(len(group1)):\n        for w_val in range(m, c, -1):\n            if dp[w_val - c] != -10**18:\n                if dp[w_val] < dp[w_val - c] + (prefix1[c] if c < len(prefix1) else prefix1[-1]):\n                    dp[w_val] = dp[w_val - c] + (prefix1[c] if c < len(prefix1) else prefix1[-1])\n                    \n    for c in range(len(group2)):\n        for w_val in range(m, 2*c, -1):\n            if dp[w_val - 2*c] != -10**18:\n                if dp[w_val] < dp[w_val - 2*c] + (prefix2[c] if c < len(prefix2) else prefix2[-1]):\n                    dp[w_val] = dp[w_val - 2*c] + (prefix2[c] if c < len(prefix2) else prefix2[-1])\n                    \n    for c in range(len(group3)):\n        for w_val in range(m, 3*c, -1):\n            if dp[w_val - 3*c] != -10**18:\n                if dp[w_val] < dp[w_val - 3*c] + (prefix3[c] if c < len(prefix3) else prefix3[-1]):\n                    dp[w_val] = dp[w_val - 3*c] + (prefix3[c] if c < len(prefix3) else prefix3[-1])\n                    \n    print(max(dp))\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1158,
        "thoughts_token_count": 1023
    }
}