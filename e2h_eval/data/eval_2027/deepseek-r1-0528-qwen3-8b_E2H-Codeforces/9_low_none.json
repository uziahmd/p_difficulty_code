{
    "start": 1758092349.0693936,
    "end": 1758094072.2028263,
    "start-formatted": "2025-09-17 15:59 KST",
    "end-formatted": "2025-09-17 16:27 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n The total weight m is up to 300000.\n\n Since the weights are only 1, 2, or 3, we can group the souvenirs by their weight.\n\n Let:\n   group1 = list of costs for souvenirs with weight 1\n   group2 = list of costs for souvenirs with weight 2\n   group3 = list of costs for souvenirs with weight 3\n\n Then, we need to choose a certain number (or fraction) of items from each group such that:\n   x1*1 + x2*2 + x3*3 <= m\n\n But note: we cannot take fractions. However, since the groups are independent and we can take at most as many as available in each group, \n but we are allowed to take any subset from each group, we can think of it as:\n\n   Let a = number of weight-1 items we take, b = number of weight-2 items, c = number of weight-3 items.\n\n   Then a in [0, count1], b in [0, count2], c in [0, count3] and a + 2b + 3c <= m.\n\n However, n can be up to 100000 and m up to 300000, so iterating over all a, b, c is too expensive.\n\n Alternative approach:\n\n Since the weights are small (only 1,2,3), we can use dynamic programming that iterates over the three groups and the possible total weight.\n\n But note: m can be up to 300000, and we have three groups. We can do:\n\n   dp[i][w] = maximum total cost we can achieve after considering the first i groups (i.e., the i-th group being the one with weight i) and having total weight w.\n\n However, we have only three groups. We can do:\n\n   dp[w] = maximum total cost for weight exactly w (or up to w) using the first two groups, then update with the third.\n\n But note: the state w can go up to 300000, and we have three groups. The total state space is 300000 * 3 which is acceptable? Actually, we have to consider that we have three groups and we might combine them.\n\n Alternatively, we can use:\n\n   Step 1: Precompute for each group the sorted list of costs and then for each group, we can precompute the maximum total cost for taking k items from that group.\n\n   But note: within a group, we want to take the top k items (since we want maximum cost). So for group1, we sort in descending order and then compute prefix sums.\n\n   Then, we can iterate over the number of items taken from group1 (a) and group2 (b) and then determine the maximum c (for group3) such that:\n        a + 2b + 3c <= m.\n\n   Then the total cost would be: prefix1[a] + prefix2[b] + prefix3[c]\n\n   But then we need to consider that the total weight constraint is linear and the groups are independent.\n\n   Steps:\n\n   1. Separate the souvenirs into three groups: w=1, w=2, w=3.\n   2. For each group, sort the costs in descending order and compute the prefix sum array (so that prefix[i] is the sum of the top i items).\n\n   3. Now, we are going to consider the combinations of a, b, c:\n\n        Let:\n          a in [0, len(group1)]\n          b in [0, len(group2)]\n          c in [0, len(group3)]\n\n        and a + 2*b + 3*c <= m.\n\n   4. How to iterate without O(n^3)? \n\n        The total weight m is up to 300000. The maximum a is up to 100000, maximum b up to 100000, maximum c up to 100000, but note that the total weight condition will break early.\n\n        However, we cannot iterate over all a, b, c because the ranges are too large.\n\n   Alternate approach: iterate over the first two groups and then use the third group?\n\n        Let F(w) = maximum cost we can get from the first two groups for total weight w (but note: we have two groups with weights 1 and 2). Then we can combine group1 and group2 by iterating over the number of items from group1 and then the number of items from group2, but then we have to account for the",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs have weights of either 1, 2, or 3 units, and each souvenir has a specific cost. \n\n### Approach\n1. **Grouping Souvenirs**: First, we group the souvenirs by their weights (1, 2, or 3). This helps in efficiently processing each group separately.\n2. **Sorting and Prefix Sums**: For each group, we sort the souvenirs in descending order of their costs. Then, we compute prefix sums for each group. The prefix sum array allows us to quickly access the maximum cost achievable by selecting the top `k` items from any group.\n3. **Dynamic Programming**: We use dynamic programming to determine the maximum cost achievable for each possible weight combination up to the given limit `m`. Specifically, we iterate over all possible combinations of items from the first two groups (weights 1 and 2) and store the maximum cost for each achievable weight. \n4. **Combining Results**: For each combination of items from the first two groups, we calculate the remaining weight capacity and use it to determine the maximum number of items from the third group (weight 3) that can be included without exceeding the total weight limit. The sum of the maximum costs from all three groups gives the solution.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m_val = int(data[1])\n    \n    group1 = []\n    group2 = []\n    group3 = []\n    \n    index = 2\n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        elif w == 3:\n            group3.append(c)\n            \n    if not group1:\n        group1 = []\n    if not group2:\n        group2 = []\n    if not group3:\n        group3 = []\n        \n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for i in range(len(group1)):\n        prefix1.append(prefix1[-1] + group1[i])\n        \n    prefix2 = [0]\n    for i in range(len(group2)):\n        prefix2.append(prefix2[-1] + group2[i])\n        \n    prefix3 = [0]\n    for i in range(len(group3)):\n        prefix3.append(prefix3[-1] + group3[i])\n        \n    max_w = m_val\n    dp = [-10**18] * (max_w + 1)\n    dp[0] = 0\n    \n    for i in range(1, len(prefix1)):\n        w_used = i\n        if w_used <= max_w:\n            for j in range(w_used, max_w + 1):\n                if dp[j - w_used] != -10**18:\n                    if dp[j] < dp[j - w_used] + prefix1[i]:\n                        dp[j] = dp[j - w_used] + prefix1[i]\n                        \n    for i in range(1, len(prefix2)):\n        w_used = 2 * i\n        if w_used > max_w:\n            break\n        for j in range(max_w, w_used - 1, -1):\n            if dp[j - w_used] != -10**18:\n                if dp[j] < dp[j - w_used] + prefix2[i]:\n                    dp[j] = dp[j - w_used] + prefix2[i]\n                    \n    ans = 0\n    for total_weight in range(m_val + 1):\n        if dp[total_weight] == -10**18:\n            continue\n        rem = m_val - total_weight\n        if rem < 0:\n            continue\n        c3_max = rem // 3\n        if c3_max >= len(prefix3):\n            c3_max = len(prefix3) - 1\n        if c3_max >= 0:\n            total_cost = dp[total_weight] + prefix3[c3_max]\n            if total_cost > ans:\n                ans = total_cost\n                \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum weight `m_val`.\n2. **Grouping**: Souvenirs are grouped based on their weights (1, 2, or 3) into three separate lists.\n3. **Sorting and Prefix Sums**: Each group is sorted in descending order of cost, and prefix sums are computed to facilitate quick calculation of the maximum cost for selecting top `k` items from any group.\n4. **Dynamic Programming Setup**: A DP array `dp` is initialized to store the maximum cost achievable for each possible weight up to `m_val`.\n5. **Processing Groups 1 and 2**: The DP array is updated by considering all possible selections of items from the first two groups (weights 1 and 2). For each item count in these groups, the maximum cost for each achievable weight is stored.\n6. **Combining with Group 3**: For each weight achievable with the first two groups, the remaining weight is used to determine the maximum number of items from the third group (weight 3) that can be included. The total cost is then calculated and the maximum value is tracked.\n7. **Output**: The maximum total cost found is printed as the result.\n\nThis approach efficiently handles the constraints by leveraging grouping, sorting, prefix sums, and dynamic programming to explore all feasible combinations without excessive computation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m_val = int(data[1])\n    \n    group1 = []\n    group2 = []\n    group3 = []\n    \n    index = 2\n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        elif w == 3:\n            group3.append(c)\n            \n    if not group1:\n        group1 = []\n    if not group2:\n        group2 = []\n    if not group3:\n        group3 = []\n        \n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for i in range(len(group1)):\n        prefix1.append(prefix1[-1] + group1[i])\n        \n    prefix2 = [0]\n    for i in range(len(group2)):\n        prefix2.append(prefix2[-1] + group2[i])\n        \n    prefix3 = [0]\n    for i in range(len(group3)):\n        prefix3.append(prefix3[-1] + group3[i])\n        \n    max_w = m_val\n    dp = [-10**18] * (max_w + 1)\n    dp[0] = 0\n    \n    for i in range(1, len(prefix1)):\n        w_used = i\n        if w_used <= max_w:\n            for j in range(w_used, max_w + 1):\n                if dp[j - w_used] != -10**18:\n                    if dp[j] < dp[j - w_used] + prefix1[i]:\n                        dp[j] = dp[j - w_used] + prefix1[i]\n                        \n    for i in range(1, len(prefix2)):\n        w_used = 2 * i\n        if w_used > max_w:\n            break\n        for j in range(max_w, w_used - 1, -1):\n            if dp[j - w_used] != -10**18:\n                if dp[j] < dp[j - w_used] + prefix2[i]:\n                    dp[j] = dp[j - w_used] + prefix2[i]\n                    \n    ans = 0\n    for total_weight in range(m_val + 1):\n        if dp[total_weight] == -10**18:\n            continue\n        rem = m_val - total_weight\n        if rem < 0:\n            continue\n        c3_max = rem // 3\n        if c3_max >= len(prefix3):\n            c3_max = len(prefix3) - 1\n        if c3_max >= 0:\n            total_cost = dp[total_weight] + prefix3[c3_max]\n            if total_cost > ans:\n                ans = total_cost\n                \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 468,
        "completion_token_count": 1249,
        "thoughts_token_count": 1023
    }
}