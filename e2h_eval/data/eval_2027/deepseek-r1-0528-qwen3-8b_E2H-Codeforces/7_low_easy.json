{
    "start": 1758089837.4000676,
    "end": 1758092195.4054718,
    "start-formatted": "2025-09-17 15:17 KST",
    "end-formatted": "2025-09-17 15:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\n We are given a number of test cases. For each test case, an integer `n` (from 1 to 10^18) is provided.\n\n We need to determine if there exists an integer `k > 1` such that a snowflake with `n` vertices can be constructed.\n\n According to the model:\n\n   - Initially, we have 1 vertex.\n   - Then, the initial vertex is connected to `k` new vertices (so now we have 1 + k vertices).\n   - Then, each vertex that has degree 1 (i.e., the leaves from the previous step) is connected to `k` new vertices, but note: this step must be done at least once.\n\n However, note that the process is built in layers. Let's break down the construction:\n\n   Step 0: 1 vertex (the center)\n   Step 1: add k vertices -> total = 1 + k\n   Step 2: from the k leaves (each of which now becomes a center for its own set of k new vertices), we add k*k = k^2 new vertices -> total = 1 + k + k^2\n\n But wait, the problem states: \"Each vertex that is connected to only one other vertex\" (i.e., the leaves) is connected by edges to k more new vertices. This step is done at least once.\n\n However, note: after step 1, we have k leaves. Then in step 2, each leaf adds k new vertices. But then the graph is built in a recursive way? Actually, the problem says \"This step should be done at least once\", meaning we do the expansion from leaves at least one time (so step 1 is the first expansion and step 2 is the second expansion). But note: the example smallest snowflake for k=4 is shown. The example doesn't show multiple layers, but the problem says \"at least once\", so we can have more than two layers.\n\n However, note: the construction rule says that we start with one vertex, then we do the expansion at least once (so minimum one expansion from the center). Then, the condition for further expansion is: each vertex with degree 1 (which are the leaves) gets expanded. So we can have multiple layers.\n\n But note: the expansion from a leaf does not connect to the center again. Each leaf (from the previous layer) independently expands.\n\n Therefore, the total number of vertices after `m` expansions (layers) is:\n\n   n = 1 + k + k^2 + ... + k^m   [for m>=1]\n\n However, wait: the problem says the first expansion (step 1) is done at least once. Then, the second expansion (step 2) is also done at least once? Actually, the problem says \"This step should be done at least once\", meaning the entire process (starting from the center and then expanding leaves) must be done at least once. But note: the example for k=4 is the minimal one, which has 1 + 4 + 4*3? Actually, the example drawing might have two layers? Or three?\n\n Let me clarify with the example: \n   In the minimal snowflake for k=4, the total vertices are 1 (center) + 4 (first layer) + 4*(4-1) ??? \n\n But wait, the rule says: each leaf (which has degree 1) is connected to k new vertices. However, when you add k new vertices from a leaf, you are effectively replacing that leaf's single edge with a new connection to k new ones? Actually, no: the leaf was already connected to its parent. Now, when you expand the leaf, you connect it to k new vertices. Then the leaf becomes a node of degree 1 + k (if we count the parent as one) but actually the parent is still connected to the leaf? \n\n Alternatively, the problem might be building a rooted tree where each node (except the center) has exactly k children? But note: the center has k children. Then each leaf (a node with no children) would be expanded to have k children. However, the center is not a leaf (because it has k children, so degree k). Then the first layer nodes (children of the center) are leaves (degree 1) until they are expanded.\n\n But then, when we expand a leaf, we are adding k children to that leaf. Then that leaf becomes a node of degree k+1 (one parent and k children). Then the next layer from that leaf are leaves (until they are expanded).\n\n However, the problem does not specify that we cannot expand the same node twice. But the process is defined as: we start with the center, then we do the expansion step (on the leaves) at least once. Then, we can continue? Actually, the problem says \"each vertex",
    "response": "\nTo solve this problem, we need to determine if a given number of vertices `n` can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in layers, starting from a central vertex and expanding outward in a manner similar to a geometric series. \n\n### Approach\n1. **Problem Analysis**: The snowflake graph starts with a single central vertex. In each subsequent layer, every leaf vertex (a vertex with only one connection) is expanded by adding `k` new vertices connected to it. This process must be performed at least once. The total number of vertices after `m` layers is given by the formula for the sum of a geometric series: \\(1 + k + k^2 + \\ldots + k^m\\).\n\n2. **Key Insight**: For a given `n`, we need to check if there exists an integer `k > 1` and an integer `m ≥ 1` such that \\(n = \\frac{k^{m+1} - 1}{k - 1}\\). This equation represents the sum of the geometric series up to the `m`-th term.\n\n3. **Algorithm Selection**: Given the constraints (n can be as large as \\(10^{18}\\)), we need an efficient way to check for the existence of such `k` and `m`. The solution involves:\n   - Handling small values of `n` directly (since for `n ≤ 5`, no valid `k` exists except trivial cases).\n   - For larger `n`, iterating over possible base values `k` (from 2 upwards) and checking if `n` can be expressed as the sum of a geometric series with base `k`.\n\n4. **Optimization**: Instead of checking all possible `k` up to `n`, we limit the range of `k` by noting that for `k ≥ 2`, the sum grows exponentially. Thus, we only need to check `k` values up to a certain limit (e.g., \\(10^6\\)) or until the computed sum exceeds `n`.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        \n        if n <= 5:\n            results.append(\"NO\")\n            continue\n            \n        found = False\n        k = 2\n        while True:\n            total = 1 + k\n            power = k\n            while total < n:\n                power *= k\n                total += power\n                if total == n:\n                    found = True\n                    break\n            if found:\n                break\n            if total >= n:\n                k += 1\n                if k > 10**6:\n                    break\n                    \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n            \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read in bulk for efficiency, especially given the constraints.\n2. **Handling Small `n`**: For `n` values less than or equal to 5, the answer is immediately \"NO\" because no valid `k` exists that forms a snowflake graph with these vertices.\n3. **Geometric Series Check**: For larger `n`, the algorithm iterates over possible base values `k` starting from 2. For each `k`, it calculates the sum of the geometric series \\(1 + k + k^2 + \\ldots\\) until the sum either matches `n` (indicating a valid snowflake) or exceeds `n` (indicating no solution for that `k`).\n4. **Termination Condition**: The loop terminates if `k` exceeds a reasonable limit (here, \\(10^6\\)) to ensure efficiency, as very large `k` values would not yield solutions for practical purposes.\n5. **Output Results**: After processing all test cases, the results are printed in sequence.\n\nThis approach efficiently checks for the existence of a snowflake graph by leveraging geometric series properties and early termination, ensuring optimal performance even for large values of `n`.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        \n        if n <= 5:\n            results.append(\"NO\")\n            continue\n            \n        found = False\n        k = 2\n        while True:\n            total = 1 + k\n            power = k\n            while total < n:\n                power *= k\n                total += power\n                if total == n:\n                    found = True\n                    break\n            if found:\n                break\n            if total >= n:\n                k += 1\n                if k > 10**6:\n                    break\n                    \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n            \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 556,
        "completion_token_count": 894,
        "thoughts_token_count": 1023
    }
}