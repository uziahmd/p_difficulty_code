{
    "start": 1758019513.1768608,
    "end": 1758021677.8361652,
    "start-formatted": "2025-09-16 19:45 KST",
    "end-formatted": "2025-09-16 20:21 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The task is to assign directions to each edge in an undirected graph such that the flow conditions are satisfied. The key points are:\n\n1. For each vertex except source (1) and sink (n), the sum of incoming flows equals the sum of outgoing flows. So, it's a conservation of flow.\n2. The source has no incoming edges. All edges connected to the source must be directed away from it.\n3. The directed graph must not have cycles.\n\nWait, but how do we ensure that the directed graph is acyclic? Also, since the original graph is connected, and after directing edges, it's a DAG with source and sink?\n\nLet me think. The problem says that the flow is a maximum flow. But the given ci values are already the flow volumes. We just need to assign directions to the edges such that the flow is valid and the directed graph is acyclic.\n\nSo the approach should be to find a way to direct the edges so that the flow conservation holds and the graph is a DAG. How?\n\nFirst, considering that the flow is a maximum flow, perhaps the underlying structure is a DAG. But how to model this?\n\nAnother thought: since the directed graph must be acyclic, we can arrange the vertices in a topological order. Then, all edges are directed from earlier vertices to later ones in this order. However, the source (vertex 1) must be the first in the topological order, and the sink (vertex n) must be the last. Because source has no incoming edges, so all edges from source go out. Similarly, sink has no outgoing edges, but that's not part of the constraints except for the flow conservation.\n\nWait, but the sink (vertex n) can have outgoing edges? No, because according to the problem statement, the flow is a maximum flow. In a standard max-flow setup, the sink can have outgoing edges in the residual graph, but here, the actual flow is given. However, the problem says that the flow must be a correct maximum flow, which implies that the sink has no outgoing edges in the directed graph. Wait, but the problem's conditions only require that for vertices 1 < v < n, the inflow equals outflow. The sink (n) can have any inflow and outflow, but since it's the sink, the outflow must be zero. Or wait, no. Let me recheck the problem statement.\n\nThe problem says: the resulting flow should be correct maximum flow. So the standard max-flow conditions apply. For the source, the total outflow is the value of the max flow. For the sink, the total inflow is equal to the max flow. All other vertices have inflow equal to outflow. So for the sink (vertex n), the inflow minus outflow equals the max flow. But in the problem's conditions, the only constraints are that for 1 < v < n, the sum of incoming equals sum of outgoing. So the sink can have any inflow and outflow as long as the net is the max flow. But the direction of edges must be such that the flow is valid.\n\nBut how does that affect our problem? Well, maybe we can ignore the sink's outflow as long as the flow is valid. But the main thing is to assign directions to edges so that the flow conservation holds for all vertices except source and sink.\n\nNow, the challenge is to assign directions to edges such that:\n\n- For all vertices except 1 and n, inflow equals outflow.\n- Source has no incoming edges.\n- The directed graph has no cycles.\n\nHmm. How to model this? Let's think about the flow conservation. For each vertex v (not 1 or n), the sum of flows on edges directed into v must equal the sum of flows directed out of v. That's equivalent to saying that the net flow (outflow - inflow) is zero. But since the flow is a valid maximum flow, the net flow for the source is (total flow) and for the sink is -(total flow).\n\nBut how to assign directions to edges to satisfy this?\n\nAnother thought: if we can model this as a directed graph where each edge's direction is chosen so that the flow conservation holds. But how?\n\nAlternatively, think of the problem as building a directed acyclic graph (DAG) where the flow conservation holds. Since the graph is acyclic, we can process the nodes in topological order. For example, if we can assign directions such that all edges go from lower-numbered nodes to higher-numbered ones (but that's not necessarily possible), but maybe there's a way to arrange the nodes in a certain order.\n\nWait, but the problem allows any topological order. So perhaps, if we can find a topological order where the source is first and the sink is last, then we can direct all edges from earlier nodes to later nodes. But how does that ensure flow conservation?\n\nAlternatively, think of the problem as building a DAG where the flow conservation holds. Let's consider that each node except the source and sink must have equal inflow and outflow. Which implies that the sum of flows on edges going into the node is equal to the sum on edges going out. Which suggests that for each node, the sum of flows on edges connected to it is even? No, not exactly. Because for each edge connected to the node, it's either incoming or outgoing. So for node v, sum of all flows on edges connected to it is (inflow + outflow) = 2 * inflow (since inflow equals outflow). So the sum of all flows on edges adjacent to v must be even. But the problem says that the input is such that a solution exists, so we don't have to check that.\n\nBut how to assign directions?\n\nLet me think about the following approach: construct a directed acyclic graph (DAG) by arranging the nodes in a certain order and directing edges accordingly. For example, arrange the nodes in a topological order, and direct edges from earlier to later in the order. This ensures that the graph is acyclic. Then, for each node, the sum of flows on edges going into the node must equal the sum on edges going out. How can this be achieved?\n\nBut how to choose the topological order such that this condition is satisfied?\n\nAlternatively, think of the problem as finding an orientation of the edges such that the flow conservation is satisfied, and the graph is a DAG. Since the graph is connected, perhaps we can build a tree structure. But I'm not sure.\n\nAnother idea: since the flow is a valid maximum flow, the underlying graph must have a structure that allows for this. For example, the residual graph would have no augmenting paths. But perhaps that's not helpful here.\n\nWait, perhaps the problem can be transformed into a problem of finding an Euler tour? No, that seems unrelated.\n\nAlternatively, think of the flow as a directed graph where each edge has a direction. The flow conservation conditions imply that the in-degree and out-degree for each node (except source and sink) have some relation. But how?\n\nAlternatively, model this as a flow problem again. Let me think: for each edge, the direction determines whether it contributes to the outflow or inflow of its endpoints. So, for each node v (not source or sink), the sum of flows on edges directed away from v must equal the sum of flows on edges directed towards v.\n\nLet me think about the problem in terms of the flow values. Let me denote for each edge between u and v, the flow is c. If the edge is directed from u to v, then u's outflow increases by c, and v's inflow increases by c. If directed the other way, then v's outflow increases by c, and u's inflow increases by c.\n\nFor each node v (not 1 or n), the sum of outflow equals sum of inflow. Which means that the total outflow is equal to the total inflow. Therefore, the net outflow is zero. Which implies that the sum over all edges connected to v of (direction-dependent contributions) must balance.\n\nBut how to model this? It seems like a system of equations. However, solving such a system for large n and m (up to 2e5) is computationally impossible with standard methods.\n\nWe need a smarter approach.\n\nLet me think about the fact that the graph must be acyclic. If we can arrange the nodes in a topological order, then for each edge, it is directed from a lower node to a higher node. Then, the graph is acyclic. Now, how to assign directions in such a way that the flow conservation is satisfied for all intermediate nodes.\n\nLet me imagine that the nodes are arranged in a topological order. Let's say the order is v_1, v_2, ..., v_n. Here, v_1 is the source (node 1), and v_n is the sink (node n). Then, for each edge between u and v, if u comes before v in the topological order, then the edge is directed from u to v. Otherwise, from v to u. Wait, but that depends on the order. However, if the order is such that the source is first and the sink is last, then all edges between nodes not in the sink can be directed in a way that follows the order.\n\nBut how to find such a topological order that ensures flow conservation?\n\nAlternatively, think of the problem as building a directed tree. For example, a spanning tree where edges are directed away from the root (source). But that's not sufficient for all cases.\n\nWait, but the graph can have cycles in the original undirected form. But once directed, they must be acyclic. So, the directed edges must form a DAG.\n\nAnother approach: since the directed graph must be acyclic, there exists a topological order. Let's suppose we can find such an order. Then, for each node v (except source and sink), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. Let's think about the sum of flows on edges connected to v. Each edge is either incoming or outgoing. Let me denote S_v as the sum of all c_i for edges connected to v. Then, since for each node v (not source or sink), the sum of incoming flows equals the sum of outgoing flows. Therefore, the sum of incoming flows is equal to (S_v)/2. Because incoming + outgoing = S_v, and incoming = outgoing. So, S_v must be even. But the problem says that the input is always valid, so this is guaranteed.\n\nSo, for each node v (not 1 or n), the sum of the flows on its edges must be even. Which is ensured by the problem's input.\n\nSo, the problem reduces to assigning directions to edges such that for each node v (not 1 or n), the sum of flows on edges directed into v is exactly half of S_v. And the graph must be acyclic.\n\nBut how to do this?\n\nLet me think about the following idea: construct a directed graph where each node (except the source and sink) has the required inflow. How can we model this?\n\nThis sounds like a problem of finding an orientation of the edges such that for each node v (except source and sink), the sum of the flows on edges directed into v is exactly (sum of flows on edges adjacent to v) / 2. \n\nThis is similar to the problem of orienting edges so that each node has a certain in-degree. But here, the \"in-degree\" is weighted by the flow values.\n\nBut how to compute that?\n\nPerhaps we can model this as a flow problem again. Wait, but that might not help.\n\nAnother idea: think of the nodes as having a certain \"balance\". For each node v (not 1 or n), the balance is zero. For the source, the balance is the total outflow (which is the max flow value). For the sink, the balance is negative of that.\n\nBut how does that help us?\n\nAlternatively, let's model this as a directed graph where for each node, the net outflow is equal to the balance. Then, the problem becomes finding an orientation of the edges that satisfies these balances.\n\nBut how to find such an orientation?\n\nThis is similar to the problem of finding an Eulerian orientation. Wait, in an Eulerian orientation, each node has in-degree equal to out-degree. But that's for undirected graphs where each node has even degree. However, in our case, the problem is different. We need to assign directions to edges so that the net outflow for each node (except source and sink) is zero. The source has a net outflow equal to the total flow, and the sink has a net inflow equal to the total flow.\n\nBut how can we model this? Let me think of the problem as a flow network where each edge can carry flow in either direction, and we need to assign directions so that the net flow for each node is correct.\n\nBut since the flow is given (the c_i values are fixed), the problem is to assign directions to the edges such that the net flow for each node is as required.\n\nThis seems like a problem that can be modeled as a directed graph with capacities. But I'm not sure.\n\nAlternatively, think of the problem as follows. For each edge, the direction determines which way the flow is going. The net outflow for a node is the sum of flows on edges directed away from it minus the sum of flows on edges directed towards it. For the source, this net outflow is equal to the total max flow. For the sink, it's equal to -total max flow. For others, zero.\n\nSo, the problem is to assign directions to edges such that the net outflow for each node is as required. How to compute that?\n\nBut how to compute the required net outflows? Well, the total outflow from the source is the sum of all flows on edges connected to it, minus the inflow. Wait, but the source has no incoming edges, so all edges connected to the source are directed away from it. So for the source, the net outflow is equal to the sum of flows on edges connected to it. Which must be the max flow value.\n\nBut how do we know what the max flow value is? Well, the max flow value is the sum of flows on edges leaving the source. But since the problem gives us the flows, perhaps the max flow value is determined by the sum of flows on edges connected to the source. Wait, but that may not be the case. For example, in the first sample input, the source (vertex 1) has edges to 2 (flow 10) and to 3 (flow 5). The total outflow is 15. But the sample output says that the flow is 10 through path 1-2-3 and 5 directly from 1 to 3, making the max flow 15. Which matches.\n\nSo, the max flow value is the sum of flows on edges leaving the source. So, the net outflow of the source is equal to the sum of all flows on edges connected to it. For the sink, the net inflow is the same value.\n\nBut how to compute this? Well, the sum of flows on edges connected to the source is the total max flow. So, for the source, the net outflow is that sum. For the sink, the net inflow is that sum. For other nodes, their net outflow is zero.\n\nSo, the problem reduces to finding an orientation of edges such that:\n\n- For each node v, the net outflow is:\n\n   - If v is source (1): total_flow = sum of flows on edges connected to source.\n\n   - If v is sink (n): -total_flow.\n\n   - Else: 0.\n\nBut how to compute this? Well, the net outflow for a node is the sum of flows on edges directed away from it minus the sum on edges directed towards it. Which is equal to the sum of flows on edges directed away from it minus (sum of all flows on edges connected to it minus sum of flows directed away from it) = 2*(sum of flows directed away) - sum of flows on edges connected to it.\n\nSo, for each node v, 2*sum_out = sum_edges_v + net_outflow_v. \n\nBut for the source, net_outflow is total_flow. So:\n\nsum_out = (sum_edges_v + total_flow)/2. \n\nSimilarly for other nodes.\n\nBut how to compute this?\n\nBut how do we know what the total_flow is? Well, the total_flow is the sum of flows on edges connected to the source, because the source has no incoming edges. So all edges connected to the source are directed away from it. Hence, the sum of flows on those edges is the total_flow.\n\nSo, the plan is:\n\n1. Compute for each node v, the sum of flows on edges connected to it. Let's call this s[v].\n\n2. For the source (v=1), the net outflow is total_flow = s[1]. For the sink (v=n), the net outflow is -total_flow. For other nodes, the net outflow is zero.\n\n3. For each node v, the sum of flows directed away from v must be (s[v] + net_outflow_v)/2.\n\nBut how to find the directions of the edges to achieve this?\n\nThis seems like a problem of finding an orientation of the edges such that for each node, the sum of flows on edges directed away from it is (s[v] + net_outflow_v)/2. \n\nThis looks like a problem that can be solved with a directed graph and some kind of flow algorithm. But I'm not sure.\n\nAlternatively, think of this as a problem of finding a directed graph where for each node, the outflow is known. How can we assign directions to edges to achieve this?\n\nThis feels like a problem that can be modeled as a system of equations, but again, with large n and m, that's not feasible.\n\nAnother idea: think of this as a directed graph where each edge can contribute to the outflow of one of its endpoints. For example, for each edge between u and v, if we direct it from u to v, then u's outflow increases by c, and v's outflow decreases by c (since the edge contributes to u's outflow and v's inflow). Wait, no. The net outflow for u is increased by c (as it's directed away from u), and for v, it's decreased by c (since the edge is directed towards v, contributing to its inflow, thus net outflow is reduced by c).\n\nSo, the problem becomes: assign directions to edges (each edge contributes +c to one node's outflow and -c to the other's) such that the final outflow for each node is as desired.\n\nThis is similar to the problem of finding an assignment of variables (directions) to edges such that the sum of contributions equals the desired outflow for each node.\n\nThis is a system of equations. Let me think: for each edge (u, v), let x_e be +1 if the direction is u→v, and -1 if v→u. Then, for each node v, the sum over all edges incident to v of (x_e * c_e) / 2 equals the desired net outflow. Wait, no. Because for each edge between u and v, if directed u→v, then the contribution to u's outflow is +c, and to v's outflow is -c. So, for each edge e between u and v, the contribution to the outflow of u is +c if directed u→v, and -c if directed v→u. So, the total outflow for node v is sum_{e incident to v} (contribution of e to v's outflow).\n\nLet me define for each edge e between u and v, the variable x_e ∈ {+1, -1}, where x_e = +1 if the edge is directed u→v, and -1 if directed v→u. Then, the total outflow for node v is sum_{e incident to v} (x_e * c_e) * (if the edge is incident to v and directed away from v, then +c, else if directed towards v, then -c). Wait, perhaps I need to think differently.\n\nFor each edge e between u and v, when directed from u to v, it contributes +c to u's outflow and -c to v's outflow. When directed from v to u, it contributes -c to u's outflow and +c to v's outflow. So, for each edge e between u and v, the contribution to u's outflow is (x_e) * c, where x_e is +1 if directed u→v, -1 otherwise. Similarly for v.\n\nSo, the total outflow for each node v is sum_{e incident to v} (x_e * c_e) * (if the edge is directed away from v, then +c, else ...). Wait, no. Let me think again. For each edge e between u and v, the direction is either u→v or v→u. For the node u, if the edge is directed away from u (u→v), then it contributes +c to u's outflow. If directed towards u (v→u), it contributes -c to u's outflow. Similarly for v.\n\nSo, the total outflow for node v is the sum over all edges incident to v of (contribution of that edge to v's outflow). For each edge between v and another node w, if the edge is directed from v to w, it contributes +c to v's outflow. If directed from w to v, it contributes -c to v's outflow.\n\nTherefore, the total outflow for node v is equal to the sum over all edges incident to v of (direction_contribution) = sum_{e} (d_e * c_e), where d_e is +1 if the edge is directed away from v, -1 otherwise.\n\nBut how to express this in terms of variables? For each edge between u and v, the direction choice affects both u and v. Let me think of the variables as x_e, which is +1 if directed from u to v, and -1 if directed from v to u. Then, for the edge e between u and v, the contribution to u's outflow is x_e * c_e, and the contribution to v's outflow is -x_e * c_e.\n\nSo, the total outflow for node v is sum_{e incident to v} (x_e * c_e if the edge is between v and some other node, and the direction is away from v) ?\n\nWait, no. For each edge between u and v, the variable x_e is defined as +1 if the direction is u→v, -1 otherwise. So, for node u, this contributes +c_e to its outflow. For node v, this contributes -c_e to its outflow. So, for each node v, the total outflow is the sum over all edges incident to v of (x_e * c_e) multiplied by a factor based on whether the edge is incident to v and the direction.\n\nWait, perhaps the total outflow for node v is sum_{e incident to v} (x_e * c_e if the edge is directed away from v). But how to model this with the variables?\n\nAlternatively, for each edge e between u and v, the variable x_e is +1 if the direction is u→v, -1 otherwise. So, for node u, the contribution to outflow is +c_e * x_e. For node v, the contribution is -c_e * x_e.\n\nSo, the total outflow for node v is sum_{e incident to v} (-c_e * x_e if the edge is between u and v, and the variable x_e is defined as per the direction). Wait, this seems complicated.\n\nAlternatively, for each node v, the total outflow is the sum for all edges e incident to v of (if the edge is directed away from v, then +c_e, else -c_e). Let me denote this as O_v. \n\nWe need O_v = desired_outflow_v for all v.\n\nBut how to express O_v in terms of x_e variables. Let's think for each edge e between u and v. If the edge is directed from u to v, then for u, it contributes +c_e to O_u, and for v, contributes -c_e to O_v. Similarly, if directed from v to u, then for u, it contributes -c_e to O_u, and for v, +c_e to O_v.\n\nSo, for each edge e between u and v, the contribution to O_u is x_e * c_e, and the contribution to O_v is -x_e * c_e.\n\nThus, for all nodes, the sum over all edges incident to them of their contribution is equal to the desired O_v.\n\nSo, the equations are:\n\nFor each node v:\n\nsum_{e incident to v} (contribution to O_v) = desired_outflow_v.\n\nWhich can be rewritten as:\n\nsum_{e incident to v} [ (if e is between v and w, then x_e * c_e if direction is v→w, else -x_e * c_e) ] = desired_outflow_v.\n\nBut this seems too abstract. However, notice that for each edge e between u and v, the contribution to O_u is x_e * c_e, and to O_v is -x_e * c_e. So, for each edge e, the variables x_e are involved in two equations (for u and v).\n\nBut the problem is to find x_e ∈ {+1, -1} for each edge e such that the above equations hold.\n\nBut solving this system seems difficult for large n and m. However, the problem states that a solution exists. How can we find such x_e?\n\nLet me think about the desired outflow for each node. As discussed earlier:\n\nFor the source (v=1), desired_outflow is total_flow = sum of flows on edges connected to it. For the sink (v=n), desired_outflow is -total_flow. For other nodes, desired_outflow is zero.\n\nLet me denote D_v as the desired_outflow for node v.\n\nThen, the equations are:\n\nFor all edges e between u and v:\n\nx_e * c_e (contribution to O_u) + (-x_e * c_e) (contribution to O_v) = 0? No, this is for each edge. The overall sum for all nodes would be zero, but individual equations are not.\n\nBut the system of equations is:\n\nFor each node v:\n\nsum_{e incident to v} [ contribution to O_v ] = D_v.\n\nBut how to find x_e variables?\n\nThis seems like a system of linear equations over integers. But solving it for large n and m is not trivial.\n\nBut perhaps there's a way to model this as a directed graph and find an orientation that satisfies these constraints.\n\nAnother observation: The sum of all D_v is zero. Because for the source, D_1 = total_flow, for the sink, D_n = -total_flow, and others are zero. Summing all D_v gives zero. Which matches the fact that the sum of all O_v must be zero (since each edge contributes to O_u and O_v with opposite signs).\n\nSo the system is consistent.\n\nNow, how to find x_e variables?\n\nLet me think of the problem as follows: For each node v, the sum of contributions from edges incident to it is D_v. So, for node v, sum_{e incident to v} (contribution) = D_v.\n\nBut the contribution for each edge e incident to v is either +c_e (if directed away from v) or -c_e (directed towards v).\n\nLet me think of this as a flow problem. Suppose we have a directed graph where each edge can be directed in either direction, and we want to assign directions so that the net outflow of each node is D_v.\n\nThis is similar to the problem of finding an Eulerian orientation, but with arbitrary net outflows.\n\nBut how?\n\nAn alternative approach is to model this as a directed graph and find an orientation that satisfies the net outflow for each node. This is known as the \"flow decomposition\" problem.\n\nBut I'm not familiar with an efficient algorithm for this. However, since the problem guarantees that a solution exists, perhaps there's a way to construct it greedily.\n\nLet me think of the following approach:\n\nWe can model this as a directed graph, where we need to assign directions to edges such that the net outflow of each node is D_v. To do this, we can perform a depth-first search (DFS) or similar traversal, and assign directions as we go.\n\nFor example, consider building a directed tree rooted at the source. For each node, we can direct edges towards the parent or child based on the required net outflow.\n\nBut I'm not sure. Another idea is to think of the problem as a directed graph where we need to find a directed spanning tree from the source to the sink, and assign directions accordingly. But again, not sure.\n\nAlternatively, think of the problem as follows: For each node v, the required net outflow is D_v. Let's imagine that we have a graph where we can add edges in a way that balances the net outflow.\n\nFor example, start with the source. The source has D_1 = total_flow. All edges connected to the source must be directed away from it, since it has no incoming edges. This contributes to the net outflow of the source. For each such edge, we can subtract c_e from the source's D_v and add it to the neighbor's D_v. Wait, perhaps not. Let me think.\n\nWhen we direct an edge from the source (u) to v, this contributes +c_e to u's net outflow (which is already accounted for) and -c_e to v's net outflow. But since u is the source, its D_v is already fixed. So, for the neighbor v, the net outflow must be adjusted by -c_e.\n\nBut how to proceed?\n\nLet me think of this as a problem of maintaining for each node v, a residual net outflow. Initially, the residual is D_v. For each edge, we need to direct it in a way that reduces the residual of the nodes involved.\n\nFor example, take any node with a non-zero residual. If the residual is positive, it needs to send out more flow. If negative, it needs to receive more flow.\n\nLet's take the source, which has a positive residual. For each edge connected to the source, we direct it away from the source. This contributes to the residual of the other end. For example, if the edge is between source (u) and v, directing it from u to v adds -c_e to the residual of v. So, the residual for v becomes D_v - c_e.\n\nThen, we can process the other nodes recursively. For example, take a node with a positive residual. We need to direct edges away from it to reduce its residual. If the node has a negative residual, we need to direct edges towards it to increase its residual.\n\nThis sounds like a way to process the nodes and assign directions to edges accordingly.\n\nThis seems like a possible approach. Let me try to formalize it.\n\nInitialize for each node v, residual[v] = D_v.\n\nFor the source, residual[1] = total_flow. For the sink, residual[n] = -total_flow. Others are zero.\n\nWe can process the nodes in a BFS-like manner. For example, pick a node u with residual[u] != 0. Then, look for an edge connected to u that hasn't been processed yet. Suppose the edge connects u to v. Depending on the sign of residual[u], we decide the direction of the edge.\n\nIf residual[u] > 0, we need to direct the edge away from u. So, the edge is directed u → v. This contributes -c_e to residual[v], and residual[u] decreases by c_e (because the edge contributes to the net outflow of u). So, residual[u] -= c_e, and residual[v] += (-c_e). Wait, no. The net outflow for u is being adjusted. Let me think again.\n\nWhen we direct the edge from u to v, this contributes +c_e to u's net outflow (which was already accounted for in D_u). But since we're trying to reach the desired D_u, this action reduces the residual for u. Wait, the residual is the amount of net outflow that still needs to be achieved. So, initially, residual[u] is D_u. After directing the edge from u to v, we have contributed +c_e to the net outflow of u. Thus, the residual for u decreases by c_e. Similarly, the net outflow for v is now affected by -c_e, so the residual for v increases by -c_e (i.e., residual[v] += (-c_e)).\n\nWait, no. Let me think again. The residual is the amount of net outflow that still needs to be achieved. For example, if the residual for u is R, then we need to have R more net outflow. By directing an edge away from u, we are adding c_e to the net outflow. So, the residual for u becomes R - c_e. Similarly, for v, the net outflow is being reduced by c_e (since this edge contributes -c_e to v's net outflow). So, the residual for v is (original residual) + c_e.\n\nWait, I think I'm getting confused here. Let me clarify:\n\nThe net outflow for node v is supposed to be D_v. Initially, residual[v] is D_v. For each edge directed away from v, it contributes +c_e to the net outflow. For each edge directed towards v, it contributes -c_e to the net outflow.\n\nSo, during processing, for each edge, we choose a direction and adjust the residuals accordingly.\n\nLet me think of the residual as the difference between the desired net outflow and the current net outflow. Initially, the current net outflow is zero, so residual is D_v. As we assign directions to edges, the residual is updated.\n\nFor example, if we direct an edge from u to v:\n\n- This adds +c_e to the net outflow of u. So, residual[u] decreases by c_e (since we've achieved c_e of the desired D_u).\n- This adds -c_e to the net outflow of v. So, residual[v] increases by c_e (since we've achieved -c_e of the desired D_v, which means we need to achieve D_v + c_e more).\n\nSo, after this operation, residual[u] = residual[u] - c_e, and residual[v] = residual[v] + c_e.\n\nSimilarly, if we direct the edge from v to u:\n\n- residual[v] decreases by c_e.\n- residual[u] increases by c_e.\n\nSo, the idea is to process edges in such a way that we always reduce the residuals until they are zero.\n\nHow to implement this?\n\nWe can use a queue-based approach. Start with the source node, which has a residual of total_flow (positive). For each node u in the queue, we look for an edge that hasn't been processed yet. For each such edge, we check the residual of u. If the residual is positive, we direct the edge away from u. If it's negative, we direct it towards u. Wait, but how do we know which direction to choose?\n\nLet me think. Suppose we have a node u with residual[u] != 0. We need to find an edge connected to u that hasn't been processed yet. For that edge, we can direct it in a way that helps reduce the residual of u.\n\nIf residual[u] is positive, then we need to direct the edge away from u to contribute to its net outflow. So, for the edge between u and v, we direct it from u to v. This reduces residual[u] by c_e and increases residual[v] by c_e.\n\nAfter this, we add v to the queue if residual[v] is not zero.\n\nIf residual[u] is negative, then we need to direct the edge towards u. So, for the edge between u and v, we direct it from v to u. This increases residual[u] by c_e (because the net outflow for u is now increased by -c_e, which is the contribution from this edge), and decreases residual[v] by c_e.\n\nThis seems like a viable approach.\n\nBut how to implement this efficiently?\n\nWe can represent the graph as an adjacency list, and for each edge, track whether it has been processed. However, since each edge is processed exactly once, we can mark edges as processed once they are assigned a direction.\n\nThe steps would be:\n\n1. Compute D_v for all nodes. For the source, D_v = sum of flows on edges connected to it. For the sink, D_v = -sum of flows on edges connected to it. For others, zero.\n\nWait, no. Earlier analysis said that D_v is the desired net outflow. For the source, D_1 = total_flow. For the sink, D_n = -total_flow. For others, zero.\n\nBut how to compute total_flow?\n\ntotal_flow is the sum of flows on edges connected to the source. Because the source has no incoming edges, all edges connected to it are directed away, contributing to the net outflow of the source.\n\nSo, to compute total_flow:\n\ntotal_flow = sum of c_i for all edges incident to the source.\n\nOnce we have D_v for all nodes, we proceed with the algorithm.\n\nThe algorithm:\n\nInitialize a queue with the source node (since it has a non-zero residual). Also, create a data structure to track for each edge whether it's been processed, and its direction.\n\nFor each node u in the queue:\n\n   while there are unprocessed edges incident to u:\n\n      pick an unprocessed edge (u, v) with flow c.\n\n      if residual[u] > 0:\n\n         direct the edge from u to v (output 0 for this edge if it's stored as ai, bi, etc.)\n\n         residual[u] -= c\n\n         residual[v] += c\n\n         mark the edge as processed.\n\n         if residual[v] != 0, add v to the queue.\n\n      elif residual[u] < 0:\n\n         direct the edge from v to u (output 1 for this edge)\n\n         residual[u] += c\n\n         residual[v] -= c\n\n         mark the edge as processed.\n\n         if residual[v] != 0, add v to the queue.\n\n      else:\n\n         break (no more processing needed for this node)\n\nBut how to handle the case where multiple",
    "response": "\n\nTo solve this problem, we need to assign directions to edges in an undirected graph such that the resulting directed graph satisfies the conditions of a valid maximum flow, including flow conservation at intermediate vertices, no incoming edges at the source, and an acyclic structure.\n\n### Approach\n1. **Understanding Flow Conservation**: Each intermediate vertex (not the source or sink) must have equal inflow and outflow. This means the sum of flows on edges connected to each intermediate vertex must be even.\n2. **Topological Order and Acyclic Graph**: By directing edges in a way that respects a topological order, we ensure the graph remains acyclic. This can be achieved using a BFS-like approach starting from the source.\n3. **Residual Adjustment**: We maintain a residual value for each node, representing the net outflow needed. Starting from the source, we process each edge, adjusting residuals as we direct edges either away from or towards nodes based on their current residual values.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    # Compute total_flow as sum of flows on edges connected to source (vertex 1)\n    total_flow = 0\n    for neighbor, _ in adj[1]:\n        # Find the edge between 1 and neighbor, but since it's stored in both, we need to check\n        # However, for the purpose of computing total_flow, just iterate through all edges connected to 1\n        pass  # Actually, we'll compute it during processing\n\n    # But we need to calculate D_v for each node\n    # D[1] = total_flow, D[n] = -total_flow, others are 0\n    # So first compute total_flow\n    total_flow = 0\n    for neighbor, edge_idx in adj[1]:\n        # Check if the edge is between 1 and neighbor\n        a, b, c = edges[edge_idx]\n        if a == 1 or b == 1:\n            total_flow += c\n\n    D = [0] * (n + 1)\n    D[1] = total_flow\n    D[n] = -total_flow\n\n    # Now, process edges\n    residual = D[:]\n    processed = [False] * m\n    direction = [0] * m  # 0 means ai->bi, 1 means bi->ai\n\n    # To track which edges are processed, and for each node, track the edges\n    # We can use a queue for BFS-like processing\n    q = deque()\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n        # Iterate through all adjacent edges\n        # Need to find unprocessed edges\n        # To avoid revisiting, we can track which edges are processed\n        # But since each edge is in adj[u] and adj[v], we need to check if processed\n        # For each edge, we need to check if it's already processed\n        # So for each neighbor, we check the edge index and if processed\n        # We can loop through all edges in adj[u], and check if they are processed\n        # To avoid reprocessing, we can mark them once processed\n        # So for each edge in adj[u], check if it's processed\n        # But how to get the edge index?\n        # For each entry in adj[u], it's (v, edge_idx)\n        # So we can loop through all (v, edge_idx) in adj[u]\n        # And check if processed[edge_idx] is False\n        # If so, process it\n        # So for each edge in adj[u], check if not processed\n        for v, edge_idx in adj[u]:\n            if processed[edge_idx]:\n                continue\n            # Get the edge data\n            a, b, c = edges[edge_idx]\n            # Determine if the edge is between u and v\n            # Since adj is built with both directions, we need to check which one is u and v\n            # But for the purpose of processing, we can proceed\n            if residual[u] > 0:\n                # Direct the edge from u to v\n                direction[edge_idx] = 0\n                residual[u] -= c\n                residual[v] += c\n                processed[edge_idx] = True\n                if residual[v] != 0:\n                    q.append(v)\n            elif residual[u] < 0:\n                # Direct the edge from v to u\n                direction[edge_idx] = 1\n                residual[u] += c\n                residual[v] -= c\n                processed[edge_idx] = True\n                if residual[v] != 0:\n                    q.append(v)\n            else:\n                # residual[u] is zero, no need to process\n                processed[edge_idx] = True\n                continue\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into edges and adjacency lists.\n2. **Total Flow Calculation**: The total flow from the source is calculated by summing the flows of all edges connected to the source.\n3. **Residual Initialization**: Each node's residual is initialized based on the required net outflow (source has positive residual, sink has negative).\n4. **BFS Processing**: Using a queue, nodes are processed to adjust residuals by directing edges appropriately. This ensures flow conservation and acyclicity by always reducing residuals until they reach zero, ensuring a valid flow configuration.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    # Compute total_flow as sum of flows on edges connected to source (vertex 1)\n    total_flow = 0\n    for neighbor, _ in adj[1]:\n        # Find the edge between 1 and neighbor, but since it's stored in both, we need to check\n        # However, for the purpose of computing total_flow, just iterate through all edges connected to 1\n        pass  # Actually, we'll compute it during processing\n\n    # But we need to calculate D_v for each node\n    # D[1] = total_flow, D[n] = -total_flow, others are 0\n    # So first compute total_flow\n    total_flow = 0\n    for neighbor, edge_idx in adj[1]:\n        # Check if the edge is between 1 and neighbor\n        a, b, c = edges[edge_idx]\n        if a == 1 or b == 1:\n            total_flow += c\n\n    D = [0] * (n + 1)\n    D[1] = total_flow\n    D[n] = -total_flow\n\n    # Now, process edges\n    residual = D[:]\n    processed = [False] * m\n    direction = [0] * m  # 0 means ai->bi, 1 means bi->ai\n\n    # To track which edges are processed, and for each node, track the edges\n    # We can use a queue for BFS-like processing\n    q = deque()\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n        # Iterate through all adjacent edges\n        # Need to find unprocessed edges\n        # To avoid revisiting, we can track which edges are processed\n        # But since each edge is in adj[u] and adj[v], we need to check if processed\n        # For each edge, we need to check if it's already processed\n        # So for each neighbor, we check the edge index and if processed\n        # We can loop through all edges in adj[u], and check if they are processed\n        # To avoid reprocessing, we can mark them once processed\n        # So for each edge in adj[u], check if it's processed\n        # But how to get the edge index?\n        # For each entry in adj[u], it's (v, edge_idx)\n        # So we can loop through all (v, edge_idx) in adj[u]\n        # And check if processed[edge_idx] is False\n        # If so, process it\n        # So for each edge in adj[u], check if not processed\n        for v, edge_idx in adj[u]:\n            if processed[edge_idx]:\n                continue\n            # Get the edge data\n            a, b, c = edges[edge_idx]\n            # Determine if the edge is between u and v\n            # Since adj is built with both directions, we need to check which one is u and v\n            # But for the purpose of processing, we can proceed\n            if residual[u] > 0:\n                # Direct the edge from u to v\n                direction[edge_idx] = 0\n                residual[u] -= c\n                residual[v] += c\n                processed[edge_idx] = True\n                if residual[v] != 0:\n                    q.append(v)\n            elif residual[u] < 0:\n                # Direct the edge from v to u\n                direction[edge_idx] = 1\n                residual[u] += c\n                residual[v] -= c\n                processed[edge_idx] = True\n                if residual[v] != 0:\n                    q.append(v)\n            else:\n                # residual[u] is zero, no need to process\n                processed[edge_idx] = True\n                continue\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 700,
        "completion_token_count": 1279,
        "thoughts_token_count": 8191
    }
}