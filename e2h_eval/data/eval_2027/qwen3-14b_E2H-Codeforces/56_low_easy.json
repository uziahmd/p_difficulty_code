{
    "start": 1758309278.1575735,
    "end": 1758309689.001476,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:21 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to determine if there's a perfect matching between R rebel spaceships and B bases such that no two connecting lines (from a spaceship to its assigned base) intersect. And since R and B are up to 10, maybe we can check all possible matchings.\n\nFirst, I need to generate all possible perfect matchings. Since R and B are equal (since the problem says every base has exactly one guardian and each spaceship has exactly one assigned base), so R must equal B. Wait, the input says R and B can be 1<=R,B<=10. But for a perfect matching, R must equal B. So the first check is whether R equals B. If not, output No. Oh right! Because if R != B, there's no way to have a perfect matching. So that's the first thing to check.\n\nSo the first step is to check if R and B are equal. If not, immediately output No. Otherwise, proceed.\n\nNow, for each possible permutation of the bases (since each spaceship is matched to exactly one base), we need to check if all the line segments between the spaceship and their assigned base do not intersect with each other.\n\nBut how do we check if any two line segments intersect?\n\nSo, the plan is:\n\n1. Check if R != B. If so, output No.\n2. Else, generate all possible permutations of the bases (since each spaceship is assigned to a unique base). For each permutation, check if all the line segments between the i-th spaceship and the i-th base in the permutation are non-intersecting.\n3. If any permutation satisfies this condition, output Yes. Otherwise, No.\n\nBut generating all permutations could be computationally feasible for R=10. Let's see: 10! is about 3.6 million. For each permutation, we need to check all pairs of line segments for intersection. For 10 line segments, there are C(10,2) = 45 pairs. For each pair, check if they intersect.\n\nBut for R=10, 3.6 million permutations multiplied by 45 checks per permutation would be around 162 million operations. That's manageable in Python? Well, considering that each check is a simple computational geometry operation, maybe. But perhaps there's a smarter way.\n\nAlternatively, for each permutation, check all pairs of line segments. If any two intersect, discard that permutation.\n\nBut how to check if two line segments intersect?\n\nI need to implement a function that takes two line segments and returns True if they intersect, False otherwise.\n\nThe standard approach for checking segment intersection is:\n\nFirst, check if the two segments' bounding boxes overlap. If not, they can't intersect. Then, use the orientation method.\n\nBut since the problem says that no three points are colinear, that might help. Wait, the note says that no three points are on the same line. So, any two segments can't have overlapping lines, but they can cross each other.\n\nBut the problem says that no two points coincide, and no three are colinear. So, when checking for intersection between two segments, the only possibilities are that they cross each other (properly intersect) or share an endpoint. However, since the problem says that all points are distinct, the segments can't share an endpoint. Because each spaceship and base is unique. So, in the permutation, each line segment connects a spaceship to a base. So, two different segments would connect (spaceship A to base X) and (spaceship B to base Y), where all four points are distinct. Therefore, the segments can't share endpoints. Therefore, when checking for intersection between two segments, we need to check if they cross each other (properly intersect) or touch at endpoints. But since the endpoints are all unique, the only possibility is that they cross each other.\n\nWait, but what if two segments share an endpoint? For example, if two segments are from the same spaceship to two different bases. But in a permutation, each spaceship is assigned to exactly one base. So, in the permutation, each spaceship is connected to exactly one base. So, two different segments would be from different spaceships to different bases. Therefore, their endpoints are all distinct. So, the two segments cannot share any endpoints. Therefore, when checking for intersection between two segments, we can ignore the case where they share endpoints. Thus, the problem reduces to checking if two line segments properly intersect.\n\nSo, the function to check if two segments AB and CD intersect would be to check whether they cross each other, not just touching at endpoints.\n\nSo, how to implement that?\n\nThe standard method is to use the orientation method. Here's how it works:\n\nFor two segments AB and CD:\n\n- Find the orientation of A, B, C and A, B, D. If they are different, then the segments may intersect.\n- Similarly, find the orientation of C, D,",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting line segments intersect. The solution involves checking all possible permutations of assignments and verifying if any permutation meets the non-intersection condition.\n\n### Approach\n1. **Check for Equal Numbers**: First, ensure the number of spaceships (R) and bases (B) are equal. If not, output \"No\".\n2. **Generate Permutations**: For each permutation of bases, consider it as a potential assignment of bases to spaceships.\n3. **Check Line Segment Intersections**: For each permutation, check if any pair of line segments (connecting spaceships to their assigned bases) intersect. This is done using computational geometry techniques to determine if two line segments intersect.\n4. **Determine Result**: If any permutation results in no intersecting line segments, output \"Yes\". Otherwise, output \"No\".\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    input_str = sys.stdin.read().strip()\n    lines = input_str.split('\\n')\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    from itertools import permutations\n    for perm in permutations(bases):\n        segments = []\n        for i in range(R):\n            segments.append( (rebels[i], perm[i]) )\n        intersect = False\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if segments_intersect(segments[i], segments[j]):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Orientation Check**: The `orientation` function determines the relative orientation of three points, which helps in checking intersections.\n- **Segment Intersection Check**: The `segments_intersect` function uses orientation checks to determine if two line segments intersect.\n- **Permutations Check**: All permutations of base assignments are checked for intersections. If any permutation results in no intersections, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    input_str = sys.stdin.read().strip()\n    lines = input_str.split('\\n')\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    from itertools import permutations\n    for perm in permutations(bases):\n        segments = []\n        for i in range(R):\n            segments.append( (rebels[i], perm[i]) )\n        intersect = False\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if segments_intersect(segments[i], segments[j]):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 951,
        "thoughts_token_count": 1024
    }
}