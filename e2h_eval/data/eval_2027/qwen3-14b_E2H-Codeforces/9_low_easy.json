{
    "start": 1758313790.689366,
    "end": 1758314108.6551924,
    "start-formatted": "2025-09-20 05:29 KST",
    "end-formatted": "2025-09-20 05:35 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this problem where Petya wants to maximize the total cost of souvenirs he can carry, given that each souvenir has a weight (1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. So the standard knapsack approach won't work here because the time complexity would be O(nm), which for 1e5 * 3e5 is way too big. So I need a smarter approach.\n\nLet me think about the weights. Since each item's weight is only 1, 2, or 3, maybe I can handle each group separately. For example, for all items of weight 1, I can take as many as possible (sorted by cost descending), same for weight 2 and 3. But how do I combine them optimally?\n\nWait, but there's a possibility that taking some combination of items with different weights gives a better total cost. For example, maybe taking one weight 3 item is better than taking two weight 2 items. So I need to find the optimal way to combine these.\n\nHmm. Let's think about grouping the items by their weight. Then, for each group, sort them in descending order of cost. Then, for each weight group, precompute the prefix sums so that for any number of items taken, we can quickly calculate the total cost.\n\nOnce I have those prefix sums, the problem becomes how to select a certain number of items from each weight group such that the total weight is <= m, and the sum of costs is maximized.\n\nSo let's denote:\n\n- For weight 1: we have a sorted list, and prefix sum array s1, where s1[k] is the sum of the first k items.\n- Similarly for weight 2: s2, and weight 3: s3.\n\nNow, the total weight is 1*a + 2*b + 3*c ≤ m, where a is the number of weight 1 items taken, b for weight 2, c for weight 3. We need to maximize s1[a] + s2[b] + s3[c].\n\nBut how do I compute this efficiently?\n\nThe idea is to iterate through possible numbers of weight 3 items, then for each possible c, determine the best combination of a and b. But even that might be expensive if done naively.\n\nAlternatively, since the weights are small (1,2,3), perhaps we can find for each possible number of weight 3 items, then compute the maximum possible for the remaining weight using the weight 1 and 2 items.\n\nBut how?\n\nLet me think. Let's say I have all possible weight 3 items sorted. For each possible c (number of weight 3 items taken), the total weight used by them is 3*c. Then the remaining weight is m - 3*c. Now, I need to find the best a and b such that a + 2*b ≤ rem_weight. How to find that?\n\nFor the remaining weight, which is rem = m - 3*c, we can consider all possible numbers of weight 2 items (b), and then take as many weight 1 items as possible (since they have the highest value per unit weight, but maybe not? Well, since we sorted them in descending order, taking as many as possible is optimal.)\n\nWait, but the problem is that the weight 1 items and weight 2 items may have varying values. For example, maybe taking one weight 2 item with higher value than two weight 1 items. So the optimal selection for a and b given a rem weight is not straightforward.\n\nBut how to compute that quickly?\n\nAnother approach: for the weight 1 and 2 items, we can precompute for every possible weight up to m, the maximum value. But since m can be up to 3e5, and for each possible rem, that's manageable?\n\nBut how to compute that. Let's think. Let's say we have the weight 1 and 2 items. Let's create a dp array for the maximum value for a given weight. However, since the weight 1 and 2 items can be processed in a way that allows us to compute this.\n\nWait, but for the weight 1 and 2 items, the maximum number of items is up to n. But perhaps we can process them in a way that for each possible total weight, we can find the maximum value. However, for this part, since the items are sorted, maybe there's a way to compute it without dynamic programming.\n\nAlternatively, for the weight 1 and 2 items, for a given total weight w, the optimal is to take as many weight 2 items as possible, then fill the rest with weight 1 items. But that's not necessarily correct. For example, if there's a weight 2 item with cost 3, and two weight 1 items",
    "response": "To solve this problem efficiently, we need to maximize the total cost of souvenirs Petya can carry, given that each souvenir has a weight of either 1, 2, or 3. The constraints make it impractical to use a standard dynamic programming approach for the knapsack problem due to its high time complexity.\n\n### Approach\n1. **Grouping by Weight**: First, group all items by their weight (1, 2, or 3) and sort each group in descending order of cost. This helps in selecting the most valuable items first.\n2. **Prefix Sums**: Compute prefix sums for each group to quickly calculate the total cost of taking the top `k` items from any group.\n3. **Iterative Optimization**: For each possible number of weight 3 items taken, compute the remaining weight capacity and determine the optimal combination of weight 1 and 2 items that can fit into this remaining capacity. This is done by iterating through possible numbers of weight 2 items and calculating how many weight 1 items can be added without exceeding the capacity.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n\n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n\n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n\n    max_total = 0\n\n    # Try all possible counts of weight 3 items\n    max_c = min(len(w3), m // 3)\n    for c in range(0, max_c + 1):\n        weight_used = 3 * c\n        if weight_used > m:\n            continue\n        rem = m - weight_used\n        # Now find best a and b where a + 2*b <= rem\n        # Try all possible b for weight 2 items\n        max_b = min(len(w2), rem // 2)\n        # For each b, a can be up to rem - 2*b\n        # But since a can't exceed len(w1)\n        best = 0\n        for b in range(0, max_b + 1):\n            a = min(len(w1), rem - 2 * b)\n            current = prefix1[a] + prefix2[b]\n            if current > best:\n                best = current\n        total = best + prefix3[c]\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Grouping**: The input is read and grouped by the weights of the souvenirs. Each group is sorted in descending order of cost to prioritize higher value items.\n2. **Prefix Sums Calculation**: Prefix sums for each group allow quick calculation of the total cost for taking the top `k` items from each group.\n3. **Iterative Check for Maximum Value**: For each possible number of weight 3 items, the remaining capacity is calculated. For this remaining capacity, all possible combinations of weight 2 and weight 1 items are checked to find the optimal value. This ensures that we explore all feasible combinations efficiently, leveraging the sorted and precomputed prefix sums for quick lookups.\n\nThis approach ensures that we handle the constraints efficiently, leveraging the limited range of weights (1, 2, 3) to optimize the solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n\n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n\n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n\n    max_total = 0\n\n    # Try all possible counts of weight 3 items\n    max_c = min(len(w3), m // 3)\n    for c in range(0, max_c + 1):\n        weight_used = 3 * c\n        if weight_used > m:\n            continue\n        rem = m - weight_used\n        # Now find best a and b where a + 2*b <= rem\n        # Try all possible b for weight 2 items\n        max_b = min(len(w2), rem // 2)\n        # For each b, a can be up to rem - 2*b\n        # But since a can't exceed len(w1)\n        best = 0\n        for b in range(0, max_b + 1):\n            a = min(len(w1), rem - 2 * b)\n            current = prefix1[a] + prefix2[b]\n            if current > best:\n                best = current\n        total = best + prefix3[c]\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 899,
        "thoughts_token_count": 1024
    }
}