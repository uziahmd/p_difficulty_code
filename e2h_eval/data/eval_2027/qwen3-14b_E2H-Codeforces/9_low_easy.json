{
    "start": 1758009435.2417984,
    "end": 1758010194.4248612,
    "start-formatted": "2025-09-16 16:57 KST",
    "end-formatted": "2025-09-16 17:09 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (which is 1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm. \n\nFirst, I need to think about the approach. Since the weights are limited to 1, 2, 3, maybe we can handle each weight category separately. For example, for items with weight 1, we can take as many as possible, but since they might have varying costs, we should sort them in descending order of cost and take the top ones. Same for weight 2 and 3.\n\nBut how do we combine them optimally? Because taking a certain number of weight 2 items might be better than taking some weight 1 items, depending on their cost per unit weight. But since the total weight is limited, we need a way to compute the best combination.\n\nLet me think. Let's separate the items into three groups: w=1, w=2, w=3. Then, for each group, sort them in descending order of cost. Then, for each group, precompute the prefix sums so that we can quickly calculate the total cost for taking k items from that group.\n\nOnce we have these prefix sums, the problem becomes selecting how many items to take from each group such that the total weight doesn't exceed m, and the total cost is maximized.\n\nBut how to efficiently iterate through all possibilities? Since m can be up to 3e5, and n up to 1e5, we need an efficient approach.\n\nLet me think of possible approaches. For example, for each possible number of weight 3 items taken, we can compute the remaining weight and then decide how to split between weight 1 and 2. But even that might be computationally heavy if done naively.\n\nAlternatively, considering that the weight is small (only 1, 2, 3), perhaps we can use dynamic programming. However, for m up to 3e5, a standard DP approach would be O(nm) which would be 3e11 operations, which is way too slow. So that's not feasible.\n\nSo back to the idea of grouping by weight. Let's think about the following steps:\n\n1. Sort each group (w=1, w=2, w=3) in descending order of cost. Then, precompute prefix sums for each group. Let's say for group 1, the prefix sum array is s1, where s1[k] is the sum of the first k items. Similarly for s2 and s3.\n\n2. Now, for each possible number of items taken from group 3 (say, x items), we can compute the remaining weight (m - 3x). Then, for that remaining weight, we can decide how to take items from groups 1 and 2 optimally. Similarly, for each possible x (number of group 3 items), we can compute the best possible combination of group 1 and 2 items.\n\nBut how to compute the best combination of group 1 and 2 for a given remaining weight?\n\nFor the group 1 and 2, the problem reduces to a knapsack problem with items of weight 1 and 2, and we want to maximize the value. However, since the items are sorted, perhaps there's a way to compute this quickly.\n\nLet me think. Suppose we have a total weight capacity of W. How to select items from group 1 and group 2 to maximize the value. Let's denote the number of group 1 items as a and group 2 items as b. Then, a*1 + b*2 ≤ W. We need to maximize s1[a] + s2[b].\n\nBut how to find the optimal a and b for a given W?\n\nLet me consider that for a given W, we can try all possible numbers of group 2 items. For example, for each possible b (from 0 to min(len(s2), W//2)), then the remaining weight is W - 2*b, and we can take min(a, remaining) items from group 1. But since len(s2) could be up to 1e5, and W could be up to 3e5, this approach may be too slow if done naively for every possible x in group 3.\n\nBut perhaps we can precompute for each possible W, the maximum value of combining group 1 and 2. However, given that W can be up to m (3e5), and for each W we need to compute this, perhaps there's a way to precompute this for all possible W.\n\nAlternatively, for each possible number of group 2 items, we can compute the maximum number of group 1 items that can be taken",
    "response": "\n\nTo solve this problem efficiently, we need to maximize the total cost of souvenirs Petya can carry given a weight limit. The souvenirs have weights of 1, 2, or 3, and we can leverage this constraint to optimize our solution.\n\n---\n\n### Approach\n\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weight (1, 2, 3).\n\n2. **Sort and Compute Prefix Sums**: For each group, sort items in descending order of cost and compute prefix sums. This helps quickly determine the total cost for selecting the top `k` items from each group.\n\n3. **Iterate Over Possible Counts of Weight 3 Items**: Try all possible numbers of weight 3 items that can be included without exceeding the weight limit. For each count, compute the remaining weight and find the optimal combination of weight 1 and 2 items to fill the remaining capacity.\n\n4. **Optimize Weight 1 and 2 Combination**: For the remaining weight after using some weight 3 items, try different combinations of weight 2 and 1 items using a two-pointer technique to efficiently compute the maximum value.\n\n---\n\n### Solution Code\n\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(data[idx])\n        idx += 1\n        ci = int(data[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    # Try all possible number of weight 3 items\n    max3 = min(len(w3), m // 3)\n    for x in range(0, max3 + 1):\n        weight_used = 3 * x\n        remaining = m - weight_used\n        \n        # Now find best combination of w1 and w2 with remaining weight\n        # Let's use two pointers approach\n        i = len(w2) - 1\n        j = 0\n        best = 0\n        while i >= 0 and j < len(w1):\n            weight = 2 * (len(w2) - i) + j\n            if weight <= remaining:\n                current = s2[len(w2) - i] + s1[j]\n                if current > best:\n                    best = current\n                j += 1\n            else:\n                i -= 1\n        # Also check for all possible b in 0 to len(w2)\n        # Try all possible b (number of weight 2 items)\n        max_b = min(len(w2), remaining // 2)\n        for b in range(0, max_b + 1):\n            rem = remaining - 2 * b\n            a = min(len(w1), rem)\n            total = s2[b] + s1[a]\n            if total > best:\n                best = total\n        # Also check when taking all possible weight 1 items\n        a_max = min(len(w1), remaining)\n        total = s1[a_max]\n        if total > best:\n            best = total\n        # Also check when taking all possible weight 2 items\n        b_max = min(len(w2), remaining // 2)\n        total = s2[b_max]\n        if total > best:\n            best = total\n        \n        total_cost = s3[x] + best\n        if total_cost > max_total:\n            max_total = total_cost\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### Explanation\n\n- **Grouping and Sorting**: We group items by their weight and sort them in descending order of cost to prioritize higher-value items.\n- **Prefix Sums**: These allow us to quickly calculate the total cost of the top `k` items from any group.\n- **Combination Optimization**: For each possible number of weight 3 items, we compute the remaining weight and then use a two-pointer technique to find the optimal combination of weight 1 and 2 items.\n- **Efficiency**: The algorithm is efficient due to the limited weight values (1, 2, 3) and precomputed prefix sums, which reduce the complexity significantly compared to a brute-force approach.\n\nThis method ensures that we explore all feasible combinations and find the maximum possible total cost within the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(data[idx])\n        idx += 1\n        ci = int(data[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    # Try all possible number of weight 3 items\n    max3 = min(len(w3), m // 3)\n    for x in range(0, max3 + 1):\n        weight_used = 3 * x\n        remaining = m - weight_used\n        \n        # Now find best combination of w1 and w2 with remaining weight\n        # Let's use two pointers approach\n        i = len(w2) - 1\n        j = 0\n        best = 0\n        while i >= 0 and j < len(w1):\n            weight = 2 * (len(w2) - i) + j\n            if weight <= remaining:\n                current = s2[len(w2) - i] + s1[j]\n                if current > best:\n                    best = current\n                j += 1\n            else:\n                i -= 1\n        # Also check for all possible b in 0 to len(w2)\n        # Try all possible b (number of weight 2 items)\n        max_b = min(len(w2), remaining // 2)\n        for b in range(0, max_b + 1):\n            rem = remaining - 2 * b\n            a = min(len(w1), rem)\n            total = s2[b] + s1[a]\n            if total > best:\n                best = total\n        # Also check when taking all possible weight 1 items\n        a_max = min(len(w1), remaining)\n        total = s1[a_max]\n        if total > best:\n            best = total\n        # Also check when taking all possible weight 2 items\n        b_max = min(len(w2), remaining // 2)\n        total = s2[b_max]\n        if total > best:\n            best = total\n        \n        total_cost = s3[x] + best\n        if total_cost > max_total:\n            max_total = total_cost\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 1096,
        "thoughts_token_count": 1023
    }
}