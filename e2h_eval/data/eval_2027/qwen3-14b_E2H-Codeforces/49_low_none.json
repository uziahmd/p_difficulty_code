{
    "start": 1758309722.9881198,
    "end": 1758309767.1911879,
    "start-formatted": "2025-09-20 04:22 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this problem where I have to determine the number of mushrooms on each lawn based on the GCD and LCM values given for each road. Let's think about how to approach this.\n\nFirst, let's understand the problem. Each road between two lawns (nodes) has a GCD and LCM of the mushrooms on those two nodes. My task is to assign numbers to each node such that for every edge, the GCD and LCM match the given values. If it's not possible, output NO.\n\nHmm. So for each edge between u and v, let's say the numbers are a and b. Then, GCD(a,b) = g and LCM(a,b) = l. Also, we know that a*b = g*l. So for each edge, the product of the two node values must equal g*l. But how do I model this?\n\nThis seems like a graph problem where each edge imposes constraints on the nodes. The challenge is to assign values to nodes such that all constraints are satisfied.\n\nLet me think about the relationships. For any edge between u and v with GCD g and LCM l, the numbers on u and v must be multiples of g. Because the GCD is g. Also, since LCM is l, then both a and b must divide l. Wait, but the LCM of a and b is l. So l must be a multiple of both a and b. So for example, a and b can be expressed as g * x and g * y, where x and y are coprime. Because GCD(a,b) = g * GCD(x,y), and since the GCD is exactly g, then x and y must be coprime. And their LCM would be g*x*y. Which must equal l. So l = g * x * y. Therefore, x*y = l/g. And since x and y are coprime, this gives us that x and y are factors of l/g, and coprime.\n\nSo for each edge, the product of x and y is l/g. And since they are coprime, x and y must be such that their product is l/g, and they are coprime. But how does this help me?\n\nBut how do I assign these x and y to the nodes? Let's think of each node's value as being g multiplied by some variable. For example, if I have an edge between u and v with GCD g and LCM l, then the values of u and v must be g * x and g * y, where x and y are coprime and x*y = l/g. So, for each edge, the ratio between the two nodes' values is (x/y) or (y/x), but since x and y are coprime, perhaps there's a way to model this as a graph with constraints.\n\nWait, but how can I model this across the entire graph? Because each node can be part of multiple edges, and the values have to be consistent across all edges connected to it.\n\nThis feels like a problem where each node's value is determined up to some factors, and we need to assign variables in such a way that all constraints are met.\n\nLet me think of building a graph where each node's value is determined by a base value multiplied by some factors. For example, if I have a connected component, maybe I can assign a base value and then propagate the constraints through the edges.\n\nBut how?\n\nAlternatively, considering that for any edge between u and v, the values of u and v must be multiples of g. So for each node, its value must be a multiple of the GCDs of all edges connected to it. But that's not necessarily true. Wait, no. Because each edge has a different GCD. For example, if a node is connected to two edges, each with different GCDs, then the value of the node must be a multiple of both of those GCDs. So the value of the node must be a multiple of the LCM of all the GCDs of edges connected to it. Hmm, but maybe that's not directly helpful.\n\nAnother approach: For each edge (u, v) with GCD g and LCM l, the values of u and v must satisfy:\n\ngcd(a_u, a_v) = g and lcm(a_u, a_v) = l.\n\nWhich implies that a_u = g * x, a_v = g * y, where gcd(x, y) = 1, and x * y = l / g.\n\nSo for each edge, we can compute l/g. Let's call that k. Then x * y = k, and x and y are coprime. So for each edge, the pair (x, y) must be coprime and multiply to k.\n\nNow, since x and y are coprime, one of them must be a divisor of k, and",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on given GCD and LCM values for each road connecting two lawns. The solution involves checking if a valid configuration of mushroom counts exists that satisfies all the constraints provided by the roads.\n\n### Approach\n1. **Graph Representation**: Represent the lawns as nodes and roads as edges in a graph.\n2. **Constraints Analysis**: For each edge between two nodes (u, v) with given GCD (g) and LCM (l), the values at u and v must be multiples of g such that their product equals g * l.\n3. **Component-wise Check**: Use a Union-Find (Disjoint Set Union, DSU) structure to handle connected components of the graph. This helps in ensuring that all constraints within a component are consistent.\n4. **DFS Traversal**: Perform a Depth-First Search (DFS) from each unvisited node to assign values to nodes while respecting the constraints imposed by the edges.\n5. **Validation**: During DFS traversal, validate if the constraints can be satisfied. If any inconsistency is found, return \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    parent = list(range(n))\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        pu = find(u)\n        pv = find(v)\n        if pu != pv:\n            parent[pv] = pu\n    \n    for u, v, g, l in edges:\n        union(u, v)\n    \n    values = [None] * n\n    \n    def dfs(u, val):\n        if values[u] is not None:\n            return values[u] == val\n        values[u] = val\n        for v, g, l in graph[u]:\n            k = l // g\n            if k < 1:\n                return False\n            if values[v] is None:\n                x = val // g\n                y = k // x\n                if x * y != k or math.gcd(x, y) != 1:\n                    return False\n                if not dfs(v, g * y):\n                    return False\n            else:\n                other_val = values[v]\n                if math.gcd(val, other_val) != g or (val * other_val) != g * l:\n                    return False\n        return True\n    \n    for i in range(n):\n        if values[i] is None:\n            if len(graph[i]) == 0:\n                values[i] = 1\n            else:\n                found = False\n                for v, g, l in graph[i]:\n                    k = l // g\n                    if k < 1:\n                        print(\"NO\")\n                        return\n                    possible = []\n                    for x in range(1, int(math.isqrt(k)) + 1):\n                        if k % x == 0:\n                            y = k // x\n                            if math.gcd(x, y) == 1:\n                                possible.append((x, y))\n                                possible.append((y, x))\n                    if not possible:\n                        print(\"NO\")\n                        return\n                    for x, y in possible:\n                        a = g * x\n                        b = g * y\n                        if dfs(i, a):\n                            found = True\n                            break\n                    if not found:\n                        print(\"NO\")\n                        return\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into nodes and edges with their respective GCD and LCM values.\n2. **Union-Find Structure**: This helps in grouping nodes into connected components to ensure consistency within each component.\n3. **DFS Traversal**: Starting from each unvisited node, we use DFS to assign values to nodes. The constraints from edges are checked during traversal to ensure valid assignments.\n4. **Validation Checks**: During DFS, we check if the current assignment of values meets the GCD and LCM constraints for each edge. If any inconsistency is found, the solution outputs \"NO\".\n\nThis approach ensures that all constraints are checked efficiently, leveraging graph traversal and union-find structures to manage component consistency.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    parent = list(range(n))\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        pu = find(u)\n        pv = find(v)\n        if pu != pv:\n            parent[pv] = pu\n    \n    for u, v, g, l in edges:\n        union(u, v)\n    \n    values = [None] * n\n    \n    def dfs(u, val):\n        if values[u] is not None:\n            return values[u] == val\n        values[u] = val\n        for v, g, l in graph[u]:\n            k = l // g\n            if k < 1:\n                return False\n            if values[v] is None:\n                x = val // g\n                y = k // x\n                if x * y != k or math.gcd(x, y) != 1:\n                    return False\n                if not dfs(v, g * y):\n                    return False\n            else:\n                other_val = values[v]\n                if math.gcd(val, other_val) != g or (val * other_val) != g * l:\n                    return False\n        return True\n    \n    for i in range(n):\n        if values[i] is None:\n            if len(graph[i]) == 0:\n                values[i] = 1\n            else:\n                found = False\n                for v, g, l in graph[i]:\n                    k = l // g\n                    if k < 1:\n                        print(\"NO\")\n                        return\n                    possible = []\n                    for x in range(1, int(math.isqrt(k)) + 1):\n                        if k % x == 0:\n                            y = k // x\n                            if math.gcd(x, y) == 1:\n                                possible.append((x, y))\n                                possible.append((y, x))\n                    if not possible:\n                        print(\"NO\")\n                        return\n                    for x, y in possible:\n                        a = g * x\n                        b = g * y\n                        if dfs(i, a):\n                            found = True\n                            break\n                    if not found:\n                        print(\"NO\")\n                        return\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 550,
        "completion_token_count": 1055,
        "thoughts_token_count": 1024
    }
}