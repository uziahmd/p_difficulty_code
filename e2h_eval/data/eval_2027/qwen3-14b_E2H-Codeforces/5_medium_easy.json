{
    "start": 1758344157.2481596,
    "end": 1758344299.140043,
    "start-formatted": "2025-09-20 13:55 KST",
    "end-formatted": "2025-09-20 13:58 KST",
    "gpu": 2,
    "pid": 5,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ â€” the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to pair left and right boots such that their colors are compatible. The colors can be letters or question marks, which are wildcards. The goal is to find the maximum number of pairs possible. And then output those pairs with their indices.\n\nHmm. So first, how do I approach this? Let's think about the steps.\n\nThe main idea is to pair left boots with right boots in a way that their colors match. The question marks can match anything. But each boot can be used only once.\n\nLet me think about the strategy. Maybe I should first try to pair specific colors. Like, for each color (excluding '?'), pair as many as possible between left and right. Then handle the question marks.\n\nWait, but how to do that efficiently?\n\nLet me think of using counts. For example, for each color c (a-z), count the number of left boots with color c, and the number of right boots with color c. The minimum of these two would be the number of pairs possible for that color. But since question marks can be used as any color, maybe we need to handle them after handling the specific colors.\n\nWait, but maybe the question marks can be used to fill in the gaps. For example, if there are some left boots with color 'a' and some right boots with color 'b', but there are also some question marks on either side. But perhaps the optimal approach is to first pair all the specific colors, then use the question marks to pair with whatever is left.\n\nBut how to model this?\n\nLet me outline the steps:\n\n1. Count the number of left boots for each color (including '?').\n2. Count the number of right boots for each color (including '?').\n3. For each color c (not '?'), the number of pairs that can be formed between left[c] and right[c] is min(left[c], right[c]). But we need to assign these pairs first. However, once we pair them, we need to subtract from the counts.\n\nWait, but maybe it's better to first pair the specific colors, then use the question marks to pair with remaining specific colors, and then pair the question marks among themselves.\n\nAlternatively, here's a plan:\n\nFirst, process all non-question mark colors. For each color c (a-z), pair as many as possible between left and right. For example, if there are 3 left 'a's and 5 right 'a's, we can pair 3 of them. Then subtract those from both left and right counts.\n\nThen, after that, we have left_question_marks and right_question_marks. But also, there might be some left and right boots that have specific colors but couldn't be paired because there were not enough of the other side. For example, if left has 5 'a's and right has 3 'a's, then after pairing 3, left has 2 'a's left. Those can be paired with question marks on the right. Similarly for the other way around.\n\nSo the next step is to pair the remaining specific colors with question marks. For example, for each color c (not '?'), the remaining left[c] can be paired with the right's question marks. Similarly, the remaining right[c] can be paired with left's question marks. But how to do this optimally.\n\nWait, but the question marks can be used to pair with any. So, for example, after pairing all specific colors, we can take the remaining left's specific colors and pair them with the right's question marks, and vice versa.\n\nBut how to track which ones are left. Because the actual positions matter when outputting the pairs.\n\nBut perhaps for the purpose of counting the maximum number of pairs, we can compute the total as follows:\n\nTotal = sum over all c (non-?) of min(left[c], right[c]) + min(remaining_left_questions, remaining_right_questions) ?\n\nNo, not exactly. Because after pairing the specific colors, the remaining left and right question marks can be paired with each other, but also with the leftover specific colors.\n\nWait, here's a better approach. Let's think of the problem as:\n\nEach left boot can be paired with a right boot if:\n\nEither:\n\n- Both are specific and same.\n\nOr:\n\n- One is specific, the other is ?.\n\nOr:\n\n- Both are ?.\n\nBut how to maximize the number of pairs.\n\nSo the optimal way is to first pair as many specific colors as possible. Then, use the ? to pair with the leftover specific colors. Then pair the remaining ?s.\n\nBut how?\n\nLet me think of the following steps:\n\n1. For each color c (a-z), pair left's c with right's c. Let's say we have a count for left and right. For example, left_counts[c] and right_counts[c]. For each color, the number of pairs is the min of the two. Then subtract those from left_counts and right_counts.\n\nBut wait, after that, the left_counts and right_counts for c will be zero (if one was less than the other) or the difference. For example, if left has 3 a's and right has 5 a's, after pairing 3, left a's are zero, right a's are 2.\n\nBut now, the remaining left a's (if any) can be paired with right's ? and vice versa.\n\nSo after pairing the specific colors, the next step is to pair the remaining specific colors with ? on the other side.\n\nFor example, for each color c (non-?), the remaining left[c] can be paired with the right's ?s. Similarly, the remaining right[c] can be paired with left's ?s.\n\nOnce that is done, the remaining ?s can be paired with each other.\n\nBut how to compute this?\n\nLet me think of variables:\n\nleft_q = number of left ?s.\n\nright_q = number of right ?s.\n\nAfter pairing the specific colors, we have:\n\nFor each color c (non-?), left_remaining[c] = original left_counts[c] - min(left_counts[c], right_counts[c]).\n\nSimilarly for right_remaining[c].\n\nWait, no. Because when we pair specific colors, we take min(left_counts[c], right_counts[c]) pairs, which reduces both left_counts[c] and right_counts[c] by that amount. So the remaining left_counts[c] would be left_counts[c] - min(...), which is max(0, left_counts[c] - right_counts[c]).\n\nWait, no. Suppose left_counts[c] is 3, right_counts[c] is 5. Then min is 3. After pairing, left_counts[c] becomes 0, right_counts[c] becomes 5-3=2.\n\nSo the remaining left_counts[c] is zero, and the remaining right_counts[c] is 2.\n\nSo, after processing all specific colors, the remaining left and right counts for specific colors are:\n\nleft_remaining[c] = left_counts[c] - pairs_made (for that color). Which is max(0, left_counts[c] - right_counts[c]) ?\n\nNo. Let me rephrase: for each color c (non-?), pairs_made = min(left_counts[c], right_counts[c]). Then, after that, left_counts[c] -= pairs_made, and right_counts[c] -= pairs_made. So the remaining left_counts[c] is left_counts[c] - pairs_made, which is max(0, left_counts[c] - right_counts[c])? No, if left_counts[c] was smaller than right_counts[c], then left_counts[c] becomes zero. If left_counts[c] was larger, then it's left_counts[c] - right_counts[c].\n\nSo, after that, for all non-? colors, the left and right have some counts left. These can be paired with ?s on the other side.\n\nSo, for example, if there are left_remaining[c] (non-zero) left boots of color c, they can be paired with right's ?s. Similarly, right_remaining[c] can be paired with left's ?s.\n\nBut how much can we pair here?\n\nFor example, suppose after processing specific colors, there are L left boots of color c (non-?), and R right ?s. Then, the number of pairs possible is min(L, R). We can pair them. Similarly for the other direction.\n\nBut once we pair these, the left's ?s and right's ?s will be reduced accordingly.\n\nSo the steps are:\n\n1. Pair all specific colors between left and right.\n\n2. Pair the remaining left specific colors with right's ?s.\n\n3. Pair the remaining right specific colors with left's ?s.\n\n4. Pair the remaining ?s between left and right.\n\nBut how to compute this?\n\nLet me think about the counts.\n\nLet me denote:\n\nInitially, after step 1:\n\nleft_non_q = sum over all c (non-?) of left_counts[c]\n\nright_non_q = sum over all c (non-?) of right_counts[c]\n\nBut after step 1, the left_non_q and right_non_q are the remaining counts of non-? colors.\n\nBut in reality, after step 1, for each non-? color, left_counts[c] and right_counts[c] may have some values.\n\nBut for step 2, we can take all the left non-? colors and pair them with right's ?s. How?\n\nFor example, the total number of left non-? colors is sum_left_non_q = sum over all c (non-?) of left_counts[c]. Similarly sum_right_q is the number of right ?s after step 1.\n\nBut how much can we pair here? It's the minimum of sum_left_non_q and sum_right_q. Because each left non-? can be paired with a right ?. Similarly, for the other direction.\n\nWait, but perhaps we can pair them in a way that uses all possible.\n\nBut here's the thing: the sum_left_non_q is the number of left boots that are non-? and not yet paired. The sum_right_q is the number of right ?s not yet paired. So the number of pairs we can make here is the minimum of these two.\n\nOnce that is done, the remaining sum_left_non_q and sum_right_q will be adjusted accordingly.\n\nSimilarly for the sum_right_non_q and sum_left_q.\n\nThen, the remaining ?s on left and right can be paired. The number of pairs here is min(left_q_remaining, right_q_remaining).\n\nBut how to model this?\n\nBut perhaps I'm overcomplicating. Because the maximum possible pairs is:\n\ntotal_pairs = (specific_pairs) + (pairs between left_non_q and right_q) + (pairs between right_non_q and left_q) + (pairs between left_q and right_q).\n\nBut how to compute that?\n\nBut for the actual pairing, I need to track which boots are paired. So the problem is not just to compute the maximum number of pairs, but also to output the actual pairs.\n\nSo the challenge is not just the count, but also to find the pairs.\n\nSo, for the code, perhaps I need to:\n\n- For each color, collect the indices of left and right boots.\n\nFor example, for each color c, have a list of left indices where l[i] == c, and similarly for right.\n\nThen, for the first step (pairing specific colors):\n\nFor each color c (a-z), take the min of the number of left and right boots for c, and pair them. For example, for each left index in left_c list and right index in right_c list, pair them. Once that is done, we can remove those from the lists.\n\nBut then, after that, the remaining left and right lists for c can be used for pairing with ?s.\n\nBut how to manage this?\n\nLet me think of data structures. For example, for each color, have a list of left indices and a list of right indices. Also, have a list for left ? and right ?.\n\nSo, for example, for color 'a', left_a = [indices of left boots with 'a'], right_a = [indices of right boots with 'a'].\n\nSimilarly, left_q = [indices of left boots with '?'], right_q = [indices of right boots with '?'].\n\nThen, the first step is to pair left and right for each color. For each color c in a-z:\n\nTake the min(len(left_c), len(right_c)) pairs. For example, for each i from 0 to min-1, pair left_c[i] with right_c[i]. Then, the remaining left_c and right_c can be added to the left and right lists for ?.\n\nWait, no. Because those remaining left_c's can be paired with right_q's.\n\nBut how to manage that.\n\nAlternatively, after pairing specific colors, the remaining left and right for each color can be stored. Then, for the next step, we can pair them with ?s.\n\nBut how?\n\nLet me outline the steps again:\n\n1. For each color c (a-z), pair left_c with right_c as much as possible. For each such pair, add to the result. Then, the remaining left_c's are kept, and the remaining right_c's are kept.\n\n2. Now, for the remaining left_c's (non-?), pair them with right_q's. For each left_c in left_c's list, pair with a right_q (if available). Similarly, for the remaining right_c's, pair with left_q's.\n\n3. Then, pair the remaining left_q's with the remaining right_q's.\n\nBut how to implement this?\n\nBut for the actual pairing, we need to collect the indices. So, for each color, we need to track the available indices.\n\nBut given that n can be up to 150,000, the code needs to be efficient.\n\nBut for the purpose of generating the pairs, perhaps the order doesn't matter as long as the maximum is achieved.\n\nSo, for example, in step 1, for each color c, pair as many as possible between left and right. Let's take the first min(len(left_c), len(right_c)) pairs. For example, for left_c and right_c, we can pair the first elements.\n\nOnce that is done, for the remaining left_c, we can add them to a list of left_remaining, which can be paired with right_q. Similarly for right_remaining.\n\nBut how to track that.\n\nAlternatively, perhaps we can process the colors in a certain order, and for each step, collect the pairs.\n\nNow, for the code structure:\n\nRead n, l, r.\n\nThen, create for each color, lists of left and right indices.\n\nFor example:\n\nfrom collections import defaultdict\n\nleft_color = defaultdict(list)\nright_color = defaultdict(list)\n\nfor i in range(n):\n    c = l[i]\n    left_color[c].append(i+1)  # since the output uses 1-based indices\n\nfor i in range(n):\n    c = r[i]\n    right_color[c].append(i+1)\n\nThen, for step 1: process each color c in a-z (excluding '?'):\n\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    left_list = left_color[c]\n    right_list = right_color[c]\n    num_pairs = min(len(left_list), len(right_list))\n    for i in range(num_pairs):\n        # pair left_list[i] with right_list[i]\n        pairs.append( (left_list[i], right_list[i]) )\n    # Now, the remaining left_list and right_list can be added to other lists?\n    # Wait, no. For example, after pairing, the left_list has len(left_list) - num_pairs elements left. These are left boots of color c that could not be paired with right boots of same color. So, they need to be paired with right ?s.\n\nBut how to track these. Well, perhaps, after pairing, we can take the remaining left_list and add them to a list called left_remaining, and same for right_remaining. But perhaps that's not necessary. Instead, after step 1, for each color c, the left and right lists have the remaining elements. Then, in step 2, we can process the left_remaining (non-?) and pair them with right_q.\n\nBut how to do that.\n\nAlternatively, after step 1, the left_remaining for each color c (non-?) is left_color[c], and similarly for right. Then, for step 2:\n\nWe can take all the left_remaining for non-? colors and pair them with right_q's.\n\nSimilarly for the right_remaining.\n\nBut how to do that.\n\nLet me think:\n\nFor step 2:\n\nCollect all left_remaining (non-? colors) into a list. Let's call this left_remaining_list. Similarly, collect all right_remaining (non-? colors) into right_remaining_list. But no, perhaps not. Because the left_remaining for each color is stored in left_color[c], and the right_remaining is in right_color[c].\n\nBut for step 2, we can process each color c (non-?), and pair their left_remaining with right_q's.\n\nSo for example, for each color c in a-z:\n\n    left_list = left_color[c]\n    right_q_list = right_color['?']\n    num_pairs = min(len(left_list), len(right_q_list))\n    for i in range(num_pairs):\n        pair left_list[i] with right_q_list[i]\n    # then, remove those from right_q_list?\n\nBut this approach may not be efficient. Because after pairing some of the right_q_list, the remaining can be used for other left_remaining.\n\nBut how to track that. Maybe the right_q_list is stored as a list, and for each step, we can pop elements as needed.\n\nBut perhaps a better way is to have for the right_q, a pointer indicating how many are left. For example, we can have a list for right_q, and track the current index. Similarly for left_q.\n\nBut this seems complicated.\n\nAlternatively, during step 2, for all left_remaining (non-? colors), pair them with right_q's as much as possible. Then, for all right_remaining (non-? colors), pair them with left_q's as much as possible. Then, pair the remaining q's.\n\nBut how to implement this.\n\nLet me think of the following:\n\nAfter step 1, we have left_color and right_color with their remaining elements.\n\nNow, for step 2, we can process the left_remaining (non-?) colors and pair them with right_q's.\n\nLet me take the right_q list (right_color['?']). For each color c in a-z:\n\n    left_list = left_color[c]\n    if len(left_list) > 0 and len(right_q) > 0:\n        num_pairs = min(len(left_list), len(right_q))\n        for i in range(num_pairs):\n            pair left_list[i] with right_q[i]\n        # remove those from right_q\n        right_q = right_q[num_pairs:]\n\nBut this is not correct, because the right_q list is being modified. However, perhaps we can process all left_remaining colors and pair them with right_q, and then process the right_remaining colors and pair them with left_q.\n\nWait, but in this case, the order matters. For example, if you process left_remaining first, then the right_q is reduced, and when processing right_remaining, the left_q may be processed.\n\nBut how to do this.\n\nAlternatively, collect all the left_remaining (non-?) into a single list, and pair them with right_q. Similarly for the right_remaining.\n\nBut how to collect them. For example:\n\nleft_non_q = []\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    left_non_q.extend(left_color[c])\n\nSimilarly for right_non_q.\n\nBut then, for step 2, we can pair left_non_q with right_q as much as possible.\n\nBut how to pair them. For example, for each element in left_non_q, pair with a right_q element.\n\nBut how to do this. For example, for each left in left_non_q, take a right_q element (if any) and pair them.\n\nBut in code:\n\nleft_non_q = []\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    left_non_q.extend(left_color[c])\n\nright_q = right_color['?']\n\npairs = []\nfor i in range(min(len(left_non_q), len(right_q))):\n    pairs.append( (left_non_q[i], right_q[i]) )\n\nBut wait, this would pair the first elements of left_non_q with the first elements of right_q.\n\nBut then, after this, the remaining left_non_q and right_q can be processed.\n\nBut then, for the right_non_q (the non-? right boots that are left after step 1), we can pair them with left_q.\n\nSimilarly:\n\nright_non_q = []\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    right_non_q.extend(right_color[c])\n\nleft_q = left_color['?']\n\nfor i in range(min(len(right_non_q), len(left_q))):\n    pairs.append( (left_q[i], right_non_q[i]) )\n\nThen, the remaining left_q and right_q can be paired with each other.\n\nBut how to collect the remaining left_q and right_q.\n\nWait, but after the first two steps, the left_non_q and right_non_q are already processed. So the left_q and right_q may have some elements left.\n\nBut how to collect them. For example, after step 1, left_color['?'] is the list of left boots with '?', and right_color['?'] is the list of right boots with '?'.\n\nBut during step 2, we took some of the right_q to pair with left_non_q. So after that, the right_q is reduced. Similarly for left_q during step 3.\n\nBut how to track that.\n\nAlternatively, during step 2, we can take the left_non_q and right_q, and pair as much as possible. Then, for step 3, take the right_non_q and left_q and pair as much as possible. Then, for step 4, pair the remaining left_q and right_q.\n\nBut how to track the remaining elements.\n\nThis seems complicated. Perhaps a better approach is to manage the lists as we go.\n\nLet me think again.\n\nAfter step 1, we have:\n\nleft_color contains for each color (including '?') the list of indices of left boots with that color. Similarly for right_color.\n\nSo, for step 2, we can take all the left_color entries for non-? colors and try to pair them with right_color['?'].\n\nBut how to do that.\n\nLet me think of the following code:\n\n# Step 2: Pair left non-? with right ?\nleft_non_q = []\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    left_non_q.extend(left_color[c])\n\nright_q = right_color['?']\n\n# Now, pair as many as possible between left_non_q and right_q\nnum_pairs = min(len(left_non_q), len(right_q))\nfor i in range(num_pairs):\n    pairs.append( (left_non_q[i], right_q[i]) )\n\n# Now, the remaining left_non_q and right_q are not used here.\n\nBut wait, this would take the first num_pairs elements of left_non_q and right_q. But after that, the remaining elements in left_non_q are not processed. However, in this approach, after step 2, the left_non_q is not modified. So perhaps we need to modify the lists. But this is not feasible if we have already extended them into left_non_q.\n\nThis suggests that perhaps the approach of creating new lists is not efficient. So, perhaps, instead, we need to process the left_color and right_color in a way that allows us to track which elements have been used.\n\nAlternatively, perhaps we can process the left and right colors as follows:\n\nFor each color c in a-z:\n\n    while there are elements in left_color[c] and right_color['?']:\n\n        pair left_color[c][0] with right_color['?'][0]\n\n        remove those elements from their respective lists.\n\nBut this would require modifying the lists. However, for large n, popping from the front of a list is O(n) time, which is not efficient. So perhaps using a deque would be better.\n\nBut for the code, perhaps the following steps can be taken:\n\nInitialize for each color, a deque for left and right.\n\nThen, during step 1, for each color c:\n\n    while left_deque[c] and right_deque[c]:\n\n        pair them.\n\n        pop left from left_deque[c], pop left from right_deque[c].\n\nThen, for step 2, for each color c in a-z:\n\n    while left_deque[c] and right_deque['?']:\n\n        pair left_deque[c].popleft() with right_deque['?'].popleft()\n\nSimilarly for step 3, for each color c in a-z:\n\n    while right_deque[c] and left_deque['?']:\n\n        pair left_deque['?'].popleft() with right_deque[c].popleft()\n\nThen, for step 4, pair the remaining left_deque['?'] and right_deque['?']:\n\n    while left_deque['?'] and right_deque['?']:\n\n        pair left_deque['?'].popleft() with right_deque['?'].popleft()\n\nThis approach would work, but requires using deques for each color.\n\nBut how to implement this.\n\nIn Python, for each color, we can have a deque. Let's think of the code:\n\nfrom collections import defaultdict, deque\n\nn = int(input())\nl = input().strip()\nr = input().strip()\n\nleft = defaultdict(deque)\nright = defaultdict(deque)\n\nfor i in range(n):\n    c = l[i]\n    left[c].append(i+1)  # 1-based index\n\nfor i in range(n):\n    c = r[i]\n    right[c].append(i+1)\n\npairs = []\n\n# Step 1: Pair same color\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    while left[c] and right[c]:\n        a = left[c].popleft()\n        b = right[c].popleft()\n        pairs.append( (a, b) )\n\n# Step 2: Pair left non-? with right ?\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    while left[c] and right['?']:\n        a = left[c].popleft()\n        b = right['?'].popleft()\n        pairs.append( (a, b) )\n\n# Step 3: Pair right non-? with left ?\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    while right[c] and left['?']:\n        a = left['?'].popleft()\n        b = right[c].popleft()\n        pairs.append( (a, b) )\n\n# Step 4: Pair remaining ? with ?\nwhile left['?'] and right['?']:\n    a = left['?'].popleft()\n    b = right['?'].popleft()\n    pairs.append( (a, b) )\n\nprint(len(pairs))\nfor a, b in pairs:\n    print(a, b)\n\nWait, but what about the order of processing the colors in step 2 and step 3? For example, in step 2, we process each color in order, and pair as much as possible. This should be okay.\n\nBut let's test this approach with an example.\n\nTake the first sample input:\n\nSample Input 1:\n\n10\ncodeforces\ndodivthree\n\nSample Output is 5.\n\nBut let's see. Let's think about the first sample.\n\nBut perhaps it's easier to think of another example.\n\nLet me think of a small example.\n\nExample:\n\nn=2\n\nl = \"a?\"\n\nr = \"?a\"\n\nSo, l is ['a', '?'] and r is ['?', 'a'].\n\nStep 1: process same color.\n\nFor 'a':\n\nleft['a'] has [1], right['a'] has [2]. So pair them. So pairs is [(1,2)].\n\nThen, step 2: process left non-? (which is 'a' is already processed. left['a'] is empty. Then, for other colors, nothing. Then, step 2 does nothing.\n\nStep 3: process right non-? (which is 'a' has been processed. right['a'] is empty. So step 3 does nothing.\n\nStep 4: left['?'] is [2], right['?'] is [1]. Pair them. So pairs is [(1,2), (2,1)]? Wait, but that's impossible because each boot can be used once. Wait, in this case, after step 1, the left['?'] is [2], and right['?'] is [1].\n\nBut in step 4, we pair them. So the pairs would be [(1,2), (2,1)]? But that's impossible because the second pair would use the same right boot (index 1) again. Wait, no. Let me think.\n\nOriginal left is [a, ?], right is [?, a].\n\nIn step 1, we pair left[0] (a) with right[1] (a). So left's ? is index 1 (original index 2?), and right's ? is index 0 (original index 1).\n\nThen, step 4: left['?'] is [2], right['?'] is [1]. So pair them. So the pairs are (1,2) and (2,1). But this would use the right boot 2 (the original index 2?), no. Wait, the right's ? is index 0 (original index 1). So in step 4, the pair is (2, 1). So the pairs are (1,2) and (2,1). But that would use the left boot 2 and right boot 1. Which is allowed. But the problem says that each boot can be part of at most one pair. So in this case, the first pair uses left 1 and right 2. The second pair uses left 2 and right 1. So that's valid. So the answer is 2 pairs.\n\nBut in reality, the maximum possible is 2. Which is correct.\n\nBut according to the code, the pairs would be (1,2) and (2,1). Which is correct.\n\nAnother example: n=1, l is '?', r is '?'. Then, step 1 does nothing. step 2 does nothing. step 3 does nothing. step 4 pairs them. So output is 1 pair.\n\nAnother example: n=1, l is 'a', r is '?'. Then, step 1: left['a'] has [1], right['a'] is empty. So step 1 does nothing. step 2: process left non-? (a). left['a'] has [1], right['?'] has [1]. So pair them. So pairs is [(1,1)]. Correct.\n\nSo the code seems to handle these cases.\n\nBut what about the case where after step 1, there are some left non-? and right non-? that could be paired with ?s.\n\nAnother example: n=3.\n\nl = ['a', 'a', '?'].\n\nr = ['?', 'b', 'b'].\n\nStep 1: for color 'a', left has 2, right has 0. So nothing. For 'b', left has 0, right has 2. So nothing. So step 1 does nothing.\n\nStep 2: process each color. For 'a', left has 2 elements. right['?'] has 1 element. So pair 1 element. So pair left[0] (a) with right['?'][0] (index 0). Then, left['a'] has 1 element left. step 2 proceeds to other colors.\n\nstep 3: process right non-? (b). right['b'] has 2 elements. left['?'] has 1 element. So pair 1 element. So pair left['?'][0] (index 2) with right['b'][0] (index 1). Now, right['b'] has 1 element left. step 3 proceeds to other colors.\n\nstep 4: left['?'] is empty. right['?'] is empty. So nothing.\n\nThus, total pairs is 2.\n\nBut what about the remaining left['a'] and right['b']? They can't be paired. So the code correctly returns 2 pairs.\n\nSo the code seems to handle that.\n\nAnother example where step 4 pairs ?s.\n\nSo the code seems to handle all the steps.\n\nBut what about the order of processing the colors in step 2 and 3? For example, if there are multiple colors, processing them in order may affect how many pairs are made. But since we are processing all colors in a-z order, and pairing as much as possible, it should be okay.\n\nThus, this approach should work.\n\nNow, considering the code's efficiency. For n up to 150,000, and each character processed once, the code should be O(n) time, as each boot is processed once in the deques.\n\nBut in Python, using deque.popleft() is O(1) time. So the code should be efficient enough.\n\nNow, the code must read the input correctly. The input is given as:\n\nThe first line is n.\n\nSecond line is l.\n\nThird line is r.\n\nBut in the sample input given in the problem statement, there are multiple test cases. Wait, looking back:\n\nThe problem says:\n\nThe input is given as:\n\nThe first line contains n.\n\nSecond line contains l.\n\nThird line contains r.\n\nBut the sample input shows something different. Wait, looking back:\n\nThe sample input is given as:\n\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\nWhich seems to be four test cases. But the problem says that the input is for a single test case. Wait, perhaps the sample input is a list of multiple test cases, but the actual code is supposed to read one test case per run. So the user probably made a mistake in formatting the sample input. But according to the problem statement, the input is for one test case. So the code should read n, then l, then r.\n\nThus, the code should read:\n\nn = int(input())\n\nl = input().strip()\n\nr = input().strip()\n\nBut in the sample input, perhaps the user provided multiple test cases as examples, but the actual code should handle one per run.\n\nThus, the code should read n, l, r as per the problem statement.\n\nNow, the code in Python would be:\n\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n\n    left = defaultdict(deque)\n    right = defaultdict(deque)\n\n    for i in range(n):\n        c = l[i]\n        left[c].append(i+1)  # 1-based index\n\n    for i in range(n):\n        c = r[i]\n        right[c].append(i+1)\n\n    pairs = []\n\n    # Step 1: Pair same color\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while left[c] and right[c]:\n            a = left[c].popleft()\n            b = right[c].popleft()\n            pairs.append( (a, b) )\n\n    # Step 2: Pair left non-? with right ?\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while left[c] and right['?']:\n            a = left[c].popleft()\n            b = right['?'].popleft()\n            pairs.append( (a, b) )\n\n    # Step 3: Pair right non-? with left ?\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while right[c] and left['?']:\n            a = left['?'].popleft()\n            b = right[c].popleft()\n            pairs.append( (a, b) )\n\n    # Step 4: Pair remaining ? with ?\n    while left['?'] and right['?']:\n        a = left['?'].popleft()\n        b = right['?'].popleft()\n        pairs.append( (a, b) )\n\n    print(len(pairs))\n    for a, b in pairs:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()\n\nBut wait, what about the case where a left ? is paired with a right non-? in step 3. For example, if right has a color c and left has ?. Then, the code takes left['?'] and pairs with right[c].\n\nYes.\n\nTesting this code with the sample input:\n\nSample Input 1:\n\n10\ncodeforces\ndodivthree\n\nBut I can't compute the exact output, but the code should generate the correct maximum pairs.\n\nAnother sample input is the third one, which outputs 0. For example, if the left and right have no compatible pairs.\n\nBut according to the code, that would be handled correctly.\n\nBut what about the case where there are multiple ways to pair, but the code chooses one of them. The problem says that any correct output is acceptable.\n\nThus, this code should handle all cases.\n\nBut what about the case where a left ? is paired with a right ? in step 4. That's handled.\n\nNow, for the code's efficiency. For n=150000, the code is O(n) time, since each boot is processed once. The loops for the 26 letters are O(26 * n) which is acceptable.\n\nThus, this code should work.\n",
    "response": "To solve this problem, we need to determine the maximum number of compatible pairs of boots (left and right) based on their colors, where a color can be a specific lowercase letter or a wildcard ('?'). The wildcard can match any color, including another wildcard.\n\n### Approach\n1. **Color Matching**: First, we pair left boots with right boots that have the same specific color.\n2. **Wildcard Pairing**: After handling specific colors, we use wildcards to pair remaining specific color boots with wildcards from the opposite side.\n3. **Remaining Wildcards**: Finally, pair any remaining wildcards from both sides.\n\nThe approach involves using deques to efficiently manage the indices of each color for both left and right boots. This allows us to process each color in sequence and efficiently pop elements from the front of the deque as we form pairs.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n\n    left = defaultdict(deque)\n    right = defaultdict(deque)\n\n    for i in range(n):\n        c = l[i]\n        left[c].append(i + 1)  # 1-based index\n\n    for i in range(n):\n        c = r[i]\n        right[c].append(i + 1)\n\n    pairs = []\n\n    # Step 1: Pair same color\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while left[c] and right[c]:\n            a = left[c].popleft()\n            b = right[c].popleft()\n            pairs.append((a, b))\n\n    # Step 2: Pair left non-? with right ?\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while left[c] and right['?']:\n            a = left[c].popleft()\n            b = right['?'].popleft()\n            pairs.append((a, b))\n\n    # Step 3: Pair right non-? with left ?\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while right[c] and left['?']:\n            a = left['?'].popleft()\n            b = right[c].popleft()\n            pairs.append((a, b))\n\n    # Step 4: Pair remaining ? with ?\n    while left['?'] and right['?']:\n        a = left['?'].popleft()\n        b = right['?'].popleft()\n        pairs.append((a, b))\n\n    print(len(pairs))\n    for a, b in pairs:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, including the number of boots and their respective color strings.\n2. **Deque Initialization**: We use deques to store indices of each color for both left and right boots, allowing efficient popping from the front.\n3. **Pairing Specific Colors**: For each color from 'a' to 'z', we pair as many left and right boots as possible.\n4. **Wildcard Pairing**: After handling specific colors, we use wildcards to pair remaining specific color boots from the left with wildcards on the right and vice versa.\n5. **Final Wildcard Pairing**: Any remaining wildcards are paired with each other.\n\nThis approach ensures that we maximize the number of compatible pairs by leveraging specific color matches first and then using wildcards to fill in the gaps, ensuring an optimal solution efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n\n    left = defaultdict(deque)\n    right = defaultdict(deque)\n\n    for i in range(n):\n        c = l[i]\n        left[c].append(i + 1)  # 1-based index\n\n    for i in range(n):\n        c = r[i]\n        right[c].append(i + 1)\n\n    pairs = []\n\n    # Step 1: Pair same color\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while left[c] and right[c]:\n            a = left[c].popleft()\n            b = right[c].popleft()\n            pairs.append((a, b))\n\n    # Step 2: Pair left non-? with right ?\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while left[c] and right['?']:\n            a = left[c].popleft()\n            b = right['?'].popleft()\n            pairs.append((a, b))\n\n    # Step 3: Pair right non-? with left ?\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while right[c] and left['?']:\n            a = left['?'].popleft()\n            b = right[c].popleft()\n            pairs.append((a, b))\n\n    # Step 4: Pair remaining ? with ?\n    while left['?'] and right['?']:\n        a = left['?'].popleft()\n        b = right['?'].popleft()\n        pairs.append((a, b))\n\n    print(len(pairs))\n    for a, b in pairs:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 717,
        "thoughts_token_count": 7881
    }
}