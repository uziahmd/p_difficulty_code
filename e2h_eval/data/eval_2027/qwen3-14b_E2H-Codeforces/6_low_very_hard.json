{
    "start": 1758008330.459637,
    "end": 1758008523.4013505,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:42 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The task is to find two non-overlapping vouchers whose total duration is exactly x, and their combined cost is minimal. If there's no such pair, return -1.\n\nFirst, I need to understand the problem correctly. So each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need two vouchers i and j where their durations add up to x. Also, they must not overlap. That means either the first ends before the second starts, or vice versa.\n\nSo the approach would be to find all pairs of vouchers where the sum of their durations is x, and they don't overlap, then find the minimum cost among those pairs.\n\nBut with n up to 2e5, checking all possible pairs would be O(n²), which is way too slow. So we need a smarter approach.\n\nLet me think. For each voucher, if I can find another voucher that has duration (x - duration_i) and doesn't overlap with it, then I can consider their sum. But how to efficiently find such vouchers?\n\nLet me break it down. Let's say for each voucher, we check if there exists a voucher with duration d = x - duration_i. Then, for each such voucher, we need to find one that starts after the first ends, or ends before the first starts.\n\nBut how to efficiently find the minimal cost for these possibilities?\n\nMaybe pre-process vouchers by their duration. For example, group vouchers by their duration. Then, for each voucher with duration d, look into the group of vouchers with duration (x - d), and check if any of them are non-overlapping.\n\nBut even that could be time-consuming if done naively. So perhaps for each duration, we can keep track of the minimal cost for vouchers that end before a certain day, or start after a certain day.\n\nAlternatively, for each voucher, we can consider two cases:\n\nCase 1: The first voucher is before the second. So the first voucher ends at ri, and the second starts at lj >= ri + 1. The durations of the two vouchers add up to x.\n\nCase 2: The second voucher is before the first. So the second voucher ends at rj, and the first starts at li >= rj + 1.\n\nSo for each voucher, we need to find vouchers with the required duration that are either entirely before or after it.\n\nBut how to do this efficiently?\n\nLet's think about the following steps:\n\n1. Precompute for each possible duration d, the list of vouchers with that duration. Since the maximum possible duration is up to 2e5 (since ri can be up to 2e5 and li can be 1, so duration is up to 2e5). So for each d, we can have a list of vouchers with that duration.\n\n2. For each voucher i with duration d, check if there exists a duration (x - d). If not, skip. Otherwise, for each voucher j in the group of (x - d), check if they are non-overlapping with voucher i. However, checking all j's in that group for each i would be O(n^2) in worst case.\n\nBut that's not feasible. So we need a way to find, for a given voucher i, the minimal cost of vouchers in the group (x - d) that end before li (so that voucher j ends before voucher i starts), or start after ri (so that voucher j starts after voucher i ends).\n\nWait, for case 1 where voucher i is before voucher j: voucher i's duration is d, voucher j's duration is x - d. So voucher i ends at ri, and voucher j starts at lj >= ri + 1. So for voucher j, we need lj >= ri + 1. Similarly, for case 2 where voucher j is before voucher i: voucher j ends at rj <= li - 1.\n\nSo for each voucher i, we can check two possibilities:\n\n- Find vouchers of duration (x - d_i) that end before li (so that they can be placed before i). The minimal cost of such vouchers.\n\n- Find vouchers of duration (x - d_i) that start after ri (so that they can be placed after i). The minimal cost of such vouchers.\n\nThen, for each voucher i, we can compute the minimal possible cost from these two possibilities, and keep track of the global minimum.\n\nBut how do we efficiently find the minimal cost of vouchers with duration (x - d_i) that end before a certain value (li - 1), or start after a certain value (ri + 1)?\n\nThis seems like a problem that can be solved with some preprocessing.\n\nFor example, for each duration d, we can have two sorted lists:\n\n- One sorted by end date (ri), and for each end date, we can have the minimal cost up to that end date.\n\n- Another sorted",
    "response": "\n\nTo solve this problem efficiently, we need to find two non-overlapping vouchers whose combined duration equals a given value `x` and whose total cost is minimized. The solution involves preprocessing vouchers by their duration and using sorted data structures to quickly query the minimum cost of vouchers that meet specific criteria.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This helps in quickly accessing vouchers of a specific duration when needed.\n2. **Sort Vouchers by End and Start Dates**: For each duration, maintain two sorted lists:\n   - One sorted by the end date (`ri`) to efficiently find vouchers that end before a given date.\n   - Another sorted by the start date (`li`) to efficiently find vouchers that start after a given date.\n3. **Prefix Minimum Arrays**: For each sorted list of vouchers by end date, maintain a prefix minimum array to quickly find the minimum cost of vouchers ending before a certain date.\n4. **Check Non-overlapping Pairs**: For each voucher, check if there exists another voucher with the required complementary duration. Use the preprocessed data to find the minimum cost of non-overlapping vouchers efficiently.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end date and create prefix min cost\n    # Also sort by start date and create suffix min cost?\n    # For each duration, we will have:\n    # - sorted_end: list of (end, cost), sorted by end\n    # - prefix_min: list where prefix_min[i] is the minimum cost up to index i in sorted_end\n    # Similarly, sorted_start: list of (start, cost), sorted by start\n    # and suffix_min: list where suffix_min[i] is the minimum cost from index i to end in sorted_start\n    \n    duration_info = dict()\n    \n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end date\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start date\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min\n        suffix_min = [0]*len(sorted_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_start[i][2])\n            suffix_min[i] = min_so_far\n        duration_info[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d not in duration_info:\n            continue\n        \n        # Case 1: find vouchers with duration target_d that end before l\n        # So their end <= l-1\n        sorted_end, prefix_min, sorted_start, suffix_min = duration_info[target_d]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l-1) - 1\n        if pos >= 0:\n            min_cost_before = prefix_min[pos]\n            min_total = min(min_total, min_cost_before + cost)\n        \n        # Case 2: find vouchers with duration target_d that start after r\n        # So their start >= r+1\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(starts, r+1)\n        if pos < len(sorted_start):\n            min_cost_after = suffix_min[pos]\n            min_total = min(min_total, min_cost_after + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with its start date, end date, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n3. **Sorting and Prefix/Suffix Minimum Arrays**: For each duration, vouchers are sorted by their end date and start date. Prefix minimum arrays are created for end-sorted lists to quickly find the minimum cost of vouchers ending before a certain date. Similarly, suffix minimum arrays are created for start-sorted lists to find the minimum cost of vouchers starting after a certain date.\n4. **Finding Valid Pairs**: For each voucher, we check if there exists another voucher with the complementary duration that either ends before the current voucher starts or starts after the current voucher ends. The minimum costs are computed and tracked to find the overall minimum.\n\nThis approach ensures efficient querying and minimizes the complexity, making it feasible to handle large input sizes within the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end date and create prefix min cost\n    # Also sort by start date and create suffix min cost?\n    # For each duration, we will have:\n    # - sorted_end: list of (end, cost), sorted by end\n    # - prefix_min: list where prefix_min[i] is the minimum cost up to index i in sorted_end\n    # Similarly, sorted_start: list of (start, cost), sorted by start\n    # and suffix_min: list where suffix_min[i] is the minimum cost from index i to end in sorted_start\n    \n    duration_info = dict()\n    \n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end date\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start date\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min\n        suffix_min = [0]*len(sorted_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_start[i][2])\n            suffix_min[i] = min_so_far\n        duration_info[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d not in duration_info:\n            continue\n        \n        # Case 1: find vouchers with duration target_d that end before l\n        # So their end <= l-1\n        sorted_end, prefix_min, sorted_start, suffix_min = duration_info[target_d]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l-1) - 1\n        if pos >= 0:\n            min_cost_before = prefix_min[pos]\n            min_total = min(min_total, min_cost_before + cost)\n        \n        # Case 2: find vouchers with duration target_d that start after r\n        # So their start >= r+1\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(starts, r+1)\n        if pos < len(sorted_start):\n            min_cost_after = suffix_min[pos]\n            min_total = min(min_total, min_cost_after + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1238,
        "thoughts_token_count": 1023
    }
}