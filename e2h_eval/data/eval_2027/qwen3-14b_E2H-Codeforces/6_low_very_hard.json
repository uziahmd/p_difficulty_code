{
    "start": 1758313550.175955,
    "end": 1758313770.767474,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, the problem is about Leha wanting to choose two vouchers such that their durations add up exactly to x days, and they don't overlap. And we have to find the minimal total cost of such two vouchers, or return -1 if impossible.\n\nFirst, let's understand the constraints. For each voucher, the duration is ri - li + 1. So, for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li). \n\nThe approach here needs to be efficient because n can be up to 2e5. So O(n^2) is definitely out of the question. We need something smarter.\n\nLet me think. How can I find pairs of vouchers where their durations sum to x, and they are non-overlapping?\n\nFirst, for each voucher, let's compute its duration. Let's call it d_i = ri - li + 1. Then, for each voucher i, we need another voucher j such that d_i + d_j = x. And the vouchers don't overlap.\n\nSo the idea is: for each voucher, check if there exists another voucher with duration (x - d_i), and that they don't overlap.\n\nBut how do we efficiently find the minimum cost for such pairs?\n\nLet me think about grouping vouchers by their duration. For example, for each possible duration d, we can keep a list of vouchers with that duration, along with their start and end times and their cost.\n\nThen, for each voucher with duration d, we look for vouchers with duration (x - d). But since x can be up to 2e5, and for each voucher, we have to check for (x - d) in the map. But how to find the best pair?\n\nBut even then, for each voucher i with duration d, we need to find a voucher j with duration (x - d) that doesn't overlap with i. And among all such j's, find the one with the minimal cost. Then, for each i, compute the minimal possible cost for j, and track the overall minimum.\n\nBut how to find the minimal cost j for a given i?\n\nLet me think. Suppose I have a voucher i with duration d, and I need to find vouchers with duration (x - d). Let's call that target duration t = x - d. So for each voucher i, we need to find the minimal cost voucher j with duration t that does not overlap with i.\n\nBut how to find such j's quickly?\n\nFor each duration t, perhaps we can pre-process the vouchers with that duration. For example, for each t, we can store the vouchers sorted by their end time (or start time?), and for a given voucher i, find the earliest possible voucher j that ends before i's start, or the earliest that starts after i's end. But how?\n\nAlternatively, for each duration t, we can keep track of the minimal cost for vouchers that end before a certain time, or start after a certain time.\n\nWait, for a voucher i with [li, ri], we need to find a voucher j with duration t such that either rj < li (so j ends before i starts) or lj > ri (so j starts after i ends). \n\nSo for each voucher i with duration d, and target t = x - d, we need to find the minimal cost among vouchers of duration t that end before li, or start after ri.\n\nBut how can we query that quickly?\n\nLet's think for each duration t, we can have two structures:\n\n- A sorted list of vouchers' end times, along with their minimal cost up to that end time. For example, for vouchers of duration t, sorted by their end time. For any given li, we can find all vouchers j with end time < li. Among those, we want the minimal cost. Similarly, for vouchers of duration t, sorted by their start time, for any given ri, find all vouchers j with start time > ri, and get the minimal cost.\n\nBut how to precompute that?\n\nFor example, for each duration t, we can pre-process two arrays:\n\n- For vouchers with duration t, sorted by end time. And for each position in this sorted array, we can keep track of the minimum cost up to that point. So when we want to find the minimal cost of vouchers ending before a certain value, we can binary search for the largest end time less than li, and then take the min cost up to that index.\n\nSimilarly, for the other condition: vouchers starting after ri. For that, we can sort the vouchers of duration t by start time, and for each position, keep track of the minimum cost from that index onwards. Then, for a given ri, we can binary search for",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, and whose total cost is minimized. The solution involves efficiently checking for valid voucher pairs using preprocessing and binary search techniques.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This allows us to quickly access all vouchers of a specific duration when needed.\n2. **Preprocess for Efficient Querying**: For each duration, preprocess the vouchers to allow efficient querying of minimum costs. Specifically, for each duration, maintain two sorted lists:\n   - One sorted by end time, with prefix minimum costs.\n   - One sorted by start time, with suffix minimum costs.\n3. **Check Valid Pairs**: For each voucher, check if there exists another voucher with the complementary duration such that they do not overlap. Use binary search on the preprocessed lists to quickly find the minimum valid costs.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    duration_map = defaultdict(list)\n    \n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n    \n    # Preprocess each duration's data\n    # For each duration t, we have:\n    # - sorted_end: list of (end, min_cost_up_to_here)\n    # - sorted_start: list of (start, min_cost_from_here)\n    # We also need to sort and compute min_prefix and min_suffix\n    preprocessed = dict()\n    \n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        min_prefix = []\n        min_val = float('inf')\n        for item in sorted_end:\n            min_val = min(min_val, item[2])\n            min_prefix.append(min_val)\n        # Sort by start time\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        min_suffix = [0]*len(sorted_start)\n        min_val = float('inf')\n        for i in reversed(range(len(sorted_start))):\n            min_val = min(min_val, sorted_start[i][2])\n            min_suffix[i] = min_val\n        preprocessed[d] = (sorted_end, min_prefix, sorted_start, min_suffix)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target = x - d\n        if target not in preprocessed:\n            continue\n        # Check for vouchers with duration target that end before l\n        sorted_end, min_prefix, _, _ = preprocessed[target]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l-1) - 1\n        if pos >= 0:\n            min_cost = min_prefix[pos]\n            min_total = min(min_total, cost + min_cost)\n        # Check for vouchers with duration target that start after r\n        _, _, sorted_start, min_suffix = preprocessed[target]\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r)\n        if pos < len(sorted_start):\n            min_cost = min_suffix[pos]\n            min_total = min(min_total, cost + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vouchers, each characterized by their start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n3. **Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix and suffix minimum cost arrays are computed to allow efficient range minimum queries.\n4. **Finding Valid Pairs**: For each voucher, we check if there exists a voucher of the complementary duration that ends before the current voucher starts or starts after the current voucher ends. Binary search is used to efficiently find valid candidates and their minimum costs.\n\nThis approach ensures that we efficiently check all possible valid pairs while keeping the complexity manageable, leading to an optimal solution for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    duration_map = defaultdict(list)\n    \n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n    \n    # Preprocess each duration's data\n    # For each duration t, we have:\n    # - sorted_end: list of (end, min_cost_up_to_here)\n    # - sorted_start: list of (start, min_cost_from_here)\n    # We also need to sort and compute min_prefix and min_suffix\n    preprocessed = dict()\n    \n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        min_prefix = []\n        min_val = float('inf')\n        for item in sorted_end:\n            min_val = min(min_val, item[2])\n            min_prefix.append(min_val)\n        # Sort by start time\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        min_suffix = [0]*len(sorted_start)\n        min_val = float('inf')\n        for i in reversed(range(len(sorted_start))):\n            min_val = min(min_val, sorted_start[i][2])\n            min_suffix[i] = min_val\n        preprocessed[d] = (sorted_end, min_prefix, sorted_start, min_suffix)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target = x - d\n        if target not in preprocessed:\n            continue\n        # Check for vouchers with duration target that end before l\n        sorted_end, min_prefix, _, _ = preprocessed[target]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l-1) - 1\n        if pos >= 0:\n            min_cost = min_prefix[pos]\n            min_total = min(min_total, cost + min_cost)\n        # Check for vouchers with duration target that start after r\n        _, _, sorted_start, min_suffix = preprocessed[target]\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r)\n        if pos < len(sorted_start):\n            min_cost = min_suffix[pos]\n            min_total = min(min_total, cost + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1021,
        "thoughts_token_count": 1024
    }
}