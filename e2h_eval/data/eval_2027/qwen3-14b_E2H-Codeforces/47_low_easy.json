{
    "start": 1758309555.1863475,
    "end": 1758309611.269107,
    "start-formatted": "2025-09-20 04:19 KST",
    "end-formatted": "2025-09-20 04:20 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest k.\n\nHmm. Let me think about how to approach this. \n\nFirst, let's note that when you add k to both a and b, the two numbers become a + k and b + k. Let me denote x = a + k and y = b + k. Then, since x and y differ by (b - a), because x - y = (a +k) - (b +k) = a - b. Wait, no, if a and b are given, then x = a +k, y = b +k. So x - y = a - b. So the difference between x and y is fixed as (a - b). Let me call the difference d = |a - b|. So without loss of generality, let's assume that a ≤ b. Then, the difference between the two numbers is (b - a). Let me say that d = b - a. Then, the two numbers are x and x + d, where x = a +k. Because if a is smaller than b, then adding k to both gives x and x + d. \n\nSo the problem reduces to finding x such that LCM(x, x + d) is minimized, and then find the corresponding k which is x - a (since x = a +k → k = x -a). But since k has to be non-negative, x must be at least a. Also, since x can be any number ≥ a, but we need to find the x that minimizes LCM(x, x +d).\n\nWait, but what if a is larger than b? Well, we can just swap them. Because the problem is symmetric in a and b. So first, let me sort a and b. Let me assume that a ≤ b. So d = b - a. Then, the problem is to find x ≥ a (since k is non-negative) such that LCM(x, x +d) is minimized. Then, the minimal k is x - a.\n\nBut how do I find this x?\n\nLet me think about LCM(x, x +d). Since x and x +d have a difference of d, their GCD is the same as GCD(x, d). Because GCD(x, x +d) = GCD(x, d). So, LCM(x, x +d) = x * (x +d) / GCD(x, x +d) = x*(x+d)/g, where g is GCD(x, d). \n\nBut since d is fixed, perhaps we can find x such that GCD(x, d) is as large as possible. Because that would make the LCM smaller. Because for fixed x and x +d, the larger the GCD, the smaller the LCM.\n\nSo, the idea is to find x such that GCD(x, d) is as large as possible. But how?\n\nAlternatively, since x and x +d have GCD equal to GCD(x, d), then the LCM is (x*(x +d))/g, where g is GCD(x, d). Let me think of this as (x*(x +d))/g. Let me think about how to minimize this.\n\nBut since d is fixed, perhaps we can consider that for x, the value of x must be such that it's a multiple of some divisor of d. Let me think. For example, suppose that d is fixed. Let me consider all possible divisors of d. Let me denote g as a divisor of d. Then, if x is a multiple of g, then GCD(x, d) will be at least g. But maybe even higher. So perhaps the optimal approach is to find for each divisor g of d, the minimal x such that x is a multiple of g, and then compute the LCM for that x, and choose the overall minimum.\n\nWait, but how does this help? Let's think. For example, let's take the first sample input: a=6, b=10. Then d = 4. So the problem is to find x ≥ a (which is 6) such that LCM(x, x+4) is minimized. Let's see. For x=6, LCM(6, 10) is 30. For x=7, LCM(7, 11) is 77. For x=8, LCM(8, 12) is 24. For x=9, LCM(9,13) is 117. For x=2, but wait x has to be ≥ a (6). So in this case,",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The approach involves leveraging the properties of the greatest common divisor (GCD) and divisors to efficiently determine the optimal $ k $.\n\n### Approach\n1. **Problem Analysis**: The LCM of two numbers can be minimized by maximizing their GCD. Given two integers $ a $ and $ b $, we can denote $ d = |a - b| $. The goal is to find a value $ x $ such that $ x $ and $ x + d $ have a high GCD, which minimizes their LCM.\n2. **Key Insight**: For any $ x $, the LCM of $ x $ and $ x + d $ can be expressed as $ \\frac{x \\cdot (x + d)}{\\text{GCD}(x, d)} $. To minimize this, we need to maximize the GCD of $ x $ and $ d $.\n3. **Divisors Utilization**: By considering all divisors of $ d $, we can determine potential values of $ x $ that are multiples of these divisors, which helps in maximizing the GCD.\n4. **Optimal $ k $ Calculation**: For each divisor $ g $ of $ d $, compute the smallest $ x $ such that $ x $ is a multiple of $ g $ and $ x \\geq a $, then determine the corresponding $ k $.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef compute_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef main():\n    a, b = map(int, sys.stdin.readline().split())\n    if a > b:\n        a, b = b, a\n    d = b - a\n    if d == 0:\n        print(0)\n        return\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = 0\n    for g in divisors:\n        # Find the minimal x >= a such that x mod g == 0\n        remainder = a % g\n        if remainder == 0:\n            x = a\n        else:\n            x = a + (g - remainder)\n        # Now x is the minimal multiple of g >= a\n        y = x + d\n        current_gcd = compute_gcd(x, d)\n        current_lcm = x * y // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x - a) < best_k):\n            min_lcm = current_lcm\n            best_k = x - a\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input values $ a $ and $ b $ are read and adjusted to ensure $ a \\leq b $.\n2. **Difference Calculation**: Compute $ d = b - a $, which represents the fixed difference between the two numbers after adding $ k $.\n3. **Divisors Calculation**: Generate all divisors of $ d $ to explore potential values of $ x $ that could maximize the GCD.\n4. **Finding Optimal $ k $**: For each divisor $ g $ of $ d $, compute the smallest $ x $ such that $ x $ is a multiple of $ g $ and $ x \\geq a $. Calculate the corresponding LCM and track the minimum LCM and the smallest $ k $ that achieves it.\n\nThis approach ensures that we efficiently explore potential values of $ k $ by leveraging mathematical properties of divisors and GCD, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef compute_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef main():\n    a, b = map(int, sys.stdin.readline().split())\n    if a > b:\n        a, b = b, a\n    d = b - a\n    if d == 0:\n        print(0)\n        return\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = 0\n    for g in divisors:\n        # Find the minimal x >= a such that x mod g == 0\n        remainder = a % g\n        if remainder == 0:\n            x = a\n        else:\n            x = a + (g - remainder)\n        # Now x is the minimal multiple of g >= a\n        y = x + d\n        current_gcd = compute_gcd(x, d)\n        current_lcm = x * y // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x - a) < best_k):\n            min_lcm = current_lcm\n            best_k = x - a\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 853,
        "thoughts_token_count": 1024
    }
}