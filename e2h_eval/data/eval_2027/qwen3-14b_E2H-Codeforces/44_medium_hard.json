{
    "start": 1758314590.4488435,
    "end": 1758314803.8388085,
    "start-formatted": "2025-09-20 05:43 KST",
    "end-formatted": "2025-09-20 05:46 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about splitting a list of n problems into exactly k days. Each day, Polycarp solves consecutive problems starting from the beginning. So, for example, on day 1, he solves some number of problems, then day 2 starts where day 1 left off, and so on. The total profit is the sum of the maximum difficulty of each day's problems. Our goal is to maximize this total profit.\n\nConstraints: n and k can be up to 2000. So any O(n^2 * k) solution might be acceptable, but I need to think about the approach.\n\nLet me think about dynamic programming. Because the problem requires partitioning into k parts, and each part's contribution depends on the max in that segment.\n\nLet me think of DP states. Let's define dp[i][j] as the maximum total profit when considering the first i problems divided into j days.\n\nThe recurrence would be something like: for each possible split point m (where m ranges from j-1 to i-1), since each day must have at least one problem. So for dp[i][j], we can look at all possible m where the j-th day takes m+1 to i problems. Then, dp[i][j] = max(dp[m][j-1] + max(a[m+1..i])) for all m from j-1 to i-1.\n\nBut calculating the max for each segment each time would be O(n^3) time. For n=2000 and k=2000, that's way too slow.\n\nWait, but n is up to 2000, and k is up to 2000. So even O(n^2 * k) would be 2000^3 = 8e10 operations, which is way too slow.\n\nHmm. Need a better approach. Let me think about how to optimize this.\n\nFirst, precompute the maximums for all possible intervals. Let's create a 2D array max_range where max_range[i][j] is the maximum value in a[i...j]. But for n=2000, this would take O(n^2) time and space. Which is 4 million entries. That's manageable.\n\nOnce we have that, the DP can proceed with O(n^2 *k) time. However, with n=2000 and k=2000, that's 2000*2000*2000 = 8e10 operations. Which is way too slow. So this approach is not feasible.\n\nWait, but maybe k is up to n. So for n=2000, even O(n^2 *k) is impossible. Therefore, we need to find another way.\n\nAlternative approach: Since each day must take a contiguous block starting from the previous day's end, the problem is similar to splitting the array into k parts, each part being a consecutive segment. The total profit is the sum of the max of each segment.\n\nBut how can we model this efficiently?\n\nAnother thought: For each day, the maximum of the segment is determined. To maximize the total sum, we want to have as many high values as possible as the max of their segments. However, since each segment must be contiguous and the order is fixed, we need to find where to split.\n\nLet me think about the case when k=1. Then the answer is the max of the entire array. For k=n, each day has one problem, so the sum is the sum of all elements.\n\nBut for general k, perhaps the optimal strategy is to split the array into k segments such that each segment's maximum is as large as possible, but considering that each split adds a new segment.\n\nBut how to model this.\n\nLet me think again about the DP approach. Let's try to find a way to compute it efficiently.\n\nLet me think of the DP[i][j] as the maximum profit for the first i problems split into j days.\n\nThen, for DP[i][j], we can consider that the j-th day is from m+1 to i, where m ranges from j-1 (since each previous day must have at least one problem) to i-1. Then, DP[i][j] = max over m (DP[m][j-1] + max(a[m+1..i])).\n\nThe problem is computing the max(a[m+1..i]) for each m and i. If we can compute that quickly, perhaps using a precomputed max_range array.\n\nSo let's precompute max_range[i][j], which is the maximum value from a[i] to a[j]. How to compute that?\n\nWe can compute for each i, iterate j from i to n-1, keeping track of the current maximum. That would take O(n^2) time, which is acceptable for n=2000.\n\nOnce we have that, the DP transitions can be done in O(1) per transition.\n\nNow, the DP's time complexity is O(k * n^2). For n=2000 and k=2000, that's 2000*2000*2000 = 8e10 operations. Which is way too big. So this approach is not feasible.\n\nHmm, but wait. What if k is up to n, but for each j, the transitions can be optimized? Let's think about the constraints.\n\nWait, but n is 2000, and k can be up to 2000. So for O(kn^2) time, that's 8e10 operations. Which is way beyond what can be handled in Python in reasonable time (say, 1e8 operations per second). So this approach is not feasible.\n\nSo, I need to find a better approach.\n\nAlternative idea: Since the splits are contiguous and the order is fixed, perhaps there's a way to find the optimal splits greedily. However, greedy approaches are tricky here. For example, taking the maximum possible in the first split may not lead to the optimal overall sum.\n\nBut maybe for certain cases. For example, when k is small, we need to split the array into k parts where each part's maximum is as large as possible. However, I don't see an obvious greedy strategy here.\n\nAlternative approach: Let's think of the problem as a variation of the classic problem of splitting an array into k segments to maximize the sum of segment maxima. This seems similar to some known DP problem.\n\nBut how to optimize the DP. Let's think of the DP[i][j] as before. For each i and j, can we find a way to compute it faster?\n\nLet me think for fixed j. For example, when j is fixed, and we compute DP[i][j] for varying i.\n\nFor j=1, DP[i][1] is the maximum of the first i elements.\n\nFor j=2, DP[i][2] is the maximum of DP[m][1] + max(a[m+1..i]) for m from 1 to i-1.\n\nBut for each i and j, perhaps there's a way to compute the DP[i][j] more efficiently.\n\nWait, but even with that, for each i and j, the inner loop is O(i) steps. So for j up to k, and i up to n, that's O(n^2 k) steps.\n\nBut with n=2000, and k=2000, that's 8e10 steps. Not feasible.\n\nBut perhaps the constraints are not that bad. Wait, n is up to 2000. Let me calculate:\n\nIf n=2000 and k=2000, then the DP[i][j] is only non-zero when j <= i. So for each j, i ranges from j to n.\n\nBut even then, for j=2000, i can be 2000. So for each j, the number of i's is (n - j + 1). So the total number of DP states is O(nk). For each state, the transitions are O(n) steps. So the total is O(n²k) steps.\n\nBut with n=2000, and k=2000, that's 2000*2000*2000 = 8e10 steps. Which is way too big for Python.\n\nTherefore, this approach is not feasible. So we need to find another way.\n\nAlternative idea: Let's think about the fact that when k is large, the optimal way is to split into as many single elements as possible. For example, if k = n, the answer is the sum of all elements. But when k is less than n, we need to merge some of the single elements into segments. Each merge can potentially increase the sum if the maximum of the merged segment is higher than the sum of the individual elements. Wait, no. For example, if you have two elements [2,3], merging them gives a max of 3, which is same as the sum of individual elements (2+3=5). So merging in that case is worse. But if you have [3,2], merging gives 3, which is same as 3+2=5. So merging is worse. So perhaps when you have to merge, you need to choose which merges will give the maximum gain. But how?\n\nAlternatively, think of the problem as starting with each element being its own segment (k = n) and then merging (k-1) times. Each merge combines two adjacent segments into one. Each merge reduces the number of segments by 1. So for k days, we need to make (n - k) merges. But how to choose which merges to do to maximize the total sum.\n\nBut the problem is that the total sum depends on the maxima of the segments. When you merge two segments, the new max is the maximum of the two previous maxima. So, the gain from merging two segments is (new_max) - (sum of old maxes). For example, merging two segments with maxima a and b, the new max is max(a,b), so the gain is max(a,b) - (a + b) = - min(a,b). Which is negative. So merging any two segments would decrease the total sum. But this contradicts the example given in the problem statement.\n\nWait, in the example, when k=3, the optimal split is [5,4,2], [6,5], [1,9,2]. The sum is 5 +6 +9 = 20. If instead, we split into [5,4,2,6,5], [1,9,2], then the sum is 6 +9 = 15, which is worse. So merging segments that have lower maxima can reduce the total sum. So in this case, the optimal way is to have as many high maxima as possible. Hence, the problem is to select k segments where each segment's max is as high as possible, but they are contiguous.\n\nBut how to model this.\n\nWait, but if you have to split into k segments, the maximum sum is achieved by selecting the k-1 largest elements in the array, and making sure that each of them is the maximum of their respective segments. But that's probably not correct, because the elements have to be in contiguous segments.\n\nBut perhaps the optimal approach is to select the k-1 largest elements, and split the array such that each of these elements is the maximum in their own segment, and the rest are merged into segments where their maxima are these elements.\n\nBut how to do that.\n\nAlternatively, think of the problem as follows: the total sum is the sum of the maxima of the k segments. Each segment must be a prefix of the array. So, the first segment is from 1 to x, the second from x+1 to y, etc. The key is that the maxima of these segments contribute to the total sum.\n\nBut how to choose the split points.\n\nAnother thought: The maximum total sum is equal to the sum of the maxima of the k segments. Since each segment must be a contiguous block, and the order is fixed.\n\nSuppose we have to choose k-1 split points. The split points divide the array into k segments. Each split point is between positions i and i+1.\n\nThe challenge is to choose these split points so that the sum of the maxima of the segments is maximized.\n\nBut how to find this.\n\nAnother idea: For each position i, compute the maximum in the prefix up to i. Then, for the first split, if we split after i, the first segment's max is the prefix max up to i. Then, recursively apply the same logic for the remaining array and k-1 splits.\n\nBut this seems like a recursive approach, which again leads to the DP idea.\n\nBut again, the DP approach is too slow for large k and n.\n\nBut perhaps there is a way to optimize the DP for this particular problem. Let me think again about the DP transitions.\n\nLet me think of the DP[i][j] as the maximum sum for the first i elements split into j segments.\n\nThen, the recurrence is:\n\nDP[i][j] = max_{m} (DP[m][j-1] + max(a[m+1..i]))\n\nThe max(a[m+1..i]) can be precomputed as mentioned earlier.\n\nBut how to compute this efficiently.\n\nWait, for each i and j, the m ranges from j-1 to i-1. Because for j-1 segments in the first m elements, m must be at least j-1 (each segment has at least one element).\n\nNow, for each i and j, we need to find the best m.\n\nBut for each j, when we compute DP[i][j], can we find a way to compute this more efficiently than O(i) per i?\n\nLet me think about the case where j is fixed, say j = t.\n\nFor each i >= t, we want to compute DP[i][t] = max_{m} (DP[m][t-1] + max(a[m+1..i])).\n\nLet me think about the term max(a[m+1..i]). For fixed i, as m increases from t-1 to i-1, the range [m+1..i] decreases in length. The maximum of this range can be computed incrementally.\n\nBut how?\n\nAlternatively, for each i and for each possible m, we can precompute the max from m+1 to i. But that's the same as the precomputed max_range array.\n\nSo, for each i and j, the recurrence is O(i) steps.\n\nBut again, this leads to O(n²k) time.\n\nBut perhaps for the constraints given, n is 2000 and k is 2000, but in practice, the code can pass if we optimize it properly.\n\nWait, 2000^3 is 8e10 operations. Even with optimized C++ code, that's way too slow. But for Python, which is slower, it's impossible.\n\nSo this suggests that the DP approach is not feasible for the given constraints.\n\nAlternative Idea:\n\nLet me think of the problem in terms of the following observation: when k is small, the optimal way is to split the array into k segments, each of which contains the largest elements. For example, the first segment would include the first occurrence of the maximum element, then the next segment would include the next maximum, etc.\n\nBut how to formalize this.\n\nAnother Idea:\n\nThe maximum total profit is the sum of the k largest elements in the array, provided that they can be arranged as the maxima of their respective segments. However, this is not always possible. For example, if the array is [5, 4, 3, 2, 1], and k=3. The three largest elements are 5,4,3. We can split into [5], [4], [3,2,1], sum is 5+4+3=12. Which is indeed the maximum possible. But if the array is [3, 1, 2, 4], and k=2. The two largest elements are 4 and 3. To have them as maxima, split into [3,1,2], [4], sum is 3+4=7. Alternatively, [3,1], [2,4], sum is 3+4=7. Or [3], [1,2,4], sum is 3+4=7. So it works. But what if the array is [2, 1, 3, 4], and k=2. The two largest elements are 4 and 3. So split into [2,1,3], [4], sum is 3+4=7. Or [2,1], [3,4], sum is 2+4=6. So the first option is better. So the maximum sum is indeed the sum of the top k elements, but only if those elements can be the maxima of their segments.\n\nBut how to ensure that. For example, suppose the array is [5, 1, 2, 3, 4], and k=3. The top three elements are 5,4,3. Can we split into segments where each has one of these as maxima? Yes: [5], [1,2,3], [4]. Sum is 5+3+4=12. But what if the array is [5, 4, 3, 2, 1], k=3. The top three elements are 5,4,3. Split into [5], [4], [3,2,1], sum is 5+4+3=12. Which is the maximum possible.\n\nSo perhaps the maximum total profit is the sum of the k largest elements in the array. But this is only true if each of those elements can be the maximum of their respective segments.\n\nBut how to confirm this.\n\nTake the third example given in the problem:\n\nInput: 4 2\\n1 2000 2000 2\n\nThe array is [1, 2000, 2000, 2]. The top two elements are 2000 and 2000. The sum is 4000. Which matches the sample output.\n\nAnother example: the first sample input is [5,4,2,6,5,1,9,2], n=8, k=3. The top 3 elements are 9, 6, 5. Sum is 20. Which matches the sample output.\n\nSo it seems that the maximum total profit is indeed the sum of the k largest elements in the array. But why?\n\nBecause each of these elements can be the maximum of their own segment. For example, the largest element must be in its own segment. The second largest can be in its own segment, etc.\n\nBut how to ensure that the segments can be formed such that each of the k largest elements is the maximum of their respective segments.\n\nBut how can we arrange that? For example, if the array is [3, 1, 2, 4], and k=2. The two largest elements are 4 and 3. So we can split into [3,1,2], [4], which gives maxima 3 and 4. Sum is 7. Which is the sum of the two largest elements. Similarly, if the array is [4, 3, 2, 1], and k=2, then the sum is 4+3=7.\n\nBut what about if the array is [2, 4, 3, 1], k=2. The two largest elements are 4 and 3. How to split. We can split into [2,4], [3,1]. Maxima are 4 and 3. Sum is 7. Which is the sum of the two largest elements.\n\nBut what if the array is [3, 2, 4, 1], and k=2. The two largest are 4 and 3. Split into [3,2,4], [1], sum is 4+1=5. Which is worse than splitting into [3,2], [4,1], sum is 3+4=7. Which is indeed the sum of the two largest elements. So yes, the maximum sum is the sum of the k largest elements.\n\nBut how to prove this?\n\nAssume that the maximum sum is the sum of the k largest elements. Because each segment must have a maximum, and the maximum of each segment can't be larger than the maximum of the entire array. So, to maximize the sum, we want to select the k largest elements as the maxima of the segments. And since the segments are contiguous, it's possible to arrange them in such a way.\n\nBut how?\n\nFor example, the largest element must be in a segment by itself. Then the next largest element must be in a segment that does not include any elements larger than it. Since the largest element is already in a separate segment, this is possible. Similarly, the third largest element can be placed in a segment that does not include the larger elements. Etc.\n\nBut how to split the array into k segments to achieve this.\n\nThis suggests that the problem can be reduced to selecting the k largest elements, and ensuring that they are each the maximum of their respective segments. Then, the sum of these elements would be the maximum possible.\n\nIf this is true, then the problem becomes much simpler. We can proceed as follows:\n\n- Find the k largest elements in the array. Let's call them S.\n\n- Then, split the array into k segments such that each of these elements is the maximum of its segment.\n\nBut how to do this?\n\nLet me think of the following approach:\n\n- Sort the elements in descending order, take the first k elements. For each of these elements, we need to assign them to their own segments. However, since the array is processed in order, we need to split the array so that each of these elements is the maximum of their segment.\n\nBut how to find the split points.\n\nAn alternative approach is to greedily select the split points. For example:\n\nStart from the end of the array. We need to select the k-1 split points. The last segment must contain the largest element. Then, the previous segment must contain the second largest element, etc.\n\nWait, but the largest element could be anywhere in the array. For example, in the first sample input, the largest element is 9, which is in the 7th position. So the last segment must include that element. But the other segments must include the next largest elements.\n\nBut how to find the split points.\n\nLet me think of the following algorithm:\n\nWe need to select k positions where we split the array into k segments. The splits are between elements. For example, for array [a1, a2, ..., an], the splits are after index i, j, etc.\n\nTo select the splits, we can find the positions of the k largest elements, and ensure that each of them is in a separate segment, and that no segment contains a larger element than the one chosen for that segment.\n\nHere's an idea:\n\nWe can process the array from right to left. We need to select k segments. The last segment must include the largest element. Then, the previous segment must include the next largest element that is before the largest element. And so on.\n\nFor example, in the first sample input, the largest element is 9 at position 7 (assuming 1-based indexing). The next largest is 6 at position 4. The third is 5 at position 1. So the splits would be after position 3 (so first segment is 3 elements), after position 5 (second segment is 2 elements), and the third segment is the remaining 3 elements.\n\nThis gives the split as [5,4,2], [6,5], [1,9,2], which matches the sample.\n\nSo the approach is:\n\n- Find the positions of the k largest elements. For example, if the array has duplicates, we need to select the earliest or latest occurrences?\n\nBut how to ensure that these elements are in separate segments.\n\nLet me think of the following steps:\n\n1. Find the positions of the k largest elements. For example, if there are multiple elements with the same value, we need to select the ones that allow us to split the array into k segments.\n\nBut perhaps the best way is to select the positions of the k largest elements, sorted in increasing order. Then, the split points are determined by these positions.\n\nFor example, if the k largest elements are located at positions p_1, p_2, ..., p_k (sorted in increasing order), then the segments would be:\n\n[1..p_1], [p_1+1..p_2], ..., [p_{k-1}+1 ... p_k], [p_k+1 ... n]. Wait, no. Because each segment must contain exactly one of the k largest elements, and the segments are contiguous.\n\nWait, no. The segments must be such that each of the selected positions is the maximum in their respective segments. For example, the first segment would be from the beginning to the first selected position. The second segment would be from the next position after the first selected position to the second selected position, and so on. However, this may not work if there are elements larger than the selected elements in between.\n\nBut since the selected elements are the k largest elements, any element in the array that is not selected is smaller than or equal to the smallest selected element.\n\nWait, if we select the k largest elements, then all other elements are <= the smallest among these selected elements. So, if we split the array into segments where each segment contains exactly one of the selected elements, and the segments are ordered such that the selected elements are in order of their positions, then each segment's maximum is the selected element. Because the other elements in the segment are smaller than or equal to the selected element.\n\nFor example, suppose the selected elements are at positions p_1 < p_2 < ... < p_k. Then, the first segment is from 1 to p_1. Its maximum is a[p_1], since all elements in this segment are <= a[p_1] (because a[p_1] is one of the k largest elements, and the other elements are not larger than it). The second segment is from p_1+1 to p_2. Its maximum is a[p_2], since all elements in this segment are <= a[p_2], and so on.\n\nYes! Because the selected elements are the k largest, and the other elements are not larger than them. So, if we split the array into k segments, each containing exactly one of the selected elements, and the segments are in order, then the maximum of each segment is the selected element.\n\nThus, the total sum is the sum of the k selected elements.\n\nTherefore, the maximum total profit is simply the sum of the k largest elements in the array.\n\nBut how to split the array into k segments accordingly.\n\nThe steps would be:\n\n- Select the k largest elements. Let's collect them in a list.\n\n- Sort their positions in increasing order.\n\n- Split the array into segments based on these positions.\n\nFor example, the first segment is from the start to the first selected position. The second segment is from the next position after the first selected position to the second selected position, and so on. The last segment is from the position after the (k-1)-th selected position to the end.\n\nBut how to select the k largest elements. For example, if there are duplicate elements, like in the third sample input: [1, 2000, 2000, 2]. The two largest elements are 2000 and 2000. So, their positions are 2 and 3. Splitting into segments [1,2000], [2000, 2], which gives maxima 2000 and 2000. Sum 4000.\n\nYes, which matches the sample.\n\nSo the algorithm is:\n\n1. Find the k largest elements in the array. If there are duplicates, we need to select exactly k elements, possibly including duplicates.\n\n2. Collect the indices of these elements, sorted in increasing order.\n\n3. Split the array into k segments based on these indices.\n\nBut how to select the indices. For example, if there are multiple elements with the same value, which ones to choose.\n\nFor example, if the array is [5, 5, 5], and k=2. The two largest elements are 5 and 5. We need to select two positions. The best way to split is to take the first two 5s as the first two segments. So the split would be [5], [5,5], sum is 5 +5=10. Alternatively, [5,5], [5], sum is 5+5=10. Either way.\n\nBut the way to choose the indices is to select the earliest possible positions. Or perhaps the latest? Or any?\n\nBut for splitting into segments, the positions must be in increasing order. So, for the k largest elements, we need to collect their positions, and sort them. However, if there are multiple elements with the same value, we need to select exactly k elements.\n\nBut how to select them. For example, if the array has more than k elements with the same value, we need to pick the first k of them? Or the last k? Or any k?\n\nThe selection of which elements to pick affects the split positions. However, the sum will be the same regardless of which elements are picked, as long as they are the k largest.\n\nSo, the steps for selecting the positions:\n\n- Create a list of all elements with their indices.\n\n- Sort them in descending order of value, and ascending order of index (to break ties).\n\n- Take the first k elements. Then, collect their indices and sort them in increasing order.\n\nFor example, in the third sample input, the elements are [1, 2000, 2000, 2]. The sorted list of elements with indices (value, index) would be:\n\n(2000, 2), (2000, 3), (2, 4), (1, 1). Taking the first two gives indices 2 and 3. Sorted in increasing order, they are [2,3].\n\nSo the split is:\n\nFirst segment from 1 to 2 (indices 1-2?), wait, need to clarify the indices.\n\nAssuming that the array is 0-based or 1-based. Let's assume the problem uses 1-based indices for the array.\n\nIn the third sample input, the array is [1, 2000, 2000, 2], which is n=4, k=2.\n\nThe positions of the two largest elements are 2 and 3 (assuming 1-based). So the first segment is from 1 to 2 (elements [1,2000]), the second from 3 to 4 (elements [2000, 2]). So the split is [2,2], giving sum 2000 + 2000 = 4000.\n\nYes.\n\nSo, the steps are:\n\n- Find the k largest elements, and collect their indices.\n\n- Sort these indices in increasing order.\n\n- Then, the split points are determined by these indices.\n\nNow, the split points are:\n\nThe first segment ends at the first index (say, p1).\n\nThe second segment ends at the second index (p2), and so on.\n\nSo, the split lengths would be:\n\nt_1 = p1 - 0 (if 1-based, then t_1 = p1).\n\nWait, assuming the array is 1-based:\n\nFor the first segment, it starts at position 1 and ends at p1. The number of elements is p1.\n\nThe second segment starts at p1 + 1 and ends at p2. The number of elements is p2 - p1.\n\nThe third segment starts at p2 + 1 and ends at p3. The number of elements is p3 - p2.\n\n...\n\nThe k-th segment starts at p_{k-1} + 1 and ends at n. The number of elements is n - p_{k-1}.\n\nSo, the split lengths are:\n\nt_1 = p1\n\nt_2 = p2 - p1\n\nt_3 = p3 - p2\n\n...\n\nt_k = n - p_{k-1}\n\nBut this requires that the indices are sorted in increasing order.\n\nSo, the problem reduces to:\n\n- Find the k largest elements and their indices.\n\n- Sort the indices in increasing order.\n\n- Compute the split lengths as above.\n\nBut how to implement this.\n\nNow, the question is: how to find the k largest elements and their indices. For example, if there are multiple elements with the same value, we need to select exactly k of them.\n\nFor example, if the array is [5,5,5], and k=2, then we select two of the 5's. Which ones?\n\nThe selection of the indices will affect the split lengths, but the sum will be the same regardless.\n\nBut for the split to be valid, we need to ensure that the indices are in order. So, the way to select the indices is to take the first k elements in the sorted list of elements, sorted by value descending and index ascending.\n\nFor example, in the case of [5,5,5], the sorted list would be [(5,1), (5,2), (5,3)]. Taking the first two gives indices 1 and 2. So the split would be [1], [2,3], which gives sum 5 +5 = 10. Alternatively, taking indices 1 and 3 would split into [1], [3], but then the second segment would be [3], but the middle element (position 2) is not included. But according to the problem statement, the splits must be contiguous. So the split must be such that the segments are consecutive.\n\nAh, so the indices selected must be in increasing order, and each subsequent index must be after the previous one. So, to select the k indices, we need to choose the earliest possible positions, or any positions that are in increasing order.\n\nBut when selecting the k largest elements, we can choose any k elements with the highest values, but their indices must be in increasing order.\n\nSo, the approach is:\n\n- Create a list of all elements with their indices.\n\n- Sort this list in descending order of value, and for equal values, ascending order of index.\n\n- Take the first k elements from this list. These will be the k elements that are the largest, with the earliest indices for ties.\n\n- Extract the indices of these elements, and sort them in increasing order.\n\nOnce we have the sorted indices, we can compute the split lengths.\n\nBut wait, what if the first k elements in the sorted list have indices that are not in increasing order? For example, suppose the array is [5, 3, 5], and k=2. The sorted list would be [(5,1), (5,3), (3,2)]. Taking the first two gives indices 1 and 3. When sorted in increasing order, they are [1,3]. So the split is [1], [3-1=2 elements (positions 2 and 3)].\n\nSo the segments are [5], [3,5], sum is 5 +5 = 10.\n\nWhich is correct.\n\nSo this approach works.\n\nNow, how to implement this.\n\nIn code:\n\nRead n and k.\n\nRead the array as a list.\n\nCreate a list of tuples (value, index) for each element (index is 1-based).\n\nSort this list in descending order of value, and for ties, ascending index.\n\nTake the first k elements from this sorted list.\n\nExtract their indices, and sort them in increasing order.\n\nOnce we have the sorted indices, say in a list called positions.\n\nThen, compute the split lengths:\n\nprev = 0\n\nresult = []\n\nfor pos in positions:\n\n    result.append(pos - prev)\n\n    prev = pos\n\nresult.append(n - prev)\n\nWait, no. Let's think:\n\npositions is a list of sorted indices (increasing). For example, [p1, p2, ..., pk].\n\nThe first segment is from 1 to p1, which has length p1.\n\nThe second segment is from p1+1 to p2, which has length p2 - p1.\n\nThe third segment is from p2+1 to p3, which has length p3 - p2.\n\n...\n\nThe k-th segment is from p_{k-1} + 1 to n, which has length n - p_{k-1}.\n\nSo the split lengths are [p1, p2-p1, p3-p2, ..., n - p_{k-1}].\n\nSo the code would be:\n\npositions = sorted([indices of selected elements])\n\nprev = 0\n\nsplit_lengths = []\n\nfor pos in positions:\n\n    split_lengths.append(pos - prev)\n\n    prev = pos\n\nsplit_lengths.append(n - prev)\n\nWait, no. Because after the loop, the last segment is from prev + 1 to n. So the length is n - prev.\n\nBut the code as written would have split_lengths as [p1 - 0, p2 - p1, ... , pk - p_{k-1}], and then append n - pk.\n\nSo the total split_lengths would be [p1, p2-p1, ..., pk - p_{k-1}, n - pk].\n\nWhich sums to p1 + (p2 - p1) + ... + (pk - p_{k-1}) ) + (n - pk) ) = n.\n\nYes.\n\nSo the code would generate the split_lengths correctly.\n\nBut in the code, the positions list is sorted in increasing order.\n\nNow, the sum of the selected elements is the sum of their values.\n\nBut how to get the sum of the selected elements.\n\nIn the code, after selecting the first k elements from the sorted list, we can sum their values.\n\nBut wait, in the case where there are multiple elements with the same value, we may have selected some of them. But since we are taking the first k elements in the sorted list, which includes the highest values, the sum will be the sum of the k largest elements.\n\nThis approach would work.\n\nNow, let's test this against the sample inputs.\n\nFirst sample input:\n\nn=8, k",
    "response": "To solve this problem, we need to distribute a list of problems into exactly `k` days such that the total profit, defined as the sum of the maximum difficulty of each day's problems, is maximized. The solution involves selecting the `k` largest elements in the list and ensuring each of these elements is the maximum of its respective segment.\n\n### Approach\n1. **Identify Key Elements**: The maximum profit can be achieved by selecting the `k` largest elements in the list. This is because each of these elements will contribute their value to the total profit when they are the maximum in their respective segments.\n2. **Determine Segments**: Once the `k` largest elements are identified, we determine their positions in the list. These positions help us split the list into `k` contiguous segments where each segment contains exactly one of these key elements.\n3. **Calculate Split Lengths**: Using the positions of the key elements, we compute the lengths of each segment to ensure all problems are distributed over exactly `k` days.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create list of (value, index) pairs, 1-based index\n    elements = [(a[i], i + 1) for i in range(n)]\n    \n    # Sort by descending value, then ascending index\n    elements.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Select first k elements\n    selected = elements[:k]\n    \n    # Extract indices and sort them\n    positions = sorted([pos for (val, pos) in selected])\n    \n    # Compute the split lengths\n    split_lengths = []\n    prev = 0\n    for pos in positions:\n        split_lengths.append(pos - prev)\n        prev = pos\n    split_lengths.append(n - prev)\n    \n    # Calculate total profit\n    total_profit = sum(val for (val, pos) in selected)\n    \n    # Output\n    print(total_profit)\n    print(' '.join(map(str, split_lengths)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of problems `n`, the number of days `k`, and the list of problem difficulties.\n2. **Identifying Key Elements**: The list of problem difficulties is transformed into a list of tuples containing each value and its 1-based index. This list is sorted in descending order of values and ascending order of indices to handle ties.\n3. **Selecting Key Elements**: The first `k` elements from the sorted list are selected, which ensures we get the `k` largest values.\n4. **Determining Segment Positions**: The indices of these selected elements are sorted to determine the split points in the original list.\n5. **Calculating Segment Lengths**: Using the sorted indices, we compute the lengths of each segment ensuring all problems are covered exactly once over `k` days.\n6. **Output**: The total profit is the sum of the selected values, and the segment lengths are printed as required.\n\nThis approach efficiently determines the optimal distribution of problems into days to maximize the total profit, leveraging sorting and careful selection of key elements.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create list of (value, index) pairs, 1-based index\n    elements = [(a[i], i + 1) for i in range(n)]\n    \n    # Sort by descending value, then ascending index\n    elements.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Select first k elements\n    selected = elements[:k]\n    \n    # Extract indices and sort them\n    positions = sorted([pos for (val, pos) in selected])\n    \n    # Compute the split lengths\n    split_lengths = []\n    prev = 0\n    for pos in positions:\n        split_lengths.append(pos - prev)\n        prev = pos\n    split_lengths.append(n - prev)\n    \n    # Calculate total profit\n    total_profit = sum(val for (val, pos) in selected)\n    \n    # Output\n    print(total_profit)\n    print(' '.join(map(str, split_lengths)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 935,
        "completion_token_count": 713,
        "thoughts_token_count": 8192
    }
}