{
    "start": 1758008523.4020634,
    "end": 1758008749.3247385,
    "start-formatted": "2025-09-16 16:42 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure of the snowflake.\n\nFrom the description:\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that has only one connection (so those leaves) are connected to k new vertices. This process must be done at least once. So, the construction involves layers. Let's think about how the number of vertices grows with each step.\n\nLet me think of the example given. For k=4, the smallest snowflake has 1 + 4 + 4*4 = 1+4+16=21? Or maybe not. Wait, maybe the steps are as follows:\n\nInitially, there's 1 node. Then, add k nodes connected to it. Now, the initial node has degree k, and each of the k nodes has degree 1. Then, each of those leaves (the k nodes) gets connected to k new nodes. So for each of those k nodes, we add k new nodes. So that's k * k new nodes. Now the total is 1 + k + k^2. But wait, the example says that the minimal snowflake for k=4 is shown. Let's check the example input. For example, when n=13, the output is YES. Let's see: 1 + 4 + 4*4 = 1+4+16=21. That's not 13. Hmm, so maybe the process is different.\n\nWait, maybe the construction is such that after the initial step (adding k children to the root), we perform the expansion step once. Let me re-read the problem statement.\n\nThe problem says:\n\nInitially, the graph has only one vertex. Then, more vertices are added. The initial vertex is connected by edges to k new vertices (k>1). Then, each vertex that is connected to only one other vertex is connected by edges to k new vertices. This step should be done at least once.\n\nSo the first step is adding k children to the root. Then, the second step is taking all the leaves (which are those k nodes) and adding k children to each. This step is done at least once. So the minimal snowflake would have 1 + k + k*k. But the example says for n=13, it's possible. Let's see: 1 + k + k^2 = 13. Let's solve for k. k^2 +k +1 =13 → k^2 +k -12=0. The roots are (-1 ± sqrt(1+48))/2 → sqrt(49)=7 → ( -1 +7)/2 = 3. So k=3. Then 1+3+9=13. So yes, that's possible. So for n=13, the answer is YES. Which matches the sample input where n=13 outputs YES.\n\nAnother example: for n=6. Let's see. Let's check if there's a k such that 1 +k +k^2 =6. Solving k² +k +1 =6 → k² +k -5=0 → discriminant 1+20=21 → sqrt(21) is irrational. So no integer solution. But maybe there's another way of building the snowflake. Wait, perhaps the expansion steps can be done more than once. Let me think.\n\nThe problem says that the step (each leaf is connected to k new vertices) is done at least once. So maybe the snowflake can have multiple layers. For example, after the first expansion (adding k children to the root), then expanding again (each leaf gets k children). Let me model the number of nodes.\n\nLet me think recursively. Let's consider that each time we do an expansion step. The initial step is step 0: 1 node. Then, step 1: add k children to the root. Now, the number of nodes is 1 + k. Then, step 2: expand each leaf (which are the k nodes from step 1) by adding k children each. So adding k *k nodes. Total becomes 1 +k +k^2. Then step 3: expand each leaf (those added in step 2) by adding k children each. Each of those leaves is a node added in step 2, which is k^2 nodes. So adding k^3 nodes. Total is 1 +k +k^2 +k^3. And so on.\n\nBut the expansion steps must be done at least once. So the minimal number of steps is two: the initial step (adding k children to the",
    "response": "\n\nTo solve this problem, we need to determine if a given number of vertices `n` can form a snowflake graph as defined in the problem. The snowflake graph is constructed by starting with one vertex and iteratively expanding each leaf node with `k` new vertices, where `k > 1`. This expansion must be done at least once.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph starts with a single vertex. Each subsequent layer adds `k` new vertices to every leaf node from the previous layer. The total number of vertices after `m` layers (including the initial layer) is given by the formula: \n   $$\n   n = 1 + k + k^2 + k^3 + \\ldots + k^m\n   $$\n   This is a geometric series which sums up to:\n   $$\n   n = \\frac{k^{m+1} - 1}{k - 1}\n   $$\n   However, since the expansion must be done at least once, the minimum number of layers is 2, leading to the formula:\n   $$\n   n = 1 + k + k^2\n   $$\n\n2. **Iterative Check**: For each test case, we check all possible values of `k` starting from 2 up to a reasonable limit. For each `k`, we check if there exists an integer `m` such that the sum of the geometric series equals `n`.\n\n3. **Efficient Calculation**: Given the constraints (up to $10^{18}$), we use binary search to efficiently check if `n` can be represented as the sum of the geometric series for some `k`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Check for k >= 2\n    # Try different k's\n    # For each k, find if there exists m >= 1 such that sum_{i=0}^m k^i = n\n    # sum_{i=0}^m k^i = (k^(m+1) - 1)/(k-1)\n    # So for each k, we need to check if there exists m such that the above equals n\n    # But since m can be large, we can try to find m for each k\n    # Alternatively, for each possible k, we can check if (k^(m+1) - 1) / (k-1) = n\n    # Let's iterate k from 2 up to cube root of n, since for m >= 2, the minimal n is 1 + k + k^2\n    # So for each k, we can compute the maximum possible m such that the sum is <= n\n    max_k = int(n ** (1/3)) + 2\n    for k in range(2, max_k + 1):\n        # We need to find m >= 1 such that (k^(m+1) - 1) // (k - 1) == n\n        # Since m can be large, we can use binary search for m\n        low = 1\n        high = 60  # since k^60 is way larger than 1e18\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute sum = (k^(mid+1) - 1) // (k - 1)\n            # But for large exponents, this may overflow, so we need to compute it carefully\n            try:\n                total = (pow(k, mid + 1) - 1) // (k - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    # Also check for cases where m=1, which gives sum = 1 + k\n    # So for m=1, sum is 1 + k, so check if n-1 is >= 2 and has a k >=2\n    # But since we already check k >=2, we need to see if n-1 is >= 2 and k = n-1\n    # For example, n=3, k=2, m=1\n    if n >= 3:\n        k_candidate = n - 1\n        if k_candidate > 1:\n            return True\n    # Also check for cases where the snowflake has only one expansion step (m=1)\n    # So for m=1, the sum is 1 + k\n    # So check if n-1 is >= 2 and k = n-1\n    # Wait, that's what we did above\n    # Also check for cases where the snowflake has more layers but the sum is exactly n\n    # Additionally, check for cases where the sum is 1 + k + k^2 + ... + k^m\n    # Another approach is to check for all possible k and m\n    # But the above loop should handle that\n    # Also check for cases where the sum is 1 + k (m=1)\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read in one go for efficiency, especially given the constraints.\n2. **Checking Snowflake Validity**: For each value of `n`, the function `is_snowflake` checks if it can be represented as the sum of a geometric series for some `k > 1`.\n3. **Geometric Series Check**: For each possible `k`, the function uses binary search to check if there exists an integer `m` such that the sum of the geometric series equals `n`.\n4. **Edge Cases**: Special handling for small values of `n` ensures correctness, especially for the smallest valid snowflakes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Check for k >= 2\n    # Try different k's\n    # For each k, find if there exists m >= 1 such that sum_{i=0}^m k^i = n\n    # sum_{i=0}^m k^i = (k^(m+1) - 1)/(k-1)\n    # So for each k, we need to check if there exists m such that the above equals n\n    # But since m can be large, we can try to find m for each k\n    # Alternatively, for each possible k, we can check if (k^(m+1) - 1) / (k-1) = n\n    # Let's iterate k from 2 up to cube root of n, since for m >= 2, the minimal n is 1 + k + k^2\n    # So for each k, we can compute the maximum possible m such that the sum is <= n\n    max_k = int(n ** (1/3)) + 2\n    for k in range(2, max_k + 1):\n        # We need to find m >= 1 such that (k^(m+1) - 1) // (k - 1) == n\n        # Since m can be large, we can use binary search for m\n        low = 1\n        high = 60  # since k^60 is way larger than 1e18\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute sum = (k^(mid+1) - 1) // (k - 1)\n            # But for large exponents, this may overflow, so we need to compute it carefully\n            try:\n                total = (pow(k, mid + 1) - 1) // (k - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    # Also check for cases where m=1, which gives sum = 1 + k\n    # So for m=1, sum is 1 + k, so check if n-1 is >= 2 and has a k >=2\n    # But since we already check k >=2, we need to see if n-1 is >= 2 and k = n-1\n    # For example, n=3, k=2, m=1\n    if n >= 3:\n        k_candidate = n - 1\n        if k_candidate > 1:\n            return True\n    # Also check for cases where the snowflake has only one expansion step (m=1)\n    # So for m=1, the sum is 1 + k\n    # So check if n-1 is >= 2 and k = n-1\n    # Wait, that's what we did above\n    # Also check for cases where the snowflake has more layers but the sum is exactly n\n    # Additionally, check for cases where the sum is 1 + k + k^2 + ... + k^m\n    # Another approach is to check for all possible k and m\n    # But the above loop should handle that\n    # Also check for cases where the sum is 1 + k (m=1)\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 1327,
        "thoughts_token_count": 1023
    }
}