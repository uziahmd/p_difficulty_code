{
    "start": 1758338783.896179,
    "end": 1758339282.7133198,
    "start-formatted": "2025-09-20 12:26 KST",
    "end-formatted": "2025-09-20 12:34 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's try to understand this problem. We need to find two things for a given p: the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, what's a p-reachable graph? It's a directed graph where there are exactly p ordered pairs (u, v) with u < v and u and v are reachable from each other. So, for each such pair, both directions must be possible. Wait, no, reachability is mutual here. Because if u and v are reachable from each other, then they are in a strongly connected component (SCC). So the count p is the number of unordered pairs {u, v} where u < v and u and v are in the same SCC. But since the problem says ordered pairs (u, v) with u < v and they are reachable from each other, that's equivalent to counting the number of unordered pairs of nodes in the same SCC, because for each such unordered pair, exactly one ordered pair (u, v) exists where u < v.\n\nSo, the problem reduces to finding a directed graph with exactly p such unordered pairs (counted as ordered pairs with u < v), and the minimal number of nodes. Then, among those graphs, find the maximum number of unidirectional pairs.\n\nNow, the first part: minimal number of nodes. Let's think about how to structure the graph to have exactly p such pairs. The key idea here is that each strongly connected component (SCC) contributes some number of ordered pairs. For a component of size k, the number of unordered pairs is C(k, 2) = k*(k-1)/2. So, if we have multiple components, the total p is the sum over all components of C(k_i, 2), where k_i is the size of each component.\n\nTherefore, our task is to find a set of integers k_1, k_2, ..., k_m such that sum_{i} C(k_i, 2) = p, and the total number of nodes, sum k_i, is minimized. Also, since we want the minimal number of nodes, we need to choose the sizes of the components optimally.\n\nThis is similar to the problem of representing a number as a sum of combinations C(k, 2), with the minimal sum of k's. How can we approach this?\n\nLet me think. For example, suppose p=3. Then, C(3,2)=3. So, one component of size 3 gives exactly 3 pairs, which is optimal. The minimal number of nodes is 3.\n\nAnother example, say p=4. What's the minimal sum? Let's see. If we take a component of size 3 (which gives 3) and another of size 2 (which gives 1), total is 3+1=4. Sum of nodes is 3+2=5. Alternatively, can we have a single component of size 4? C(4,2)=6, which is larger than 4. So no. Another option is two components of size 2 and 2: sum 2*1=2, which is less than 4. Not enough. So the minimal sum is 5 nodes.\n\nWait, but the example in the problem says for input 4, the output is 5 6. Let me check that. Oh right, the first part is the minimal number of nodes. So for p=4, the minimal number is 5 nodes. Then the second part is the maximum number of unidirectional pairs.\n\nBut how do we find the minimal number of nodes for any given p?\n\nThe approach here is to find the minimal sum of k_i where sum C(k_i, 2) = p. To minimize the sum of k_i, we need to maximize the value of C(k_i, 2) per node. Because for a given sum of C(k_i, 2), the minimal sum of k_i is achieved when the components are as large as possible. However, since C(k, 2) increases quadratically with k, perhaps the optimal way is to have as many as possible components of size m, where m is the largest possible such that C(m, 2) ≤ remaining p.\n\nAlternatively, think of it as a greedy approach. For example, for a given p, we can try to find the largest k such that C(k, 2) ≤ p. Then subtract that from p and repeat. But is this approach correct?\n\nWait, let's think of p=4. The largest C(k, 2) ≤4 is 3 (k=3). Then remaining is 1. Then the largest is 1 (k=2). So total sum is 3+2=5. Which is correct.\n\nAnother example: p=6. The largest is 6 (C(4, 2) = 6). So one component of 4 nodes. Sum is 4. Which is better than, say, 3+3 (sum 6, which would give C(3,2)*2 = 3*2=6, sum nodes 3+3=6, which is worse than 4).\n\nSo the greedy approach of taking the largest possible component each time seems correct. Therefore, the minimal number of nodes is found by greedily choosing the largest possible k_i such that C(k_i, 2) ≤ remaining p, subtracting that value, and proceeding until p is zero.\n\nSo, for the first part of the problem, we can model it as follows:\n\nWe need to find the minimal sum of k_i where sum C(k_i, 2) = p. The way to do this is to find the maximum possible k for each step, subtract C(k, 2) from p, and add k to the total nodes.\n\nBut how to compute this efficiently?\n\nLet me think. For a given p, the maximum k where C(k, 2) ≤ p is found by solving k(k-1)/2 ≤ p. So, k^2 -k - 2p ≤0. Solving quadratic equation, the positive root is [1 + sqrt(1 + 8p)] / 2. Take the floor of that value.\n\nFor example, for p=4, sqrt(33) is ~5.744, so (1 + 5.744)/2 ~ 3.37, floor is 3. Which gives 3*2/2=3 ≤4. Correct.\n\nOnce we find that k, we subtract C(k, 2) from p, and repeat the process until p becomes zero.\n\nBut wait, what if after taking the largest k, the remainder can't be represented with smaller components? Well, since we can take components of size 1 (which contribute zero to p) but adding them doesn't help. So, for example, if p is 1, then the maximum k is 2 (since C(2,2)=1). So the minimal sum is 2.\n\nSo the algorithm for the first part is:\n\nInitialize total_nodes = 0\n\nWhile p > 0:\n\n   find the largest k such that k*(k-1)/2 ≤ p\n\n   subtract k*(k-1)/2 from p\n\n   add k to total_nodes\n\nThus, this will give us the minimal number of nodes.\n\nOnce we have the minimal number of nodes, we need to compute the maximum number of unidirectional pairs.\n\nNow, what's a unidirectional pair? It's an ordered pair (u, v) where u != v, there's a path from u to v, but no path from v to u. So, these are pairs that are in different strongly connected components (SCCs), and there's a directed edge from one component to another.\n\nBut how to count them?\n\nLet me think. Suppose the graph is structured as a DAG of SCCs, where each component is a node in the DAG. Each edge between components in the DAG represents that there is a path from one component to another. So, for two components A and B, if there's a directed edge from A to B in the DAG, then all pairs (a, b) where a is in A and b is in B are unidirectional pairs if there is no path from B to A.\n\nBut in order to maximize the number of unidirectional pairs, the DAG should be structured such that for every pair of components A and B, either there is a directed edge from A to B or from B to A, but not both. Because if there is a path from A to B and from B to A, then they would be merged into a single component. So, the DAG must be a tournament, where for any two components, there is exactly one direction of edge between them.\n\nIn such a case, the number of unidirectional pairs is the sum over all pairs of components (A, B) where A comes before B in the DAG (i.e., there's a directed edge from A to B) of |A| * |B|, multiplied by 1 (since for each such pair, all a in A and b in B form a unidirectional pair (a,b)).\n\nBut how to maximize this sum? Since the DAG is a tournament, the maximum number of such pairs is achieved when the DAG is a linear order. For example, arrange the components in a sequence C1, C2, ..., Cm, where there is a directed edge from Ci to Cj if i < j. In this case, for each pair of components (Ci, Cj) with i < j, all pairs of nodes between Ci and Cj contribute |Ci| * |Cj| unidirectional pairs.\n\nSo, the total unidirectional pairs is the sum over all i < j of |Ci| * |Cj|.\n\nBut how to compute this sum?\n\nLet me think. Let the sizes of the components be s_1, s_2, ..., s_k. Then the sum is sum_{i < j} s_i * s_j.\n\nBut sum_{i < j} s_i s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2.\n\nBecause (sum s_i)^2 = sum s_i^2 + 2 * sum_{i<j} s_i s_j.\n\nSo, the total is (total^2 - sum_squares) / 2.\n\nBut in our case, the components are arranged in a DAG where each pair of components has a directed edge in one direction. So, arranging them in a linear order maximizes the sum of products between different components.\n\nSo, the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) / 2 - p', where p' is the number of pairs within the same component. Wait, no. Because the unidirectional pairs are between different components. The pairs within the same component are not unidirectional. Because if u and v are in the same component, they are in a strongly connected component, so they are mutually reachable. Hence, they are not counted as unidirectional pairs. So, the total unidirectional pairs is the sum of all pairs between different components, which is exactly the sum_{i < j} s_i s_j.\n\nBut how do we compute that?\n\nYes. So, for the given components, the sum is (total^2 - sum_squares) / 2. But since the total number of nodes is fixed (the minimal number of nodes), and the sum_squares is determined by the sizes of the components.\n\nBut how do we find the maximum possible value of this sum, given that the components are chosen to achieve the minimal number of nodes?\n\nWait, the minimal number of nodes is determined by the way we split p into the sum of C(k_i, 2). So, for the minimal number of nodes, the components are determined by the greedy approach. However, when there are multiple ways to split p into sum of C(k_i, 2) with the same total nodes, we need to choose the split that maximizes the sum of s_i s_j for i < j.\n\nWait, but the problem says that the first part is to find the minimal number of nodes. Once that is fixed, among all such graphs with that minimal number of nodes, find the maximum number of unidirectional pairs.\n\nSo, the question is: given that the components must be such that sum C(k_i, 2) = p, and the sum of k_i is minimal, how to choose the sizes of the components (k_i) such that the sum_{i<j} s_i s_j is maximized.\n\nBut how?\n\nBecause the sum_{i<j} s_i s_j depends on the sizes of the components. For example, if we have two components of sizes a and b, then sum is ab. If instead, we have components of sizes a-1 and b+1, then sum is (a-1)(b+1) = ab +a -b -1. Whether this is larger than ab depends on a -b -1. So, for example, if a > b, then increasing the size of one component and decreasing another may decrease the sum. So, perhaps the maximum sum is achieved when the components are as equal as possible.\n\nWait, but the sum of products is maximized when the sizes are as equal as possible. For example, if you have a fixed sum of s_i, the sum of products for pairs is maximized when the sizes are as equal as possible. Because the product of two numbers with a fixed sum is maximized when they are equal.\n\nBut in our case, the sum of s_i is fixed (the minimal number of nodes). However, the sum of C(k_i, 2) is fixed as p. So, given that, how to choose the components to maximize the sum of products.\n\nBut perhaps the way to maximize the sum is to have as few components as possible. For example, if we can merge some components, but that would require that the sum of C(k_i, 2) remains the same.\n\nWait, but the sum of C(k_i, 2) is fixed. For example, if you have two components of size 2 and 2, their contribution is 1 + 1 = 2. If you merge them into a component of size 4, then the contribution is 6, which is more than 2. But that would change the sum, so it's not allowed.\n\nAh, right. Because the sum of C(k_i, 2) must be exactly p. So, the components are determined by the decomposition of p into the sum of C(k_i, 2), and the minimal sum of k_i.\n\nSo, during the decomposition process, when we split p into C(k_i, 2), the way we split it may affect the sum of products. For example, for a given p, there might be multiple ways to split it into C(k_i, 2) with the same sum of k_i. For instance, let's say p=6. The minimal sum of nodes is 4 (one component of size 4, C(4,2)=6). Alternatively, could we have two components of size 3 (each contributes 3, total 6). Then sum of nodes is 3+3=6, which is larger than 4, so it's not the minimal. So, in this case, the minimal is achieved by one component of 4.\n\nBut in cases where there are multiple decompositions with the same sum of nodes, how do we choose the components to maximize the sum of products.\n\nBut perhaps, during the decomposition process, the way we split p into C(k_i, 2) with the minimal sum of nodes is unique. For example, in the first part of the problem, the greedy approach of taking the largest possible k each time may not always be the only way, but perhaps it's the way that leads to the minimal sum of nodes. However, for the same sum of nodes, there could be different component sizes.\n\nBut I'm not sure. Let's think of an example. Let's say p=5.\n\nGreedy approach: the largest k where C(k, 2) ≤5 is 3 (3*2/2=3). Then remaining p is 5-3=2. The largest k for 2 is 2 (C(2,2)=1). Then remaining p is 2-1=1. Largest k for 1 is 2 again. Now, sum of nodes is 3+2+2=7. Wait, but C(2, 2) is 1. So 3 + 1 + 1 = 5. But that would be 3 components: 3,2,2. Total nodes is 3+2+2=7.\n\nBut maybe there's a better way. Let's see. Suppose instead of taking 3, 2, 2 (sum 7), can we take 3 and 3? Because C(3,2) is 3, so 3+3=6, which is more than 5. No. So that's not allowed. What about 2 components: 3 and something else. For example, 3 and 2 (sum 3+1=4) which is less than 5. Then, need to take another component of 2 (adding 1) to get sum 5. So that's the same as before. So, the minimal sum of nodes is 7.\n\nBut what if there's another decomposition. Let's see. Suppose we take 2 components: one of size 3 (contribution 3) and one of size 3 (contribution 3), but that's sum 6, which is larger than 5. Not allowed. So no. So the decomposition is forced.\n\nAnother example: p=6. Greedy approach gives one component of size 4 (C(4,2)=6). Sum nodes is 4. Alternatively, could we have a component of size 3 (C(3,2)=3) and another of size 3 (another 3), sum is 3+3=6. Sum of nodes is 3+3=6, which is larger than 4. So minimal is 4.\n\nSo, the decomposition seems unique for the minimal sum of nodes. Thus, the way the components are chosen is uniquely determined by the greedy approach. Therefore, once we find the components via the greedy approach, the sum of products can be calculated based on the sizes of those components.\n\nBut how to find the components' sizes. Let's think again.\n\nThe first part of the problem is to find the minimal number of nodes. For that, we use the greedy approach of taking the largest possible k_i each time.\n\nOnce we have the list of component sizes, the second part is to compute the maximum number of unidirectional pairs, which is sum_{i<j} s_i * s_j, where s_i are the sizes of the components. As discussed earlier, this can be calculated as (total_nodes^2 - sum_squares) / 2.\n\nSo, for example, in the first sample input where p=3:\n\nThe minimal number of nodes is 3, with a single component of size 3. The sum of products is (3^2 - 3^2)/2 = 0. Which matches the sample output of 0.\n\nAnother example: input p=4. The minimal number of nodes is 5, with components of sizes 3 and 2 (since C(3,2)=3, C(2,2)=1, total 4). The sum_squares is 3^2 + 2^2 = 9 +4=13. Total nodes squared is 25. So (25-13)/2 = 6. Which matches the sample output of 5 6.\n\nSo, the plan is:\n\n1. For the given p, compute the minimal number of nodes by greedily choosing the largest k_i each time, as described.\n\n2. Once we have the list of component sizes, compute the sum of squares of their sizes.\n\n3. Compute (total_nodes^2 - sum_squares) // 2 as the maximum number of unidirectional pairs.\n\nBut how to implement the first part?\n\nLet's think about implementing the greedy approach.\n\nWe can start with p, and for each step:\n\nFind the maximum k such that k*(k-1)/2 ≤ p.\n\nThen subtract that value from p, add k to the list of component sizes, and repeat until p becomes 0.\n\nBut how to compute k for each step?\n\nWe can compute k as the floor of (sqrt(8*p + 1) + 1)/2. Let's see.\n\nLet me take p as current value.\n\nWe need to find the maximum k where k*(k-1)/2 ≤ p.\n\nSolving for k:\n\nk² -k - 2p ≤ 0.\n\nThe roots of the equation k² -k - 2p = 0 are [1 ± sqrt(1 + 8p)] / 2.\n\nThe positive root is [1 + sqrt(1 + 8p)] / 2.\n\nSo, the maximum integer k is floor( [sqrt(8p + 1) + 1]/2 )\n\nBut perhaps we need to adjust this, because sometimes the exact value may be a bit off.\n\nFor example, let's take p=3. Then sqrt(8*3 +1) = sqrt(25) =5. So [5 +1]/2 = 3. So k=3. Which is correct.\n\nAnother example: p=4. sqrt(33) is ~5.744. Adding 1 gives 6.744, divided by 2 is ~3.37, floor is 3. Which is correct.\n\nAnother example: p=1. sqrt(9) is 3. (3+1)/2=2. So k=2. Correct.\n\nSo, the formula for k is floor( (sqrt(8*p +1) +1)/2 )\n\nBut perhaps we can compute this using binary search for each step. However, for p up to 2e5, even with O(log n) steps, it's manageable.\n\nBut for code purposes, perhaps we can compute k as follows:\n\ndef max_k(p):\n\n    k = int( ( (1 + (8*p +1)**0.5 ) ) / 2 )\n\n    while k*(k-1)//2 > p:\n\n        k -=1\n\n    while (k+1)*k//2 <= p:\n\n        k +=1\n\n    return k\n\nWait, but maybe the initial calculation gives the correct value, but sometimes needs adjustment. So perhaps the code can be written as:\n\nCompute k as the integer part of the formula, then check and adjust.\n\nAlternatively, for code, we can compute k as the floor of the formula, then check if (k+1)*(k)/2 is <= p. If yes, increment k. Otherwise, keep it.\n\nBut perhaps for code, it's easier to compute via binary search.\n\nBut for the purposes of code, perhaps the following approach is sufficient.\n\nSo, during the process of building the component sizes, for each step, compute k as the maximum possible.\n\nOnce we have the list of component sizes, we can proceed to compute the sum of squares.\n\nNow, the code steps:\n\nRead p.\n\nIf p is 0, then the minimal number of nodes is 0 (but wait, the problem says that u != v. So for p=0, the graph must have no pairs (u, v) with u < v and mutually reachable. So, the graph can have multiple components. For example, with 0 nodes, but that's impossible. Wait, the problem says that the graph must have exactly p pairs. So for p=0, the graph can be any directed graph where no two nodes are mutually reachable. For example, a DAG with no cycles. But the minimal number of nodes required is 0? Or 1?\n\nWait, the problem says that the nodes are ordered pairs (u, v) with u != v. So, for p=0, the graph must have no such pairs. So, for example, a graph with 1 node has zero pairs (since u and v must be different). So, for p=0, the minimal number of nodes is 1? Or 0?\n\nBut according to the sample input, when p=0, the output is 0 0. Let's check the sample input given:\n\nSample input includes 0, and output is '0 0'.\n\nBut according to the note in the problem statement, the first test case is input 3, output 3 0. So for p=0, the output is 0 0. So, perhaps the minimal number of nodes is 0 when p=0. But how can a graph with 0 nodes exist? Probably, the problem allows for zero nodes. But perhaps the problem requires that the graph has at least one node? Let's check the sample input.\n\nWait, the third example in the sample input is p=0, output is 0 0. So according to that, when p=0, the minimal number of nodes is 0.\n\nBut that's a bit strange. However, according to the problem statement, the graph must contain exactly p ordered pairs (u, v) with u < v and mutually reachable. For p=0, the graph can be empty. But with zero nodes, there are no such pairs. So that's acceptable.\n\nSo, the code needs to handle p=0 as a special case.\n\nSo, the code steps:\n\nif p == 0:\n\n    print 0 0\n\nelse:\n\n    proceed with the steps.\n\nBut let's think again. For example, when p=0, the minimal number of nodes is 0. However, if the problem requires that the graph has at least one node, then for p=0, the minimal number of nodes is 1. But according to the sample input, when input is 0, the output is 0 0. So, the code must return 0 for p=0.\n\nBut how to handle that. Let's proceed with the code.\n\nNow, the code:\n\nWe need to handle p=0 as a special case.\n\nElse:\n\nInitialize total_nodes = 0\n\ncomponents = list()\n\ncurrent_p = p\n\nwhile current_p > 0:\n\n    compute k as the maximum possible such that k*(k-1)/2 <= current_p\n\n    add k to components\n\n    subtract k*(k-1)//2 from current_p\n\n    add k to total_nodes\n\nOnce we have components, compute sum_squares = sum( [x*x for x in components] )\n\nthen, the maximum unidirectional pairs is (total_nodes^2 - sum_squares) // 2\n\nBut wait, what about when there are multiple components? For example, components [3,2], sum_squares is 9 +4 =13. total_nodes is 5. 5^2 =25. (25-13)/2 =6. Which is correct.\n\nBut in the case of p=0, the code returns 0 0, which is correct.\n\nNow, let's test the sample inputs.\n\nSample Input 1: p=3.\n\ncurrent_p =3.\n\nk is computed as (sqrt(25)+1)/2 = (5+1)/2=3. So k=3. subtract 3, current_p becomes 0. components is [3]. sum_squares is 9. total_nodes is 3. (3^2 -9)/2 = (9-9)/2=0. So output is 3 0. Correct.\n\nSample Input 2: p=4. components are 3 (contribution 3) and 2 (contribution 1). sum_squares is 9+4=13. total_nodes is 5. (25-13)/2=6. Output is 5 6. Correct.\n\nSample Input 3: p=0. Output 0 0. Correct.\n\nAnother example: p=1. The components are [2]. sum_squares is 4. total_nodes is 2. (4-4)/2=0. So output is 2 0.\n\nAnother example: p=2. The maximum k is 2 (C(2,2)=1). subtract 1, current_p is 1. Again, take k=2. Subtract 1. current_p is 0. components are [2,2]. sum_squares is 4+4=8. total_nodes is 4. (16-8)/2=4. So output is 4 4.\n\nBut what if there's a better way? For p=2, is there a way to have a component of size 3? C(3,2)=3>2. No. So the minimal nodes is 2+2=4.\n\nSo the code works here.\n\nNow, the code needs to handle the case when p is zero. Also, for cases where the decomposition results in multiple components.\n\nNow, the code steps in Python:\n\nImplementing the calculation of k.\n\nBut how to compute k for each step?\n\nIn Python, for each current_p, compute k as the floor of (sqrt(8*current_p +1) +1)/2.\n\nBut we need to make sure that k*(k-1)/2 <= current_p.\n\nSo, in code:\n\nimport math\n\ndef get_max_k(p):\n\n    if p ==0:\n\n        return 0\n\n    # compute k as the floor of (sqrt(8p +1) +1)/2\n\n    sqrt_val = math.sqrt(8*p +1)\n\n    k = int( (sqrt_val +1) // 2 )\n\n    # Now check if k*(k-1)//2 <= p. If not, decrease.\n\n    while k*(k-1)//2 > p:\n\n        k -=1\n\n    # Also check if (k+1)*k//2 <=p ?\n\n    # Because sometimes the initial calculation may be too low.\n\n    # For example, if sqrt_val is exactly integer.\n\n    # Let's see:\n\n    # Suppose 8p+1 is a perfect square.\n\n    # For example, p=3: 8*3+1=25, sqrt_val=5. (5+1)/2=3. Which is correct.\n\n    # Another example: p=6: 8*6+1=49, sqrt_val=7. (7+1)/2=4. Which is correct.\n\n    # So, the initial calculation is correct.\n\n    # But perhaps due to floating point errors, the calculation may be wrong.\n\n    # So, perhaps after computing k, we need to check if (k+1)*k//2 <= p. If yes, then increment.\n\n    # Let me think of a case where the calculation may be wrong.\n\n    # For example, p= (k*(k-1))/2 -1.\n\n    # Let's take k=3. Then C(3,2) is 3. So p=2. sqrt(8*2+1)=sqrt(17)=~4.123. (4.123 +1)/2 is ~2.56, floor is 2. So k=2. Which is correct since 2*1/2=1 <=2. But (k+1)*k/2 = 3*2/2=3>2. So no. So the code returns k=2.\n\n    # So the code is correct.\n\n    # So perhaps the code is okay.\n\n    # So the function returns k.\n\n    return k\n\nBut in code, perhaps it's better to use binary search for each step to find the maximum k. However, for the purposes of efficiency, the above approach is acceptable.\n\nBut for code, perhaps the following:\n\nOnce current_p is given, compute k as the maximum possible.\n\nNow, code steps:\n\nRead p.\n\nif p ==0:\n\n    print 0 0\n\nelse:\n\n    components = []\n\n    current_p = p\n\n    while current_p >0:\n\n        k = ... as above\n\n        components.append(k)\n\n        current_p -= k*(k-1)//2\n\n    total_nodes = sum(components)\n\n    sum_squares = sum( [x*x for x in components] )\n\n    unidirectional_pairs = (total_nodes * total_nodes - sum_squares) // 2\n\n    print(total_nodes, unidirectional_pairs)\n\nBut let's test for p=4.\n\ncurrent_p starts as 4.\n\nk = floor( (sqrt(33)+1)/2 ) = (5.744 +1)/2 = 3.37, floor is 3. Check 3*2/2=3 <=4. Yes. So add 3 to components. current_p becomes 4-3=1.\n\nNext iteration: current_p=1.\n\nk = floor( (sqrt(8*1 +1)+1)/2 ) = sqrt(9)=3. (3+1)/2=2. So k=2. Check 2*1/2=1 <=1. Yes. Add 2. current_p becomes 0. components is [3,2]. total_nodes=5. sum_squares is 9+4=13. unidirectional is (25-13)/2=6. Correct.\n\nAnother example: p=2.\n\ncurrent_p=2. k is (sqrt(17)+1)/2 ~ (4.123 +1)/2 ~ 2.56 → 2. Check 2*1/2=1 ≤2. Yes. Subtract 1. current_p=1. Then again, k=2. Subtract 1. current_p=0. components are [2,2]. sum_squares is 8. total_nodes 4. (16-8)/2=4. Correct.\n\nAnother example: p=5. Let's see:\n\ncurrent_p=5.\n\nCompute k: sqrt(8*5 +1) = sqrt(41) ≈6.4. (6.4+1)/2 = 3.7 → floor is 3. Check 3*2/2=3 ≤5. Yes. Subtract 3. current_p=2. Next step: k=2, subtract 1. current_p=1. Then k=2 again. Subtract 1. current_p=0. components are [3,2,2]. sum is 3+2+2=7. sum_squares is 9+4+4=17. (7^2 -17)/2 = (49-17)/2= 32/2=16. So the output is 7 16.\n\nBut what if there is another decomposition for p=5? For example, 2 components of 3 and 3 (sum 3+3=6) which is larger than 5. No. So the decomposition is correct.\n\nNow, code implementation.\n\nBut what about when p is zero? For example, in the sample input, when p=0, the output is 0 0. But according to the code, the code will print 0 0. So that's handled.\n\nBut what if p=0, but the code is not handled? Let's see.\n\nNow, the code:\n\nRead p as input. Let's see.\n\nBut for the code:\n\nimport math\n\np = int(input())\n\nif p ==0:\n\n    print(\"0 0\")\n\nelse:\n\n    components = []\n\n    current_p = p\n\n    while current_p >0:\n\n        # compute k\n\n        sqrt_val = math.sqrt(8 * current_p +1)\n\n        k = int( (sqrt_val +1) // 2 )\n\n        # adjust k\n\n        while k*(k-1)//2 > current_p:\n\n            k -=1\n\n        components.append(k)\n\n        current_p -= k*(k-1)//2\n\n    total_nodes = sum(components)\n\n    sum_squares = sum(x*x for x in components)\n\n    unidirectional = (total_nodes * total_nodes - sum_squares) //2\n\n    print(f\"{total_nodes} {unidirectional}\")\n\nWait, but for p=0, the code returns 0 0. But what about when p=0, but the minimal number of nodes is 0? But according to the problem statement, the graph must have exactly p pairs. For p=0, the graph can be empty (zero nodes), which is acceptable.\n\nBut what about when the minimal number of nodes is zero? For example, for p=0, the minimal number of nodes is zero. So the code is correct.\n\nBut what if p is zero, but the code returns zero nodes, but for the second part, the maximum number of unidirectional pairs is zero. Which is correct.\n\nBut what if p is zero, but the code proceeds to calculate components? No, because the code checks if p is zero and returns immediately.\n\nNow, testing the code for the sample input.\n\nSample Input 3: 0 → output 0 0. Correct.\n\nSample Input 1: 3 → code returns 3 0. Correct.\n\nSample Input 2: 4 → code returns 5 6. Correct.\n\nAnother test case: p=1. Code returns 2 0. Because components is [2], sum_squares 4. total_nodes 2. (2^2 -4)/2 = 0. Correct.\n\nAnother test case: p=2. Components [2,2]. total_nodes 4. (16 - 8)/2 = 4. So output 4 4.\n\nAnother example: p=6. The code will take k=4 (C(4,2)=6). components is [4]. sum_squares is 16. total_nodes 4. (16-16)/2=0. So output 4 0. Which makes sense. Because all pairs are within the same component. So no unidirectional pairs.\n\nAnother example: p=5. components [3, 2, 2]. sum_squares 9+4+4=17. total_nodes=7. (7^2 -17)/2 = (49-17)/2 = 16. So output 7 16.\n\nBut what if there's another decomposition for p=5 with the same total_nodes? Let's see. For example, can we have components of 3 and 3? But C(3,2) is 3. 3+3=6>",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes. \n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly p ordered pairs (u, v) such that u < v and both u and v are mutually reachable. This translates to finding strongly connected components (SCCs) where the sum of combinations of node sizes in each SCC equals p.\n\n2. **Greedy Decomposition**: To minimize the number of nodes, we decompose p into sums of combinations of node sizes using a greedy approach. For each step, we find the largest possible size `k` such that the combination C(k, 2) is less than or equal to the remaining value of p.\n\n3. **Unidirectional Pairs Calculation**: Once the minimum number of nodes is determined, the maximum number of unidirectional pairs is calculated by considering the sum of products of sizes of different SCCs. This is derived from the formula: `(total_nodes^2 - sum_squares) // 2`, where `sum_squares` is the sum of squares of the sizes of each SCC.\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    import sys\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    components = []\n    current_p = p\n    while current_p > 0:\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Adjust k to ensure it's valid\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        components.append(k)\n        current_p -= k * (k - 1) // 2\n    \n    total_nodes = sum(components)\n    sum_squares = sum(x * x for x in components)\n    unidirectional = (total_nodes * total_nodes - sum_squares) // 2\n    print(f\"{total_nodes} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input integer `p` is read, which represents the number of reachable pairs required.\n2. **Special Case Handling**: If `p` is 0, the output is immediately set to \"0 0\" since no nodes are needed.\n3. **Greedy Decomposition**: For each iteration, the largest possible component size `k` is determined such that the combination C(k, 2) does not exceed the remaining value of `p`. This process continues until `p` is reduced to zero.\n4. **Calculating Unidirectional Pairs**: After determining the component sizes, the total number of nodes and the sum of their squares are computed. Using these values, the maximum number of unidirectional pairs is derived using the formula mentioned.\n\nThis approach ensures that we efficiently determine the minimum number of nodes and the maximum number of unidirectional pairs using mathematical decomposition and properties of combinations.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    import sys\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    components = []\n    current_p = p\n    while current_p > 0:\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Adjust k to ensure it's valid\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        components.append(k)\n        current_p -= k * (k - 1) // 2\n    \n    total_nodes = sum(components)\n    sum_squares = sum(x * x for x in components)\n    unidirectional = (total_nodes * total_nodes - sum_squares) // 2\n    print(f\"{total_nodes} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 661,
        "thoughts_token_count": 8192
    }
}