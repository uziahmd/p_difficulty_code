{
    "start": 1758312813.040593,
    "end": 1758313014.5010626,
    "start-formatted": "2025-09-20 05:13 KST",
    "end-formatted": "2025-09-20 05:16 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find the minimum number of edges to add to a graph to create an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I need to understand what's required. The problem says that the cycle must be simple (no repeated vertices) and of odd length. Also, each vertex occurs at most once in the cycle. Oh right, that's just a simple cycle. So the question is about making sure that after adding some edges, there's at least one such cycle.\n\nBut how do we approach this? Let's think about the properties of bipartite graphs. Because a bipartite graph doesn't have any odd-length cycles. So if the original graph is bipartite, then adding edges to create an odd cycle would require breaking that property. Conversely, if the graph is not bipartite, then it already contains an odd cycle, so t would be 0 and w would be 1 (since no edges need to be added). Wait, but wait. Wait, the problem says that we need to form a simple cycle of odd length. So if the graph already has such a cycle, then t is 0, and the number of ways is 1? Or maybe more?\n\nWait, the output requires w to be the number of ways to add t edges to form such a cycle. So if the graph already has an odd cycle, then t is 0, and the number of ways is 1? But that can't be right. Because there might be multiple existing odd cycles. However, the problem says that the answer is the number of ways to add t edges. But when t is zero, that means that there's already at least one such cycle. However, the way the problem counts w is the number of ways to add t edges to form such a cycle. But since no edges are added, the way is to choose nothing. However, the problem says that the answer should count the number of ways to add t edges. But if the graph already has an odd cycle, then there's exactly one way (adding zero edges), but maybe there are multiple existing cycles. However, the problem states that the answer is the number of ways to add edges to form a cycle. So perhaps when the graph already contains an odd cycle, then the answer is t=0 and w=1? Or is it possible that there are multiple ways to add zero edges (but that's just one way, since adding no edges is a single way)?\n\nWait, the problem says that two ways are considered equal if they have the same set of added edges. So for t=0, the only way is to add no edges. So regardless of how many existing odd cycles there are, the answer for w is 1. Because the question is about the number of ways to add t edges. So if the graph already has an odd cycle, then you don't need to add any edges. So the answer is t=0 and w=1. But that's not correct. For example, consider the sample input where the second case is 3 nodes connected in a triangle. That's already an odd cycle. So the output is 0 1. Which matches the sample. So yes, in that case, the answer is 0 1.\n\nSo the first thing to check is whether the graph is bipartite. If the graph is bipartite, then we need to add edges to make it non-bipartite. Otherwise, the answer is t=0 and w=1.\n\nBut how to check if the graph is bipartite. Well, for each connected component, we can check if it's bipartite. If any component is not bipartite, then the entire graph is not bipartite, and thus already contains an odd cycle. So in that case, t=0 and w=1.\n\nSo the problem reduces to:\n\nIf the graph is bipartite (all components are bipartite), then we need to find the minimal number of edges to add to make it non-bipartite. Otherwise, answer is 0 and 1.\n\nSo the first step is to check if the graph is bipartite. If not, output 0 1.\n\nIf the graph is bipartite, then we need to find the minimal t and count the ways.\n\nNow, how to make a bipartite graph non-bipartite by adding edges. Since a bipartite graph is a graph whose vertices can be divided into two sets such that all edges are between the sets. Adding an edge within a partition would create an odd-length cycle. Wait, for example, if you have a bipartition (A, B), then adding an edge between two nodes in A would create a cycle of length 2k+1. Because suppose there's a path from u to v in A through B, which would be even length. Adding the edge u-v would make a cycle of odd length.\n\nSo to create an odd cycle, we need to add an edge between two nodes in the same partition of some component. Therefore, for each connected component, which is bipartite, we can compute the number of nodes in each partition. Let's say the component has partitions of size a and b. Then, the number of possible edges that can be added between the same partition is (a choose 2) + (b choose 2). But adding any such edge would make the component non-bipartite. However, since the graph is bipartite, adding such an edge would create an odd cycle.\n\nSo, for each connected component, the minimal number of edges to add to make it non-bipartite is 1. Because adding any one such edge would do. However, the minimal t is 1, but how does that relate to the overall problem?\n\nWait, the problem asks for the minimal number of edges to add to create an odd cycle. So, if the graph is bipartite, then adding any edge between two nodes in the same partition of any component will create an odd cycle. So the minimal t is 1. But the question is, what is the minimal t? So t is 1, and w is the number of possible edges that can be added in this way across all components.\n\nWait, but perhaps there are multiple components. For example, if the graph has multiple connected components, each being bipartite. Then, adding an edge within a component's partition would create an odd cycle. So the minimal number of edges is 1. But for the count w, it's the number of possible edges that can be added in this way.\n\nSo the problem reduces to: if the graph is bipartite, then t is 1, and w is the sum over all connected components of (number of possible edges within each partition of the component). But wait, no. Because adding any such edge would create an odd cycle. So the number of ways is the total number of such possible edges across all components.\n\nBut wait, the problem says that adding edges must result in forming a cycle of odd length. So adding an edge between two nodes in the same partition of a component would create an odd cycle. So for each such edge, adding it would create such a cycle. Therefore, the number of ways is the sum over all components of (number of possible edges within each partition of the component).\n\nBut wait, the minimal t is 1. So the answer is t=1 and w is the sum of (a_i choose 2 + b_i choose 2) for each component, where a_i and b_i are the sizes of the two partitions of component i.\n\nBut wait, let's look at the sample input.\n\nSample Input 1:\n\n4 4\n\nEdges: 1-2, 1-3, 4-2, 4-3. Let's see the structure. Let's think about the connected components. The graph is connected (all nodes are connected). Let's check if it's bipartite.\n\nLet me try to color it. Let's take node 1. Assign color 0. Its neighbors are 2 and 3. Assign them color 1. Now, node 2 is connected to 4. So 4 gets color 0. Node 4 is connected to 3. So 3 is color 1. But node 1 is connected to 3. So that's okay. Wait, node 1 is color 0, node 3 is color 1. So the edges are okay. So the graph is bipartitioned as {1,4} and {2,3}. So for this component, a=2, b=2. The number of possible edges within the same partition is (2 choose 2) + (2 choose 2) = 1 + 1 = 2. Which matches the sample output where the first case outputs 1 2. So that's correct.\n\nAnother sample input is the third case: 3 nodes with 0 edges. So the graph is three separate components (each node is a component). Each component is trivially bipartite. For each component, the partitions are 1 and 0. So for each component, the number of possible edges is (1 choose 2) + (0 choose 2) = 0 + 0 = 0. But wait, no. Wait, for a single node, the bipartition is (1,0). So adding an edge between two nodes in the same partition. But in this case, the component is a single node. So the possible edges would be (1 choose 2) (which is 0) plus (0 choose 2) (also 0). So for each component, the contribution is zero. However, the third sample input is 3 nodes with 0 edges. So the answer is t=3 and w=1. Wait, why?\n\nWait, the sample output for that case is '3 1'. So according to that, the minimal number of edges to add is 3. How?\n\nBecause in this case, the graph is bipartite. To create an odd cycle, you need to add edges. But how?\n\nFor a graph with three disconnected nodes, each is a component. All are bipartite. So, adding any edge between two nodes in the same partition of a component. But each component is a single node. So, for each component, the partitions are size 1 and 0. So, there are no possible edges to add within the same partition. Therefore, how can we create an odd cycle?\n\nAh, here's the problem. If the graph is bipartite, but adding an edge between two different components. Wait, but how does that affect the bipartition?\n\nWait, if you have two separate bipartite components. Suppose you connect them with an edge. The combined graph may still be bipartite. For example, if you have two separate components, each bipartitioned as (A, B) and (C, D). If you connect a node from A to C, then the new graph can be bipartitioned as (A ∪ D, B ∪ C). So adding an edge between two components may not break the bipartition.\n\nSo, to make the graph non-bipartite, you need to add edges that create an odd-length cycle. So, in the case of the third sample input (three isolated nodes), how can we create an odd cycle?\n\nThe minimal number of edges to add would be 3, forming a triangle. Because adding three edges between the three nodes creates a cycle of length 3 (odd). But how can we get that?\n\nBut according to the earlier logic, the minimal t is 1. But in this case, adding a single edge would not create an odd cycle. Because the graph is bipartite. For example, adding an edge between node 1 and 2. Then the graph has two nodes connected by an edge. The bipartition is {1}, {2}, but adding the edge between them is allowed. So the graph is still bipartite. So adding a single edge won't create an odd cycle. Similarly, adding any single edge between two nodes in the same component (but in this case, the component is a single node, so adding an edge between two nodes would be in different components. Wait, but the components are separate. So, adding an edge between node 1 and 2 would connect them. Now, the component containing them would be a bipartitioned as {1, 2} (if you think of the edge as connecting them). Wait, no. The bipartition would be {1}, {2} for the two nodes connected by an edge. So that's bipartitioned. So the component is still bipartite. Therefore, adding any single edge would not create an odd cycle. Therefore, the minimal number of edges to add is 3. Wait, but how?\n\nSo, for the third sample input, the answer is t=3 and w=1. Which suggests that adding three edges is needed. How?\n\nLet me think. To create an odd cycle, you need to have a cycle of length 3, 5, etc. For three nodes, you need to connect all three in a triangle. So adding three edges. So that's the minimal number of edges to add. So in this case, t is 3 and w is 1. But according to our previous logic, how does that fit?\n\nOur previous approach was to compute for each connected component the number of possible edges that can be added within the same partition. But in the case of the third sample, each component is a single node, which can't contribute any edges. So the total number of possible edges to add is zero. But in this case, we need to add three edges. So our initial reasoning was wrong.\n\nHmm, so this indicates that the previous approach is incomplete. So what's wrong with the initial approach?\n\nThe initial approach assumed that adding an edge within a component's same partition would create an odd cycle. However, when the component is a single node, adding an edge between two nodes (which are in different components) would not create an odd cycle. So how do we handle cases where the graph is bipartite, but adding edges between different components?\n\nSo, the problem arises when the graph is bipartite, but all individual components are bipartite. How can we create an odd cycle?\n\nThe answer is that we need to add edges in such a way that the combined graph is not bipartite. This can be achieved by adding edges that create an odd-length cycle. However, in the case of multiple components, adding edges between them may or may not create such a cycle.\n\nSo, for example, if we have two separate components. Each is bipartite. Suppose we add an edge between two nodes in the same partition of their respective components. Then, the new component would have an odd cycle. Let me think. Suppose component 1 has partitions A and B. Component 2 has partitions C and D. If we add an edge between a node in A and a node in C. Then, the new component can be bipartitioned as (A ∪ D) and (B ∪ C). So the edge between A and C is between the two partitions. So the graph remains bipartite. However, if we add an edge between a node in A and a node in C, and another edge between a node in B and a node in D, then the combined graph may have some structure. But perhaps I need to think of a different approach.\n\nAlternatively, perhaps the minimal number of edges required to make the graph non-bipartite is determined by the number of components. For example, if the graph is bipartite and has k connected components, then the minimal number of edges to add is (k - 1) + 1 = k? Or something else?\n\nWait, here's an idea. For a bipartite graph, the minimal number of edges to add to make it non-bipartite depends on the number of connected components. Because, if the graph is bipartite and has k components, then adding edges between components can create a situation where the graph is no longer bipartite.\n\nBut how?\n\nLet me think. Suppose we have two components. Each is bipartite. Let's say component 1 has partitions A and B, component 2 has partitions C and D. Suppose we add an edge between A and C, and another edge between B and D. Now, the combined graph is still bipartitioned as (A ∪ D) and (B ∪ C). So adding edges between the components may not help.\n\nBut if we add an edge between A and A (but that's in the same component, but the component is bipartitioned. Wait, but adding an edge between two nodes in the same partition of a component would create an odd cycle. So for example, if you have a component that is bipartitioned into A and B, and you add an edge between two nodes in A, then that creates an odd cycle. So the minimal number of edges to add is 1, regardless of the number of components. But that contradicts the third sample input.\n\nAh! In the third sample input, the graph has three components (each a single node). So, each component is bipartitioned into (1, 0). So, adding an edge between two nodes in the same partition of a component. But for each component, there's only one node. So, for example, if you add an edge between node 1 and node 2, then they are in different components. So, the new component would consist of nodes 1 and 2 connected by an edge. The bipartition is {1}, {2}, which is bipartitioned. So adding that edge does not create an odd cycle. Hence, in this case, adding a single edge is not sufficient. Therefore, the previous approach was incorrect. The mistake was assuming that adding any edge within a component's same partition would work, but that's only possible when the component has at least two nodes in one of its partitions.\n\nSo, the correct approach is:\n\nIf the graph is bipartite, then:\n\nCase 1: There exists at least one connected component with at least two nodes. Then, the minimal t is 1, and the number of ways is the sum over all components of (a_i choose 2 + b_i choose 2), where a_i and b_i are the sizes of the two partitions of component i.\n\nCase 2: All connected components are single-node components (so n is the number of components, each with one node). Then, the minimal number of edges to add is 3 (to form a triangle), and the number of ways is 1 (only one way to choose three edges to form a triangle, but since the graph has no edges, the number of ways is the number of possible triangles, which is C(n,3) if n >=3. Wait, but in the third sample input, n=3 and m=0. So the number of ways is 1. Because the only way is to add all three edges between the three nodes. So for that case, the answer is t=3 and w=1.\n\nWait, but how do we generalize this?\n\nSo, the problem comes down to two scenarios when the graph is bipartite:\n\n1. If there is at least one connected component with size ≥2. Then, the minimal t is 1, and the number of ways is the sum of (a_i choose 2 + b_i choose 2) for each component. Because adding any of these edges would create an odd cycle.\n\n2. If all components are single-node components (n is the number of components, each with one node). Then, the minimal number of edges to add is 3 (since you need to form a triangle), and the number of ways is 1 (since there's only one way to add all three edges of a triangle). Wait, but in this case, the number of ways depends on the number of possible triangles. For example, if there are 4 nodes, then the number of ways would be C(4,3) * 1 (since for each triplet of nodes, adding the three edges forms a triangle). However, the problem says that the answer is the number of ways to add t edges. So for the case when the graph is made of all single-node components, and the minimal t is 3, the number of ways is the number of possible triplets of nodes, each of which forms a triangle by adding the three edges. So for n=3, the answer is 1. For n=4, the answer is 4 (C(4,3) = 4). But according to the third sample input, which has n=3, the output is 3 1.\n\nSo how do we detect this case?\n\nSo the steps for solving the problem:\n\nFirst, check if the graph is bipartite. If not, output 0 1.\n\nIf it is bipartite:\n\nCheck if there exists at least one connected component with size ≥ 2. If yes:\n\nThen t = 1, and w is the sum for each component of (a_i choose 2 + b_i choose 2).\n\nElse:\n\nAll components are single-node. Then, t is 3, and w is the number of ways to choose 3 nodes and add all edges between them. Which is C(n,3). However, in the third sample input, n=3, C(3,3)=1, which matches the sample output. So for this case, the answer is t=3 and w=C(n,3).\n\nBut wait, in the third sample input, the output is 3 1, which aligns with this.\n\nBut what if n < 3? Like n=2. Then, the graph is two single-node components. How can we form a cycle of odd length? Well, a cycle must have at least 3 nodes. So in this case, it's impossible. But according to the problem statement, the graph can have n=1? Wait, the input constraints say n can be up to ... Well, the problem says that the graph is not necessarily connected. But the input is given with n and m. So for example, if n=2 and m=0. Then, the graph is two components. How to form a cycle? It's impossible. But according to the problem statement, the output must be t and w. However, the problem says that the cycle must have more than one vertex. So for a cycle, it must have at least 3 vertices. So in this case, if the graph is bipartite (which it is), and all components are single-node, but n is less than 3, then it's impossible to form a cycle. But according to the problem statement, the input is such that it's possible. Or is there a guarantee that the answer exists?\n\nWait, the problem says that the graph can have any number of nodes. But the problem says that the output must be t and w. So for example, if n=1, then it's impossible to form a cycle. But the problem says that the graph is given with n and m, but in this case, the answer would require t to be ... Well, how can you form a cycle with one node? Impossible. So the problem must have constraints that ensure that the answer is possible. However, looking back at the problem statement, the sample input includes n=3, and the output for that case is 3 1. So what if n=2, m=0? How would that be handled?\n\nBut according to the problem statement, the input is such that the graph can be modified to have a cycle. But the problem doesn't state that. So perhaps the code needs to handle such cases. However, the problem says that the graph may not be connected, but the output requires to find the minimal t. So, for example, if n=2, the minimal t is 3? No, because you need at least 3 nodes to form a cycle. Therefore, in this case, it's impossible. But according to the problem statement, the input may not allow that. However, the problem says that the input is given as per the constraints, but perhaps there's no such constraints. So, the code must handle all possible cases.\n\nBut according to the problem's sample input, the third case is n=3, m=0. Which requires adding 3 edges to form a cycle. So, in general, when the graph is bipartite and all components are single nodes (i.e., n is the number of components, and each is size 1), then:\n\nIf n < 3: it's impossible to form a cycle. But according to the problem statement, the output must be provided. However, the problem says that the graph is given, and the answer is required. So perhaps the problem ensures that n ≥ 3 in such cases. Or perhaps the code must account for that.\n\nBut how to handle this?\n\nWell, in the code, when checking the case where all components are single nodes, we need to check if n ≥ 3. If n < 3, then it's impossible to form a cycle, but according to the problem's note, the sample input includes a case where n=3. So, perhaps the problem assumes that it's always possible. But the problem statement says that the graph may not be connected, but the output requires to find the answer. So, for example, when n=1, the answer would be impossible. However, the problem statement says that the graph has n vertices, and the output must be printed. But in that case, the code would have to return something. However, the problem's note says that the sample input includes the third case where n=3 and m=0, and the answer is 3 1. So, for the case when all components are single nodes and n ≥ 3, then the minimal t is 3, and the number of ways is C(n,3).\n\nSo, in the code, we can proceed as follows:\n\nAfter checking that the graph is bipartite, check if there is at least one component with size ≥2. If yes, then t=1 and w is the sum of (a_i choose 2 + b_i choose 2) for each component. Else, if n ≥3, then t=3 and w = C(n,3). Else, if n <3, then what? Well, for n=1, you can't form a cycle. For n=2, you can't form a cycle. So the answer would be t=3 (but adding 3 edges is impossible, since there are only 2 nodes. So perhaps the code must handle this. However, the problem says that the input is such that the answer exists. But I'm not sure. However, the problem says that the graph is given, and the answer must be computed. So perhaps the code should assume that n is ≥3 when in this case.\n\nBut how to handle this?\n\nIn the problem statement, the third sample input is n=3, m=0. So the code for that case would have to compute C(3,3) = 1, which is correct.\n\nSo, putting all together, the steps are:\n\nCheck if the graph is bipartite. If not, output 0 1.\n\nElse:\n\nCheck if there exists at least one component with size ≥2. If yes:\n\nt=1, and w is the sum over all components of (a_i choose 2 + b_i choose 2).\n\nElse:\n\nif n >=3:\n\nt=3, w = C(n,3)\n\nelse:\n\nBut what? For example, n=2, m=0. The answer would require adding edges to form a cycle. But with two nodes, you can't form a cycle. So, the answer would be impossible. However, the problem says that the answer exists. But perhaps the problem guarantees that n ≥3 in such cases. But since the problem allows for any input, the code must handle it.\n\nBut according to the problem's note, the sample input includes n=3. So, perhaps the code can assume that in the case where all components are single nodes, then n is ≥3. However, the code must handle cases where n is less than 3. But how?\n\nBut according to the problem statement, the output must be printed. So, perhaps in such cases, the code would output t= (something), but how?\n\nWait, the problem says that the cycle must consist of more than one vertex. So, for n=1, it's impossible. For n=2, you can't form a cycle. So in those cases, the answer would be impossible. However, the problem says that the graph is given and you need to find the answer. So, perhaps the problem guarantees that the answer exists. For example, the input may not have cases where n is 1 or 2 and the graph is bipartite (with all components being single nodes). But how to know?\n\nWell, the problem says that the graph can be not connected. But for the code, perhaps we can proceed as follows:\n\nIn the case where all components are single nodes:\n\nif n < 3 → then it's impossible to form a cycle. But according to the problem statement, perhaps this is not possible. However, the code needs to handle it. But how?\n\nBut according to the problem's sample input, for n=3, the answer is 3 1. So, the code can proceed under the assumption that when all components are single nodes, then n ≥3. Otherwise, perhaps the answer is t= (n - 1) + 1? Not sure.\n\nBut given that the problem's sample includes n=3, and the code is supposed to pass all test cases, perhaps the code should proceed as follows:\n\nIn the case where all components are single nodes, then:\n\nif n >=3:\n\nt = 3, w = C(n,3)\n\nelse:\n\nt is impossible. But the problem says that the answer must exist. So perhaps the code can assume that in this case, n >=3.\n\nThus, the code proceeds under that assumption.\n\nNow, the next step is to implement this logic.\n\nSo, the plan is:\n\nImplement a function to check if the graph is bipartite. For each connected component, perform BFS/DFS to check if it's bipartite. If any component is not bipartite, then the graph is not bipartite, and the answer is 0 1.\n\nElse, proceed to calculate the required t and w.\n\nNow, for each connected component, during the BFS/DFS, we can track the size of each partition (a_i and b_i). For example, for each component, during the BFS, we assign colors (0 or 1) to the nodes. Then, the count of nodes with color 0 and color 1 is a_i and b_i. For each component, the number of possible edges that can be added within the same partition is (a_i choose 2) + (b_i choose 2). Summing this over all components gives the w for the case when t=1.\n\nNow, the code needs to check whether there is at least one component with size ≥2. For example, if a component has a_i + b_i ≥ 2 (i.e., the component has at least two nodes). So, during the processing of the components, we can check if any component has size ≥2.\n\nSo, steps:\n\nRead the graph.\n\nCheck if the graph is bipartite. If not, output 0 1.\n\nElse:\n\nCheck if there is any component with size ≥2. If yes:\n\nt=1, w is sum over all components (a_i choose 2 + b_i choose 2).\n\nElse:\n\nt=3, w = C(n,3).\n\nNow, the code must implement this.\n\nNow, the problem is to implement the bipartition check and track the sizes of the partitions for each component.\n\nSo, for each connected component, we can run BFS and track the color of each node. For each component, we can count the number of nodes in each color group.\n\nNow, let's think about the code.\n\nImplementing Bipartition Check:\n\nWe can represent the graph as an adjacency list.\n\nFor each node not visited, perform BFS. Assign colors (0 and 1). For each neighbor, check if it's colored. If not, assign the opposite color. If it is colored, check if it's the opposite color. If not, the graph is not bipartite.\n\nNow, during this process, we can track for each component the count of nodes in each color.\n\nOnce we have this information, we can proceed.\n\nNow, code steps:\n\nRead n and m.\n\nBuild adjacency list.\n\nInitialize visited array.\n\nFor each node from 1 to n:\n\n   if not visited, perform BFS/DFS to check bipartition.\n\n   during this, track color of each node and the size of each partition.\n\n   if during this process, the graph is not bipartitionable, then set a flag.\n\nOnce all components are processed, if the graph is not bipartitionable, output 0 1.\n\nElse:\n\nCheck if any component has size ≥2. How?\n\nFor each component, the size is a_i + b_i. If any component has a_i + b_i ≥2, then yes.\n\nSo, during processing, we can track this.\n\nOnce that is determined, if yes:\n\nsum_w = sum over all components of (a_i choose 2 + b_i choose 2)\n\noutput 1 sum_w.\n\nElse:\n\nif n >=3:\n\nsum_w = n*(n-1)*(n-2)//6\n\noutput 3 sum_w.\n\nelse:\n\nBut what? For example, n=2. Then, it's impossible to form a cycle. However, the problem says that the answer must exist. So perhaps the input will not have such cases. But the code must handle them. However, according to the problem's sample input, the third case is n=3, m=0. So for the code, we can proceed under the assumption that when all components are single nodes, then n ≥3.\n\nSo, in code, we can proceed with that.\n\nNow, let's think about the sample input.\n\nSample Input 1: 4 nodes, 4 edges. The graph is connected and bipartitioned. The component has a_i=2 and b_i=2. So sum_w is 1+1=2. Output is 1 2.\n\nSample Input 2: 3 nodes, 3 edges. The graph is a triangle. It's not bipartitioned. So output is 0 1.\n\nSample Input 3: 3 nodes, 0 edges. The graph is bipartitioned (each component is single node). So no component has size ≥2. So t=3, w= C(3,3)=1. Which matches the sample.\n\nAnother test case: n=2, m=0. The graph is bipartitioned. All components are single nodes. So, since n=2 <3, what to do? According to the code, it would output 3 and C(2,3) which is 0. But that's invalid. However, the problem may not have such test cases. But the code needs to handle it. However, since C(2,3) is zero, the code would output 3 0, which is invalid. But according to the problem statement, the answer must be valid. So perhaps the code should check for n ≥3 in this case.\n\nSo, in code, when handling the case where all components are single nodes, we can check if n ≥3. If not, then it's impossible. However, the problem says that the answer exists. So perhaps the code can assume that in such cases, n ≥3.\n\nBut how to proceed?\n\nIn code:\n\nwhen all components are single nodes:\n\nif n >=3:\n\n   t=3, w = n*(n-1)*(n-2)//6\n\nelse:\n\n   # impossible, but what to do?\n\nBut according to the problem statement, the answer must exist. So perhaps the code can assume that n ≥3 in this case.\n\nSo, the code proceeds with that.\n\nNow, coding.\n\nNow, the code must read input from stdin. The input can have multiple test cases? Wait, no. Looking at the sample input:\n\nThe first line shows that the input is given as a list of inputs. Wait, the sample input shows:\n\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\nBut this seems to be multiple test cases. However, the problem statement says that the input is for a single test case. Wait, no. Looking back at the problem statement:\n\nThe input is given as:\n\nThe first line of the input contains two integers n and m. Then m lines follow.\n\nBut in the sample input, the user provided multiple test cases. However, in the actual problem, the input is a single test case. The sample input shows multiple test cases, but perhaps that's for the purpose of the example. For example, the sample input shows three different test cases and their outputs. However, the actual program must read a single test case.\n\nWait, the problem says:\n\nInput:\n\nThe first line of the input contains two integers n and m...\n\nSo the code should read a single test case. However, the sample input shows three test cases, but that's probably for the purpose of the example. For example, in the sample input, the first line is the first test case, then the second line is the second test case, etc. But the actual program should read a single test case. So the code should read from standard input, which for the problem is a single test case.\n\nSo the code should read n and m, then m lines of edges.\n\nNow, the code in Python:\n\nImplement the steps.\n\nFirst, read n and m, then the edges.\n\nImplement BFS for bipartition check.\n\nLet's proceed.\n\nImplementing Bipartition Check:\n\nWe can use a color array. For each node, color is -1 (unvisited), 0 or 1.\n\nFor each unvisited node, start BFS.\n\nInitialize color as 0.\n\nFor each node in the queue, iterate through neighbors. For each neighbor, if not colored, assign opposite color and add to queue. Else, check if color is opposite. If not, return False.\n\nAlso, during this process, for each component, track the count of color 0 and color 1.\n\nNow, code:\n\nimport sys\n\nfrom collections import deque\n\ndef main():\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n+1)]\n\n    for _ in range(m):\n\n        u, v = map(int",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and the number of ways to achieve this. The solution involves checking if the graph is bipartite, as a bipartite graph cannot contain odd-length cycles.\n\n### Approach\n1. **Check Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent nodes share the same color. If the graph is not bipartite, it already contains an odd-length cycle, so the answer is 0 edges and 1 way.\n2. **Component Analysis**: If the graph is bipartite, we analyze each connected component. If any component has at least two nodes, we can form an odd cycle by adding one edge within the same partition of that component.\n3. **Special Case Handling**: If all components are single-node components (i.e., the graph is completely disconnected), forming an odd cycle requires creating a triangle (3 nodes), which necessitates adding 3 edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for start in range(1, n + 1):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    total_ways = 0\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            total_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n    \n    if has_large_component:\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"0 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartiteness Check**: The graph is checked for bipartiteness using BFS. If any component is not bipartite, we immediately know there's an existing odd cycle.\n2. **Component Analysis**: For each connected component, we count the nodes in each partition. If any component has at least two nodes, the minimum edges needed is 1, and the number of ways is calculated based on possible intra-partition edges.\n3. **Special Case Handling**: If all components are single-node, forming a triangle (3 nodes) requires adding 3 edges. The number of ways to choose 3 nodes from `n` is calculated using combinations.\n\nThis approach ensures that we efficiently determine the minimum edges and ways to form an odd-length cycle, leveraging graph properties and combinatorial calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for start in range(1, n + 1):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    total_ways = 0\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            total_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n    \n    if has_large_component:\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"0 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 822,
        "thoughts_token_count": 8192
    }
}