{
    "start": 1758008330.4961107,
    "end": 1758008519.9848144,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The task is to find two non-overlapping vouchers whose total duration is exactly x, and their combined cost is minimal. If there's no such pair, return -1.\n\nFirst, I need to understand the problem correctly. So each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need two vouchers i and j where their durations add up to x. Also, they must not overlap. That means either the first ends before the second starts, or vice versa.\n\nSo the approach would be to find all pairs of vouchers where the sum of their durations is x, and they don't overlap, then find the minimum cost among those pairs.\n\nBut with n up to 2e5, checking all possible pairs would be O(n²), which is way too slow. So we need a smarter approach.\n\nLet me think. For each voucher, if I can find another voucher that has duration (x - duration_i) and doesn't overlap with it, then I can consider their sum. But how to efficiently find such vouchers?\n\nMaybe we can pre-process vouchers by their duration. Let's group vouchers by their duration. Then for each voucher with duration d, look for vouchers with duration (x - d). But even then, how do we check for non-overlapping?\n\nAlternatively, for each voucher, we can check for vouchers that have the required duration and are either completely before or after it.\n\nBut again, how to do this efficiently?\n\nLet's think about the steps:\n\n1. Precompute for each possible duration d, the list of vouchers with that duration. Then, for each voucher with duration d, we can look for vouchers with duration (x - d).\n\nBut even then, for each voucher, we need to find the minimum cost of vouchers with duration (x - d) that don't overlap with it.\n\nBut how to find those quickly?\n\nAnother idea: For each possible duration d, we can have two structures:\n\n- The minimum cost of vouchers with duration d that end before a certain day (so that they can be paired with vouchers starting after that day).\n- Similarly, the minimum cost of vouchers with duration d that start after a certain day (so that they can be paired with vouchers ending before that day).\n\nWait, maybe for each duration, we can sort the vouchers by their end time and keep track of the minimum cost up to that point. Similarly, sort by start time and track the minimum cost from that point onwards.\n\nLet me think. Suppose we have a voucher A with duration d. We need to find a voucher B with duration (x - d) that ends before A's start (so that B is before A). Or a voucher B that starts after A's end (so that A is before B).\n\nSo for each voucher A, we can check two possibilities:\n\nCase 1: Find a voucher B with duration (x - d) that ends before A's li. Then, the earliest possible B would be any such voucher, and we want the minimum cost among them.\n\nCase 2: Find a voucher B with duration (x - d) that starts after A's ri. Again, find the minimum cost among such vouchers.\n\nIf we can find these minima quickly for each voucher, then we can compute the total cost for each possible pair and track the minimum overall.\n\nSo the plan is:\n\n- Preprocess for each duration, two arrays:\n\n   a) sorted by end time, and for each position in the sorted list, track the minimum cost up to that point. This allows us to query for the minimum cost of vouchers with duration d that end before a certain day.\n\n   b) sorted by start time, and for each position in the sorted list, track the minimum cost from that point onwards. This allows us to query for the minimum cost of vouchers with duration d that start after a certain day.\n\nBut how to structure this.\n\nLet me break it down.\n\nFor each duration value, say, d, we can have:\n\n- A list of vouchers with duration d, sorted by their end time. Then, for each voucher in this list, we can create a prefix minimum array. So, for any given day 't', we can find the maximum end time in the list that is <= t, and get the minimum cost up to that point.\n\nSimilarly, for the same duration d, we can have a list sorted by start time, and for each position, a suffix minimum array. For a given day 't', we can find the earliest start time in the list that is >= t, and get the minimum cost from that position onwards.\n\nBut how to perform these queries efficiently?\n\nFor example, for case 1, when looking for vouchers B with duration (x - d) that end before A's li.\n\nWe can take the list of vouchers with duration (x - d), sorted by end time. For each such voucher, we can binary search for the largest end time that",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, while minimizing their total cost. If no such pair exists, we return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This allows us to efficiently look up vouchers with specific durations when needed.\n2. **Sort and Preprocess**: For each duration, we maintain two sorted lists:\n   - One sorted by the end time of vouchers, used to find the minimum cost of vouchers ending before a certain day.\n   - Another sorted by the start time of vouchers, used to find the minimum cost of vouchers starting after a certain day.\n3. **Prefix and Suffix Minimum Arrays**: For each sorted list, we precompute prefix minimum arrays for end-sorted lists and suffix minimum arrays for start-sorted lists. These arrays help in quickly finding the minimum cost for valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by end, sorted by start\n    # Also create prefix min for end-sorted, and suffix min for start-sorted\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        end_sorted = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min_end = []\n        min_cost = float('inf')\n        for l, r, cost in end_sorted:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        start_sorted = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min_start = [0] * len(start_sorted)\n        min_cost = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            l, r, cost = start_sorted[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (end_sorted, prefix_min_end, start_sorted, suffix_min_start)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in preprocessed:\n            continue\n        # Check for vouchers with duration target_d that end before l1\n        end_sorted, prefix_min_end, start_sorted, suffix_min_start = preprocessed[target_d]\n        # Binary search in end_sorted for the largest end <= l1 - 1\n        # Since end_sorted is sorted by end time\n        left, right = 0, len(end_sorted) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if end_sorted[mid][1] <= l1 - 1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min_end[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check for vouchers with duration target_d that start after r1 + 1\n        # Binary search in start_sorted for the first start >= r1 + 1\n        left, right = 0, len(start_sorted) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if start_sorted[mid][0] >= r1 + 1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min_start[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by its start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient lookup.\n3. **Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix and suffix minimum arrays are created to quickly determine the minimum cost of valid non-overlapping vouchers.\n4. **Finding Valid Pairs**: For each voucher, we check for valid pairs with the required complementary duration, ensuring they do not overlap. Binary search is used to efficiently find valid vouchers and their minimum costs.\n\nThis approach ensures that we efficiently check all possible valid pairs while keeping the complexity manageable, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by end, sorted by start\n    # Also create prefix min for end-sorted, and suffix min for start-sorted\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        end_sorted = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min_end = []\n        min_cost = float('inf')\n        for l, r, cost in end_sorted:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        start_sorted = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min_start = [0] * len(start_sorted)\n        min_cost = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            l, r, cost = start_sorted[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (end_sorted, prefix_min_end, start_sorted, suffix_min_start)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in preprocessed:\n            continue\n        # Check for vouchers with duration target_d that end before l1\n        end_sorted, prefix_min_end, start_sorted, suffix_min_start = preprocessed[target_d]\n        # Binary search in end_sorted for the largest end <= l1 - 1\n        # Since end_sorted is sorted by end time\n        left, right = 0, len(end_sorted) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if end_sorted[mid][1] <= l1 - 1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min_end[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check for vouchers with duration target_d that start after r1 + 1\n        # Binary search in start_sorted for the first start >= r1 + 1\n        left, right = 0, len(start_sorted) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if start_sorted[mid][0] >= r1 + 1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min_start[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1200,
        "thoughts_token_count": 1023
    }
}