{
    "start": 1758313547.1800036,
    "end": 1758313600.9121652,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nThe problem is about finding two non-overlapping vouchers whose total duration equals exactly x days, and their combined cost is minimized. If there's no such pair, return -1.\n\nSo the input is n vouchers, each with li (departure day), ri (return day), and cost. The duration of a voucher is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations sum to x, and they don't overlap. And find the minimal total cost.\n\nFirst, I need to think about how to approach this efficiently. Since n can be up to 2e5, O(n²) approaches are definitely out of the question. So we need something smarter.\n\nLet me think about the constraints. For two vouchers to not overlap, one must end before the other starts. So for voucher A and B, either A ends before B starts (ri < lj) or B ends before A starts (rj < li).\n\nThe durations of the two vouchers must add up to x. Let's denote duration of voucher i as d_i = ri - li + 1. So we need d_i + d_j = x.\n\nSo for each voucher, if we can find another voucher whose duration is (x - d_i), and which doesn't overlap with it, then we can consider their sum.\n\nBut how do we efficiently find for each voucher, the minimal cost voucher of duration (x - d_i) that doesn't overlap with it?\n\nHmm. Let's think of grouping vouchers by their duration. For example, for each possible duration d, we can have a list of vouchers with that duration. Then, for each voucher with duration d, we can look into the group of vouchers with duration (x - d), and find the minimum cost voucher that doesn't overlap with the current one.\n\nBut even that approach might be tricky. How do we efficiently check for non-overlapping?\n\nAlternatively, maybe we can pre-process for each possible duration, the minimal cost vouchers that end before a certain day, or start after a certain day.\n\nWait, here's an idea. For each voucher, let's say we have a duration d. Then, we need another voucher with duration x - d. Let's call that target duration t = x - d.\n\nFor the current voucher, which has a start and end time (li, ri), we need to find a voucher of duration t that ends before li (so that it doesn't overlap), or starts after ri (so that it doesn't overlap). But since the other voucher could be either before or after, perhaps we can precompute for each duration t, the minimal cost voucher that ends before a certain day, and the minimal cost voucher that starts after a certain day.\n\nBut how?\n\nLet me think. Suppose I have all vouchers grouped by their duration. For each duration, I can precompute two structures:\n\n- For vouchers of duration t, sorted by their end time, and for each end time, keep track of the minimum cost up to that point. So that given a start time s, I can find the earliest end time that is less than s, and get the minimal cost among those.\n\nSimilarly, for vouchers of duration t, sorted by their start time, and for each start time, keep track of the minimum cost from that point onwards. So that given an end time e, I can find the earliest start time that is greater than e, and get the minimal cost among those.\n\nWait, but how would that work? Let's take an example. For vouchers of duration t, if I want a voucher that ends before some day s (so that it doesn't overlap with a voucher starting at s), then I can find the minimal cost among all vouchers of duration t that end before s.\n\nSimilarly, for vouchers of duration t that start after some day e (so that they don't overlap with a voucher ending at e), find the minimal cost among those.\n\nIf I can pre-process these for each duration, then for each voucher, I can check both possibilities (other voucher before or after) and find the minimal cost.\n\nSo the plan is:\n\n1. Preprocess for each duration d, the list of vouchers with that duration. For each such list, sort them by their end time and also by their start time. Then, for each possible query (like find the minimal cost voucher of duration t that ends before a certain day s, or starts after a certain day e), we can perform a binary search.\n\nBut how to compute the minimal cost for vouchers of duration t that end before s?\n\nFor example, suppose we have vouchers of duration t sorted by their end time. For each such voucher, we can create a prefix minimum array. So for each position in the sorted list, we know the minimum cost up to that point. Then, given a day s, we can binary search the latest end time that is less than",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This allows us to efficiently look up vouchers with a specific duration when needed.\n2. **Preprocess for Efficient Querying**: For each duration, preprocess the vouchers to allow efficient querying of the minimum cost voucher that ends before a certain day or starts after a certain day. This involves sorting vouchers by their end time and start time, and maintaining prefix minimum arrays for quick lookup.\n3. **Check Non-overlapping Conditions**: For each voucher, check if there exists another voucher of the required duration that either ends before the current voucher starts or starts after the current voucher ends. Use binary search to efficiently find these vouchers and compute the minimum cost.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time, and sorted by start time\n    # Also, for each sorted list, create prefix min and suffix min arrays\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array for end-sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array for start-sorted list\n        suffix_min_start = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Get the preprocessed data for target_d\n        sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start = preprocessed[target_d]\n        \n        # Check for vouchers ending before l1\n        # Binary search in sorted_by_end for the largest end <= l1 - 1\n        ends = [v[1] for v in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1) - 1\n        if pos >= 0:\n            min_cost = prefix_min_end[pos]\n            min_total = min(min_total, cost1 + min_cost)\n        \n        # Check for vouchers starting after r1\n        # Binary search in sorted_by_start for the first start >= r1 + 1\n        starts = [v[0] for v in sorted_by_start]\n        pos = bisect.bisect_left(starts, r1 + 1)\n        if pos < len(starts):\n            min_cost = suffix_min_start[pos]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n- **Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix and suffix minimum cost arrays are created to allow efficient minimum cost queries.\n- **Binary Search**: For each voucher, we use binary search to find the best non-overlapping voucher of the required duration, ensuring efficient query times.\n- **Combining Costs**: For each valid pair of non-overlapping vouchers, the total cost is computed and the minimum is tracked.\n\nThis approach ensures that we efficiently check all possible pairs of vouchers while adhering to the constraints, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time, and sorted by start time\n    # Also, for each sorted list, create prefix min and suffix min arrays\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array for end-sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array for start-sorted list\n        suffix_min_start = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Get the preprocessed data for target_d\n        sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start = preprocessed[target_d]\n        \n        # Check for vouchers ending before l1\n        # Binary search in sorted_by_end for the largest end <= l1 - 1\n        ends = [v[1] for v in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1) - 1\n        if pos >= 0:\n            min_cost = prefix_min_end[pos]\n            min_total = min(min_total, cost1 + min_cost)\n        \n        # Check for vouchers starting after r1\n        # Binary search in sorted_by_start for the first start >= r1 + 1\n        starts = [v[0] for v in sorted_by_start]\n        pos = bisect.bisect_left(starts, r1 + 1)\n        if pos < len(starts):\n            min_cost = suffix_min_start[pos]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1108,
        "thoughts_token_count": 1024
    }
}