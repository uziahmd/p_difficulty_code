{
    "start": 1758309835.9435256,
    "end": 1758309877.28318,
    "start-formatted": "2025-09-20 04:23 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. The goal is to maximize the sum of their numbers S1 and S2. Each takes exactly n moves, and the order of taking digits depends on who is chosen each turn. The output is the sequence of H and M that leads to the maximum total.\n\nHmm, the key here is to find the optimal way for them to pick digits so that their combined total is maximized. Since each choice affects the remaining digits, we need to consider all possibilities. But with n up to 18, the total length of A is 36 digits. Trying all possible sequences would be O( (2n choose n) ) which is way too big for n=18. That's like 36 choose 18 which is around 9e10, which is impossible for brute force.\n\nSo we need a dynamic programming approach. Let's think about the state. The state can be represented by the number of digits each has taken so far. Let's say, Homer has taken h moves and Marge has taken m moves. Since each move is either H or M, and the total steps are 2n, we can model the state as (h, m), and track the maximum total value possible from that state onwards.\n\nWait, but how do we track the digits that are left? Because the digits are being taken from the front. Oh right! The digits that are left are the suffix of the original string. So, for example, if we have taken k digits already, the current A is the original string starting from position k. So the state can be represented by the number of digits taken so far (k = h + m). Because the next digit to take is the (k)th position in the original string. Wait, the original string is 2n digits. For example, when k digits have been taken, the next digit is the (k)th index (assuming 0-based or 1-based? Well, the initial A is given as a string, and each time we take the leftmost digit. So the first move takes the first character, then the next takes the new leftmost, etc.)\n\nSo the state can be represented by how many digits have been taken so far (k = h + m), and how many times Homer has taken (h). Because once we know k and h, m is k - h. Since the total steps are 2n, and each step is either H or M, but the total number of H steps is n and M steps is n. So for the state (h, m), we can represent it as (h, k), since k = h + m. But since m = k - h, perhaps the state can be represented as (h, k). However, since k = h + m, and each step increases k by 1, maybe the state can be represented by (h, k). Wait, but k is h + m, and since each step adds one to k, the possible values of k range from 0 to 2n. But for each state, the number of H's is h, and the number of M's is m = k - h. But since the total number of H's must be n, and the same for M's, we can only proceed when h <=n and m <=n.\n\nSo for the DP approach, the state is (h, k), where h is the number of H's taken so far, and k is the total number of digits taken so far. Wait, but k is equal to h + m. But m is the number of M's taken so far. However, since the next move can be H or M, depending on which is allowed. For example, if we are at state (h, k), then the next move can be H only if h < n, and M only if (k - h) < n. Because m = k - h, and m can't exceed n.\n\nBut how do we model the transitions? For each state (h, k), the next digit is the k-th digit of A (assuming that the original string is 0-based, and after taking k digits, the next is the k-th index). Then, if we choose H, we add that digit to Homer's number, and increment h by 1, and k by 1. Similarly for M.\n\nBut the problem is to maximize the total sum. However, the digits are added to S1 and S2. But the value of S1 and S2 depends on the digits taken in the order of their selection. For example, the first digit taken by Homer is the most significant digit of his number. So, the value of S1 is the sum of digit * 10^{n - h} for each step. Wait, but when Homer takes a digit, it's added",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge to maximize the total prize they receive from a given number A. Each player takes exactly n turns, and the goal is to choose the sequence of moves (H for Homer, M for Marge) that results in the maximum combined value of their numbers.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a DP approach where the state is represented by the number of moves Homer has made so far and the total number of digits taken from the original number A. This allows us to efficiently explore all possible sequences of moves while keeping track of the maximum total prize.\n2. **Recursive Exploration with Memoization**: For each state, we recursively determine the best move (either H or M) by considering the future states and their respective values. Memoization ensures that we do not recompute results for the same state, significantly improving efficiency.\n3. **Digit Contribution Calculation**: When a digit is chosen by either player, its contribution to the total prize is calculated based on its position in the resulting number. This is done using powers of 10 to reflect the positional value of each digit.\n\n### Solution Code\n```python\nimport sys\nimport functools\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    A = data[1]\n    \n    length = 2 * n\n    digits = [int(c) for c in A]\n    \n    @functools.lru_cache(maxsize=None)\n    def dp(h, k):\n        if h == n:\n            # All H moves are done, rest must be M\n            return (sum(digits[k + i] * (10 ** (n - 1 - i)) for i in range(n - k)), 'M' * (length - k))\n        if k == length:\n            return (0, '')\n        # Current digit is digits[k]\n        # Try H if possible\n        max_val = -1\n        best_choice = ''\n        if h < n:\n            val_h = digits[k] * (10 ** (n - 1 - h))\n            next_val, next_choice = dp(h + 1, k + 1)\n            total = val_h + next_val\n            if total > max_val:\n                max_val = total\n                best_choice = 'H' + next_choice\n        # Try M if possible\n        m = k - h\n        if m < n:\n            val_m = digits[k] * (10 ** (n - 1 - m))\n            next_val, next_choice = dp(h, k + 1)\n            total = val_m + next_val\n            if total > max_val:\n                max_val = total\n                best_choice = 'M' + next_choice\n        return (max_val, best_choice)\n    \n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Dynamic Programming State**: The function `dp(h, k)` computes the maximum total prize value starting from the state where Homer has taken `h` moves and `k` digits have been taken from the original number A.\n- **Recursive Transitions**: For each state, we consider both possible moves (H or M) if they are valid (i.e., within the allowed number of moves for each player). The contribution of each digit is calculated based on its position in the resulting number.\n- **Memoization**: The `@functools.lru_cache` decorator is used to memoize results of subproblems, ensuring that each state is computed only once, leading to efficient computation even for large values of n.\n\nThis approach efficiently explores all possible sequences of moves while ensuring optimal substructure and overlapping subproblems are handled through dynamic programming and memoization.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport functools\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    A = data[1]\n    \n    length = 2 * n\n    digits = [int(c) for c in A]\n    \n    @functools.lru_cache(maxsize=None)\n    def dp(h, k):\n        if h == n:\n            # All H moves are done, rest must be M\n            return (sum(digits[k + i] * (10 ** (n - 1 - i)) for i in range(n - k)), 'M' * (length - k))\n        if k == length:\n            return (0, '')\n        # Current digit is digits[k]\n        # Try H if possible\n        max_val = -1\n        best_choice = ''\n        if h < n:\n            val_h = digits[k] * (10 ** (n - 1 - h))\n            next_val, next_choice = dp(h + 1, k + 1)\n            total = val_h + next_val\n            if total > max_val:\n                max_val = total\n                best_choice = 'H' + next_choice\n        # Try M if possible\n        m = k - h\n        if m < n:\n            val_m = digits[k] * (10 ** (n - 1 - m))\n            next_val, next_choice = dp(h, k + 1)\n            total = val_m + next_val\n            if total > max_val:\n                max_val = total\n                best_choice = 'M' + next_choice\n        return (max_val, best_choice)\n    \n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 425,
        "completion_token_count": 810,
        "thoughts_token_count": 1024
    }
}