{
    "start": 1758313042.273361,
    "end": 1758313287.5780613,
    "start-formatted": "2025-09-20 05:17 KST",
    "end-formatted": "2025-09-20 05:21 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to find the minimum number of edges to add to a graph to create an odd-length cycle, and also count the number of ways to do that with exactly that minimum number of edges. Hmm.\n\nFirst, I need to understand what's required. An odd-length cycle is a cycle where the number of edges (and vertices) is odd. And the cycle must be simple, meaning no repeated vertices. So the problem is about making sure that after adding some edges, such a cycle exists.\n\nWait, but the original graph might already have such a cycle. In that case, t would be 0, and w would be 1? Or maybe not. Let me check the examples.\n\nLooking at the second example input: 3 nodes connected in a triangle. That's a cycle of length 3, which is odd. So the output is 0 1. Which makes sense. So if the graph already has an odd cycle, then t is 0, and w is 1 (since there's only one way to do nothing). But wait, maybe there are multiple existing odd cycles. But the problem says that the answer is the number of ways to add t edges. If t is zero, then the number of ways is the number of existing odd cycles? Or no. Wait, no. Because the question says that we need to find the number of ways to add exactly t edges (which is zero here) to form an odd cycle. But if the graph already contains an odd cycle, then adding zero edges would suffice. However, the problem states that the answer for w is the number of ways to add t edges (so zero edges here) to form such a cycle. However, since the graph may have multiple existing odd cycles, but the way of adding zero edges is just one way (i.e., not adding any edges), but the problem says that two ways are considered the same if they have the same set of added edges. So if the graph already contains an odd cycle, then adding zero edges is one way. But why is the output for the second example '0 1'? Because the original graph is a triangle, which is an odd cycle. So the answer is correct. So in that case, the w is 1. Therefore, if the graph already has an odd cycle, then the answer is t=0, w=1. Because even if there are multiple existing odd cycles, the way to add zero edges is just one way (no edges added).\n\nSo the first thing to check is whether the graph already has an odd cycle. If it does, then t is 0 and w is 1. Otherwise, we need to compute the minimal t and the number of ways to add t edges.\n\nSo the problem reduces to two parts:\n\n1. Determine if the graph already contains an odd cycle. If yes, output t=0, w=1.\n2. If not, find the minimal t and the number of ways to add t edges to create an odd cycle.\n\nNow, how do we check if the graph has an odd cycle? Well, that's equivalent to checking if the graph is bipartite. Because a bipartite graph cannot have any odd-length cycles. So if the graph is bipartite, then it doesn't have any odd cycles. If it's not bipartite, then it has at least one odd cycle.\n\nWait, but the graph may consist of multiple components. So for each component, we need to check if it's bipartite. If any component is not bipartite, then the graph has an odd cycle.\n\nSo the first step is to check for each connected component if it is bipartite. If any component is not bipartite, then the answer is t=0, w=1. Otherwise, the graph is bipartite, and we need to find the minimal edges to add to create an odd cycle.\n\nSo the next part is when the graph is bipartite. How can we add edges to create an odd cycle?\n\nIn a bipartite graph, all cycles are of even length. So to create an odd cycle, we need to add edges in such a way that there's a cycle of odd length.\n\nBut how?\n\nLet me think. Since the graph is bipartite, each connected component is bipartite. Let's consider each connected component. Suppose that the component has a bipartition (A, B). Adding an edge between two nodes in the same partition would create an odd cycle. Because suppose you have a path from u to v that goes through even steps (since the graph is bipartite). Adding an edge between u and v (same partition) would create a cycle of length (path length + 1). Since the path length is even, adding 1 makes it odd.\n\nSo for example, in a bipartition (A, B), if we add an edge between two nodes in A, then there's a cycle. Let's see: suppose u and v are in A. Then the path from u to v in the original graph (if it exists) must have even length. Adding the edge u-v creates a cycle of length (path length + 1), which is odd.\n\nTherefore, the minimal number of edges to add is 1. Because adding any single edge between two nodes in the same partition of a bipartite component will create an odd cycle.\n\nBut wait, the question requires that the cycle is of more than one vertex. So for example, adding an edge between two nodes that are already connected by a path of even length would create a cycle of odd length.\n\nSo, for a bipartite graph, the minimal t is 1. But how to compute w?\n\nThe number of ways to add exactly one edge between two nodes in the same partition of any component. But since adding such an edge would create an odd cycle, and since the graph is bipartite, adding any such edge would do.\n\nSo, the problem becomes: for each connected component, compute the number of possible edges that can be added between nodes in the same partition. Then, the total number of ways is the sum over all components of (number of possible edges in same partition) for that component.\n\nBut wait, because adding any such edge would create an odd cycle. However, the minimal t is 1. So the answer for t is 1, and w is the total number of such possible edges across all components.\n\nWait, but let's think again. Suppose there are multiple components. For example, if there are two separate bipartite components. Each component can contribute some edges. Adding any of those edges would create an odd cycle. So the minimal t is 1, and the number of ways is the sum over all possible edges that can be added in each component (i.e., edges within the same partition of each component).\n\nSo for each connected component, which is bipartite, we can split into two partitions A and B. The number of possible edges that can be added between two nodes in A is C(|A|, 2), and similarly for B. So the total for the component is (C(|A|,2) + C(|B|,2)).\n\nBut wait, the original graph may already have some edges. So for each component, the number of possible edges that can be added between same partitions is (size_A choose 2 + size_B choose 2) minus the existing edges in the component. Wait, no. Because the original graph is bipartite. All existing edges are between A and B. So in the component, there are no edges between nodes in the same partition. Because if there were, that would create an odd cycle, which contradicts the fact that the component is bipartite. So for each component, the number of possible edges that can be added between same partitions is (size_A choose 2 + size_B choose 2). Because all such edges are not present in the original graph.\n\nSo, the total number of ways is the sum over all components of (C(a, 2) + C(b, 2)), where a and b are the sizes of the two partitions of the component.\n\nBut wait, the problem says that the graph may have multiple components. So for example, if there are two separate components, each of which is bipartitioned into A and B. Adding any edge between two nodes in the same partition of any component would create an odd cycle. So the total number of ways is the sum of all possible such edges for all components.\n\nTherefore, if the graph is bipartite, then t is 1, and w is the sum for all components of (a choose 2 + b choose 2).\n\nBut wait, the example given in the first input:\n\nSample Input 1:\n4 4\n1 2\n1 3\n4 2\n4 3\n\nLet me think. The graph is:\n\nNodes 1, 2, 3, 4.\n\nEdges: 1-2, 1-3, 2-4, 3-4.\n\nLet me check if this graph is bipartite. Let's try to color it.\n\nSuppose we start with node 1 as color 0. Its neighbors (2 and 3) must be color 1. Then node 2's neighbors are 1 (color 0), 4. So 4 must be color 0. Similarly, node 3's neighbors are 1 (color 0) and 4. So 4 must be color 0. So that's consistent. Now, node 4 is connected to 2 and 3, which are color 1. So node 4 is color 0. So the bipartition is {1,4} and {2,3}.\n\nSo for this component, a = 2, b = 2. So (2 choose 2) + (2 choose 2) = 1 + 1 = 2. So the total w is 2. Which matches the first sample's output of 1 2. So t is 1, and w is 2. Which is correct.\n\nAnother sample is the third input: 3 0. So the graph has three nodes and no edges. So each node is a separate component. Wait, no. The graph is three nodes, no edges. So each node is a separate component. But each component is trivially bipartite (as there are no edges). So for each component, the partitions are (1, 0) (since the component has one node). So for each component, the number of possible edges is (C(1,2) + C(0,2)) = 0 + 0 = 0. Wait, but that's not right. Because for a component with one node, the partitions are (1, 0). So adding an edge between two nodes in the same partition. But for a single node, the same partition is only that node. So to add an edge between two nodes in the same partition, you need two nodes. But in this case, the component has only one node. So the number of possible edges for this component is zero.\n\nBut the third sample input is 3 0. So the graph is three isolated nodes. So for each component (each node), the possible edges is zero. So the sum is zero. But according to the sample output, the answer is 3 1. Wait, that contradicts. What's wrong here?\n\nWait, the sample input is 3 0. The output is 3 1. So according to the sample, t is 3 and w is 1. How?\n\nBecause the original graph is bipartite (all components are bipartite). So the minimal t is 1? But the sample output says t is 3. That suggests that my previous reasoning is wrong. So where is the mistake?\n\nAh! Oh no, perhaps I made a mistake in the analysis. Let me re-examine the problem.\n\nThe problem requires that after adding t edges, there is a simple cycle of odd length. But if the graph is bipartite, adding a single edge between two nodes in the same partition creates an odd cycle. However, in the third sample input, which is three isolated nodes, adding a single edge between two nodes would not form a cycle. Because a cycle requires at least three nodes. So adding a single edge between two nodes (say 1-2) would not create a cycle. To form a cycle, you need to have a closed path. So adding a single edge between two nodes in the same partition (but in a component that's just a single node) is not possible. Wait, but for the third sample, each component is a single node. So for each component, the bipartition is (1, 0). So the possible edges to add between same partitions are zero. So the total sum is zero. So according to previous reasoning, the answer would be t=1 and w=0. But that's not possible. So clearly, my previous reasoning was wrong.\n\nThis suggests that there's a flaw in the logic. So I need to re-examine the problem.\n\nLet me think again. How can adding edges to a bipartite graph create an odd cycle?\n\nFor that, the added edges must form a cycle of odd length. So, for example, adding a single edge between two nodes in the same partition of a bipartitioned component would create a cycle of odd length. But that's only possible if there's a path between those two nodes in the original graph. Because if there's no path, adding an edge between them would not form a cycle.\n\nAh! Oh right! So for example, if two nodes are in the same partition but are not connected by any path (like in a disconnected graph), adding an edge between them would not create a cycle. So the cycle can only be formed if the two nodes are in the same partition and are connected by a path in the original graph. Because then adding the edge creates a cycle. The length of that cycle would be the length of the path (even) plus 1 (the new edge), which is odd.\n\nSo in the case of a component with a single node, adding any edge would not create a cycle. Because there's no path between the two nodes (since the component is just one node). So in that case, adding an edge between two nodes (say, in different components) would create a cycle only if they are connected through other edges. But in the case of three isolated nodes, adding any single edge would not create a cycle. Adding two edges would create a path of two edges (say, between 1-2 and 2-3). But that's a path, not a cycle. To create a cycle, you need to connect two nodes that are already connected by a path. So for example, in the case of three nodes, adding edges 1-2 and 1-3 would not form a cycle. But adding edges 1-2, 2-3, and 1-3 would form a triangle (cycle of length 3). But that requires adding three edges. So in this case, the minimal t is 3. Which is the sample's output.\n\nSo the previous approach is wrong. Because for a component to allow adding an edge that creates a cycle, the two nodes must be in the same partition and connected by a path. Therefore, the number of possible edges that can be added in a component is not (C(a,2) + C(b,2)), but rather the number of pairs of nodes in the same partition that are connected by a path (so that adding the edge creates a cycle).\n\nBut how to calculate that?\n\nAlternatively, for each component, the number of possible edges that can be added to create an odd cycle is equal to the number of pairs of nodes in the same partition that are connected by a path (so that adding the edge forms a cycle of odd length). However, in a bipartitioned component, any two nodes in the same partition are connected by a path of even length (since the component is bipartitioned). Because the parity of the path length depends on the partitions. So if two nodes are in the same partition, any path between them must have even length. Therefore, adding an edge between them would create a cycle of length (even + 1) = odd.\n\nBut if two nodes are in the same partition but not connected by any path (i.e., they are in different connected components), then adding an edge between them would not create a cycle. So in that case, the edge addition would not form a cycle.\n\nTherefore, in order to create an odd cycle by adding an edge, the two nodes must be in the same partition and be in the same connected component (so that there's a path between them). So for a connected bipartitioned component, the number of possible edges that can be added to create an odd cycle is (number of pairs of nodes in the same partition) - existing edges between same partitions (which is zero, since the graph is bipartitioned). Wait, but the existing edges are between different partitions. So in a connected bipartitioned component, the number of possible edges that can be added between same partitions is (a choose 2 + b choose 2). Because all such edges are not present in the original graph. However, adding any of those edges would create a cycle of odd length. Because the two nodes are in the same partition and connected by a path (since the component is connected). Thus, adding an edge between them creates a cycle.\n\nSo for a connected bipartitioned component, the number of possible edges to add is (a choose 2 + b choose 2). But in the case of a component with only one node (a=1, b=0), then (1 choose 2 + 0 choose 2) = 0. So adding an edge between two nodes in the same partition is not possible here. However, if the component is a single node, then adding an edge to another node (from another component) would not create a cycle.\n\nSo for the third sample input, which is three nodes with no edges. Each node is a component. Each component is bipartitioned as (1,0). So for each component, the number of possible edges is 0. So the sum is 0. Therefore, adding one edge is not sufficient. So what is the minimal t?\n\nIn this case, the graph is bipartitioned. So adding edges to create an odd cycle. Since the graph is bipartitioned, but each component is a single node, adding edges between different components may help. Let's think: to create a cycle of odd length, we need to have a cycle. For example, adding three edges between three nodes to form a triangle. That's a cycle of length 3. But how to get that?\n\nIn this case, the original graph is three separate components. So adding edges between the three nodes. For example, adding edges (1-2), (2-3), (3-1) would create a cycle of length 3. But how many edges need to be added? Three edges. So t is 3. And the number of ways is 1 (only one way to add all three edges). Which matches the sample output.\n\nSo how to find the minimal t in such cases?\n\nSo the previous approach was incorrect. The minimal t is not always 1. It depends on the structure of the graph.\n\nSo now, I need to rethink the approach.\n\nThe problem is: given a bipartite graph (since the original graph has no odd cycles), find the minimal number of edges to add to create an odd cycle. Let's think about the possibilities.\n\nCase 1: There exists a connected component with at least two nodes. Then, in that component, adding a single edge between two nodes in the same partition would create an odd cycle. Therefore, the minimal t is 1.\n\nCase 2: All connected components are single-node. Then, we have to create a cycle. For example, with three nodes, we need to add three edges (forming a triangle). So t is 3, and w is 1 (only one way to add all three edges).\n\nBut wait, in case of two components, each with one node. Then, adding two edges between them would form a path of length two. But that's not a cycle. So to create a cycle, you need to connect them in a way that forms a loop. For example, three nodes, you need three edges. So in general, the minimal t is (k) where k is the number of nodes needed to form a cycle of odd length. But how?\n\nSo, the minimal t depends on the number of components. Let me think:\n\nIf the graph is bipartite, then the minimal number of edges to add to create an odd cycle is:\n\nIf there is at least one connected component with size ≥ 2, then t is 1. Because adding an edge between two nodes in the same partition of that component will create an odd cycle.\n\nOtherwise, all components are single-node. Then, we need to create a cycle of odd length. The smallest such cycle is of length 3. So we need to connect three nodes. Since the original graph has no edges, we need to add three edges (connecting them into a triangle). So t is 3.\n\nSo the minimal t is 1 if there is at least one component with size ≥ 2. Otherwise, t is 3.\n\nBut how to determine that?\n\nSo first, check if the graph is bipartite. If not, then t is 0. Else:\n\nCheck if there's at least one component with size ≥ 2. If yes, then t is 1. Else (all components are size 1), then t is 3.\n\nThen, the number of ways w depends on the case.\n\nIn the case where t is 1, then the number of ways is the sum over all components of (a choose 2 + b choose 2), where a and b are the sizes of the two partitions of each component.\n\nIn the case where t is 3, then the number of ways is the number of ways to select three nodes and connect them in a triangle. However, since the original graph has no edges, the number of such ways is the number of combinations of three nodes (C(n,3)), but since each way requires adding exactly three edges (the triangle). However, the problem says that the way to add edges is considered the same if they have the same set of edges. So for three nodes, there's exactly one way to add the three edges. So the number of ways is C(n, 3).\n\nBut in the sample input 3, n is 3. So C(3,3) = 1. Which matches the sample output.\n\nSo, putting it all together:\n\nThe algorithm is:\n\n1. Check if the graph has an odd cycle. If yes, output 0 1.\n\nElse:\n\n   a. Check if there is at least one connected component with size ≥ 2. \n\n      i. If yes, then t = 1, and w is the sum over all components of (a choose 2 + b choose 2).\n\n      ii. If no (all components are single-node), then t = 3, and w = C(n,3).\n\nSo, how to implement this?\n\nFirst, check if the graph is bipartite. For that, perform BFS or DFS for each component and check bipartition.\n\nOnce we know the graph is bipartite, then:\n\nCheck if there is at least one component with size ≥ 2. If yes, then t is 1, and compute w as sum for each component (a * (a-1)/2 + b * (b-1)/2).\n\nElse, t is 3, and w is C(n,3) if n ≥ 3, else 0 (but since n is the number of vertices, if all components are size 1, then n must be ≥ 1. But if n is 1, then no way to form a cycle. However, the problem says that the cycle must have more than one vertex. So for n=1, the answer is impossible. But according to the problem statement, the input is such that the graph can be modified to have such a cycle. However, the input constraints don't specify that the graph can be modified. Wait, the problem says that the answer must be found. So for example, if n=1, then it's impossible to form a cycle. But the problem says that the graph is not necessarily connected. But according to the problem statement, the input is such that the output is possible. Or perhaps the code should handle all cases.\n\nBut according to the sample input 3, when n=3, the answer is 3 1.\n\nSo, for the case when all components are size 1, then:\n\nIf n < 3, then it's impossible to form a cycle. However, the problem says that the answer must be computed. But according to the input constraints, the problem says that the graph can be modified to form a cycle. So perhaps the input is such that n ≥ 3 in this case. Or perhaps the code needs to handle that.\n\nBut according to the problem statement, the output must be computed. Let's think: for example, if n=2, and the graph is two isolated nodes. Then, the minimal t is 3? No. Because to form a cycle, you need at least three nodes. So adding edges between the two nodes would not form a cycle. So in this case, it's impossible. But the problem says that the input is such that the answer exists. But perhaps the problem's input allows for such cases, but the code must handle them. However, the problem says that the graph is given without loops or parallel edges. So, for example, if n=2 and m=0, then the minimal t is 3? But that's impossible. However, the problem's third example has n=3, which is possible.\n\nSo, in the case where all components are single-node, and n ≥ 3, then t is 3, and w is C(n,3). Otherwise, if n <3, then there's no way to form a cycle. But according to the problem statement, the answer must be found. So perhaps the code can assume that n ≥ 3 in that case. However, the problem's input may have n=2 and all components are single-node. How to handle that?\n\nBut according to the problem's note, the output must be printed. So for example, if n=2 and all components are single-node (so the graph has two isolated nodes), then the minimal t is 3, but it's impossible to form a cycle. However, according to the problem's requirements, the answer must be computed. But this case seems impossible. However, according to the problem statement, the output must be given. But perhaps in such cases, the code can return t=3 and w=0. However, the problem's sample input 3 shows that for n=3, the answer is 3 1. So the code must handle that.\n\nSo, in our code, for the case when all components are single-node:\n\nif n < 3, then there is no way to form a cycle. However, the problem says that the graph can be modified to form a cycle. So perhaps the input will not have such cases. But the code must handle it.\n\nBut the problem says that the graph can be modified to form a cycle. For example, in the case where n=2, you need to add 3 edges. But that's impossible. So perhaps the problem's input ensures that n ≥ 3 in this case. However, the code should handle it.\n\nBut for the purposes of solving the problem, perhaps the code can proceed as follows:\n\nWhen all components are single-node:\n\nif n >= 3: t=3, w = C(n,3)\n\nelse: t=3, w=0 (but this case is impossible, but the code can return that)\n\nBut according to the problem statement, the answer must exist. So perhaps the input is such that in this case, n >=3.\n\nSo, back to the algorithm.\n\nSo, the code steps:\n\nFirst, check if the graph is bipartite. If not, output 0 1.\n\nElse:\n\nCheck if there is at least one component with size ≥ 2.\n\nIf yes:\n\nt=1, and w is sum for each component (a choose 2 + b choose 2).\n\nElse:\n\nif n >=3: t=3, w = C(n,3)\n\nelse: ?\n\nBut according to the problem's sample input 3, when n=3, the answer is 3 1. Which is C(3,3)=1.\n\nSo, the code can proceed with that.\n\nNow, the problem is to implement this logic.\n\nSo, the steps for the code:\n\nImplement Bipartition check for each component.\n\nFor each component, during BFS/DFS, assign colors (0 and 1), and check if it's bipartitioned.\n\nIf during this process, any component is not bipartitioned, then the graph has an odd cycle. Output 0 1.\n\nElse, proceed.\n\nThen, check if there's at least one component with size ≥2.\n\nIf yes:\n\nCompute for each component, the size of the two partitions (a and b). Sum (a*(a-1)//2 + b*(b-1)//2) across all components. This is the value of w. Output t=1 and this w.\n\nElse:\n\nif n < 3: then no way to form a cycle. But according to the problem, perhaps the input is such that this case does not happen. But according to the problem's sample input 3, when n=3, output is 3 1.\n\nSo, in code:\n\nif n >=3: t=3, w = n*(n-1)*(n-2)//6\n\nelse: ?\n\nBut for n=1, it's impossible. But the code can return t=3 and w=0.\n\nBut according to the problem's note, the output must be printed. So in the code, perhaps the code can proceed with that.\n\nNow, the code steps:\n\nImplement Bipartition check.\n\nSo, the code needs to:\n\nRead n and m.\n\nRead m edges.\n\nBuild adjacency list.\n\nFor each component, check if it's bipartite. Also, for each component, record the size of the two partitions.\n\nIf any component is not bipartitioned, output 0 1.\n\nElse:\n\nCheck if any component has size ≥2.\n\nIf yes:\n\nsum_w = sum for each component (a*(a-1)//2 + b*(b-1)//2)\n\noutput 1 sum_w.\n\nElse:\n\nif n >=3:\n\noutput 3 and C(n,3)\n\nelse:\n\noutput something. But according to the problem statement, the input is such that it's possible. So perhaps the code can assume that when all components are single-node, then n >=3.\n\nBut how to handle when n=2?\n\nBut according to the problem statement, the input is such that the answer exists. So perhaps in such cases, the code can output 3 and 0, but that's unclear.\n\nBut according to the sample input 3, when n=3, the answer is 3 1. So the code can proceed with that.\n\nNow, implement this.\n\nNow, the code:\n\nWe need to perform BFS for each component, track the color of each node, and check for bipartition.\n\nLet's proceed with writing code.\n\nIn Python:\n\nRead n and m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n    u, v = map(int, input().split())\n\n    adj[u].append(v)\n\n    adj[v].append(u)\n\ncolor = [-1] * (n+1)\n\nis_bipartite = True\n\ncomponents = [] # list of (a, b) for each component.\n\nfor each node from 1 to n:\n\n    if not visited:\n\n        perform BFS or DFS to check bipartition.\n\n        during this process, track the color of each node, and count the number of nodes in each partition (color 0 and color 1).\n\n        if during BFS/DFS, a conflict is found (neighbor has same color), then is_bipartite = False.\n\n        if is_bipartite is False, break.\n\nOnce all components are processed:\n\nif not is_bipartite:\n\n    print(0 1)\n\nelse:\n\n    check if any component has size ≥2.\n\n    if yes:\n\n        compute sum_w as sum over all components (a*(a-1)//2 + b*(b-1)//2)\n\n        print(1 sum_w)\n\n    else:\n\n        if n >=3:\n\n            print(3, n*(n-1)*(n-2)//6 )\n\n        else:\n\n            # impossible, but code can output 3 0?\n\nBut how to check if any component has size ≥2?\n\nWe can collect for each component, the sizes of the two partitions. For example, during BFS, for each component, we can count the number of nodes with color 0 and color 1.\n\nSo, during the BFS:\n\nfor each component:\n\n    count0 = 0\n\n    count1 = 0\n\n    for each node in component:\n\n        if color is 0: count0 +=1\n\n        else: count1 +=1\n\n    components.append( (count0, count1) )\n\nThen, for checking if any component has size ≥2: check if any (count0 + count1) ≥2.\n\nBut since the component is a connected component, the size is count0 + count1.\n\nSo, in code:\n\nhas_large_component = any( (a + b) >=2 for a, b in components )\n\nIf yes:\n\nproceed with sum_w.\n\nElse:\n\nall components are of size 1. So n must be equal to the number of components.\n\nThus, in code:\n\nNow, implement this.\n\nNow, the code:\n\nBut how to track the components and their counts.\n\nLet me think about the code.\n\nInitialize color array as -1.\n\nvisited = [False] * (n+1)\n\ncomponents = []\n\nfor u in 1..n:\n\n    if not visited[u]:\n\n        queue = deque()\n\n        queue.append(u)\n\n        visited[u] = True\n\n        color[u] = 0\n\n        count0 = 1\n\n        count1 = 0\n\n        is_bipart = True\n\n        while queue not empty:\n\n            current = queue.popleft()\n\n            for neighbor in adj[current]:\n\n                if color[neighbor] == -1:\n\n                    color[neighbor] = 1 - color[current]\n\n                    visited[neighbor] = True\n\n                    queue.append(neighbor)\n\n                    if color[neighbor] == 0:\n\n                        count0 +=1\n\n                    else:\n\n                        count1 +=1\n\n                else:\n\n                    if color[neighbor] == color[current]:\n\n                        is_bipart = False\n\n        if not is_bipart:\n\n            is_bipartite = False\n\n            break\n\n        components.append( (count0, count1) )\n\nWait, but this code is not correct. Because during BFS, the initial node is added to the queue. Then, for each neighbor, we check if it is colored. But the code above is not handling the initial count correctly. Because the initial node is color 0, count0 starts as 1. Then, for each neighbor, when added, their color is set to 1 - color of current. So for example, the first node is color 0, and its neighbors are color 1. But during BFS, the code for counting is done when adding the neighbor. However, the initial code may not capture all counts. For example, the initial node is in count0. When processing its neighbors, each neighbor is added, and their color is set, and the count is updated. However, this approach may not capture all nodes. Because when a node is dequeued, it's already been processed, but the code is only adding to count0/count1 when the neighbor is added. But the current node's color is already accounted for in count0 or count1. However, the initial node's count is handled. But when processing the current node, the code may have already added to count0 or count1. But during the BFS, the code may miss some counts. For example, the initial node is added to count0. Then, when processing its neighbor, the neighbor is added to count1. But when the neighbor is dequeued, its neighbors are processed, etc. However, the code as written only counts the neighbor when it is added to the queue. So the count0 and count1 variables would be accurate.\n\nWait, no. Because when a node is added to the queue, it's because it's being discovered. So for each node, when it's discovered, its color is assigned, and the count is updated. So the count variables would be correct.\n\nBut the initial node is added to the queue, and when processed, its neighbors are checked. So for the initial node, count0 is 1. For each neighbor added, their color is 1, and count1 increases. So the count variables are correct.\n\nYes. So during BFS, for each node, when it is first discovered (i.e., when it's added to the queue), we can increment the count0 or count1 based on its color.\n\nBut the initial code may have a problem. For example, when the initial node is added, count0 is 1. Then, when processing the initial node, the code checks its neighbors. For each neighbor that is uncolored, it is colored and added to the queue. The count0 or count1 is incremented accordingly.\n\nBut the code above, the count variables are initialized as count0 = 1, count1 = 0. Then, for each neighbor added, the code checks the color of the neighbor and increments count0 or count1. But what about the current node (the one being dequeued)? For example, when a node is dequeued, it's already been counted. So the code is correct.\n\nBut during the BFS, the code may miss some nodes. For example, if a node is added to the queue, but not processed yet. However, the count variables are updated when the node is discovered (added to the queue). So the count variables should be correct.\n\nBut perhaps a better way is to track the count0 and count1 during BFS by checking the color of each node when it is added to the queue. Because each node is added once.\n\nSo the code for each component would be:\n\ncount0 = 0\n\ncount1 = 0\n\nwhen a node is discovered (added to the queue), check its color, and increment count0 or count1.\n\nBut in the code above, the initial node is added to the queue, and count0 is initialized to 1. However, when the initial node is added to the queue, it",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and the number of ways to achieve this. The solution involves checking if the graph already contains an odd cycle, and if not, determining the minimum edges required based on the graph's bipartite properties.\n\n### Approach\n1. **Check for Odd Cycle**: Use BFS to determine if the graph is bipartite. If it is not bipartite, it contains an odd cycle, and the answer is 0 edges with 1 way.\n2. **Component Analysis**: If the graph is bipartite, check each connected component. If any component has at least two nodes, we can form an odd cycle by adding one edge within the same partition of that component.\n3. **Count Ways**: For each component, calculate the number of ways to add edges within the same partition to form an odd cycle.\n4. **Special Case Handling**: If all components are single-node components, the minimum edges required to form a cycle of three nodes (triangle) is 3, and the number of ways is calculated using combinations.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    is_bipartite = True\n    components = []\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            queue = deque()\n            queue.append(u)\n            visited[u] = True\n            color[u] = 0\n            count0 = 1\n            count1 = 0\n            current_is_bipartite = True\n\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n                        if color[neighbor] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                    else:\n                        if color[neighbor] == color[current]:\n                            current_is_bipartite = False\n\n            if not current_is_bipartite:\n                is_bipartite = False\n                break\n\n            components.append((count0, count1))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    has_large = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large = True\n            break\n\n    if has_large:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The graph is checked for bipartiteness using BFS. If any component is not bipartite, it contains an odd cycle.\n2. **Component Analysis**: Each connected component is analyzed to determine the number of ways to add edges within the same partition to form an odd cycle.\n3. **Special Case Handling**: If all components are single-node, forming a triangle (cycle of length 3) requires adding 3 edges, and the number of ways is calculated using combinations of three nodes.\n\nThis approach ensures that we efficiently determine the minimum edges and ways to form an odd cycle, leveraging graph properties and combinatorial calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    is_bipartite = True\n    components = []\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            queue = deque()\n            queue.append(u)\n            visited[u] = True\n            color[u] = 0\n            count0 = 1\n            count1 = 0\n            current_is_bipartite = True\n\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n                        if color[neighbor] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                    else:\n                        if color[neighbor] == color[current]:\n                            current_is_bipartite = False\n\n            if not current_is_bipartite:\n                is_bipartite = False\n                break\n\n            components.append((count0, count1))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    has_large = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large = True\n            break\n\n    if has_large:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 915,
        "thoughts_token_count": 8192
    }
}