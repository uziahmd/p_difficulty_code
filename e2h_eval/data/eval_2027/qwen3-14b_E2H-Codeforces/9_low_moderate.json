{
    "start": 1758009477.2964535,
    "end": 1758010268.7863424,
    "start-formatted": "2025-09-16 16:57 KST",
    "end-formatted": "2025-09-16 17:11 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (which is 1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm. \n\nFirst, I need to think about the approach here. Since the weights are limited to 1, 2, or 3, maybe there's a way to handle each weight category separately and then combine them optimally. Because with knapsack problems, when the weights are small, there might be some optimizations.\n\nThe classic unbounded knapsack approach won't work here because n is too big. But since each item is unique (it's 0-1 knapsack), but with the weights limited to 1, 2, 3, perhaps we can find an efficient way.\n\nLet me think: for each weight category (1, 2, 3), we can sort the items in descending order of cost per unit weight. Wait, but since each item is taken as a whole, maybe for each weight group, we can take the most valuable items first. For example, for all items of weight 1, we take as many as possible (up to the available capacity), but considering that the total weight can't exceed m. However, the problem is that the total weight is limited, and combining different weight groups optimally is tricky.\n\nSo maybe the approach is:\n\n1. Separate the items into three groups based on their weight (w=1, 2, 3).\n2. Sort each group in descending order of cost. This way, for each group, we can take the most expensive items first.\n3. Then, we need to decide how many items from each group to take, considering the total weight.\n\nBut how do we combine these groups optimally?\n\nLet me think about the possible combinations. Let's say we have for each group, a list of prefix sums. For example, for weight 1 items, sorted in descending order, we can compute the prefix sum for taking k items (each of weight 1). Similarly for weight 2 and 3.\n\nThen, the problem becomes selecting how many items to take from each group such that the total weight is <= m, and the total cost is maximized.\n\nBut considering that the total weight can be up to 3e5, and the number of items could be large, how can we efficiently compute this?\n\nAn alternative approach is to consider that for each possible number of weight 3 items taken, we can compute the optimal combination of weight 1 and 2 items. But even that might be computationally heavy if done naively.\n\nWait, but maybe for each weight group, we can precompute the prefix sums. Let's think:\n\nFor weight 1 items, sorted in descending order of cost, the prefix sum array is s1 where s1[k] is the total cost of taking the first k items. Similarly for weight 2, s2[k], and for weight 3, s3[k].\n\nThen, for any possible number of weight 3 items taken (let's say x), the remaining weight is m - 3*x. Then, we need to find the best combination of weight 1 and 2 items that fit into that remaining weight.\n\nBut how to compute that combination quickly?\n\nFor the remaining weight, say rem = m - 3*x. How to find the best combination of weight 1 and 2 items? Well, for this, perhaps we can use a two-pointer approach. Let me think: for each possible number of weight 2 items taken (say y), the remaining weight after that is rem - 2*y, which can be filled with weight 1 items. But since the weight 1 items are sorted, we can take min(rem - 2*y, len1) items. But trying all possible y for each x would be O(n^2), which is not feasible.\n\nAlternatively, for the weight 1 and 2 items, we can precompute for all possible total weights up to m. But since m is up to 3e5, and for each possible weight, we can compute the maximum value for that weight using the weight 1 and 2 items. How?\n\nWait, the problem with weight 1 and 2 is that they can be combined in various ways. But since the weight is small (each is 1 or 2), perhaps we can compute for each possible weight up to m, the maximum value achievable using only weight 1 and 2 items. But how?\n\nThis sounds like a dynamic programming approach. Let's say dp[w] represents the maximum value for weight w using items of weight 1 and 2. Then, for each weight w, we can consider adding a weight 1 item or a weight 2 item. However,",
    "response": "\n\nTo solve this problem efficiently, we need to maximize the total cost of souvenirs Petya can carry given a weight limit. The souvenirs have weights of 1, 2, or 3, and the constraints are large (up to 100,000 items and 300,000 weight capacity). The key insight is that since the weights are small (1, 2, or 3), we can optimize using sorting and prefix sums for each weight group.\n\n---\n\n### **Approach**\n\n1. **Group and Sort**: Separate items by their weight (1, 2, 3) and sort each group in descending order of cost.\n2. **Prefix Sums**: Precompute prefix sums for each group so we can quickly determine the maximum cost when taking the top `k` items from each group.\n3. **Iterate Over Weight 3 Items**: For each possible number of weight-3 items taken, compute the remaining capacity and find the best combination of weight-1 and weight-2 items within that capacity.\n4. **Two-Pointer Technique**: Use a two-pointer approach on the weight-1 and weight-2 items to find the optimal combination for a given remaining capacity.\n\n---\n\n### **Code Implementation**\n\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    idx = 0\n    n, m = map(int, data[idx].split())\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        if idx >= len(data):\n            break\n        line = data[idx]\n        idx += 1\n        if not line:\n            continue\n        wi, ci = map(int, line.split())\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_cost = 0\n    \n    # Try all possible number of weight 3 items\n    max_w3 = min(len(w3), m // 3)\n    for x in range(0, max_w3 + 1):\n        rem = m - 3 * x\n        # Now find best combination of w1 and w2 with total weight <= rem\n        i = 0\n        j = 0\n        best = 0\n        while i < len(prefix1) and j < len(prefix2):\n            w = i + 2 * j\n            if w > rem:\n                i += 1\n            else:\n                best = max(best, prefix1[i] + prefix2[j])\n                j += 1\n        # Also check the case where we take all possible w1 items\n        max_i = min(len(prefix1) - 1, rem)\n        best = max(best, prefix1[max_i])\n        # Also check the case where we take all possible w2 items\n        max_j = min(len(prefix2) - 1, rem // 2)\n        best = max(best, prefix2[max_j])\n        # Update global maximum\n        max_cost = max(max_cost, best + prefix3[x])\n    \n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### **Explanation**\n\n- **Grouping and Sorting**: Items are grouped by their weight and sorted to prioritize higher-cost items.\n- **Prefix Sums**: These allow O(1) lookup for the total value of the top `k` items in each weight group.\n- **Iterating Over Weight 3 Items**: For each number of weight-3 items taken (`x`), the remaining capacity is used to find the optimal combination of weight-1 and weight-2 items.\n- **Two-Pointer Technique**: Efficiently finds the best combination of weight-1 and weight-2 items for each remaining capacity.\n\nThis solution runs in **O(n log n)** due to sorting and **O(m)** for the prefix sum and two-pointer steps, making it efficient enough for the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    idx = 0\n    n, m = map(int, data[idx].split())\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        if idx >= len(data):\n            break\n        line = data[idx]\n        idx += 1\n        if not line:\n            continue\n        wi, ci = map(int, line.split())\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_cost = 0\n    \n    # Try all possible number of weight 3 items\n    max_w3 = min(len(w3), m // 3)\n    for x in range(0, max_w3 + 1):\n        rem = m - 3 * x\n        # Now find best combination of w1 and w2 with total weight <= rem\n        i = 0\n        j = 0\n        best = 0\n        while i < len(prefix1) and j < len(prefix2):\n            w = i + 2 * j\n            if w > rem:\n                i += 1\n            else:\n                best = max(best, prefix1[i] + prefix2[j])\n                j += 1\n        # Also check the case where we take all possible w1 items\n        max_i = min(len(prefix1) - 1, rem)\n        best = max(best, prefix1[max_i])\n        # Also check the case where we take all possible w2 items\n        max_j = min(len(prefix2) - 1, rem // 2)\n        best = max(best, prefix2[max_j])\n        # Update global maximum\n        max_cost = max(max_cost, best + prefix3[x])\n    \n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 978,
        "thoughts_token_count": 1023
    }
}