{
    "start": 1758338187.1405017,
    "end": 1758338295.4025629,
    "start-formatted": "2025-09-20 12:16 KST",
    "end-formatted": "2025-09-20 12:18 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    g = int(data[2])\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_fact = n + m\n    fact = [1] * (max_fact + 1)\n    for i in range(1, max_fact + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact = [1] * (max_fact + 1)\n    inv_fact[max_fact] = pow(fact[max_fact], MOD - 2, MOD)\n    for i in range(max_fact - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n\n    # We need to find the number of strings with exactly n 0s and m 1s\n    # that can be reduced to g with the given operation rules.\n\n    # The operation reduces the string length by 1 each time.\n    # So the total number of operations is (n + m - 1), since we start from n + m\n    # and reduce to 1 character.\n    # The final character must be g.\n\n    # Let's define dp[i][j]: number of ways to have i 0s and j 1s such that\n    # the final character is 0 or 1, depending on the state.\n\n    # But we can use a more efficient approach based on parity and logic.\n\n    # Let's consider the parity of the number of 0s and 1s.\n\n    # The final character after all operations is determined by the parity of the number of 0s.\n    # Because each operation replaces two characters with one:\n    # - If two 0s: replace with 1\n    # - If two 1s: replace with 0\n    # - If one 0 and one 1: replace with 0 (since 0+1=1, but the rule says \"if it replaces two zeros, otherwise zero\")\n\n    # Wait, the rule says: replace two last characters with one other character.\n    # It equals one if it replaces two zeros, otherwise zero.\n\n    # So:\n    # - 00 -> 1\n    # - 01 -> 0\n    # - 10 -> 0\n    # - 11 -> 0\n\n    # So the result of combining any pair is 0 except when combining two 0s.\n\n    # This implies that the final character depends on the number of 0s.\n    # Each operation reduces the count of 0s by 1 or 2, depending on the pair.\n    # But in the end, the parity of the number of 0s determines the final character.\n\n    # If the number of 0s is even, then the final character is 0.\n    # If the number of 0s is odd, then the final character is 1.\n\n    # Because:\n    # - Every pair of 0s becomes 1 (odd number of 0s -> eventually becomes 1)\n    # - Any other pair becomes 0 (even number of 0s -> eventually becomes 0)\n\n    # Therefore, the final character is:\n    # - 0 if the number of 0s is even\n    # - 1 if the number of 0s is odd\n\n    # So for the final character to be g, the number of 0s must be congruent to g mod 2.\n\n    # Thus, the answer is the number of ways to choose n 0s and m 1s such that n ≡ g mod 2.\n\n    if (n % 2) == g:\n        print(comb(n + m, n))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    g = int(data[2])\n    \n    # Precompute factorials and inverse factorials modulo MOD\n    max_fact = n + m\n    fact = [1] * (max_fact + 1)\n    for i in range(1, max_fact + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact = [1] * (max_fact + 1)\n    inv_fact[max_fact] = pow(fact[max_fact], MOD - 2, MOD)\n    for i in range(max_fact - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n\n    # We need to find the number of strings with exactly n 0s and m 1s\n    # that can be reduced to g with the given operation rules.\n\n    # The operation reduces the string length by 1 each time.\n    # So the total number of operations is (n + m - 1), since we start from n + m\n    # and reduce to 1 character.\n    # The final character must be g.\n\n    # Let's define dp[i][j]: number of ways to have i 0s and j 1s such that\n    # the final character is 0 or 1, depending on the state.\n\n    # But we can use a more efficient approach based on parity and logic.\n\n    # Let's consider the parity of the number of 0s and 1s.\n\n    # The final character after all operations is determined by the parity of the number of 0s.\n    # Because each operation replaces two characters with one:\n    # - If two 0s: replace with 1\n    # - If two 1s: replace with 0\n    # - If one 0 and one 1: replace with 0 (since 0+1=1, but the rule says \"if it replaces two zeros, otherwise zero\")\n\n    # Wait, the rule says: replace two last characters with one other character.\n    # It equals one if it replaces two zeros, otherwise zero.\n\n    # So:\n    # - 00 -> 1\n    # - 01 -> 0\n    # - 10 -> 0\n    # - 11 -> 0\n\n    # So the result of combining any pair is 0 except when combining two 0s.\n\n    # This implies that the final character depends on the number of 0s.\n    # Each operation reduces the count of 0s by 1 or 2, depending on the pair.\n    # But in the end, the parity of the number of 0s determines the final character.\n\n    # If the number of 0s is even, then the final character is 0.\n    # If the number of 0s is odd, then the final character is 1.\n\n    # Because:\n    # - Every pair of 0s becomes 1 (odd number of 0s -> eventually becomes 1)\n    # - Any other pair becomes 0 (even number of 0s -> eventually becomes 0)\n\n    # Therefore, the final character is:\n    # - 0 if the number of 0s is even\n    # - 1 if the number of 0s is odd\n\n    # So for the final character to be g, the number of 0s must be congruent to g mod 2.\n\n    # Thus, the answer is the number of ways to choose n 0s and m 1s such that n ≡ g mod 2.\n\n    if (n % 2) == g:\n        print(comb(n + m, n))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 549,
        "completion_token_count": 914,
        "thoughts_token_count": 0
    }
}