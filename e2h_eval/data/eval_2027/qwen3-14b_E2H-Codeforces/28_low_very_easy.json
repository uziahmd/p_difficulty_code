{
    "start": 1758309637.9066951,
    "end": 1758309685.3574886,
    "start-formatted": "2025-09-20 04:20 KST",
    "end-formatted": "2025-09-20 04:21 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to understand this problem. The task is to count the number of beautiful strings based on given n, m, and g. The beautiful string has exactly n zeros and m ones. But there's a catch: we need to be able to modify the string into the character g through some operations. \n\nWait, what's the modification process? The problem says that a modification is replacing the last two characters with one. And the replacement depends on the two characters. For example, if two zeros are replaced, they become one. If two ones are replaced, they become zero? Wait, no. Wait the description says: \"we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero.\" Oh right. So if you replace two zeros, you get a 1. If you replace two ones, you get a 0. And if you have two different characters, like 0 and 1, then what happens? Wait, the problem says that the replacement is done by exactly one other character. But the rule is: when you replace two last characters, the new character is 1 if the two are zeros, else zero. Wait, so if the two are 0 and 1, then the new character is zero? Because it's not two zeros. So for example, replacing \"01\" would result in 0. Similarly, replacing \"10\" would also result in 0. And replacing \"11\" would result in 0. Wait, but the problem says that the replacement is done by exactly one other character. So the replacement is determined by the two characters. So:\n\nIf the two are both 0s: replace with 1.\nIf the two are not both 0s (i.e., any other case, like 01, 10, 11): replace with 0.\n\nWait, but in the example given: \"01010\" becomes \"0100\" after one modification. Let's see: the original string is \"01010\". The last two characters are '10'. So replacing them with 0, which gives \"0100\". Then another modification would take the last two characters '00' and replace with 1, resulting in \"011\". So the final character is 1. \n\nSo the key here is that the process of modifying the string reduces its length by one each time. And the process can be done multiple times. The end goal is that after some number of modifications, the string becomes the single character g. \n\nBut how do we determine whether a given string s (with n zeros and m ones) can be modified down to g?\n\nSo the problem requires that the string s can be transformed via these operations into the character g. And we need to count all such s's that satisfy that condition.\n\nSo first, let's think about what conditions must hold for a string s (with n zeros and m ones) to be reducible to g.\n\nLet me think about the process of reducing the string. Each operation reduces the length by one. So starting with a string of length L = n + m. We need to perform (L - 1) operations to get down to a single character. But maybe not all possible sequences of operations lead to the same result. However, perhaps the final result depends only on the initial string's properties, not on the order of operations. That's probably the case. Otherwise, the problem would be impossible to solve. \n\nSo let's try to find out what the final character depends on. Let's think recursively. Suppose we have a string s. Let's say we perform any sequence of operations until we get to one character. What's the value of that character?\n\nLet me think about the parity of the number of 1s or something similar. Let's take some examples.\n\nFor example, consider the sample input where n=1, m=1, g=0. The possible strings are \"01\" and \"10\". Both of these can be reduced to 0. Let's see:\n\nTake \"01\": length is 2. One modification: replace the two characters. Since they are 0 and 1, not both 0s, so replace with 0. So the result is 0. Which matches g=0. Hence, these two strings are valid.\n\nAnother example: the second sample input is n=2, m=2, g=0. The output is 4. The possible strings are those with two 0s and two 1s. How can they be reduced to 0?\n\nLet's take the string \"0011\". Let's perform operations:\n\nFirst, the length is 4. Let's perform operations until we get to one character. Let's see:\n\nOne way: first, take the last two characters (11), replace with",
    "response": "To solve this problem, we need to determine the number of \"beautiful\" strings that can be reduced to a given character `g` using specific modification operations. The modifications involve replacing the last two characters of a string with a single character based on certain rules. \n\n### Approach\n1. **Understanding Modifications**: Each modification reduces the length of the string by 1. The replacement rule is:\n   - Replace two '0's with '1'.\n   - Replace any other pair (e.g., '01', '10', '11') with '0'.\n\n2. **Key Insight**: The final character after all possible modifications depends on the parity of the number of '1's in the string. Specifically:\n   - If the total number of '1's is even, the final character will be '0'.\n   - If the total number of '1's is odd, the final character will be '1'.\n\n3. **Conditions for Valid Strings**:\n   - The string must have exactly `n` zeros and `m` ones.\n   - The total number of '1's (i.e., `m`) must have the same parity as `g`. If `g` is '0', `m` must be even. If `g` is '1', `m` must be odd.\n\n4. **Combinatorial Counting**: Use combinatorial mathematics to count the number of valid permutations of `n` zeros and `m` ones that meet the parity condition. This is done using precomputed factorials and modular inverses for efficiency.\n\n### Solution Code\n```python\nMOD = 10**9 + 7\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    \n    # Precompute factorial and inverse factorial up to 2*1e5 + 5\n    max_n = 2 * 10**5 + 5\n    fact = [1] * (max_n)\n    inv_fact = [1] * (max_n)\n    \n    for i in range(1, max_n):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_n-1] = pow(fact[max_n-1], MOD-2, MOD)\n    for i in range(max_n-2, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    def comb(n, k):\n        if n < 0 or k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    idx = 0\n    results = []\n    while idx < len(input):\n        n = int(input[idx])\n        m = int(input[idx+1])\n        g = int(input[idx+2])\n        idx += 3\n        \n        total = n + m\n        if total == 0:\n            results.append(0)\n            continue\n        \n        # Check if the number of 1s (m) has the same parity as g\n        if g == 0:\n            if m % 2 != 0:\n                results.append(0)\n                continue\n        else:  # g == 1\n            if m % 2 == 0:\n                results.append(0)\n                continue\n        \n        # Compute combination(n + m, n)\n        c = comb(n + m, n)\n        results.append(c % MOD)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Precomputation**: Factorials and their modular inverses are precomputed up to a sufficiently large number to efficiently calculate combinations using modular arithmetic.\n- **Combination Calculation**: The number of valid permutations of `n` zeros and `m` ones is calculated using the combination formula $ C(n+m, n) $, which is computed using precomputed factorials and modular inverses.\n- **Parity Check**: The solution checks if the number of ones `m` has the correct parity based on the target character `g`. If not, the result is zero. Otherwise, it calculates the number of valid permutations using combinatorial mathematics.\n\nThis approach ensures that the solution is efficient and handles large values of `n` and `m` within the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 10**9 + 7\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    \n    # Precompute factorial and inverse factorial up to 2*1e5 + 5\n    max_n = 2 * 10**5 + 5\n    fact = [1] * (max_n)\n    inv_fact = [1] * (max_n)\n    \n    for i in range(1, max_n):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_n-1] = pow(fact[max_n-1], MOD-2, MOD)\n    for i in range(max_n-2, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    def comb(n, k):\n        if n < 0 or k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    idx = 0\n    results = []\n    while idx < len(input):\n        n = int(input[idx])\n        m = int(input[idx+1])\n        g = int(input[idx+2])\n        idx += 3\n        \n        total = n + m\n        if total == 0:\n            results.append(0)\n            continue\n        \n        # Check if the number of 1s (m) has the same parity as g\n        if g == 0:\n            if m % 2 != 0:\n                results.append(0)\n                continue\n        else:  # g == 1\n            if m % 2 == 0:\n                results.append(0)\n                continue\n        \n        # Compute combination(n + m, n)\n        c = comb(n + m, n)\n        results.append(c % MOD)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 547,
        "completion_token_count": 908,
        "thoughts_token_count": 1024
    }
}