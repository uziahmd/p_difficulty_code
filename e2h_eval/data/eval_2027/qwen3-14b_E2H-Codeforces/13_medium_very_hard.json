{
    "start": 1758019600.9170663,
    "end": 1758021774.6691234,
    "start-formatted": "2025-09-16 19:46 KST",
    "end-formatted": "2025-09-16 20:22 KST",
    "gpu": 2,
    "pid": 13,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine whether a given set of three musical notes forms a major triad, a minor triad, or neither. The input is three notes, and we have to check all possible orderings to see if any of them fit the major or minor criteria.\n\nFirst, I need to understand how the distances between the notes are calculated. The notes are arranged in a cyclic order of 12 notes. Each consecutive note is a semitone apart. So the distance between two notes is the number of semitones when moving from the lower to the higher note. For example, C to E is 4 semitones (C to C# is 1, then D, D#, E — that's four steps). But if the notes are in reverse, like E to C, the distance would be 8 semitones because you go the other way around the cycle. Wait, but according to the problem statement, the distance is measured from the lower to the upper. So when calculating the distance between X and Y, we need to find the minimal number of semitones when moving forward? Or wait, no. Wait the problem says that the distance between X and Y is taken as from the lower to the upper. So for example, between C and E, it's 4 semitones. Between E and C, it's 8 semitones. Because the distance is calculated as the number of steps from X to Y when moving upwards. So if X is lower than Y, then it's the number of steps between them. If X is higher than Y, then it's the number of steps when going the long way around the cycle?\n\nWait, the problem says: \"the distance between X and Y is taken from the lowest tone to the uppest one\". So, for example, the distance between E and C is 8 semitones because you have to go from E up to C via the next notes. Wait, but that's not possible. Wait, perhaps the way to compute the distance is that if you have two notes, you can arrange them in order. Let me think: the distance between X and Y is the number of semitones between them when moving from X to Y in the upward direction. So for example, if X is C and Y is E, then the distance is 4. If X is E and Y is C, then the distance is (12 - 4) = 8? Because moving from E to C upwards would require going through F, G, A, B, C — which is 8 semitones. So the distance between two notes is (Y - X) mod 12, but if we consider the order. Wait, no. Let me think of the notes as being arranged in a list. Let's assign each note an index. For example:\n\nThe order is C, C#, D, D#, E, F, F#, G, G#, A, B, H. Then, the next note after H is C again. So each note has an index from 0 to 11. For example, C is 0, C# is 1, D is 2, etc., H is 11.\n\nThen, the distance between X and Y is (Y_index - X_index) mod 12? No, because if X is C (0) and Y is E (4), then the distance is 4. If X is E (4) and Y is C (0), then the distance would be (0 -4 + 12) mod 12 = 8. So yes, the distance from X to Y is (Y_index - X_index) mod 12. Wait, but that's only if we take the minimal path. Wait, no. Because if X is C and Y is C#, the distance is 1. If X is C# and Y is C, then the distance is 11? Because moving upwards from C# to C would require going all the way around. So the distance is (Y - X) mod 12, but since we are moving from X to Y upwards, the distance is (Y_index - X_index) if Y is higher than X, else (Y_index - X_index + 12). Which is equivalent to (Y_index - X_index) mod 12, but since the problem says that the distance is measured from the lower to the upper, so the distance between X and Y is (Y_index - X_index) if Y is higher than X, otherwise (Y_index - X_index + 12). But how do I compute that?\n\nAlternatively, the distance between X and Y is (Y_index - X_index) if positive, else (Y_index - X_index + 12). So for example, if X is E (index 4) and Y is C (index 0), then Y_index - X_index is -4, which is negative. So adding 12 gives 8. Which matches the example given in the problem statement.\n\nSo the first thing I need to do is map each note to its index. Let's create a list of the notes in order, then for each note, find its index. Then, for any two notes, compute the distance between them as (y_index - x_index) if positive, else (y_index - x_index + 12). Wait, but that's the same as (y_index - x_index) % 12? Let's see. For example, if y_index is 0 and x_index is 4: (0 -4) = -4. mod 12 is 8. Which is correct. So the distance between X and Y is (y_index - x_index) mod 12. But wait, that's not correct. Because for example, if X is C (0) and Y is E (4), then (4-0) mod 12 is 4, which is correct. If X is E (4) and Y is C (0), (0-4) mod 12 is 8, which is correct. So the distance between X and Y is (y_index - x_index) mod 12. However, the problem says that the distance is measured from the lower to the upper. So, for example, if X is lower than Y, then the distance is positive. If X is higher than Y, then the distance is (y_index - x_index + 12). But mod 12 gives the same result.\n\nSo, the key is to compute the distance between two notes as (y_index - x_index) mod 12. But wait, no. Because if X is E and Y is C, then the distance is 8. But (y_index - x_index) mod 12 is (0 -4) mod 12 is 8. So that's correct.\n\nSo, the distance between X and Y is (y_index - x_index) mod 12. But since the problem says that the distance is from the lower to the upper, perhaps the way to compute it is that if you have two notes, the distance is the number of semitones you need to move upward from X to reach Y. Which is exactly what (y_index - x_index) mod 12 gives. Because if Y is higher than X, then the distance is positive. Otherwise, it's (y_index - x_index + 12).\n\nSo, with that in mind, the next step is to process the three notes. Since the triad is unordered, we need to check all possible permutations of the three notes to see if any permutation satisfies the major or minor conditions.\n\nFor a major triad: there exists an ordering X, Y, Z such that distance between X and Y is 4, and between Y and Z is 3. Then, the total between X and Z would be 7, but that's not necessary to check. For the major triad, the condition is that there exists a sequence where X to Y is 4, Y to Z is 3. Similarly, for minor, the sequence must have X to Y as 3 and Y to Z as 4.\n\nSo, for the three notes, we need to generate all possible permutations (since the order matters for checking the conditions) and check for each permutation if it meets either the major or minor criteria.\n\nBut since there are three notes, the number of permutations is 3! = 6. For each permutation (X, Y, Z), check if distance(X,Y) is 4 and distance(Y,Z) is 3 (major), or distance(X,Y) is 3 and distance(Y,Z) is 4 (minor).\n\nIf any of the permutations meets the major condition, then the answer is major. Similarly for minor. If none of the permutations meet either condition, then it's strange.\n\nSo the steps are:\n\n1. Read the three notes.\n\n2. Map each note to its index in the list of 12 notes.\n\n3. Generate all permutations of the three notes.\n\n4. For each permutation, check if it meets the major or minor condition.\n\n5. If any permutation meets major, return 'major'. Similarly for minor. If none, return 'strange'.\n\nBut how to generate all permutations? Well, in Python, itertools.permutations can be used. For example, for the three notes, permutations would generate all 6 possible orderings.\n\nNow, the problem says that the answer is always unambiguous, so we don't have to worry about overlapping cases.\n\nSo, first, I need to create a list of the notes in order. Let's see:\n\nThe order is C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, the problem says:\n\nThe notes are listed as: C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, in the problem description, the order is given as:\n\n\"the notes are repeated cyclically: after H goes C again, and before C stands H.\"\n\nSo the list is:\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nWait, but in the problem statement, the example says that the third input is 'A B H' and output is 'strange'. Let's check that. Let's think about that example.\n\nFor example, the third input is A, B, H.\n\nLet me think about the possible permutations. Let's take each permutation and check.\n\nLet's first map each note to their index. Let's create a dictionary for that.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nSo, indexes are:\n\nC: 0\n\nC#: 1\n\nD: 2\n\nD#:3\n\nE:4\n\nF:5\n\nF#:6\n\nG:7\n\nG#:8\n\nA:9\n\nB:10\n\nH:11\n\nSo for the third example input: A (9), B (10), H (11).\n\nNow, let's check all permutations.\n\nTake permutation (A, B, H):\n\ndistance between A and B is 10 -9 = 1 mod 12 is 1. Then between B and H is 11 -10 = 1. So not 3 or 4.\n\nAnother permutation: (A, H, B). Let's compute distance between A and H: H is 11. A is 9. 11 -9 = 2. So 2 semitones. Then between H and B: B is 10. H is 11. 10 -11 is -1 mod 12 is 11. So that's 11. Not 3 or 4.\n\nAnother permutation: (B, A, H). Distance between B and A: A is 9, B is 10. So (9 -10) mod 12 is ( -1 ) mod 12 = 11. So distance is 11. Not 3 or 4.\n\nAnother permutation: B, H, A. Distance B to H is 11 -10 = 1. Then H to A is 9 -11 = -2 mod 12 is 10. Not helpful.\n\nAnother permutation: H, A, B. Distance H to A is 9 -11 = -2 mod 12 is 10. Not 3 or 4. Then A to B is 1.\n\nAnother permutation: H, B, A. Distance H to B is 10 -11 = -1 mod 12 = 11. Then B to A is 9-10 = -1 mod 12 = 11. So nothing.\n\nSo none of the permutations meet the major or minor conditions. Hence output is strange. Which matches the example.\n\nSo the approach seems correct.\n\nNow, the plan is:\n\n- Create a mapping from note names to their indices.\n\n- For the three input notes, get their indices.\n\n- Generate all permutations of the three notes.\n\n- For each permutation, check:\n\n   For major: distance between first and second is 4, and between second and third is 3.\n\n   For minor: distance between first and second is 3, and between second and third is 4.\n\n- If any permutation satisfies major, return 'major'; if any satisfies minor, return 'minor'; else 'strange'.\n\nNow, the code steps:\n\nFirst, create the note to index mapping. Let's create a list of the notes in order, then a dictionary.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\nThen, for each input note, we can get their indices.\n\nThen, generate all permutations of the three notes. For example, if the input is [note1, note2, note3], then permutations will be all possible orderings.\n\nIn Python, itertools.permutations can be used. So, for the three notes, permutations would generate 6 possibilities.\n\nFor each permutation (x, y, z), compute the distance between x and y, then between y and z.\n\nBut how to compute the distance between two notes. Let's say x_index and y_index. The distance is (y_index - x_index) % 12 ?\n\nWait, no. Wait, the distance between X and Y is (y_index - x_index) if positive, else (y_index - x_index + 12). Which is equivalent to (y_index - x_index) % 12, but since the problem defines the distance as from the lower to upper note, which is exactly what (y_index - x_index) mod 12 gives. Wait, no. Let me think again. Suppose x is at index 11 (H), and y is at index 0 (C). Then, the distance from X to Y is (0 -11) mod 12 = ( -11 ) mod 12 = 1. But according to the problem statement, the distance between H and C is 1 semitone (since H is followed by C). So yes, that's correct. So the distance between X and Y is (y_index - x_index) mod 12. But wait, in that case, if X is H (11) and Y is C (0), the distance is (0 -11) mod 12 = 1. Which is correct. So that formula works.\n\nBut wait, the problem says that the distance between X and Y is measured from the lower to the upper. So if X is lower than Y, then it's the positive difference. If X is higher than Y, then the distance is (Y's index + 12 - X's index). For example, X is E (index 4), Y is C (index 0). Then the distance is (0 + 12 -4) = 8. Which is (0 -4) mod 12 = 8. So yes, the formula (y_index - x_index) mod 12 gives the correct distance.\n\nSo the code for distance between x and y is (y_index - x_index) % 12.\n\nSo for each permutation (x, y, z), we can compute:\n\nd1 = (y_index - x_index) % 12\n\nd2 = (z_index - y_index) % 12\n\nThen check if d1 is 4 and d2 is 3 (for major), or d1 is 3 and d2 is 4 (for minor).\n\nBut wait, for the major triad, the problem says that the distance between X and Y is 4 semitones and between Y and Z is 3. So the code for that is:\n\nif d1 ==4 and d2 ==3 → major.\n\nSimilarly for minor: d1 ==3 and d2 ==4 → minor.\n\nSo for each permutation, check these conditions.\n\nOnce any permutation satisfies major or minor, we can return accordingly.\n\nNow, the code steps:\n\nRead the input. The input is three space-separated notes. For example, the input could be read as a list of strings. For example, in the sample input, the first example is ['C E G'], which would be split into ['C', 'E', 'G'].\n\nSo, the code can read the input line, split into parts, then process each note.\n\nBut the input is given as a single line with three notes. For example, the first sample input is:\n\n['C E G', 'C# B F', 'A B H']\n\nWait, no. Wait, the sample input is given as:\n\nInput:\n\n['C E G', 'C# B F', 'A B H']\n\nBut that's probably a typo. Wait, the original problem says that the input is the only line contains 3 space-separated notes. So the input is a single line with three notes, like \"C E G\".\n\nBut in the example given, the input is a list of three examples. But that's probably part of the problem's example. For example, the sample input is given as:\n\nInput:\n\n['C E G', 'C# B F', 'A B H']\n\nBut that's probably a mistake. Because the actual input is a single line with three notes. So, perhaps the sample input is three separate test cases. But the user's code needs to read one line of input, split into three notes.\n\nSo, in the code, the input is read as a single line. For example, the code would read something like:\n\nnotes = input().split()\n\nWhich would split the input into a list of three elements.\n\nBut the sample input shows that the input is given as a list of three examples. However, in the problem statement, the input is described as \"the only line contains 3 space-separated notes\".\n\nSo for the code, the input is read as a single line, split into three notes. For example, for the first example, the input line is \"C E G\", which is split into ['C', 'E', 'G'].\n\nSo, the code should read the input as:\n\nnotes = input().split()\n\nThen, get the three notes.\n\nNow, the code can proceed as follows:\n\n- Create the note_to_index mapping.\n\n- For the three notes, get their indices as a list, say, indices = [note_to_index[note] for note in notes]\n\n- Generate all permutations of the three indices. For example, using itertools.permutations.\n\n- For each permutation (x, y, z):\n\n   compute d1 = (y - x) % 12\n\n   compute d2 = (z - y) % 12\n\n   if d1 ==4 and d2 ==3 → major → return 'major'\n\n   elif d1 ==3 and d2 ==4 → minor → return 'minor'\n\nIf after checking all permutations, none of them satisfy either condition, then return 'strange'.\n\nNow, code-wise, in Python, we can import itertools.permutations.\n\nBut for three elements, permutations would generate all 6 possible orderings.\n\nSo, the code:\n\nimport sys\n\nfrom itertools import permutations\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ndef main():\n\n    # Read input line\n\n    input_line = input().strip()\n\n    # Split into three notes\n\n    notes = input_line.split()\n\n    # Get their indices\n\n    indices = [note_to_index[note] for note in notes]\n\n    # Generate all permutations of the three indices\n\n    for perm in permutations(indices):\n\n        x, y, z = perm\n\n        d1 = (y - x) % 12\n\n        d2 = (z - y) % 12\n\n        if d1 == 4 and d2 ==3:\n\n            print(\"major\")\n\n            return\n\n        elif d1 ==3 and d2 ==4:\n\n            print(\"minor\")\n\n            return\n\n    # If none found\n\n    print(\"strange\")\n\nBut wait, the code above checks for each permutation. Once any permutation meets the major or minor condition, it prints and returns. Otherwise, after all permutations are checked, it prints 'strange'.\n\nBut let's test with the sample input.\n\nSample input 1: C E G → indices are 0, 4, 7.\n\nPermutations would include (0,4,7). Let's compute d1 = 4-0=4 mod12 is 4. d2 =7-4=3 mod12 is 3. So yes, major. So the code returns 'major'.\n\nSample input 2: C# B F → notes are C#, B, F. Their indices are 1, 10, 5.\n\nLet's check permutations. One of the permutations is B, C#, F → indices 10, 1, 5.\n\nd1 is (1 -10) mod12 → ( -9 ) mod12 → 3. Because 1-10 = -9. -9 + 12 = 3. So d1 is 3. Then d2 is (5 -1) mod12 = 4. So 3 and 4 → minor. So code returns 'minor'.\n\nThird example: A B H → indices 9, 10, 11. Let's check all permutations. For example, (9,10,11): d1 is 1, d2 is 1. No. Any permutation? Let's see (10, 9, 11): d1 is (9-10) mod12 → -1 mod12 is 11. d2 is 11-9=2 mod12 is 2. No. Another permutation (10, 11, 9): d1 is 1, d2 is (9-11) mod12 → -2 mod12 is 10. No. Another permutation (11, 9, 10): d1 is (9-11) mod12 → -2 → 10. d2 is 10-9=1. No. So none of them meet the conditions. So output is 'strange'.\n\nThus, the code works for the sample.\n\nBut what about cases where the same note appears multiple times? Well, the problem says that the input is three notes. But the problem says that a chord is an unordered set of no less than three notes. However, the problem says that the input is three notes, but perhaps they can be duplicates. However, according to the problem statement, the answer is always unambiguous. But in the code, if two notes are the same, then for example, the distance between them is zero. But since the code checks for permutations, but if two notes are same, then in any permutation, the distance between them would be zero. But since the code requires d1 and d2 to be 3 or 4, etc., it would not match. So the code would return 'strange'.\n\nBut the problem says that the input is three notes. However, the problem says that the answer is always unambiguous, so perhaps the input is always valid (i.e., three distinct notes). But the code can handle duplicates.\n\nNow, what about the case where the same note is present multiple times? For example, input is C C C. Then, all permutations would have x, y, z as same. So d1 is 0, d2 is 0. So code returns 'strange'.\n\nBut the problem says that the answer is always unambiguous. However, the code handles that.\n\nNow, code-wise, the code is correct. But I need to make sure that the note_to_index is properly built. Let's check the order.\n\nThe order is as per the problem statement: C, C#, D, D#, E, F, F#, G, G#, A, B, H.\n\nYes. So the list is correct.\n\nAnother test case: C# B F → which is the second example. Let's check the code. The code would generate permutations. One of them is B, C#, F. Which is indices 10, 1, 5.\n\nd1 is (1 -10) mod 12 → ( -9 ) mod12 = 3. d2 is (5 - 1) mod12 = 4. So yes, minor.\n\nSo code returns minor.\n\nAnother test case: C E G → returns major.\n\nNow, another example: let's take a minor triad. For example, B C# F. The code should detect that. Let's see:\n\nNotes are B (10), C# (1), F (5). Permutation (B, C#, F) → d1 is 1-10 mod12 → -9 mod12 is 3. d2 is 5-1=4 mod12 → 4. So yes, minor.\n\nAnother example: C# E G. Let's see. What's the distance between C# and E? E is index 4, C# is 1. 4-1=3 → d1 is 3. Then E to G is 7-4=3. So d2 is 3. So no. So that's not minor. But if the permutation is C#, G, E? Let's see. d1 is (G's index - C#'s index) → 7-1=6. d2 is E's index - G's index → 4-7 = -3 mod12 is 9. No. Not helpful. So that's not a minor or major.\n\nSo code would return strange.\n\nAnother test case: C D# G. Let's check. Let's see, C is 0, D# is 3, G is 7. Let's check permutations. For example, C, D#, G. d1 is 3-0=3, d2 is 7-3=4 → that's minor. So code would return minor.\n\nYes. So the code would detect that.\n\nSo the code seems correct.\n\nNow, implement this in Python.\n\nBut note that the code needs to read from stdin and write to stdout. Also, the code should not have any print statements except for the output.\n\nNow, code:\n\nImport permutations from itertools.\n\nBut in some coding platforms, the code may need to have the necessary imports. So the code will have:\n\nimport sys\n\nfrom itertools import permutations\n\nBut the code must not have any extra outputs.\n\nSo the code would be:\n\nRead the input line, split into three notes, process as above.\n\nNow, code:\n\nBut the code must be written as a Python script that reads from stdin and writes to stdout.\n\nSo here's the code:\n\nimport sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_line = sys.stdin.read().strip()\n    notes = input_line.split()\n    \n    indices = [note_to_index[note] for note in notes]\n    \n    for perm in permutations(indices):\n        x, y, z = perm\n        d1 = (y - x) % 12\n        d2 = (z - y) % 12\n        if d1 == 4 and d2 == 3:\n            print(\"major\")\n            return\n        elif d1 == 3 and d2 == 4:\n            print(\"minor\")\n            return\n    print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n\nWait, but in some cases, the input may have leading or trailing spaces. But using split() would handle that.\n\nTesting with the sample input:\n\nSample input line: 'C E G' → output 'major'.\n\nAnother sample input line: 'C# B F' → output 'minor'.\n\nThird input line: 'A B H' → output 'strange'.\n\nSo the code should work.\n\nBut what about the case where the same note is present multiple times?\n\nLike input 'C C C' → returns strange.\n\nAnother example: 'C E G' → major.\n\nAnother example: 'C E# G'? Wait, but the note names are fixed. The input notes are only from the given list. So the code will raise KeyError if the note is not in the note_to_index. However, the problem says that the input is three notes in the given notation. So the code can assume that the input is valid.\n\nThus, the code is correct.\n",
    "response": "\n\nTo solve this problem, we need to determine if a given set of three musical notes forms a major triad, a minor triad, or neither. The solution involves checking all permutations of the three notes to see if they meet the criteria for either a major or minor triad based on the semitone distances between the notes.\n\n### Approach\n1. **Mapping Notes to Indices**: Convert each musical note to an index based on its position in the cyclic sequence of 12 notes.\n2. **Permutations Check**: Generate all permutations of the three input notes and check each permutation against the criteria for major and minor triads.\n3. **Distance Calculation**: Calculate the semitone distance between consecutive notes in each permutation using modular arithmetic to handle the cyclic nature of the musical scale.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_line = sys.stdin.read().strip()\n    notes = input_line.split()\n    \n    indices = [note_to_index[note] for note in notes]\n    \n    for perm in permutations(indices):\n        x, y, z = perm\n        d1 = (y - x) % 12\n        d2 = (z - y) % 12\n        if d1 == 4 and d2 == 3:\n            print(\"major\")\n            return\n        elif d1 == 3 and d2 == 4:\n            print(\"minor\")\n            return\n    print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Mapping Notes**: The notes are mapped to indices based on their order in the musical scale. This allows for easy calculation of semitone distances using modular arithmetic.\n2. **Permutations**: By generating all permutations of the three input notes, we ensure that every possible ordering is checked for both major and minor triad conditions.\n3. **Distance Calculation**: For each permutation, the distances between consecutive notes are calculated using modulo 12 arithmetic to handle the cyclic nature of the scale. If a permutation meets the criteria for a major or minor triad, the corresponding result is printed immediately. If no valid triad is found after checking all permutations, \"strange\" is printed.\n\nThis approach efficiently checks all possible configurations of the input notes and ensures correctness by leveraging permutations and modular arithmetic.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_line = sys.stdin.read().strip()\n    notes = input_line.split()\n    \n    indices = [note_to_index[note] for note in notes]\n    \n    for perm in permutations(indices):\n        x, y, z = perm\n        d1 = (y - x) % 12\n        d2 = (z - y) % 12\n        if d1 == 4 and d2 == 3:\n            print(\"major\")\n            return\n        elif d1 == 3 and d2 == 4:\n            print(\"minor\")\n            return\n    print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 683,
        "completion_token_count": 547,
        "thoughts_token_count": 6416
    }
}