{
    "start": 1758017573.2683918,
    "end": 1758019487.1477551,
    "start-formatted": "2025-09-16 19:12 KST",
    "end-formatted": "2025-09-16 19:44 KST",
    "gpu": 2,
    "pid": 2,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Valera and X\n\nValera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter \"X\". Valera's teacher thinks that the letters on the piece of paper form an \"X\", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.\n\n## Input\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\n## Output\nPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\n## Example\n### Input\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n### Output\n['NO', 'YES', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe task is to determine if a given square grid forms an 'X' according to specific rules. The conditions are:\n\n1. Both diagonals must have the same letter.\n2. All other squares (not on the diagonals) must have the same letter, which is different from the diagonal's letter.\n\nSo, first, I need to check all the cells in the two diagonals. Then check all the other cells.\n\nLet me think about how to approach this.\n\nFirst, for a grid of size n x n where n is odd. The main diagonal is from (0,0) to (n-1, n-1). The other diagonal is from (0, n-1) to (n-1, 0). All cells on these two diagonals must be the same. Also, all non-diagonal cells must be the same and different from the diagonal's letter.\n\nSo steps to solve:\n\n1. Check all cells in the two diagonals. Are they all the same? Let's call this character 'd_char'.\n2. Check all non-diagonal cells. Are they all the same? Let's call this 'other_char'.\n3. Ensure that 'd_char' is not equal to 'other_char'.\n\nBut how to check these?\n\nFirst, let's collect all the diagonal cells. For each cell (i,j), it's on the main diagonal if i == j. Or on the anti-diagonal if i + j == n - 1. So for each cell in the grid, check if it's on either of these two lines.\n\nSo for the first part, iterate through all cells. For each cell, if it is on a diagonal, check if it's equal to the first diagonal character. But wait, what if there are multiple characters in the diagonals? So, for example, the first diagonal cell (0,0) is 'x', but another cell in the diagonal is 'y'? Then it's invalid.\n\nSo, for the diagonals, collect all the characters and check if they are all the same. Similarly for the non-diagonal cells.\n\nBut how to do that?\n\nLet me think: For the diagonals, collect all the characters. Then check if all of them are the same. Then for the non-diagonal cells, collect all their characters and check if all are same and different from the diagonal's.\n\nBut how to collect those?\n\nLet me think of the steps:\n\n- Read the grid. Let's say grid is a list of lists.\n\n- For all cells (i, j):\n\n   if i == j or i + j == n-1: it's a diagonal cell.\n\n   else: it's a non-diagonal cell.\n\nSo first, collect all diagonal characters. Let's get the first diagonal character (for example, grid[0][0]) and check if all other diagonal cells are equal to it.\n\nBut what if the grid has no diagonal cells? Well, n is at least 3, so there are diagonals.\n\nWait, for n=3, the main diagonal has 3 cells, and the anti-diagonal also has 3 cells. But the center cell (1,1) is part of both diagonals. So when collecting the diagonal cells, we need to make sure that we don't count duplicates, but in terms of checking, the same cell is part of both diagonals. However, the code can just check all cells that are on either diagonal.\n\nBut for the purpose of checking if all diagonal cells are same, we can collect all the characters from the diagonals and check if they are all same.\n\nSo for example, for n=5, the diagonals are:\n\ncells (i, i) and (i, n-1 -i) for i from 0 to n-1.\n\nBut for the center cell (i = n//2), it's part of both diagonals. So when collecting the characters, it's included once, but in the code, it's checked once.\n\nSo, for the diagonals, collect all the characters in the two diagonals. Then check if all are same.\n\nSimilarly, collect all the non-diagonal characters and check if all are same and different from the diagonal's.\n\nSo here's the plan:\n\nCheck if all diagonal cells are same. Let's call this d_char.\n\nCheck if all non-diagonal cells are same. Let's call this o_char.\n\nCheck if d_char != o_char.\n\nIf all these are true, output YES, else NO.\n\nNow, how to implement this?\n\nFirst, read the input. The first line is n, then n lines of n characters each.\n\nSo in Python, read n, then read n lines, each line being a string. Then, for each line, convert into a list of characters? Or just process as strings.\n\nThen, for each cell (i, j):\n\nCheck if i == j or i + j == n-1. If yes, it's a diagonal cell.\n\nSo for all cells, we can loop through i from 0 to n-1, j from 0 to n-1.\n\nLet me think of variables:\n\ndiagonal_chars = set()\n\nnon_diagonal_chars = set()\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if i == j or i + j == n-1:\n\n            diagonal_chars.add(grid[i][j])\n\n        else:\n\n            non_diagonal_chars.add(grid[i][j])\n\nThen, check if len(diagonal_chars) == 1 and len(non_diagonal_chars) == 1 and diagonal_chars != non_diagonal_chars.\n\nWait, but that would work?\n\nYes. Because if all diagonal cells are same, then diagonal_chars has one element. Similarly for non-diagonal. And then check that they are different.\n\nBut what about the case where non_diagonal_chars is empty? Well, for n >=3, when n is 3, the non-diagonal cells are the ones not on the diagonals. For example, in a 3x3 grid, the diagonals have 3 + 3 -1 = 5 cells (since the center is counted twice). So non-diagonal cells are 9 -5 =4 cells. So for n=3, non_diagonal_chars will have 4 elements. So for the code, if all of them are same, then len(non_diagonal_chars) is 1.\n\nSo yes, the code can proceed with that approach.\n\nBut wait, what if there are no non-diagonal cells? Well, for n=1, but the problem says n is at least 3. So no problem.\n\nSo the steps are:\n\nRead n.\n\nRead n lines, each line is a string of length n.\n\nThen:\n\nCollect all diagonal characters into a set. Check that the set has size 1.\n\nCollect all non-diagonal characters into a set. Check that the set has size 1.\n\nCheck that the two sets are different.\n\nIf all these are true, output YES, else NO.\n\nYes, that seems correct.\n\nBut let's test with the examples.\n\nFirst example input:\n\n5\n\nxooox\n\noxoxo\n\nsoxoo\n\noxoxo\n\nxooox\n\nSo the grid is:\n\nRow 0: x o o o x\n\nRow 1: o x o x o\n\nRow 2: s o x o o\n\nRow 3: o x o x o\n\nRow 4: x o o o x\n\nThe diagonals are:\n\nFor i=0, j=0 (x), i=0, j=4 (x)\n\ni=1, j=1 (x), j=3 (x)\n\ni=2, j=2 (x), j=2 (since i + j = 2 + 2 =4, which is n-1=4 (n=5). So yes.\n\ni=3, j=1 (x?), j=3 (i=3, j=1: i + j =4, yes. So for row 3, j=1 is part of the anti-diagonal.\n\nWait, let's check for each cell:\n\nFor i=0, j=0 (main diagonal), and i=0, j=4 (anti-diagonal). So in row 0, the first and last are x.\n\nIn row 1, j=1 (main) and j=3 (anti). The values are x and x.\n\nIn row 2, j=2 (main) and j=2 (anti? i + j = 2 + 2 =4 = n-1 (5-1=4). Yes. So cell (2,2) is x. But in the input, row 2 is 'soxoo' — so row 2 is s o x o o. So cell (2,2) is x. So that's part of both diagonals.\n\nBut in the third row (i=3), j=1 (i + j = 3+1=4). So that's part of the anti-diagonal. The cell (3,1) is x. And cell (3,3) is x (i=3, j=3, main diagonal). Wait, i=3, j=3: i + j =6, which is not 4. So for n=5, the anti-diagonal is when i + j = 4. So for i=3, j=1: 3+1=4. So yes. So the cell (3,1) is part of the anti-diagonal. And cell (3,3) is part of the main diagonal? No, because i=3, j=3: i == j. So yes. So for the main diagonal.\n\nBut in the sample input, the third row is 'oxoxo' — row 3 is o x o x o. So (3,0) is o, (3,1) is x, (3,2) is o, (3,3) is x, (3,4) is o.\n\nSo for the main diagonal, (3,3) is x. For the anti-diagonal, (3,1) is x.\n\nSo for the diagonals, all cells are x? Let's check.\n\nLooking at row 2, cell (2,2) is x. But what about row 2, cell (2, 2) is x. What about other cells?\n\nIn row 0, the two ends are x. Row 1, the middle is x. Row 2, the middle is x. Row 3, the middle is x. Row 4, the ends are x. So all the diagonal cells are x. So diagonal_chars is {'x'}.\n\nNow for non-diagonal cells. Let's look at row 0, positions 1, 2, 3. Those are o, o, o. Then row 1, positions 0, 2, 4: o, o, o. Row 2, positions 0, 1, 3, 4: s, o, o, o. Wait, row 2 is s o x o o. So non-diagonal cells in row 2 are (i=2, j=0) which is s, j=1 (o), j=3 (o), j=4 (o). So in that row, the non-diagonal cells are s, o, o, o. So the non-diagonal_chars includes s, o. So the set would have size 2. Thus, the code would return NO, which matches the first sample's output.\n\nYes. So the code would correctly detect that the non-diagonal characters are not all same.\n\nAnother sample input is:\n\n3\n\nwsw\n\nsws\n\nwsw\n\nSo grid:\n\nRow 0: w s w\n\nRow 1: s w s\n\nRow 2: w s w\n\nThe diagonals are:\n\ncells (0,0) = w, (0,2) = w.\n\n(1,1) = w.\n\n(2,0) = w, (2,2) = w.\n\nSo all diagonals are w. The non-diagonal cells are:\n\nrow 0, j=1: s.\n\nrow 1, j=0 and j=2: s and s.\n\nrow 2, j=1: s.\n\nSo all non-diagonal cells are s. So the two sets are {'w'} and {'s'}, which are different. So output is YES. Which matches the sample.\n\nThird sample input:\n\n3\n\nxpx\n\npxp\n\nxpe\n\nSo grid:\n\nRow 0: x p x\n\nRow 1: p x p\n\nRow 2: x p e\n\nThe diagonals:\n\ncells (0,0)=x, (0,2)=x.\n\n(1,1)=x.\n\n(2,0)=x, (2,2)=e.\n\nSo the diagonal cells include x and e. So the set for diagonals is {x, e}, so len is 2. So code returns NO. Which matches the sample.\n\nThus, the approach seems correct.\n\nNow, coding this in Python.\n\nRead n. Then read n lines. For each line, read as a string. Then for each cell (i,j), check if it is on a diagonal.\n\nSo code:\n\nRead n.\n\ngrid = [input().strip() for _ in range(n)]\n\nThen, collect the diagonal and non-diagonal characters.\n\nBut in Python, for each row, it's a string. So grid[i][j] is the character at row i, column j.\n\nSo:\n\ndiagonal_chars = set()\n\nnon_diagonal_chars = set()\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if i == j or i + j == n - 1:\n\n            diagonal_chars.add(grid[i][j])\n\n        else:\n\n            non_diagonal_chars.add(grid[i][j])\n\nThen check:\n\nif len(diagonal_chars) == 1 and len(non_diagonal_chars) == 1 and diagonal_chars != non_diagonal_chars:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")\n\nWait, but what if the non_diagonal_chars is empty? Well, for n >=3, the non-diagonal cells are present. For example, n=3: 3x3 grid. Diagonals have 3 + 3 -1 =5 cells (since center is counted twice). So non-diagonal cells are 9-5=4. So non_diagonal_chars will have 4 elements. So in code, the len is 1 only if all are same.\n\nSo this code should handle all cases.\n\nBut what if all non-diagonal cells are same as the diagonal? Like, if all cells are same. Then the code would check that the diagonal and non-diagonal sets are same. So the condition would fail.\n\nYes. So that's correct.\n\nSo this code should work.\n\nNow, testing the sample inputs.\n\nSample Input 1:\n\n5\n\nxooox\n\noxoxo\n\nsoxoo\n\noxoxo\n\nxooox\n\nThe code would collect diagonal_chars as {x} (all x's?), but in row 2, cell (2,2) is x. But in row 2, the other cells are s, o, etc. So the non-diagonal chars include s, o, etc. So the non_diagonal_chars would have more than one element.\n\nSample input 2:\n\n3\n\nwsw\n\nsws\n\nwsw\n\ndiagonal_chars: all w's. non_diagonal_chars: all s's. So condition is met.\n\nSample input 3:\n\n3\n\nxpx\n\npxp\n\nxpe\n\ndiagonal_chars: (0,0) x, (0,2) x, (1,1) x, (2,0) x, (2,2) e. So diagonal_chars is {x, e}, len is 2. So condition fails.\n\nThus, code works.\n\nNow, code in Python.\n\nBut note that the input may have leading or trailing spaces? Probably not, as per the problem statement. Each of the next n lines contains n small letters. So the input lines are exactly n characters long. So when reading, using input().strip() could be wrong if the input has leading or trailing whitespace. However, the problem says that each line contains n letters. So perhaps it's better to read each line as input().strip()?\n\nBut perhaps in some cases, the input lines may have leading/trailing spaces? Probably not. The problem says that each of the next n lines contains n small letters. So each line is exactly n characters. So, perhaps using input().strip() is not needed. But in practice, perhaps the code should read each line as input().strip()? Because sometimes when you read from stdin, there may be trailing newlines, but in programming competition problems, each line is exactly the required characters. So for example, for the input line 'xooox', it's 5 characters. So perhaps using input().strip() is safe, but perhaps not necessary. However, in Python, when you read a line with input(), it includes the newline character? No. The input() function reads until the newline, which is excluded. So for example, if the line is 'xooox', then input() returns 'xooox' (without the newline). So for the code, the grid can be read as:\n\ngrid = [input() for _ in range(n)]\n\nBut in some cases, perhaps the user may have entered leading or trailing spaces. However, according to the problem statement, each line contains exactly n letters. So the code can safely read each line as input().strip()? Or perhaps not. Because if the line is exactly n characters, then input().strip() could remove leading/trailing whitespace, but if the line is correct, then it's not needed. But in programming competition problems, it's better to read the line as is. So perhaps the code should read each line as input().strip()? For example, if the input has leading or trailing spaces, but the problem says that each line has exactly n letters. So perhaps the code can read each line as input().strip().\n\nBut perhaps the code can just read each line as input().strip().\n\nBut in the sample input given, the first input is:\n\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\nBut in the actual input, the first line is 5, then the next 5 lines are the grid. So the code needs to read n, then read n lines, each line being exactly n characters.\n\nIn Python, when reading via input(), each line is read as a string without the trailing newline. So for example, if the input line is 'xooox', then input() returns that string. So the code can read the grid as [input() for _ in range(n)].\n\nBut in some cases, when the user inputs the lines, maybe there are leading or trailing spaces. However, according to the problem statement, each line contains exactly n letters. So we can assume that each line is exactly n letters. So the code can read each line as input().strip()?\n\nBut suppose a line is 'xooox ', with a trailing space. Then input().strip() would remove it, but that would change the data. However, according to the problem statement, the input is correct. So perhaps the code can read each line as input().strip().\n\nBut in practice, in programming contests, the code should read each line as input().strip() to avoid any leading/trailing whitespace. But perhaps the problem's input ensures that each line is exactly n letters. So perhaps the code can read each line as input().strip().\n\nBut for example, if a line is 'xooox', then input().strip() is same as the original. So, perhaps it's better to read as input().strip().\n\nBut in the code, perhaps the code can read each line as input().strip().\n\nSo in code:\n\nn = int(input())\n\ngrid = [input().strip() for _ in range(n)]\n\nBut then, for each row, the length must be n. But according to the problem statement, that is guaranteed.\n\nSo, the code proceeds.\n\nNow, code:\n\nRead n.\n\nRead grid.\n\nCheck for the diagonals and non-diagonals.\n\nNow, code:\n\nBut in Python, for the loops:\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if i == j or i + j == n -1:\n\n            diagonal_chars.add(...)\n\nBut for the code, the code can be written as:\n\ndiagonal = set()\n\nnon_diagonal = set()\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if i == j or i + j == n -1:\n\n            diagonal.add(grid[i][j])\n\n        else:\n\n            non_diagonal.add(grid[i][j])\n\nThen check:\n\nif len(diagonal) == 1 and len(non_diagonal) == 1 and diagonal != non_diagonal:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")\n\nYes.\n\nBut what if the grid is all same letters? For example, n=3, all 'a's. Then the diagonals are 'a's, non-diagonal are 'a's. So the condition is that diagonal and non-diagonal are different. So the code returns NO. Which is correct, since the non-diagonal letters are same as the diagonal.\n\nSo the code works.\n\nAnother case: n=3, diagonals are all 'a's, non-diagonal are all 'b's. Then code returns YES.\n\nYes.\n\nThus, this code should handle all cases.\n\nNow, let's code this in Python.\n\nBut note that in Python, the input may have multiple test cases? Wait, looking back at the problem statement:\n\nThe input is given as:\n\nThe first line contains integer n. Then n lines follow.\n\nBut the sample input shows multiple test cases. Wait, the sample input is given as a list of inputs. For example, the first input is:\n\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\nBut that's probably the way the sample input is structured. However, in the actual problem, the code is supposed to read from standard input. So the code should read one test case. Wait, the problem says:\n\nInput:\n\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\nSo the code should process one test case. However, the sample input shows three test cases. But that's probably the way the sample is presented. For example, the sample input is given as three separate test cases, and the outputs are given as three outputs. However, in practice, the code is supposed to read one test case. So the code should read one n, then n lines.\n\nBut looking back, the sample input is given as a list of inputs. For example, the first input is:\n\n5\n\nxooox\n\noxoxo\n\nsoxoo\n\noxoxo\n\nxooox\n\nWhich is one test case. Then another test case with n=3, etc. But in the actual programming competition problem, the code is supposed to read one test case. So the code is written for one test case.\n\nBut the sample input is presented as a list of multiple test cases, but the code is supposed to process one. So the code is written to read one test case.\n\nThus, the code is correct as written.\n\nNow, let's write the Python code.\n\nRead n from input.\n\nThen read n lines.\n\nThen process.\n\nSo:\n\nn = int(input())\n\ngrid = [input().strip() for _ in range(n)]\n\ndiagonal = set()\n\nnon_diagonal = set()\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if i == j or i + j == n - 1:\n\n            diagonal.add(grid[i][j])\n\n        else:\n\n            non_diagonal.add(grid[i][j])\n\nif len(diagonal) == 1 and len(non_diagonal) == 1 and diagonal != non_diagonal:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")\n\nWait, but in Python, comparing sets with '!=' is possible. For example, if diagonal is {'x'}, non_diagonal is {'o'}, then diagonal != non_diagonal is True.\n\nYes.\n\nBut what if diagonal is {'x'}, non_diagonal is {'x'}? Then the condition is false.\n\nYes.\n\nSo this code should work.\n\nTesting the sample input.\n\nSample 1:\n\nInput is 5, then the grid. The code's diagonal is {x} and non_diagonal has s and o. So len(non_diagonal) is more than 1. So output is NO.\n\nSample 2: 3, grid is:\n\nwsw\n\nsws\n\nwsw\n\ndiagonal is {w} (all cells on diagonals are w). non_diagonal is {s} (all non-diagonal cells are s). So condition is met. Output YES.\n\nSample 3: 3, grid:\n\nxpx\n\npxp\n\nxpe\n\ndiagonal cells: (0,0) x, (0,2) x, (1,1) x, (2,0) x, (2,2) e. So diagonal set is {x, e}, len is 2. So output NO.\n\nThus, code works.\n\nNow, check edge cases.\n\nCase where n=3, all cells are same. Then diagonal and non-diagonal are same. So output is NO.\n\nAnother case where n=3, diagonals are all 'a', non-diagonal are all 'b'. Output YES.\n\nAnother case where diagonals have two different letters. For example, in a 3x3 grid, the main diagonal has 'a' and 'b' (but that's impossible, since all diagonals must be same). Wait, for example:\n\nRow 0: a b a\n\nRow 1: b a b\n\nRow 2: a b a\n\nThen diagonals are (0,0) a, (0,2) a, (1,1) a, (2,0) a, (2,2) a. So diagonal is {a}. Non-diagonal cells are (0,1) b, (1,0) b, (1,2) b, (2,1) b. So non_diagonal is {b}. So output YES.\n\nAnother case: n=3, grid:\n\na a a\n\na a a\n\na a a\n\nThen diagonals are {a}, non-diagonal {a}. So they are same. So output NO.\n\nAnother case where diagonals have two different letters. For example, grid:\n\na b c\n\nd e f\n\ng h i\n\nThe diagonals are a, e, i and c, e, g. So the diagonal cells are a, c, e, g, i. So if they are not all same, then the code returns NO.\n\nThus, the code handles all cases.\n\nSo this should be the correct solution.\n",
    "response": "\n\nTo solve this problem, we need to determine if a given square grid of characters forms the letter \"X\" based on specific criteria. The criteria are that all characters on both diagonals of the grid must be the same, and all other characters (not on the diagonals) must be the same and different from the characters on the diagonals.\n\n### Approach\n1. **Input Reading**: Read the size of the grid `n` and the grid itself.\n2. **Diagonal and Non-diagonal Character Collection**: Traverse each cell in the grid to collect characters that lie on the main diagonal (from top-left to bottom-right) and the anti-diagonal (from top-right to bottom-left) into one set. Collect characters not on these diagonals into another set.\n3. **Validation**: Check if both sets contain exactly one unique character each and ensure these characters are different.\n\n### Solution Code\n```python\nn = int(input())\ngrid = [input().strip() for _ in range(n)]\n\ndiagonal = set()\nnon_diagonal = set()\n\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            diagonal.add(grid[i][j])\n        else:\n            non_diagonal.add(grid[i][j])\n\nif len(diagonal) == 1 and len(non_diagonal) == 1 and diagonal != non_diagonal:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n```\n\n### Explanation\n- **Reading Input**: The input is read as an integer `n` followed by `n` lines of strings, each representing a row of the grid.\n- **Character Collection**: We use two sets to collect characters from the diagonals and non-diagonal positions. This helps efficiently check if all characters in each category are the same.\n- **Validation Checks**: By ensuring both sets have exactly one element each and that these elements are different, we confirm the grid meets the criteria for forming an \"X\".\n\nThis approach ensures that we efficiently check the required conditions using set operations, which are optimal for membership testing and uniqueness checks. The solution runs in O(n^2) time complexity, which is efficient given the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\ngrid = [input().strip() for _ in range(n)]\n\ndiagonal = set()\nnon_diagonal = set()\n\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            diagonal.add(grid[i][j])\n        else:\n            non_diagonal.add(grid[i][j])\n\nif len(diagonal) == 1 and len(non_diagonal) == 1 and diagonal != non_diagonal:\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 444,
        "completion_token_count": 453,
        "thoughts_token_count": 5743
    }
}