{
    "start": 1758313600.2995505,
    "end": 1758313633.5396245,
    "start-formatted": "2025-09-20 05:26 KST",
    "end-formatted": "2025-09-20 05:27 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me understand the construction rules again.\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that has only one connection (so those leaves) are connected to k more new vertices. And this step must be done at least once. So the process is like building layers. \n\nLet me think about the structure. The first step is the root node. Then, in the first expansion, we add k children to the root. Now, each of those children is a leaf. Then, in the next step, each of those leaves gets k new children. But this step must be done at least once. So the minimal case would be when we do this expansion once. Wait, the example says that for k=4, the minimal snowflake has 1 + 4 + 4*4 = 1 + 4 + 16 = 21? Or maybe not. Wait the example given in the problem says that the smallest possible for k=4 is shown, but the example input includes 13 as a valid case. Let me check the sample input.\n\nIn the sample input, for example, n=13 gives YES. Let me think how that can be achieved. Let's think about the structure.\n\nLet me model the number of nodes. Let's think recursively. Suppose the snowflake is built in m layers. The first layer is the root. Then each layer adds new nodes. Let's think about the process:\n\n- Initially, there's 1 node (level 0).\n- Level 1: add k nodes. Total is 1 + k.\n- Then, each node in level 1 (which are all leaves) gets k children. So level 2 adds k * k nodes. Total is 1 + k + k^2. But wait, this is after one expansion step. However, according to the problem statement, the step of adding k children to each leaf must be done at least once. So the minimal case would be when we have two expansions. For example, the initial step (adding the first k nodes) is the first expansion. Then, the second expansion is adding k children to each of the leaves (the first k nodes). So the total is 1 + k + k^2. But the problem says that the step should be done at least once. So the minimal snowflake is when you have two expansions. Wait, no. Because the initial step is adding the first k children. Then, the step of adding k children to each leaf (which is done once) would be the second expansion. So the minimal number of nodes is 1 + k + k^2. For example, if k=2, the minimal would be 1+2+4=7.\n\nBut the sample input says that n=13 is a yes. Let's see. Let's think for k=3. Then 1 + 3 + 9 = 13. Oh right! So that's why n=13 is valid. So the formula for the snowflake is that the total number of nodes is 1 + k + k^2 + ... + k^m, where m is the number of expansions. Wait, no. Because the first expansion is adding k nodes. Then, each expansion step adds k^something.\n\nWait, the process is:\n\nStart with 1 node.\n\nFirst expansion: add k children to the root. Now, the total nodes is 1 + k. Then, each of the k leaves gets k children. So each of the k nodes adds k children. That's k*k = k² nodes added. Now total is 1 + k + k². Then, if we do another expansion step, each of the leaves (those added in the previous step) would get k children. So each of the k² nodes adds k children, which is k³ added. So total becomes 1 +k +k² +k³. But according to the problem statement, the step of adding k children to each leaf must be done at least once. So the minimal case is when we have two expansions: the initial step (adding k children) and then the step of adding k children to each of the leaves once. Which gives 1 +k +k².\n\nWait, but the first expansion is the initial step. Then, the second expansion is the step that's done once. So the total nodes is 1 +k +k². So the snowflake can be constructed for any n that is equal to 1 +k +k² + ... +k^m, where m ≥ 2? Or perhaps m ≥1?\n\nWait, the problem says: the initial step is adding the",
    "response": "To solve this problem, we need to determine if a given number of vertices `n` can form a snowflake graph as defined. The snowflake graph is constructed in a specific hierarchical manner, and we need to check if there exists a valid `k > 1` such that the total number of vertices matches `n`.\n\n### Approach\n1. **Understanding Snowflake Construction**:\n   - A snowflake starts with a single vertex.\n   - This vertex is connected to `k` new vertices (where `k > 1`).\n   - Each leaf node (vertices with only one connection) is then connected to `k` more vertices. This step must be performed at least once.\n\n2. **Mathematical Insight**:\n   - The total number of vertices in a snowflake can be represented as a sum of a geometric series. Specifically, for a snowflake with `m` layers (expansions), the total number of vertices is given by the formula:\n     $$\n     n = 1 + k + k^2 + \\ldots + k^m\n     $$\n   - This simplifies to:\n     $$\n     n = \\frac{k^{m+1} - 1}{k - 1}\n     $$\n\n3. **Efficient Check**:\n   - For each test case, we need to check if there exists a valid `k > 1` such that the above formula holds for some integer `m ≥ 1`.\n   - We iterate over possible values of `k` starting from 2 up to a reasonable limit (since `k` grows exponentially, we can cap it at around 60 for practical purposes).\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k from 2 to a maximum of log2(n) + 1\n    max_k = int(math.log(n, 2)) + 2\n    for k in range(2, max_k + 1):\n        # Try different m\n        # We want to find m such that (k^(m+1) - 1) / (k - 1) == n\n        # So, we can compute the sum until it exceeds n\n        total = 1\n        m = 0\n        while True:\n            total += k ** (m + 1)\n            m += 1\n            if total == n:\n                return True\n            elif total > n:\n                break\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    for i in range(1, t + 1):\n        n = int(input[i])\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read in one go for efficiency, especially given the constraints.\n- **Checking Validity**: For each number `n`, the function `is_snowflake` checks if there exists a valid `k` such that the sum of the geometric series equals `n`.\n- **Geometric Series Calculation**: For each `k`, we simulate the addition of layers (expansions) until the total number of vertices exceeds `n`. If it matches exactly, we return \"YES\".\n\nThis approach efficiently checks all possible values of `k` and ensures that we handle very large numbers up to $10^{18}$ within feasible limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k from 2 to a maximum of log2(n) + 1\n    max_k = int(math.log(n, 2)) + 2\n    for k in range(2, max_k + 1):\n        # Try different m\n        # We want to find m such that (k^(m+1) - 1) / (k - 1) == n\n        # So, we can compute the sum until it exceeds n\n        total = 1\n        m = 0\n        while True:\n            total += k ** (m + 1)\n            m += 1\n            if total == n:\n                return True\n            elif total > n:\n                break\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    for i in range(1, t + 1):\n        n = int(input[i])\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 554,
        "completion_token_count": 746,
        "thoughts_token_count": 1024
    }
}