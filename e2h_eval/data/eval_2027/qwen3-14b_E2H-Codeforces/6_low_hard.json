{
    "start": 1758008332.4786153,
    "end": 1758008515.639176,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. So the task is to find two vouchers that don't overlap, their durations add up exactly to x, and the sum of their costs is as small as possible. If there's no such pair, output -1.\n\nFirst, I need to understand what the duration is. Oh right, the duration is ri - li + 1. So for each voucher, we can calculate that. Then, for two vouchers i and j, their durations should sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nSo the approach here is to find pairs of vouchers where one has duration d, the other has duration x - d, and they don't overlap. And find the minimum cost among all such pairs.\n\nBut how to do this efficiently? Because n can be up to 2e5, so O(n^2) is impossible. We need a smarter approach.\n\nLet me think. For each voucher, we can check if there exists another voucher with duration (x - duration_i), and that doesn't overlap with it. But how to find the minimal cost for that?\n\nMaybe we can pre-process vouchers by their duration. Like, create a dictionary where for each duration d, we have a list of vouchers with that duration, sorted by their end time (or start time?), and also track the minimum cost for certain ranges.\n\nWait, but for each voucher with duration d, we need to find a voucher with duration (x - d) that starts after this voucher ends, or ends before this voucher starts.\n\nSo for example, suppose we have a voucher A with duration d, and we want to find vouchers B with duration (x - d) that end before A's start. Or start after A's end.\n\nSo for each voucher, we can check two possibilities:\n\n1. Find a voucher B that ends before the start of A. Then, A's duration is d, B's duration is x - d. The total duration is x. And since B ends before A starts, they don't overlap.\n\nOR\n\n2. Find a voucher B that starts after A ends. Then again, same condition.\n\nBut how to do this efficiently?\n\nAn idea: group vouchers by their duration. For each duration d, we can have a list of vouchers sorted by their end time. Also, for each duration, we can have a sorted list of start times, or something like that.\n\nFor example, suppose we have a voucher A with duration d. We need to find vouchers with duration (x - d). Let's call this target duration t = x - d. For each such voucher B in t, we need to check if B ends before A's start (so B's end <= A's start - 1). Or if B starts after A's end (B's start >= A's end + 1).\n\nSo for each voucher A, we can look for vouchers B in the t group that satisfy either of these two conditions.\n\nBut how to find the minimal cost for those B's?\n\nFor example, for the first case (B ends before A's start), we can find the minimal cost of B's where B's end <= A's start - 1. Similarly, for the second case, find minimal cost of B's where B's start >= A's end + 1.\n\nTo do this quickly, for each duration t, we can pre-process the vouchers in that group. For example, for each t, we can have a list of vouchers sorted by end time, and also have a prefix minimum array (for the end time sorted list) so that for any given value (like A's start - 1), we can binary search to find the latest end time that is <= that value, and then get the minimum cost up to that point. Similarly, for the start times, maybe we can sort by start time and have a prefix min array.\n\nAlternatively, for each duration t, we can have two sorted lists:\n\n- One sorted by end time, with a prefix min array (so for a given end time, we can find the minimal cost among all vouchers in this duration that end before or equal to a certain value).\n\n- Another sorted by start time, with a prefix min array (so for a given start time, we can find the minimal cost among vouchers in this duration that start at or after a certain value).\n\nWait, but for the first case (B ends before A's start), we need to find the minimal cost of B's in duration t where end <= A's start -1. For that, if we have the list of vouchers in duration t sorted by end time, then we can binary search to find the largest end time <= A's start -1. Then, the minimal cost up to that point would be our candidate.\n\nSimilarly, for the second case (B starts after A's end), we need to find the minimal cost of B's in duration t where start >=",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, while minimizing the total cost. The solution must efficiently handle up to 200,000 vouchers and ensure optimal performance.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly finding vouchers of a specific duration when needed.\n2. **Sort and Preprocess**: For each duration, we sort vouchers by their end time and start time. Additionally, we maintain prefix minimum arrays for these sorted lists to quickly find the minimum cost for valid ranges.\n3. **Binary Search for Efficient Lookup**: For each voucher, we check if there exists another voucher with a complementary duration (i.e., `x - duration`). Using binary search, we efficiently find valid non-overlapping vouchers and compute the minimum cost.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, pre-process sorted lists and prefix minima\n    # For each duration, we have two sorted lists:\n    # 1. sorted by end time, with prefix minima of cost\n    # 2. sorted by start time, with prefix minima of cost\n    # Also, for the second list, we can sort by start time and have prefix minima\n    \n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix minima for end-sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix minima for start-sorted list\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_by_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append(min_cost)\n        # Store in processed\n        processed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target = x - d\n        if target not in processed:\n            continue\n        # Check for vouchers with duration target that end before l\n        sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start = processed[target]\n        # Find the largest end <= l - 1\n        # Binary search on sorted_by_end's end times\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min_end[pos]\n            min_total = min(min_total, current_min + cost)\n        # Check for vouchers with duration target that start after r\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(starts, r + 1)\n        if pos < len(prefix_min_start):\n            current_min = prefix_min_start[pos]\n            min_total = min(min_total, current_min + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for complementary durations.\n- **Sorting and Prefix Minima**: For each duration group, vouchers are sorted by end time and start time. Prefix minimum arrays are used to quickly determine the minimum cost up to any point in the sorted lists.\n- **Binary Search**: For each voucher, we use binary search to efficiently find valid non-overlapping vouchers with the required complementary duration, ensuring the solution is both optimal and efficient.\n\nThis approach ensures that we efficiently check all possible pairs of vouchers while maintaining a time complexity that is feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, pre-process sorted lists and prefix minima\n    # For each duration, we have two sorted lists:\n    # 1. sorted by end time, with prefix minima of cost\n    # 2. sorted by start time, with prefix minima of cost\n    # Also, for the second list, we can sort by start time and have prefix minima\n    \n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix minima for end-sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix minima for start-sorted list\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_by_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append(min_cost)\n        # Store in processed\n        processed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target = x - d\n        if target not in processed:\n            continue\n        # Check for vouchers with duration target that end before l\n        sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start = processed[target]\n        # Find the largest end <= l - 1\n        # Binary search on sorted_by_end's end times\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min_end[pos]\n            min_total = min(min_total, current_min + cost)\n        # Check for vouchers with duration target that start after r\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(starts, r + 1)\n        if pos < len(prefix_min_start):\n            current_min = prefix_min_start[pos]\n            min_total = min(min_total, current_min + cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1050,
        "thoughts_token_count": 1023
    }
}