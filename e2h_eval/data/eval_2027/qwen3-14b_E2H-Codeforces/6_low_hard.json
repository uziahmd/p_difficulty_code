{
    "start": 1758313551.4631069,
    "end": 1758313607.05419,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo the task is to find two vouchers that don't overlap, their durations add up exactly to x, and the sum of their costs is minimized. If there's no such pair, output -1.\n\nFirst, understanding the problem. Each voucher has a duration of ri - li + 1. We need two vouchers where one's duration is a, the other's is b, such that a + b = x. Also, they must not overlap. And we have to find the minimum cost for such pairs.\n\nThe challenge is to efficiently check all possible pairs that meet these conditions, given that n can be up to 2e5, which suggests that O(n^2) approaches are out of the question. So we need an efficient way to find for each voucher, another voucher that fits the duration requirement and doesn't overlap.\n\nLet me think about how to approach this. Let's break it down:\n\nFor each voucher i, we can compute its duration d_i = ri - li + 1. Then, we need another voucher j with duration d_j = x - d_i. And vouchers i and j must not overlap.\n\nSo the idea is: for each voucher, check if there exists another voucher with duration (x - d_i), and that they don't overlap. Then take the minimum cost for such pairs.\n\nBut how do we efficiently find for each voucher i, the minimum cost of a voucher j with duration (x - d_i) that doesn't overlap with i?\n\nLet me think about pre-processing. Maybe group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher i with duration d, we can look into the group for duration (x - d) and check if any of those vouchers don't overlap with i.\n\nBut even that approach could be O(n^2) in the worst case. For example, if all vouchers have duration x/2, then for each voucher, we have to check all others. However, perhaps we can optimize this by pre-processing for each duration, the vouchers sorted in some way, so that for a given voucher i, we can quickly find the minimal cost voucher j in the (x - d_i) group that doesn't overlap with i.\n\nWait, but how to find the minimal cost voucher j that doesn't overlap with i. For that, perhaps for each duration, we can pre-process some data structures. For example, for vouchers of duration d, sorted by their end time (ri) or start time (li), so that when checking for a voucher i, we can find the earliest possible voucher j that ends before i starts, or the latest possible voucher j that starts after i ends. But how?\n\nLet me think. Suppose for each duration d, we have two sorted lists:\n\n- One sorted by their end time (ri). So for a voucher i with duration d_i, looking for vouchers of duration (x - d_i) that end before li (so that their ri < li). In that case, the earliest possible ones would be the ones with the smallest end times. But since we want the minimal cost, maybe we can pre-process for each duration d, the minimal cost for vouchers that end before a certain time, or start after a certain time.\n\nAlternatively, for each duration d, we can have two structures:\n\n- A list of vouchers sorted by their end time (ri), and for each position, we can keep track of the minimum cost up to that point. So that for a given li, we can binary search in this list for the largest ri that is less than li, and then get the minimum cost up to that index. Similarly, for vouchers sorted by their start time (li), we can find the earliest li that is greater than ri of voucher i, and find the minimum cost in that part.\n\nThis seems promising. Let's elaborate.\n\nSuppose we have a duration d. For all vouchers with duration d, we can sort them by their end time (ri), and create a prefix minimum array. Similarly, sort them by start time (li), and create a prefix minimum array. Wait, maybe not. Let me think again.\n\nFor a voucher i with duration d_i, we need to find vouchers j with duration d_j = x - d_i. These vouchers j must either end before the start of i (rj < li) or start after the end of i (lj > ri).\n\nSo for each voucher i, for the required duration d_j = x - d_i, we can check two possibilities:\n\n1. Find the minimal cost voucher j with duration d_j that ends before li (rj < li). \n\n2. Find the minimal cost voucher j with duration d_j that starts after ri (lj > ri).\n\nIf we can find the minimal cost for both cases, then take the minimum between",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. The solution involves efficiently checking for valid voucher pairs using preprocessing and binary search techniques.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. This allows us to quickly access all vouchers of a specific duration.\n2. **Sorting and Prefix Minimum Arrays**: For each duration, sort vouchers by their end time and start time. Additionally, maintain prefix minimum arrays to quickly determine the minimum cost for vouchers ending before a certain time or starting after a certain time.\n3. **Binary Search**: For each voucher, check if there exists another voucher with the required complementary duration that does not overlap. Use binary search on the sorted lists to efficiently find valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Group vouchers by their duration\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        l, r, cost, d = v\n        duration_map[d].append((l, r, cost))\n\n    # For each duration, pre-process sorted lists and prefix minima\n    # For each duration d, we have:\n    # sorted_by_end: list of (r, l, cost), sorted by r\n    # prefix_min_end: list of min cost up to index i in sorted_by_end\n    # sorted_by_start: list of (l, r, cost), sorted by l\n    # prefix_min_start: list of min cost up to index i in sorted_by_start\n    preprocessed = dict()\n\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time (r)\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min for end sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time (l)\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix min for start sorted list\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_by_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append(min_cost)\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start)\n\n    min_total = float('inf')\n\n    for v in vouchers:\n        l_i, r_i, cost_i, d_i = v\n        needed_d = x - d_i\n        if needed_d < 1:\n            continue\n        if needed_d not in preprocessed:\n            continue\n        # Get the preprocessed data for needed_d\n        sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start = preprocessed[needed_d]\n\n        # Case 1: find vouchers in needed_d that end before l_i\n        # sorted_by_end is sorted by r (end time)\n        # find the largest r_j < l_i\n        # use bisect to find the insertion point\n        # the index is the number of elements <= l_i - 1\n        end_list = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_left(end_list, l_i) - 1\n        if pos >= 0:\n            min_cost = prefix_min_end[pos]\n            if min_cost != float('inf'):\n                total = cost_i + min_cost\n                if total < min_total:\n                    min_total = total\n\n        # Case 2: find vouchers in needed_d that start after r_i\n        # sorted_by_start is sorted by l (start time)\n        # find the first l_j > r_i\n        start_list = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_right(start_list, r_i)\n        if pos < len(start_list):\n            min_cost = prefix_min_start[pos]\n            if min_cost != float('inf'):\n                total = cost_i + min_cost\n                if total < min_total:\n                    min_total = total\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with their start time, end time, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end time and start time. Prefix minimum arrays are created to quickly determine the minimum cost for vouchers up to a certain point in these sorted lists.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists a valid complementary voucher (with the required duration) that does not overlap. Binary search is used to efficiently find the relevant vouchers in the preprocessed lists, and the minimum cost is updated accordingly.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n^2) solution, making it feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Group vouchers by their duration\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        l, r, cost, d = v\n        duration_map[d].append((l, r, cost))\n\n    # For each duration, pre-process sorted lists and prefix minima\n    # For each duration d, we have:\n    # sorted_by_end: list of (r, l, cost), sorted by r\n    # prefix_min_end: list of min cost up to index i in sorted_by_end\n    # sorted_by_start: list of (l, r, cost), sorted by l\n    # prefix_min_start: list of min cost up to index i in sorted_by_start\n    preprocessed = dict()\n\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time (r)\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min for end sorted list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time (l)\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix min for start sorted list\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_by_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append(min_cost)\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start)\n\n    min_total = float('inf')\n\n    for v in vouchers:\n        l_i, r_i, cost_i, d_i = v\n        needed_d = x - d_i\n        if needed_d < 1:\n            continue\n        if needed_d not in preprocessed:\n            continue\n        # Get the preprocessed data for needed_d\n        sorted_by_end, prefix_min_end, sorted_by_start, prefix_min_start = preprocessed[needed_d]\n\n        # Case 1: find vouchers in needed_d that end before l_i\n        # sorted_by_end is sorted by r (end time)\n        # find the largest r_j < l_i\n        # use bisect to find the insertion point\n        # the index is the number of elements <= l_i - 1\n        end_list = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_left(end_list, l_i) - 1\n        if pos >= 0:\n            min_cost = prefix_min_end[pos]\n            if min_cost != float('inf'):\n                total = cost_i + min_cost\n                if total < min_total:\n                    min_total = total\n\n        # Case 2: find vouchers in needed_d that start after r_i\n        # sorted_by_start is sorted by l (start time)\n        # find the first l_j > r_i\n        start_list = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_right(start_list, r_i)\n        if pos < len(start_list):\n            min_cost = prefix_min_start[pos]\n            if min_cost != float('inf'):\n                total = cost_i + min_cost\n                if total < min_total:\n                    min_total = total\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1236,
        "thoughts_token_count": 1024
    }
}