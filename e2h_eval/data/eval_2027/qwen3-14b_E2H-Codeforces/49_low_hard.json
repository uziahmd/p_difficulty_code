{
    "start": 1758309537.0152192,
    "end": 1758309915.8896768,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:25 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. So the task is to determine if we can assign mushroom counts to each lawn (vertex) such that for every given edge (road), the GCD and LCM of the two connected lawns match the given values. And if possible, output one such assignment.\n\nFirst, I need to think about the constraints. For each edge between u and v, we have gcd(u_val, v_val) = g and lcm(u_val, v_val) = l. Also, there's a relation between gcd and lcm: gcd(a,b) * lcm(a,b) = a*b. So, for each edge, the product of g and l must equal a*b. But since g divides both a and b, and l is a multiple of both, perhaps we can find possible values for a and b based on g and l.\n\nWait, but for a given pair (g, l), what are the possible values of a and b? Well, since the gcd is g, then a = g * x, b = g * y, where x and y are coprime. Then the lcm of a and b is g*x*y. So the lcm must be equal to g*lcm(x,y) = g*x*y. Which implies that the given l must be equal to g*x*y. Therefore, l must be divisible by g. If it's not, then there's no solution. Wait, but the problem statement says that the input is such that the original numbers were valid, but when we have the torn map, maybe some of the edges in the input may have invalid g and l pairs. So first, for each edge, we need to check if l is divisible by g. Because if not, then it's impossible. So that's a preliminary check.\n\nSo for each edge, if l % g != 0, then answer is NO. Otherwise, we can proceed.\n\nBut even if that's true, how do we model the problem? Because each edge gives us a relationship between two nodes. So this seems like a graph problem where each node has a value, and edges impose constraints between pairs of nodes.\n\nBut how to model these constraints? Let's think. For each edge between u and v, we know that the values of u and v must be multiples of g, and their product must be g*l. Also, since a and b are multiples of g, and their gcd is g, then x and y must be coprime. So, for the edge between u and v, the possible pairs (a, b) are (g*x, g*y), where x and y are coprime, and x*y = l/g.\n\nSo, for example, if the edge has g=1, l=3, then x*y must be 3. The coprime pairs (x,y) could be (1,3) or (3,1). So the possible a and b would be (1,3) or (3,1).\n\nNow, the problem is to assign values to each node such that all these constraints are satisfied. How can this be modeled?\n\nThis feels like a graph where each node's value is constrained by its edges. However, since each edge imposes a relationship between two nodes, perhaps we can model this as a graph where each connected component must have values that are consistent with each other.\n\nBut how to model the relationships. Let's think of each node's value as being a multiple of some base value, but with certain constraints. For example, if two nodes u and v are connected by an edge with g and l, then their values are multiples of g. Also, their product is g*l. So, if u's value is a, v's value is b, then a*b = g*l. Also, since gcd(a, b) = g, then a = g * x, b = g * y, and x and y are coprime. So x*y = l/g. Let me denote k = l/g. Then x*y = k, and gcd(x,y)=1.\n\nSo for each edge, the product of x and y is k, and they are coprime. Therefore, x and y must be divisors of k and coprime. So for each edge, the possible pairs (x, y) are pairs of coprime divisors of k whose product is k.\n\nBut how to assign x and y to the nodes. Let's think of this as building a graph where each node's value is determined relative to others. For example, suppose we have a connected component. We can pick a root node and assign a value, then propagate constraints through the edges.\n\nBut how to handle this? Let's consider that for each edge, the two nodes must have values that are multiples of g. Also, their ratio must be such that when divided by g, they are coprime.\n\nAlternatively, considering that for each node u, its value is some",
    "response": "To solve this problem, we need to determine if we can assign mushroom counts to each lawn (vertex) such that for every given edge (road), the GCD and LCM of the two connected lawns match the given values. If possible, we also need to output one such valid assignment.\n\n### Approach\n1. **Check Validity of Input**: For each edge, check if the LCM is divisible by the GCD. If not, it's impossible to satisfy the constraints, so we immediately return \"NO\".\n2. **Graph Construction**: Represent the lawns and roads as a graph where each node (lawn) has edges with associated GCD and LCM values.\n3. **Component Analysis**: Each connected component of the graph must be analyzed separately. We use a BFS approach to propagate constraints from an arbitrary starting node.\n4. **Value Assignment**: For each edge, derive the possible values for the nodes based on the GCD and LCM constraints. This involves ensuring that the product of the values of the two nodes equals the product of the GCD and LCM of the edge.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if any edge has LCM not divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Prepare answer array\n    ans = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            # BFS to assign values\n            q = deque()\n            q.append(start)\n            visited[start] = True\n            # Assign initial value (we can choose any value compatible with the first edge)\n            # But since there are no edges yet, we can assign any value, but need to be consistent\n            # Let's assume the first node has value g * x, and then propagate\n            # However, for the first node, if it's isolated, assign 1 (since it's allowed)\n            if len(graph[start]) == 0:\n                ans[start] = 1\n                continue\n            # Take the first edge to set up the initial value\n            first_edge = graph[start][0]\n            neighbor, g_val, l_val = first_edge\n            k = l_val // g_val\n            # Possible pairs (x, y) where x * y = k and gcd(x, y) = 1\n            # For simplicity, pick x=1, y=k\n            # Assign ans[start] = g_val * 1\n            ans[start] = g_val\n            q.append(neighbor)\n            visited[neighbor] = True\n            ans[neighbor] = g_val * k\n            # Now process the queue\n            while q:\n                curr = q.popleft()\n                for neighbor, g_val, l_val in graph[curr]:\n                    if visited[neighbor]:\n                        # Check consistency\n                        a = ans[curr]\n                        b = ans[neighbor]\n                        if math.gcd(a, b) != g_val or (a * b) // math.gcd(a, b) != l_val:\n                            print(\"NO\")\n                            return\n                        continue\n                    # Compute required product\n                    k = l_val // g_val\n                    a = ans[curr]\n                    # Since a and ans[neighbor] must satisfy:\n                    # gcd(a, b) = g_val, lcm(a,b) = l_val\n                    # So b must be (g_val * k) / (a / g_val)\n                    # Because a * b = g_val * l_val\n                    # So b = (g_val * l_val) / a\n                    # Also, since a must be divisible by g_val\n                    if a % g_val != 0:\n                        print(\"NO\")\n                        return\n                    b = (g_val * l_val) // a\n                    # Check if gcd(a, b) == g_val and lcm(a, b) == l_val\n                    if math.gcd(a, b) != g_val or (a * b) // math.gcd(a, b) != l_val:\n                        print(\"NO\")\n                        return\n                    ans[neighbor] = b\n                    visited[neighbor] = True\n                    q.append(neighbor)\n    \n    print(\"YES\")\n    print(' '.join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into a list of edges and a graph structure.\n2. **Validity Check**: Each edge is checked to ensure that the LCM is divisible by the GCD. If not, the answer is immediately \"NO\".\n3. **BFS Traversal**: For each connected component of the graph, we use BFS to propagate values from an arbitrary starting node. The initial value is chosen based on the first edge encountered.\n4. **Consistency Check**: During BFS traversal, we ensure that each node's value is consistent with its neighbors according to the given GCD and LCM constraints. If any inconsistency is found, the answer is \"NO\".\n\nThis approach ensures that all constraints are checked efficiently and any valid assignment is determined using graph traversal techniques.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if any edge has LCM not divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Prepare answer array\n    ans = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            # BFS to assign values\n            q = deque()\n            q.append(start)\n            visited[start] = True\n            # Assign initial value (we can choose any value compatible with the first edge)\n            # But since there are no edges yet, we can assign any value, but need to be consistent\n            # Let's assume the first node has value g * x, and then propagate\n            # However, for the first node, if it's isolated, assign 1 (since it's allowed)\n            if len(graph[start]) == 0:\n                ans[start] = 1\n                continue\n            # Take the first edge to set up the initial value\n            first_edge = graph[start][0]\n            neighbor, g_val, l_val = first_edge\n            k = l_val // g_val\n            # Possible pairs (x, y) where x * y = k and gcd(x, y) = 1\n            # For simplicity, pick x=1, y=k\n            # Assign ans[start] = g_val * 1\n            ans[start] = g_val\n            q.append(neighbor)\n            visited[neighbor] = True\n            ans[neighbor] = g_val * k\n            # Now process the queue\n            while q:\n                curr = q.popleft()\n                for neighbor, g_val, l_val in graph[curr]:\n                    if visited[neighbor]:\n                        # Check consistency\n                        a = ans[curr]\n                        b = ans[neighbor]\n                        if math.gcd(a, b) != g_val or (a * b) // math.gcd(a, b) != l_val:\n                            print(\"NO\")\n                            return\n                        continue\n                    # Compute required product\n                    k = l_val // g_val\n                    a = ans[curr]\n                    # Since a and ans[neighbor] must satisfy:\n                    # gcd(a, b) = g_val, lcm(a,b) = l_val\n                    # So b must be (g_val * k) / (a / g_val)\n                    # Because a * b = g_val * l_val\n                    # So b = (g_val * l_val) / a\n                    # Also, since a must be divisible by g_val\n                    if a % g_val != 0:\n                        print(\"NO\")\n                        return\n                    b = (g_val * l_val) // a\n                    # Check if gcd(a, b) == g_val and lcm(a, b) == l_val\n                    if math.gcd(a, b) != g_val or (a * b) // math.gcd(a, b) != l_val:\n                        print(\"NO\")\n                        return\n                    ans[neighbor] = b\n                    visited[neighbor] = True\n                    q.append(neighbor)\n    \n    print(\"YES\")\n    print(' '.join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 1252,
        "thoughts_token_count": 1024
    }
}