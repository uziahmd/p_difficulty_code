{
    "start": 1758309274.8130984,
    "end": 1758309328.9363542,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about determining whether there's a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. So, the main task is to check if such a matching exists. \n\nFirst, I need to understand the constraints. The input gives R rebels and B bases. But since it's a perfect matching, R must equal B. Wait, the first line says R and B. Oh right, the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\". So for a perfect matching, R must equal B. Wait, but the input could have R != B. But according to the problem statement, the first line gives R and B. However, the problem says that the assignment is a perfect matching. So in that case, if R != B, then it's impossible. But looking at the input constraints, the first line says 1 ≤ R, B ≤ 10. But the problem says that the assignment is a perfect matching. Therefore, if R != B, the answer is automatically No. Wait, but the problem says that the input is given with R and B. So the first thing to check is if R equals B. If not, output No. Otherwise, proceed.\n\nSo the first step in the code is to check if R and B are equal. If not, output No. Otherwise, proceed to check for possible non-intersecting matchings.\n\nNow, the main challenge is to find if there's a way to match each rebel to a base such that no two line segments between matched pairs cross each other.\n\nHow do I approach this? Well, since the number of points is small (up to 10), maybe we can generate all possible perfect matchings and check each one for intersections. For example, for R = B = 3, there are 3! = 6 possible matchings. For each of these, check if any two line segments cross. If there's at least one matching where none of the segments cross, output Yes, else No.\n\nBut how to check if two line segments intersect?\n\nFirst, I need a function that checks if two line segments AB and CD intersect. But since the problem says that no three points are colinear, so any two lines that are not overlapping will either cross or not. Also, since all points are distinct, and no three are colinear, two line segments can't share a common point (since that would imply that two points are same, which is not allowed). Wait, but the line segments could be from different pairs. For example, if a line segment from A to B and another from C to D, but they cross at a point that's not an endpoint. But since no three points are colinear, any two line segments that cross must do so at a single point that's not an endpoint of either segment.\n\nBut how to check if two line segments AB and CD intersect?\n\nI remember that there's a computational geometry method for checking this. The standard approach is to use the orientation method. So, for two line segments AB and CD:\n\n- Check if the orientations of (A, B, C) and (A, B, D) are different, and the orientations of (C, D, A) and (C, D, B) are different. That would indicate that the segments cross each other.\n\nAlternatively, using the cross product approach.\n\nAnother approach is to use the formula for line intersection. But considering that the problem states that no three points are colinear, so we don't have to worry about overlapping lines or cases where the segments lie on the same line.\n\nSo, the steps to check for two line segments AB and CD intersecting:\n\nCheck if the following two conditions hold:\n\n1. The orientation of (A, B, C) is different from the orientation of (A, B, D). This implies that C and D are on opposite sides of AB.\n\n2. The orientation of (C, D, A) is different from the orientation of (C, D, B). This implies that A and B are on opposite sides of CD.\n\nIf both conditions are true, then the segments AB and CD intersect.\n\nBut also, there's the case where one of the endpoints lies on the other segment. However, the problem states that no three points are colinear. So, for example, if C is on AB, then since no three points are colinear, that would require that C is one of A or B. But since all points are distinct, that's not possible. So, the line segments cannot share any points, and thus, the only possible way for two segments to intersect is if they cross each other in their interiors.\n\nTherefore, the standard orientation-based check should suffice.\n\nSo, first, I need to implement a function to compute the orientation of three points. The orientation can be determined by the cross product. For three points p, q, r:\n\norientation = (q.x - p.x)",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting line segments intersect. The solution involves checking all possible perfect matchings and verifying if any of them meet the non-intersection condition.\n\n### Approach\n1. **Check for Equal Numbers**: First, ensure that the number of spaceships (R) is equal to the number of bases (B). If not, output \"No\".\n2. **Generate Permutations**: For the given number of spaceships and bases, generate all possible permutations of assignments.\n3. **Check for Intersections**: For each permutation, check if any pair of line segments (connecting spaceships to bases) intersect. This is done using orientation checks based on cross products to determine if line segments intersect.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().splitlines()\n    R, B = map(int, data[0].split())\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, data[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, data[i].split())\n        bases.append((x, y))\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef has_intersection(matching, rebels, bases):\n    for i in range(len(matching)):\n        for j in range(i+1, len(matching)):\n            a = rebels[i]\n            b = bases[matching[i]]\n            c = rebels[j]\n            d = bases[matching[j]]\n            if segments_intersect(a, b, c, d):\n                return True\n    return False\n\ndef main():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    # Generate all possible permutations of bases indices\n    from itertools import permutations\n    for perm in permutations(range(B)):\n        if not has_intersection(perm, rebels, bases):\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Orientation Check**: The `orientation` function calculates the orientation of three points using the cross product, which helps determine if points are collinear or the direction of rotation.\n3. **Segment Intersection Check**: The `segments_intersect` function uses the orientation results to determine if two line segments intersect.\n4. **Permutations Check**: The main function generates all permutations of base indices and checks each permutation for intersections. If any permutation is found without intersections, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().splitlines()\n    R, B = map(int, data[0].split())\n    rebels = []\n    for i in range(1, R+1):\n        x, y = map(int, data[i].split())\n        rebels.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, data[i].split())\n        bases.append((x, y))\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef has_intersection(matching, rebels, bases):\n    for i in range(len(matching)):\n        for j in range(i+1, len(matching)):\n            a = rebels[i]\n            b = bases[matching[i]]\n            c = rebels[j]\n            d = bases[matching[j]]\n            if segments_intersect(a, b, c, d):\n                return True\n    return False\n\ndef main():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    # Generate all possible permutations of bases indices\n    from itertools import permutations\n    for perm in permutations(range(B)):\n        if not has_intersection(perm, rebels, bases):\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 762,
        "thoughts_token_count": 1024
    }
}