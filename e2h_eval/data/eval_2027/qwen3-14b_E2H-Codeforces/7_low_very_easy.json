{
    "start": 1758008513.7410622,
    "end": 1758008724.0959609,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure.\n\nThe snowflake starts with one vertex. Then, we add k new vertices connected to the initial one. Then, each vertex that has only one connection (so those added in the first step) must get k new vertices connected to them. And this process is done at least once. Wait, so the steps are:\n\n- Start with 1 node.\n- Add k nodes connected to the initial node. Now total nodes: 1 + k.\n- Then, each node that has degree 1 (those added in the previous step) must have k new nodes connected to them. This step must be done at least once. So after the first expansion, we do another expansion. So for example, if we do this once, then each of those k nodes gets k new nodes. So the total would be 1 + k + k*k. But maybe there are more steps?\n\nWait, the problem says that the step of adding k new nodes to each leaf (nodes with only one connection) is done at least once. So the construction can have multiple layers. Let me think about how the number of nodes is formed.\n\nLet me model the construction. Let's think of it as layers. The initial node is layer 0. Then layer 1 has k nodes. Each node in layer 1 has k children in layer 2. Then each node in layer 2 has k children in layer 3, and so on. But the process requires that the step of adding k children to each leaf is done at least once. So the minimum depth is 2 layers? Or maybe the initial step is adding layer 1, then adding layer 2 (so that step is done once). So the snowflake must have at least two layers beyond the initial node.\n\nWait, the initial step is adding k nodes to the initial node. Then, the step of adding k new nodes to each leaf (which are those in layer 1) must be done at least once. So the minimal snowflake is when we do that once. So the total number of nodes is 1 + k + k * k. For example, when k=4, the minimal is 1 +4 +4*4 = 21? But the example says that for n=6, the answer is NO. Let me check the sample input.\n\nLooking at the sample input:\n\nSample Input includes n=6, output is NO. Let's see why. For example, if k=2, then the minimal would be 1+2 + 2*2 = 1+2+4=7. Which is larger than 6. If k=1, but the problem states that k>1. So no possible k for n=6. Hence output is NO.\n\nAnother sample input is n=13. Output is YES. Let's see. Let's think of possible k and steps. Suppose the snowflake has two layers. So total nodes is 1 +k +k^2. For example, if k=3, then 1+3+9=13. Yes! So that's valid. So answer is YES.\n\nSo the problem reduces to checking if n can be written in the form of 1 + k + k^2 + ... + k^m, where m ≥ 1 (since the step must be done at least once). Wait, no. Because the initial step is adding k nodes (layer 1), then the step is adding k nodes to each of the leaves (layer 1 nodes) once. That would be layer 2. So the total is 1 +k + k^2. But perhaps there can be more steps. Like, after adding layer 2, we can again add layer 3, etc. So the general formula for the number of nodes is 1 + k*(k^m -1)/(k-1), where m is the number of expansions. Wait, let me think again.\n\nThe initial node is 1. Then, the first expansion adds k nodes. Then, each expansion step adds k times the number of leaves from the previous step. Let me think recursively. Let's say that the number of nodes is built as follows:\n\nLet's consider that the snowflake is built with m layers. The initial node is layer 0. Then layer 1 has k nodes. Layer 2 has k * k nodes. Layer 3 has k * k^2 nodes, etc. So the total number of nodes is sum_{i=0}^d (k^i) where d is the depth. But wait, for the initial step, the first expansion is layer 1. Then, the step of adding to leaves is done once. So the minimal case is when d=",
    "response": "\n\nTo solve this problem, we need to determine if a given number of vertices `n` can form a snowflake graph as defined by the rules. The snowflake graph starts with one vertex and expands by adding layers of vertices where each vertex in a layer connects to `k` new vertices in the next layer, with `k > 1`.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph starts with one vertex. Each subsequent layer adds `k` times the number of vertices from the previous layer. The total number of vertices after `d` layers (including the initial vertex) is given by the geometric series sum: `1 + k + k^2 + ... + k^d`.\n\n2. **Geometric Series Check**: For a given `n`, we need to check if there exists an integer `k > 1` and an integer `d ≥ 1` such that the sum of the geometric series equals `n`. This translates to checking if `n - 1` can be expressed as a geometric series sum starting from `k` with `d` terms.\n\n3. **Efficient Check**: For each test case, iterate over possible values of `d` (starting from 1 up to a reasonable limit, since `k` must be greater than 1 and `k^d` grows exponentially). For each `d`, compute the corresponding `k` using binary search or direct computation and check if it results in an integer.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    max_d = 60  # since 2^60 is larger than 1e18\n    for d in range(1, max_d + 1):\n        # We want to find if there exists k > 1 such that sum_{i=0}^d k^i = n\n        # sum = (k^(d+1) - 1) / (k - 1) = n\n        # So, (k^(d+1) - 1) = n * (k - 1)\n        # But solving directly is hard, so we try to find k such that sum_{i=0}^d k^i = n\n        # Let's consider that sum_{i=0}^d k^i = n\n        # Which is 1 + k + k^2 + ... + k^d = n\n        # So, the sum is (k^(d+1) - 1) / (k - 1) = n\n        # Let's rearrange this equation to find possible k.\n        # However, for large n, we can try binary search for k for each d.\n        # Since k must be at least 2, and for fixed d, the sum increases with k.\n        # So for each d, we can binary search for k such that the sum equals n.\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while True:\n            val = (high ** (d + 1) - 1) // (high - 1)\n            if val >= n:\n                break\n            high *= 2\n        # Now binary search between low and high\n        left = 2\n        right = high\n        while left <= right:\n            mid = (left + right) // 2\n            # Compute sum = (mid^(d+1) - 1) // (mid - 1)\n            # To avoid overflow, compute it step by step\n            total = 0\n            for i in range(d + 1):\n                total += mid ** i\n                if total > n:\n                    break\n            if total == n:\n                return True\n            elif total < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **is_snowflake Function**: This function checks if a number `n` can be represented as a geometric series sum starting from 1 with some base `k > 1` and depth `d ≥ 1`.\n- **Binary Search for k**: For each possible depth `d`, we use binary search to find a suitable `k` such that the sum of the geometric series equals `n`.\n- **Efficiency**: The approach efficiently limits the depth `d` up to 60 (since `2^60` exceeds `10^18`), ensuring the solution handles very large values of `n` within feasible time complexity.\n\nThis method ensures that we check all possible configurations of the snowflake graph efficiently and correctly.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    max_d = 60  # since 2^60 is larger than 1e18\n    for d in range(1, max_d + 1):\n        # We want to find if there exists k > 1 such that sum_{i=0}^d k^i = n\n        # sum = (k^(d+1) - 1) / (k - 1) = n\n        # So, (k^(d+1) - 1) = n * (k - 1)\n        # But solving directly is hard, so we try to find k such that sum_{i=0}^d k^i = n\n        # Let's consider that sum_{i=0}^d k^i = n\n        # Which is 1 + k + k^2 + ... + k^d = n\n        # So, the sum is (k^(d+1) - 1) / (k - 1) = n\n        # Let's rearrange this equation to find possible k.\n        # However, for large n, we can try binary search for k for each d.\n        # Since k must be at least 2, and for fixed d, the sum increases with k.\n        # So for each d, we can binary search for k such that the sum equals n.\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while True:\n            val = (high ** (d + 1) - 1) // (high - 1)\n            if val >= n:\n                break\n            high *= 2\n        # Now binary search between low and high\n        left = 2\n        right = high\n        while left <= right:\n            mid = (left + right) // 2\n            # Compute sum = (mid^(d+1) - 1) // (mid - 1)\n            # To avoid overflow, compute it step by step\n            total = 0\n            for i in range(d + 1):\n                total += mid ** i\n                if total > n:\n                    break\n            if total == n:\n                return True\n            elif total < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 1061,
        "thoughts_token_count": 1023
    }
}