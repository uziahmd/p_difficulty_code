{
    "start": 1758309343.4410613,
    "end": 1758309578.191708,
    "start-formatted": "2025-09-20 04:15 KST",
    "end-formatted": "2025-09-20 04:19 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the minimum number of edges to add to a graph to form an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I need to understand what's required here. The problem says that the cycle must be simple (no repeated vertices), have an odd length, and consist of more than one vertex. Also, the graph is undirected, no loops or parallel edges.\n\nSo, the key here is that the graph must have at least one odd-length cycle. But wait, the question is about adding edges to create such a cycle. Wait, but if the original graph already has an odd-length cycle, then t would be 0, and w would be 1? Or maybe not. Wait, the problem says that we need to find the minimal t. So if the graph already has such a cycle, then t is zero, and w is the number of ways to add zero edges (i.e., 1 way?), but maybe there are multiple existing cycles. But according to the problem statement, the output for the second example is '0 1'. Let me check that example.\n\nIn the second input example, it's a triangle (3 nodes connected in a cycle). So it's already an odd-length cycle. So the answer is t=0, w=1. Which matches the output. So that makes sense.\n\nSo the first thing to check is whether the graph already contains an odd-length cycle. If yes, then t is 0, and w is 1. But wait, how can there be multiple ways? Because adding zero edges is only one way. So in that case, the answer is t=0 and w=1.\n\nBut if the graph doesn't have any odd-length cycles, then we need to find the minimal number of edges to add. Let's think about that.\n\nNow, the problem is related to bipartite graphs. Because a graph is bipartite if and only if it contains no odd-length cycles. So if the graph is bipartite, then adding edges to make an odd cycle would require some steps.\n\nSo the approach could be:\n\nFirst, check if the graph already has an odd-length cycle. If yes, then t=0 and w=1.\n\nIf not, then the graph is bipartite (or consists of bipartite components). Then, to create an odd-length cycle, we need to add edges in such a way that we create an odd-length cycle.\n\nBut how?\n\nLet's think about the components. Each connected component is bipartite. So, for each connected component, we can perform a bipartition into two sets, say A and B. For each component, if we add an edge between two nodes in the same set (A or B), then that creates an odd-length cycle. Because in a bipartite graph, any cycle is even-length. Adding an edge between two nodes in the same partition would create a cycle of length (original path length) + 1. Since the original path between them is even (since they are in the same partition), adding the edge would make the cycle length odd.\n\nSo, for each component, the minimal number of edges to add to create an odd cycle is 1. But how?\n\nWait, but if the component is a single node, then it's trivially bipartite. But adding any edge would create a loop, which is not allowed. But since the graph has no loops, but in this case, the component has only one node. However, the problem states that the cycle must consist of more than one vertex. So, for a component with a single node, you can't form a cycle. So in that case, you need to connect it to another component. Wait, but how?\n\nWait, let's think about the minimal t. For the graph to have an odd-length cycle, we need to find the minimal t. So for each connected component, if it's bipartite, then adding one edge within the same partition would create an odd cycle. But if the component is a tree (which is bipartite), then adding any edge between two nodes in the same partition would create a cycle of odd length.\n\nBut if the component is a single node, then adding any edge would require connecting it to another node. But that would form a single edge, which isn't a cycle. So, to form a cycle, you need at least two edges. So, for example, if there's a component with one node, and another component with two nodes. Then, adding edges between the single node and the two nodes would form a cycle of length 3? No. Wait, the two nodes are connected by an edge. Then adding edges from the single node to both would create a cycle of length 3 (the single node connected to both ends of the original edge). That's a triangle. Which is an odd-length cycle.\n\nSo, for components that are single nodes, how to handle them?\n\nLet me think: The minimal t depends on the structure of the graph. If the graph is bipartite, then the minimal t is the minimal number of edges needed to create an odd-length cycle.\n\nBut how to compute that?\n\nLet me think again. For each connected component, if it's bipartite, then adding an edge between two nodes in the same partition will create an odd-length cycle. So, for each component, the number of possible ways to add such an edge is equal to the number of pairs of nodes in the same partition. But since the graph is bipartitioned into two sets A and B, the number of such pairs is C(|A|, 2) + C(|B|, 2). However, if the component is a single node, then |A| is 1 and |B| is 0. So C(1,2) is zero, and C(0,2) is zero. So that component contributes zero possible edges. But for such a component, you need to connect it with other components.\n\nWait, but if there are multiple components, like two components that are single nodes. Then, adding an edge between them would create a component with two nodes and one edge. Which is not a cycle. So, to create a cycle, you need to add edges in such a way that you form a cycle. For example, if there are three components that are single nodes. Then, adding edges between them in a triangle (three edges) would create a cycle of length 3. But that requires adding 3 edges, which is more than the t for other cases.\n\nBut perhaps the minimal t is 1 when there exists at least one component with at least two nodes, and that component is bipartite. Because adding one edge in that component's same partition would create an odd cycle. However, if all components are single nodes, then you need to add 3 edges (to form a triangle), but that's possible only if n ≥ 3.\n\nSo, the problem breaks down into two cases:\n\nCase 1: The graph already has an odd-length cycle. Then t=0, w=1.\n\nCase 2: The graph is bipartite (so no odd-length cycles). Then, we need to find the minimal t and the number of ways.\n\nSo, how to determine whether the graph has an odd-length cycle? We can check if the graph is bipartite. If any component is not bipartite, then the graph has an odd cycle.\n\nSo the first step is to check if the graph is bipartite. If it is not, then output t=0 and w=1.\n\nBut if the graph is bipartite, then we need to compute the minimal t and w.\n\nNow, for the bipartite case:\n\nWe need to find the minimal number of edges to add to create an odd cycle. The minimal t is 1 if there exists at least one component with at least two nodes. Because adding one edge between two nodes in the same partition of that component would create an odd cycle.\n\nBut if all components are single nodes, then we need to add 3 edges (to form a triangle). But in that case, n must be at least 3. For example, if n is 3 and m is 0, then the answer is t=3 and w=1 (only one way to connect all three nodes in a triangle).\n\nWait, but the problem says that the cycle must consist of more than one vertex. So, for the case where all components are single nodes, the minimal t would be 3 if there are at least three nodes. But if there are two single nodes, then you can't form a cycle with just two nodes. So for two components, each with one node, the minimal t is 3 (adding three edges to form a triangle, but that requires three nodes. So if n is 2, then it's impossible. But the input constraints say n ≥ 1, but the problem requires the cycle to have more than one vertex. So for example, if n is 2 and m is 0, then the answer would be t=3 (but that's impossible because there's only two nodes. Wait, no. To form a cycle, you need at least three nodes. So in this case, the minimal t is 3 edges (but that would require adding three edges between two nodes, which is not allowed as it would create loops and parallel edges. So this seems impossible. Wait, but the input is such that the graph has no loops or parallel edges. So in this case, for n=2, m=0, how can we form a cycle? It's impossible. But the problem says that the input is valid. But according to the third sample input, for 3 0, the output is 3 1. Which makes sense: adding three edges to form a triangle. So for n=3, m=0, adding three edges (each pair) forms a triangle. So the answer is t=3, w=1.\n\nSo, for the bipartite case, the minimal t depends on the components:\n\nIf there is at least one component with size ≥ 2, then t is 1. Otherwise, if all components are single nodes (so n ≥ 3), then t is 3.\n\nBut how to compute this?\n\nSo, for the bipartite case, the minimal t is:\n\n- If there's at least one component with size ≥ 2: t = 1.\n\n- Else (all components are single nodes, i.e., n ≥ 1, but m=0, and n ≥ 3?), then t = 3.\n\nBut what if n is 1? Then, you can't form a cycle. But according to the problem statement, the input is valid. However, the problem says that the graph may not be connected. But in the case where n=1, m=0, then there's no way to form a cycle. But the problem says that the output must be the answer. But according to the problem statement, the input is given, and the output must be computed. However, the problem says that the graph is allowed to be disconnected. So for n=1, the answer would be t=3? But that's impossible. Wait, but the problem says that the cycle must have more than one vertex. So for n=1, it's impossible. However, the problem's third sample input is 3 0, which outputs 3 1. So in that case, the answer is possible.\n\nSo, for the case where all components are single nodes (so n ≥ 1), then:\n\nIf n < 3, then it's impossible to form a cycle. But according to the problem statement, the input is given, and the code must output something. However, according to the problem statement, the input is valid. Wait, but the problem says that the graph may not be connected. But in the case where n is 1, the answer is impossible. But the problem says that the answer must exist. How?\n\nWait, the problem says that the graph is given, and you have to add edges to form a cycle. So for the input where n=1 and m=0, the answer would be impossible. But the problem's sample input includes the third case as 3 0, which outputs 3 1. So for the case where n=1, perhaps the code needs to handle it. But according to the problem statement, the input is valid. However, the problem says that the graph may not be connected. So for n=1, the code must output something. However, the problem says that the cycle must have more than one vertex. So for n=1, the answer is impossible. But how?\n\nBut the problem says that the input can be such that n is 1. But according to the problem's note, the output must be the minimal number of edges to add. But if it's impossible, then what? Wait, no. Because in this case, the code must add edges to form a cycle. For example, for n=1, you can't form a cycle. But the problem says that the answer must be computed. But the problem says that the graph is given, and you need to add edges. So perhaps, in this case, the answer is t=3 and w=1 if n >=3. But for n=1, it's impossible. However, the problem's third example is for n=3, m=0. So the code must handle that.\n\nBut how to handle the case when all components are single nodes. Let's think:\n\nIf the number of components is k, and each component is a single node. Then, to form a cycle, you need to connect them in such a way that there is a cycle. For example, if there are three components, you can connect them in a triangle. That requires adding three edges. But if there are four components, you need to add edges to form a cycle. For example, select three of them and connect them in a triangle (three edges). So in this case, the minimal t is 3. But if there are two components (each single node), then you can't form a cycle. So, in that case, the minimal t is 3 only if there are at least three components. Otherwise, it's impossible.\n\nWait, but the problem says that the graph can be modified by adding edges. So, for example, if the graph has two components (each with one node), then adding three edges would require creating a cycle. But how? You need three edges to connect the two nodes, but that's impossible. Because adding edges between them would create multiple edges, which is not allowed. So, in this case, it's impossible. So, how can the code handle such cases?\n\nBut the problem says that the input is valid. So, perhaps the code can assume that it is possible to form a cycle. But how?\n\nLet me re-examine the problem statement. The problem says that the graph may not be connected, but the output must be the answer. So for example, if the graph has n=2 and m=0, then the answer would be t=3 and w=0? No, but that's impossible. However, the problem requires that the output is printed regardless.\n\nBut according to the problem's sample input, the third case is 3 0, which outputs 3 1. So for n=3, m=0, the minimal t is 3. Which is correct.\n\nSo, the code needs to handle the following scenarios:\n\nCase when the graph is bipartite (no odd cycles):\n\n- Check if there exists at least one component with size ≥ 2. If yes, then t is 1, and the number of ways is the sum over all components of (C(a_i, 2) + C(b_i, 2)), where a_i and b_i are the sizes of the two partitions of the component. However, this is only if the component is bipartite. Wait, but for each component, the number of ways to add an edge that creates an odd cycle is the number of possible edges between same partitions. But since the graph is already bipartite, adding any such edge would create an odd cycle.\n\nBut the problem says that the added edges must not create loops or parallel edges. So, the number of ways for each component is the number of pairs of nodes in the same partition, minus the existing edges. Wait, no. Because the existing edges are between different partitions. So for a bipartition (A, B), all existing edges are between A and B. So, the number of possible edges that can be added between nodes in the same partition is (C(|A|, 2) + C(|B|, 2)) minus the existing edges that are already present. Wait, no. Because the existing edges are already between A and B. So the possible edges between same partitions are those that are not already present.\n\nWait, but the graph may already have some edges between same partitions? No, because if the graph is bipartite, then any edge between same partitions would create an odd-length cycle. But the graph is bipartite, so it cannot have such edges. Therefore, in the bipartition (A, B), all existing edges are between A and B. So the number of possible edges that can be added between same partitions is (C(|A|, 2) + C(|B|, 2)) - existing edges in same partitions. But since the graph is bipartite, there are no existing edges between same partitions. So the number of possible edges is (C(|A|, 2) + C(|B|, 2)).\n\nBut in this case, adding any of these edges would create an odd-length cycle. However, if there are multiple components, then adding an edge in any component would create an odd cycle. So the minimal t is 1, and the number of ways is the total number of such possible edges across all components.\n\nWait, but the problem says that the minimal t is 1. So the number of ways is the total number of possible edges that can be added to any component to create an odd cycle. But since adding any of those edges would suffice, the total number of ways is the sum of (C(a_i, 2) + C(b_i, 2)) for each component i.\n\nBut wait, what if there are multiple components that can contribute to this. For example, if there are two components, each with a_i and b_i sizes. Then, adding an edge in either component would create an odd cycle. So the total number of ways is the sum of all possible edges in all components.\n\nBut the problem says that the answer is the number of ways to add t edges (t being minimal) to form a cycle. So for t=1, the number of ways is the number of possible edges that can be added in any component to create an odd cycle.\n\nBut for example, if there are two components, each contributing x and y ways, then the total number of ways is x + y.\n\nYes. Because each way is adding exactly one edge in any of the components.\n\nSo, in the case where the graph is bipartite and has at least one component with size ≥ 2, then t is 1, and w is the sum over all components of (C(a_i, 2) + C(b_i, 2)).\n\nBut what if there are multiple components, but none of them have size ≥ 2? Like, for example, all components are single nodes. Then, the minimal t is 3 (as discussed), but only if there are at least three components (so n ≥ 3). Otherwise, it's impossible. But how to handle that.\n\nSo, putting it all together:\n\nFirst, check if the graph has an odd-length cycle. If yes, output t=0, w=1.\n\nElse, the graph is bipartite. Then:\n\nCheck if there is at least one component with size ≥ 2.\n\nIf yes:\n\nt = 1.\n\nw = sum over all components (C(a_i, 2) + C(b_i, 2)).\n\nElse:\n\nAll components are single nodes. So, the number of components is n (each component has one node). So, if n < 3, then it's impossible. But the problem requires that the answer exists. But according to the problem's third example, when n=3 and m=0, the answer is t=3, w=1.\n\nSo, for this case, if n >= 3, then t is 3, and the number of ways is 1 (since you have to connect all three nodes in a triangle, but there's only one way to choose the three nodes and add all three edges). Wait, but the problem says that the number of ways is the number of ways to add t edges. So, in the case of n=3, m=0, the only way to add 3 edges is to connect all three pairs. So the number of ways is 1.\n\nBut if there are more than three nodes, say n=4, and all components are single nodes. Then, to create an odd-length cycle, you can choose any three nodes and connect them in a triangle. How many ways are there?\n\nThe number of ways would be C(n, 3) * 1. Because for each group of three nodes, there's exactly one way to add three edges to form a triangle. But since the graph is bipartitioned into single-node components, which are trivially bipartite, and adding any three edges between three nodes would form a cycle. However, in this scenario, the code would have to calculate that.\n\nBut how does this fit into the problem's requirements? Because for the case where all components are single nodes, the minimal t is 3, and the number of ways is the number of possible triplets of nodes. Because each triplet can be connected to form a triangle (adding three edges). So the number of ways is C(n, 3).\n\nBut in the third sample input, n=3, m=0. So C(3,3)=1. Which matches the sample output of 3 1.\n\nSo, for the case where all components are single nodes:\n\nif n < 3 → impossible. But according to the problem statement, the input is valid. However, the problem may not have such test cases. For example, if n=1, then there's no way to form a cycle. But the code must output something. However, according to the problem's sample input, for n=3, m=0, the output is 3 1.\n\nBut how to handle that in code?\n\nSo, the code needs to:\n\n- Check if the graph is bipartite.\n\nIf it is not bipartite → output t=0, w=1.\n\nElse:\n\nCheck if there's any component with size ≥ 2.\n\nIf yes:\n\nt = 1.\n\nw = sum over all components of (a_i choose 2 + b_i choose 2).\n\nElse:\n\nif n < 3 → impossible. But according to the problem's input, perhaps this case is not present. However, the problem says that the input is valid, but the code must handle it. However, the problem says that the graph must be able to form a cycle. But for n=1, it's impossible. However, the problem's third sample input has n=3, which is possible.\n\nSo, for the else case (all components are single nodes):\n\nif n < 3 → output t=...? Well, the problem says that the answer must exist. But perhaps the input is such that n ≥ 3. But the code must handle it. However, according to the problem's third sample, when n=3 and m=0, the answer is 3 1.\n\nSo, in code:\n\nif all components are single nodes:\n\n   if n < 3:\n\n       then, it's impossible to form a cycle. But the problem requires that the code outputs something. However, the problem's input may not include such cases. But how to proceed?\n\nBut according to the problem statement, the graph may not be connected. So, for example, if n=2 and m=0, the code must output t=3 and w=... but it's impossible. However, the code can't output anything. So perhaps, the problem's input ensures that n ≥ 3 when all components are single nodes. But how?\n\nWell, perhaps the code should assume that in such cases, the answer is t=3 and w= C(n,3) if n ≥3, else impossible. But how to handle that.\n\nBut according to the problem's sample input, the third case is n=3, m=0, which outputs t=3, w=1. So, the code should compute that.\n\nSo, putting it all together:\n\nSo, the plan is:\n\n1. Check if the graph has an odd-length cycle. If yes, output t=0, w=1.\n\nElse:\n\n2. For each connected component, check if it's bipartite. Since the entire graph is bipartite, all components are bipartite.\n\n3. For each component, compute the size of each partition (a_i, b_i).\n\n4. Check if there exists at least one component with size ≥ 2. If yes:\n\n   t = 1.\n\n   w is the sum over all components of (a_i choose 2 + b_i choose 2).\n\nElse:\n\n   All components are single nodes. So, n must be ≥ 3 (since otherwise, it's impossible to form a cycle). But the problem may not have such inputs.\n\n   So, if n < 3 → output t=... but how?\n\nBut according to the problem statement, the input is valid. So perhaps the input will always allow forming a cycle. So for the code, assuming that n ≥ 3 in this case.\n\nThus, in this case:\n\nt = 3.\n\nw = C(n, 3).\n\nBut why? Because for each triplet of nodes, you can add three edges to form a triangle. So the number of ways is the number of triplets.\n\nBut wait, in the third sample input, n=3, m=0. So the number of triplets is 1. So the output is 3 1. Which matches the sample.\n\nSo, in code, for the case where all components are single nodes, the code can proceed as follows:\n\nif n < 3:\n\n    impossible. But how? Well, the problem says that the input is valid. But perhaps the code can assume that n ≥ 3.\n\nBut perhaps the code can proceed as:\n\nif n < 3:\n\n    then, the answer is t = ... ?\n\nBut according to the problem's note, the answer must exist. So perhaps, for n=1, the answer is t=3, but that's impossible. However, the problem may not have such test cases.\n\nBut given that the problem's third sample is for n=3, m=0, perhaps the code can proceed under the assumption that in this case, n ≥3.\n\nThus, the code can proceed with:\n\nif all components are single nodes:\n\n   t = 3\n\n   w = C(n, 3)\n\nBut how to compute that.\n\nSo, the code steps:\n\nImplement BFS or DFS to check if the graph is bipartite. For each component, check if it's bipartite and record the size of the two partitions.\n\nSo, the code can:\n\nFor each connected component, perform BFS and assign colors. If during BFS, a conflict is found (i.e., a node is found that is already colored with the opposite color), then the graph is not bipartite. So, the code can check for this.\n\nOnce we know that the graph is bipartite, then proceed to check the components.\n\nSo, the code outline:\n\nRead n and m.\n\nBuild adjacency list.\n\nCheck if the graph is bipartite.\n\nIf not bipartite → output 0 1.\n\nElse:\n\nCheck if any component has size ≥ 2.\n\nIf yes:\n\n   compute the sum over all components of (a_i choose 2 + b_i choose 2) → this is w.\n\n   output t=1 and w.\n\nElse:\n\n   if n >=3:\n\n      t=3\n\n      w = combination(n,3)\n\n   else:\n\n      ??? (But perhaps the problem's input ensures that this case is not present.)\n\nBut how to handle the case when all components are single nodes and n < 3.\n\nBut according to the problem's sample input, for n=3, m=0, the answer is 3 1.\n\nSo, for the code, perhaps the code can proceed with:\n\nif n >=3:\n\n   t=3, w= n*(n-1)*(n-2)//6\n\nelse:\n\n   t= ... but this is impossible. However, the problem may not have such test cases.\n\nBut how to handle it? For example, n=2, m=0. Then, the code would output t=3, w= C(2,3)=0. But that's impossible. But since C(2,3) is zero, then the code would output 3 0. But that's not correct. However, the problem may not have such test cases.\n\nBut the problem's input constraints state that n and m are given, but there's no restriction on n. So the code must handle all possible cases.\n\nBut in the case where n=2 and m=0, the code would output t=3, w=0. However, in reality, it's impossible to form a cycle. But according to the problem's requirements, the code must output something.\n\nBut according to the problem statement, the code must output t and w. So for such cases, perhaps the code can output t=3 and w=0. But how?\n\nAlternatively, perhaps the code can consider that for the case when all components are single nodes, the minimal t is 3 if n ≥3, and otherwise impossible. But the code can't know that. So perhaps, for the code, the answer is t=3 and w= C(n,3) if n ≥3, else t=3 and w=0. But for n=2, that would give w=0, which is correct because there's no way to form a cycle.\n\nBut how to handle that in code.\n\nBut the problem's third sample is n=3, m=0, which gives w=1. Which is correct.\n\nSo, the code can proceed as follows:\n\nIn the case where all components are single nodes:\n\nt = 3 if n >=3 else impossible (but code can't handle that, so perhaps output t=3 and w=0 if n <3).\n\nBut how to compute that.\n\nBut in code, for the case where all components are single nodes:\n\nif n < 3:\n\n   t = 3\n\n   w = 0\n\nelse:\n\n   t = 3\n\n   w = n * (n-1) * (n-2) // 6\n\nBut then for n=2, the code outputs t=3 and w=0, which is correct.\n\nBut in that case, the answer is t=3 and w=0. However, the problem requires that the added edges form a cycle. But adding three edges to a graph with two nodes would require adding three edges between them, which is not allowed (parallel edges). Thus, in this case, there are zero ways. Hence, the code outputs w=0. Which is correct.\n\nSo, in code, that's acceptable.\n\nSo, putting it all together.\n\nNow, the code steps:\n\nImplement BFS/DFS to check bipartition and collect component sizes.\n\nBut how to check if the graph is bipartite.\n\nImplement a function that for each component, checks if it is bipartite, and returns whether the entire graph is bipartite.\n\nAlso, during the process, for each component, track the size of the two partitions (a_i and b_i).\n\nSo, for each component, after checking bipartition, we can store a list of (a_i, b_i) for each component.\n\nOnce the graph is determined to be bipartite, then:\n\nCheck if any component has a_i + b_i >=2. Because a_i + b_i is the size of the component. So for a component with size ≥2.\n\nIf yes:\n\nsum_w = sum( (a_i * (a_i -1) // 2) + (b_i * (b_i -1) // 2) for all components )\n\noutput t=1, w=sum_w.\n\nElse:\n\nif n >=3:\n\n   w = n * (n-1) * (n-2) // 6\n\n   output t=3, w.\n\nelse:\n\n   output t=3, w=0.\n\nBut how to check if any component has size ≥2.\n\nIn code, for each component, during the BFS, we can track the size of the component (a_i + b_i). So, for example, during the BFS, after processing the component, we can check if the component size is ≥2.\n\nSo, during the BFS, for each component, we can collect the sizes of the partitions and the component size.\n\nSo, code steps:\n\nInitialize color array (for bipartition check). Initially, all -1.\n\nFor each node not visited:\n\n   perform BFS.\n\n   assign colors 0 and 1.\n\n   during BFS, check if any conflict occurs (i.e., neighbor has same color).\n\n   if conflict, then the graph is not bipartite.\n\n   else, record the component's a_i and b_i (count of color 0 and color 1).\n\n   also, track if any component has size ≥2.\n\nOnce all components are processed:\n\nif the graph is not bipartite → output 0 1.\n\nelse:\n\n   if any component has size ≥2:\n\n      compute sum_w as sum of (a_i choose 2 + b_i choose 2) for all components.\n\n      output 1 sum_w.\n\n   else:\n\n      if n >=3:\n\n         w = n * (n-1) * (n-2) // 6\n\n         output 3 w.\n\n      else:\n\n         output 3 0.\n\nBut wait, for the case when all components are single nodes, and n=3, the code would compute w=1, which is correct.\n\nNow, let's test this logic against the sample inputs.\n\nSample Input 1:\n\n4 4\n\nEdges: 1-2, 1-3, 4-2, 4-3.\n\nLet's see if the graph is bipartite.\n\nLet's try to color the graph.\n\nComponent 1: nodes 1,2,3,4.\n\nLet's start with node 1: color 0.\n\nNeighbors of 1: 2,3. Assign color 1.\n\nThen, node 2's neighbors: 1 (color 0), 4. Assign 4 color 0.\n\nNode 4's neighbors: 2 (color 1), 3. Assign 3 color 0.\n\nBut node 3 is connected to 1 (color 0) and 4 (color 0). So node 3's color is 0, which is same as 1's color (0). But 1 and 3 are connected? Yes, the edge 1-3 exists. So in this case, node 1 is color 0, node 3 is color 0. They are connected, which is a conflict. So the graph is not bipartite. Therefore, the output is 0 1. But according to the first sample input, the output is '1 2'.\n\nWait, this contradicts. Wait, the first sample input is:\n\nInput is:\n\n4 4\n\nEdges:\n\n1-2, 1-3, 4-2, 4-3.\n\nSo the graph is:\n\nNodes 1 connected to 2 and 3.\n\nNodes 2 connected to 1 and 4.\n\nNodes 3 connected to 1 and 4.\n\nNodes 4 connected to 2 and 3.\n\nSo the graph has a cycle: 1-2-4-3-1. This is a cycle of length 4 (even). But there's another cycle: 1-2-4-3-1 (same as before). Are there any odd-length cycles?\n\nWait, what about 1-2-4-3-1? Length 4. Even.\n\nAnother cycle: 1-3-4-2-1. Also length 4.\n\nWhat about 1-2-3-1? That's a cycle of length 3. Because 1-2-3-1. But is there such a cycle? Let's see. There's an edge between 1-2, 1-3, and 2-3? No. There is no edge between 2 and 3. So that's not a cycle.\n\nSo the graph is bipartite? Let's try again.\n\nLet me try to color the graph.\n\nStart with node 1: color 0.\n\nNeighbors (2,3) are color 1.\n\nNode 2's neighbors: 1 (color 0), 4. Assign 4 color 0.\n\nNode 3's neighbors: 1 (color 0), 4. Assign 4 color 0. But node 4 is already color 0. So node 3's color is 1.\n\nWait, node 3 is connected to 4. So if node 3 is color 1, and node 4 is color 0, that's okay.\n\nNow, node 4's neighbors are 2 (color 1) and 3 (color 1). So node 4 is color 0, which is correct.\n\nSo the coloring is:\n\nnode 1: 0\n\nnode 2: 1\n\nnode 3: 1\n\nnode 4: 0.\n\nCheck all edges:\n\n1-2: 0 and 1 → ok.\n\n1-3: 0 and 1 → ok.\n\n2-4: 1 and 0 → ok.\n\n4-3: 0 and 1 → ok.\n\nSo the graph is bipartitioned. So why does the first sample input have output 1 2?\n\nWait, the first sample input is:\n\nInput is:\n\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', ... ]\n\nSo the first input is:\n\nn=4, m=4.\n\nEdges are 1-2, 1-3, 4-2, 4-3.\n\nBut according to the above analysis, the graph is bipartite. So why is the sample output for the first input '1 2'?\n\nBecause the sample output says that the first input's output is '1 2'.\n\nWait, this suggests that the graph is bipartite. So according to our code, the",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and also count the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges based on the structure of the graph's components.\n\n### Approach\n1. **Check for Odd-Length Cycle**: If the graph already contains an odd-length cycle, the answer is straightforward (0 edges needed, 1 way).\n2. **Bipartite Check**: If the graph is bipartite, we need to determine how to form an odd-length cycle by adding edges.\n3. **Component Analysis**: For each connected component, if it is bipartite, calculate the number of ways to add edges within the same partition to form an odd-length cycle.\n4. **Special Cases**: Handle cases where all components are single nodes separately, requiring adding edges to form a triangle (3 edges) if there are at least three nodes.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * n\n    is_bipartite = True\n    components = []\n    any_large_component = False\n\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            count0 = 1\n            count1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append((count0, count1))\n            if count0 + count1 >= 2:\n                any_large_component = True\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    if any_large_component:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into an adjacency list.\n2. **Bipartite Check**: Using BFS, each component is checked for bipartiteness. If any conflict is found during BFS, the graph is not bipartite.\n3. **Component Analysis**: For each bipartite component, the sizes of the two partitions are recorded. If any component has more than one node, it contributes to the number of ways to add edges to form an odd-length cycle.\n4. **Special Cases Handling**: If all components are single nodes, check if there are at least three nodes to form a triangle (3 edges) and compute the number of ways accordingly.\n\nThis approach efficiently determines the minimum edges needed and the number of ways to achieve the desired cycle, leveraging properties of bipartite graphs and combinatorial counting.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * n\n    is_bipartite = True\n    components = []\n    any_large_component = False\n\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            count0 = 1\n            count1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append((count0, count1))\n            if count0 + count1 >= 2:\n                any_large_component = True\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    if any_large_component:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 852,
        "thoughts_token_count": 8192
    }
}