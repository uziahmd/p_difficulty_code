{
    "start": 1758309281.3152368,
    "end": 1758309517.872186,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about determining if there's a perfect matching between R spaceships and B bases such that no two connecting lines intersect. And since R and B are up to 10, maybe we can check all possible matchings?\n\nFirst, the constraints: each base must be assigned exactly one spaceship, and vice versa. So, for the case where R != B, it's impossible. Wait, the first thing to check is if R equals B. Because if they are not equal, then there's no perfect matching. Oh right, the problem says \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\". So R must equal B. So first, if R != B, output No immediately.\n\nSo the first step is to check if R and B are equal. If not, output No. Otherwise, proceed.\n\nNow, the main problem is when R = B. We need to check if there exists a perfect matching (a bijection between spaceships and bases) such that no two edges (lines between a spaceship and base) cross each other.\n\nHow to approach this? Well, for small R and B (since up to 10), we can generate all possible permutations of assignments and check each one for intersection.\n\nSo the steps would be:\n\n1. Check if R != B. If so, output No.\n2. Else, generate all possible permutations of assigning spaceships to bases. For each permutation, check if all the connecting lines are non-intersecting.\n3. If any permutation satisfies the condition, output Yes. Otherwise, No.\n\nBut how to check if two line segments intersect? Well, given that no three points are colinear, which is given in the problem statement. So, for any two line segments (from ship A to base X, and ship B to base Y), they can't have overlapping points, but they might cross each other.\n\nThe problem requires that no two paths (line segments) intersect. So for a given permutation (matching), we need to check that all pairs of line segments in the matching are non-intersecting.\n\nBut how to check if two line segments intersect?\n\nI remember that there's a computational geometry method to check if two line segments intersect. Let me recall.\n\nThe standard approach involves checking the orientation of points. For two line segments AB and CD, they intersect if:\n\n- The orientations of (A, B, C) and (A, B, D) are different, and the orientations of (C, D, A) and (C, D, B) are different. (Which means they cross each other)\nOR\n- One of the segments' endpoints lies on the other segment. However, the problem says that no three points are colinear. So this case can't happen. Because if a point lies on another segment, then the three points (the two endpoints of one segment and the point on the other) would be colinear. But the problem states that no three points are colinear. Therefore, this case is not possible. So, we can ignore that scenario.\n\nSo, for our problem, two line segments AB and CD will intersect if and only if the orientations of (A,B,C) and (A,B,D) are different, and the orientations of (C,D,A) and (C,D,B) are different.\n\nTherefore, the function to check if two line segments AB and CD intersect is based on checking the orientations.\n\nSo, first, I need to implement a function to compute the orientation of three points. The orientation can be:\n\n- 0 if colinear,\n- 1 if clockwise,\n- 2 if counterclockwise.\n\nBut since the problem states that no three points are colinear, we don't have to handle the 0 case here. So, the orientation function can return 1 or -1, or something like that. Let me think.\n\nThe orientation of three points p, q, r can be determined by the cross product of vectors (q-p) and (r-p). The cross product is (q.x - p.x)*(r.y - p.y) - (q.y - p.y)*(r.x - p.x). If this is positive, the turn is counterclockwise; if negative, clockwise; zero if colinear.\n\nSo, the function would be:\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # 1 for clockwise, 2 for counterclockwise?\n\nWait, actually, the sign tells us the direction. But for the purpose of checking if two segments AB and CD intersect, the standard approach is to check if the points C and D are",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting paths (line segments) intersect. The solution involves checking all possible permutations of assignments between spaceships and bases and verifying if any permutation meets the non-intersecting condition.\n\n### Approach\n1. **Check for Equal Numbers**: First, ensure the number of spaceships (R) is equal to the number of bases (B). If not, output \"No\" immediately.\n2. **Generate Permutations**: For the case where R equals B, generate all possible permutations of assigning spaceships to bases.\n3. **Check Intersections**: For each permutation, check if any pair of line segments (connecting a spaceship to its assigned base) intersect. This is done using a geometric method involving cross products to determine orientations of points.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # 1 for clockwise, 2 for counterclockwise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if (o1 != o2) and (o3 != o4):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    R, B = map(int, input[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, input[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, input[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Generate all permutations of bases assignments\n    from itertools import permutations\n    for perm in permutations(bases):\n        # Check all pairs of segments in this permutation\n        intersect = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Orientation Check**: The `orientation` function calculates the orientation of three points using the cross product to determine if they are clockwise, counterclockwise, or collinear.\n2. **Segment Intersection Check**: The `segments_intersect` function uses the orientation values to determine if two line segments intersect.\n3. **Main Logic**: The main function reads input, checks for equal numbers of spaceships and bases, generates permutations of possible assignments, and checks each permutation for intersecting segments. If a valid permutation is found, it prints \"Yes\"; otherwise, it prints \"No\".\n\nThis approach ensures that all possible assignments are checked efficiently given the constraints (R and B up to 10), leveraging permutations and geometric checks for correctness.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # 1 for clockwise, 2 for counterclockwise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if (o1 != o2) and (o3 != o4):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    R, B = map(int, input[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, input[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, input[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Generate all permutations of bases assignments\n    from itertools import permutations\n    for perm in permutations(bases):\n        # Check all pairs of segments in this permutation\n        intersect = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 784,
        "thoughts_token_count": 1024
    }
}