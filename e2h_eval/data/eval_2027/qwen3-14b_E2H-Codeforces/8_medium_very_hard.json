{
    "start": 1758346045.6344814,
    "end": 1758346231.2690642,
    "start-formatted": "2025-09-20 14:27 KST",
    "end-formatted": "2025-09-20 14:30 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem says that we have an undirected graph with given flows on each edge, and we need to assign directions to the edges such that the flow is a valid maximum flow. Also, the directed graph must not have cycles. Hmm.\n\nSo, the key points are:\n\n1. For each vertex except source (1) and sink (n), the sum of incoming flows equals the sum of outgoing flows. That's the flow conservation.\n2. The source (vertex 1) has no incoming edges.\n3. The directed graph must be acyclic.\n\nFirst, I need to think about how to model this. Since the flow is already given (the ci values), the problem is about directing the edges correctly.\n\nWait, but the flow is already a maximum flow. So the given ci's must form a valid flow. Our job is to assign directions to edges so that the flow conditions are satisfied and the graph is acyclic.\n\nBut how do we assign the directions?\n\nLet me think about the flow conservation. For each node v (not 1 or n), the sum of flows entering must equal the sum leaving. Which implies that for each node, the total flow through its edges must be even? No, because the sum of incoming and outgoing is same. Wait, for each edge, the flow is either incoming or outgoing. So for each node, the sum of all flows on edges connected to it must be even? Because for each edge, the flow contributes once to either in or out. So the sum of all flows for the node's edges would be equal to twice the outflow (since in equals out). Wait, no. For example, if a node has two edges: one incoming with c1 and one outgoing with c2. Then in equals out, so c1 = c2. So the total sum of flows for the node is c1 + c2 = 2c1. Which is even. So for any node except source and sink, the sum of all ci's on edges connected to it must be even. But the problem says that the input is such that a solution exists, so we don't need to check that.\n\nBut how does this help us? Well, perhaps we need to model this as a directed graph where the flow conservation holds. But how to assign directions.\n\nAnother thought: since the directed graph must be acyclic, we can arrange the nodes in a topological order. Then, the direction of edges can be determined based on this order. For example, if we have a topological order where all edges go from earlier nodes to later nodes, then there are no cycles.\n\nBut how to find such a topological order that also satisfies the flow conservation conditions?\n\nAlternatively, maybe we can model this as a directed acyclic graph (DAG) where the flow conservation holds. But how?\n\nWait, the flow conservation is similar to the condition in a flow network where the inflow equals outflow for intermediate nodes. So, the directed graph must form a valid flow.\n\nBut how to assign directions to the edges to satisfy this?\n\nAnother approach: think of the problem as building a DAG where the flow is valid. Since the flow is maximum, maybe we can model this as a DAG where the source is at the beginning, the sink at the end, and all edges go in the direction of the topological order.\n\nBut how to construct such a DAG.\n\nAlternatively, think of the problem as a directed graph where the edges are directed in a way that forms a DAG, and for each node (except source and sink), the sum of the flows on the incoming edges equals the sum on the outgoing edges.\n\nBut how to model that.\n\nLet me think about the flow conservation. For each node v (other than source and sink), the sum of flows on edges directed into v equals the sum of flows on edges directed out of v. Let me denote for each node v, the net flow (outflow - inflow) must be zero. But for the source, the net outflow is equal to the total flow (since it has no incoming edges). For the sink, the net inflow is equal to the total flow.\n\nBut how to model this. Maybe this is similar to finding an Eulerian trail, but not sure.\n\nWait, here's an idea: For each node except source and sink, the sum of flows on edges connected to it must be even. Which is already ensured by the problem's constraints. But how to split those into incoming and outgoing flows such that they are equal.\n\nFor example, suppose a node has edges with total sum S. Then, the inflow must be S/2, and the outflow must be S/2. So for each node, we need to choose directions of edges such that the sum of flows on edges directed into the node is S/2.\n\nBut how to compute this.\n\nThis seems like a problem of assigning directions to edges so that for each node, the sum of flows on edges directed towards it is equal to half of the sum of all flows connected to it. But how?\n\nThis is similar to building an Eulerian orientation. In an Eulerian orientation, each node has equal in-degree and out-degree. But here, it's about the sum of flows, not counts.\n\nWait, maybe we can model this as a directed graph where each node has a certain balance. For example, for each node v (other than source and sink), the sum of flows on edges directed into v must be equal to the sum of flows on edges directed out of v. Which implies that for each node, the sum of flows on edges connected to it must be even, which is already given.\n\nSo, the problem reduces to assigning directions to edges such that for each node, the sum of flows on incoming edges is equal to the sum of outgoing edges, and the resulting directed graph is acyclic.\n\nBut how to do that.\n\nAnother thought: the directed graph must be acyclic. So, we can arrange the nodes in a topological order. Then, for each edge, we can direct it from the node that comes earlier in the topological order to the one that comes later. However, this may not directly satisfy the flow conservation conditions. But perhaps if we can find a topological order such that the flow conservation conditions are met.\n\nAlternatively, maybe we can model this as a directed graph where we perform a DFS traversal, and assign directions based on the traversal. For example, when you visit a node, you direct the edges towards unvisited nodes. But again, how to ensure flow conservation.\n\nAlternatively, think of the problem as building a DAG where the edges are directed in a way that allows flow conservation. Since the flow is a maximum flow, perhaps we can model this as a DAG with the source and sink, and the edges directed in a way that allows the flow.\n\nBut I'm stuck. Let's look for hints from the sample input.\n\nSample Input 1:\n\n3 3\n\n3 2 10\n\n1 2 10\n\n3 1 5\n\nThe output is 1, 0, 1. Let's see:\n\nEdge 1: 3→2 becomes 2→3 (since output is 1). So direction is bi→ai.\n\nEdge 2: 1→2 remains as is (output 0).\n\nEdge 3: 3→1 becomes 1→3 (output 1).\n\nSo the directed edges are:\n\n2→3 (from first edge), 1→2, 1→3.\n\nThen, for node 2 (which is not source or sink), inflow is 10 (from 1→2) and outflow is 10 (to 3). So it's balanced.\n\nFor node 1 (source), no incoming edges. For node 3 (sink), inflow is 10 (from 2) and 5 (from 1), total 15. Which is the max flow.\n\nThe directed graph is 1→2, 1→3, 2→3. Which is a DAG with topological order 1, 2, 3.\n\nSo the idea is that the edges are directed in a way that follows a topological order. So maybe we can construct a topological order of the nodes, and then direct each edge from the node that appears earlier in the order to the one that appears later.\n\nBut how to construct such an order that also satisfies the flow conservation.\n\nWait, but the flow conservation is automatically satisfied if we assign directions in such a way that for each node, the sum of flows on edges going out of it is equal to the sum of flows on edges coming in. How can that happen?\n\nAlternatively, think of the problem as a directed graph where the flow is a valid flow. So, the flow conservation holds. But how to assign directions.\n\nAnother idea: since the flow is a valid maximum flow, the residual graph has no augmenting paths. But I'm not sure how that helps here.\n\nAlternatively, consider the problem as a directed graph where the edges are directed in such a way that the flow is valid. To ensure that the directed graph is acyclic, perhaps we can build a DAG where the edges are directed away from the source towards the sink, and arrange the nodes in a way that allows this.\n\nBut how to model this.\n\nLet me think about the flow conservation again. For each node v (not source or sink), the inflow equals the outflow. So, the net flow for the node is zero. For the source, the net outflow is the total flow, and for the sink, the net inflow is the same.\n\nIf we model this as a directed graph, then the net outflow for the source is the sum of all flows on edges leaving the source minus those entering. But since the source has no incoming edges, the net outflow is the sum of all flows on edges leaving it. Similarly for the sink.\n\nBut how to assign directions.\n\nLet me think about the problem as building a directed graph where each edge's direction is chosen such that the flow conservation holds. Then, to make it acyclic, perhaps we can arrange the nodes in a certain order and assign directions accordingly.\n\nWait, here's a possible approach:\n\nWe can model this as a directed graph, and then perform a topological sort. However, the problem is that the directions are not known yet. So perhaps we need to find a way to assign directions that allow for a topological order.\n\nAlternatively, think of the problem as building a DAG where the flow is valid. Since the flow is valid, the directed edges must form a DAG with the source and sink, and the flow conservation conditions.\n\nAnother thought: the problem requires that the directed graph has no cycles. Therefore, the graph must be a DAG. In a DAG, there exists a topological ordering of the nodes. So, if we can assign directions to edges such that they go from earlier nodes to later nodes in the topological order, then the graph is acyclic.\n\nBut how to find such a topological order that also satisfies the flow conservation conditions.\n\nWait, perhaps we can model this as a directed graph where the edges are directed according to some hierarchy. For example, the source is first, then other nodes, then the sink. But how to determine the directions of edges between nodes.\n\nAlternatively, think of the problem as a flow network. Since the flow is a maximum flow, perhaps we can use the residual graph to determine the direction of edges. However, since the original graph is undirected, the residual graph is not straightforward.\n\nAlternatively, think of the problem as building a directed graph where the direction of each edge is determined based on the flow. For example, if in the maximum flow, the flow is from u to v, then we direct the edge u→v. But how to find this flow.\n\nBut the problem states that the given ci's are the flow values. So the flow is already given, but we need to assign directions to the edges.\n\nWait, the problem says that the given ci's are the flow volume for each edge. So, for each undirected edge (ai, bi), the flow is ci. But the direction is unknown. However, the flow must be such that for each node, the inflow equals the outflow (except source and sink). So, for each edge, the flow is directed from one end to the other. So, the flow is a valid flow in the directed graph.\n\nSo, the problem is to assign directions to the edges such that the flow is valid and the directed graph is acyclic.\n\nNow, how to assign directions.\n\nLet me think of the flow as a directed graph. For each node, the sum of flows on edges directed into it is equal to the sum of flows on edges directed out of it, except for source and sink.\n\nSo, for each node v (not source or sink), the sum of flows on edges directed into v is equal to the sum of flows on edges directed out of v.\n\nThis suggests that for each node v, the total flow of edges connected to v is even. Which is given by the problem's constraints.\n\nSo, for each node, the sum of flows on edges connected to it is even. Let's call this value S_v. Then, the sum of flows directed into the node must be S_v / 2, and similarly for the outflow.\n\nSo, the problem reduces to assigning directions to edges such that for each node, the sum of flows on edges directed into it is exactly S_v / 2.\n\nNow, how can we model this? It looks like a problem where each edge contributes its flow to either the in-flow or out-flow of its endpoints.\n\nThis seems similar to an Eulerian circuit problem, but for flows instead of degrees.\n\nWait, perhaps we can model this as a directed graph where we need to assign directions to edges so that each node has a certain in-flow. This sounds like a problem of finding a directed graph that satisfies certain in-degree constraints. However, the in-degree here is not about the number of edges, but the sum of their flows.\n\nThis seems challenging. How can we model this?\n\nAlternative approach: Let's consider that each edge's direction is determined by the direction of the flow. For example, for each edge between u and v, if the flow is from u to v, then we direct the edge u→v. Otherwise, v→u.\n\nBut how to determine which direction to choose for each edge.\n\nLet me think of the entire graph as a flow network. The flow is already given. The problem is to assign directions to edges so that the flow is valid and the directed graph is acyclic.\n\nBut how to find such directions.\n\nAnother idea: Since the directed graph must be acyclic, we can arrange the nodes in a topological order. Let's assume that we have a topological order where the source is first, and the sink is last. Then, for each edge between u and v, if u comes before v in the topological order, we direct the edge from u to v. Otherwise, we direct it from v to u. But how to ensure that this assignment satisfies the flow conservation.\n\nBut how to choose the topological order such that the flow conservation is satisfied.\n\nAlternatively, think of the problem as a directed graph where the edges are directed in a way that forms a DAG. To ensure flow conservation, perhaps we can model this as a directed graph where for each node, the sum of flows on edges directed away from it is equal to the sum of flows directed into it (for non-source/sink nodes).\n\nBut how to find such a direction.\n\nLet me think of the following approach:\n\n- We can model this as a directed graph where we want to assign directions to edges such that the flow conservation holds, and then ensure that the graph is acyclic.\n\nBut how to find such directions.\n\nLet me think of the flow conservation as a system of equations. For each node v (not source or sink), the sum of flows on edges directed into v equals the sum of flows on edges directed out of v. Let's denote for each edge (u, v), we have a variable x_e which is 0 or 1, indicating whether the edge is directed from u to v (x_e=0) or from v to u (x_e=1). Then, for each node v, the sum over all edges incident to v of (x_e * c_e if the edge is directed into v, or (1 - x_e) * c_e if directed out of v) must be equal to the sum for the other direction.\n\nBut solving this system seems computationally expensive for large n and m.\n\nBut since the problem says that a solution exists, perhaps there's a way to construct this direction assignment.\n\nAnother idea: Since the directed graph must be acyclic, we can imagine that there is a way to assign directions to edges such that they form a DAG. For example, we can perform a DFS traversal and assign directions based on the order of discovery. However, I'm not sure how to ensure flow conservation.\n\nAlternatively, think of the problem as building a DAG where the edges are directed from the source towards the sink, and for each node, the inflow equals outflow.\n\nBut how to model this.\n\nWait, here's an idea inspired by the sample input. In the sample input, the directions were such that the edges formed a DAG with the source first, then other nodes, then the sink. For example, the source (1) had edges directed to other nodes, and those nodes had edges directed to the sink.\n\nSo, perhaps we can arrange the nodes in a certain order (like a topological order) and direct all edges from earlier nodes to later ones. But how to choose this order such that the flow conservation is satisfied.\n\nLet me think about this. Suppose we have a topological order of the nodes. Then, for each edge, it's directed from the node that comes earlier in the order to the one that comes later. Now, the question is: can we find such an order so that for each node v (not source or sink), the sum of flows on edges directed into it equals the sum of flows on edges directed out of it.\n\nLet me think of the flow conservation for such a node v. The sum of flows on edges directed into v is the sum of flows from nodes that come before v in the topological order. The sum of flows directed out of v is the sum of flows to nodes that come after v in the topological order. So, for the flow conservation, these two sums must be equal.\n\nBut how to find such an order.\n\nThis seems like a problem of finding an order where for each node v, the sum of flows from earlier nodes to v equals the sum of flows from v to later nodes.\n\nBut how to compute this.\n\nAlternatively, think of the problem as a directed graph where the edges are directed in the topological order. Then, the flow conservation for node v implies that the sum of flows on edges coming into v (from earlier nodes) equals the sum of flows on edges going out of v (to later nodes). So, for node v, the sum of flows on edges connected to it that are directed into v must equal the sum of flows on edges directed out of v. Which is the same as saying that the sum of flows on edges connected to v is even, and that the sum of flows on edges directed into v is exactly half of that.\n\nBut how to find this.\n\nPerhaps we can model this as a directed graph where each node's \"balance\" is zero. For example, the balance for a node v is the sum of flows on edges directed into v minus the sum of flows on edges directed out of v. For the flow conservation, this balance must be zero for nodes other than source and sink.\n\nBut how to assign directions to edges to achieve this.\n\nAnother idea: Let's model this as a directed graph where the edges are directed in a way that forms a DAG, and the flow conservation is satisfied. Since the graph is connected and has a solution, perhaps we can perform a BFS or DFS traversal and assign directions based on the traversal order.\n\nFor example, during BFS traversal, when we visit a node, we direct all edges from the current node to its neighbors that haven't been visited yet. This ensures that the graph is a DAG (since edges are directed from parent to children in the BFS tree). However, this approach might not account for the flow conservation.\n\nBut perhaps we can adjust the traversal order based on the flow values.\n\nAlternatively, think of the problem as building a directed graph where each node's in-flow is equal to its out-flow. This resembles the problem of finding an Eulerian path, but again, not sure.\n\nWait, here's a different approach inspired by the fact that the directed graph must be acyclic. In a DAG, there is at least one node with in-degree zero (the source of the DAG). But in our case, the source (node 1) has no incoming edges, so it's a candidate for being the in-degree zero node.\n\nMaybe we can construct a DAG by performing a greedy algorithm. For example, start with node 1. For each edge connected to node 1, direct it away from node 1. Then, process the next nodes in some order, ensuring that their flow conservation is maintained.\n\nBut how to handle this for all nodes.\n\nLet me think about the following steps:\n\n1. Compute for each node v (excluding source and sink) the required in-flow, which is S_v / 2, where S_v is the sum of flows on edges connected to v.\n\n2. For the source node, the required out-flow is the total flow (which is the sum of flows on edges connected to it, since it has no incoming edges).\n\n3. For the sink node, the required in-flow is the total flow.\n\nBut how to assign directions to edges to meet these requirements.\n\nThis feels like a problem of finding a directed graph that satisfies certain constraints on the in-flow of each node.\n\nBut how to model this. Perhaps we can model this as a directed graph and use some kind of flow-based approach.\n\nAlternatively, think of the problem as a directed graph where each edge's direction is chosen such that the flow conservation holds. Once the directions are chosen, we need to ensure that the graph is acyclic.\n\nBut how.\n\nWait, here's an idea inspired by the fact that the directed graph must be acyclic. If we can assign directions to the edges in such a way that they form a DAG, and the flow conservation holds, then the problem is solved.\n\nTo construct such a DAG, we can think of the graph as a directed acyclic graph with the source as the only node with no incoming edges. Then, for each node, the flow conservation is satisfied.\n\nLet me think of the following approach:\n\n- We can perform a topological sort of the nodes. Let's say the order is v_1, v_2, ..., v_n, where v_1 is the source (node 1), and v_n is the sink (node n).\n\n- For each edge between u and v, if u comes before v in the topological order, then we direct the edge from u to v. Otherwise, we direct it from v to u.\n\n- Then, we need to ensure that for each node (except source and sink), the sum of flows on edges directed into it equals the sum of flows on edges directed out of it.\n\nBut how to choose the topological order such that this condition is satisfied.\n\nThis seems challenging, but perhaps we can model this as a problem of finding a topological order that balances the inflow and outflow for each node.\n\nLet me think of the following: For each node v, the sum of flows on edges directed into it (in the topological order) must be equal to the sum of flows on edges directed out of it. Let's denote the sum of flows on edges connected to v as S_v. Then, the sum of flows directed into v is equal to the sum of flows directed out of v, which is S_v / 2.\n\nSo, for the topological order, the sum of flows on edges from earlier nodes to v must be equal to the sum of flows on edges from v to later nodes.\n\nThis seems like a problem of choosing an order where for each node v, the sum of flows on edges connecting it to earlier nodes is equal to the sum of flows on edges connecting it to later nodes.\n\nBut how to compute this.\n\nThis feels like a dynamic programming problem, but for large n and m, it's not feasible.\n\nAlternative idea: For each node v, the sum of flows on edges connected to it is S_v. Let's denote the required in-flow for v as S_v / 2. So, during the topological sort, we need to ensure that when we process node v, the sum of flows on edges from already processed nodes to v is equal to the required in-flow for v.\n\nBut how to achieve this.\n\nPerhaps we can process nodes in an order where, for each node, the required in-flow is satisfied by the edges that have already been directed.\n\nLet me think of this as a greedy algorithm. We start with the source node (node 1). The required in-flow for node 1 is zero (since it has no incoming edges). All edges connected to node 1 are directed away from it. For each such edge, the flow is added to the outflow of node 1.\n\nNext, we select a node that has already received enough inflow from previously processed nodes. For example, for a node v, if the sum of flows on edges directed into it (from already processed nodes) is equal to S_v / 2, then we can process it next. When processing it, we direct all its edges to unprocessed nodes, which will contribute to their inflow.\n\nBut how to find such nodes in the right order.\n\nThis sounds like a problem that can be modeled with a priority queue or some kind of selection based on the current inflow.\n\nLet me formalize this:\n\nFor each node v, maintain a variable called current_inflow, which is the sum of flows on edges that have been directed into v from already processed nodes.\n\nInitially, current_inflow for node 1 is zero. For all other nodes, it starts at zero.\n\nWe process nodes in an order such that when we process a node v, current_inflow[v] equals S_v / 2. Once processed, we direct all edges from v to unprocessed nodes, adding their flow to the current_inflow of those nodes.\n\nBut how to ensure that this is possible.\n\nLet's take the sample input:\n\nSample Input 1:\n\nNodes are 1, 2, 3.\n\nFor node 1:\n\nEdges are (1-2 with 10), (1-3 with 5). S_1 = 15. But since it's the source, its required in-flow is zero. So all edges are directed out of it. So current_inflow for node 1 is zero, and it is processed first.\n\nFor node 2: edges are (1-2 with 10), (2-3 with 10). S_2 = 20. Required in-flow is 10.\n\nWhen node 1 is processed, the edge between 1 and 2 is directed from 1 to 2. This adds 10 to current_inflow[2]. Now current_inflow[2] is 10, which equals S_2 / 2. So node 2 can be processed next.\n\nWhen processing node 2, we look at its unprocessed edges. The only unprocessed edge is between 2 and 3. We direct it from 2 to 3, adding 10 to current_inflow[3].\n\nNow, node 3 has edges (1-3 with 5) and (2-3 with 10). S_3 = 15. Required in-flow is 7.5? Wait, but the problem says that the input is such that a solution exists. Oh, but in the sample input, node 3 is the sink. So the required in-flow for node 3 is the total flow, which is 15. But in this case, the current_inflow for node 3 is 10 (from edge 2→3) plus 5 (from edge 1→3) = 15. Which is correct.\n\nSo, node 3 is processed after node 2.\n\nThus, the topological order is 1 → 2 → 3. And the edges are directed accordingly.\n\nThis seems to work. So the algorithm could be:\n\n- Compute for each node v (except source and sink) the required in-flow, which is S_v / 2.\n\n- For the source, required in-flow is zero.\n\n- For the sink, required in-flow is the total flow (but we don't need to check this since it's the sink).\n\n- Process nodes in an order where when a node is processed, its current_inflow is equal to the required in-flow.\n\n- When processing a node v, direct all edges from v to unprocessed nodes, adding their flow to the current_inflow of those nodes.\n\nThis way, the directed edges are from processed nodes to unprocessed nodes, ensuring that the graph is acyclic (since edges are directed from earlier processed nodes to later ones).\n\nBut how to implement this.\n\nThe key is to find the order of processing nodes such that when a node is processed, its current_inflow equals the required in-flow.\n\nTo implement this, we can use a priority queue or a queue that holds nodes whose current_inflow equals their required in-flow.\n\nLet's think of the steps:\n\n1. For each node v, calculate S_v = sum of flows on edges connected to v.\n\n   For the source (v=1), required_inflow is 0.\n\n   For the sink (v=n), required_inflow is S_n (but since it's the sink, we don't need to process it in the same way).\n\n   For other nodes, required_inflow is S_v / 2.\n\n2. Initialize a data structure (like a queue) with the source node. Initially, current_inflow for the source is 0, which matches its required_inflow.\n\n3. While the queue is not empty:\n\n   a. Dequeue a node u.\n\n   b. For each edge connected to u that hasn't been processed yet:\n\n      i. If the other end of the edge is not processed yet, direct the edge from u to that node (so the flow is added to the other node's current_inflow).\n\n      ii. Add the flow of this edge to the current_inflow of the other node.\n\n      iii. If the other node's current_inflow now equals its required_inflow, enqueue it.\n\n4. Once all nodes are processed, the edges are directed accordingly.\n\nBut wait, how to track which edges have been processed. Because each edge is processed once, when either of its endpoints is processed.\n\nBut in this approach, when processing a node u, we look at all edges connected to u that are not yet directed. For each such edge, if the other node v is not yet processed, we direct the edge from u to v. This way, the edge is directed once, and the other node v's current_inflow is updated.\n\nThis seems promising.\n\nLet's test this approach on the sample input.\n\nSample Input 1:\n\nNodes 1, 2, 3.\n\nEdges:\n\nEdge 1: 3-2 (ci=10)\n\nEdge 2: 1-2 (ci=10)\n\nEdge 3: 3-1 (ci=5)\n\nFor each node:\n\nS_1 = 10 (edge 2) + 5 (edge 3) = 15. Required inflow is 0 (source).\n\nS_2 = 10 (edge 2) + 10 (edge 1) = 20. Required inflow is 10.\n\nS_3 = 10 (edge 1) + 5 (edge 3) = 15. Required inflow is 15 (since it's the sink, but the algorithm doesn't care about it).\n\nProcessing starts with node 1 in the queue.\n\nDequeue node 1. Look at all edges connected to node 1. These are edge 2 (1-2) and edge 3 (1-3).\n\nFor edge 2 (connecting to node 2):\n\nNode 2 is not processed. So direct edge from 1 to 2. Add 10 to node 2's current_inflow (now 10). Check if this equals required_inflow (10) → yes. Enqueue node 2.\n\nFor edge 3 (connecting to node 3):\n\nNode 3 is not processed. Direct edge from 1 to 3. Add 5 to node 3's current_inflow (now 5). Since node 3 is the sink, we don't check anything.\n\nNow, the queue has node 2.\n\nDequeue node 2. Look at all edges connected to node 2 that are not yet directed. These are edge 1 (connecting to node 3).\n\nEdge 1 connects to node 3, which is not processed. So direct edge from 2 to 3. Add 10 to node 3's current_inflow (now 5+10=15, which is the required inflow for the sink). Since node 3 is the sink, we don't enqueue it.\n\nNow, the queue is empty. All edges are directed.\n\nThe directions are:\n\nEdge 2: 1→2 (output 0).\n\nEdge 1: 2→3 (original was 3-2, so direction is 2→3 → output 1 (since original was ai=3, bi=2, so direction is bi→ai? Or depends on how we stored the edges.)\n\nWait, the edges are stored as per the input. For example, edge 1 is between ai=3 and bi=2. When we direct it from 2 to 3, that would mean that the direction is bi→ai? Or is it that the direction is from u to v, where u is the processed node and v is the unprocessed node.\n\nSo, for edge (ai, bi) = (3,2), when we direct it from 2 to 3, the direction is from bi to ai? Or from u to v, where u is 2 and v is 3.\n\nIn this case, the original edge is between 3 and 2. So when we direct it from 2 to 3, it would be bi (2) → ai (3)? Or depends on the original edge's ai and bi.\n\nWait, the original edge is stored as (ai, bi). When we decide to direct it from u to v, we need to check if u is ai or bi.\n\nFor example, if the original edge is between ai and bi, and we decide to direct it from ai to bi, then output is 0. If we direct it from bi to ai, output is 1.\n\nSo, during the processing, for each edge (ai, bi), when we decide to direct it from u to v, we need to check if u is ai and v is bi (output 0), or u is bi and v is ai (output 1), or if the edge is between u and v in some order.\n\nTherefore, during the processing, for each edge, we need to track which direction it is directed.\n\nSo, during the algorithm, for each edge, when we process it, we need to know which direction it's directed in.\n\nBut how to track which edges are processed and which are not.\n\nThis suggests that we need to represent the edges in a way that allows us to iterate through them for each node.\n\nSo, perhaps for each node u, we can have a list of adjacent edges. But since the graph is undirected, each edge is stored twice (once for each endpoint). However, during processing, once an edge is directed, we need to mark it as processed so it's not processed again.\n\nBut this could be tricky. Alternatively, during processing, when we process a node u, we iterate through all edges connected to u, and for each edge, if the other node v hasn't been processed yet, we direct the edge from u to v and mark it as processed. Otherwise, if the other node has already been processed, we ignore it (since the edge would have been directed in the opposite direction when the other node was processed).\n\nWait, but this requires that each edge is processed exactly once. So, when we process node u, we look at all edges connected to u. For each such edge, if the other node v hasn't been processed yet, we direct it from u to v. Otherwise, we do nothing, since the edge was already directed when v was processed.\n\nBut how to avoid processing the same edge twice.\n\nFor example, if u is processed and v is not, we direct the edge u→v. Then, when v is processed, we look at the edge and see that u has already been processed, so we don't direct it again.\n\nSo, to implement this, we need to track for each edge whether it has been directed already.\n\nBut how to do this efficiently.\n\nAn alternative approach is to represent each edge as a pair of nodes, and for each edge, when processing a node u, check if the other node v is already processed. If not, direct the edge from u to v, and mark the edge as processed.\n\nBut how to represent the edges and track which ones have been processed.\n\nThis seems manageable. Let's think of the following data structures:\n\n- For each node u, we have a list of edges connected to it. Each edge is represented as a tuple (v, index), where index is the index of the edge in the input.\n\n- We also have a boolean array processed_edges of size m, initially False.\n\n- When processing node u, for each edge (v, idx) in u's adjacency list:\n\n   if processed_edges[idx] is False:\n\n      if v hasn't been processed yet:\n\n         direct the edge from u to v. Mark processed_edges[idx] as True.\n\n         add the flow to v's current_inflow.\n\n         if v's current_inflow equals required_inflow, enqueue it.\n\n      else:\n\n         do nothing (since the edge was already directed when v was processed).\n\nBut how to know whether v has been processed yet. We need to track for each node whether it has been processed.\n\nSo, we need a processed_nodes array, which marks whether a node has been processed.\n\nBut during the processing of node u, when we look at an edge between u and v, if v is not processed, then we direct the edge from u to v. Otherwise, we do nothing.\n\nThis way, each edge is processed exactly once, when the first of its endpoints is processed.\n\nThis seems correct.\n\nNow, let's think about how to implement this.\n\nThe steps would be:\n\n1. Read the input, and build an adjacency list for each node. For each node u, store a list of tuples (v, idx, ci), where idx is the index of the edge in the input.\n\n2. For each node, compute S_v as the sum of ci for all edges",
    "response": "To solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph forms a valid maximum flow with no cycles. The key constraints are ensuring flow conservation at each node (except the source and sink) and maintaining an acyclic structure.\n\n### Approach\n1. **Flow Conservation**: For each node (except the source and sink), the sum of flows entering the node must equal the sum of flows exiting the node. This implies that the total flow through each node must be even.\n2. **Acyclic Structure**: The directed graph must be acyclic. We can achieve this by processing nodes in a topological order, ensuring edges are directed from processed nodes to unprocessed nodes.\n\nThe approach involves:\n1. **Graph Construction**: Build an adjacency list for the graph, storing each edge along with its index and flow value.\n2. **Inflow Calculation**: For each node, calculate the required inflow based on the sum of flows on its connected edges.\n3. **Topological Processing**: Use a queue to process nodes starting from the source. For each node processed, direct all its edges to unprocessed nodes, updating their inflow values accordingly. If an unprocessed node's inflow meets the required value, it is enqueued for processing.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]  # 1-based indexing\n\n    for idx in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        edges.append((a, b, c))\n        adj[a].append((b, idx, c))\n        adj[b].append((a, idx, c))\n\n    # Compute S_v for each node\n    S = [0] * (n + 1)\n    for a, b, c in edges:\n        S[a] += c\n        S[b] += c\n\n    required_inflow = [0] * (n + 1)\n    for v in range(1, n + 1):\n        if v == 1:\n            required_inflow[v] = 0\n        elif v == n:\n            required_inflow[v] = S[v]\n        else:\n            required_inflow[v] = S[v] // 2\n\n    # Initialize current_inflow and processed_nodes\n    current_inflow = [0] * (n + 1)\n    processed_nodes = [False] * (n + 1)\n    processed_edges = [False] * m\n\n    # Queue for processing nodes\n    q = deque()\n    q.append(1)\n    processed_nodes[1] = True\n\n    # To store the direction of each edge (0: ai->bi, 1: bi->ai)\n    direction = [0] * m\n\n    while q:\n        u = q.popleft()\n        for (v, idx, c) in adj[u]:\n            if processed_edges[idx]:\n                continue\n            if not processed_nodes[v]:\n                # Direct the edge from u to v\n                # Check if the original edge is (u, v) or (v, u)\n                original_a, original_b, original_c = edges[idx]\n                if original_a == u and original_b == v:\n                    direction[idx] = 0\n                else:\n                    direction[idx] = 1\n                processed_edges[idx] = True\n                current_inflow[v] += c\n                if current_inflow[v] == required_inflow[v]:\n                    q.append(v)\n                    processed_nodes[v] = True\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Graph Construction**: The graph is built using an adjacency list where each entry includes the connected node, edge index, and flow value.\n2. **Inflow Calculation**: For each node, the required inflow is calculated based on the sum of flows of its connected edges.\n3. **Topological Processing**: Nodes are processed starting from the source. Each edge is directed from the currently processed node to an unprocessed node, updating the inflow of the destination node. If the destination node's inflow meets the required value, it is added to the queue for further processing, ensuring an acyclic structure.\n\nThis approach ensures that the resulting directed graph satisfies both flow conservation and acyclicity constraints efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]  # 1-based indexing\n\n    for idx in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        edges.append((a, b, c))\n        adj[a].append((b, idx, c))\n        adj[b].append((a, idx, c))\n\n    # Compute S_v for each node\n    S = [0] * (n + 1)\n    for a, b, c in edges:\n        S[a] += c\n        S[b] += c\n\n    required_inflow = [0] * (n + 1)\n    for v in range(1, n + 1):\n        if v == 1:\n            required_inflow[v] = 0\n        elif v == n:\n            required_inflow[v] = S[v]\n        else:\n            required_inflow[v] = S[v] // 2\n\n    # Initialize current_inflow and processed_nodes\n    current_inflow = [0] * (n + 1)\n    processed_nodes = [False] * (n + 1)\n    processed_edges = [False] * m\n\n    # Queue for processing nodes\n    q = deque()\n    q.append(1)\n    processed_nodes[1] = True\n\n    # To store the direction of each edge (0: ai->bi, 1: bi->ai)\n    direction = [0] * m\n\n    while q:\n        u = q.popleft()\n        for (v, idx, c) in adj[u]:\n            if processed_edges[idx]:\n                continue\n            if not processed_nodes[v]:\n                # Direct the edge from u to v\n                # Check if the original edge is (u, v) or (v, u)\n                original_a, original_b, original_c = edges[idx]\n                if original_a == u and original_b == v:\n                    direction[idx] = 0\n                else:\n                    direction[idx] = 1\n                processed_edges[idx] = True\n                current_inflow[v] += c\n                if current_inflow[v] == required_inflow[v]:\n                    q.append(v)\n                    processed_nodes[v] = True\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 702,
        "completion_token_count": 986,
        "thoughts_token_count": 8192
    }
}