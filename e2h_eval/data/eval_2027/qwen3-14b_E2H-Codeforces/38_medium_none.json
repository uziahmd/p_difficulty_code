{
    "start": 1758310222.8848271,
    "end": 1758310637.40054,
    "start-formatted": "2025-09-20 04:30 KST",
    "end-formatted": "2025-09-20 04:37 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about finding the minimum number of nodes required to create a p-reachable directed graph. Then, among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, let's understand what a p-reachable graph is. The definition says that it has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So, for each such pair, both u can reach v and v can reach u. And we have exactly p such pairs.\n\nOur task is two-fold: find the minimal number of nodes needed for this, and then find the maximum possible number of unidirectional pairs in such a graph.\n\nLet me think about how to model this.\n\nLet's start with the first part: finding the minimal number of nodes.\n\nLet me think about the number of pairs (u, v) with u < v that are mutually reachable. For a graph with n nodes, how can we arrange the edges so that the number of such pairs is exactly p, and find the minimal n?\n\nBut how do we model the number of such pairs? Well, perhaps the key is to consider strongly connected components (SCCs). Because if two nodes are in the same SCC, they are mutually reachable. Also, if there's a path from u to v and from v to u, they are in the same SCC.\n\nSo, the number of pairs (u, v) with u < v and mutually reachable is equal to the sum over all SCCs of C(k, 2), where k is the size of the SCC. Because in an SCC of size k, there are k*(k-1)/2 ordered pairs (u, v) where u < v and they are mutually reachable.\n\nWait, but the problem defines (u, v) as ordered pairs where u < v. So for each SCC of size k, the number of such pairs is C(k, 2) = k*(k-1)/2. So the total p is the sum of C(k_i, 2) for each SCC in the graph.\n\nSo the problem reduces to: find a collection of integers k_1, k_2, ..., k_m such that sum_{i} C(k_i, 2) = p, and the sum of k_i is minimized. Because each k_i represents the size of an SCC. Then, the minimal number of nodes is the sum of the k_i's.\n\nSo the first part of the problem is equivalent to: given p, find the minimal sum of integers (each ≥1) such that the sum of C(k_i, 2) is exactly p.\n\nOnce we find that minimal sum, which is the minimal number of nodes, then the second part is to compute the maximum number of unidirectional pairs in such a graph.\n\nSo first, solving the first part: find the minimal number of nodes n such that there exists a set of integers k_1, ..., k_m where sum C(k_i, 2) = p, and sum k_i is minimized.\n\nLet me think about how to find this minimal n. For example, for p=3, the minimal n is 3. Because C(3,2) = 3. So one SCC of size 3. Sum is 3. But if we tried to split into smaller components, say two components, like 2 and 1. Then sum C(2,2)+C(1,2) = 1 + 0 = 1, which is less than 3. So not enough. Alternatively, maybe three components of size 2, 1, 1. Then sum would be 1 + 0 + 0 = 1. Still not enough. So the minimal n is 3.\n\nAnother example: p=4. The output in the sample input for p=4 is 5 and 6. Wait, the sample input for p=4 is output '5 6'. Let me see why. The first part is the minimal number of nodes. How can we get sum C(k_i, 2) = 4?\n\nPossible options:\n\nOption 1: one component of size 3 (C(3,2)=3) and another component of size 2 (C(2,2)=1). Total sum is 3+1=4. The total nodes is 3+2=5. That's better than other options. Like, a component of size 4: C(4,2)=6>4. So that's too big. Or two components of size 2 and 2: sum is 1+1=2 <4. So no. So the minimal n is 5.\n\nSo the first part is to find the minimal sum of k_i's such that sum C(k_i, 2) = p.\n\nNow, how to find that minimal sum?\n\nThis seems similar to a problem where you want to represent p as the sum of combinations C(k_i, 2), and minimize the sum of k_i. Let's think about how to choose the k_i's optimally.\n\nThe idea is that for a given p, we want to use as large as possible C(k, 2) values. Because larger C(k, 2) per unit of k. For example, for a given value of C(k, 2), the k is as small as possible. Wait, no. Let's think about the efficiency of using a component of size k. Each C(k, 2) contributes to p, but the cost is k nodes. So, for each unit of p, how much does it cost in terms of nodes?\n\nFor example, C(k,2) = k*(k-1)/2. For a given value of x = C(k,2), the cost is k. So to maximize the value of x per unit cost, we need to choose k as large as possible. Wait, no. Let's think about the ratio x / cost. For example, when k increases, x increases quadratically, while cost increases linearly. So for higher k, the x per cost is better.\n\nTherefore, to minimize the sum of k_i's for a given sum of x_i's (which is p), we should maximize the individual x_i's, i.e., use as large as possible components.\n\nBut how to do that?\n\nLet me think of this as a greedy problem. For example, for p, find the largest possible k such that C(k, 2) ≤ p. Then subtract that from p, and repeat. However, this might not be optimal. Wait, but perhaps it is. Let's see.\n\nFor example, take p=4. The largest C(k,2) ≤4 is 3 (k=3). Subtract 3, remaining p=1. Then take k=2 (C(2,2)=1). Total sum is 3+2=5, which is correct.\n\nAnother example: p=5. Largest C(k,2) is 3 (k=3), then remaining 2. Then next largest is 1 (k=2), remaining 1. Then another k=2. So total sum is 3+2+2=7. But another way: take k=3 (C(3,2)=3) and k=3 again (another 3). That gives sum 3+3=6, which is more than 5. So that's not allowed. Wait, but 3+1=4. So maybe another approach.\n\nAlternatively, for p=5: what is the best way? Let's think.\n\nIf we take a component of size 4, C(4,2)=6 which is larger than 5, so not allowed. So the next is 3. Then subtract 3, remaining 2. Now, the best is to take a component of size 2 (C(2,2)=1), but that leaves 1. Then another component of size 2. So total sum 3+2+2=7. Alternatively, maybe take two components of size 3 and 2. Wait, that's sum 3+2=5, but the total C(k,2) is 3 + 1 =4, which is less than 5. Not helpful.\n\nWait, perhaps another approach: for p=5, can we have a component of size 3 (3) and another of size 3 (3) but that's 6, which is more than 5. Not allowed. So perhaps the best is to take a component of size 3 (3) and then a component of size 3, but subtract 1? No. That's not possible. So maybe the best is 3+2+2=7. But is there a better way?\n\nAnother possibility: take a component of size 4, but then subtract 1. But that's not allowed. Because C(4,2) is 6. So how can we get 5? Maybe take a component of size 4 and then subtract 1. But that's not possible. So maybe the only way is to take 3 + 2 + 2 = 7. But wait, perhaps there's a way to split into components of size 3 and 2 and 1. Then the sum is 3+2+1=6. But the sum of C(k_i, 2) is 3 + 1 + 0 =4, which is less than 5.\n\nHmm. So maybe the greedy approach of taking the largest possible C(k,2) each time is the right approach. Let's check for p=5.\n\nThe largest possible is 3 (k=3). Then remaining is 2. Now, the largest possible for 2 is 1 (k=2). Then remaining is 1. Take another k=2. So total sum is 3+2+2=7. But perhaps another way: take two components of size 3 and 2, but that gives 3+1=4. No. Not enough. What about a component of size 3 (3) and a component of size 3 (but that would be 3+3=6, which is more than 5). So that's invalid. So the greedy approach seems necessary here.\n\nBut then, perhaps the minimal sum is achieved by taking the maximum possible C(k,2) each time. So how to compute this?\n\nSo the approach would be to find the maximum k such that C(k, 2) ≤ p. Then subtract that value from p, add k to the total nodes, and repeat until p becomes zero.\n\nBut let's test this approach for some examples.\n\nSample input p=3: the maximum k is 3 (C(3,2)=3). Subtract 3, p=0. Total nodes 3. Correct.\n\nSample input p=4: max k is 3 (3), subtract 3, p=1. Then max k is 2 (1). Subtract 1. Total nodes 3+2=5. Correct.\n\nAnother example: p=6. Max k is 4 (C(4,2)=6). So subtract 6, done. Total nodes 4. Which is better than splitting into 3+3 (sum 6, which would be 3+3=6 nodes, but 4 is better).\n\nSo yes, the greedy approach of taking the largest possible C(k, 2) each time gives the minimal sum.\n\nSo the algorithm for the first part is:\n\nInitialize total_nodes = 0.\n\nWhile p > 0:\n\n   Find the maximum k such that k*(k-1)/2 ≤ p.\n\n   Subtract k*(k-1)/2 from p.\n\n   Add k to total_nodes.\n\nSo that's the way to compute the minimal number of nodes.\n\nBut how to find this maximum k for a given p?\n\nWe can solve k*(k-1)/2 ≤ p. Let's rearrange this equation:\n\nk^2 -k - 2p ≤ 0.\n\nSolving for k: the positive root of the equation k^2 -k - 2p = 0 is [1 + sqrt(1 + 8p)] / 2. So the maximum k is floor( (sqrt(8p + 1) + 1)/2 )\n\nLet me test this.\n\nFor example, p=3: sqrt(25) =5. (5+1)/2=3. So k=3. Correct.\n\nFor p=4: sqrt(33) is ~5.744. (5.744+1)/2 ≈ 3.37. So floor is 3. Correct.\n\nFor p=6: sqrt(49) is 7. (7+1)/2=4. Correct.\n\nFor p=5: sqrt(41) is ~6.4. (6.4+1)/2 = 3.7 → floor 3. So k=3. Then subtract 3 from p=5, leaving 2. Then next step: for p=2, sqrt(17) is ~4.123. (4.123 +1)/2= ~2.56 → floor 2. So subtract 1, leaving 1. Then again, same for p=1: k=2 (since 1 is C(2,2)). So total nodes is 3+2+2=7.\n\nYes. So the formula works.\n\nSo the first part can be computed by this approach.\n\nNow, once we have the minimal number of nodes, the second part is to find the maximum number of unidirectional pairs among all such graphs.\n\nWhat is a unidirectional pair? It's an ordered pair (u, v) where u != v, there's a path from u to v, but no path from v to u.\n\nIn terms of the graph structure, the unidirectional pairs are those pairs where u and v are in different strongly connected components (SCCs), and there is a directed path from u's component to v's component, but not vice versa.\n\nBut how to model this?\n\nLet me think about the structure of the graph. Suppose the graph is divided into SCCs. Let's assume that the graph is a DAG of SCCs. Because in any directed graph, the SCCs can be arranged into a DAG, where there is an edge from component A to component B if there's an edge from a node in A to a node in B.\n\nIn this DAG, if there is a directed path from component A to component B, then all nodes in A can reach all nodes in B. But if there's no path from B to A, then any pair (u in A, v in B) will be a unidirectional pair. Because u can reach v, but v cannot reach u.\n\nSo the total number of unidirectional pairs is the sum over all pairs of components (A, B) where there is a directed path from A to B but not from B to A, of |A| * |B|.\n\nBut since the DAG is a DAG, for any two distinct components A and B, either there is a path from A to B or from B to A, or neither. However, if the DAG is such that there's no cycle, then for any two components, there's at most one direction.\n\nBut how to maximize the number of unidirectional pairs? Let's think about the structure of the DAG of components.\n\nThe total number of ordered pairs (u, v) with u != v is n*(n-1). From this, subtract the number of pairs that are mutual (i.e., in the same component) and subtract the number of pairs that are not reachable in either direction.\n\nBut since the graph is a DAG of components, any two components A and B, if there is a path from A to B, then all pairs (u in A, v in B) are unidirectional if there is no path back from B to A.\n\nWait, but if there is a path from A to B and from B to A, then A and B must be in the same component. So in the DAG of components, there are no such pairs. Therefore, for any two components A and B, either:\n\n- A and B are in the same component (so their pairs are mutual and counted in p).\n\n- Or there is a directed path from A to B but not vice versa. Then, all pairs (u in A, v in B) are unidirectional.\n\n- Or there is no path between them. Then, neither u can reach v nor vice versa. These pairs are not counted as unidirectional.\n\nThus, the total number of unidirectional pairs is the sum over all pairs of components (A, B) where there is a directed path from A to B but not from B to A, of |A| * |B|.\n\nTo maximize this sum, given the sizes of the components, we need to arrange the DAG of components in a way that maximizes the number of such pairs.\n\nWhat's the best way to arrange the components to maximize the number of unidirectional pairs?\n\nLet me think of the components as being arranged in a linear order. Suppose we have components ordered as C1, C2, ..., Cm, where there is a directed path from Ci to Cj if i < j. Then, for any pair (Ci, Cj) with i < j, there is a path from Ci to Cj, but not from Cj to Ci. Thus, all pairs of nodes between Ci and Cj contribute |Ci| * |Cj| to the unidirectional count.\n\nIn this case, the total number of unidirectional pairs is the sum_{i < j} |Ci| * |Cj|.\n\nBut this is the maximum possible, because if you arrange the DAG as a linear chain, then every pair of components contributes their product. If there's any other arrangement, some pairs of components may not contribute, leading to a lower total.\n\nFor example, if you have three components A, B, C, and arrange them in a DAG where A points to B and C, and B points to C. Then the pairs (A,B), (A,C), (B,C) contribute. But if you had a DAG where A points to B and B points to C, but A and C are not connected directly, then the same sum applies. However, if you have components arranged in a DAG with multiple branches, like A points to B and C, and B and C are not connected, then the sum would be |A|*|B| + |A|*|C| + |B|*|C| (if B and C are not connected). Wait, no. If B and C are not connected, then there's no path from B to C or vice versa. So the pair (B, C) would not contribute. So the sum would be |A|*|B| + |A|*|C|. Which is less than the sum when arranged in a linear chain (which includes |B|*|C| as well). Hence, arranging the components in a linear chain maximizes the sum.\n\nTherefore, the maximum number of unidirectional pairs is achieved when the DAG of components is a linear chain, and each component points to all subsequent components.\n\nSo, given the sizes of the components, the maximum number of unidirectional pairs is the sum_{i < j} (size_i * size_j).\n\nBut how do we compute this sum?\n\nLet me note that sum_{i < j} size_i * size_j = [ (sum size_i)^2 - sum size_i^2 ] / 2.\n\nBecause sum_{i != j} size_i * size_j = (sum size_i)^2 - sum size_i^2. And since sum_{i<j} size_i * size_j = sum_{i>j} size_i * size_j, so the total is half of that.\n\nSo, the maximum number of unidirectional pairs is [ (total_nodes)^2 - sum (size_i^2) ] / 2 - (number of mutual pairs) ?\n\nWait, no. Because the mutual pairs are those within the same component. The sum_{i < j} size_i * size_j counts all pairs of nodes from different components, but in the DAG arranged as a linear chain, all such pairs are unidirectional. However, the problem says that unidirectional pairs are those where u can reach v but not vice versa. But in this scenario, for any pair of nodes in different components, there is a path from one to the other, but not vice versa. Hence, all such pairs are unidirectional. So the total number of unidirectional pairs is exactly sum_{i < j} size_i * size_j.\n\nBut wait, the problem defines a unidirectional pair as (u, v) where u != v, there's a path from u to v, and no path from v to u. So for each pair of nodes in different components, exactly one of the following is true: u can reach v or v can reach u. Because the DAG is a linear chain. So for each pair of nodes in different components, exactly one of the directions is present. Hence, the total number of unidirectional pairs is indeed sum_{i < j} size_i * size_j.\n\nSo the problem reduces to, once we have the sizes of the components (the k_i's chosen in the first part), compute sum_{i<j} size_i * size_j. Which is equal to (total^2 - sum size_i^2)/2.\n\nSo, the second part of the problem is to compute this value.\n\nBut how to compute the sum of squares of the component sizes?\n\nIn the first part, when we split p into sum C(k_i, 2), the way we split is using the greedy approach. For example, for p=4, we split into 3 and 2. The sum of squares is 3² + 2² = 9+4=13. The total nodes is 5. Then (5² -13)/2 = (25-13)/2 = 6. Which matches the sample input for p=4, which outputs 6 as the second part.\n\nYes. So the sample input for p=4 is 5 6. Which aligns with this calculation.\n\nAnother example: p=3. The component sizes are [3]. sum squares is 9. total nodes is 3. So (3² -9)/2 = 0. Which matches the first sample's output of 0.\n\nSo the approach is:\n\nOnce we have the component sizes (k_1, k_2, ..., k_m), compute the sum of their squares, then compute (total^2 - sum_squares) // 2.\n\nSo the steps for solving the problem are:\n\nFor a given p:\n\n1. If p is 0: then the minimal number of nodes is 0 (but wait, the problem says that the ordered pairs (u, v) must have u < v. For p=0, the graph must have no such pairs. So, the graph can be a DAG with no cycles. But the minimal number of nodes? Well, for p=0, the sum of C(k_i, 2) must be 0. Which implies that all components are of size 1 (since C(1,2)=0). So the minimal number of nodes is 0? No. Wait, the problem says that the graph is directed. But for p=0, the graph must have no pairs (u, v) with u < v and mutual reachability. So, the components can be of size 1 (each node is its own component). So the minimal number of nodes is 0? No. Because the problem says that the graph must contain exactly p ordered pairs. For p=0, the graph can have any number of nodes, but with no mutual reachability pairs. However, the minimal number of nodes is 0? But the problem says that nodes are in the graph. Wait, the problem says \"the minimum number of nodes required to create a p-reachable directed graph.\"\n\nWait, for p=0, the graph must have exactly zero pairs (u, v) with u < v and mutual reachability. So, for example, a graph with 0 nodes (empty graph) satisfies this. But perhaps the problem expects that the graph must have at least one node? Let's check the sample input where p=0. The sample input has p=0 and output is '0 0'.\n\nLooking at the sample input for p=0: the output is '0 0'.\n\nBut according to the problem statement, the input p can be 0. So for p=0, the minimal number of nodes is 0. However, in practice, perhaps the problem considers that a graph must have at least one node. Wait, but the problem says that the ordered pair (u, v) requires u != v. For p=0, there are no such pairs, which can be achieved with 0 nodes (since there are no pairs at all). But perhaps the problem allows that.\n\nBut according to the sample input for p=0, the output is 0 0. So that's acceptable.\n\nSo, for p=0, the minimal number of nodes is 0, and the maximum unidirectional pairs is 0.\n\nSo the steps for solving the problem are:\n\nFor the first part:\n\nCompute the minimal number of nodes n as per the greedy approach.\n\nFor the second part:\n\nCompute the sum of squares of the component sizes (from the greedy decomposition), then compute (n^2 - sum_squares) // 2.\n\nSo, the problem now becomes to implement this logic.\n\nNow, the code steps:\n\nFirst, handle the case when p=0. Then the answer is 0 0.\n\nElse:\n\nWe need to decompose p into the sum of C(k_i, 2) using the greedy approach, and collect the list of k_i's.\n\nOnce we have the list of k_i's, compute sum_squares = sum(k_i^2).\n\nThen, n = sum(k_i), and the answer for the second part is (n^2 - sum_squares) // 2.\n\nSo, the code needs to:\n\nImplement the decomposition of p into the sum of C(k_i, 2) using the greedy approach.\n\nLet me think about how to implement this.\n\nImplementing the decomposition:\n\nInitialize p as input.\n\nInitialize list of k's as empty.\n\nWhile p > 0:\n\n   find the maximum k such that k*(k-1)/2 ≤ p.\n\n   append k to the list.\n\n   subtract k*(k-1)/2 from p.\n\nSo, how to compute k for each step.\n\nAs discussed, k is floor( (sqrt(8p + 1) + 1)/2 )\n\nBut we need to compute this accurately.\n\nLet me think about how to compute k for a given p.\n\nFor example, compute the value of k as follows:\n\nCompute the value of x = 8*p + 1.\n\nTake the square root of x. Let's call it sqrt_x.\n\nThen, compute candidate k as (sqrt_x + 1) // 2.\n\nBut need to check if k*(k-1)/2 is <= p, and possibly adjust.\n\nAlternatively, compute k as the floor of (sqrt(8p + 1) + 1)/2.\n\nBut perhaps using binary search would be better for accuracy, but for the purposes of code, perhaps using math.sqrt is sufficient.\n\nBut in code, we need to be careful with floating point precision.\n\nLet me think of code steps:\n\nFor a given p, compute k as follows:\n\nk = floor( (sqrt(8*p + 1) + 1)/2 )\n\nBut let me check for p=4:\n\nsqrt(8*4 +1) = sqrt(33) ≈5.74456...\n\nAdding 1 gives 6.74456... divided by 2 is ~3.372, floor is 3. Which is correct.\n\nFor p=5:\n\nsqrt(41) ≈6.403, adding 1 is 7.403, divided by 2 is 3.7015, floor 3. Correct.\n\nFor p=6: sqrt(49) is 7. (7+1)/2 = 4. Correct.\n\nSo, code can compute this as:\n\nimport math\n\ndef get_k(p):\n\n    sqrt_val = math.sqrt(8*p + 1)\n\n    k = int( (sqrt_val + 1) // 2 )\n\n    # Now check if k*(k-1)//2 exceeds p. If yes, decrease by 1.\n\n    while k*(k-1)//2 > p:\n\n        k -= 1\n\n    return k\n\nWait, but perhaps the initial calculation is accurate. For example, when 8p+1 is a perfect square, then sqrt_val is exact. Else, the floor is correct.\n\nBut perhaps there's a case where the initial calculation gives k, but k*(k-1)/2 is larger than p. For example, if p is exactly C(k, 2) - 1, then the formula would give k, but the actual value would be k*(k-1)/2 which is larger than p. So we need to check and adjust.\n\nBut how to avoid that?\n\nAlternatively, compute k as the floor of (sqrt(8p + 1) + 1)/2, but then check if (k+1)*k/2 is <= p. Wait, perhaps not. Let me think.\n\nAlternatively, the formula is:\n\nk = floor( (sqrt(8p + 1) + 1)/2 )\n\nBut let's compute that in code.\n\nBut perhaps in code, using math.isqrt (for Python 3.8+) for integer square roots would be better.\n\nBut for the sake of code, let's proceed.\n\nOnce we have the list of k_i's, then sum_squares is sum(k_i**2).\n\nNow, for the code:\n\nRead p from input. For each test case (the input is a single integer p).\n\nBut looking at the sample input, the input is given as a list of p's. Wait, the original problem says:\n\nInput:\n\nThe first and only line contains a single integer p (0 ≤ p ≤ 2e5).\n\nWait, the sample input shows:\n\n['3', '4', '0']\n\nBut that's probably a mistake. Looking back, the sample input shows:\n\nSample Input:\n\n['3', '4', '0']\n\nSample Output:\n\n['3 0', '5 6', '0 0']\n\nBut that's probably a formatting error. The actual input is a single integer p. So for example, for the first test case, input is 3, output is 3 0. For input 4, output 5 6. For input 0, output 0 0.\n\nSo the code should read a single integer p from stdin.\n\nSo the code is:\n\nRead p.\n\nHandle p=0: output 0 0.\n\nElse:\n\nProceed to decompose p into the k_i's.\n\nOnce we have the list of k_i's, compute n = sum(k_i), sum_squares = sum(k_i^2).\n\nThen, the answer for the second part is (n^2 - sum_squares) // 2.\n\nSo, code steps:\n\nImplement the decomposition.\n\nNow, code:\n\nimport math\n\ndef min_nodes_and_unidirectional(p):\n\n    if p == 0:\n\n        return (0, 0)\n\n    components = []\n\n    while p > 0:\n\n        # Compute k for current p\n\n        sqrt_val = math.sqrt(8 * p + 1)\n\n        k = int( (sqrt_val + 1) // 2 )\n\n        # Check if k*(k-1)//2 <= p\n\n        while k*(k-1)//2 > p:\n\n            k -= 1\n\n        components.append(k)\n\n        p -= k*(k-1)//2\n\n    n = sum(components)\n\n    sum_squares = sum(k*k for k in components)\n\n    unidirectional_pairs = (n * n - sum_squares) // 2\n\n    return (n, unidirectional_pairs)\n\nWait, but for p=0, the code returns (0, 0). Which is correct.\n\nTesting for p=3:\n\ncomponents = [3], sum is 3. sum_squares =9. (3^2 -9)/2 = 0. Correct.\n\nFor p=4: components [3, 2]. sum 5. sum_squares 9+4=13. 25-13=12, 12//2=6. Correct.\n\nFor p=0: returns (0, 0). Correct.\n\nAnother test case: p=1. The decomposition is [2], since C(2,2)=1. sum is 2. sum_squares is 4. (2^2 -4)/2= 0. So output is 2 0. But what is the maximum number of unidirectional pairs? Well, since the graph has one component of size 2, all pairs are mutual. So no unidirectional pairs. Correct.\n\nAnother example: p=2. How to decompose?\n\nThe maximum k is 2 (C(2,2)=1). Subtract 1, p=1. Then again, k=2. Subtract 1. So components [2,2]. sum is 4. sum_squares is 4+4=8. (4^2 -8)/2 = (16-8)/2=4. So the maximum unidirectional pairs is 4. How?\n\nThe components are two of size 2. Arranged in a linear chain. So the sum is 2*2 =4. Which is correct. So for two components of size 2, the unidirectional pairs are 2*2=4. Which is correct.\n\nSo the code seems to work.\n\nBut what about when p is 6?\n\nDecomposition: k=4 (C(4,2)=6). So components [4]. sum is 4. sum_squares is 16. (4^2 -16)/2 = 0. So output is 4 0. Which is correct, because all pairs are mutual.\n\nAnother example: p=5. Decomposition steps:\n\nInitial p=5.\n\nCompute sqrt(8*5+1) = sqrt(41) ≈6.403. (6.403 +1)/2 ≈3.7. So k=3. Check 3*2/2=3 ≤5. So subtract 3. p=2.\n\nNext iteration: p=2. sqrt(8*2+1)=sqrt(17)=~4.123. (4.123+1)/2 ~ 2.56. k=2. 2*1/2=1 ≤2. Subtract 1. p=1. Next, same process: k=2. subtract 1. p=0. components are [3,2,2]. sum is 3+2+2=7. sum_squares is 9+4+4=17. (7^2 -17)/2 = (49-17)/2 = 32/2=16. So the maximum unidirectional pairs is 16.\n\nBut how? The components are arranged in a linear chain. So the components are ordered as 3, 2, 2. The sum is (3*2 + 3*2 + 2*2) = 6 +6 +4 =16. Which is correct.\n\nYes.\n\nSo the code seems to handle these cases.\n\nNow, what about when p is 2? The code returns (2+2) =4 nodes, and (4^2 - 8)/2 = (16-8)/2=4. Which is correct.\n\nNow, the code seems correct.\n\nNow, considering edge cases.\n\nCase when p=0: returns 0 0.\n\nAnother case when p=1: returns 2 0.\n\nAnother case: p=2, returns 4 4?\n\nWait, no. Wait for p=2, the components are [2,2], sum is 4. sum_squares is 8. (4^2 -8)/2 = (16-8)/2=4. So yes. Which is 2*2=4. So the maximum unidirectional pairs is 4. Which is correct.\n\nNow, what about when p is 1, but the code returns 2 nodes and 0 unidirectional pairs. Which is correct.\n\nNow, let's think about the code's performance. Since p can be up to 2e5, and each iteration reduces p by at least 1 (since for k >=2, C(k,2) is at least 1). So the number of iterations is O(sqrt(p)), which is acceptable for p up to 2e5.\n\nSo the code should be efficient enough.\n\nNow, let's code this in Python.\n\nBut also, note that in Python, math.sqrt returns a float. So for large numbers, there could be precision issues. For example, when 8*p +1 is a perfect square, but due to floating point inaccuracies, the sqrt might return something slightly less than the exact value. So perhaps using integer square roots would be better.\n\nBut perhaps the code as written is sufficient. Alternatively, we can compute k via binary search.\n\nBut let's proceed with the code as written.\n\nNow, handling the case when p is zero.\n\nNow, the code:\n\nRead p from input. Then, process as above.\n\nBut in code, the function is called once per input.\n\nSo the code would be:\n\nimport math\n\ndef main():\n\n    import sys\n\n    p = int(sys.stdin.readline())\n\n    if p == 0:\n\n        print(\"0 0\")\n\n        return\n\n    components = []\n\n    current_p = p\n\n    while current_p > 0:\n\n        sqrt_val = math.sqrt(8 * current_p + 1)\n\n        k = int( (sqrt_val + 1) // 2 )\n\n        # Adjust k if needed\n\n        while k * (k - 1) // 2 > current_p:\n\n            k -= 1\n\n        components.append(k)\n\n        current_p -= k * (k - 1) // 2\n\n    n = sum(components)\n\n    sum_squares = sum(k*k for k in components)\n\n    unidirectional = (n * n - sum_squares) // 2\n\n    print(f",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This can be achieved by forming Strongly Connected Components (SCCs) such that the sum of combinations C(k, 2) for each SCC size `k` equals `p`.\n\n2. **Minimum Number of Nodes**: To minimize the number of nodes, we use a greedy approach. For each step, find the largest possible size `k` such that C(k, 2) ≤ remaining `p`. Subtract this value from `p` and repeat until `p` is zero.\n\n3. **Maximum Unidirectional Pairs**: Once we have the sizes of the SCCs, the maximum number of unidirectional pairs is derived from arranging these components in a linear chain. This is calculated using the formula: `(total_nodes^2 - sum_of_squares_of_component_sizes) // 2`.\n\n### Solution Code\n```python\nimport math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    components = []\n    current_p = p\n    while current_p > 0:\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Adjust k if necessary\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        components.append(k)\n        current_p -= k * (k - 1) // 2\n    \n    n = sum(components)\n    sum_squares = sum(k * k for k in components)\n    unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as a single integer `p`.\n2. **Handling Zero Case**: If `p` is zero, the output is immediately \"0 0\" since no nodes are needed.\n3. **Greedy Decomposition**: For each iteration, compute the largest possible component size `k` such that C(k, 2) ≤ remaining `p`. This is done using the quadratic formula and adjusted to ensure correctness.\n4. **Summing Component Sizes**: The total number of nodes is the sum of all component sizes found.\n5. **Calculating Unidirectional Pairs**: Using the derived formula, compute the maximum number of unidirectional pairs based on the component sizes.\n\nThis approach ensures that we efficiently determine the minimum number of nodes and the maximum unidirectional pairs using mathematical insights and greedy decomposition.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    components = []\n    current_p = p\n    while current_p > 0:\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Adjust k if necessary\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        components.append(k)\n        current_p -= k * (k - 1) // 2\n    \n    n = sum(components)\n    sum_squares = sum(k * k for k in components)\n    unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 472,
        "completion_token_count": 627,
        "thoughts_token_count": 8192
    }
}