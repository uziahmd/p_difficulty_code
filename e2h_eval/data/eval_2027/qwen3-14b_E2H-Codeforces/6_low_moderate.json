{
    "start": 1758313506.6793556,
    "end": 1758313904.2736409,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:31 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem statement carefully.\n\nSo, the problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and the sum of their costs is minimized. If there's no such pair, return -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. We need two vouchers i and j where the sum of their durations is exactly x. Also, they must not overlap. The non-overlapping condition is that either ri < lj or rj < li. So, they can't have any overlapping days.\n\nThe approach here is to find pairs of vouchers where one has duration d and the other has duration x - d. For each voucher with duration d, we need to find another voucher with duration x-d that doesn't overlap with it. And then track the minimum cost.\n\nBut how do I efficiently do this? Because checking all possible pairs would be O(n²), which is not feasible for n up to 2e5.\n\nSo, I need an efficient way. Let's think about grouping vouchers by their duration. For each duration d, store the vouchers with that duration. Then, for each voucher with duration d, check if there exists a voucher with duration x - d that does not overlap with it. But even that might be too slow if done naively.\n\nAlternatively, for each voucher, we can check if there exists a voucher of duration x - d that ends before the current voucher starts, or starts after the current voucher ends. But how to find the minimal cost for those cases?\n\nLet me think. Suppose I have all vouchers grouped by their duration. For example, for each duration d, I have a list of vouchers. Now, for a voucher A with duration d, I need to find vouchers B with duration (x - d) that end before A starts (so B's ri < A's li), or start after A ends (B's li > A's ri). For each such B, the minimal cost would be the minimal cost in those B's that meet the condition.\n\nSo, perhaps for each duration, we can pre-process the vouchers in a way that allows us to quickly find the minimal cost of vouchers that end before a certain day, or start after a certain day.\n\nFor example, for each duration k, we can have two sorted lists:\n\n- One sorted by their ri (end day), and for each position, we can have the minimum cost up to that point. This way, given a query for \"what is the minimal cost of vouchers with duration k that end before day L\", we can binary search for the largest ri that is less than L, and then get the minimum cost up to that point.\n\nSimilarly, for vouchers sorted by li (start day), we can have a sorted list and for each position, the minimum cost from that point onward. So, for a query \"what is the minimal cost of vouchers with duration k that start after day R\", we can binary search for the first li that is greater than R, and get the minimum cost from that index onwards.\n\nThis seems promising. Let's break it down.\n\nFirst, pre-process all vouchers into groups based on their duration. For each duration d, we have two structures:\n\n- A list of vouchers sorted by their ri (end day), along with a prefix min array. This allows us to find the minimum cost among vouchers with duration d that end before a certain day.\n\n- A list of vouchers sorted by their li (start day), along with a suffix min array. This allows us to find the minimum cost among vouchers with duration d that start after a certain day.\n\nOnce these structures are built, for each voucher A with duration d, we can check if there is a duration x - d. If so, then:\n\n- Find the minimal cost of vouchers with duration (x - d) that end before A's li. That would be the first case (B ends before A starts).\n\n- Find the minimal cost of vouchers with duration (x - d) that start after A's ri. That would be the second case (B starts after A ends).\n\nThen, take the minimum between these two possibilities (if they exist) and add to A's cost. Keep track of the overall minimum.\n\nBut how to implement this?\n\nLet me outline the steps:\n\n1. Preprocess all vouchers into groups by duration. For each duration d, store two sorted lists:\n\n   a. Sorted by ri, with prefix minima.\n\n   b. Sorted by li, with suffix minima.\n\n2. For each voucher in the list, check if there exists a duration (x - d) in the groups. If yes, then for that duration, perform the two checks mentioned above.\n\n3. For each possible pair, compute the sum of the costs and keep track of the minimum.\n\nNow, the question is how to build these sorted lists",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, while minimizing their total cost. The solution involves efficiently grouping and querying vouchers based on their durations and start/end dates.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This allows us to quickly access vouchers of specific durations when needed.\n2. **Preprocess for Efficient Queries**: For each duration, maintain two sorted lists:\n   - One sorted by the end date (`ri`) with prefix minimum costs.\n   - Another sorted by the start date (`li`) with suffix minimum costs.\n3. **Check Valid Pairs**: For each voucher, check if there exists another voucher of duration `x - duration` that does not overlap with it. Use the preprocessed lists to efficiently find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration, we have:\n    # sorted_ri: list of (r, l, cost) sorted by r\n    # prefix_min: min cost up to each index\n    # sorted_li: list of (l, r, cost) sorted by l\n    # suffix_min: min cost from each index onwards\n    preprocess = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by ri\n        sorted_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_ri:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by li\n        sorted_li = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_li)\n        min_cost = float('inf')\n        for i in range(len(sorted_li)-1, -1, -1):\n            min_cost = min(min_cost, sorted_li[i][2])\n            suffix_min[i] = min_cost\n        preprocess[d] = (sorted_ri, prefix_min, sorted_li, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocess:\n            continue\n        # Get the data for target_d\n        sorted_ri, prefix_min, sorted_li, suffix_min = preprocess[target_d]\n\n        # Check for vouchers ending before l1\n        # Find the largest r in sorted_ri that is < l1\n        # sorted_ri is sorted by r\n        r_list = [item[1] for item in sorted_ri]\n        pos = bisect.bisect_left(r_list, l1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n\n        # Check for vouchers starting after r1\n        # Find the first l in sorted_li that is > r1\n        l_list = [item[0] for item in sorted_li]\n        pos = bisect.bisect_right(l_list, r1)\n        if pos < len(sorted_li):\n            min_cost = suffix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by their start date, end date, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient lookup.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end date and start date. Prefix and suffix minimum cost arrays are created to allow quick minimum cost queries.\n4. **Checking Valid Pairs**: For each voucher, check if there exists another voucher of the required duration that does not overlap. Use binary search to efficiently find valid non-overlapping vouchers and compute the minimum cost.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n²) solution, making it feasible for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration, we have:\n    # sorted_ri: list of (r, l, cost) sorted by r\n    # prefix_min: min cost up to each index\n    # sorted_li: list of (l, r, cost) sorted by l\n    # suffix_min: min cost from each index onwards\n    preprocess = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by ri\n        sorted_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_ri:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by li\n        sorted_li = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_li)\n        min_cost = float('inf')\n        for i in range(len(sorted_li)-1, -1, -1):\n            min_cost = min(min_cost, sorted_li[i][2])\n            suffix_min[i] = min_cost\n        preprocess[d] = (sorted_ri, prefix_min, sorted_li, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocess:\n            continue\n        # Get the data for target_d\n        sorted_ri, prefix_min, sorted_li, suffix_min = preprocess[target_d]\n\n        # Check for vouchers ending before l1\n        # Find the largest r in sorted_ri that is < l1\n        # sorted_ri is sorted by r\n        r_list = [item[1] for item in sorted_ri]\n        pos = bisect.bisect_left(r_list, l1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n\n        # Check for vouchers starting after r1\n        # Find the first l in sorted_li that is > r1\n        l_list = [item[0] for item in sorted_li]\n        pos = bisect.bisect_right(l_list, r1)\n        if pos < len(sorted_li):\n            min_cost = suffix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1085,
        "thoughts_token_count": 1024
    }
}