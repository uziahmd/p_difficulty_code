{
    "start": 1758019748.7702732,
    "end": 1758022342.942117,
    "start-formatted": "2025-09-16 19:49 KST",
    "end-formatted": "2025-09-16 20:32 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The task is to assign directions to each edge in an undirected graph such that the flow is valid and maximum. The conditions are that for every vertex except source (1) and sink (n), the incoming flow equals outgoing flow. Also, the source has no incoming edges, and the directed graph must be acyclic. \n\nFirst, I need to understand what the problem is really asking. So, we have a maximum flow already computed, but the directions of the edges are not known. Our job is to assign directions to each edge so that the flow satisfies the conservation laws and the graph is acyclic.\n\nWait, but how do we ensure that the flow is a maximum flow? Oh, right, the problem says that the given ci values are the flow volumes for each edge. So our job is just to assign directions to these edges such that the flow is valid, and the directed graph is acyclic.\n\nSo the main constraints are:\n\n1. For all vertices except 1 and n, the sum of incoming flows equals the sum of outgoing flows.\n2. Vertex 1 has no incoming edges.\n3. The directed graph has no cycles.\n\nBut how do I model this? Let's think about the flow conservation. Since the flow is a maximum flow, the total outflow from the source (vertex 1) should equal the total inflow into the sink (vertex n). But since we're only assigning directions, perhaps the ci values are already such that this holds. So the problem is not to compute the flow but to assign directions correctly.\n\nNow, the key challenge is to assign directions to edges so that the flow is conserved at each intermediate node and the graph is acyclic.\n\nHmm. How can I model this? One approach is to think of the flow as a directed graph where each edge has a direction. For each node except source and sink, the sum of flows going into it must equal the sum going out. Also, the graph must be acyclic.\n\nBut how to assign directions?\n\nAn idea comes to mind: if we can find a topological order of the nodes such that all edges go from earlier nodes to later nodes in the order. Then, the graph is acyclic. Also, for the flow conservation, perhaps we can model this as a directed acyclic graph (DAG) with certain properties.\n\nWait, but how does the flow conservation fit into this? For each node (except source and sink), the sum of the flows entering equals the sum leaving. Which implies that the net flow (outflow minus inflow) is zero. For the source, the net outflow is equal to the total flow (since no incoming edges), and for the sink, the net inflow is equal to the total flow.\n\nBut how to model this with directions? Maybe think of the problem as building a DAG where each node's in-degree and out-degree flows balance except for the source and sink.\n\nAnother thought: since the graph is acyclic, there exists a topological order. Let's imagine that we arrange the nodes in a topological order. Then, for each edge, we direct it from the node that comes earlier in the order to the one that comes later. But how to choose this order such that the flow conservation is satisfied?\n\nAlternatively, maybe we can model this as a directed graph where each edge's direction is determined by the flow. For example, if the flow is from u to v, then we direct the edge u→v. But how to determine this direction?\n\nBut since the flow is already fixed (the ci values are given), perhaps the direction is determined by the flow's direction in the residual network. However, since the problem says that the flow is maximum, maybe we can use some properties of maximum flow to assign directions.\n\nAlternatively, considering that the graph is connected and acyclic once directed, perhaps we can model this as a DAG where each edge's direction is determined based on the flow's contribution to the source and sink.\n\nWait, here's another approach. Let's think of the flow as a directed graph. For each node except source and sink, the sum of flows going out must equal the sum of flows coming in. Which means that the net flow (outflow - inflow) is zero. For the source, the net outflow is equal to the total flow value (let's call it F), and for the sink, the net inflow is F.\n\nBut how to assign directions to edges to satisfy these constraints?\n\nLet me consider the problem as a system of equations. For each node v (not source or sink), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. However, since the edges are undirected, each edge can be directed in either way, but once directed, contributes to the in or out of the nodes.\n\nThis seems like a problem of finding a feasible flow direction assignment. But how?\n\nAnother idea: since the graph is connected, and the solution exists, perhaps we can model this as a directed graph where the edges are directed in such a way that the flow conservation holds. But how to find such a direction?\n\nWait, here's a possible way. For each node except the source and sink, the sum of all flows on edges adjacent to it must be even? No, that's not necessarily true. Because for example, if the node has two edges, each with flow 5. Then, if one is directed into the node and the other out, the sum is 5 in and 5 out, which balances. But the total sum of flows around the node is 10. So the sum of flows for each node (regardless of direction) must be even? No, because for the node, the total sum of flows on edges is 2 * (sum of flows in/out). Because each edge contributes to exactly one direction. Wait, no. For each edge, the flow is assigned to either in or out. So the sum of all flows in and out for a node is the sum of all flows on edges connected to that node. But for flow conservation, the sum of inflows equals the sum of outflows, so their difference is zero. Therefore, the sum of all flows on edges connected to the node must be even? Because sum_in = sum_out => sum_in + sum_out = 2*sum_in = total_flow. So total_flow must be even. However, the problem says that the input is such that a solution exists. Therefore, for each node (except source and sink), the sum of flows on edges connected to it must be even. But how do we know that? Well, the problem states that the solution exists, so we don't need to check that.\n\nBut how to proceed?\n\nAnother approach: think of the problem as building a directed graph where the flow conservation holds. Let's model this as a directed graph. For each node v (other than 1 and n), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. This can be viewed as a flow conservation condition.\n\nBut how to model this as a graph problem. Let's think about the following: the problem is equivalent to finding a directed graph where the flow on each edge is given, and for each node (except source and sink), the inflow equals outflow. Also, the graph must be acyclic.\n\nWait, but the flow is fixed. So the direction of the edge determines whether the flow is counted as incoming or outgoing for the nodes. So for each edge between u and v with flow c, if we direct it from u to v, then the flow contributes to the outflow of u and inflow of v. If directed the other way, it contributes to outflow of v and inflow of u.\n\nSo, for each node v (not 1 or n), the sum over all edges incident to v of (direction * c) must be zero. Where direction is +1 if the edge is directed away from v, and -1 if directed towards v. Wait, maybe not. Let me think again. For each edge between u and v, if directed from u to v, then for node u, this contributes +c to its outflow (so net outflow is increased by c), and for node v, it contributes +c to inflow (net inflow increased by c). The flow conservation requires that for each node v (except 1 and n), the net outflow is zero. Which means that the total outflow equals the inflow.\n\nSo, for each such node v, the sum of flows on edges directed away from v (outflow) minus the sum of flows on edges directed towards v (inflow) equals zero. Which implies that the total outflow equals the total inflow.\n\nBut how to model this as a system of equations? It's challenging.\n\nAlternatively, think of this as a directed graph where for each node v (except source and sink), the net flow is zero. The source has net outflow equal to F (the total flow), and the sink has net inflow equal to F. But how do I find such a direction assignment?\n\nBut how do I find F? Well, the total outflow from the source must be equal to the sum of all flows on edges connected to the source, but directed away from it. But since the problem says that the flow is maximum, perhaps the sum of flows on edges connected to the source (directed away) is F. Similarly, the sum of flows on edges connected to the sink (directed into it) is F.\n\nBut perhaps there's a way to model this as a directed graph where the flow conservation holds. However, solving this directly seems difficult.\n\nWait, here's an idea inspired by the fact that the directed graph must be acyclic. If we can arrange the nodes in a topological order, then all edges go from earlier nodes to later nodes. Then, the graph is acyclic. Also, for each node (except the source and sink), the sum of flows from incoming edges (which would be edges from earlier nodes) must equal the sum of flows from outgoing edges (edges to later nodes). But how to find such a topological order?\n\nAlternatively, think of the problem as a directed graph where each edge is directed from the node with lower potential to higher potential, and the potentials are chosen such that the flow conservation is satisfied. But how to compute these potentials?\n\nWait, here's a possible approach. Let's model the problem as a directed graph where each edge is directed from u to v if the potential of u is less than the potential of v. Then, the graph is acyclic. Now, the potentials can be assigned such that for each node v (except source and sink), the sum of flows on edges directed into v equals the sum of flows on edges directed out of v.\n\nBut how to compute these potentials? This seems like a system of equations. For each node v (not 1 or n), the sum of flows on edges directed into v must equal the sum on edges directed out of v. Let's denote the potential of a node as p(v). For each edge between u and v, the direction depends on whether p(u) < p(v) or p(u) > p(v). But how to set p(v) so that the flow conservation is satisfied?\n\nAlternatively, think of the problem as a directed graph where each node's potential is such that for each edge, the direction is determined by the potential difference. Then, for each node v (not source or sink), the sum of flows on edges where v is the source (u=v) minus the sum of flows on edges where v is the destination (v=w) equals zero. That is, sum_{edges from v} c_i - sum_{edges to v} c_i = 0. Which can be rewritten as sum_{edges from v} c_i = sum_{edges to v} c_i. Which implies that the net outflow from v is zero.\n\nBut how to find such potentials? Let's think of this as a system of equations. For each node v (excluding 1 and n), the sum of flows on edges going out of v equals the sum of flows on edges going into v. Which can be written as:\n\nsum_{(v, w) ∈ E} c_{vw} - sum_{(u, v) ∈ E} c_{uv} = 0\n\nWhich can be rearranged as:\n\nsum_{(v, w) ∈ E} c_{vw} = sum_{(u, v) ∈ E} c_{uv}\n\nBut how to find a way to assign directions such that this holds?\n\nAnother idea: since the graph is connected and acyclic once directed, perhaps we can build a directed tree structure, but I'm not sure.\n\nAlternatively, think of the problem as a directed graph where each node's outflow minus inflow is equal to some value. For the source, it's F (total flow), and for the sink, it's -F. For others, it's zero. So the problem reduces to finding a directed graph with these net flows, and being acyclic.\n\nThis seems similar to the problem of finding a flow in a graph, but with the direction of edges fixed. However, the edges are undirected, and their direction is to be determined.\n\nBut how to model this? Maybe we can model this as a flow problem where each edge can carry flow in either direction, and we want to find a flow that satisfies the conservation laws. But since the flow values are fixed (given as ci), perhaps this is a different approach.\n\nWait, here's a key insight. The given ci values are the flow on each edge, regardless of direction. So, for each edge, the flow is ci, but the direction is to be determined. The problem is to assign directions such that the flow conservation holds. So, the total flow for the entire graph is fixed. For example, the total outflow from the source is F, which must be equal to the sum of all ci's for edges connected to the source and directed away from it.\n\nBut how to compute F? Well, since the given graph is connected and the solution exists, F is the sum of flows on edges directed away from the source. However, without knowing the directions, how can we compute F?\n\nAlternatively, F can be determined by the fact that the sum of all flows on edges connected to the source (but since the source has no incoming edges, all edges connected to the source are directed away from it). Wait, no. Because the source can have edges connected to other nodes. For example, if there's an edge between 1 and 2, then the direction must be from 1 to 2 (since the source cannot have incoming edges). So, for all edges connected to the source, they must be directed away from the source. Therefore, the sum of all ci for edges connected to the source is F. Because the source's outflow is exactly the sum of all those ci's. And that must be equal to the sink's inflow.\n\nBut how to find that sum? Well, since the problem states that the given graph is connected and a solution exists, perhaps we can calculate F as the sum of all flows on edges connected to the source. Wait, but that might not be correct. Because the source may have multiple edges, but the flow through them is part of the maximum flow. However, in reality, the maximum flow F is determined by the capacities of the graph, but in this problem, the flow is already given. So, perhaps the given ci's are part of a valid maximum flow, and the sum of the flows on edges leaving the source is F. But how to compute F? Well, since the source has no incoming edges, all edges connected to it must be directed away from it. Thus, F is the sum of ci's of all edges connected to the source.\n\nBut then, for the sink, the sum of ci's of edges directed into it must be F. But how to ensure that?\n\nThis seems complicated. Let's try to think of the problem differently. Let's model the problem as a directed graph where:\n\n- All edges are directed from parent to child in a tree structure. But since the graph can have cycles (but after directing, it must be acyclic), perhaps we can build a DAG.\n\nBut how?\n\nAnother approach: since the graph must be acyclic, we can assign directions such that the edges form a DAG. A common way to do this is to assign a topological order to the nodes. Once the order is fixed, all edges go from earlier nodes to later ones. So, the question becomes: can we find a topological order such that for each node (except source and sink), the sum of flows on edges going into the node from earlier nodes equals the sum of flows on edges going out to later nodes?\n\nBut how to find such an order?\n\nAlternatively, think of the nodes as having a potential (like in electrical circuits) such that for each node, the sum of flows on edges leaving it equals the sum of flows entering it. For the source, the sum of flows leaving is F, and for the sink, the sum entering is F.\n\nBut how to model this potential. Let's consider that each node has a value (potential) such that for any edge between u and v, the direction is from u to v if potential[u] < potential[v]. Then, the graph is acyclic (since the potential is a strict ordering). Then, for each node v (not source or sink), the sum of flows on edges leaving v (i.e., edges where v's potential is less than the other end's) must equal the sum of flows on edges entering v (i.e., edges where v's potential is higher than the other end's).\n\nSo, for each node v (not source or sink):\n\nsum_{edges from v to w} c_{v,w} = sum_{edges from u to v} c_{u,v} \n\nWhich can be rewritten as:\n\nsum_{edges incident to v} c_{e} * (direction) = 0 \n\nWhere direction is +1 if the edge is directed away from v, -1 otherwise.\n\nBut how to find the potential values that satisfy this equation for all nodes except source and sink?\n\nLet me think of this as a system of equations. For each node v (not source or sink), the sum of flows on edges directed away from v equals the sum of flows directed into v. Which is equivalent to:\n\nsum_{edges (u, v)} c_uv * (if directed from u to v, then it's part of the incoming flow for v. Or wait, if the edge is directed from v to u, then it's part of the outgoing flow of v.)\n\nAlternatively, for each node v, the net outflow is zero. The net outflow is the sum of flows on edges directed away from v minus the sum of flows on edges directed towards v. So:\n\nsum_{edges directed away from v} c_e - sum_{edges directed towards v} c_e = 0 \n\nWhich can be rewritten as:\n\nsum_{edges incident to v} c_e * (1 if directed away from v, -1 if directed towards v) = 0 \n\nBut how to model this with potentials. If the potential of v is higher than the potential of u, then the edge between u and v is directed from u to v (assuming that higher potential implies direction from lower to higher). Wait, no. If we have a potential function p, then for an edge between u and v, if p[u] < p[v], we direct the edge from u to v. Otherwise, from v to u. Then, the net outflow for node v is the sum of c_e for edges directed away from v minus the sum of c_e for edges directed into v.\n\nSo, for each node v, the net outflow is:\n\nsum_{edges (v, w) where p[v] < p[w]} c_{v,w} + sum_{edges (u, v) where p[u] > p[v]} c_{u,v} ?\n\nNo, wait. For each edge between u and v, if p[u] < p[v], then the edge is directed from u to v. So for node u, this contributes to outgoing flow (so +c), and for node v, this contributes to incoming flow (so -c). For node v, if there's an edge to w with p[v] < p[w], then that contributes to outgoing flow (+c). If there's an edge from x to v with p[x] < p[v], then that contributes to incoming flow (-c). So the net outflow for v is:\n\nsum_{edges directed away from v} c_e - sum_{edges directed towards v} c_e = 0 \n\nWhich can be rewritten as:\n\nsum_{edges incident to v} [c_e * (1 if directed away from v else -1)] = 0 \n\nBut how to relate this to the potentials. For each edge between u and v, the direction is determined by the potentials. If p[u] < p[v], then the edge is directed from u to v, contributing +c to u's outflow and -c to v's outflow. If p[u] > p[v], then it's directed from v to u, contributing +c to v's outflow and -c to u's outflow. If p[u] = p[v], then the direction is arbitrary, but the problem says that the solution exists, so perhaps we can assume that all potentials are distinct.\n\nAssuming all potentials are distinct, then for each edge between u and v, the direction is determined by p[u] and p[v]. Now, the net outflow for each node v (not source or sink) is zero. Let's express this in terms of potentials.\n\nFor node v, the net outflow is:\n\nsum_{edges (v, w)} c_{v,w} * [1 if p[v] < p[w]] - sum_{edges (u, v)} c_{u,v} * [1 if p[u] < p[v]] \n\nWait, this seems complicated. But perhaps we can find a way to model this as a system of equations. Let's think about the net outflow for node v being zero. For each edge between u and v, if p[u] < p[v], then the edge contributes +c to u's outflow and -c to v's outflow. If p[v] < p[u], then the edge contributes +c to v's outflow and -c to u's outflow. \n\nBut for the net outflow of v to be zero, the sum of contributions from all edges must be zero. Let's think of it as follows: for each edge between u and v, the contribution to the net outflow of v is:\n\nif p[v] < p[u], then the edge is directed from v to u, contributing +c to v's outflow (so +c) and -c to u's outflow. But for v's net outflow, this is +c.\n\nIf p[v] > p[u], then the edge is directed from u to v, contributing -c to v's outflow (because it's incoming to v).\n\nIf p[u] == p[v], then direction is arbitrary, but this case is avoided by assuming all potentials are distinct.\n\nSo for each edge (u, v), the contribution to v's net outflow is:\n\nif p[v] < p[u], then +c (since edge is directed from v to u, which adds to v's outflow).\n\nif p[v] > p[u], then -c (since edge is directed from u to v, which adds to v's inflow).\n\nSo the net outflow for v is the sum over all edges incident to v of:\n\nif p[v] < p[neighbor], then +c, else -c.\n\nBut for the net outflow to be zero, this sum must be zero.\n\nLet me define for each node v, the value S_v = sum_{edges incident to v} c_e * (sign based on potential difference). \n\nWe need S_v = 0 for all non-source/sink nodes.\n\nBut how to find potentials that satisfy this condition?\n\nThis seems like a system of equations that's hard to solve directly. However, there's a clever way to model this. Let's think of the potential p(v) as a variable for each node. For each edge between u and v, the contribution to the net outflow of u is +c if p[u] < p[v], else -c. Similarly for v. But how to express this in terms of p(u) and p(v)?\n\nWait, for each edge (u, v), the contribution to the net outflow of u is:\n\nif p[u] < p[v], then +c (since edge is directed from u to v, adding to u's outflow).\n\nif p[u] > p[v], then -c (since edge is directed from v to u, adding to u's inflow).\n\nSo, for each edge (u, v), the net outflow for u is increased by +c if p[u] < p[v], else decreased by c.\n\nBut how to model this for all edges. It seems challenging.\n\nAnother idea: Let's think of the net outflow for each node v as follows. Let’s define for each node v, the net outflow as:\n\nsum_{edges incident to v} (c_e * (1 if direction is away from v else -1)) = 0.\n\nBut this is equivalent to:\n\nsum_{edges incident to v} c_e * (direction) = 0.\n\nNow, if we consider the direction as determined by the potentials, then for each edge (u, v), the direction is determined by the sign of p[u] - p[v]. But how to relate this to the net outflow.\n\nAlternatively, think of the net outflow for node v as the sum over all edges incident to v of c_e multiplied by (1 if the edge is directed away from v, -1 otherwise). Let's denote this as D_v = 0 for non-source/sink nodes.\n\nBut how to find potentials p(v) such that D_v=0.\n\nBut perhaps we can model this as a system where the sum over all edges incident to v of c_e * (p(v) - p(w)) / |p(v) - p(w)| ) = 0. But this seems too abstract.\n\nAlternatively, think of this as a directed graph where the net outflow for each node (except source and sink) is zero. This is exactly the definition of a flow in a network, except that the flow values are fixed (ci for each edge), and the edges can be directed either way. So the problem reduces to finding a flow in the graph with fixed edge capacities (ci) that satisfies flow conservation. However, since the flow is already given (the ci values), it's more like finding a feasible flow.\n\nBut how to find such a flow. Well, this sounds like a flow decomposition problem. However, I'm not sure.\n\nAnother observation: the problem is similar to finding an Eulerian trail, but not quite. Because in an Eulerian trail, the in-degree equals out-degree for all nodes except start and end. Which is exactly what we need here, except that the edges are undirected and we can assign directions. So, if we can assign directions to the edges such that each node (except source and sink) has equal in-degree and out-degree, and the graph is acyclic, then we are done.\n\nBut how to do that?\n\nBut the problem isn't about degrees, but about the sum of flows. So, it's not about counting edges, but about the sum of their flows.\n\nBut maybe we can model this as a directed graph where for each node v (not source or sink), the sum of flows on edges directed away from v equals the sum of flows on edges directed towards v. This is similar to the condition for an Eulerian trail, but with weights.\n\nSo, for each node v (not source or sink), the total flow on edges incident to v must be even, because sum_in = sum_out implies that total_flow = 2*sum_in. But since the problem says that a solution exists, this must be true.\n\nBut how to proceed from here.\n\nAnother idea: since the graph is connected and we need to assign directions, perhaps we can perform a DFS traversal and assign directions based on the traversal. For example, during DFS, when we visit a node, we direct the edge from the parent to the child. However, this might not account for the flow conservation.\n\nBut what if we use the flow values to determine the direction. For example, during DFS, for each edge, we decide the direction based on the flow's contribution to the conservation of the nodes.\n\nAlternatively, think of the problem as building a directed graph where the edges are directed in such a way that the flow conservation holds. To do this, we can model this as a directed graph and perform a BFS or DFS, ensuring that the flow conservation is maintained.\n\nBut I'm not sure.\n\nLet me think of an example. Take the first sample input:\n\nn=3, m=3.\n\nEdges are:\n\n3-2 (10)\n\n1-2 (10)\n\n3-1 (5)\n\nThe output directions are 1, 0, 1. Let's see:\n\nFirst edge (3-2) is directed as 1, meaning from bi to ai. Original ai is 3, bi is 2. So direction is 2→3. So for edge 3-2, direction is 2→3.\n\nSecond edge (1-2) is directed as 0, meaning ai→bi: 1→2.\n\nThird edge (3-1) is directed as 1, meaning bi→ai. Original ai is 3, bi is 1. So direction is 1→3.\n\nNow, for node 2 (which is not source or sink), the incoming flows are from 1→2 (10) and from 2→3 (10)? No, wait:\n\nWait, node 2's incoming flows are from edges directed into it. Edge 1→2 is directed from 1 to 2, so contributes 10 to node 2's inflow. Edge 2→3 is directed from 2 to 3, so contributes 10 to node 2's outflow. What about the third edge? It's directed from 1 to 3, which is not connected to node 2. So for node 2, inflow is 10 (from 1) and outflow is 10 (to 3). So sum is equal. Correct.\n\nFor node 1, it has no incoming edges. Outgoing edges are 1→2 (10) and 1→3 (5). Total outflow is 15, which is the maximum flow.\n\nNode 3 has inflow of 10 (from 2) and 5 (from 1), total 15. Which is the total flow. So that's correct.\n\nNow, the directed graph has edges 1→2, 2→3, 1→3. This is a DAG with topological order 1, 2, 3. So it's acyclic.\n\nSo the approach used here was to assign directions in a way that forms a DAG, and ensures flow conservation. How was that achieved?\n\nPerhaps by building a DAG where the edges are directed from lower-numbered nodes to higher-numbered nodes. But in the sample, node 1 is the source, node 3 is the sink. The edges are directed in a way that follows this order. However, this may not always be possible.\n\nBut how to generalize this.\n\nMaybe the solution is to assign directions based on a topological order of the nodes. For example, assign a topological order where the source is first, the sink is last, and all other nodes are in between. Then, direct all edges from earlier nodes to later nodes. This would ensure that the graph is acyclic. Now, we need to ensure that for each node (except source and sink), the sum of flows on edges directed into it equals the sum of flows directed out of it.\n\nBut how to find such a topological order.\n\nThis seems like a chicken-and-egg problem. We need the topological order to ensure the flow conservation, but how to find it.\n\nAnother idea: since the graph is connected and the solution exists, we can construct a directed spanning tree rooted at the source, with edges directed away from the root. Then, for each node, the flow conservation can be ensured by adjusting the directions of the edges.\n\nBut how to do this.\n\nAlternatively, think of the problem as building a directed graph where each node (except source and sink) has equal inflow and outflow. This resembles a flow network, and perhaps we can model this as a flow problem where we need to find a flow that satisfies the conservation constraints.\n\nBut since the flow values are already given, perhaps we can treat the problem as finding a directed graph where for each edge, the flow is ci, and the conservation holds.\n\nBut how to find such a direction.\n\nLet me think of the problem as a directed graph where each edge has capacity ci and must be saturated. The flow conservation is required for all nodes except source and sink. So, this is exactly a flow problem where we need to find a flow that satisfies these constraints. However, since the flow is already given, perhaps this is trivial.\n\nWait, but the problem says that the given ci's are the flow volumes. So the flow is already fixed. So the problem reduces to assigning directions to edges such that the flow is valid.\n\nThis seems like a problem of finding an orientation of the edges such that the flow is valid. This is similar to finding an Eulerian orientation, but with weighted edges.\n\nBut how to find such an orientation.\n\nHere's an idea: for each node (except source and sink), the sum of flows on edges incident to it must be even. Because the sum of inflow and outflow is equal to twice the inflow (or outflow). So, for each such node, the total sum of flows on edges incident to it must be even. This must be true since the solution exists. \n\nBut how to use this to assign directions.\n\nLet me think of the following approach:\n\n1. For the source node (1), direct all its edges away from it. This ensures that the source has no incoming edges.\n\n2. For the sink node (n), direct all its edges towards it. But wait, the sink can have outgoing edges as well, but the flow conservation for the sink is not required. However, the sink's inflow must be equal to the total flow.\n\nBut how to ensure this.\n\nAlternatively, think of the problem as building a directed graph where:\n\n- All edges are directed in such a way that the flow conservation holds for intermediate nodes.\n\n- The graph is acyclic.\n\nTo achieve this, perhaps we can perform a BFS or DFS starting from the source, and assign directions to the edges as we traverse, ensuring that the flow conservation is maintained.\n\nLet me think of a possible algorithm:\n\nWe can model this as a directed graph, and perform a BFS/DFS. For each node, we keep track of the remaining flow that needs to be distributed. For example, for the source, we have a certain amount of flow to distribute. As we traverse the graph, we direct edges to carry flow from the current node to the next, adjusting the remaining flow accordingly.\n\nBut how to manage this.\n\nFor example, suppose we start at the source (node 1). We have a certain amount of flow to distribute. For each edge connected to node 1, we direct it away from node 1. Then, for each neighbor, we subtract the flow from the available flow at node 1, and add it to the neighbor's \"inflow\". Then, for each neighbor, we need to ensure that the inflow is balanced with outflow. But this seems like a recursive process.\n\nBut how to implement this.\n\nLet me think of this as a flow distribution problem. For each node, the net flow out (for non-source/sink) must be zero. So, for each node, the sum of flows on edges directed away from it must equal the sum of flows on edges directed towards it.\n\nLet me consider the following approach:\n\nWe can model the problem as a directed graph where we assign directions to edges in such a way that for each node, the sum of flows on edges directed away from it equals the sum of flows on edges directed towards it. We can do this by performing a traversal of the graph, and for each node, directing edges to balance the flows.\n\nLet's say we start with the source node. For the source, all edges are directed away from it. Then, for each neighbor, the flow is added to their inflow. For each such neighbor, we need to ensure that their inflow is balanced by their outflow. So, for example, if a neighbor has an inflow of 10, then we need to direct edges away from it to carry 10 units of flow.\n\nBut how to do this recursively.\n\nThis sounds like a problem that can be solved with a BFS or DFS, where for each node, we process its edges and direct them to balance the inflow and outflow.\n\nLet's formalize this idea:\n\nEach node has a \"balance\" which is the difference between the inflow and outflow. Initially, for the source, the balance is -F (where F is the total flow, since all edges are directed away from it, contributing to outflow). For the sink, the balance is +F. For other nodes, the balance starts at zero.\n\nWait, no. The balance for a node is the net outflow. For the source, it should be F (since all edges are directed away, so outflow is F). For the sink, it should be -F (inflow is F). For other nodes, it should be zero.\n\nBut how to model this balance during the traversal.\n\nLet me think of it as follows: for each node, we maintain a variable called \"excess\", which represents the amount of flow that needs to be sent out from this node. Initially, for the source, the excess is F (the total flow). For the sink, it's -F. For other nodes, it's zero.\n\nThen, for each node, we process its edges and direct them in a way that reduces the excess.\n\nFor example, consider a node u with a positive excess (needs to send out more flow). For each undirected edge between u and v, if v hasn't been processed yet, we can direct the edge from u to v, subtracting the flow from u's excess and adding it to v's excess. This way, u's excess decreases, and v's increases.\n\nThis is similar to the standard algorithm for finding an Eulerian trail, where we adjust the excesses by directing edges.\n\nLet's try to formalize this:\n\nInitialize a queue with the source node. For each node in the queue, while it has excess flow, look for an adjacent edge that hasn't been directed yet. Direct it from the current node to the adjacent node. Subtract the flow from the",
    "response": "\n\nTo solve this problem, we need to assign directions to edges in an undirected graph such that the resulting directed graph satisfies flow conservation at each vertex (except the source and sink), has no incoming edges at the source, and is acyclic.\n\n### Approach\n1. **Flow Conservation**: For each intermediate vertex (not the source or sink), the sum of flows on incoming edges must equal the sum of flows on outgoing edges.\n2. **Acyclic Graph**: The directed graph must be acyclic, which can be ensured by constructing a topological order.\n3. **Traversal and Direction Assignment**: Use a BFS traversal starting from the source to direct edges. Maintain an excess value for each node representing the net flow that needs to be sent out from that node. As we traverse, we direct edges from nodes with positive excess to their neighbors, adjusting their excess values accordingly.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    # We need to track the direction of each edge\n    direction = [0] * m\n\n    # Compute the total flow from the source\n    # All edges connected to the source must be directed away from it\n    # So first, let's compute the initial excess for each node\n    excess = [0] * (n + 1)\n    # For the source, the excess is the sum of all flows on its edges\n    # Because all edges from source are directed away\n    for a, b, c in edges:\n        if a == 1 or b == 1:\n            excess[1] += c\n\n    # Now, the sink will have negative excess\n    # But since we don't know yet, we'll process via BFS\n\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n\n    while q:\n        u = q.popleft()\n        while excess[u] != 0:\n            found = False\n            for v, idx in adj[u]:\n                if not visited[v]:\n                    # Direct the edge from u to v\n                    direction[idx] = 0 if (edges[idx][0] == u and edges[idx][1] == v) else 1\n                    # Subtract c from u's excess, add to v's\n                    c_val = edges[idx][2]\n                    excess[u] -= c_val\n                    excess[v] += c_val\n                    visited[v] = True\n                    q.append(v)\n                    found = True\n                    break\n            if not found:\n                break\n\n    # Output the directions\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into edges and adjacency lists.\n2. **Excess Calculation**: The initial excess for the source is calculated as the sum of all flows on its edges, as these edges must be directed away from the source.\n3. **BFS Traversal**: Using BFS starting from the source, we ensure that each node processes its excess flow by directing edges to neighboring nodes. This ensures that the flow conservation is maintained and the graph remains acyclic.\n4. **Direction Assignment**: During BFS traversal, edges are directed from the current node to its neighbor, adjusting the excess values of both nodes involved.\n\nThis approach ensures that the resulting directed graph meets all the required conditions for a valid maximum flow configuration.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    # We need to track the direction of each edge\n    direction = [0] * m\n\n    # Compute the total flow from the source\n    # All edges connected to the source must be directed away from it\n    # So first, let's compute the initial excess for each node\n    excess = [0] * (n + 1)\n    # For the source, the excess is the sum of all flows on its edges\n    # Because all edges from source are directed away\n    for a, b, c in edges:\n        if a == 1 or b == 1:\n            excess[1] += c\n\n    # Now, the sink will have negative excess\n    # But since we don't know yet, we'll process via BFS\n\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n\n    while q:\n        u = q.popleft()\n        while excess[u] != 0:\n            found = False\n            for v, idx in adj[u]:\n                if not visited[v]:\n                    # Direct the edge from u to v\n                    direction[idx] = 0 if (edges[idx][0] == u and edges[idx][1] == v) else 1\n                    # Subtract c from u's excess, add to v's\n                    c_val = edges[idx][2]\n                    excess[u] -= c_val\n                    excess[v] += c_val\n                    visited[v] = True\n                    q.append(v)\n                    found = True\n                    break\n            if not found:\n                break\n\n    # Output the directions\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 692,
        "completion_token_count": 856,
        "thoughts_token_count": 8191
    }
}