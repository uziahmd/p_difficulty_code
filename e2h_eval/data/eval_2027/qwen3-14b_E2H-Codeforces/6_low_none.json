{
    "start": 1758313550.76938,
    "end": 1758313600.2991881,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo the task is to find two vouchers that don't overlap, their durations add up exactly to x, and their total cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a duration of ri - li + 1. We need two vouchers i and j such that:\n\n- The sum of their durations is exactly x.\n- They don't overlap. Which means either ri < lj or rj < li.\n- Find the minimum cost of such pairs.\n\nConstraints are n up to 2e5, which is big. So any O(n^2) approach is out of the question. Need an efficient way.\n\nLet me think about how to approach this.\n\nThe key points are:\n\nFor each voucher, we need to find another voucher that doesn't overlap with it, and whose duration is (x - duration of current voucher). So for each voucher i with duration d, we look for vouchers with duration (x - d), and that don't overlap with it.\n\nBut how to efficiently find those?\n\nLet me think about grouping vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher, check if there's a duration (x - d) in the dictionary, and then find the minimal cost voucher in that group that doesn't overlap with the current one.\n\nBut even that approach may be too slow if not handled properly. Because for each voucher, checking all vouchers in the other group could be O(n) per voucher, leading to O(n^2) time.\n\nSo we need a way to find, for a given voucher, the minimal cost voucher in another group that doesn't overlap with it.\n\nWait, but maybe we can pre-process for each duration, the vouchers sorted in some way so that we can quickly find the minimal cost voucher that ends before the current voucher starts, or starts after the current voucher ends.\n\nLet me think. For example, suppose I have a group of vouchers with duration d'. For a given voucher i with duration d, where d + d' = x. For voucher i, which has a start li and end ri, I need to find vouchers in the d' group that end before li (so that their ri' < li), or start after ri (so their li' > ri). For each of these two cases, I need to find the minimum cost in the d' group that satisfies either condition.\n\nSo for each duration d', we can pre-process the vouchers in two sorted structures:\n\n- One sorted by their end time (ri'), so that for a given li, we can find all vouchers in d' that end before li. Among those, the minimal cost.\n\n- Another sorted by their start time (li'), so that for a given ri, we can find all vouchers in d' that start after ri. Among those, the minimal cost.\n\nIf we can do that, then for each voucher i with duration d, we can check if x - d exists in our duration map. If it does, then for that duration group, we can query the min cost for vouchers that end before li (so they don't overlap with voucher i) and the min cost for vouchers that start after ri (so they don't overlap with voucher i). Then take the minimum between those two possibilities.\n\nBut how to pre-process this?\n\nFor each duration group, let's say we have a list of vouchers. For each such list, we can sort them by their end time, and also keep a prefix minimum array. Similarly, sort them by their start time, and keep a suffix minimum array? Or perhaps for the first case (end before li), we can sort the vouchers in the group by their end time, and for a given li, find the maximum end time that is less than li. Then among all such vouchers, the minimal cost.\n\nWait, but how to find the minimal cost among all vouchers in the group that end before li?\n\nIf the vouchers in the group are sorted by their end time, then we can perform a binary search to find the largest end time that is less than li. Then all vouchers up to that index have end time <= li-1. But among them, we need the minimal cost. So for that, we can pre-process for each group a sorted list of end times, and a corresponding prefix minimum cost array.\n\nSimilarly, for the start time: for vouchers that start after ri, we can sort the vouchers in the group by their start time, and for a given ri, find the first start time that is greater than ri. All vouchers from that index onwards have start time >= ri+1. Again, we need the minimal cost among those.\n\nSo for each duration group, we can have two sorted lists:\n\n- Sorted by end time (ri), with a prefix min cost array. So when we",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. The solution involves efficiently querying for vouchers that meet the duration and non-overlapping criteria using preprocessing and binary search.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This helps in quickly finding vouchers that can complement a given voucher to meet the required total duration `x`.\n2. **Preprocess for Efficient Queries**: For each duration group, preprocess the vouchers to allow efficient queries:\n   - Sort vouchers by their end time and maintain a prefix minimum cost array.\n   - Sort vouchers by their start time and maintain a suffix minimum cost array.\n3. **Check Complementary Durations**: For each voucher, check if there exists another voucher with a duration that complements it to sum up to `x`. Use binary search on the preprocessed data to find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n\n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_map[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration d, we have:\n    # sorted_end: list of (end, min_cost_up_to_here)\n    # sorted_start: list of (start, min_cost_from_here)\n    # Also, for sorted_end, we sort by end, and for sorted_start by start\n    processed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Prepare sorted_end list\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Prepare sorted_start list\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 <= 0:\n            continue\n        if d2 not in processed:\n            continue\n        # Now check for vouchers with duration d2\n        sorted_end, prefix_min, sorted_start, suffix_min = processed[d2]\n\n        # Check for vouchers ending before l1\n        # Binary search in sorted_end for the largest end < l1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_left(ends, l1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n\n        # Check for vouchers starting after r1\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to quickly find potential complementary vouchers.\n- **Preprocessing**: Each group of vouchers is sorted by end time and start time, with corresponding prefix and suffix minimum cost arrays to allow efficient range minimum queries.\n- **Binary Search**: For each voucher, binary search is used to find the minimum cost of non-overlapping vouchers in the complementary duration group, ensuring efficient query times.\n\nThis approach ensures that we efficiently check all possible valid pairs of vouchers while maintaining a time complexity that is feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n\n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_map[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration d, we have:\n    # sorted_end: list of (end, min_cost_up_to_here)\n    # sorted_start: list of (start, min_cost_from_here)\n    # Also, for sorted_end, we sort by end, and for sorted_start by start\n    processed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Prepare sorted_end list\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Prepare sorted_start list\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 <= 0:\n            continue\n        if d2 not in processed:\n            continue\n        # Now check for vouchers with duration d2\n        sorted_end, prefix_min, sorted_start, suffix_min = processed[d2]\n\n        # Check for vouchers ending before l1\n        # Binary search in sorted_end for the largest end < l1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_left(ends, l1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n\n        # Check for vouchers starting after r1\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 732,
        "completion_token_count": 1040,
        "thoughts_token_count": 1024
    }
}