{
    "start": 1758008327.6287506,
    "end": 1758008502.7007818,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. So the task is to find two vouchers that don't overlap, their durations add up exactly to x, and the sum of their costs is as small as possible. If there's no such pair, output -1.\n\nFirst, I need to understand what the duration is. Oh right, the duration is ri - li + 1. So for each voucher, we can calculate that. Then, for two vouchers i and j, their durations should sum to x. Also, they must not overlap. Which means either the first ends before the second starts, or vice versa.\n\nSo the approach here is to find pairs of vouchers where one has duration d, the other has duration x - d, and they don't overlap. And find the minimum cost among all such pairs.\n\nBut how to do this efficiently? Because n can be up to 2e5, so O(n^2) is impossible. So we need an efficient way.\n\nLet me think. For each voucher, if we can find another voucher that has a duration of (x - duration_i), and that doesn't overlap with it. But how?\n\nMaybe we can pre-process vouchers by their duration. Let's group vouchers by their duration. Then, for each voucher with duration d, we look for vouchers with duration (x - d). But then, how to check if they don't overlap.\n\nWait, but for each voucher, we need to find the minimal cost voucher in the other group that doesn't overlap with it. But how?\n\nAlternatively, perhaps we can sort vouchers by their start and end times, and for each duration d, precompute some structures that allow us to query the minimal cost for vouchers with duration (x - d) that end before a certain time, or start after a certain time.\n\nLet me think. Suppose we have two durations d1 and d2 such that d1 + d2 = x. For each voucher with duration d1, we need a voucher with duration d2 that ends before the start of the first voucher, or starts after the end of the first voucher.\n\nSo for each voucher i with duration d, we can check for vouchers with duration (x - d) that end before li (so that they are before the current voucher starts), or start after ri (so that they are after the current voucher ends).\n\nBut how to efficiently find the minimal cost in those cases?\n\nLet me think about pre-processing. For each possible duration, we can have sorted lists of vouchers' end times and start times, along with their costs.\n\nFor example, for duration d, we can have a list of vouchers sorted by their end time. Then, for a voucher with duration d, when looking for vouchers with duration (x - d) that end before li, we can find the earliest end time that is less than li, and take the minimal cost in that subset.\n\nBut how to get the minimal cost for vouchers with duration (x - d) that end before a certain value?\n\nAlternatively, for each duration d, we can have two structures:\n\n- A sorted list of end times, and for each end time, track the minimum cost up to that point. Similarly, a sorted list of start times, and track the minimum cost from that point onwards.\n\nWait, maybe for each duration, we can sort the vouchers by their end time, and create a prefix minimum array. Then, given a target end time (like li - 1), we can binary search in the sorted end times to find the largest end time that is <= li - 1. Then, the prefix min up to that index would give the minimal cost for vouchers with that duration that end before li.\n\nSimilarly, for vouchers with duration (x - d), we can also have them sorted by start time, and have a suffix min array. Then, for a voucher that ends at ri, we can find the smallest start time that is >= ri + 1, and get the minimal cost in that suffix.\n\nSo the plan is:\n\n1. Preprocess all vouchers into groups based on their duration. For each duration, store two sorted lists:\n\n   a. One sorted by end time (ri), and for each position in this sorted list, keep track of the minimum cost up to that position. This allows us to quickly find the minimal cost for vouchers with that duration that end before a certain time.\n\n   b. Another sorted by start time (li), and for each position, keep track of the minimum cost from that position onwards. This allows us to find the minimal cost for vouchers with that duration that start after a certain time.\n\n2. For each voucher i with duration d, check if there exists a duration (x - d). If not, skip. Otherwise, for the vouchers with duration (x - d):\n\n   a. Find the minimal cost of vouchers that end before li (so they can be before voucher i). This is done by querying the prefix min array for duration (x - d) where end time <=",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, while minimizing the total cost. The solution involves efficiently grouping and querying vouchers based on their durations and time intervals.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly finding vouchers with a specific duration when needed.\n2. **Preprocessing for Efficient Querying**: For each duration, we maintain two sorted lists:\n   - One sorted by end time (`ri`) with a prefix minimum cost array to quickly find the minimum cost of vouchers ending before a certain time.\n   - Another sorted by start time (`li`) with a suffix minimum cost array to quickly find the minimum cost of vouchers starting after a certain time.\n3. **Check Valid Pairs**: For each voucher, check if there exists another voucher with a duration that complements it to sum up to `x`. Use the preprocessed data to efficiently find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Preprocess: group by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end time and create prefix min\n    # Also sort by start time and create suffix min\n    duration_info = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        duration_info[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    for l1, r1, cost1, d1 in vouchers:\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in duration_info:\n            continue\n        # Check for vouchers with duration d2 that end before l1\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = duration_info[d2]\n        # Find the largest end <= l1 - 1\n        ends = [item[1] for item in sorted_by_end]\n        idx_end = bisect.bisect_right(ends, l1 - 1) - 1\n        if idx_end >= 0:\n            min_cost = prefix_min[idx_end]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check for vouchers with duration d2 that start after r1\n        starts = [item[0] for item in sorted_by_start]\n        idx_start = bisect.bisect_left(starts, r1 + 1)\n        if idx_start < len(starts):\n            min_cost = suffix_min[idx_start]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n- **Prefix and Suffix Minimum Arrays**: These arrays help in efficiently finding the minimum cost of vouchers that end before or start after a specific time, using binary search.\n- **Binary Search**: Used to quickly locate valid vouchers that do not overlap with the current voucher, ensuring the solution is efficient even for large input sizes.\n\nThis approach ensures that we efficiently check all possible valid pairs of vouchers, leveraging preprocessing and binary search to keep the complexity manageable.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Preprocess: group by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end time and create prefix min\n    # Also sort by start time and create suffix min\n    duration_info = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        duration_info[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    for l1, r1, cost1, d1 in vouchers:\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in duration_info:\n            continue\n        # Check for vouchers with duration d2 that end before l1\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = duration_info[d2]\n        # Find the largest end <= l1 - 1\n        ends = [item[1] for item in sorted_by_end]\n        idx_end = bisect.bisect_right(ends, l1 - 1) - 1\n        if idx_end >= 0:\n            min_cost = prefix_min[idx_end]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check for vouchers with duration d2 that start after r1\n        starts = [item[0] for item in sorted_by_start]\n        idx_start = bisect.bisect_left(starts, r1 + 1)\n        if idx_start < len(starts):\n            min_cost = suffix_min[idx_start]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 731,
        "completion_token_count": 1014,
        "thoughts_token_count": 1023
    }
}