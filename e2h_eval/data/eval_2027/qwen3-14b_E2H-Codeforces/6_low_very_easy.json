{
    "start": 1758313547.0685894,
    "end": 1758313600.7043278,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nThe problem is about finding two non-overlapping vouchers whose total duration equals exactly x days, and their combined cost is minimized. If there's no such pair, return -1.\n\nSo the input is n vouchers, each with li (start day), ri (end day), and cost. The duration of a voucher is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations sum to x, and they don't overlap. And find the minimum total cost.\n\nFirst, I need to think about how to approach this efficiently. Since n can be up to 2e5, O(n²) approaches are definitely out of the question. So we need something smarter.\n\nLet me think about the constraints. For each voucher, its duration is d = ri - li + 1. Let's say for a voucher, we want to find another voucher with duration x - d, and that they don't overlap.\n\nSo the plan could be:\n\n- Preprocess all vouchers by their duration. For each possible duration d, keep track of the minimum cost for vouchers of that duration, and also possibly some information about their start and end times so that we can check for non-overlapping.\n\nBut how do we efficiently find for each voucher, if there exists another voucher with duration (x - d) that doesn't overlap with it?\n\nAlternatively, for each voucher with duration d, we can look for vouchers with duration (x - d) that end before the current voucher starts, or start after the current voucher ends.\n\nBut how do we efficiently find the minimal cost for such vouchers?\n\nLet me think. Let's group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration, sorted by their end time (or start time?), and also for each duration, keep track of the minimum cost up to certain points.\n\nWait, but for each voucher of duration d, we need to find vouchers of duration (x - d) that end before li (so that their end is before the current voucher starts) or start after ri (so that the current voucher ends before the other starts).\n\nSo for example, suppose we have a voucher A with duration d, which starts at lA and ends at rA. Then, we need to find vouchers B with duration (x - d) such that rB < lA (so B ends before A starts) or lB > rA (so B starts after A ends). The minimal cost of such B's would be the best option for pairing with A.\n\nTherefore, for each voucher A, if we can find the minimal cost of vouchers B with duration (x - d) that end before lA, or start after rA, then we can compute the total cost and track the minimum overall.\n\nBut how do we do this efficiently?\n\nLet me think about pre-processing. For each possible duration k, we can have two structures:\n\n- One sorted list of end times of vouchers with duration k, along with their minimal cost up to that end time. So for vouchers of duration k, sorted by end time, and for each position in the list, we can know the minimum cost among all vouchers up to that point. Then, for a given lA, we can binary search in the sorted end times of vouchers of duration (x - d) to find those with end time < lA. The minimal cost in that subset would be the minimal possible for B's that end before lA.\n\nSimilarly, for the other case, vouchers of duration k sorted by their start time, and for each start time, we can have the minimal cost of vouchers with start time >= some value. So for vouchers of duration k, sorted by start time, and for a given rA, find the minimal cost of vouchers with start time > rA.\n\nWait, but how to handle both cases?\n\nLet me outline the steps:\n\n1. Preprocess all vouchers, grouping them by their duration. So, for each duration d, we have a list of vouchers with that duration. For each such list, we can sort them by their end time and also by their start time. Also, for each sorted list, we can precompute prefix minimums for the end-sorted list and suffix minimums for the start-sorted list.\n\nWait, for example, for vouchers with duration k, sorted by end time, then for any query of \"find the minimal cost of vouchers with end time <= some value\", we can binary search to find the latest end time that is <= the value, and then take the prefix min up to that index. Similarly for the start time.\n\nAlternatively, for each duration k, we can have two sorted lists:\n\n- List1: sorted by end time. For each entry, we can have the end time and the cost. Also, we can precompute a prefix",
    "response": "To solve this problem, we need to find two non-overlapping travel vouchers such that their combined duration equals a given number of days `x`, and their total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently checking for pairs of vouchers whose combined duration equals `x`.\n2. **Preprocess for Efficient Lookup**: For each duration, we maintain two sorted lists:\n   - One sorted by the end time of the vouchers.\n   - Another sorted by the start time of the vouchers.\n3. **Prefix and Suffix Minimums**: For each sorted list, we precompute prefix minimums (for end-sorted lists) and suffix minimums (for start-sorted lists). This allows us to quickly determine the minimum cost of vouchers that end before a certain date or start after a certain date.\n4. **Check Valid Pairs**: For each voucher, check if there exists another voucher with a duration that complements it to sum up to `x`. Use the preprocessed lists to efficiently find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by end and start, with prefix min and suffix min\n    # For each duration, we have:\n    # - sorted_end: list of (end, cost), sorted by end\n    # - prefix_min: list where prefix_min[i] is the min cost in sorted_end[0..i]\n    # - sorted_start: list of (start, cost), sorted by start\n    # - suffix_min: list where suffix_min[i] is the min cost in sorted_start[i..end]\n\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0]*len(sorted_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_start[i][2])\n            suffix_min[i] = min_so_far\n        processed[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Check for vouchers with duration target_d that end before l1 or start after r1\n        sorted_end, prefix_min, sorted_start, suffix_min = processed[target_d]\n        # Check end before l1\n        # Binary search in sorted_end for the largest end <= l1-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost1)\n        # Check start after r1\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by their start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient lookup.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end time and start time. Prefix and suffix minimums are precomputed to quickly determine the minimum cost of valid non-overlapping vouchers.\n4. **Finding Valid Pairs**: For each voucher, we check if there exists another voucher with a complementary duration. Using binary search, we efficiently find the minimum cost of valid non-overlapping vouchers and update the minimum total cost accordingly.\n\nThis approach ensures that we efficiently check all possible valid pairs while maintaining an optimal time complexity.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by end and start, with prefix min and suffix min\n    # For each duration, we have:\n    # - sorted_end: list of (end, cost), sorted by end\n    # - prefix_min: list where prefix_min[i] is the min cost in sorted_end[0..i]\n    # - sorted_start: list of (start, cost), sorted by start\n    # - suffix_min: list where suffix_min[i] is the min cost in sorted_start[i..end]\n\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0]*len(sorted_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_start[i][2])\n            suffix_min[i] = min_so_far\n        processed[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Check for vouchers with duration target_d that end before l1 or start after r1\n        sorted_end, prefix_min, sorted_start, suffix_min = processed[target_d]\n        # Check end before l1\n        # Binary search in sorted_end for the largest end <= l1-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost1)\n        # Check start after r1\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1162,
        "thoughts_token_count": 1024
    }
}