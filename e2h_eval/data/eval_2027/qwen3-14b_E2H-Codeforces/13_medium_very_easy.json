{
    "start": 1758019433.7702036,
    "end": 1758021514.6213214,
    "start-formatted": "2025-09-16 19:43 KST",
    "end-formatted": "2025-09-16 20:18 KST",
    "gpu": 2,
    "pid": 13,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if a given set of three musical notes forms a major triad, minor triad, or is strange. The input is three notes, and I have to check all possible orderings to see if any of them fit the major or minor conditions.\n\nFirst, I need to understand how the distances between the notes are calculated. The notes are arranged in a cyclic order of 12 notes. Each consecutive note is a semitone apart, which is 0.5 tones. Wait, but the problem says that the distance between two consecutive notes is one semitone, which is 0.5 tone? Wait, maybe there's confusion here. Wait, the problem says that the distance between consecutive notes is one semitone, and that the distance between C and E is 4 semitones. Let me check that.\n\nFor example, C to C# is 1 semitone. Then C to D is 2, and so on. So C to D# is 3 semitones? Wait, no. Let's think: the order is C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, then between C and E, there are four steps. Let me count:\n\nC to C# is 1, C# to D is 2, D to D# is 3, D# to E is 4. Oh right, so the distance between C and E is 4 semitones. So the problem says that for a major triad, X to Y is 4 semitones, Y to Z is 3. Then X to Z would be 7 (since 4+3=7). But since the notes are cyclic, we need to calculate the distances properly.\n\nSo the first thing I need to do is map each note to its position in the sequence. Let's create a list of the notes in order, and then for any two notes, compute the distance between them as the number of steps from the first to the second in the cyclic order.\n\nWait, but the problem says that the distance is measured from the lower to the upper note. So for example, between C and E, it's 4 semitones. But between E and C, it's 8 semitones (since the total circle is 12 semitones). So when calculating the distance between two notes, it's the number of steps moving forward (i.e., in the order of the list) from the first to the second. So if the first note is X and the second is Y, the distance is (Y's index - X's index) mod 12? No, wait, because if X is after Y in the list, then the distance would be (Y's index + 12 - X's index) ?\n\nWait, for example, let's say X is E (index 4) and Y is C (index 0). The distance from E to C would be (0 -4) mod 12? No, that's negative. Wait, but the distance is measured from the lower to the upper. So if you have two notes, the distance is the minimal number of steps going forward. Wait no, the problem says that the distance between X and Y is calculated as follows: if you take the lower note (in the scale) and move up to the higher note, the number of semitones. So for example, between C and E, it's 4 semitones. Between E and C, the distance is 8 semitones, because you have to go from E to F (1), F to F# (2), etc., up to C. Which is 8 steps.\n\nSo the distance between X and Y is (Y's position - X's position) mod 12? No, because if Y is after X in the list, then that's the difference. But if Y is before X, then the distance would be (Y's position + 12 - X's position). For example, X is E (position 4), Y is C (position 0). The distance is (0 + 12 - 4) = 8 semitones. So the formula for the distance from X to Y is (y_index - x_index) if y_index >= x_index, else (y_index + 12 - x_index). Alternatively, it can be written as (y_index - x_index) % 12? Wait, no. Because if y_index is less than x_index, then (y_index - x_index) is negative, and mod 12 would give the same as adding 12. For example, (0 -4) mod 12 is 8. So yes, the distance between X and Y is (y_index - x_index) mod 12. Wait, but that would be the number of semitones when moving forward from X to Y. So for example, if X is C (0), Y is E (4), then 4-0=4 mod 12 is 4. Correct. If X is E (4), Y is C (0), then 0-4 = -4 mod 12 is 8. Which is correct. So yes, the distance from X to Y is (y_index - x_index) mod 12. But since the problem says that the distance is measured from the lower note to the upper note, but in the case where X is lower than Y, then the distance is positive. So the formula is correct.\n\nBut how do I compute this for any pair of notes?\n\nSo first, I need to assign each note to an index. Let's create a list of the notes in order. Let me check the order again:\n\nThe problem says the order is C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, wait, what about B and H? Oh, in some countries, B is called H. So the order is:\n\nNotes in order: C, C#, D, D#, E, F, F#, G, G#, A, B, H. Then after H comes C again.\n\nWait, but in the problem statement, the list is given as C, C#, D, D#, E, F, F#, G, G#, A, B, H. So the indexes are 0 to 11.\n\nSo I can create a list like this:\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nWait, but then the index of B is 10, H is 11. Then, for example, the distance from B to H is (11 - 10) = 1 semitone. From H to B would be (10 - 11) mod 12 = ( -1 ) mod 12 = 11 semitones. Which makes sense.\n\nSo first, I need to create a mapping from note names to their indexes. So for each note in the input, I can find its index in this list.\n\nOnce I have the indexes, for any three notes, I need to check all possible permutations of the three notes to see if any permutation satisfies the major or minor condition.\n\nBut since the chord is unordered, the three notes can be arranged in any order. So for the three notes, I need to check all possible orderings (permutations) of the three notes, and see if any of them meets the major or minor condition.\n\nBut how many permutations are there? For three elements, there are 3! = 6 permutations. However, for checking major and minor, we need to check if there exists an ordering X, Y, Z such that:\n\nFor major: distance between X and Y is 4 semitones, and between Y and Z is 3 semitones.\n\nFor minor: distance between X and Y is 3 semitones, and between Y and Z is 4 semitones.\n\nSo for each permutation of the three notes, check these two possibilities.\n\nBut perhaps there's a smarter way than checking all permutations. For example, for the three notes, we can check all possible pairs for X and Y, then check if the remaining note is Z. But perhaps generating all permutations is easier.\n\nAlternatively, for the three notes, we can generate all possible orderings (X, Y, Z) and check if any of them meets the major or minor conditions.\n\nBut how to generate all permutations? Well, in Python, itertools.permutations can be used.\n\nSo the plan is:\n\n1. Read the three input notes.\n\n2. For each note, find their index in the notes_order list.\n\n3. Generate all permutations of the three notes (each permutation is a possible ordering of X, Y, Z).\n\n4. For each permutation, check:\n\n   a. For major: distance between X and Y is 4, and between Y and Z is 3.\n\n   b. For minor: distance between X and Y is 3, and between Y and Z is 4.\n\n5. If any permutation satisfies major, then output \"major\".\n\n6. Similarly for minor.\n\n7. If neither, output \"strange\".\n\nBut since the problem says that the answer is unambiguous, there's no case where both major and minor are possible.\n\nNow, the question is how to compute the distance between two notes.\n\nSo for two notes, say note1 and note2, their indexes are idx1 and idx2. The distance from note1 to note2 is (idx2 - idx1) % 12. Wait, but according to the problem description, the distance is measured from the lower note to the upper note. However, the formula (idx2 - idx1) mod 12 gives the number of semitones when moving forward from note1 to note2. For example, if note1 is C (0) and note2 is E (4), the distance is 4. If note1 is E (4) and note2 is C (0), the distance is (0 -4) mod 12 = 8. Which is correct.\n\nSo yes, the distance between X and Y is (idx_y - idx_x) mod 12. So for each pair of notes, we can compute that.\n\nSo for each permutation (X, Y, Z), compute distance between X and Y, then between Y and Z.\n\nNow, for the major triad, the distance between X and Y must be 4, and between Y and Z must be 3. So for that permutation, check if (distance(X,Y) == 4) and (distance(Y,Z) ==3). If so, then it's a major triad.\n\nSimilarly for minor: check if distance(X,Y) is 3 and distance(Y,Z) is 4.\n\nSo the code steps:\n\nFirst, create a dictionary mapping note names to their indexes.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\nThen, read the input. The input is three space-separated notes. For example, the first example input is ['C E G', 'C# B F', 'A B H'] — but wait, the input is a single line with three notes. Wait, the problem says that the input is the only line contains 3 space-separated notes. So for example, in the sample input, the input is something like \"C E G\" (but the sample shows that the input is a list of three examples, but perhaps that's just for the example. The actual input is a single line with three notes.)\n\nWait, the sample input shows:\n\nInput:\n\n['C E G', 'C# B F', 'A B H']\n\nOutput:\n\n['major', 'minor', 'strange']\n\nBut perhaps that's a list of test cases, not the actual input. So the actual input for each test case is a single line with three notes.\n\nSo for example, in the first case, the input is \"C E G\", which is split into three notes.\n\nSo, in the code, I need to read a line, split into three notes.\n\nSo in Python, the code would be:\n\nimport sys\n\nfrom itertools import permutations\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().split()\n\nThen, for the three notes, get their indexes.\n\nBut wait, the input may have notes like 'B' or 'H', which are in the list.\n\nOnce we have the three indexes, say a, b, c.\n\nThen, generate all permutations of the three indexes. For each permutation (x, y, z):\n\nCheck for major:\n\ndistance_xy = (y - x) % 12\n\ndistance_yz = (z - y) % 12\n\nif distance_xy == 4 and distance_yz == 3 → major.\n\nSimilarly for minor: distance_xy == 3 and distance_yz ==4.\n\nIf any permutation satisfies either condition, then return the corresponding result.\n\nSo, code steps:\n\nRead the three notes.\n\nFor each note, get their index.\n\nGenerate all permutations of the three indexes.\n\nCheck for each permutation:\n\nCheck for major and minor.\n\nIf any permutation meets major → output 'major'.\n\nIf any permutation meets minor → output 'minor'.\n\nElse → 'strange'.\n\nBut how to generate permutations? For example, for the three indexes, say [a, b, c], permutations would be all possible orderings.\n\nIn Python, itertools.permutations can be used. For example, permutations([a, b, c], 3) gives all possible orderings.\n\nSo, code:\n\nfrom itertools import permutations\n\n...\n\nindexes = [note_to_index[note] for note in input_notes]\n\nfound_major = False\n\nfound_minor = False\n\nfor perm in permutations(indexes):\n\n    x, y, z = perm\n\n    # check for major\n\n    d1 = (y - x) % 12\n\n    d2 = (z - y) % 12\n\n    if d1 == 4 and d2 == 3:\n\n        found_major = True\n\n    if d1 == 3 and d2 ==4:\n\n        found_minor = True\n\nif found_major:\n\n    print(\"major\")\n\nelif found_minor:\n\n    print(\"minor\")\n\nelse:\n\n    print(\"strange\")\n\nWait, but for each permutation, we check if it meets major or minor. However, even if one permutation meets major, we can immediately return 'major' as the answer. Similarly for minor.\n\nBut since the problem says that the answer is unambiguous, there's no case where both are possible. So once any permutation meets major, we can return 'major' regardless of other permutations.\n\nBut in code, the code above checks all permutations, but once any permutation meets major, found_major becomes True, and same for minor.\n\nBut perhaps there's a case where multiple permutations meet the same condition. But the code will capture that.\n\nBut the problem says that the answer is always unambiguous, so the code can safely check all permutations and if any permutation meets major, then output major, etc.\n\nBut for example, in the first sample input, 'C E G' → indexes are 0, 4, 7.\n\nLet's check permutations.\n\nOne permutation is (0, 4, 7). Then:\n\nd1 = 4-0 =4 → mod 12 is 4. d2 is 7-4=3. So yes, major. So found_major is True.\n\nAnother permutation may be (4, 7, 0). Then d1 is (7-4)=3, d2 is (0-7) mod 12 → (0-7) is -7 mod 12 is 5. So no.\n\nAnother permutation could be (0,7,4). d1 is 7-0=7 mod 12 is 7. Not 4 or 3. So no.\n\nSo the code would find that found_major is True.\n\nSo the code would output 'major'.\n\nAnother example: 'C# B F' → the notes are C#, B, F.\n\nLet's get their indexes. C# is index 1. B is index 10. F is index 5.\n\nSo indexes are [1, 10, 5].\n\nLooking for permutations. One possible permutation is B, C#, F → indexes 10, 1, 5.\n\nCheck:\n\nd1 = (1 - 10) mod 12 → (1 -10) is -9 mod 12 is 3. So d1 is 3. Then d2 is (5 - 1) mod 12 → 4. So that's 3 and 4 → minor. So found_minor is True.\n\nThus, the code would output 'minor'.\n\nAnother example: 'A B H' → indexes are A is 9, B is 10, H is 11.\n\nCheck permutations. Let's take all permutations.\n\nFor example, (9, 10, 11): d1 is 1, d2 is 1. No.\n\nAnother permutation: (9, 11, 10). d1 is 11-9=2 mod 12 is 2. d2 is 10-11 = -1 mod 12 is 11. No.\n\nAnother permutation: (10, 9, 11). d1 is (9-10) mod 12 → 11. No.\n\nAnother permutation: (10, 11, 9). d1 is 1, d2 is 9-11 = -2 mod 12 → 10. No.\n\nAnother permutation: (11, 9, 10). d1 is (9-11) mod 12 → -2 mod 12 is 10. No.\n\nAnother permutation: (11, 10, 9). d1 is 10-11 = -1 mod 12 → 11. d2 is 9-10 → -1 mod 12 → 11. No.\n\nSo none of the permutations meet the major or minor conditions. So output is 'strange'.\n\nWhich matches the sample.\n\nSo the code seems to work.\n\nNow, possible edge cases: what if the same note is repeated? But the problem says that the input is three notes. However, the problem says that a chord is an unordered set of no less than three notes. But for the problem, the input is three notes. But the problem says that the answer is unambiguous. However, the problem says that the input will be three notes. But what if two or all three are the same? For example, input is C C C. Then, for any permutation, the distances between X and Y is zero. So no major or minor. So output is strange.\n\nAnother case: input is C, E, G. Which is major.\n\nAnother case: input is C, E, G#. Let's see. For example, check permutations. Let's take C (0), E (4), G# (8). Check permutations:\n\nFor (0,4,8): d1 is 4, d2 is 4. So not major (needs 4 and 3). So no. What about (0, 8, 4)? d1 is 8-0=8 mod 12 is 8. Not 4. So no. So this would be strange.\n\nNow, the code needs to process the input correctly.\n\nNow, the code needs to handle the note names correctly. For example, note_to_index must have all the correct note names. Let me check the order again:\n\nThe problem says the notes are ordered as C, C#, D, D#, E, F, F#, G, G#, A, B, H. So the list is:\n\n['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nYes. So the note_to_index should have 'B' as index 10, 'H' as index 11.\n\nSo that's correct.\n\nNow, code-wise, the code would be:\n\nImporting permutations from itertools.\n\nBut the code must read the input from stdin, process it, and output the answer.\n\nSo the code:\n\nimport sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_notes = sys.stdin.readline().split()\n    \n    indexes = [note_to_index[note] for note in input_notes]\n    \n    found_major = False\n    found_minor = False\n    \n    for perm in permutations(indexes):\n        x, y, z = perm\n        d1 = (y - x) % 12\n        d2 = (z - y) % 12\n        if d1 == 4 and d2 == 3:\n            found_major = True\n        if d1 == 3 and d2 ==4:\n            found_minor = True\n    \n    if found_major:\n        print(\"major\")\n    elif found_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n\nWait, but the code checks all permutations. However, once found_major is True, even if other permutations may also satisfy, but since the problem says that the answer is unambiguous, it's okay.\n\nBut for example, suppose there are two permutations that satisfy major and one that satisfies minor. But according to the problem statement, this can't happen. So the code can safely check all permutations and then decide based on whether any of them met the condition.\n\nBut in practice, the code will check all permutations and set found_major and found_minor flags. However, since the problem says that the answer is unique, the code will not have both flags set.\n\nBut the code checks for found_major first, then found_minor. So if a permutation meets both conditions (which is impossible according to the problem statement), but the code would output 'major' in that case.\n\nBut according to the problem statement, there are no such cases.\n\nTesting the sample input:\n\nSample input: 'C E G' → indexes 0,4,7. Permutations:\n\nFor (0,4,7): d1=4, d2=3 → major. So found_major is True.\n\nSample input 'C# B F' → indexes 1, 10, 5. One of the permutations is (10, 1, 5). d1 is (1-10) mod 12 → (1-10) is -9 mod 12 is 3. d2 is (5-1) =4 → so minor. So found_minor is True.\n\nThird sample input 'A B H' → indexes 9, 10, 11. All permutations checked, no conditions met. Output 'strange'.\n\nSo the code works for the sample.\n\nWhat about a case where the same note is present? Like 'C C C'? The indexes are [0,0,0]. For any permutation, x, y, z are all 0. d1 is 0, d2 is 0. So no major or minor. Output 'strange'.\n\nAnother test case: 'C E G#'. Let's see. C is 0, E is 4, G# is 8. Check permutations.\n\nCheck (0,4,8): d1=4, d2=4 → no. (0,8,4): d1 is 8-0=8 mod 12 is 8. d2 is 4-8 mod 12 is (4-8) = -4 mod 12 is 8. No. (4, 0, 8): d1 is 0-4 mod 12 is 8. No. (4, 8, 0): d1 is 4. d2 is (0-8) mod 12 → 4. So d1 is 4, d2 is 4. No. (8, 0, 4): d1 is 0-8 mod 12 is 4. d2 is 4-0=4. No. (8,4,0): d1 is 4-8 mod 12 → (4-8) is -4 mod 12 → 8. No. So output 'strange'.\n\nAnother test case: 'C# E G' → indexes 1, 4, 7. Let's check permutations. For example, (1,4,7): d1 is 3, d2 is 3. No. (1,7,4): d1 is 6, d2 is (4-7) mod 12 is 9. No. (4, 1, 7): d1 is (1-4) mod 12 → 9. No. (4,7,1): d1 is 3, d2 is (1-7) mod 12 → 6. No. (7,1,4): d1 is (1-7) mod 12 → 6. No. (7,4,1): d1 is (4-7) mod 12 → 9. No. So output strange.\n\nAnother test case for minor: 'B C# F' → indexes 10, 1, 5. Let's check permutation (10,1,5). d1 is (1-10) mod 12 → (1-10) = -9 → mod 12 is 3. d2 is (5-1) mod 12 → 4. So this is minor. So code returns minor.\n\nAnother case: 'C E G' is major. So code returns major.\n\nSo the code seems to handle all cases.\n\nNow, possible issues:\n\n- Are the note names in the input exactly as per the problem's list? For example, 'C#' is allowed, but what if the input has 'Db'? According to the problem statement, the input will be in the given notation, so the code doesn't need to handle alternative names like Db. So the code can assume that the input notes are in the format given (like C#, D#, etc.)\n\nAnother possible issue: the code uses permutations, which generates all possible orderings. However, since the problem says that the chord is unordered, but the code checks all permutations, which is correct.\n\nAnother possible optimization: since for three notes, there are 6 permutations, but perhaps some can be checked in a smarter way. However, for the problem's constraints, this is acceptable.\n\nSo the code is correct.\n",
    "response": "\n\nTo solve this problem, we need to determine if a given set of three musical notes forms a major triad, minor triad, or neither. The solution involves checking the distances between the notes in all possible permutations to see if they meet the criteria for major or minor triads.\n\n### Approach\n1. **Mapping Notes to Indices**: Convert each note into an index based on its position in the cyclic sequence of musical notes.\n2. **Distance Calculation**: Calculate the distance between two notes using their indices. The distance is determined by the number of semitones between them in the cyclic order.\n3. **Permutations Check**: For each permutation of the three notes, check if the distances between consecutive notes in the permutation meet the criteria for a major or minor triad.\n4. **Determine Result**: Based on the checks, determine if the chord is major, minor, or strange.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_notes = sys.stdin.readline().split()\n    \n    indexes = [note_to_index[note] for note in input_notes]\n    \n    found_major = False\n    found_minor = False\n    \n    for perm in permutations(indexes):\n        x, y, z = perm\n        d1 = (y - x) % 12\n        d2 = (z - y) % 12\n        if d1 == 4 and d2 == 3:\n            found_major = True\n        if d1 == 3 and d2 == 4:\n            found_minor = True\n    \n    if found_major:\n        print(\"major\")\n    elif found_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Mapping Notes**: The `notes_order` list defines the sequence of musical notes, and `note_to_index` maps each note to its corresponding index for quick lookup.\n2. **Reading Input**: The input is read and split into three notes, which are then converted into their respective indices.\n3. **Permutations Check**: Using `itertools.permutations`, all possible orderings of the three notes are checked. For each permutation, the distances between consecutive notes are calculated.\n4. **Distance Calculation**: The distance between two notes is computed using modulo arithmetic to handle the cyclic nature of the musical scale.\n5. **Check Conditions**: For each permutation, we check if the distances match the criteria for a major or minor triad. If any permutation meets the criteria, the corresponding flag (`found_major` or `found_minor`) is set to `True`.\n6. **Output Result**: Based on the flags, the result is printed as \"major\", \"minor\", or \"strange\".\n\nThis approach ensures that all possible configurations of the three notes are checked efficiently, leveraging permutations and modular arithmetic to handle the cyclic nature of the musical scale.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_notes = sys.stdin.readline().split()\n    \n    indexes = [note_to_index[note] for note in input_notes]\n    \n    found_major = False\n    found_minor = False\n    \n    for perm in permutations(indexes):\n        x, y, z = perm\n        d1 = (y - x) % 12\n        d2 = (z - y) % 12\n        if d1 == 4 and d2 == 3:\n            found_major = True\n        if d1 == 3 and d2 == 4:\n            found_minor = True\n    \n    if found_major:\n        print(\"major\")\n    elif found_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 683,
        "completion_token_count": 668,
        "thoughts_token_count": 5828
    }
}