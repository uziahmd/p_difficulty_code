{
    "start": 1758022368.6093192,
    "end": 1758025932.7389834,
    "start-formatted": "2025-09-16 20:32 KST",
    "end-formatted": "2025-09-16 21:32 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (which is 1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm. \n\nFirst, I need to think about the approach here. Since the weights are limited to 1, 2, or 3, maybe there's a way to optimize based on that. Because if all items had arbitrary weights, we'd need a standard knapsack solution, but with n up to 1e5 and m up to 3e5, a standard O(nm) DP approach would be too slow. But since the weights are small, perhaps we can find a way to handle them efficiently.\n\nLet me think. Let's consider grouping the items by their weight. For each weight category (1, 2, 3), we can sort the items in descending order of cost. Then, for each weight group, we can precompute the prefix sums so that we can quickly determine the maximum value when taking a certain number of items from that group.\n\nFor example, for weight 1 items, if we take k items, we can get the sum of the top k costs. Same for weight 2 and 3. Then the problem becomes selecting how many items to take from each group such that the total weight is ≤ m, and the sum of their values is maximized.\n\nBut how do we combine these choices efficiently? Let's think about possible combinations.\n\nLet me outline the steps:\n\n1. Separate the items into three groups based on their weight: w1, w2, w3.\n2. Sort each group in descending order of cost. Then compute prefix sums for each group. For example, for group w1, prefix_sum[i] is the sum of the first i items. This allows us to quickly calculate the value for taking any number of items from that group.\n3. Now, the problem reduces to choosing x items from w1, y items from w2, z items from w3, such that x*1 + y*2 + z*3 ≤ m, and the total value is maximized.\n\nBut considering all possible combinations of x, y, z would be computationally expensive. However, since the weights are small, maybe we can find a way to iterate through possible counts of two groups and compute the third.\n\nAlternatively, since the weight of each item is small, maybe we can use dynamic programming with a state that considers the possible weight up to m. But even that might be tricky because m is up to 3e5, and for each weight, we have to process all items. Wait, but the items are grouped by weight. Let me think again.\n\nAnother approach: For each possible number of weight 3 items, we can compute how much weight is left and then solve for weight 1 and 2 items. But even that could be expensive. Let's think about the possible ranges.\n\nFor example, the maximum number of weight 3 items is min( len(w3), m//3 ). Let's say that's up to around 1e5. But even that, for each possible count of weight 3 items, then for the remaining weight, we can try to compute the best combination of weight 1 and 2 items.\n\nBut how to compute the best combination of weight 1 and 2 items for a given remaining capacity?\n\nLet me think about that. Suppose after taking some weight 3 items, we have a remaining capacity of 'rem'. How do we find the best combination of weight 1 and 2 items?\n\nLet me think of it as a knapsack problem where items have weights 1 and 2, and we can take any number of them. But since the items are sorted, maybe we can find an optimal way.\n\nFor example, for a given rem, the optimal choice would be to take as many high-value items as possible. But how?\n\nLet me consider that for the weight 1 and 2 items, we can precompute their prefix sums. Let's say we have prefix1 for weight 1 items (each item has weight 1), and prefix2 for weight 2 items (each item has weight 2). Now, for a given rem, the problem is to choose a number of weight 1 items (a) and weight 2 items (b) such that a + 2*b <= rem. The maximum value would be prefix1[a] + prefix2[b], and we need to find the maximum over all valid a and b.\n\nBut how to compute this efficiently for each rem?\n\nLet me think of the following approach. For each possible number of weight 2 items (b), the maximum number of weight 1 items is (rem - 2*b). So for each b in 0 to min(len(prefix2), rem//2), we can take the maximum a as min( (rem - 2*b), len(prefix1) ), and then take the sum of prefix1[a] + prefix2[b].\n\nBut iterating over all possible b for each rem might be feasible if the number of weight 2 items is small. However, if rem is up to 3e5, and for each rem we have to check O(k) possibilities (where k is the number of weight 2 items), that could be expensive.\n\nWait, but perhaps for each possible rem, the maximum possible b is up to rem//2. However, if the number of weight 2 items is large (like up to 1e5), then this approach would be O(1e5) per rem, which is not feasible.\n\nAlternative idea: For the weight 1 and 2 items, we can precompute for each possible total weight up to m, the maximum value possible using those items. But how?\n\nBut since the weight is up to 3e5, and for each weight, we can compute the maximum value using the weight 1 and 2 items. Let's think of this as another knapsack problem. However, since the items are sorted, perhaps we can compute this in an optimized way.\n\nAlternatively, for the weight 1 and 2 items, we can precompute for each possible total weight, the maximum value. But how?\n\nLet me think. For the weight 1 items, since they are sorted, taking as many as possible gives the maximum value. Similarly for weight 2 items. However, combining them is more complex.\n\nWait, here's a possible approach. For each possible number of weight 2 items (say, up to len(w2)), we can compute the maximum number of weight 1 items that can fit into the remaining weight. Then, for each possible b (number of weight 2 items), we can compute the maximum a (number of weight 1 items) as min( (rem - 2*b), len(w1) ), and take the sum of prefix1[a] + prefix2[b]. Then, the maximum over all possible b would be the answer for that rem.\n\nBut the problem is that for each rem, we need to find the best combination. However, if we can precompute for all possible numbers of weight 2 items and then for each possible rem, compute the best possible, but I'm not sure.\n\nAlternatively, for each possible number of weight 2 items (let's say up to k), we can compute the maximum possible number of weight 1 items that can be taken for a given rem. But how to do that efficiently.\n\nAlternatively, since the weight 1 items are sorted, and the weight 2 items are also sorted, perhaps for a given total weight capacity (let's call it cap), the optimal way is to take as many weight 2 items as possible, but sometimes replacing some of them with weight 1 items.\n\nWait, but how to find that balance. For example, suppose cap is 5. If I take two weight 2 items (total weight 4), and one weight 1 item (total weight 5). Or take one weight 2 item (weight 2) and three weight 1 items (weight 3). Which is better depends on the actual values.\n\nBut with the prefix sums, perhaps we can find for each possible cap, the best combination.\n\nBut again, how to compute this efficiently.\n\nLet me think of the following approach. For each possible cap (which is the remaining weight after handling weight 3 items), the maximum value can be computed as follows:\n\nLet's assume that we have prefix1 for weight 1 items, and prefix2 for weight 2 items.\n\nWe can iterate over the possible number of weight 2 items (b) that we can take. For each b, the maximum number of weight 1 items is a = min( (cap - 2*b), len1 ), where len1 is the number of weight 1 items.\n\nThe total value is prefix1[a] + prefix2[b].\n\nBut since b can be up to min( len2, cap // 2 ), and for each cap, this could be O(len2) operations, which is O(1e5) per cap. However, since cap can be up to 3e5, this would be O(3e5 * 1e5) which is way too big.\n\nSo this approach isn't feasible.\n\nAlternative Idea: For a given cap, the optimal selection between weight 1 and 2 items can be found by considering that for each possible number of weight 2 items, the best is to take as many as possible weight 1 items. However, since the weight 2 items may have higher value per unit weight than weight 1 items, perhaps there's a way to find the optimal b quickly.\n\nBut how?\n\nLet me think of the following. For each cap, the maximum value is the maximum over all possible b (number of weight 2 items) such that 2*b ≤ cap. Then, for each such b, the number of weight 1 items is a = min( (cap - 2*b), len1 ), and the value is prefix1[a] + prefix2[b].\n\nBut how can we find the optimal b quickly?\n\nNote that for each cap, the possible values of b range from 0 to min( len2, cap//2 ). Let's denote this as max_b = min( len2, cap//2 )\n\nNow, for each possible b in 0..max_b, we can compute the value as above. But doing this for every possible cap would be O(m * max_b) which is not feasible.\n\nAlternative Idea: Since the weight 2 items are sorted in descending order, the prefix2 array is non-decreasing. Similarly, the prefix1 array is non-decreasing. So, for a given cap, the optimal choice of b is somewhere where the trade-off between the number of weight 2 items and the number of weight 1 items is best.\n\nBut how to find that optimal point.\n\nLet me think about this. For a fixed cap, the total weight used by weight 2 items is 2*b. The remaining weight is cap - 2*b, which can be filled with a weight 1 items. So the value is prefix2[b] + prefix1[ min( len1, cap - 2*b ) ].\n\nLet me denote this as f(b) = prefix2[b] + prefix1[ a ], where a is min( len1, cap - 2*b ). \n\nWe need to find the maximum value of f(b) over all possible b.\n\nNow, since the prefix arrays are non-decreasing, how does f(b) behave?\n\nAs b increases, 2*b increases, so cap - 2*b decreases. Thus, a decreases, and prefix1[a] decreases. However, prefix2[b] increases. So f(b) is a function that first increases and then decreases, or vice versa. But maybe it's unimodal, allowing for binary search.\n\nAlternatively, perhaps the optimal b is around the point where the marginal gain of adding a weight 2 item (i.e., the cost of that item) compared to the marginal loss of removing two weight 1 items (since adding a weight 2 item takes away two units of weight, which could have been filled with two weight 1 items).\n\nBut this seems complicated.\n\nAnother Idea: For each cap, the maximum value can be found by considering all possible numbers of weight 2 items up to min( len2, cap//2 ), but since len2 can be up to 1e5, and cap can be up to 3e5, this would be O(1e5 * 3e5) = 3e10 operations, which is way too slow.\n\nSo that's not feasible. Need a better approach.\n\nAlternative Plan: Since the weight of the items is small (only 1,2,3), perhaps we can model the problem with a dynamic programming approach that's optimized for these weights.\n\nLet me think about the standard knapsack DP. The standard 0-1 knapsack is O(nm), which for n=1e5 and m=3e5 would be 3e10 operations, which is way too slow. However, since the items are grouped by weight, maybe we can find a way to process each group efficiently.\n\nFor example, for items of weight 1, we can process them in a way that for each possible weight, we take the maximum number of items possible. But since they are sorted, taking the top ones is optimal.\n\nWait, but this is similar to the unbounded knapsack problem, but with the twist that each item can be taken once. However, since the items are sorted, taking as many as possible of the highest value items is optimal.\n\nSo perhaps for each group of items (weight 1, 2, 3), we can precompute their prefix sums, and then find the optimal combination of counts from each group.\n\nLet me think again about the problem. The total weight is m. We can take any number of items from each group, but with their weight multiplied by the count. So for weight 1, taking x items contributes x * 1 weight and sum of their costs. Similarly for others.\n\nThe problem is to find x, y, z such that x + 2y + 3z ≤ m, and sum of prefix1[x] + prefix2[y] + prefix3[z] is maximized.\n\nSo the question is how to find x, y, z efficiently.\n\nBut how to iterate over all possible combinations of x, y, z?\n\nWell, given that the weight is small, perhaps for each possible z (number of weight 3 items), we can compute the remaining capacity and then find the best x and y for that remaining capacity.\n\nSo the steps would be:\n\n- Precompute prefix sums for weight 1, 2, 3.\n\n- For each possible z (number of weight 3 items), from 0 to min( len3, m//3 ):\n\n   - Compute the remaining capacity rem = m - 3*z.\n\n   - For this rem, compute the maximum value from weight 1 and 2 items.\n\n   - Keep track of the maximum total value (prefix3[z] + value from rem).\n\nThe key part is how to compute the maximum value from weight 1 and 2 items for a given rem.\n\nBut how to compute that efficiently.\n\nLet me think again about the weight 1 and 2 case.\n\nSuppose we have rem capacity. How to find the maximum sum of prefix1[x] + prefix2[y], where x + 2y ≤ rem.\n\nLet me denote that rem as R.\n\nLet me think about the maximum possible y for this R. The maximum possible y is min( len2, R // 2 ). Let's call this max_y.\n\nBut for each possible y in 0 to max_y, the maximum x is min( len1, R - 2y ). So the value is prefix1[ min(len1, R - 2y) ] + prefix2[y].\n\nBut again, checking all possible y for each R is O(len2) time, which is O(1e5) per R. If we have to do this for each possible z (up to 1e5), then it's O(1e5 * 1e5) = 1e10 operations. That's way too slow.\n\nSo this approach is not feasible. Need to find a better way.\n\nAlternative Idea: For each R, the optimal y is such that 2y is as close as possible to R minus some amount. But how?\n\nAnother Idea: Since the weight 1 items are sorted, taking as many as possible is better. So for a given R, the optimal choice is to take as many weight 2 items as possible, but possibly replace some with weight 1 items if they are more valuable.\n\nBut again, how to find that.\n\nAlternatively, for each possible R, the maximum value from weight 1 and 2 items can be found by considering that for each possible number of weight 2 items, we can compute the corresponding x.\n\nBut how to find the optimal y quickly.\n\nLet me think of the following approach. For a given R, the maximum number of weight 2 items is y_max = min(len2, R//2). Then, for each possible y in [max(0, y_max - k), y_max], where k is a small number (like 100), check those possibilities. Because maybe the optimal y is near y_max, or near some other value.\n\nBut why would that work? Well, since the weight 2 items are sorted, the prefix2 array is increasing. However, taking more weight 2 items may not always be better, since the remaining capacity can allow taking more weight 1 items. For example, if a weight 2 item is worth less than two weight 1 items, it's better to take the two weight 1 items instead.\n\nSo, for each R, the optimal y could be in the vicinity of the value where the next weight 2 item is not better than two weight 1 items. But how to find that?\n\nAlternatively, for each R, the optimal y can be determined by considering that for each possible y, the maximum x is R - 2y. So the value is prefix2[y] + prefix1[min(R - 2y, len1)].\n\nLet me consider that for a given R, the optimal y is either:\n\n- The maximum possible y (y_max), or\n\n- Some y where 2y is as large as possible, but where the next weight 2 item is not better than taking two weight 1 items.\n\nBut I'm not sure. However, perhaps for each R, the optimal y is either y_max, or y_max - 1, etc., up to some small number. For example, considering the top 200 possible y values around y_max and the ones that could possibly be better. Since the number of weight 2 items is up to 1e5, but if we limit ourselves to checking only say 200 possibilities per R, this would be manageable.\n\nBut how to choose which y to check?\n\nAlternatively, since the weight 1 items are sorted, the value of prefix1 is non-decreasing. So, for a given R, if we take y weight 2 items, the value is prefix2[y] + prefix1[ min( len1, R - 2y ) ].\n\nLet me imagine that for varying y, the function f(y) = prefix2[y] + prefix1[ min( len1, R - 2y ) ].\n\nWe can think of this as a function that first increases, then decreases. So it's unimodal, and thus can be optimized with ternary search.\n\nBut is this function unimodal?\n\nLet me think. Suppose that as y increases, initially, the gain from adding a weight 2 item is more than the loss of losing two weight 1 items. But after some point, adding a weight 2 item causes a larger loss in the weight 1 items than the gain. So the function may first increase and then decrease, making it unimodal. If that's the case, then ternary search can be applied.\n\nIf that's true, then for each R, we can perform a ternary search on y in [0, y_max] to find the maximum value of f(y).\n\nBut how to verify this?\n\nLet's take an example. Suppose that the weight 2 items are all very valuable. Then, increasing y would increase f(y) until y_max. Then, the function is strictly increasing, and ternary search would find the maximum at y_max.\n\nAnother example: suppose that the weight 2 items are not as valuable as two weight 1 items. Then, for y=0, the value is prefix1[R], which could be higher than any other y. So the function is decreasing as y increases, and the maximum is at y=0.\n\nIn between, there could be a peak. So the function is unimodal. Hence, ternary search is applicable.\n\nAssuming that this is the case, then for each R, we can perform a ternary search on y in [0, y_max], and find the maximum f(y) in O(log y_max) time. Since y_max is up to 1e5, log2(1e5) is about 17 steps. For each step, we compute f(y) in O(1) time. So for each R, the time is O(log y_max), which is acceptable.\n\nBut how to implement this correctly?\n\nSo, the plan is:\n\nFor each R (the remaining capacity after handling weight 3 items):\n\n   Compute y_max = min( len2, R // 2 )\n\n   Perform a ternary search on y in [0, y_max] to find the maximum f(y) = prefix2[y] + prefix1[ min( len1, R - 2*y ) ]\n\nThen, the maximum value for this R is the result of this ternary search.\n\nBut wait, what if R - 2y is negative? Well, since y is up to R//2, R - 2y is >= 0.\n\nSo that's handled.\n\nSo, with this approach, the total time complexity would be:\n\nFor each z in 0 to len3 (up to 1e5):\n\n   R = m - 3*z\n\n   if R < 0, skip\n\n   compute the maximum value from weight 1 and 2 items for this R, using ternary search.\n\nThe time for each z is O(log (len2)).\n\nSo overall time is O( len3 * log len2 ), which for len3 up to 1e5 and log len2 being ~20, is about 2e6 operations. That's acceptable.\n\nSo, the steps are:\n\n1. Group the items by weight (1, 2, 3), sort each group in descending order of cost, compute their prefix sums.\n\n2. For each possible number of weight 3 items (z), from 0 to min( len3, m//3 ), compute the remaining capacity R = m - 3*z.\n\n3. For each R, compute the best combination of weight 1 and 2 items using ternary search on y.\n\n4. The overall maximum is the maximum over all these possibilities.\n\nBut how to handle the case when R is negative? For example, if 3*z exceeds m, then we can't take that z. So during iteration, we need to ensure that 3*z <= m.\n\nSo, for z in 0 to min( len3, m//3 ), inclusive.\n\nNow, the code steps.\n\nFirst, read n and m.\n\nThen, read n lines of wi and ci, and group them into lists for weight 1, 2, 3.\n\nSort each list in descending order of cost.\n\nCompute prefix sums for each list.\n\nFor example, for weight 1 list:\n\nprefix1[0] = 0\n\nprefix1[1] = cost of first item\n\nprefix1[2] = cost of first + second, etc.\n\nSimilarly for prefix2 and prefix3.\n\nOnce that's done, for each possible z (number of weight 3 items), compute the maximum value.\n\nNow, for the ternary search part.\n\nImplementing ternary search for a function f(y) over [low, high].\n\nBut since the function may not be strictly unimodal, but we can assume that it is, we can proceed.\n\nBut how to handle the ternary search. Let me think.\n\nThe ternary search works by dividing the interval into two parts, and comparing the function values at two points to decide which half to keep.\n\nBut in practice, for programming competition purposes, sometimes people use a loop that runs for a fixed number of steps (like 100 times) to get close enough to the maximum.\n\nAlternatively, since the possible range of y is small, we can use a loop that iterates until low <= high, and in each step, computes mid1 and mid2, and compares the function values.\n\nBut for the sake of code simplicity, perhaps it's easier to iterate over all possible y in the range [max(0, y_max - 200), y_max], and take the maximum. Because for each R, the optimal y is likely to be near y_max, or in the vicinity of where the weight 2 items are more valuable than weight 1 items.\n\nBut why?\n\nBecause the weight 2 items are sorted in descending order, and the weight 1 items are also sorted. So, for a given R, if we take y_max weight 2 items, then the remaining capacity is R - 2*y_max. However, it's possible that replacing some of the weight 2 items with weight 1 items gives a better total.\n\nBut how many such possibilities need to be checked?\n\nFor example, for each R, we can check all possible y in the range from max(0, y_max - 200) to y_max. Since 200 is a small number, this would add O(200) per R.\n\nBut why would this work? Well, the optimal y could be in that vicinity. For example, if the best y is where the next weight 2 item is worse than two weight 1 items, then checking up to 200 possibilities would capture that.\n\nThis approach is called the \"greedy with checking nearby\" method and is often used in programming contests when the exact optimal is hard to find but the function is unimodal and the optimal is near the end.\n\nBut how to choose the number of steps? For example, in the sample input:\n\nSample 2:\n\nInput:\n\n2 2\n\n1 3\n\n2 2\n\nSo, the weight 1 items are [3], weight 2 items are [2].\n\nFor R = 2 (when z=0), the possible y is 1 (since 2*1=2). The value is prefix2[1] + prefix1[0] = 2 + 0 = 2. But also, taking y=0, and x=2 (but since there is only 1 item in weight 1, x=1, value 3). So the maximum is 3.\n\nSo, in this case, the optimal y is 0. But y_max is 1. So checking up to y_max - 1 would include y=0.\n\nIf we check all y in the range from 0 to y_max, but that's O(y_max) steps again. So that's back to the original problem.\n\nBut if we can limit the number of checks to a small number, say 200, then for each R, we check the top 200 possible y values (starting from y_max down to max(0, y_max - 200)), and also check the cases where we take as many weight 1 items as possible.\n\nBut how to know how many steps to check?\n\nAlternatively, since the weight 2 items are sorted, the prefix2 is non-decreasing. The prefix1 is also non-decreasing. For a given R, when you take y weight 2 items, the remaining capacity is R - 2y, which allows taking up to (R - 2y) weight 1 items. So the value is prefix2[y] + prefix1[ min( len1, R - 2y ) ].\n\nLet me think of this as a function where for each y, the value is the sum of two non-decreasing functions. But since R-2y decreases as y increases, the prefix1 term decreases. So the function may have a single peak.\n\nThus, the maximum is achieved at a certain y, and checking all possible y in a small window around that peak is sufficient.\n\nBut how to find that window?\n\nAlternatively, for each R, we can compute the maximum between two possibilities:\n\n- Take as many weight 2 items as possible (y_max), and then take as many weight 1 items as possible.\n\n- Take as many weight 1 items as possible (x_max = min(len1, R)), and then take as many weight 2 items as possible with the remaining capacity (which is zero, so no weight 2 items).\n\nBut this might miss some cases. However, perhaps combining these two approaches and checking a few more possibilities could cover the optimal.\n\nAlternatively, for each R, the optimal y is either:\n\n- y_max, or\n\n- the largest y where the cost of the y-th weight 2 item is greater than or equal to the sum of the two most valuable weight 1 items that would be replaced by taking that weight 2 item.\n\nBut this seems complex.\n\nAlternatively, for each R, we can check all possible y in the range [max(0, y_max - 200), y_max], and also check the case where y is 0. This way, even if the optimal y is not near y_max, but is small, we can capture it.\n\nBut why would that work? Well, the number of weight 2 items that are better than two weight 1 items is limited. For example, if the first few weight 2 items are better than two weight 1 items, then taking them would be better. But after that, it's better to take the weight 1 items. So the optimal y is somewhere in that region. If we check up to 200 possibilities, even if the optimal y is 200 steps away from y_max, we would capture it.\n\nIn practice, this approach may work for the given problem. So let's proceed with this idea.\n\nSo for each R, we can compute y_max = min(len2, R // 2). Then, we check all possible y from max(0, y_max - 200) to y_max. For each y in this range, compute the value and take the maximum. Also, we can check y=0.\n\nThis would give us O(200) operations per R. Considering that len3 is up to 1e5, and 200 * 1e5 = 2e7 operations, which is acceptable.\n\nBut what if the optimal y is outside of this range? Well, for the problem constraints, perhaps this approach would pass all test cases. However, there's a risk of failing some cases. But given the time constraints, this seems like a feasible approach.\n\nAlternatively, we can set the number of checks to 300 or even 500, which would increase the computation time slightly but still be manageable.\n\nBut how to decide? Well, let's think about the worst case. Suppose that the optimal y is exactly y_max - 300. Then checking up to y_max - 200 would miss it. However, for the problem's test cases, this approach may be sufficient.\n\nAlternatively, perhaps we can find the optimal y by checking all possible y in the range where the value of the y-th weight 2 item is greater than or equal to the sum of two weight 1 items. But how?\n\nAnother Idea: For each R, the optimal y is such that the next weight 2 item (if any) is not better than two weight 1 items. So, for example, for each y, compare the value of the (y+1)-th weight 2 item with the sum of the two highest weight 1 items that are not yet taken.\n\nBut this seems complex.\n\nAlternatively, since the weight 1 items are sorted, the sum of the first two items (if available) would be the maximum possible for two items. So, for each possible y, if the next weight 2 item (i.e., the (y+1)-th item) has a cost less than the sum of the first two weight 1 items that are not used, then it's better to take those two weight 1 items instead of the weight 2 item.\n\nThis suggests that the optimal y is the largest possible such that the (y+1)-th weight 2 item is not better than two weight 1 items.\n\nBut how to find this?\n\nLet me think. For a given R, the maximum number of weight 2 items is y_max. Let's say that we have y_max items. For each y from 0 to y_max, the value is prefix2[y] + prefix1[ min( len1, R - 2y ) ].\n\nNow, for each y, the next item (y+1) is weight 2. The cost of that item is c2[y+1]. The current R - 2y is the remaining capacity for weight 1 items. If we take one more weight 2 item, the remaining capacity for weight 1 items is R - 2*(y+1) = R - 2y - 2. So the number of weight 1 items is min( len1, R - 2y - 2 ). The difference between taking this additional weight 2 item and not taking it is:\n\nc2[y+1] - (prefix1[ min( len1, R - 2y ) ] - prefix1[ min( len1, R - 2y - 2 ) ] )\n\nWhich is the cost of the new weight 2 item minus the cost of the two weight 1 items that are no longer taken.\n\nIf this difference is positive, then it's better to take the additional weight 2 item. Else, it's better not to.\n\nSo, the optimal y is the largest y where this condition holds.\n\nBut how to find this y?\n\nThis seems like a possible way to find the optimal y, but implementing it may be complex.\n\nBut perhaps, for the purpose of this problem, we can find the optimal y by checking all possible y in the range from 0 to y_max, but that's again O(y_max) per R.\n\nBut this brings us back to the original problem.\n\nHmm. It seems that the only feasible way is to find a way to handle the weight 1 and 2 items for a given R efficiently.\n\nLet me think of another Idea. Since the weight of the items is small, perhaps we can use a greedy approach for the combination of weight 1 and 2 items.\n\nFor example, for a given R, we can take as many weight 2 items as possible, but whenever adding a weight 2 item is worse than taking two weight 1 items, we replace it.\n\nBut how to implement this.\n\nLet me think. Suppose we have taken y weight 2 items. Then, the remaining capacity is R - 2y. We can take x = min( len1, R - 2y ) weight 1 items.\n\nNow, if we can replace one weight 2 item with two weight 1 items, and that gives a better total value, then we should do that.\n\nBut how to find the optimal number of such replacements.\n\nThis sounds like a problem where we can take the maximum of all possible combinations of y and x, but again, this is not helpful.\n\nAlternative Idea: Since the weight 1 and 2 items are sorted, we can think of the problem as selecting a subset of items from both groups, with the constraint that the total weight is <= R. This is similar to the classic knapsack problem, but with items grouped by weight.\n\nBut since the items are sorted, perhaps we can find the optimal selection by considering the following: take as many as possible of the highest value items from both groups.\n\nBut how?\n\nFor example, we can merge the two lists (weight 1 and 2 items) into a single list, sorted by value per unit weight, and take the highest ones. But this is not straightforward.\n\nAlternatively, since each weight 1 item contributes 1 unit of weight and its cost, and each weight 2 item contributes 2 units and its cost. We can think of this as a knapsack problem with two types of items, but with the twist that we can take any number of items from each type, as long as the total weight is within R.\n\nBut with the items sorted, perhaps the optimal selection is to take as many of the highest value items as possible, regardless of their weight.\n\nBut this is not necessarily true. For example, if there is a weight 2 item with cost 3, and two weight 1 items with cost 2 each. Taking the two weight 1 items gives a total cost of 4, which is better than taking the weight 2 item (cost 3). So the greedy approach of taking the highest value items first would work here.\n\nWait, but the highest value item is the weight 2 item with cost 3. So taking that would be better than taking the two weight 1 items. But in reality, the two weight 1 items are better. So the greedy approach of taking the highest value items first is not correct.\n\nAh, right. So this shows that the greedy approach of taking the highest value items doesn't work. Hence, the need for a more sophisticated approach.\n\nBack to the original Idea of using ternary search. Let's try to implement that.\n\nLet's assume that the function f(y) is unimodal. Let's proceed with implementing ternary search.\n\nSo for each R, perform a ternary search on y in [0, y_max], and find the maximum value.\n\nBut how to implement this.\n\nHere's a sample code for ternary search:\n\ndef find_max(R):\n    low = 0\n    high = y_max\n    best = 0\n    while low <= high:\n        mid1 = low + (high - low) // 3\n        mid2 = high - (high - low) // 3\n        val1 = compute_value(mid1)\n        val2 = compute_value(mid2)\n        if val1 < val2:\n            best = max(best, val2)\n            low = mid1 + 1\n        else:\n            best = max(best, val1)\n            high = mid2 - 1\n    return best\n\nBut this is just",
    "response": "\n\nTo solve this problem, we need to maximize the total cost of souvenirs Petya can carry given a weight constraint. The souvenirs have weights of 1, 2, or 3, and we need an efficient approach to handle the constraints where the number of items (n) can be up to 100,000 and the maximum weight (m) up to 300,000.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Compute Prefix Sums**: For each group, sort the items by descending cost and compute prefix sums to quickly calculate the maximum value for any number of items taken from each group.\n3. **Iterate Over Possible Counts of Weight 3 Items**: For each possible count of weight 3 items, calculate the remaining weight capacity and determine the optimal combination of weight 1 and 2 items using a ternary search approach.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    \n    len1 = len(w1)\n    len2 = len(w2)\n    len3 = len(w3)\n    \n    # Iterate over possible number of weight 3 items\n    max_z = min(len3, m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3 * z\n        if rem < 0:\n            continue\n        \n        # Now find best combination of w1 and w2 for rem\n        y_max = min(len2, rem // 2)\n        \n        # Use ternary search on y in [0, y_max]\n        low = 0\n        high = y_max\n        best_val = 0\n        \n        # Perform ternary search\n        while low <= high:\n            mid1 = low + (high - low) // 3\n            mid2 = high - (high - low) // 3\n            \n            # Compute value for mid1\n            val1 = prefix2[mid1]\n            remaining = rem - 2 * mid1\n            a = min(len1, remaining)\n            val1 += prefix1[a]\n            \n            # Compute value for mid2\n            val2 = prefix2[mid2]\n            remaining = rem - 2 * mid2\n            a = min(len1, remaining)\n            val2 += prefix1[a]\n            \n            if val1 < val2:\n                best_val = max(best_val, val2)\n                low = mid1 + 1\n            else:\n                best_val = max(best_val, val1)\n                high = mid2 - 1\n        \n        # Also check the endpoints\n        # Check y=0\n        val0 = prefix2[0]\n        remaining = rem - 0\n        a = min(len1, remaining)\n        val0 += prefix1[a]\n        best_val = max(best_val, val0)\n        \n        # Check y=y_max\n        valy_max = prefix2[y_max]\n        remaining = rem - 2 * y_max\n        a = min(len1, remaining)\n        valy_max += prefix1[a]\n        best_val = max(best_val, valy_max)\n        \n        total = prefix3[z] + best_val\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: Items are grouped by their weights and sorted in descending order of cost to facilitate greedy selection.\n2. **Prefix Sums**: Prefix sums are computed for each group to allow quick calculation of the total cost for any number of items taken from a group.\n3. **Ternary Search**: For each possible count of weight 3 items, the remaining capacity is calculated, and ternary search is used to efficiently determine the optimal combination of weight 1 and 2 items within the remaining capacity, ensuring an optimal solution without excessive computation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    \n    len1 = len(w1)\n    len2 = len(w2)\n    len3 = len(w3)\n    \n    # Iterate over possible number of weight 3 items\n    max_z = min(len3, m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3 * z\n        if rem < 0:\n            continue\n        \n        # Now find best combination of w1 and w2 for rem\n        y_max = min(len2, rem // 2)\n        \n        # Use ternary search on y in [0, y_max]\n        low = 0\n        high = y_max\n        best_val = 0\n        \n        # Perform ternary search\n        while low <= high:\n            mid1 = low + (high - low) // 3\n            mid2 = high - (high - low) // 3\n            \n            # Compute value for mid1\n            val1 = prefix2[mid1]\n            remaining = rem - 2 * mid1\n            a = min(len1, remaining)\n            val1 += prefix1[a]\n            \n            # Compute value for mid2\n            val2 = prefix2[mid2]\n            remaining = rem - 2 * mid2\n            a = min(len1, remaining)\n            val2 += prefix1[a]\n            \n            if val1 < val2:\n                best_val = max(best_val, val2)\n                low = mid1 + 1\n            else:\n                best_val = max(best_val, val1)\n                high = mid2 - 1\n        \n        # Also check the endpoints\n        # Check y=0\n        val0 = prefix2[0]\n        remaining = rem - 0\n        a = min(len1, remaining)\n        val0 += prefix1[a]\n        best_val = max(best_val, val0)\n        \n        # Check y=y_max\n        valy_max = prefix2[y_max]\n        remaining = rem - 2 * y_max\n        a = min(len1, remaining)\n        valy_max += prefix1[a]\n        best_val = max(best_val, valy_max)\n        \n        total = prefix3[z] + best_val\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 1096,
        "thoughts_token_count": 8191
    }
}