{
    "start": 1758309714.9176824,
    "end": 1758309753.2399104,
    "start-formatted": "2025-09-20 04:21 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. The goal is to maximize the sum of their numbers S1 and S2. Each takes exactly n moves, and the order of taking digits depends on who is chosen each turn. The output is the sequence of H and M that leads to the maximum total.\n\nHmm, the key here is to find the optimal way for them to pick digits so that their combined total is maximized. Since each choice affects the remaining digits, we need a way to decide at each step whether Homer or Marge should take the next digit.\n\nBut wait, how do we model this? Because the decision at each step depends on the current state of the digits left and how many moves each has made so far. For example, if there are k digits left, and Homer has taken h moves and Marge m moves, then the next move could be either H or M, but only if they haven't reached their n moves yet.\n\nThe challenge is that n can be up to 18, which makes the total number of digits 36. So the state space would involve the current position in the string (which can be up to 36 steps), and the counts of H and M moves taken so far. But with n=18, the possible states would be something like 36 * 19 * 19, since for each position, the number of H moves can be up to n, and same for M. Let me calculate: for each state, the number of digits left is 2n - (h + m). But since h + m can be from 0 to 2n, and h can be up to n, m up to n, the state can be represented by h and m (since the number of digits left is determined by h + m). Wait, because the initial length is 2n. So for each state, the number of digits left is 2n - (h + m) = (number of digits taken so far). But when we take a digit, we add to h or m. So the state can be represented by h and m, where h is the number of H moves taken so far, m is the number of M moves. And since each player must take exactly n moves, the total steps is 2n.\n\nSo the total possible states are (n+1) * (n+1) = for n=18, that's 19*19= 361. Which is manageable. Because for each state, we can decide whether to take H or M, provided that h < n and m < n respectively.\n\nBut how do we choose between H and M to maximize the total sum? Well, the total sum is the sum of the digits taken by H and M. Wait, no. Wait, the sum S1 + S2 is the value of the numbers formed by their digits. But since each digit is taken in order, the value depends on the position. For example, the first digit taken is the most significant digit. So, for example, if Homer takes a digit first, that digit contributes 10^{n-1} times its value to his total, depending on when he took it. But this seems complicated to model.\n\nWait, but the problem says that the total prize is S1 + S2. So each digit that is taken contributes to the sum based on its position in the respective player's number. However, since the players take digits in order, the order in which they take digits determines the value of their numbers. For instance, the first digit taken by Homer will be the first digit of his number (most significant), the next one will be second, etc. Similarly for Marge.\n\nBut how do we compute the total sum? For example, if Homer takes the first digit, then the second, etc. The value of his number is sum_{i=0}^{n-1} (digit_i) * 10^{n-1 - i}. Similarly for Marge. But adding S1 and S2 would require considering all digits in their positions. However, this seems computationally heavy to track during a dynamic programming approach.\n\nBut perhaps there's a smarter way. Let's think about the contribution of each digit. Suppose a digit is taken at position k (the original position in A, say 0-based). Then, depending on which player takes it, and when they take it (i.e., the order in which they take it), the digit contributes to the total sum. For example, if Homer takes the digit as his i-th move (so the i-th digit in his number), then the contribution is digit * 10^{n - i - 1} (assuming n digits). Similarly for Marge.\n\nBut how do we model this? Because the choice of which player takes which digit affects the contribution of each",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The key challenge is to decide at each step whether Homer or Marge should take the next digit from the given number A to maximize the sum of their respective numbers.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a recursive approach with memoization to explore all possible sequences of moves efficiently. The state of our DP function will be defined by the current position in the number A and the counts of moves made by Homer and Marge so far.\n2. **Greedy Choice Based on Digit Value**: At each step, we consider both possible choices (Homer or Marge taking the next digit) and choose the one that leads to the maximum total prize. This decision is based on the immediate benefit of taking the current digit and the future possibilities.\n3. **Memoization**: To avoid redundant computations, we memoize the results of subproblems using a dictionary where the keys are tuples representing the current state (position, Homer's moves, Marge's moves).\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(pos, h, m):\n        if h + m == length:\n            return (0, \"\")\n        # Determine who can take the next move\n        options = []\n        if h < n:\n            # Homer takes the next digit\n            current_digit = int(A[pos])\n            new_h = h + 1\n            remaining = dp(pos + 1, new_h, m)\n            contribution = current_digit * (10 ** (n - new_h)) + remaining[0]\n            options.append((contribution, 'H' + remaining[1]))\n        if m < n:\n            # Marge takes the next digit\n            current_digit = int(A[pos])\n            new_m = m + 1\n            remaining = dp(pos + 1, h, new_m)\n            contribution = current_digit * (10 ** (n - new_m)) + remaining[0]\n            options.append((contribution, 'M' + remaining[1]))\n        # Choose the option with maximum contribution, preferring 'H' if tie\n        max_contribution = max(options, key=lambda x: (x[0], 0 if x[1][0] == 'H' else 1))\n        return (max_contribution[0], max_contribution[1])\n\n    result = dp(0, 0, 0)\n    print(result[1])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Dynamic Programming Function**: The `dp` function is defined with parameters `pos`, `h`, and `m` representing the current position in the string A and the number of moves made by Homer and Marge respectively.\n- **Base Case**: When all digits have been taken (`h + m == length`), the function returns a contribution of 0 and an empty string.\n- **Recursive Case**: For each position, the function explores both possible moves (Homer or Marge taking the next digit). It calculates the contribution of each choice and recursively determines the optimal sequence for the remaining digits.\n- **Memoization**: The `lru_cache` decorator is used to store results of previously computed states to avoid redundant calculations and improve efficiency.\n- **Greedy Choice**: The function selects the move that maximizes the total contribution, with a tie-breaker preferring 'H' to ensure deterministic results when multiple optimal sequences exist.\n\nThis approach ensures that we efficiently explore all possible sequences of moves while maximizing the total prize money for Homer and Marge.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(pos, h, m):\n        if h + m == length:\n            return (0, \"\")\n        # Determine who can take the next move\n        options = []\n        if h < n:\n            # Homer takes the next digit\n            current_digit = int(A[pos])\n            new_h = h + 1\n            remaining = dp(pos + 1, new_h, m)\n            contribution = current_digit * (10 ** (n - new_h)) + remaining[0]\n            options.append((contribution, 'H' + remaining[1]))\n        if m < n:\n            # Marge takes the next digit\n            current_digit = int(A[pos])\n            new_m = m + 1\n            remaining = dp(pos + 1, h, new_m)\n            contribution = current_digit * (10 ** (n - new_m)) + remaining[0]\n            options.append((contribution, 'M' + remaining[1]))\n        # Choose the option with maximum contribution, preferring 'H' if tie\n        max_contribution = max(options, key=lambda x: (x[0], 0 if x[1][0] == 'H' else 1))\n        return (max_contribution[0], max_contribution[1])\n\n    result = dp(0, 0, 0)\n    print(result[1])\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 426,
        "completion_token_count": 796,
        "thoughts_token_count": 1024
    }
}