{
    "start": 1758024022.2730281,
    "end": 1758026858.2544146,
    "start-formatted": "2025-09-16 21:00 KST",
    "end-formatted": "2025-09-16 21:47 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ â€” the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The task is to find the maximum number of compatible left-right boot pairs. Each pair must consist of one left and one right boot, and their colors must be compatible. Also, each boot can be used in at most one pair. \n\nSo, first, I need to figure out how to pair them optimally. Let's think about the compatibility rules. A specific color (like 'a') can only pair with another 'a' or a '?'. A '?' can pair with any color, including another '?'. \n\nThe challenge is to maximize the number of pairs. How to approach this?\n\nLet me think about possible strategies. Maybe we can first pair the specific colors with each other, then use the question marks for the remaining ones. But how to handle that efficiently?\n\nLet me break it down into steps:\n\n1. For each color (excluding '?'), count the number of left boots and right boots. For example, if there are x left boots of color 'a' and y right boots of color 'a', then the maximum possible pairs for this color is min(x, y). But since a '?' can be used as a wildcard, maybe we need to handle those first.\n\nWait, but if we have a left boot with color 'a' and a right boot with color 'a', that's a direct match. So perhaps we should first pair all such direct matches. Then, the remaining boots (left and right) which can't be paired directly can be matched using the '?'s.\n\nBut how to handle the '?'s? For example, if there are left '?'s and right '?'s, they can be paired with each other. Also, left '?'s can pair with right non-? colors, and vice versa.\n\nAlternatively, here's an idea:\n\nFirst, pair all left boots with specific colors with right boots of the same color. Then, collect the leftover left and right boots (those that couldn't be paired directly). Then, for these leftovers, pair them using the '?'s.\n\nBut how to manage that? Let's think:\n\nLet's create two dictionaries: left_count and right_count. For each color (excluding '?'), left_count[color] is the number of left boots with that color. Similarly for right_count. Then, for each color, the number of pairs is min(left_count[color], right_count[color]). However, once we pair these, the remaining left and right boots (for that color) would be left_count[color] - min(...) and similarly for right. But wait, no. Because once we pair them, the min is subtracted from both. But maybe the way to do this is to process each color and pair as much as possible.\n\nWait, but perhaps we should first pair the same colors. Then, for the remaining left and right boots (which have either specific colors or ?), we can pair the ?s with others.\n\nBut how to handle the ?s. Let me think of the following steps:\n\nStep 1: Pair all same-colored boots (non-?) between left and right. For example, for each color c in a-z, take min(left_c, right_c) pairs. Then, subtract those from left and right counts. For example, if there are 3 left 'a's and 5 right 'a's, we can make 3 pairs. Then, after that, the left 'a's are all used up, and the right 'a's have 5-3=2 remaining.\n\nBut how to track which boots are actually used. Because in the output, we need to list the actual indices. So this approach might not work directly. Because for example, when we have a lot of same-color boots, we need to pair them, but how to track which ones to pick.\n\nHmm. So perhaps the first step is to process the same-color pairs. For each color c (excluding '?'), we can pair left boots with color c with right boots with color c. But how to track which ones are used. So maybe we need to collect all the positions where left has color c, and same for right. Then, pair them in some way, like taking the first m elements from each list, where m is the min of the counts.\n\nOnce that is done, we can move on to handling the ?s.\n\nNow, the remaining left boots are those that were not paired in step 1. These include:\n\n- Left boots with color ?, and those that had a specific color but couldn't be paired (but since step 1 pairs as much as possible, those would be zero for specific colors. Wait, no. For example, if left has 3 'a's, and right has 2 'a's, then after step 1, we have 2 pairs, and 1 left 'a' remains. So for that 'a', it can't be paired with any right 'a's, but maybe it can be paired with a right '?'.\n\nSo, after step 1, for each specific color, the left and right counts may have some leftover. For example, left has some 'a's that couldn't be matched with right 'a's. Similarly, right has some 'a's that couldn't be matched with left 'a's.\n\nThen, for step 2, we can process the remaining left and right boots. The idea is to pair the ?s with others.\n\nBut how?\n\nLet me think of the remaining left boots as:\n\n- Some left boots with specific colors (not ?), and some left boots with ?. Similarly for right.\n\nFor the remaining left boots with specific color c, they can be paired with right boots that have color c or ?. Similarly, for right boots with specific color c, they can be paired with left boots with c or ?.\n\nBut how to maximize the total pairs here.\n\nAnother approach: collect all the remaining left boots and right boots. Let's call them left_remaining and right_remaining. Now, for these, we can try to pair as follows:\n\n- First, pair the left '?'s with the right '?'s. The number of such pairs is min(number of left '?', number of right '?'). But then, after that, there may be leftover '?'s on either side.\n\n- Then, for the remaining left '?'s, pair them with the right boots that have specific colors (but not yet paired). Similarly, for the remaining right '?'s, pair them with left boots that have specific colors.\n\nBut how to manage that.\n\nAlternatively, here's a plan:\n\nAfter step 1 (pairing same-colored non-? boots):\n\nWe have:\n\n- left_non_q: list of left boots with color != ?, which were not paired (because their corresponding right boots were not available)\n- right_non_q: same for right\n- left_q: list of left boots with ?\n- right_q: list of right boots with ?\n\nNow, for each left_non_q boot (color c), they can be paired with right boots that have color c or ?. Similarly for right_non_q.\n\nBut how to pair them optimally.\n\nLet me think about this. For each color c (excluding ?), the number of left_non_q boots with color c is L[c], and the number of right_non_q boots with color c is R[c]. Also, there are left_q and right_q.\n\nThe idea is to pair the left_non_q and right_non_q with same color. But since they were not paired in step 1, that's because there was not enough of the other side. For example, suppose in step 1, we paired as much as possible for each color. So for color c, L[c] and R[c] would be the remaining counts.\n\nBut how to pair them now. Well, for example, for each color c, the number of left_non_q with color c is L[c], and the number of right_non_q with color c is R[c]. But since in step 1 we already took min(left_c, right_c), perhaps now L[c] is left_c - (number of pairs made in step 1), which could be zero or more? Wait, no. Wait step 1 is pairing same color between left and right. For example, for color c, the number of pairs is min(left_c, right_c). So after that, the left_c_remaining is left_c - pairs, and right_c_remaining is right_c - pairs. But in this case, if left_c was less than right_c, then left_c_remaining is zero, and right_c_remaining is (right_c - left_c). Similarly for the other way around.\n\nSo for the remaining left_non_q and right_non_q, for each color c, the left_non_q has some number of boots with color c, and the right_non_q has some number of boots with color c. But since step 1 already took the max possible same-color pairs, these left and right can't be paired with same color anymore. Because, for example, if left had 3 c's and right had 5 c's, then step 1 paired 3 pairs, leaving 0 left c's and 2 right c's. So the left c's are all used up. So in this case, the right c's can't be paired with left c's anymore. But they can be paired with left ?'s.\n\nSo for the remaining left_non_q and right_non_q, they can't be paired with same color (since that's already handled in step 1). Therefore, they can only be paired with ?'s from the other side.\n\nSo, the next step would be to pair the left_non_q with right_q and vice versa.\n\nBut how to do that optimally.\n\nLet me think. For example, suppose there are left boots with color 'a' (non-?), and right boots with '?'. Those can be paired. Similarly, right boots with 'a' can be paired with left boots with '?'.\n\nSo, the approach would be:\n\n- For all left_non_q (specific colors), pair them with right_q (if possible). Similarly for right_non_q with left_q.\n\nBut how to manage that. Let's think:\n\nWe have left_non_q (specific colors) and right_q (wildcards). So for each left_non_q boot, we can pair it with any right_q boot. Similarly for right_non_q with left_q.\n\nBut since we want to maximize the number of pairs, we can pair all possible left_non_q with right_q, and right_non_q with left_q.\n\nBut how to do that in code.\n\nLet me think of the following steps:\n\nAfter step 1:\n\n- Collect all left boots that are non-? and not yet paired. Let's call them left_non_q_list.\n- Collect all right boots that are non-? and not yet paired. Call them right_non_q_list.\n- Collect all left boots that are ? and not yet paired. Call left_q_list.\n- Collect all right boots that are ? and not yet paired. Call right_q_list.\n\nNow, for the left_non_q_list and right_q_list:\n\nEach left_non_q can be paired with any right_q. So the number of possible pairs here is min(len(left_non_q_list), len(right_q_list)).\n\nSimilarly, for the right_non_q_list and left_q_list: min(len(right_non_q_list), len(left_q_list)).\n\nBut how to pair them. Let's say we first pair left_non_q with right_q. For example, take the first m elements from left_non_q and the first m elements from right_q, where m is the min of their lengths. Then, after that, the remaining left_non_q and right_q can be processed.\n\nBut what about the other direction? For example, after pairing left_non_q with right_q, there may be some right_non_q and left_q left. So we need to pair them as well.\n\nBut how to decide which to prioritize. Because, for example, pairing left_non_q with right_q may leave more right_non_q to pair with left_q. But perhaps the order doesn't matter here. Because the total number of pairs would be (number of left_non_q + number of right_non_q) - (some constraints based on the available q's).\n\nAlternatively, here's a way to compute the maximum possible pairs:\n\nThe total possible pairs from left_non_q and right_q is the number of left_non_q, since each can be paired with a right_q. But if there are more left_non_q than right_q, then after pairing all right_q, the rest left_non_q can't be paired. Similarly for the other way.\n\nSame for the right_non_q and left_q.\n\nSo, the total pairs from these two groups would be:\n\npairs1 = min(len(left_non_q), len(right_q))\npairs2 = min(len(right_non_q), len(left_q))\n\nBut after pairing pairs1, the right_q is reduced by pairs1. Then, the remaining right_q can be paired with right_non_q? No. Wait, the right_q is wildcards. So after pairing left_non_q with right_q, the remaining right_q can be used to pair with right_non_q? No, because right_non_q are specific colors. Wait, no. Right_non_q are the right boots with specific colors that couldn't be paired with left boots of same color. So, they can't be paired with other right boots. They need to be paired with left boots (either ? or same color). But in this case, the right_non_q are already processed in step 1, so they can't be paired with left_non_q (same color). So they can be paired with left_q (wildcards). But the left_q may have been used in pairing with left_non_q. \n\nThis seems complicated. Maybe the best way is to pair all left_non_q with right_q as much as possible, then pair all right_non_q with left_q as much as possible. But perhaps this isn't optimal. However, given that the problem allows any correct answer, perhaps this approach is acceptable.\n\nAlternatively, perhaps we can pair the left_non_q with right_q and right_non_q with left_q, but in a way that uses all possible pairs.\n\nBut how to implement this. Let me think of the following approach:\n\nFor the left_non_q and right_q:\n\nTake all the left_non_q and pair them with the right_q. For example, for each left boot in left_non_q, pair it with a right_q. So the number of pairs is min(len(left_non_q), len(right_q)). Suppose we pair as many as possible. Then, the remaining right_q can be paired with the right_non_q? No, that's not possible. Because the right_non_q have specific colors, and the right_q are wildcards. Wait, no. The right_q are wildcards, but they are part of the right boots. So, perhaps the right_q can be paired with left_non_q or left_q. But in this case, after pairing left_non_q with right_q, the remaining right_q can be paired with left_q (which are wildcards). \n\nSo, after pairing left_non_q with right_q, the remaining right_q can be paired with left_q. Similarly, if we first pair right_non_q with left_q, then the remaining left_q can be paired with right_q.\n\nBut which order gives a better result? For example, suppose:\n\nleft_non_q has 3 elements, right_q has 2 elements, right_non_q has 3 elements, left_q has 2 elements.\n\nIf we pair left_non_q with right_q (2 pairs), then we have 1 left_non_q left. Then, pair right_non_q with left_q (2 pairs). Total 4 pairs.\n\nAlternatively, if we pair right_non_q with left_q first (2 pairs), then pair left_non_q with right_q (2 pairs). Same total.\n\nSo, the order doesn't affect the total. Thus, the maximum possible pairs from these steps would be (len(left_non_q) + len(right_non_q)) - (some constraints?), but perhaps not. Wait, no. Because the total possible pairs is len(left_non_q) + len(right_non_q) - (something?), but considering that the q's are limited.\n\nWait, the total possible pairs from left_non_q and right_q is min(len(left_non_q), len(right_q)), and the total possible pairs from right_non_q and left_q is min(len(right_non_q), len(left_q)).\n\nBut after pairing the first, the left_q is reduced by the number of pairs made in the first step. So the order matters here.\n\nBut how to maximize the sum. For example, if we have:\n\nleft_non_q: 3\n\nright_q: 2\n\nright_non_q: 3\n\nleft_q: 2\n\nIf we first pair left_non_q with right_q (2 pairs), then left_q is still 2. Then, pair right_non_q (3) with left_q (2): 2 pairs. Total 4.\n\nIf instead, first pair right_non_q with left_q (2 pairs), then left_non_q (3) with right_q (2): 2 pairs. Total 4 again.\n\nSame result.\n\nAnother example: left_non_q = 5, right_q = 3; right_non_q = 5, left_q = 3.\n\nIf first pair left_non_q with right_q (3 pairs), then left_q is 3. Then pair right_non_q (5) with left_q (3): 3 pairs. Total 6.\n\nAlternatively, if first pair right_non_q with left_q (3 pairs), then left_non_q (5) with right_q (3): 3 pairs. Total 6 again.\n\nSo regardless of order, the total is same.\n\nThus, the order in which we pair these groups doesn't affect the total. Therefore, we can proceed in any order. So, for code, perhaps:\n\nPair left_non_q with right_q as much as possible. Then pair right_non_q with left_q as much as possible.\n\nBut how to implement this.\n\nNow, the problem is not only to compute the maximum number of pairs, but also to output the actual pairs. So we need to track which boots are used in each step.\n\nSo, here's a plan for the code:\n\n1. Read n, l, r.\n\n2. For each position i (from 0 to n-1), track whether the left boot and right boot are used.\n\n3. For step 1: pair same-colored non-? boots.\n\n   For each color c in a-z (excluding '?'):\n\n      collect all left positions where l[i] == c and not used.\n\n      collect all right positions where r[i] == c and not used.\n\n      the number of pairs is min(len(left_list), len(right_list)).\n\n      pair them. For example, take the first m elements from each list and pair them.\n\n      mark those positions as used.\n\n4. After step 1, collect the remaining left and right boots.\n\n   For left boots not used, which are either ? or specific colors (but couldn't be paired with same color right boots).\n\n   Similarly for right.\n\n5. For step 2: pair left_non_q (specific colors) with right_q (wildcards).\n\n   Collect all left boots not used with color != ? (left_non_q_list) and all right boots not used with color ? (right_q_list).\n\n   Take min(len(left_non_q_list), len(right_q_list)) pairs. Pair them.\n\n   Mark those as used.\n\n6. For step 3: pair right_non_q (specific colors) with left_q (wildcards).\n\n   Collect all right boots not used with color != ? (right_non_q_list) and all left boots not used with color ? (left_q_list).\n\n   Take min(len(right_non_q_list), len(left_q_list)) pairs. Pair them.\n\n   Mark those as used.\n\n7. Finally, collect all the pairs made in steps 1, 2, 3.\n\nBut wait, after step 1, the left_non_q_list includes left boots with specific colors (they couldn't be paired with same color right boots) and left boots with ?. Similarly for right.\n\nWait, no. Because in step 1, we only pair same-colored non-? boots. So, left boots with ? are not considered in step 1. So after step 1, the left_non_q_list includes all left boots with color not ?, which were not used in step 1. And the left_q_list includes all left boots with ? which were not used in step 1.\n\nSo, for step 2, the left_non_q_list is the left boots with specific colors (not ?) that are not yet used. These can be paired with right_q (wildcards). Similarly, step 3 pairs right_non_q with left_q.\n\nBut what about the remaining ?s? Like, after step 2 and 3, there may be some left_q and right_q that are not used. For example, if there are more left_q than needed to pair with left_non_q and right_non_q. Those can be paired among themselves.\n\nAh! Right. Because ? can pair with any color, including other ?s. So, after steps 1, 2, 3, there may be left_q and right_q that are not used. These can be paired with each other. The number of pairs is min(remaining_left_q, remaining_right_q).\n\nSo step 4: pair remaining left_q with remaining right_q.\n\nSo adding that step.\n\nSo, the full plan is:\n\nSteps:\n\n1. Pair same-colored non-? boots (step 1).\n\n2. Pair left_non_q (specific colors) with right_q (step 2).\n\n3. Pair right_non_q (specific colors) with left_q (step 3).\n\n4. Pair remaining left_q and right_q (step 4).\n\nSo, this way, all possibilities are covered.\n\nNow, how to implement this.\n\nBut how to collect the lists for each step. Let's think about data structures.\n\nWe need to track which left and right boots are used. So, for example, have two arrays: used_left and used_right, of size n, initialized to False.\n\nThen, during each step, we collect the indices that are not used and meet the criteria.\n\nBut for step 1, for each color c (a-z), collect all left indices with color c and not used, and same for right. Then pair as much as possible.\n\nBut for large n (up to 150000), we need an efficient way to collect these.\n\nBut for Python, even O(n) per color is manageable, since 26 * 150000 is 3.9 million, which is acceptable.\n\nSo, for step 1:\n\nWe can pre-process for each color, the list of left and right indices. For example, for each color c, have left_positions[c] = list of indices where l[i] == c. Similarly for right_positions[c].\n\nBut then, during step 1, we need to iterate through each color, and for each, pair as much as possible.\n\nBut during that process, we need to mark the indices as used.\n\nAlternatively, during the pairing steps, we can collect the available indices for each color.\n\nBut for code, perhaps the following approach:\n\nInitialize used_left and used_right as [False] * n.\n\nFor step 1:\n\nfor each color c in 'a' to 'z':\n\n   collect left_candidates = [i for i in range(n) if l[i] == c and not used_left[i]]\n\n   collect right_candidates = [i for i in range(n) if r[i] == c and not used_right[i]]\n\n   m = min(len(left_candidates), len(right_candidates))\n\n   for i in range(m):\n\n       pair left_candidates[i] with right_candidates[i]\n\n       mark used_left[left_candidates[i]] = True\n\n       mark used_right[right_candidates[i]] = True\n\nBut this would take O(n) time for each color, which is acceptable.\n\nBut for n=1.5e5, and 26 colors, this is 26 * O(n) = acceptable.\n\nBut for Python, list comprehensions may be slow. So perhaps we can precompute for each color, the list of indices, and then during step 1, process them.\n\nBut perhaps a better way is to loop through each color, and for each, collect the left and right indices.\n\nOnce that is done, step 2:\n\nCollect all left indices not used and with color != '?'. Similarly, collect all right indices not used and with color '?'.\n\nThen, pair as much as possible.\n\nSame for step 3.\n\nThen, step 4: collect all left indices not used and color '?', and same for right. Pair as much as possible.\n\nBut how to collect these lists.\n\nFor step 2:\n\nleft_non_q = [i for i in range(n) if not used_left[i] and l[i] != '?']\nright_q = [i for i in range(n) if not used_right[i] and r[i] == '?']\n\nThen, the number of pairs is min(len(left_non_q), len(right_q)).\n\nWe can pair the first m elements of left_non_q with first m elements of right_q.\n\nSimilarly for step 3:\n\nright_non_q = [i for i in range(n) if not used_right[i] and r[i] != '?']\nleft_q = [i for i in range(n) if not used_left[i] and l[i] == '?']\n\npairs = min(len(right_non_q), len(left_q)).\n\nPair them.\n\nThen, step 4:\n\nleft_q_remaining = [i for i in range(n) if not used_left[i] and l[i] == '?']\nright_q_remaining = [i for i in range(n) if not used_right[i] and r[i] == '?']\n\npairs = min(len(left_q_remaining), len(right_q_remaining))\n\nPair them.\n\nBut this approach is O(n) for each of the steps, which is acceptable.\n\nBut for very large n, this could be time-consuming. However, given that n is up to 1.5e5, and each step is O(n), it's manageable.\n\nNow, the code structure:\n\nRead n, l, r.\n\nused_left = [False] * n\n\nused_right = [False] * n\n\npairs = []\n\nThen, step 1:\n\nfor c in 'a' to 'z':\n\n   left_candidates = [i for i in range(n) if l[i] == c and not used_left[i]]\n\n   right_candidates = [i for i in range(n) if r[i] == c and not used_right[i]]\n\n   m = min(len(left_candidates), len(right_candidates))\n\n   for i in range(m):\n\n       pairs.append( (left_candidates[i]+1, right_candidates[i]+1) )\n\n       used_left[left_candidates[i]] = True\n\n       used_right[right_candidates[i]] = True\n\nBut this is O(n) per color, which for 26 colors is acceptable.\n\nBut for large n, generating these lists for each color may be slow. So perhaps a better way is to precompute for each color, the list of indices. For example:\n\nfrom collections import defaultdict\n\nleft_color_map = defaultdict(list)\n\nright_color_map = defaultdict(list)\n\nfor i in range(n):\n\n    left_color_map[l[i]].append(i)\n\n    right_color_map[r[i]].append(i)\n\nThen, during step 1, for each color c in left_color_map and right_color_map, we can process. But even that may not be efficient, since for each color, we need to check which indices are not yet used. But perhaps during step 1, for each color c, we can iterate through the left and right lists, and pair as much as possible.\n\nBut how to track which indices are used. For example, for left_color_map[c], which is a list of indices. But during step 1, some of them may have been already used. So perhaps for each color, during step 1, we need to iterate through the list, and collect the indices that are not used. But this would be O(n) for each color again.\n\nAlternatively, during step 1, for each color c, we can have pointers to the current position in the left and right lists, and pair as much as possible.\n\nBut perhaps that's getting too complicated.\n\nAlternatively, during step 1, for each color c, process all left and right indices for that color, and pair as much as possible. But for that, we can have for each color, a list of left and right indices, and then for each pair, we can pair them in order, and mark them as used.\n\nBut for example, for color 'a', left list is [0, 2, 5], right list is [1, 3, 6]. We can pair 0 with 1, 2 with 3, 5 with 6. So that's 3 pairs. But if the right list has more elements, like [1,3,6,7], then we pair 0 with 1, 2 with 3, 5 with 6, and leave 7 unpaired.\n\nSo, for each color c, we can process the left and right lists, and pair them in order. But how to track which indices are already used. Well, since during step 1, the used_left and used_right arrays are initially all False, and once marked as True, they are not processed again.\n\nThus, for each color c in 'a' to 'z':\n\n   left_list = left_color_map.get(c, [])\n\n   right_list = right_color_map.get(c, [])\n\n   i = 0\n\n   j = 0\n\n   while i < len(left_list) and j < len(right_list):\n\n       if not used_left[left_list[i]] and not used_right[right_list[j]]:\n\n           # pair them\n\n           pairs.append( (left_list[i]+1, right_list[j]+1) )\n\n           used_left[left_list[i]] = True\n\n           used_right[right_list[j]] = True\n\n           i += 1\n\n           j += 1\n\n       elif not used_left[left_list[i]]:\n\n           # the right_list[j] is already used, so move j\n\n           j += 1\n\n       else:\n\n           # the left_list[i] is used, move i\n\n           i += 1\n\nBut this approach would process each color's left and right lists, and pair them as long as they are not used. However, this could be time-consuming for large n.\n\nAlternatively, perhaps the initial approach of generating lists for each color during step 1 is better.\n\nBut for code, perhaps the first approach is easier to implement.\n\nBut considering that for each color, we can generate the list of left and right indices that are not used, and then pair them. However, for each color, this would take O(n) time, but for 26 colors, it's manageable.\n\nBut for n=1.5e5, and per color O(n), that's 1.5e5 * 26 = 3.9e6 operations, which is acceptable.\n\nSo, the code for step 1 would be:\n\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n\n    left_candidates = [i for i in range(n) if l[i] == c and not used_left[i]]\n\n    right_candidates = [i for i in range(n) if r[i] == c and not used_right[i]]\n\n    m = min(len(left_candidates), len(right_candidates))\n\n    for i in range(m):\n\n        pairs.append( (left_candidates[i]+1, right_candidates[i]+1) )\n\n        used_left[left_candidates[i]] = True\n\n        used_right[right_candidates[i]] = True\n\nBut this is O(n) per color, which is acceptable.\n\nOnce step 1 is done, proceed to step 2.\n\nFor step 2:\n\nCollect left_non_q = [i for i in range(n) if not used_left[i] and l[i] != '?'] \n\nright_q = [i for i in range(n) if not used_right[i] and r[i] == '?'] \n\nm = min(len(left_non_q), len(right_q))\n\nfor i in range(m):\n\n    pairs.append( (left_non_q[i]+1, right_q[i]+1) )\n\n    used_left[left_non_q[i]] = True\n\n    used_right[right_q[i]] = True\n\nSimilarly for step 3:\n\nright_non_q = [i for i in range(n) if not used_right[i] and r[i] != '?']\n\nleft_q = [i for i in range(n) if not used_left[i] and l[i] == '?']\n\nm = min(len(right_non_q), len(left_q))\n\nfor i in range(m):\n\n    pairs.append( (left_q[i]+1, right_non_q[i]+1) )\n\n    used_left[left_q[i]] = True\n\n    used_right[right_non_q[i]] = True\n\nThen step 4:\n\nleft_q_remaining = [i for i in range(n) if not used_left[i] and l[i] == '?']\n\nright_q_remaining = [i for i in range(n) if not used_right[i] and r[i] == '?']\n\nm = min(len(left_q_remaining), len(right_q_remaining))\n\nfor i in range(m):\n\n    pairs.append( (left_q_remaining[i]+1, right_q_remaining[i]+1) )\n\n    used_left[left_q_remaining[i]] = True\n\n    used_right[right_q_remaining[i]] = True\n\nThis would cover all possible pairs.\n\nNow, the problem is that in the code, for each step, we are generating lists of indices that are not used. But for large n, generating these lists can be time-consuming. However, given that n is up to 1.5e5, and each step is O(n), it's manageable.\n\nBut in Python, list comprehensions are efficient enough for this.\n\nNow, the code needs to read input, process as above, and output the pairs.\n\nBut let's test the sample input.\n\nSample Input 1:\n\n['10\\ncodeforces\\ndodivthree', ...]\n\nWait, the sample input seems to have multiple test cases. Wait, looking back:\n\nThe user provided an example input with four different test cases. But the problem says that the input is given as per the problem statement. So, the actual input is:\n\nThe first line is n.\n\nSecond line is l.\n\nThird line is r.\n\nBut in the sample input, the user shows multiple test cases. However, the problem says that the code should read from stdin and output to stdout. So the code should handle one test case per run.\n\nBut the sample input seems to be a list of test cases. However, the problem's input format is as follows:\n\nThe first line contains n.\n\nSecond line is l.\n\nThird line is r.\n\nSo the code should read n, l, r, and output the answer.\n\nBut the sample input given by the user seems to be multiple test cases. However, perhaps the user is providing multiple examples, but the actual code should handle one test case per run.\n\nSo, the code should read n, then l, then r.\n\nNow, for the code.\n\nBut let's think about the code structure.\n\nIn Python, the code would read from stdin. So:\n\nimport sys\n\nn = int(sys.stdin.readline())\n\nl = sys.stdin.readline().strip()\n\nr = sys.stdin.readline().strip()\n\nBut then, for some cases, the input may have leading/trailing spaces. But the problem says that l and r are strings of length n, so we can assume that after reading, the strings are correctly of length n.\n\nOnce that is read, proceed with the steps.\n\nNow, code:\n\nImplement the steps as discussed.\n\nNow, let's think about the sample input given in the example.\n\nSample Input 1:\n\n10\n\ncodeforces\n\ndodivthree\n\nSample Output 1:\n\n5\n\n7 8\n\n4 9\n\n2 2\n\n9 10\n\n3 1\n\nBut I'm not going to check that now. Let's proceed with writing the code.\n\nPotential issues:\n\n- The order in which the pairs are generated may affect the actual pairs, but the problem allows any valid answer.\n\n- The code must not use the same boot more than once.\n\n- The code must collect all possible pairs.\n\nNow, the code:\n\nImplementing the steps.\n\nNow, code:\n\nRead n, l, r.\n\nInitialize used_left and used_right as [False] * n.\n\npairs = list()\n\nThen, for step 1:\n\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n\n    left_candidates = [i for i in range(n) if l[i] == c and not used_left[i]]\n\n    right_candidates = [i for i in range(n) if r[i] == c and not used_right[i]]\n\n    m = min(len(left_candidates), len(right_candidates))\n\n    for i in range(m):\n\n        pairs.append( (left_candidates[i]+1, right_candidates[i]+1) )\n\n        used_left[left_candidates[i]] = True\n\n        used_right[right_candidates[i]] = True\n\nThen step 2:\n\nleft_non_q = [i for i in range(n) if not used_left[i] and l[i] != '?']\n\nright_q = [i for i in range(n) if not used_right[i] and r[i] == '?']\n\nm = min(len(left_non_q), len(right_q))\n\nfor i in range(m):\n\n    pairs.append( (left_non_q[i]+1, right_q[i]+1) )\n\n    used_left[left_non_q[i]] = True\n\n    used_right[right_q[i]] = True\n\nThen step 3:\n\nright_non_q = [i for i in range(n) if not used_right[i] and r[i] != '?']\n\nleft_q = [i for i in range(n) if not used_left[i] and l[i] == '?']\n\nm = min(len(right_non_q), len(left_q))\n\nfor i in range(m):\n\n    pairs.append( (left_q[i]+1, right_non_q[i]+1) )\n\n    used_left[left_q[i]] = True\n\n    used_right[right_non_q[i]] = True\n\nThen step 4:\n\nleft_q_remaining = [i for i in range(n) if not used_left[i] and l[i] == '?']\n\nright_q_remaining = [i for i in range(n) if not used_right[i] and r[i] == '?']\n\nm = min(len(left_q_remaining), len(right_q_remaining))\n\nfor i in range(m):\n\n    pairs.append( (left_q_remaining[i]+1, right_q_remaining[i]+1) )\n\n    used_left[left_q_remaining[i]] = True\n\n    used_right[right_q_remaining[i]] = True\n\nThen, output len(pairs), followed by the pairs.\n\nBut wait, for the sample input given in the first example, the code would generate the correct output?\n\nBut perhaps there's a mistake here. For example, in step 1, when processing each color, the code collects all left_candidates and right_candidates. But for each color, the code may process the same indices multiple times. However, since used_left and used_right are marked as True once paired, they are not included in subsequent steps.\n\nYes.\n\nNow, possible optimizations:\n\nIn Python, list comprehensions can be slow for very large n. However, for the constraints given, it's manageable.\n\nBut for n=15000",
    "response": "\n\nTo solve this problem, we need to determine the maximum number of compatible pairs of left and right boots based on their colors. Each boot can be either a specific color (a lowercase letter) or an indefinite color (denoted by '?'). A specific color is compatible with another boot of the same color or an indefinite color, while an indefinite color is compatible with any color.\n\n### Approach\n1. **Pair Same-Colored Boots**: First, pair all left boots with the same color as right boots. This is done for each specific color from 'a' to 'z'.\n2. **Pair Specific Colors with Indefinite Colors**: After pairing same-colored boots, use the remaining specific colored boots to pair with indefinite colored boots from the opposite side.\n3. **Pair Remaining Indefinite Colors**: Finally, pair any remaining indefinite colored boots with each other if possible.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n    \n    used_left = [False] * n\n    used_right = [False] * n\n    pairs = []\n    \n    # Step 1: Pair same-colored non-? boots\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_candidates = []\n        for i in range(n):\n            if l[i] == c and not used_left[i]:\n                left_candidates.append(i)\n        right_candidates = []\n        for i in range(n):\n            if r[i] == c and not used_right[i]:\n                right_candidates.append(i)\n        m = min(len(left_candidates), len(right_candidates))\n        for i in range(m):\n            pairs.append((left_candidates[i] + 1, right_candidates[i] + 1))\n            used_left[left_candidates[i]] = True\n            used_right[right_candidates[i]] = True\n    \n    # Step 2: Pair left_non_q with right_q\n    left_non_q = []\n    for i in range(n):\n        if not used_left[i] and l[i] != '?':\n            left_non_q.append(i)\n    right_q = []\n    for i in range(n):\n        if not used_right[i] and r[i] == '?':\n            right_q.append(i)\n    m = min(len(left_non_q), len(right_q))\n    for i in range(m):\n        pairs.append((left_non_q[i] + 1, right_q[i] + 1))\n        used_left[left_non_q[i]] = True\n        used_right[right_q[i]] = True\n    \n    # Step 3: Pair right_non_q with left_q\n    right_non_q = []\n    for i in range(n):\n        if not used_right[i] and r[i] != '?':\n            right_non_q.append(i)\n    left_q = []\n    for i in range(n):\n        if not used_left[i] and l[i] == '?':\n            left_q.append(i)\n    m = min(len(right_non_q), len(left_q))\n    for i in range(m):\n        pairs.append((left_q[i] + 1, right_non_q[i] + 1))\n        used_left[left_q[i]] = True\n        used_right[right_non_q[i]] = True\n    \n    # Step 4: Pair remaining ? with ?\n    left_q_remaining = []\n    for i in range(n):\n        if not used_left[i] and l[i] == '?':\n            left_q_remaining.append(i)\n    right_q_remaining = []\n    for i in range(n):\n        if not used_right[i] and r[i] == '?':\n            right_q_remaining.append(i)\n    m = min(len(left_q_remaining), len(right_q_remaining))\n    for i in range(m):\n        pairs.append((left_q_remaining[i] + 1, right_q_remaining[i] + 1))\n        used_left[left_q_remaining[i]] = True\n        used_right[right_q_remaining[i]] = True\n    \n    print(len(pairs))\n    for p in pairs:\n        print(p[0], p[1])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, which includes the number of boots and their respective color strings.\n2. **Tracking Usage**: Arrays `used_left` and `used_right` track which boots have been paired already.\n3. **Step 1**: For each color from 'a' to 'z', we find all left and right boots of that color that haven't been used yet and pair them.\n4. **Step 2**: After handling same-colored pairs, we pair remaining specific colored boots with indefinite colored boots from the opposite side.\n5. **Step 3**: Similarly, we pair remaining specific colored right boots with indefinite colored left boots.\n6. **Step 4**: Finally, any remaining indefinite colored boots are paired with each other.\n\nThis approach ensures that we maximize the number of compatible pairs efficiently while adhering to the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n    \n    used_left = [False] * n\n    used_right = [False] * n\n    pairs = []\n    \n    # Step 1: Pair same-colored non-? boots\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_candidates = []\n        for i in range(n):\n            if l[i] == c and not used_left[i]:\n                left_candidates.append(i)\n        right_candidates = []\n        for i in range(n):\n            if r[i] == c and not used_right[i]:\n                right_candidates.append(i)\n        m = min(len(left_candidates), len(right_candidates))\n        for i in range(m):\n            pairs.append((left_candidates[i] + 1, right_candidates[i] + 1))\n            used_left[left_candidates[i]] = True\n            used_right[right_candidates[i]] = True\n    \n    # Step 2: Pair left_non_q with right_q\n    left_non_q = []\n    for i in range(n):\n        if not used_left[i] and l[i] != '?':\n            left_non_q.append(i)\n    right_q = []\n    for i in range(n):\n        if not used_right[i] and r[i] == '?':\n            right_q.append(i)\n    m = min(len(left_non_q), len(right_q))\n    for i in range(m):\n        pairs.append((left_non_q[i] + 1, right_q[i] + 1))\n        used_left[left_non_q[i]] = True\n        used_right[right_q[i]] = True\n    \n    # Step 3: Pair right_non_q with left_q\n    right_non_q = []\n    for i in range(n):\n        if not used_right[i] and r[i] != '?':\n            right_non_q.append(i)\n    left_q = []\n    for i in range(n):\n        if not used_left[i] and l[i] == '?':\n            left_q.append(i)\n    m = min(len(right_non_q), len(left_q))\n    for i in range(m):\n        pairs.append((left_q[i] + 1, right_non_q[i] + 1))\n        used_left[left_q[i]] = True\n        used_right[right_non_q[i]] = True\n    \n    # Step 4: Pair remaining ? with ?\n    left_q_remaining = []\n    for i in range(n):\n        if not used_left[i] and l[i] == '?':\n            left_q_remaining.append(i)\n    right_q_remaining = []\n    for i in range(n):\n        if not used_right[i] and r[i] == '?':\n            right_q_remaining.append(i)\n    m = min(len(left_q_remaining), len(right_q_remaining))\n    for i in range(m):\n        pairs.append((left_q_remaining[i] + 1, right_q_remaining[i] + 1))\n        used_left[left_q_remaining[i]] = True\n        used_right[right_q_remaining[i]] = True\n    \n    print(len(pairs))\n    for p in pairs:\n        print(p[0], p[1])\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 1028,
        "thoughts_token_count": 8191
    }
}