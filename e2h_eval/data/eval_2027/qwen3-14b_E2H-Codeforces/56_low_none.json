{
    "start": 1758309273.9913769,
    "end": 1758309507.4601095,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about assigning R Rebel spaceships to B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. Additionally, the paths between each spaceship and its assigned base must not intersect with any other path. The key here is that the paths are straight lines, and no two of them should cross in the 2D plane. Also, the input guarantees that no two points are the same and no three are colinear. \n\nSo, the first thing I need to check is whether there's a perfect matching between the spaceships and bases. But since R and B are up to 10, maybe we can check all possible permutations. However, even more importantly, for each possible matching, we need to check if all the line segments between the pairs do not intersect each other.\n\nWait, but how do I check if any two line segments intersect? Because for a given permutation (matching), all the line segments must be non-intersecting. So for each possible matching, I need to check all pairs of line segments to see if they cross.\n\nBut first, the problem says that R and B are equal. Wait, the input says R and B. Wait, the first line has R and B. Wait, the problem says that the assignment is a perfect matching. So that requires that R equals B. Otherwise, it's impossible. Oh, right! Because a perfect matching requires that the number of spaceships equals the number of bases. So, if R != B, then the answer is automatically No. But looking at the input constraints, the first line has R and B. So in the code, first check if R != B. If so, output No. Otherwise, proceed.\n\nSo that's the first check. For example, in the second sample input, the input is 2 1. So R=2, B=1. So output is No. Which matches the sample.\n\nSo, the first step is to check if R != B. If not, return No.\n\nThen, for the case where R = B, we need to check if there exists a perfect matching (permutation) of the spaceships to bases such that all the line segments between the pairs don't cross each other.\n\nNow, how to approach this?\n\nSince R and B are up to 10, the total number of possible permutations is 10! = 3.6 million. For each permutation, we need to check all pairs of line segments for intersection. For each permutation, checking O(R^2) pairs. For R=10, that's 100 checks per permutation. So total operations would be around 3.6e6 * 100 = 3.6e8. Wait, that's 360 million operations. That might be too slow for Python, which is generally slower than C++. But wait, R and B are up to 10. Let me think again. For R=10, 10! is 3,628,800. For each permutation, checking all pairs of line segments. For each pair of line segments, check if they intersect. How many pairs? For R=10, there are 10 line segments. The number of pairs is C(10, 2) = 45. So for each permutation, 45 checks. So total operations would be 3.6 million * 45 = 163 million. That's a lot. But maybe with optimizations, it can work. However, for R=10, that's manageable? Let me think. Let's see, in Python, perhaps each check is a few operations. But maybe there's a smarter way. Alternatively, perhaps there's a way to find a matching that satisfies the condition without checking all permutations. But for small R and B, perhaps brute force is acceptable.\n\nBut how to check if two line segments intersect?\n\nFirst, I need to implement a function that takes two line segments (each defined by two points) and returns True if they intersect, False otherwise.\n\nBut how to do that? The standard approach is to check if the two line segments intersect using the orientation method. The steps are:\n\nFor two line segments AB and CD:\n\n- Check if they intersect by checking if the orientations of (A, B, C) and (A, B, D) are different, and similarly for (C, D, A) and (C, D, B). Also, handle cases where points are colinear and overlapping.\n\nBut given the problem's note that no three points are colinear. Wait, the problem says that no three points are on the same line. So for any two line segments, they cannot have three points on the same line. So, in our case, when checking for intersection between two line segments, if they are not colinear",
    "response": "To solve this problem, we need to determine if we can assign Rebel spaceships to bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base, with the additional constraint that no two paths (straight lines) between a spaceship and its assigned base intersect.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, it's impossible to have a perfect matching, so the answer is immediately \"No\".\n2. **Generate Permutations**: For the case where R equals B, generate all permutations of the bases. Each permutation represents a potential assignment of spaceships to bases.\n3. **Check for Intersections**: For each permutation, check if any pair of line segments (paths from spaceships to their assigned bases) intersect. This is done using a helper function that determines if two line segments intersect by checking their orientations.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    input_str = sys.stdin.read().strip()\n    inputs = input_str.split('\\n')\n    return inputs\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(a, c, b):\n        return True\n    if o2 == 0 and on_segment(a, d, b):\n        return True\n    if o3 == 0 and on_segment(c, a, d):\n        return True\n    if o4 == 0 and on_segment(c, b, d):\n        return True\n\n    return False\n\ndef main():\n    inputs = read_input()\n    idx = 0\n    R = int(inputs[idx].split()[0])\n    B = int(inputs[idx].split()[1])\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, inputs[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, inputs[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        intersect = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Orientation Check**: The `orientation` function determines the orientation of three points, which helps in checking if line segments intersect.\n- **Intersection Check**: The `segments_intersect` function uses the orientation method to determine if two line segments intersect, considering both general and colinear cases.\n- **Permutations and Checks**: For each permutation of bases, we check if all line segments between spaceships and their assigned bases do not intersect. If any valid permutation is found, \"Yes\" is printed; otherwise, \"No\".\n\nThis approach ensures that we check all possible assignments efficiently given the constraints, leveraging permutations and geometric intersection checks.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    input_str = sys.stdin.read().strip()\n    inputs = input_str.split('\\n')\n    return inputs\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(a, c, b):\n        return True\n    if o2 == 0 and on_segment(a, d, b):\n        return True\n    if o3 == 0 and on_segment(c, a, d):\n        return True\n    if o4 == 0 and on_segment(c, b, d):\n        return True\n\n    return False\n\ndef main():\n    inputs = read_input()\n    idx = 0\n    R = int(inputs[idx].split()[0])\n    B = int(inputs[idx].split()[1])\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, inputs[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, inputs[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        intersect = False\n        for i in range(R):\n            for j in range(i + 1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 950,
        "thoughts_token_count": 1024
    }
}