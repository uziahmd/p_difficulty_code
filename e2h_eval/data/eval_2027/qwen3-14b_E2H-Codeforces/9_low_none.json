{
    "start": 1758313837.9671054,
    "end": 1758314029.3936071,
    "start-formatted": "2025-09-20 05:30 KST",
    "end-formatted": "2025-09-20 05:33 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (which can be 1, 2, or 3) and a cost. The total weight can't exceed m. And n can be up to 1e5, m up to 3e5. Hmm, so we need an efficient algorithm here.\n\nFirst, I remember that this is a variation of the knapsack problem. But since the weights are limited to 1, 2, 3, maybe there's a way to optimize it. The standard knapsack approach would be O(nm), which for n=1e5 and m=3e5 would be way too slow. So we need a smarter approach.\n\nLet me think. For items with small weights, perhaps we can group them by their weight and then process them in a way that allows us to compute the maximum value efficiently.\n\nSo, for each weight (1, 2, 3), we can sort the items in descending order of cost. Then, for each weight category, we can precompute the prefix sums. That way, when considering how many items of that weight to take, we can quickly calculate the total cost.\n\nBut how do we combine these three groups to maximize the total value?\n\nLet me outline the steps:\n\n1. Separate the items into three groups based on their weight: w=1, w=2, w=3.\n2. Sort each group in descending order of cost. Then compute prefix sums for each group. For example, for weight 1 items, prefix_sum[i] is the sum of the first i items' costs.\n3. Now, the problem becomes selecting a certain number of items from each group such that the total weight is <= m, and the total cost is maximized.\n\nThe challenge is to find the optimal combination of counts for each weight.\n\nLet me think about how to approach this. For example, for each possible number of weight 1 items (say x), and weight 2 items (y), and weight 3 items (z), we need x + 2y + 3z ≤ m. But trying all combinations is not feasible.\n\nAlternative idea: Since the weights are small, maybe we can iterate through possible numbers of one of the weights and compute the best possible for the others.\n\nFor example, let's consider that for each possible number of weight 3 items (say z), we can compute the remaining capacity and then find the best combination of weight 1 and 2 items. However, even this might be expensive if done naively.\n\nBut since the maximum possible z is m//3, which for m=3e5 is around 1e5. That's manageable? Let's see. If we loop through all possible z (up to m//3), and for each z, compute the best possible for weight 1 and 2 items with the remaining capacity (m - 3*z), then that might be feasible.\n\nBut how do we compute the best for weight 1 and 2 items given a certain capacity?\n\nFor that, perhaps we can precompute the prefix sums for weight 1 and 2. Then, for a given capacity left (let's say rem = m - 3*z), we can try all possible numbers of weight 2 items (y), and then take as many weight 1 items as possible.\n\nWait, but even that could be O(m) for each z. Which would be O(m^2) in the worst case, which is not feasible.\n\nAlternative approach for combining weight 1 and 2 items:\n\nLet's suppose we have a certain capacity rem. How to choose x and y where x + 2y ≤ rem, and x is the number of weight 1 items, y the number of weight 2 items. We want to maximize the sum of the prefix sums of x and y.\n\nBut since the weight 1 and 2 items are sorted, the optimal way to choose x and y for a given rem is to take as many as possible of the higher value items.\n\nBut how to compute that quickly?\n\nLet me think. For the weight 1 and 2 items, we can precompute their prefix sums. Let's say for weight 1, the prefix sum is s1, and for weight 2, it's s2. Then, for a given rem, we can iterate over possible y (number of weight 2 items) and then take x = min(rem - 2*y, len1) where len1 is the number of weight 1 items. Then, the total is s1[x] + s2[y]. But again, for each rem, this would take O(k) time where k is the number of weight 2 items, which could be O(n) per rem. Which would be too slow.\n\nBut perhaps there's a smarter way. Let",
    "response": "To solve this problem efficiently, we need to maximize the total cost of souvenirs Petya can carry given a weight constraint. The key insight is that the weights of the souvenirs are limited to 1, 2, or 3, which allows us to use a greedy approach combined with prefix sums to optimize the solution.\n\n### Approach\n1. **Group Items by Weight**: Separate the items into three groups based on their weight (1, 2, and 3).\n2. **Sort and Compute Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums. This helps in quickly determining the maximum value for a given number of items.\n3. **Iterate Over Possible Counts of Heaviest Items**: For each possible count of weight 3 items, calculate the remaining capacity and determine the optimal combination of weight 1 and 2 items that fit within this capacity using a two-pointer technique.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n\n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n\n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n\n    max_total = 0\n\n    # Try all possible numbers of weight 3 items\n    max_z = min(len(w3), m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3 * z\n        # Now find best x and y such that x + 2y <= rem\n        # Use two pointers approach for w1 and w2\n        i = len(prefix1) - 1  # number of w1 items\n        j = len(prefix2) - 1  # number of w2 items\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = i + 2 * j\n            if weight <= rem:\n                current = prefix1[i] + prefix2[j]\n                if current > best:\n                    best = current\n                # Try to take more w2 items\n                j -= 1\n            else:\n                # Need to reduce w1 items\n                i -= 1\n        # Also check when i=0 or j=0\n        while i >= 0:\n            if i <= rem:\n                current = prefix1[i] + prefix2[0]\n                if current > best:\n                    best = current\n                i -= 1\n            else:\n                break\n        while j >= 0:\n            if 2 * j <= rem:\n                current = prefix1[0] + prefix2[j]\n                if current > best:\n                    best = current\n                j -= 1\n            else:\n                break\n        total = best + prefix3[z]\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping and Sorting**: Items are grouped by their weights and sorted to prioritize higher value items.\n- **Prefix Sums**: These allow quick calculation of the total value for any number of items taken from each group.\n- **Two-Pointer Technique**: This efficiently finds the optimal combination of weight 1 and 2 items for the remaining capacity after considering weight 3 items, ensuring the solution is both optimal and efficient.\n\nThis approach ensures that we handle the constraints effectively, leveraging the small weight values to optimize the solution using greedy methods and prefix sums.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n\n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n\n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n\n    max_total = 0\n\n    # Try all possible numbers of weight 3 items\n    max_z = min(len(w3), m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3 * z\n        # Now find best x and y such that x + 2y <= rem\n        # Use two pointers approach for w1 and w2\n        i = len(prefix1) - 1  # number of w1 items\n        j = len(prefix2) - 1  # number of w2 items\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = i + 2 * j\n            if weight <= rem:\n                current = prefix1[i] + prefix2[j]\n                if current > best:\n                    best = current\n                # Try to take more w2 items\n                j -= 1\n            else:\n                # Need to reduce w1 items\n                i -= 1\n        # Also check when i=0 or j=0\n        while i >= 0:\n            if i <= rem:\n                current = prefix1[i] + prefix2[0]\n                if current > best:\n                    best = current\n                i -= 1\n            else:\n                break\n        while j >= 0:\n            if 2 * j <= rem:\n                current = prefix1[0] + prefix2[j]\n                if current > best:\n                    best = current\n                j -= 1\n            else:\n                break\n        total = best + prefix3[z]\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 933,
        "thoughts_token_count": 1024
    }
}