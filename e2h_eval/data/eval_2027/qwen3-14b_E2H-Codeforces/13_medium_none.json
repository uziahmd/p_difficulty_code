{
    "start": 1758019529.947166,
    "end": 1758021603.8081815,
    "start-formatted": "2025-09-16 19:45 KST",
    "end-formatted": "2025-09-16 20:20 KST",
    "gpu": 2,
    "pid": 13,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to determine whether a given set of three musical notes forms a major triad, a minor triad, or neither. The input is three notes, and we have to check all possible orderings to see if any of them fit the major or minor criteria.\n\nFirst, I need to understand how the distances between notes are calculated. The notes are arranged in a cyclic order of 12 notes. Each consecutive note is a semitone apart. So, the distance between two notes is the number of semitones from the first to the second when moving upwards. For example, C to E is 4 semitones (C to C# is 1, C# to D is 2, etc., up to E). But if the distance is calculated the other way around, like E to C, it's 8 semitones because you go through all the notes up to C again. Wait, but the problem says that the distance is measured from the lower to the upper note. So, when calculating the distance between X and Y, we need to find the number of semitones when moving from X to Y in the upward direction. So for example, if X is E and Y is C, then since E is higher than C, maybe the distance is considered as the number of steps from E to C going upwards? Wait, no. Wait, the problem says: \"the distance between X and Y is taken from the lowest tone to the uppest one.\" So if X is lower than Y, then the distance is positive. Otherwise, if X is higher than Y, then the distance would be calculated by wrapping around? Or perhaps the distance is calculated as the minimal steps? No, no. Let me recheck the problem statement.\n\nThe problem says: \"the distance between X and Y is taken from the lowest tone to the uppest one. So for example, the distance between C and E is 4 semitones and between E and C is 8 semitones.\" Oh right, because when you go from C to E, you have 4 semitones. But when you go from E to C, since you have to go up, you wrap around. Let's think: there are 12 notes. So the distance from E to C would be (C is 0, E is 4?), wait, maybe I should assign each note a numerical value. Let's list the notes in order:\n\nThe order is: C, C#, D, D#, E, F, F#, G, G#, A, B, H. Then after H comes C again.\n\nSo each note can be mapped to an index from 0 to 11. For example, C is 0, C# is 1, D is 2, D# is 3, E is 4, F is 5, F# is 6, G is 7, G# is 8, A is 9, B is 10, H is 11. Then, the next note after H (index 11) is C (index 0).\n\nSo the distance between two notes X and Y is calculated as (Y's index - X's index) mod 12, but only if we are going from X to Y upwards. Wait, no. Wait, the problem says that the distance between X and Y is the number of semitones when moving from the lower to the upper. So if X is lower than Y, then it's Y's index - X's index. But if X is higher than Y, then the distance is (12 - (X's index - Y's index))? Or maybe it's (Y's index + 12 - X's index) mod 12? Wait, no. For example, the distance between E (index 4) and C (index 0) is 8 semitones. Because if you start at E, you go up to F (1), F# (2), G (3), G# (4), A (5), B (6), H (7), C (8). So that's 8 steps. So the formula for the distance between X and Y is (Y_index - X_index) if Y is higher than X, else (Y_index + 12 - X_index). Which can be written as (Y_index - X_index) mod 12? Wait, no. Because (Y_index - X_index) mod 12 gives the difference in the cyclic way. But for example, if X is E (4) and Y is C (0), then (0 -4) mod 12 is 8, which is correct. So yes, the distance between X and Y is (Y_index - X_index) mod 12. But wait, the problem says that the distance between X and Y is the number of semitones from the lower to upper. So when X is lower than Y, the distance is Y - X. When X is higher than Y, the distance is (Y + 12 - X). Which is the same as (Y - X) mod 12, but since mod can give negative numbers, but in Python, the modulo operator returns a non-negative result. Wait, for example, (0 -4) mod 12 is 8. So yes, the distance between X and Y is (Y_index - X_index) mod 12. But since the problem says that the distance is taken from the lowest to the upper, so for example, if X is lower than Y, then the distance is positive. If X is higher than Y, then the distance is the number of semitones when moving up from X to Y, which wraps around. So that formula gives the correct value.\n\nSo the key is to compute for any pair of notes, the distance between them in semitones, using that formula.\n\nNow, the problem says that a major triad is when, after ordering the notes as X, Y, Z, the distance between X and Y is 4 semitones, and between Y and Z is 3. So the total between X and Z is 7. Similarly, a minor triad is when the distance between X and Y is 3, and between Y and Z is 4.\n\nBut since the triad is unordered, we need to check all possible permutations of the three notes to see if any permutation satisfies either the major or minor condition.\n\nSo the approach is:\n\n- For the three given notes, generate all possible permutations (since the order matters for checking the distances).\n\n- For each permutation (X, Y, Z), check if the distance between X and Y is 4 and between Y and Z is 3. If yes, then it's a major triad.\n\n- Also check if the distance between X and Y is 3 and between Y and Z is 4. If yes, then it's a minor triad.\n\n- If any permutation satisfies major, then output 'major'. Similarly for minor. If none, output 'strange'.\n\nBut since the problem says that the answer is unambiguous, we don't have to worry about overlapping cases.\n\nSo the steps:\n\nFirst, create a mapping from note names to their indices. Let's make a dictionary for that. The notes are in the order given in the problem statement: C, C#, D, D#, E, F, F#, G, G#, A, B, H. So the indexes are 0 to 11.\n\nSo the dictionary would be:\n\nnote_to_index = {\n    'C': 0,\n    'C#': 1,\n    'D': 2,\n    'D#': 3,\n    'E': 4,\n    'F': 5,\n    'F#': 6,\n    'G': 7,\n    'G#': 8,\n    'A': 9,\n    'B': 10,\n    'H': 11\n}\n\nWait, but what about the note 'B' and 'H'? The problem says that the notes are C, C#, D, D#, E, F, F#, G, G#, A, B, H. So B is the 10th index, H is 11th. So that's correct.\n\nOnce we have the three notes converted into their indices, we can generate all permutations of the three elements. For each permutation, check for major or minor.\n\nBut how many permutations are there? For three elements, there are 3! = 6 permutations. For each permutation, we can check the two conditions.\n\nSo, for each permutation (X, Y, Z):\n\nCheck if (distance between X and Y) is 4 and (distance between Y and Z) is 3. If yes, then it's a major.\n\nCheck if (distance between X and Y) is 3 and (distance between Y and Z) is 4. If yes, then it's a minor.\n\nIf any permutation meets the major condition, then the answer is 'major'. Similarly for minor.\n\nSo the plan is:\n\nRead the three notes. Convert them into their indices.\n\nGenerate all permutations of the three indices.\n\nFor each permutation:\n\nCheck for major and minor.\n\nIf any permutation satisfies major, return 'major'.\n\nIf any permutation satisfies minor, return 'minor'.\n\nElse, 'strange'.\n\nBut how to generate permutations? Well, in Python, itertools.permutations can be used. So for the three notes, generate all possible orderings.\n\nBut perhaps there's a more efficient way. But with three elements, it's manageable.\n\nSo code steps:\n\nFirst, parse the input. The input is three space-separated notes. For example, the input could be something like 'C E G', which would be split into ['C', 'E', 'G'].\n\nThen, convert each note to its index using the note_to_index dictionary.\n\nOnce we have the three indices, generate all permutations of them.\n\nFor each permutation (x, y, z):\n\nCompute distance between x and y: (y - x) % 12 ?\n\nWait, no. Wait, the distance between X and Y is (Y_index - X_index) mod 12? Wait, for example, if X is C (0) and Y is E (4), then (4-0) mod 12 is 4, which is correct. If X is E (4) and Y is C (0), then (0-4) mod 12 is 8, which is correct. So yes, the distance between X and Y is (y - x) mod 12. But wait, the problem says that the distance is from the lower to upper. So, for example, if X is lower than Y, then the distance is y - x. If X is higher than Y, then the distance is (y + 12 - x). Which is equivalent to (y - x) mod 12. Because, for example, when y < x, then (y - x) is negative. Mod 12 gives the correct positive value.\n\nSo, the distance between X and Y is (y - x) % 12.\n\nBut wait, the problem says that the distance is measured from the lower to upper. So, for example, the distance between X and Y is the number of semitones when moving from X to Y upwards. So if X is lower than Y, then it's y -x. If X is higher than Y, then it's 12 - (x - y). Which is the same as (y - x) mod 12. So yes, that formula is correct.\n\nSo, for each permutation, compute the distance between x and y, then between y and z.\n\nSo for a permutation (x, y, z):\n\nd1 = (y - x) % 12\n\nd2 = (z - y) % 12\n\nIf d1 ==4 and d2 ==3 → major.\n\nIf d1 ==3 and d2 ==4 → minor.\n\nSo, for each permutation, check these conditions.\n\nNow, the code:\n\nWe need to generate all permutations of the three notes. Let's take the three notes as a list, say, notes = [n1, n2, n3]. Then, permutations would be all possible orderings.\n\nIn Python, itertools.permutations(notes, 3) would generate all possible orderings.\n\nBut since the input is three distinct notes? Well, the problem says that the input is three notes, but it's possible that they are not distinct? Wait, the problem says that a chord is an unordered set of no less than three notes. However, the input is three notes. But the problem says that the answer is unambiguous. So, perhaps the input can have duplicates? But according to the problem statement, the input is three notes. But in practice, for a chord, they must be distinct. However, the problem says nothing about that. But according to the sample input, the examples have distinct notes. However, the problem says that the answer is always unambiguous. So perhaps the input will have three distinct notes. But perhaps the code should handle any three notes, even if they are same. But according to the problem statement, it's possible that the input is three same notes. But for example, in that case, the distances would be zero. So the code can process them regardless.\n\nBut regardless, the code can process all permutations, even if the notes are same.\n\nSo, in code:\n\nFirst, create the note_to_index dictionary.\n\nThen, read the input line. Split into three notes. For example, input is read as a list, say, input_notes = input().split()\n\nThen, convert each note into its index. Let's say, indices = [note_to_index[note] for note in input_notes]\n\nThen, generate all permutations of indices. For example, using itertools.permutations.\n\nThen, for each permutation in permutations:\n\nCheck for major and minor.\n\nOnce any permutation satisfies major, then return 'major'.\n\nSimilarly for minor.\n\nSo, in code:\n\nimport itertools\n\nnote_to_index = {\n    'C': 0,\n    'C#': 1,\n    'D': 2,\n    'D#': 3,\n    'E': 4,\n    'F': 5,\n    'F#': 6,\n    'G': 7,\n    'G#': 8,\n    'A': 9,\n    'B': 10,\n    'H': 11\n}\n\ninput_notes = input().split()\nindices = [note_to_index[note] for note in input_notes]\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(indices):\n    x, y, z = perm\n    d1 = (y - x) % 12\n    d2 = (z - y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 ==4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")\n\nWait, but what if multiple permutations satisfy the same condition? For example, if two permutations are major. But the code will set found_major to True once, and then it's okay.\n\nBut this code would check all permutations, and if any permutation meets the major condition, found_major is True. Same for minor.\n\nBut wait, the problem says that the answer is unambiguous, so there's no case where both found_major and found_minor are True. So, in the code, once we check all permutations, if found_major is True, output 'major', else check if found_minor is True, else 'strange'.\n\nBut let's test this with the sample input.\n\nSample Input:\n\n['C E G', 'C# B F', 'A B H']\n\nFirst case: C E G → indices are 0, 4, 7.\n\nPermutations:\n\nLet's take the permutation (0,4,7):\n\nd1 = 4-0=4 mod12 is 4. d2 = 7-4=3 mod12 is 3. So this is a major. So found_major is True.\n\nOther permutations may not matter. So the code returns 'major'.\n\nSecond case: C# B F → notes are C# (1), B (10), F (5). Let's look at permutations.\n\nLooking for a permutation where the distances are 3 and 4. For example, the sample says that ordering B, C#, F.\n\nB is 10, C# is 1, F is 5.\n\nSo permutation (10, 1, 5):\n\nd1 is (1-10) mod 12 → ( -9 ) mod 12 → 3? Because 12 -9 =3. So yes. d1 is 3. Then d2 is (5 -1) mod 12 → 4. So that's 3 and 4 → minor. So found_minor is True.\n\nThird case: A B H → A is 9, B is 10, H is 11.\n\nCheck all permutations.\n\nLet's take (9,10,11): d1 is 1, d2 is 1. Not matching.\n\nAnother permutation: (9, 11, 10). d1 is (11-9) = 2 mod12 → 2. d2 is (10-11) mod12 → ( -1 ) mod12 = 11. Not matching.\n\nAnother permutation: (10, 9, 11). d1 is (9-10) mod12 → 11. Not 3 or 4.\n\nAnother permutation: (10, 11, 9). d1 is 1, d2 is (9-11) mod12 → 10. No.\n\nAnother permutation: (11, 9, 10). d1 is (9-11) mod12 = ( -2 ) mod12 = 10. No. d2 is (10-9)=1.\n\nAnother permutation: (11, 10, 9). d1 is (10-11) mod12 → 11. d2 is (9-10) mod12 → 11. No.\n\nSo none of the permutations meet the major or minor conditions. Hence output 'strange'.\n\nWhich matches the sample.\n\nSo the code seems to work.\n\nBut wait, in the code, when checking permutations, for each permutation, we check for major and minor. So for example, in the first case, the code will find that for the permutation (0,4,7), it's major. So found_major is True. Then, even if another permutation is checked, it doesn't matter. So the code will output 'major'.\n\nBut what about permutations where the same triad is checked in different orderings?\n\nBut since we check all permutations, the code will find if any of them meets the condition.\n\nNow, possible edge cases:\n\nWhat if the three notes are such that two different permutations satisfy different conditions? But according to the problem statement, the answer is unambiguous, so that's not possible.\n\nAnother edge case: when the three notes are the same. For example, input is ['C C C']. Then, all permutations would have x, y, z as same. So d1 is 0, d2 is 0. So no conditions met. Output is strange.\n\nAnother case: a major triad that can be ordered in multiple ways. For example, suppose the three notes are C, E, G. The code checks all permutations. For example, (E, G, C). Let's see:\n\ndistance between E (4) and G (7) is 3. Then between G (7) and C (0): (0-7) mod12 is 5. So that's not 3 and 4. So only certain permutations will trigger the condition.\n\nAnother example: for a minor triad. Suppose the notes are B, C#, F. Let's check permutations. One of them is B, C#, F. The distance between B (10) and C# (1) is (1 -10) mod12 = 3. Then between C# (1) and F (5) is 4. So that's minor.\n\nBut other permutations may not trigger the condition. But the code will find at least one.\n\nNow, the code seems correct.\n\nBut what about the order of the permutations? For example, in the case of a major triad, the code checks all permutations and finds that at least one of them meets the major condition.\n\nNow, the code uses itertools.permutations. So for the three elements, all 6 permutations are checked.\n\nSo the code is correct.\n\nNow, the code needs to be written. Also, note that the input is read from stdin. The input is a single line with three notes separated by spaces. For example, in the sample input, the input is given as ['C E G', 'C# B F', 'A B H'], but that's probably a mistake. Wait, looking back at the problem statement:\n\nThe input is given as:\n\nInput\nThe only line contains 3 space-separated notes in the above-given notation.\n\nSo the sample input is probably:\n\nFor example, the sample input is:\n\nC E G\n\nC# B F\n\nA B H\n\nBut the sample input shows that the input is a list of three elements, but perhaps that's a mistake in the problem description. The actual input is a single line with three notes. For example, the sample input is:\n\nInput:\n\nC E G\n\nOutput:\n\nmajor\n\nBut the problem's sample shows:\n\nSample Input:\n\n['C E G', 'C# B F', 'A B H']\n\nSample Output:\n\n['major', 'minor', 'strange']\n\nBut that's probably a mistake. Because the problem says that the input is a single line with three notes. So perhaps the sample input is three separate test cases. But the problem says that the code should read input from stdin. So the code is supposed to read one line, process it, and output the result.\n\nBut the sample shows that the input is a list of three test cases, but that's probably a formatting error. For example, perhaps the sample input is three separate lines, but the problem's sample shows them as a list. But the actual code is supposed to read one line, process it, and output one line.\n\nBut the user's problem says:\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout).\n\nSo for example, for the input line 'C E G', the output is 'major'.\n\nSo the code should read a single line, split into three notes, and output one of the three options.\n\nSo the code is as follows.\n\nBut in the code, the input is read with input().split(), which splits by whitespace. So for example, if the input is 'C E G', then input().split() gives ['C', 'E', 'G'].\n\nThus, the code is correct.\n\nNow, the code must be written, including the note_to_index dictionary.\n\nBut what about the note 'H'? In the problem statement, the notes are listed as C, C#, D, D#, E, F, F#, G, G#, A, B, H. So the note H is present. So the code's note_to_index includes 'H' as 11.\n\nNow, code:\n\nimport itertools\n\nnote_to_index = {\n    'C': 0,\n    'C#': 1,\n    'D': 2,\n    'D#': 3,\n    'E': 4,\n    'F': 5,\n    'F#': 6,\n    'G': 7,\n    'G#': 8,\n    'A': 9,\n    'B': 10,\n    'H': 11\n}\n\nnotes = input().split()\nindices = [note_to_index[note] for note in notes]\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(indices):\n    x, y, z = perm\n    d1 = (y - x) % 12\n    d2 = (z - y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 == 4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")\n\nBut wait, what about the case where the same note is used multiple times? For example, if the input is ['C C C'], then the code will generate permutations of [0, 0, 0]. For each permutation, x, y, z are 0, 0, 0. Then d1 = (0-0) mod 12 = 0, d2 is same. So no conditions met. Output 'strange'.\n\nAnother test case: input is ['C E G'] → which is the first sample. Code returns 'major'.\n\nAnother test case: input is ['C# B F'] → which is the second sample. The code will check permutations. For example, the permutation (10, 1, 5) → B, C#, F. d1 = (1 - 10) mod 12 → ( -9 ) mod 12 is 3. d2 is (5 - 1) mod 12 → 4. So found_minor is True. So output 'minor'.\n\nThird sample input is ['A B H'] → indices are 9, 10, 11. Let's check all permutations:\n\nFor example, (9, 10, 11): d1 is 1, d2 is 1. No.\n\n(9, 11, 10): d1 is (11-9)=2 mod12 → 2. d2 is (10-11) mod12 → 11. No.\n\n(10, 9, 11): d1 is (9-10) mod12 → 11. No.\n\n(10, 11, 9): d1 is (11-10) mod12 → 1. d2 is (9-11) mod12 → 10. No.\n\n(11, 9, 10): d1 is (9-11) mod12 → 10. No.\n\n(11, 10, 9): d1 is (10-11) mod12 → 11. No.\n\nSo none of the permutations meet the conditions. Output 'strange'.\n\nSo the code works for the sample.\n\nNow, possible issues:\n\nWhat about the note names? For example, the input may have 'B' and 'H' as different notes. But according to the problem statement, the notes are as given. So the code correctly maps 'B' to 10 and 'H' to 11.\n\nAnother possible issue: the code uses permutations, but perhaps some permutations are redundant. However, since the code checks all permutations, it's okay.\n\nSo the code should be correct.\n",
    "response": "\n\nTo solve this problem, we need to determine if a given set of three musical notes forms a major triad, a minor triad, or neither. The solution involves checking all permutations of the three notes to see if they meet the criteria for either a major or minor triad based on the semitone distances between the notes.\n\n### Approach\n1. **Mapping Notes to Indices**: Convert each musical note to an index representing its position in the cyclic sequence of 12 notes.\n2. **Permutations Check**: Generate all permutations of the three given notes to check each possible ordering.\n3. **Distance Calculation**: For each permutation, calculate the semitone distances between consecutive notes using modular arithmetic to handle the cyclic nature of the musical scale.\n4. **Triad Classification**: Check if the distances match the criteria for a major or minor triad. If neither is found, classify the chord as \"strange\".\n\n### Solution Code\n```python\nimport itertools\n\nnote_to_index = {\n    'C': 0,\n    'C#': 1,\n    'D': 2,\n    'D#': 3,\n    'E': 4,\n    'F': 5,\n    'F#': 6,\n    'G': 7,\n    'G#': 8,\n    'A': 9,\n    'B': 10,\n    'H': 11\n}\n\nnotes = input().split()\nindices = [note_to_index[note] for note in notes]\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(indices):\n    x, y, z = perm\n    d1 = (y - x) % 12\n    d2 = (z - y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 == 4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")\n```\n\n### Explanation\n1. **Mapping Notes**: Each note is mapped to an index from 0 to 11 based on its position in the cyclic sequence of musical notes.\n2. **Permutations**: All permutations of the three notes are generated to check every possible order.\n3. **Distance Calculation**: The distance between two notes is calculated using modulo 12 arithmetic to handle the cyclic nature of the scale. For example, the distance from E (index 4) to C (index 0) is calculated as (0 - 4) % 12 = 8 semitones.\n4. **Triad Check**: For each permutation, we check if the distances between the first and second note, and the second and third note match the criteria for a major or minor triad. If any permutation meets these criteria, the corresponding result is printed.\n\nThis approach ensures that all possible configurations of the three notes are checked efficiently, leveraging permutations and modular arithmetic to handle the cyclic nature of the musical scale.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\nnote_to_index = {\n    'C': 0,\n    'C#': 1,\n    'D': 2,\n    'D#': 3,\n    'E': 4,\n    'F': 5,\n    'F#': 6,\n    'G': 7,\n    'G#': 8,\n    'A': 9,\n    'B': 10,\n    'H': 11\n}\n\nnotes = input().split()\nindices = [note_to_index[note] for note in notes]\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(indices):\n    x, y, z = perm\n    d1 = (y - x) % 12\n    d2 = (z - y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 == 4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 674,
        "completion_token_count": 642,
        "thoughts_token_count": 5827
    }
}