{
    "start": 1758008431.656914,
    "end": 1758008634.419285,
    "start-formatted": "2025-09-16 16:40 KST",
    "end-formatted": "2025-09-16 16:43 KST",
    "gpu": 2,
    "pid": 2,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Valera and X\n\nValera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals n squares (n is an odd number) and each unit square contains some small letter of the English alphabet.Valera needs to know if the letters written on the square piece of paper form letter \"X\". Valera's teacher thinks that the letters on the piece of paper form an \"X\", if:  on both diagonals of the square paper all letters are the same;  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. Help Valera, write the program that completes the described task for him.\n\n## Input\nThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\n## Output\nPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\n## Example\n### Input\n['5\\nxooox\\noxoxo\\nsoxoo\\noxoxo\\nxooox', '3\\nwsw\\nsws\\nwsw', '3\\nxpx\\npxp\\nxpe']\n\n### Output\n['NO', 'YES', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe task is to determine if a given square grid forms an 'X' according to specific rules. The conditions are:\n\n1. Both diagonals must have the same letter.\n2. All other squares (not on the diagonals) must have the same letter, which is different from the diagonal's letter.\n\nSo, first, I need to check two things: the diagonals and the non-diagonal elements.\n\nLet me think about how to approach this.\n\nFirst, the grid is n x n, where n is odd. The diagonals are the main diagonal (from top-left to bottom-right) and the anti-diagonal (from top-right to bottom-left). All elements on these two diagonals must be the same. Also, all elements not on either diagonal must be the same and different from the diagonal's letter.\n\nSo steps to solve:\n\n1. Check that all elements on both diagonals are the same. Let's call this character 'd_char'.\n2. Check that all elements not on either diagonal are the same and not equal to 'd_char'.\n\nBut how to check these?\n\nFirst, for each cell (i,j) in the grid, determine if it's on either diagonal.\n\nFor a square grid, the main diagonal has i == j. The anti-diagonal has i + j == n - 1 (since indices start at 0). So for each cell, if i == j or i + j == n-1, it's part of a diagonal.\n\nSo for all cells, we can check if they are on a diagonal.\n\nNow, for the first part: collect all characters on the diagonals. They must all be the same. Then collect all non-diagonal characters, they must all be same and different from the diagonal's character.\n\nBut how to collect them?\n\nLet me think. Let's iterate through each cell in the grid. For each cell, check if it's on a diagonal. If yes, check if all of them are same. If not, check if all are same and different.\n\nBut perhaps, first collect the diagonal characters and non-diagonal characters.\n\nBut maybe there's a better way. Let's think:\n\nFirst, check all the diagonal elements. Let's get the first diagonal element (i=0, j=0) as the reference. Then check that all other diagonal elements (both main and anti) are same as this.\n\nWait, but the main diagonal and the anti-diagonal may have overlapping elements. For example, in a 3x3 grid, the center cell (1,1) is on both diagonals. So when checking, we need to make sure that all elements on both diagonals are same. So for example, if the main diagonal has all 'x' and the anti-diagonal has all 'x', then it's okay. But if the main diagonal has 'x' and the anti has 'y', then it's invalid.\n\nSo the first step is to check that all elements on both diagonals are same. How to do that?\n\nLet me think. For each cell (i,j), if it is on either diagonal, check that it's equal to the first diagonal's character.\n\nWait, but what's the first diagonal's character? Let's take the first cell (0,0) as the reference. Then, for all cells on the diagonals, they must equal this character.\n\nBut wait, what if the first cell is part of both diagonals? Well, in that case, the first cell is part of both, so the rest of the diagonals must match it.\n\nBut maybe there's a case where the main diagonal has some value, and the anti-diagonal has a different value. For example, suppose the main diagonal is all 'a' except for one cell which is 'b', and the anti-diagonal is all 'b' except for one cell which is 'a'. Then the code would fail.\n\nBut the problem says that both diagonals must have the same letters. So all elements on both diagonals must be the same. So, for example, if any element on either diagonal is different from the others, it's invalid.\n\nSo the approach is:\n\nCollect all the elements on the diagonals. Check that all of them are the same.\n\nThen collect all elements not on the diagonals. Check that all of them are same and different from the diagonal's character.\n\nBut how to collect those elements?\n\nSo here's the plan:\n\nLoop through each cell in the grid. For each cell (i,j):\n\nIf it is on a diagonal (i == j or i + j == n-1), add it to the diagonal_chars list.\n\nElse, add it to the non_diagonal_chars list.\n\nOnce all are collected, check:\n\n- All elements in diagonal_chars are same.\n\n- All elements in non_diagonal_chars are same.\n\n- The diagonal_char is different from non_diagonal_char.\n\nBut also, what if there",
    "response": "\n\nTo solve this problem, we need to determine if a given square grid forms the letter \"X\" based on specific conditions. The conditions are that all elements on both diagonals must be the same, and all other elements (not on the diagonals) must be the same and different from the diagonal elements.\n\n### Approach\n1. **Identify Diagonals**: For a given grid, the main diagonal consists of elements where the row index equals the column index (i.e., `i == j`). The anti-diagonal consists of elements where the sum of the row and column indices equals `n - 1` (i.e., `i + j == n - 1`).\n2. **Collect Characters**: Separate the characters into two groups: those on the diagonals and those not on the diagonals.\n3. **Check Uniformity**: Ensure all characters on the diagonals are the same and all characters not on the diagonals are the same and different from the diagonal characters.\n\n### Solution Code\n```python\nn = int(input())\ngrid = [input().strip() for _ in range(n)]\n\ndiagonal_chars = set()\nnon_diagonal_chars = set()\n\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            diagonal_chars.add(grid[i][j])\n        else:\n            non_diagonal_chars.add(grid[i][j])\n\n# Check if all diagonal characters are the same and non-diagonal are same and different\nif len(diagonal_chars) == 1 and len(non_diagonal_chars) == 1:\n    d_char = diagonal_chars.pop()\n    nd_char = non_diagonal_chars.pop()\n    if d_char != nd_char:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `n` followed by `n` lines of strings representing the grid.\n2. **Character Collection**: We iterate through each cell in the grid. If the cell is on either diagonal, its character is added to `diagonal_chars`; otherwise, it is added to `non_diagonal_chars`.\n3. **Validation**: We check if both sets contain exactly one unique character. If they do, we ensure the characters from the diagonals and non-diagonals are different. If all conditions are met, the output is \"YES\"; otherwise, it is \"NO\".\n\nThis approach efficiently checks the required conditions with a time complexity of O(n^2), which is optimal given the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\ngrid = [input().strip() for _ in range(n)]\n\ndiagonal_chars = set()\nnon_diagonal_chars = set()\n\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            diagonal_chars.add(grid[i][j])\n        else:\n            non_diagonal_chars.add(grid[i][j])\n\n# Check if all diagonal characters are the same and non-diagonal are same and different\nif len(diagonal_chars) == 1 and len(non_diagonal_chars) == 1:\n    d_char = diagonal_chars.pop()\n    nd_char = non_diagonal_chars.pop()\n    if d_char != nd_char:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 444,
        "completion_token_count": 534,
        "thoughts_token_count": 1023
    }
}