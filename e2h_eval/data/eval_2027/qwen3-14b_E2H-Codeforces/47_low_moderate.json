{
    "start": 1758309315.497209,
    "end": 1758309515.498326,
    "start-formatted": "2025-09-20 04:15 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about how to approach this. \n\nFirst, let's note that when you add k to both a and b, the two numbers become a + k and b + k. Let me denote x = a + k and y = b + k. Then, since k is the same for both, the difference between x and y is (b - a). Wait, because x - y = (a +k) - (b +k) = a - b. So the difference between x and y is fixed as (a - b) or (b - a), depending on which is larger. Let's say that d = |a - b|. So, the two numbers x and y differ by d. \n\nBut since LCM(x, y) is involved, perhaps we can find some way to express it in terms of their difference. Also, LCM(x, y) is equal to (x * y) / GCD(x, y). So, to minimize the LCM, we need to maximize the GCD of x and y, given that their difference is fixed. Because for a fixed product, a higher GCD would lead to a lower LCM. But wait, the product isn't fixed. Hmm. So maybe the idea is to find x and y such that their GCD is as large as possible. Because for numbers with a fixed difference, the maximum possible GCD would be the maximum divisor of the difference. \n\nWait, here's an idea: Let me assume that a and b are such that a < b. Let's say that a is smaller than b. Then, the difference between the two numbers after adding k is (b - a). Let me call this d. So, the difference between x and y is d. So, x and y are two numbers differing by d. Let me think about their GCD. Let's say that g is the GCD of x and y. Since x and y differ by d, then g must divide d. Because x = g * m, y = g * n. Then, x - y = g(m -n) = d. So, g must divide d. Therefore, the maximum possible GCD of x and y is a divisor of d. \n\nSo, the maximum possible GCD is the maximum divisor of d. But how do we find such x and y? Well, if we can find x and y such that their GCD is as large as possible, then their LCM will be minimized. Because LCM(x, y) = x*y / GCD(x,y). So, for fixed difference d, maximizing the GCD would minimize the LCM. \n\nSo, the problem reduces to finding the maximum possible GCD of two numbers that differ by d. Then, once we find that maximum GCD, say g, then the minimal LCM would be (g * m) * (g * n) / g = g * m * n, where m and n are coprime, and m - n = d/g. Wait, but since x and y differ by d, then m - n = d/g. But since m and n are coprime, the minimal possible product would be when m and n are as small as possible. \n\nBut perhaps the key is that the maximum GCD is the maximum divisor of d. So, for example, if d is 4, then the maximum possible GCD is 4. Then, x and y could be 4 and 8 (difference 4), GCD is 4. Then LCM is 8. \n\nSo, the approach would be:\n\n- Compute d = |a - b|. If d is zero, then a = b, so any k gives LCM(a +k, a +k) = a +k. So the minimal is when k is 0. So the answer is 0.\n\nOtherwise, for d > 0, find the maximum divisor of d (call it g) such that there exists x and y with difference d, GCD(x, y) = g. Then, the minimal LCM is achieved when the GCD is as large as possible. \n\nBut how do we find the maximum possible g? It's the maximum divisor of d. Wait, but the maximum divisor of d is d itself. So, if we can have x and y such that their GCD is d, then that's the maximum possible. How can that happen? Well, x and y must be multiples of d. Let's say x = d * m, y = d * n. Their difference is d*(m -n) = d. So m -n = 1",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The approach involves leveraging the properties of divisors and greatest common divisors (GCD) to efficiently determine the optimal $ k $.\n\n### Approach\n1. **Understanding the Difference**: Let $ d = |a - b| $. The difference between $ a + k $ and $ b + k $ remains constant as $ d $.\n2. **Maximizing GCD**: The LCM of two numbers can be minimized by maximizing their GCD. For numbers differing by $ d $, the maximum possible GCD is a divisor of $ d $.\n3. **Finding Optimal Divisor**: We need to find the largest divisor $ g $ of $ d $ such that $ g $ can be used to form two numbers with the required difference $ d $.\n4. **Determine Minimum $ k $**: Once we identify the optimal divisor $ g $, we compute the smallest $ k $ that aligns with this divisor.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef compute_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    max_gcd = 1\n    # Find the maximum divisor of d\n    # We can iterate from sqrt(d) downwards to find the largest divisor\n    for i in range(int(math.isqrt(d)), 0, -1):\n        if d % i == 0:\n            max_gcd = i\n            break\n    # Now, we need to find the minimal k such that (a +k) and (b +k) are multiples of max_gcd\n    # Let's assume a < b, so let's set a as the smaller one\n    if a > b:\n        a, b = b, a\n    # So, a is the smaller one. Then, a + k = m * max_gcd, and b + k = (m + t) * max_gcd\n    # The difference between them is d = (t * max_gcd)\n    # Since d = (b - a), then t = d / max_gcd\n    # So, a + k must be a multiple of max_gcd. Let's find the smallest k >= 0 such that (a + k) % max_gcd == 0\n    # The minimal k is (max_gcd - (a % max_gcd)) % max_gcd\n    k = (max_gcd - (a % max_gcd)) % max_gcd\n    return k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input and processed in pairs of integers $ a $ and $ b $.\n2. **Handling Equal Values**: If $ a $ and $ b $ are equal, the optimal $ k $ is immediately 0 since adding any $ k $ will not change the LCM.\n3. **Finding Maximum Divisor**: The maximum divisor of $ d = |a - b| $ is found by iterating from the square root of $ d $ downwards to ensure efficiency.\n4. **Calculating Optimal $ k $**: Using the largest divisor $ g $, we compute the smallest $ k $ such that both $ a + k $ and $ b + k $ are multiples of $ g $, ensuring the LCM is minimized.\n\nThis approach ensures that we efficiently determine the optimal $ k $ by leveraging mathematical properties of divisors and GCD, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef compute_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    max_gcd = 1\n    # Find the maximum divisor of d\n    # We can iterate from sqrt(d) downwards to find the largest divisor\n    for i in range(int(math.isqrt(d)), 0, -1):\n        if d % i == 0:\n            max_gcd = i\n            break\n    # Now, we need to find the minimal k such that (a +k) and (b +k) are multiples of max_gcd\n    # Let's assume a < b, so let's set a as the smaller one\n    if a > b:\n        a, b = b, a\n    # So, a is the smaller one. Then, a + k = m * max_gcd, and b + k = (m + t) * max_gcd\n    # The difference between them is d = (t * max_gcd)\n    # Since d = (b - a), then t = d / max_gcd\n    # So, a + k must be a multiple of max_gcd. Let's find the smallest k >= 0 such that (a + k) % max_gcd == 0\n    # The minimal k is (max_gcd - (a % max_gcd)) % max_gcd\n    k = (max_gcd - (a % max_gcd)) % max_gcd\n    return k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 848,
        "thoughts_token_count": 1024
    }
}