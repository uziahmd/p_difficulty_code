{
    "start": 1758312782.5213764,
    "end": 1758313158.4376237,
    "start-formatted": "2025-09-20 05:13 KST",
    "end-formatted": "2025-09-20 05:19 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is as small as possible. And if there are multiple k's with the same minimal LCM, pick the smallest k.\n\nHmm. Let me think about how to approach this problem. \n\nFirst, let's note that a and b are given. Let me consider that when we add k to both, the two numbers become a +k and b +k. Let me denote x = a +k and y = b +k. Then, since x and y differ by (b - a), assuming a < b. Wait, but if a and b are swapped, it's symmetric. So maybe I can assume without loss of generality that a ≤ b. Because if a is bigger than b, swapping them would not change the problem. So perhaps I should first swap a and b so that a ≤ b. That might make things easier.\n\nWait, for example, in the first sample input, a is 6 and b is 10. So after adding k=2, we have 8 and 12. Their LCM is 24. What's the difference between them? 4. So the difference between the two numbers is (b - a) = 4. \n\nSo, the difference between the two numbers (x and y) is fixed. Let me call d = |a - b|. Wait, no. Because if a and b are swapped, then the difference is same. So, if I let a be the smaller one, then the difference is (b - a). Let me assume that a ≤ b. So, the difference between the two numbers after adding k is (b +k) - (a +k) = b -a. So, the difference between the two numbers is fixed as (b - a). Let me denote this difference as D. So D = b - a.\n\nNow, the problem becomes: find x and y such that y - x = D, and their LCM is minimized. Then, find the minimal k such that x = a +k, y = b +k. Since x and y must be positive integers, but since k is non-negative, x and y will be at least a and b, which are ≥1. So no problem there.\n\nBut how to find x and y with difference D, such that their LCM is minimized. And then find the minimal k.\n\nWait, the LCM of x and y is (x * y) / GCD(x, y). So, to minimize LCM(x, y), we need to maximize GCD(x, y), given that y -x = D.\n\nBecause for fixed difference D, the LCM is minimized when the GCD is maximized. Because x and y can be written as g * m and g * n, where m and n are coprime. Then, their difference is g*(m -n) = D. So, g must be a divisor of D. Because m and n are coprime, m -n must be a divisor of D/g. Wait, maybe I'm getting ahead of myself here.\n\nLet me think again. Let me suppose that x and y have a GCD of g. Then, x = g * m, y = g * n, where m and n are coprime. Also, since y -x = D, then g*(n - m) = D. Therefore, g must be a divisor of D. Because n - m is an integer. So, the possible values of g are the divisors of D. \n\nSo, for each possible divisor g of D, we can compute m and n such that n -m = D/g, and m and n are coprime. Then, the LCM of x and y is g*m*n. Because LCM(gm, gn) = g * LCM(m,n) = g * m *n since m and n are coprime.\n\nTherefore, the minimal LCM is achieved when g is as large as possible, and m *n is as small as possible. But since for each possible g (divisor of D), the value of m and n would be such that n -m = D/g. So, given that, for each possible divisor g of D, we can find the minimal m *n for that case.\n\nWait, but for a given g, the difference between n and m is (D/g). So, to minimize m *n, given that n - m = K (where K = D/g), and that m and n are coprime. How do we choose m and n?\n\nWell, since n = m + K. So m and m + K must be coprime. So, the minimal product m*(m + K) is achieved when m is as small as possible. But since m and m + K must be coprime, what is the minimal possible m?\n\nFor example, if K is fixed, then m and m + K are coprime if and only if gcd(m, K) = 1. Because any common divisor of m and m+K must divide their difference, which is K. So, if m and K are coprime, then m and m + K are coprime. Conversely, if they are coprime, then their GCD divides K. So, if m and K share a common divisor d>1, then that d divides m and K, hence divides m + K and m, so their GCD would be at least d.\n\nSo, for m and n to be coprime, m must be chosen such that gcd(m, K) = 1. So, the minimal m is 1. But then n = 1 + K. So, the product is 1*(1 + K) = K +1. However, if K is even, then m=1 and K= even, then m and K are coprime (since 1 is coprime with anything). So, yes, the product is K +1. But if there's a smaller m that satisfies the condition, but perhaps m is not 1? Well, m has to be at least 1, because m is a positive integer (since x = g*m must be positive, and g is positive). So, the minimal product for a given K is K +1, achieved when m=1 and n=K+1. But wait, that's only if m=1 and n=K+1 are coprime. Which they are, since m=1 and K is any integer. So yes.\n\nTherefore, for each divisor g of D, the minimal possible product m *n is (K + 1) = (D/g + 1). Thus, the LCM is g * (D/g + 1) = D + g. Wait, wait:\n\nWait, K is D/g. So m *n is m*(m + K) = m*(m + D/g). For m=1, this is 1*(1 + D/g) = 1 + D/g. Then, the LCM is g * (1 + D/g) = g + D. \n\nWait, that's interesting. So for each divisor g of D, the minimal possible LCM is D + g. So, to find the minimal LCM, we need to find the maximum possible g (divisor of D) such that D + g is minimized. Wait, no. Because D is fixed. For example, if D is fixed, then D + g is minimized when g is as small as possible. Wait, that can't be right. Because if D is fixed, then D +g is minimized when g is as small as possible. But earlier reasoning says that for each divisor g of D, the minimal LCM is D +g. But that would imply that the minimal LCM is achieved when g is as small as possible. But that contradicts the earlier idea that maximizing g would help. So I must have made a mistake in my reasoning.\n\nLet me re-examine this. \n\nEarlier steps:\n\nWe have that x and y have difference D. Let's say that x = g*m, y = g*n. Then, since y -x = D, we have g(n - m) = D. Hence, g must be a divisor of D. Let me denote that as g divides D. Let me set K = n -m = D/g. \n\nThen, since m and n are coprime, and n = m + K. So, the product m *n is m*(m + K). We want to minimize this product. \n\nBut earlier conclusion was that the minimal product is achieved when m is as small as possible. For example, m=1. Then, the product is 1*(1 + K) = K +1. Which gives the LCM as g*(K + 1) = g*(D/g + 1) = D + g. \n\nBut this seems to indicate that for each possible divisor g of D, the minimal LCM is D + g. So, the minimal overall LCM is the minimum of D + g over all possible divisors g of D. But that would suggest that the minimal value is achieved when g is as small as possible. But that's not correct. For example, take D=4. The divisors are 1, 2, 4. Then D +g would be 5, 6, 8. So the minimal is 5, achieved when g is 1. But that would mean the minimal LCM is 5. But let's see what that implies.\n\nIf D=4, and g=1. Then, K = D/g =4. So m and n are m and m +4. They must be coprime. Choosing m=1, n=5. Then the LCM is 1*1*5 = 5. Which is indeed correct. But what if we take another divisor, like g=2. Then K=2. Then m and m+2 must be coprime. For m=1, product is 1*3=3. Then LCM is 2 * 3 =6, which is larger than 5. So in this case, the minimal is indeed achieved with the smallest possible g. But that seems counter-intuitive. Because higher g would lead to higher D +g. So why is this the case?\n\nBut this suggests that the minimal LCM is D +g, and to minimize this, we need to find the smallest possible g. But that's not possible because for example, when D is 4, the minimal LCM is 5, but what if there's another way to get a lower LCM?\n\nWait, but what if D is 4, and we take x and y such that x = 2 and y = 6. Then their LCM is 6. But according to the previous calculation, the minimal LCM is 5. How is that possible?\n\nAh, because in this case, the difference between x and y is 4. Let me see: for x=2 and y=6, their difference is 4. Their LCM is 6. But according to the earlier logic, when g is 1, the LCM is 5. How can that be?\n\nWait, maybe my reasoning is wrong. Let's check. For D=4, and g=1. Then, x = g*m = 1*m, y = 1*n. And n - m = D/g =4. So, n = m +4. And m and n must be coprime. For example, m=1, n=5. Then x=1, y=5. Their LCM is 5. Which is indeed smaller than 6. But in that case, x and y are 1 and 5. So their difference is 4. So that's valid. So why didn't I think of that before?\n\nAh! Because in the original problem, x is a +k, and y is b +k. So, if a and b are such that their difference is D=4, then x and y can be 1 and 5. But that requires that a +k =1 and b +k =5. Which implies that a =1 -k, and b =5 -k. But since a and b are given as positive integers, this would require that k is such that 1 -k ≥1, which would imply k ≤0. But since k is non-negative, this is only possible if k=0. Which would imply that a=1 and b=5. Then, the original a and b would be 1 and 5, and k=0. Then, the LCM is LCM(1,5)=5. Which is indeed better than other possibilities. \n\nSo, this shows that the minimal LCM can be achieved when g is the smallest possible divisor of D. But then why does the sample input have a different scenario?\n\nLet me check the first sample input. The input is a=6 and b=10. So D = 10 -6 =4. According to our reasoning, the minimal LCM is D +g, where g is a divisor of D. The minimal D +g would be when g is 1, giving 4+1=5. But the sample output says that when k=2, the LCM is 24. What's going on here?\n\nWait, this suggests that my reasoning is wrong. Because according to the sample input, the minimal LCM is 24, but according to the previous logic, it should be 5. But that's impossible. So clearly, there's a mistake in my reasoning.\n\nWhat's the problem here?\n\nAh! Because in the problem, x and y are a +k and b +k. Which implies that x and y must be greater than or equal to a and b, respectively. Because k is non-negative. So, if a is 6 and b is 10, then x = a +k =6 +k, and y =10 +k. So, x and y can't be less than 6 and 10, respectively. So, in the previous example where x=1 and y=5, that's not possible because 1 <6 and 5 <10. So, the previous reasoning assumes that x and y can be any numbers with difference D, but in reality, they must be at least a and b. Therefore, the earlier reasoning is incomplete. It needs to take into account the constraints on x and y.\n\nOh right! So, the earlier analysis is only valid if x and y can be any numbers with difference D. But in reality, x and y are constrained by the original a and b. So, for example, if a=6 and b=10, then x = a +k =6 +k and y =10 +k. Therefore, x and y can't be smaller than 6 and 10. So, the minimal possible x is 6, and y is 10. So, when considering possible x and y, we need to ensure that x >=a and y >=b. Which implies that x = a +k, and since k is non-negative, x can't be smaller than a. Similarly for y.\n\nSo, the previous approach of considering all divisors of D is not sufficient. Because even though there may exist x and y with difference D and LCM D +g, those x and y may not be achievable with some k. \n\nThis is a critical point. Therefore, my previous reasoning is incomplete. So, how can I adjust for this?\n\nThe problem now becomes: find x and y such that y -x = D, x >=a, y >=b, and LCM(x,y) is minimized. Then, find the minimal k such that x = a +k and y = b +k.\n\nBut since y = x + D, and since y = b +k, and x = a +k, then substituting x = a +k into y = x + D gives y = a +k + D. But since D = b -a, then a +k + D = a +k + (b -a) = b +k. Which matches the definition of y. So, that's consistent.\n\nSo, the key is that x can be any number >= a, and y = x + D. But since D is fixed, the problem reduces to finding x >= a such that LCM(x, x + D) is minimized. Then, once x is found, k = x - a.\n\nSo, the problem is equivalent to finding the minimal x >= a such that LCM(x, x + D) is minimized. Then, k = x -a.\n\nBut how to find this x?\n\nLet me think again. Let me denote x as the variable, and D = b -a. So, the problem is to find x >=a, such that LCM(x, x + D) is as small as possible.\n\nLet me consider that x and x + D have GCD g. Then, as before, x = g * m, x + D = g * n, where m and n are coprime. Then, since x + D -x = D = g(n -m). So, g must divide D. So again, g is a divisor of D.\n\nBut also, x = g * m >=a. And x + D = g *n >=b. Since D = b -a, then x + D = a +k + D = a +k + (b -a) = b +k >=b. So, the second condition is automatically satisfied if x >=a. Because x + D = x + (b -a) >=a + (b -a) =b. So, the only constraint is x >=a.\n\nSo, for each divisor g of D, we can find possible x = g*m, where m is a positive integer, such that x >=a. Also, since x + D = g *n, and n = m + (D/g). And since m and n must be coprime, then m must be such that gcd(m, m + D/g) = 1. Which, as before, implies that gcd(m, D/g) = 1.\n\nSo, for each divisor g of D, we can find the minimal x that satisfies x =g*m, m >=1, and gcd(m, D/g) =1, and x >=a.\n\nOnce we find all such possible x for all possible divisors g of D, we can compute the LCM(x, x + D) for each, and find the minimal one, and then the corresponding k.\n\nBut how to find the minimal x for each g?\n\nLet me think. For a given g (divisor of D), D/g is K. Then, x = g *m, and m must satisfy:\n\n- m >=1\n- gcd(m, K) = 1\n- x >=a => g*m >=a => m >= ceil(a/g)\n\nSo, for each such g, the minimal m that satisfies these conditions is the minimal m >= max(1, ceil(a/g)) such that gcd(m, K) =1. Once we find that m, then x = g*m is a candidate. Then, the LCM is (g*m) * (g*n)/g = g*m*n. Since n = m + K. And since m and n are coprime, LCM is g*m*n.\n\nBut for each g, the minimal possible LCM for that g is achieved when m is as small as possible. Because m*n is m*(m + K). For fixed K, the minimal m*(m + K) is achieved when m is as small as possible. Because m increases, m*(m + K) increases. So, for each g, we can compute the minimal possible x (i.e., the minimal m for that g) and then calculate the LCM.\n\nSo, the plan is:\n\n1. Compute D = b -a. If D is zero (i.e., a =b), then the LCM of (a +k, a +k) is a +k, which is minimized when k=0. So, the answer is 0.\n\nBut if a =b, then adding any k gives the same value, so the minimal LCM is a +0 =a, and k=0.\n\nElse, proceed.\n\n2. Find all divisors of D.\n\n3. For each divisor g of D:\n\n   a. Compute K = D/g.\n\n   b. Find the minimal m >= max(1, ceil(a/g)) such that gcd(m, K) =1. Let's call this m_min.\n\n   c. Compute x_candidate = g * m_min.\n\n   d. Compute the LCM for this x_candidate: LCM(x_candidate, x_candidate + D) = g * m_min * (m_min + K) = g * m_min * (m_min + D/g).\n\n   e. Keep track of the minimal LCM and the corresponding k (which is x_candidate -a).\n\n4. Also, there's another possibility: when x is such that x and x + D are coprime. In that case, the LCM is x*(x + D). But this would be considered in the case where g=1 (since D/g = D, and K = D. Then, m must be such that gcd(m, D) =1. So, the minimal m is the smallest m >= ceil(a/1) =a, and coprime with D. But perhaps there are other possibilities where g is not a divisor of D. Wait, but earlier reasoning said that g must divide D. Because x and x + D have difference D, which is equal to g*(n -m) =g*K. So, g must divide D. Therefore, all possible cases are covered by considering the divisors of D.\n\nBut then, what about when the optimal x is not generated by any of the divisors of D? For example, if there exists x where the GCD(x, x+D) is not a divisor of D. But according to the previous reasoning, that's not possible. Because if x and x+D have GCD g, then g divides D. Because x+D -x = D, and g divides both x and x+D, so it divides their difference D. So, yes, all possible g's are divisors of D. Therefore, considering all divisors of D is sufficient.\n\nSo, the approach is to generate all divisors of D, compute for each the minimal x_candidate, and then compare all those candidates to find the minimal LCM.\n\nOnce we have all these candidates, we select the one with the minimal LCM. If there are multiple candidates with the same minimal LCM, we choose the one with the smallest k (which would correspond to the smallest x_candidate, since k =x_candidate -a).\n\nBut how to find all the divisors of D?\n\nWell, D can be up to 1e9 (since a and b are up to 1e9). So, generating all divisors of D can be done efficiently by factorizing D and generating all possible products of exponents.\n\nBut for numbers up to 1e9, trial division is feasible. So, first, we need to generate all divisors of D.\n\nOnce we have all the divisors, for each of them, compute K = D/g. Then, find the minimal m for that g.\n\nBut how to find the minimal m >= m_low (where m_low is max(1, ceil(a/g))) such that gcd(m, K) =1.\n\nLet me think. For example, given K, and m_low, find the smallest m >= m_low such that gcd(m, K) =1.\n\nHow can we find that?\n\nWell, if m_low is 1, then the minimal m is 1 (since gcd(1, anything) is 1). Otherwise, we need to find the first number >= m_low that is coprime with K.\n\nBut how to compute that quickly?\n\nWell, for small K, we can check numbers starting from m_low upwards until we find one that is coprime with K. However, for large K, this could take time. However, given that D is up to 1e9, and K is D/g, and g is a divisor of D, so K is also a divisor of D. But even so, for each K, the worst case is that m_low is up to something like 1e9, and checking each m from m_low upwards until we find a coprime.\n\nBut perhaps for the problem's constraints, this is acceptable. Because the number of divisors of D is O(1e3) for D up to 1e9. For example, the maximum number of divisors for a number up to 1e9 is around 1000 (for numbers with many factors). So, for each of these, checking up to maybe a few numbers would be manageable.\n\nBut let's think of an example. Suppose K is 1e9, and m_low is 1. Then, the minimal m is 1. If K is 1e9 and m_low is 2, then check 2 (gcd(2, 1e9) is 2 if K is even, which it is. Then check 3, etc. So in the worst case, it might take O(K) steps, but that's not feasible.\n\nBut perhaps there's a smarter way. Let's think: for a given K, the minimal m >= m_low that is coprime with K. How to find it?\n\nWell, the first number >= m_low that is coprime with K. Let's note that if m_low is 1, then the answer is 1. Otherwise, for m_low, we can check whether it's coprime with K. If yes, done. Else, check m_low +1, etc. But for large K, this could take O(1) steps if m_low is coprime with K, or O(1) steps if m_low is not coprime but m_low +1 is.\n\nBut in the worst case, for example, if K is a prime number, and m_low is K. Then, m_low is K, which is not coprime with K. Then, m_low +1 is K+1, which is coprime with K. So, the answer is K+1. So, in this case, it takes 1 step.\n\nBut in cases where K is a product of primes, and m_low is such that all numbers from m_low up to m_low + something are multiples of some factors of K, then it could take longer. However, given that K is up to 1e9, and m_low is up to (a/g), which for a up to 1e9 and g being a divisor of D (which is up to 1e9), m_low can be up to 1e9. But even then, in practice, for most K, the first number after m_low that is coprime with K is not too far away.\n\nBut for the purposes of programming competition, perhaps the code can just iterate from m_low upwards until a coprime is found. Given that the number of divisors is small, and for each divisor, the check is O(1) per step (with gcd), and given that the average case is manageable, this approach may be feasible.\n\nSo, the steps for the code are:\n\n- Read a and b. Let's assume a <=b. If a >b, swap them. So, D =b -a.\n\n- If D is zero, output 0.\n\n- Else, compute all divisors of D.\n\n- For each divisor g of D:\n\n   - compute K = D/g\n\n   - compute m_low = max(1, ceil(a/g)). Since a and g are integers, ceil(a/g) can be computed as (a +g -1) // g.\n\n   - find the minimal m >= m_low such that gcd(m, K) ==1.\n\n   - compute x_candidate = g * m.\n\n   - compute the LCM value for this x_candidate: LCM(x_candidate, x_candidate + D) = x_candidate * (x_candidate + D) / gcd(x_candidate, x_candidate + D). But since x_candidate =g*m and x_candidate + D =g*(m + K), and since K = D/g, and m and m + K are coprime (because we have ensured that gcd(m, K) =1, which implies that m and m + K are coprime?), wait:\n\nWait, earlier reasoning said that if m and K are coprime, then m and m + K are coprime. Because any common divisor of m and m + K divides their difference, which is K. But since gcd(m, K) =1, then the only possible common divisor is 1. Therefore, m and m + K are coprime. So, the GCD of x_candidate and x_candidate + D is g * gcd(m, m + K) = g * 1 =g. Therefore, the LCM is (x_candidate * (x_candidate + D )) / g = (g*m * g*(m + K)) / g = g*m*(m + K). Which is equal to g * m * (m + D/g). \n\nSo, for each candidate, the LCM is g * m * (m + D/g). Which can be calculated as above.\n\nBut for the purpose of comparing between different candidates, perhaps it's better to compute the actual LCM value, but given that the formula is known, perhaps we can compute it using the formula.\n\nOnce all the candidates are generated, we select the one with the minimal LCM. If multiple candidates have the same LCM, we choose the one with the smallest k (which is x_candidate -a).\n\nAdditionally, there's another case: when the optimal x is not generated by the divisors of D. But according to earlier reasoning, that's not possible. So, considering all divisors of D is sufficient.\n\nBut what about when D is zero? That's handled separately.\n\nSo, the code outline is:\n\nRead a and b.\n\nif a >b: swap them.\n\nif a ==b: print 0.\n\nelse:\n\n   D = b -a.\n\n   generate all divisors of D.\n\n   for each divisor g of D:\n\n      K = D//g\n\n      m_low = max(1, (a +g -1) // g )\n\n      find m_min >= m_low, coprime with K.\n\n      x_candidate = g * m_min\n\n      current_LCM = g * m_min * (m_min + K)\n\n      add to list of candidates.\n\n   also, there's another possibility: when K is D/g, but perhaps for the same g, there are multiple m's. But we are taking the minimal m for each g, which gives the minimal x_candidate for that g, hence the minimal LCM for that g.\n\nOnce all candidates are collected, find the one with minimal LCM. If tie, pick the one with minimal k (x_candidate -a).\n\nBut wait, there's another case: when the minimal x_candidate is not generated by any of the divisors of D. But according to previous reasoning, that's not possible. Because the GCD(x_candidate, x_candidate + D) is g, which divides D. So, all possibilities are covered by the divisors of D.\n\nBut then, what about when the optimal solution is when x and x + D are coprime? For example, x and x + D are coprime. In that case, the GCD is 1, which is a divisor of D. So, it's covered by the case where g=1. So, yes.\n\nBut there's another thing to consider: when K = D/g is zero? No, because D is non-zero (since a !=b), and g is a divisor of D, so K = D/g is at least 1. Because D is positive, and g is a positive divisor of D.\n\nSo, the code can proceed.\n\nNow, the problem is to generate all the divisors of D. How to generate them?\n\nTo generate all divisors of D, we can perform trial division. For example, for D, we can factorize it into primes, then generate all combinations of exponents.\n\nBut for numbers up to 1e9, trial division is manageable.\n\nAlternatively, for generating all divisors, we can do the following:\n\nInitialize a list of divisors. For i from 1 to sqrt(D), check if i divides D. If yes, then add i and D//i to the list. Then, after collecting all, remove duplicates and sort.\n\nBut for D up to 1e9, this is feasible.\n\nBut in Python, for D up to 1e9, sqrt(D) is up to 3e4, so manageable.\n\nOnce we have all the divisors, we can process them.\n\nBut note that for D=0, but that case is handled earlier.\n\nSo, code steps for generating divisors:\n\ndef get_divisors(D):\n\n    divisors = set()\n\n    for i in range(1, int(math.sqrt(D)) +1):\n\n        if D %i ==0:\n\n            divisors.add(i)\n\n            divisors.add(D//i)\n\n    return sorted(divisors)\n\nBut need to handle D=0, but in our case D is non-zero.\n\nOnce we have all the divisors, proceed.\n\nNow, for each divisor g, compute K = D//g.\n\nThen, find m_low = max(1, ceil(a/g)).\n\nBut how to compute ceil(a/g)?\n\nIn Python, (a +g -1) //g.\n\nYes.\n\nOnce m_low is computed, find the smallest m >= m_low such that gcd(m, K) ==1.\n\nOnce that m is found, compute x_candidate = g*m.\n\nOnce all candidates are generated, collect all the (k_candidate, LCM_value) pairs, then select the one with minimal LCM, and if tie, minimal k.\n\nBut what if there are multiple divisors leading to same LCM? For example, two different g's leading to same LCM. Then, we need to pick the one with the smallest k.\n\nSo, the code can collect all possible candidates, and then select the best one.\n\nBut what about the case when there are multiple m's for the same g? But for each g, we take the minimal m, which gives the minimal x_candidate for that g, which gives the minimal LCM for that g.\n\nSo, the code can proceed.\n\nBut let's test this with the sample input.\n\nSample Input 1: 6 10 → a=6, b=10. D=4.\n\nDivisors of 4: 1, 2,4.\n\nProcessing each divisor:\n\nCase 1: g=1 → K =4/1 =4.\n\nm_low = max(1, (6 +1 -1)//1 ) = max(1, 6) =6.\n\nFind the minimal m >=6 such that gcd(m,4) =1.\n\nCheck m=6: gcd(6,4) =2 → no.\n\nm=7: gcd(7,4)=1 → yes. So m_min=7. x_candidate =1 *7=7. Then, LCM is 1 *7 * (7 +4) =7*11=77. k_candidate =7-6=1.\n\nCase 2: g=2 → K =4/2=2.\n\nm_low = max(1, (6 +2-1)//2 ) = (6+1)//2 =7//2=3.5 → floor? Wait, (a +g -1) //g → (6 +2 -1) //2 →7//2=3. So m_low is 3.\n\nFind m >=3 such that gcd(m, 2) =1. So m must be odd.\n\nCheck m=3: gcd(3,2) =1 → yes. So m_min=3. x_candidate=2*3=6. LCM is 2 *3*(3 + 2) =2 *3 *5 =30. k_candidate=6-6=0. But wait, according to the sample input, the correct k is 2. What's happening here?\n\nWait, this seems conflicting. According to this case, for g=2, the x_candidate is 6. Which is a +k =6 →k=0. Then, y =x +D =6 +4=10. So LCM(6,10) is 30. But according to the sample input, the correct answer is k=2, which gives x=8 and y=12. Their LCM is 24. Which is smaller than 30. So why isn't this case considered?\n\nAh! Because there's a mistake in the code logic. Because for this case, the code is considering g=2, K=2. m_low is 3, and m=3. But then x_candidate is 6, which is a +k =6 →k=0. Then, the LCM is 30. But in reality, there's a better option. How?\n\nBecause according to the sample input, the minimal LCM is 24. How is that possible?\n\nBecause for x=8, which is 6 +k=8 →k=2. Then, y=12. The LCM is 24. How does this fit into the code's logic?\n\nLet me see. What is the GCD of 8 and 12? 4. So, g=4. Which is a divisor of D=4. So, for g=4, K= D/g =4/4=1.\n\nFor g=4, m_low is max(1, (6 +4 -1)/4) = (9)/4 =2.25 → floor? Wait, (a +g -1) //g → (6 +4 -1) //4 →9//4=2. So m_low is 2.\n\nFind the minimal m >=2 such that gcd(m, K=1) =1. Since K=1, any m is coprime with 1. So m_min is 2. x_candidate =4*2=8. LCM is 4 *2*(2 +1) =4*2*3=24. Which is the correct value. So in this case, the code",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The solution involves leveraging number theory concepts, specifically divisors and greatest common divisors (GCD).\n\n### Approach\n1. **Problem Analysis**: The goal is to minimize the LCM of two numbers $ a + k $ and $ b + k $. Given the constraint that $ k \\geq 0 $, we can reframe the problem by considering the difference $ D = |a - b| $ and finding the optimal $ k $ such that the LCM of the adjusted values is minimized.\n\n2. **Key Insight**: For any integers $ x $ and $ y $ with a fixed difference $ D $, the LCM of $ x $ and $ y $ is minimized when their GCD is maximized. This leads us to consider all divisors of $ D $, as the GCD must divide $ D $.\n\n3. **Divisors Calculation**: Generate all divisors of $ D $. For each divisor $ g $, compute the corresponding value $ K = D / g $, and determine the smallest $ m $ such that $ m \\geq \\lceil a / g \\rceil $ and $ \\gcd(m, K) = 1 $.\n\n4. **Optimal $ k $ Calculation**: For each valid divisor $ g $, calculate the corresponding $ x $ and check the resulting LCM. Track the minimum LCM and the corresponding $ k $.\n\n### Solution Code\n```python\nimport math\nimport sys\n\ndef get_divisors(D):\n    divisors = set()\n    for i in range(1, int(math.isqrt(D)) + 1):\n        if D % i == 0:\n            divisors.add(i)\n            divisors.add(D // i)\n    return sorted(divisors)\n\ndef find_min_k(a, b):\n    if a > b:\n        a, b = b, a\n    D = b - a\n    if D == 0:\n        return 0\n    divisors = get_divisors(D)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    \n    for g in divisors:\n        K = D // g\n        m_low = max(1, (a + g - 1) // g)\n        # Find minimal m >= m_low with gcd(m, K) == 1\n        m = m_low\n        while True:\n            if math.gcd(m, K) == 1:\n                break\n            m += 1\n        x_candidate = g * m\n        current_lcm = g * m * (m + K)\n        k_candidate = x_candidate - a\n        # Update the best\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n    return best_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, handling multiple test cases.\n2. **Divisors Calculation**: The function `get_divisors` generates all divisors of $ D $ using trial division up to the square root of $ D $.\n3. **Finding Optimal $ k $**: For each divisor $ g $ of $ D $, the code calculates the minimum $ m $ such that $ m \\geq \\lceil a / g \\rceil $ and $ \\gcd(m, K) = 1 $ where $ K = D / g $. This ensures that the resulting $ x $ and $ y $ values yield the smallest possible LCM.\n4. **Tracking Minimum LCM**: The code tracks the minimum LCM and the corresponding $ k $ value, ensuring that the smallest $ k $ is chosen in case of ties.\n\nThis approach efficiently leverages number theory concepts to minimize the LCM and ensure optimal performance even for large input values.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef get_divisors(D):\n    divisors = set()\n    for i in range(1, int(math.isqrt(D)) + 1):\n        if D % i == 0:\n            divisors.add(i)\n            divisors.add(D // i)\n    return sorted(divisors)\n\ndef find_min_k(a, b):\n    if a > b:\n        a, b = b, a\n    D = b - a\n    if D == 0:\n        return 0\n    divisors = get_divisors(D)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    \n    for g in divisors:\n        K = D // g\n        m_low = max(1, (a + g - 1) // g)\n        # Find minimal m >= m_low with gcd(m, K) == 1\n        m = m_low\n        while True:\n            if math.gcd(m, K) == 1:\n                break\n            m += 1\n        x_candidate = g * m\n        current_lcm = g * m * (m + K)\n        k_candidate = x_candidate - a\n        # Update the best\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n    return best_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 901,
        "thoughts_token_count": 8192
    }
}