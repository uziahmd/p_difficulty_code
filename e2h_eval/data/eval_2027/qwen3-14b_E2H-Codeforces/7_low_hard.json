{
    "start": 1758008515.6395323,
    "end": 1758008706.6209323,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a specific way. Let me try to understand the structure of such a graph.\n\nFrom the description:\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that has only one connection (so those leaves) are connected to k new vertices. This process must be done at least once. So, the construction involves layers. Let's think about how the number of vertices grows with each step.\n\nLet me think of the example given. For k=4, the smallest snowflake has 1 + 4 + 4*4 = 1+4+16=21? Or maybe not. Wait, maybe the steps are as follows:\n\nInitially, there's 1 node. Then, we add k nodes connected to it. So after first step, total nodes is 1 + k. Then, each of those k nodes (which are leaves) are connected to k new nodes. So each of them adds k nodes. So the next step adds k * k nodes. So total becomes 1 + k + k^2. But wait, the example says for k=4, the smallest is shown. Let me check the sample input. For example, in the sample input, when n=13, the answer is YES. Let's see: 1 + 4 + 4*4 = 1+4+16=21. That's larger than 13. So perhaps there's another way.\n\nWait, maybe the process is that the initial step is adding k nodes. Then, the second step is adding k nodes to each of the leaves. But maybe the process can be done for multiple steps. So the snowflake can have multiple layers. Let me think of the general case.\n\nLet me model the number of nodes. Let's say the construction process has m layers. Let me think of the layers as follows:\n\nLayer 0: 1 node (the root)\nLayer 1: k nodes connected to the root.\nLayer 2: Each node in layer 1 has k children. So layer 2 has k * k nodes.\nLayer 3: Each node in layer 2 has k children. So layer 3 has k^3 nodes.\n...\nBut the process requires that after the initial step (adding layer 1), the step of adding new nodes to leaves is done at least once. So the minimum number of layers is 2. So the total number of nodes would be 1 + k + k^2 + ... + k^m, where m is the number of layers minus 1. Wait, but maybe the construction stops after some steps. So the snowflake can be built with any number of layers, as long as there are at least two layers (since the second step must be done at least once). Wait, the initial step is adding layer 1. Then, the second step (adding to leaves) is done once. So the minimal snowflake would have 1 + k + k^2 nodes.\n\nSo for example, if k=2, then the minimal is 1+2+4=7 nodes. But in the sample input, n=6 is output NO. So that makes sense. Because for n=6, there's no possible k.\n\nSo the problem reduces to checking if n can be written as 1 + k + k^2 + ... + k^m, where m ≥ 1 (since the second step must be done at least once). Wait, m is the number of layers minus 1. Let me rephrase:\n\nThe snowflake construction starts with the root (layer 0). Then, we add layer 1 (k nodes). Then, for each of the layers after that, each node in the previous layer adds k children. But the process of adding new nodes to leaves (i.e., expanding the layers) must be done at least once. So the minimal is when there are two layers (layer 1 and layer 2). So the total number of nodes is 1 + k + k^2.\n\nBut also, maybe the process can stop after adding layer 1 and layer 2. Or maybe even more layers. So the total number of nodes is the sum from i=0 to m of k^i, where m ≥ 1. Wait, no. Because the sum from i=0 to m of k^i is (k^{m+1} - 1)/(k-1). But for the snowflake, the sum is 1 + k + k^2 + ... + k^m, where m ≥ 1. Because the first expansion is adding layer 1 (k nodes), then the second expansion is adding layer 2 (k^2 nodes), etc.",
    "response": "\n\nTo solve this problem, we need to determine if a given number of vertices `n` can form a snowflake graph as defined by the rules. The snowflake graph starts with one vertex and expands in layers, where each layer adds `k` new vertices to each leaf node from the previous layer. The key is to check if `n` can be represented as the sum of a geometric series starting from 1, with at least two terms (since the second expansion must occur at least once).\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph structure can be modeled as a geometric series. For a given `k`, the total number of vertices after `m` layers is given by the sum $1 + k + k^2 + \\ldots + k^m$.\n2. **Geometric Series Check**: For a given `n`, we need to check if there exists some integer `k > 1` such that `n` can be represented as the sum of a geometric series with at least two terms.\n3. **Iterative Check**: For each test case, iterate over possible values of `k` and check if `n` can be decomposed into the sum of the geometric series for some `k`. This involves checking all possible `k` values up to a certain limit derived from the maximum possible value of `n`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k starting from 2 up to some limit\n    # The maximum possible k is when the sum is 1 + k, so k <= n-1\n    # However, for efficiency, we can limit k to log(n) base 2\n    max_k = int(math.log(n, 2)) + 2\n    for k in range(2, max_k + 1):\n        total = 1\n        current = 1\n        count = 0\n        while True:\n            count += 1\n            next_term = current * k\n            if total + next_term > n:\n                break\n            total += next_term\n            current = next_term\n            if count >= 2:  # At least two layers (so m >= 1)\n                if total == n:\n                    return True\n    # Also check if n is of the form (k^m - 1)/(k-1) for some k>1 and m>=2\n    # Since the above loop may miss some cases where the sum is exactly n\n    # For example, when the sum ends exactly at n\n    for k in range(2, max_k + 1):\n        total = 1\n        current = 1\n        count = 0\n        while True:\n            count += 1\n            next_term = current * k\n            total += next_term\n            current = next_term\n            if count >= 2:\n                if total == n:\n                    return True\n            if total > n:\n                break\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read all at once for efficiency, especially given the constraints.\n2. **Checking Snowflake Validity**: The function `is_snowflake` checks if `n` can be represented as the sum of a geometric series starting from 1 with at least two terms. It iterates over possible values of `k` and computes the sum incrementally.\n3. **Efficiency Considerations**: The loop for `k` is limited to values up to the logarithm base 2 of `n`, ensuring that the solution remains efficient even for very large values of `n` (up to $10^{18}$).\n\nThis approach ensures that we efficiently check all possible configurations of the snowflake graph to determine if the given number of vertices `n` is valid.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k starting from 2 up to some limit\n    # The maximum possible k is when the sum is 1 + k, so k <= n-1\n    # However, for efficiency, we can limit k to log(n) base 2\n    max_k = int(math.log(n, 2)) + 2\n    for k in range(2, max_k + 1):\n        total = 1\n        current = 1\n        count = 0\n        while True:\n            count += 1\n            next_term = current * k\n            if total + next_term > n:\n                break\n            total += next_term\n            current = next_term\n            if count >= 2:  # At least two layers (so m >= 1)\n                if total == n:\n                    return True\n    # Also check if n is of the form (k^m - 1)/(k-1) for some k>1 and m>=2\n    # Since the above loop may miss some cases where the sum is exactly n\n    # For example, when the sum ends exactly at n\n    for k in range(2, max_k + 1):\n        total = 1\n        current = 1\n        count = 0\n        while True:\n            count += 1\n            next_term = current * k\n            total += next_term\n            current = next_term\n            if count >= 2:\n                if total == n:\n                    return True\n            if total > n:\n                break\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 561,
        "completion_token_count": 886,
        "thoughts_token_count": 1023
    }
}