{
    "start": 1758338143.5249817,
    "end": 1758338310.4641411,
    "start-formatted": "2025-09-20 12:15 KST",
    "end-formatted": "2025-09-20 12:18 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    results = []\n    \n    for i in range(0, len(data), 3):\n        n = int(data[i])\n        m = int(data[i+1])\n        g = int(data[i+2])\n        \n        # Precompute factorials and inverse factorials modulo MOD\n        max_nm = max(n, m)\n        fact = [1] * (max_nm + 1)\n        inv_fact = [1] * (max_nm + 1)\n        \n        for i in range(1, max_nm + 1):\n            fact[i] = fact[i-1] * i % MOD\n        \n        inv_fact[max_nm] = pow(fact[max_nm], MOD - 2, MOD)\n        for i in range(max_nm - 1, -1, -1):\n            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n        \n        def comb(a, b):\n            if a < 0 or b < 0 or a < b:\n                return 0\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n        \n        # Total number of strings with n 0s and m 1s\n        total = comb(n + m, n)\n        \n        # Now we need to check if it's possible to reduce the string to g using allowed operations\n        # Allowed operation: replace last two characters with one character.\n        # This operation reduces the length by 1 each time.\n        # So, the final string must have length 1, which means original length must be reducible to 1.\n        # The original length is n + m. To reduce to 1, we must have n + m - k = 1 => k = n + m - 1\n        # Each operation reduces length by 1, so we must have at least n + m - 1 operations\n        # But each operation requires at least 2 characters, so the original length must be >= 2\n        # So for the string to be reducible to g, the original length must be >= 2 and reducible to 1\n        \n        if n + m < 2:\n            results.append(0)\n            continue\n        \n        # Now simulate reduction process\n        # We need to know whether the string can be reduced to g\n        # For that, the number of 0s and 1s must satisfy some condition\n        \n        # Let's think recursively: the number of 0s and 1s must be such that they can be reduced to g\n        # We define a function f(a, b, target) that returns True if it's possible to reduce a string with a 0s and b 1s to target\n        \n        # Base case: if a + b == 1, then it's possible if the only character is target\n        def can_reduce(a, b, target):\n            if a + b == 1:\n                return a == (target == '0') and b == (target == '1')\n            \n            # Try all possible ways to reduce the last two characters\n            # If last two are 00 -> replace with 1\n            # If last two are 11 -> replace with 0\n            # If last two are 01 or 10 -> replace with 0 or 1? No, according to problem statement:\n            # \"replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero.\"\n            # So only 00 -> 1, others -> 0\n            \n            # So, the replacement is:\n            # 00 -> 1\n            # 01 -> 0\n            # 10 -> 0\n            # 11 -> 0\n            \n            # So, when reducing, we can only get 1 from 00, and 0 from anything else\n            \n            # So, the parity of the number of 00 pairs matters\n            # But since we don't know the order, it's hard to track\n            # However, we can use the following logic:\n            # To get g as the final character, the number of times we apply the operation that produces 1 (i.e., replacing 00 with 1) must be congruent to g mod 2\n            \n            # Let's consider the number of 0s and 1s\n            # The number of 00 pairs that can be formed is min(a, a - 1) // 2?\n            # Not sure, but let's think in terms of parity\n            \n            # Let's assume that during the reduction, the number of times we get 1 is equal to the number of 00 pairs we had\n            # Then, the final result is 1 if the number of 00 pairs is odd, 0 otherwise\n            \n            # But how many 00 pairs can we form?\n            # It depends on the order of characters, which is unknown\n            # However, the key observation is that the number of 0s and 1s must be such that it is possible to reach the desired g\n            \n            # Let's use dynamic programming approach to count the number of strings that can be reduced to g\n            \n            # We'll use memoization\n            from functools import lru_cache\n            \n            @lru_cache(None)\n            def dp(a, b, target):\n                if a + b == 1:\n                    return 1 if (a == 1 and target == '0') or (b == 1 and target == '1') else 0\n                \n                res = 0\n                # Try all possible ways to reduce the last two characters\n                # Case 1: last two are 00 -> replace with 1\n                if a >= 2:\n                    res += dp(a - 2 + 1, b, '1')  # a-2 zeros removed, add 1 new 1\n                # Case 2: last two are 01 or 10 -> replace with 0\n                if a >= 1 and b >= 1:\n                    res += dp(a - 1 + 0, b - 1 + 1, '0')  # remove 1 zero and 1 one, add 1 zero\n                # Case 3: last two are 11 -> replace with 0\n                if b >= 2:\n                    res += dp(a + 0, b - 2 + 1, '0')  # remove 2 ones, add 1 zero\n                \n                return res % MOD\n            \n            return dp(n, m, str(g))\n        \n        count = can_reduce(n, m, g)\n        results.append(count)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    results = []\n    \n    for i in range(0, len(data), 3):\n        n = int(data[i])\n        m = int(data[i+1])\n        g = int(data[i+2])\n        \n        # Precompute factorials and inverse factorials modulo MOD\n        max_nm = max(n, m)\n        fact = [1] * (max_nm + 1)\n        inv_fact = [1] * (max_nm + 1)\n        \n        for i in range(1, max_nm + 1):\n            fact[i] = fact[i-1] * i % MOD\n        \n        inv_fact[max_nm] = pow(fact[max_nm], MOD - 2, MOD)\n        for i in range(max_nm - 1, -1, -1):\n            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n        \n        def comb(a, b):\n            if a < 0 or b < 0 or a < b:\n                return 0\n            return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n        \n        # Total number of strings with n 0s and m 1s\n        total = comb(n + m, n)\n        \n        # Now we need to check if it's possible to reduce the string to g using allowed operations\n        # Allowed operation: replace last two characters with one character.\n        # This operation reduces the length by 1 each time.\n        # So, the final string must have length 1, which means original length must be reducible to 1.\n        # The original length is n + m. To reduce to 1, we must have n + m - k = 1 => k = n + m - 1\n        # Each operation reduces length by 1, so we must have at least n + m - 1 operations\n        # But each operation requires at least 2 characters, so the original length must be >= 2\n        # So for the string to be reducible to g, the original length must be >= 2 and reducible to 1\n        \n        if n + m < 2:\n            results.append(0)\n            continue\n        \n        # Now simulate reduction process\n        # We need to know whether the string can be reduced to g\n        # For that, the number of 0s and 1s must satisfy some condition\n        \n        # Let's think recursively: the number of 0s and 1s must be such that they can be reduced to g\n        # We define a function f(a, b, target) that returns True if it's possible to reduce a string with a 0s and b 1s to target\n        \n        # Base case: if a + b == 1, then it's possible if the only character is target\n        def can_reduce(a, b, target):\n            if a + b == 1:\n                return a == (target == '0') and b == (target == '1')\n            \n            # Try all possible ways to reduce the last two characters\n            # If last two are 00 -> replace with 1\n            # If last two are 11 -> replace with 0\n            # If last two are 01 or 10 -> replace with 0 or 1? No, according to problem statement:\n            # \"replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero.\"\n            # So only 00 -> 1, others -> 0\n            \n            # So, the replacement is:\n            # 00 -> 1\n            # 01 -> 0\n            # 10 -> 0\n            # 11 -> 0\n            \n            # So, when reducing, we can only get 1 from 00, and 0 from anything else\n            \n            # So, the parity of the number of 00 pairs matters\n            # But since we don't know the order, it's hard to track\n            # However, we can use the following logic:\n            # To get g as the final character, the number of times we apply the operation that produces 1 (i.e., replacing 00 with 1) must be congruent to g mod 2\n            \n            # Let's consider the number of 0s and 1s\n            # The number of 00 pairs that can be formed is min(a, a - 1) // 2?\n            # Not sure, but let's think in terms of parity\n            \n            # Let's assume that during the reduction, the number of times we get 1 is equal to the number of 00 pairs we had\n            # Then, the final result is 1 if the number of 00 pairs is odd, 0 otherwise\n            \n            # But how many 00 pairs can we form?\n            # It depends on the order of characters, which is unknown\n            # However, the key observation is that the number of 0s and 1s must be such that it is possible to reach the desired g\n            \n            # Let's use dynamic programming approach to count the number of strings that can be reduced to g\n            \n            # We'll use memoization\n            from functools import lru_cache\n            \n            @lru_cache(None)\n            def dp(a, b, target):\n                if a + b == 1:\n                    return 1 if (a == 1 and target == '0') or (b == 1 and target == '1') else 0\n                \n                res = 0\n                # Try all possible ways to reduce the last two characters\n                # Case 1: last two are 00 -> replace with 1\n                if a >= 2:\n                    res += dp(a - 2 + 1, b, '1')  # a-2 zeros removed, add 1 new 1\n                # Case 2: last two are 01 or 10 -> replace with 0\n                if a >= 1 and b >= 1:\n                    res += dp(a - 1 + 0, b - 1 + 1, '0')  # remove 1 zero and 1 one, add 1 zero\n                # Case 3: last two are 11 -> replace with 0\n                if b >= 2:\n                    res += dp(a + 0, b - 2 + 1, '0')  # remove 2 ones, add 1 zero\n                \n                return res % MOD\n            \n            return dp(n, m, str(g))\n        \n        count = can_reduce(n, m, g)\n        results.append(count)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 541,
        "completion_token_count": 1478,
        "thoughts_token_count": 0
    }
}