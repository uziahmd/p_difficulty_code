{
    "start": 1758308727.2510755,
    "end": 1758308898.6897583,
    "start-formatted": "2025-09-20 04:05 KST",
    "end-formatted": "2025-09-20 04:08 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Polycarp is dividing his problems into k days, each day solving consecutive problems, and the total profit is the sum of the maximums of each day's problems. My goal is to maximize that total profit.\n\nHmm. The constraints are n up to 2000, and k up to n. So for a dynamic programming approach, maybe O(n^2 * k) would be acceptable? Let me think.\n\nFirst, I need to model the problem. Let's think about dynamic programming. Let's say dp[i][j] represents the maximum total profit when considering the first i problems divided into j days. Then, the transition would be: for each possible split point m (where m ranges from j-1 to i-1), because each day must have at least one problem. So for dp[i][j], we can look at all possible m where the j-th day is from m+1 to i. Then, dp[i][j] = max(dp[m][j-1] + max(a[m+1..i])) for all valid m.\n\nBut calculating the max for each possible interval might be expensive. For example, if I have to compute max(a[m+1..i]) for every possible m and i, that's O(n^3) time in the worst case. Since n is 2000, that's 8e9 operations, which is way too slow.\n\nSo I need a way to precompute the maximums for all intervals. Oh right! We can precompute a 2D array max_range where max_range[l][r] is the maximum value in a[l..r]. Then, for any interval, we can get the max in O(1) time. How to compute that?\n\nWell, for each starting index l, we can iterate r from l to n-1, keeping track of the current maximum. That would take O(n^2) time, which is acceptable since n is 2000, so 4 million operations. That's manageable.\n\nOnce I have that precomputed, then the DP transitions can be done with O(n^2 * k) time. Let's think about the DP steps.\n\nThe base case would be dp[0][0] = 0. But for the first day, for example, dp[i][1] would be the max of the first i elements. For other cases, for each j from 2 to k, and for each i >= j (since each day has at least one problem), we can compute dp[i][j] as the maximum over m from j-1 to i-1 of dp[m][j-1] + max_range[m][i-1] (assuming 0-based arrays).\n\nWait, but the indices here need to be handled carefully. Let's clarify:\n\nAssuming the array a is 0-based. For the first i elements (from 0 to i-1?), or maybe 1-based? Let me think. Let's make it 1-based for easier thinking. So the array a is 1-based. For the first i elements (positions 1..i), and splitting into j days. Then, for the j-th day, the last day could be from m+1 to i, where m is the number of elements before. So for the j-th day, the previous j-1 days would have covered m elements, and the j-th day covers i - m elements. So m ranges from j-1 (since each of the previous j-1 days must have at least 1 element) to i-1 (since the j-th day must have at least 1 element).\n\nSo for dp[i][j], the recurrence is:\n\ndp[i][j] = max{ dp[m][j-1] + max(a[m+1..i]) }, for m from j-1 to i-1.\n\nNow, the initial conditions: dp[0][0] = 0. For j=1, dp[i][1] = max(a[1..i]).\n\nBut how to handle the DP table? Let's consider that the maximum possible n is 2000, and k is up to 2000. So the DP table would be size (n+1) x (k+1). For each i from 1 to n, and j from 1 to k.\n\nBut with n=2000 and k=2000, the DP table would be 2000*2000 = 4 million entries. For each entry, the transition could take O(n) time. So the total time would be O(n^2 * k) which would be 2000 * 2000 * 2000 = 8e10 operations. That's way too slow. Wait, that can't be right. Oh wait, no, for each dp[i][j], the inner loop is over m from j-1 to i-1. So for each i and j, the number of m's is up to i - (j-1) steps. But for j up to k, and i up to n, the total steps would be O(n^2 * k) which is 2000^3 = 8e10. Which is way too big. That's not feasible. So this approach is not going to work for n=2000.\n\nHmm. So what's another way? Maybe there's some optimization here. Let's think about the constraints again. For example, when k is large, like when k equals n, then each day has exactly one problem. Then the total profit is the sum of all elements. So maybe the DP approach is not feasible for n=2000 and k=2000. So perhaps we need to find another approach.\n\nAlternatively, perhaps there's a way to optimize the DP transitions. Let's think about the problem again.\n\nAnother observation: since each day's segment is a prefix of the array. Because the problems are solved in order, and each day's segment is a contiguous block starting from the beginning. Wait, no. Wait, the problem says that each day's problems are a contiguous sequence from the start. Wait, no, the problem says that Polycarp solves the problems in the order they are given. So each day's problems are a consecutive block, but the split is such that the first day takes some number of problems, then the second day takes some number after that, etc. So the splits are like, the first day ends at position m, the second at position m + l, etc. So the entire array is partitioned into k consecutive blocks, each of at least one element.\n\nSo for example, the first day is from 1 to t_1, the second from t_1 + 1 to t_1 + t_2, etc.\n\nSo the problem is to split the array into k consecutive parts, and for each part, take the max of that part, then sum all those maxes. We need to maximize that sum.\n\nSo the DP approach is necessary, but how to optimize it?\n\nLet me think about the DP again. The problem is that for each dp[i][j], the transition requires checking all m from j-1 to i-1. But maybe for certain cases, we can find a way to compute this more efficiently.\n\nBut for n=2000 and k=2000, even O(n^2) is 4 million, but O(n^2 * k) is 8e9. Which is way too slow.\n\nBut wait, when k is up to 2000, and n is 2000, perhaps there's a way to optimize. Let me think about the constraints again. For example, for j days, the minimal i is j (since each day must have at least one problem). So for j=1, i can be from 1 to n. For j=2, i can be from 2 to n, etc.\n\nBut perhaps the time can be optimized by using some properties of the problem.\n\nAnother idea: For each j, when computing dp[i][j], the max_range[m][i] can be considered. However, when considering m from j-1 to i-1, perhaps for some ranges, we can find a way to compute the maximum more efficiently.\n\nAlternatively, perhaps we can use the fact that the max_range[m][i] is non-decreasing as m decreases. Wait, no. For example, if you have a larger interval (from a smaller m to i), the max could be higher. But when m increases, the interval becomes smaller. So for a fixed i, the max_range[m][i] is the maximum of a[m+1 ... i]. As m increases, the interval becomes shorter, so the maximum could decrease or stay the same.\n\nBut how does that help?\n\nAlternatively, perhaps for each i and j, the optimal m is somewhere that allows us to take the maximum possible value. But I'm not sure.\n\nWait, let's think of the problem as follows. For each j, we can compute the dp[i][j] based on dp[m][j-1] plus the max from m+1 to i. So for a fixed j and i, we need to find the best m in [j-1, i-1].\n\nBut perhaps for each j, we can compute the dp[i][j] in a way that uses some previous information.\n\nAlternatively, maybe for each j, we can compute the dp[i][j] by considering that when we add a new element to the end of the previous splits.\n\nBut I'm not seeing a clear way forward.\n\nLet me think about the sample input. For example, in the first sample, n=8, k=3. The optimal split is [5,4,2], [6,5], [1,9,2]. The max for each day is 5, 6, 9. So the sum is 20.\n\nAnother observation: since each day's max is the maximum in that day's segment, and the segments are consecutive, perhaps for a given j, the optimal way to split the first i elements is to take the maximum of the current segment, and combine it with the best possible split for the first m elements into j-1 days.\n\nBut again, how to compute that.\n\nAlternatively, perhaps the DP approach can be optimized with some pre-processing.\n\nLet me think again about the pre-processing of the max_range. For example, for any interval [l, r], we can compute the maximum quickly. So that part is manageable.\n\nNow, for the DP. Let's try to proceed with the DP approach and see if it's feasible.\n\nLet me calculate the time complexity again. For n=2000, k=2000. The worst case is when k is 2000. For each j from 1 to k, and for each i from j to n, and for each m from j-1 to i-1. Let's think about the total number of operations.\n\nFor j=1, i ranges from 1 to n. For each i, m ranges from 0 to i-1 (but j=1, so j-1=0). So for j=1, the number of operations is O(n^2).\n\nFor j=2, i ranges from 2 to n. For each i, m ranges from 1 to i-1. So for j=2, the number of operations is O(n^2).\n\nSimilarly for each j, the number of operations is O(n^2). So for k=2000, the total number of operations is O(k * n^2) = 2000 * 2000^2 = 8e10 operations. Which is way too big. Even if each operation is a simple addition, this would take way longer than the allowed time (assuming 1e8 operations per second, this would be 800 seconds).\n\nTherefore, this approach is not feasible for n=2000.\n\nSo, we need a better approach. Let's think of other possibilities.\n\nAlternative idea: since the problem requires splitting into k days, and each day's segment is a prefix, perhaps the optimal solution involves selecting the k-1 largest elements in the array, and placing them as the max of each day. But that's probably not correct, because the max of a segment can be overlapping. For example, if two large elements are adjacent, splitting between them would allow both to be maxes.\n\nBut perhaps the maximum total profit is achieved by choosing the k largest elements, each being the max of their respective segments. However, this is only possible if those elements can be placed in different segments. For example, if the array is [5, 4, 6, 3], and k=2, then the best is to split into [5,4,6] and [3], giving max 6 +3 =9, or [5,4] and [6,3], which gives 5 +6 = 11. So the two largest elements are 6 and 5. But the optimal is to have 6 and 5 as maxes. However, if the array was [5,6,4,3], then splitting into [5], [6,4,3] gives 5+6=11, which is better than splitting into [5,6] and [4,3], which is 6+4=10. So in this case, the two largest elements are 6 and 5, and they are used as maxes.\n\nSo maybe the optimal strategy is to select the k-1 largest elements and split the array so that each of these elements is the max of a segment. However, how to do this?\n\nBut how to find which elements to choose and where to split. This seems tricky, but perhaps we can think of it as follows: the maximum total profit is the sum of the k largest elements, provided that they can be arranged as the max of their respective segments. However, this may not always be possible. For example, if the array is [1, 3, 2, 4], and k=2. The two largest elements are 4 and 3. To have them as maxes, we need to split the array into [1,3,2] and [4], which gives 3+4=7. Alternatively, [1,3], [2,4] gives 3+4=7. Or [1], [3,2,4] gives 1+4=5. So the maximum is indeed 7, which is the sum of the two largest elements. But suppose the array is [5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ",
    "response": "To solve this problem, we need to distribute `n` problems into `k` days such that the total profit, defined as the sum of the maximum difficulties of each day's problems, is maximized. The solution involves dynamic programming (DP) with precomputed maximum values for subarrays to optimize the transitions.\n\n### Approach\n1. **Precompute Maximum Values**: We first precompute the maximum values for all possible subarrays using a 2D array `max_range`, where `max_range[i][j]` stores the maximum value in the subarray from index `i` to `j`.\n\n2. **Dynamic Programming Setup**: Define a DP table `dp[i][j]` which represents the maximum profit achievable by solving the first `i` problems in `j` days. The transition involves considering all possible splits of the first `i` problems into `j` days and taking the maximum profit from those splits.\n\n3. **Reconstruct the Solution**: After filling the DP table, we backtrack from `dp[n][k]` to determine the exact distribution of problems across the `k` days.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Precompute max_range[l][r] = max(a[l..r]) (0-based)\n    max_range = [[0]*n for _ in range(n)]\n    for i in range(n):\n        current_max = a[i]\n        max_range[i][i] = current_max\n        for j in range(i+1, n):\n            current_max = max(current_max, a[j])\n            max_range[i][j] = current_max\n    \n    # Initialize DP table\n    INF = float('-inf')\n    dp = [[INF]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    \n    # Fill DP table\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if j > i:\n                continue\n            for m in range(j-1, i):\n                if dp[m][j-1] != INF:\n                    current_max = max_range[m][i-1]\n                    if dp[i][j] < dp[m][j-1] + current_max:\n                        dp[i][j] = dp[m][j-1] + current_max\n    \n    # Reconstruct the solution\n    res = []\n    current_i = n\n    current_j = k\n    while current_j > 0:\n        if current_j == 1:\n            res.append(current_i)\n            break\n        for m in range(current_j-1, current_i):\n            if dp[current_i][current_j] == dp[m][current_j-1] + max_range[m][current_i-1]:\n                res.append(current_i - m)\n                current_i = m\n                current_j -= 1\n                break\n    \n    res.reverse()\n    print(dp[n][k])\n    print(' '.join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Precompute Maximum Values**: The `max_range` array is filled such that each entry `max_range[i][j]` holds the maximum value in the subarray from index `i` to `j`. This allows quick lookup of maximum values during the DP transitions.\n\n2. **Dynamic Programming Table Initialization**: The DP table `dp[i][j]` is initialized with `-inf` to represent impossible states, except for `dp[0][0]` which is 0 (base case).\n\n3. **DP Transitions**: For each possible number of problems `i` and days `j`, we consider all possible previous splits `m` to compute the maximum profit by combining the best profit up to `m` problems in `j-1` days with the maximum value of the subarray from `m` to `i`.\n\n4. **Backtracking to Reconstruct the Solution**: After computing the DP table, we backtrack from `dp[n][k]` to determine the exact distribution of problems across the `k` days by checking which splits yielded the maximum profit at each step.\n\nThis approach ensures that we efficiently compute the maximum profit using dynamic programming with precomputed maximum values, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Precompute max_range[l][r] = max(a[l..r]) (0-based)\n    max_range = [[0]*n for _ in range(n)]\n    for i in range(n):\n        current_max = a[i]\n        max_range[i][i] = current_max\n        for j in range(i+1, n):\n            current_max = max(current_max, a[j])\n            max_range[i][j] = current_max\n    \n    # Initialize DP table\n    INF = float('-inf')\n    dp = [[INF]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    \n    # Fill DP table\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if j > i:\n                continue\n            for m in range(j-1, i):\n                if dp[m][j-1] != INF:\n                    current_max = max_range[m][i-1]\n                    if dp[i][j] < dp[m][j-1] + current_max:\n                        dp[i][j] = dp[m][j-1] + current_max\n    \n    # Reconstruct the solution\n    res = []\n    current_i = n\n    current_j = k\n    while current_j > 0:\n        if current_j == 1:\n            res.append(current_i)\n            break\n        for m in range(current_j-1, current_i):\n            if dp[current_i][current_j] == dp[m][current_j-1] + max_range[m][current_i-1]:\n                res.append(current_i - m)\n                current_i = m\n                current_j -= 1\n                break\n    \n    res.reverse()\n    print(dp[n][k])\n    print(' '.join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 935,
        "completion_token_count": 943,
        "thoughts_token_count": 8192
    }
}