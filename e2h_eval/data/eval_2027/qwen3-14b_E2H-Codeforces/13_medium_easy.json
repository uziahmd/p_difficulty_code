{
    "start": 1758344252.9418342,
    "end": 1758344376.9226708,
    "start-formatted": "2025-09-20 13:57 KST",
    "end-formatted": "2025-09-20 13:59 KST",
    "gpu": 2,
    "pid": 13,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if a given triad of notes is major, minor, or strange. Let's think about how to approach this.\n\nFirst, the problem says that the notes are ordered in a cyclic way. The list given is C, C#, D, D#, E, F, F#, G, G#, A, B, H. And then it cycles back. So each note has a position in this list, and the distance between two notes is calculated based on their positions. But the distance is measured as the number of semitones from the lower to the higher note. For example, between C and E, there are 4 semitones. Wait, let me check that. Let's see: C to C# is 1, then D is 2, D# 3, E is 4. Oh right. So the distance between C and E is 4 semitones. But if the order is reversed, like E to C, then the distance would be 8 semitones because there's 12 total notes. Because the distance is calculated as (target - start) mod 12, but since it's the distance along the scale from lower to upper, maybe we need to compute the difference in positions, taking into account the cyclic nature.\n\nSo first, I need to map each note to its index in the list. Let me create a list of the notes in order. Let's see:\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nWait, but the problem says that after H comes C again. So the order is cyclic. So for any two notes, the distance between them is (position of Y - position of X) mod 12? But wait, the distance is measured from the lower to the upper. So for example, if X is C (position 0), Y is E (position 4), then the distance is 4 semitones. If X is E (position 4) and Y is C (position 0), then the distance would be (0 -4 + 12) mod 12? Which is 8 semitones. So the distance between X and Y is (Y_pos - X_pos) mod 12? No, wait. Because if Y is after X in the list, then the distance is Y_pos - X_pos. If Y is before X, then the distance is (12 - (X_pos - Y_pos))? Or maybe (Y_pos - X_pos + 12) % 12? Wait, no. For example, X is E (position 4), Y is C (position 0). Then the distance from X to Y would be (0 -4) mod 12? Which is 8. But the actual distance along the scale from X to Y would be 8 semitones. Because going up from E to C would require going through F, F#, G, G#, A, B, H, C. That's 8 steps. So yes, the distance between X and Y is (Y_pos - X_pos) mod 12. Wait, but if Y is before X, then (Y_pos - X_pos) is negative. So mod 12 would give the correct positive value. For example, if X is at position 4 (E), Y is at 0 (C), then Y_pos - X_pos is -4. Mod 12 is 8. Which is correct. So the distance between X and Y is (Y_pos - X_pos) mod 12. But wait, the problem says that the distance is measured from the lower to the upper. So if X is lower than Y, then the distance is Y_pos - X_pos. If X is higher than Y, then the distance is (Y_pos + 12 - X_pos). Which is the same as (Y_pos - X_pos) mod 12. So yes, the distance between X and Y is (Y_pos - X_pos) mod 12. But wait, the problem says that the distance between E and C is 8 semitones. Which is exactly (0 -4) mod 12 = 8. So that's correct.\n\nSo the first step is to convert each note into its position in the list. Then, for the three notes in the input, I need to check all possible orderings to see if any of them satisfy the major or minor conditions.\n\nBut the problem says that the triad is unordered. So the three notes can be arranged in any order. For example, for a major triad, there must be some ordering X, Y, Z such that the distance between X and Y is 4 semitones, and between Y and Z is 3 semitones. Similarly for minor, the distance between X and Y is 3, and Y and Z is 4.\n\nSo for the given three notes, I need to check all permutations of the three notes and see if any permutation satisfies either the major or minor condition.\n\nBut since the problem says that the answer is unambiguous, we don't have to worry about overlapping cases.\n\nSo the plan is:\n\n1. Create a mapping from note names to their positions in the list. For example, 'C' is 0, 'C#' is 1, etc.\n\n2. Read the three input notes.\n\n3. Generate all permutations of the three notes. For each permutation (X, Y, Z), check:\n\n   a. For major: distance between X and Y is 4, and between Y and Z is 3.\n\n   b. For minor: distance between X and Y is 3, and between Y and Z is 4.\n\nIf any permutation satisfies major, then output 'major'. Similarly for minor. If none, output 'strange'.\n\nBut wait, the problem says that the chord is an unordered set. So for example, the same three notes can be arranged in different orders. However, for checking the major or minor, we need to check all possible orderings.\n\nBut how many permutations do I need to check?\n\nFor three elements, there are 6 permutations. However, since the problem is checking for any possible ordering, perhaps we can check all possible permutations.\n\nAlternatively, perhaps there's a smarter way. For example, for the major case, the three notes must be X, Y, Z such that X to Y is 4, Y to Z is 3. So the total from X to Z is 7. But since the order is cyclic, perhaps we can check for all possible pairs of notes and see if the distances fit.\n\nBut regardless, generating all permutations is manageable here. Since there are only 6 permutations, even if the code is a bit brute-force, it's acceptable.\n\nSo let's proceed with that.\n\nSo steps:\n\nFirst, create the note list and a dictionary for mapping note names to their index.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nThen, for each note in the input, get its index. Let's say the input is a list of three notes, like ['C', 'E', 'G'].\n\nThen, generate all permutations of the three notes. For each permutation (X, Y, Z):\n\nCheck for major: distance between X and Y is 4, and between Y and Z is 3.\n\nCheck for minor: distance between X and Y is 3, and between Y and Z is 4.\n\nIf any permutation meets the major condition, then return 'major'. Similarly for minor.\n\nBut how to compute the distance between X and Y?\n\nFor X and Y, their positions are x and y. The distance is (y - x) mod 12. Wait, no. Because the distance is measured from X to Y. So if X is before Y, then the distance is y - x. If X is after Y, then the distance is (y + 12 - x). Which is equivalent to (y - x) mod 12. Because if y < x, then (y -x) mod 12 is (y -x + 12) mod 12. Which is the same as the distance from X to Y.\n\nSo for example, if X is E (4), Y is C (0), then (0 -4) mod 12 is 8. Which is correct.\n\nSo for any two notes, the distance is (y - x) mod 12. But wait, in the problem statement, the distance between X and Y is taken as the number of semitones from the lower to upper. So if X is lower than Y, then the distance is Y - X. If X is higher than Y, then the distance is (Y + 12 - X). Which is the same as (Y - X) mod 12. So yes, the formula (y - x) mod 12 gives the correct distance between X and Y.\n\nBut wait, in the example given in the problem:\n\nThe first example is \"C E G\". Let's check the permutation (C, E, G). The distance between C and E is 4 (correct). Between E and G is 2 semitones? Wait, E is position 4, G is position 7. 7-4=3. So yes, that's 3. So the major condition is satisfied. So that's a major chord.\n\nAnother example: the second input is C# B F. Let's see. The correct permutation is B, C#, F. Let's check the positions. B is position 10, C# is 1, F is 5. So distance between B and C#: (1 - 10) mod 12 is ( -9 ) mod 12 = 3. So that's 3 semitones. Then between C# and F: 5 - 1 = 4. So that's 4. So minor condition is satisfied.\n\nSo the code needs to generate all permutations of the three notes, and for each, check the conditions.\n\nSo, in Python, for the three notes, we can generate all possible permutations using itertools.permutations.\n\nSo, the code steps:\n\nRead the input. The input is three space-separated notes. For example, the input is given as a list, but in the sample input, it's written as ['C E G', 'C# B F', 'A B H'], but the actual input is one line with three notes. Wait, the problem says that the input is the only line contains 3 space-separated notes. So for example, the sample input would be something like \"C E G\" (but the sample shows a list of three examples, but that's probably the input for three test cases. But the problem says that the input is one line with three notes.)\n\nWait, looking back at the problem statement:\n\nInput: The only line contains 3 space-separated notes in the above-given notation.\n\nSo, for example, for the first example, the input is \"C E G\", which outputs \"major\".\n\nSo the code needs to read a single line, split into three notes.\n\nSo in Python, the code would read:\n\nnotes = input().split()\n\nThen, the three notes are in notes[0], notes[1], notes[2].\n\nThen, generate all permutations of these three notes.\n\nFor each permutation, check:\n\ndistance between first and second is 4, and between second and third is 3 → major.\n\nOR distance between first and second is 3, and between second and third is 4 → minor.\n\nIf any permutation satisfies major, then output 'major'. Similarly for minor.\n\nIf none, output 'strange'.\n\nSo, the code can proceed as follows.\n\nFirst, create a dictionary for note positions.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\nThen, for the three input notes, get their indices.\n\nThen, generate all permutations of the three notes. For each permutation, check for major and minor.\n\nBut wait, permutations returns tuples of the elements. So for example, for the three notes [A, B, C], permutations will generate all 6 possible orderings.\n\nSo for each perm in permutations(notes):\n\nx, y, z = perm\n\nCompute distance between x and y: (y_idx - x_idx) mod 12.\n\ndistance_xy = (y_idx - x_idx) % 12\n\ndistance_yz = (z_idx - y_idx) % 12\n\nCheck if distance_xy == 4 and distance_yz == 3 → major.\n\nOr if distance_xy == 3 and distance_yz == 4 → minor.\n\nIf any permutation meets either condition, then return accordingly.\n\nBut wait, the problem says that the answer is unambiguous. So once any permutation meets major, then the answer is major. Similarly for minor.\n\nSo, in code:\n\nfor each permutation:\n\n    check major condition\n\n    if yes: return 'major'\n\n    check minor condition\n\n    if yes: return 'minor'\n\nIf after checking all permutations, none meet the conditions, return 'strange'.\n\nSo, the code can proceed as follows:\n\nimport itertools\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().split()\n\nfor perm in itertools.permutations(input_notes):\n    x, y, z = perm\n    x_idx = note_to_index[x]\n    y_idx = note_to_index[y]\n    z_idx = note_to_index[z]\n    \n    # Check major\n    dist_xy = (y_idx - x_idx) % 12\n    dist_yz = (z_idx - y_idx) % 12\n    if dist_xy == 4 and dist_yz == 3:\n        print(\"major\")\n        exit()\n    # Check minor\n    if dist_xy == 3 and dist_yz == 4:\n        print(\"minor\")\n        exit()\n\nprint(\"strange\")\n\nWait, but what about the case where multiple permutations could satisfy the condition? For example, if there are two permutations that satisfy major. But the problem says that the answer is unambiguous, so once any permutation satisfies major, we can return immediately.\n\nBut the code checks for all permutations. So for example, if the first permutation is not major, but another permutation is, then the code will check it.\n\nBut in the code above, for each permutation, we check if it satisfies major or minor. Once any permutation satisfies, the code returns.\n\nBut wait, the code checks for each permutation, in order. So for example, if the first permutation is not major, but another permutation is, then the code will find it.\n\nBut what if there are multiple permutations that satisfy the same condition? It doesn't matter, since once found, the code exits.\n\nBut this code may have a problem. Let's take the example of the first sample input: 'C E G'.\n\nThe permutations would include (C, E, G), which would have:\n\ndist_xy = E - C = 4-0=4 → 4 mod 12 is 4. Then dist_yz is G - E = 7-4=3. So yes, major. So the code would print 'major' and exit.\n\nAnother example: 'C# B F' → the permutation (B, C#, F) would be checked. Let's compute:\n\nB is note_to_index['B'] → looking at the notes_order list, the indexes are:\n\nC is 0, C# 1, D 2, D# 3, E 4, F 5, F# 6, G 7, G# 8, A 9, B 10, H 11.\n\nSo B is 10. C# is 1. F is 5.\n\ndist_xy is (1 - 10) mod 12 → ( -9 ) mod 12 is 3. Then dist_yz is (5 -1) mod 12 → 4. So yes, minor. So the code would print 'minor'.\n\nAnother example: 'A B H' → let's see.\n\nNotes are A, B, H. Let's check all permutations.\n\nLet's take A, B, H.\n\nA is index 9, B is 10, H is 11.\n\ndist_xy between A and B: 10-9=1 → mod 12 is 1. Not 3 or 4. So no.\n\nThen, check for other permutations.\n\nTake B, H, A.\n\nB is 10, H is 11, A is 9.\n\ndist_xy is 11-10=1. dist_yz is 9-11 = -2 mod 12 is 10. Not 3/4.\n\nAnother permutation: H, A, B.\n\nH is 11, A is 9. dist_xy is 9-11 = -2 mod 12 is 10. Not 3 or 4.\n\nAnother permutation: A, H, B. dist_xy is H - A → 11 -9 = 2. Then dist_yz is B - H → 10 -11 = -1 mod 12 is 11. No.\n\nAnother permutation: B, A, H. dist_xy is A - B → 9-10 = -1 mod 12 → 11. No.\n\nAnother permutation: H, B, A. dist_xy is B - H → 10 -11 = -1 mod 12 is 11. No.\n\nSo none of the permutations satisfy the major or minor conditions. So the output is 'strange'.\n\nWhich matches the sample input.\n\nSo the code seems to work.\n\nBut wait, what about the case where the same chord can be arranged in different ways? For example, suppose a chord that is major can be arranged in multiple ways. But the code would check all permutations and exit once the first one is found.\n\nBut the code is correct as long as it checks all permutations and returns when any of them meets the condition.\n\nNow, possible edge cases:\n\nWhat if two notes are the same? But according to the problem statement, the input is three notes. However, the problem says that the chord is an unordered set of no less than three notes. However, the problem says that the input is three notes. But the problem says that the answer is unambiguous. However, the code will process them as per the permutations. For example, if the input is ['C', 'C', 'C'], then all permutations will have x, y, z as same note. The distance between x and y is 0, so no condition met. So output 'strange'.\n\nAnother case: what if the three notes are in a different order but satisfy the condition?\n\nFor example, for a major chord, the code checks all permutations. Suppose the permutation is Y, Z, X. But the code checks for the first two elements (Y and Z) and then Z and X. But that may not meet the condition. However, the code will check all permutations. So for example, if the correct order is X, Y, Z, then in the permutations, that order will be checked.\n\nAnother possible issue: the code checks for (X, Y, Z) in permutations, and checks if X-Y is 4 and Y-Z is 3. But what about if the chord is X, Z, Y? For example, if the correct order is X, Y, Z, but the permutation is X, Z, Y. Then the code would check X-Z and Z-Y. Which may not satisfy the condition. But since the code checks all permutations, the correct one will be found.\n\nSo the code should handle all possibilities.\n\nNow, let's implement this in Python.\n\nBut first, the code needs to import itertools.permutations.\n\nBut the code must not have any print statements except for the output. Also, the code must read from stdin and output the correct answer.\n\nSo the code would be:\n\nimport itertools\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().split()\n\nfor perm in itertools.permutations(input_notes):\n    x, y, z = perm\n    x_idx = note_to_index[x]\n    y_idx = note_to_index[y]\n    z_idx = note_to_index[z]\n    \n    dist_xy = (y_idx - x_idx) % 12\n    dist_yz = (z_idx - y_idx) % 12\n    \n    if dist_xy == 4 and dist_yz == 3:\n        print(\"major\")\n        exit()\n    if dist_xy == 3 and dist_yz == 4:\n        print(\"minor\")\n        exit()\n\nprint(\"strange\")\n\nWait, but in Python, the exit() function may not be the best. But in code submission, it's acceptable. Alternatively, using return in a function, but since it's a script, using sys.exit. However, the code as written uses exit(), which in Python is part of the built-in functions. But in some environments, it's better to use sys.exit. However, in practice, for code submission, using exit() might be acceptable. However, in Python, exit() is actually from the sys module. So perhaps better to import sys and use sys.exit().\n\nBut the code as written may raise an error. Let me check: in Python, exit() is a built-in function in the standard environment. However, in some contexts, like in certain online judges, perhaps it's better to use sys.exit(). But for the purposes of code submission, perhaps it's better to use sys.exit().\n\nSo modifying the code:\n\nimport sys\nimport itertools\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().split()\n\nfor perm in itertools.permutations(input_notes):\n    x, y, z = perm\n    x_idx = note_to_index[x]\n    y_idx = note_to_index[y]\n    z_idx = note_to_index[z]\n    \n    dist_xy = (y_idx - x_idx) % 12\n    dist_yz = (z_idx - y_idx) % 12\n    \n    if dist_xy == 4 and dist_yz == 3:\n        print(\"major\")\n        sys.exit()\n    if dist_xy == 3 and dist_yz == 4:\n        print(\"minor\")\n        sys.exit()\n\nprint(\"strange\")\n\nYes. This code should work.\n\nNow, let's test the sample input.\n\nSample Input: 'C E G' → code checks permutations. One of them is (C, E, G). dist_xy is 4, dist_yz is 3 → major. So output is 'major'.\n\nSample Input: 'C# B F' → permutations include (B, C#, F). dist_xy is (1 -10) mod 12 → ( -9 ) mod 12 is 3. dist_yz is (5 -1) mod 12 → 4. So minor.\n\nThird sample input: 'A B H' → all permutations checked, none meet the conditions, output 'strange'.\n\nSo the code works.\n\nAnother test case: let's take a minor chord. For example, 'B C# F' → which is the same as the second sample input. The code would output 'minor'.\n\nAnother example: 'C E G#'. Let's see. Let's check permutations.\n\nLooking for any permutation where X-Y is 4 and Y-Z is 3. For example, C, E, G#. The distance between C and E is 4. Between E and G# is 8-4=4? Wait, E is index 4. G# is index 8. So distance is 8-4=4. So dist_xy is 4, dist_yz is 4. Not 3. So not major. What about other permutations?\n\nWhat if the permutation is C, G#, E? Then X is C, Y is G# (index 8). Distance is 8-0=8 mod 12 is 8. Not 4. So no. Maybe another permutation. Let's see. Maybe E, G#, C. dist_xy is 8-4=4. dist_yz is 0-8 mod 12 is 4. So 4 and 4. Not 3. So no. So this would be strange.\n\nBut what if the chord is C, E, G. Which is major. So the code works.\n\nAnother test case: 'C# E G#'. Let's see. Let's check for major. Let's see, for permutation (C#, E, G#). C# is index 1, E is 4. dist_xy is 3. Then E to G# is 8-4=4. So that's 3 and 4. So minor. So the code would output 'minor'.\n\nYes. So the code would check that permutation and output 'minor'.\n\nSo the code seems to handle all cases correctly.\n\nThus, this should be the correct solution.\n",
    "response": "To solve this problem, we need to determine if a given triad of musical notes forms a major chord, a minor chord, or neither. The solution involves checking all permutations of the three notes to see if they meet the criteria for either a major or minor chord based on semitone distances.\n\n### Approach\n1. **Mapping Notes to Indices**: Convert each note to its corresponding position in a predefined list of musical notes. This helps in calculating the semitone distances between any two notes.\n2. **Permutations Check**: Generate all permutations of the three input notes. For each permutation, calculate the semitone distances between consecutive notes.\n3. **Distance Calculation**: For each permutation, check if the distances between the first and second note (X to Y) and between the second and third note (Y to Z) meet the criteria for a major or minor chord:\n   - **Major Chord**: Distance from X to Y is 4 semitones and from Y to Z is 3 semitones.\n   - **Minor Chord**: Distance from X to Y is 3 semitones and from Y to Z is 4 semitones.\n4. **Output Result**: If any permutation meets the criteria for a major or minor chord, print the corresponding result. If none do, print \"strange\".\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().split()\n\nfor perm in itertools.permutations(input_notes):\n    x, y, z = perm\n    x_idx = note_to_index[x]\n    y_idx = note_to_index[y]\n    z_idx = note_to_index[z]\n    \n    dist_xy = (y_idx - x_idx) % 12\n    dist_yz = (z_idx - y_idx) % 12\n    \n    if dist_xy == 4 and dist_yz == 3:\n        print(\"major\")\n        sys.exit()\n    if dist_xy == 3 and dist_yz == 4:\n        print(\"minor\")\n        sys.exit()\n\nprint(\"strange\")\n```\n\n### Explanation\n- **Mapping Notes**: The `notes_order` list defines the sequence of musical notes, and `note_to_index` maps each note to its index for quick lookup.\n- **Permutations**: Using `itertools.permutations`, we generate all possible orderings of the three input notes to check each possible configuration.\n- **Distance Calculation**: The semitone distance between two notes is calculated using modulo arithmetic to handle the cyclic nature of the musical scale.\n- **Check Conditions**: For each permutation, we check if the distances meet the criteria for a major or minor chord and print the result immediately if found. If no valid configuration is found, we print \"strange\".\n\nThis approach ensures that all possible configurations are checked efficiently, leveraging permutations and modular arithmetic to handle the cyclic nature of musical notes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().split()\n\nfor perm in itertools.permutations(input_notes):\n    x, y, z = perm\n    x_idx = note_to_index[x]\n    y_idx = note_to_index[y]\n    z_idx = note_to_index[z]\n    \n    dist_xy = (y_idx - x_idx) % 12\n    dist_yz = (z_idx - y_idx) % 12\n    \n    if dist_xy == 4 and dist_yz == 3:\n        print(\"major\")\n        sys.exit()\n    if dist_xy == 3 and dist_yz == 4:\n        print(\"minor\")\n        sys.exit()\n\nprint(\"strange\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 683,
        "completion_token_count": 646,
        "thoughts_token_count": 5512
    }
}