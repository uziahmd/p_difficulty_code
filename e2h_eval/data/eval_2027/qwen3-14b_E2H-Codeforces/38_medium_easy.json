{
    "start": 1758308365.1762514,
    "end": 1758308553.7335103,
    "start-formatted": "2025-09-20 03:59 KST",
    "end-formatted": "2025-09-20 04:02 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to find two things for a given p: the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, I need to understand what a p-reachable graph is. According to the problem statement, a p-reachable graph has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So, for each such pair, both directions must have paths. Wait no, the definition says \"reachable from each other\", which means that there's a path from u to v and from v to u. So those pairs are mutual.\n\nThe first part of the problem is to find the minimal number of nodes needed so that the graph can have exactly p such mutual pairs. Then, for that minimal node count, find the maximum number of unidirectional pairs possible.\n\nLet me think about how to model the mutual reachability pairs. For a graph with n nodes, how many mutual pairs can it have? Well, if the graph is a DAG with some structure, but maybe the maximum number of mutual pairs comes from certain configurations.\n\nWait, but the problem is not about maximizing mutual pairs. It's about having exactly p mutual pairs. So for the first part, we need to find the minimal n such that there exists a graph with exactly p mutual pairs.\n\nSo, perhaps we can model the problem by considering that the mutual pairs are formed in a way that each pair contributes 1 to the count. But how?\n\nLet me think about the minimal n. Let's think about the maximum number of mutual pairs possible with n nodes. Because if we can find for a given n, the maximum possible mutual pairs, then we can find the minimal n such that this maximum is >= p. But wait, the problem says that the graph must have exactly p mutual pairs. So for example, if the maximum number of mutual pairs for n nodes is m, then for p up to m, we can have a graph with exactly p pairs by adjusting the structure.\n\nBut how do we find the minimal n such that the maximum possible mutual pairs for that n is at least p?\n\nAlternatively, perhaps the minimal n is determined by the triangular numbers. Because, for example, if the graph is a complete graph with all edges in both directions (so that every pair is mutual), then the number of mutual pairs is C(n, 2). But that's only if all pairs are mutual. However, if you have a graph that's a collection of strongly connected components (SCCs), then each pair within an SCC contributes to the mutual pairs.\n\nWait, but for mutual reachability, if two nodes are in the same strongly connected component (SCC), then they are mutually reachable. So the total number of mutual pairs is the sum over each SCC of C(k, 2), where k is the size of the SCC. Because each pair within the same SCC contributes one mutual pair (since u < v, but the count is ordered pairs, but the problem says u < v. Wait, the problem defines ordered pairs (u, v) with u < v. So for each unordered pair {u, v}, there is exactly one ordered pair (u, v) where u < v. So the total mutual pairs is the sum over all SCCs of C(size, 2).\n\nSo the problem reduces to choosing a set of SCCs whose sizes are such that the sum of C(k_i, 2) equals p. And we need to find the minimal total number of nodes, which is the sum of k_i's, such that the sum of C(k_i, 2) is exactly p.\n\nAh! So the problem becomes: find the minimal sum of integers k_1 + k_2 + ... + k_m such that the sum of (k_i choose 2) equals p. Then, once we have that minimal sum, which is the minimal number of nodes, we need to compute the maximum number of unidirectional pairs possible in such a configuration.\n\nSo for example, in the first sample input where p=3, the minimal sum is 3. Because 3 choose 2 is 3. So the sum is 3. So the minimal number of nodes is 3. Now, for the second part, the maximum number of unidirectional pairs. How to calculate that?\n\nUnidirectional pairs are those (u, v) where u != v, there is a path from u to v, but no path from v to u. So in terms of the SCCs, if you have two different SCCs, say A and B. If there is an edge from A to B, then for any u in A and v in B, if there's a path from u to v, but since there's no path from B to A (since they are separate SCCs), then (u, v) is a unidirectional pair. But if there's a path from A to B and also from B to A, then they would be merged into a single SCC.\n\nSo the maximum number of unidirectional pairs would be achieved when the graph is structured in such a way that between different SCCs, all possible directed edges go in one direction, and there are as many such pairs as possible.\n\nBut how to compute this?\n\nLet me think. Suppose that the graph has several SCCs. Let's say that the SCCs are arranged in a DAG, where there's an edge from one component to another if there's a path between them. The number of unidirectional pairs is the number of ordered pairs (u, v) where u is in one component, v is in another component, and there's a path from u to v but not vice versa. Also, within each component, there are no unidirectional pairs because all pairs are mutual (since they are in the same SCC).\n\nSo the total unidirectional pairs would be the sum over all pairs of components (A, B) where there is a directed edge from A to B (but not vice versa), multiplied by the product of their sizes (since for each u in A and v in B, there is a path from u to v, but not the reverse). However, if the DAG of components is a total order, then for each pair of components A and B, if A comes before B in the order, then there's a path from A to B, and no path from B to A. Thus, the total number of such pairs is the sum over all i < j of (size_i * size_j) * 2? No, wait. Because for each pair of components (A, B) where A is before B, the ordered pairs (u, v) with u in A and v in B contribute to unidirectional pairs. Similarly, the ordered pairs (v, u) where v is in B and u is in A would not be unidirectional because there's no path from B to A. So for each pair of components, the number of unidirectional pairs between them is (size_A * size_B) if there's a path from A to B but not vice versa.\n\nBut in order to maximize the number of unidirectional pairs, we need to arrange the components in a DAG such that between any two components, there's a directed edge in one direction. The maximum would be achieved when the DAG of components is a total order, so that for every pair of components, one is before the other, and thus contributes size_A * size_B to the unidirectional count.\n\nSo, the maximum number of unidirectional pairs is the sum over all pairs of components (A, B) where A comes before B in the total order, multiplied by size_A * size_B. Which is equal to (sum_{i} size_i)^2 - sum_{i} size_i^2 ) / 2. Because the total number of ordered pairs between different components is (total_nodes)^2 - sum size_i^2. Then, since each such pair is counted once in one direction (because the DAG is a total order), the total is (total_nodes^2 - sum size_i^2 ) / 2. Wait, no. Let me think again.\n\nSuppose that the total number of nodes is N = sum size_i. The total number of ordered pairs (u, v) where u and v are in different components is N^2 - sum (size_i^2). Each such pair is either (u in A, v in B) or (v in B, u in A). In the case where the components are ordered in a total order, for each pair of components A and B, if A is before B, then all (u in A, v in B) are unidirectional, and (v in B, u in A) are not. So the total number of unidirectional pairs is sum_{i < j} size_i * size_j. Which is equal to [ (sum size_i)^2 - sum size_i^2 ] / 2.\n\nYes, because sum_{i != j} size_i * size_j = (sum size_i)^2 - sum size_i^2. And since sum_{i < j} size_i size_j = sum_{i > j} size_i size_j, so each is half of that. Therefore, the maximum number of unidirectional pairs is [N^2 - sum size_i^2 ] / 2.\n\nBut wait, this assumes that the DAG of components is a total order, so that for any two components, one is before the other. So in this case, the maximum possible unidirectional pairs is achieved.\n\nTherefore, for the second part of the problem, once we have the minimal N (sum of sizes of components), and the sizes of the components (say, the sizes are k_1, k_2, ..., k_m, such that sum (k_i choose 2) = p), then the maximum number of unidirectional pairs is [N^2 - sum (k_i^2)] / 2.\n\nSo the problem now becomes:\n\n1. Find the minimal N such that there exists a set of integers k_1, k_2, ..., k_m, where each k_i >= 1, sum (k_i choose 2) = p, and sum k_i = N. And N is minimized.\n\n2. Once N is found, find the maximum [N² - sum k_i² ] / 2, which is achieved when the components are arranged in a total order, so that all possible cross-component pairs are unidirectional.\n\nSo the first task is to find the minimal N. How?\n\nThe minimal N is obtained by choosing the sizes of the components such that each component contributes as much as possible to p with as few nodes as possible. Because (k choose 2) is the number of mutual pairs for a component of size k. So for example, for a given p, the optimal way to minimize N is to use as large as possible components, because (k choose 2) grows quadratically with k, while the sum of k's grows linearly. So, for example, if p is 3, the best is one component of size 3, which gives 3 mutual pairs and uses 3 nodes. If we used two components, say 2 and 1, then (2 choose 2) + (1 choose 2) = 1 + 0 = 1 < 3. So that's worse.\n\nSo the strategy for finding the minimal N is to take the largest possible components, such that the sum of (k_i choose 2) is exactly p.\n\nSo the approach is similar to the problem of representing p as the sum of triangular numbers, and finding the minimal sum of their bases.\n\nFor example, for a given p, we can greedily take the largest possible k such that (k choose 2) <= p. Subtract that value from p, and proceed recursively. However, this may not always give the minimal N. For example, sometimes taking a slightly smaller component allows for more efficient use of the remaining p.\n\nBut for the minimal N, the greedy approach of taking the largest possible k_i each time might be correct. Let me think.\n\nLet's take an example. Suppose p is 4. The largest possible (k choose 2) is 3 (k=3). Then the remaining is 1. The next largest is 1 (k=2, 1). So total nodes is 3+2 = 5. However, if we take two components of size 2 and 2, then sum (2 choose 2) * 2 is 1 + 1 = 2 < 4. Not enough. Alternatively, maybe a component of size 3 (3) and a component of size 2 (1) gives 3 + 1 = 4. So total nodes 3+2=5. Alternatively, a component of size 4 (6) is larger than 4, so no. So the minimal N here would be 5. But perhaps there's another way? Let me see. What about a component of size 3 (3) and a component of size 2 (1), total 3+2=5. Or maybe a component of size 4 (6) is too big. So no. So the minimal N is 5.\n\nAnother example: p=5. Largest possible is 3 (3), then 2 (1) gives total 3+2=5. But 3+1=4. Wait, 3+1 is 4, but 3+1=4? Wait, 3 is the sum of (3 choose 2) = 3. Then remaining p is 5-3=2. Next largest is 2 (which gives 1). Then remaining is 2-1=1. Then take another 2 (but that would add 1 again, making total 3+2+2=7). But that's worse. Alternatively, maybe take 3 (3) and 2 (1) and 1 (0) gives 3+1+0=4. But that's not helpful. Wait, perhaps there's a better way. What if we take a component of size 4 (6) is too big. So maybe 3 (3) and 2 (1) and 1 (0) gives total 3+2+1=6 nodes, but sum is 3+1=4, which is less than 5. So no. Hmm. Wait, maybe take 3 (3) and 3 (3) gives sum 6, which is more than 5. So not allowed. So maybe take 3 (3) and 2 (1) gives 4, and then take another 2 (1) to get 5. That would be 3+2+2=7 nodes. But perhaps there's a better way. What if take a component of size 4 (6) and subtract 1? No, because we can't have fractions. So maybe the minimal N is 5. How? Let's see. For example, if we have a component of size 3 (3) and a component of size 2 (1), but that gives sum 4. To get 5, we need to add another 1. So perhaps a component of size 3 (3) and a component of size 2 (1), and a component of size 1 (0). So the sum is 3+1+0=4. No. Alternatively, perhaps take a component of size 4 (6) and subtract 1, but that's not allowed. So maybe the minimal N is 5? Or is there a way to split 5 into sum of (k_i choose 2) with a smaller sum of k_i?\n\nWait, 5 can be written as 3 + 1 + 1. Which would be three components: 3, 2, 2. The sum of their sizes is 3+2+2=7. Or maybe 5 can be written as 2+2+1. Wait, (2 choose 2) is 1. So 1+1+1 = 3. No. So that's not enough. Hmm. Maybe there's no way except to take 3 (3) and then 2 (1) and then another 2 (1) for a total of 3+2+2=7. But that gives 3+1+1=5. So the sum of k_i is 7. But maybe there's a better way. What about a component of size 4 (6) minus 1? No. Because that would require having 5 = (something). Wait, 5 = 3 + 1 + 1, which is 3 + 2*1. So the minimal sum is 3 + 2 + 2 = 7. But perhaps there's a better way. For example, if we have a component of size 3 (3) and a component of size 3 (3), but that gives 6, which is larger than 5. So no. So the minimal N is 7? But that seems high. Wait, perhaps there's another decomposition. For example, 5 can be written as (4 choose 2) is 6, which is larger than 5. So not allowed. What about (3 choose 2) is 3, and (2 choose 2) is 1. Then 3 + 1 + 1 = 5. Which requires two components of size 2. So sum is 3 + 2 + 2 = 7. Alternatively, can we have a component of size 5? (5 choose 2) is 10, which is bigger than 5. So no. So the minimal N is 7 for p=5? But that seems counterintuitive. Wait, but maybe there's a way to split into components with different sizes. For example, 2 + 2 + 1. But (2 choose 2) is 1, so 1 + 1 + 0 = 2 < 5. Not helpful. So perhaps the minimal N is indeed 7. But that seems a bit strange. Maybe I'm missing something.\n\nAlternatively, perhaps there's a way to have components that are not just individual ones. For example, if you have a component of size 4 and another of size 1. Then (4 choose 2) is 6, which is more than 5. So not allowed. So no. So for p=5, the minimal N is 7? But that's a lot. However, perhaps the minimal N is not found by the greedy approach. So maybe the greedy approach is not sufficient, and we need to think differently.\n\nWait, but maybe I made a mistake. Let me think again. How can we get p=5? For example, if we have a component of size 3 (3 mutual pairs) and a component of size 2 (1 mutual pair), and then a component of size 2 (another 1 mutual pair). Then the total is 3 + 1 + 1 = 5. So the sum of the sizes is 3 + 2 + 2 = 7. But maybe there's a better way. What if we have a component of size 4 (6 mutual pairs) and then subtract 1? But that's not allowed. How else?\n\nAlternatively, what if we have a component of size 3 and another of size 3. Then sum of mutual pairs is 3 + 3 = 6. But that's more than 5. So not allowed. So we can't take that. So maybe the minimal N is 7. But how?\n\nAlternatively, perhaps there's a way to have a component of size 5, but not fully connected. Wait, but the mutual pairs are determined by the SCCs. For example, if you have a component of size 5, but not all pairs are mutually reachable. Wait, but if the component is a single SCC, then all pairs are mutually reachable. So the number of mutual pairs is C(5, 2) = 10. So that's not helpful. So to get exactly 5 mutual pairs, the components must be arranged such that the sum of C(k_i, 2) is 5.\n\nSo, for example, if there are two components: one of size 3 (3 mutual pairs) and another of size 2 (1 mutual pair). Then the sum is 3 + 1 = 4. Not enough. We need one more. So add another component of size 2 (another 1 mutual pair). Total sum is 5, and sum of sizes is 3 + 2 + 2 = 7.\n\nAlternatively, can we have a component of size 4 and another of size 2. Then C(4,2) is 6, which is more than 5. Not allowed.\n\nHmm. So perhaps the minimal N for p=5 is 7. But then, what about the example given in the problem statement?\n\nIn the sample input, for p=3, the minimal N is 3. Which is achieved by a single component of size 3.\n\nAnother sample input is p=4. Let's think: the maximum possible mutual pairs for n=3 is C(3,2)=3 <4. So the minimal N is 4. Let's see:\n\nFor N=4, possible decompositions:\n\nOption 1: one component of size 4: C(4,2) = 6 >=4. But how to get exactly 4? We can't. Because the sum must be exactly p. So perhaps we need to split into multiple components. For example, a component of size 3 (3 mutual pairs) and a component of size 1 (0). Sum is 3. Not enough. Then another component of size 2 (1). Sum is 3+1=4. So total nodes is 3+2=5. So N=5. But maybe there's a better way. For example, two components of size 2 and 2. Sum is 1+1=2 <4. No. Or a component of size 3 (3) and a component of size 2 (1) and a component of size 1 (0). Sum is 3+1=4. Nodes 3+2+1=6. Which is worse than 5. So the minimal N for p=4 is 5.\n\nBut according to the sample input, for p=4, the output is '5 6'. Let's check that. The first part is 5 nodes. Then the maximum number of unidirectional pairs is 6.\n\nSo according to the formula, N is 5. The components are 3 and 2. So sum of k_i^2 is 3² + 2² = 9 +4=13. N² is 25. So (25-13)/2 = 12/2=6. Which matches the sample output. So that's correct.\n\nSo for p=4, the minimal N is 5. Which is achieved by 3+2 components. So the approach of taking the largest possible components (greedily) may not be correct. Because for p=4, the greedy approach would take the largest possible k_i such that C(k, 2) <=4. The largest is 3 (C(3,2)=3). Then remaining p is 1. Take the next largest, which is 2 (C(2,2)=1). So total sum is 3+2=5. Which is correct.\n\nSo perhaps the greedy approach works. Let's think again. For each step, take the largest possible k such that C(k, 2) ≤ remaining p. Subtract C(k,2) from p, and proceed. Repeat until p is zero.\n\nSo for p=5, the greedy approach would take 3 (3), then 2 (1), then 2 (1), total 3+2+2=7. Which gives sum of mutual pairs 3+1+1=5. Which is correct. So the minimal N is 7.\n\nBut perhaps there's a better way. For example, can we take a component of size 4 (C(4,2)=6) and then subtract 1? But that's not allowed. So no. So the greedy approach seems to work here.\n\nThus, the plan is:\n\nTo find the minimal N, we can use the greedy approach of taking the largest possible k_i each time, such that C(k_i, 2) ≤ remaining p.\n\nOnce we have the list of k_i's, the minimal N is the sum of the k_i's.\n\nNow, the next part is to compute the maximum number of unidirectional pairs, which is (N^2 - sum k_i^2) // 2.\n\nSo the steps for solving the problem are:\n\nFor a given p:\n\n1. If p is 0, then the minimal N is 0 (but wait, the nodes must be at least 1? Or zero? Because for p=0, the graph must have exactly zero ordered pairs (u, v) where u < v and they are mutually reachable. So for example, a graph with 0 nodes? But the problem says \"nodes\" so probably the minimal number is 0? But looking at the sample input for p=0, the output is '0 0'.\n\nBut let's check the sample input given. The third input is 0, and the output is '0 0'. So for p=0, the minimal number of nodes is 0. However, for p=0, the graph can have any number of nodes, but with no mutual pairs. So the minimal number of nodes is 0 (if allowed). But perhaps the problem requires that the graph has at least one node. Wait, the problem says \"the number of nodes required to create a p-reachable directed graph.\" For p=0, the graph can have zero nodes? But that's impossible. Because the definition says \"ordered pairs of nodes (u, v)\" which implies that the graph must have at least two nodes for any pair. However, if the graph has zero nodes, then there are zero ordered pairs. So for p=0, the minimal number of nodes is 0. However, the sample input for p=0 outputs 0 0. Which matches.\n\nBut in practice, for p=0, the minimal N is 0. However, when p=0, the graph can be any graph with zero nodes. So the answer is 0 and 0.\n\nBut for p=0, the code needs to handle that.\n\nBut back to the algorithm.\n\nSo, for the first part, the code needs to find the minimal N by decomposing p into sum of (k_i choose 2) with minimal sum of k_i.\n\nSo the code can proceed as follows:\n\nInitialize the list of components as empty.\n\nWhile p > 0:\n\n   find the largest integer k such that k*(k-1)/2 ≤ p.\n\n   add k to the list of components.\n\n   subtract k*(k-1)/2 from p.\n\nOnce this loop ends, the sum of the components is N.\n\nBut wait, what if after this process, the sum is not exactly p? No, because each step subtracts exactly the value of the chosen k_i choose 2.\n\nBut for example, let's take p=3. The loop will take k=3 (3*2/2=3), subtract 3, p becomes 0. So the list is [3], sum is 3. Correct.\n\nAnother example: p=4. The largest k is 3 (3), subtract 3, p=1. Then largest k is 2 (1), subtract 1, p=0. So list is [3,2], sum is 5.\n\nAnother example: p=5. Largest is 3 (3), subtract 3 → 2. Then largest is 2 (1), subtract 1 → 1. Then largest is 2 (1), subtract 1 → 0. So list is [3,2,2], sum is 7.\n\nBut what if there is a better decomposition?\n\nFor example, p=5. What if we take k=4 (6) which is larger than 5. So no. So the next is k=3 (3). Then remaining is 2. What's the best way to decompose 2?\n\nThe largest k is 2 (1), subtract 1, remaining 1. Then another 2 (1), subtract 1. So total 3+2+2=7. Or, perhaps take 2 (1) and 2 (1) and 2 (1), but that would be 3*1=3. Not enough. So no. So the greedy approach seems correct.\n\nBut why is that the case? Because for each step, taking the largest possible k_i minimizes the sum of the k_i's. For example, suppose that you have a remainder r. The minimal sum to represent r as sum of (k_i choose 2) is achieved by taking the largest possible k each time. This is similar to the problem of making change with coins of denominations (k choose 2) for k ≥ 1, and trying to find the minimal number of coins. However, in that case, the greedy approach may not always work. But perhaps for this particular problem, it does.\n\nBut how can we be sure?\n\nLet's think of a case where the greedy approach might not work. Suppose p=6. Greedy approach would take k=4 (C(4,2)=6) → sum is 4. So N is 4. Which is better than taking 3+3 (sum 6, which gives C(3,2)*2 = 3*2=6. So sum of k_i is 3+3=6. Which is worse than 4. So greedy is better here.\n\nAnother example: p=7. Greedy approach would take 4 (6), then 2 (1). Sum is 4+2=6. Alternatively, 3 (3) + 3 (3) + 2 (1) → sum is 3+3+2=8. Worse. Or 3 (3) + 4 (6) → sum is 3+4=7. But 3+4=7 gives 3+6=9>7. So no. So the correct decomposition is 4 (6) and 2 (1) → sum 7. Which gives p=6+1=7. So N=6. But is there a better way? What about 3 (3) + 3 (3) + 2 (1) → sum 3+3+2=8. No. So the greedy approach is better.\n\nAnother example: p=5. Greedy gives 3+2+2=7. What if we have two components of size 3 and 2 (sum 3+2=5, mutual pairs 3+1=4, which is less than 5. No. So we need to add another component of size 2 (adding 1). So 3+2+2=7.\n\nSo it seems that the greedy approach works.\n\nThus, the algorithm for finding the minimal N is:\n\nInitialize N as 0.\n\nWhile p > 0:\n\n   find the maximum k where k*(k-1)/2 ≤ p.\n\n   add k to the list.\n\n   subtract k*(k-1)/2 from p.\n\n   add k to N.\n\nOnce done, the minimal N is the sum of the k's.\n\nOnce we have the list of k's, compute the maximum unidirectional pairs as (N^2 - sum (k_i^2 )) // 2.\n\nNow, the code can be written as follows.\n\nBut first, how to find the maximum k for a given p?\n\nWe can compute k as the floor of (sqrt(2p + 0.25) + 0.5). Because solving k(k-1)/2 ≤ p → k² -k - 2p ≤ 0. The positive root is [1 + sqrt(1 + 8p)] / 2. So the maximum k is floor( (sqrt(8p + 1) + 1)/2 )\n\nFor example, p=3: sqrt(25) is 5, (5+1)/2=3 → correct.\n\np=4: sqrt(33) is ~5.744, (5.744 +1)/2 ≈ 3.37 → floor is 3. Correct.\n\nSo the code can compute k for each step as the floor of (sqrt(8p + 1) + 1)/2.\n\nBut since p can be up to 2e5, we need to compute this efficiently.\n\nOnce we have the list of k's, then compute the sum of k_i^2.\n\nNow, for the case when p=0, the minimal N is 0. But for the code, when p is 0, the loop doesn't run. So the sum is zero. Then the maximum unidirectional pairs is (0^2 - 0)/2 = 0. Which matches the sample.\n\nAnother edge case: p=1. The minimal N is 2 (since C(2,2) =1). The sum of k_i^2 is 4. N is 2. So unidirectional pairs is (4 -4)/2 = 0. Which makes sense: if there is one component of size 2, then all pairs are mutual. So no unidirectional pairs.\n\nAnother example: p=2. The greedy approach takes k=2 (1) and then p=1. Then another k=2 (1) → sum of k's is 2+2=4. But wait, 1+1=2. But is there a better way? What about k=3 (3) is larger than 2. So no. So the minimal N is 2+2=4. But wait, what about a component of size 3 (C(3,2)=3) which is larger than 2. So no. So the correct decomposition is two components of size 2, sum 4. However, another possibility is a component of size 2 (1) and a component of size 1 (0) and another component of size 1 (0). Sum of mutual pairs is 1. Not enough. So no. So the minimal N is 4. Then the maximum unidirectional pairs is (4^2 - (2^2 + 2^2 )) /2 = (16 - 8)/2 = 8/2=4. So for N=4, the maximum unidirectional pairs is 4.\n\nBut what if we have a component of size 2 and another of size 2. The total nodes is 4. The unidirectional pairs is (4² - 2² - 2²)/2 = (16 - 8)/2 = 4. Which is correct.\n\nBut what if we have a component of size 3 and a component of size 1. Then sum of mutual pairs is 3 (from C(3,2)) + 0 = 3. Which is larger than 2. So that's not allowed. Hence, the decomposition must be two components of size 2.\n\nSo the code seems to handle this correctly.\n\nNow, the code steps:\n\nRead p.\n\nIf p is zero, output 0 0.\n\nElse:\n\nCompute the list of k's as per the greedy approach.\n\nSum them to get N.\n\nCompute sum_k_squares = sum (k^2 for k in list).\n\nunidirectional_pairs = (N*N - sum_k_squares) // 2.\n\nOutput N and unidirectional_pairs.\n\nBut how to compute the list of k's?\n\nImplementing the loop:\n\nInitialize p_remaining = p.\n\nlist_ks = []\n\nwhile p_remaining > 0:\n\n   compute k = floor( (sqrt(8*p_remaining + 1) + 1)/2 )\n\n   list_ks.append(k)\n\n   p_remaining -= k*(k-1)//2\n\nBut wait, what if the computed k is such that k*(k-1)/2 is larger than p_remaining? Because of the floor operation?\n\nNo, because the formula for k is the maximum integer such that k*(k-1)/2 ≤ p_remaining.\n\nLet me think. Let me compute for p_remaining.\n\nLet x = 8*p_remaining + 1.\n\nsqrt_x = sqrt(x)\n\nk_candidate = floor( (sqrt_x + 1)/2 )\n\nBut we need to check whether k_candidate*(k_candidate -1)/2 <= p_remaining.\n\nBut since x = 8p +1, then (sqrt(x) is the exact value. Let me see:\n\nFor example, for p_remaining=3, x=25, sqrt_x=5. (5+1)/2=3 → correct.\n\nFor p_remaining=4, x= 33 → sqrt(33) is approx 5.744. (5.744 +1)/2 is approx 3.37 → floor is 3. Which gives 3*2/2=3 ≤4. Correct.\n\nBut what if the actual maximum k is higher than this? No, because the formula gives the maximum k.\n\nBut perhaps due to floating point inaccuracies, we need to adjust.\n\nAlternatively, we can compute k via binary search.\n\nBut for code purposes, perhaps using math.isqrt (in Python 3.8+) to compute the square root accurately.\n\nLet me think of the code.\n\nIn Python, for a given p_remaining, compute:\n\nk = (1 + int( ( (8*p_remaining + 1)**0.5 )) ) // 2\n\nWait, perhaps not. Let's think.\n\nLet me compute the maximum k such that k*(k-1)/2 ≤ p_remaining.\n\nLet me denote this as k_max.\n\nWe can compute k_max as the floor of (sqrt(8*p_remaining + 1) + 1)/2.\n\nBut perhaps the exact calculation can be done with integer operations.\n\nBut for code, perhaps using math.sqrt and then flooring.\n\nBut for large p_remaining, this may have precision issues. So perhaps using binary search for k_max is safer.\n\nBut for the purposes of this problem, perhaps the initial approach is sufficient.\n\nLet me try to code it.\n\nFor example, in Python:\n\nimport math\n\ndef get_k(p_remaining):\n\n    # compute maximum",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding Mutual Reachability**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This can be achieved by decomposing `p` into sums of combinations of node sizes (k choose 2) for different components.\n2. **Greedy Decomposition**: To minimize the number of nodes, we use a greedy approach to decompose `p` into the largest possible components. For each step, we find the largest integer `k` such that `k*(k-1)/2` is less than or equal to the remaining value of `p`.\n3. **Calculate Minimum Nodes**: Sum the sizes of these components to get the minimum number of nodes required.\n4. **Maximize Unidirectional Pairs**: Once the minimum number of nodes is determined, compute the maximum number of unidirectional pairs using the formula derived from the sum of squares of component sizes and the total number of nodes.\n\n### Solution Code\n```python\nimport math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    list_ks = []\n    p_remaining = p\n    while p_remaining > 0:\n        # Compute k such that k*(k-1)/2 <= p_remaining\n        sqrt_val = math.sqrt(8 * p_remaining + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Check if k is too big\n        while k * (k - 1) // 2 > p_remaining:\n            k -= 1\n        list_ks.append(k)\n        p_remaining -= k * (k - 1) // 2\n    \n    N = sum(list_ks)\n    sum_k_squares = sum(k*k for k in list_ks)\n    unidirectional = (N * N - sum_k_squares) // 2\n    print(f\"{N} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input value `p` is read from standard input.\n2. **Handling Zero Case**: If `p` is zero, the output is immediately set to \"0 0\".\n3. **Greedy Decomposition**: For each iteration, the largest possible component size `k` is determined such that the number of mutual pairs from this component does not exceed the remaining value of `p`. This is done using mathematical calculations and adjusted if necessary.\n4. **Summing Component Sizes**: The total number of nodes `N` is the sum of all component sizes found.\n5. **Unidirectional Pairs Calculation**: Using the formula derived from the sum of squares of component sizes and the total number of nodes, the maximum number of unidirectional pairs is calculated and printed alongside the minimum number of nodes.\n\nThis approach ensures that we efficiently determine the minimal node count and maximize unidirectional pairs using mathematical decomposition and greedy strategies.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    list_ks = []\n    p_remaining = p\n    while p_remaining > 0:\n        # Compute k such that k*(k-1)/2 <= p_remaining\n        sqrt_val = math.sqrt(8 * p_remaining + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Check if k is too big\n        while k * (k - 1) // 2 > p_remaining:\n            k -= 1\n        list_ks.append(k)\n        p_remaining -= k * (k - 1) // 2\n    \n    N = sum(list_ks)\n    sum_k_squares = sum(k*k for k in list_ks)\n    unidirectional = (N * N - sum_k_squares) // 2\n    print(f\"{N} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 676,
        "thoughts_token_count": 8192
    }
}