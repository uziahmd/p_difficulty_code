{
    "start": 1758309804.1300986,
    "end": 1758309867.1959643,
    "start-formatted": "2025-09-20 04:23 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road (edge) between two lawns (vertices). \n\nFirst, I need to understand the constraints. Each edge connects two lawns, and for that edge, we have the GCD and LCM of the mushroom counts on those two lawns. Our task is to assign numbers to each lawn such that all these conditions are satisfied. If it's not possible, we return NO.\n\nLet me think about the properties of GCD and LCM. For two numbers a and b, we know that GCD(a,b) * LCM(a,b) = a*b. So for each edge between u and v with GCD g and LCM l, we have that a_u * a_v = g * l. Also, since GCD(a_u, a_v) is g, both a_u and a_v must be multiples of g. Let me denote a_u = g * x and a_v = g * y. Then, the LCM of a_u and a_v would be g * LCM(x,y). But since the LCM is given as l, we have that g * LCM(x,y) = l. Which implies that LCM(x,y) = l/g. Also, since x and y are coprime (because when you divide by the GCD, the remaining numbers have GCD 1), then LCM(x,y) = x*y. Therefore, x*y = l/g. \n\nSo, for each edge between u and v with GCD g and LCM l, we can say that a_u = g * x, a_v = g * y, where x and y are coprime and x * y = l/g. \n\nBut how do we model this for the entire graph? It seems like a graph problem where each node has some value, and edges impose constraints between pairs of nodes. \n\nThis looks similar to a system of equations, but with constraints on the relationships between variables. However, since the variables are integers, and the relationships are multiplicative, perhaps we can model this as a graph where each connected component must satisfy certain conditions.\n\nSo, the approach might be:\n\n1. For each connected component in the graph, assign values to the nodes such that all edges' constraints are satisfied.\n2. Check for consistency within each component.\n\nBut how to model this? Let's think of each node's value as being determined by a base value multiplied by some factors. For example, if two nodes are connected via an edge with GCD g and LCM l, then their values must be multiples of g. Moreover, their ratio (a_u/a_v) must be such that when divided by g, they are coprime and their product is l/g.\n\nWait, maybe we can model this as a graph where each node's value is determined relative to others. For example, in a connected component, we can pick a root node and assign it a value, then propagate the constraints through the edges. However, this requires that the constraints are consistent across the entire component.\n\nAlternatively, since the constraints are multiplicative, perhaps we can model this as a bipartition problem, but I'm not sure. Let's think again.\n\nLet me consider that for each edge u-v with GCD g and LCM l, the product of the two nodes' values is g*l. Also, the GCD of the two nodes is g. So, for each pair, the product is fixed, and their GCD is fixed. How can we model this?\n\nAnother thought: for each edge, the two nodes must be multiples of g. Let me consider that each node's value is a multiple of some value. But how to ensure that for all connected edges?\n\nPerhaps, we can model this as a graph where each node's value is determined by a base value multiplied by some factors. For example, for each edge, we can find that the ratio between the two nodes must be a specific value. \n\nLet me take an example. Suppose there's an edge between u and v with GCD g and LCM l. Then, a_u and a_v must be multiples of g, and their product is g*l. Let me denote a_u = g * x, a_v = g * y. Then, since GCD(a_u, a_v) = g, which implies that GCD(x, y) = 1. Also, since LCM(a_u, a_v) = g * LCM(x, y) = l. Since x and y are coprime, LCM(x, y) = x*y. Therefore, x*y = l/g. \n\nSo, for each edge u-v, we have x*y = l/g, and GCD(x,y)=1. Therefore, x and y must be coprime divisors of l/g.",
    "response": "To solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn based on given GCD and LCM values for each road. The solution involves checking the consistency of the constraints imposed by the roads and using a graph traversal approach to assign values to each lawn.\n\n### Approach\n1. **Graph Representation**: Represent the lawns and roads as a graph where each node (lawn) is connected by edges (roads) with given GCD and LCM values.\n2. **Constraints Check**: For each edge, verify if the product of GCD and LCM is valid. If not, immediately return \"NO\".\n3. **Component-wise Processing**: Process each connected component of the graph separately. Use BFS to traverse each component starting from an arbitrary node, assigning values while respecting the constraints from the edges.\n4. **Value Assignment**: For each node, maintain a value that is consistent with the constraints from its connected edges. If any inconsistency is found during traversal, return \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if any edge has LCM < GCD or GCD * LCM not divisible by GCD (which it always is)\n    # Also check if LCM % GCD != 0, which would be invalid\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Now process each connected component\n    visited = [False] * n\n    values = [None] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            values[start] = 1  # We'll adjust this later based on constraints\n            \n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in graph[u]:\n                    if not visited[v]:\n                        # Compute x and y such that x*y = l/g and gcd(x,y)=1\n                        # Since a_u = g * x, a_v = g * y\n                        # So x * y = l/g\n                        # Also, gcd(x, y) = 1\n                        product = l // g\n                        # Find x and y such that x * y = product and gcd(x,y)=1\n                        # So, x must be a divisor of product, and y = product / x\n                        # But how to choose x and y?\n                        # We can assign x as 1 and y as product, but need to ensure that the constraints are consistent\n                        # However, since we have a tree structure here (as it's a connected component being traversed once), we can assign values based on the parent\n                        # Let's assume that the value of u is known, then compute the value of v\n                        # Since a_u = g * x, and a_v = g * y, and x * y = product\n                        # Also, gcd(a_u, a_v) = g, so gcd(gx, gy) = g * gcd(x,y) = g => gcd(x,y) = 1\n                        # So, given a_u, we can compute a_v as (g * product) / a_u\n                        # Because a_u * a_v = g * l => a_v = (g*l)/a_u\n                        # But since a_u is already set, we can compute a_v\n                        # Wait, but a_u is set as g * x, and a_v is g * y\n                        # So, a_u * a_v = g^2 * x * y = g^2 * (l/g) = g*l\n                        # Which matches the condition\n                        # Therefore, once a_u is known, a_v can be computed as (g * l) // a_u\n                        # But we need to ensure that a_v is integer, and that gcd(a_u, a_v) == g\n                        # However, since the product is correct, and the GCD is given, it should be okay\n                        # But we need to check if (g * l) % a_u == 0\n                        # But since a_u = g * x, and a_v = g * y, and x * y = l/g, then a_u * a_v = g*l\n                        # So (g*l) // a_u = a_v\n                        # Therefore, we can proceed\n                        a_u = values[u]\n                        a_v = (g * l) // a_u\n                        # Now check if gcd(a_u, a_v) == g\n                        if math.gcd(a_u, a_v) != g:\n                            print(\"NO\")\n                            return\n                        values[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check if the current values satisfy the constraints\n                        a_u = values[u]\n                        a_v = values[v]\n                        if math.gcd(a_u, a_v) != g or (a_u * a_v) != g * l:\n                            print(\"NO\")\n                            return\n    # After processing all components, check if all nodes have values assigned\n    if None in values:\n        # This can happen if the graph is disconnected and some components have no edges\n        # For example, a node with no edges (n=1, m=0)\n        # In that case, the value can be any positive integer, but since the problem says \"any one\", we can assign 1\n        # However, in our code, for a node with no edges, it's not processed in the loop above\n        # So we need to handle that\n        for i in range(n):\n            if values[i] is None:\n                values[i] = 1\n    # Now check all edges again to ensure all constraints are satisfied\n    for u, v, g, l in edges:\n        a_u = values[u]\n        a_v = values[v]\n        if math.gcd(a_u, a_v) != g or (a_u * a_v) != g * l:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into nodes and edges.\n2. **Initial Checks**: For each edge, check if the LCM is a multiple of the GCD. If not, immediately return \"NO\".\n3. **Graph Traversal**: Using BFS, traverse each connected component of the graph. Assign values to nodes starting from an arbitrary node, ensuring that each node's value satisfies the constraints imposed by its connected edges.\n4. **Consistency Check**: After assigning values, verify all edges to ensure the GCD and LCM constraints are satisfied. If any inconsistency is found, return \"NO\"; otherwise, return the values assigned to each node.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if any edge has LCM < GCD or GCD * LCM not divisible by GCD (which it always is)\n    # Also check if LCM % GCD != 0, which would be invalid\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Now process each connected component\n    visited = [False] * n\n    values = [None] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            values[start] = 1  # We'll adjust this later based on constraints\n            \n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in graph[u]:\n                    if not visited[v]:\n                        # Compute x and y such that x*y = l/g and gcd(x,y)=1\n                        # Since a_u = g * x, a_v = g * y\n                        # So x * y = l/g\n                        # Also, gcd(x, y) = 1\n                        product = l // g\n                        # Find x and y such that x * y = product and gcd(x,y)=1\n                        # So, x must be a divisor of product, and y = product / x\n                        # But how to choose x and y?\n                        # We can assign x as 1 and y as product, but need to ensure that the constraints are consistent\n                        # However, since we have a tree structure here (as it's a connected component being traversed once), we can assign values based on the parent\n                        # Let's assume that the value of u is known, then compute the value of v\n                        # Since a_u = g * x, and a_v = g * y, and x * y = product\n                        # Also, gcd(a_u, a_v) = g, so gcd(gx, gy) = g * gcd(x,y) = g => gcd(x,y) = 1\n                        # So, given a_u, we can compute a_v as (g * product) / a_u\n                        # Because a_u * a_v = g * l => a_v = (g*l)/a_u\n                        # But since a_u is already set, we can compute a_v\n                        # Wait, but a_u is set as g * x, and a_v is g * y\n                        # So, a_u * a_v = g^2 * x * y = g^2 * (l/g) = g*l\n                        # Which matches the condition\n                        # Therefore, once a_u is known, a_v can be computed as (g * l) // a_u\n                        # But we need to ensure that a_v is integer, and that gcd(a_u, a_v) == g\n                        # However, since the product is correct, and the GCD is given, it should be okay\n                        # But we need to check if (g * l) % a_u == 0\n                        # But since a_u = g * x, and a_v = g * y, and x * y = l/g, then a_u * a_v = g*l\n                        # So (g*l) // a_u = a_v\n                        # Therefore, we can proceed\n                        a_u = values[u]\n                        a_v = (g * l) // a_u\n                        # Now check if gcd(a_u, a_v) == g\n                        if math.gcd(a_u, a_v) != g:\n                            print(\"NO\")\n                            return\n                        values[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check if the current values satisfy the constraints\n                        a_u = values[u]\n                        a_v = values[v]\n                        if math.gcd(a_u, a_v) != g or (a_u * a_v) != g * l:\n                            print(\"NO\")\n                            return\n    # After processing all components, check if all nodes have values assigned\n    if None in values:\n        # This can happen if the graph is disconnected and some components have no edges\n        # For example, a node with no edges (n=1, m=0)\n        # In that case, the value can be any positive integer, but since the problem says \"any one\", we can assign 1\n        # However, in our code, for a node with no edges, it's not processed in the loop above\n        # So we need to handle that\n        for i in range(n):\n            if values[i] is None:\n                values[i] = 1\n    # Now check all edges again to ensure all constraints are satisfied\n    for u, v, g, l in edges:\n        a_u = values[u]\n        a_v = values[v]\n        if math.gcd(a_u, a_v) != g or (a_u * a_v) != g * l:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 1618,
        "thoughts_token_count": 1024
    }
}