{
    "start": 1758314292.1592634,
    "end": 1758314460.3573692,
    "start-formatted": "2025-09-20 05:38 KST",
    "end-formatted": "2025-09-20 05:41 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. The task is to find the minimum number of nodes required for a p-reachable directed graph and then determine the maximum number of unidirectional pairs in such graphs. \n\nFirst, let me understand what a p-reachable graph is. The definition says that it has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So for each such pair, both directions must have paths. Wait, no, the problem says \"reachable from each other\", meaning that there's a path from u to v and from v to u. So these pairs are mutual.\n\nThe first part of the problem is to find the minimal number of nodes needed so that there are exactly p such pairs. Then, among all those graphs with that minimal number of nodes, find the maximum number of unidirectional pairs.\n\nLet's think about the minimal number of nodes. For example, when p is 0, we need a graph where no two nodes are mutually reachable. How can that be achieved? Well, if the graph is a DAG with no cycles, but even that might not be enough. Wait, but for any two nodes u and v, if there's no path between them in either direction, then they aren't mutually reachable. But how to arrange that?\n\nAlternatively, maybe the minimal number of nodes depends on the maximum number of mutual pairs possible with a given number of nodes. Let's think about the maximum possible p for a given n. Because once we know that, we can find the minimal n such that the maximum p for that n is at least the target p.\n\nWait, but the problem requires exactly p mutual pairs. So perhaps the minimal n is determined by finding the smallest n where the maximum number of mutual pairs possible (for that n) is ≥ p. But how?\n\nWait, but how do we model the mutual pairs? For example, if we have a graph where all nodes are in a single strongly connected component (SCC), then every pair of nodes (u, v) where u < v will be mutual. So the number of such pairs is C(n, 2) = n*(n-1)/2. However, if we have multiple SCCs arranged in a way that there's no path between different components, then mutual pairs are only within each component.\n\nSo, to maximize the number of mutual pairs, you would want as many nodes as possible in a single SCC. However, if you have multiple SCCs, say, one large component and others, the mutual pairs are only within each component.\n\nBut for our problem, we need exactly p mutual pairs. So the minimal number of nodes would be determined by finding the smallest n where the maximum number of mutual pairs possible (which is C(n, 2)) is ≥ p. Wait, but maybe there's a better way. Let me think again.\n\nWait, suppose that the minimal number of nodes is determined by the following approach: arrange the graph into some structure that allows us to have exactly p mutual pairs. For example, if we have a single strongly connected component (SCC) of size k, then the number of mutual pairs is C(k, 2). If we have another component, say of size m, then the mutual pairs are C(k, 2) + C(m, 2), etc. So to get exactly p mutual pairs, perhaps we can find the minimal n by considering the sum of combinations of sizes of various components. But how to minimize the total number of nodes?\n\nAlternatively, the minimal number of nodes is determined by the minimal n such that the maximum possible number of mutual pairs for n nodes is ≥ p. Because if we can have a graph with n nodes that has exactly p mutual pairs, then that's the minimal. But how?\n\nWait, for example, if p is 3, then the maximum mutual pairs possible with n=3 is C(3,2) = 3. So that's exactly p. Hence, the minimal number of nodes is 3. Which matches the first sample input.\n\nIn the sample input where p=3, the output is 3 0. So the first part is correct. For the second part, the maximum number of unidirectional pairs is 0. How?\n\nUnidirectional pairs are ordered pairs (u, v) where u != v, there's a path from u to v, but no path from v to u. So in a graph where all nodes are in a single SCC, every pair of nodes is mutually reachable. Hence, there are zero unidirectional pairs. Hence, the sample makes sense.\n\nSo, the key seems to be that for the minimal number of nodes, the optimal way to reach exactly p mutual pairs is to have a structure that allows exactly p mutual pairs. But how?\n\nLet me think: To minimize the number of nodes, we need to maximize the number of mutual pairs per node. The maximum possible mutual pairs for a given number of nodes is when all nodes are in a single SCC. So if p is less than or equal to C(n, 2), then perhaps the minimal n is the smallest n where C(n, 2) ≥ p. But wait, maybe not. Because maybe you can have a combination of components. For example, if p is 4, then C(3, 2) is 3, which is less than 4. The next possible is n=4, which gives C(4,2)=6. So the minimal n would be 4. But wait, can we have a configuration with 3 nodes and another component? For example, suppose we have two components: one of size 3 (with all mutual pairs, giving 3 pairs) and another of size 1 (no pairs). Then the total is 3. But that's less than 4. Alternatively, maybe two components: one of size 2 (1 pair) and another of size 2 (another 1 pair), total 2. Still less than 4. So in that case, the minimal n is 4.\n\nBut what if p is 4? Then the minimal n is 4, because C(4,2)=6 ≥4. But how do we get exactly 4 mutual pairs? Well, perhaps by having a single component of 4 nodes, but then removing some edges to reduce the number of mutual pairs. But that seems complicated. However, the problem says that the graph must have exactly p mutual pairs. But how can we achieve that?\n\nWait, but perhaps the minimal n is determined by the minimal n such that the maximum possible number of mutual pairs for n nodes is ≥p. Because even if we can't reach exactly p, but perhaps we can arrange the graph to have exactly p mutual pairs. For example, if the maximum is C(n, 2) ≥p, then maybe we can have a graph with exactly p mutual pairs by splitting into components. For example, take a component of size k where C(k, 2) = p, and the rest as singletons. But how to split?\n\nAlternatively, perhaps the minimal n is the smallest integer such that the sum of the first m numbers (like triangular numbers) is ≥p. Wait, no. For example, if p is 3, then n is 3. If p is 4, then the minimal n is 4, because C(3,2)=3 <4, and C(4,2)=6≥4. But how to get exactly 4 mutual pairs with n=4? Well, perhaps by having a component of 3 nodes (which gives 3 mutual pairs) and another component of 1 node. Then the total is 3, which is less than 4. Alternatively, have a component of size 4 with some structure that allows exactly 4 mutual pairs. But how?\n\nWait, maybe I'm misunderstanding the problem. The problem says that the graph must have exactly p mutual pairs. However, the way to achieve that may not be through a single component. For example, if you have two components: one of size k and another of size m, then the total mutual pairs is C(k,2) + C(m,2). So if we can find integers k and m such that their combination equals p, and the sum of their sizes is less than the minimal n for a single component. But how?\n\nBut the minimal n is the minimal number of nodes required to create a p-reachable graph. So for example, if p is 4, can we find a configuration with n=4 nodes that has exactly 4 mutual pairs?\n\nYes. Suppose we have a component with 3 nodes (C(3,2)=3 mutual pairs) and another node that is in a separate component. Then the total is 3. But that's not enough. Alternatively, perhaps we have a component of size 4 with some structure where the number of mutual pairs is 4. But how? Because in a strongly connected component of 4 nodes, all pairs are mutual. So that would give 6 mutual pairs. But how to reduce that to 4?\n\nAh, but perhaps the problem allows for some nodes to be in a strongly connected component, and others not. For example, if we have two components: one of size 3 (with 3 mutual pairs) and another component of size 2 (with 1 mutual pair). Total is 4. The total number of nodes is 3+2=5. But that's more than 4. So the minimal n would be 4? But how?\n\nAlternatively, perhaps the minimal n is determined by the minimal n where the maximum possible mutual pairs is ≥p, and then arrange the graph to have exactly p mutual pairs. But how?\n\nWait, perhaps the problem is that for the minimal n, the maximum number of mutual pairs possible with that n is at least p, and then we can construct a graph with exactly p mutual pairs by using some combination of components. For example, for p=4, the minimal n is 4. The maximum mutual pairs possible with 4 nodes is 6. So to get exactly 4, we could have a component of 3 nodes (3 mutual pairs) and a component of 1 node (0), but that gives 3. Not enough. Or, maybe a component of 4 nodes where some pairs are not mutually reachable. But how?\n\nWait, but if the graph is not strongly connected, then the mutual pairs are only within each component. So if we have a component of size 4, but it's not strongly connected, then the mutual pairs would be less than 6. For example, if the component is a DAG with a topological order, then there are no mutual pairs. But that's not helpful. Alternatively, perhaps split the component into two parts where each part is strongly connected. Like, two strongly connected components of size 2 each. Then the mutual pairs would be 1 + 1 = 2. Still not enough. \n\nHmm. This suggests that maybe the minimal n is not determined by the maximum possible mutual pairs for a given n. Maybe I need to think differently.\n\nWait, perhaps the minimal number of nodes is determined by the following approach: the maximum number of mutual pairs for a given n is C(n, 2). Therefore, to have exactly p mutual pairs, the minimal n is the smallest integer such that C(n, 2) >= p. Because then, you can have a graph with exactly p mutual pairs by taking a complete strongly connected component of size k where C(k, 2) = p. But if p is not a triangular number, then perhaps you need to use multiple components. For example, if p is 4, then the minimal n is 4 (since C(3,2)=3 <4 and C(4,2)=6 ≥4). Then, how to arrange the graph with exactly 4 mutual pairs?\n\nWell, you can have two components: one of size 3 (3 mutual pairs) and one of size 2 (which contributes C(2,2) =1 mutual pair). Total is 4. So the total nodes is 3+2=5. But that's larger than 4. So why is the minimal n 4?\n\nThis seems conflicting. What's wrong here?\n\nWait, maybe the minimal n is not determined by the maximum possible mutual pairs. Because in this case, the maximum possible mutual pairs with n=4 is 6. So if we need exactly 4, perhaps we can have a graph with 4 nodes where exactly 4 pairs are mutual. How?\n\nFor example, consider a graph with 4 nodes arranged in a way that there are 4 mutual pairs. Let's imagine that the graph has a cycle between three nodes (A, B, C) and a fourth node D that has edges to A and B, but not vice versa. But then, the mutual pairs are among A, B, C (assuming they form a strongly connected component). That would be C(3, 2) =3 mutual pairs. D is not part of any mutual pairs. So total is 3, which is less than 4. \n\nAlternatively, maybe have two strongly connected components. One of size 2 (mutual pairs 1) and another of size 3 (mutual pairs 3). Total 4. The total nodes is 2+3=5. But that's more than 4. \n\nAlternatively, what if the graph is not strongly connected but has some mutual pairs. For example, suppose there are two components: one of size 3 (strongly connected, 3 mutual pairs) and another of size 1. That gives 3 mutual pairs. Not enough. \n\nWait, but how can we have exactly 4 mutual pairs with 4 nodes? Maybe if there's a component of size 4 that isn't fully strongly connected. For example, imagine a component where nodes A, B, C are strongly connected (so they contribute 3 mutual pairs), and node D can reach A but not vice versa. Then, D is not part of any mutual pairs. So total is 3. \n\nAlternatively, if there are two separate strongly connected components of size 2. Each contributes 1 mutual pair. Total is 2. No. \n\nAlternatively, maybe a component of size 3 (3 mutual pairs) and another component of size 1. Total 3. \n\nHmm. So how can we get 4 mutual pairs with 4 nodes?\n\nMaybe there's a way to have a graph with some overlapping components. For example, if the graph has a strongly connected component of size 3 (A, B, C) and node D is connected to A and B in such a way that D is also in a strongly connected component with one of them. Wait, but if D is in a strongly connected component with A, then that would imply that D can reach A and vice versa. So if D is part of a component with A, then the component includes D and A. But then, the mutual pairs would be C(2, 2) =1 between D and A, plus the existing 3 mutual pairs between A, B, C. But then, since A is in both components, the entire component would be A, B, C, D. So the mutual pairs would be C(4, 2) =6. Which is more than 4. \n\nSo this seems impossible. Which suggests that the minimal n for p=4 is 5, not 4. But according to the earlier logic, the minimal n should be the smallest n where C(n,2) ≥ p. For p=4, C(3,2)=3 <4, C(4,2)=6 ≥4. So according to that logic, the minimal n is 4. But how?\n\nThis seems like a contradiction. So perhaps my initial assumption is wrong. What's the correct way to approach this?\n\nLet me think again. The problem says that the graph must have exactly p mutual pairs. The minimal number of nodes required. So for p=4, what's the minimal n?\n\nIf there's a way to have exactly 4 mutual pairs with 4 nodes, then n=4 is possible. Otherwise, it's higher.\n\nAnother approach: think of the mutual pairs as the number of unordered pairs {u, v} where u and v are in the same strongly connected component. Because for any two nodes in the same SCC, they are mutually reachable. So the total number of mutual pairs is the sum over all SCCs of C(size of SCC, 2).\n\nThus, the problem reduces to finding the minimal number of nodes such that there exists a partition of the nodes into some number of SCCs, where the sum of C(k_i, 2) over all components equals p. And we need to find the minimal possible total nodes.\n\nSo the problem becomes: find the minimal n such that there exists integers k_1, k_2, ..., k_m where sum_{i} C(k_i, 2) = p, and sum_{i} k_i = n. And we want to minimize n.\n\nSo now the question is, for a given p, find the minimal n possible.\n\nSo for example, when p=4, what is the minimal n?\n\nWe need to find integers k_i such that sum C(k_i, 2) =4. Let's see:\n\nOption 1: one component of size 4: C(4, 2)=6>4. Not good.\n\nOption 2: one component of size 3 (C(3,2)=3) and another of size 2 (C(2,2)=1): sum is 3+1=4. Total nodes is 3+2=5.\n\nOption 3: two components of size 2 and 2: sum is 1+1=2 <4.\n\nOption 4: four components of size 2: sum is 4*1=4. Total nodes is 4*2=8. Which is worse than option 2.\n\nOption 5: one component of size 3 (3) and one of size 1 (0): sum is 3. Not enough.\n\nSo the minimal n for p=4 is 5.\n\nBut according to the previous idea of finding the minimal n where C(n,2) ≥p, that would have been 4. But that's not possible. Hence, that approach was wrong.\n\nSo the correct approach is to find the minimal n such that there exists a set of integers k_i with sum C(k_i, 2) =p, and sum k_i =n. So the problem reduces to finding the minimal sum of k_i's where the sum of C(k_i, 2) is exactly p.\n\nNow, how to find this minimal n for given p.\n\nThis seems like a classic optimization problem. For a given p, find the minimal sum of k_i's such that sum C(k_i, 2) =p.\n\nTo minimize the sum of k_i's, given that sum C(k_i, 2) =p.\n\nBecause C(k,2) is convex, the minimal sum is achieved by making the k_i's as large as possible. Wait, no. Wait, for a fixed value of sum C(k_i, 2), the minimal sum of k_i's is achieved by grouping as much as possible into larger components. Because for example, if you have two components of size 2 (sum C(2,2)=1+1=2) and sum of sizes is 4. Whereas a component of size 3 (C(3,2)=3) would require sum of sizes 3, which is better for higher p. But if we need sum C(k_i, 2) =2, then the minimal sum of sizes is 3 (component of size 3, which gives 3, which is too big. So no, that's not helpful. So perhaps the minimal sum is achieved by using as many large components as possible.\n\nAlternatively, think of it as the problem of representing p as the sum of C(k_i, 2), and find the minimal sum of k_i's. For example, for p=4, the best decomposition is 3+1 (sum C(3,2)+C(1,2) =3+0=3) which is not enough. Wait, but earlier example said that for p=4, the decomposition is 3 and 2, which sum to 3+2=5. Which gives 3+1=4. So that's the way.\n\nSo the problem becomes similar to the problem of expressing p as the sum of triangular numbers, but with the goal of minimizing the sum of the bases.\n\nBut how to compute this efficiently for large p (up to 2e5)?\n\nAn approach could be to find the largest possible C(k, 2) that is ≤p, subtract it from p, and repeat. But this greedy approach may not work. For example, suppose p=4. The largest C(k, 2) ≤4 is C(3,2)=3. Then p becomes 1. The largest C(k,2) ≤1 is 1 (k=2). So total sum is 3+2=5. Which is correct.\n\nAnother example: p=5. Largest is 3 (k=3), then remaining is 2. Largest is 1 (k=2), then remaining 1. So total sum is 3+2+2=7. But perhaps there's a better decomposition. For example, 2+2+2: sum C(2,2)*3 =3. Not enough. Or 3+2: sum 3+1=4. Not enough. Or 3+2+ something. Hmm. Maybe 3 (C(3,2)=3) and then 2 (C(2,2)=1) and 2 (another 1) gives 3+1+1=5. Sum of sizes is 3+2+2=7. Alternatively, 4 (C(4,2)=6) is larger than 5. So no. So the minimal sum is 7.\n\nBut maybe another decomposition. For example, 2+3: sum 3+1=4. Not enough. Or 4 (but C(4,2) is 6, which is larger than 5. So no. So perhaps the minimal sum is indeed 7.\n\nSo the greedy approach of taking the largest possible C(k, 2) each time seems to work. Let's test for p=6. The largest is 6 (k=4), sum is 4. So that's better than 3+3 (sum 3+3=6, which gives 3+3=6). So 4 is better. So yes, the greedy approach works.\n\nSo the algorithm for finding the minimal n is:\n\nInitialize n = 0, remaining p.\n\nWhile p > 0:\n\n   Find the largest k such that C(k, 2) ≤ p.\n\n   Subtract C(k, 2) from p.\n\n   Add k to n.\n\nSo for example, p=4: 3 (C(3,2)=3), then 1 (C(2,2)=1). So n=3+2=5.\n\nThis seems to work. But how to compute this for large p?\n\nNow, the question is, for a given p, how to find the largest k such that k*(k-1)/2 ≤ p.\n\nThis can be found via binary search. For example, solving k^2 -k - 2p ≤0. The positive root is [1 + sqrt(1 + 8p)] / 2. So the maximum k is floor( (sqrt(8p +1) +1)/2 )\n\nOnce we find that, we can proceed with the greedy approach.\n\nSo this would give us the minimal number of nodes required for the first part of the problem.\n\nOnce we have the minimal number of nodes, the next part is to find the maximum number of unidirectional pairs among all such graphs.\n\nSo the first step is to compute the minimal number of nodes. Now, for the second part.\n\nNow, for the maximum number of unidirectional pairs, given that the graph has exactly p mutual pairs and uses the minimal number of nodes.\n\nUnidirectional pairs are ordered pairs (u, v) with u !=v, there's a path from u to v but not from v to u.\n\nIn order to maximize the number of unidirectional pairs, we need to arrange the graph in a way that maximizes the number of such pairs.\n\nBut how?\n\nLet's think about the structure of the graph. The graph is divided into several strongly connected components (SCCs). For each pair of SCCs, say A and B, if there's a directed edge from A to B, but not vice versa, then all ordered pairs (a, b) where a is in A and b is in B contribute to unidirectional pairs. Because a can reach b (since there's a path from A to B), but b cannot reach a (since there's no path from B to A). However, if there are multiple paths between components, but the direction is maintained, it's still the same.\n\nBut to maximize the number of unidirectional pairs, we need to arrange the SCCs in a way that maximizes the number of such cross-component pairs.\n\nSo the maximum number of unidirectional pairs is achieved when the components are arranged in a DAG, and for each pair of components A and B, there is a directed edge from A to B if and only if A comes before B in the DAG ordering. In that case, for every pair of components A and B, if A is before B, then all ordered pairs (a, b) where a is in A and b is in B are unidirectional (assuming that there are no paths from B to A).\n\nBut how to model this?\n\nThe maximum number of unidirectional pairs would be the sum over all ordered pairs of components (A, B) where A is before B in the DAG ordering, multiplied by the product of the sizes of A and B. Because for each such pair (a in A, b in B), there's a path from a to b (since A is before B) but no path from b to a. So each such pair contributes one unidirectional pair.\n\nBut how to maximize this sum? The maximum is achieved when the components are arranged in a linear order, i.e., a chain. For example, if the components are ordered in a sequence C1, C2, ..., Cm, where there's a directed edge from Ci to Cj for all i < j. Then the total number of unidirectional pairs is sum_{i < j} |Ci| * |Cj|.\n\nAdditionally, within each component, there are no unidirectional pairs (since they are in an SCC, so for any two nodes in the same component, they are mutually reachable). So the unidirectional pairs are entirely between components.\n\nSo, the problem reduces to, given the sizes of the components (from the minimal node count calculation), arrange them in a linear order to maximize the sum of |Ci| * |Cj| for all i < j.\n\nBut how to compute this sum?\n\nLet me think. Suppose we have components of sizes s_1, s_2, ..., s_k. Then the sum for all i < j of s_i * s_j is equal to [(sum s_i)^2 - sum s_i^2 ] / 2. Because sum_{i≠j} s_i s_j = (sum s_i)^2 - sum s_i^2. And since we want i<j, it's half of that.\n\nBut in our case, the sum of s_i is the total number of nodes, which is n. So the sum is (n^2 - sum s_i^2)/2.\n\nBut since the arrangement of components in a DAG doesn't affect this sum (as long as they are arranged in a linear order), the maximum number of unidirectional pairs is (n^2 - sum s_i^2)/2.\n\nWait, but how does that depend on the arrangement of components? It doesn't. Because regardless of how you arrange the components into a DAG, the sum of |Ci| * |Cj| for all pairs where there's a path from Ci to Cj and not vice versa would be equal to the sum over all ordered pairs of components (i,j) where i and j are in the DAG such that there's a path from Ci to Cj. However, if the DAG is a linear chain, then all pairs (i,j) with i < j are included, and the sum is as above. If the DAG is more complex, like having multiple branches, then some pairs may not be counted. Hence, to maximize the sum, the components must be arranged in a linear order, which gives the maximum possible sum.\n\nTherefore, the maximum number of unidirectional pairs is (n^2 - sum s_i^2)/2, where s_i are the sizes of the components chosen during the minimal node count calculation.\n\nSo, the steps are:\n\n1. Compute the minimal n by decomposing p into sum of C(k_i, 2) using the greedy approach.\n\n2. For the decomposition, collect the sizes of the components (the k_i's).\n\n3. Compute sum_squares = sum (k_i^2).\n\n4. The maximum number of unidirectional pairs is (n^2 - sum_squares) // 2.\n\nWait, but let's check with the sample input.\n\nSample input 1: p=3.\n\nThe minimal n is 3, with components [3]. sum_squares is 3^2=9. n^2 is 9. So (9-9)/2 =0. Which matches the sample output of 0.\n\nSample input 2: p=4. The minimal n is 5 (components 3 and 2). sum_squares is 3^2 + 2^2 = 9 +4=13. n^2 is 25. 25-13=12. Divided by 2 is 6. Which matches the sample output of 5 6.\n\nAnother example: p=0. Then the minimal n is 0? No. Wait, for p=0, the graph must have no mutual pairs. So the minimal n is 0? But the problem says nodes are in a directed graph. Wait, the problem says \"nodes\" but for p=0, the graph can be empty. But what's the minimal number of nodes? For example, if n=0, but the problem probably expects n=0 when p=0. However, looking at the sample input where p=0, the output is '0 0'.\n\nBut according to the sample input provided, when the input is 0, the output is '0 0'. So for p=0, the minimal number of nodes is 0. But what if p=0 and n=1? Then there are no pairs (u, v) with u <v, so p=0 is satisfied. So why is the minimal n 0?\n\nBut according to the problem statement, the input p can be 0. So for p=0, the minimal number of nodes is 0? Or 1?\n\nWait, the problem defines an ordered pair (u, v) where u !=v. So when there are no nodes, there are no such pairs. So p=0 is satisfied. But when there is one node, there are no pairs (u, v) with u <v. So for p=0, the minimal n is 1? Or 0?\n\nBut according to the sample input where p=0, the output is 0 0. So perhaps the problem allows n=0. However, in practice, directed graphs are defined with at least one node. But perhaps the problem considers n=0 as acceptable for p=0. However, the sample input shows that for p=0, the output is 0 0.\n\nBut let's think: if n=0, then the number of ordered pairs (u, v) with u <v is zero. So p=0 is satisfied. Hence, the minimal n is 0. But for n=1, it's also valid. So the minimal n is 0.\n\nBut how to handle this in code. Because for p=0, the code needs to return 0 and 0.\n\nBut let's proceed. So the code will need to handle p=0 as a special case. Let's think about that later.\n\nSo, the plan for the code is:\n\nFirst, handle p=0. The minimal n is 0, and the maximum unidirectional pairs is 0.\n\nFor p>0:\n\nCompute the minimal n by greedily choosing the largest possible C(k, 2) each time.\n\nThen, collect the sizes of the components used in this decomposition (like for p=4, the components are 3 and 2).\n\nOnce we have these sizes, compute sum_squares = sum(s_i^2), and then the maximum unidirectional pairs is (n^2 - sum_squares) // 2.\n\nNow, the code steps:\n\nImplement the function to compute the minimal n and the component sizes.\n\nBut how to compute the component sizes for the decomposition. Let's think:\n\nInitialize p_remaining = p.\n\ncomponents = list()\n\nwhile p_remaining > 0:\n\n   find k such that k*(k-1)/2 <= p_remaining, and (k+1)*k/2 > p_remaining.\n\n   add k to components.\n\n   p_remaining -= k*(k-1)//2\n\nOnce this loop is done, the components list contains the sizes of the components.\n\nBut for example, for p=4, the components are 3 and 2.\n\nOnce we have the components, compute sum_squares = sum(k^2 for k in components).\n\nThen, n is sum(components).\n\nNow, the maximum unidirectional pairs is (n^2 - sum_squares) // 2.\n\nBut let's test with the sample input.\n\nSample input 3: p=0 → output is 0 0.\n\nSample input 1: p=3. components is [3], sum_squares is 9. n=3. (3² -9)/2 =0 → correct.\n\nSample input 2: p=4 → components [3,2]. sum_squares 9+4=13. n=5. 5²=25. 25-13=12 → 6. Correct.\n\nAnother test case: p=6. The greedy approach would take k=4 (C(4,2)=6), so components [4], sum_squares=16. n=4. (4² -16)/2 = (16-16)/2=0. So the maximum unidirectional pairs is 0. Which makes sense, since all nodes are in a single component. Hence, no unidirectional pairs.\n\nAnother example: p=5. Greedy decomposition is 3 (C(3,2)=3), then 2 (C(2,2)=1), then 2 (C(2,2)=1). Total p_remaining 5-3-1-1=0. Components [3,2,2]. sum_squares is 9 +4 +4= 17. n=3+2+2=7. (7^2 -17)/2 = (49-17)/2 = 32/2=16. So maximum unidirectional pairs is 16.\n\nBut how is that possible? The components are 3, 2, 2. Arranged in a linear order, the total cross-component pairs would be:\n\nBetween 3 and 2: 3*2 =6.\n\nBetween 3 and 2 (second component): 3*2=6.\n\nBetween 2 and 2: 2*2=4.\n\nTotal: 6+6+4=16. Which matches.\n\nSo the formula works.\n\nNow, the code steps:\n\nImplement the decomposition for p.\n\nBut what about when p=0? Then the code returns 0 and 0.\n\nNow, the code:\n\nRead p from input.\n\nif p == 0:\n\n   print 0 0\n\nelse:\n\n   compute components via the greedy approach.\n\n   compute n = sum(components)\n\n   compute sum_squares = sum(k*k for k in components)\n\n   max_unidir = (n*n - sum_squares) // 2\n\n   print n, max_unidir\n\nBut wait, what about when p=0 but the code returns n=0. However, in some cases, for example, if the problem requires at least one node. Let's check the sample input where p=0, the output is 0 0. So the code is correct.\n\nBut what about when p=0 and n=0. How to handle that. But the code handles it.\n\nNow, the code for the decomposition.\n\nImplementing the decomposition:\n\ndef minimal_nodes(p):\n\n    components = []\n\n    while p > 0:\n\n        # find the largest k where k*(k-1)//2 <= p\n\n        k = int( ( (2*p + 0.25)**0.5 + 0.5 ) )\n\n        # because solving k^2 -k - 2p <=0 → k = [1 + sqrt(1 + 8p)] / 2\n\n        # compute k as floor( (sqrt(8p +1) +1)/2 )\n\n        # let's compute this properly\n\n        # compute sqrt(8p +1)\n\n        # but perhaps using binary search is better for precision.\n\n        # but for code purposes, perhaps using math.sqrt is sufficient.\n\n        # however, due to floating point inaccuracies, we need to check.\n\n        # alternative approach:\n\n        # compute k as the floor of (sqrt(8p +1) + 1)/2\n\n        # but let's compute it.\n\n        # compute k:\n\n        k = int( ( ( (8*p +1)**0.5 + 1 ) ) / 2 )\n\n        # but need to check if (k+1)*(k)/2 <= p ?\n\n        # perhaps better to compute using binary search.\n\n        # but for code purposes, perhaps the following:\n\n        # find the maximum k such that k*(k-1)//2 <= p.\n\n        # initial code:\n\n        # compute k as the floor of (sqrt(8p +1) + 1)/2.\n\n        # but let's test with p=4:\n\n        # 8*4 +1 =33 → sqrt(33) ≈5.744 → +1 =6.744 /2=3.372 → floor is 3. Which is correct.\n\n        # for p=6: 8*6+1=",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs in such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs of nodes `(u, v)` where `u < v` and both nodes are mutually reachable.\n2. **Minimum Nodes Calculation**: To minimize the number of nodes, we decompose `p` into sums of triangular numbers (i.e., values of the form `k*(k-1)/2`). This decomposition is done greedily by selecting the largest possible triangular number at each step.\n3. **Maximizing Unidirectional Pairs**: Once we have the minimum number of nodes, we calculate the maximum number of unidirectional pairs by considering the sizes of the components formed during the decomposition. The formula used is derived from the sum of products of component sizes arranged in a linear order.\n\n### Solution Code\n```python\nimport math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    components = []\n    remaining = p\n    while remaining > 0:\n        # Compute the largest k such that k*(k-1)//2 <= remaining\n        k = int(((2 * remaining + 0.25) ** 0.5 + 0.5))\n        # Check if k is too big\n        while k * (k - 1) // 2 > remaining:\n            k -= 1\n        components.append(k)\n        remaining -= k * (k - 1) // 2\n\n    n = sum(components)\n    sum_squares = sum(k * k for k in components)\n    max_unidir = (n * n - sum_squares) // 2\n    print(f\"{n} {max_unidir}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input value `p` is read from standard input.\n2. **Special Case Handling**: If `p` is 0, the output is immediately set to \"0 0\" as no nodes are needed.\n3. **Greedy Decomposition**: For each value of `p`, we decompose it into the sum of triangular numbers using a greedy approach. This involves finding the largest integer `k` such that `k*(k-1)/2` is less than or equal to the remaining value of `p`.\n4. **Component Sizes**: The sizes of the components formed during decomposition are stored in a list.\n5. **Calculating Minimum Nodes**: The total number of nodes `n` is the sum of all component sizes.\n6. **Unidirectional Pairs Calculation**: Using the component sizes, we compute the maximum number of unidirectional pairs using the formula derived from the sum of products of component sizes arranged in a linear order.\n\nThis approach ensures that we efficiently determine the minimum number of nodes and maximize the unidirectional pairs using mathematical properties of triangular numbers and component arrangements.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    components = []\n    remaining = p\n    while remaining > 0:\n        # Compute the largest k such that k*(k-1)//2 <= remaining\n        k = int(((2 * remaining + 0.25) ** 0.5 + 0.5))\n        # Check if k is too big\n        while k * (k - 1) // 2 > remaining:\n            k -= 1\n        components.append(k)\n        remaining -= k * (k - 1) // 2\n\n    n = sum(components)\n    sum_squares = sum(k * k for k in components)\n    max_unidir = (n * n - sum_squares) // 2\n    print(f\"{n} {max_unidir}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 659,
        "thoughts_token_count": 8192
    }
}