{
    "start": 1758314437.091174,
    "end": 1758315199.4238284,
    "start-formatted": "2025-09-20 05:40 KST",
    "end-formatted": "2025-09-20 05:53 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem statement carefully.\n\nThe problem is about finding the minimum number of nodes required to create a p-reachable directed graph and then determining the maximum number of unidirectional pairs in such graphs. \n\nFirst, let's understand the definitions:\n\nA p-reachable graph has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So for each such pair, both directions must have paths. Wait no, the definition says that u and v are reachable from each other. So that means there's a path from u to v and a path from v to u. So for each such ordered pair (u, v) with u < v, they are mutually reachable. The count p is the number of such pairs.\n\nThe first part of the problem is to find the minimal number of nodes needed for such a graph. Then, among all such graphs with that minimal number of nodes, find the maximum possible number of unidirectional pairs. \n\nUnidirectional pairs are those where u != v, there's a path from u to v, but no path from v to u. \n\nSo, the approach is to model the problem in terms of how to structure the graph to meet the p-reachable condition with as few nodes as possible, and then maximize the unidirectional pairs under that constraint.\n\nLet me think about the structure of the graph. \n\nFor the p-reachable part: The number of mutual pairs (u, v) with u < v. For example, if the graph is a complete DAG (directed acyclic graph) with edges in one direction, then there are no mutual pairs. But if the graph has strongly connected components (SCCs), then within each SCC, all pairs of nodes are mutually reachable. Because in an SCC, every node can reach every other node. So, for a single SCC of size k, the number of mutual pairs is C(k, 2) = k*(k-1)/2. \n\nWait, but the problem counts ordered pairs (u, v) where u < v. So for a component of size k, the number of such pairs is C(k, 2). So the total p is the sum over all components of C(k_i, 2), where k_i is the size of each component. \n\nWait, but if there are multiple components, and between components, say, component A and component B, if there's a path from A to B, then any pair (u, v) where u is in A and v is in B would not be mutual reachable unless there's also a path from B to A. So, the mutual pairs can only exist within the same component. Because if two nodes are in different components, and there's a path from u to v, but not the other way around, then they aren't mutual. If there's a path both ways, then they are in the same component. So, the mutual pairs are exactly those within the same strongly connected component. \n\nTherefore, the problem reduces to partitioning the nodes into some number of strongly connected components, and the sum of C(k_i, 2) over all components equals p. And we need to find the minimal number of nodes n such that this sum is exactly p. Then, among all such possible configurations with minimal n, find the maximum number of unidirectional pairs.\n\nSo, the first part is to find the minimal n such that there exists a set of integers k_1, k_2, ..., k_m (each ≥1) where sum_{i} C(k_i, 2) = p, and sum k_i = n. And we want the minimal possible n.\n\nBut how do we find this? Let's think about how to minimize n given p. \n\nThe key idea is that for a given p, we want to split it into the sum of combinations C(k_i, 2) such that the sum of k_i is as small as possible. \n\nTo minimize the sum of k_i, given that sum C(k_i, 2) = p, we should make the individual k_i as large as possible. Because C(k, 2) grows quadratically, while the sum k_i grows linearly. For example, using larger components allows us to cover more of p with fewer nodes. \n\nWait, for example, suppose p is 3. The possible options are:\n\nOption 1: One component of size 3. C(3,2) = 3. Sum of k_i is 3.\n\nOption 2: Three components of size 2. Each contributes 1, so sum is 3. Total nodes is 3*2=6. Which is worse. So the minimal is 3.\n\nSo the optimal approach is to use as large components as possible. So the strategy is to find the minimal n by greedily taking the largest possible component sizes, starting from the largest possible k such that C(k, 2) ≤ remaining p. \n\nWait, but how?\n\nLet me think of the problem as follows: We need to represent p as the sum of C(k_i, 2), and minimize the sum of k_i. How?\n\nThis seems similar to the problem of representing a number as the sum of triangular numbers (since C(k, 2) is the k-th triangular number minus something? Wait, no: C(k, 2) is equal to k*(k-1)/2, which is the (k-1)th triangular number. For example, when k=3, it's 3, which is the 2nd triangular number (1+2).\n\nBut regardless, the problem is to find the minimal sum of k_i such that the sum of their C(k_i, 2) equals p. \n\nThe greedy approach here would be to take the largest possible k_i for each step. For example, for p=3, the largest possible k_i is 3 (C(3, 2)=3). So that's optimal. For p=4, the largest possible is 3 (C(3,2)=3), leaving 1. Then the next largest is 2 (C(2,2)=1). So total sum is 3+2=5. Alternatively, could we have two components of size 3 and 1? No, because C(3,2) + C(1,2) = 3 + 0 = 3. Not enough. Or maybe 4? C(4, 2) is 6, which is larger than 4. So no. So the best is 3+2=5. So sum of nodes is 5. \n\nBut what if p=6? C(4,2)=6. So sum is 4. Which is better than 3+2+... etc. So yes, the greedy approach works here.\n\nSo the way to find the minimal number of nodes is to greedily take the largest possible component sizes. \n\nThus, the algorithm for the first part (finding the minimal number of nodes) is:\n\nInitialize n = 0, remaining_p = p.\n\nWhile remaining_p > 0:\n\n   Find the maximum k such that C(k, 2) ≤ remaining_p.\n\n   Subtract C(k, 2) from remaining_p.\n\n   Add k to n.\n\nBut wait, this is not exactly correct. Because for example, if p is 4, the greedy approach would take k=3 (C(3,2)=3), remaining_p is 1. Then take k=2 (C(2,2)=1), total n=3+2=5. However, another way is to take two components of size 2 and 2: sum C(2,2)*2 = 1+1=2, which is not enough. Or perhaps a component of size 3 and one of size 1 (but that gives 3). No, that's not helpful. So the greedy approach is correct here.\n\nAnother example: p=5. Greedy approach: largest k with C(k,2) ≤5 is 3 (3). Then remaining_p is 2. Next largest is 2 (1), remaining_p is 1. Then another 2 (another 1?), but that would give sum 3+2+2=7 nodes. But another way: 3 (C(3,2)=3), and then 2 (C(2,2)=1) and 2 (another 1). But that's same as before. Alternatively, maybe a component of size 4 (C(4,2)=6) which is larger than 5. So no. What about 2 components of size 3 and 2? Wait, 3+1=4. So sum is 3+2=5. But 3+1 is 4, which is less than 5. Hmm, perhaps there's a better way. Wait, perhaps I'm missing something. Let me think again.\n\nWait, for p=5, the sum of C(k_i, 2) must be exactly 5. How?\n\nPossible options:\n\n- One component of size 4 (C(4,2) = 6) is too big. So no.\n\n- One component of size 3 (3) and then 2. The remaining is 5-3=2. Now, the next largest is 2 (C(2,2)=1). Then remaining is 1. Then another 2 (another 1). So total is 3+2+2=7 nodes. \n\nAlternatively, can we have a component of size 3 and a component of size 2? Then sum is 3 + 1 = 4. Not enough. So we need another component of size 2 (adding 1). So total 3+2+2=7. \n\nAnother possibility: two components of size 3 and 2. That's 3 + 1 = 4. Not enough. So no. \n\nAnother possibility: one component of size 3 and one component of size 3. Then sum is 3 + 3 = 6. That's over. \n\nHmm. So maybe the greedy approach is correct. So the minimal n for p=5 is 3+2+2=7? Or is there a better way? \n\nWait, what about a component of size 4 and a component of size 1? Then sum is C(4,2) + C(1,2) = 6 + 0 = 6. Still over. \n\nAlternatively, a component of size 3 and one of size 2 and one of size 1. That's 3+1+0 =4. Not enough. \n\nSo perhaps the minimal n for p=5 is indeed 7. \n\nBut maybe there's a better way. Let's think: suppose we have two components of size 3 and 2. Wait, that's sum 3+1=4. Not enough. Then add another component of size 2 (1) to get 5. So total nodes is 3+2+2=7. \n\nAlternatively, is there a way to have a component of size 5? C(5,2) is 10, which is bigger than 5. \n\nSo the answer for p=5 is 7. \n\nBut according to the greedy approach, the steps would be:\n\nremaining_p =5.\n\nFind maximum k where k*(k-1)/2 ≤5. Let's compute:\n\nk=3: 3*2/2=3 ≤5.\n\nk=4: 4*3/2=6>5. So max k is 3. Subtract 3 from remaining_p (now 2). Add 3 to n. \n\nNext step: remaining_p=2. Find max k for which k*(k-1)/2 ≤2. \n\nk=2: 1 ≤2. k=3: 3>2. So take 2. Subtract 1. Remaining_p=1. Add 2 to n. \n\nNow remaining_p=1. Again, find k=2: 1. Subtract 1. Add 2. Now total n is 3+2+2=7. \n\nYes. So the approach is correct. \n\nSo the first part of the problem is to find the minimal n by greedily choosing the largest possible k_i for each step. \n\nSo the code for the first part would involve, for a given p, finding the minimal n by this process. \n\nBut wait, there's a case when p is zero. For example, if p=0, then the graph must have no mutual pairs. Which implies that the graph is a DAG with no cycles. Because if there is any cycle, then all nodes in the cycle are mutually reachable. So for p=0, the minimal number of nodes is 1 (since with 1 node, there are no pairs (u, v) with u < v). Or maybe even 0? Wait, the problem says nodes. So for p=0, the minimal number of nodes is 1? Because for n=1, there are zero pairs (u, v) with u < v. So yes. \n\nBut according to the sample input, when p=0, the output is \"0 0\". Wait, looking at the sample input:\n\nSample Input 3: 0. Output is \"0 0\".\n\nWait, but in that case, the first number is the minimal number of nodes. So for p=0, the minimal number of nodes is 0? Or 1?\n\nWait, the problem says that the graph is a directed graph. So nodes can be 0? Probably not. Because a graph with zero nodes has zero pairs. So for p=0, the minimal number of nodes is 0? But that's probably not allowed. Let's check the sample input. \n\nIn the third example, input is 0, output is 0 0. So according to the sample, when p=0, the minimal number of nodes is 0. But how can a graph have zero nodes? Well, perhaps the problem allows that. But maybe the problem expects that for p=0, the minimal number of nodes is 1. Wait, but the sample shows that when p=0, the output is 0 0. So that suggests that for p=0, the minimal number of nodes is 0. \n\nBut that's confusing. Let me think again. The problem says that the ordered pair (u, v) must satisfy u != v. So for n=1, there are no such pairs. Hence, p=0 is achieved with n=1. But according to the sample input, when p=0, the output is 0 0. So why is that?\n\nLooking back at the sample input:\n\nThe third example input is 0. Output is 0 0. \n\nBut according to the problem statement, the first part is the minimal number of nodes required to create a p-reachable graph. For p=0, the graph must have exactly 0 pairs (u, v) with u < v and mutual reachability. \n\nSo for n=0, there are no such pairs. Hence, it's acceptable. However, can a graph have zero nodes? It depends on the problem's constraints. The problem says that the graph is directed. But in programming competition problems, sometimes n=0 is allowed. However, the sample output shows that for p=0, the answer is 0. So perhaps the problem allows n=0. \n\nBut then, for p=0, the minimal number of nodes is 0. However, in practice, when n=0, there are zero nodes, so there are zero pairs. So the answer is correct. \n\nBut how to handle this in the code. For example, when p=0, the code needs to return 0 and 0. \n\nSo, in the code, the first part is to compute the minimal n. Let's proceed with the algorithm.\n\nNow, for the second part of the problem: once we have the minimal n, we need to find the maximum number of unidirectional pairs among all such graphs.\n\nSo, how to compute this maximum number of unidirectional pairs.\n\nLet's think about the structure of the graph. The graph consists of several strongly connected components (SCCs). Each component contributes C(k_i, 2) to the p value. The rest of the pairs (those not in the same component) may or may not be unidirectional. \n\nBut how do we maximize the number of unidirectional pairs? \n\nThe unidirectional pairs are those (u, v) where u != v, and there's a path from u to v but not from v to u. \n\nSo, to maximize this, we need to arrange the components in such a way that as many as possible of the pairs between components are unidirectional. \n\nBut how?\n\nLet's consider that between two components A and B, if there's a directed edge from A to B, but no edge from B to A, then all pairs (a, b) where a is in A and b is in B will be unidirectional (assuming that there's a path from A to B, but not vice versa). Similarly, for pairs (b, a) where a is in A and b in B, if there's a path from B to A, then they are unidirectional. \n\nBut to maximize the number of unidirectional pairs, we need to arrange the components in a DAG, where between any two components, there's a directed edge in one direction, but not the other. \n\nBecause if two components are connected in both directions (so there's a path from A to B and from B to A), then they are in the same component. So in our case, the components are arranged in a DAG structure, where there are no cycles between them. \n\nSo the way to maximize the number of unidirectional pairs is to arrange the components in a DAG where between any two components, there's a single direction (so that all pairs between them are unidirectional). \n\nMoreover, for each pair of components A and B, if there is a directed edge from A to B, then all pairs (a, b) where a is in A and b is in B are unidirectional. \n\nThus, the number of unidirectional pairs between components is the sum over all ordered pairs of components (A, B) where A ≠ B and there's a path from A to B but not vice versa, multiplied by the product of their sizes. \n\nBut how to maximize this sum? \n\nThis is equivalent to arranging the components in a DAG where the components are ordered in a way that for each pair of components, there is a directed edge in one direction. Then, for each such pair (A, B) where A comes before B in the DAG, we have all pairs (a, b) contributing to unidirectional pairs. \n\nIn this case, the total number of unidirectional pairs between components is the sum for all i < j (in the DAG order) of (size_i * size_j) * 1 (since all pairs from i to j are unidirectional) plus the same for j to i if there's a path in that direction. Wait, no. If the DAG is a linear order, then for each pair of components (A, B) where A is before B, there's a path from A to B but not the other way. So for each such pair, the number of unidirectional pairs is size_A * size_B. \n\nIf the DAG is a total order, then the total number of such pairs between components is the sum_{i < j} size_i * size_j. \n\nBut if the DAG is not a total order, then there may be some pairs of components that are not connected, leading to no paths between them, hence no unidirectional pairs. \n\nThus, to maximize the number of unidirectional pairs between components, we need to arrange the components in a DAG where there's a total order between them (i.e., a linear order). This way, every pair of components has a directed path in one direction. \n\nIn that case, the number of unidirectional pairs between components is sum_{i < j} size_i * size_j. \n\nAdditionally, within each component, since it's strongly connected, there are no unidirectional pairs (since all pairs are mutual). \n\nSo, the total number of unidirectional pairs is sum_{i < j} size_i * size_j. \n\nWait, but the problem counts all ordered pairs (u, v) where u != v, and there's a path from u to v but not the other way. \n\nSo, for the components arranged in a linear order, for each pair of components A and B, where A is before B, all (a, b) pairs contribute to unidirectional pairs. Also, for the same components, if B is before A, then (b, a) pairs are not unidirectional. \n\nThus, the total number of unidirectional pairs between components is sum_{i < j} (size_i * size_j) * 1 (for the direction from i to j). \n\nSo, the total unidirectional pairs is sum_{i < j} size_i * size_j. \n\nBut how to compute this sum? \n\nNote that sum_{i < j} size_i * size_j = [ (sum size_i)^2 - sum size_i^2 ] / 2. \n\nBecause sum_{i != j} size_i * size_j = (sum size_i)^2 - sum size_i^2. Then, dividing by 2 gives sum_{i < j} size_i * size_j. \n\nSo, the total number of unidirectional pairs between components is [ (total_nodes)^2 - sum (size_i)^2 ] / 2. \n\nBut total_nodes is the sum of size_i, which is n. \n\nWait, but the total_nodes is the sum of the sizes of the components. Which is n. \n\nSo, the formula is (n^2 - sum (size_i^2 )) / 2. \n\nBut in addition to that, there may be unidirectional pairs within components? No, because within a component, all pairs are mutual. So no unidirectional pairs. \n\nSo, the maximum number of unidirectional pairs is (n^2 - sum (size_i^2 )) / 2. \n\nBut how to maximize this value? Because the sum of size_i^2 is fixed once the sizes of the components are determined. \n\nWait, but for the same p, the way we split into components can affect the sum of squares. \n\nSo, for example, if we have p=3, and the components are [3], then sum of squares is 3²=9. The total unidirectional pairs is (3² - 9)/2 = 0. Which matches the first sample input. \n\nAnother example: suppose p=3, but the components are split into [2, 1]. Then sum of squares is 4 + 1 = 5. Then the unidirectional pairs would be ( (3^2 - 5)/2 ) = (9-5)/2 = 2. But this would require that the components are arranged in a DAG. However, in this case, the sum of C(k_i, 2) is C(2,2) + C(1,2) = 1 + 0 =1, which is not equal to p=3. So that's not allowed. \n\nSo the way to maximize the unidirectional pairs is to arrange the components in such a way that the sum of squares is as small as possible. Because the formula is (n² - sum_squares)/2. To maximize this, we need to minimize sum_squares. \n\nTherefore, given that the sum of C(k_i, 2) is fixed as p, and the sum of k_i is fixed as n (the minimal n), how to split the components into sizes k_1, k_2, ..., k_m such that the sum of squares is minimized. \n\nAh! Because the minimal sum of squares occurs when the sizes are as equal as possible. For example, splitting into as equal parts as possible. \n\nSo, for example, if the components are split into sizes as equal as possible, then sum of squares is minimized. \n\nBut how does this relate to the way we split the p into the sum of C(k_i, 2)? \n\nLet's think. For the first part, the minimal n is obtained by taking the largest possible components. However, for the second part, we need to split into components that minimize sum of squares. Which would be when the components are as equal as possible. \n\nBut there's a conflict here. For example, if the minimal n is achieved by splitting into one large component (say, size 3 for p=3), then the sum of squares is 3²=9. If instead, the same p could be achieved by splitting into smaller components (but that would require a larger n, which is not allowed). So for the minimal n, the split into components is determined by the greedy approach. However, perhaps there are multiple splits of the same p into components that sum to the same n. For example, if p=6, the greedy approach would take a component of size 4 (C(4,2) =6), sum n=4. Alternatively, could we split into two components of size 3 and 3? Then sum C(3,2) * 2 = 3*2=6. So n is 3+3=6. Which is larger than 4. So the minimal n is 4. So in that case, the split is forced to be a single component. \n\nBut if there are multiple splits with the same n, then we need to choose the one with the minimal sum of squares. \n\nSo the problem is: once we have determined the minimal n, and the way to split into components (as per the greedy approach), we need to find the split of the components that gives the minimal sum of squares. \n\nBut how can there be multiple splits with the same n? Let's think of an example. \n\nSuppose p=6. \n\nGreedy approach would take a component of size 4 (C(4, 2) = 6). So n=4. \n\nAlternative splits with same n? No. Because any other split would have to have sum of C(k_i, 2) =6, and sum k_i=4. \n\nWhat are the possibilities?\n\nPossible options:\n\n- One component of size 4. Sum C(4,2)=6. Sum k_i=4.\n\n- Two components: Let's see. Let's suppose components of size 3 and 1. Then sum C(3, 2) + C(1, 2) = 3 + 0 =3 <6. Not enough. \n\nOr components of size 2 and 2: sum is 1 +1 =2 <6. \n\nNo. So the only way is to have one component of size 4. So sum of squares is 16. \n\nAnother example: p=5. As discussed earlier, the minimal n is 7. How was that achieved? \n\nThe greedy approach would have components of sizes 3, 2, 2. Sum of C(k_i, 2) is 3 + 1 + 1 =5. Sum of k_i is 3+2+2=7. \n\nIs there another way to split into components with sum of C(k_i, 2) =5 and sum of k_i=7?\n\nAnother possibility: 3, 3, 1. Sum C(3,2) is 3 + 3 + 0 =6. No. \n\nOr 4, 2: C(4,2)=6, C(2,2)=1. Sum is 7. Which is more than 5. \n\nNo. So the split is forced. Thus, sum of squares is 3² + 2² + 2² = 9 +4 +4 = 17. \n\nSo, for this split, the unidirectional pairs would be (7² - 17)/2 = (49-17)/2 = 32/2=16. \n\nBut is this the maximum possible?\n\nBut how to find the split that gives minimal sum of squares. \n\nThe minimal sum of squares occurs when the components are as equal as possible. So, for example, if the components are split into sizes that are as close to each other as possible. \n\nBut how can we achieve that? \n\nIn the first part, the split into components is determined by the greedy approach. However, perhaps there are alternative splits with the same sum of C(k_i, 2) and same sum of k_i, but different component sizes. \n\nFor example, suppose p=4. The greedy approach would take 3 (C(3,2)=3) and then 2 (C(2,2)=1). Total n=5. \n\nAlternative split: two components of size 2 and 2. Their C(2,2) is 1 + 1 =2. Not enough. \n\nOr, one component of size 3 and one of size 2, sum is 3+1=4. That's the same as the greedy split. So in this case, the split is unique. \n\nAnother example: p=6. As before, the only split is a single component of size 4. \n\nAnother example: p=2. Greedy approach would take k=2 (C(2,2)=1) and then another k=2 (C(2,2)=1). Sum is 2, sum of k_i is 4. Alternatively, could we have a component of size 3 (C(3,2)=3) and then subtract 1? No. So the split is two components of size 2. Sum of squares is 4 +4=8. Unidirectional pairs would be (4² -8)/2= (16-8)/2=4. \n\nBut if the split was possible into one component of size 3 and another of size 1, but that would sum to 3 +0=3, which is more than p=2. So no. \n\nThus, the problem becomes: once the minimal n is found, how to split the components into sizes such that sum C(k_i, 2) =p, sum k_i =n, and the sum of squares is minimized. \n\nBut how to find this split? \n\nThe minimal sum of squares occurs when the components are as equal as possible. \n\nSo, for example, if the components are split into sizes that are as equal as possible, the sum of squares is minimized. \n\nBut how to find such a split given the constraints of sum C(k_i, 2) =p and sum k_i =n. \n\nThis seems challenging. \n\nBut perhaps, during the first part (finding the minimal n), the way the components are split is already the one that gives the minimal sum of squares. \n\nBut how?\n\nLet me think again. For example, in the case where p=5 and n=7. The split is [3, 2, 2]. The sum of squares is 9+4+4=17. \n\nIs there another split with sum of C(k_i, 2) =5 and sum of k_i=7, but with a smaller sum of squares?\n\nLet me think. Suppose the split is [4, 1, 2]. Then C(4,2) is 6, which is more than 5. So no. \n\nAnother possibility: [3, 3, 1]. Then sum C(k_i, 2) is 3 +3 +0 =6. Too big. \n\nAnother possibility: [2, 2, 3] which is same as the original split. \n\nSo no other splits. \n\nAnother example: p=4, n=5. Split is [3,2]. Sum of squares 9+4=13. Is there another split with sum of C(k_i, 2) =4 and sum k_i=5?\n\nAlternative split: [2, 2, 1]. Sum C(k_i, 2) is 1+1+0=2. No. \n\nAnother option: [4, 1]. C(4,2)=6. No. \n\nSo no. \n\nThus, perhaps the way the components are split during the first part (greedy approach) is the one that gives the minimal sum of squares. \n\nBut why? Because the greedy approach takes the largest possible components first. Which may not be the case for minimizing sum of squares. \n\nWait, for example, suppose we have p=6. The greedy approach would take a single component of size 4 (sum of squares 16). Alternatively, could we split into two components of size 3 and 3. Then sum C(3,2) is 3+3=6. Sum of squares is 9+9=18. Which is higher than 16. So the greedy approach gives a better sum of squares. \n\nAnother example: p=6, n=6. Wait, how? \n\nIf n=6, then the sum of C(k_i, 2) is 6. How to split into components with sum k_i=6. \n\nFor example, two components of 3 and 3. Sum of squares 18. \n\nOr one component of size 4 and one of size 2. C(4,2)+C(2,2)=6+1=7>6. Not allowed. \n\nOr one component of size 3, one of size 2, and one of size 1. Sum C(3,2)+C(2,2)+C(1,2) =3+1+0=4. Not enough. \n\nSo the only way is two components of 3 and 3. Sum of squares 18. Which is worse than the greedy approach (single component of size 4, sum 16). \n\nSo, in this case, the greedy approach gives a better sum of squares. \n\nAnother example: p=3. The greedy approach gives a single component of 3. Sum of squares 9. Alternatively, three components of 2, 1, 0. No, sum C(2,2) + C(1,2) + ... =1+0=1. Not enough. \n\nSo no. \n\nSo, perhaps the greedy approach for the first part (maximizing component sizes) also results in the minimal sum of squares. \n\nIf that's the case, then for the second part, once we have the components as per the greedy approach, the sum of squares is fixed. \n\nBut why? Because the sum of squares is minimized when the components are as large as possible. \n\nWait, for example, if you have two components of size a and b, then sum of squares is a² + b². If you replace them with a component of size a + b, then the sum of squares is (a + b)^2 = a² + 2ab + b², which is larger than the previous sum. So, this suggests that splitting into smaller components increases the sum of squares. \n\nBut this contradicts the previous example where splitting into two components of 3 and 3 (sum 18) is worse than a single component of size 4 (sum 16). \n\nWait, but in that case, the sum of squares for the single component is (4)^2 = 16. Which is less than 18. So splitting into smaller components increases the sum of squares. \n\nTherefore, to minimize the sum of squares, we want to have as few components as possible, and as large as possible. Which is exactly what the greedy approach does. \n\nThus, the way the components are split during the first part (greedy approach) gives the minimal sum of squares. Therefore, the maximum number of unidirectional pairs is (n^2 - sum_squares)/2. \n\nThus, the problem reduces to:\n\nOnce the minimal n is found, compute the sum of squares of the component sizes generated by the greedy approach. Then calculate (n² - sum_squares) // 2. \n\nSo, the plan for the code is:\n\nFor a given p:\n\nCase 1: p=0. Then the minimal n is 0. The number of unidirectional pairs is 0.\n\nElse:\n\nCompute the minimal n by the greedy approach, and collect the component sizes.\n\nThen compute sum_squares = sum(k_i^2 for each component size k_i).\n\nThen the answer for the second part is (n^2 - sum_squares) // 2.\n\nBut how to implement the greedy approach for finding the component sizes?\n\nLet's think about how to compute the component sizes. \n\nWe can start with remaining_p = p, and collect a list of component sizes. \n\nFor each step:\n\nFind the maximum k where k*(k-1)/2 <= remaining_p.\n\nAdd k to the list.\n\nSubtract k*(k-1)/2 from remaining_p.\n\nRepeat until remaining_p is 0.\n\nBut how to find the maximum k for each step?\n\nWe can compute k as the floor of the solution to k(k-1)/2 = remaining_p. \n\nSolving for k:\n\nk^2 -k - 2*remaining_p = 0.\n\nThe positive solution is [1 + sqrt(1 + 8*remaining_p)] / 2.\n\nSo, the maximum k is the floor of that value. \n\nFor example, if remaining_p is 3:\n\nsqrt(1 + 24) = sqrt(25) =5. (1+5)/2=3. So k=3.\n\nIf remaining_p is 4: sqrt(1 + 32) = sqrt(33) ≈5.744. (1+5.744)/2 ≈3.37. So floor is 3. \n\nSo the code for finding k is:\n\nk = floor( (sqrt(1 + 8 * remaining_p) + 1)/2 )\n\nBut we need to verify that k*(k-1)/2 <= remaining_p. \n\nOnce we find k, subtract it from remaining_p and proceed. \n\nSo, the code for generating the component sizes is:\n\ncomponents = []\nwhile p > 0:\n    k = floor( (sqrt(1 + 8*p) + 1)/2 )\n    # check if k*(k-1)//2 is <= p\n    # but since we compute it as the floor, it should be.\n    components.append(k)\n    p -= k",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This can be achieved by partitioning the nodes into strongly connected components (SCCs) such that the sum of combinations of node sizes in each component equals `p`.\n\n2. **Minimum Nodes Calculation**: To minimize the number of nodes, we use a greedy approach. For each step, we find the largest possible component size `k` such that the combination `C(k, 2)` (which is `k*(k-1)/2`) does not exceed the remaining value of `p`. This ensures we use the fewest nodes possible.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimum number of nodes is determined, the maximum number of unidirectional pairs is derived from the structure of the components. This is calculated using the formula `(n^2 - sum_squares) // 2`, where `sum_squares` is the sum of the squares of the sizes of each component.\n\n### Solution Code\n```python\nimport math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    components = []\n    remaining_p = p\n    while remaining_p > 0:\n        # Calculate the maximum k such that k*(k-1)//2 <= remaining_p\n        sqrt_val = math.sqrt(1 + 8 * remaining_p)\n        k = int((1 + sqrt_val) // 2)\n        # Check if k*(k-1)//2 exceeds remaining_p\n        while k * (k - 1) // 2 > remaining_p:\n            k -= 1\n        components.append(k)\n        remaining_p -= k * (k - 1) // 2\n    \n    n = sum(components)\n    sum_squares = sum(k*k for k in components)\n    max_unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`.\n2. **Special Case for p=0**: Directly handle the case where `p` is 0, which requires 0 nodes and 0 unidirectional pairs.\n3. **Greedy Component Size Calculation**: For each iteration, compute the largest possible component size `k` using the quadratic formula derived from solving `k*(k-1)/2 <= remaining_p`. This ensures we use the largest possible components first to minimize the total number of nodes.\n4. **Summing Component Sizes**: The total number of nodes `n` is the sum of all component sizes.\n5. **Calculating Unidirectional Pairs**: Using the formula `(n^2 - sum_squares) // 2`, where `sum_squares` is the sum of the squares of each component's size, we determine the maximum number of unidirectional pairs.\n\nThis approach efficiently computes the required values using mathematical insights and greedy strategies to ensure optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    components = []\n    remaining_p = p\n    while remaining_p > 0:\n        # Calculate the maximum k such that k*(k-1)//2 <= remaining_p\n        sqrt_val = math.sqrt(1 + 8 * remaining_p)\n        k = int((1 + sqrt_val) // 2)\n        # Check if k*(k-1)//2 exceeds remaining_p\n        while k * (k - 1) // 2 > remaining_p:\n            k -= 1\n        components.append(k)\n        remaining_p -= k * (k - 1) // 2\n    \n    n = sum(components)\n    sum_squares = sum(k*k for k in components)\n    max_unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 715,
        "thoughts_token_count": 8192
    }
}