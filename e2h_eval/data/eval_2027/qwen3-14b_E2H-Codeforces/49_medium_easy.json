{
    "start": 1758308560.5145855,
    "end": 1758308727.6815395,
    "start-formatted": "2025-09-20 04:02 KST",
    "end-formatted": "2025-09-20 04:05 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road (edge) between two lawns (vertices). \n\nFirst, I need to understand the constraints. Each edge connects two lawns, and for that edge, we have the GCD and LCM of the mushroom counts on those two lawns. Our task is to assign numbers to each lawn such that all these conditions are satisfied. If it's not possible, we return NO.\n\nLet me think about the relationship between GCD and LCM. For two numbers a and b, we know that GCD(a, b) * LCM(a, b) = a*b. So, given the GCD (g) and LCM (l) for an edge between two nodes u and v, we can say that a and b must be multiples of g, and their product must be g*l. Also, since LCM(a,b) is l, then l must be a multiple of both a and b. Wait, but since LCM(a,b) is the least common multiple, that means that l must be divisible by both a and b. So, for each edge, the GCD and LCM must satisfy that g divides l. Because if a and b have a GCD of g, then their LCM is (a*b)/g. So, for the given g and l, the product of a and b must be g*l. But since a and b are multiples of g, let's say a = g * x, b = g * y. Then, GCD(a, b) is g * GCD(x, y), and LCM(a, b) is g * LCM(x, y). But according to the problem statement, the given GCD is exactly g, so that implies that GCD(x, y) must be 1. Because GCD(a, b) = g * GCD(x, y) = given_gcd. So given_gcd must equal g, which implies that GCD(x,y) is 1. And the LCM of a and b would be g * x * y (since LCM(x,y) is x*y when GCD(x,y) is 1). Therefore, the given LCM must be equal to g * x * y. But since the given LCM is l, then l must be equal to g * x * y. Which implies that x * y = l / g. \n\nSo for each edge, the product of x and y (which are co-prime) must be l/g. Also, since x and y are co-prime, their product is l/g, and they must be factors of that product. So for each edge, the given GCD and LCM must satisfy that l is divisible by g. Otherwise, there's no solution. For example, if the given GCD is 2 and LCM is 3, then l/g is 3/2, which is not integer, so impossible. So first, for each edge, we need to check if LCM is divisible by GCD. If not, then immediately return NO.\n\nSo that's the first check. For each edge, check if LCM % GCD != 0. If any of them does, output NO.\n\nOnce that's done, for each edge, we can compute the product of x and y as l/g. Then, since x and y are co-prime, we need to find two numbers x and y such that x * y = (l/g) and GCD(x, y) = 1. But since x and y are co-prime, their product is (l/g), and each of them must be a divisor of that product. However, how do we choose x and y? Well, for the problem, we can assign x and y in any way as long as they are co-prime and their product is (l/g). However, since the problem allows any valid assignment, perhaps we can assign one of them as (l/g) divided by some factor, but how?\n\nBut wait, the problem is that each node's value is determined by the product of the GCD and x (since a = g * x, and similarly for b). So for each edge, the two nodes connected by the edge must have values a and b, which are g*x and g*y, respectively, where x and y are co-prime and x*y = l/g. \n\nSo the problem reduces to building a graph where each edge has a constraint that the two nodes must be multiples of the given GCD, and their ratio (in terms of x and y) must be co-prime and multiply to l/g.\n\nBut how do we model this? It seems like a graph problem where each node's value is determined by some constraints from its edges. This looks similar to a system of equations, but with multiplicative constraints.\n\nLet me think about modeling this as a graph where each node has a value, and for each edge (u, v), the values of u and v must be such that GCD(u, v) = g and LCM(u, v) = l. Which, as discussed earlier, implies that u = g * x, v = g * y, with x and y coprime and x*y = l/g. \n\nBut since x and y are coprime, and their product is fixed, then for each edge, the pair (x, y) must be such that x divides (l/g) and y divides (l/g), and x and y are coprime. However, since x*y = (l/g), once x is chosen, y is determined as (l/g)/x, and then we have to check that GCD(x, y) is 1. But since x*y = k (where k is l/g), and x and y are coprime, that implies that x and y must be divisors of k that are coprime. So for each edge, the possible pairs (x, y) are pairs of coprime divisors of k whose product is k. So for example, if k is 6, then possible pairs are (1,6), (2,3), (3,2), (6,1). But since x and y are interchangeable (as the edge is undirected), we can pick any of them.\n\nBut how do we assign x and y to the nodes in the graph? Because each node can be part of multiple edges. For example, if a node u is connected to two different edges, each with their own GCD and LCM, then the value of u must be compatible with all those edges.\n\nThis seems like a problem where each node's value must be determined in a way that for every edge connected to it, the value satisfies the constraints. But how?\n\nAn approach could be to model this as a graph where each node's value is determined up to a multiple of some factors, and we need to assign values such that all constraints are satisfied.\n\nAlternatively, perhaps we can model the problem using a union-find data structure, but I'm not sure. Another idea is to model the problem as a graph where each node's value is a multiple of some base value, and the constraints between nodes enforce relations between these multiples.\n\nWait, considering that for each edge (u, v), the values of u and v are multiples of g (the GCD of the edge). Let's denote for each edge, the GCD is g, and the LCM is l. Then, u and v must be multiples of g. Let me denote u = g * a, v = g * b. Then, GCD(u, v) = g * GCD(a, b) = given_gcd. Since the given_gcd is g, this implies that GCD(a, b) must be 1. Also, LCM(u, v) = g * LCM(a, b) = given_lcm. Since LCM(a, b) = a*b (because GCD(a,b)=1), this implies that g * a*b = l. Therefore, a*b = l/g. \n\nSo for each edge, we have that a and b are coprime and their product is l/g. \n\nBut how do we assign a and b to the nodes? Let's think of this as a graph where each node has a value (a_i) such that for each edge between u and v, a_u and a_v are coprime and their product is (l/g). However, the same a_u may be involved in multiple edges, so we need to ensure that all constraints are satisfied.\n\nThis seems like a problem that can be modeled with a graph where each node's value is determined by a set of constraints. For example, if two nodes u and v are connected by an edge, then their a values must be coprime and their product must be k (where k is l/g for that edge). \n\nBut how do we find such values? Let's consider that for each connected component in the graph, the values of the nodes must be assigned in a way that satisfies all the constraints. \n\nLet me think of the following approach: \n\nFor each connected component of the graph, we can assign a value to one node (say, the root), and then propagate the constraints to other nodes. However, this might not be straightforward because the constraints between nodes can create dependencies that may or may not be compatible.\n\nFor example, suppose we have a chain of nodes u - v - w. Between u and v, the product of a_u and a_v is k1, and they are coprime. Between v and w, the product of a_v and a_w is k2, and they are coprime. How can we assign a_v, a_u, and a_w?\n\nSince a_v must be coprime with both a_u and a_w, and also a_v is part of the product for both edges. Let's see: a_u * a_v = k1, so a_u = k1 / a_v. Similarly, a_w = k2 / a_v. Now, since a_u and a_v are coprime, then a_v must divide k1, and since GCD(a_u, a_v) = 1, then GCD(k1/a_v, a_v) = 1. Which implies that a_v must be a divisor of k1, and that a_v and k1/a_v are coprime. Which is only possible if a_v is a divisor of k1, and that a_v and k1/a_v are coprime. Which implies that a_v must be a divisor of k1 that is coprime with k1/a_v. Which implies that a_v must be a divisor of k1, and that a_v is coprime with k1/a_v. Which is equivalent to saying that a_v is a divisor of k1, and that a_v is square-free? Not sure. Alternatively, since a_v and (k1 / a_v) are coprime, then any prime factor of a_v cannot divide k1/a_v. Which implies that any prime factor of a_v must divide a_v and not divide (k1 / a_v), which implies that all primes in a_v must divide k1, but since k1 is a_v * (k1/a_v), and they are coprime, then the primes in a_v must not be present in (k1/a_v), hence a_v must be a divisor of k1, and the product of a_v and (k1/a_v) is k1. Also, since they are coprime, then the prime factors of a_v and (k1/a_v) are distinct. Therefore, k1 must be square-free? Not necessarily. For example, if k1 is 6, then a_v can be 2 and k1/a_v is 3. They are coprime. Or a_v is 3, then k1/a_v is 2. Or a_v is 6, then k1/a_v is 1. All are coprime. So for any k1, the possible a_v's are the divisors of k1 that are coprime with k1/a_v. Which is equivalent to saying that a_v must be a divisor of k1, and that a_v is coprime with k1/a_v. Which is equivalent to saying that a_v is a divisor of k1 and that a_v^2 divides k1? No, not necessarily. For example, if k1 is 4, then a_v could be 1 (coprime with 4), or 4 (coprime with 1). But if a_v is 2, then k1/a_v is 2, and GCD(2,2) is 2, which is not 1. So in that case, a_v can't be 2. So for k1=4, the possible a_v's are 1, 4. So for each k1, the possible a_v's are the divisors of k1 that are square-free? Not sure. \n\nBut regardless, the key point here is that for each edge, the product of the two a's is k, and they are coprime. So for each edge, the two a's must be coprime divisors of k. \n\nNow, back to the problem of assigning values. How can we model this?\n\nLet me think of each node's value as being determined relative to others. For example, in a connected component, if I assign a value to one node, then the values of other nodes can be determined based on the edges. However, this requires that the assignments are consistent across the entire component.\n\nFor example, suppose I have a tree structure. Let's take a simple case: two nodes connected by an edge. Then, for the edge, the product of a_u and a_v is k. Since they are coprime, we can choose a_u = 1 and a_v = k. Or vice versa. Either choice is valid. \n\nBut when there are more nodes, the choices may have to be consistent. For example, consider three nodes u, v, w connected as u-v and v-w. Suppose for u-v, the product is k1, and for v-w, the product is k2. Then, for the first edge, a_u = k1/a_v, and for the second edge, a_w = k2/a_v. Now, since a_u and a_v are coprime, and a_w and a_v are coprime. So, the value of a_v must be such that it divides both k1 and k2, and that a_v is coprime with k1/a_v and with k2/a_v. \n\nBut how can we find such a value of a_v? \n\nThis seems complicated. Perhaps we can model this as a graph where each node has a value, and for each edge, the product of the two values is k (for that edge), and they are coprime. \n\nBut how can we find such values?\n\nAnother approach: Let's think of the a_i values as being part of a system where for each edge (u, v), a_u * a_v = k_uv, and GCD(a_u, a_v) = 1. \n\nThis is similar to a system where variables are multiplied together with certain products. But since the variables are coprime, this imposes that each variable is a divisor of the product of their adjacent edges' k's, but also that they are coprime with their neighbors.\n\nWait, but for each edge (u, v), a_u and a_v are coprime. Therefore, any prime factor of a_u cannot be present in a_v. Which implies that for any two nodes connected by a path, their a values must be coprime with each other. Wait, no. Because if there is a path u - v - w, then a_u and a_v are coprime, and a_v and a_w are coprime. But that doesn't necessarily mean that a_u and a_w are coprime. For example, a_u could be 2, a_v is 3, and a_w is 2. Then, a_u and a_v are coprime, a_v and a_w are coprime, but a_u and a_w share a factor of 2. \n\nSo, in that case, the a values of nodes connected through a path can share factors. However, for the problem, this is allowed as long as each adjacent pair is coprime. \n\nBut how can we model this? \n\nLet me think of the graph as a collection of variables. For each connected component, the variables (a_i) must be such that for every edge, their product is k_uv and they are coprime. \n\nLet me think of the variables in terms of their prime factors. Since any two adjacent nodes are coprime, their prime factors must be disjoint. Therefore, each node's a_i can be assigned a unique set of primes, such that no two adjacent nodes share any primes. However, since the product of a_i and a_j is k_uv (for edge u-v), which is fixed, this suggests that the primes in a_i and a_j must be exactly the primes in k_uv. \n\nWait, but if a_i and a_j are coprime, then their product is k_uv. So, the primes in k_uv are exactly the primes in a_i plus those in a_j. Therefore, the primes in a_i must be a subset of the primes of k_uv, and same for a_j, but their subsets are disjoint. \n\nSo, for example, if k_uv is 6 (primes 2 and 3), then a_i could be 2 and a_j 3. Or a_i could be 6 and a_j 1, etc. But in all cases, the primes in a_i and a_j are disjoint and their union is the set of primes in k_uv. \n\nThis suggests that for each connected component, the primes used in all the k_uv's of that component must form a set that can be partitioned into subsets assigned to each node, such that adjacent nodes have disjoint subsets. \n\nBut how do we find such a partitioning?\n\nAlternatively, perhaps each connected component must have all the k_uv's (for edges in that component) having the same set of primes. Because, for example, if two edges in the same component have different prime factors, then there's a possibility of conflict. \n\nWait, let's take an example. Suppose we have a connected component with two edges: one with k_uv = 6 (primes 2 and 3) and another edge with k_xw = 10 (primes 2 and 5). Now, if u and x are connected via some path, then the primes in their a values must be disjoint. But how can that happen?\n\nLet me try to imagine. Suppose u and x are connected through a path. Let's say u is connected to v (k_uv=6), and v is connected to w (k_vw= something?), and then w is connected to x (k_wx=10). Let me see. \n\nBut this seems too vague. Maybe there's a better approach. \n\nAnother idea: For each connected component, the product of all k_uv's (for edges in the component) must be a perfect square? Not sure. \n\nAlternatively, considering that for each edge, a_u * a_v = k_uv. So for the entire component, multiplying all these equations together, we get the product of all a_i's raised to the degree of each node equals the product of all k_uv's. But since each edge contributes two nodes, but each a_i is multiplied once per edge it's part of. So, for example, if a node u is part of d edges, then a_u appears d times in the product. Therefore, the product over all edges (a_u * a_v) = product of all k_uv. Which equals (product of a_i^{degree_i}) ). \n\nBut I'm not sure how this helps. However, for the product of all k_uv's to be a square, since each a_i is multiplied as many times as its degree, then the product would be a square if and only if all degrees are even? No, that's not necessarily true. \n\nBut perhaps this line of thinking isn't helpful. Let's think differently.\n\nLet me think of the problem as building a graph where each node's a_i is determined by the constraints. For example, if we have a tree structure, we can assign values starting from the root. \n\nSuppose we have a connected component. Let's pick a root node and assign a value to it. Then, for each child node connected by an edge, we can compute the required value based on the product. \n\nFor example, take the root node u. Assign a_u = x. Then, for each neighbor v connected via an edge with k_uv, we have a_u * a_v = k_uv. So a_v = k_uv / a_u. But since a_u and a_v must be coprime, then a_u must divide k_uv, and the GCD(a_u, k_uv / a_u) must be 1. \n\nSo, for the initial assignment of a_u, we need to choose a value that divides k_uv for all edges connected to u. But how can we choose such a value? \n\nAlternatively, perhaps we can model the problem with a BFS or DFS traversal, assigning values as we go. For example:\n\n- Start with a node u. Assign a value to it. For example, assign a_u = 1. Then, for each neighbor v connected via an edge with k_uv, compute a_v = k_uv / a_u. Then, check if a_u and a_v are coprime. If yes, proceed. If not, then this assignment is invalid. \n\nBut this approach may not work because the initial assignment of a_u may not be compatible with all edges. For example, if u has two edges with different k_uv's. Let's say u is connected to v with k_uv = 6, and to w with k_uw = 10. If we assign a_u = 1, then a_v = 6 and a_w = 10. Then, since a_v and a_w are connected (if there's a path between them), but their values are 6 and 10. However, they are not coprime (GCD(6, 10) is 2). But if there is no edge between them, that's okay. But if there is an edge between them, then that would be a problem. \n\nBut this suggests that the assignment depends on the structure of the graph. \n\nThe problem is that the choice of a_u affects all other nodes connected to it. So, for example, in a tree, once we assign a value to the root, the rest of the values are determined. However, we need to ensure that for each edge, the two nodes' values are coprime and their product is k_uv. \n\nBut how do we choose the initial value for the root? \n\nPerhaps, for each connected component, the product of all k_uv's (for edges in the component) must be a square. Wait, let's think again. \n\nIn the case of a tree, the product of all edges' k_uv's would be equal to the product of all a_i's raised to the degree of each node. But since in a tree, the number of edges is (number of nodes - 1), and each node's degree is at least 1. However, this may not directly help. \n\nBut let's take an example. Suppose we have a tree with three nodes: u connected to v (k_uv = 6), and v connected to w (k_vw = 10). Then, the product of the edges is 6 * 10 = 60. \n\nAssuming the values are a_u, a_v, a_w. For the first edge, a_u * a_v = 6. For the second edge, a_v * a_w = 10. \n\nMultiplying them gives a_u * a_v^2 * a_w = 60. \n\nBut since we can choose a_u and a_w, this equation may not give us much. \n\nBut what if we have a cycle? Let's say a triangle: u connected to v (k_uv=6), v connected to w (k_vw=10), and w connected to u (k_wu=15). Then, the product of edges is 6*10*15 = 900. \n\nThe equations are:\n\na_u * a_v = 6\n\na_v * a_w = 10\n\na_w * a_u = 15\n\nMultiply all three: (a_u * a_v) * (a_v * a_w) * (a_w * a_u) ) = 6 * 10 * 15 = 900 \n\nWhich equals (a_u a_v a_w)^2 * (a_u a_v a_w)^0 ? Wait, no. The left side is (a_u * a_v * a_w)^2. Because each of a_u, a_v, a_w appears twice. \n\nSo, (a_u a_v a_w)^2 = 900 → a_u a_v a_w = sqrt(900) = 30. \n\nThen, from the equations:\n\na_u * a_v = 6 → a_w = 30 / (a_u a_v) ) = 30/6 = 5 \n\nSimilarly, a_v * a_w = 10 → a_u = 30/(a_v a_w) ) = 30/10 = 3 \n\na_w * a_u = 15 → a_v = 30/(a_w a_u) ) = 30/15 = 2 \n\nCheck if these satisfy the original equations:\n\na_u = 3, a_v = 2, a_w =5. \n\nCheck u and v: 3*2=6 (correct). Check v and w: 2*5=10 (correct). Check w and u:5*3=15 (correct). \n\nAlso, check that they are pairwise coprime. \n\nGCD(3,2) is 1. GCD(2,5) is 1. GCD(5,3) is 1. Yes. \n\nSo this works. \n\nBut what if the product of the edges in a cycle is not a perfect square? For example, suppose there's a cycle with edges having product 2. Then the square root would be irrational, which is impossible. Hence, in this case, there's no solution. \n\nSo, for any connected component, the product of all k_uv for edges in that component must be a perfect square. Otherwise, there is no solution. \n\nWait, but in the case of a tree (no cycles), the product of the edges is (product of a_i^degree_i) as discussed before. But for a tree, the product of the edges is (a_u a_v ... )^{something}? Not sure. However, in the case of a cycle, the product of the edges must be a square. \n\nSo, this suggests that for any connected component, the product of all k_uv's must be a square. Because when you multiply all the equations (a_u a_v = k_uv) for all edges in the component, the left-hand side becomes the product of (a_u a_v) for each edge. Which equals the product of a_i^{degree_i} for all nodes in the component. \n\nBut in the case of a connected component with cycles, the product of the edges' k_uv's would be a square if and only if the product of a_i^{degree_i} is a square. But since the a_i's are integers, this would require that for each prime in the product, its exponent is even. \n\nHowever, for a general connected component, this may not hold. \n\nBut how can we ensure that this is the case? For example, if the component is a tree, then the product of the edges' k_uv's is equal to the product of a_i^{degree_i} for all nodes. However, for a tree, the sum of degrees is 2*(number of edges) = 2*(n-1), where n is the number of nodes. \n\nBut this seems too abstract. However, the key takeaway from the cycle example is that for a connected component with cycles, the product of the k_uv's must be a square. \n\nTherefore, perhaps the following steps can be taken:\n\nFor each connected component in the graph:\n\n1. Compute the product of all k_uv's (k_uv = LCM / GCD for each edge). If this product is not a perfect square, then return NO.\n\nBut how do we compute this product? Because for large n and m, this product could be very big. However, we can represent it as a dictionary of prime factors, and check if all exponents are even. \n\nBut how can we compute the product of all k_uv's for a component? Well, for each edge in the component, we have k_uv = (LCM / GCD). So, for each edge, we can compute k_uv and multiply them all. However, for large components, this could result in a huge number. \n\nBut for checking whether the product is a square, we can factorize each k_uv into primes, and accumulate the exponents. Then, after processing all edges in the component, check that all exponents are even. \n\nIf this is not the case, then there is no solution. \n\nBut why? Because for the product of all edges' k_uv's to be a square, the product of all a_i^{degree_i} must be a square. Since the a_i's are integers, their product's squareness depends on the exponents of primes in their factorizations. \n\nBut this seems like a necessary condition, but is it sufficient? \n\nNot sure. Let's take an example. Suppose we have a component with two edges forming a cycle. For example, two edges between u and v. But according to the problem statement, no two lawns are connected by more than one road. So that's not allowed. So the minimal cycle is three edges. \n\nBut even if the product of k_uv's is a square, it doesn't necessarily mean that there's a valid assignment. For example, suppose we have a triangle with edges having k_uv = 2, k_vw=2, k_wu=2. The product is 8, which is not a square. So that would fail. But if we have a triangle with edges k_uv = 2, k_vw = 2, k_wu = 8. The product is 2*2*8 = 32, which is not a square. So that's invalid. \n\nBut if we have a triangle with edges k_uv=2, k_vw=2, k_wu= 2*2=4. Then the product is 2*2*4 = 16, which is a square. \n\nLet's see if this is possible. \n\nThe equations are:\n\na_u * a_v = 2\n\na_v * a_w = 2 \n\na_w * a_u = 4 \n\nMultiply all three: (a_u a_v a_w)^2 = 2*2*4 = 16 → a_u a_v a_w = 4. \n\nFrom first equation, a_u = 2 / a_v \n\nFrom second equation, a_w = 2 / a_v \n\nSubstituting into third equation: (2/a_v) * (2/a_v) = 4 → (4)/(a_v^2) = 4 → a_v^2 = 1 → a_v = 1 or -1. Since the numbers are positive, a_v = 1. \n\nSo a_u = 2, a_w = 2. \n\nCheck if they are coprime with their neighbors:\n\na_u and a_v: 2 and 1 → coprime. \n\na_v and a_w: 1 and 2 → coprime. \n\na_w and a_u: 2 and 2 → GCD is 2. Which is not 1. So this violates the condition. \n\nThus, even though the product of the edges' k_uv's is a square, there's no solution. \n\nSo this suggests that the condition of the product being a square is necessary but not sufficient. \n\nHmm. So this approach may not work. \n\nAlternative idea: For each connected component, the values of a_i must be determined in such a way that for each edge, a_u and a_v are coprime and their product is k_uv. \n\nThis seems like a problem that can be modeled with a bipartition of the graph. Wait, but how?\n\nAlternatively, think of the a_i's as being part of a system where each edge defines a relation between two variables. For example, for an edge between u and v, a_u * a_v = k_uv. And GCD(a_u, a_v) = 1. \n\nThis seems like a system of equations that can be solved with a graph traversal. \n\nLet me think of the following approach:\n\nFor each connected component:\n\n- Choose a starting node and assign a value to it. For example, assign a value of 1. \n\n- Then, perform a BFS or DFS, propagating the values based on the edges. \n\nFor example, during BFS, when visiting a neighbor v of u, we have the edge (u, v) with k_uv. We know that a_u * a_v = k_uv. So a_v = k_uv / a_u. \n\nBut since a_u and a_v must be coprime, we need to check that GCD(a_u, k_uv / a_u) == 1. \n\nIf this is not the case, then the current assignment is invalid. \n\nBut what if the initial assignment of a_u is not correct? For example, choosing a_u = 1 may not work. How can we choose the correct initial value?\n\nThis seems tricky. For example, in the previous example with the triangle (edges k_uv=2, k_vw=2, k_wu=4), if we start with u=1, then:\n\na_u = 1. \n\nEdge uv: a_v = 2 / 1 = 2. Check GCD(1, 2) = 1 → ok. \n\nEdge vw: a_w = 2 / a_v = 2/2 = 1. Check GCD(2, 1) = 1 → ok. \n\nEdge wu: a_w * a_u = 1 * 1 = 1, but k_wu is 4. So 1 != 4 → contradiction. \n\nSo this assignment fails. \n\nBut what if we choose a different initial value? For example, assign a_u = 2. Then:\n\na_u = 2. \n\nEdge uv: a_v = 2 / 2 = 1. \n\nEdge vw: a_w = 2 / 1 = 2. \n\nEdge wu: a_w * a_u = 2 * 2 = 4 → which matches k_wu. \n\nBut check coprimality:\n\na_u and a_v: 2 and 1 → ok. \n\na_v and a_w: 1 and 2 → ok. \n\na_w and a_u: 2 and 2 → GCD is 2, which is not 1. So invalid. \n\nSo again, invalid. \n\nThus, no matter what initial value we choose for u, the assignment leads to a contradiction. Hence, the answer is NO. \n\nBut according to the earlier product check, the product of the edges' k_uv's is 2*2*4=16, which is a square. But there is no solution. So the product being a square is not sufficient. \n\nThis suggests that the product check is not sufficient. \n\nSo what is the correct way to approach this problem?\n\nAlternative Idea:\n\nFor each edge, the product of the two a_i's is k_uv. Also, since the a_i's are coprime, they must be divisors of k_uv, and their product is exactly k_uv. So for each edge, the possible pairs (a_u, a_v) are pairs of coprime divisors of k_uv whose product is k_uv. \n\nThis suggests that for each edge, we can choose one of the possible pairs. But how to ensure consistency across the entire graph?\n\nThis seems like a problem that can be modeled as a graph where each node has a value that is a divisor of the k_uv for each of its edges. \n\nBut how to find such values?\n\nLet me think of the following approach:\n\nFor each connected component, build a graph where each node's value must be a divisor of the product of the k_uv's of its edges. But this is too vague. \n\nAnother Idea: For each connected component, construct a system of equations where each equation is a_u * a_v = k_uv. Then, the system must be solved with the additional constraints that GCD(a_u, a_v) = 1 for each edge. \n\nBut solving such a system is non-trivial. \n\nLet me think of the system as follows: For each edge (u, v), we have a_u * a_v = k_uv. \n\nIf we treat this as a system of equations, we can express variables in terms of others. For example, in a tree, we can assign a value to the root and compute the rest. However, for cycles, we need to ensure that the equations are consistent. \n\nFor example, in the cycle example with three edges, the equations are:\n\na_u * a_v = k1\n\na_v * a_w = k2\n\na_w * a_u = k3\n\nMultiplying them gives (a_u a_v a_w)^2 = k1*k2*k3 → a_u a_v a_w = sqrt(k1*k2*k3). \n\nFrom this, we can derive:\n\na_u = sqrt(k1*k2*k3) / (a_v a_w) \n\nBut substituting from the equations, we can find the values. However, for this to work, the product must be a perfect square. \n\nBut even then, as shown in the earlier example, it may not be possible. \n\nBut in that example, the product was a square (16), and yet there was no solution. What's the reason?\n\nIn that example, the equations were:\n\na_u * a_v = 2 → equation 1",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on the given GCD and LCM values for each road connecting two lawns. The solution involves checking constraints and using a graph traversal approach to assign valid values to each node.\n\n### Approach\n1. **Check Validity of Input**: For each road, ensure that the LCM is divisible by the GCD. If not, it's impossible to restore the mushroom counts.\n2. **Graph Construction**: Treat each lawn as a node and each road as an edge with the given GCD and LCM values.\n3. **Component-wise Processing**: Process each connected component of the graph separately.\n4. **BFS Traversal**: Use BFS to traverse the graph starting from an arbitrary node, assigning values to nodes such that the product of the values on adjacent nodes matches the required product derived from the GCD and LCM values.\n5. **Consistency Check**: During traversal, ensure that the assigned values are consistent with the constraints (i.e., GCD of adjacent nodes' values should be 1).\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        k = l // g\n        edges.append((u, v, g, l, k))\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n\n    visited = [False] * n\n    mushroom = [0] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        mushroom[start] = 1\n        while queue:\n            u = queue.popleft()\n            for (v, k) in graph[u]:\n                if visited[v]:\n                    if mushroom[u] * mushroom[v] != k:\n                        return False\n                    continue\n                # Compute a_v = k / a_u\n                a_u = mushroom[u]\n                if k % a_u != 0:\n                    return False\n                a_v = k // a_u\n                if math.gcd(a_u, a_v) != 1:\n                    return False\n                mushroom[v] = a_v\n                visited[v] = True\n                queue.append(v)\n        return True\n\n    for i in range(n):\n        if not visited[i]:\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    # Now check all edges\n    for u, v, g, l, k in edges:\n        a = mushroom[u]\n        b = mushroom[v]\n        if a * b != k or math.gcd(a, b) != 1:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, [g * mushroom[i] for i in range(n)])))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initial Checks**: The input is read and checked for validity. Each edge's LCM must be divisible by its GCD.\n2. **Graph Construction**: The graph is built using adjacency lists, where each node points to its neighbors along with the computed product of the GCD and LCM values.\n3. **BFS Traversal**: Starting from an unvisited node, BFS is used to assign values to nodes such that the product of values on adjacent nodes matches the required product. This ensures that the GCD of adjacent nodes is 1.\n4. **Consistency Check**: After assigning values via BFS, all edges are rechecked to ensure they meet the original constraints of GCD and LCM.\n\nThis approach ensures that we efficiently determine the mushroom counts or correctly identify if it's impossible based on the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        k = l // g\n        edges.append((u, v, g, l, k))\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n\n    visited = [False] * n\n    mushroom = [0] * n\n\n    def bfs(start):\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        mushroom[start] = 1\n        while queue:\n            u = queue.popleft()\n            for (v, k) in graph[u]:\n                if visited[v]:\n                    if mushroom[u] * mushroom[v] != k:\n                        return False\n                    continue\n                # Compute a_v = k / a_u\n                a_u = mushroom[u]\n                if k % a_u != 0:\n                    return False\n                a_v = k // a_u\n                if math.gcd(a_u, a_v) != 1:\n                    return False\n                mushroom[v] = a_v\n                visited[v] = True\n                queue.append(v)\n        return True\n\n    for i in range(n):\n        if not visited[i]:\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    # Now check all edges\n    for u, v, g, l, k in edges:\n        a = mushroom[u]\n        b = mushroom[v]\n        if a * b != k or math.gcd(a, b) != 1:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, [g * mushroom[i] for i in range(n)])))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 909,
        "thoughts_token_count": 8192
    }
}