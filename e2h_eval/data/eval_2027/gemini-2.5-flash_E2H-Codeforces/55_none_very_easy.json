{
    "start": 1758293704.5447023,
    "end": 1758293712.8918405,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    zeros = []\n    ones_count = 0\n    twos = []\n\n    for char in s:\n        if char == '0':\n            zeros.append('0')\n        elif char == '1':\n            ones_count += 1\n        else: # char == '2'\n            twos.append('2')\n\n    # The key insight is that '0' and '2' cannot be swapped directly.\n    # '0' can move past '1's. '2' can move past '1's.\n    # This means all '0's can effectively move to the left of all '1's,\n    # and all '2's can effectively move to the right of all '1's.\n    # However, '0's and '2's maintain their relative order.\n    #\n    # To get the lexicographically smallest string:\n    # 1. All '0's should come first.\n    # 2. Then all '1's.\n    # 3. Then all '2's.\n    #\n    # The only constraint is that '0' cannot pass '2'.\n    # This means if there's a '2' before a '0' in the original string,\n    # that '2' will always remain before that '0' (or at least,\n    # it can't move past it to the left).\n    #\n    # Consider the first '2' in the string. Any '0's that appear *after* this '2'\n    # cannot move to the left of this '2'.\n    # All '0's that appear *before* the first '2' can move to the very beginning.\n    # All '1's can move freely past '0's and '2's.\n    #\n    # So, the strategy is:\n    # 1. Collect all '0's that appear *before* the first '2'.\n    # 2. Collect all '1's.\n    # 3. Collect all '2's that appear in the original string.\n    # 4. Collect all '0's that appear *after* the first '2'.\n    #\n    # This simplifies:\n    # All '0's can move to the left, but they are blocked by the first '2'.\n    # All '2's can move to the right, but they are blocked by the last '0'.\n    # All '1's can move anywhere.\n    #\n    # To make the string lexicographically smallest, we want '0's first, then '1's, then '2's.\n    #\n    # Let's find the first occurrence of '2'.\n    first_two_idx = -1\n    for i in range(len(s)):\n        if s[i] == '2':\n            first_two_idx = i\n            break\n\n    result_parts = []\n\n    if first_two_idx == -1:\n        # No '2's in the string. All '0's can move to the left of all '1's.\n        # Result: all '0's, then all '1's.\n        result_parts.append('0' * len(zeros))\n        result_parts.append('1' * ones_count)\n    else:\n        # There are '2's.\n        # All '0's that appear before the first '2' can move to the very beginning.\n        # All '1's can be grouped together.\n        # The first '2' and all subsequent '2's will maintain their relative order.\n        # Any '0's after the first '2' cannot move before it.\n\n        # Append all '0's that appear before the first '2'.\n        for i in range(first_two_idx):\n            if s[i] == '0':\n                result_parts.append('0')\n\n        # Append all '1's. They can be placed after the initial '0's and before any '2's\n        # (or between '0's and '2's if '0's are blocked).\n        # To minimize lexicographically, we want '1's after '0's and before '2's.\n        result_parts.append('1' * ones_count)\n\n        # Append all characters from the first '2' onwards.\n        # The relative order of '0's and '2's in this segment is preserved.\n        # '1's from this segment have already been counted and placed.\n        for i in range(first_two_idx, len(s)):\n            if s[i] != '1': # Only '0's and '2's from this part\n                result_parts.append(s[i])\n\n    sys.stdout.write(\"\".join(result_parts) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    zeros = []\n    ones_count = 0\n    twos = []\n\n    for char in s:\n        if char == '0':\n            zeros.append('0')\n        elif char == '1':\n            ones_count += 1\n        else: # char == '2'\n            twos.append('2')\n\n    # The key insight is that '0' and '2' cannot be swapped directly.\n    # '0' can move past '1's. '2' can move past '1's.\n    # This means all '0's can effectively move to the left of all '1's,\n    # and all '2's can effectively move to the right of all '1's.\n    # However, '0's and '2's maintain their relative order.\n    #\n    # To get the lexicographically smallest string:\n    # 1. All '0's should come first.\n    # 2. Then all '1's.\n    # 3. Then all '2's.\n    #\n    # The only constraint is that '0' cannot pass '2'.\n    # This means if there's a '2' before a '0' in the original string,\n    # that '2' will always remain before that '0' (or at least,\n    # it can't move past it to the left).\n    #\n    # Consider the first '2' in the string. Any '0's that appear *after* this '2'\n    # cannot move to the left of this '2'.\n    # All '0's that appear *before* the first '2' can move to the very beginning.\n    # All '1's can move freely past '0's and '2's.\n    #\n    # So, the strategy is:\n    # 1. Collect all '0's that appear *before* the first '2'.\n    # 2. Collect all '1's.\n    # 3. Collect all '2's that appear in the original string.\n    # 4. Collect all '0's that appear *after* the first '2'.\n    #\n    # This simplifies:\n    # All '0's can move to the left, but they are blocked by the first '2'.\n    # All '2's can move to the right, but they are blocked by the last '0'.\n    # All '1's can move anywhere.\n    #\n    # To make the string lexicographically smallest, we want '0's first, then '1's, then '2's.\n    #\n    # Let's find the first occurrence of '2'.\n    first_two_idx = -1\n    for i in range(len(s)):\n        if s[i] == '2':\n            first_two_idx = i\n            break\n\n    result_parts = []\n\n    if first_two_idx == -1:\n        # No '2's in the string. All '0's can move to the left of all '1's.\n        # Result: all '0's, then all '1's.\n        result_parts.append('0' * len(zeros))\n        result_parts.append('1' * ones_count)\n    else:\n        # There are '2's.\n        # All '0's that appear before the first '2' can move to the very beginning.\n        # All '1's can be grouped together.\n        # The first '2' and all subsequent '2's will maintain their relative order.\n        # Any '0's after the first '2' cannot move before it.\n\n        # Append all '0's that appear before the first '2'.\n        for i in range(first_two_idx):\n            if s[i] == '0':\n                result_parts.append('0')\n\n        # Append all '1's. They can be placed after the initial '0's and before any '2's\n        # (or between '0's and '2's if '0's are blocked).\n        # To minimize lexicographically, we want '1's after '0's and before '2's.\n        result_parts.append('1' * ones_count)\n\n        # Append all characters from the first '2' onwards.\n        # The relative order of '0's and '2's in this segment is preserved.\n        # '1's from this segment have already been counted and placed.\n        for i in range(first_two_idx, len(s)):\n            if s[i] != '1': # Only '0's and '2's from this part\n                result_parts.append(s[i])\n\n    sys.stdout.write(\"\".join(result_parts) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 613,
        "completion_token_count": 1140,
        "thoughts_token_count": 0
    }
}