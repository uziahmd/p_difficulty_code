{
    "start": 1758009368.5748343,
    "end": 1758009584.2619379,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:59 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Okay, here's what I'm thinking:**\n\nI've got this \"Flawed Flow\" problem, and I need a Python script to crack it. Let's break down my initial thought process, as if I'm navigating this like a pro.\n\n**Problem Breakdown:**\n\nFirst, I'm given an undirected graph with `n` vertices and `m` edges, each with a flow capacity `c_i`. The goal is to orient these edges to satisfy a few crucial constraints. It's not a standard flow problem, but it definitely *feels* like one. The conditions are:\n\n1.  **Flow Conservation:** Except for the source (vertex 1) and the sink (vertex `n`), the total incoming flow must equal the total outgoing flow for every intermediate vertex.\n2.  **Source Constraint:** Vertex 1 has *no* incoming edges. This is a very important constraint to internalize.\n3.  **No Cycles:** The resulting directed graph has to be a Directed Acyclic Graph (DAG). This is a strong, powerful constraint.\n4.  **Maximum Flow:** The problem states that the given flow volumes are part of a *correct maximum flow*. This implies that the total flow leaving vertex 1 equals the total flow entering vertex `n`.\n\nThe output needs to be a list of directions for each edge, `d_i`, where 0 means `a_i -> b_i` and 1 means `b_i -> a_i`.\n\n**Key Insights:**\n\n1.  **Flow Conservation, Explained**: I've got to make sure that the flow is balanced at each intermediate vertex. The source can only *send* flow, while the sink can only *receive* flow. The \"no incoming edges\" on vertex 1 is the key here. The phrasing is important: It implies that the total flow *leaving* vertex 1 equals the total flow *entering* vertex `n`. That's because, if the flow *out* of `n` wasn't `0`, it would somehow need to find its way *back* to 1, contradicting the constraint that `1` has no incoming edges.\n\n2.  **DAG Power:** The DAG constraint is a huge hint. If it has to be a DAG, then there *must* be a topological ordering. In a topological ordering, all edges go from earlier vertices to later vertices. Vertex 1 must be among the earliest vertices, since it has no incoming edges. Conversely, vertex `n` should likely be among the latest in the topological sort, as it's the sink.\n\n3.  **Direction Determination, the core:** Now the tricky part. For each vertex `v`, I've got to ensure the incoming flow equals the outgoing flow. This likely involves some form of graph traversal, perhaps starting with a topological sort, but that's where I need to focus my energies.\n",
    "response": "The problem asks us to direct each edge `(a_i, b_i)` with a given flow volume `c_i` such that:\n1. For any intermediate vertex `v` (1 < `v` < `n`), the total incoming flow equals the total outgoing flow.\n2. Vertex 1 (source) has no incoming edges.\n3. The resulting directed graph has no cycles.\n\nWe need to output `0` if the flow is `a_i -> b_i` and `1` if the flow is `b_i -> a_i`.\n\nThe crucial constraints are \"no cycles\" and \"vertex 1 has no incoming edges\". If the directed graph has no cycles, it is a Directed Acyclic Graph (DAG). A DAG has a topological ordering of its vertices. Since vertex 1 has no incoming edges, it must be one of the \"earliest\" vertices in any topological sort.\n\nConsider the \"flow conservation\" rule. For any vertex `v` (1 < `v` < `n`), the sum of incoming flow must equal the sum of outgoing flow. Let `S_v` be the sum of all flow volumes `c_i` incident to `v` in the *undirected* graph. If we direct an edge `(u, v)` as `u -> v`, it contributes `c` to `v`'s incoming flow. If we direct it as `v -> u`, it contributes `c` to `v`'s outgoing flow.\nLet `in_v` be the total incoming flow and `out_v` be the total outgoing flow for vertex `v`.\nFor `1 < v < n`, we need `in_v = out_v`.\nFor `v = 1`, we need `in_1 = 0`.\nFor `v = n`, the problem doesn't explicitly state `out_n = 0`, but this is standard for a sink in a max-flow problem. If `out_n > 0`, that flow would have to go somewhere, and given the cycle constraint and `in_1=0`, it would imply flow could leave the sink and not return to the source, which is unusual. The total flow leaving source 1 must equal total flow entering sink `n`.\n\nLet's define `balance_v = in_v - out_v`.\nFor `1 < v < n`, `balance_v = 0`.\nFor `v = 1`, `balance_1 = - (total flow out of source)`.\nFor `v = n`, `balance_n = (total flow into sink)`.\nSince total flow out of source equals total flow into sink, `balance_1 = -balance_n`.\nAlso, `sum(balance_v for all v)` must be 0.\n\nThe key insight comes from the \"no cycles\" constraint. This implies that we can process vertices in a topological order. A common way to find a topological order or to process nodes in a DAG is using a queue-based approach (Kahn's algorithm) or Depth First Search (DFS).\n\nLet's consider the balance `B_v` for each vertex `v`. Initially, for each vertex `v`, we can calculate the *sum of flow volumes of all incident edges*. Let's call this `total_incident_flow[v]`.\nIf we knew the direction of all edges, we could check the conservation. But we don't.\n\nConsider a DFS-based approach. Since we need to avoid cycles and vertex 1 has no incoming edges, it's natural to think about a traversal starting from vertex 1.\nHowever, we don't know the directions yet. We need to *determine* the directions.\nWhat if we process vertices based on their \"net flow requirement\"?\nFor any vertex `v` (1 < `v` < `n`), its net flow must be zero. This means `sum(incoming_flow) = sum(outgoing_flow)`.\nThis is equivalent to saying that if we consider all edges incident to `v`, some must be incoming and some outgoing, such that their sums match.\n\nLet's maintain for each vertex `v` the sum of flow volumes of edges *whose direction has not yet been determined*. Let `current_balance[v]` be the net flow *into* `v` from edges whose direction *has* been determined. Initially, `current_balance[v] = 0` for all `v`.\n\nThe problem guarantees a solution exists and the graph is connected.\nThe \"no cycles\" constraint is very strong. If we can find a topological ordering, all edges must respect it. This means if `u` comes before `v` in the topological order, any edge between `u` and `v` must be `u -> v`.\n\nA common technique for problems involving flow conservation and DAGs is to use a source/sink approach.\nFor each vertex `v`, let `D_v` be the sum of flow values `c_i` for edges `(v, u)` that *must* be directed `v -> u` (i.e., `u` is \"later\" in the topological sort) and `I_v` be the sum of flow values `c_i` for edges `(u, v)` that *must* be directed `u -> v`.\nFor `1 < v < n`, we need `D_v = I_v`.\nFor `v = 1`, `I_1 = 0`.\nFor `v = n`, `D_n = 0`.\n\nThis problem can be modeled as finding a topological sort implicitly.\nLet's consider the degree of each vertex. The problem is about balancing flows.\nA standard approach for problems involving balancing quantities at nodes in a tree or DAG (after some initial processing) is to use a DFS traversal.\n\nLet's define `total_flow_sum[v]` as the sum of `c_i` for all edges incident to `v`.\nWe can initialize a `deficit[v]` for each vertex `v`. For `v=1`, `deficit[1]` can be thought of as the total flow that must leave `1`. For `v=n`, `deficit[n]` can be thought of as the total flow that must enter `n`. For `1 < v < n`, `deficit[v]` should eventually be 0.\n\nLet's use a DFS from vertex 1. When we traverse an edge `(u, v)`:\nIf `v` has already been visited (and is not the parent of `u` in the DFS tree), this implies a back edge or cross edge. In a DAG, cross edges are allowed if they respect topological order. Back edges are not. Since we are building a DAG, we must ensure we don't create back edges.\nThe problem statement \"vertex with number 1 has no incoming edges\" and \"the obtained directed graph does not have cycles\" suggests that we should try to direct edges away from already visited nodes in the DFS tree, especially those that are ancestors.\n\nA simpler approach for DAGs is to build the DAG from source to sink.\nWe can use a queue to process vertices. Initially, we put vertex 1 in the queue.\nWhen we process a vertex `u` from the queue:\nFor each neighbor `v` of `u` via edge `(u, v)` with flow `c`:\nWe need to decide if `u -> v` or `v -> u`.\nThis is tricky because we don't know the full context.\n\nLet's reconsider the balance. For each vertex `v`, let `balance[v]` be the current net incoming flow. Initially `balance[v] = 0` for all `v`.\nWe can use a DFS. When we traverse an edge `(u, v)`:\nIf `v` is `u`'s parent in the DFS tree, we don't process it as a child.\nIf `v` is unvisited, we direct the edge `u -> v` for now, add `c` to `balance[v]`, and recursively call DFS on `v`. After the recursive call returns, `balance[v]` will contain the net flow that needs to be satisfied by the edge `(u, v)`. If `balance[v]` is positive, it means `v` has an excess of incoming flow from its subtree and needs to send `balance[v]` units *out* through `(u, v)`. So we direct `v -> u`, and subtract `balance[v]` from `balance[u]`. If `balance[v]` is negative, it means `v` has a deficit and needs to receive `|balance[v]|` units *in* through `(u, v)`. So we direct `u -> v`, and add `|balance[v]|` to `balance[u]`.\nThis logic is more common for tree-like structures or specific flow problems.\nThe cycle constraint is key. A DFS-based solution that directs edges based on tree traversal (parent-child) and then handles back-edges/cross-edges can ensure a DAG.\n\nLet's try a DFS from source 1, keeping track of the `current_flow_sum` for each node.\n`current_flow_sum[v]` will store the net flow *into* `v` from its children in the DFS tree.\nWhen `DFS(u, parent_u)` is called:\n  Initialize `current_flow_sum[u] = 0`.\n  Mark `u` as visited.\n  For each neighbor `v` of `u` connected by edge `e_idx` with flow `c`:\n    If `v == parent_u`, continue (this is the edge leading back to parent).\n    If `v` is already visited:\n      This is a cross edge or forward edge. To avoid cycles, we must direct `u -> v`.\n      `ans[e_idx] = 0` (flow `u -> v`).\n      Add `c` to `current_flow_sum[v]`. (This is an incoming flow for `v` from outside its subtree or from an already processed node).\n    If `v` is unvisited:\n      `DFS(v, u)`.\n      After `DFS(v, u)` returns, `current_flow_sum[v]` will contain the net flow that needs to be satisfied by the edge `(u, v)`.\n      If `current_flow_sum[v] > 0`: This means `v` needs to send `current_flow_sum[v]` flow *out* through `(u, v)` to satisfy its internal balance. So, `v -> u`.\n        `ans[e_idx] = 1`.\n        `current_flow_sum[u] += current_flow_sum[v]`. (Flow `v -> u` is incoming to `u`).\n      If `current_flow_sum[v] < 0`: This means `v` needs to receive `|current_flow_sum[v]|` flow *in* through `(u, v)` to satisfy its internal balance. So, `u -> v`.\n        `ans[e_idx] = 0`.\n        `current_flow_sum[u] += current_flow_sum[v]`. (Flow `u -> v` is outgoing from `u`, so it's a negative incoming flow).\n      If `current_flow_sum[v] == 0`: This means `v`'s subtree is perfectly balanced. We can direct `u -> v` or `v -> u`. To maintain the DAG property and minimize complexity, we can default to `u -> v`.\n        `ans[e_idx] = 0`.\n        `current_flow_sum[u] += current_flow_sum[v]`. (Still 0).\n\nThis `current_flow_sum` logic is usually for when the graph is a tree. For a general graph, the \"visited\" nodes logic needs refinement.\nWhen `v` is visited, and not `parent_u`, it means `v` is an ancestor or a cross-node. To avoid cycles, we should direct `u -> v` if `v` is an ancestor of `u` (this would be a forward edge in the DFS tree). If `v` is a cross-node, we must direct `u -> v` or `v -> u` such that `v` is \"later\" than `u` in the topological order. The standard DFS ensures this by only processing unvisited nodes. If `v` is visited and not parent, it means `v` was visited *before* `u` in the DFS traversal. To maintain a DAG, the edge must be `v -> u`.\n\nLet's refine the DFS:\n`visited` array to track visited nodes.\n`ans` array to store directions.\n`balance[v]` will store the *net incoming flow* from edges whose direction has been decided *within the DFS subtree rooted at v*, plus any flow from cross-edges directed into `v`.\nInitialize `balance[v] = 0` for all `v`.\n\n`DFS(u, p_edge_idx)`:\n  Mark `u` as visited.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue (this is the edge we came from).\n    If `v` is visited:\n      // This is a cross-edge or a forward-edge (to an ancestor) or a back-edge.\n      // To ensure a DAG and satisfy `in_1=0`, we must direct flow from earlier visited nodes to later visited nodes.\n      // Since `v` is already visited, it must have been visited before `u`.\n      // Therefore, to maintain a DAG, the edge MUST be `v -> u`.\n      // This is a critical point: if `v` is visited, it implies `v` is \"earlier\" in the topological order.\n      // So, flow must be `v -> u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `balance[u] += c`. // `u` receives flow `c` from `v`.\n    Else (`v` is unvisited):\n      `DFS(v, e_idx)`.\n      // After DFS(v) returns, `balance[v]` contains the net flow that `v` needs to send *up* to `u`\n      // (if positive) or receive *from* `u` (if negative) to satisfy its subtree conservation.\n      If `balance[v] > 0`: // `v` needs to send `balance[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `balance[u] += balance[v]`.\n      Else (`balance[v] <= 0`): // `v` needs to receive `|balance[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `balance[u] += balance[v]`. // `balance[v]` is negative, so `u` effectively sends out `|balance[v]|`.\n\nInitial call: `DFS(1, -1)` (parent edge index -1 to signify no parent edge).\n\nAfter the initial `DFS(1, -1)` call finishes, `balance[1]` will contain the total net flow leaving vertex 1. This should be equal to the total flow of the maximum flow.\nFor all other vertices `v` (1 < `v` < `n`), `balance[v]` should be 0.\nFor `v = n`, `balance[n]` should be the total flow entering `n`.\n\nLet's test this logic with an example.\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\nAdjacency list:\n1: [(2, 10, 1), (3, 5, 2)]\n2: [(3, 10, 0), (1, 10, 1)]\n3: [(2, 10, 0), (1, 5, 2)]\n\nInitialize `visited = [F, F, F, F]`, `balance = [0, 0, 0, 0]`, `ans = [?, ?, ?]`.\n\n`DFS(1, -1)`:\n  `visited[1] = T`.\n  Neighbors of 1:\n  1. Edge (1, 2) with flow 10, index 1. `v = 2`. `2` is unvisited.\n     `DFS(2, 1)`:\n       `visited[2] = T`.\n       Neighbors of 2:\n       1. Edge (2, 3) with flow 10, index 0. `v = 3`. `3` is unvisited.\n          `DFS(3, 0)`:\n            `visited[3] = T`.\n            Neighbors of 3:\n            1. Edge (3, 2) with flow 10, index 0. This is `p_edge_idx`, skip.\n            2. Edge (3, 1) with flow 5, index 2. `v = 1`. `1` is visited.\n               `ans[2] = 1` (flow `1 -> 3` is `0`, flow `3 -> 1` is `1`). So `3 -> 1`.\n               `balance[3] += 5`. `balance = [0, 0, 5, 0]`.\n            `DFS(3, 0)` returns. `balance[3] = 5`.\n       Back in `DFS(2, 1)`: `v = 3`, `e_idx = 0`. `balance[3] = 5 > 0`.\n         `ans[0] = 1` (flow `3 -> 2`).\n         `balance[2] += balance[3] = 5`. `balance = [0, 5, 5, 0]`.\n       2. Edge (2, 1) with flow 10, index 1. This is `p_edge_idx`, skip.\n       `DFS(2, 1)` returns. `balance[2] = 5`.\n  Back in `DFS(1, -1)`: `v = 2`, `e_idx = 1`. `balance[2] = 5 > 0`.\n    `ans[1] = 1` (flow `2 -> 1`).\n    `balance[1] += balance[2] = 5`. `balance = [5, 5, 5, 0]`.\n  2. Edge (1, 3) with flow 5, index 2. `v = 3`. `3` is visited.\n     `ans[2]` is already set to `1` (flow `3 -> 1`). This is a problem! `ans[e_idx]` should only be set once.\n     The issue is that when `v` is visited, the edge `(u, v)` might have already been processed when `v` was `u`'s parent.\n     The `ans` array must be initialized to a special value (e.g., -1) to indicate not yet set.\n\nRevised DFS:\n`DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set (not -1), continue. // This edge has been directed by a previous DFS call.\n    If `v` is visited:\n      // This is a cross-edge or forward-edge. `v` was visited before `u`.\n      // To maintain DAG, flow must be `v -> u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `balance[u] += c`.\n    Else (`v` is unvisited):\n      `DFS(v, e_idx)`.\n      // After DFS(v) returns, `balance[v]` contains the net flow that `v` needs to send *up* to `u`\n      // (if positive) or receive *from* `u` (if negative) to satisfy its subtree conservation.\n      If `balance[v] > 0`: // `v` needs to send `balance[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `balance[u] += balance[v]`.\n      Else (`balance[v] <= 0`): // `v` needs to receive `|balance[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `balance[u] += balance[v]`.\n\nLet's re-trace the example with `ans` check:\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n`adj`:\n1: `[(2, 10, 1), (3, 5, 2)]`\n2: `[(3, 10, 0), (1, 10, 1)]`\n3: `[(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F,F,F,F]`, `balance = [0,0,0,0]`, `ans = [-1,-1,-1]`\n\n`DFS(1, -1)`:\n  `visited[1] = T`.\n  Neighbors of 1:\n  1. Edge (1, 2) flow 10, `e_idx = 1`. `v = 2`. `ans[1]` is -1. `2` is unvisited.\n     `DFS(2, 1)`:\n       `visited[2] = T`.\n       Neighbors of 2:\n       1. Edge (2, 3) flow 10, `e_idx = 0`. `v = 3`. `ans[0]` is -1. `3` is unvisited.\n          `DFS(3, 0)`:\n            `visited[3] = T`.\n            Neighbors of 3:\n            1. Edge (3, 2) flow 10, `e_idx = 0`. This is `p_edge_idx`, skip.\n            2. Edge (3, 1) flow 5, `e_idx = 2`. `v = 1`. `ans[2]` is -1. `1` is visited.\n               `ans[2] = 1` (flow `3 -> 1`). `balance[3] += 5`. `balance = [0,0,5,0]`.\n            `DFS(3, 0)` returns. `balance[3] = 5`.\n       Back in `DFS(2, 1)`: `v = 3`, `e_idx = 0`. `ans[0]` is -1.\n         `balance[3] = 5 > 0`.\n         `ans[0] = 1` (flow `3 -> 2`). `balance[2] += 5`. `balance = [0,5,5,0]`.\n       2. Edge (2, 1) flow 10, `e_idx = 1`. This is `p_edge_idx`, skip.\n       `DFS(2, 1)` returns. `balance[2] = 5`.\n  Back in `DFS(1, -1)`: `v = 2`, `e_idx = 1`. `ans[1]` is -1.\n    `balance[2] = 5 > 0`.\n    `ans[1] = 1` (flow `2 -> 1`). `balance[1] += 5`. `balance = [5,5,5,0]`.\n  2. Edge (1, 3) flow 5, `e_idx = 2`. `v = 3`. `ans[2]` is `1` (already set by `DFS(3,0)`). Skip.\n  `DFS(1, -1)` returns. `balance[1] = 5`.\n\nFinal `ans`: `[1, 1, 1]`\nThis means:\nEdge 0 (3, 2, 10): `3 -> 2`\nEdge 1 (1, 2, 10): `2 -> 1`\nEdge 2 (3, 1, 5): `3 -> 1`\n\nLet's check the balance:\nVertex 1 (source):\n  Incoming: `2 -> 1` (10), `3 -> 1` (5). Total 15.\n  Outgoing: None.\n  This violates `in_1 = 0`. The `balance[1]` value is 5, which is the total flow *into* node 1.\n  The problem states \"vertex with number 1 has no incoming edges\". My DFS logic for `v` visited leads to `v -> u` which means `1` can have incoming edges.\n\nThe condition \"vertex with number 1 has no incoming edges\" means that any edge `(1, v)` must be directed `1 -> v`.\nAnd any edge `(v, 1)` must be directed `v -> 1` if `v` is a neighbor of `1`.\nWait, this is contradictory. If an edge `(1, v)` exists, it must be `1 -> v`. If an edge `(v, 1)` exists, it must be `v -> 1`. But these are the same edge in an undirected graph.\nThe problem statement \"vertex with number 1 has no incoming edges\" means that for any edge `(u, 1)`, it must be directed `1 -> u`.\n\nLet's modify the DFS:\n`DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set, continue.\n    If `u == 1`: // Special case for source. All edges must be outgoing from 1.\n      `ans[e_idx] = 0` (flow `1 -> v`).\n      `balance[u] -= c`. // 1 sends flow `c` out.\n      If `v` is unvisited:\n        `DFS(v, e_idx)`.\n        `balance[u] += balance[v]`. // `v` sends `balance[v]` to `u`.\n      Else (`v` is visited):\n        // `v` must have been visited before `u` (impossible if `u=1` and `v` is visited by `DFS(1)`).\n        // This means `v` was visited by a DFS from another component, but the graph is connected.\n        // So `v` must be a node that `1` has an edge to, and `v` was visited via another path from `1`.\n        // This would only happen if `v` is an ancestor of `u` in the DFS tree, but `u=1` has no ancestors.\n        // So, if `v` is visited, it implies `v` is already part of the DFS tree from 1.\n        // This is a forward edge `1 -> v` to an already visited node.\n        // The flow `1 -> v` has already been handled by `ans[e_idx]=0` above.\n        // No, this `if v is visited` is specifically for when `u` is not `1`.\n        // If `u=1`, `v` cannot be visited *before* `u` in the DFS traversal.\n        // So, if `u=1` and `v` is visited, it must be a forward edge to a node in its own subtree.\n        // This implies a cycle if `v` is an ancestor of `u`. But `u=1` has no ancestors.\n        // So `v` must be a cross-edge to a node already visited in the `1`'s DFS tree.\n        // The `ans[e_idx]=0` already handles the direction.\n        // `balance[u] -= c` has already been applied.\n        // The only thing to do is ensure `balance[v]` is handled.\n        // This `balance[u] += balance[v]` is for when `v` is a child.\n        // If `v` is visited, it's not a child. `balance[v]` is already settled.\n        // So, for `u=1`, if `v` is visited, we just direct `1 -> v` and move on.\n        // This means the `balance[u] -= c` is sufficient for `u=1`.\n        pass // No additional balance adjustment for `u=1` and `v` visited.\n    Else if `v` is visited: // `u` is not 1. `v` was visited before `u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `balance[u] += c`.\n    Else (`v` is unvisited, `u` is not 1):\n      `DFS(v, e_idx)`.\n      If `balance[v] > 0`: // `v` needs to send `balance[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `balance[u] += balance[v]`.\n      Else (`balance[v] <= 0`): // `v` needs to receive `|balance[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `balance[u] += balance[v]`.\n\nLet's re-trace the example with this logic:\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n`adj`:\n1: `[(2, 10, 1), (3, 5, 2)]`\n2: `[(3, 10, 0), (1, 10, 1)]`\n3: `[(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F,F,F,F]`, `balance = [0,0,0,0]`, `ans = [-1,-1,-1]`\n\n`DFS(1, -1)`:\n  `visited[1] = T`.\n  Neighbors of 1:\n  1. Edge (1, 2) flow 10, `e_idx = 1`. `v = 2`. `ans[1]` is -1. `u=1`.\n     `ans[1] = 0` (flow `1 -> 2`). `balance[1] -= 10`. `balance = [-10,0,0,0]`.\n     `2` is unvisited.\n     `DFS(2, 1)`:\n       `visited[2] = T`.\n       Neighbors of 2:\n       1. Edge (2, 3) flow 10, `e_idx = 0`. `v = 3`. `ans[0]` is -1. `u=2` (not 1). `3` is unvisited.\n          `DFS(3, 0)`:\n            `visited[3] = T`.\n            Neighbors of 3:\n            1. Edge (3, 2) flow 10, `e_idx = 0`. This is `p_edge_idx`, skip.\n            2. Edge (3, 1) flow 5, `e_idx = 2`. `v = 1`. `ans[2]` is -1. `u=3` (not 1). `1` is visited.\n               `ans[2] = 1` (flow `1 -> 3` is `0`, flow `3 -> 1` is `1`). So `3 -> 1`.\n               `balance[3] += 5`. `balance = [-10,0,5,0]`.\n            `DFS(3, 0)` returns. `balance[3] = 5`.\n       Back in `DFS(2, 1)`: `v = 3`, `e_idx = 0`. `ans[0]` is -1. `u=2` (not 1).\n         `balance[3] = 5 > 0`.\n         `ans[0] = 1` (flow `3 -> 2`). `balance[2] += 5`. `balance = [-10,5,5,0]`.\n       2. Edge (2, 1) flow 10, `e_idx = 1`. This is `p_edge_idx`, skip.\n       `DFS(2, 1)` returns. `balance[2] = 5`.\n  Back in `DFS(1, -1)`: `v = 2`, `e_idx = 1`. `ans[1]` is `0` (already set). Skip.\n  2. Edge (1, 3) flow 5, `e_idx = 2`. `v = 3`. `ans[2]` is `1` (already set). Skip.\n  `DFS(1, -1)` returns. `balance[1] = -10`.\n\nFinal `ans`: `[1, 0, 1]`\nThis means:\nEdge 0 (3, 2, 10): `3 -> 2`\nEdge 1 (1, 2, 10): `1 -> 2`\nEdge 2 (3, 1, 5): `3 -> 1`\n\nLet's check balances with this output:\nVertex 1 (source):\n  Outgoing: `1 -> 2` (10).\n  Incoming: `3 -> 1` (5).\n  This still violates `in_1 = 0`. The problem is that `balance[1]` is tracking net flow *into* 1, but for source 1, we must ensure *no* incoming flow.\n\nThe problem \"vertex with number 1 has no incoming edges\" means that for any edge `(u, 1)`, it *must* be directed `1 -> u`.\nThe problem \"vertex with number 1 has no incoming edges\" is the most restrictive.\nThis means for any edge `(1, v)`, it *must* be directed `1 -> v`.\nThis implies that `ans[e_idx] = 0` if `a_i = 1` and `b_i = v`. And `ans[e_idx] = 1` if `a_i = v` and `b_i = 1`.\nThis is a fixed direction for all edges connected to `1`. Let's pre-process this.\n\nPre-process edges connected to 1:\nFor each edge `(a_i, b_i)` with flow `c_i`, index `idx_i`:\n  If `a_i == 1`: `ans[idx_i] = 0` (flow `1 -> b_i`).\n  If `b_i == 1`: `ans[idx_i] = 1` (flow `1 -> a_i`).\n  In either case, `balance[1]` decreases by `c_i` (flow leaves 1).\n  `balance[other_node]` increases by `c_i` (flow enters `other_node`).\n  Mark these edges as processed.\n\nThen, run DFS on remaining unvisited nodes and unassigned edges.\nThis is difficult because the graph might become disconnected after fixing edges from node 1.\nThe DFS approach with `balance[v]` is designed for a connected graph and determines directions as it goes.\n\nLet's reconsider the \"no cycles\" constraint. This means the graph is a DAG.\nIf we can find a topological sort, say `p_1, p_2, ..., p_n`. Then all edges `(u, v)` must be directed such that `u` appears before `v` in the sort.\nVertex 1 must be `p_1` because it has no incoming edges.\nVertex `n` is likely `p_n` (sink).\nThe `balance[v]` logic can be used to determine the relative order of nodes.\nIf `balance[v]` is positive after processing its subtree, it means `v` has an excess of incoming flow from its children/cross-edges, so it must send flow to its parent. This implies parent is \"later\".\nIf `balance[v]` is negative, it means `v` has a deficit, so it must receive flow from its parent. This implies parent is \"earlier\".\n\nThe issue with my DFS is that `balance[v]` represents net flow *into* `v` from its children.\nIf `balance[v]` is positive, `v` needs to send `balance[v]` flow *up* to its parent. So `v -> parent`.\nIf `balance[v]` is negative, `v` needs to receive `|balance[v]|` flow *from* its parent. So `parent -> v`.\nThis is exactly how it should work for tree edges.\n\nThe problem is the \"visited\" node case.\nIf `v` is visited and `v != parent_u`, it means `v` has already been part of the DFS tree.\nIf `v` is an *ancestor* of `u`, then `u -> v` would be a back-edge, creating a cycle. So we must have `v -> u`.\nIf `v` is a *cross-node* (neither ancestor nor descendant), then we need to direct `v -> u` or `u -> v` to avoid cycles. Since `v` was visited before `u`, `v` is \"earlier\" in the topological sort. So we must direct `v -> u`.\nIn both cases (ancestor or cross-node), the edge must be `v -> u`. This is what my current DFS does: `ans[e_idx] = 1` (flow `v -> u`), and `balance[u] += c`.\n\nSo, the logic for `v` is visited: `ans[e_idx] = 1` (flow `v -> u`), `balance[u] += c`. This seems correct for maintaining DAG.\nThe only node that cannot have incoming flow is vertex 1.\nSo, if `u=1`, then `balance[1]` must always be 0.\nThis means that if `balance[v]` is positive, `v` must send flow `v -> 1`. This makes `balance[1]` positive.\nIf `balance[v]` is negative, `v` must receive flow `1 -> v`. This makes `balance[1]` negative.\nThis implies `balance[1]` will be the total flow from 1.\n\nThe problem statement \"vertex with number 1 has no incoming edges\" implies that for any edge `(u,1)`, the direction must be `1 -> u`. This is a fixed direction.\nThis means my DFS logic for `u=1` is wrong.\nIf `u=1`, for any neighbor `v`, the edge `(1, v)` *must* be `1 -> v`.\nSo, `ans[e_idx] = 0` (flow `1 -> v`).\nAnd `balance[1]` should decrease by `c`.\nAnd `balance[v]` should increase by `c`. (Because `v` receives flow).\n\nLet's adjust the `balance` definition. Let `balance[v]` be the net flow *out* of `v`.\nInitially `balance[v] = 0`.\nWhen `DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set, continue.\n    If `u == 1`: // All edges from 1 must be outgoing.\n      `ans[e_idx] = 0` (flow `1 -> v`).\n      `balance[u] += c`. // 1 sends flow `c` out.\n      If `v` is unvisited:\n        `DFS(v, e_idx)`.\n        `balance[u] += balance[v]`. // `v` needs to send `balance[v]` flow to its parent.\n                                   // If `balance[v]` is positive, `v` sends flow *out*, so it is `v -> u`.\n                                   // This flow comes *into* `u`. So `u`'s *outgoing* balance is reduced.\n                                   // This is confusing. Let's stick to net incoming flow.\n\nLet `balance[v]` be the sum of flow *into* `v` from edges whose direction has been determined.\nFor `v=1`, `balance[1]` must be 0 at the end.\nFor `1 < v < n`, `balance[v]` must be 0 at the end.\nFor `v=n`, `balance[n]` must be the total flow.\n\nThe problem can be solved by a DFS from node 1.\nWhen traversing an edge `(u, v)` with flow `c`:\n1. If `u=1`: The edge must be `1 -> v`. So `ans[e_idx] = 0`. `balance[v] += c`.\n2. If `v` is `u`'s parent in DFS tree: This edge is for `u` to pass its remaining balance to parent.\n3. If `v` is visited and not parent: `v` is an \"earlier\" node. To maintain DAG, `v -> u`. So `ans[e_idx] = 1`. `balance[u] += c`.\n4. If `v` is unvisited: Recursively call `DFS(v, e_idx)`. After `DFS(v)` returns, `balance[v]` contains the net flow that needs to be satisfied by the edge `(u, v)`.\n   If `balance[v] > 0`: `v` has an excess of incoming flow, needs to send `balance[v]` out. So `v -> u`. `ans[e_idx] = 1`. `balance[u] += balance[v]`.\n   If `balance[v] < 0`: `v` has a deficit, needs to receive `|balance[v]|` in. So `u -> v`. `ans[e_idx] = 0`. `balance[u] += balance[v]`.\n   If `balance[v] == 0`: `v` is balanced. We can choose `u -> v` (e.g. `ans[e_idx]=0`). `balance[u]` unchanged.\n\nThis means `balance[v]` represents the *unbalanced incoming flow* for `v` that needs to be passed to its parent.\nAfter `DFS(v)` returns, `balance[v]` holds the net flow `v` needs to send to its parent (if positive) or receive from its parent (if negative).\n\nLet's re-run example 1 with THIS logic:\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n`adj`:\n1: `[(2, 10, 1), (3, 5, 2)]`\n2: `[(3, 10, 0), (1, 10, 1)]`\n3: `[(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F,F,F,F]`, `balance = [0,0,0,0]`, `ans = [-1,-1,-1]`\n\n`DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set, continue.\n    If `u == 1`:\n      `ans[e_idx] = 0` (flow `1 -> v`).\n      `balance[v] += c`. // `v` receives `c` from `1`.\n      If `v` is unvisited: `DFS(v, e_idx)`.\n      // No `balance[u]` adjustment here for `u=1` because `1` has no incoming edges.\n      // `balance[1]` should remain 0 throughout.\n      // The `balance[v]` from DFS(v) will eventually propagate to `n` or other visited nodes.\n    Else if `v` is visited: // `u` is not 1. `v` was visited before `u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `balance[u] += c`. // `u` receives `c` from `v`.\n    Else (`v` is unvisited, `u` is not 1):\n      `DFS(v, e_idx)`.\n      If `balance[v] > 0`: // `v` needs to send `balance[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `balance[u] += balance[v]`.\n      Else (`balance[v] < 0`): // `v` needs to receive `|balance[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `balance[u] += balance[v]`.\n      Else (`balance[v] == 0`): // `v` is balanced. Default to `u -> v`.\n        `ans[e_idx] = 0`.\n        // `balance[u]` is unchanged.\n\n`DFS(1, -1)`:\n  `visited[1] = T`.\n  Neighbors of 1:\n  1. Edge (1, 2) flow 10, `e_idx = 1`. `v = 2`. `ans[1]` is -1. `u=1`.\n     `ans[1] = 0` (flow `1 -> 2`). `balance[2] += 10`. `balance = [0,10,0,0]`.\n     `2` is unvisited. `DFS(2, 1)`:\n       `visited[2] = T`.\n       Neighbors of 2:\n       1. Edge (2, 3) flow 10, `e_idx = 0`. `v = 3`. `ans[0]` is -1. `u=2` (not 1). `3` is unvisited.\n          `DFS(3, 0)`:\n            `visited[3] = T`.\n            Neighbors of 3:\n            1. Edge (3, 2) flow 10, `e_idx = 0`. This is `p_edge_idx`, skip.\n            2. Edge (3, 1) flow 5, `e_idx = 2`. `v = 1`. `ans[2]` is -1. `u=3` (not 1). `1` is visited.\n               `ans[2] = 1` (flow `3 -> 1`). `balance[3] += 5`. `balance = [0,10,5,0]`.\n            `DFS(3, 0)` returns. `balance[3] = 5`.\n       Back in `DFS(2, 1)`: `v = 3`, `e_idx = 0`. `ans[0]` is -1. `u=2` (not 1).\n         `balance[3] = 5 > 0`.\n         `ans[0] = 1` (flow `3 -> 2`). `balance[2] += 5`. `balance = [0,15,5,0]`.\n       2. Edge (2, 1) flow 10, `e_idx = 1`. This is `p_edge_idx`, skip.\n       `DFS(2, 1)` returns. `balance[2] = 15`.\n  Back in `DFS(1, -1)`: `v = 2`, `e_idx = 1`. `ans[1]` is `0` (already set). Skip.\n  2. Edge (1, 3) flow 5, `e_idx = 2`. `v = 3`. `ans[2]` is `1` (already set). Skip.\n  `DFS(1, -1)` returns. `balance = [0,15,5,0]`.\n  The `balance` array is not what we expect. `balance[2]` and `balance[3]` are not 0.\n\nThe issue is that `balance[v]` is meant to represent the net incoming flow *that needs to be passed up to the parent*.\nWhen `u=1`, we direct `1 -> v`. This flow `c` goes into `v`. `balance[v]` should reflect this.\nIf `v` is visited (and not parent), we direct `v -> u`. This flow `c` goes into `u`. `balance[u]` should reflect this.\n\nThe correct way to handle `balance` for `u=1` is that `balance[1]` must remain `0`. Any flow `c` from `1 -> v` means `v` receives `c`. So `balance[v] += c`.\nFor `1 < v < n`, `balance[v]` must be `0` at the end.\nFor `v=n`, `balance[n]` must be the total flow.\n\nLet's think about the total flow required for each node.\nFor each node `v`, calculate `total_incident_flow[v] = sum(c_i for edges incident to v)`.\nFor `1 < v < n`, the sum of incoming flow must equal sum of outgoing flow.\nThis means `sum(incoming_c_i) = sum(outgoing_c_i)`.\nSince `sum(incoming_c_i) + sum(outgoing_c_i) = total_incident_flow[v]`,\nit implies `2 * sum(incoming_c_i) = total_incident_flow[v]`.\nSo, `total_incident_flow[v]` must be an even number for `1 < v < n`.\nAnd `balance[v]` (net incoming flow) = `sum(incoming_c_i) - sum(outgoing_c_i) = 0`.\n\nThis is the standard approach for \"Eulerian path/circuit\" type problems on trees, where each node has a \"parity\" or \"odd/even\" requirement. Here, it's a flow amount.\n\nLet `current_flow_at_node[v]` be the net flow *into* node `v` from edges whose direction has been decided *within its DFS subtree*.\n`DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  `current_flow_at_node[u] = 0`.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set, continue.\n    If `u == 1`:\n      `ans[e_idx] = 0` (flow `1 -> v`).\n      `current_flow_at_node[u] -= c`. // 1 sends flow out.\n      If `v` is unvisited:\n        `DFS(v, e_idx)`.\n        `current_flow_at_node[u] += current_flow_at_node[v]`. // `v` sends flow to `u`.\n      Else (`v` is visited):\n        // `v` is a cross-node. We have directed `1 -> v`.\n        // `current_flow_at_node[v]` would already be set.\n        // `current_flow_at_node[u] -= c` already handles 1's outgoing flow.\n        // No further adjustment to `current_flow_at_node[u]` from `v` is needed.\n        pass\n    Else if `v` is visited: // `u` is not 1. `v` was visited before `u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `current_flow_at_node[u] += c`. // `u` receives flow from `v`.\n    Else (`v` is unvisited, `u` is not 1):\n      `DFS(v, e_idx)`.\n      If `current_flow_at_node[v] > 0`: // `v` has excess incoming flow, needs to send `current_flow_at_node[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `current_flow_at_node[u] += current_flow_at_node[v]`.\n      Else (`current_flow_at_node[v] < 0`): // `v` has deficit, needs to receive `|current_flow_at_node[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `current_flow_at_node[u] += current_flow_at_node[v]`.\n      Else (`current_flow_at_node[v] == 0`): // `v` is balanced. Default `u -> v`.\n        `ans[e_idx] = 0`.\n        // `current_flow_at_node[u]` is unchanged.\n\nThis `current_flow_at_node` logic is for balancing the flows within the DFS tree.\nThe `current_flow_at_node[u]` after the loop will be the net flow *into* `u` from its children and cross-edges.\nThis `current_flow_at_node[u]` then needs to be passed up to `u`'s parent.\n\nThe problem guarantees a solution exists.\nThe total flow out of source 1 must equal total flow into sink `n`.\nLet's consider the initial sum of flows for each node: `initial_flow_sum[v] = sum(c_i)` for all edges `(v,u)`.\nFor `1 < v < n`, the net flow must be 0.\nFor `v = 1`, net flow is `-(total flow)`.\nFor `v = n`, net flow is `+(total flow)`.\n\nA common trick for this type of problem is to use a DFS and sum up flows.\nInitialize `balance[v] = 0` for all `v`.\n`DFS(u, p_edge_idx)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue\n    If `ans[e_idx]` is not -1, continue (already assigned)\n\n    If `v` is visited:\n      // This is a cross-edge or forward edge. `v` was visited before `u`.\n      // To maintain DAG, flow must be `v -> u`.\n      `ans[e_idx] = 1` // `v -> u`\n      `balance[u] += c`\n    Else: // `v` is unvisited\n      `DFS(v, e_idx)`\n      // After `DFS(v)` returns, `balance[v]` contains the net flow that needs to be satisfied by `(u, v)`.\n      // If `balance[v]` is positive, `v` needs to send `balance[v]` flow *out* to `u`. So `v -> u`.\n      // If `balance[v]` is negative, `v` needs to receive `|balance[v]|` flow *from* `u`. So `u -> v`.\n      If `balance[v] > 0`:\n        `ans[e_idx] = 1` // `v -> u`\n        `balance[u] += balance[v]`\n      Else (`balance[v] <= 0`):\n        `ans[e_idx] = 0` // `u -> v`\n        `balance[u] += balance[v]` // `balance[v]` is negative, so this subtracts `|balance[v]|` from `balance[u]`\n\nThe only special handling is for node 1. Node 1 cannot have any incoming edges.\nSo, any edge `(u, 1)` must be directed `1 -> u`.\nThis means if `u` is 1, `ans[e_idx]` must be 0.\nThis is implicitly handled by the `balance[v] <= 0` case (if `balance[v]` is negative, `u -> v`).\nIf `u` is 1, `balance[1]` must be 0 at the end.\nThe problem is that `balance[1]` will accumulate the total flow leaving 1.\nThe total flow leaving 1 should be `sum(c_i)` for all `1 -> v` edges.\n\nLet's use `current_excess_flow[v]` which is the sum of flows that *must* leave `v` through its parent edge.\n`DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  `current_excess_flow[u] = 0`. // Initialize flow that must leave `u` via parent.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set, continue.\n\n    If `u == 1`: // All edges from 1 must be outgoing.\n      `ans[e_idx] = 0` (flow `1 -> v`).\n      `current_excess_flow[u] += c`. // 1 sends `c` out.\n      If `v` is unvisited:\n        `DFS(v, e_idx)`.\n        `current_excess_flow[u] += current_excess_flow[v]`. // `v` sends flow to `u`, so `u` has more to send up.\n      // If `v` is visited, it's a cross-edge. `1 -> v` is set. `v`'s `current_excess_flow` is already settled.\n      // No further modification to `current_excess_flow[u]` from `v` is needed.\n    Else if `v` is visited: // `u` is not 1. `v` was visited before `u`.\n      // To maintain DAG, flow must be `v -> u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `current_excess_flow[u] -= c`. // `u` receives `c`, so `u` has less to send out.\n    Else (`v` is unvisited, `u` is not 1):\n      `DFS(v, e_idx)`.\n      If `current_excess_flow[v] > 0`: // `v` needs to send `current_excess_flow[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `current_excess_flow[u] -= current_excess_flow[v]`. // `u` receives, so less to send.\n      Else (`current_excess_flow[v] <= 0`): // `v` needs to receive `|current_excess_flow[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `current_excess_flow[u] -= current_excess_flow[v]`. // `u` sends, so more to send.\n\nThis logic seems more robust. `current_excess_flow[u]` is the net flow `u` needs to send to its parent.\nFor `u = n`, `current_excess_flow[n]` should be `-(Total Flow)`.\nFor `1 < u < n`, `current_excess_flow[u]` should be `0`.\nFor `u = 1`, `current_excess_flow[1]` should be `Total Flow`.\n\nLet's re-trace example 1 with `current_excess_flow` logic:\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n`adj`:\n1: `[(2, 10, 1), (3, 5, 2)]`\n2: `[(3, 10, 0), (1, 10, 1)]`\n3: `[(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F,F,F,F]`, `current_excess_flow = [0,0,0,0]`, `ans = [-1,-1,-1]`\n\n`DFS(1, -1)`:\n  `visited[1] = T`. `current_excess_flow[1] = 0`.\n  Neighbors of 1:\n  1. Edge (1, 2) flow 10, `e_idx = 1`. `v = 2`. `ans[1]` is -1. `u=1`.\n     `ans[1] = 0` (flow `1 -> 2`). `current_excess_flow[1] += 10`. `current_excess_flow = [10,0,0,0]`.\n     `2` is unvisited. `DFS(2, 1)`:\n       `visited[2] = T`. `current_excess_flow[2] = 0`.\n       Neighbors of 2:\n       1. Edge (2, 3) flow 10, `e_idx = 0`. `v = 3`. `ans[0]` is -1. `u=2` (not 1). `3` is unvisited.\n          `DFS(3, 0)`:\n            `visited[3] = T`. `current_excess_flow[3] = 0`.\n            Neighbors of 3:\n            1. Edge (3, 2) flow 10, `e_idx = 0`. This is `p_edge_idx`, skip.\n            2. Edge (3, 1) flow 5, `e_idx = 2`. `v = 1`. `ans[2]` is -1. `u=3` (not 1). `1` is visited.\n               `ans[2] = 1` (flow `1 -> 3` is `0`, flow `3 -> 1` is `1`). So `3 -> 1`.\n               `current_excess_flow[3] -= 5`. `current_excess_flow = [10,0,-5,0]`.\n            `DFS(3, 0)` returns. `current_excess_flow[3] = -5`.\n       Back in `DFS(2, 1)`: `v = 3`, `e_idx = 0`. `ans[0]` is -1. `u=2` (not 1).\n         `current_excess_flow[3] = -5 <= 0`.\n         `ans[0] = 0` (flow `2 -> 3`). `current_excess_flow[2] -= current_excess_flow[3] = -(-5) = 5`.\n         `current_excess_flow = [10,5,-5,0]`.\n       2. Edge (2, 1) flow 10, `e_idx = 1`. This is `p_edge_idx`, skip.\n       `DFS(2, 1)` returns. `current_excess_flow[2] = 5`.\n  Back in `DFS(1, -1)`: `v = 2`, `e_idx = 1`. `ans[1]` is `0` (already set). `u=1`.\n    `current_excess_flow[1] += current_excess_flow[2] = 5`.\n    `current_excess_flow = [15,5,-5,0]`.\n  2. Edge (1, 3) flow 5, `e_idx = 2`. `v = 3`. `ans[2]` is `1` (already set). Skip.\n  `DFS(1, -1)` returns. `current_excess_flow = [15,5,-5,0]`.\n\nFinal `ans`: `[0, 0, 1]`\nThis means:\nEdge 0 (3, 2, 10): `2 -> 3`\nEdge 1 (1, 2, 10): `1 -> 2`\nEdge 2 (3, 1, 5): `3 -> 1`\n\nLet's check balances:\nVertex 1 (source):\n  Outgoing: `1 -> 2` (10).\n  Incoming: `3 -> 1` (5).\n  This still violates `in_1 = 0`.\n\nThe problem is the `v is visited` case. If `v` is visited, it means the edge `(u, v)` forms a cross-edge or a back-edge. To guarantee a DAG, we must direct `v -> u` if `v` was visited before `u`. My code does this.\nThe problem statement \"vertex with number 1 has no incoming edges\" means that for any edge `(X, 1)`, it must be directed `1 -> X`.\nThis means if `v` is 1, and `u` is some other node, the edge `(u, 1)` must be `1 -> u`.\nThis is exactly the case `u != 1`, `v == 1`.\nIf `v == 1` (the source), then the edge `(u, v)` must be directed `1 -> u`.\nSo `ans[e_idx] = 0` (if `u` is `a_i` and `v` is `b_i`, then `a_i -> b_i`).\nAnd `current_excess_flow[u] -= c` (since `u` is sending flow to `1`).\n\nLet's modify the `v is visited` part:\n`DFS(u, p_edge_idx)`:\n  `visited[u] = T`.\n  `current_excess_flow[u] = 0`.\n  For each edge `(u, v)` with index `e_idx` and flow `c`:\n    If `e_idx == p_edge_idx`, continue.\n    If `ans[e_idx]` is already set, continue.\n\n    If `u == 1`: // All edges from 1 must be outgoing.\n      `ans[e_idx] = 0` (flow `1 -> v`).\n      `current_excess_flow[u] += c`.\n      If `v` is unvisited:\n        `DFS(v, e_idx)`.\n        `current_excess_flow[u] += current_excess_flow[v]`.\n    Else if `v == 1`: // `u` is not 1, `v` is 1. Edge must be `1 -> u`.\n      `ans[e_idx] = 0` (flow `1 -> u`).\n      `current_excess_flow[u] -= c`. // `u` receives flow from 1.\n    Else if `v` is visited: // `u` is not 1, `v` is not 1, `v` was visited before `u`.\n      // To maintain DAG, flow must be `v -> u`.\n      `ans[e_idx] = 1` (flow `v -> u`).\n      `current_excess_flow[u] -= c`.\n    Else (`v` is unvisited, `u` is not 1, `v` is not 1):\n      `DFS(v, e_idx)`.\n      If `current_excess_flow[v] > 0`: // `v` needs to send `current_excess_flow[v]` out. So `v -> u`.\n        `ans[e_idx] = 1`.\n        `current_excess_flow[u] -= current_excess_flow[v]`.\n      Else (`current_excess_flow[v] <= 0`): // `v` needs to receive `|current_excess_flow[v]|` in. So `u -> v`.\n        `ans[e_idx] = 0`.\n        `current_excess_flow[u] -= current_excess_flow[v]`.\n\nLet's re-trace example 1 with THIS logic:\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n`adj`:\n1: `[(2, 10, 1), (3, 5, 2)]`\n2: `[(3, 10, 0), (1, 10, 1)]`\n3: `[(2, 10, 0), (1, 5, 2)]`\n\n`visited = [F,F,F,F]`, `current_excess_flow = [0,0,0,0]`, `ans = [-1,-1,-1]`\n\n`DFS(1, -1)`:\n  `visited[1] = T`. `current_excess_flow[1] = 0`.\n  Neighbors of 1:\n  1. Edge (1, 2) flow 10, `e_idx = 1`. `v = 2`. `ans[1]` is -1. `u=1`.\n     `ans[1] = 0` (flow `1 -> 2`). `current_excess_flow[1] += 10`. `current_excess_flow = [10,0,0,0]`.\n     `2` is unvisited. `DFS(2, 1)`:\n       `visited[2] = T`. `current_excess_flow[2] = 0`.\n       Neighbors of 2:\n       1. Edge (2, 3) flow 10, `e_idx = 0`. `v = 3`. `ans[0]` is -1. `u=2` (not 1). `3` is unvisited.\n          `DFS(3, 0)`:\n            `visited[3] = T`. `current_excess_flow[3] = 0`.\n            Neighbors of 3:\n            1. Edge (3, 2) flow 10, `e_idx = 0`. This is `p_edge_idx`, skip.\n            2. Edge (3, 1) flow 5, `e_idx = 2`. `v = 1`. `ans[2]` is -1. `u=3` (not 1). `v=1` is true.\n               `ans[2] = 0` (flow `1 -> 3`). `current_excess_flow[3] -= 5`. `current_excess_flow = [10,0,-5,0]`.\n            `DFS(3, 0)` returns. `current_excess_flow[3] = -5`.\n       Back in `DFS(2, 1)`: `v = 3`, `e_idx = 0`. `ans[0]` is -1. `u=2` (not 1). `v` is not 1. `v` is unvisited before this line.\n         `current_excess_flow[3] = -5 <= 0`.\n         `ans[0] = 0` (flow `2 -> 3`). `current_excess_flow[2] -= current_excess_flow[3] = -(-5) = 5`.\n         `current_excess_flow = [10,5,-5,0]`.\n       2. Edge (2, 1) flow 10, `e_idx = 1`. This is `p_edge_idx`, skip.\n       `DFS(2, 1)` returns. `current_excess_flow[2] = 5`.\n  Back in `DFS(1, -1)`: `v = 2`, `e_idx = 1`. `ans[1]` is `0` (already set). `u=1`.\n    `current_excess_flow[1] += current_excess_flow[2] = 5`.\n    `current_excess_flow = [15,5,-5,0]`.\n  2. Edge (1, 3) flow 5, `e_idx = 2`. `v = 3`. `ans[2]` is `0` (already set). Skip.\n  `DFS(1, -1)` returns. `current_excess_flow = [15,5,-5,0]`.\n\nFinal `ans`: `[0, 0, 0]`\nEdge 0 (3, 2, 10): `2 -> 3`\nEdge 1 (1, 2, 10): `1 -> 2`\nEdge 2 (3, 1, 5): `1 -> 3`\n\nLet's check balances:\nVertex 1 (source):\n  Outgoing: `1 -> 2` (10), `1 -> 3` (5). Total 15.\n  Incoming: None. (Correct!)\nVertex 2:\n  Incoming: `1 -> 2` (10).\n  Outgoing: `2 -> 3` (10).\n  Net flow: `10 - 10 = 0`. (Correct!)\nVertex 3 (sink):\n  Incoming: `1 -> 3` (5), `2 -> 3` (10). Total 15.\n  Outgoing: None.\n  Net flow: `15 - 0 = 15`. (Correct, total flow is 15).\nDAG check:\n1 -> 2\n1 -> 3\n2 -> 3\nThis is a DAG. No cycles.\n\nThis seems to be the correct logic! The `v == 1` case is critical.\nThe `current_excess_flow[u]` at the end of `DFS(u)` represents the net flow that `u` must send *up* to its parent (if positive) or receive *from* its parent (if negative) to satisfy flow conservation for `u` and its children (excluding the parent edge).\nFor `u = 1`, it should be the total flow leaving the source.\nFor `u = n`, it should be `-(Total Flow)` (since `n` is a sink, it receives flow).\nFor `1 < u < n`, it should be `0`.\n\nThe problem also states `n-1 <= m`. The graph is connected.\nThe solution always exists.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Increase recursion limit for deep DFS\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n\n    # ans[i] will store 0 if flow is a_i -> b_i, 1 if b_i -> a_i\n    # Initialize with -1 to indicate not yet assigned\n    ans = [-1] * m\n    \n    # current_excess_flow[v] will store the net flow that 'v' needs to send\n    # to its parent in the DFS tree to satisfy flow conservation within its subtree.\n    # A positive value means 'v' has an excess of outgoing flow from its children/cross-edges\n    # and needs to send this amount up.\n    # A negative value means 'v' has a deficit of outgoing flow and needs to receive\n    # flow from its parent.\n    current_excess_flow = [0] * (n + 1)\n    \n    visited = [False] * (n + 1)\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        \n        # current_excess_flow[u] is initialized to 0 for this node's contribution\n        # from its children/cross-edges. It will accumulate flow that needs to be\n        # passed up to its parent.\n        \n        for v, c, e_idx in adj[u]:\n            if e_idx == p_edge_idx:\n                continue\n            \n            if ans[e_idx] != -1: # This edge has already been directed by another DFS path\n                continue\n\n            if u == 1: # Special case for source node 1: all edges must be outgoing from 1.\n                ans[e_idx] = 0 # Flow 1 -> v\n                current_excess_flow[u] += c # 1 sends flow 'c' out\n                if not visited[v]:\n                    dfs(v, e_idx)\n                    # After DFS(v) returns, current_excess_flow[v] is the net flow 'v' needs to send up.\n                    # If current_excess_flow[v] > 0, v sends flow to u. This flow comes *into* u.\n                    # But u=1 must only have outgoing flow. This means the flow from v to u\n                    # must be balanced by other outgoing flows from u.\n                    # The value current_excess_flow[v] here represents flow that v needs to send to its parent.\n                    # If u is 1, and v is a child, then u is v's parent. So v sends to 1.\n                    # This means 1 receives flow from v. But 1 cannot receive flow.\n                    # This implies current_excess_flow[v] must be 0 if v's parent is 1.\n                    # This part needs to be carefully handled.\n                    # The problem states 1 has no incoming edges. This means any edge (X, 1) must be 1 -> X.\n                    # My logic for u=1 is implicitly setting 1->v.\n                    # The `current_excess_flow[u] += current_excess_flow[v]` part is for passing the balance up the DFS tree.\n                    # If u=1, and v is its child, and v has excess `current_excess_flow[v]`, it needs to send it to 1.\n                    # This means 1 receives `current_excess_flow[v]`. This is problematic for `in_1=0`.\n                    # This means for children of 1, their `current_excess_flow` must be 0.\n                    # This implies that the total flow *out* of 1 must be exactly what leaves its children's subtrees.\n                    # Let's adjust: current_excess_flow[u] += current_excess_flow[v] is correct if v sends flow to u.\n                    # If current_excess_flow[v] is positive, v sends flow to u.\n                    # If current_excess_flow[v] is negative, v needs flow from u.\n                    # The goal is that current_excess_flow[u] becomes 0 for 1 < u < n.\n                    current_excess_flow[u] += current_excess_flow[v]\n                # If v is visited and u=1, it means it's a cross-edge from 1 to an already processed part of 1's DFS tree.\n                # The direction 1->v is set. No further balance adjustment needed for u from v.\n            elif v == 1: # u is not 1, v is 1. Edge must be 1 -> u.\n                # This means the flow is 1 -> u.\n                # If the input edge was (u, 1), ans[e_idx] = 0.\n                # If the input edge was (1, u), ans[e_idx] = 1.\n                # The problem output format is 0 for a_i -> b_i, 1 for b_i -> a_i.\n                # If edge is (a_i, b_i), and 1 is a_i, then 1 -> b_i (ans=0).\n                # If edge is (a_i, b_i), and 1 is b_i, then 1 -> a_i (ans=1).\n                # This is equivalent to saying the flow is from 1 to the other node.\n                \n                # Check original edge direction:\n                original_u, original_v, _ = edges_input[e_idx]\n                if original_u == 1: # Edge was (1, u) or (1, v)\n                    ans[e_idx] = 0 # Flow 1 -> u\n                else: # Edge was (u, 1) or (v, 1)\n                    ans[e_idx] = 1 # Flow 1 -> u\n                \n                # u receives flow 'c' from 1. So u has less to send up.\n                current_excess_flow[u] -= c \n            elif visited[v]: # u is not 1, v is not 1, v was visited before u (cross-edge or forward edge).\n                # To maintain DAG, flow must be v -> u.\n                # Check original edge direction to set ans correctly.\n                original_u, original_v, _ = edges_input[e_idx]\n                if original_u == v: # Edge was (v, u)\n                    ans[e_idx] = 0 # Flow v -> u\n                else: # Edge was (u, v)\n                    ans[e_idx] = 1 # Flow v -> u\n                \n                # u receives flow 'c' from v. So u has less to send up.\n                current_excess_flow[u] -= c\n            else: # v is unvisited, u is not 1, v is not 1 (tree edge).\n                dfs(v, e_idx)\n                # After DFS(v) returns, current_excess_flow[v] is the net flow 'v' needs to send up.\n                if current_excess_flow[v] > 0: # v has excess outgoing flow, needs to send it to u. So v -> u.\n                    # Check original edge direction to set ans correctly.\n                    original_u, original_v, _ = edges_input[e_idx]\n                    if original_u == v: # Edge was (v, u)\n                        ans[e_idx] = 0 # Flow v -> u\n                    else: # Edge was (u, v)\n                        ans[e_idx] = 1 # Flow v -> u\n                    \n                    current_excess_flow[u] -= current_excess_flow[v] # u receives, so less to send.\n                else: # v has deficit or is balanced, needs to receive flow from u. So u -> v.\n                    # Check original edge direction to set ans correctly.\n                    original_u, original_v, _ = edges_input[e_idx]\n                    if original_u == u: # Edge was (u, v)\n                        ans[e_idx] = 0 # Flow u -> v\n                    else: # Edge was (v, u)\n                        ans[e_idx] = 1 # Flow u -> v\n                    \n                    current_excess_flow[u] -= current_excess_flow[v] # u sends, so more to send. (current_excess_flow[v] is negative, so it adds to current_excess_flow[u])\n\n    dfs(1, -1)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Increase recursion limit for deep DFS\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n\n    # ans[i] will store 0 if flow is a_i -> b_i, 1 if b_i -> a_i\n    # Initialize with -1 to indicate not yet assigned\n    ans = [-1] * m\n    \n    # current_excess_flow[v] will store the net flow that 'v' needs to send\n    # to its parent in the DFS tree to satisfy flow conservation within its subtree.\n    # A positive value means 'v' has an excess of outgoing flow from its children/cross-edges\n    # and needs to send this amount up.\n    # A negative value means 'v' has a deficit of outgoing flow and needs to receive\n    # flow from its parent.\n    current_excess_flow = [0] * (n + 1)\n    \n    visited = [False] * (n + 1)\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        \n        # current_excess_flow[u] is initialized to 0 for this node's contribution\n        # from its children/cross-edges. It will accumulate flow that needs to be\n        # passed up to its parent.\n        \n        for v, c, e_idx in adj[u]:\n            if e_idx == p_edge_idx:\n                continue\n            \n            if ans[e_idx] != -1: # This edge has already been directed by another DFS path\n                continue\n\n            if u == 1: # Special case for source node 1: all edges must be outgoing from 1.\n                ans[e_idx] = 0 # Flow 1 -> v\n                current_excess_flow[u] += c # 1 sends flow 'c' out\n                if not visited[v]:\n                    dfs(v, e_idx)\n                    # After DFS(v) returns, current_excess_flow[v] is the net flow 'v' needs to send up.\n                    # If current_excess_flow[v] > 0, v sends flow to u. This flow comes *into* u.\n                    # But u=1 must only have outgoing flow. This means the flow from v to u\n                    # must be balanced by other outgoing flows from u.\n                    # The value current_excess_flow[v] here represents flow that v needs to send to its parent.\n                    # If u is 1, and v is a child, then u is v's parent. So v sends to 1.\n                    # This means 1 receives flow from v. But 1 cannot receive flow.\n                    # This implies current_excess_flow[v] must be 0 if v's parent is 1.\n                    # This part needs to be carefully handled.\n                    # The problem states 1 has no incoming edges. This means any edge (X, 1) must be 1 -> X.\n                    # My logic for u=1 is implicitly setting 1->v.\n                    # The `current_excess_flow[u] += current_excess_flow[v]` part is for passing the balance up the DFS tree.\n                    # If u=1, and v is its child, and v has excess `current_excess_flow[v]`, it needs to send it to 1.\n                    # This means 1 receives `current_excess_flow[v]`. This is problematic for `in_1=0`.\n                    # This means for children of 1, their `current_excess_flow` must be 0.\n                    # This implies that the total flow *out* of 1 must be exactly what leaves its children's subtrees.\n                    # Let's adjust: current_excess_flow[u] += current_excess_flow[v] is correct if v sends flow to u.\n                    # If current_excess_flow[v] is positive, v sends flow to u.\n                    # If current_excess_flow[v] is negative, v needs flow from u.\n                    # The goal is that current_excess_flow[u] becomes 0 for 1 < u < n.\n                    current_excess_flow[u] += current_excess_flow[v]\n                # If v is visited and u=1, it means it's a cross-edge from 1 to an already processed part of 1's DFS tree.\n                # The direction 1->v is set. No further balance adjustment needed for u from v.\n            elif v == 1: # u is not 1, v is 1. Edge must be 1 -> u.\n                # This means the flow is 1 -> u.\n                # If the input edge was (u, 1), ans[e_idx] = 0.\n                # If the input edge was (1, u), ans[e_idx] = 1.\n                # The problem output format is 0 for a_i -> b_i, 1 for b_i -> a_i.\n                # If edge is (a_i, b_i), and 1 is a_i, then 1 -> b_i (ans=0).\n                # If edge is (a_i, b_i), and 1 is b_i, then 1 -> a_i (ans=1).\n                # This is equivalent to saying the flow is from 1 to the other node.\n                \n                # Check original edge direction:\n                original_u, original_v, _ = edges_input[e_idx]\n                if original_u == 1: # Edge was (1, u) or (1, v)\n                    ans[e_idx] = 0 # Flow 1 -> u\n                else: # Edge was (u, 1) or (v, 1)\n                    ans[e_idx] = 1 # Flow 1 -> u\n                \n                # u receives flow 'c' from 1. So u has less to send up.\n                current_excess_flow[u] -= c \n            elif visited[v]: # u is not 1, v is not 1, v was visited before u (cross-edge or forward edge).\n                # To maintain DAG, flow must be v -> u.\n                # Check original edge direction to set ans correctly.\n                original_u, original_v, _ = edges_input[e_idx]\n                if original_u == v: # Edge was (v, u)\n                    ans[e_idx] = 0 # Flow v -> u\n                else: # Edge was (u, v)\n                    ans[e_idx] = 1 # Flow v -> u\n                \n                # u receives flow 'c' from v. So u has less to send up.\n                current_excess_flow[u] -= c\n            else: # v is unvisited, u is not 1, v is not 1 (tree edge).\n                dfs(v, e_idx)\n                # After DFS(v) returns, current_excess_flow[v] is the net flow 'v' needs to send up.\n                if current_excess_flow[v] > 0: # v has excess outgoing flow, needs to send it to u. So v -> u.\n                    # Check original edge direction to set ans correctly.\n                    original_u, original_v, _ = edges_input[e_idx]\n                    if original_u == v: # Edge was (v, u)\n                        ans[e_idx] = 0 # Flow v -> u\n                    else: # Edge was (u, v)\n                        ans[e_idx] = 1 # Flow v -> u\n                    \n                    current_excess_flow[u] -= current_excess_flow[v] # u receives, so less to send.\n                else: # v has deficit or is balanced, needs to receive flow from u. So u -> v.\n                    # Check original edge direction to set ans correctly.\n                    original_u, original_v, _ = edges_input[e_idx]\n                    if original_u == u: # Edge was (u, v)\n                        ans[e_idx] = 0 # Flow u -> v\n                    else: # Edge was (v, u)\n                        ans[e_idx] = 1 # Flow u -> v\n                    \n                    current_excess_flow[u] -= current_excess_flow[v] # u sends, so more to send. (current_excess_flow[v] is negative, so it adds to current_excess_flow[u])\n\n    dfs(1, -1)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 19268,
        "thoughts_token_count": 758
    }
}