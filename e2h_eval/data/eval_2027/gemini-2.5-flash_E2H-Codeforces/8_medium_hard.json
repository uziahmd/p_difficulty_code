{
    "start": 1758015880.0906317,
    "end": 1758015961.1977727,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**My Reasoning for Solving \"Flawed Flow\"**\n\nOkay, here's how I'm thinking about this \"Flawed Flow\" problem.  My goal is a Python solution.\n\nFirst, I need to really understand the problem.  We're given an undirected graph with capacities on each edge.  The task is to direct the edges such that we get a directed acyclic graph (DAG) and the flow is conserved at every vertex except the source (no incoming flow) and sink (no outgoing flow).  We need to output `0` or `1` for each edge, indicating the direction.\n\nThe critical constraints are: `2 <= n <= 2 * 10^5`, `n - 1 <= m <= 2 * 10^5`, and a solution *always* exists. This suggests we're looking at a well-defined structure.\n\nInitially, I'm thinking maximum flow, but the no-cycles constraint is a big hurdle.  That screams topological sort. If we can get a topological ordering of the vertices, we can automatically get a DAG by directing flow from earlier vertices to later ones.\n\nSo, I start by thinking about \"flow conservation.\" For vertices *between* the source and sink, the incoming flow must equal outgoing flow. The source has only outgoing, and the sink only incoming. The guarantee of a solution existing implies that the total outgoing flow from the source must equal the total incoming flow at the sink.\n\nThen, I consider topological ordering. I want a way to build a directed graph where flow goes from earlier to later vertices. But, how do I find this order? Greedily assigning directions could lead to cycles.\n\nI start to focus on node balances. For any non-source/sink vertex, the net flow must be zero. Let's keep a `current_balance` for each vertex. Positive means it's receiving, negative means it's sending. Ideally, `current_balance` becomes zero at all intermediate vertices.\n\nHow do I get the initial flow directions?  Source only outgoing, sink only incoming. I can build an initial balance based on these two nodes. The rest must be balanced.\n\nI consider DFS or BFS. I'm imagining a process where I start at the source and iteratively direct edges, trying to keep those balance values at zero.  But I need to be *really* careful about cycles.\n\nKahn's algorithm for topological sort is something that comes to mind, but in this graph, flow values are important.\n\nI then go down a bit of a tangent, thinking about even/odd sums related to node capacities, trying to understand if there is some hidden property of the total capacities, which I abandoned.\n\nNext, I get back to considering a \"balance\" for each vertex. For intermediate nodes, the incoming and outgoing flow must be equal.\n\nThe problem hints at a specific traversal (DFS). If I start at the source and do DFS, when traversing an edge `(u, v)` I might have to \"balance\" flows at vertices in the middle of the traversal. If a vertex `v` has an imbalance, I might decide to make the flow through edge `(u,v)` in one direction or the other, to resolve the imbalance in `v`. This needs to be handled very carefully to ensure acyclicity.\n\nIf I maintain the current_balance, I see a DFS approach. Imagine going through an edge `(u,v)`. If I go down that path, I might accumulate an \"imbalance\" for vertex `v`. But I need to propagate that imbalance upwards.\n\nThe core idea is: `current_deficit` stores the net *out* flow that is still not set, and needs to be balanced. It is what each vertex needs to send to its parent (in DFS).\n\nI redefine `current_deficit` to be a flow balance. Initial values would be 0 (except at the source and sink). And while doing a DFS, I set the edge's direction so that the sum of the flow remains zero for all non-source/sink nodes.\n\nWhen I traverse an edge `(u, v)`, I'll set its direction, updating the `current_deficit` for vertices `u`, `v`. If the edge I just used connects a vertex that I haven't processed yet, that's fine. If it connects a vertex that I have *already* processed that's trickier. This is when the cycle-checking part comes into play. I believe that since DFS creates a *tree*, the direction of the edges should always be from a node to any of its direct children, thus resulting in an acyclic graph.\n\nI now get a clearer view of the DFS approach: I start from the root vertex 1. I maintain `current_deficit[v] = sum(in_flow) - sum(out_flow)`. In",
    "response": "The problem asks us to assign directions to edges of an undirected graph, given their flow volumes, such that standard max-flow conditions are met: flow conservation at intermediate vertices, no incoming flow to the source (vertex 1), and no cycles in the resulting directed graph. We are guaranteed that a solution always exists.\n\nThe \"no cycles\" condition is crucial. It implies that the resulting directed graph must be a Directed Acyclic Graph (DAG). In a DAG, there exists a topological ordering of vertices. If we can define a consistent ordering for all edges, we can satisfy this condition.\n\nLet's define `current_deficit[v]` for each vertex `v` as the sum of flow values of edges directed *into* `v` minus the sum of flow values of edges directed *out of* `v`.\nThe conditions can be restated as:\n1. For `1 < v < n`, `current_deficit[v]` must be 0 (flow conservation).\n2. For `v = 1` (source), `current_deficit[1]` must be `sum(outgoing flow) - sum(incoming flow) = -F_total`, where `F_total` is the total flow from source to sink. Since there are no incoming edges, `current_deficit[1]` represents `0 - F_total`.\n3. For `v = n` (sink), `current_deficit[n]` must be `sum(incoming flow) - sum(outgoing flow) = F_total`. Since there are no outgoing edges, `current_deficit[n]` represents `F_total - 0`.\n\nWe can use a Depth First Search (DFS) traversal starting from the source (vertex 1) to determine the directions. The DFS approach naturally helps in constructing a DAG. When traversing an edge `(u, v)`:\n- If `v` is not visited, it's a tree edge. We recursively call DFS on `v`.\n- If `v` is visited and `v` is not the parent `p` of `u` in the DFS tree, it's a back-edge or cross-edge. To maintain acyclicity, flow must always go from a node that was visited later in the DFS to a node that was visited earlier. This means if `v` was visited before `u` (and `v` is not `p`), we must direct the edge `u -> v`.\n\nLet's refine the DFS logic:\n`dfs(u, p)`:\n1. Mark `u` as visited.\n2. Initialize `current_deficit[u] = 0`. This variable will accumulate the net flow `u` receives from its children in the DFS tree and from any back/cross edges it directs.\n3. For each neighbor `v` of `u` connected by an edge `(u, v)` with flow `c` (and original index `edge_idx`):\n    a. If `v == p`, skip this edge (it's the edge leading back to the parent).\n    b. If `v` is already visited:\n        This is a back-edge or cross-edge. To avoid cycles, we must direct flow from `u` to `v`.\n        Set `ans[edge_idx]` to `0` (if `u` was the first endpoint in input) or `1` (if `v` was the first endpoint).\n        Update `current_deficit[u] -= c` (since `u` sends `c` flow out).\n    c. If `v` is not visited:\n        Recursively call `dfs(v, u)`.\n        After `dfs(v, u)` returns, `current_deficit[v]` holds the net flow `v` needs to send up to `u` (if positive) or receive from `u` (if negative).\n        - If `current_deficit[v] > 0`: `v` has an excess of incoming flow from its subtree. It must send this flow to `u`. So, direct `v -> u`.\n          Set `ans[edge_idx]` to `1` (if `u` was the first endpoint) or `0` (if `v` was the first endpoint).\n          Update `current_deficit[u] += current_deficit[v]` (since `u` receives `current_deficit[v]` flow).\n        - If `current_deficit[v] <= 0`: `v` has a deficit or is balanced. It must receive `abs(current_deficit[v])` flow from `u`. So, direct `u -> v`.\n          Set `ans[edge_idx]` to `0` (if `u` was the first endpoint) or `1` (if `v` was the first endpoint).\n          Update `current_deficit[u] += current_deficit[v]` (since `u` sends `abs(current_deficit[v])` flow out, `current_deficit[u]` decreases by this amount).\n\nThe base case for the recursion is when a leaf node `u` is reached or all its unvisited neighbors have been processed. At this point, `current_deficit[u]` will represent the net flow `u` needs to balance with its parent `p`.\n\nThe problem guarantees a solution exists, which implies that `current_deficit[v]` for `1 < v < n` will be 0 after all its incident edges are processed, and `current_deficit[1]` and `current_deficit[n]` will hold the total flow `F_total` and `-F_total` respectively, as required.\n\n**Implementation Details:**\n- Adjacency list: `adj[u]` stores tuples `(v, c, edge_idx, u_is_first)`. `u_is_first` is a boolean indicating if `u` was the first vertex in the input for this edge. This helps in correctly setting `0` or `1` for `ans`.\n- `visited` array: to keep track of visited nodes during DFS.\n- `current_deficit` array: to store the flow balance for each node.\n- `ans` array: to store the final directions.\n\nThe DFS should start from vertex 1.\n\n```python\nimport sys\n\n# Increase recursion limit for deep DFS\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        # Store (neighbor, capacity, original_edge_index, is_u_first_in_input)\n        adj[u].append((v, c, i, True))\n        adj[v].append((u, c, i, False))\n\n    ans = [0] * m\n    visited = [False] * (n + 1)\n    current_deficit = [0] * (n + 1) # sum(incoming_flow) - sum(outgoing_flow)\n\n    def dfs(u, p):\n        visited[u] = True\n        \n        # Iterate over a copy to allow modification of adj list if needed (though not strictly necessary here)\n        # Or, more simply, use a standard loop and rely on visited array.\n        for i in range(len(adj[u])):\n            v, c, edge_idx, u_is_first = adj[u][i]\n            \n            if v == p:\n                continue\n\n            if visited[v]:\n                # This is a back-edge or cross-edge.\n                # To ensure acyclicity, flow must go from u to v.\n                # The node visited earlier (v) receives flow from the node visited later (u).\n                # This ensures topological order.\n                \n                # Direct u -> v\n                if u_is_first:\n                    ans[edge_idx] = 0 # u -> v\n                else:\n                    ans[edge_idx] = 1 # v -> u (but we want u -> v, so flip)\n                \n                current_deficit[u] -= c # u sends c flow out\n            else:\n                # Tree edge. Recurse on v.\n                dfs(v, u)\n                \n                # After dfs(v, u) returns, current_deficit[v] holds the net flow\n                # that v (and its subtree) needs to balance with u.\n                if current_deficit[v] > 0:\n                    # v has excess incoming flow, so v must send flow to u.\n                    # Direct v -> u\n                    if u_is_first:\n                        ans[edge_idx] = 1 # u was first, so v -> u is 1\n                    else:\n                        ans[edge_idx] = 0 # v was first, so v -> u is 0\n                    current_deficit[u] += current_deficit[v] # u receives flow from v\n                else:\n                    # v has a deficit or is balanced. u must send flow to v.\n                    # Direct u -> v\n                    if u_is_first:\n                        ans[edge_idx] = 0 # u was first, so u -> v is 0\n                    else:\n                        ans[edge_idx] = 1 # v was first, so u -> v is 1\n                    current_deficit[u] += current_deficit[v] # u sends flow to v (deficit decreases u's balance)\n        \n        # For non-source/sink nodes, current_deficit[u] must be 0.\n        # The DFS ensures this by balancing flow up the tree.\n        # For source (1) and sink (n), their deficits will reflect total flow.\n\n    # Start DFS from source (vertex 1) with no parent (0).\n    dfs(1, 0)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\n# Increase recursion limit for deep DFS\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        # Store (neighbor, capacity, original_edge_index, is_u_first_in_input)\n        adj[u].append((v, c, i, True))\n        adj[v].append((u, c, i, False))\n\n    ans = [0] * m\n    visited = [False] * (n + 1)\n    current_deficit = [0] * (n + 1) # sum(incoming_flow) - sum(outgoing_flow)\n\n    def dfs(u, p):\n        visited[u] = True\n        \n        # Iterate over a copy to allow modification of adj list if needed (though not strictly necessary here)\n        # Or, more simply, use a standard loop and rely on visited array.\n        for i in range(len(adj[u])):\n            v, c, edge_idx, u_is_first = adj[u][i]\n            \n            if v == p:\n                continue\n\n            if visited[v]:\n                # This is a back-edge or cross-edge.\n                # To ensure acyclicity, flow must go from u to v.\n                # The node visited earlier (v) receives flow from the node visited later (u).\n                # This ensures topological order.\n                \n                # Direct u -> v\n                if u_is_first:\n                    ans[edge_idx] = 0 # u -> v\n                else:\n                    ans[edge_idx] = 1 # v -> u (but we want u -> v, so flip)\n                \n                current_deficit[u] -= c # u sends c flow out\n            else:\n                # Tree edge. Recurse on v.\n                dfs(v, u)\n                \n                # After dfs(v, u) returns, current_deficit[v] holds the net flow\n                # that v (and its subtree) needs to balance with u.\n                if current_deficit[v] > 0:\n                    # v has excess incoming flow, so v must send flow to u.\n                    # Direct v -> u\n                    if u_is_first:\n                        ans[edge_idx] = 1 # u was first, so v -> u is 1\n                    else:\n                        ans[edge_idx] = 0 # v was first, so v -> u is 0\n                    current_deficit[u] += current_deficit[v] # u receives flow from v\n                else:\n                    # v has a deficit or is balanced. u must send flow to v.\n                    # Direct u -> v\n                    if u_is_first:\n                        ans[edge_idx] = 0 # u was first, so u -> v is 0\n                    else:\n                        ans[edge_idx] = 1 # v was first, so u -> v is 1\n                    current_deficit[u] += current_deficit[v] # u sends flow to v (deficit decreases u's balance)\n        \n        # For non-source/sink nodes, current_deficit[u] must be 0.\n        # The DFS ensures this by balancing flow up the tree.\n        # For source (1) and sink (n), their deficits will reflect total flow.\n\n    # Start DFS from source (vertex 1) with no parent (0).\n    dfs(1, 0)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 2242,
        "thoughts_token_count": 7864
    }
}