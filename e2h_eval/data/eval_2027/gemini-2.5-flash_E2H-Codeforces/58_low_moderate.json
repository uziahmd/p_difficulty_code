{
    "start": 1758284910.0806806,
    "end": 1758284979.4369438,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Finding Minimum Edges for Odd Cycle Formation**\n\nOkay, so I'm tackling a graph problem, and I need to figure out the fewest edges, `t`, to add to a graph to create a simple, odd-length cycle, and also the number of ways, `w`, to do this. My initial thought process revolves around graph properties, particularly odd cycles and their relationship to graph components.\n\nFirst, I realize that a graph containing an odd cycle is the key. If it *already* has one, `t` is simply zero, and `w` is one – a trivial case. I need to check for this quickly, probably through a Breadth-First Search or Depth-First Search for a bipartite check. If the graph is bipartite, then no odd cycle currently exists.\n\nNow, if it's bipartite, meaning all components are bipartite, then I need to start thinking about adding edges. The goal is an odd cycle. This means I need to figure out what values `t` can take on.\n\nIf the original graph does not have an odd cycle, `t` will be greater than 0. The minimum will most likely be `t=1`, and I need to prove this.  How can adding an edge create an odd cycle? By connecting vertices within the same partition of a bipartite component.  This is because the path between them in the original bipartite component would be even length, and adding the edge would make the cycle odd.\n\nCan I always achieve `t = 1`? If a component has at least three vertices, I know I'm good. At least one partition must have at least two vertices, and connecting them will create an odd cycle.\n\nSo, to summarize, I'll need to first check if an odd cycle is present already. If not, then the minimum `t` is 1 if there exists a connected component in the graph with at least 3 nodes, and 0 otherwise.\n\nTo find the number of ways, `w`, for the case `t=1`, I'll sum the number of ways to pick two vertices in the same color class across all the connected components (which is combination of size 2). This should give me the number of ways to achieve the odd cycle. I will need to be careful with handling the special case where a connected component is simply an isolated node, in this case, the `w` is 0.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. Therefore, we can use a 2-coloring algorithm (like BFS or DFS) to determine if the graph (or any of its connected components) already contains an odd cycle.\n\nLet's analyze the cases based on the value of `t`:\n\n**Case 1: `t = 0`**\nIf the graph already contains an odd cycle, then `t = 0`. There is only `w = 1` way to form such a cycle (by not adding any edges, as it already exists).\nTo check this, we can perform a BFS/DFS based 2-coloring. Iterate through all unvisited vertices. For each such vertex, start a BFS/DFS:\n1. Assign the starting vertex color 0.\n2. For each neighbor `v` of a current vertex `u`:\n   a. If `v` is uncolored, assign it the opposite color of `u` and add it to the queue/stack.\n   b. If `v` is colored and has the same color as `u`, then we have found an odd cycle. In this case, `t=0, w=1`. We can stop and print this result.\nIf the entire graph is traversed and no such conflict is found, then the graph is bipartite.\n\n**Case 2: `t > 0`**\nIf the graph is bipartite (all its connected components are bipartite), we need to add edges to create an odd cycle.\nAn odd cycle is formed when an edge connects two vertices of the same color in a bipartite graph.\n\n**Subcase 2.1: `t = 1`**\nWe can form an odd cycle by adding a single edge if there exist two distinct vertices `u` and `v` that are in the same connected component and are assigned the same color by the 2-coloring algorithm. Adding an edge `(u, v)` would create an odd cycle.\nThis is possible if and only if there is at least one connected component that has at least 3 vertices. (If a component has 1 or 2 vertices, say `V_0 = {a}, V_1 = {b}`, we cannot pick two vertices of the same color).\nIf a component `C` has partitions `V_0` and `V_1`, the number of ways to add an edge within `C` to form an odd cycle is `|V_0| * (|V_0| - 1) / 2 + |V_1| * (|V_1| - 1) / 2`.\nIf any component has `|V_0| >= 2` or `|V_1| >= 2`, we can form an odd cycle with `t=1`.\nThe total number of ways `w` for `t=1` would be the sum of these counts over all connected components.\nIf `w > 0` from this calculation, then `t=1`.\n\n**Subcase 2.2: `t = 2`**\nIf `t` is not 0 or 1, it means all connected components are paths or isolated vertices (i.e., `|V_0| <= 1` and `|V_1| <= 1` for all components). This implies all components have at most 2 vertices.\nIn this scenario, we cannot form an odd cycle by adding a single edge within any component.\nWe must add an edge between two different connected components.\nIf we add an edge `(u, v)` where `u` is in component `C_i` and `v` is in component `C_j` (`i != j`), this effectively merges `C_i` and `C_j`. The resulting merged component is still bipartite if `color(u) != color(v)`.\nTo form an odd cycle with `t=2` edges:\nWe need to pick two distinct connected components, say `C_i` and `C_j`. Let `u_i` be a vertex in `C_i` and `u_j` be a vertex in `C_j`. We add an edge `(u_i, u_j)`. This merges them into a larger bipartite component.\nNow we need to add another edge to form an odd cycle. This means adding an edge between two vertices of the same color in this newly merged component.\nThe simplest way to guarantee an odd cycle is to pick two vertices `u, v` from different components `C_i, C_j` and add two edges `(u, v)` and `(u, v')` where `v'` is also in `C_j` and `color(v') == color(v)`. This is not possible if `C_j` has only one vertex of that color.\nA more robust approach for `t=2`:\nPick two distinct components `C_i` and `C_j`. Pick a vertex `u` from `C_i` and a vertex `v` from `C_j`. Add edge `(u, v)`. Now we have a new merged component.\nTo form an odd cycle, we need to add another edge `(x, y)` such that `x` and `y` are of the same color in the merged component.\nIf we have at least 3 components, say `C_1, C_2, C_3`. Pick `u_1 \\in C_1`, `u_2 \\in C_2`, `u_3 \\in C_3`. Add edges `(u_1, u_2)` and `(u_2, u_3)`. If `color(u_1) == color(u_3)`, then `u_1 - u_2 - u_3` forms a path of length 2, and adding `(u_1, u_3)` would form an odd cycle. But we are only adding 2 edges.\nThe cycle `u_1 - u_2 - u_3 - u_1` is an odd cycle (length 3).\nThis means we need to pick three vertices `u_1, u_2, u_3` from three *distinct* connected components `C_1, C_2, C_3`. Add edges `(u_1, u_2)` and `(u_2, u_3)`. The path `u_1 - u_2 - u_3` has length 2. If `color(u_1) == color(u_3)`, then we have formed an odd cycle of length 3 using 2 edges.\nThe number of ways `w` for `t=2` would be `N_C * (N_C - 1) * (N_C - 2) / 2 * 2` where `N_C` is the number of connected components. Each component has 2 choices for vertex color (0 or 1).\nFor each component `C_k`, we can pick either `v_{k,0}` (color 0) or `v_{k,1}` (color 1).\nWe need to select 3 components `C_i, C_j, C_k`.\nPick `u_i \\in C_i`, `u_j \\in C_j`, `u_k \\in C_k`. Add edges `(u_i, u_j)` and `(u_j, u_k)`.\nThis creates a path `u_i - u_j - u_k`. This forms an odd cycle if `u_i` and `u_k` are of the same color.\nThis means we need to pick `u_i` and `u_k` to be of the same color, and `u_j` to be of the opposite color.\nThe number of ways to pick three components `C_i, C_j, C_k` is `N_C * (N_C - 1) * (N_C - 2)`.\nFor each component, there's only one vertex of color 0 and one vertex of color 1 (since we are in the `t=2` case, components have at most 2 vertices).\nSo for `C_i`, `C_j`, `C_k`, we pick `v_{i,0}`, `v_{j,1}`, `v_{k,0}`. Add `(v_{i,0}, v_{j,1})` and `(v_{j,1}, v_{k,0})`. This forms an odd cycle `v_{i,0} - v_{j,1} - v_{k,0} - v_{i,0}`.\nThe number of ways to choose 3 components is `N_C * (N_C - 1) * (N_C - 2)`.\nFor each choice, we pick `v_{i,0}, v_{j,1}, v_{k,0}` or `v_{i,1}, v_{j,0}, v_{k,1}`. There are 2 such choices for colors.\nSo `w = N_C * (N_C - 1) * (N_C - 2) * 2`. But this counts ordered triples. We need unordered sets of edges.\nThe edges are `(u_i, u_j)` and `(u_j, u_k)`.\nThis counting is getting tricky. Let's simplify.\nIf we have `N_C` components, each of size 1 or 2.\nWe need to connect 3 vertices from 3 distinct components to form a `C_3`.\nNumber of ways to choose 3 components: `N_C * (N_C - 1) * (N_C - 2) / 6`.\nFor each set of 3 components, say `C_a, C_b, C_c`.\nEach component `C_x` has vertices `v_{x,0}` and `v_{x,1}` (if it's size 2) or just `v_{x,0}` (if size 1, then `v_{x,1}` is `None`).\nWe need to pick `u_a \\in C_a`, `u_b \\in C_b`, `u_c \\in C_c` such that `color(u_a) = color(u_c)` and `color(u_b) != color(u_a)`.\nThere are 2 ways to assign the colors for this pattern (e.g., `(0, 1, 0)` or `(1, 0, 1)`).\nFor each component `C_x`, if it's a single vertex, say `v_{x,0}`, we must pick that vertex. If it's two vertices `v_{x,0}, v_{x,1}`, we can pick either.\nSince we are in the `t=2` case, all components are size 1 or 2.\nIf a component is size 1, say `v_0`, then `v_1` is not available.\nIf a component is size 2, say `v_0, v_1`, both are available.\nLet `N_1` be the number of components of size 1, and `N_2` be the number of components of size 2.\n`N_C = N_1 + N_2`.\nFor `t=2`, we need to pick 3 vertices `u_1, u_2, u_3` from 3 distinct components `C_1, C_2, C_3`.\nAdd edges `(u_1, u_2)` and `(u_2, u_3)`. This forms an odd cycle `u_1 - u_2 - u_3 - u_1` if `color(u_1) = color(u_3)`.\nThe number of ways to pick 3 vertices `u_1, u_2, u_3` from distinct components `C_1, C_2, C_3` such that `color(u_1) = color(u_3)` and `color(u_2) != color(u_1)`:\n- Choose 3 components: `N_C * (N_C - 1) * (N_C - 2)`.\n- For each component `C_i`, it has vertices `v_{i,0}` and `v_{i,1}` (if size 2).\n- We need to choose colors `(c, 1-c, c)` for `u_1, u_2, u_3`.\n- For each chosen component, say `C_x`, if it's size 1, we must pick its single vertex (which has a fixed color). If it's size 2, we can pick either vertex (0 or 1).\nThis is getting complicated. Let's consider `t=2` only if `N_C >= 3`.\nIf `N_C < 3`, we cannot form a `C_3` by connecting 3 components.\nIf `N_C = 0, 1, 2`, we cannot form an odd cycle with `t=2`.\n\n**Subcase 2.3: `t = 3`**\nThis happens if `N_C < 3` (specifically, `N_C = 0, 1, 2`).\nIf `N_C = 0` (empty graph), we need to add 3 vertices and 3 edges to form a `C_3`. `t=3, w=1` (only 1 way to form a C3 on 3 new vertices).\nIf `N_C = 1`. One component `C_1`. It must be size 1 or 2.\nIf `C_1` has size 1 (just `v_1`), we need to add 2 new vertices `v_2, v_3` and 3 edges `(v_1, v_2), (v_2, v_3), (v_3, v_1)`. This forms a `C_3`. `t=3, w=1`.\nIf `C_1` has size 2 (`v_1, v_2`), we need to add 1 new vertex `v_3` and 3 edges `(v_1, v_3), (v_2, v_3), (v_1, v_2)`. This forms a `C_3`. `t=3, w=1`.\nIf `N_C = 2`. Two components `C_1, C_2`. Each is size 1 or 2.\nWe need to add 3 edges to form an odd cycle.\nPick `u_1 \\in C_1`, `u_2 \\in C_2`. Add edge `(u_1, u_2)`. Now we have one merged component.\nWe need to add 2 more edges to form an odd cycle. This means adding a vertex `v_3` and edges `(u_1, v_3), (u_2, v_3)`. This forms a `C_3`. `t=3, w=1`.\nIn all these `t=3` scenarios, `w=1`.\n\nSummary of logic:\n1. Initialize `colors` array to -1 (uncolored). `has_odd_cycle = False`. `comp_sizes = []`. `comp_bipartition_counts = []`.\n2. Iterate `i` from 1 to `n`:\n   If `i` is uncolored:\n     Start BFS from `i`.\n     `current_comp_nodes = 0`. `count0 = 0`. `count1 = 0`.\n     Queue `q`. Add `(i, 0)` to `q`. `colors[i] = 0`.\n     While `q` not empty:\n       `u, color_u = q.pop_front()`.\n       `current_comp_nodes += 1`.\n       If `color_u == 0`, `count0 += 1`. Else `count1 += 1`.\n       For each neighbor `v` of `u`:\n         If `colors[v] == -1`: `colors[v] = 1 - color_u`. `q.push_back((v, 1 - color_u))`.\n         Else if `colors[v] == color_u`: `has_odd_cycle = True`.\n     `comp_sizes.append(current_comp_nodes)`.\n     `comp_bipartition_counts.append((count0, count1))`.\n\n3. After checking all components:\n   If `has_odd_cycle` is `True`: Print `0 1`.\n   Else (`graph is bipartite`):\n     `t1_ways = 0`.\n     For each `(count0, count1)` in `comp_bipartition_counts`:\n       `t1_ways += count0 * (count0 - 1) // 2`.\n       `t1_ways += count1 * (count1 - 1) // 2`.\n     If `t1_ways > 0`: Print `1 t1_ways`.\n     Else (`t=1` is not possible, all components have size at most 2):\n       `num_components = len(comp_sizes)`.\n       `num_isolated_vertices = 0`.\n       `num_edges_components = 0`.\n       For `s` in `comp_sizes`:\n         If `s == 1`: `num_isolated_vertices += 1`.\n         Else (`s == 2`): `num_edges_components += 1`. (These are components that are single edges)\n\n       If `num_components >= 3`:\n         `t2_ways = num_components * (num_components - 1) * (num_components - 2) // 2`\n         Print `2 t2_ways`.\n       Else (`num_components < 3`): Print `3 1`.\n\nLet's recheck the `t=2` calculation.\nIf `t=1` is not possible, all components are either isolated vertices (size 1) or single edges (size 2).\nLet `k` be the number of connected components.\nIf `k >= 3`: We can pick 3 distinct components, say `C_i, C_j, C_k`.\nPick a vertex `u_i` from `C_i`, `u_j` from `C_j`, `u_k` from `C_k`.\nAdd edges `(u_i, u_j)` and `(u_j, u_k)`.\nThis forms a path `u_i - u_j - u_k`.\nThe cycle `u_i - u_j - u_k - u_i` will be an odd cycle if `u_i` and `u_k` have the same color.\nSince all components are bipartite (size 1 or 2), each vertex has a determined color (0 or 1).\nIf `C_x` is a single vertex `v_x`, then `color(v_x)` is fixed.\nIf `C_x` is an edge `(v_{x0}, v_{x1})`, then `color(v_{x0}) = 0` and `color(v_{x1}) = 1` (or vice versa).\nTo form an odd cycle `u_i - u_j - u_k - u_i` (length 3), we need `color(u_i) = color(u_k)` and `color(u_j) \\neq color(u_i)`.\nWe choose 3 components `C_i, C_j, C_k`. There are `k * (k-1) * (k-2) / 6` ways to choose the set of 3 components.\nFor each set of 3 components, say `C_a, C_b, C_c`:\nWe need to assign roles: one component provides `u_1`, one `u_2`, one `u_3`. There are `3!` ways to assign roles.\nLet's fix `C_a, C_b, C_c`.\nWe need to pick `u_a \\in C_a`, `u_b \\in C_b`, `u_c \\in C_c`.\nAnd edges `(u_a, u_b)` and `(u_b, u_c)`.\nThe cycle `u_a - u_b - u_c - u_a` is odd if `color(u_a) = color(u_c)`.\nFor each component `C_x`, it has a `v_{x,0}` and `v_{x,1}` (if size 2).\nNumber of ways to pick `u_a, u_b, u_c` such that `color(u_a) = color(u_c)` and `color(u_b) \\neq color(u_a)`:\nWe can choose `color(u_a) = 0`, `color(u_b) = 1`, `color(u_c) = 0`.\nNumber of ways to pick `u_a` of color 0 from `C_a`: `(number of vertices of color 0 in C_a)`. Let this be `cnt_0(C_a)`.\nSimilarly `cnt_1(C_a)`.\nSince all components are size 1 or 2:\nIf `C_x` is size 1 (isolated vertex), say `v_x`. Then `cnt_0(C_x)=1, cnt_1(C_x)=0` or `cnt_0(C_x)=0, cnt_1(C_x)=1`.\nIf `C_x` is size 2 (single edge), say `(v_{x0}, v_{x1})`. Then `cnt_0(C_x)=1, cnt_1(C_x)=1`.\nSo, `cnt_0(C_x)` is either 1 or 0, and `cnt_1(C_x)` is either 1 or 0.\nFor any component `C_x`, we can choose a vertex of color 0 if `cnt_0(C_x) == 1`.\nWe can choose a vertex of color 1 if `cnt_1(C_x) == 1`.\nFor the pattern `(0, 1, 0)`: `cnt_0(C_a) * cnt_1(C_b) * cnt_0(C_c)` ways.\nFor the pattern `(1, 0, 1)`: `cnt_1(C_a) * cnt_0(C_b) * cnt_1(C_c)` ways.\nSum these up over all permutations of `(C_a, C_b, C_c)`.\nThis is exactly `k * (k-1) * (k-2)` ways to choose ordered `(C_a, C_b, C_c)` and ordered `(u_a, u_b, u_c)` from them.\nSince for each component, there is exactly one vertex of color 0 and one of color 1 (if size 2), or one vertex of one color (if size 1), the product `cnt_0(C_a) * cnt_1(C_b) * cnt_0(C_c)` is either 0 or 1.\nThe total number of ways is `k * (k-1) * (k-2) * 2`.\nThis is because for each ordered triple of components, say `C_i, C_j, C_k`, we can pick `u_i` of color 0, `u_j` of color 1, `u_k` of color 0. Or `u_i` of color 1, `u_j` of color 0, `u_k` of color 1.\nEach component has at least one vertex of color 0 and at least one of color 1 (if size 2), or one vertex of a specific color (if size 1).\nThe crucial part is that `k * (k-1) * (k-2)` is the number of ordered triples of distinct components. For each such triple, we can choose the colors `(0,1,0)` or `(1,0,1)`.\nFor example, if `C_i` has `v_{i,0}`, `C_j` has `v_{j,0}, v_{j,1}`, `C_k` has `v_{k,1}`.\nThen for `(0,1,0)` we pick `v_{i,0}, v_{j,1}, \\text{no } v_{k,0}` (0 ways).\nFor `(1,0,1)` we pick `\\text{no } v_{i,1}, v_{j,0}, v_{k,1}` (0 ways).\nThis means that `k * (k-1) * (k-2)` is not correct.\nLet `N_0` be the total number of vertices colored 0 across all components.\nLet `N_1` be the total number of vertices colored 1 across all components.\nFor `t=2`, we need to pick 3 vertices `u_a, u_b, u_c` from 3 distinct components.\nEdges `(u_a, u_b)` and `(u_b, u_c)`.\nThe number of ways to pick `u_a, u_b, u_c` such that `color(u_a) = color(u_c) = 0` and `color(u_b) = 1` is `N_0 * N_1 * (N_0 - 1)`.\nThe number of ways to pick `u_a, u_b, u_c` such that `color(u_a) = color(u_c) = 1` and `color(u_b) = 0` is `N_1 * N_0 * (N_1 - 1)`.\nTotal `w = N_0 * N_1 * (N_0 - 1) + N_1 * N_0 * (N_1 - 1)`.\nThis is correct. `N_0` is the sum of `count0`s, `N_1` is the sum of `count1`s.\nSince `t=1` is not possible, all `count0 <= 1` and `count1 <= 1`.\nSo `N_0` is the number of components that have a vertex of color 0.\n`N_1` is the number of components that have a vertex of color 1.\nIf a component is size 1, it contributes 1 to `N_0` or `N_1`.\nIf a component is size 2, it contributes 1 to `N_0` and 1 to `N_1`.\nSo `N_0` is `num_isolated_vertices_color0 + num_edges_components`.\nAnd `N_1` is `num_isolated_vertices_color1 + num_edges_components`.\nThis means `N_0` and `N_1` can be different.\n`num_isolated_vertices_color0 + num_isolated_vertices_color1 = num_isolated_vertices`.\nThe total number of vertices `n = N_0 + N_1`.\nSo `t=2` calculation: `w = N_0 * N_1 * (N_0 - 1) + N_1 * N_0 * (N_1 - 1)`.\n\nFinal algorithm:\n1. Initialize `colors` array of size `n+1` to -1. `has_odd_cycle = False`.\n2. `component_info = []` (list of `(count0, count1)` for each component).\n3. For `i` from 1 to `n`:\n   If `colors[i] == -1`:\n     `current_count0 = 0`, `current_count1 = 0`.\n     `q = collections.deque([(i, 0)])`.\n     `colors[i] = 0`.\n     `is_bipartite_comp = True`.\n     `component_nodes = []` (to store nodes of current component for checking isolated vertices).\n     While `q`:\n       `u, color_u = q.popleft()`.\n       `component_nodes.append(u)`.\n       If `color_u == 0`: `current_count0 += 1`.\n       Else: `current_count1 += 1`.\n       For `v` in `adj[u]`:\n         If `colors[v] == -1`:\n           `colors[v] = 1 - color_u`.\n           `q.append((v, 1 - color_u))`.\n         Else if `colors[v] == color_u`:\n           `has_odd_cycle = True`.\n           `is_bipartite_comp = False`.\n     If `is_bipartite_comp`:\n       `component_info.append((current_count0, current_count1))`.\n     # If not bipartite, we don't care about its counts, because t=0.\n\n4. If `has_odd_cycle`:\n   Print `0 1`.\n5. Else (`graph is bipartite`):\n   `t1_ways = 0`.\n   For `c0, c1` in `component_info`:\n     `t1_ways += c0 * (c0 - 1) // 2`.\n     `t1_ways += c1 * (c1 - 1) // 2`.\n   If `t1_ways > 0`:\n     Print `1 t1_ways`.\n   Else (`t=1` is not possible, all components have size at most 2):\n     `total_count0 = 0`.\n     `total_count1 = 0`.\n     For `c0, c1` in `component_info`:\n       `total_count0 += c0`.\n       `total_count1 += c1`.\n     `t2_ways = total_count0 * total_count1 * (total_count0 - 1) + total_count1 * total_count0 * (total_count1 - 1)`.\n     If `t2_ways > 0`:\n       Print `2 t2_ways`.\n     Else (`t=2` is not possible, i.e. `total_count0 < 2` or `total_count1 < 2` or `total_count0 * total_count1 == 0`):\n       Print `3 1`.\n\nExample 1:\n4 4\n1 2\n1 3\n4 2\n4 3\nAdj: 1:[2,3], 2:[1,4], 3:[1,4], 4:[2,3]\nBFS from 1:\n1(0)\n  2(1), 3(1)\n    2: 1(0)-ok, 4(0)\n    3: 1(0)-ok, 4(0)\n      4: 2(1)-ok, 3(1)-ok\nWait, when 4 is colored 0. Its neighbors are 2 and 3.\ncolors[2]=1, colors[3]=1. colors[4]=0.\nWhen processing 4, we see 2 (color 1) and 3 (color 1). Both are different from 0. OK.\nThis graph is bipartite. Partitions: {1,4} and {2,3}.\nComponent info: (2,2)\nt1_ways = 2*(2-1)//2 + 2*(2-1)//2 = 1 + 1 = 2.\nOutput: 1 2. Correct.\n\nExample 2:\n3 3\n1 2\n2 3\n3 1\nAdj: 1:[2,3], 2:[1,3], 3:[2,1]\nBFS from 1:\n1(0)\n  2(1), 3(1)\n    2: 1(0)-ok, 3(1). colors[3]=1. current_color_u=1. colors[3]=1. Conflict! has_odd_cycle = True.\nOutput: 0 1. Correct.\n\nExample 3:\n3 0\nAdj: empty\nBFS from 1: 1(0). comp_info: (1,0)\nBFS from 2: 2(0). comp_info: (1,0), (1,0)\nBFS from 3: 3(0). comp_info: (1,0), (1,0), (1,0)\nhas_odd_cycle = False.\nt1_ways = 0 (since all counts are 1 or 0).\ntotal_count0 = 1+1+1 = 3.\ntotal_count1 = 0+0+0 = 0.\nt2_ways = 3 * 0 * (3-1) + 0 * 3 * (0-1) = 0.\nOutput: 3 1. Correct.\n\nThe logic seems sound.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1)  # -1: uncolored, 0: color 0, 1: color 1\n    has_odd_cycle = False\n    component_info = []  # Stores (count0, count1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            # Start BFS for a new connected component\n            current_count0 = 0\n            current_count1 = 0\n            q = collections.deque([(i, 0)])\n            colors[i] = 0\n            is_bipartite_comp = True\n\n            nodes_in_comp = 0\n            \n            while q:\n                u, color_u = q.popleft()\n                nodes_in_comp += 1\n\n                if color_u == 0:\n                    current_count0 += 1\n                else:\n                    current_count1 += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - color_u\n                        q.append((v, 1 - color_u))\n                    elif colors[v] == color_u:\n                        has_odd_cycle = True\n                        is_bipartite_comp = False\n            \n            if is_bipartite_comp:\n                component_info.append((current_count0, current_count1))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n    else:\n        # Graph is bipartite\n        t1_ways = 0\n        for c0, c1 in component_info:\n            # Ways to add an edge within the same partition\n            # c0 * (c0 - 1) / 2 for partition 0\n            # c1 * (c1 - 1) / 2 for partition 1\n            t1_ways += c0 * (c0 - 1) // 2\n            t1_ways += c1 * (c1 - 1) // 2\n        \n        if t1_ways > 0:\n            print(f\"1 {t1_ways}\")\n        else:\n            # t=1 is not possible. All components must have at most 2 vertices.\n            # (i.e., c0 <= 1 and c1 <= 1 for all components)\n            \n            total_count0 = 0\n            total_count1 = 0\n            for c0, c1 in component_info:\n                total_count0 += c0\n                total_count1 += c1\n            \n            # Ways to add 2 edges to form an odd cycle (a C3)\n            # Pick u1, u2, u3 from 3 distinct components.\n            # Edges (u1, u2) and (u2, u3). Cycle u1-u2-u3-u1 is odd if color(u1)=color(u3) and color(u2)!=color(u1)\n            # Ways to pick (u1, u2, u3) such that colors are (0, 1, 0)\n            # N_0 * N_1 * (N_0 - 1)\n            # Ways to pick (u1, u2, u3) such that colors are (1, 0, 1)\n            # N_1 * N_0 * (N_1 - 1)\n            # Summing these gives the total number of ways to pick 3 vertices from distinct components\n            # and add 2 edges to form a C3.\n            t2_ways = total_count0 * total_count1 * (total_count0 - 1) + \\\n                      total_count1 * total_count0 * (total_count1 - 1)\n            \n            if t2_ways > 0:\n                print(f\"2 {t2_ways}\")\n            else:\n                # t=2 is not possible. This implies that we don't have enough vertices\n                # of certain colors to form a C3 across components.\n                # Specifically, this happens if total_count0 < 2 or total_count1 < 2.\n                # (e.g., all components are isolated vertices of the same color, or there's only one component total)\n                # In this case, we need to add 3 edges to form a C3.\n                # This involves creating new vertices or using existing ones to form a C3.\n                # There's only 1 way to form a C3 if we are forced to add 3 edges.\n                # For example, if n=3, m=0, we have 3 isolated vertices. total_count0=3, total_count1=0. t2_ways=0.\n                # We add edges (1,2), (2,3), (3,1). This requires 3 edges.\n                print(\"3 1\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1)  # -1: uncolored, 0: color 0, 1: color 1\n    has_odd_cycle = False\n    component_info = []  # Stores (count0, count1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            # Start BFS for a new connected component\n            current_count0 = 0\n            current_count1 = 0\n            q = collections.deque([(i, 0)])\n            colors[i] = 0\n            is_bipartite_comp = True\n\n            nodes_in_comp = 0\n            \n            while q:\n                u, color_u = q.popleft()\n                nodes_in_comp += 1\n\n                if color_u == 0:\n                    current_count0 += 1\n                else:\n                    current_count1 += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - color_u\n                        q.append((v, 1 - color_u))\n                    elif colors[v] == color_u:\n                        has_odd_cycle = True\n                        is_bipartite_comp = False\n            \n            if is_bipartite_comp:\n                component_info.append((current_count0, current_count1))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n    else:\n        # Graph is bipartite\n        t1_ways = 0\n        for c0, c1 in component_info:\n            # Ways to add an edge within the same partition\n            # c0 * (c0 - 1) / 2 for partition 0\n            # c1 * (c1 - 1) / 2 for partition 1\n            t1_ways += c0 * (c0 - 1) // 2\n            t1_ways += c1 * (c1 - 1) // 2\n        \n        if t1_ways > 0:\n            print(f\"1 {t1_ways}\")\n        else:\n            # t=1 is not possible. All components must have at most 2 vertices.\n            # (i.e., c0 <= 1 and c1 <= 1 for all components)\n            \n            total_count0 = 0\n            total_count1 = 0\n            for c0, c1 in component_info:\n                total_count0 += c0\n                total_count1 += c1\n            \n            # Ways to add 2 edges to form an odd cycle (a C3)\n            # Pick u1, u2, u3 from 3 distinct components.\n            # Edges (u1, u2) and (u2, u3). Cycle u1-u2-u3-u1 is odd if color(u1)=color(u3) and color(u2)!=color(u1)\n            # Ways to pick (u1, u2, u3) such that colors are (0, 1, 0)\n            # N_0 * N_1 * (N_0 - 1)\n            # Ways to pick (u1, u2, u3) such that colors are (1, 0, 1)\n            # N_1 * N_0 * (N_1 - 1)\n            # Summing these gives the total number of ways to pick 3 vertices from distinct components\n            # and add 2 edges to form a C3.\n            t2_ways = total_count0 * total_count1 * (total_count0 - 1) + \\\n                      total_count1 * total_count0 * (total_count1 - 1)\n            \n            if t2_ways > 0:\n                print(f\"2 {t2_ways}\")\n            else:\n                # t=2 is not possible. This implies that we don't have enough vertices\n                # of certain colors to form a C3 across components.\n                # Specifically, this happens if total_count0 < 2 or total_count1 < 2.\n                # (e.g., all components are isolated vertices of the same color, or there's only one component total)\n                # In this case, we need to add 3 edges to form a C3.\n                # This involves creating new vertices or using existing ones to form a C3.\n                # There's only 1 way to form a C3 if we are forced to add 3 edges.\n                # For example, if n=3, m=0, we have 3 isolated vertices. total_count0=3, total_count1=0. t2_ways=0.\n                # We add edges (1,2), (2,3), (3,1). This requires 3 edges.\n                print(\"3 1\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 8786,
        "thoughts_token_count": 775
    }
}