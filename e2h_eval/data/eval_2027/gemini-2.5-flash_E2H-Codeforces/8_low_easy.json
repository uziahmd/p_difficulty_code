{
    "start": 1758009393.7798078,
    "end": 1758009632.4013774,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 17:00 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Tackling the Flawed Flow Problem: A Plan of Attack**\n\nOkay, so I've got this \"Flawed Flow\" problem, and I need a Python script to crack it. Let's break this down systematically. I see `n` vertices, `m` edges, and each edge has a capacity.  The output needs to tell me the direction of each edge's flow: `0` for `a -> b`, and `1` for `b -> a`.\n\nThe core conditions are really interesting. We've got flow conservation at every intermediate node, vertex 1 as a source with no incoming flow, and a big one: an acyclic directed graph. Plus, we're guaranteed a solution, which is a huge relief! The problem also tells us that no two edges connect the same vertices, that the graph is connected, and `n, m <= 2 * 10^5`.\n\nImmediately, the acyclicity and the source condition jump out at me.  If we're dealing with an acyclic graph and vertex 1 is the source (no incoming edges), then intuitively, we're looking at flow *originating* from 1 and flowing *towards* `n`. This suggests a topological ordering or something similar.  We're essentially building a directed flow network with a source and a sink.\n\nNow, flow conservation is standard, but the key is that for a given vertex, the incoming flow *must* equal the outgoing flow (except for source and sink). The total flow out of 1 must be equal to the total flow into `n`.\n\nSo, the biggest hurdle is determining the direction of each edge.  We need to look at each edge `(ai, bi, ci)` and decide whether it's `ai -> bi` (with capacity `ci`) or the reverse. If we can direct edges in a \"forward\" way, maintaining the acyclic condition while respecting flow conservation, we're golden.\nThe problem is very much asking us to construct a valid flow graph given the undirected edges and their capacities, and we are told such graph can always be constructed.\nWe need to get some sort of \"net flow\" for each vertex. It looks like `1` needs to have maximum flow out, and other intermediate nodes need to have zero net flow out.\n\nThe problem implies some greedy or iterative approach. I'll need to develop a strategy to assign directions to edges one at a time while adhering to the conditions. I'm going to start brainstorming some flow algorithms that could provide clues for an optimal solution.\n\nLet's start sketching some code and see where this takes us.\n",
    "response": "The problem asks us to direct edges of a given undirected graph, each with a specified flow volume, such that certain conditions are met. These conditions are:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  **Source Condition:** Vertex 1 has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n\nWe are guaranteed that a solution always exists, the graph is connected, and vertices 1 and `n` are the source and sink respectively.\n\nThe key insight comes from the acyclicity condition and the source condition. If vertex 1 has no incoming edges and there are no cycles, it implies that all flow must originate from vertex 1 and eventually terminate at vertex `n`. This structure is characteristic of a Directed Acyclic Graph (DAG). In a DAG, there exists a topological ordering of vertices. If we direct edges from a vertex with a lower topological rank to a vertex with a higher topological rank, acyclicity is guaranteed.\n\nLet's consider the \"net flow\" for each vertex. For an intermediate vertex `v`, the net flow *out* of `v` must be 0 (sum of outgoing flows minus sum of incoming flows). For vertex 1, since it has no incoming edges, its net flow *out* must be positive (equal to the total max flow). For vertex `n`, its net flow *out* must be negative (equal to minus the total max flow, as all flow must enter it).\n\nThis problem can be modeled as finding a topological ordering or a \"level\" for each node. A common approach for problems involving flow direction and acyclicity in a DAG is to use a breadth-first search (BFS) or depth-first search (DFS) starting from the source.\n\nSince vertex 1 must have no incoming edges, it's a natural starting point. We can use a BFS-like approach:\n1.  Maintain a `current_flow_balance` for each vertex. Initially, all are 0.\n2.  Maintain a queue for vertices that are \"ready\" to be processed. A vertex `u` is ready if we have determined the direction of all edges connected to `u` such that `u` is the *destination* of the flow, and its `current_flow_balance` is known.\n3.  A simpler approach is to realize that the condition \"vertex 1 has no incoming edges\" means all edges connected to vertex 1 must be directed *out* of vertex 1.\n    *   For an edge `(1, b_i, c_i)`, the direction must be `1 -> b_i`. This adds `c_i` to `b_i`'s incoming flow.\n    *   Once we direct these edges, we can update the flow balance for `b_i`.\n    *   Now, `b_i` has some incoming flow. If `b_i` is an intermediate node, it *must* eventually have an equal amount of outgoing flow. This suggests a propagation strategy.\n\nLet's refine the idea using a BFS-like approach based on flow conservation.\nFor each vertex `v`, let `required_outgoing_flow[v]` be the total flow that *must* leave `v` eventually.\nFor vertex `n` (the sink), `required_outgoing_flow[n]` should be 0.\nFor vertex 1 (the source), `required_outgoing_flow[1]` is the total max flow.\nFor intermediate vertices `v` (1 < `v` < `n`), `required_outgoing_flow[v]` is equal to its total incoming flow.\n\nSince we don't know the total max flow or the incoming/outgoing flows initially, we can use a \"deficit\" approach. For each vertex `v`, let `balance[v]` be `(sum of outgoing flow so far) - (sum of incoming flow so far)`.\nInitially, all `balance[v] = 0`.\nWe know that for `v = 1`, all edges must be outgoing. For `v = n`, all edges must be incoming. For `v` (1 < `v` < `n`), `balance[v]` must be 0 at the end.\n\nA robust way to enforce acyclicity and the source condition is to process nodes in a topological order. Since we don't have a pre-defined topological order, we can build one on the fly.\nConsider the source `s = 1`. Any edge `(s, u)` must be directed `s -> u`.\nConsider the sink `t = n`. Any edge `(u, t)` must be directed `u -> t`.\nThis isn't quite right because we don't know if `u` is \"before\" `t` in the topological order.\n\nThe most straightforward approach that satisfies all conditions:\n1.  **Initialize `current_flow_out[v]` for all `v`:** This will track the total flow that has been directed *out* of `v` so far. Initially, all `current_flow_out[v] = 0`.\n2.  **Initialize a queue and `degree[v]`:** For each vertex `v`, `degree[v]` is the count of undirected edges connected to it. Add vertex 1 to the queue.\n3.  **Process using BFS:**\n    *   When we process a vertex `u` from the queue, we iterate through its adjacent undirected edges `(u, v, c)`.\n    *   For each such edge:\n        *   If `v == n` (the sink): We *must* direct flow `u -> n`. This is because any flow reaching `n` must be incoming to `n` (as `n` is the sink), and `u` cannot be `n`. So, we direct `u -> n`. Add `c` to `current_flow_out[u]`. Store the direction `u -> n`.\n        *   If `v != n`: We tentatively direct the flow `u -> v`. This means `c` contributes to `current_flow_out[u]`. Store the direction `u -> v`.\n    *   After processing all edges for `u` in this manner:\n        *   If `u == 1` (the source): All its edges are directed `1 -> v`. The total flow out of `1` is `current_flow_out[1]`.\n        *   If `u != 1` and `u != n`: For flow conservation, the total flow *into* `u` must equal `current_flow_out[u]`.\n            *   This implies that for any edge `(x, u, c)` that has *not yet been directed*, if we direct it `x -> u`, it contributes to incoming flow. If we direct it `u -> x`, it contributes to outgoing flow.\n            *   The problem states that a solution always exists and the graph is connected. This suggests a simpler greedy strategy: when processing a node `u`, direct all its *undirected* neighbors `v` as `u -> v`. This will create a tree-like structure rooted at 1, which is acyclic.\n            *   However, this simple strategy might violate flow conservation for intermediate nodes.\n\nThe correct approach for flow conservation and acyclicity is to use a **topological sort** based on the flow direction.\nThe problem can be solved by a **single DFS/BFS traversal starting from vertex 1**, while keeping track of the \"balance\" for each vertex.\n\nLet `balance[v]` be the net flow *out* of vertex `v` that has been determined so far.\nInitially, `balance[v] = 0` for all `v`.\nWe use a queue `Q` for a BFS traversal.\nAdd `1` to `Q`.\nWhen we extract `u` from `Q`:\nIterate through all *undirected* edges `(u, v, c)`:\n    1.  **If `u` is the source (1):** All flow must go *out* of `u`. So, direct `u -> v`.\n        `balance[u] += c`.\n        `balance[v] -= c`. (This means `c` is incoming to `v`).\n        Add `v` to `Q` if not visited.\n    2.  **If `u` is an intermediate node (1 < `u` < `n`):** We need `balance[u]` to be 0 eventually.\n        If `balance[u]` is currently *negative* (meaning more flow has come *into* `u` than gone *out* of it), we need to direct flow *out* of `u` to compensate. So, direct `u -> v`.\n        `balance[u] += c`.\n        `balance[v] -= c`.\n        Add `v` to `Q` if not visited.\n        If `balance[u]` is currently *positive* (meaning more flow has gone *out* of `u` than come *into* it), we need to direct flow *into* `u` to compensate. So, direct `v -> u`.\n        `balance[u] -= c`.\n        `balance[v] += c`.\n        Add `v` to `Q` if not visited.\n    3.  **If `u` is the sink (`n`):** All flow must go *into* `u`. So, direct `v -> u`.\n        `balance[u] -= c`.\n        `balance[v] += c`.\n        Add `v` to `Q` if not visited.\n\nThis BFS approach is a bit tricky because `balance[v]` can change multiple times as neighbors are processed. The standard way to ensure acyclicity and flow conservation for intermediate nodes is to process nodes in a specific order.\n\nThe problem states \"vertex with number 1 has no incoming edges\". This is the strongest constraint. All edges connected to 1 must be `1 -> v`.\nFor any other vertex `v` (1 < `v` < `n`), the sum of incoming flow must equal the sum of outgoing flow.\nFor vertex `n`, all flow must be incoming.\n\nLet's maintain `current_sum_in[v]` for each vertex `v`. This is the total flow that has been directed *into* `v` so far.\nWe can use a **DFS** approach starting from vertex 1.\n`dfs(u, parent_edge_id)`:\n    `visited[u] = true`\n    For each edge `(u, v, c)` with `edge_id`:\n        If `edge_id == parent_edge_id`, continue (don't go back immediately).\n        If `v == n`:\n            Direct `u -> n`. `ans[edge_id] = 0` if `u=a_i, v=b_i` or `1` if `u=b_i, v=a_i`.\n            Add `c` to `sum_out_from_u`.\n            This `u` will contribute `c` to `n`.\n        Else if `v` is visited:\n            This is a back edge in the DFS tree. Since we need acyclicity, this edge must be directed `v -> u` if `v` is an ancestor of `u`, or `u -> v` if `u` is an ancestor of `v`. But we can't have `u -> v` if `v` is an ancestor and `u` is already processed.\n            A simpler rule: If `v` is already visited, and `v` is not the parent, direct `v -> u`. Add `c` to `sum_in_to_u`.\n        Else (`v` is not visited):\n            `dfs(v, edge_id)`\n            After `dfs(v)` returns, we know how much flow `v` needs to send *out* to satisfy its own balance.\n            Let `flow_from_v_to_u` be the flow that `v` needs to send to `u`.\n            If `current_flow_out_of_v[v]` (total flow leaving `v`) is less than `current_flow_in_to_v[v]` (total flow entering `v`), then `v` needs to send more flow out. This edge `(u, v)` might be `v -> u`.\n            If `current_flow_out_of_v[v]` is greater than `current_flow_in_to_v[v]`, then `v` needs to receive more flow. This edge `(u, v)` might be `u -> v`.\n\nThis is the standard approach for finding a valid flow direction in a tree, or a graph that can be reduced to a tree after fixing some edges.\nLet's use a DFS. We will keep track of `current_flow_balance[u]` for each node `u`, representing `(sum of flow directed OUT of u) - (sum of flow directed INTO u)`.\nThe goal is for `current_flow_balance[u]` to be 0 for `1 < u < n`.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n    n = int(n)\n    m = int(m)\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c, original_index)\n\n    for i in range(m):\n        u, v, c = map(sys.stdin.readline().split())\n        u = int(u)\n        v = int(v)\n        c = int(c)\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v, c))\n\n    ans = [-1] * m\n    \n    # current_balance[v] = (sum of flow directed OUT of v) - (sum of flow directed INTO v)\n    # We want current_balance[v] == 0 for 1 < v < n.\n    # We use a DFS traversal. For each node u, we determine the flow balance\n    # for all edges in its subtree. When returning from dfs(v) to u,\n    # if v has a non-zero balance, it means v needs to send/receive flow\n    # through the edge (u, v).\n    \n    current_balance = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    # Stack for iterative DFS to avoid recursion depth limit\n    # Each element in stack: (u, parent_edge_idx, neighbor_idx)\n    # neighbor_idx helps track which neighbor we are processing for u\n    dfs_stack = [(1, -1, 0)] # Start DFS from node 1, no parent edge, start with 0th neighbor\n    visited[1] = True\n\n    # Store the order of nodes to process their neighbors.\n    # This is effectively a topological sort in reverse for back-propagation.\n    dfs_order = [] \n\n    while dfs_stack:\n        u, parent_edge_idx, neighbor_idx = dfs_stack[-1]\n\n        if neighbor_idx < len(adj[u]):\n            v, c, edge_id = adj[u][neighbor_idx]\n            dfs_stack[-1] = (u, parent_edge_idx, neighbor_idx + 1) # Prepare for next neighbor\n\n            if v == n: # Special handling for sink node\n                # If u is not the source, and this is the only path to sink...\n                # We prioritize directing flow away from u towards v=n for now.\n                # This will be adjusted if u's balance requires it.\n                # For now, let's just mark it as visited and don't recurse.\n                # The balance will be resolved when returning from DFS.\n                continue \n            \n            if not visited[v]:\n                visited[v] = True\n                dfs_stack.append((v, edge_id, 0)) # Push v onto stack\n        else:\n            # All neighbors of u have been processed (or pushed to stack).\n            # Now, u is ready to be added to dfs_order, and its balance can be finalized\n            # relative to its parent.\n            dfs_order.append(u)\n            dfs_stack.pop()\n\n    # Now process nodes in reverse DFS order to determine directions and balances\n    # The last node added to dfs_order is the deepest node in the DFS tree.\n    # The first node added to dfs_order is the root (1).\n    # We need to process from deepest to shallowest, so iterate dfs_order in reverse.\n    \n    # The order should be: process children first, then parent.\n    # So, when we pop from DFS stack, that's when we know all children are processed.\n    # The dfs_order already stores nodes in post-order traversal.\n    # We need to iterate dfs_order in reverse to propagate balance up.\n    \n    # dfs_order contains nodes in post-order traversal (children before parent)\n    # Example: 1 -> 2 -> 3. dfs_order: [3, 2, 1]\n    # We need to process from 3, then 2, then 1.\n    \n    # The `ans` array stores 0 for a_i -> b_i and 1 for b_i -> a_i.\n    # edges_info[i] = (original_u, original_v, c)\n    \n    for u in dfs_order:\n        # For each edge (u, v, c, edge_id) connected to u\n        for v_neighbor, c, edge_id in adj[u]:\n            # If this edge direction is not yet decided (ans[edge_id] == -1)\n            # and v_neighbor is not the sink (n)\n            # (Edges to sink are special, they will be handled by the balance propagation)\n            \n            # This logic needs to be careful. The DFS order is crucial.\n            # When we are at node `u`, and we are propagating balance upwards:\n            #   - If `u` is `n` (sink), all its edges must be incoming. We don't adjust `n`'s balance.\n            #   - If `u` is `1` (source), all its edges must be outgoing. We don't adjust `1`'s balance based on parent.\n            #   - If `u` is an intermediate node (1 < u < n):\n            #       Its current_balance[u] represents the net flow it has sent out to its children.\n            #       If current_balance[u] > 0, it means u has sent out more flow than it received from its children.\n            #           It needs to receive flow from its parent. So, the edge to its parent should be `parent -> u`.\n            #       If current_balance[u] < 0, it means u has received more flow than it sent out to its children.\n            #           It needs to send flow to its parent. So, the edge to its parent should be `u -> parent`.\n            #       If current_balance[u] == 0, it means u is balanced with its children. The edge to its parent could be either way, but we need to ensure acyclicity.\n            #       The problem guarantees a solution, so this balance will always work out.\n            \n            # The DFS structure:\n            # dfs(u, p_edge_id):\n            #   visited[u] = true\n            #   for (v, c, edge_id) in adj[u]:\n            #     if edge_id == p_edge_id: continue\n            #     if v == n:\n            #       # This is an edge to the sink. We must direct it u -> n.\n            #       # This contributes to u's outgoing flow.\n            #       current_balance[u] += c\n            #       ans[edge_id] = 0 if edges_info[edge_id][0] == u else 1\n            #     elif not visited[v]:\n            #       # Recurse on child v\n            #       dfs(v, edge_id)\n            #       # After child v returns, its balance needs to be resolved with u\n            #       if current_balance[v] > 0: # v sent out more than it received from its subtree\n            #         # v needs to receive flow from u. So u -> v.\n            #         current_balance[u] += current_balance[v]\n            #         ans[edge_id] = 0 if edges_info[edge_id][0] == u else 1\n            #       elif current_balance[v] < 0: # v received more than it sent out to its subtree\n            #         # v needs to send flow to u. So v -> u.\n            #         current_balance[u] += current_balance[v] # This is effectively current_balance[u] - abs(current_balance[v])\n            #         ans[edge_id] = 1 if edges_info[edge_id][0] == u else 0\n            #       # If current_balance[v] == 0, it means v is balanced within its subtree and with u.\n            #       # This edge (u,v) does not carry any \"net\" flow for balancing.\n            #       # This is where the problem becomes tricky. The \"flow volume ci\" is given.\n            #       # We can't just sum up arbitrary balances.\n            #       # The balance must be exactly 0 for intermediate nodes.\n            #       # The value 'c' on the edge is the *amount* of flow.\n            #       # So if v needs to send 'X' flow to u, and this edge is (u,v) with capacity 'c', then X must be c.\n            #       # This means current_balance[v] must be c or -c.\n            #     else: # v is visited and not parent (cross/forward edge)\n            #       # This edge forms a cycle if directed u -> v.\n            #       # So it must be directed v -> u.\n            #       current_balance[u] -= c\n            #       ans[edge_id] = 1 if edges_info[edge_id][0] == u else 0\n            \n            # The above logic is flawed because `current_balance[v]` is the net flow *from* v.\n            # If `current_balance[v]` is positive, it means `v` has an excess of outgoing flow.\n            # This excess must be sent to `u` via the edge `(u, v)`. So flow is `v -> u`.\n            # If `current_balance[v]` is negative, it means `v` has a deficit of outgoing flow (excess incoming flow).\n            # This deficit must be covered by `u` sending flow to `v` via the edge `(u, v)`. So flow is `u -> v`.\n            # The magnitude of this flow is `abs(current_balance[v])`.\n            # This `abs(current_balance[v])` must be equal to `c` for the edge `(u, v, c)`.\n\n    # Let's restart with a simpler DFS structure based on the \"balance\" for each node.\n    # `balance[u]` will store the sum of `c` for edges directed `u -> X` minus `c` for edges directed `X -> u`.\n    # For `1 < u < n`, we want `balance[u]` to be `0` at the end.\n    # For `u = 1`, `balance[1]` will be the total max flow (positive).\n    # For `u = n`, `balance[n]` will be -total max flow (negative).\n    \n    # `dfs_flow(u, p_edge_id)` returns the net flow that needs to be sent *out* of `u` through the edge `(u, parent)`\n    # to make `u` balanced with its subtree.\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    \n    def dfs_flow(u, p_edge_id):\n        visited[u] = True\n        \n        # flow_out_of_u_in_subtree: sum of c for edges directed u -> child, minus sum of c for edges directed child -> u\n        # in the subtree rooted at u (excluding the edge to parent).\n        flow_out_of_u_in_subtree = 0 \n\n        for v, c, edge_id in adj[u]:\n            if edge_id == p_edge_id:\n                continue\n\n            if visited[v]:\n                # This is a back-edge (or cross-edge).\n                # To maintain acyclicity and ensure flow from 1 to n,\n                # any such edge must be directed away from the \"earlier\" node in DFS traversal.\n                # Since v is already visited, it means v is an ancestor or a node in a different subtree.\n                # To prevent cycles, we direct flow from v to u. (This is a common strategy in DFS-based flow problems).\n                # This makes `c` flow *into* `u`.\n                if ans[edge_id] == -1: # Only decide if not already decided by v\n                    if edges_info[edge_id][0] == u: # Original edge was u-v\n                        ans[edge_id] = 1 # v -> u\n                    else: # Original edge was v-u\n                        ans[edge_id] = 0 # v -> u\n                    flow_out_of_u_in_subtree -= c # c flows into u\n            else:\n                # v is a child in the DFS tree. Recurse.\n                # child_net_flow_out is the flow that v needs to send out through (v,u)\n                # to balance itself with its subtree.\n                child_net_flow_out = dfs_flow(v, edge_id)\n                \n                # Now, use child_net_flow_out to determine direction for edge (u,v,c)\n                if child_net_flow_out > 0:\n                    # v has an excess of outgoing flow (sent out more than it received in its subtree).\n                    # This excess must be sent to u. So, flow is v -> u.\n                    # The amount is child_net_flow_out. This must be equal to c.\n                    # This means c flows *into* u.\n                    if edges_info[edge_id][0] == u: # Original edge was u-v\n                        ans[edge_id] = 1 # v -> u\n                    else: # Original edge was v-u\n                        ans[edge_id] = 0 # v -> u\n                    flow_out_of_u_in_subtree -= c # c flows into u\n                elif child_net_flow_out < 0:\n                    # v has a deficit of outgoing flow (received more than it sent out in its subtree).\n                    # This deficit must be covered by u sending flow to v. So, flow is u -> v.\n                    # The amount is abs(child_net_flow_out). This must be equal to c.\n                    # This means c flows *out* of u.\n                    if edges_info[edge_id][0] == u: # Original edge was u-v\n                        ans[edge_id] = 0 # u -> v\n                    else: # Original edge was v-u\n                        ans[edge_id] = 1 # u -> v\n                    flow_out_of_u_in_subtree += c # c flows out of u\n                # If child_net_flow_out == 0, it means v is balanced within its subtree and with u.\n                # This edge (u,v) does not carry any net flow for balancing. This case is tricky.\n                # However, the problem guarantees a solution. This implies that for any intermediate node,\n                # the sum of flow volumes of edges directed into it must equal the sum of flow volumes\n                # of edges directed out of it.\n                # This means `child_net_flow_out` will never be 0 for an edge that *needs* to carry flow.\n                # It will always be `c` or `-c`.\n        \n        # After processing all neighbors, determine what u needs to do with its parent.\n        if u == 1: # Source node\n            # All edges connected to 1 must be outgoing.\n            # The flow_out_of_u_in_subtree should represent the total max flow.\n            # This means any edge (1,v) that wasn't directed u->v by the `child_net_flow_out < 0` case\n            # must be directed 1->v.\n            # Let's re-check the logic.\n            \n            # The problem is that the `dfs_flow` function needs to return the \"net flow\"\n            # that is passed through the parent edge.\n            # For node `u`, `flow_out_of_u_in_subtree` is the sum of flows that `u` sends out to its children\n            # minus flows that `u` receives from its children.\n            # If `u` is an intermediate node (1 < u < n), its total net flow must be 0.\n            # So, if `flow_out_of_u_in_subtree` is `X`, it means `u` needs to receive `X` from its parent\n            # (if X > 0) or send `|X|` to its parent (if X < 0).\n            # This `X` is returned.\n            \n            # If `u` is the sink (`n`), it must receive all flow.\n            # So `flow_out_of_u_in_subtree` should be `0` (it sends nothing out).\n            # Any flow directed `u -> X` is wrong.\n            # For sink `n`, `child_net_flow_out` will always be negative, meaning children send flow to `n`.\n            # So, `flow_out_of_n_in_subtree` should be `0`.\n            return flow_out_of_u_in_subtree\n        elif u == n: # Sink node\n            # The sink must have all flow incoming.\n            # Its `flow_out_of_u_in_subtree` must be 0, as it sends no flow out.\n            # Any non-zero value implies an error or needs to be absorbed by the parent.\n            # The problem guarantees a solution, so this should work out.\n            return flow_out_of_u_in_subtree # Should effectively be 0\n        else: # Intermediate node\n            # The net flow for an intermediate node must be 0.\n            # So, whatever `flow_out_of_u_in_subtree` is, that amount must be balanced by the parent edge.\n            # If `flow_out_of_u_in_subtree` is positive, `u` needs to receive this amount from its parent.\n            # If `flow_out_of_u_in_subtree` is negative, `u` needs to send this amount to its parent.\n            return flow_out_of_u_in_subtree\n\n    # Call DFS from source node 1\n    # The return value for dfs_flow(1, -1) should be the total max flow.\n    dfs_flow(1, -1)\n\n    # Print the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\n# This DFS logic is standard for tree-like flows.\n# Let's verify the edge cases:\n# - Vertex 1 (source): No incoming edges. This means `flow_out_of_u_in_subtree` for u=1 will be `total_max_flow`.\n#   All edges connected to 1 will be directed `1 -> v`.\n#   This is handled by the `child_net_flow_out < 0` case for children `v` of `1`.\n#   If `v` is a child of `1`, and `dfs_flow(v, edge_id)` returns `child_net_flow_out < 0`,\n#   it means `v` needs to receive flow from `1`. So `1 -> v`. This is correct.\n#   If `dfs_flow(v, edge_id)` returns `child_net_flow_out > 0`, it means `v` needs to send flow to `1`.\n#   This would imply `v -> 1`, which is an incoming edge to 1, violating condition 2.\n#   This implies `child_net_flow_out` must always be <= 0 for children of 1.\n#   This is not necessarily true. For example, 1 -> 2 <- 3. If 3 is a child of 2.\n#   The guarantee \"a solution always exists\" is strong.\n#   The core idea is that `current_balance[u]` accumulates signed flow amounts.\n#   When returning from `dfs(v)`, `current_balance[v]` is the net flow *out* of `v` accumulated from its subtree.\n#   This value `current_balance[v]` must be *resolved* by the edge `(u, v)`.\n#   So, `abs(current_balance[v])` must be equal to `c` of edge `(u, v, c)`.\n\n# Let's try to trace the logic with a small example:\n# 3 3\n# 3 2 10 (edge 0)\n# 1 2 10 (edge 1)\n# 3 1 5  (edge 2)\n\n# adj:\n# 1: [(2, 10, 1), (3, 5, 2)]\n# 2: [(3, 10, 0), (1, 10, 1)]\n# 3: [(2, 10, 0), (1, 5, 2)]\n\n# dfs_flow(1, -1):\n#   visited[1] = True\n#   flow_out_of_1_in_subtree = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      v=2 not visited. Recurse: child_net_flow_out = dfs_flow(2, 1)\n#      \n#      dfs_flow(2, 1):\n#        visited[2] = True\n#        flow_out_of_2_in_subtree = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           v=3 not visited. Recurse: child_net_flow_out_3 = dfs_flow(3, 0)\n#           \n#           dfs_flow(3, 0):\n#             visited[3] = True\n#             flow_out_of_3_in_subtree = 0\n#             Neighbors of 3: (2, 10, 0), (1, 5, 2)\n#             \n#             1. Process (2, 10, 0): v=2, c=10, edge_id=0. This is parent_edge_id. Continue.\n#             2. Process (1, 5, 2): v=1, c=5, edge_id=2\n#                v=1 is visited. This is a back-edge to the root (1).\n#                Direct v -> u, i.e., 1 -> 3. (This is where the rule needs to be careful)\n#                The rule \"direct v -> u\" (v=1, u=3) means flow 1 -> 3.\n#                Original edge was (3,1), so ans[2] = 1 (1->3).\n#                flow_out_of_3_in_subtree -= c (5) = -5. (Flow 5 comes into 3).\n#             \n#             Return flow_out_of_3_in_subtree = -5.\n#           \n#           Back to dfs_flow(2, 1) for (3, 10, 0):\n#           child_net_flow_out_3 = -5.\n#           Since it's < 0, v=3 needs to receive flow from u=2. So 2 -> 3.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           flow_out_of_2_in_subtree += c (10) = 10. (Flow 10 goes out of 2).\n#           \n#           2. Process (1, 10, 1): v=1, c=10, edge_id=1. This is parent_edge_id. Continue.\n#           \n#           Return flow_out_of_2_in_subtree = 10.\n#           \n#   Back to dfs_flow(1, -1) for (2, 10, 1):\n#   child_net_flow_out = 10.\n#   Since it's > 0, v=2 needs to send flow to u=1. So 2 -> 1.\n#   Original edge was (1,2), so ans[1] = 1 (2->1).\n#   flow_out_of_1_in_subtree -= c (10) = -10. (Flow 10 comes into 1).\n#\n#   2. Process (3, 5, 2): v=3, c=5, edge_id=2\n#      v=3 is visited. This is a back-edge.\n#      Direct v -> u, i.e., 3 -> 1.\n#      Original edge was (3,1), so ans[2] = 0 (3->1).\n#      flow_out_of_1_in_subtree -= c (5) = -10 - 5 = -15. (Flow 5 comes into 1).\n#\n#   Return flow_out_of_1_in_subtree = -15.\n\n# This result for ans:\n# ans[0]: 1 (2->3)\n# ans[1]: 1 (2->1)\n# ans[2]: 0 (3->1)\n\n# Let's check the conditions for output:\n# 1. Vertex 1 has no incoming edges:\n#    Edge (2,1): 2->1 (incoming to 1) VIOLATED!\n#    Edge (3,1): 3->1 (incoming to 1) VIOLATED!\n\n# The DFS logic for back-edges and determining direction based on `child_net_flow_out` is incorrect\n# for the source node and potentially for other nodes.\n# The \"no incoming edges for vertex 1\" is a hard constraint.\n# The \"no cycles\" is also a hard constraint.\n\n# A more robust approach for flow problems with given edge capacities is often to use a **minimum cost maximum flow** like structure, or more simply, a potential function.\n# However, this problem is marked \"easy\". The key must be simpler.\n\n# Let's rethink the \"no incoming edges for vertex 1\" and \"no cycles\" + \"flow conservation\".\n# This implies a topological ordering starting from 1.\n# The flow must \"push\" away from 1 and \"pull\" towards n.\n\n# Consider the total flow `S` from 1 to `n`.\n# For any vertex `v` (1 < `v` < `n`), `sum(in_flow) = sum(out_flow)`.\n# For `v = 1`, `sum(out_flow) = S`.\n# For `v = n`, `sum(in_flow) = S`.\n\n# What if we use a BFS starting from `n` (the sink) and determine how much flow each node *needs* to send to `n`?\n# Or a BFS from `1` to determine how much flow each node *has* from `1`.\n\n# Let `required_flow_in_to_v` be the total flow that must enter `v` from its neighbors in the \"parent\" direction.\n# Or, let `balance[v]` be `(sum of flow directed into v) - (sum of flow directed out of v)`.\n# We want `balance[v] = 0` for `1 < v < n`.\n# `balance[1]` should be `0` (no incoming, some outgoing).\n# `balance[n]` should be `total_flow` (all incoming, no outgoing).\n\n# This problem is a variant of \"flow circulation\" or \"potential function\" problems.\n# If we assign a \"potential\" `p[v]` to each node `v`, and direct flow `u -> v` if `p[u] > p[v]`,\n# then acyclicity is guaranteed if `p` values are distinct.\n# The flow conservation `sum(in) = sum(out)` means that for each node `v`,\n# `sum_{u: u->v} c_{uv} = sum_{w: v->w} c_{vw}`.\n\n# The approach that usually works for \"find flow directions in a DAG\" is:\n# 1. Start a DFS/BFS from source (1).\n# 2. Maintain `incoming_sum[v]` and `outgoing_sum[v]` for each node `v`.\n# 3. For an edge `(u, v, c)`:\n#    If `u` is processed and `v` is not, then `u` is \"earlier\" than `v`.\n#    We can tentatively direct `u -> v`. Add `c` to `outgoing_sum[u]` and `incoming_sum[v]`.\n#    If `u` and `v` are both processed, this is a back-edge or cross-edge.\n#    To avoid cycles, we must direct from the node that was visited first to the node visited later.\n#    This is hard without knowing the full topological order.\n\n# The \"easy\" tag suggests a simple greedy approach or a standard graph algorithm.\n# The key condition \"vertex with number 1 has no incoming edges\" is very strong.\n# All edges connected to 1 must be `1 -> v`.\n# This defines the initial state for nodes adjacent to 1.\n\n# Let's use a BFS-like approach with a `current_deficit[v]` variable.\n# `current_deficit[v]` = (sum of flow directed INTO v) - (sum of flow directed OUT OF v).\n# Initially, `current_deficit[v] = 0` for all `v`.\n# `ans` array to store directions.\n# `q` for BFS. Add `1` to `q`.\n\n# When processing `u` from `q`:\n#   For each neighbor `v` of `u` with edge `(u, v, c)` (original edge `a_i, b_i, c_i` with index `idx`):\n#     If `ans[idx]` is already set, continue. (This means the other endpoint already decided direction).\n#     \n#     If `u == 1`:\n#       Must be `1 -> v`.\n#       Set `ans[idx]` appropriately.\n#       `current_deficit[v] += c`.\n#       Add `v` to `q` if not yet added.\n#     Else if `v == n`:\n#       Must be `u -> n`.\n#       Set `ans[idx]` appropriately.\n#       `current_deficit[u] -= c`.\n#       Add `u` to `q` if not yet added (though `u` might already be processed or in queue).\n#     Else (`u` is intermediate, `v` is intermediate):\n#       This is the tricky part. We need to decide `u -> v` or `v -> u`.\n#       If `current_deficit[u] < 0`: (u has sent out more flow than it received)\n#         `u` needs to receive more flow. So, `v -> u`.\n#         Set `ans[idx]` appropriately.\n#         `current_deficit[u] += c`.\n#         `current_deficit[v] -= c`.\n#         Add `v` to `q`.\n#       Else if `current_deficit[u] > 0`: (u has received more flow than it sent out)\n#         `u` needs to send out more flow. So, `u -> v`.\n#         Set `ans[idx]` appropriately.\n#         `current_deficit[u] -= c`.\n#         `current_deficit[v] += c`.\n#         Add `v` to `q`.\n#       Else (`current_deficit[u] == 0`):\n#         This is the hardest case. `u` is balanced so far.\n#         We need to pick a direction that doesn't create a cycle and allows flow to propagate.\n#         This implies a topological order.\n\n# The standard way to handle this in a DAG is a DFS post-order traversal.\n# When `dfs(u)` returns, it means all children of `u` have been visited.\n# At this point, `current_balance[u]` holds the net flow from `u` to its children.\n# If `current_balance[u]` is positive, `u` has an excess of outgoing flow. This must go to its parent.\n# So, the edge `(u, parent)` is `u -> parent`.\n# If `current_balance[u]` is negative, `u` has a deficit of outgoing flow. This must come from its parent.\n# So, the edge `(u, parent)` is `parent -> u`.\n# The magnitude `abs(current_balance[u])` must be equal to the flow `c` of the edge `(u, parent, c)`.\n\n# This relies on the fact that for all intermediate nodes `1 < u < n`, `current_balance[u]` eventually becomes 0.\n# For `u=1`, it becomes `TotalMaxFlow`. For `u=n`, it becomes `-TotalMaxFlow`.\n\n# Let's refine the DFS approach:\n# `ans`: array of size `m` for directions.\n# `visited`: boolean array for DFS.\n# `dfs_balance(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0` (this will be the net flow that `u` needs to send *out* to its parent)\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#\n#     If `v == n`: # Edge to the sink\n#       # This edge must carry flow `u -> n`.\n#       # This contributes `c` to `u`'s outgoing flow.\n#       # And `c` to `n`'s incoming flow.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#     elif visited[v]: # Back-edge or cross-edge\n#       # To maintain acyclicity and ensure flow from 1 to n,\n#       # we must direct flow from `v` to `u`. (This is a common strategy in DFS-based flow problems)\n#       # This means `c` flows *into* `u`.\n#       # This contributes `c` to `u`'s incoming flow.\n#       if ans[edge_id] == -1: # Only decide if not already decided by v\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#       balance_for_u -= c\n#     else: # Tree edge, `v` is a child\n#       # Recurse on `v`. `child_net_flow_out` is the net flow `v` sends to its parent (`u`).\n#       child_net_flow_out = dfs_balance(v, edge_id)\n#\n#       if child_net_flow_out > 0: # `v` has excess outgoing flow, sends it to `u`. So `v -> u`.\n#         # Amount is `child_net_flow_out`. This must be equal to `c`.\n#         # This means `c` flows *into* `u`.\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#         balance_for_u -= c\n#       elif child_net_flow_out < 0: # `v` has deficit outgoing flow, receives it from `u`. So `u -> v`.\n#         # Amount is `abs(child_net_flow_out)`. This must be equal to `c`.\n#         # This means `c` flows *out* of `u`.\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#         else: ans[edge_id] = 1 # u -> v\n#         balance_for_u += c\n#       # If child_net_flow_out == 0, it means the edge (u,v) does not carry net flow.\n#       # This case should not happen for a flow problem with positive capacities if a solution exists.\n#       # The problem guarantees a solution, so `child_net_flow_out` will always be `c` or `-c`.\n#       # The `child_net_flow_out` is the exact flow that needs to pass through edge (u,v).\n#       # So `abs(child_net_flow_out)` must be `c`.\n#\n#   return balance_for_u\n\n# Initial call: `dfs_balance(1, -1)`.\n# After this, `ans` array should be populated.\n\n# Let's re-trace example 1 with this refined DFS:\n# 3 3\n# 3 2 10 (edge 0)\n# 1 2 10 (edge 1)\n# 3 1 5  (edge 2)\n\n# adj:\n# 1: [(2, 10, 1), (3, 5, 2)]\n# 2: [(3, 10, 0), (1, 10, 1)]\n# 3: [(2, 10, 0), (1, 5, 2)]\n\n# dfs_balance(1, -1):\n#   visited[1] = True\n#   balance_for_1 = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      v=2 not visited. Recurse: child_net_flow_out = dfs_balance(2, 1)\n#      \n#      dfs_balance(2, 1):\n#        visited[2] = True\n#        balance_for_2 = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           v=3 not visited. Recurse: child_net_flow_out_3 = dfs_balance(3, 0)\n#           \n#           dfs_balance(3, 0):\n#             visited[3] = True\n#             balance_for_3 = 0\n#             Neighbors of 3: (2, 10, 0), (1, 5, 2)\n#             \n#             1. Process (2, 10, 0): v=2, c=10, edge_id=0. This is parent_edge_id. Continue.\n#             2. Process (1, 5, 2): v=1, c=5, edge_id=2\n#                v=1 is visited. This is a back-edge.\n#                Direct v -> u, i.e., 1 -> 3.\n#                Original edge was (3,1), so ans[2] = 1 (1->3).\n#                balance_for_3 -= c (5) = -5. (Flow 5 comes into 3).\n#             \n#             Return balance_for_3 = -5. (3 needs to receive 5 more flow)\n#           \n#           Back to dfs_balance(2, 1) for (3, 10, 0):\n#           child_net_flow_out_3 = -5.\n#           Since it's < 0, v=3 needs to receive flow from u=2. So 2 -> 3.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           balance_for_2 += c (10) = 10. (Flow 10 goes out of 2).\n#           \n#           2. Process (1, 10, 1): v=1, c=10, edge_id=1. This is parent_edge_id. Continue.\n#           \n#           Return balance_for_2 = 10. (2 needs to send 10 more flow)\n#           \n#   Back to dfs_balance(1, -1) for (2, 10, 1):\n#   child_net_flow_out = 10.\n#   Since it's > 0, v=2 needs to send flow to u=1. So 2 -> 1.\n#   Original edge was (1,2), so ans[1] = 1 (2->1).\n#   balance_for_1 -= c (10) = -10. (Flow 10 comes into 1).\n#\n#   2. Process (3, 5, 2): v=3, c=5, edge_id=2\n#      v=3 is visited. This is a back-edge.\n#      Direct v -> u, i.e., 3 -> 1.\n#      Original edge was (3,1), so ans[2] = 0 (3->1). (This overwrites previous ans[2]=1. This is an issue!)\n#      balance_for_1 -= c (5) = -10 - 5 = -15. (Flow 5 comes into 1).\n#\n#   Return balance_for_1 = -15.\n\n# The issue is that `ans[edge_id]` might be set twice.\n# When `v` is visited, and it's not the parent, it's a cross-edge or back-edge.\n# The direction for such an edge must be consistent with the topological order.\n# The rule \"direct v -> u\" (from already visited to currently visiting) is a common heuristic for acyclicity.\n# But it might contradict the \"no incoming to 1\" rule.\n\n# The problem is that the problem statement for the first test case output is:\n# 1 (3->2)\n# 0 (1->2)\n# 1 (1->3)\n# Total flow from 1: 10 (1->2) + 5 (1->3) = 15.\n# Node 2: In: 10 (from 1). Out: 10 (to 3). Balanced.\n# Node 3: In: 5 (from 1) + 10 (from 2). Out: 0 (to n, which is 3 itself).\n# Wait, n=3 is the sink. So node 3 is the sink.\n# Node 3: In: 5 (from 1) + 10 (from 2) = 15. Out: 0. This is consistent.\n# Node 1: Out: 10 (to 2) + 5 (to 3) = 15. In: 0. Consistent.\n# This solution is valid.\n\n# My DFS output:\n# ans[0]: 1 (2->3)\n# ans[1]: 1 (2->1) - INCORRECT, should be 0 (1->2)\n# ans[2]: 0 (3->1) - INCORRECT, should be 1 (1->3)\n\n# The DFS logic for back-edges needs to be fixed.\n# If `v` is visited and `v != n` and `v != 1`:\n#   If `u` is the source (1), then the edge `(1, v)` must be `1 -> v`.\n#   If `v` is the sink (n), then the edge `(u, n)` must be `u -> n`.\n#   Otherwise, if both `u` and `v` are intermediate, and `v` is already visited.\n#   This means `v` has already had its `dfs_balance` called and returned.\n#   So `v` is \"earlier\" in the DFS tree or a different subtree.\n#   To maintain acyclicity, we should direct `v -> u`.\n\n# The crucial part is that `ans[edge_id]` is set *only once*.\n# If `ans[edge_id]` is already set, it means the other endpoint `v` (or `u` if we are processing `v`'s neighbors) already decided the direction.\n# This implies that `dfs_balance` should only process edges that haven't been directed yet.\n\n# Revised DFS:\n# `ans`: array of size `m` for directions.\n# `visited`: boolean array for DFS.\n# `dfs_balance(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0` (net flow that `u` needs to send *out* to its parent)\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#\n#     If `ans[edge_id] != -1`: continue # Already decided by other endpoint\n#\n#     If `v == n`: # Edge to the sink\n#       # This edge must carry flow `u -> n`.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#     elif visited[v]: # Back-edge or cross-edge\n#       # `v` is already visited. To maintain acyclicity, flow must go from `v` to `u`.\n#       # This means `c` flows *into* `u`.\n#       balance_for_u -= c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#       else: ans[edge_id] = 0 # v -> u\n#     else: # Tree edge, `v` is a child\n#       child_net_flow_out = dfs_balance(v, edge_id)\n#\n#       if child_net_flow_out > 0: # `v` has excess outgoing flow, sends it to `u`. So `v -> u`.\n#         balance_for_u -= c # c flows into u\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#       elif child_net_flow_out < 0: # `v` has deficit outgoing flow, receives it from `u`. So `u -> v`.\n#         balance_for_u += c # c flows out of u\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#         else: ans[edge_id] = 1 # u -> v\n#       # The problem guarantees a solution, so `child_net_flow_out` will always be `c` or `-c`.\n#       # So no `else` for `child_net_flow_out == 0` is needed.\n#\n#   return balance_for_u\n\n# Initial call: `dfs_balance(1, -1)`.\n\n# Trace example 1 with REVISED DFS:\n# 3 3\n# 3 2 10 (edge 0)\n# 1 2 10 (edge 1)\n# 3 1 5  (edge 2)\n\n# dfs_balance(1, -1):\n#   visited[1] = True\n#   balance_for_1 = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      ans[1] == -1. v=2 not visited. Recurse: child_net_flow_out = dfs_balance(2, 1)\n#      \n#      dfs_balance(2, 1):\n#        visited[2] = True\n#        balance_for_2 = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           ans[0] == -1. v=3 not visited. Recurse: child_net_flow_out_3 = dfs_balance(3, 0)\n#           \n#           dfs_balance(3, 0):\n#             visited[3] = True\n#             balance_for_3 = 0\n#             Neighbors of 3: (2, 10, 0), (1, 5, 2)\n#             \n#             1. Process (2, 10, 0): v=2, c=10, edge_id=0. This is parent_edge_id. Continue.\n#             2. Process (1, 5, 2): v=1, c=5, edge_id=2\n#                ans[2] == -1. v=1 is visited. Back-edge.\n#                Direct v -> u, i.e., 1 -> 3.\n#                Original edge was (3,1), so ans[2] = 1 (1->3).\n#                balance_for_3 -= c (5) = -5. (Flow 5 comes into 3).\n#             \n#             Return balance_for_3 = -5. (3 needs to receive 5 more flow)\n#           \n#           Back to dfs_balance(2, 1) for (3, 10, 0):\n#           child_net_flow_out_3 = -5.\n#           Since it's < 0, v=3 needs to receive flow from u=2. So 2 -> 3.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           balance_for_2 += c (10) = 10. (Flow 10 goes out of 2).\n#           \n#           2. Process (1, 10, 1): v=1, c=10, edge_id=1. This is parent_edge_id. Continue.\n#           \n#           Return balance_for_2 = 10. (2 needs to send 10 more flow)\n#           \n#   Back to dfs_balance(1, -1) for (2, 10, 1):\n#   child_net_flow_out = 10.\n#   Since it's > 0, v=2 needs to send flow to u=1. So 2 -> 1.\n#   Original edge was (1,2), so ans[1] = 1 (2->1).\n#   balance_for_1 -= c (10) = -10. (Flow 10 comes into 1).\n#\n#   2. Process (3, 5, 2): v=3, c=5, edge_id=2\n#      ans[2] is now 1. This edge was already decided by dfs_balance(3,0).\n#      So, we `continue`.\n#\n#   Return balance_for_1 = -10.\n\n# Resulting `ans`:\n# ans[0]: 1 (2->3)\n# ans[1]: 1 (2->1)\n# ans[2]: 1 (1->3)\n\n# This is still not matching the example output. The example output has 1->2, 1->3, 3->2.\n# My DFS: 2->1, 1->3, 2->3.\n# The DFS is creating an incoming edge to 1 (2->1), which is forbidden.\n\n# The condition \"vertex with number 1 has no incoming edges\" means that for any edge (1, v), it *must* be 1 -> v.\n# This is a hard constraint.\n# The `dfs_balance` function should respect this.\n# If `u == 1`, then `balance_for_u` should only increase. `ans` for (1,v) should be `1->v`.\n# If `v == 1`, then `balance_for_u` should only decrease. `ans` for (u,1) should be `u->1`.\n\n# Let's modify the DFS to explicitly handle the source (1) and sink (n).\n# `dfs_balance(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0`\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#     If `ans[edge_id] != -1`: continue\n#\n#     If `u == 1`: # Source node\n#       # Must be 1 -> v.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#       # If v is not visited, recurse.\n#       if not visited[v]: dfs_balance(v, edge_id)\n#     elif v == n: # Edge to the sink\n#       # Must be u -> n.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#       # No recursion into n, it's a sink.\n#     elif visited[v]: # Back-edge or cross-edge involving intermediate nodes\n#       # Direct v -> u to maintain acyclicity.\n#       balance_for_u -= c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 1\n#       else: ans[edge_id] = 0\n#     else: # Tree edge, `v` is a child, and both `u, v` are intermediate\n#       child_net_flow_out = dfs_balance(v, edge_id)\n#       if child_net_flow_out > 0: # `v` sends to `u`. So `v -> u`.\n#         balance_for_u -= c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1\n#         else: ans[edge_id] = 0\n#       elif child_net_flow_out < 0: # `v` receives from `u`. So `u -> v`.\n#         balance_for_u += c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#         else: ans[edge_id] = 1\n#\n#   return balance_for_u\n\n# This logic is still problematic because `dfs_balance` returns a value, but if `u=1`, its value is not used by a parent.\n# The `balance_for_u` for `u=1` is the total flow, which is fine.\n# But `visited[v]` check for `u=1`'s neighbors is also tricky.\n# If `u=1` and `v` is visited, it implies `v` is an ancestor of `1` (impossible) or in a separate component (impossible, connected graph).\n# So for `u=1`, `v` will always be `not visited` (unless `v=n` and `n` was visited somehow).\n\n# The example output's directions:\n# 1 -> 2 (10)\n# 1 -> 3 (5)\n# 2 -> 3 (10)\n\n# The total flow is 15.\n# For node 1: out = 15, in = 0.\n# For node 2: in = 10 (from 1), out = 10 (to 3). Balance = 0.\n# For node 3: in = 5 (from 1) + 10 (from 2) = 15. out = 0. Balance = 0.\n\n# This implies that all edges must be directed \"downstream\" from 1 to 3.\n# The DFS should naturally find this.\n\n# Let's try the provided solution from a competitive programming context.\n# Usually this involves a DFS from the source.\n# `flow[u]` is the net flow *out* of `u` from its children.\n# `dfs(u, p)`:\n#   `visited[u] = true`\n#   `current_out_flow = 0`\n#   For each edge `(u, v, c, idx)`:\n#     If `v == p`: continue\n#     If `v == n`: # Edge to sink\n#       `current_out_flow += c`\n#       `ans[idx]` = `u->n`\n#     Else if `visited[v]`: # Back-edge to an ancestor or cross-edge\n#       # This edge must be directed `v -> u` to avoid cycles.\n#       `current_out_flow -= c`\n#       `ans[idx]` = `v->u`\n#     Else: # Tree edge\n#       `child_net_flow = dfs(v, u)`\n#       If `child_net_flow > 0`: # v has excess, sends to u: v -> u\n#         `current_out_flow -= c`\n#         `ans[idx]` = `v->u`\n#       Else: # v has deficit, receives from u: u -> v\n#         `current_out_flow += c`\n#         `ans[idx]` = `u->v`\n#   Return `current_out_flow`.\n\n# This is the exact same logic as my refined DFS. Why does it fail for the example?\n# The problem is the \"no incoming edges for vertex 1\".\n# If `u=1`, the `current_out_flow -= c` for `v->u` is wrong. It implies flow into 1.\n# So, the logic `if u==1` must be special.\n\n# Special handling for `u=1`:\n# `dfs(1, -1)`:\n#   `visited[1] = true`\n#   `current_out_flow = 0`\n#   For each edge `(1, v, c, idx)`:\n#     If `v == n`: # Edge to sink\n#       `current_out_flow += c`\n#       `ans[idx]` = `1->n`\n#     Else: # `v` is an intermediate node\n#       # For `u=1`, all edges must be outgoing. So `1 -> v`.\n#       `current_out_flow += c`\n#       `ans[idx]` = `1->v`\n#       If `not visited[v]`:\n#         `dfs(v, 1)` # Recurse\n#   Return `current_out_flow`. (This is the total max flow)\n\n# This is a bit different. The `dfs` for `u=1` does not rely on `child_net_flow` for its own edges.\n# It just directs them all outwards.\n# Then, for `v` (child of 1), `dfs(v, 1)` will behave normally.\n\n# Let's try this (simplified) DFS:\n# `ans`: array of size `m` for directions.\n# `visited`: boolean array for DFS.\n# `dfs_flow(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0` # Net flow that `u` needs to send *out* to its parent\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#     If `ans[edge_id] != -1`: continue # Already decided by other endpoint\n#\n#     If `u == 1`: # Source node: ALL edges must be outgoing\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#       else: ans[edge_id] = 1 # u -> v\n#       if not visited[v]: dfs_flow(v, edge_id) # Recurse\n#     elif v == n: # Edge to the sink: ALL edges must be incoming to n\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> n\n#       else: ans[edge_id] = 1 # u -> n\n#       # No recursion into n, it's a sink.\n#     elif visited[v]: # Back-edge or cross-edge (u, v are intermediate)\n#       # Direct v -> u to maintain acyclicity.\n#       balance_for_u -= c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#       else: ans[edge_id] = 0 # v -> u\n#     else: # Tree edge, `v` is a child, `u, v` are intermediate\n#       child_net_flow_out = dfs_flow(v, edge_id)\n#\n#       if child_net_flow_out > 0: # `v` sends to `u`. So `v -> u`.\n#         balance_for_u -= c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#       elif child_net_flow_out < 0: # `v` receives from `u`. So `u -> v`.\n#         balance_for_u += c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#         else: ans[edge_id] = 1 # u -> v\n#\n#   return balance_for_u\n\n# Trace example 1 with this latest DFS:\n# dfs_flow(1, -1):\n#   visited[1] = True\n#   balance_for_1 = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      ans[1] == -1. u=1 (source). Must be 1 -> 2.\n#      balance_for_1 += 10 = 10.\n#      Original edge was (1,2), so ans[1] = 0 (1->2).\n#      v=2 not visited. Recurse: dfs_flow(2, 1)\n#      \n#      dfs_flow(2, 1):\n#        visited[2] = True\n#        balance_for_2 = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           ans[0] == -1. u=2 (intermediate), v=3 (sink). Must be 2 -> 3.\n#           balance_for_2 += 10 = 10.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           No recursion into n.\n#           \n#        2. Process (1, 10, 1): v=1, c=10, edge_id=1.\n#           ans[1] is 0. Already decided. Continue.\n#           \n#        Return balance_for_2 = 10. (2 needs to send 10 more flow)\n#           \n#   Back to dfs_flow(1, -1) for (2, 10, 1):\n#   (This part of the code is skipped because it's `if not visited[v]: dfs_flow(v, edge_id)`\n#   and it doesn't process the return value of dfs_flow(v, edge_id) for `u=1`'s neighbors).\n#   This is the problem. The `balance_for_u` should be updated by children.\n#   The `dfs_flow` returns the balance that needs to be resolved by the parent.\n#   For `u=1`, it doesn't have a parent.\n\n# A common way to handle this is to use a global `total_flow` or let `dfs_flow(1, -1)` return the total flow.\n# The core logic for intermediate nodes must be correct.\n# The structure of the DFS should be:\n# `dfs(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `net_flow_from_children = 0` # sum of flows from children to u, minus flows from u to children\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#     If `ans[edge_id] != -1`: continue\n#\n#     If `v == n`: # Edge to sink\n#       `ans[edge_id]` = `u->n` direction\n#       `net_flow_from_children -= c` # u sends c to n\n#     Else if `visited[v]`: # Back-edge or cross-edge\n#       `ans[edge_id]` = `v->u` direction\n#       `net_flow_from_children += c` # v sends c to u\n#     Else: # Tree edge\n#       `child_balance = dfs(v, edge_id)` # child_balance is net flow from v to u\n#       If `child_balance > 0`: # v sends flow to u\n#         `ans[edge_id]` = `v->u` direction\n#         `net_flow_from_children += c`\n#       Else: # v receives flow from u\n#         `ans[edge_id]` = `u->v` direction\n#         `net_flow_from_children -= c`\n#\n#   If `u == 1`: # Source\n#     # All flow must be outgoing.\n#     # `net_flow_from_children` should be `0` (no incoming flow to 1).\n#     # All edges `1->v` have already been set.\n#     # We need to make sure `net_flow_from_children` is 0 by the end of processing neighbors.\n#     # This means the `ans[edge_id]` for edges `1->v` must be set.\n#     # The `ans[edge_id]` for edges `v->1` must not be set.\n#     # This means for `u=1`, `child_balance` must always be `<= 0`.\n#     # If `child_balance > 0`, it means `v` wants to send flow to `1`, which is forbidden.\n#     # This is where the problem becomes critical. The problem guarantees a solution.\n#     return 0 # Source doesn't pass balance up.\n#   Else: # Intermediate or sink\n#     return `net_flow_from_children` # This is the balance to be resolved with parent.\n\n# This implies that the `ans[edge_id]` for `u=1`'s edges must be set *before* `dfs(v, edge_id)` is called.\n# And `ans[edge_id]` for `v=n`'s edges must be set *after* `dfs(u, edge_id)` returns.\n\n# The example output matches the logic if we always prioritize `1 -> v` and `u -> n`.\n# The logic for intermediate nodes must then resolve the remaining balance.\n\n# Final strategy attempt:\n# Use a queue for BFS.\n# `balance[v]` = (total flow into v) - (total flow out of v). Target `0` for `1 < v < n`.\n# `edges_to_process`: list of (u, v, c, idx) that are not yet decided.\n# `ans`: array for directions.\n# `q`: queue for BFS. Add `1` to `q`.\n\n# 1. Initialize `balance = [0]*(n+1)`, `ans = [-1]*m`.\n# 2. Add `1` to `q`.\n# 3. While `q` is not empty:\n#    `u = q.popleft()`\n#    For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#      If `ans[edge_id] != -1`: continue\n#      \n#      If `u == 1`: # Source rule\n#        `ans[edge_id]` = `1->v` direction.\n#        `balance[u] -= c` # Flow leaves u\n#        `balance[v] += c` # Flow enters v\n#        `q.append(v)` (add to queue to process `v` later)\n#      Else if `v == n`: # Sink rule\n#        `ans[edge_id]` = `u->n` direction.\n#        `balance[u] -= c` # Flow leaves u\n#        `balance[v] += c` # Flow enters v\n#        `q.append(u)` (add u to queue to process its other edges)\n#      Else: # Intermediate nodes\n#        # This is where the DFS with post-order traversal is better.\n#        # BFS can't easily guarantee topological order for acyclicity.\n#        # The DFS approach with `child_net_flow_out` is the most standard for this.\n\n# The issue with my DFS was the \"back-edge\" rule.\n# The problem statement says the obtained directed graph does not have cycles.\n# If `v` is visited (and not parent), and `v` is an ancestor of `u` in DFS tree, then `u->v` creates a cycle. So `v->u`.\n# If `v` is in a different subtree (cross-edge), then `u->v` or `v->u` might be fine.\n# But the `dfs_flow` only returns the balance for the parent edge.\n# The rule `v->u` for back-edges ensures acyclicity in the DFS tree.\n\n# Let's use the standard Python recursion depth limit increase.\n# The last DFS approach (with separate handling for source, sink, back-edges, tree-edges):\n\nimport sys\nsys.setrecursionlimit(2 * 10**5 + 500) # Increased recursion limit\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n    n = int(n)\n    m = int(m)\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c) for original edge to determine 0/1\n\n    for i in range(m):\n        u, v, c = map(sys.stdin.readline().split())\n        u = int(u)\n        v = int(v)\n        c = int(c)\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v, c))\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    \n    # dfs_flow(u, p_edge_id) returns the net flow that needs to be sent *out* of u\n    # through the edge (u, parent) to make u balanced with its subtree.\n    def dfs_flow(u, p_edge_id):\n        visited[u] = True\n        \n        # balance_for_u: net flow that u sends out to its children, minus flow it receives from children.\n        # This is the flow that u needs to resolve with its parent.\n        balance_for_u = 0 \n\n        for v, c, edge_id in adj[u]:\n            if edge_id == p_edge_id:\n                continue\n\n            if ans[edge_id] != -1: # Direction for this edge already decided by other endpoint\n                continue\n            \n            # Case 1: Edge to the sink (n)\n            if v == n:\n                # Flow must go u -> n. This contributes to u's outgoing flow.\n                balance_for_u += c\n                if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> n\n                else: ans[edge_id] = 1 # u -> n (original edge was v-u)\n            # Case 2: Back-edge or cross-edge to an already visited node (not parent, not sink)\n            elif visited[v]:\n                # To maintain acyclicity, flow must go from v to u.\n                # This contributes to u's incoming flow.\n                balance_for_u -= c\n                if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n                else: ans[edge_id] = 0 # v -> u (original edge was v-u)\n            # Case 3: Tree edge, v is a child\n            else:\n                child_net_flow_out = dfs_flow(v, edge_id)\n                \n                # child_net_flow_out > 0 means v has an excess of outgoing flow (v sends to u).\n                # child_net_flow_out < 0 means v has a deficit of outgoing flow (v receives from u).\n                \n                if child_net_flow_out > 0: # v sends flow to u\n                    balance_for_u -= c # c flows into u\n                    if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n                    else: ans[edge_id] = 0 # v -> u\n                elif child_net_flow_out < 0: # v receives flow from u\n                    balance_for_u += c # c flows out of u\n                    if edges[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n                    else: ans[edge_id] = 1 # u -> v\n                # The problem guarantees a solution, so child_net_flow_out will always be `c` or `-c`.\n                # Hence, no need to handle child_net_flow_out == 0 explicitly for flow-carrying edges.\n\n        return balance_for_u\n\n    # Start DFS from source node 1.\n    # The return value of dfs_flow(1, -1) will be the total max flow out of source 1.\n    dfs_flow(1, -1)\n\n    # Print the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n    n = int(n)\n    m = int(m)\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c, original_index)\n\n    for i in range(m):\n        u, v, c = map(sys.stdin.readline().split())\n        u = int(u)\n        v = int(v)\n        c = int(c)\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v, c))\n\n    ans = [-1] * m\n    \n    # current_balance[v] = (sum of flow directed OUT of v) - (sum of flow directed INTO v)\n    # We want current_balance[v] == 0 for 1 < v < n.\n    # We use a DFS traversal. For each node u, we determine the flow balance\n    # for all edges in its subtree. When returning from dfs(v) to u,\n    # if v has a non-zero balance, it means v needs to send/receive flow\n    # through the edge (u, v).\n    \n    current_balance = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    # Stack for iterative DFS to avoid recursion depth limit\n    # Each element in stack: (u, parent_edge_idx, neighbor_idx)\n    # neighbor_idx helps track which neighbor we are processing for u\n    dfs_stack = [(1, -1, 0)] # Start DFS from node 1, no parent edge, start with 0th neighbor\n    visited[1] = True\n\n    # Store the order of nodes to process their neighbors.\n    # This is effectively a topological sort in reverse for back-propagation.\n    dfs_order = [] \n\n    while dfs_stack:\n        u, parent_edge_idx, neighbor_idx = dfs_stack[-1]\n\n        if neighbor_idx < len(adj[u]):\n            v, c, edge_id = adj[u][neighbor_idx]\n            dfs_stack[-1] = (u, parent_edge_idx, neighbor_idx + 1) # Prepare for next neighbor\n\n            if v == n: # Special handling for sink node\n                # If u is not the source, and this is the only path to sink...\n                # We prioritize directing flow away from u towards v=n for now.\n                # This will be adjusted if u's balance requires it.\n                # For now, let's just mark it as visited and don't recurse.\n                # The balance will be resolved when returning from DFS.\n                continue \n            \n            if not visited[v]:\n                visited[v] = True\n                dfs_stack.append((v, edge_id, 0)) # Push v onto stack\n        else:\n            # All neighbors of u have been processed (or pushed to stack).\n            # Now, u is ready to be added to dfs_order, and its balance can be finalized\n            # relative to its parent.\n            dfs_order.append(u)\n            dfs_stack.pop()\n\n    # Now process nodes in reverse DFS order to determine directions and balances\n    # The last node added to dfs_order is the deepest node in the DFS tree.\n    # The first node added to dfs_order is the root (1).\n    # We need to process from deepest to shallowest, so iterate dfs_order in reverse.\n    \n    # The order should be: process children first, then parent.\n    # So, when we pop from DFS stack, that's when we know all children are processed.\n    # The dfs_order already stores nodes in post-order traversal.\n    # We need to iterate dfs_order in reverse to propagate balance up.\n    \n    # dfs_order contains nodes in post-order traversal (children before parent)\n    # Example: 1 -> 2 -> 3. dfs_order: [3, 2, 1]\n    # We need to process from 3, then 2, then 1.\n    \n    # The `ans` array stores 0 for a_i -> b_i and 1 for b_i -> a_i.\n    # edges_info[i] = (original_u, original_v, c)\n    \n    for u in dfs_order:\n        # For each edge (u, v, c, edge_id) connected to u\n        for v_neighbor, c, edge_id in adj[u]:\n            # If this edge direction is not yet decided (ans[edge_id] == -1)\n            # and v_neighbor is not the sink (n)\n            # (Edges to sink are special, they will be handled by the balance propagation)\n            \n            # This logic needs to be careful. The DFS order is crucial.\n            # When we are at node `u`, and we are propagating balance upwards:\n            #   - If `u` is `n` (sink), all its edges must be incoming. We don't adjust `n`'s balance.\n            #   - If `u` is `1` (source), all its edges must be outgoing. We don't adjust `1`'s balance based on parent.\n            #   - If `u` is an intermediate node (1 < u < n):\n            #       Its current_balance[u] represents the net flow it has sent out to its children.\n            #       If current_balance[u] > 0, it means u has sent out more flow than it received from its children.\n            #           It needs to receive flow from its parent. So, the edge to its parent should be `parent -> u`.\n            #       If current_balance[u] < 0, it means u has received more flow than it sent out to its children.\n            #           It needs to send flow to its parent. So, the edge to its parent should be `u -> parent`.\n            #       If current_balance[u] == 0, it means u is balanced with its children. The edge to its parent could be either way, but we need to ensure acyclicity.\n            #       The problem guarantees a solution, so this balance will always work out.\n            \n            # The DFS structure:\n            # dfs(u, p_edge_id):\n            #   visited[u] = true\n            #   for (v, c, edge_id) in adj[u]:\n            #     if edge_id == p_edge_id: continue\n            #     if v == n:\n            #       # This is an edge to the sink. We must direct it u -> n.\n            #       # This contributes to u's outgoing flow.\n            #       current_balance[u] += c\n            #       ans[edge_id] = 0 if edges_info[edge_id][0] == u else 1\n            #     elif not visited[v]:\n            #       # Recurse on child v\n            #       dfs(v, edge_id)\n            #       # After child v returns, its balance needs to be resolved with u\n            #       if current_balance[v] > 0: # v sent out more than it received from its subtree\n            #         # v needs to receive flow from u. So u -> v.\n            #         current_balance[u] += current_balance[v]\n            #         ans[edge_id] = 0 if edges_info[edge_id][0] == u else 1\n            #       elif current_balance[v] < 0: # v received more than it sent out to its subtree\n            #         # v needs to send flow to u. So v -> u.\n            #         current_balance[u] += current_balance[v] # This is effectively current_balance[u] - abs(current_balance[v])\n            #         ans[edge_id] = 1 if edges_info[edge_id][0] == u else 0\n            #       # If current_balance[v] == 0, it means v is balanced within its subtree and with u.\n            #       # This edge (u,v) does not carry any \"net\" flow for balancing.\n            #       # This is where the problem becomes tricky. The \"flow volume ci\" is given.\n            #       # We can't just sum up arbitrary balances.\n            #       # The balance must be exactly 0 for intermediate nodes.\n            #       # The value 'c' on the edge is the *amount* of flow.\n            #       # So if v needs to send 'X' flow to u, and this edge is (u,v) with capacity 'c', then X must be c.\n            #       # This means current_balance[v] must be c or -c.\n            #     else: # v is visited and not parent (cross/forward edge)\n            #       # This edge forms a cycle if directed u -> v.\n            #       # So it must be directed v -> u.\n            #       current_balance[u] -= c\n            #       ans[edge_id] = 1 if edges_info[edge_id][0] == u else 0\n            \n            # The above logic is flawed because `current_balance[v]` is the net flow *from* v.\n            # If `current_balance[v]` is positive, it means `v` has an excess of outgoing flow.\n            # This excess must be sent to `u` via the edge `(u, v)`. So flow is `v -> u`.\n            # If `current_balance[v]` is negative, it means `v` has a deficit of outgoing flow (excess incoming flow).\n            # This deficit must be covered by `u` sending flow to `v` via the edge `(u, v)`. So flow is `u -> v`.\n            # The magnitude of this flow is `abs(current_balance[v])`.\n            # This `abs(current_balance[v])` must be equal to `c` for the edge `(u, v, c)`.\n\n    # Let's restart with a simpler DFS structure based on the \"balance\" for each node.\n    # `balance[u]` will store the sum of `c` for edges directed `u -> X` minus `c` for edges directed `X -> u`.\n    # For `1 < u < n`, we want `balance[u]` to be `0` at the end.\n    # For `u = 1`, `balance[1]` will be the total max flow (positive).\n    # For `u = n`, `balance[n]` will be -total max flow (negative).\n    \n    # `dfs_flow(u, p_edge_id)` returns the net flow that needs to be sent *out* of `u` through the edge `(u, parent)`\n    # to make `u` balanced with its subtree.\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    \n    def dfs_flow(u, p_edge_id):\n        visited[u] = True\n        \n        # flow_out_of_u_in_subtree: sum of c for edges directed u -> child, minus sum of c for edges directed child -> u\n        # in the subtree rooted at u (excluding the edge to parent).\n        flow_out_of_u_in_subtree = 0 \n\n        for v, c, edge_id in adj[u]:\n            if edge_id == p_edge_id:\n                continue\n\n            if visited[v]:\n                # This is a back-edge (or cross-edge).\n                # To maintain acyclicity and ensure flow from 1 to n,\n                # any such edge must be directed away from the \"earlier\" node in DFS traversal.\n                # Since v is already visited, it means v is an ancestor or a node in a different subtree.\n                # To prevent cycles, we direct flow from v to u. (This is a common strategy in DFS-based flow problems).\n                # This makes `c` flow *into* `u`.\n                if ans[edge_id] == -1: # Only decide if not already decided by v\n                    if edges_info[edge_id][0] == u: # Original edge was u-v\n                        ans[edge_id] = 1 # v -> u\n                    else: # Original edge was v-u\n                        ans[edge_id] = 0 # v -> u\n                    flow_out_of_u_in_subtree -= c # c flows into u\n            else:\n                # v is a child in the DFS tree. Recurse.\n                # child_net_flow_out is the flow that v needs to send out through (v,u)\n                # to balance itself with its subtree.\n                child_net_flow_out = dfs_flow(v, edge_id)\n                \n                # Now, use child_net_flow_out to determine direction for edge (u,v,c)\n                if child_net_flow_out > 0:\n                    # v has an excess of outgoing flow (sent out more than it received in its subtree).\n                    # This excess must be sent to u. So, flow is v -> u.\n                    # The amount is child_net_flow_out. This must be equal to c.\n                    # This means c flows *into* u.\n                    if edges_info[edge_id][0] == u: # Original edge was u-v\n                        ans[edge_id] = 1 # v -> u\n                    else: # Original edge was v-u\n                        ans[edge_id] = 0 # v -> u\n                    flow_out_of_u_in_subtree -= c # c flows into u\n                elif child_net_flow_out < 0:\n                    # v has a deficit of outgoing flow (received more than it sent out in its subtree).\n                    # This deficit must be covered by u sending flow to v. So, flow is u -> v.\n                    # The amount is abs(child_net_flow_out). This must be equal to c.\n                    # This means c flows *out* of u.\n                    if edges_info[edge_id][0] == u: # Original edge was u-v\n                        ans[edge_id] = 0 # u -> v\n                    else: # Original edge was v-u\n                        ans[edge_id] = 1 # u -> v\n                    flow_out_of_u_in_subtree += c # c flows out of u\n                # If child_net_flow_out == 0, it means v is balanced within its subtree and with u.\n                # This edge (u,v) does not carry any net flow for balancing. This case is tricky.\n                # However, the problem guarantees a solution. This implies that for any intermediate node,\n                # the sum of flow volumes of edges directed into it must equal the sum of flow volumes\n                # of edges directed out of it.\n                # This means `child_net_flow_out` will never be 0 for an edge that *needs* to carry flow.\n                # It will always be `c` or `-c`.\n        \n        # After processing all neighbors, determine what u needs to do with its parent.\n        if u == 1: # Source node\n            # All edges connected to 1 must be outgoing.\n            # The flow_out_of_u_in_subtree should represent the total max flow.\n            # This means any edge (1,v) that wasn't directed u->v by the `child_net_flow_out < 0` case\n            # must be directed 1->v.\n            # Let's re-check the logic.\n            \n            # The problem is that the `dfs_flow` function needs to return the \"net flow\"\n            # that is passed through the parent edge.\n            # For node `u`, `flow_out_of_u_in_subtree` is the sum of flows that `u` sends out to its children\n            # minus flows that `u` receives from its children.\n            # If `u` is an intermediate node (1 < u < n), its total net flow must be 0.\n            # So, if `flow_out_of_u_in_subtree` is `X`, it means `u` needs to receive `X` from its parent\n            # (if X > 0) or send `|X|` to its parent (if X < 0).\n            # This `X` is returned.\n            \n            # If `u` is the sink (`n`), it must receive all flow.\n            # So `flow_out_of_u_in_subtree` should be `0` (it sends nothing out).\n            # Any flow directed `u -> X` is wrong.\n            # For sink `n`, `child_net_flow_out` will always be negative, meaning children send flow to `n`.\n            # So, `flow_out_of_n_in_subtree` should be `0`.\n            return flow_out_of_u_in_subtree\n        elif u == n: # Sink node\n            # The sink must have all flow incoming.\n            # Its `flow_out_of_u_in_subtree` must be 0, as it sends no flow out.\n            # Any non-zero value implies an error or needs to be absorbed by the parent.\n            # The problem guarantees a solution, so this should work out.\n            return flow_out_of_u_in_subtree # Should effectively be 0\n        else: # Intermediate node\n            # The net flow for an intermediate node must be 0.\n            # So, whatever `flow_out_of_u_in_subtree` is, that amount must be balanced by the parent edge.\n            # If `flow_out_of_u_in_subtree` is positive, `u` needs to receive this amount from its parent.\n            # If `flow_out_of_u_in_subtree` is negative, `u` needs to send this amount to its parent.\n            return flow_out_of_u_in_subtree\n\n    # Call DFS from source node 1\n    # The return value for dfs_flow(1, -1) should be the total max flow.\n    dfs_flow(1, -1)\n\n    # Print the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\n# This DFS logic is standard for tree-like flows.\n# Let's verify the edge cases:\n# - Vertex 1 (source): No incoming edges. This means `flow_out_of_u_in_subtree` for u=1 will be `total_max_flow`.\n#   All edges connected to 1 will be directed `1 -> v`.\n#   This is handled by the `child_net_flow_out < 0` case for children `v` of `1`.\n#   If `v` is a child of `1`, and `dfs_flow(v, edge_id)` returns `child_net_flow_out < 0`,\n#   it means `v` needs to receive flow from `1`. So `1 -> v`. This is correct.\n#   If `dfs_flow(v, edge_id)` returns `child_net_flow_out > 0`, it means `v` needs to send flow to `1`.\n#   This would imply `v -> 1`, which is an incoming edge to 1, violating condition 2.\n#   This implies `child_net_flow_out` must always be <= 0 for children of 1.\n#   This is not necessarily true. For example, 1 -> 2 <- 3. If 3 is a child of 2.\n#   The guarantee \"a solution always exists\" is strong.\n#   The core idea is that `current_balance[u]` accumulates signed flow amounts.\n#   When returning from `dfs(v)`, `current_balance[v]` is the net flow *out* of `v` accumulated from its subtree.\n#   This value `current_balance[v]` must be *resolved* by the edge `(u, v)`.\n#   So, `abs(current_balance[v])` must be equal to `c` of edge `(u, v, c)`.\n\n# Let's try to trace the logic with a small example:\n# 3 3\n# 3 2 10 (edge 0)\n# 1 2 10 (edge 1)\n# 3 1 5  (edge 2)\n\n# adj:\n# 1: [(2, 10, 1), (3, 5, 2)]\n# 2: [(3, 10, 0), (1, 10, 1)]\n# 3: [(2, 10, 0), (1, 5, 2)]\n\n# dfs_flow(1, -1):\n#   visited[1] = True\n#   flow_out_of_1_in_subtree = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      v=2 not visited. Recurse: child_net_flow_out = dfs_flow(2, 1)\n#      \n#      dfs_flow(2, 1):\n#        visited[2] = True\n#        flow_out_of_2_in_subtree = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           v=3 not visited. Recurse: child_net_flow_out_3 = dfs_flow(3, 0)\n#           \n#           dfs_flow(3, 0):\n#             visited[3] = True\n#             flow_out_of_3_in_subtree = 0\n#             Neighbors of 3: (2, 10, 0), (1, 5, 2)\n#             \n#             1. Process (2, 10, 0): v=2, c=10, edge_id=0. This is parent_edge_id. Continue.\n#             2. Process (1, 5, 2): v=1, c=5, edge_id=2\n#                v=1 is visited. This is a back-edge to the root (1).\n#                Direct v -> u, i.e., 1 -> 3. (This is where the rule needs to be careful)\n#                The rule \"direct v -> u\" (v=1, u=3) means flow 1 -> 3.\n#                Original edge was (3,1), so ans[2] = 1 (1->3).\n#                flow_out_of_3_in_subtree -= c (5) = -5. (Flow 5 comes into 3).\n#             \n#             Return flow_out_of_3_in_subtree = -5.\n#           \n#           Back to dfs_flow(2, 1) for (3, 10, 0):\n#           child_net_flow_out_3 = -5.\n#           Since it's < 0, v=3 needs to receive flow from u=2. So 2 -> 3.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           flow_out_of_2_in_subtree += c (10) = 10. (Flow 10 goes out of 2).\n#           \n#           2. Process (1, 10, 1): v=1, c=10, edge_id=1. This is parent_edge_id. Continue.\n#           \n#           Return flow_out_of_2_in_subtree = 10.\n#           \n#   Back to dfs_flow(1, -1) for (2, 10, 1):\n#   child_net_flow_out = 10.\n#   Since it's > 0, v=2 needs to send flow to u=1. So 2 -> 1.\n#   Original edge was (1,2), so ans[1] = 1 (2->1).\n#   flow_out_of_1_in_subtree -= c (10) = -10. (Flow 10 comes into 1).\n#\n#   2. Process (3, 5, 2): v=3, c=5, edge_id=2\n#      v=3 is visited. This is a back-edge.\n#      Direct v -> u, i.e., 3 -> 1.\n#      Original edge was (3,1), so ans[2] = 0 (3->1).\n#      flow_out_of_1_in_subtree -= c (5) = -10 - 5 = -15. (Flow 5 comes into 1).\n#\n#   Return flow_out_of_1_in_subtree = -15.\n\n# This result for ans:\n# ans[0]: 1 (2->3)\n# ans[1]: 1 (2->1)\n# ans[2]: 0 (3->1)\n\n# Let's check the conditions for output:\n# 1. Vertex 1 has no incoming edges:\n#    Edge (2,1): 2->1 (incoming to 1) VIOLATED!\n#    Edge (3,1): 3->1 (incoming to 1) VIOLATED!\n\n# The DFS logic for back-edges and determining direction based on `child_net_flow_out` is incorrect\n# for the source node and potentially for other nodes.\n# The \"no incoming edges for vertex 1\" is a hard constraint.\n# The \"no cycles\" is also a hard constraint.\n\n# A more robust approach for flow problems with given edge capacities is often to use a **minimum cost maximum flow** like structure, or more simply, a potential function.\n# However, this problem is marked \"easy\". The key must be simpler.\n\n# Let's rethink the \"no incoming edges for vertex 1\" and \"no cycles\" + \"flow conservation\".\n# This implies a topological ordering starting from 1.\n# The flow must \"push\" away from 1 and \"pull\" towards n.\n\n# Consider the total flow `S` from 1 to `n`.\n# For any vertex `v` (1 < `v` < `n`), `sum(in_flow) = sum(out_flow)`.\n# For `v = 1`, `sum(out_flow) = S`.\n# For `v = n`, `sum(in_flow) = S`.\n\n# What if we use a BFS starting from `n` (the sink) and determine how much flow each node *needs* to send to `n`?\n# Or a BFS from `1` to determine how much flow each node *has* from `1`.\n\n# Let `required_flow_in_to_v` be the total flow that must enter `v` from its neighbors in the \"parent\" direction.\n# Or, let `balance[v]` be `(sum of flow directed into v) - (sum of flow directed out of v)`.\n# We want `balance[v] = 0` for `1 < v < n`.\n# `balance[1]` should be `0` (no incoming, some outgoing).\n# `balance[n]` should be `total_flow` (all incoming, no outgoing).\n\n# This problem is a variant of \"flow circulation\" or \"potential function\" problems.\n# If we assign a \"potential\" `p[v]` to each node `v`, and direct flow `u -> v` if `p[u] > p[v]`,\n# then acyclicity is guaranteed if `p` values are distinct.\n# The flow conservation `sum(in) = sum(out)` means that for each node `v`,\n# `sum_{u: u->v} c_{uv} = sum_{w: v->w} c_{vw}`.\n\n# The approach that usually works for \"find flow directions in a DAG\" is:\n# 1. Start a DFS/BFS from source (1).\n# 2. Maintain `incoming_sum[v]` and `outgoing_sum[v]` for each node `v`.\n# 3. For an edge `(u, v, c)`:\n#    If `u` is processed and `v` is not, then `u` is \"earlier\" than `v`.\n#    We can tentatively direct `u -> v`. Add `c` to `outgoing_sum[u]` and `incoming_sum[v]`.\n#    If `u` and `v` are both processed, this is a back-edge or cross-edge.\n#    To avoid cycles, we must direct from the node that was visited first to the node visited later.\n#    This is hard without knowing the full topological order.\n\n# The \"easy\" tag suggests a simple greedy approach or a standard graph algorithm.\n# The key condition \"vertex with number 1 has no incoming edges\" is very strong.\n# All edges connected to 1 must be `1 -> v`.\n# This defines the initial state for nodes adjacent to 1.\n\n# Let's use a BFS-like approach with a `current_deficit[v]` variable.\n# `current_deficit[v]` = (sum of flow directed INTO v) - (sum of flow directed OUT OF v).\n# Initially, `current_deficit[v] = 0` for all `v`.\n# `ans` array to store directions.\n# `q` for BFS. Add `1` to `q`.\n\n# When processing `u` from `q`:\n#   For each neighbor `v` of `u` with edge `(u, v, c)` (original edge `a_i, b_i, c_i` with index `idx`):\n#     If `ans[idx]` is already set, continue. (This means the other endpoint already decided direction).\n#     \n#     If `u == 1`:\n#       Must be `1 -> v`.\n#       Set `ans[idx]` appropriately.\n#       `current_deficit[v] += c`.\n#       Add `v` to `q` if not yet added.\n#     Else if `v == n`:\n#       Must be `u -> n`.\n#       Set `ans[idx]` appropriately.\n#       `current_deficit[u] -= c`.\n#       Add `u` to `q` if not yet added (though `u` might already be processed or in queue).\n#     Else (`u` is intermediate, `v` is intermediate):\n#       This is the tricky part. We need to decide `u -> v` or `v -> u`.\n#       If `current_deficit[u] < 0`: (u has sent out more flow than it received)\n#         `u` needs to receive more flow. So, `v -> u`.\n#         Set `ans[idx]` appropriately.\n#         `current_deficit[u] += c`.\n#         `current_deficit[v] -= c`.\n#         Add `v` to `q`.\n#       Else if `current_deficit[u] > 0`: (u has received more flow than it sent out)\n#         `u` needs to send out more flow. So, `u -> v`.\n#         Set `ans[idx]` appropriately.\n#         `current_deficit[u] -= c`.\n#         `current_deficit[v] += c`.\n#         Add `v` to `q`.\n#       Else (`current_deficit[u] == 0`):\n#         This is the hardest case. `u` is balanced so far.\n#         We need to pick a direction that doesn't create a cycle and allows flow to propagate.\n#         This implies a topological order.\n\n# The standard way to handle this in a DAG is a DFS post-order traversal.\n# When `dfs(u)` returns, it means all children of `u` have been visited.\n# At this point, `current_balance[u]` holds the net flow from `u` to its children.\n# If `current_balance[u]` is positive, `u` has an excess of outgoing flow. This must go to its parent.\n# So, the edge `(u, parent)` is `u -> parent`.\n# If `current_balance[u]` is negative, `u` has a deficit of outgoing flow. This must come from its parent.\n# So, the edge `(u, parent)` is `parent -> u`.\n# The magnitude `abs(current_balance[u])` must be equal to the flow `c` of the edge `(u, parent, c)`.\n\n# This relies on the fact that for all intermediate nodes `1 < u < n`, `current_balance[u]` eventually becomes 0.\n# For `u=1`, it becomes `TotalMaxFlow`. For `u=n`, it becomes `-TotalMaxFlow`.\n\n# Let's refine the DFS approach:\n# `ans`: array of size `m` for directions.\n# `visited`: boolean array for DFS.\n# `dfs_balance(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0` (this will be the net flow that `u` needs to send *out* to its parent)\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#\n#     If `v == n`: # Edge to the sink\n#       # This edge must carry flow `u -> n`.\n#       # This contributes `c` to `u`'s outgoing flow.\n#       # And `c` to `n`'s incoming flow.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#     elif visited[v]: # Back-edge or cross-edge\n#       # To maintain acyclicity and ensure flow from 1 to n,\n#       # we must direct flow from `v` to `u`. (This is a common strategy in DFS-based flow problems)\n#       # This means `c` flows *into* `u`.\n#       # This contributes `c` to `u`'s incoming flow.\n#       if ans[edge_id] == -1: # Only decide if not already decided by v\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#       balance_for_u -= c\n#     else: # Tree edge, `v` is a child\n#       # Recurse on `v`. `child_net_flow_out` is the net flow `v` sends to its parent (`u`).\n#       child_net_flow_out = dfs_balance(v, edge_id)\n#\n#       if child_net_flow_out > 0: # `v` has excess outgoing flow, sends it to `u`. So `v -> u`.\n#         # Amount is `child_net_flow_out`. This must be equal to `c`.\n#         # This means `c` flows *into* `u`.\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#         balance_for_u -= c\n#       elif child_net_flow_out < 0: # `v` has deficit outgoing flow, receives it from `u`. So `u -> v`.\n#         # Amount is `abs(child_net_flow_out)`. This must be equal to `c`.\n#         # This means `c` flows *out* of `u`.\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#         else: ans[edge_id] = 1 # u -> v\n#         balance_for_u += c\n#       # If child_net_flow_out == 0, it means the edge (u,v) does not carry net flow.\n#       # This case should not happen for a flow problem with positive capacities if a solution exists.\n#       # The problem guarantees a solution, so `child_net_flow_out` will always be `c` or `-c`.\n#       # The `child_net_flow_out` is the exact flow that needs to pass through edge (u,v).\n#       # So `abs(child_net_flow_out)` must be `c`.\n#\n#   return balance_for_u\n\n# Initial call: `dfs_balance(1, -1)`.\n# After this, `ans` array should be populated.\n\n# Let's re-trace example 1 with this refined DFS:\n# 3 3\n# 3 2 10 (edge 0)\n# 1 2 10 (edge 1)\n# 3 1 5  (edge 2)\n\n# adj:\n# 1: [(2, 10, 1), (3, 5, 2)]\n# 2: [(3, 10, 0), (1, 10, 1)]\n# 3: [(2, 10, 0), (1, 5, 2)]\n\n# dfs_balance(1, -1):\n#   visited[1] = True\n#   balance_for_1 = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      v=2 not visited. Recurse: child_net_flow_out = dfs_balance(2, 1)\n#      \n#      dfs_balance(2, 1):\n#        visited[2] = True\n#        balance_for_2 = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           v=3 not visited. Recurse: child_net_flow_out_3 = dfs_balance(3, 0)\n#           \n#           dfs_balance(3, 0):\n#             visited[3] = True\n#             balance_for_3 = 0\n#             Neighbors of 3: (2, 10, 0), (1, 5, 2)\n#             \n#             1. Process (2, 10, 0): v=2, c=10, edge_id=0. This is parent_edge_id. Continue.\n#             2. Process (1, 5, 2): v=1, c=5, edge_id=2\n#                v=1 is visited. This is a back-edge.\n#                Direct v -> u, i.e., 1 -> 3.\n#                Original edge was (3,1), so ans[2] = 1 (1->3).\n#                balance_for_3 -= c (5) = -5. (Flow 5 comes into 3).\n#             \n#             Return balance_for_3 = -5. (3 needs to receive 5 more flow)\n#           \n#           Back to dfs_balance(2, 1) for (3, 10, 0):\n#           child_net_flow_out_3 = -5.\n#           Since it's < 0, v=3 needs to receive flow from u=2. So 2 -> 3.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           balance_for_2 += c (10) = 10. (Flow 10 goes out of 2).\n#           \n#           2. Process (1, 10, 1): v=1, c=10, edge_id=1. This is parent_edge_id. Continue.\n#           \n#           Return balance_for_2 = 10. (2 needs to send 10 more flow)\n#           \n#   Back to dfs_balance(1, -1) for (2, 10, 1):\n#   child_net_flow_out = 10.\n#   Since it's > 0, v=2 needs to send flow to u=1. So 2 -> 1.\n#   Original edge was (1,2), so ans[1] = 1 (2->1).\n#   balance_for_1 -= c (10) = -10. (Flow 10 comes into 1).\n#\n#   2. Process (3, 5, 2): v=3, c=5, edge_id=2\n#      v=3 is visited. This is a back-edge.\n#      Direct v -> u, i.e., 3 -> 1.\n#      Original edge was (3,1), so ans[2] = 0 (3->1). (This overwrites previous ans[2]=1. This is an issue!)\n#      balance_for_1 -= c (5) = -10 - 5 = -15. (Flow 5 comes into 1).\n#\n#   Return balance_for_1 = -15.\n\n# The issue is that `ans[edge_id]` might be set twice.\n# When `v` is visited, and it's not the parent, it's a cross-edge or back-edge.\n# The direction for such an edge must be consistent with the topological order.\n# The rule \"direct v -> u\" (from already visited to currently visiting) is a common heuristic for acyclicity.\n# But it might contradict the \"no incoming to 1\" rule.\n\n# The problem is that the problem statement for the first test case output is:\n# 1 (3->2)\n# 0 (1->2)\n# 1 (1->3)\n# Total flow from 1: 10 (1->2) + 5 (1->3) = 15.\n# Node 2: In: 10 (from 1). Out: 10 (to 3). Balanced.\n# Node 3: In: 5 (from 1) + 10 (from 2). Out: 0 (to n, which is 3 itself).\n# Wait, n=3 is the sink. So node 3 is the sink.\n# Node 3: In: 5 (from 1) + 10 (from 2) = 15. Out: 0. This is consistent.\n# Node 1: Out: 10 (to 2) + 5 (to 3) = 15. In: 0. Consistent.\n# This solution is valid.\n\n# My DFS output:\n# ans[0]: 1 (2->3)\n# ans[1]: 1 (2->1) - INCORRECT, should be 0 (1->2)\n# ans[2]: 0 (3->1) - INCORRECT, should be 1 (1->3)\n\n# The DFS logic for back-edges needs to be fixed.\n# If `v` is visited and `v != n` and `v != 1`:\n#   If `u` is the source (1), then the edge `(1, v)` must be `1 -> v`.\n#   If `v` is the sink (n), then the edge `(u, n)` must be `u -> n`.\n#   Otherwise, if both `u` and `v` are intermediate, and `v` is already visited.\n#   This means `v` has already had its `dfs_balance` called and returned.\n#   So `v` is \"earlier\" in the DFS tree or a different subtree.\n#   To maintain acyclicity, we should direct `v -> u`.\n\n# The crucial part is that `ans[edge_id]` is set *only once*.\n# If `ans[edge_id]` is already set, it means the other endpoint `v` (or `u` if we are processing `v`'s neighbors) already decided the direction.\n# This implies that `dfs_balance` should only process edges that haven't been directed yet.\n\n# Revised DFS:\n# `ans`: array of size `m` for directions.\n# `visited`: boolean array for DFS.\n# `dfs_balance(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0` (net flow that `u` needs to send *out* to its parent)\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#\n#     If `ans[edge_id] != -1`: continue # Already decided by other endpoint\n#\n#     If `v == n`: # Edge to the sink\n#       # This edge must carry flow `u -> n`.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#     elif visited[v]: # Back-edge or cross-edge\n#       # `v` is already visited. To maintain acyclicity, flow must go from `v` to `u`.\n#       # This means `c` flows *into* `u`.\n#       balance_for_u -= c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#       else: ans[edge_id] = 0 # v -> u\n#     else: # Tree edge, `v` is a child\n#       child_net_flow_out = dfs_balance(v, edge_id)\n#\n#       if child_net_flow_out > 0: # `v` has excess outgoing flow, sends it to `u`. So `v -> u`.\n#         balance_for_u -= c # c flows into u\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#       elif child_net_flow_out < 0: # `v` has deficit outgoing flow, receives it from `u`. So `u -> v`.\n#         balance_for_u += c # c flows out of u\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#         else: ans[edge_id] = 1 # u -> v\n#       # The problem guarantees a solution, so `child_net_flow_out` will always be `c` or `-c`.\n#       # So no `else` for `child_net_flow_out == 0` is needed.\n#\n#   return balance_for_u\n\n# Initial call: `dfs_balance(1, -1)`.\n\n# Trace example 1 with REVISED DFS:\n# 3 3\n# 3 2 10 (edge 0)\n# 1 2 10 (edge 1)\n# 3 1 5  (edge 2)\n\n# dfs_balance(1, -1):\n#   visited[1] = True\n#   balance_for_1 = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      ans[1] == -1. v=2 not visited. Recurse: child_net_flow_out = dfs_balance(2, 1)\n#      \n#      dfs_balance(2, 1):\n#        visited[2] = True\n#        balance_for_2 = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           ans[0] == -1. v=3 not visited. Recurse: child_net_flow_out_3 = dfs_balance(3, 0)\n#           \n#           dfs_balance(3, 0):\n#             visited[3] = True\n#             balance_for_3 = 0\n#             Neighbors of 3: (2, 10, 0), (1, 5, 2)\n#             \n#             1. Process (2, 10, 0): v=2, c=10, edge_id=0. This is parent_edge_id. Continue.\n#             2. Process (1, 5, 2): v=1, c=5, edge_id=2\n#                ans[2] == -1. v=1 is visited. Back-edge.\n#                Direct v -> u, i.e., 1 -> 3.\n#                Original edge was (3,1), so ans[2] = 1 (1->3).\n#                balance_for_3 -= c (5) = -5. (Flow 5 comes into 3).\n#             \n#             Return balance_for_3 = -5. (3 needs to receive 5 more flow)\n#           \n#           Back to dfs_balance(2, 1) for (3, 10, 0):\n#           child_net_flow_out_3 = -5.\n#           Since it's < 0, v=3 needs to receive flow from u=2. So 2 -> 3.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           balance_for_2 += c (10) = 10. (Flow 10 goes out of 2).\n#           \n#           2. Process (1, 10, 1): v=1, c=10, edge_id=1. This is parent_edge_id. Continue.\n#           \n#           Return balance_for_2 = 10. (2 needs to send 10 more flow)\n#           \n#   Back to dfs_balance(1, -1) for (2, 10, 1):\n#   child_net_flow_out = 10.\n#   Since it's > 0, v=2 needs to send flow to u=1. So 2 -> 1.\n#   Original edge was (1,2), so ans[1] = 1 (2->1).\n#   balance_for_1 -= c (10) = -10. (Flow 10 comes into 1).\n#\n#   2. Process (3, 5, 2): v=3, c=5, edge_id=2\n#      ans[2] is now 1. This edge was already decided by dfs_balance(3,0).\n#      So, we `continue`.\n#\n#   Return balance_for_1 = -10.\n\n# Resulting `ans`:\n# ans[0]: 1 (2->3)\n# ans[1]: 1 (2->1)\n# ans[2]: 1 (1->3)\n\n# This is still not matching the example output. The example output has 1->2, 1->3, 3->2.\n# My DFS: 2->1, 1->3, 2->3.\n# The DFS is creating an incoming edge to 1 (2->1), which is forbidden.\n\n# The condition \"vertex with number 1 has no incoming edges\" means that for any edge (1, v), it *must* be 1 -> v.\n# This is a hard constraint.\n# The `dfs_balance` function should respect this.\n# If `u == 1`, then `balance_for_u` should only increase. `ans` for (1,v) should be `1->v`.\n# If `v == 1`, then `balance_for_u` should only decrease. `ans` for (u,1) should be `u->1`.\n\n# Let's modify the DFS to explicitly handle the source (1) and sink (n).\n# `dfs_balance(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0`\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#     If `ans[edge_id] != -1`: continue\n#\n#     If `u == 1`: # Source node\n#       # Must be 1 -> v.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#       # If v is not visited, recurse.\n#       if not visited[v]: dfs_balance(v, edge_id)\n#     elif v == n: # Edge to the sink\n#       # Must be u -> n.\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#       else: ans[edge_id] = 1\n#       # No recursion into n, it's a sink.\n#     elif visited[v]: # Back-edge or cross-edge involving intermediate nodes\n#       # Direct v -> u to maintain acyclicity.\n#       balance_for_u -= c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 1\n#       else: ans[edge_id] = 0\n#     else: # Tree edge, `v` is a child, and both `u, v` are intermediate\n#       child_net_flow_out = dfs_balance(v, edge_id)\n#       if child_net_flow_out > 0: # `v` sends to `u`. So `v -> u`.\n#         balance_for_u -= c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1\n#         else: ans[edge_id] = 0\n#       elif child_net_flow_out < 0: # `v` receives from `u`. So `u -> v`.\n#         balance_for_u += c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0\n#         else: ans[edge_id] = 1\n#\n#   return balance_for_u\n\n# This logic is still problematic because `dfs_balance` returns a value, but if `u=1`, its value is not used by a parent.\n# The `balance_for_u` for `u=1` is the total flow, which is fine.\n# But `visited[v]` check for `u=1`'s neighbors is also tricky.\n# If `u=1` and `v` is visited, it implies `v` is an ancestor of `1` (impossible) or in a separate component (impossible, connected graph).\n# So for `u=1`, `v` will always be `not visited` (unless `v=n` and `n` was visited somehow).\n\n# The example output's directions:\n# 1 -> 2 (10)\n# 1 -> 3 (5)\n# 2 -> 3 (10)\n\n# The total flow is 15.\n# For node 1: out = 15, in = 0.\n# For node 2: in = 10 (from 1), out = 10 (to 3). Balance = 0.\n# For node 3: in = 5 (from 1) + 10 (from 2) = 15. out = 0. Balance = 0.\n\n# This implies that all edges must be directed \"downstream\" from 1 to 3.\n# The DFS should naturally find this.\n\n# Let's try the provided solution from a competitive programming context.\n# Usually this involves a DFS from the source.\n# `flow[u]` is the net flow *out* of `u` from its children.\n# `dfs(u, p)`:\n#   `visited[u] = true`\n#   `current_out_flow = 0`\n#   For each edge `(u, v, c, idx)`:\n#     If `v == p`: continue\n#     If `v == n`: # Edge to sink\n#       `current_out_flow += c`\n#       `ans[idx]` = `u->n`\n#     Else if `visited[v]`: # Back-edge to an ancestor or cross-edge\n#       # This edge must be directed `v -> u` to avoid cycles.\n#       `current_out_flow -= c`\n#       `ans[idx]` = `v->u`\n#     Else: # Tree edge\n#       `child_net_flow = dfs(v, u)`\n#       If `child_net_flow > 0`: # v has excess, sends to u: v -> u\n#         `current_out_flow -= c`\n#         `ans[idx]` = `v->u`\n#       Else: # v has deficit, receives from u: u -> v\n#         `current_out_flow += c`\n#         `ans[idx]` = `u->v`\n#   Return `current_out_flow`.\n\n# This is the exact same logic as my refined DFS. Why does it fail for the example?\n# The problem is the \"no incoming edges for vertex 1\".\n# If `u=1`, the `current_out_flow -= c` for `v->u` is wrong. It implies flow into 1.\n# So, the logic `if u==1` must be special.\n\n# Special handling for `u=1`:\n# `dfs(1, -1)`:\n#   `visited[1] = true`\n#   `current_out_flow = 0`\n#   For each edge `(1, v, c, idx)`:\n#     If `v == n`: # Edge to sink\n#       `current_out_flow += c`\n#       `ans[idx]` = `1->n`\n#     Else: # `v` is an intermediate node\n#       # For `u=1`, all edges must be outgoing. So `1 -> v`.\n#       `current_out_flow += c`\n#       `ans[idx]` = `1->v`\n#       If `not visited[v]`:\n#         `dfs(v, 1)` # Recurse\n#   Return `current_out_flow`. (This is the total max flow)\n\n# This is a bit different. The `dfs` for `u=1` does not rely on `child_net_flow` for its own edges.\n# It just directs them all outwards.\n# Then, for `v` (child of 1), `dfs(v, 1)` will behave normally.\n\n# Let's try this (simplified) DFS:\n# `ans`: array of size `m` for directions.\n# `visited`: boolean array for DFS.\n# `dfs_flow(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `balance_for_u = 0` # Net flow that `u` needs to send *out* to its parent\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#     If `ans[edge_id] != -1`: continue # Already decided by other endpoint\n#\n#     If `u == 1`: # Source node: ALL edges must be outgoing\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#       else: ans[edge_id] = 1 # u -> v\n#       if not visited[v]: dfs_flow(v, edge_id) # Recurse\n#     elif v == n: # Edge to the sink: ALL edges must be incoming to n\n#       balance_for_u += c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> n\n#       else: ans[edge_id] = 1 # u -> n\n#       # No recursion into n, it's a sink.\n#     elif visited[v]: # Back-edge or cross-edge (u, v are intermediate)\n#       # Direct v -> u to maintain acyclicity.\n#       balance_for_u -= c\n#       if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#       else: ans[edge_id] = 0 # v -> u\n#     else: # Tree edge, `v` is a child, `u, v` are intermediate\n#       child_net_flow_out = dfs_flow(v, edge_id)\n#\n#       if child_net_flow_out > 0: # `v` sends to `u`. So `v -> u`.\n#         balance_for_u -= c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n#         else: ans[edge_id] = 0 # v -> u\n#       elif child_net_flow_out < 0: # `v` receives from `u`. So `u -> v`.\n#         balance_for_u += c\n#         if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n#         else: ans[edge_id] = 1 # u -> v\n#\n#   return balance_for_u\n\n# Trace example 1 with this latest DFS:\n# dfs_flow(1, -1):\n#   visited[1] = True\n#   balance_for_1 = 0\n#   Neighbors of 1: (2, 10, 1), (3, 5, 2)\n#   \n#   1. Process (2, 10, 1): v=2, c=10, edge_id=1\n#      ans[1] == -1. u=1 (source). Must be 1 -> 2.\n#      balance_for_1 += 10 = 10.\n#      Original edge was (1,2), so ans[1] = 0 (1->2).\n#      v=2 not visited. Recurse: dfs_flow(2, 1)\n#      \n#      dfs_flow(2, 1):\n#        visited[2] = True\n#        balance_for_2 = 0\n#        Neighbors of 2: (3, 10, 0), (1, 10, 1)\n#        \n#        1. Process (3, 10, 0): v=3, c=10, edge_id=0\n#           ans[0] == -1. u=2 (intermediate), v=3 (sink). Must be 2 -> 3.\n#           balance_for_2 += 10 = 10.\n#           Original edge was (3,2), so ans[0] = 1 (2->3).\n#           No recursion into n.\n#           \n#        2. Process (1, 10, 1): v=1, c=10, edge_id=1.\n#           ans[1] is 0. Already decided. Continue.\n#           \n#        Return balance_for_2 = 10. (2 needs to send 10 more flow)\n#           \n#   Back to dfs_flow(1, -1) for (2, 10, 1):\n#   (This part of the code is skipped because it's `if not visited[v]: dfs_flow(v, edge_id)`\n#   and it doesn't process the return value of dfs_flow(v, edge_id) for `u=1`'s neighbors).\n#   This is the problem. The `balance_for_u` should be updated by children.\n#   The `dfs_flow` returns the balance that needs to be resolved by the parent.\n#   For `u=1`, it doesn't have a parent.\n\n# A common way to handle this is to use a global `total_flow` or let `dfs_flow(1, -1)` return the total flow.\n# The core logic for intermediate nodes must be correct.\n# The structure of the DFS should be:\n# `dfs(u, p_edge_id)`:\n#   `visited[u] = True`\n#   `net_flow_from_children = 0` # sum of flows from children to u, minus flows from u to children\n#\n#   For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#     If `edge_id == p_edge_id`: continue\n#     If `ans[edge_id] != -1`: continue\n#\n#     If `v == n`: # Edge to sink\n#       `ans[edge_id]` = `u->n` direction\n#       `net_flow_from_children -= c` # u sends c to n\n#     Else if `visited[v]`: # Back-edge or cross-edge\n#       `ans[edge_id]` = `v->u` direction\n#       `net_flow_from_children += c` # v sends c to u\n#     Else: # Tree edge\n#       `child_balance = dfs(v, edge_id)` # child_balance is net flow from v to u\n#       If `child_balance > 0`: # v sends flow to u\n#         `ans[edge_id]` = `v->u` direction\n#         `net_flow_from_children += c`\n#       Else: # v receives flow from u\n#         `ans[edge_id]` = `u->v` direction\n#         `net_flow_from_children -= c`\n#\n#   If `u == 1`: # Source\n#     # All flow must be outgoing.\n#     # `net_flow_from_children` should be `0` (no incoming flow to 1).\n#     # All edges `1->v` have already been set.\n#     # We need to make sure `net_flow_from_children` is 0 by the end of processing neighbors.\n#     # This means the `ans[edge_id]` for edges `1->v` must be set.\n#     # The `ans[edge_id]` for edges `v->1` must not be set.\n#     # This means for `u=1`, `child_balance` must always be `<= 0`.\n#     # If `child_balance > 0`, it means `v` wants to send flow to `1`, which is forbidden.\n#     # This is where the problem becomes critical. The problem guarantees a solution.\n#     return 0 # Source doesn't pass balance up.\n#   Else: # Intermediate or sink\n#     return `net_flow_from_children` # This is the balance to be resolved with parent.\n\n# This implies that the `ans[edge_id]` for `u=1`'s edges must be set *before* `dfs(v, edge_id)` is called.\n# And `ans[edge_id]` for `v=n`'s edges must be set *after* `dfs(u, edge_id)` returns.\n\n# The example output matches the logic if we always prioritize `1 -> v` and `u -> n`.\n# The logic for intermediate nodes must then resolve the remaining balance.\n\n# Final strategy attempt:\n# Use a queue for BFS.\n# `balance[v]` = (total flow into v) - (total flow out of v). Target `0` for `1 < v < n`.\n# `edges_to_process`: list of (u, v, c, idx) that are not yet decided.\n# `ans`: array for directions.\n# `q`: queue for BFS. Add `1` to `q`.\n\n# 1. Initialize `balance = [0]*(n+1)`, `ans = [-1]*m`.\n# 2. Add `1` to `q`.\n# 3. While `q` is not empty:\n#    `u = q.popleft()`\n#    For each neighbor `v` of `u` with edge `(u, v, c)` and `edge_id`:\n#      If `ans[edge_id] != -1`: continue\n#      \n#      If `u == 1`: # Source rule\n#        `ans[edge_id]` = `1->v` direction.\n#        `balance[u] -= c` # Flow leaves u\n#        `balance[v] += c` # Flow enters v\n#        `q.append(v)` (add to queue to process `v` later)\n#      Else if `v == n`: # Sink rule\n#        `ans[edge_id]` = `u->n` direction.\n#        `balance[u] -= c` # Flow leaves u\n#        `balance[v] += c` # Flow enters v\n#        `q.append(u)` (add u to queue to process its other edges)\n#      Else: # Intermediate nodes\n#        # This is where the DFS with post-order traversal is better.\n#        # BFS can't easily guarantee topological order for acyclicity.\n#        # The DFS approach with `child_net_flow_out` is the most standard for this.\n\n# The issue with my DFS was the \"back-edge\" rule.\n# The problem statement says the obtained directed graph does not have cycles.\n# If `v` is visited (and not parent), and `v` is an ancestor of `u` in DFS tree, then `u->v` creates a cycle. So `v->u`.\n# If `v` is in a different subtree (cross-edge), then `u->v` or `v->u` might be fine.\n# But the `dfs_flow` only returns the balance for the parent edge.\n# The rule `v->u` for back-edges ensures acyclicity in the DFS tree.\n\n# Let's use the standard Python recursion depth limit increase.\n# The last DFS approach (with separate handling for source, sink, back-edges, tree-edges):\n\nimport sys\nsys.setrecursionlimit(2 * 10**5 + 500) # Increased recursion limit\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n    n = int(n)\n    m = int(m)\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c) for original edge to determine 0/1\n\n    for i in range(m):\n        u, v, c = map(sys.stdin.readline().split())\n        u = int(u)\n        v = int(v)\n        c = int(c)\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v, c))\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    \n    # dfs_flow(u, p_edge_id) returns the net flow that needs to be sent *out* of u\n    # through the edge (u, parent) to make u balanced with its subtree.\n    def dfs_flow(u, p_edge_id):\n        visited[u] = True\n        \n        # balance_for_u: net flow that u sends out to its children, minus flow it receives from children.\n        # This is the flow that u needs to resolve with its parent.\n        balance_for_u = 0 \n\n        for v, c, edge_id in adj[u]:\n            if edge_id == p_edge_id:\n                continue\n\n            if ans[edge_id] != -1: # Direction for this edge already decided by other endpoint\n                continue\n            \n            # Case 1: Edge to the sink (n)\n            if v == n:\n                # Flow must go u -> n. This contributes to u's outgoing flow.\n                balance_for_u += c\n                if edges_info[edge_id][0] == u: ans[edge_id] = 0 # u -> n\n                else: ans[edge_id] = 1 # u -> n (original edge was v-u)\n            # Case 2: Back-edge or cross-edge to an already visited node (not parent, not sink)\n            elif visited[v]:\n                # To maintain acyclicity, flow must go from v to u.\n                # This contributes to u's incoming flow.\n                balance_for_u -= c\n                if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n                else: ans[edge_id] = 0 # v -> u (original edge was v-u)\n            # Case 3: Tree edge, v is a child\n            else:\n                child_net_flow_out = dfs_flow(v, edge_id)\n                \n                # child_net_flow_out > 0 means v has an excess of outgoing flow (v sends to u).\n                # child_net_flow_out < 0 means v has a deficit of outgoing flow (v receives from u).\n                \n                if child_net_flow_out > 0: # v sends flow to u\n                    balance_for_u -= c # c flows into u\n                    if edges_info[edge_id][0] == u: ans[edge_id] = 1 # v -> u\n                    else: ans[edge_id] = 0 # v -> u\n                elif child_net_flow_out < 0: # v receives flow from u\n                    balance_for_u += c # c flows out of u\n                    if edges[edge_id][0] == u: ans[edge_id] = 0 # u -> v\n                    else: ans[edge_id] = 1 # u -> v\n                # The problem guarantees a solution, so child_net_flow_out will always be `c` or `-c`.\n                # Hence, no need to handle child_net_flow_out == 0 explicitly for flow-carrying edges.\n\n        return balance_for_u\n\n    # Start DFS from source node 1.\n    # The return value of dfs_flow(1, -1) will be the total max flow out of source 1.\n    dfs_flow(1, -1)\n\n    # Print the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 20577,
        "thoughts_token_count": 812
    }
}