{
    "start": 1758284961.19924,
    "end": 1758284990.1341891,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Thinking Through the Competitive Programming Problem**\n\nOkay, so I'm tasked with writing a Python script for a competitive programming problem. Let's break down what's going on. The core idea seems to revolve around directed graphs and reachability. We're dealing with \"unidirectional pairs\" and \"p-reachable graphs,\" which need precise definitions.\n\nI see that a \"p-reachable graph\" is one that has exactly `p` ordered pairs `(u, v)` where `u < v` and both `u` and `v` are reachable from each other. That means they're part of the same Strongly Connected Component (SCC). My goal is to find the smallest number of nodes (`N`) needed to create a `p`-reachable graph, and then maximize the unidirectional pairs within that graph.\n\nThinking about reachability, if two nodes are mutually reachable, they form an SCC. Any pair of distinct nodes within an SCC, where the first node is smaller than the second, contributes to this \"p\". The number of such pairs within an SCC of size `k` is `k * (k - 1) / 2`. The problem essentially boils down to strategically dividing the total 'p' into the sum of these `k_i * (k_i - 1) / 2` components.\n\nTo minimize the total number of nodes `N`, I should prioritize using the largest possible SCCs. I need to find the largest 'k' such that `k * (k - 1) / 2` is less than or equal to the remaining 'p'. This suggests a greedy approach where I keep subtracting the largest possible `k * (k - 1) / 2` from 'p' and incrementing my node count (N) by 'k' as I go. Then I'll have the minimum N, and I need to come up with how to maximize the unidirectional pairs.\n",
    "response": "The problem asks us to find two values:\n1.  The minimum number of nodes `N` required to create a `p`-reachable directed graph.\n2.  Among all such `p`-reachable graphs with minimum `N` nodes, the maximum number of unidirectional pairs.\n\nLet's break down the definitions:\n*   **Mutually reachable nodes:** Two distinct nodes `u` and `v` are mutually reachable if there's a path `u -> v` and a path `v -> u`. This means `u` and `v` belong to the same Strongly Connected Component (SCC).\n*   **`p`-reachable graph:** A graph is `p`-reachable if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are mutually reachable.\n*   **Unidirectional pair `(u, v)`:** `u != v`, there's a path `u -> v`, but no path `v -> u`.\n\n**Part 1: Minimum number of nodes `N`**\n\nIf an SCC has `k` nodes, any two distinct nodes within this SCC are mutually reachable. The number of pairs `(u, v)` with `u < v` (where `u` and `v` are in this SCC) is `k * (k - 1) / 2`.\nIf a graph has multiple SCCs with sizes `k_1, k_2, ..., k_m`, the total number of `p` pairs is `p = sum(k_i * (k_i - 1) / 2)` for `i` from `1` to `m`. The total number of nodes is `N = sum(k_i)`.\n\nTo minimize `N` for a given `p`, we should try to use the largest possible `k_i` values. The function `f(k) = k * (k - 1) / 2` grows quadratically. To obtain a sum `p` with the minimum `sum(k_i)`, we should greedily pick the largest `k` such that `k * (k - 1) / 2 <= p`, add `k` to our total `N`, subtract `k * (k - 1) / 2` from `p`, and repeat until `p` becomes 0.\n\nLet's precompute `f(k) = k * (k - 1) / 2` values. Since `p <= 2 * 10^5`, the maximum `k` needed will be relatively small.\n`k * (k - 1) / 2 <= 2 * 10^5` implies `k^2` is roughly `4 * 10^5`, so `k` is roughly `sqrt(4 * 10^5) = 2 * sqrt(10^5) approx 2 * 316 = 632`.\nWe can precompute `scc_pairs[k] = k * (k - 1) / 2` for `k` from `0` up to `632` (or a bit more, say `650`).\n\nAlgorithm for minimum `N`:\n1.  Initialize `min_nodes = 0`.\n2.  While `p > 0`:\n    a.  Find the largest `k` such that `scc_pairs[k] <= p`.\n    b.  Add `k` to `min_nodes`.\n    c.  Subtract `scc_pairs[k]` from `p`.\n3.  The final `min_nodes` is the answer for the first part.\n\n**Part 2: Maximum unidirectional pairs**\n\nConsider a graph with `min_nodes` nodes. These `min_nodes` are partitioned into SCCs `k_1, k_2, ..., k_m` as determined in Part 1.\nNodes within the same SCC are mutually reachable, so they don't form unidirectional pairs with each other.\nUnidirectional pairs `(u, v)` can only exist if `u` and `v` are in different SCCs. Specifically, if `u` is in `SCC_A` and `v` is in `SCC_B`, for `(u, v)` to be unidirectional, there must be a path from `SCC_A` to `SCC_B`, but no path from `SCC_B` to `SCC_A`. This implies `SCC_A` must come \"before\" `SCC_B` in the condensation graph (DAG of SCCs).\n\nTo maximize unidirectional pairs, we want to maximize paths between different SCCs in one direction. The optimal structure for this is a \"chain\" or \"line\" of SCCs in the condensation graph.\nSuppose we have SCCs `S_1, S_2, ..., S_m` with sizes `k_1, k_2, ..., k_m`.\nIf we arrange them in a line `S_1 -> S_2 -> ... -> S_m` (meaning there's an edge from some node in `S_i` to some node in `S_{i+1}` for all `i`), then for any `i < j`, there's a path from any node in `S_i` to any node in `S_j`.\nThe total number of such pairs `(u, v)` where `u` is in `S_i` and `v` is in `S_j` (with `i < j`) is `k_i * k_j`.\nThe total number of unidirectional pairs would be `sum(k_i * k_j)` for all `1 <= i < j <= m`.\n\nThis sum `sum(k_i * k_j)` for `i < j` can be calculated efficiently.\nConsider the square of the sum of all `k_i`:\n`(sum(k_i))^2 = (k_1 + k_2 + ... + k_m)^2`\n`= sum(k_i^2) + 2 * sum(k_i * k_j for i < j)`\nSo, `2 * sum(k_i * k_j for i < j) = (sum(k_i))^2 - sum(k_i^2)`.\nTherefore, `sum(k_i * k_j for i < j) = ((sum(k_i))^2 - sum(k_i^2)) / 2`.\nSince `sum(k_i) = min_nodes`, this becomes `(min_nodes^2 - sum(k_i^2)) / 2`.\n\nAlgorithm for maximum unidirectional pairs:\n1.  First, determine the `k_i` values (sizes of SCCs) using the greedy approach from Part 1. Store these `k_i` values in a list (e.g., `scc_sizes`).\n2.  Calculate `sum_k_squared = sum(k*k for k in scc_sizes)`.\n3.  `max_unidirectional = (min_nodes * min_nodes - sum_k_squared) // 2`.\n\n**Example: p = 3**\n1.  Precompute `scc_pairs`: `scc_pairs[0]=0, scc_pairs[1]=0, scc_pairs[2]=1, scc_pairs[3]=3, scc_pairs[4]=6, ...`\n2.  `p = 3`:\n    a.  Largest `k` such that `scc_pairs[k] <= 3` is `k=3` (`scc_pairs[3]=3`).\n    b.  `min_nodes = 0 + 3 = 3`.\n    c.  `p = 3 - 3 = 0`.\n    d.  `scc_sizes = [3]`.\n3.  `min_nodes = 3`.\n4.  `sum_k_squared = 3*3 = 9`.\n5.  `max_unidirectional = (3*3 - 9) // 2 = (9 - 9) // 2 = 0`.\nOutput: `3 0`. Matches example.\n\n**Example: p = 4**\n1.  `p = 4`:\n    a.  Largest `k` such that `scc_pairs[k] <= 4` is `k=3` (`scc_pairs[3]=3`).\n    b.  `min_nodes = 0 + 3 = 3`.\n    c.  `p = 4 - 3 = 1`.\n    d.  `scc_sizes = [3]`.\n    e.  `p = 1`: Largest `k` such that `scc_pairs[k] <= 1` is `k=2` (`scc_pairs[2]=1`).\n    f.  `min_nodes = 3 + 2 = 5`.\n    g.  `p = 1 - 1 = 0`.\n    h.  `scc_sizes = [3, 2]`.\n3.  `min_nodes = 5`.\n4.  `sum_k_squared = 3*3 + 2*2 = 9 + 4 = 13`.\n5.  `max_unidirectional = (5*5 - 13) // 2 = (25 - 13) // 2 = 12 // 2 = 6`.\nOutput: `5 6`. Matches example.\n\n**Implementation details:**\n*   Precompute `scc_pairs` array.\n*   The greedy choice of `k` can be found by iterating `k` downwards from the max possible value (around 650).\n\n```python\nimport sys\n\ndef solve():\n    p = int(sys.stdin.readline())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute k*(k-1)/2 for k up to ~650\n    # Max p is 2*10^5. k*(k-1)/2 approx k^2/2. So k^2 approx 4*10^5. k approx sqrt(4*10^5) = 632.\n    # Let's go up to 635 to be safe.\n    max_k = 635 \n    scc_pairs = [0] * (max_k + 1)\n    for k in range(max_k + 1):\n        scc_pairs[k] = k * (k - 1) // 2\n\n    min_nodes = 0\n    scc_sizes = [] # To store the sizes of SCCs chosen\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest k such that scc_pairs[k] <= current_p\n        # Iterate downwards from max_k\n        found_k = 0\n        for k in range(max_k, 1, -1): # k=0 and k=1 give 0 pairs, so start from 2\n            if scc_pairs[k] <= current_p:\n                found_k = k\n                break\n        \n        # If no k (>=2) is found, it means current_p is 0 or 1.\n        # k=0 and k=1 both contribute 0 pairs. \n        # If current_p is 0, loop terminates.\n        # If current_p is 1, we must use k=2 (scc_pairs[2]=1).\n        # The loop (range(max_k, 1, -1)) will find k=2 if current_p >= 1.\n        # So found_k will always be >=2 if current_p > 0 and scc_pairs[k] <= current_p.\n        # The only edge case is if current_p=0, which terminates.\n\n        min_nodes += found_k\n        scc_sizes.append(found_k)\n        current_p -= scc_pairs[found_k]\n    \n    # Calculate max unidirectional pairs\n    # max_unidirectional = (sum(k_i))^2 - sum(k_i^2) / 2\n    sum_k_squared = 0\n    for k_val in scc_sizes:\n        sum_k_squared += k_val * k_val\n    \n    max_unidirectional = (min_nodes * min_nodes - sum_k_squared) // 2\n\n    print(min_nodes, max_unidirectional)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    p = int(sys.stdin.readline())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute k*(k-1)/2 for k up to ~650\n    # Max p is 2*10^5. k*(k-1)/2 approx k^2/2. So k^2 approx 4*10^5. k approx sqrt(4*10^5) = 632.\n    # Let's go up to 635 to be safe.\n    max_k = 635 \n    scc_pairs = [0] * (max_k + 1)\n    for k in range(max_k + 1):\n        scc_pairs[k] = k * (k - 1) // 2\n\n    min_nodes = 0\n    scc_sizes = [] # To store the sizes of SCCs chosen\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest k such that scc_pairs[k] <= current_p\n        # Iterate downwards from max_k\n        found_k = 0\n        for k in range(max_k, 1, -1): # k=0 and k=1 give 0 pairs, so start from 2\n            if scc_pairs[k] <= current_p:\n                found_k = k\n                break\n        \n        # If no k (>=2) is found, it means current_p is 0 or 1.\n        # k=0 and k=1 both contribute 0 pairs. \n        # If current_p is 0, loop terminates.\n        # If current_p is 1, we must use k=2 (scc_pairs[2]=1).\n        # The loop (range(max_k, 1, -1)) will find k=2 if current_p >= 1.\n        # So found_k will always be >=2 if current_p > 0 and scc_pairs[k] <= current_p.\n        # The only edge case is if current_p=0, which terminates.\n\n        min_nodes += found_k\n        scc_sizes.append(found_k)\n        current_p -= scc_pairs[found_k]\n    \n    # Calculate max unidirectional pairs\n    # max_unidirectional = (sum(k_i))^2 - sum(k_i^2) / 2\n    sum_k_squared = 0\n    for k_val in scc_sizes:\n        sum_k_squared += k_val * k_val\n    \n    max_unidirectional = (min_nodes * min_nodes - sum_k_squared) // 2\n\n    print(min_nodes, max_unidirectional)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 2833,
        "thoughts_token_count": 736
    }
}