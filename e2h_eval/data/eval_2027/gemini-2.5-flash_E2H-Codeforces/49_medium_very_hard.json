{
    "start": 1758294857.7695043,
    "end": 1758294960.7342923,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**The Mushroom Strife: My Thought Process**\n\nAlright, let's break this down. I've got a classic graph problem here, but with a number theory twist. My goal is to figure out the number of mushrooms on each lawn, given GCD and LCM constraints for connected lawns. I'm thinking prime factorization is the key.\n\nFirst things first, I need to represent the problem. Let's say `x_i` is the number of mushrooms on lawn `i`.  For an edge between lawns `u` and `v`, I'm given the GCD (`g`) and LCM (`l`) of `x_u` and `x_v`.  The fundamental relationship here is `g * l = x_u * x_v`. Plus, `g` must divide both `x_u` and `x_v`, and `l` must be a multiple of both. This implies `l` must be divisible by `g` - if that's not true, it's immediately \"NO\".\n\nNow, let's think about how to represent the numbers using their prime factors. If `p` is a prime, and `v_p(x)` is the exponent of `p` in the factorization of `x`, I can represent `x` as a product of `p_i^{v_p(x_i)}`. For an edge, `g = \\prod p_i^{\\min(\\alpha_i, \\beta_i)}` and `l = \\prod p_i^{\\max(\\alpha_i, \\beta_i)}`. So, I can solve this for each prime independently. This transforms the problem into finding the exponents for each prime for each node.\n\nLet's say `e_{u,p}` is the exponent of prime `p` for node `u`.  Then, for an edge, I'm constrained to either `e_{u,p} = v_p(g)` and `e_{v,p} = v_p(l)`, or vice versa. This looks a lot like a 2-coloring problem on a graph for each prime – a critical insight. For a particular prime, if I can't find a valid coloring that satisfies all edges, it's \"NO\".\n\nMy plan now:\n1.  Sieve to generate primes and smallest prime factor for factorization up to `10^6`. This lets me factorize the values given.\n2.  Iterate through each edge, factorizing `g` and `l` to find the relevant primes for each node. For each edge, check `g` divides `l`, otherwise print \"NO\".\n3.  For each prime `p`, build a graph based on the GCD and LCM constraints.  The nodes are the lawns, and the edges come from the GCD and LCM constraints.\n4.  For any prime not present in an edge involving a node, that exponent is initially assumed to be zero.\n5.  If, for a given prime `p`, I see a node `i` connected only by edges where the prime appears, the options for `e_{i,p}` are derived from all edges involving `i`.\n6.  If `v_p(g) == v_p(l)` for an edge, then `e_{u,p}` and `e_{v,p}` are fixed. Propagate that constraint to any unfixed edges for nodes `u` and `v`.\n7.  If `v_p(g) < v_p(l)`, the node must have a valid combination. Iterate and ensure it's valid.\n\nBasically, I'm going to determine exponents for each prime, then reconstruct the values of `x_i`. I think I've got this. Let's code it!\n",
    "response": "The problem asks us to restore the number of mushrooms `x_i` on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `g = GCD(x_u, x_v)` and `l = LCM(x_u, x_v)`. We need to output any valid assignment of `x_i` or report if none exists. The values `x_i`, `g`, `l` are between 1 and 10^6.\n\nThe core property connecting GCD, LCM, and the numbers themselves is `GCD(a, b) * LCM(a, b) = a * b`.\nAlso, for any prime `p`, let `v_p(k)` denote the exponent of `p` in the prime factorization of `k`.\nThen `v_p(g) = min(v_p(x_u), v_p(x_v))` and `v_p(l) = max(v_p(x_u), v_p(x_v))`.\nFrom these, it follows that `v_p(g) + v_p(l) = v_p(x_u) + v_p(x_v)`.\nThis crucial observation allows us to solve the problem independently for each prime factor.\n\nFor a fixed prime `p`, let `e_i = v_p(x_i)`. For an edge `(u, v)` with given `g, l`:\nLet `g_p = v_p(g)` and `l_p = v_p(l)`.\nWe must have `min(e_u, e_v) = g_p` and `max(e_u, e_v) = l_p`.\nThis implies two conditions:\n1. `g_p <= l_p`. If `g_p > l_p` for any prime `p` (which is equivalent to `l` not being divisible by `g`), then no solution exists.\n2. The pair `(e_u, e_v)` must be either `(g_p, l_p)` or `(l_p, g_p)`.\n\nThis structure is a variation of a 2-coloring problem for each prime `p`.\nFor each node `i` and prime `p`, `e_i` must eventually be determined.\nIf `g_p = l_p` for an edge `(u, v)`, then `e_u` and `e_v` must both be `g_p`. This fixes their values for this prime.\nIf `g_p < l_p`, then `e_u` and `e_v` must be `g_p` and `l_p` in some order. This means `e_u \\ne e_v`.\n\nAlgorithm Steps:\n\n1.  **Precomputation (Sieve):**\n    Generate primes up to `MAX_VAL = 10^6` using a sieve. Store the smallest prime factor (`spf`) for each number up to `MAX_VAL`. This helps in efficient prime factorization.\n\n2.  **Initial Checks and Prime Factor Collection:**\n    Initialize `adj[u]` to store `(v, g, l)` for edges connected to `u`.\n    Initialize `primes_to_consider` as a set to store all unique prime factors encountered in any `g` or `l` from the input.\n    For each input edge `(u, v, g, l)`:\n    *   Decrement `u` and `v` to be 0-indexed.\n    *   If `l % g != 0`, print \"NO\" and exit.\n    *   Factorize `g` and `l` to find their prime factors. Add these primes to `primes_to_consider`.\n    *   Store the edge `(v, g, l)` in `adj[u]` and `(u, g, l)` in `adj[v]`.\n\n3.  **Solve for each Prime Independently:**\n    Initialize `final_exponents[i][p]` to -1 for all `i, p` (meaning `v_p(x_i)` is not yet determined).\n    Initialize `x_values[i]` to 1 for all `i` (these will be multiplied by `p^e_i` later).\n\n    For each prime `p` in `primes_to_consider`:\n    *   `node_state[i]` will store the current status of `e_i`:\n        *   `0`: `e_i` must be `g_p` (relative to a component's reference).\n        *   `1`: `e_i` must be `l_p` (relative to a component's reference).\n        *   `-1`: `e_i` is unassigned.\n    *   `q = deque()` for BFS.\n    *   `potential_edges` stores edges `(u, v, g_p, l_p)` where `g_p < l_p`.\n\n    *   **Phase 1: Determine fixed exponents and identify 2-coloring components.**\n        For each node `i = 0...n-1`:\n            `possible_values_for_node_i_at_prime_p = set()`\n            For each edge `(j, g_val, l_val)` in `adj[i]`:\n                `g_p = v_p(g_val)`, `l_p = v_p(l_val)`.\n                `possible_values_for_node_i_at_prime_p.add(g_p)`\n                `possible_values_for_node_i_at_prime_p.add(l_p)`\n\n            If `possible_values_for_node_i_at_prime_p` is empty:\n                This means `p` is not a factor of any `g` or `l` connected to `i`. So `e_i` can be 0.\n                If `final_exponents[i][p] == -1`: `final_exponents[i][p] = 0`.\n                Else if `final_exponents[i][p] != 0`: print \"NO\", exit.\n            Else if `len(possible_values_for_node_i_at_prime_p) == 1`:\n                `val = possible_values_for_node_i_at_prime_p.pop()`.\n                If `final_exponents[i][p] == -1`:\n                    `final_exponents[i][p] = val`.\n                    `q.append(i)`.\n                Else if `final_exponents[i][p] != val`: print \"NO\", exit.\n            Else if `len(possible_values_for_node_i_at_prime_p) > 2`:\n                This should not happen given the problem constraints (`g_p` and `l_p` are the only options). If it does, it's an impossible state. Print \"NO\", exit.\n            Else (`len(possible_values_for_node_i_at_prime_p) == 2`):\n                `val1, val2 = sorted(list(possible_values_for_node_i_at_prime_p))`.\n                `potential_edges` will handle these.\n\n    *   **Phase 2: Propagate fixed exponents using BFS.**\n        While `q` is not empty:\n            `u = q.popleft()`.\n            `e_u = final_exponents[u][p]`.\n            For each edge `(v, g_val, l_val)` in `adj[u]`:\n                `g_p = v_p(g_val)`, `l_p = v_p(l_val)`.\n                If `g_p == l_p`:\n                    `e_v_required = g_p`.\n                Else (`g_p < l_p`):\n                    If `e_u == g_p`: `e_v_required = l_p`.\n                    Else (`e_u == l_p`): `e_v_required = g_p`.\n                    // If e_u is fixed to something else, it's a contradiction. This should have been caught earlier\n                    // or implicitly by how possible_values_for_node_i_at_prime_p was built.\n                    // For safety:\n                    Else: print \"NO\", exit.\n\n                If `final_exponents[v][p] == -1`:\n                    `final_exponents[v][p] = e_v_required`.\n                    `q.append(v)`.\n                Else if `final_exponents[v][p] != e_v_required`: print \"NO\", exit.\n\n    *   **Phase 3: Handle 2-coloring components (unassigned nodes).**\n        For each node `i = 0...n-1`:\n            If `final_exponents[i][p] == -1`: // Node `i` is part of an unassigned component\n                Start a new BFS/DFS from `i`.\n                Assign `node_state[i] = 0` (arbitrary choice, e.g., `e_i` maps to `g_p`).\n                `q.append(i)`.\n                While `q` is not empty:\n                    `u = q.popleft()`.\n                    For each edge `(v, g_val, l_val)` in `adj[u]`:\n                        `g_p = v_p(g_val)`, `l_p = v_p(l_val)`.\n                        If `g_p == l_p`:\n                            // This case should have been handled by Phase 1 and 2,\n                            // fixing e_u and e_v to g_p. If it reaches here, it's a contradiction\n                            // with the assumption that e_u is unassigned or has two options.\n                            // If node_state[u] is 0 (meaning e_u should be g_p)\n                            // and g_p is not the value associated with node_state 0 for this component,\n                            // or if node_state[u] is 1 and g_p is not the value associated with node_state 1 for this component,\n                            // it's a contradiction.\n                            // A simpler approach: if g_p == l_p, both e_u and e_v should be g_p.\n                            // If node_state[u] is 0, then the exponent for u is g_p.\n                            // If node_state[u] is 1, then the exponent for u is l_p.\n                            // If g_p == l_p, then the two choices must be the same.\n                            // This means any node in such a component should have only one option for exponent.\n                            // This is effectively handled by Phase 1 and 2.\n                            // So if we reach here and g_p == l_p, it's a contradiction.\n                            print \"NO\", exit.\n                        Else (`g_p < l_p`):\n                            `v_state_required = 1 - node_state[u]`.\n                            If `node_state[v] == -1`:\n                                `node_state[v] = v_state_required`.\n                                `q.append(v)`.\n                            Else if `node_state[v] != v_state_required`: print \"NO\", exit.\n                \n                // After coloring a component, assign `final_exponents`.\n                // For each node `k` in this component:\n                // `final_exponents[k][p] = g_p` if `node_state[k] == 0`\n                // `final_exponents[k][p] = l_p` if `node_state[k] == 1`\n                // This is still problematic because `g_p` and `l_p` depend on the edge.\n                // All edges in a connected component where `g_p < l_p` must use the same two values.\n                // To check this, collect all `(g_p, l_p)` pairs for edges in this component.\n                // They must all be identical. If not, print \"NO\".\n                \n                // Revised Phase 3:\n                // For each node `i = 0...n-1`:\n                // If `final_exponents[i][p] == -1`: // Node `i` is part of an unassigned component\n                //   `component_edges = []`\n                //   `component_nodes = []`\n                //   `q.append(i)`\n                //   `visited_component_nodes = {i}`\n                //   `q_for_component_bfs = deque([i])`\n                //   `base_g_p = -1`, `base_l_p = -1`\n                //   While `q_for_component_bfs`:\n                //     `u = q_for_component_bfs.popleft()`\n                //     `component_nodes.append(u)`\n                //     For each edge `(v, g_val, l_val)` in `adj[u]`:\n                //       `g_p = v_p(g_val)`, `l_p = v_p(l_val)`.\n                //       If `g_p == l_p`: print \"NO\", exit. // Should be fixed by phase 1/2\n                //       If `base_g_p == -1`: `base_g_p = g_p`, `base_l_p = l_p`.\n                //       Else if `base_g_p != g_p` or `base_l_p != l_p`: print \"NO\", exit.\n                //       If `v` not in `visited_component_nodes` and `final_exponents[v][p] == -1`:\n                //         `visited_component_nodes.add(v)`\n                //         `q_for_component_bfs.append(v)`\n                //   \n                //   // Now, `base_g_p` and `base_l_p` are the two values for this component.\n                //   // Perform 2-coloring.\n                //   `q.append(i)`\n                //   `node_state[i] = 0` // Assign e_i to base_g_p\n                //   While `q`:\n                //     `u = q.popleft()`\n                //     For each edge `(v, g_val, l_val)` in `adj[u]`:\n                //       If `final_exponents[v][p] == -1`: // Only consider unassigned nodes\n                //         `v_state_required = 1 - node_state[u]`.\n                //         If `node_state[v] == -1`:\n                //           `node_state[v] = v_state_required`.\n                //           `q.append(v)`.\n                //         Else if `node_state[v] != v_state_required`: print \"NO\", exit. // Bipartite check failed\n                //   \n                //   // Assign final exponents for the component\n                //   For `k` in `component_nodes`:\n                //     If `node_state[k] == 0`: `final_exponents[k][p] = base_g_p`.\n                //     Else: `final_exponents[k][p] = base_l_p`.\n\n    *   **Simpler Phase 3 for 2-coloring:**\n        For each node `i = 0...n-1`:\n            If `final_exponents[i][p] == -1`: // Node `i` is still unassigned for prime `p`\n                // This node is part of a component that needs 2-coloring.\n                // Start a BFS/DFS to 2-color it.\n                // `color[u]` will be 0 or 1.\n                // `val_map[0]` will be one exponent, `val_map[1]` the other.\n                // The values `g_p, l_p` for edges in this component must be consistent.\n                \n                `component_q = deque([i])`\n                `component_nodes_in_q = {i}`\n                `component_edges_data = []` // Store (u,v,gp,lp) for edges in this component\n                \n                `current_component_nodes = []`\n                `current_component_edges = []` // For 2-coloring graph\n                \n                `q_bfs_component = deque([i])`\n                `visited_for_component = {i}`\n                \n                `base_g_p = -1`, `base_l_p = -1`\n                \n                While `q_bfs_component`:\n                    `u_comp = q_bfs_component.popleft()`\n                    `current_component_nodes.append(u_comp)`\n                    For each edge `(v_comp, g_val_comp, l_val_comp)` in `adj[u_comp]`:\n                        `g_p_comp = v_p(g_val_comp)`, `l_p_comp = v_p(l_val_comp)`.\n                        \n                        If `g_p_comp == l_p_comp`:\n                            // If this edge is processed here, it means both u_comp and v_comp were unassigned.\n                            // But if g_p == l_p, then e_u = e_v = g_p. This should have been fixed in Phase 1/2.\n                            // If it reaches here, it means we have a contradiction, as it implies a choice, but there's only one.\n                            print \"NO\", exit.\n                            \n                        If `base_g_p == -1`:\n                            `base_g_p = g_p_comp`\n                            `base_l_p = l_p_comp`\n                        Else if `base_g_p != g_p_comp` or `base_l_p != l_p_comp`:\n                            // Edges in the same 2-coloring component must have the same (g_p, l_p) pair.\n                            print \"NO\", exit.\n                            \n                        If `final_exponents[v_comp][p] == -1` and `v_comp` not in `visited_for_component`:\n                            `visited_for_component.add(v_comp)`\n                            `q_bfs_component.append(v_comp)`\n                        \n                        // Add edge to the component's 2-coloring graph\n                        current_component_edges.append((u_comp, v_comp))\n                \n                // Perform 2-coloring on `current_component_nodes` using `current_component_edges`.\n                // `node_state[u]` will store the color (0 or 1).\n                `q_coloring = deque([i])`\n                `node_state[i] = 0` // Arbitrarily assign color 0 to the starting node.\n                \n                While `q_coloring`:\n                    `u_color = q_coloring.popleft()`\n                    For each edge `(v_color, g_val_color, l_val_color)` in `adj[u_color]`:\n                        If `final_exponents[v_color][p] == -1`: // Only process unassigned neighbors\n                            If `node_state[v_color] == -1`:\n                                `node_state[v_color] = 1 - node_state[u_color]`\n                                `q_coloring.append(v_color)`\n                            Else if `node_state[v_color] == node_state[u_color]`:\n                                // Not bipartite, contradiction.\n                                print \"NO\", exit.\n                \n                // Assign `final_exponents` based on `node_state` for this component.\n                For `u_comp` in `current_component_nodes`:\n                    If `node_state[u_comp] == 0`:\n                        `final_exponents[u_comp][p] = base_g_p`\n                    Else:\n                        `final_exponents[u_comp][p] = base_l_p`\n\n\n4.  **Final Result Calculation:**\n    After iterating through all primes, if no \"NO\" was printed, construct `x_values`.\n    `x_values[i]` is initialized to 1.\n    For each node `i = 0...n-1`:\n        For each prime `p` in `primes_to_consider`:\n            If `final_exponents[i][p] != -1`:\n                `x_values[i] *= (p ** final_exponents[i][p])`.\n            // If `final_exponents[i][p]` is still -1, it means prime `p` was not a factor of any `g` or `l`\n            // adjacent to `i`, and `i` was not part of any 2-coloring component for `p`.\n            // In this case, `v_p(x_i)` can be 0. (Implicitly handled if `x_values[i]` starts at 1).\n\n        // For primes not in `primes_to_consider`, `final_exponents[i][p]` is implicitly 0.\n        // This is handled by initializing `x_values[i]` to 1.\n\n    Print \"YES\" and then `x_values`.\n\n**Optimization and Details:**\n*   Maximum value of `10^6`. `v_p(10^6)` is at most `v_2(2^19) = 19`.\n*   The number of primes up to `10^6` is ~78k. Iterating through all primes for each node/edge is too slow.\n*   The `primes_to_consider` set effectively reduces the number of primes to check. Max `2*M` distinct prime factors. `M` is 10^5, so `2*10^5` distinct prime factors in worst case (if all `g,l` are distinct primes). This is still too many.\n*   The number of distinct prime factors of numbers up to `10^6` is much smaller. `2*3*5*7*11*13*17 = 510510`, `2*3*5*7*11*13*17*19 > 10^6`. So at most 7-8 distinct prime factors for any number.\n*   The number of distinct prime factors across all `2*M` numbers can be up to `pi(10^6)`.\n*   The `final_exponents` table should be `final_exponents[N][MAX_PRIME_INDEX]`. A map `dict[prime] -> exponent` might be better for sparse prime usage.\n\nLet's use `defaultdict(lambda: defaultdict(lambda: -1))` for `final_exponents` and `node_state`.\n\n```python\nimport sys\nfrom collections import deque, defaultdict\n\n# Max value for GCD, LCM, and X_i\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization (exponent of p in num)\ndef get_prime_exponent(num, p):\n    count = 0\n    while num > 0 and num % p == 0:\n        count += 1\n        num //= p\n    return count\n\n# Function to get all prime factors of a number\ndef get_prime_factors(num):\n    factors = set()\n    temp_num = num\n    while temp_num > 1:\n        p = spf[temp_num]\n        factors.add(p)\n        while temp_num % p == 0:\n            temp_num //= p\n    return factors\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = defaultdict(list)\n    all_primes_in_input = set()\n\n    # Store original edge data for later checks\n    edge_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edge_data.append((u, v, g, l))\n\n        all_primes_in_input.update(get_prime_factors(g))\n        all_primes_in_input.update(get_prime_factors(l))\n    \n    # final_exponents[node_idx][prime] = exponent\n    final_exponents = defaultdict(lambda: defaultdict(lambda: -1))\n\n    for p in all_primes_in_input:\n        # node_state[node_idx] for current prime p:\n        # -1: unassigned\n        # 0: assigned to the 'smaller' exponent option for this prime\n        # 1: assigned to the 'larger' exponent option for this prime\n        node_state = [-1] * n \n        q = deque()\n\n        # Phase 1: Identify fixed exponents and initial propagation\n        for i in range(n):\n            if final_exponents[i][p] != -1: # Already fixed by a previous component\n                continue\n\n            possible_vals = set()\n            for neighbor, g_val, l_val in adj[i]:\n                g_p = get_prime_exponent(g_val, p)\n                l_p = get_prime_exponent(l_val, p)\n                possible_vals.add(g_p)\n                possible_vals.add(l_p)\n            \n            if not possible_vals: # No adjacent edges involve prime p\n                if final_exponents[i][p] == -1:\n                    final_exponents[i][p] = 0\n                    q.append(i) # Add to queue for propagation\n                elif final_exponents[i][p] != 0:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            elif len(possible_vals) == 1:\n                val = possible_vals.pop()\n                if final_exponents[i][p] == -1:\n                    final_exponents[i][p] = val\n                    q.append(i)\n                elif final_exponents[i][p] != val:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            # If len(possible_vals) == 2, it's a 2-coloring case, handled in Phase 3\n            # If len(possible_vals) > 2, it's a contradiction. This shouldn't happen by definition of g_p, l_p.\n\n        # Phase 2: Propagate fixed exponents using BFS\n        while q:\n            u = q.popleft()\n            e_u = final_exponents[u][p]\n\n            for v, g_val, l_val in adj[u]:\n                g_p = get_prime_exponent(g_val, p)\n                l_p = get_prime_exponent(l_val, p)\n\n                e_v_required = -1\n                if g_p == l_p:\n                    e_v_required = g_p\n                elif e_u == g_p:\n                    e_v_required = l_p\n                elif e_u == l_p:\n                    e_v_required = g_p\n                else: # e_u is fixed to something not g_p or l_p for this edge, contradiction\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                if final_exponents[v][p] == -1:\n                    final_exponents[v][p] = e_v_required\n                    q.append(v)\n                elif final_exponents[v][p] != e_v_required:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n\n        # Phase 3: Handle 2-coloring components (unassigned nodes)\n        for i in range(n):\n            if final_exponents[i][p] == -1: # Node i is still unassigned for prime p\n                # This node is part of a component that needs 2-coloring.\n                # All edges in such a component must imply the same (g_p, l_p) pair.\n                \n                q_component_bfs = deque([i])\n                visited_for_component = {i}\n                \n                component_nodes = []\n                \n                base_g_p = -1\n                base_l_p = -1\n                \n                while q_component_bfs:\n                    u_comp = q_component_bfs.popleft()\n                    component_nodes.append(u_comp)\n\n                    for v_comp, g_val_comp, l_val_comp in adj[u_comp]:\n                        g_p_comp = get_prime_exponent(g_val_comp, p)\n                        l_p_comp = get_prime_exponent(l_val_comp, p)\n\n                        if g_p_comp == l_p_comp:\n                            # This case should have been fixed in Phase 1/2. \n                            # If it reaches here, it implies a node that should be fixed was not.\n                            # This is a contradiction.\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        if base_g_p == -1:\n                            base_g_p = g_p_comp\n                            base_l_p = l_p_comp\n                        elif base_g_p != g_p_comp or base_l_p != l_p_comp:\n                            # Edges in the same 2-coloring component must have consistent (g_p, l_p) pairs.\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                            \n                        if final_exponents[v_comp][p] == -1 and v_comp not in visited_for_component:\n                            visited_for_component.add(v_comp)\n                            q_component_bfs.append(v_comp)\n                \n                # Now, perform 2-coloring on this component\n                q_coloring = deque([i])\n                node_state[i] = 0 # Arbitrarily assign color 0 to the starting node\n                \n                while q_coloring:\n                    u_color = q_coloring.popleft()\n                    for v_color, g_val_color, l_val_color in adj[u_color]:\n                        if final_exponents[v_color][p] == -1: # Only process unassigned neighbors in this component\n                            if node_state[v_color] == -1:\n                                node_state[v_color] = 1 - node_state[u_color]\n                                q_coloring.append(v_color)\n                            elif node_state[v_color] == node_state[u_color]:\n                                # Not bipartite, contradiction\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                \n                # Assign final exponents based on node_state for this component\n                for u_comp in component_nodes:\n                    if final_exponents[u_comp][p] != -1: # Should not happen if component_nodes only contains unassigned\n                        continue\n                    if node_state[u_comp] == 0:\n                        final_exponents[u_comp][p] = base_g_p\n                    else: # node_state[u_comp] == 1\n                        final_exponents[u_comp][p] = base_l_p\n                \n\n    # Final verification and calculation of x_values\n    x_values = [1] * n\n    for i in range(n):\n        for p_val in final_exponents[i]:\n            exp = final_exponents[i][p_val]\n            if exp != -1: # Should always be assigned now\n                x_values[i] *= (p_val ** exp)\n    \n    # Check consistency with original edge data\n    for u, v, g_orig, l_orig in edge_data:\n        x_u = x_values[u]\n        x_v = x_values[v]\n        \n        # Check GCD and LCM\n        # Python's math.gcd is efficient\n        import math\n        if math.gcd(x_u, x_v) != g_orig or (x_u * x_v) // math.gcd(x_u, x_v) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n            \n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, x_values)) + \"\\n\")\n\n\n# Run sieve once\nsieve()\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque, defaultdict\n\n# Max value for GCD, LCM, and X_i\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization (exponent of p in num)\ndef get_prime_exponent(num, p):\n    count = 0\n    while num > 0 and num % p == 0:\n        count += 1\n        num //= p\n    return count\n\n# Function to get all prime factors of a number\ndef get_prime_factors(num):\n    factors = set()\n    temp_num = num\n    while temp_num > 1:\n        p = spf[temp_num]\n        factors.add(p)\n        while temp_num % p == 0:\n            temp_num //= p\n    return factors\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = defaultdict(list)\n    all_primes_in_input = set()\n\n    # Store original edge data for later checks\n    edge_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edge_data.append((u, v, g, l))\n\n        all_primes_in_input.update(get_prime_factors(g))\n        all_primes_in_input.update(get_prime_factors(l))\n    \n    # final_exponents[node_idx][prime] = exponent\n    final_exponents = defaultdict(lambda: defaultdict(lambda: -1))\n\n    for p in all_primes_in_input:\n        # node_state[node_idx] for current prime p:\n        # -1: unassigned\n        # 0: assigned to the 'smaller' exponent option for this prime\n        # 1: assigned to the 'larger' exponent option for this prime\n        node_state = [-1] * n \n        q = deque()\n\n        # Phase 1: Identify fixed exponents and initial propagation\n        for i in range(n):\n            if final_exponents[i][p] != -1: # Already fixed by a previous component\n                continue\n\n            possible_vals = set()\n            for neighbor, g_val, l_val in adj[i]:\n                g_p = get_prime_exponent(g_val, p)\n                l_p = get_prime_exponent(l_val, p)\n                possible_vals.add(g_p)\n                possible_vals.add(l_p)\n            \n            if not possible_vals: # No adjacent edges involve prime p\n                if final_exponents[i][p] == -1:\n                    final_exponents[i][p] = 0\n                    q.append(i) # Add to queue for propagation\n                elif final_exponents[i][p] != 0:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            elif len(possible_vals) == 1:\n                val = possible_vals.pop()\n                if final_exponents[i][p] == -1:\n                    final_exponents[i][p] = val\n                    q.append(i)\n                elif final_exponents[i][p] != val:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            # If len(possible_vals) == 2, it's a 2-coloring case, handled in Phase 3\n            # If len(possible_vals) > 2, it's a contradiction. This shouldn't happen by definition of g_p, l_p.\n\n        # Phase 2: Propagate fixed exponents using BFS\n        while q:\n            u = q.popleft()\n            e_u = final_exponents[u][p]\n\n            for v, g_val, l_val in adj[u]:\n                g_p = get_prime_exponent(g_val, p)\n                l_p = get_prime_exponent(l_val, p)\n\n                e_v_required = -1\n                if g_p == l_p:\n                    e_v_required = g_p\n                elif e_u == g_p:\n                    e_v_required = l_p\n                elif e_u == l_p:\n                    e_v_required = g_p\n                else: # e_u is fixed to something not g_p or l_p for this edge, contradiction\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                if final_exponents[v][p] == -1:\n                    final_exponents[v][p] = e_v_required\n                    q.append(v)\n                elif final_exponents[v][p] != e_v_required:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n\n        # Phase 3: Handle 2-coloring components (unassigned nodes)\n        for i in range(n):\n            if final_exponents[i][p] == -1: # Node i is still unassigned for prime p\n                # This node is part of a component that needs 2-coloring.\n                # All edges in such a component must imply the same (g_p, l_p) pair.\n                \n                q_component_bfs = deque([i])\n                visited_for_component = {i}\n                \n                component_nodes = []\n                \n                base_g_p = -1\n                base_l_p = -1\n                \n                while q_component_bfs:\n                    u_comp = q_component_bfs.popleft()\n                    component_nodes.append(u_comp)\n\n                    for v_comp, g_val_comp, l_val_comp in adj[u_comp]:\n                        g_p_comp = get_prime_exponent(g_val_comp, p)\n                        l_p_comp = get_prime_exponent(l_val_comp, p)\n\n                        if g_p_comp == l_p_comp:\n                            # This case should have been fixed in Phase 1/2. \n                            # If it reaches here, it implies a node that should be fixed was not.\n                            # This is a contradiction.\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        if base_g_p == -1:\n                            base_g_p = g_p_comp\n                            base_l_p = l_p_comp\n                        elif base_g_p != g_p_comp or base_l_p != l_p_comp:\n                            # Edges in the same 2-coloring component must have consistent (g_p, l_p) pairs.\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                            \n                        if final_exponents[v_comp][p] == -1 and v_comp not in visited_for_component:\n                            visited_for_component.add(v_comp)\n                            q_component_bfs.append(v_comp)\n                \n                # Now, perform 2-coloring on this component\n                q_coloring = deque([i])\n                node_state[i] = 0 # Arbitrarily assign color 0 to the starting node\n                \n                while q_coloring:\n                    u_color = q_coloring.popleft()\n                    for v_color, g_val_color, l_val_color in adj[u_color]:\n                        if final_exponents[v_color][p] == -1: # Only process unassigned neighbors in this component\n                            if node_state[v_color] == -1:\n                                node_state[v_color] = 1 - node_state[u_color]\n                                q_coloring.append(v_color)\n                            elif node_state[v_color] == node_state[u_color]:\n                                # Not bipartite, contradiction\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                \n                # Assign final exponents based on node_state for this component\n                for u_comp in component_nodes:\n                    if final_exponents[u_comp][p] != -1: # Should not happen if component_nodes only contains unassigned\n                        continue\n                    if node_state[u_comp] == 0:\n                        final_exponents[u_comp][p] = base_g_p\n                    else: # node_state[u_comp] == 1\n                        final_exponents[u_comp][p] = base_l_p\n                \n\n    # Final verification and calculation of x_values\n    x_values = [1] * n\n    for i in range(n):\n        for p_val in final_exponents[i]:\n            exp = final_exponents[i][p_val]\n            if exp != -1: # Should always be assigned now\n                x_values[i] *= (p_val ** exp)\n    \n    # Check consistency with original edge data\n    for u, v, g_orig, l_orig in edge_data:\n        x_u = x_values[u]\n        x_v = x_values[v]\n        \n        # Check GCD and LCM\n        # Python's math.gcd is efficient\n        import math\n        if math.gcd(x_u, x_v) != g_orig or (x_u * x_v) // math.gcd(x_u, x_v) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n            \n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, x_values)) + \"\\n\")\n\n\n# Run sieve once\nsieve()\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 7699,
        "thoughts_token_count": 7368
    }
}