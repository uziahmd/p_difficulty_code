{
    "start": 1758284889.8158937,
    "end": 1758284913.0039084,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Neko's Maths Problem - My Approach**\n\nOkay, so I'm tackling this \"Neko does Maths\" problem. The core is finding a 'k' that minimizes the least common multiple of (a+k) and (b+k). I know that LCM is calculated as (x*y)/GCD(x,y).  This leads me to think about simplifying the LCM expression by focusing on the GCD.\n\nThe GCD property is crucial here: GCD(x, y) = GCD(x, y-x). Applying this, I can transform GCD(a+k, b+k) to GCD(a+k, b-a).  I can assume a <= b because the LCM is symmetric, making the problem easier. This means dealing with a non-negative difference `d = b-a`.\n\nIf a=b (d=0), the LCM becomes simply a+k, and the minimum k is obviously 0. So, that's a straightforward base case.\n\nNow, if a < b (d > 0), the key is that GCD(a+k, b+k) now becomes GCD(a+k, d). This is the key insight.  The GCD must be a divisor of 'd'.\n\nSo, I'll need to iterate through the divisors of 'd'. For each divisor 'g' of 'd', I can express a+k as a multiple of 'g' (let's say m*g). Then, b+k will also be easily expressed in terms of 'g' and 'd' (which is also a multiple of g), let's say (m+n)g. This should allow me to express the LCM in terms of 'm', 'n' and 'g', which means, for a given 'g', I can calculate the LCM directly.\n\nMy strategy will be to consider all divisors of d, calculate the corresponding 'k' values. For each 'k' value calculate the LCM and find the minimum among them. It's a matter of finding the best balance between maximizing the GCD (g) and keeping the product (a+k)(b+k) as small as possible to minimize the LCM.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If multiple `k` values yield the same minimum LCM, we choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nA key property of the greatest common divisor (GCD) is `gcd(X, Y) = gcd(X, Y-X)`.\nApplying this, `gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a)`.\n\nLet `diff = abs(b-a)`. Without loss of generality, we can assume `a <= b`, so `diff = b-a`.\nIf `diff = 0` (i.e., `a = b`):\nThen `gcd(a+k, b+k) = gcd(a+k, 0) = a+k`.\n`lcm(a+k, a+k) = (a+k)(a+k) / (a+k) = a+k`.\nTo minimize `a+k`, we choose the smallest possible `k`, which is `k=0`.\nThe minimum LCM is `a`. So, if `a=b`, the answer is `k=0`.\n\nIf `diff > 0`:\n`gcd(a+k, b+k)` must be a divisor of `diff`. Let `g = gcd(a+k, b+k)`.\nSince `g` divides `diff`, we can iterate through all divisors `g` of `diff`.\nFor a fixed `g`, we need `a+k` to be a multiple of `g`.\nThis means `a+k = m * g` for some integer `m`.\nSo, `k = m*g - a`.\nSince `k` must be non-negative, `m*g - a >= 0`, which implies `m*g >= a`.\nThe smallest `m*g` that is greater than or equal to `a` and is a multiple of `g` is `ceil(a/g) * g`.\nMore precisely, `a+k` must be a multiple of `g`. The smallest non-negative `k` such that `a+k` is a multiple of `g` is found by calculating `a % g`.\nIf `a % g == 0`, then `a` is already a multiple of `g`, so we can take `k=0`.\nIf `a % g != 0`, we need to add `g - (a % g)` to `a` to make it a multiple of `g`.\nSo, `k_candidate = (g - (a % g)) % g`. (This handles both cases: if `a % g == 0`, `k_candidate` becomes `0`).\nThis `k_candidate` gives the smallest `a+k` that is a multiple of `g`.\nLet `current_a_plus_k = a + k_candidate`.\nThen `current_b_plus_k = b + k_candidate`.\nThe LCM for this `k_candidate` is `(current_a_plus_k * current_b_plus_k) // g`.\n\nWe need to iterate through all divisors `g` of `diff`. For each `g`, we calculate the corresponding `k_candidate` and the resulting LCM. We keep track of the minimum LCM found so far and the smallest `k` that achieves it.\n\n**Algorithm:**\n1. Read `a` and `b`.\n2. If `a == b`, print `0` and exit.\n3. Calculate `diff = abs(b-a)`.\n4. Initialize `min_lcm = infinity` and `best_k = 0`.\n5. Find all divisors of `diff`. We can do this by iterating from `1` up to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff // i` are divisors.\n6. For each divisor `g` of `diff`:\n    a. Calculate `k_candidate = (g - (a % g)) % g`. This is the smallest non-negative `k` such that `a+k` is a multiple of `g`.\n    b. Calculate `current_a_plus_k = a + k_candidate`.\n    c. Calculate `current_b_plus_k = b + k_candidate`.\n    d. Calculate `current_lcm = (current_a_plus_k * current_b_plus_k) // g`.\n    e. Compare `current_lcm` with `min_lcm`:\n        i. If `current_lcm < min_lcm`:\n           `min_lcm = current_lcm`\n           `best_k = k_candidate`\n        ii. If `current_lcm == min_lcm`:\n            `best_k = min(best_k, k_candidate)` (to ensure we pick the smallest `k`)\n7. Print `best_k`.\n\n**Example: a=6, b=10**\n`diff = 10 - 6 = 4`.\nDivisors of 4: `1, 2, 4`.\n\n- **g = 1**:\n  `k_candidate = (1 - (6 % 1)) % 1 = (1 - 0) % 1 = 0`.\n  `a+k = 6`, `b+k = 10`.\n  `lcm = (6 * 10) // 1 = 60`.\n  `min_lcm = 60`, `best_k = 0`.\n\n- **g = 2**:\n  `k_candidate = (2 - (6 % 2)) % 2 = (2 - 0) % 2 = 0`.\n  `a+k = 6`, `b+k = 10`.\n  `lcm = (6 * 10) // 2 = 30`.\n  `min_lcm = 30`, `best_k = 0`.\n\n- **g = 4**:\n  `k_candidate = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2`.\n  `a+k = 6+2 = 8`, `b+k = 10+2 = 12`.\n  `lcm = (8 * 12) // 4 = 96 // 4 = 24`.\n  `min_lcm = 24`, `best_k = 2`.\n\nFinal result: `best_k = 2`.\n\n**Constraints:**\n`a, b <= 10^9`. `diff` can be up to `10^9`.\nFinding divisors up to `sqrt(diff)` (approx `sqrt(10^9) = 31622`) is efficient.\nThe number of divisors for `diff` up to `10^9` is relatively small (max 1344 for `735134400`).\nCalculations involve numbers up to `(10^9 + 10^9)^2 / 1 = 4 * 10^18`, which fits within standard 64-bit integers (Python handles large integers automatically).\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a <= b for simpler calculations, swap if not.\n    # The result lcm(a+k, b+k) is symmetric.\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    # Iterate through each divisor 'g' of diff\n    for g in divisors:\n        # Calculate k_candidate: the smallest non-negative k\n        # such that (a + k) is a multiple of g.\n        # This is equivalent to finding k such that (a + k) % g == 0.\n        # If a % g == 0, k = 0.\n        # Otherwise, k = g - (a % g).\n        k_candidate = (g - (a % g)) % g\n\n        current_a_plus_k = a + k_candidate\n        current_b_plus_k = b + k_candidate\n\n        # lcm(X, Y) = (X * Y) / gcd(X, Y)\n        # We know gcd(a+k, b+k) = gcd(a+k, diff).\n        # Since we chose k_candidate such that (a+k_candidate) is a multiple of g,\n        # and g is a divisor of diff, then g is a common divisor of (a+k_candidate) and diff.\n        # In fact, with this choice of k_candidate, g will be gcd(a+k_candidate, diff).\n        # This is because (a+k_candidate) is the smallest multiple of g that is >= a.\n        # Any larger multiple of g would result in a larger a+k, and thus a larger LCM.\n        # So, the gcd is indeed g.\n        current_lcm = (current_a_plus_k * current_b_plus_k) // g\n\n        # Update min_lcm and best_k\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k_candidate\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            best_k = min(best_k, k_candidate)\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a <= b for simpler calculations, swap if not.\n    # The result lcm(a+k, b+k) is symmetric.\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    # Iterate through each divisor 'g' of diff\n    for g in divisors:\n        # Calculate k_candidate: the smallest non-negative k\n        # such that (a + k) is a multiple of g.\n        # This is equivalent to finding k such that (a + k) % g == 0.\n        # If a % g == 0, k = 0.\n        # Otherwise, k = g - (a % g).\n        k_candidate = (g - (a % g)) % g\n\n        current_a_plus_k = a + k_candidate\n        current_b_plus_k = b + k_candidate\n\n        # lcm(X, Y) = (X * Y) / gcd(X, Y)\n        # We know gcd(a+k, b+k) = gcd(a+k, diff).\n        # Since we chose k_candidate such that (a+k_candidate) is a multiple of g,\n        # and g is a divisor of diff, then g is a common divisor of (a+k_candidate) and diff.\n        # In fact, with this choice of k_candidate, g will be gcd(a+k_candidate, diff).\n        # This is because (a+k_candidate) is the smallest multiple of g that is >= a.\n        # Any larger multiple of g would result in a larger a+k, and thus a larger LCM.\n        # So, the gcd is indeed g.\n        current_lcm = (current_a_plus_k * current_b_plus_k) // g\n\n        # Update min_lcm and best_k\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k_candidate\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            best_k = min(best_k, k_candidate)\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 2346,
        "thoughts_token_count": 839
    }
}