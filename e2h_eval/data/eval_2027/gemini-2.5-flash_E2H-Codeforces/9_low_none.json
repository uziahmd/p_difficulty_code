{
    "start": 1758009635.275114,
    "end": 1758009656.026073,
    "start-formatted": "2025-09-16 17:00 KST",
    "end-formatted": "2025-09-16 17:00 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Breaking Down the Souvenir Sale Problem**\n\nOkay, so I'm looking at this \"Selling Souvenirs\" problem, and my initial thoughts are that it's a constrained knapsack variant. We've got *n* souvenirs, a maximum weight *m*, and each souvenir has a weight *wi* (crucially, limited to 1, 2, or 3!) and a cost *ci*. The goal is to maximize the total cost without exceeding the weight limit.\n\nThe massive *n* (up to 10^5) immediately ruled out a straightforward O(n*m) DP, as that would be computationally too expensive (3*10^10 operations). The weight constraint is the key.\n\nMy thought process then shifted to exploiting that tiny weight range. If weights are only 1, 2, or 3, I should group the souvenirs by weight. I envision three lists: `costs1`, `costs2`, and `costs3`, each holding the costs of souvenirs with weights 1, 2, and 3, respectively. To make it maximally efficient, I'd sort each list in descending order.\n\nSo, now I'm thinking,  I have `costs1`, `costs2`, and `costs3`, sorted from highest to lowest cost within each weight category. The problem now becomes choosing `k1`, `k2`, and `k3` items from these lists such that `k1 * 1 + k2 * 2 + k3 * 3 <= m` and `sum(costs1[:k1]) + sum(costs2[:k2]) + sum(costs3[:k3])` is maximized.  Still looks like a knapsack, but maybe with a more specialized solution.\n\nThis structure of the small weights sparked an idea: iterate through the number of items of one weight, solve for the others. The process of picking the items is like solving a simpler knapsack with a reduced capacity. For example, if I'm picking `k3` items of weight 3, I know they contribute `k3 * 3` to the total weight and `sum(costs3[:k3])` to the total cost. I now have remaining capacity, `m - k3 * 3`, and need to maximize the cost using only items from `costs1` and `costs2`. I believe this approach will work.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    costs1 = []\n    costs2 = []\n    costs3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs1.append(c)\n        elif w == 2:\n            costs2.append(c)\n        else: # w == 3\n            costs3.append(c)\n\n    # Sort costs in descending order to pick most expensive first\n    costs1.sort(reverse=True)\n    costs2.sort(reverse=True)\n    costs3.sort(reverse=True)\n\n    # Precompute prefix sums for efficient cost calculation\n    # P_i[k] will store the sum of costs of the k most expensive items of weight i\n    P1 = [0] * (len(costs1) + 1)\n    for i in range(len(costs1)):\n        P1[i+1] = P1[i] + costs1[i]\n\n    P2 = [0] * (len(costs2) + 1)\n    for i in range(len(costs2)):\n        P2[i+1] = P2[i] + costs2[i]\n\n    P3 = [0] * (len(costs3) + 1)\n    for i in range(len(costs3)):\n        P3[i+1] = P3[i] + costs3[i]\n\n    max_total_cost = 0\n\n    # Iterate through the number of items of weight 3\n    # k3 is the count of items of weight 3\n    for k3 in range(len(P3)):\n        weight_used_by_3 = k3 * 3\n        if weight_used_by_3 > m:\n            break # Cannot take k3 items of weight 3, too heavy\n\n        current_cost_3 = P3[k3]\n        remaining_capacity = m - weight_used_by_3\n\n        # Now, we need to fill the remaining_capacity using items of weight 1 and 2.\n        # This is a 0/1 knapsack for two item types.\n        # We can iterate through the number of items of weight 2.\n        # k2 is the count of items of weight 2\n        \n        # The maximum possible number of weight 2 items we can take is limited by remaining_capacity\n        # and the available items in costs2.\n        max_k2_possible = min(len(P2) - 1, remaining_capacity // 2)\n\n        # To optimize finding the best k1 for each k2, we can use a two-pointer approach\n        # or precompute and iterate efficiently.\n        # Let's use a two-pointer-like approach. We want to find the best k1 for each k2.\n        # As k2 decreases, remaining_capacity_for_1 increases, so k1 can increase.\n\n        # We will iterate k2 from 0 up to max_k2_possible.\n        # For each k2, we calculate the remaining capacity for weight 1 items\n        # and take as many as possible.\n\n        current_cost_1_2 = 0\n        best_k1_for_current_k2 = 0\n        \n        # Iterate k2 from max_k2_possible down to 0 to maintain the optimal k1\n        # from a previous, larger k2. This isn't strictly necessary with prefix sums\n        # as we can just calculate k1 directly, but it's a common pattern.\n        # Here, a direct calculation is simpler:\n        \n        for k2 in range(max_k2_possible + 1):\n            weight_used_by_2 = k2 * 2\n            \n            # Calculate cost from k2 items of weight 2\n            current_cost_2 = P2[k2]\n            \n            # Remaining capacity for weight 1 items\n            remaining_capacity_for_1 = remaining_capacity - weight_used_by_2\n            \n            # Take as many weight 1 items as possible\n            k1 = min(len(P1) - 1, remaining_capacity_for_1)\n            \n            current_cost_1 = P1[k1]\n            \n            # Total cost for this combination of k1, k2, k3\n            current_total_cost = current_cost_3 + current_cost_2 + current_cost_1\n            max_total_cost = max(max_total_cost, current_total_cost)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    costs1 = []\n    costs2 = []\n    costs3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs1.append(c)\n        elif w == 2:\n            costs2.append(c)\n        else: # w == 3\n            costs3.append(c)\n\n    # Sort costs in descending order to pick most expensive first\n    costs1.sort(reverse=True)\n    costs2.sort(reverse=True)\n    costs3.sort(reverse=True)\n\n    # Precompute prefix sums for efficient cost calculation\n    # P_i[k] will store the sum of costs of the k most expensive items of weight i\n    P1 = [0] * (len(costs1) + 1)\n    for i in range(len(costs1)):\n        P1[i+1] = P1[i] + costs1[i]\n\n    P2 = [0] * (len(costs2) + 1)\n    for i in range(len(costs2)):\n        P2[i+1] = P2[i] + costs2[i]\n\n    P3 = [0] * (len(costs3) + 1)\n    for i in range(len(costs3)):\n        P3[i+1] = P3[i] + costs3[i]\n\n    max_total_cost = 0\n\n    # Iterate through the number of items of weight 3\n    # k3 is the count of items of weight 3\n    for k3 in range(len(P3)):\n        weight_used_by_3 = k3 * 3\n        if weight_used_by_3 > m:\n            break # Cannot take k3 items of weight 3, too heavy\n\n        current_cost_3 = P3[k3]\n        remaining_capacity = m - weight_used_by_3\n\n        # Now, we need to fill the remaining_capacity using items of weight 1 and 2.\n        # This is a 0/1 knapsack for two item types.\n        # We can iterate through the number of items of weight 2.\n        # k2 is the count of items of weight 2\n        \n        # The maximum possible number of weight 2 items we can take is limited by remaining_capacity\n        # and the available items in costs2.\n        max_k2_possible = min(len(P2) - 1, remaining_capacity // 2)\n\n        # To optimize finding the best k1 for each k2, we can use a two-pointer approach\n        # or precompute and iterate efficiently.\n        # Let's use a two-pointer-like approach. We want to find the best k1 for each k2.\n        # As k2 decreases, remaining_capacity_for_1 increases, so k1 can increase.\n\n        # We will iterate k2 from 0 up to max_k2_possible.\n        # For each k2, we calculate the remaining capacity for weight 1 items\n        # and take as many as possible.\n\n        current_cost_1_2 = 0\n        best_k1_for_current_k2 = 0\n        \n        # Iterate k2 from max_k2_possible down to 0 to maintain the optimal k1\n        # from a previous, larger k2. This isn't strictly necessary with prefix sums\n        # as we can just calculate k1 directly, but it's a common pattern.\n        # Here, a direct calculation is simpler:\n        \n        for k2 in range(max_k2_possible + 1):\n            weight_used_by_2 = k2 * 2\n            \n            # Calculate cost from k2 items of weight 2\n            current_cost_2 = P2[k2]\n            \n            # Remaining capacity for weight 1 items\n            remaining_capacity_for_1 = remaining_capacity - weight_used_by_2\n            \n            # Take as many weight 1 items as possible\n            k1 = min(len(P1) - 1, remaining_capacity_for_1)\n            \n            current_cost_1 = P1[k1]\n            \n            # Total cost for this combination of k1, k2, k3\n            current_total_cost = current_cost_3 + current_cost_2 + current_cost_1\n            max_total_cost = max(max_total_cost, current_total_cost)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 487,
        "completion_token_count": 1093,
        "thoughts_token_count": 735
    }
}