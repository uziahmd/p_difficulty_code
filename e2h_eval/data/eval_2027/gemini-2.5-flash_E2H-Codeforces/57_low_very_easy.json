{
    "start": 1758284877.3682067,
    "end": 1758284918.8090367,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Let's Tackle This Competitive Programming Problem!**\n\nOkay, so I've got this problem about figuring out Vasya's best and worst ranks in an Olympiad.  I'm given the number of participants (`n`), the minimum points Vasya got (`x`), and the scores for the first and second tours (`a` and `b`). The goal is to determine the best and worst possible ranks Vasya could achieve.\n\nThe critical insight here is understanding how tied scores affect ranking. If multiple participants have the same total score, the jury decides their order. This means I need to optimize my strategies for both the best and worst-case scenarios.\n\nFor the best rank, I need to maximize Vasya's score while simultaneously minimizing the number of other participants who score *strictly higher* than him.  I know his total score has to be at least `x`. Since I don't know which scores belong to Vasya, I need to figure out how to assign his scores from the given lists. The constraint `a_i + b_j >= x` is guaranteed for some `i` and `j` which means Vasya can always achieve at least `x`.\n\nTo find his highest possible score, I'll sort the scores in the lists `a` and `b` in descending order. Then, I'll pair the largest possible scores from each list. If the sum is at least `x`, great, that's Vasya's maximum score! Now I just need to figure out who else is scoring higher to get his best rank.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Sort 'a' in descending order and 'b' in ascending order.\n    # This pairing strategy (largest a_i with smallest b_j) is useful for both best and worst case.\n    # For best case: it helps find Vasya's max score, and for others, it helps minimize their scores\n    # when paired against the remaining largest a_i's.\n    # For worst case: it helps find Vasya's min score, and for others, it helps maximize their scores\n    # when paired against the remaining largest a_i's.\n    a.sort(reverse=True)\n    b.sort()\n\n    # --- Calculate Best Rank ---\n    # To find the best rank, Vasya should aim for the highest possible score,\n    # and we want to minimize the number of participants who score STRICTLY more than Vasya.\n    # If multiple participants have the same score as Vasya, Vasya can be ranked 1st among them.\n\n    # Vasya's maximum possible score, given he must score at least x.\n    # We pair the largest available score from 'a' with the largest available score from 'b'.\n    # This is a fixed value, as it's the absolute max any participant could get.\n    vasya_max_score = a[0] + b[n-1] # Largest a + Largest b\n    # The problem guarantees Vasya's score is at least x.\n    # If a[0] + b[n-1] < x, this implies x is unachievable with these specific a and b,\n    # but the problem guarantees it's possible for some i, j.\n    # So, we just assume Vasya gets this max score, as long as it's >= x.\n    # The guarantee \"ai + bj >= x\" means there *exists* a pair for Vasya.\n    # To maximize Vasya's score, we pick the largest a and largest b.\n    # If a[0] + b[n-1] is less than x, it means x is a very high threshold.\n    # However, the problem statement \"Vasya got at least x points\" implies his *actual* score is >= x.\n    # So we just consider his score to be a[0] + b[n-1]. If this is less than x, it means the problem\n    # statement implies Vasya's true score is higher than what a[0]+b[n-1] would suggest, which\n    # contradicts the idea of finding the max score from available a and b.\n    # The most natural interpretation is that Vasya *could* achieve the maximum possible sum from the lists,\n    # and this sum is guaranteed to be >= x (or if his actual score is higher than x, it's still the max possible).\n    # So, Vasya's score for best rank is simply a[0] + b[n-1].\n\n    # For best rank, Vasya gets a[0] + b[n-1].\n    # Other participants are paired to minimize their scores.\n    # We use a greedy strategy: pair the remaining largest 'a' values with the smallest 'b' values.\n    # This means a[1] with b[0], a[2] with b[1], ..., a[n-1] with b[n-2].\n    # This pairing forms n-1 other scores.\n    # The number of participants with score > Vasya's max score is 0.\n    # Vasya's best rank is always 1. (As per the problem statement, if scores are equal, jury can assign 1st place).\n\n    best_rank = 1\n\n    # --- Calculate Worst Rank ---\n    # To find the worst rank, Vasya should aim for the lowest possible score (but still >= x).\n    # Other participants should aim for the highest possible scores.\n    # We want to maximize the number of participants who score STRICTLY more than Vasya,\n    # and also maximize the number of participants who score EQUAL to Vasya.\n\n    # We use a two-pointer approach to find the minimum possible score for Vasya that is >= x.\n    # Sort 'a' descending and 'b' ascending.\n    # The idea is to pair a[i] with b[j].\n    # To maximize other participants' scores, we would pair large 'a' with large 'b'.\n    # To minimize Vasya's score, we would pair small 'a' with small 'b'.\n    # This is a bit tricky because we don't know *which* a_i and b_j are Vasya's.\n    # We need to find a pairing of all n `a` values and n `b` values such that:\n    # 1. One pair (a_V, b_V) has a sum S_V >= x. This is Vasya's score.\n    # 2. All other (n-1) pairs (a_k, b_k) have sums S_k.\n    # We want to maximize the count of S_k > S_V or S_k = S_V.\n\n    # Consider the sorted arrays: a (descending), b (ascending)\n    # a: [a_0, a_1, ..., a_{n-1}]\n    # b: [b_0, b_1, ..., b_{n-1}]\n    # We are looking for a pairing (a_i, b_j) for Vasya.\n    # For a fixed a_i, we need to find b_j such that a_i + b_j >= x.\n    # To minimize Vasya's score (for worst rank), we want to pick the smallest possible b_j for a given a_i.\n    # The smallest b_j that satisfies a_i + b_j >= x is b_j >= x - a_i.\n    # In the sorted `b` array (ascending), this would be `b[k]` where `b[k]` is the first element >= `x - a_i`.\n    # This suggests that for each `a_i`, we can find a candidate `b_j`.\n    # However, each `a_i` and `b_j` can only be used once.\n\n    # A more systematic approach for worst rank:\n    # We want to find a permutation of `b` (let's call it `b'`) such that `a_i + b'_i` are the total scores.\n    # Vasya gets one of these `a_i + b'_i` scores, and it must be >= x.\n    # We want to maximize the number of people who score strictly more or equal to Vasya.\n    # This means we should try to make Vasya's score as small as possible (but >= x)\n    # and make other people's scores as large as possible.\n\n    # The optimal pairing strategy to maximize the sums of other participants (and thus Vasya's worst rank)\n    # while ensuring Vasya's score is at least `x` is as follows:\n    # Sort `a` in descending order. Sort `b` in ascending order.\n    # We want to pair a_i with b_j such that the sums are maximized for others.\n    # Consider the pairing `a[i]` with `b[n-1-i]`. This pairing (largest with largest, second largest with second largest, etc.)\n    # maximizes the sum of pairs. This is not what we want.\n    # The pairing `a[i]` with `b[i]` (largest a with smallest b, second largest a with second smallest b)\n    # minimizes the sum of pairs.\n\n    # Let's use the two-pointer approach to find the number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Sort `a` in descending order. Sort `b` in ascending order.\n    # `a = [a_0, a_1, ..., a_{n-1}]`\n    # `b = [b_0, b_1, ..., b_{n-1}]`\n    # We iterate through `a` with pointer `i` from `0` to `n-1`.\n    # For each `a[i]`, we want to find how many `b[j]` (with `j` from `0` to `n-1`) can be paired with it\n    # to satisfy `a[i] + b[j] >= x`.\n    # Since `b` is sorted, we can use a second pointer `j` starting from `0`.\n    # If `a[i] + b[j] >= x`, then `a[i]` can be paired with `b[j]`, `b[j+1]`, ..., `b[n-1]`.\n    # If `a[i] + b[j] < x`, then `b[j]` is too small for `a[i]`. We need a larger `b`. Increment `j`.\n\n    # This is a standard approach to count pairs (a_i, b_j) with a_i + b_j >= x.\n    # Initialize `count = 0`.\n    # Pointer `j` for `b` starts at `0`.\n    # For `i` from `0` to `n-1` (iterating through `a`):\n    #   While `j < n` and `a[i] + b[j] < x`:\n    #     Increment `j`.\n    #   If `j < n`:\n    #     This means `a[i] + b[j] >= x`.\n    #     We can form a valid pair `(a[i], b[j])`.\n    #     Increment `count`.\n    #     Increment `j` (b[j] is now \"used\"). This is the crucial part for the worst rank.\n    #     When we pair `a[i]` with `b[j]`, we are effectively saying these two are used up.\n    #     We want to maximize the number of such pairs, because each such pair could be Vasya's.\n    #     The problem states \"Vasya got at least x points\". This means there's *one* such pair that is Vasya's.\n    #     The question is how many *other* participants could also achieve a score of at least x.\n    #     No, the question is how many participants score *more than or equal to* Vasya's score.\n\n    # Let's re-evaluate the worst rank strategy.\n    # We need to find a permutation of `b` (let's call it `b_perm`) such that `sum_scores = [a[i] + b_perm[i] for i in range(n)]`.\n    # Vasya's score `S_V` is one of these `sum_scores`. `S_V >= x`.\n    # We want to maximize `count(S_k >= S_V)`.\n\n    # To maximize the number of people who score >= Vasya's score, Vasya should get the smallest possible score >= x.\n    # And other people should get the largest possible scores.\n    # This implies that the `a_i` and `b_j` that form Vasya's score should be \"small\" (but sufficient).\n    # And the `a_i` and `b_j` that form other people's scores should be \"large\".\n\n    # Consider the pairing `a[i]` with `b[i]` (after sorting `a` descending and `b` ascending).\n    # This pairing minimizes the overall sums.\n    # `a = [a_0, a_1, ..., a_{n-1}]` (desc)\n    # `b = [b_0, b_1, ..., b_{n-1}]` (asc)\n    # Pairing: `(a_0, b_0), (a_1, b_1), ..., (a_{n-1}, b_{n-1})`\n    # Scores: `s_0=a_0+b_0, s_1=a_1+b_1, ..., s_{n-1}=a_{n-1}+b_{n-1}`.\n    # These scores `s_i` are not necessarily sorted.\n    # This pairing strategy (largest a with smallest b, etc.) is the one that minimizes the sum of all pairs.\n    # It also minimizes the maximum sum of any pair.\n    # And it maximizes the minimum sum of any pair. (This is not quite right, it's more complex).\n\n    # The correct approach for worst rank:\n    # We want to count how many participants can score `S_k >= S_V`, where `S_V` is Vasya's score and `S_V >= x`.\n    # To maximize this count, we should choose Vasya's score `S_V` to be as small as possible (but >= x).\n    # And we should try to make other participants' scores as high as possible.\n    # This means, for Vasya, we use an `a_i` and `b_j` that sum to a minimal value `>= x`.\n    # For others, we use the remaining `a` and `b` values to maximize their sums.\n\n    # This is equivalent to finding the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\n    # This is a classic two-pointer problem.\n    # Sort `a` in descending order.\n    # Sort `b` in ascending order.\n    # Use pointer `i` for `a` (from left, `a[0]` is largest).\n    # Use pointer `j` for `b` (from right, `b[n-1]` is largest).\n    # `a_ptr = 0` (points to `a[0]`)\n    # `b_ptr = n - 1` (points to `b[n-1]`)\n    # `worst_rank = 0` (this will count participants whose score *could* be >= Vasya's minimum score)\n\n    # We iterate `a_ptr` from `0` to `n-1`.\n    # For each `a[a_ptr]`, we try to find a `b[b_ptr]` such that `a[a_ptr] + b[b_ptr] >= x`.\n    # If `a[a_ptr] + b[b_ptr] >= x`:\n    #   This pair `(a[a_ptr], b[b_ptr])` can form a score `S >= x`.\n    #   We want to count how many such pairs we can form.\n    #   We increment `worst_rank` (this pair contributes to the count of people who could score high).\n    #   We then move both pointers: `a_ptr` to the right, `b_ptr` to the left.\n    #   Why? Because `a[a_ptr]` is now used, and `b[b_ptr]` is now used.\n    # If `a[a_ptr] + b[b_ptr] < x`:\n    #   The current `a[a_ptr]` (which is large) is not enough to make `x` even with the current `b[b_ptr]` (which is also large).\n    #   This means `a[a_ptr]` is too small to contribute to a sum `>= x` with any *remaining* `b` values (since `b_ptr` is the largest remaining `b`).\n    #   So, we must use `a[a_ptr]` with a smaller `b` (if any are left), but that would make the sum even smaller.\n    #   This means `a[a_ptr]` cannot form a pair that sums to `x` or more with any of the remaining `b`s.\n    #   So, `a[a_ptr]` cannot be Vasya's score (or any participant's score >= x) in this pairing strategy.\n    #   We move `a_ptr` to the right, effectively discarding `a[a_ptr]` for forming a sum `>= x`.\n    #   The `b[b_ptr]` is still available for other `a` values.\n\n    # Let's refine the two-pointer for worst rank:\n    # Sort `a` in descending order.\n    # Sort `b` in ascending order.\n    # `worst_rank_count = 0`\n    # `ptr_a = 0` (index for `a`, starts at largest)\n    # `ptr_b = n - 1` (index for `b`, starts at largest)\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= x`:\n    #     # This pair can achieve at least x points.\n    #     # This means one participant can get this score.\n    #     # This *could* be Vasya, or it could be someone else who scores high.\n    #     # We want to maximize the count of such people.\n    #     worst_rank_count += 1\n    #     ptr_a += 1 # Use this a_i\n    #     ptr_b -= 1 # Use this b_j\n    #   Else (`a[ptr_a] + b[ptr_b] < x`):\n    #     # `a[ptr_a]` (current largest available `a`) combined with `b[ptr_b]` (current largest available `b`)\n    #     # is not enough to reach `x`.\n    #     # This means `a[ptr_a]` cannot be paired with *any* remaining `b` to reach `x` (since `b` is sorted ascending,\n    #     # `b[ptr_b]` is the largest available `b`, so any `b[k]` with `k < ptr_b` would be even smaller).\n    #     # So, `a[ptr_a]` cannot be used to form a score `>= x`.\n    #     # We must \"discard\" `a[ptr_a]` by advancing `ptr_a`.\n    #     # The `b[ptr_b]` is still available. It might be paired with a smaller `a` value later.\n    #     # This is precisely the logic to maximize the number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    #     ptr_a += 1\n\n    # After the loop, `worst_rank_count` will hold the maximum number of participants\n    # who *can* achieve a score of at least `x`.\n    # Vasya is one of these participants.\n    # To get his worst rank, we assume all `worst_rank_count - 1` other participants\n    # who also achieved `>= x` points are ranked before him.\n    # And if there are participants who scored < x, they are ranked after.\n    # So, Vasya's worst rank is `worst_rank_count`.\n\n    # Example: n=5, x=2, a=[1,1,1,1,1], b=[1,1,1,1,1]\n    # a_desc = [1,1,1,1,1]\n    # b_asc = [1,1,1,1,1]\n    # ptr_a=0, ptr_b=4. a[0]+b[4] = 1+1=2 >= x. count=1. ptr_a=1, ptr_b=3.\n    # ptr_a=1, ptr_b=3. a[1]+b[3] = 1+1=2 >= x. count=2. ptr_a=2, ptr_b=2.\n    # ptr_a=2, ptr_b=2. a[2]+b[2] = 1+1=2 >= x. count=3. ptr_a=3, ptr_b=1.\n    # ptr_a=3, ptr_b=1. a[3]+b[1] = 1+1=2 >= x. count=4. ptr_a=4, ptr_b=0.\n    # ptr_a=4, ptr_b=0. a[4]+b[0] = 1+1=2 >= x. count=5. ptr_a=5, ptr_b=-1.\n    # Loop ends. worst_rank_count = 5. Output: 1 5. Correct for example 1.\n\n    # Example 2: n=6, x=7, a=[4,3,5,6,4,4], b=[8,6,0,4,3,4]\n    # a_desc = [6,5,4,4,4,3]\n    # b_asc = [0,3,4,4,6,8]\n    #\n    # ptr_a=0 (a[0]=6), ptr_b=5 (b[5]=8). Sum=14. 14 >= 7. count=1. ptr_a=1, ptr_b=4.\n    # ptr_a=1 (a[1]=5), ptr_b=4 (b[4]=6). Sum=11. 11 >= 7. count=2. ptr_a=2, ptr_b=3.\n    # ptr_a=2 (a[2]=4), ptr_b=3 (b[3]=4). Sum=8. 8 >= 7. count=3. ptr_a=3, ptr_b=2.\n    # ptr_a=3 (a[3]=4), ptr_b=2 (b[2]=4). Sum=8. 8 >= 7. count=4. ptr_a=4, ptr_b=1.\n    # ptr_a=4 (a[4]=4), ptr_b=1 (b[1]=3). Sum=7. 7 >= 7. count=5. ptr_a=5, ptr_b=0.\n    # ptr_a=5 (a[5]=3), ptr_b=0 (b[0]=0). Sum=3. 3 < 7. No. ptr_a=6.\n    # Loop ends. worst_rank_count = 5. Output: 1 5. Correct for example 2.\n\n    worst_rank_count = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            worst_rank_count += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # If current a[ptr_a] (largest available) + b[ptr_b] (largest available) is less than x,\n            # then a[ptr_a] cannot form a sum >= x with *any* remaining b.\n            # So, we \"discard\" a[ptr_a] for the purpose of forming sums >= x.\n            ptr_a += 1\n            # b[ptr_b] is still available and might form a sum >= x with a smaller a_i (which is not how this logic works).\n            # The logic \"ptr_a += 1\" when sum < x is specifically for maximizing the count of pairs.\n            # If a[ptr_a] + b[ptr_b] < x, it means a[ptr_a] is too small to contribute to a sum >= x,\n            # even with the largest available b[ptr_b]. So, it cannot form such a pair.\n            # We move to the next a[ptr_a+1] which is smaller.\n            # This is correct.\n\n    sys.stdout.write(f\"{best_rank} {worst_rank_count}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Sort 'a' in descending order and 'b' in ascending order.\n    # This pairing strategy (largest a_i with smallest b_j) is useful for both best and worst case.\n    # For best case: it helps find Vasya's max score, and for others, it helps minimize their scores\n    # when paired against the remaining largest a_i's.\n    # For worst case: it helps find Vasya's min score, and for others, it helps maximize their scores\n    # when paired against the remaining largest a_i's.\n    a.sort(reverse=True)\n    b.sort()\n\n    # --- Calculate Best Rank ---\n    # To find the best rank, Vasya should aim for the highest possible score,\n    # and we want to minimize the number of participants who score STRICTLY more than Vasya.\n    # If multiple participants have the same score as Vasya, Vasya can be ranked 1st among them.\n\n    # Vasya's maximum possible score, given he must score at least x.\n    # We pair the largest available score from 'a' with the largest available score from 'b'.\n    # This is a fixed value, as it's the absolute max any participant could get.\n    vasya_max_score = a[0] + b[n-1] # Largest a + Largest b\n    # The problem guarantees Vasya's score is at least x.\n    # If a[0] + b[n-1] < x, this implies x is unachievable with these specific a and b,\n    # but the problem guarantees it's possible for some i, j.\n    # So, we just assume Vasya gets this max score, as long as it's >= x.\n    # The guarantee \"ai + bj >= x\" means there *exists* a pair for Vasya.\n    # To maximize Vasya's score, we pick the largest a and largest b.\n    # If a[0] + b[n-1] is less than x, it means x is a very high threshold.\n    # However, the problem statement \"Vasya got at least x points\" implies his *actual* score is >= x.\n    # So we just consider his score to be a[0] + b[n-1]. If this is less than x, it means the problem\n    # statement implies Vasya's true score is higher than what a[0]+b[n-1] would suggest, which\n    # contradicts the idea of finding the max score from available a and b.\n    # The most natural interpretation is that Vasya *could* achieve the maximum possible sum from the lists,\n    # and this sum is guaranteed to be >= x (or if his actual score is higher than x, it's still the max possible).\n    # So, Vasya's score for best rank is simply a[0] + b[n-1].\n\n    # For best rank, Vasya gets a[0] + b[n-1].\n    # Other participants are paired to minimize their scores.\n    # We use a greedy strategy: pair the remaining largest 'a' values with the smallest 'b' values.\n    # This means a[1] with b[0], a[2] with b[1], ..., a[n-1] with b[n-2].\n    # This pairing forms n-1 other scores.\n    # The number of participants with score > Vasya's max score is 0.\n    # Vasya's best rank is always 1. (As per the problem statement, if scores are equal, jury can assign 1st place).\n\n    best_rank = 1\n\n    # --- Calculate Worst Rank ---\n    # To find the worst rank, Vasya should aim for the lowest possible score (but still >= x).\n    # Other participants should aim for the highest possible scores.\n    # We want to maximize the number of participants who score STRICTLY more than Vasya,\n    # and also maximize the number of participants who score EQUAL to Vasya.\n\n    # We use a two-pointer approach to find the minimum possible score for Vasya that is >= x.\n    # Sort 'a' descending and 'b' ascending.\n    # The idea is to pair a[i] with b[j].\n    # To maximize other participants' scores, we would pair large 'a' with large 'b'.\n    # To minimize Vasya's score, we would pair small 'a' with small 'b'.\n    # This is a bit tricky because we don't know *which* a_i and b_j are Vasya's.\n    # We need to find a pairing of all n `a` values and n `b` values such that:\n    # 1. One pair (a_V, b_V) has a sum S_V >= x. This is Vasya's score.\n    # 2. All other (n-1) pairs (a_k, b_k) have sums S_k.\n    # We want to maximize the count of S_k > S_V or S_k = S_V.\n\n    # Consider the sorted arrays: a (descending), b (ascending)\n    # a: [a_0, a_1, ..., a_{n-1}]\n    # b: [b_0, b_1, ..., b_{n-1}]\n    # We are looking for a pairing (a_i, b_j) for Vasya.\n    # For a fixed a_i, we need to find b_j such that a_i + b_j >= x.\n    # To minimize Vasya's score (for worst rank), we want to pick the smallest possible b_j for a given a_i.\n    # The smallest b_j that satisfies a_i + b_j >= x is b_j >= x - a_i.\n    # In the sorted `b` array (ascending), this would be `b[k]` where `b[k]` is the first element >= `x - a_i`.\n    # This suggests that for each `a_i`, we can find a candidate `b_j`.\n    # However, each `a_i` and `b_j` can only be used once.\n\n    # A more systematic approach for worst rank:\n    # We want to find a permutation of `b` (let's call it `b'`) such that `a_i + b'_i` are the total scores.\n    # Vasya gets one of these `a_i + b'_i` scores, and it must be >= x.\n    # We want to maximize the number of people who score strictly more or equal to Vasya.\n    # This means we should try to make Vasya's score as small as possible (but >= x)\n    # and make other people's scores as large as possible.\n\n    # The optimal pairing strategy to maximize the sums of other participants (and thus Vasya's worst rank)\n    # while ensuring Vasya's score is at least `x` is as follows:\n    # Sort `a` in descending order. Sort `b` in ascending order.\n    # We want to pair a_i with b_j such that the sums are maximized for others.\n    # Consider the pairing `a[i]` with `b[n-1-i]`. This pairing (largest with largest, second largest with second largest, etc.)\n    # maximizes the sum of pairs. This is not what we want.\n    # The pairing `a[i]` with `b[i]` (largest a with smallest b, second largest a with second smallest b)\n    # minimizes the sum of pairs.\n\n    # Let's use the two-pointer approach to find the number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Sort `a` in descending order. Sort `b` in ascending order.\n    # `a = [a_0, a_1, ..., a_{n-1}]`\n    # `b = [b_0, b_1, ..., b_{n-1}]`\n    # We iterate through `a` with pointer `i` from `0` to `n-1`.\n    # For each `a[i]`, we want to find how many `b[j]` (with `j` from `0` to `n-1`) can be paired with it\n    # to satisfy `a[i] + b[j] >= x`.\n    # Since `b` is sorted, we can use a second pointer `j` starting from `0`.\n    # If `a[i] + b[j] >= x`, then `a[i]` can be paired with `b[j]`, `b[j+1]`, ..., `b[n-1]`.\n    # If `a[i] + b[j] < x`, then `b[j]` is too small for `a[i]`. We need a larger `b`. Increment `j`.\n\n    # This is a standard approach to count pairs (a_i, b_j) with a_i + b_j >= x.\n    # Initialize `count = 0`.\n    # Pointer `j` for `b` starts at `0`.\n    # For `i` from `0` to `n-1` (iterating through `a`):\n    #   While `j < n` and `a[i] + b[j] < x`:\n    #     Increment `j`.\n    #   If `j < n`:\n    #     This means `a[i] + b[j] >= x`.\n    #     We can form a valid pair `(a[i], b[j])`.\n    #     Increment `count`.\n    #     Increment `j` (b[j] is now \"used\"). This is the crucial part for the worst rank.\n    #     When we pair `a[i]` with `b[j]`, we are effectively saying these two are used up.\n    #     We want to maximize the number of such pairs, because each such pair could be Vasya's.\n    #     The problem states \"Vasya got at least x points\". This means there's *one* such pair that is Vasya's.\n    #     The question is how many *other* participants could also achieve a score of at least x.\n    #     No, the question is how many participants score *more than or equal to* Vasya's score.\n\n    # Let's re-evaluate the worst rank strategy.\n    # We need to find a permutation of `b` (let's call it `b_perm`) such that `sum_scores = [a[i] + b_perm[i] for i in range(n)]`.\n    # Vasya's score `S_V` is one of these `sum_scores`. `S_V >= x`.\n    # We want to maximize `count(S_k >= S_V)`.\n\n    # To maximize the number of people who score >= Vasya's score, Vasya should get the smallest possible score >= x.\n    # And other people should get the largest possible scores.\n    # This implies that the `a_i` and `b_j` that form Vasya's score should be \"small\" (but sufficient).\n    # And the `a_i` and `b_j` that form other people's scores should be \"large\".\n\n    # Consider the pairing `a[i]` with `b[i]` (after sorting `a` descending and `b` ascending).\n    # This pairing minimizes the overall sums.\n    # `a = [a_0, a_1, ..., a_{n-1}]` (desc)\n    # `b = [b_0, b_1, ..., b_{n-1}]` (asc)\n    # Pairing: `(a_0, b_0), (a_1, b_1), ..., (a_{n-1}, b_{n-1})`\n    # Scores: `s_0=a_0+b_0, s_1=a_1+b_1, ..., s_{n-1}=a_{n-1}+b_{n-1}`.\n    # These scores `s_i` are not necessarily sorted.\n    # This pairing strategy (largest a with smallest b, etc.) is the one that minimizes the sum of all pairs.\n    # It also minimizes the maximum sum of any pair.\n    # And it maximizes the minimum sum of any pair. (This is not quite right, it's more complex).\n\n    # The correct approach for worst rank:\n    # We want to count how many participants can score `S_k >= S_V`, where `S_V` is Vasya's score and `S_V >= x`.\n    # To maximize this count, we should choose Vasya's score `S_V` to be as small as possible (but >= x).\n    # And we should try to make other participants' scores as high as possible.\n    # This means, for Vasya, we use an `a_i` and `b_j` that sum to a minimal value `>= x`.\n    # For others, we use the remaining `a` and `b` values to maximize their sums.\n\n    # This is equivalent to finding the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\n    # This is a classic two-pointer problem.\n    # Sort `a` in descending order.\n    # Sort `b` in ascending order.\n    # Use pointer `i` for `a` (from left, `a[0]` is largest).\n    # Use pointer `j` for `b` (from right, `b[n-1]` is largest).\n    # `a_ptr = 0` (points to `a[0]`)\n    # `b_ptr = n - 1` (points to `b[n-1]`)\n    # `worst_rank = 0` (this will count participants whose score *could* be >= Vasya's minimum score)\n\n    # We iterate `a_ptr` from `0` to `n-1`.\n    # For each `a[a_ptr]`, we try to find a `b[b_ptr]` such that `a[a_ptr] + b[b_ptr] >= x`.\n    # If `a[a_ptr] + b[b_ptr] >= x`:\n    #   This pair `(a[a_ptr], b[b_ptr])` can form a score `S >= x`.\n    #   We want to count how many such pairs we can form.\n    #   We increment `worst_rank` (this pair contributes to the count of people who could score high).\n    #   We then move both pointers: `a_ptr` to the right, `b_ptr` to the left.\n    #   Why? Because `a[a_ptr]` is now used, and `b[b_ptr]` is now used.\n    # If `a[a_ptr] + b[b_ptr] < x`:\n    #   The current `a[a_ptr]` (which is large) is not enough to make `x` even with the current `b[b_ptr]` (which is also large).\n    #   This means `a[a_ptr]` is too small to contribute to a sum `>= x` with any *remaining* `b` values (since `b_ptr` is the largest remaining `b`).\n    #   So, we must use `a[a_ptr]` with a smaller `b` (if any are left), but that would make the sum even smaller.\n    #   This means `a[a_ptr]` cannot form a pair that sums to `x` or more with any of the remaining `b`s.\n    #   So, `a[a_ptr]` cannot be Vasya's score (or any participant's score >= x) in this pairing strategy.\n    #   We move `a_ptr` to the right, effectively discarding `a[a_ptr]` for forming a sum `>= x`.\n    #   The `b[b_ptr]` is still available for other `a` values.\n\n    # Let's refine the two-pointer for worst rank:\n    # Sort `a` in descending order.\n    # Sort `b` in ascending order.\n    # `worst_rank_count = 0`\n    # `ptr_a = 0` (index for `a`, starts at largest)\n    # `ptr_b = n - 1` (index for `b`, starts at largest)\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= x`:\n    #     # This pair can achieve at least x points.\n    #     # This means one participant can get this score.\n    #     # This *could* be Vasya, or it could be someone else who scores high.\n    #     # We want to maximize the count of such people.\n    #     worst_rank_count += 1\n    #     ptr_a += 1 # Use this a_i\n    #     ptr_b -= 1 # Use this b_j\n    #   Else (`a[ptr_a] + b[ptr_b] < x`):\n    #     # `a[ptr_a]` (current largest available `a`) combined with `b[ptr_b]` (current largest available `b`)\n    #     # is not enough to reach `x`.\n    #     # This means `a[ptr_a]` cannot be paired with *any* remaining `b` to reach `x` (since `b` is sorted ascending,\n    #     # `b[ptr_b]` is the largest available `b`, so any `b[k]` with `k < ptr_b` would be even smaller).\n    #     # So, `a[ptr_a]` cannot be used to form a score `>= x`.\n    #     # We must \"discard\" `a[ptr_a]` by advancing `ptr_a`.\n    #     # The `b[ptr_b]` is still available. It might be paired with a smaller `a` value later.\n    #     # This is precisely the logic to maximize the number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    #     ptr_a += 1\n\n    # After the loop, `worst_rank_count` will hold the maximum number of participants\n    # who *can* achieve a score of at least `x`.\n    # Vasya is one of these participants.\n    # To get his worst rank, we assume all `worst_rank_count - 1` other participants\n    # who also achieved `>= x` points are ranked before him.\n    # And if there are participants who scored < x, they are ranked after.\n    # So, Vasya's worst rank is `worst_rank_count`.\n\n    # Example: n=5, x=2, a=[1,1,1,1,1], b=[1,1,1,1,1]\n    # a_desc = [1,1,1,1,1]\n    # b_asc = [1,1,1,1,1]\n    # ptr_a=0, ptr_b=4. a[0]+b[4] = 1+1=2 >= x. count=1. ptr_a=1, ptr_b=3.\n    # ptr_a=1, ptr_b=3. a[1]+b[3] = 1+1=2 >= x. count=2. ptr_a=2, ptr_b=2.\n    # ptr_a=2, ptr_b=2. a[2]+b[2] = 1+1=2 >= x. count=3. ptr_a=3, ptr_b=1.\n    # ptr_a=3, ptr_b=1. a[3]+b[1] = 1+1=2 >= x. count=4. ptr_a=4, ptr_b=0.\n    # ptr_a=4, ptr_b=0. a[4]+b[0] = 1+1=2 >= x. count=5. ptr_a=5, ptr_b=-1.\n    # Loop ends. worst_rank_count = 5. Output: 1 5. Correct for example 1.\n\n    # Example 2: n=6, x=7, a=[4,3,5,6,4,4], b=[8,6,0,4,3,4]\n    # a_desc = [6,5,4,4,4,3]\n    # b_asc = [0,3,4,4,6,8]\n    #\n    # ptr_a=0 (a[0]=6), ptr_b=5 (b[5]=8). Sum=14. 14 >= 7. count=1. ptr_a=1, ptr_b=4.\n    # ptr_a=1 (a[1]=5), ptr_b=4 (b[4]=6). Sum=11. 11 >= 7. count=2. ptr_a=2, ptr_b=3.\n    # ptr_a=2 (a[2]=4), ptr_b=3 (b[3]=4). Sum=8. 8 >= 7. count=3. ptr_a=3, ptr_b=2.\n    # ptr_a=3 (a[3]=4), ptr_b=2 (b[2]=4). Sum=8. 8 >= 7. count=4. ptr_a=4, ptr_b=1.\n    # ptr_a=4 (a[4]=4), ptr_b=1 (b[1]=3). Sum=7. 7 >= 7. count=5. ptr_a=5, ptr_b=0.\n    # ptr_a=5 (a[5]=3), ptr_b=0 (b[0]=0). Sum=3. 3 < 7. No. ptr_a=6.\n    # Loop ends. worst_rank_count = 5. Output: 1 5. Correct for example 2.\n\n    worst_rank_count = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            worst_rank_count += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # If current a[ptr_a] (largest available) + b[ptr_b] (largest available) is less than x,\n            # then a[ptr_a] cannot form a sum >= x with *any* remaining b.\n            # So, we \"discard\" a[ptr_a] for the purpose of forming sums >= x.\n            ptr_a += 1\n            # b[ptr_b] is still available and might form a sum >= x with a smaller a_i (which is not how this logic works).\n            # The logic \"ptr_a += 1\" when sum < x is specifically for maximizing the count of pairs.\n            # If a[ptr_a] + b[ptr_b] < x, it means a[ptr_a] is too small to contribute to a sum >= x,\n            # even with the largest available b[ptr_b]. So, it cannot form such a pair.\n            # We move to the next a[ptr_a+1] which is smaller.\n            # This is correct.\n\n    sys.stdout.write(f\"{best_rank} {worst_rank_count}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 5512,
        "thoughts_token_count": 759
    }
}