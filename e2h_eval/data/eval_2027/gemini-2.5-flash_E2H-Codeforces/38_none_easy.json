{
    "start": 1758293706.2247505,
    "end": 1758293773.0038092,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = -1\n    max_unidirectional_pairs = -1\n\n    # Iterate through possible values of k (number of nodes in the largest SCC)\n    # The number of pairs (u, v) with u < v that are reachable from each other\n    # in an SCC of size k is k * (k - 1) / 2.\n    # We want to find k such that k * (k - 1) / 2 <= p.\n    # The largest such k will minimize the remaining p' to be covered by other SCCs.\n    # k^2 - k - 2p <= 0\n    # Roots are (1 +/- sqrt(1 + 8p)) / 2\n    # So k <= (1 + sqrt(1 + 8p)) / 2\n    \n    # We can find the largest k such that k * (k - 1) / 2 <= p\n    # This k will be the size of the main SCC.\n    \n    # Calculate k_max_scc\n    k_max_scc = 0\n    while (k_max_scc + 1) * k_max_scc // 2 <= p:\n        k_max_scc += 1\n    k_max_scc -= 1 # k_max_scc is now the largest k such that k*(k-1)/2 <= p\n\n    # Case 1: All nodes form a single SCC.\n    # This is when p = k * (k - 1) / 2 for some k.\n    # In this case, there are no unidirectional pairs.\n    if p == k_max_scc * (k_max_scc - 1) // 2:\n        min_nodes = k_max_scc\n        max_unidirectional_pairs = 0\n    else:\n        # Case 2: We need more nodes.\n        # We have an SCC of size k_max_scc, contributing k_max_scc * (k_max_scc - 1) // 2 pairs.\n        # The remaining pairs needed are p_rem = p - k_max_scc * (k_max_scc - 1) // 2.\n        # Each additional node added to the graph (not in the main SCC) can form at most one\n        # pair (u, v) with u < v that are reachable from each other if it forms a 2-node SCC\n        # with an existing node, or is part of a larger SCC.\n        # However, the most efficient way to get remaining 'p_rem' pairs is to have\n        # 'p_rem' separate 2-node SCCs. This is not quite right.\n        # A simpler way to think about it:\n        # We have k_max_scc nodes in the main SCC.\n        # The remaining p_rem pairs must come from nodes outside this SCC.\n        # Each additional node we add, say 'x', and make it part of a new SCC of size 2\n        # (e.g., x < y, x -> y, y -> x), contributes 1 pair (x, y).\n        # So, if we need p_rem additional pairs, we need p_rem additional nodes\n        # to form p_rem 2-node SCCs.\n        # Total nodes = k_max_scc + p_rem.\n        # Total unidirectional pairs:\n        # Each of the p_rem nodes (let's call them 'single_nodes') can have paths\n        # to/from the main SCC.\n        # To maximize unidirectional pairs, we want a structure like:\n        # A chain of nodes, say 1 -> 2 -> ... -> m, where each node is a separate SCC.\n        # And then a main SCC of size k.\n        # If we have k nodes in the main SCC and m single nodes,\n        # total nodes = k + m.\n        # The p_rem pairs must come from these m nodes.\n        # The most efficient way to get p_rem pairs is to have p_rem nodes, each forming a 2-node SCC.\n        # No, that's wrong.\n        # If we have k nodes in one SCC and m nodes in another SCC, they don't contribute to p unless\n        # they are connected to each other, which means they would be in the same SCC.\n        #\n        # Let's re-evaluate.\n        # We have k_max_scc nodes. These contribute k_max_scc * (k_max_scc - 1) / 2 pairs.\n        # Remaining pairs needed: p_rem = p - k_max_scc * (k_max_scc - 1) // 2.\n        # Each additional node we add, say node 'x', can be connected to the main SCC.\n        # If we add a node 'x' and make it reachable from all nodes in the main SCC,\n        # and all nodes in the main SCC reachable from 'x', then 'x' joins the main SCC.\n        # This increases the SCC size by 1.\n        # If we add 'x' and make it reachable from the main SCC, but not vice-versa,\n        # or vice-versa, but not both, then 'x' is a separate SCC.\n        #\n        # To get p_rem additional pairs (u, v) with u < v that are reachable from each other:\n        # We need to add more nodes to form SCCs.\n        # Each additional node 'x' can be added such that it forms a 2-node SCC with one of the\n        # k_max_scc nodes. This would require 1 new node and adds 1 pair.\n        # Total nodes = k_max_scc + p_rem.\n        #\n        # Consider the nodes as a main SCC of size k_max_scc, and then p_rem individual nodes\n        # that are connected to the main SCC to form 2-node SCCs.\n        # Example: Node 'x' and node 'y' from the main SCC. If x < y, and x -> y, y -> x, this is 1 pair.\n        #\n        # The problem statement says \"u < v and u and v are reachable from each other\".\n        # This means they must be in the same SCC.\n        # So, to get p_rem additional pairs, we need to add nodes to form new SCCs or expand existing ones.\n        #\n        # If we have k_max_scc nodes in one SCC, and need p_rem additional pairs:\n        # We must add p_rem nodes, each forming a new SCC of size 2 with one of the existing nodes.\n        # This means we add p_rem nodes, and each new node 'x_i' forms an SCC with one of the k_max_scc nodes 'y_i'.\n        # This requires p_rem nodes.\n        # Total nodes = k_max_scc + p_rem.\n        #\n        # Let's consider the structure:\n        # We have a main SCC of size `k_scc = k_max_scc`.\n        # This contributes `k_scc * (k_scc - 1) / 2` pairs.\n        # We need `p_rem = p - k_scc * (k_scc - 1) / 2` more pairs.\n        # Each of these `p_rem` pairs must come from a new SCC of size 2.\n        # To form `p_rem` new SCCs of size 2, we need `p_rem` additional nodes.\n        # Let these nodes be `s_1, s_2, ..., s_p_rem`.\n        # Each `s_i` forms an SCC with some `x_i` (where `x_i` can be from the main SCC or another `s_j`).\n        # To minimize nodes, we pair each `s_i` with one of the `k_scc` nodes.\n        # So, we add `p_rem` new nodes.\n        # Total nodes = `k_scc + p_rem`.\n        #\n        # Now, for unidirectional pairs.\n        # We have `k_scc` nodes in the main SCC. Let's call them `C_1, ..., C_{k_scc}`.\n        # We have `p_rem` additional nodes. Let's call them `S_1, ..., S_{p_rem}`.\n        # Each `S_i` forms an SCC of size 2 with some `C_j`.\n        # Example: `S_1 < C_1`, `S_1 <-> C_1`. This adds 1 pair (S_1, C_1).\n        #\n        # To maximize unidirectional pairs, we want a \"chain\" structure between SCCs.\n        # The `k_scc` nodes form one SCC.\n        # The `p_rem` nodes are \"single\" nodes, each forming its own SCC.\n        # Let's say we have `k_scc` nodes in one SCC (call it `SCC_main`).\n        # And `p_rem` nodes, each forming an SCC of size 1.\n        # To get `p_rem` pairs that are reachable from each other, we must have `p_rem` nodes each forming an SCC of size 2.\n        # So, we have `k_scc` nodes in `SCC_main`.\n        # And we have `p_rem` nodes `N_1, ..., N_{p_rem}`.\n        # Each `N_i` forms an SCC of size 2 with some node from `SCC_main`. This means `N_i` is connected to `SCC_main`.\n        # This doesn't seem right. If `N_i` forms an SCC of size 2 with `C_j`, then `N_i` and `C_j` are in the same SCC.\n        # This means `SCC_main` would absorb `N_i`.\n        #\n        # Let's rethink the structure for p_rem pairs.\n        # Suppose we have `N` nodes in total.\n        # The pairs (u, v) with u < v and reachable from each other means they are in the same SCC.\n        # Let the SCCs be `SCC_1, SCC_2, ..., SCC_m`.\n        # Let `size_i` be the number of nodes in `SCC_i`.\n        # The total number of such pairs is `sum(size_i * (size_i - 1) / 2 for i in 1..m)`.\n        # We want this sum to be `p`.\n        # We want to minimize `sum(size_i)`.\n        #\n        # To minimize nodes for a given `p`:\n        # We want to make one SCC as large as possible.\n        # Let `k` be the size of the largest SCC.\n        # `k * (k - 1) / 2 <= p`.\n        # `k_max_scc` is the largest such `k`.\n        # Let `p_covered = k_max_scc * (k_max_scc - 1) / 2`.\n        # `p_rem = p - p_covered`.\n        # We need to cover `p_rem` additional pairs using the minimum number of additional nodes.\n        # Each additional node can contribute at most 1 pair if it forms a 2-node SCC with an existing node.\n        # So, we need `p_rem` additional nodes.\n        # Total nodes = `k_max_scc + p_rem`.\n        # This is the minimum number of nodes.\n        #\n        # Let `n = k_max_scc + p_rem`.\n        # The graph structure to achieve this:\n        # We have `k_max_scc` nodes forming one SCC (let's call it `SCC_A`).\n        # We have `p_rem` nodes `x_1, ..., x_{p_rem}`.\n        # Each `x_i` forms a 2-node SCC with one distinct node from `SCC_A`.\n        # For example, `x_1 <-> y_1`, `x_2 <-> y_2`, ..., `x_{p_rem} <-> y_{p_rem}`,\n        # where `y_1, ..., y_{p_rem}` are distinct nodes from `SCC_A`.\n        # This configuration results in `k_max_scc` nodes in `SCC_A` and `p_rem` nodes,\n        # each forming a 2-node SCC with a node from `SCC_A`.\n        # This means `SCC_A` effectively expands to include these `p_rem` nodes, if `y_i` are distinct.\n        # This would mean the main SCC has size `k_max_scc + p_rem`.\n        # This structure would yield `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` pairs, which is > p.\n        #\n        # The structure must be:\n        # One SCC of size `k_max_scc`.\n        # `p_rem` SCCs of size 2. Each consisting of two distinct nodes.\n        # Total nodes = `k_max_scc + 2 * p_rem`. This is too many nodes.\n        #\n        # The problem states \"u < v and u and v are reachable from each other\".\n        # This means they are in the same SCC.\n        # Let's say we have `k` nodes in one SCC and `m` nodes in `m` separate SCCs of size 1.\n        # Total nodes `k+m`. Pairs `k*(k-1)/2`.\n        #\n        # Let's re-read: \"u < v and u and v are reachable from each other\".\n        # This implies that the 'p' pairs must be from nodes within the same SCC.\n        #\n        # Consider `n` nodes.\n        # We want to minimize `n`.\n        # The number of pairs `u < v` in an SCC of size `s` is `s * (s - 1) / 2`.\n        # We want to find `s_1, s_2, ..., s_m` such that `sum(s_i * (s_i - 1) / 2) = p`.\n        # And `sum(s_i)` is minimized.\n        # To minimize `sum(s_i)` for a fixed `p`, we should make one `s_i` as large as possible.\n        # Let `k` be the size of the largest SCC.\n        # `k_max_scc` is the largest integer such that `k_max_scc * (k_max_scc - 1) / 2 <= p`.\n        #\n        # If `p = k_max_scc * (k_max_scc - 1) / 2`:\n        #   Then we have one SCC of size `k_max_scc`.\n        #   Minimum nodes = `k_max_scc`.\n        #   Unidirectional pairs = 0 (since all nodes are in one SCC, no paths between SCCs).\n        #   This is the first part of the `if/else` block.\n        #\n        # If `p > k_max_scc * (k_max_scc - 1) / 2`:\n        #   We have an SCC of size `k_max_scc`. This covers `k_max_scc * (k_max_scc - 1) / 2` pairs.\n        #   We need `p_rem = p - k_max_scc * (k_max_scc - 1) / 2` more pairs.\n        #   Each additional pair must come from a new SCC of size 2.\n        #   To form `p_rem` additional pairs, we need `p_rem` SCCs of size 2.\n        #   Each SCC of size 2 uses 2 nodes and contributes 1 pair (u,v) where u<v.\n        #   So, we need `2 * p_rem` nodes for these `p_rem` SCCs.\n        #   Total nodes = `k_max_scc + 2 * p_rem`.\n        #   However, we can reuse nodes.\n        #   If we have `k_max_scc` nodes in `SCC_A`.\n        #   We need `p_rem` additional pairs.\n        #   We can add `p_rem` new nodes `x_1, ..., x_{p_rem}`.\n        #   And connect `x_i` to `y_i` (where `y_i` is one of the `k_max_scc` nodes) such that `x_i <-> y_i`.\n        #   This makes `x_i` and `y_i` part of the same SCC.\n        #   So, if we take `p_rem` distinct nodes from `SCC_A` (say `y_1, ..., y_{p_rem}`)\n        #   and add `p_rem` new nodes `x_1, ..., x_{p_rem}`.\n        #   Then for each `i`, make `x_i` and `y_i` form a 2-node SCC.\n        #   This implies `x_i` and `y_i` are in the same SCC.\n        #   This structure is actually one large SCC of size `k_max_scc + p_rem`.\n        #   This would yield `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` pairs.\n        #   But we know `k_max_scc` is the largest such that `k_max_scc * (k_max_scc - 1) / 2 <= p`.\n        #   So `(k_max_scc + 1) * k_max_scc / 2 > p`.\n        #   Therefore, `k_max_scc + p_rem` must be `k_max_scc` plus some nodes that form SCCs of size 2 *with new nodes*.\n        #\n        # The structure is:\n        # One SCC of size `k_max_scc`.\n        # And `p_rem` additional nodes, each forming an SCC of size 1.\n        # This configuration gives `k_max_scc * (k_max_scc - 1) / 2` pairs.\n        # This is incorrect. The `p_rem` pairs must come from SCCs.\n        #\n        # The \"minimum number of nodes\" part:\n        # Let `n` be the total number of nodes.\n        # Let `s_1, s_2, ..., s_m` be the sizes of the SCCs.\n        # Then `sum(s_i) = n`.\n        # We need `sum(s_i * (s_i - 1) / 2) = p`.\n        # To minimize `n`, we want to maximize `s_i * (s_i - 1) / 2` for each `s_i`.\n        # This means we want to make one SCC as large as possible.\n        # Let `k` be the size of the largest SCC.\n        # `k_max_scc` is the largest integer such that `k_max_scc * (k_max_scc - 1) / 2 <= p`.\n        # Let `p_covered = k_max_scc * (k_max_scc - 1) / 2`.\n        # `p_rem = p - p_covered`.\n        # We have `k_max_scc` nodes in one SCC.\n        # We need `p_rem` more pairs.\n        # Each additional pair `(u,v)` with `u<v` and `u<->v` must come from a new SCC of size 2.\n        # If we add `p_rem` new nodes, and each forms a 2-node SCC with one of the `k_max_scc` nodes,\n        # then these `p_rem` nodes are effectively absorbed into the `k_max_scc` SCC.\n        # This means the SCC size becomes `k_max_scc + p_rem`.\n        # This leads to `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` pairs, which is too many.\n        #\n        # The only way to get `p_rem` pairs with `p_rem` additional nodes is to have `p_rem` nodes,\n        # each of which forms a 2-node SCC with a distinct node from the main SCC, and these nodes are *not*\n        # connected to each other, only to the main SCC.\n        # This implies that the `k_max_scc` nodes form one SCC, and each of the `p_rem` nodes forms a\n        # 2-node SCC with one of the `k_max_scc` nodes, but these 2-node SCCs are distinct.\n        # This is a bit confusing.\n        #\n        # Let's consider the problem statement again: \"u < v and u and v are reachable from each other.\"\n        # This means they are in the same SCC.\n        # So we need to partition `n` nodes into `m` SCCs of sizes `s_1, ..., s_m`.\n        # `sum(s_i) = n`.\n        # `sum(s_i * (s_i - 1) / 2) = p`.\n        # To minimize `n`, we maximize the sizes of SCCs.\n        # `k_max_scc` is the largest `k` such that `k * (k - 1) / 2 <= p`.\n        # Let `p_rem = p - k_max_scc * (k_max_scc - 1) / 2`.\n        # We have `k_max_scc` nodes in one SCC.\n        # We need `p_rem` additional pairs.\n        # Each additional pair must come from a 2-node SCC.\n        # We need `p_rem` such 2-node SCCs.\n        # Each 2-node SCC uses 2 nodes. So `2 * p_rem` nodes.\n        # Total nodes = `k_max_scc + 2 * p_rem`.\n        # This is the standard greedy approach.\n        #\n        # Example: p=3\n        # k=1: 0\n        # k=2: 1\n        # k=3: 3\n        # k_max_scc = 3. p_covered = 3. p_rem = 0.\n        # Min nodes = 3. Unidirectional = 0. (Example output: 3 0)\n        #\n        # Example: p=4\n        # k=1: 0\n        # k=2: 1\n        # k=3: 3\n        # k_max_scc = 3. p_covered = 3. p_rem = 4 - 3 = 1.\n        # Min nodes = k_max_scc + 2 * p_rem = 3 + 2 * 1 = 5.\n        #\n        # Now for unidirectional pairs for p=4, min_nodes=5.\n        # We have one SCC of size 3 (nodes {1,2,3}).\n        # We need 1 additional pair. This comes from an SCC of size 2 (nodes {4,5}).\n        # So we have `SCC_A = {1,2,3}` and `SCC_B = {4,5}`.\n        # Total nodes = 3 + 2 = 5. Total pairs = 3 + 1 = 4.\n        #\n        # To maximize unidirectional pairs:\n        # We connect these SCCs in a chain.\n        # E.g., `SCC_A -> SCC_B`.\n        # This means there's a path from any node in `SCC_A` to any node in `SCC_B`.\n        # And no path from any node in `SCC_B` to any node in `SCC_A`.\n        #\n        # Number of unidirectional pairs:\n        # `|SCC_A| * |SCC_B| = 3 * 2 = 6`.\n        # This matches the example output: 5 6.\n        #\n        # Generalizing:\n        # Min nodes = `k_max_scc + 2 * p_rem`.\n        # The structure is `SCC_main` of size `k_max_scc`.\n        # And `p_rem` SCCs of size 2. Let's call them `SCC_1, ..., SCC_{p_rem}`.\n        # Total `1 + p_rem` SCCs.\n        #\n        # To maximize unidirectional pairs, arrange them in a chain.\n        # `SCC_main -> SCC_1 -> SCC_2 -> ... -> SCC_{p_rem}`.\n        # Number of nodes in `SCC_main` is `k_max_scc`.\n        # Number of nodes in each `SCC_i` is 2.\n        #\n        # If we have `m` SCCs with sizes `s_1, ..., s_m`, and we arrange them in a chain `SCC_1 -> SCC_2 -> ... -> SCC_m`.\n        # The number of unidirectional pairs is `sum(s_i * s_j for i < j)`.\n        # This is `(sum(s_i))^2 - sum(s_i^2) / 2`. No, this is wrong.\n        # It's `s_1 * (s_2 + s_3 + ... + s_m) + s_2 * (s_3 + ... + s_m) + ... + s_{m-1} * s_m`.\n        # This is equivalent to `(sum(s_i))^2 - sum(s_i^2) / 2` if all pairs were considered.\n        #\n        # Let `N_scc = 1 + p_rem` be the number of SCCs.\n        # The sizes are `k_max_scc, 2, 2, ..., 2` (`p_rem` times).\n        # Total nodes `n = k_max_scc + 2 * p_rem`.\n        #\n        # Max unidirectional pairs:\n        # We have `p_rem + 1` SCCs.\n        # Let `s_0 = k_max_scc`.\n        # Let `s_i = 2` for `i = 1, ..., p_rem`.\n        #\n        # Total unidirectional pairs = `sum_{0 <= i < j <= p_rem} s_i * s_j`.\n        # This is `(sum(s_i))^2 / 2 - sum(s_i^2) / 2`. No, this is for undirected.\n        # For directed chain `SCC_0 -> SCC_1 -> ... -> SCC_{p_rem}`:\n        # `s_0 * (s_1 + s_2 + ... + s_{p_rem})`\n        # `+ s_1 * (s_2 + ... + s_{p_rem})`\n        # `+ ...`\n        # `+ s_{p_rem-1} * s_{p_rem}`\n        #\n        # This is `sum_{i=0}^{p_rem-1} (s_i * sum_{j=i+1}^{p_rem} s_j)`.\n        #\n        # Let `S_total = sum(s_i) = k_max_scc + 2 * p_rem`.\n        # `sum_{j=i+1}^{p_rem} s_j = S_total - sum_{k=0}^{i} s_k`.\n        #\n        # Let's calculate this iteratively.\n        # `current_sum_of_sizes = 0`\n        # `unidirectional = 0`\n        #\n        # `scc_sizes = [k_max_scc] + [2] * p_rem`\n        #\n        # `for i in range(len(scc_sizes)):`\n        #   `current_scc_size = scc_sizes[i]`\n        #   `remaining_sum_of_sizes = S_total - current_sum_of_sizes - current_scc_size`\n        #   `unidirectional += current_scc_size * remaining_sum_of_sizes`\n        #   `current_sum_of_sizes += current_scc_size`\n        #\n        # This is exactly `sum_{i=0}^{N_scc-1} s_i * (S_total - sum_{k=0}^{i} s_k - s_i)`.\n        # No, this is `sum_{i=0}^{N_scc-1} s_i * (sum_{j=i+1}^{N_scc-1} s_j)`.\n        #\n        # Let `S_suffix[i] = sum_{j=i}^{p_rem} s_j`.\n        # `unidirectional = sum_{i=0}^{p_rem-1} s_i * S_suffix[i+1]`.\n        #\n        # `S_suffix = [0] * (p_rem + 2)`\n        # `S_suffix[p_rem + 1] = 0`\n        # `S_suffix[p_rem] = 2` (if p_rem > 0, else 0)\n        # `for i from p_rem-1 down to 1: S_suffix[i] = S_suffix[i+1] + 2`\n        # `S_suffix[0] = S_suffix[1] + k_max_scc`\n        #\n        # More simply:\n        # `total_nodes = k_max_scc + 2 * p_rem`.\n        # `unidirectional = k_max_scc * (2 * p_rem)` (pairs from SCC_main to all 2-node SCCs)\n        # `+ sum_{i=0}^{p_rem-1} (2 * (2 * (p_rem - 1 - i)))` (pairs from 2-node SCCs to other 2-node SCCs)\n        #\n        # Let `scc_sizes = [k_max_scc] + [2] * p_rem`.\n        # `num_sccs = len(scc_sizes)`.\n        # `total_nodes_val = sum(scc_sizes)`.\n        # `unidirectional_val = 0`.\n        # `current_sum = 0`.\n        # `for i in range(num_sccs):`\n        #   `current_scc_size = scc_sizes[i]`.\n        #   `unidirectional_val += current_scc_size * (total_nodes_val - current_sum - current_scc_size)`.\n        #   `current_sum += current_scc_size`.\n        #\n        # This is the correct formula for a chain of SCCs.\n        #\n        # Let's test with p=4:\n        # k_max_scc = 3. p_rem = 1.\n        # min_nodes = 3 + 2*1 = 5.\n        # scc_sizes = [3, 2].\n        # total_nodes_val = 5.\n        # unidirectional_val = 0.\n        #\n        # i = 0: scc_sizes[0] = 3.\n        #   unidirectional_val += 3 * (5 - 0 - 3) = 3 * 2 = 6.\n        #   current_sum = 3.\n        # i = 1: scc_sizes[1] = 2.\n        #   unidirectional_val += 2 * (5 - 3 - 2) = 2 * 0 = 0.\n        #   current_sum = 3 + 2 = 5.\n        #\n        # Result: unidirectional_val = 6. This matches the example.\n        #\n        # This confirms the logic for `min_nodes` and `max_unidirectional_pairs`.\n        \n        min_nodes = k_max_scc + p_rem\n        \n        # Calculate max_unidirectional_pairs\n        scc_sizes = [k_max_scc] + [1] * p_rem # Each remaining pair (p_rem) comes from a single node SCC.\n        # This is wrong. Each remaining pair comes from a 2-node SCC.\n        # The structure for min_nodes = k_max_scc + p_rem is:\n        # One SCC of size k_max_scc.\n        # And p_rem nodes, each forming a 2-node SCC with one of the k_max_scc nodes.\n        # This means we have one large SCC of size k_max_scc + p_rem.\n        # This leads to (k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2 pairs.\n        # This would be greater than p.\n        #\n        # The assumption that `min_nodes = k_max_scc + p_rem` implies that the `p_rem` pairs are\n        # formed by making `p_rem` nodes into 2-node SCCs with nodes from the `k_max_scc` SCC.\n        # This means the `k_max_scc` SCC absorbs `p_rem` nodes.\n        # The new SCC size would be `k_max_scc + p_rem`.\n        # The number of pairs would be `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2`.\n        # This value must be `p`.\n        # But `k_max_scc` is defined such that `k_max_scc * (k_max_scc - 1) / 2 <= p`\n        # and `(k_max_scc + 1) * k_max_scc / 2 > p`.\n        # So `k_max_scc + p_rem` can only be `k_max_scc` if `p_rem = 0`.\n        # If `p_rem > 0`, then `k_max_scc + p_rem` is strictly greater than `k_max_scc`.\n        # So `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` would be strictly greater than `p`.\n        # This means my interpretation of `min_nodes = k_max_scc + p_rem` is wrong.\n        #\n        # Let's re-evaluate `min_nodes` for `p_rem > 0`.\n        # We have `k_max_scc` nodes in one SCC, contributing `k_max_scc * (k_max_scc - 1) / 2` pairs.\n        # We need `p_rem` more pairs.\n        # To get `p_rem` pairs, we need `p_rem` additional 2-node SCCs.\n        # Each 2-node SCC needs 2 nodes. So `2 * p_rem` nodes.\n        # Total nodes = `k_max_scc + 2 * p_rem`. This seems to be the correct minimum number of nodes.\n        # This assumes the `p_rem` 2-node SCCs are distinct from the `k_max_scc` SCC and from each other.\n        # This is what the example `p=4` implies.\n        #\n        # So, min_nodes = k_max_scc + 2 * p_rem.\n        # And the SCCs are `SCC_main` (size `k_max_scc`) and `p_rem` SCCs of size 2.\n        \n        min_nodes = k_max_scc + 2 * p_rem\n        \n        # Calculate max_unidirectional_pairs using the chain formula.\n        scc_sizes = [k_max_scc] + [2] * p_rem\n        \n        total_nodes_val = sum(scc_sizes)\n        unidirectional_val = 0\n        current_sum = 0\n        for i in range(len(scc_sizes)):\n            current_scc_size = scc_sizes[i]\n            unidirectional_val += current_scc_size * (total_nodes_val - current_sum - current_scc_size)\n            current_sum += current_scc_size\n        \n        max_unidirectional_pairs = unidirectional_val\n\n    print(f\"{min_nodes} {max_unidirectional_pairs}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = -1\n    max_unidirectional_pairs = -1\n\n    # Iterate through possible values of k (number of nodes in the largest SCC)\n    # The number of pairs (u, v) with u < v that are reachable from each other\n    # in an SCC of size k is k * (k - 1) / 2.\n    # We want to find k such that k * (k - 1) / 2 <= p.\n    # The largest such k will minimize the remaining p' to be covered by other SCCs.\n    # k^2 - k - 2p <= 0\n    # Roots are (1 +/- sqrt(1 + 8p)) / 2\n    # So k <= (1 + sqrt(1 + 8p)) / 2\n    \n    # We can find the largest k such that k * (k - 1) / 2 <= p\n    # This k will be the size of the main SCC.\n    \n    # Calculate k_max_scc\n    k_max_scc = 0\n    while (k_max_scc + 1) * k_max_scc // 2 <= p:\n        k_max_scc += 1\n    k_max_scc -= 1 # k_max_scc is now the largest k such that k*(k-1)/2 <= p\n\n    # Case 1: All nodes form a single SCC.\n    # This is when p = k * (k - 1) / 2 for some k.\n    # In this case, there are no unidirectional pairs.\n    if p == k_max_scc * (k_max_scc - 1) // 2:\n        min_nodes = k_max_scc\n        max_unidirectional_pairs = 0\n    else:\n        # Case 2: We need more nodes.\n        # We have an SCC of size k_max_scc, contributing k_max_scc * (k_max_scc - 1) // 2 pairs.\n        # The remaining pairs needed are p_rem = p - k_max_scc * (k_max_scc - 1) // 2.\n        # Each additional node added to the graph (not in the main SCC) can form at most one\n        # pair (u, v) with u < v that are reachable from each other if it forms a 2-node SCC\n        # with an existing node, or is part of a larger SCC.\n        # However, the most efficient way to get remaining 'p_rem' pairs is to have\n        # 'p_rem' separate 2-node SCCs. This is not quite right.\n        # A simpler way to think about it:\n        # We have k_max_scc nodes in the main SCC.\n        # The remaining p_rem pairs must come from nodes outside this SCC.\n        # Each additional node we add, say 'x', and make it part of a new SCC of size 2\n        # (e.g., x < y, x -> y, y -> x), contributes 1 pair (x, y).\n        # So, if we need p_rem additional pairs, we need p_rem additional nodes\n        # to form p_rem 2-node SCCs.\n        # Total nodes = k_max_scc + p_rem.\n        # Total unidirectional pairs:\n        # Each of the p_rem nodes (let's call them 'single_nodes') can have paths\n        # to/from the main SCC.\n        # To maximize unidirectional pairs, we want a structure like:\n        # A chain of nodes, say 1 -> 2 -> ... -> m, where each node is a separate SCC.\n        # And then a main SCC of size k.\n        # If we have k nodes in the main SCC and m single nodes,\n        # total nodes = k + m.\n        # The p_rem pairs must come from these m nodes.\n        # The most efficient way to get p_rem pairs is to have p_rem nodes, each forming a 2-node SCC.\n        # No, that's wrong.\n        # If we have k nodes in one SCC and m nodes in another SCC, they don't contribute to p unless\n        # they are connected to each other, which means they would be in the same SCC.\n        #\n        # Let's re-evaluate.\n        # We have k_max_scc nodes. These contribute k_max_scc * (k_max_scc - 1) / 2 pairs.\n        # Remaining pairs needed: p_rem = p - k_max_scc * (k_max_scc - 1) // 2.\n        # Each additional node we add, say node 'x', can be connected to the main SCC.\n        # If we add a node 'x' and make it reachable from all nodes in the main SCC,\n        # and all nodes in the main SCC reachable from 'x', then 'x' joins the main SCC.\n        # This increases the SCC size by 1.\n        # If we add 'x' and make it reachable from the main SCC, but not vice-versa,\n        # or vice-versa, but not both, then 'x' is a separate SCC.\n        #\n        # To get p_rem additional pairs (u, v) with u < v that are reachable from each other:\n        # We need to add more nodes to form SCCs.\n        # Each additional node 'x' can be added such that it forms a 2-node SCC with one of the\n        # k_max_scc nodes. This would require 1 new node and adds 1 pair.\n        # Total nodes = k_max_scc + p_rem.\n        #\n        # Consider the nodes as a main SCC of size k_max_scc, and then p_rem individual nodes\n        # that are connected to the main SCC to form 2-node SCCs.\n        # Example: Node 'x' and node 'y' from the main SCC. If x < y, and x -> y, y -> x, this is 1 pair.\n        #\n        # The problem statement says \"u < v and u and v are reachable from each other\".\n        # This means they must be in the same SCC.\n        # So, to get p_rem additional pairs, we need to add nodes to form new SCCs or expand existing ones.\n        #\n        # If we have k_max_scc nodes in one SCC, and need p_rem additional pairs:\n        # We must add p_rem nodes, each forming a new SCC of size 2 with one of the existing nodes.\n        # This means we add p_rem nodes, and each new node 'x_i' forms an SCC with one of the k_max_scc nodes 'y_i'.\n        # This requires p_rem nodes.\n        # Total nodes = k_max_scc + p_rem.\n        #\n        # Let's consider the structure:\n        # We have a main SCC of size `k_scc = k_max_scc`.\n        # This contributes `k_scc * (k_scc - 1) / 2` pairs.\n        # We need `p_rem = p - k_scc * (k_scc - 1) / 2` more pairs.\n        # Each of these `p_rem` pairs must come from a new SCC of size 2.\n        # To form `p_rem` new SCCs of size 2, we need `p_rem` additional nodes.\n        # Let these nodes be `s_1, s_2, ..., s_p_rem`.\n        # Each `s_i` forms an SCC with some `x_i` (where `x_i` can be from the main SCC or another `s_j`).\n        # To minimize nodes, we pair each `s_i` with one of the `k_scc` nodes.\n        # So, we add `p_rem` new nodes.\n        # Total nodes = `k_scc + p_rem`.\n        #\n        # Now, for unidirectional pairs.\n        # We have `k_scc` nodes in the main SCC. Let's call them `C_1, ..., C_{k_scc}`.\n        # We have `p_rem` additional nodes. Let's call them `S_1, ..., S_{p_rem}`.\n        # Each `S_i` forms an SCC of size 2 with some `C_j`.\n        # Example: `S_1 < C_1`, `S_1 <-> C_1`. This adds 1 pair (S_1, C_1).\n        #\n        # To maximize unidirectional pairs, we want a \"chain\" structure between SCCs.\n        # The `k_scc` nodes form one SCC.\n        # The `p_rem` nodes are \"single\" nodes, each forming its own SCC.\n        # Let's say we have `k_scc` nodes in one SCC (call it `SCC_main`).\n        # And `p_rem` nodes, each forming an SCC of size 1.\n        # To get `p_rem` pairs that are reachable from each other, we must have `p_rem` nodes each forming an SCC of size 2.\n        # So, we have `k_scc` nodes in `SCC_main`.\n        # And we have `p_rem` nodes `N_1, ..., N_{p_rem}`.\n        # Each `N_i` forms an SCC of size 2 with some node from `SCC_main`. This means `N_i` is connected to `SCC_main`.\n        # This doesn't seem right. If `N_i` forms an SCC of size 2 with `C_j`, then `N_i` and `C_j` are in the same SCC.\n        # This means `SCC_main` would absorb `N_i`.\n        #\n        # Let's rethink the structure for p_rem pairs.\n        # Suppose we have `N` nodes in total.\n        # The pairs (u, v) with u < v and reachable from each other means they are in the same SCC.\n        # Let the SCCs be `SCC_1, SCC_2, ..., SCC_m`.\n        # Let `size_i` be the number of nodes in `SCC_i`.\n        # The total number of such pairs is `sum(size_i * (size_i - 1) / 2 for i in 1..m)`.\n        # We want this sum to be `p`.\n        # We want to minimize `sum(size_i)`.\n        #\n        # To minimize nodes for a given `p`:\n        # We want to make one SCC as large as possible.\n        # Let `k` be the size of the largest SCC.\n        # `k * (k - 1) / 2 <= p`.\n        # `k_max_scc` is the largest such `k`.\n        # Let `p_covered = k_max_scc * (k_max_scc - 1) / 2`.\n        # `p_rem = p - p_covered`.\n        # We need to cover `p_rem` additional pairs using the minimum number of additional nodes.\n        # Each additional node can contribute at most 1 pair if it forms a 2-node SCC with an existing node.\n        # So, we need `p_rem` additional nodes.\n        # Total nodes = `k_max_scc + p_rem`.\n        # This is the minimum number of nodes.\n        #\n        # Let `n = k_max_scc + p_rem`.\n        # The graph structure to achieve this:\n        # We have `k_max_scc` nodes forming one SCC (let's call it `SCC_A`).\n        # We have `p_rem` nodes `x_1, ..., x_{p_rem}`.\n        # Each `x_i` forms a 2-node SCC with one distinct node from `SCC_A`.\n        # For example, `x_1 <-> y_1`, `x_2 <-> y_2`, ..., `x_{p_rem} <-> y_{p_rem}`,\n        # where `y_1, ..., y_{p_rem}` are distinct nodes from `SCC_A`.\n        # This configuration results in `k_max_scc` nodes in `SCC_A` and `p_rem` nodes,\n        # each forming a 2-node SCC with a node from `SCC_A`.\n        # This means `SCC_A` effectively expands to include these `p_rem` nodes, if `y_i` are distinct.\n        # This would mean the main SCC has size `k_max_scc + p_rem`.\n        # This structure would yield `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` pairs, which is > p.\n        #\n        # The structure must be:\n        # One SCC of size `k_max_scc`.\n        # `p_rem` SCCs of size 2. Each consisting of two distinct nodes.\n        # Total nodes = `k_max_scc + 2 * p_rem`. This is too many nodes.\n        #\n        # The problem states \"u < v and u and v are reachable from each other\".\n        # This means they are in the same SCC.\n        # Let's say we have `k` nodes in one SCC and `m` nodes in `m` separate SCCs of size 1.\n        # Total nodes `k+m`. Pairs `k*(k-1)/2`.\n        #\n        # Let's re-read: \"u < v and u and v are reachable from each other\".\n        # This implies that the 'p' pairs must be from nodes within the same SCC.\n        #\n        # Consider `n` nodes.\n        # We want to minimize `n`.\n        # The number of pairs `u < v` in an SCC of size `s` is `s * (s - 1) / 2`.\n        # We want to find `s_1, s_2, ..., s_m` such that `sum(s_i * (s_i - 1) / 2) = p`.\n        # And `sum(s_i)` is minimized.\n        # To minimize `sum(s_i)` for a fixed `p`, we should make one `s_i` as large as possible.\n        # Let `k` be the size of the largest SCC.\n        # `k_max_scc` is the largest integer such that `k_max_scc * (k_max_scc - 1) / 2 <= p`.\n        #\n        # If `p = k_max_scc * (k_max_scc - 1) / 2`:\n        #   Then we have one SCC of size `k_max_scc`.\n        #   Minimum nodes = `k_max_scc`.\n        #   Unidirectional pairs = 0 (since all nodes are in one SCC, no paths between SCCs).\n        #   This is the first part of the `if/else` block.\n        #\n        # If `p > k_max_scc * (k_max_scc - 1) / 2`:\n        #   We have an SCC of size `k_max_scc`. This covers `k_max_scc * (k_max_scc - 1) / 2` pairs.\n        #   We need `p_rem = p - k_max_scc * (k_max_scc - 1) / 2` more pairs.\n        #   Each additional pair must come from a new SCC of size 2.\n        #   To form `p_rem` additional pairs, we need `p_rem` SCCs of size 2.\n        #   Each SCC of size 2 uses 2 nodes and contributes 1 pair (u,v) where u<v.\n        #   So, we need `2 * p_rem` nodes for these `p_rem` SCCs.\n        #   Total nodes = `k_max_scc + 2 * p_rem`.\n        #   However, we can reuse nodes.\n        #   If we have `k_max_scc` nodes in `SCC_A`.\n        #   We need `p_rem` additional pairs.\n        #   We can add `p_rem` new nodes `x_1, ..., x_{p_rem}`.\n        #   And connect `x_i` to `y_i` (where `y_i` is one of the `k_max_scc` nodes) such that `x_i <-> y_i`.\n        #   This makes `x_i` and `y_i` part of the same SCC.\n        #   So, if we take `p_rem` distinct nodes from `SCC_A` (say `y_1, ..., y_{p_rem}`)\n        #   and add `p_rem` new nodes `x_1, ..., x_{p_rem}`.\n        #   Then for each `i`, make `x_i` and `y_i` form a 2-node SCC.\n        #   This implies `x_i` and `y_i` are in the same SCC.\n        #   This structure is actually one large SCC of size `k_max_scc + p_rem`.\n        #   This would yield `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` pairs.\n        #   But we know `k_max_scc` is the largest such that `k_max_scc * (k_max_scc - 1) / 2 <= p`.\n        #   So `(k_max_scc + 1) * k_max_scc / 2 > p`.\n        #   Therefore, `k_max_scc + p_rem` must be `k_max_scc` plus some nodes that form SCCs of size 2 *with new nodes*.\n        #\n        # The structure is:\n        # One SCC of size `k_max_scc`.\n        # And `p_rem` additional nodes, each forming an SCC of size 1.\n        # This configuration gives `k_max_scc * (k_max_scc - 1) / 2` pairs.\n        # This is incorrect. The `p_rem` pairs must come from SCCs.\n        #\n        # The \"minimum number of nodes\" part:\n        # Let `n` be the total number of nodes.\n        # Let `s_1, s_2, ..., s_m` be the sizes of the SCCs.\n        # Then `sum(s_i) = n`.\n        # We need `sum(s_i * (s_i - 1) / 2) = p`.\n        # To minimize `n`, we want to maximize `s_i * (s_i - 1) / 2` for each `s_i`.\n        # This means we want to make one SCC as large as possible.\n        # Let `k` be the size of the largest SCC.\n        # `k_max_scc` is the largest integer such that `k_max_scc * (k_max_scc - 1) / 2 <= p`.\n        # Let `p_covered = k_max_scc * (k_max_scc - 1) / 2`.\n        # `p_rem = p - p_covered`.\n        # We have `k_max_scc` nodes in one SCC.\n        # We need `p_rem` more pairs.\n        # Each additional pair `(u,v)` with `u<v` and `u<->v` must come from a new SCC of size 2.\n        # If we add `p_rem` new nodes, and each forms a 2-node SCC with one of the `k_max_scc` nodes,\n        # then these `p_rem` nodes are effectively absorbed into the `k_max_scc` SCC.\n        # This means the SCC size becomes `k_max_scc + p_rem`.\n        # This leads to `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` pairs, which is too many.\n        #\n        # The only way to get `p_rem` pairs with `p_rem` additional nodes is to have `p_rem` nodes,\n        # each of which forms a 2-node SCC with a distinct node from the main SCC, and these nodes are *not*\n        # connected to each other, only to the main SCC.\n        # This implies that the `k_max_scc` nodes form one SCC, and each of the `p_rem` nodes forms a\n        # 2-node SCC with one of the `k_max_scc` nodes, but these 2-node SCCs are distinct.\n        # This is a bit confusing.\n        #\n        # Let's consider the problem statement again: \"u < v and u and v are reachable from each other.\"\n        # This means they are in the same SCC.\n        # So we need to partition `n` nodes into `m` SCCs of sizes `s_1, ..., s_m`.\n        # `sum(s_i) = n`.\n        # `sum(s_i * (s_i - 1) / 2) = p`.\n        # To minimize `n`, we maximize the sizes of SCCs.\n        # `k_max_scc` is the largest `k` such that `k * (k - 1) / 2 <= p`.\n        # Let `p_rem = p - k_max_scc * (k_max_scc - 1) / 2`.\n        # We have `k_max_scc` nodes in one SCC.\n        # We need `p_rem` additional pairs.\n        # Each additional pair must come from a 2-node SCC.\n        # We need `p_rem` such 2-node SCCs.\n        # Each 2-node SCC uses 2 nodes. So `2 * p_rem` nodes.\n        # Total nodes = `k_max_scc + 2 * p_rem`.\n        # This is the standard greedy approach.\n        #\n        # Example: p=3\n        # k=1: 0\n        # k=2: 1\n        # k=3: 3\n        # k_max_scc = 3. p_covered = 3. p_rem = 0.\n        # Min nodes = 3. Unidirectional = 0. (Example output: 3 0)\n        #\n        # Example: p=4\n        # k=1: 0\n        # k=2: 1\n        # k=3: 3\n        # k_max_scc = 3. p_covered = 3. p_rem = 4 - 3 = 1.\n        # Min nodes = k_max_scc + 2 * p_rem = 3 + 2 * 1 = 5.\n        #\n        # Now for unidirectional pairs for p=4, min_nodes=5.\n        # We have one SCC of size 3 (nodes {1,2,3}).\n        # We need 1 additional pair. This comes from an SCC of size 2 (nodes {4,5}).\n        # So we have `SCC_A = {1,2,3}` and `SCC_B = {4,5}`.\n        # Total nodes = 3 + 2 = 5. Total pairs = 3 + 1 = 4.\n        #\n        # To maximize unidirectional pairs:\n        # We connect these SCCs in a chain.\n        # E.g., `SCC_A -> SCC_B`.\n        # This means there's a path from any node in `SCC_A` to any node in `SCC_B`.\n        # And no path from any node in `SCC_B` to any node in `SCC_A`.\n        #\n        # Number of unidirectional pairs:\n        # `|SCC_A| * |SCC_B| = 3 * 2 = 6`.\n        # This matches the example output: 5 6.\n        #\n        # Generalizing:\n        # Min nodes = `k_max_scc + 2 * p_rem`.\n        # The structure is `SCC_main` of size `k_max_scc`.\n        # And `p_rem` SCCs of size 2. Let's call them `SCC_1, ..., SCC_{p_rem}`.\n        # Total `1 + p_rem` SCCs.\n        #\n        # To maximize unidirectional pairs, arrange them in a chain.\n        # `SCC_main -> SCC_1 -> SCC_2 -> ... -> SCC_{p_rem}`.\n        # Number of nodes in `SCC_main` is `k_max_scc`.\n        # Number of nodes in each `SCC_i` is 2.\n        #\n        # If we have `m` SCCs with sizes `s_1, ..., s_m`, and we arrange them in a chain `SCC_1 -> SCC_2 -> ... -> SCC_m`.\n        # The number of unidirectional pairs is `sum(s_i * s_j for i < j)`.\n        # This is `(sum(s_i))^2 - sum(s_i^2) / 2`. No, this is wrong.\n        # It's `s_1 * (s_2 + s_3 + ... + s_m) + s_2 * (s_3 + ... + s_m) + ... + s_{m-1} * s_m`.\n        # This is equivalent to `(sum(s_i))^2 - sum(s_i^2) / 2` if all pairs were considered.\n        #\n        # Let `N_scc = 1 + p_rem` be the number of SCCs.\n        # The sizes are `k_max_scc, 2, 2, ..., 2` (`p_rem` times).\n        # Total nodes `n = k_max_scc + 2 * p_rem`.\n        #\n        # Max unidirectional pairs:\n        # We have `p_rem + 1` SCCs.\n        # Let `s_0 = k_max_scc`.\n        # Let `s_i = 2` for `i = 1, ..., p_rem`.\n        #\n        # Total unidirectional pairs = `sum_{0 <= i < j <= p_rem} s_i * s_j`.\n        # This is `(sum(s_i))^2 / 2 - sum(s_i^2) / 2`. No, this is for undirected.\n        # For directed chain `SCC_0 -> SCC_1 -> ... -> SCC_{p_rem}`:\n        # `s_0 * (s_1 + s_2 + ... + s_{p_rem})`\n        # `+ s_1 * (s_2 + ... + s_{p_rem})`\n        # `+ ...`\n        # `+ s_{p_rem-1} * s_{p_rem}`\n        #\n        # This is `sum_{i=0}^{p_rem-1} (s_i * sum_{j=i+1}^{p_rem} s_j)`.\n        #\n        # Let `S_total = sum(s_i) = k_max_scc + 2 * p_rem`.\n        # `sum_{j=i+1}^{p_rem} s_j = S_total - sum_{k=0}^{i} s_k`.\n        #\n        # Let's calculate this iteratively.\n        # `current_sum_of_sizes = 0`\n        # `unidirectional = 0`\n        #\n        # `scc_sizes = [k_max_scc] + [2] * p_rem`\n        #\n        # `for i in range(len(scc_sizes)):`\n        #   `current_scc_size = scc_sizes[i]`\n        #   `remaining_sum_of_sizes = S_total - current_sum_of_sizes - current_scc_size`\n        #   `unidirectional += current_scc_size * remaining_sum_of_sizes`\n        #   `current_sum_of_sizes += current_scc_size`\n        #\n        # This is exactly `sum_{i=0}^{N_scc-1} s_i * (S_total - sum_{k=0}^{i} s_k - s_i)`.\n        # No, this is `sum_{i=0}^{N_scc-1} s_i * (sum_{j=i+1}^{N_scc-1} s_j)`.\n        #\n        # Let `S_suffix[i] = sum_{j=i}^{p_rem} s_j`.\n        # `unidirectional = sum_{i=0}^{p_rem-1} s_i * S_suffix[i+1]`.\n        #\n        # `S_suffix = [0] * (p_rem + 2)`\n        # `S_suffix[p_rem + 1] = 0`\n        # `S_suffix[p_rem] = 2` (if p_rem > 0, else 0)\n        # `for i from p_rem-1 down to 1: S_suffix[i] = S_suffix[i+1] + 2`\n        # `S_suffix[0] = S_suffix[1] + k_max_scc`\n        #\n        # More simply:\n        # `total_nodes = k_max_scc + 2 * p_rem`.\n        # `unidirectional = k_max_scc * (2 * p_rem)` (pairs from SCC_main to all 2-node SCCs)\n        # `+ sum_{i=0}^{p_rem-1} (2 * (2 * (p_rem - 1 - i)))` (pairs from 2-node SCCs to other 2-node SCCs)\n        #\n        # Let `scc_sizes = [k_max_scc] + [2] * p_rem`.\n        # `num_sccs = len(scc_sizes)`.\n        # `total_nodes_val = sum(scc_sizes)`.\n        # `unidirectional_val = 0`.\n        # `current_sum = 0`.\n        # `for i in range(num_sccs):`\n        #   `current_scc_size = scc_sizes[i]`.\n        #   `unidirectional_val += current_scc_size * (total_nodes_val - current_sum - current_scc_size)`.\n        #   `current_sum += current_scc_size`.\n        #\n        # This is the correct formula for a chain of SCCs.\n        #\n        # Let's test with p=4:\n        # k_max_scc = 3. p_rem = 1.\n        # min_nodes = 3 + 2*1 = 5.\n        # scc_sizes = [3, 2].\n        # total_nodes_val = 5.\n        # unidirectional_val = 0.\n        #\n        # i = 0: scc_sizes[0] = 3.\n        #   unidirectional_val += 3 * (5 - 0 - 3) = 3 * 2 = 6.\n        #   current_sum = 3.\n        # i = 1: scc_sizes[1] = 2.\n        #   unidirectional_val += 2 * (5 - 3 - 2) = 2 * 0 = 0.\n        #   current_sum = 3 + 2 = 5.\n        #\n        # Result: unidirectional_val = 6. This matches the example.\n        #\n        # This confirms the logic for `min_nodes` and `max_unidirectional_pairs`.\n        \n        min_nodes = k_max_scc + p_rem\n        \n        # Calculate max_unidirectional_pairs\n        scc_sizes = [k_max_scc] + [1] * p_rem # Each remaining pair (p_rem) comes from a single node SCC.\n        # This is wrong. Each remaining pair comes from a 2-node SCC.\n        # The structure for min_nodes = k_max_scc + p_rem is:\n        # One SCC of size k_max_scc.\n        # And p_rem nodes, each forming a 2-node SCC with one of the k_max_scc nodes.\n        # This means we have one large SCC of size k_max_scc + p_rem.\n        # This leads to (k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2 pairs.\n        # This would be greater than p.\n        #\n        # The assumption that `min_nodes = k_max_scc + p_rem` implies that the `p_rem` pairs are\n        # formed by making `p_rem` nodes into 2-node SCCs with nodes from the `k_max_scc` SCC.\n        # This means the `k_max_scc` SCC absorbs `p_rem` nodes.\n        # The new SCC size would be `k_max_scc + p_rem`.\n        # The number of pairs would be `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2`.\n        # This value must be `p`.\n        # But `k_max_scc` is defined such that `k_max_scc * (k_max_scc - 1) / 2 <= p`\n        # and `(k_max_scc + 1) * k_max_scc / 2 > p`.\n        # So `k_max_scc + p_rem` can only be `k_max_scc` if `p_rem = 0`.\n        # If `p_rem > 0`, then `k_max_scc + p_rem` is strictly greater than `k_max_scc`.\n        # So `(k_max_scc + p_rem) * (k_max_scc + p_rem - 1) / 2` would be strictly greater than `p`.\n        # This means my interpretation of `min_nodes = k_max_scc + p_rem` is wrong.\n        #\n        # Let's re-evaluate `min_nodes` for `p_rem > 0`.\n        # We have `k_max_scc` nodes in one SCC, contributing `k_max_scc * (k_max_scc - 1) / 2` pairs.\n        # We need `p_rem` more pairs.\n        # To get `p_rem` pairs, we need `p_rem` additional 2-node SCCs.\n        # Each 2-node SCC needs 2 nodes. So `2 * p_rem` nodes.\n        # Total nodes = `k_max_scc + 2 * p_rem`. This seems to be the correct minimum number of nodes.\n        # This assumes the `p_rem` 2-node SCCs are distinct from the `k_max_scc` SCC and from each other.\n        # This is what the example `p=4` implies.\n        #\n        # So, min_nodes = k_max_scc + 2 * p_rem.\n        # And the SCCs are `SCC_main` (size `k_max_scc`) and `p_rem` SCCs of size 2.\n        \n        min_nodes = k_max_scc + 2 * p_rem\n        \n        # Calculate max_unidirectional_pairs using the chain formula.\n        scc_sizes = [k_max_scc] + [2] * p_rem\n        \n        total_nodes_val = sum(scc_sizes)\n        unidirectional_val = 0\n        current_sum = 0\n        for i in range(len(scc_sizes)):\n            current_scc_size = scc_sizes[i]\n            unidirectional_val += current_scc_size * (total_nodes_val - current_sum - current_scc_size)\n            current_sum += current_scc_size\n        \n        max_unidirectional_pairs = unidirectional_val\n\n    print(f\"{min_nodes} {max_unidirectional_pairs}\")\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 8638,
        "thoughts_token_count": 0
    }
}