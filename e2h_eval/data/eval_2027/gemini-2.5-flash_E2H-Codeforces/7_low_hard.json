{
    "start": 1758009329.760642,
    "end": 1758009389.2310443,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Deconstructing the Snowflake Problem**\n\nOkay, so I'm tackling this \"Rudolf and Snowflakes\" problem. The hard version, of course. Let's see... the core is figuring out the structure of these snowflakes. It starts with a single center vertex. Then, we add `k` new vertices connected to the center, where `k` is greater than 1.  That's the first step.  Now, the crucial bit: *each* of those newly added vertices (the leaves) is then connected to *k* *more* new vertices. And this must happen at least once.\n\nLet's trace the vertex count.  Initially, it's 1. After the first step, it's `1 + k`. The second step adds `k^2` new vertices, making it `1 + k + k^2`. Then `k^3`, and so on.  If we apply this secondary rule `d` times, the total vertices become a geometric series: `N = 1 + k + k^2 + ... + k^(d+1)`.  That's helpful, it means the total number of vertices `N` will be `(k^(d+2) - 1) / (k - 1)`.\n\nThe problem gives us the total number of vertices `n`, and we have to find if there's a valid `k` (greater than 1) and `d` (greater or equal to 1) that fits.  Let's simplify that: if we let `m = d + 1`, since `d >= 1`, it means `m >= 2`. So, we're looking to see if `n = 1 + k + k^2 + ... + k^m`, or `n = (k^(m+1) - 1) / (k - 1)`.\n\nGiven the constraints, `n` goes up to 10^18. So, that narrows down how big `k` and `m` can be.  Let me explore a simplified example with m=2 to check for the validity.\n\nFor `m = 2`, the formula turns into `n = 1 + k + k^2`. That gives us a quadratic for `k`: `k^2 + k + (1 - n) = 0`.  Using the quadratic formula, we have `k = (-1 ± sqrt(4n - 3)) / 2`. Okay, so `4n-3` has to be a perfect square.  Let's check for integer values of `k`.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is defined by a central vertex, which connects to `k` new vertices (`k > 1`). Then, this \"branching\" step is repeated at least once: each outermost vertex (connected to only one other vertex) connects to `k` new vertices.\n\nLet's trace the number of vertices:\n1.  **Initial:** 1 central vertex.\n2.  **First step:** The central vertex connects to `k` new vertices. Total vertices: `1 + k`. These `k` new vertices are now the outermost vertices.\n3.  **Second step (first application of the branching rule):** Each of the `k` outermost vertices connects to `k` new vertices. Total new vertices added: `k * k = k^2`. Total vertices: `1 + k + k^2`. These `k^2` new vertices are now the outermost vertices.\n4.  **Third step (second application of the branching rule):** Each of the `k^2` outermost vertices connects to `k` new vertices. Total new vertices added: `k^2 * k = k^3`. Total vertices: `1 + k + k^2 + k^3`. These `k^3` new vertices are now the outermost vertices.\n\nThis process continues. If the branching rule is applied `d` times (`d >= 1`), the total number of vertices `n` will be:\n`n = 1 + k + k^2 + ... + k^(d+1)`\n\nThis is a geometric series. Let `m = d+1`. Since `d >= 1`, we must have `m >= 2`.\nSo, `n = 1 + k + k^2 + ... + k^m`, where `k > 1` and `m >= 2`.\nThe sum of this geometric series is `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if for a given `n`, there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\nThere are two main cases to consider:\n\n**Case 1: `m = 2`**\nIf `m = 2`, the equation becomes `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1)(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `4n - 3 = s^2` for some integer `s`.\n2.  `s` must be odd (because `s^2 = 4n - 3` is odd, so `s` must be odd).\n3.  `k = (-1 + s) / 2` must be an integer greater than 1. Since `s` is odd, `s-1` is even, so `k` will be an integer. For `k > 1`, we need `(-1 + s) / 2 > 1`, which implies `s - 1 > 2`, so `s > 3`.\n    Since `n >= 1`, `4n - 3 >= 1`, so `s >= 1`.\n    If `n=1`, `s=1`, `k=0` (not valid).\n    If `n=2`, `s=sqrt(5)` (not integer).\n    If `n=3`, `s=sqrt(9)=3`, `k=(-1+3)/2=1` (not valid, `k` must be `>1`).\n    So we need `s > 3`.\n\nWe can check this by calculating `s = floor(sqrt(4n - 3))`. If `s*s == 4n - 3` and `s > 3`, then `n` is a valid snowflake number for `m=2`.\n\n**Case 2: `m > 2` (i.e., `m >= 3`)**\nFor `m >= 3`, `k` must be relatively small for `n` to be within `10^18`.\n`n = 1 + k + k^2 + ... + k^m`.\nSince `k > 1`, `k^m < n`. This implies `k < n^(1/m)`.\nFor `m = 3`, `k < n^(1/3)`. Since `n <= 10^18`, `k < (10^18)^(1/3) = 10^6`.\nFor `m = 4`, `k < n^(1/4)`. `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\nFor `m = 60`, `k < n^(1/60)`. `k < (10^18)^(1/60) = 10^(0.3) approx 2`.\nIf `k=2`, `n = 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\nIf `n = 10^18`, `2^(m+1) - 1 approx 10^18`. `2^(m+1) approx 10^18`. `(m+1) log10(2) approx 18`. `(m+1) * 0.301 approx 18`. `m+1 approx 18/0.301 approx 59.8`. So `m+1` can be at most `59`. This means `m` can be at most `58`.\nTherefore, `m` can range from `3` up to about `58-59`.\n\nWe can iterate through possible values of `m` from `3` up to `60` (a safe upper bound). For each `m`, we need to find if there's an integer `k > 1` such that `n = (k^(m+1) - 1) / (k - 1)`.\nThis equation can be rewritten as `n(k-1) = k^(m+1) - 1`.\n`nk - n = k^(m+1) - 1`.\n`k^(m+1) - nk + (n-1) = 0`.\n\nThis is a polynomial equation in `k`. We can use binary search to find `k`.\nFor a fixed `m`, we are looking for `k` in the range `[2, N_max^(1/m)]`. A safe upper bound for `k` is `10^6` (for `m=3`).\nLet `f(k) = 1 + k + ... + k^m`. This function is monotonically increasing for `k > 1`.\nWe can binary search for `k` in the range `[2, 10^6]`.\nFor a given `k_mid` in binary search, calculate `val = 1 + k_mid + ... + k_mid^m`.\nIf `val == n`, we found a solution.\nIf `val < n`, `k` must be larger, so search in `[k_mid + 1, high]`.\nIf `val > n`, `k` must be smaller, so search in `[low, k_mid - 1]`.\n\nThe maximum value of `k` to check is `10^6`. The maximum `m` is `60`.\nThe `k^m` term can be `(10^6)^60 = 10^360`, which overflows standard 64-bit integers. Python handles large integers automatically, so this is not an issue for Python. However, the calculation `1 + k + ... + k^m` involves `m+1` terms. Calculating powers `k^j` and summing them can be done efficiently.\n\n**Optimization for Binary Search:**\nThe upper bound for `k` can be estimated more tightly.\n`k^m < n`. So `k < n^(1/m)`.\nFor `m=3`, `k < (10^18)^(1/3) = 10^6`.\nFor `m=4`, `k < (10^18)^(1/4) = 31622`.\nFor `m=5`, `k < (10^18)^(1/5) = 6309`.\nFor `m=6`, `k < (10^18)^(1/6) = 1000`.\nFor `m=7`, `k < (10^18)^(1/7) = 372`.\nFor `m=8`, `k < (10^18)^(1/8) = 177`.\nFor `m=9`, `k < (10^18)^(1/9) = 100`.\nFor `m=10`, `k < (10^18)^(1/10) = 63`.\nFor `m=18`, `k < (10^18)^(1/18) = 10`.\nFor `m=59`, `k < (10^18)^(1/59) = 2`.\nSo, the binary search range for `k` shrinks significantly as `m` increases. We can set `high = int(n**(1/m)) + 2` as a safe upper bound for `k` for each `m`.\n\n**Algorithm:**\n1.  Handle `n=1, 2, 3, 4, 5, 6` explicitly, as they cannot be formed by the rules (`n=1+k+k^2` requires `k>1` and `n >= 1+2+2^2 = 7`). For `n=1..6`, output \"NO\".\n2.  For each test case `n`:\n    a.  Check Case 1 (`m=2`):\n        Calculate `s_squared = 4*n - 3`.\n        If `s_squared < 0`, continue (no real `s`).\n        `s = round(s_squared**0.5)`.\n        If `s*s == s_squared` and `s > 3` (ensures `k > 1`), then `n` is a snowflake. Print \"YES\" and move to the next test case.\n    b.  Check Case 2 (`m >= 3`):\n        Iterate `m` from `3` up to `60`.\n        For each `m`, perform a binary search for `k` in the range `[2, int(n**(1/m)) + 2]`.\n        Inside the binary search:\n            `low = 2`, `high = int(n**(1/m)) + 2` (or `10^6` for safety, then `high` will be reduced by `n**(1/m)` quickly).\n            While `low <= high`:\n                `k_mid = (low + high) // 2`\n                If `k_mid < 2`, set `k_mid = 2` and continue (or break if `low` already started at `2`).\n                Calculate `current_sum = 0`.\n                `term = 1`.\n                For `i` from `0` to `m`:\n                    `current_sum += term`\n                    If `i < m` and `term > n // k_mid` (to prevent overflow before `term * k_mid`), then `term` will exceed `n`, so `current_sum` will exceed `n`. Break and set `current_sum = n + 1` to indicate too large.\n                    `term *= k_mid`\n                \n                If `current_sum == n`: print \"YES\" and break from `m` loop and `n` loop.\n                If `current_sum < n`: `low = k_mid + 1`.\n                If `current_sum > n`: `high = k_mid - 1`.\n        If `n` was found, the outer loop for `m` will also break.\n    c.  If `n` was not found after checking all `m` and `k`, print \"NO\".\n\n**Example walkthrough for n=13:**\n1.  `n=13`. Not `1..6`.\n2.  Case 1 (`m=2`):\n    `s_squared = 4*13 - 3 = 52 - 3 = 49`.\n    `s = round(49**0.5) = 7`.\n    `s*s == 49` is true. `s=7 > 3` is true.\n    So, `n=13` is a snowflake. `k = (-1+7)/2 = 3`.\n    Output \"YES\".\n\n**Example walkthrough for n=10101:**\n1.  `n=10101`. Not `1..6`.\n2.  Case 1 (`m=2`):\n    `s_squared = 4*10101 - 3 = 40404 - 3 = 40401`.\n    `s = round(40401**0.5) = 201`.\n    `s*s == 40401` is true. `s=201 > 3` is true.\n    So, `n=10101` is a snowflake. `k = (-1+201)/2 = 100`.\n    Output \"YES\".\n\n**Example walkthrough for n=255:**\n1.  `n=255`. Not `1..6`.\n2.  Case 1 (`m=2`):\n    `s_squared = 4*255 - 3 = 1020 - 3 = 1017`.\n    `s = round(1017**0.5) = 31.89...` Not a perfect square.\n3.  Case 2 (`m >= 3`):\n    Try `m=3`: Binary search `k` in `[2, int(255**(1/3))+2] = [2, 6+2] = [2, 8]`.\n        `k=2`: `1+2+4+8 = 15`. `15 < 255`. `low = 3`.\n        `k=3`: `1+3+9+27 = 40`. `40 < 255`. `low = 4`.\n        `k=4`: `1+4+16+64 = 85`. `85 < 255`. `low = 5`.\n        `k=5`: `1+5+25+125 = 156`. `156 < 255`. `low = 6`.\n        `k=6`: `1+6+36+216 = 259`. `259 > 255`. `high = 5`.\n        `low > high`. No solution for `m=3`.\n    Try `m=4`: Binary search `k` in `[2, int(255**(1/4))+2] = [2, 3+2] = [2, 5]`.\n        `k=2`: `1+2+4+8+16 = 31`. `31 < 255`. `low = 3`.\n        `k=3`: `1+3+9+27+81 = 121`. `121 < 255`. `low = 4`.\n        `k=4`: `1+4+16+64+256 = 341`. `341 > 255`. `high = 3`.\n        `low > high`. No solution for `m=4`.\n    Try `m=5`: Binary search `k` in `[2, int(255**(1/5))+2] = [2, 3+2] = [2, 5]`.\n        `k=2`: `1+2+4+8+16+32 = 63`. `63 < 255`. `low = 3`.\n        `k=3`: `1+3+9+27+81+243 = 364`. `364 > 255`. `high = 2`.\n        `low > high`. No solution for `m=5`.\n    Try `m=6`: Binary search `k` in `[2, int(255**(1/6))+2] = [2, 2+2] = [2, 4]`.\n        `k=2`: `1+2+4+8+16+32+64 = 127`. `127 < 255`. `low = 3`.\n        `k=3`: `1+3+9+27+81+243+729 = 1093`. `1093 > 255`. `high = 2`.\n        `low > high`. No solution for `m=6`.\n    Try `m=7`: Binary search `k` in `[2, int(255**(1/7))+2] = [2, 2+2] = [2, 4]`.\n        `k=2`: `1+2+4+8+16+32+64+128 = 255`. Found! `k=2, m=7`.\n    Output \"YES\".\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Edge cases: n < 7 cannot be a snowflake\n    # Smallest snowflake is 1 + 2 + 2^2 = 7 (for k=2, m=2)\n    # If n is 1, 2, 3, 4, 5, 6, it cannot be a snowflake.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    s_squared = 4 * n - 3\n    if s_squared >= 0:\n        s = int(s_squared**0.5)\n        if s * s == s_squared:\n            # For k to be an integer > 1, s must be odd and s > 3.\n            # If s is odd, s-1 is even, so (-1+s)/2 is an integer.\n            # If s is even, s-1 is odd, so (-1+s)/2 is not an integer.\n            # s_squared = 4n - 3 is always odd, so s must be odd.\n            # We need k > 1, so (-1 + s) / 2 > 1 => s - 1 > 2 => s > 3.\n            if s > 3:\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to a reasonable limit (log2(N_max) approx 60 for k=2)\n    # The upper bound for m is around 59-60 for k=2.\n    # The upper bound for k for m=3 is (10^18)^(1/3) = 10^6.\n    # For m=60, k must be 2.\n    for m in range(3, 61): \n        # Binary search for k\n        # k_low = 2 (k > 1)\n        # k_high = int(n**(1/m)) + 2 is a safe upper bound for k.\n        # For m=3, k_high is ~10^6. For m=60, k_high is ~2.\n        k_low = 2\n        k_high = int(n**(1/m)) + 2 # Add a small buffer for floating point precision and edge cases\n\n        while k_low <= k_high:\n            k_mid = (k_low + k_high) // 2\n            if k_mid < 2: # Ensure k_mid is at least 2\n                k_low = 2\n                continue\n\n            current_sum = 0\n            term = 1 # k^0\n            \n            # Calculate 1 + k + ... + k^m\n            # Check for overflow before multiplication\n            overflow = False\n            for _ in range(m + 1):\n                current_sum += term\n                if current_sum > n: # If sum exceeds n, it's too large\n                    overflow = True\n                    break\n                # Prepare for next term: term * k_mid\n                # Check if term * k_mid would overflow current_sum (i.e., exceed n)\n                # This check is slightly conservative, as current_sum has not yet reached n,\n                # but term * k_mid could make it exceed n.\n                # A better check is if term > n / k_mid (if k_mid is not 0)\n                if _ < m and k_mid > 0 and term > n // k_mid:\n                    overflow = True\n                    break\n                term *= k_mid\n            \n            if overflow:\n                k_high = k_mid - 1 # k_mid is too large\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                k_low = k_mid + 1 # k_mid is too small\n            else: # current_sum > n (this path should be handled by overflow or k_high = k_mid - 1)\n                k_high = k_mid - 1\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Edge cases: n < 7 cannot be a snowflake\n    # Smallest snowflake is 1 + 2 + 2^2 = 7 (for k=2, m=2)\n    # If n is 1, 2, 3, 4, 5, 6, it cannot be a snowflake.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    s_squared = 4 * n - 3\n    if s_squared >= 0:\n        s = int(s_squared**0.5)\n        if s * s == s_squared:\n            # For k to be an integer > 1, s must be odd and s > 3.\n            # If s is odd, s-1 is even, so (-1+s)/2 is an integer.\n            # If s is even, s-1 is odd, so (-1+s)/2 is not an integer.\n            # s_squared = 4n - 3 is always odd, so s must be odd.\n            # We need k > 1, so (-1 + s) / 2 > 1 => s - 1 > 2 => s > 3.\n            if s > 3:\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to a reasonable limit (log2(N_max) approx 60 for k=2)\n    # The upper bound for m is around 59-60 for k=2.\n    # The upper bound for k for m=3 is (10^18)^(1/3) = 10^6.\n    # For m=60, k must be 2.\n    for m in range(3, 61): \n        # Binary search for k\n        # k_low = 2 (k > 1)\n        # k_high = int(n**(1/m)) + 2 is a safe upper bound for k.\n        # For m=3, k_high is ~10^6. For m=60, k_high is ~2.\n        k_low = 2\n        k_high = int(n**(1/m)) + 2 # Add a small buffer for floating point precision and edge cases\n\n        while k_low <= k_high:\n            k_mid = (k_low + k_high) // 2\n            if k_mid < 2: # Ensure k_mid is at least 2\n                k_low = 2\n                continue\n\n            current_sum = 0\n            term = 1 # k^0\n            \n            # Calculate 1 + k + ... + k^m\n            # Check for overflow before multiplication\n            overflow = False\n            for _ in range(m + 1):\n                current_sum += term\n                if current_sum > n: # If sum exceeds n, it's too large\n                    overflow = True\n                    break\n                # Prepare for next term: term * k_mid\n                # Check if term * k_mid would overflow current_sum (i.e., exceed n)\n                # This check is slightly conservative, as current_sum has not yet reached n,\n                # but term * k_mid could make it exceed n.\n                # A better check is if term > n / k_mid (if k_mid is not 0)\n                if _ < m and k_mid > 0 and term > n // k_mid:\n                    overflow = True\n                    break\n                term *= k_mid\n            \n            if overflow:\n                k_high = k_mid - 1 # k_mid is too large\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                k_low = k_mid + 1 # k_mid is too small\n            else: # current_sum > n (this path should be handled by overflow or k_high = k_mid - 1)\n                k_high = k_mid - 1\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 5221,
        "thoughts_token_count": 887
    }
}