{
    "start": 1758011939.6080625,
    "end": 1758012020.289355,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Here's how I'm thinking about the \"Flawed Flow\" problem:**\n\nOkay, so we've got this flow network where we need to figure out which direction each edge should go to satisfy some rules. The key constraints are no cycles, flow conservation at intermediate nodes, the source (vertex 1) having all outgoing edges, and the graph being connected, with a guarantee of a solution. This screams DAG (Directed Acyclic Graph) to me because the \"no cycles\" rule is a strong indicator of a topological ordering that we can try and exploit.\n\nFirst, let's nail down what the inputs and outputs are. We're given the number of vertices and edges, plus the edges themselves. Each edge has a direction (which we have to figure out) and a capacity (the flow amount). The output is simply the directions of each of those edges. \n\nThe main condition is the flow conservation rule. It says that for every vertex except the source and sink, the amount of flow going in must equal the amount going out. Now the source, vertex 1, is special, as there is no incoming flow. So all edges connected to it must be outgoing. \n\nThe sink (vertex *n*) is also special. Even though the flow conservation condition doesn't apply to the sink, it's pretty clear that it will be receiving the *total flow* into the network. Also, standard max flow dictates that all flow ends at the sink.\n\nThe cycle condition is what drives my thinking. A DAG implies a topological ordering, which is a specific ordering of nodes where all edges go from \"earlier\" nodes to \"later\" nodes. If we could find this ordering, determining the flow direction for an edge would be as easy as looking at where it connects. But we don't know this ordering *a priori*. We'll have to *construct* one as we decide flow directions.\n\nWe also have these \"balance\" conditions. I can define this at each node as the net flow leaving the node. The goal is to make all intermediate nodes balanced, i.e., net flow should be zero. The source will have a negative balance (flow leaving), and the sink a positive (flow entering).\n\nSo, the game plan is: Start at the source, direct its edges outward, and then use the remaining edges to balance out the remaining nodes. The queue-based approach seems promising. Each node in the queue represents a node that's essentially \"ready\" to have its flow decided. The \"ready\" nodes are the ones that have only one remaining undirected edge. \n\nSo the strategy is this: for each remaining node (except the sink), if it has more flow incoming than outgoing, the last edge has to be outgoing (v -> neighbor). If it has more outgoing flow than incoming, then the last edge is incoming (neighbor -> v).\n\nNow, the \"cycle-free\" condition means this should be possible.\n```python\n# The actual Python implementation would go here, based on my thought process.\n```\nI'm now implementing the solution and will refine and test to make sure it's correct. I'm focusing on those queue conditions and \"deficit\" calculations to make the flow balance out.\n",
    "response": "The problem asks us to determine the direction of flow for each edge in an undirected graph, given the flow volume for each edge. The goal is to satisfy specific flow conditions and ensure the resulting directed graph is acyclic.\n\nLet's summarize the conditions:\n1.  **Flow Conservation (intermediate vertices):** For any vertex `v` where `1 < v < n`, the total incoming flow must equal the total outgoing flow.\n2.  **Source (vertex 1):** Vertex 1 must have no incoming edges. All edges connected to vertex 1 must be outgoing.\n3.  **No Cycles:** The final directed graph must not contain any cycles.\n\nThe problem guarantees that a solution always exists, the graph is connected, and edge capacities `ci` are at least 1.\n\n**Core Idea:**\nThe \"no cycles\" condition is very strong. It implies that the graph is a Directed Acyclic Graph (DAG), which means there exists a topological ordering of its vertices. Combined with the flow conservation rules, this suggests a greedy approach where we determine edge directions based on the flow balance requirements.\n\nLet's define `net_flow_out[v]` for each vertex `v` as the sum of flow volumes leaving `v` minus the sum of flow volumes entering `v`.\nInitially, `net_flow_out[v] = 0` for all `v`.\nIf an edge `(u, v)` with flow `c` is directed `u -> v`:\n`net_flow_out[u] += c`\n`net_flow_out[v] -= c`\n\nOur goal is:\n*   For `1 < v < n`: `net_flow_out[v] = 0`.\n*   For `v = 1`: `net_flow_out[1]` will be the total maximum flow (positive).\n*   For `v = n`: `net_flow_out[n]` will be the negative of the total maximum flow (negative).\n\n**Algorithm:**\n\n1.  **Initialization:**\n    *   Store all edges along with their original indices.\n    *   Create an adjacency list `adj[v]` for each vertex `v`, storing `(neighbor, flow_capacity, edge_index)`.\n    *   Initialize `ans` array of size `m` with -1 (to mark undirected edges).\n    *   Initialize `net_flow_out[v] = 0` for all `v`.\n    *   Initialize `undirected_edge_count[v]` for all `v` to be the initial degree of `v`.\n    *   Create a queue `q`.\n\n2.  **Handle Source Edges (Vertex 1):**\n    *   According to condition 2, all edges connected to vertex 1 must be directed *out* from 1.\n    *   For each edge `(1, u, c, idx)`:\n        *   Determine the direction: `1 -> u`.\n        *   Update `ans[idx]` (0 if `1` was `a_i`, `u` was `b_i`; 1 otherwise).\n        *   Update `net_flow_out[1] += c`.\n        *   Update `net_flow_out[u] -= c`.\n        *   Decrement `undirected_edge_count[1]` and `undirected_edge_count[u]`.\n        *   If `u` is not the sink (`u != n`) and `undirected_edge_count[u]` becomes 1, add `u` to the queue `q`. (This is because `u` now has only one remaining undirected edge, and its balance might be forced).\n\n3.  **Process Queue (Topological Sort-like):**\n    *   While the queue `q` is not empty:\n        *   Dequeue a vertex `v`.\n        *   If `v` is the sink (`v == n`) or `undirected_edge_count[v]` is 0 (all edges already directed), continue.\n        *   Find the single remaining undirected edge `(v, u)` with flow `c` and index `idx` connected to `v`. (There must be exactly one due to `undirected_edge_count[v] == 1`).\n        *   **Determine direction for `(v, u)`:**\n            *   If `net_flow_out[v] > 0`: Vertex `v` has an excess of outgoing flow (or deficit of incoming flow). To satisfy flow conservation (`net_flow_out[v]` must become 0), `v` needs more incoming flow. Therefore, the edge must be directed `u -> v`.\n                *   Update `ans[idx]` accordingly.\n                *   `net_flow_out[u] += c`.\n                *   `net_flow_out[v] -= c`. (This should make `net_flow_out[v]` equal to 0).\n            *   If `net_flow_out[v] < 0`: Vertex `v` has an excess of incoming flow (or deficit of outgoing flow). To satisfy flow conservation, `v` needs more outgoing flow. Therefore, the edge must be directed `v -> u`.\n                *   Update `ans[idx]` accordingly.\n                *   `net_flow_out[u] -= c`.\n                *   `net_flow_out[v] += c`. (This should make `net_flow_out[v]` equal to 0).\n        *   Decrement `undirected_edge_count[v]` and `undirected_edge_count[u]`.\n        *   If `u` is not the sink (`u != n`) and `undirected_edge_count[u]` becomes 1, add `u` to the queue `q`.\n\nThis process effectively performs a reverse topological sort. By forcing the balance of nodes with only one remaining undirected edge, we gradually determine the directions of all edges. The \"no cycles\" guarantee ensures that this process will always terminate and correctly assign directions. The final `net_flow_out[v]` for `1 < v < n` will be 0.\n\n**Example Walkthrough (First example):**\n`n=3, m=3`\nEdges:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\n`adj`:\n1: [(2, 10, 1), (3, 5, 2)]\n2: [(3, 10, 0), (1, 10, 1)]\n3: [(2, 10, 0), (1, 5, 2)]\n\n`ans = [-1, -1, -1]`\n`net_flow_out = [0, 0, 0, 0]` (for indices 0, 1, 2, 3)\n`undirected_edge_count = [0, 2, 2, 2]`\n`q = deque()`\n\n**Step 2: Handle Source Edges (Vertex 1)**\n1.  Edge `(1, 2, 10, 1)`: `u=1, v=2` (original edge).\n    *   Direct `1 -> 2`. `ans[1] = 0` (since `original_u=1`).\n    *   `net_flow_out[1] += 10` (now 10). `net_flow_out[2] -= 10` (now -10).\n    *   `undirected_edge_count[1] -= 1` (now 1). `undirected_edge_count[2] -= 1` (now 1).\n    *   `2 != n (3)` and `undirected_edge_count[2] == 1`. Add `2` to `q`. `q = [2]`.\n2.  Edge `(3, 1, 5, 2)`: `u=3, v=1` (original edge). We need `1 -> 3`.\n    *   `original_u=3, original_v=1`. Flow `1 -> 3` means `original_v -> original_u`. So `ans[2] = 1`.\n    *   `net_flow_out[1] += 5` (now 15). `net_flow_out[3] -= 5` (now -5).\n    *   `undirected_edge_count[1] -= 1` (now 0). `undirected_edge_count[3] -= 1` (now 1).\n    *   `3 == n (3)`. Do not add `3` to `q`.\n\nAfter Step 2:\n`ans = [-1, 0, 1]`\n`net_flow_out = [0, 15, -10, -5]`\n`undirected_edge_count = [0, 0, 1, 1]`\n`q = [2]`\n\n**Step 3: Process Queue**\n*   Dequeue `v = 2`.\n    *   `v=2` is not `n`. `undirected_edge_count[2] = 1`.\n    *   `net_flow_out[2] = -10`. This is `< 0`, so `2` needs outgoing flow. Direct `2 -> u`.\n    *   Find remaining undirected edge for `v=2`: It's `(3, 10, 0)`. `u=3, flow=10, idx=0`.\n    *   Original edge was `(3, 2, 10)`. We want `2 -> 3`, which is `original_v -> original_u`. So `ans[0] = 1`.\n    *   `net_flow_out[3] -= 10` (now -5 - 10 = -15). This is a mistake in my trace, `net_flow_out[u]` should be updated as `net_flow_out[u] -= c` when `v -> u`.\n        *   Correct: `net_flow_out[3] -= 10` (now -5 - 10 = -15).\n        *   `net_flow_out[2] += 10` (now -10 + 10 = 0).\n    *   `undirected_edge_count[2] -= 1` (now 0). `undirected_edge_count[3] -= 1` (now 0).\n    *   `u=3` is `n`. Do not add `3` to `q`.\n\nAfter processing `v=2`:\n`ans = [1, 0, 1]`\n`net_flow_out = [0, 15, 0, -15]`\n`undirected_edge_count = [0, 0, 0, 0]`\n`q = []`\n\nThe queue is empty. All edges are directed.\nFinal `ans`: `[1, 0, 1]` which matches the example output.\n\nThis approach is correct because the \"no cycles\" condition combined with flow conservation for intermediate nodes allows us to uniquely determine the direction of edges in this manner. When a node `v` (not `1` or `n`) has only one undirected edge remaining, its `net_flow_out[v]` *must* be balanced to zero through that last edge.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges with their original index\n    # edges[i] = (u, v, c, original_idx)\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c, i))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    ans = [-1] * m  # Stores the direction: 0 for u->v, 1 for v->u\n    # net_flow_out[v] = sum(flow_out_of_v) - sum(flow_into_v)\n    # We want net_flow_out[v] = 0 for 1 < v < n\n    net_flow_out = [0] * (n + 1) \n    \n    # undirected_edge_count[v] stores how many edges incident to v are still undirected\n    undirected_edge_count = [len(adj[v]) for v in range(n + 1)]\n\n    q = collections.deque()\n\n    # Step 1: Handle edges from source (vertex 1)\n    # All edges from 1 must be outgoing.\n    # Iterate over a copy of adj[1] because we modify undirected_edge_count\n    for neighbor, flow, idx in list(adj[1]):\n        if ans[idx] != -1: # Edge already processed (shouldn't happen for source edges)\n            continue\n        \n        original_u, original_v, _, _ = edges_input[idx]\n        \n        # Direct 1 -> neighbor\n        if original_u == 1:\n            ans[idx] = 0 # Flow 1 -> neighbor (original_u -> original_v)\n        else: # original_v == 1\n            ans[idx] = 1 # Flow 1 -> neighbor (original_v -> original_u)\n        \n        net_flow_out[1] += flow\n        net_flow_out[neighbor] -= flow\n        \n        undirected_edge_count[1] -= 1\n        undirected_edge_count[neighbor] -= 1\n        \n        # If a neighbor (not the sink) now has only one undirected edge, add it to queue\n        if neighbor != n and undirected_edge_count[neighbor] == 1:\n            q.append(neighbor)\n\n    # Step 2: Process nodes in the queue\n    # Nodes are added to the queue if they are not the sink (n)\n    # and they have exactly one remaining undirected edge.\n    while q:\n        v = q.popleft()\n\n        # If v is the sink, or all its edges are already directed, skip\n        if v == n or undirected_edge_count[v] == 0:\n            continue\n        \n        # Find the single remaining undirected edge for v\n        # Iterate through all incident edges of v to find the one that is still undirected\n        found_edge = False\n        for neighbor, flow, idx in adj[v]:\n            if ans[idx] == -1: # This is the remaining undirected edge\n                original_u, original_v, _, _ = edges_input[idx]\n                \n                if net_flow_out[v] > 0: # v has excess outgoing flow, needs incoming flow\n                    # Direct neighbor -> v\n                    if original_u == v: # Original edge was (v, neighbor). For neighbor->v, it's original_v -> original_u\n                        ans[idx] = 1\n                    else: # Original edge was (neighbor, v). For neighbor->v, it's original_u -> original_v\n                        ans[idx] = 0\n                    \n                    net_flow_out[v] -= flow # Incoming flow reduces net_flow_out\n                    net_flow_out[neighbor] += flow # Outgoing flow increases net_flow_out\n                else: # net_flow_out[v] < 0, v has excess incoming flow, needs outgoing flow\n                    # Direct v -> neighbor\n                    if original_u == v: # Original edge was (v, neighbor). For v->neighbor, it's original_u -> original_v\n                        ans[idx] = 0\n                    else: # Original edge was (neighbor, v). For v->neighbor, it's original_v -> original_u\n                        ans[idx] = 1\n                    \n                    net_flow_out[v] += flow # Outgoing flow reduces net_flow_out (makes it less negative)\n                    net_flow_out[neighbor] -= flow # Incoming flow reduces net_flow_out\n                \n                undirected_edge_count[v] -= 1\n                undirected_edge_count[neighbor] -= 1\n                \n                # If the neighbor (not the sink) now has only one undirected edge, add it to queue\n                if neighbor != n and undirected_edge_count[neighbor] == 1:\n                    q.append(neighbor)\n                \n                found_edge = True\n                break\n        \n        # If found_edge is false, it means v was processed, but its last edge was already handled\n        # by its neighbor, or it was the sink. This should be covered by the initial checks.\n        # Given problem constraints, this should not be an issue.\n\n    # Output the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges with their original index\n    # edges[i] = (u, v, c, original_idx)\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c, i))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    ans = [-1] * m  # Stores the direction: 0 for u->v, 1 for v->u\n    # net_flow_out[v] = sum(flow_out_of_v) - sum(flow_into_v)\n    # We want net_flow_out[v] = 0 for 1 < v < n\n    net_flow_out = [0] * (n + 1) \n    \n    # undirected_edge_count[v] stores how many edges incident to v are still undirected\n    undirected_edge_count = [len(adj[v]) for v in range(n + 1)]\n\n    q = collections.deque()\n\n    # Step 1: Handle edges from source (vertex 1)\n    # All edges from 1 must be outgoing.\n    # Iterate over a copy of adj[1] because we modify undirected_edge_count\n    for neighbor, flow, idx in list(adj[1]):\n        if ans[idx] != -1: # Edge already processed (shouldn't happen for source edges)\n            continue\n        \n        original_u, original_v, _, _ = edges_input[idx]\n        \n        # Direct 1 -> neighbor\n        if original_u == 1:\n            ans[idx] = 0 # Flow 1 -> neighbor (original_u -> original_v)\n        else: # original_v == 1\n            ans[idx] = 1 # Flow 1 -> neighbor (original_v -> original_u)\n        \n        net_flow_out[1] += flow\n        net_flow_out[neighbor] -= flow\n        \n        undirected_edge_count[1] -= 1\n        undirected_edge_count[neighbor] -= 1\n        \n        # If a neighbor (not the sink) now has only one undirected edge, add it to queue\n        if neighbor != n and undirected_edge_count[neighbor] == 1:\n            q.append(neighbor)\n\n    # Step 2: Process nodes in the queue\n    # Nodes are added to the queue if they are not the sink (n)\n    # and they have exactly one remaining undirected edge.\n    while q:\n        v = q.popleft()\n\n        # If v is the sink, or all its edges are already directed, skip\n        if v == n or undirected_edge_count[v] == 0:\n            continue\n        \n        # Find the single remaining undirected edge for v\n        # Iterate through all incident edges of v to find the one that is still undirected\n        found_edge = False\n        for neighbor, flow, idx in adj[v]:\n            if ans[idx] == -1: # This is the remaining undirected edge\n                original_u, original_v, _, _ = edges_input[idx]\n                \n                if net_flow_out[v] > 0: # v has excess outgoing flow, needs incoming flow\n                    # Direct neighbor -> v\n                    if original_u == v: # Original edge was (v, neighbor). For neighbor->v, it's original_v -> original_u\n                        ans[idx] = 1\n                    else: # Original edge was (neighbor, v). For neighbor->v, it's original_u -> original_v\n                        ans[idx] = 0\n                    \n                    net_flow_out[v] -= flow # Incoming flow reduces net_flow_out\n                    net_flow_out[neighbor] += flow # Outgoing flow increases net_flow_out\n                else: # net_flow_out[v] < 0, v has excess incoming flow, needs outgoing flow\n                    # Direct v -> neighbor\n                    if original_u == v: # Original edge was (v, neighbor). For v->neighbor, it's original_u -> original_v\n                        ans[idx] = 0\n                    else: # Original edge was (neighbor, v). For v->neighbor, it's original_v -> original_u\n                        ans[idx] = 1\n                    \n                    net_flow_out[v] += flow # Outgoing flow reduces net_flow_out (makes it less negative)\n                    net_flow_out[neighbor] -= flow # Incoming flow reduces net_flow_out\n                \n                undirected_edge_count[v] -= 1\n                undirected_edge_count[neighbor] -= 1\n                \n                # If the neighbor (not the sink) now has only one undirected edge, add it to queue\n                if neighbor != n and undirected_edge_count[neighbor] == 1:\n                    q.append(neighbor)\n                \n                found_edge = True\n                break\n        \n        # If found_edge is false, it means v was processed, but its last edge was already handled\n        # by its neighbor, or it was the sink. This should be covered by the initial checks.\n        # Given problem constraints, this should not be an issue.\n\n    # Output the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 3877,
        "thoughts_token_count": 6248
    }
}