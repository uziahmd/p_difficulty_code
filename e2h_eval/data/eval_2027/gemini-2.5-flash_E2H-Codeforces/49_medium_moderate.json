{
    "start": 1758294880.9123833,
    "end": 1758294984.6750414,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Okay, let's break down this \"Mushroom Strife\" problem. My understanding is that we're given a graph where the edges represent relationships between the number of mushrooms (represented by integer values between 1 and 10^6) on the lawns (vertices).  The constraints are defined by the GCD and LCM of the mushroom counts on the connected lawns.**\n\nFirst, I need to make sure the problem is even solvable. For each edge, the LCM must be divisible by the GCD.  If not, it's an immediate \"NO\".\n\nThe crucial insight here is the prime factorization. The GCD and LCM are all about the powers of prime numbers.  For any prime *p*, the exponent of *p* in the GCD is the *minimum* of the exponents of *p* in the numbers, while the LCM's exponent is the *maximum*.  This gives us a strong constraint: for any edge (u, v) and prime *p*, either *u* has the same exponent as the GCD or *v* does. The same is true for the LCM.\n\nThis sets up a 2-coloring scenario. For each prime factor, we can essentially build a separate graph where each vertex can have one of two states related to whether the lawn's mushroom count has the GCD or LCM's power of that prime.  If two vertices are connected by an edge, and that prime's power of GCD is equal to the LCM, the two connected vertices are forced to have the *same* \"state\". If the power of the GCD is less than the LCM, then the two connected vertices have to have opposite states. This is looking like a Disjoint-Set Union approach, that will help find the same \"state\" connected components.\n\nMy initial thought was to find the LCM of all GCDs connected to a single vertex and assign a value to it that is multiple of this LCM. However, this is not quite right because each edge and its GCD/LCM combination constraints the value.\n\nSo, I think I need to construct these graphs for each prime.  I'll iterate through primes up to the square root of 10^6, and for each prime, create a graph.  I can then use DSU to resolve the constraints. If there's a conflict (i.e., the DSU forces two vertices to have opposite states but are connected by an edge where this is not possible), then the problem has no solution (\"NO\").\n\nThis DSU approach seems promising. For each prime, the DSU will effectively group vertices that must have the same or opposite exponents. Once I've handled all the primes, I should be able to reconstruct a valid mushroom count for each lawn. If at any stage a conflict occurs, then I can immediately output \"NO\".\n",
    "response": "The problem asks us to assign a number of mushrooms `x_i` (between 1 and 10^6) to each lawn `i` such that for every given road between lawns `u` and `v` with specified GCD `g` and LCM `l`, the conditions `gcd(x_u, x_v) = g` and `lcm(x_u, x_v) = l` are met. We need to find any valid assignment or report that none exists.\n\nThe fundamental property `gcd(a, b) * lcm(a, b) = a * b` implies `x_u * x_v = g * l`.\nAlso, for any prime `p`, let `v_p(N)` denote the exponent of `p` in the prime factorization of `N`.\nThe conditions `gcd(x_u, x_v) = g` and `lcm(x_u, x_v) = l` translate to:\n1. `min(v_p(x_u), v_p(x_v)) = v_p(g)` for all primes `p`.\n2. `max(v_p(x_u), v_p(x_v)) = v_p(l)` for all primes `p`.\n\nFrom these two conditions, it follows that for any prime `p`, the set of exponents `{v_p(x_u), v_p(x_v)}` must be equal to the set `{v_p(g), v_p(l)}`.\nThis is a crucial observation. It also implies that `v_p(g) <= v_p(l)` must hold for all primes `p`. If `v_p(g) > v_p(l)` for any prime `p` and any edge, then no solution exists. Also, `l` must be divisible by `g`. If `l % g != 0`, then `v_p(g) > v_p(l)` for some prime `p` (specifically, primes dividing `g` but not `l/g`), so no solution.\n\nThe problem can be decomposed by prime factors. For each prime `p`, we need to determine `v_p(x_i)` for all lawns `i`. Let `e_{pi} = v_p(x_i)`.\nFor each edge `(u, v)` with `g, l`:\n- If `v_p(g) = v_p(l)`: Then `e_{pu}` and `e_{pv}` must both be equal to `v_p(g)`. This means `u` and `v` must have the same exponent for prime `p`.\n- If `v_p(g) < v_p(l)`: Then one of `e_{pu}, e_{pv}` must be `v_p(g)` and the other `v_p(l)`. This means `u` and `v` must have different exponents for prime `p`.\n\nThis structure suggests a 2-coloring problem for each prime `p`.\nFor each prime `p` that divides any `g` or `l` in the input:\n1. Initialize `final_exp[i] = 0` for all `i`. This represents `v_p(x_i)`.\n2. Use a Disjoint Set Union (DSU) structure to manage relationships between `e_{pi}` values. For each vertex `i`, we store `parent[i]` and `parity[i]`. `parity[i]` is 0 if `e_{pi}` is \"same\" as `e_{p,parent[i]}`, and 1 if \"different\".\n3. For each edge `(u, v)` with `g, l`:\n   Let `vg = v_p(g)` and `vl = v_p(l)`.\n   If `vg > vl` (or `l % g != 0`), output \"NO\" and terminate.\n   If `vg == vl`: `e_{pu}` and `e_{pv}` must be `vg`. This is an equality constraint.\n     We try to `union(u, v, 0)` (meaning `e_{pu}` and `e_{pv}` are same).\n     If `final_exp[u]` is set and `final_exp[u] != vg`, conflict. Output \"NO\".\n     If `final_exp[v]` is set and `final_exp[v] != vg`, conflict. Output \"NO\".\n     Set `final_exp[u] = vg`, `final_exp[v] = vg`.\n   If `vg < vl`: `e_{pu}` and `e_{pv}` must be `vg` and `vl` in some order. This is an inequality constraint.\n     We try to `union(u, v, 1)` (meaning `e_{pu}` and `e_{pv}` are different).\n     If `final_exp[u]` is set and `final_exp[v]` is set:\n       If `(final_exp[u], final_exp[v])` is not `(vg, vl)` and not `(vl, vg)`, conflict. Output \"NO\".\n     If `final_exp[u]` is set, then `final_exp[v]` must be `vg + vl - final_exp[u]`. Check consistency.\n     If `final_exp[v]` is set, then `final_exp[u]` must be `vg + vl - final_exp[v]`. Check consistency.\n     If `final_exp[u]` is not set, we can tentatively set it to `vg`. Then `final_exp[v]` becomes `vl`. This is arbitrary but valid for one component.\n\nThe DSU approach needs to be more robust. Instead of `final_exp` and `parity`, we can track the assigned value of the root of each component, and `parity` relative to the root.\nFor each prime `p`:\n  Initialize `dsu_parent[i] = i`, `dsu_parity[i] = 0` for `i=1..n`.\n  Initialize `dsu_value[i] = -1` (unassigned) for `i=1..n`.\n  For each edge `(u, v)` with `g, l`:\n    `vg = v_p(g)`, `vl = v_p(l)`.\n    If `vg > vl`, output \"NO\", exit.\n    `ru, pu = find(u)`, `rv, pv = find(v)`.\n    If `ru != rv`:\n      `dsu_parent[rv] = ru`.\n      `dsu_parity[rv] = pu ^ pv ^ (0 if vg == vl else 1)`.\n      If `dsu_value[ru] != -1`:\n        `val_rv = dsu_value[ru] ^ dsu_parity[rv]`.\n        If `vg == vl` and `val_rv != vg`, conflict. Output \"NO\".\n        If `vg < vl` and `val_rv not in {vg, vl}`, conflict. Output \"NO`.\n        `dsu_value[rv] = val_rv`.\n      Else if `dsu_value[rv] != -1`:\n        `val_ru = dsu_value[rv] ^ dsu_parity[rv]`.\n        If `vg == vl` and `val_ru != vg`, conflict. Output \"NO\".\n        If `vg < vl` and `val_ru not in {vg, vl}`, conflict. Output \"NO`.\n        `dsu_value[ru] = val_ru`.\n      Else: // Both roots unassigned\n        If `vg == vl`: `dsu_value[ru] = vg`, `dsu_value[rv] = vg`.\n        Else: `dsu_value[ru] = vg`, `dsu_value[rv] = vl`. (Arbitrary choice, will be consistent)\n    Else (`ru == rv`): // Same component\n      `expected_parity = pu ^ pv`.\n      `required_parity = (0 if vg == vl else 1)`.\n      If `expected_parity != required_parity`, conflict. Output \"NO\".\n      If `dsu_value[ru] != -1`:\n        `val_u = dsu_value[ru] ^ pu`.\n        `val_v = dsu_value[ru] ^ pv`.\n        If `vg == vl` and `val_u != vg`, conflict. Output \"NO\".\n        If `vg < vl` and `(val_u, val_v)` is not `(vg, vl)` and not `(vl, vg)`, conflict. Output \"NO\".\n\nThis DSU approach is still complex. Let's try simpler:\nFor each prime `p`:\n  We need to assign `e_{pi}` for each `i`.\n  `ans_exp[p][i]` stores `e_{pi}`. Initialize to -1.\n  `adj[i]` stores pairs `(j, type)` where `type=0` means `e_{pi} == e_{pj}` and `type=1` means `e_{pi} != e_{pj}`.\n  `range_exp[i]` stores `[min_possible_exp, max_possible_exp]` for `e_{pi}`.\n  \n  Precompute `min_g_exp[i][p]` and `max_l_exp[i][p]` for all `i, p`.\n  `min_g_exp[i][p] = max_{j: (i,j) edge} v_p(g_{ij})` (or 0 if no edges).\n  `max_l_exp[i][p] = min_{j: (i,j) edge} v_p(l_{ij})` (or infinity if no edges).\n  If `min_g_exp[i][p] > max_l_exp[i][p]` for any `i, p`, output \"NO\".\n\n  For each prime `p`:\n    `ans_exp[i]` for `i=1..n` (for this `p`). Initialize to -1.\n    `q = collections.deque()`.\n    For each vertex `i`:\n      If `min_g_exp[i][p] == max_l_exp[i][p]`:\n        `ans_exp[i] = min_g_exp[i][p]`. `q.append(i)`.\n    \n    While `q`:\n      `u = q.popleft()`.\n      For each edge `(u, v)` with `g, l`:\n        `vg = v_p(g)`, `vl = v_p(l)`.\n        If `vg > vl`, impossible.\n        If `ans_exp[u]` is determined:\n          If `vg == vl`:\n            If `ans_exp[u] != vg`, conflict. Output \"NO\".\n            If `ans_exp[v] == -1`: `ans_exp[v] = vg`, `q.append(v)`.\n            Else if `ans_exp[v] != vg`, conflict. Output \"NO\".\n          Else (`vg < vl`):\n            `target_v_exp = vg + vl - ans_exp[u]`.\n            If `target_v_exp not in {vg, vl}`, conflict. Output \"NO\".\n            If `ans_exp[v] == -1`: `ans_exp[v] = target_v_exp`, `q.append(v)`.\n            Else if `ans_exp[v] != target_v_exp`, conflict. Output \"NO\".\n    \n    // After BFS, some nodes might still be -1 (undetermined).\n    // These belong to components where all edges are `vg < vl` and no node had fixed `min_g_exp == max_l_exp`.\n    // We can arbitrarily pick one node `u` in such a component, set `ans_exp[u] = min_g_exp[u][p]`, and propagate.\n    For `i=1..n`:\n      If `ans_exp[i] == -1`:\n        `ans_exp[i] = min_g_exp[i][p]`.\n        `q.append(i)`.\n        // Run another BFS from `i` to propagate this choice.\n        `visited = {i}`\n        `q_comp = collections.deque([i])`\n        While `q_comp`:\n          `u = q_comp.popleft()`\n          For each edge `(u, v)` with `g, l`: // Need to store edges in adj list\n            `vg = v_p(g)`, `vl = v_p(l)`.\n            If `vg == vl`:\n              If `ans_exp[u] != vg`, conflict. Output \"NO\".\n              If `ans_exp[v] == -1`: `ans_exp[v] = vg`, `q_comp.append(v)`, `visited.add(v)`.\n              Else if `ans_exp[v] != vg`, conflict. Output \"NO\".\n            Else (`vg < vl`):\n              `target_v_exp = vg + vl - ans_exp[u]`.\n              If `target_v_exp not in {vg, vl}`, conflict. Output \"NO\".\n              If `ans_exp[v] == -1`: `ans_exp[v] = target_v_exp`, `q_comp.append(v)`, `visited.add(v)`.\n              Else if `ans_exp[v] != target_v_exp`, conflict. Output \"NO\".\n        \n    // Final check for `ans_exp[i]` against `min_g_exp[i][p]` and `max_l_exp[i][p]`\n    For `i=1..n`:\n      If `ans_exp[i] == -1`: `ans_exp[i] = 0` (for isolated nodes)\n      If `ans_exp[i] < min_g_exp[i][p]` or `ans_exp[i] > max_l_exp[i][p]`, output \"NO\".\n\nThis BFS-based propagation for each prime `p` seems correct.\n\n**Algorithm Steps:**\n\n1.  **Sieve:** Precompute primes up to `10^6` and smallest prime factor (`spf`) for numbers up to `10^6`. This allows efficient prime factorization.\n2.  **`v_p(N)` function:** Implement `get_prime_exponent(n, p)` using `spf`.\n3.  **Precompute `min_g_exp`, `max_l_exp`:**\n    Initialize `min_g_exp[i][p] = 0` and `max_l_exp[i][p] = infinity` for all `i, p`.\n    Store all edges in an adjacency list `adj[u]` to easily iterate neighbors.\n    For each edge `(u, v, g, l)`:\n        If `l % g != 0`, print \"NO\", exit.\n        Find all unique prime factors `p` of `g` and `l`.\n        For each such `p`:\n            `vg = get_prime_exponent(g, p)`\n            `vl = get_prime_exponent(l, p)`\n            If `vg > vl`, print \"NO\", exit.\n            `min_g_exp[u][p] = max(min_g_exp[u][p], vg)`\n            `min_g_exp[v][p] = max(min_g_exp[v][p], vg)`\n            `max_l_exp[u][p] = min(max_l_exp[u][p], vl)`\n            `max_l_exp[v][p] = min(max_l_exp[v][p], vl)`\n        Also, collect all unique primes encountered into a set `all_primes`.\n4.  **Main loop for each prime:**\n    For each prime `p` in `all_primes`:\n        `current_exp[i]` for `i=1..n`. Initialize to -1.\n        `q = collections.deque()`\n        For `i=1..n`:\n            If `min_g_exp[i][p] > max_l_exp[i][p]`, print \"NO\", exit.\n            If `min_g_exp[i][p] == max_l_exp[i][p]`:\n                `current_exp[i] = min_g_exp[i][p]`. `q.append(i)`.\n        \n        While `q`:\n            `u = q.popleft()`\n            For each edge `(u, v, g, l)` (from `adj[u]`):\n                `vg = get_prime_exponent(g, p)`\n                `vl = get_prime_exponent(l, p)`\n                \n                `target_v_exp = -1`\n                If `vg == vl`:\n                    `target_v_exp = vg`\n                    If `current_exp[u] != vg`, print \"NO\", exit.\n                Else (`vg < vl`):\n                    `target_v_exp = vg + vl - current_exp[u]`\n                    If `target_v_exp not in {vg, vl}`, print \"NO\", exit.\n                \n                If `current_exp[v] == -1`:\n                    `current_exp[v] = target_v_exp`\n                    `q.append(v)`\n                Else if `current_exp[v] != target_v_exp`:\n                    print \"NO\", exit.\n        \n        // Handle remaining unassigned components\n        For `i=1..n`:\n            If `current_exp[i] == -1`:\n                `current_exp[i] = min_g_exp[i][p]` // Arbitrary choice, consistent with min_g_exp\n                `q.append(i)`\n                \n                // Propagate this choice within its component\n                `visited_comp = {i}`\n                `q_comp = collections.deque([i])`\n                While `q_comp`:\n                    `u = q_comp.popleft()`\n                    For each edge `(u, v, g, l)` (from `adj[u]`):\n                        If `v in visited_comp`: continue\n                        `vg = get_prime_exponent(g, p)`\n                        `vl = get_prime_exponent(l, p)`\n                        \n                        `target_v_exp = -1`\n                        If `vg == vl`:\n                            `target_v_exp = vg`\n                            If `current_exp[u] != vg`, print \"NO\", exit.\n                        Else (`vg < vl`):\n                            `target_v_exp = vg + vl - current_exp[u]`\n                            If `target_v_exp not in {vg, vl}`, print \"NO\", exit.\n                        \n                        If `current_exp[v] == -1`:\n                            `current_exp[v] = target_v_exp`\n                            `q_comp.append(v)`\n                            `visited_comp.add(v)`\n                        Else if `current_exp[v] != target_v_exp`:\n                            print \"NO\", exit.\n        \n        // Final check for consistency and store results\n        For `i=1..n`:\n            If `current_exp[i] == -1`: `current_exp[i] = 0` (for truly isolated nodes with no prime factors)\n            If `current_exp[i] < min_g_exp[i][p]` or `current_exp[i] > max_l_exp[i][p]`, print \"NO\", exit.\n            `final_ans_exponents[i][p] = current_exp[i]`\n            \n5.  **Construct final `x_i` values:**\n    Initialize `ans_x[i] = 1` for all `i`.\n    For `i=1..n`:\n        For each prime `p` in `all_primes`:\n            `ans_x[i] *= (p ** final_ans_exponents[i][p])`\n        If `ans_x[i] > 10^6`, print \"NO\", exit. (This check is crucial as `x_i` must be <= 10^6).\n    \n6.  **Output:** Print \"YES\" and then `ans_x` values.\n\n**Complexity:**\n- Sieve: `O(MAX_VAL * log log MAX_VAL)` where `MAX_VAL = 10^6`.\n- `get_prime_exponent`: `O(log N)` for prime factorization using `spf`.\n- Precomputing `min_g_exp`, `max_l_exp`: `M` edges. Each edge involves prime factorizing `g, l`. Max `log(10^6)` prime factors. Total `O(M * log MAX_VAL * log MAX_VAL)`. This is too slow if `log MAX_VAL` is large.\n  A number up to `10^6` has at most `~10` distinct prime factors. So `O(M * 10 * log MAX_VAL)` for `v_p` computation.\n  The `min_g_exp` and `max_l_exp` arrays can be sparse. Use dictionaries/hash maps to store exponents for each `(vertex, prime)`.\n- Main loop for each prime:\n    Number of unique primes up to `10^6` is `~78k`. However, we only care about primes that are factors of `g` or `l`. The total number of distinct prime factors across all `g, l` values is much smaller, at most `M * 2 * log(MAX_VAL)` (number of prime factors).\n    For each prime `p`, the BFS takes `O(N + M)`. So total `O(Num_Primes * (N+M))`. This is too slow if `Num_Primes` is large.\n\n**Optimization for `min_g_exp`, `max_l_exp` and prime loop:**\nInstead of iterating all primes, iterate through edges.\nFor each edge `(u, v, g, l)`:\n  Factorize `g` and `l`. For each prime factor `p`:\n    `vg = v_p(g)`, `vl = v_p(l)`.\n    Store `(u, v, vg, vl)` in a list associated with `p`. `prime_constraints[p]`.\n    `min_g_exp[u][p] = max(min_g_exp[u][p], vg)`\n    `min_g_exp[v][p] = max(min_g_exp[v][p], vg)`\n    `max_l_exp[u][p] = min(max_l_exp[u][p], vl)`\n    `max_l_exp[v][p] = min(max_l_exp[v][p], vl)`\n    (Use `defaultdict(lambda: defaultdict(int))` for `min_g_exp`, etc.)\n\nNow, iterate `p` over `prime_constraints.keys()`. This `Num_Primes` is at most `M * log(MAX_VAL)`.\nFor each `p`, the BFS will visit only nodes that have constraints for `p`.\nThe total number of `(vertex, prime)` pairs with non-zero exponent is `N * Num_Primes_overall_max` (too much), or `M * log(MAX_VAL)` (more reasonable).\nThe BFS part: Each edge `(u,v)` is processed for each prime `p` that divides `g` or `l`. Each `(u,p)` pair is added to queue at most once. Total complexity for BFS steps across all primes is `O(sum_{p} (N_p + M_p))` where `N_p` is number of vertices affected by prime `p` and `M_p` is number of edges affected by prime `p`. This sum is `O(N * log MAX_VAL + M * log MAX_VAL)`.\n\nThe `min_g_exp` and `max_l_exp` should be stored as dictionaries `defaultdict(lambda: defaultdict(int))` and `defaultdict(lambda: defaultdict(lambda: float('inf')))`.\n`final_ans_exponents` as `defaultdict(lambda: defaultdict(int))`.\n`current_exp` for each prime `p` can be a temporary array `[-1] * (N+1)`.\n\nThe total time complexity will be roughly `O(MAX_VAL * log log MAX_VAL + M * log MAX_VAL + (N+M) * log MAX_VAL)`. Given `N, M <= 10^5`, `MAX_VAL = 10^6`, `log MAX_VAL approx 20`. This should be efficient enough.\n\n```python\nimport sys\nimport collections\nimport math\n\n# Constants\nMAX_VAL = 10**6\nINF = float('inf')\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime exponent (v_p(N))\ndef get_prime_exponent(n, p):\n    count = 0\n    if p == 0: return 0 # Should not happen with valid primes\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Function to get prime factors and their exponents\ndef get_prime_factorization(n):\n    factors = collections.defaultdict(int)\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        factors[p] += 1\n        temp_n //= p\n    return factors\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = collections.defaultdict(list)\n    \n    # Store min_g_exp and max_l_exp for each (vertex, prime) pair\n    # Use defaultdict for sparse storage\n    min_g_exp = collections.defaultdict(lambda: collections.defaultdict(int))\n    max_l_exp = collections.defaultdict(lambda: collections.defaultdict(lambda: INF))\n    \n    # Store constraints per prime\n    prime_constraints = collections.defaultdict(list)\n    \n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l)) # Graph is undirected\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n\n        # Collect all unique primes involved in this edge\n        all_edge_primes = set(g_factors.keys()).union(set(l_factors.keys()))\n\n        for p in all_edge_primes:\n            vg = g_factors[p] # get_prime_exponent(g, p)\n            vl = l_factors[p] # get_prime_exponent(l, p)\n\n            if vg > vl: # Should already be caught by l%g != 0, but good to double check\n                print(\"NO\")\n                return\n            \n            # Store constraints for this prime\n            prime_constraints[p].append((u, v, vg, vl))\n\n            # Update overall min_g_exp and max_l_exp for u and v\n            min_g_exp[u][p] = max(min_g_exp[u][p], vg)\n            min_g_exp[v][p] = max(min_g_exp[v][p], vg)\n            max_l_exp[u][p] = min(max_l_exp[u][p], vl)\n            max_l_exp[v][p] = min(max_l_exp[v][p], vl)\n            \n    # final_ans_exponents[i][p] will store the exponent of p for lawn i\n    final_ans_exponents = collections.defaultdict(lambda: collections.defaultdict(int))\n\n    # Process each prime independently\n    for p in prime_constraints:\n        current_exp = [-1] * (n + 1) # -1 means unassigned\n        q = collections.deque()\n\n        # Initialize queue with nodes whose exponents are fixed by min_g_exp == max_l_exp\n        for i in range(1, n + 1):\n            if min_g_exp[i][p] > max_l_exp[i][p]:\n                print(\"NO\")\n                return\n            if min_g_exp[i][p] == max_l_exp[i][p] and min_g_exp[i][p] != INF: # INF check for isolated nodes\n                current_exp[i] = min_g_exp[i][p]\n                q.append(i)\n        \n        # BFS to propagate fixed exponents\n        while q:\n            u = q.popleft()\n            \n            # Iterate through all edges involving u\n            for v_neighbor, g_edge, l_edge in adj[u]:\n                vg = get_prime_exponent(g_edge, p)\n                vl = get_prime_exponent(l_edge, p)\n\n                # Determine the required exponent for v_neighbor\n                target_v_exp = -1\n                if vg == vl:\n                    # Both u and v must have vg\n                    if current_exp[u] != vg:\n                        print(\"NO\")\n                        return\n                    target_v_exp = vg\n                else: # vg < vl\n                    # One of u, v is vg, the other is vl\n                    target_v_exp = vg + vl - current_exp[u]\n                    if target_v_exp not in {vg, vl}: # Should not happen if current_exp[u] is vg or vl\n                        print(\"NO\")\n                        return\n                \n                # Apply or check target_v_exp for v_neighbor\n                if current_exp[v_neighbor] == -1:\n                    current_exp[v_neighbor] = target_v_exp\n                    q.append(v_neighbor)\n                elif current_exp[v_neighbor] != target_v_exp:\n                    print(\"NO\")\n                    return\n        \n        # Handle remaining unassigned components\n        # For each unassigned node, make an arbitrary choice (min_g_exp[i][p]) and propagate\n        for i in range(1, n + 1):\n            if current_exp[i] == -1:\n                # If node i has no edges involving prime p, its exponent is 0\n                if not min_g_exp[i][p] and max_l_exp[i][p] == INF:\n                    current_exp[i] = 0\n                    continue\n\n                # Otherwise, it's part of an unassigned component.\n                # Arbitrarily pick min_g_exp[i][p] and propagate.\n                current_exp[i] = min_g_exp[i][p]\n                q_comp = collections.deque([i])\n                visited_comp = {i}\n\n                while q_comp:\n                    u = q_comp.popleft()\n                    \n                    for v_neighbor, g_edge, l_edge in adj[u]:\n                        if v_neighbor in visited_comp:\n                            continue\n\n                        vg = get_prime_exponent(g_edge, p)\n                        vl = get_prime_exponent(l_edge, p)\n\n                        target_v_exp = -1\n                        if vg == vl:\n                            if current_exp[u] != vg:\n                                print(\"NO\")\n                                return\n                            target_v_exp = vg\n                        else: # vg < vl\n                            target_v_exp = vg + vl - current_exp[u]\n                            if target_v_exp not in {vg, vl}:\n                                print(\"NO\")\n                                return\n                        \n                        if current_exp[v_neighbor] == -1:\n                            current_exp[v_neighbor] = target_v_exp\n                            q_comp.append(v_neighbor)\n                            visited_comp.add(v_neighbor)\n                        elif current_exp[v_neighbor] != target_v_exp:\n                            print(\"NO\")\n                            return\n\n        # Final consistency check for current_exp against min_g_exp and max_l_exp\n        for i in range(1, n + 1):\n            if current_exp[i] == -1: # Should not happen after second BFS, but for safety\n                current_exp[i] = 0 # Isolated node\n            if current_exp[i] < min_g_exp[i][p] or current_exp[i] > max_l_exp[i][p]:\n                print(\"NO\")\n                return\n            final_ans_exponents[i][p] = current_exp[i]\n\n    # Construct final x_i values\n    ans_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p, exp in final_ans_exponents[i].items():\n            ans_x[i] *= (p ** exp)\n        \n        # Check if x_i is within bounds\n        if ans_x[i] > MAX_VAL:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans_x[1:]))\n\nsieve()\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\nimport math\n\n# Constants\nMAX_VAL = 10**6\nINF = float('inf')\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime exponent (v_p(N))\ndef get_prime_exponent(n, p):\n    count = 0\n    if p == 0: return 0 # Should not happen with valid primes\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Function to get prime factors and their exponents\ndef get_prime_factorization(n):\n    factors = collections.defaultdict(int)\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        factors[p] += 1\n        temp_n //= p\n    return factors\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = collections.defaultdict(list)\n    \n    # Store min_g_exp and max_l_exp for each (vertex, prime) pair\n    # Use defaultdict for sparse storage\n    min_g_exp = collections.defaultdict(lambda: collections.defaultdict(int))\n    max_l_exp = collections.defaultdict(lambda: collections.defaultdict(lambda: INF))\n    \n    # Store constraints per prime\n    prime_constraints = collections.defaultdict(list)\n    \n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l)) # Graph is undirected\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n\n        # Collect all unique primes involved in this edge\n        all_edge_primes = set(g_factors.keys()).union(set(l_factors.keys()))\n\n        for p in all_edge_primes:\n            vg = g_factors[p] # get_prime_exponent(g, p)\n            vl = l_factors[p] # get_prime_exponent(l, p)\n\n            if vg > vl: # Should already be caught by l%g != 0, but good to double check\n                print(\"NO\")\n                return\n            \n            # Store constraints for this prime\n            prime_constraints[p].append((u, v, vg, vl))\n\n            # Update overall min_g_exp and max_l_exp for u and v\n            min_g_exp[u][p] = max(min_g_exp[u][p], vg)\n            min_g_exp[v][p] = max(min_g_exp[v][p], vg)\n            max_l_exp[u][p] = min(max_l_exp[u][p], vl)\n            max_l_exp[v][p] = min(max_l_exp[v][p], vl)\n            \n    # final_ans_exponents[i][p] will store the exponent of p for lawn i\n    final_ans_exponents = collections.defaultdict(lambda: collections.defaultdict(int))\n\n    # Process each prime independently\n    for p in prime_constraints:\n        current_exp = [-1] * (n + 1) # -1 means unassigned\n        q = collections.deque()\n\n        # Initialize queue with nodes whose exponents are fixed by min_g_exp == max_l_exp\n        for i in range(1, n + 1):\n            if min_g_exp[i][p] > max_l_exp[i][p]:\n                print(\"NO\")\n                return\n            if min_g_exp[i][p] == max_l_exp[i][p] and min_g_exp[i][p] != INF: # INF check for isolated nodes\n                current_exp[i] = min_g_exp[i][p]\n                q.append(i)\n        \n        # BFS to propagate fixed exponents\n        while q:\n            u = q.popleft()\n            \n            # Iterate through all edges involving u\n            for v_neighbor, g_edge, l_edge in adj[u]:\n                vg = get_prime_exponent(g_edge, p)\n                vl = get_prime_exponent(l_edge, p)\n\n                # Determine the required exponent for v_neighbor\n                target_v_exp = -1\n                if vg == vl:\n                    # Both u and v must have vg\n                    if current_exp[u] != vg:\n                        print(\"NO\")\n                        return\n                    target_v_exp = vg\n                else: # vg < vl\n                    # One of u, v is vg, the other is vl\n                    target_v_exp = vg + vl - current_exp[u]\n                    if target_v_exp not in {vg, vl}: # Should not happen if current_exp[u] is vg or vl\n                        print(\"NO\")\n                        return\n                \n                # Apply or check target_v_exp for v_neighbor\n                if current_exp[v_neighbor] == -1:\n                    current_exp[v_neighbor] = target_v_exp\n                    q.append(v_neighbor)\n                elif current_exp[v_neighbor] != target_v_exp:\n                    print(\"NO\")\n                    return\n        \n        # Handle remaining unassigned components\n        # For each unassigned node, make an arbitrary choice (min_g_exp[i][p]) and propagate\n        for i in range(1, n + 1):\n            if current_exp[i] == -1:\n                # If node i has no edges involving prime p, its exponent is 0\n                if not min_g_exp[i][p] and max_l_exp[i][p] == INF:\n                    current_exp[i] = 0\n                    continue\n\n                # Otherwise, it's part of an unassigned component.\n                # Arbitrarily pick min_g_exp[i][p] and propagate.\n                current_exp[i] = min_g_exp[i][p]\n                q_comp = collections.deque([i])\n                visited_comp = {i}\n\n                while q_comp:\n                    u = q_comp.popleft()\n                    \n                    for v_neighbor, g_edge, l_edge in adj[u]:\n                        if v_neighbor in visited_comp:\n                            continue\n\n                        vg = get_prime_exponent(g_edge, p)\n                        vl = get_prime_exponent(l_edge, p)\n\n                        target_v_exp = -1\n                        if vg == vl:\n                            if current_exp[u] != vg:\n                                print(\"NO\")\n                                return\n                            target_v_exp = vg\n                        else: # vg < vl\n                            target_v_exp = vg + vl - current_exp[u]\n                            if target_v_exp not in {vg, vl}:\n                                print(\"NO\")\n                                return\n                        \n                        if current_exp[v_neighbor] == -1:\n                            current_exp[v_neighbor] = target_v_exp\n                            q_comp.append(v_neighbor)\n                            visited_comp.add(v_neighbor)\n                        elif current_exp[v_neighbor] != target_v_exp:\n                            print(\"NO\")\n                            return\n\n        # Final consistency check for current_exp against min_g_exp and max_l_exp\n        for i in range(1, n + 1):\n            if current_exp[i] == -1: # Should not happen after second BFS, but for safety\n                current_exp[i] = 0 # Isolated node\n            if current_exp[i] < min_g_exp[i][p] or current_exp[i] > max_l_exp[i][p]:\n                print(\"NO\")\n                return\n            final_ans_exponents[i][p] = current_exp[i]\n\n    # Construct final x_i values\n    ans_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p, exp in final_ans_exponents[i].items():\n            ans_x[i] *= (p ** exp)\n        \n        # Check if x_i is within bounds\n        if ans_x[i] > MAX_VAL:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans_x[1:]))\n\nsieve()\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 7818,
        "thoughts_token_count": 7768
    }
}