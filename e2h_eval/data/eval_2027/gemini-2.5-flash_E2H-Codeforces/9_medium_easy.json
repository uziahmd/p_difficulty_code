{
    "start": 1758015865.1264548,
    "end": 1758015974.345286,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Knapsack with a Twist: My Optimized Solution**\n\nOkay, so I've got this \"Selling Souvenirs\" problem, which boils down to a variation of the classic knapsack problem. We're given souvenirs with weights and costs, and a weight limit `m`. The goal is to maximize the total cost of the selected souvenirs without exceeding `m`. The catch?  The weights can only be 1, 2, or 3.\n\nInitially, I was thinking dynamic programming with `dp[i][w]`, which seemed like the most obvious approach. But with `n=100000` and `m=300000`, that blows up to `O(n*m)`, a no-go zone.\n\nThe weight constraint (1, 2, or 3) is the key.  I realized I could sort the souvenirs by weight and store them in separate lists (`items_w1`, `items_w2`, `items_w3`), sorted in descending order of cost (highest cost first). This is crucial for maximizing the overall profit.\n\nNow, I was initially considering a DP approach where I'd iterate through different combinations of `k1` (weight 1 items), `k2` (weight 2 items), and `k3` (weight 3 items). The constraint is `k1 + 2*k2 + 3*k3 <= m`.  But that still seemed to be `O(m^3)`, maybe slightly better, but too slow.  Then I had the idea to use the weight 3 as the outer loop. Fix `k3`, and solve the remaining problem using weight 1 and 2.\n\nThe core of the problem then becomes finding the *best* combination of weight 1 and 2 souvenirs for a remaining capacity.  I was going to use prefix sums to keep track of the total costs and try all possible combinations of weight 1 and 2 items, for each value of `k2` (number of weight 2 items). This approach was close to `O(m^2)`.\n\nBut then, it hit me: The problem of combining weight 1 and 2 items is *special*. Let `max_cost_12[W]` be the maximum cost using weight 1 and 2 items with weight at most W. For a fixed weight capacity `W`, the optimal number of weight 2 items, `k2`, gives the best solution using ternary search! This should be `O(log W)` since the function is concave. So `max_cost_12[w]` can be computed in O(log(300000)) = O(18). I could compute all the values of `max_cost_12` for weight capacity `0` to `m` in O(m * log(m)). This precomputation will cost me O(m * log(m)).\n\nThe overall algorithm:\n1. Sort the lists.\n2. Precompute the prefix sums.\n3. Compute `max_cost_12[w]` for all `w`. This will take `O(m log m)`\n4. For each k3, find weight 1 and 2 combinations: O(m/3 * O(log(m))).\nThe ternary search would allow me to precompute `max_cost_12[w]` in O(m log m) time.  This seemed like the most efficient approach, and I think it would be good to optimize `max_cost_12` table.\n\nSo, here's my plan: the total cost for O(m log m) and I will have my solution!",
    "response": "The problem asks us to select a subset of souvenirs to maximize total cost, given a total weight capacity `m`. Souvenirs have weights `w_i` and costs `c_i`, with the crucial constraint that `w_i` can only be 1, 2, or 3. The number of souvenirs `n` can be up to 100,000 and capacity `m` up to 300,000.\n\nA standard 0/1 knapsack dynamic programming approach would be `O(n*m)`, which is too slow for these constraints (`10^5 * 3*10^5 = 3*10^{10}`). However, the small range of weights allows for a more efficient solution.\n\n**1. Categorize and Sort Souvenirs:**\nFirst, separate the souvenirs into three lists based on their weights: `items_w1`, `items_w2`, and `items_w3`. To maximize cost, we should always pick the most expensive items first from each category. So, sort these lists in descending order of cost.\n\n**2. Precompute Prefix Sums:**\nAfter sorting, compute prefix sums for each list. `pref_w1[k]` will store the sum of costs of the `k` most expensive souvenirs of weight 1. Similarly for `pref_w2` and `pref_w3`. These prefix sums allow us to quickly calculate the cost of taking `k` items of a certain weight. This step takes `O(N)` time after sorting.\n\n**3. Iterate on Weight 3 Items:**\nThe maximum number of items of weight 3 we can take is `m/3`. Since `m` is up to 300,000, `m/3` is up to 100,000. We can iterate through all possible counts `k3` of weight 3 items we might take, from `0` up to `min(len(items_w3), m // 3)`.\nFor each `k3`:\n   - Calculate the cost from these `k3` items: `current_cost_w3 = pref_w3[k3]`.\n   - Calculate the weight used by these `k3` items: `weight_used_w3 = k3 * 3`.\n   - Determine the remaining capacity: `rem_m = m - weight_used_w3`.\n   - Now, the subproblem is to fill `rem_m` capacity using only weight 1 and weight 2 items, maximizing their cost.\n\n**4. Efficiently Solve the Weight 1 and 2 Subproblem:**\nFor a given `rem_m`, we need to find `k1` (number of weight 1 items) and `k2` (number of weight 2 items) such that `k1*1 + k2*2 <= rem_m` and `pref_w1[k1] + pref_w2[k2]` is maximized.\nSince `pref_w1` and `pref_w2` are sums of non-increasing values (due to sorting), they are concave functions. The sum of a concave function and another concave function (after appropriate transformations for `k1 + 2*k2 <= rem_m`) is also concave. This allows us to use ternary search to find the optimal `k2` for a fixed `rem_m` in `O(log(rem_m))` time.\n\nHowever, we need to solve this subproblem for many different `rem_m` values (up to `m` times). An `O(m log m)` precomputation for all `rem_m` would be:\n`max_cost_12[w]` = maximum cost using weight 1 and 2 items for capacity `w`.\nInitialize `max_cost_12 = [0] * (m + 1)`.\nFor `w` from `0` to `m`:\n  `max_val_for_w = 0`\n  `low_k2 = 0`\n  `high_k2 = min(len(items_w2), w // 2)`\n  If `high_k2 < low_k2`:\n    `max_val_for_w = pref_w1[min(len(items_w1), w)]`\n  Else:\n    // Ternary search for k2 in range [low_k2, high_k2]\n    // The function to maximize is G(k2) = pref_w1[min(len(items_w1), w - 2*k2)] + pref_w2[k2]\n    // This part is `O(log m)` per `w`. Total `O(m log m)`.\n\nA more efficient way to compute `max_cost_12` for all `w` in `O(m)` time is a specialized DP for small weights:\n`max_cost_12 = [0] * (m + 1)`\n`ptr_w1 = 0` (pointer to the next best weight 1 item to consider)\n`ptr_w2 = 0` (pointer to the next best weight 2 item to consider)\nFor `w` from `1` to `m`:\n  `max_cost_12[w] = max_cost_12[w-1]` (default: don't add any new item for this `w`, just carry over from `w-1`)\n\n  // Option 1: Add a weight 1 item\n  // If we can add a weight 1 item (if `w-1 >= 0` and `ptr_w1 < len(items_w1)`),\n  // the cost would be `max_cost_12[w-1] + items_w1[ptr_w1]`.\n  // This logic is flawed. We need to consider adding a new best item.\n  // The correct DP for this type of problem (unbounded knapsack with specific items):\n  // `dp[w]` = max cost for weight `w`.\n  // `dp[w] = dp[w-1] + items_w1[k1]` is not necessarily true because `items_w1[k1]` is not a \"new\" item.\n  // It's simpler to iterate `k2` and for each `k2`, calculate the best `k1`.\n\nLet's use the `O(m)` approach for `max_cost_12` that's common for small weights.\nWe can compute `max_cost_12[w]` values iteratively.\n`max_cost_12 = [0] * (m + 1)`\n`current_cost_w1 = 0`\n`k1_count = 0`\n`k2_count = 0`\n`max_k2 = len(items_w2)`\n\nFor `w` from `0` to `m`:\n  // Option 1: Only use weight 1 items up to capacity `w`.\n  // This is `pref_w1[min(len(items_w1), w)]`.\n  // We need to find the best combination of weight 1 and weight 2 items.\n  // The `max_cost_12[w]` is the best value for exactly weight `w`.\n  // It can be formed by:\n  // 1. `max_cost_12[w-1]` + `items_w1[k]` for some `k`.\n  // 2. `max_cost_12[w-2]` + `items_w2[k]` for some `k`.\n\nThis is a variation of the \"coin change\" problem or unbounded knapsack.\n`dp[w]` = max value for weight `w`.\n`dp[w] = max(dp[w-1] + items_w1[idx_w1], dp[w-2] + items_w2[idx_w2])`\nThis is tricky because `idx_w1` and `idx_w2` need to be managed.\n\nA simple `O(m)` approach for `max_cost_12[w]` for `w` from `0` to `m`:\nInitialize `max_cost_12 = [0] * (m + 1)`.\n`j = len(items_w2) - 1` (index for `items_w2`, starting from most expensive)\n`current_sum_w2 = 0`\nFor `i` from `0` to `m`: // `i` represents the capacity `w`\n  `current_sum_w1 = pref_w1[min(len(items_w1), i)]`\n  `max_cost_12[i] = current_sum_w1` // Base case: only use weight 1 items\n\n  // Now try to replace some weight 1 items with weight 2 items.\n  // Iterate `k2` (number of weight 2 items) from 1 up to `min(len(items_w2), i // 2)`.\n  // For each `k2`, calculate `cost_w2 = pref_w2[k2]`.\n  // Remaining capacity for weight 1 items: `i - k2 * 2`.\n  // Cost from weight 1 items: `pref_w1[min(len(items_w1), i - k2 * 2)]`.\n  // Total cost for this `k2`: `cost_w2 + pref_w1[min(len(items_w1), i - k2 * 2)]`.\n  // This is the `O(m^2)` part.\n\nThe `O(m log m)` approach using ternary search for each `w` for `max_cost_12`:\n`max_cost_12 = [0] * (m + 1)`\n`func_G = lambda k2, W: pref_w1[min(len(items_w1), W - 2 * k2)] + pref_w2[k2]`\nFor `w` from `0` to `m`:\n  `low_k2 = 0`\n  `high_k2 = min(len(items_w2), w // 2)`\n  `current_max_val = 0`\n  if high_k2 < low_k2:\n    current_max_val = pref_w1[min(len(items_w1), w)]\n  else:\n    while high_k2 - low_k2 >= 3:\n      `mid1 = low_k2 + (high_k2 - low_k2) // 3`\n      `mid2 = high_k2 - (high_k2 - low_k2) // 3`\n      if func_G(mid1, w) < func_G(mid2, w):\n        `low_k2 = mid1`\n      else:\n        `high_k2 = mid2`\n    // After ternary search, check remaining few values\n    for k2 in range(low_k2, high_k2 + 1):\n      current_max_val = max(current_max_val, func_G(k2, w))\n  `max_cost_12[w] = current_max_val`\n\nThis `O(m log m)` precomputation for `max_cost_12` is feasible.\nTotal time complexity: `O(N log N)` for sorting (if `N` dominates `M`), or `O(N)` if `N` is sum of lengths of lists, `O(M log M)` for `max_cost_12` table, and `O(M)` for the final loop. Overall `O(N log N + M log M)`.\n\nLet's check the constraints: `N=10^5`, `M=3*10^5`.\n`N log N` is `10^5 * log(10^5) approx 10^5 * 17`.\n`M log M` is `3*10^5 * log(3*10^5) approx 3*10^5 * 18`.\nThis should pass.\n\n**Final Algorithm Steps:**\n1. Read `n, m`.\n2. Initialize `items_w1`, `items_w2`, `items_w3` as empty lists.\n3. For each of `n` souvenirs, read `w, c` and append `c` to the corresponding list (`items_w1`, `items_w2`, or `items_w3`).\n4. Sort `items_w1`, `items_w2`, `items_w3` in descending order.\n5. Compute prefix sums:\n   `pref_w1 = [0] * (len(items_w1) + 1)`\n   `for i in range(len(items_w1)): pref_w1[i+1] = pref_w1[i] + items_w1[i]`\n   (Do similarly for `pref_w2`, `pref_w3`).\n6. Precompute `max_cost_12` table:\n   `max_cost_12 = [0] * (m + 1)`\n   Define `get_cost_12(k2_count, capacity)` helper function:\n     `k1_count = min(len(items_w1), capacity - 2 * k2_count)`\n     `return pref_w1[k1_count] + pref_w2[k2_count]`\n   For `w` from `0` to `m`:\n     `low_k2 = 0`\n     `high_k2 = min(len(items_w2), w // 2)`\n     `current_max_val = 0`\n     if `high_k2 < low_k2`:\n       `current_max_val = pref_w1[min(len(items_w1), w)]`\n     else:\n       // Ternary search for `k2` in range `[low_k2, high_k2]`\n       while `high_k2 - low_k2 >= 3`:\n         `mid1 = low_k2 + (high_k2 - low_k2) // 3`\n         `mid2 = high_k2 - (high_k2 - low_k2) // 3`\n         if `get_cost_12(mid1, w) < get_cost_12(mid2, w)`:\n           `low_k2 = mid1`\n         else:\n           `high_k2 = mid2`\n       // Check the remaining few values\n       for `k2` in range(`low_k2`, `high_k2 + 1`):\n         `current_max_val = max(current_max_val, get_cost_12(k2, w))`\n     `max_cost_12[w] = current_max_val`\n7. Calculate the final maximum total cost:\n   `total_max_cost = 0`\n   For `k3` from `0` to `min(len(items_w3), m // 3)`:\n     `cost_w3 = pref_w3[k3]`\n     `weight_w3 = k3 * 3`\n     `remaining_capacity = m - weight_w3`\n     `cost_w12 = max_cost_12[remaining_capacity]`\n     `total_max_cost = max(total_max_cost, cost_w3 + cost_w12)`\n8. Print `total_max_cost`.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else: # w == 3\n            items_w3.append(c)\n\n    # Sort items in descending order of cost\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    # Compute prefix sums\n    # pref_w[k] will store the sum of costs of the first k items\n    pref_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        pref_w1[i+1] = pref_w1[i] + items_w1[i]\n\n    pref_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        pref_w2[i+1] = pref_w2[i] + items_w2[i]\n\n    pref_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        pref_w3[i+1] = pref_w3[i] + items_w3[i]\n\n    # Precompute max_cost_12[w] for all w from 0 to m\n    # max_cost_12[w] stores the maximum cost for capacity w using only weight 1 and weight 2 items\n    max_cost_12 = [0] * (m + 1)\n\n    # Helper function for ternary search: calculates cost for a given k2_count and capacity\n    # This function is concave w.r.t k2_count\n    def get_cost_12(k2_count, capacity):\n        current_cost_w2 = pref_w2[k2_count]\n        remaining_capacity_for_w1 = capacity - k2_count * 2\n        k1_count = min(len(items_w1), remaining_capacity_for_w1)\n        current_cost_w1 = pref_w1[k1_count]\n        return current_cost_w1 + current_cost_w2\n\n    for w in range(m + 1):\n        low_k2 = 0\n        high_k2 = min(len(items_w2), w // 2)\n        \n        current_max_val = 0\n        if high_k2 < low_k2: # No weight 2 items can be taken\n            current_max_val = pref_w1[min(len(items_w1), w)]\n        else:\n            # Ternary search to find optimal k2_count\n            # The range high_k2 - low_k2 can be large, so ternary search is needed.\n            # We need to ensure the range is at least 3 for mid1 and mid2 to be distinct from low/high.\n            # If the range is small, iterate.\n            while high_k2 - low_k2 >= 3:\n                mid1 = low_k2 + (high_k2 - low_k2) // 3\n                mid2 = high_k2 - (high_k2 - low_k2) // 3\n                \n                if get_cost_12(mid1, w) < get_cost_12(mid2, w):\n                    low_k2 = mid1\n                else:\n                    high_k2 = mid2\n            \n            # After ternary search, check the remaining few values\n            for k2 in range(low_k2, high_k2 + 1):\n                current_max_val = max(current_max_val, get_cost_12(k2, w))\n        \n        max_cost_12[w] = current_max_val\n\n    # Main loop: iterate over the number of weight 3 items\n    max_total_cost = 0\n    for k3_count in range(len(items_w3) + 1):\n        weight_used_w3 = k3_count * 3\n        if weight_used_w3 > m:\n            break\n        \n        cost_from_w3 = pref_w3[k3_count]\n        remaining_capacity = m - weight_used_w3\n        \n        # Get max cost for remaining capacity using weight 1 and 2 items from precomputed table\n        cost_from_w12 = max_cost_12[remaining_capacity]\n        \n        max_total_cost = max(max_total_cost, cost_from_w3 + cost_from_w12)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else: # w == 3\n            items_w3.append(c)\n\n    # Sort items in descending order of cost\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    # Compute prefix sums\n    # pref_w[k] will store the sum of costs of the first k items\n    pref_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        pref_w1[i+1] = pref_w1[i] + items_w1[i]\n\n    pref_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        pref_w2[i+1] = pref_w2[i] + items_w2[i]\n\n    pref_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        pref_w3[i+1] = pref_w3[i] + items_w3[i]\n\n    # Precompute max_cost_12[w] for all w from 0 to m\n    # max_cost_12[w] stores the maximum cost for capacity w using only weight 1 and weight 2 items\n    max_cost_12 = [0] * (m + 1)\n\n    # Helper function for ternary search: calculates cost for a given k2_count and capacity\n    # This function is concave w.r.t k2_count\n    def get_cost_12(k2_count, capacity):\n        current_cost_w2 = pref_w2[k2_count]\n        remaining_capacity_for_w1 = capacity - k2_count * 2\n        k1_count = min(len(items_w1), remaining_capacity_for_w1)\n        current_cost_w1 = pref_w1[k1_count]\n        return current_cost_w1 + current_cost_w2\n\n    for w in range(m + 1):\n        low_k2 = 0\n        high_k2 = min(len(items_w2), w // 2)\n        \n        current_max_val = 0\n        if high_k2 < low_k2: # No weight 2 items can be taken\n            current_max_val = pref_w1[min(len(items_w1), w)]\n        else:\n            # Ternary search to find optimal k2_count\n            # The range high_k2 - low_k2 can be large, so ternary search is needed.\n            # We need to ensure the range is at least 3 for mid1 and mid2 to be distinct from low/high.\n            # If the range is small, iterate.\n            while high_k2 - low_k2 >= 3:\n                mid1 = low_k2 + (high_k2 - low_k2) // 3\n                mid2 = high_k2 - (high_k2 - low_k2) // 3\n                \n                if get_cost_12(mid1, w) < get_cost_12(mid2, w):\n                    low_k2 = mid1\n                else:\n                    high_k2 = mid2\n            \n            # After ternary search, check the remaining few values\n            for k2 in range(low_k2, high_k2 + 1):\n                current_max_val = max(current_max_val, get_cost_12(k2, w))\n        \n        max_cost_12[w] = current_max_val\n\n    # Main loop: iterate over the number of weight 3 items\n    max_total_cost = 0\n    for k3_count in range(len(items_w3) + 1):\n        weight_used_w3 = k3_count * 3\n        if weight_used_w3 > m:\n            break\n        \n        cost_from_w3 = pref_w3[k3_count]\n        remaining_capacity = m - weight_used_w3\n        \n        # Get max cost for remaining capacity using weight 1 and 2 items from precomputed table\n        cost_from_w12 = max_cost_12[remaining_capacity]\n        \n        max_total_cost = max(max_total_cost, cost_from_w3 + cost_from_w12)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 496,
        "completion_token_count": 4756,
        "thoughts_token_count": 6386
    }
}