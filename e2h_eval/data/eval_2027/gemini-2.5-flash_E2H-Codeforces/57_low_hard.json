{
    "start": 1758284858.6001582,
    "end": 1758284959.5952642,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Thinking Through the Competitive Programming Problem**\n\nOkay, so I'm being asked to figure out the best and worst possible ranks Vasya can achieve in this Olympiad.  The core of this is a matching problem, coupled with rank calculation.  I need to consider all possible ways to pair up the scores from the two rounds.  Crucially, I only know Vasya's *minimum* total score (`x`) and that there *exists* some combination of scores from the two rounds that add up to at least that amount.\n\nThe input gives me `n` participants, two sets of scores (one for each round), and that crucial `x`. I'm supposed to output the best and worst possible ranks.  The constraints are fairly standard for this kind of problem; I need to keep efficiency in mind.\n\nMy strategy needs to revolve around finding *specific* matchings that give Vasya the best and worst ranks, not necessarily enumerating every single possible matching.  I need to somehow optimize the matching process.\n\n**Key Observations:**\n\n*   **Ranks are determined by the *number of people with strictly higher scores* plus one.**  This suggests that to minimize Vasya's rank (i.e., make it \"best\"), I want to maximize his score relative to everyone else's.  To maximize his rank (\"worst\"), I want to make his score as small as possible, still satisfying the condition that his score is at least `x`.\n*   **Tie-breaking is important.**  If multiple people have the same score, Vasya's rank can vary.  This is critical to the best and worst case scenarios.  I need to use this to my advantage.\n*   **I'm not given which `a_i` and `b_j` are Vasya's.** I have to account for the unknown pair that makes up Vasya's score.\n\n**Breaking Down the Problem:**\n\nEssentially, for the best rank, I want to pair Vasya's scores with the *highest* possible values (still meeting the >= x constraint) and pair the other participants such that most of them score less than Vasya.  For the worst rank, I want to pair Vasya's scores with the *lowest* possible scores that still make the condition true.\n\nI'm thinking I need to design a strategy using sorting.  If I sort the scores, it becomes easier to identify and consider potentially high and low scores.  I bet that sorting `a` and `b` in some order will be very important. Then, I need to try to figure out which `a_i` to pair with which `b_j`, subject to that `a_i + b_j >= x` requirement. Finally, I will iterate through all possible matchings that satisfy that condition to find the best and worst rank. The trick is to avoid brute force and be clever!\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given `n` scores for the first tour (`a`) and `n` scores for the second tour (`b`), and a minimum total score `x` that Vasya achieved. The scores in `a` and `b` are not paired. We need to pair them up to form `n` participants' total scores. Vasya is one of these participants.\n\nLet's analyze the best and worst rank scenarios.\n\n**Best Possible Rank for Vasya:**\nTo achieve the best rank (rank 1), Vasya needs to maximize his own score and minimize the scores of all other participants.\n1.  **Maximize Vasya's score:** Vasya should be assigned the highest possible `a_i` and `b_j` such that `a_i + b_j >= x`. To maximize `a_i + b_j`, we should pick the largest `a_i` and largest `b_j` available. Let's say Vasya gets `a_max` and `b_max` (the maximum values from lists `a` and `b`). His score would be `S_Vasya = a_max + b_max`.\n2.  **Minimize others' scores:** After Vasya takes `a_max` and `b_max`, the remaining `n-1` scores from `a` and `b` must be paired up. To minimize the scores of other participants, we should pair the largest remaining `a` with the smallest remaining `b`, the second largest `a` with the second smallest `b`, and so on. This strategy is not directly relevant for the *best* rank, because if Vasya has the highest possible score, he will be rank 1 regardless of how others are paired, as long as no one else can also achieve `S_Vasya`.\n    However, the tie-breaking rule is crucial: \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\" This means if Vasya has `S_V` points, and `k` other people also have `S_V` points, Vasya can be assigned rank 1 (if the jury favors him) among these `k+1` people.\n    Therefore, for the best rank, Vasya can always be rank 1 if he can achieve a score `S_V` that is at least `x` and is the maximum possible score any participant can get *in that specific pairing*.\n    To ensure Vasya gets rank 1, we can simply assign him `a_max` and `b_max`. His score is `S_V = a_max + b_max`. Since it's guaranteed that Vasya was present and `a_i + b_j >= x` for some `i, j`, it must be possible for Vasya to take `a_max` and `b_max` if `a_max + b_max >= x`. If `a_max + b_max < x`, then Vasya must take some other `a_i, b_j` with `a_i + b_j >= x`. However, the problem statement \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\" implies that *some* valid pairing exists for Vasya. If we assign Vasya the largest `a` and largest `b`, his score `a_max + b_max` will be the maximum possible individual score any participant can achieve in any pairing. If `a_max + b_max >= x`, then Vasya can take these scores and be rank 1. If `a_max + b_max < x`, this implies that there is no `a_i, b_j` such that `a_i + b_j >= x`, which contradicts the problem guarantee. So, Vasya can always achieve `a_max + b_max` and it will be `a_max + b_max >= x`.\n    Thus, the best rank is always **1**.\n\n**Worst Possible Rank for Vasya:**\nTo achieve the worst rank, Vasya needs to minimize his own score (while still satisfying `a_i + b_j >= x`) and maximize the scores of all other participants.\n1.  **Minimize Vasya's score:** Vasya should be assigned `a_i` and `b_j` such that `a_i + b_j >= x` is minimized.\n2.  **Maximize others' scores:** The remaining `n-1` `a` scores and `n-1` `b` scores must be paired up. To maximize their scores, we should pair the largest remaining `a` with the largest remaining `b`, the second largest `a` with the second largest `b`, and so on. This is achieved by sorting both `a` and `b` in descending order and pairing `a_k` with `b_k`.\n\nLet's sort `a` in ascending order and `b` in descending order.\n`a_sorted_asc = [a_1, a_2, ..., a_n]`\n`b_sorted_desc = [b_1, b_2, ..., b_n]`\n\nConsider a participant `P_k` who gets `a_k` from `a_sorted_asc` and `b_j` from `b_sorted_desc`.\nIf we want to maximize the number of people who score *more* than Vasya, or *equal* to Vasya (to push Vasya down in ties), we should try to make as many sums `a_i + b_j` as large as possible.\nThe \"greedy pairing\" strategy for maximizing sums is to sort both lists in descending order and pair `a_i` with `b_i`. This maximizes the sum of all pairs `sum(a_i + b_i)`. It also tends to create a few very high scores and a few very low scores.\nThe \"greedy pairing\" strategy for minimizing sums (or making them more balanced) is to sort one list ascending and one descending, then pair `a_i` with `b_i`. This minimizes the sum of all pairs `sum(a_i + b_i)`. It tends to make scores more clustered around the average.\n\nFor the worst rank, we want to maximize the number of participants whose scores are greater than or equal to Vasya's score.\nLet Vasya be assigned `a_i` and `b_j`. His score is `S_V = a_i + b_j`.\nAll other `n-1` participants must be formed from the remaining `n-1` `a` scores and `n-1` `b` scores.\nTo maximize the number of people who score `S_P >= S_V`, we should try to make as many `a_k + b_l` sums as large as possible.\n\nLet's fix Vasya's score to be `S_V`. Vasya is assigned some `a_i` and `b_j` such that `a_i + b_j = S_V` and `S_V >= x`.\nThe remaining `n-1` values in `a` and `n-1` values in `b` must be paired. We want to maximize the number of pairs `(a_k, b_l)` such that `a_k + b_l >= S_V`.\n\nThis is a matching problem. We want to find a pairing `(p_1, q_1), ..., (p_n, q_n)` of `a` and `b` such that `a_{p_k} + b_{q_k} >= x` for some `k`, and for this `k`, Vasya's rank is maximized.\nThe worst rank for Vasya is `1 + (number of participants P_m such that S_{P_m} > S_V) + (number of participants P_m such that S_{P_m} = S_V and jury ranks them above Vasya)`.\nSince the jury can assign Vasya the worst possible tie-breaking rank, we count all participants with `S_{P_m} >= S_V`.\n\nConsider sorting `a` in ascending order: `a_1 <= a_2 <= ... <= a_n`.\nConsider sorting `b` in descending order: `b_1 >= b_2 >= ... >= b_n`.\nIf we pair `a_i` with `b_i` for all `i`, we get `n` sums: `s_i = a_i + b_i`. This specific pairing strategy (sorting one ascending, one descending, then pairing corresponding elements) is known to minimize the maximum sum among all pairings, and maximize the minimum sum among all pairings. It also makes the sums `a_i + b_i` as \"balanced\" as possible.\nLet's analyze the sums `a_i + b_i` from this pairing.\nIf `a_i + b_i < x`, then `a_i` cannot be paired with `b_i` if `a_i` is Vasya's score (and `b_i` is Vasya's score).\nHowever, we are looking for *any* pairing.\n\nLet's use a two-pointer approach to find the maximum number of participants who can achieve a score of at least `x`.\nSort `a` in ascending order: `a_1 <= a_2 <= ... <= a_n`.\nSort `b` in descending order: `b_1 >= b_2 >= ... >= b_n`.\nWe want to form pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\nLet `count` be the number of such pairs we can form.\nInitialize two pointers: `i = 0` (for `a_sorted_asc`) and `j = 0` (for `b_sorted_desc`).\nWhile `i < n` and `j < n`:\n  If `a_i + b_j >= x`:\n    We can form a valid pair. This `a_i` and `b_j` are used. Increment `count`, `i`, and `j`.\n  Else (`a_i + b_j < x`):\n    Since `a_i` is the smallest remaining `a` and `b_j` is the largest remaining `b`, if their sum is less than `x`, then `a_i` cannot be paired with *any* of the remaining `b` values (because `b_k <= b_j` for `k > j`). So, `a_i` cannot form a pair that sums to `x` or more with any currently available `b`. We must discard `a_i` from consideration for forming a sum `>=x`. Increment `i`. (This `a_i` will be used to form a pair that sums to less than `x`.)\n\nThis strategy counts the maximum number of participants who can achieve a score of at least `x`.\nLet this count be `k`.\nThese `k` participants (including Vasya) can all achieve a score of at least `x`.\nFor the worst case, Vasya is one of these `k` participants, and the jury can decide that all `k-1` other participants who scored `>=x` are ranked above Vasya. And any participant who scored more than Vasya (even if their score was also `>=x`) is also ranked above Vasya.\nThe worst rank for Vasya will be `k`.\n\nLet's re-verify the logic for the worst rank.\nWe want to maximize the number of people who score *at least* Vasya's score.\nLet Vasya's score be `S_V`. We want to maximize `count(P_m | S_{P_m} >= S_V)`.\nThe problem states \"It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x.\"\nThis means at least one `a_i` and `b_j` can be paired to satisfy `a_i + b_j >= x`.\nThe two-pointer approach described above (sort `a` ascending, `b` descending) finds the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\nLet this maximum number be `max_valid_pairs`.\nIn the worst-case scenario, Vasya is one of these `max_valid_pairs` participants. All `max_valid_pairs` participants achieve a score of at least `x`. The jury can decide to rank Vasya last among these `max_valid_pairs` participants.\nTherefore, Vasya's worst rank is `max_valid_pairs`.\n\nExample 1:\nn=5, x=2\na = [1, 1, 1, 1, 1]\nb = [1, 1, 1, 1, 1]\nSorted a (asc): [1, 1, 1, 1, 1]\nSorted b (desc): [1, 1, 1, 1, 1]\n\ni=0, j=0: a[0]+b[0] = 1+1 = 2. 2 >= x (2). Yes. count=1. i=1, j=1.\ni=1, j=1: a[1]+b[1] = 1+1 = 2. 2 >= x (2). Yes. count=2. i=2, j=2.\ni=2, j=2: a[2]+b[2] = 1+1 = 2. 2 >= x (2). Yes. count=3. i=3, j=3.\ni=3, j=3: a[3]+b[3] = 1+1 = 2. 2 >= x (2). Yes. count=4. i=4, j=4.\ni=4, j=4: a[4]+b[4] = 1+1 = 2. 2 >= x (2). Yes. count=5. i=5, j=5.\nLoop ends.\nWorst rank = 5.\nBest rank = 1.\nOutput: 1 5. Matches example.\n\nExample 2:\nn=6, x=7\na = [4, 3, 5, 6, 4, 4]\nb = [8, 6, 0, 4, 3, 4]\nSorted a (asc): [3, 4, 4, 4, 5, 6]\nSorted b (desc): [8, 6, 4, 4, 4, 3]\n\ni=0, j=0: a[0]+b[0] = 3+8 = 11. 11 >= x (7). Yes. count=1. i=1, j=1.\ni=1, j=1: a[1]+b[1] = 4+6 = 10. 10 >= x (7). Yes. count=2. i=2, j=2.\ni=2, j=2: a[2]+b[2] = 4+4 = 8. 8 >= x (7). Yes. count=3. i=3, j=3.\ni=3, j=3: a[3]+b[3] = 4+4 = 8. 8 >= x (7). Yes. count=4. i=4, j=4.\ni=4, j=4: a[4]+b[4] = 5+4 = 9. 9 >= x (7). Yes. count=5. i=5, j=5.\ni=5, j=5: a[5]+b[5] = 6+3 = 9. 9 >= x (7). Yes. count=6. i=6, j=6.\nLoop ends.\nWorst rank = 6.\nBest rank = 1.\nOutput: 1 6.\nWait, the example output is 1 5. Why?\n\nLet's re-read the worst case scenario explanation in the example:\n\"In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\"\nPairs and sums:\n(4,8) -> 12\n(4,6) -> 10\n(6,4) -> 10\n(5,4) -> 9\n(4,3) -> 7 (Vasya's score)\n(3,0) -> 3\n\nScores: [12, 10, 10, 9, 7, 3].\nSorted scores: [12, 10, 10, 9, 7, 3].\nVasya's score is 7.\nParticipants with score >= 7: 12, 10, 10, 9, 7. There are 5 such participants.\nSo Vasya's rank is 5.\nThis means my two-pointer logic is not quite right for the worst case.\n\nThe two-pointer logic counts the maximum number of participants who *can* achieve `S_P >= x`.\nThe example's worst case pairing `{(4:8), (4:6), (6:4), (5:4), (4:3), (3:0)}` is one specific pairing.\nIn this pairing:\n`a` values used: 3, 4, 4, 4, 5, 6 (original `a` sorted: [3, 4, 4, 4, 5, 6])\n`b` values used: 0, 3, 4, 4, 6, 8 (original `b` sorted: [0, 3, 4, 4, 6, 8])\nThis is a valid pairing of all `a` and `b` scores.\nVasya is assigned (4,3), total 7.\nScores of others: 12, 10, 10, 9, 3.\nNumber of people with score >= Vasya's score (7): 12, 10, 10, 9, 7. Total 5 people.\nSo Vasya's rank is 5.\n\nThe crucial difference is that my two-pointer approach finds the maximum number of people who can score *at least x*.\nThe example's worst case finds a pairing where Vasya gets a score `S_V >= x`, and then maximizes the number of people who score *at least S_V*.\n\nLet `k` be the number of people who score strictly more than Vasya.\nLet `t` be the number of people who score exactly the same as Vasya (excluding Vasya himself).\nVasya's rank would be `k + 1` (if jury favors him) to `k + 1 + t` (if jury is against him).\nFor the worst rank, we want `k + 1 + t`. This is `1 + (number of people with score > S_V) + (number of people with score = S_V)`.\nThis is equivalent to `(number of people with score >= S_V)`.\n\nLet `a_i` be sorted ascending, `b_i` be sorted ascending.\nTo achieve the worst rank for Vasya, we want to pick Vasya's scores `(a_v, b_v)` such that `a_v + b_v >= x` and `a_v + b_v` is as small as possible.\nAnd then, for the remaining `n-1` `a` scores and `n-1` `b` scores, we want to pair them up to maximize the number of people who score `S_P >= a_v + b_v`.\n\nThis is a bit complicated. What if Vasya takes a very low score `S_V` (but `S_V >= x`), and then all other `n-1` participants can be paired up to score much higher than `S_V`?\nOr what if Vasya takes a moderate score `S_V`, and many others can match `S_V`?\n\nThe key insight for this type of problem often involves sorting and a greedy approach or two pointers.\nLet's sort `a` in ascending order and `b` in ascending order.\n`a = [a_1, ..., a_n]`\n`b = [b_1, ..., b_n]`\n\nConsider an `a_i` from the sorted `a` list. What is the smallest `b_j` such that `a_i + b_j >= x`?\nWe can find this `b_j` efficiently using binary search (or two pointers if we iterate `a_i`).\nFor each `a_i`, the smallest `b_j` that satisfies `a_i + b_j >= x` is `b_j >= x - a_i`.\nLet `k_i` be the index of the first `b` value in `b_sorted_asc` that is `>= x - a_i`.\nIf such `b_j` exists, then `a_i` can be paired with `b_{k_i}, b_{k_i+1}, ..., b_n`.\nThe sum `a_i + b_{k_i}` would be the minimum possible sum for `a_i` that satisfies the condition.\n\nLet's try to construct the worst case.\nWe want to maximize the number of people who score `>= S_V`.\nThis means we want to find a pairing `P = {(a_i, b_j)}` and a specific pair `(a_v, b_v) \\in P` such that `a_v + b_v >= x`, and the number of pairs `(a_k, b_l) \\in P` where `a_k + b_l >= a_v + b_v` is maximized.\n\nThis is equivalent to finding a matching `M` of `a` and `b` such that `M = {(a_{p_1}, b_{q_1}), ..., (a_{p_n}, b_{q_n})}` and then finding `k` such that `a_{p_k} + b_{q_k} >= x`, and then counting how many `m` have `a_{p_m} + b_{q_m} >= a_{p_k} + b_{q_k}`. We want to maximize this count.\n\nThis sounds like we need to find the \"optimal\" `S_V` for Vasya.\nWhat if Vasya takes the smallest possible sum `S_V` that is `>= x`?\nTo find the smallest possible sum `S_V >= x`, we can iterate through `a_i` (sorted ascending). For each `a_i`, find the smallest `b_j` (from `b_sorted_asc`) such that `a_i + b_j >= x`. This `b_j` can be found using `bisect_left` on `b` for `x - a_i`.\nLet `min_vasya_score = infinity`.\nFor `i` from `0` to `n-1`:\n  `target_b = x - a[i]`\n  `idx = bisect_left(b, target_b)`\n  If `idx < n`:\n    `min_vasya_score = min(min_vasya_score, a[i] + b[idx])`\n\nThis `min_vasya_score` is the absolute minimum score Vasya could get that satisfies the condition.\nLet's assume Vasya gets this `min_vasya_score`.\nNow, we need to find a pairing of all `n` scores such that Vasya gets `min_vasya_score` (using some `a_i`, `b_j` such that `a_i + b_j = min_vasya_score`), and the number of other participants who score `>= min_vasya_score` is maximized.\n\nThis is still tricky because we need to construct a *full matching*.\nThe problem essentially asks:\nWhat is the maximum `k` such that there exists a perfect matching `M` of `A` and `B` and an element `(a_v, b_v) \\in M` with `a_v + b_v \\ge x`, AND there are `k` elements `(a_i, b_i) \\in M` with `a_i + b_i \\ge a_v + b_v`?\n\nThis is a known problem structure. The \"worst rank\" for a participant whose score is `S_V` is `1 + (# of participants with score > S_V) + (# of participants with score = S_V)`. This is equivalent to counting participants with score `>= S_V`.\nWe need to find a pairing `(a_p, b_q)` for all `n` participants, and identify Vasya's pair `(a_v, b_v)` such that `a_v + b_v >= x`. We want to maximize the count of participants `(a_i, b_j)` such that `a_i + b_j >= a_v + b_v`.\n\nConsider sorting `a` in ascending order and `b` in ascending order.\nLet `a = [a_0, ..., a_{n-1}]` and `b = [b_0, ..., b_{n-1}]`.\nWe want to find the maximum `k` such that there exists a pairing `P` and a pair `(a_i, b_j) \\in P` with `a_i + b_j \\ge x`, and `k` pairs `(a_x, b_y) \\in P` satisfy `a_x + b_y \\ge a_i + b_j`.\n\nThis can be solved by iterating over all possible sums `S_V` that Vasya could achieve.\nHowever, `S_V` can be up to `2*10^5`, and there are `n^2` possible sums. Too slow.\nThe number of distinct sums is at most `2n-1`.\n\nLet's rethink the two-pointer approach for the worst case.\nSort `a` in ascending order: `a_0, ..., a_{n-1}`.\nSort `b` in ascending order: `b_0, ..., b_{n-1}`.\n\nWe want to maximize the number of participants who score at least `S_V`.\nConsider a specific score `S_target`. We want to find the maximum number of pairs `(a_i, b_j)` that can be formed from `a` and `b` such that `a_i + b_j >= S_target`.\nLet's say we have `n` `a` values and `n` `b` values.\nTo maximize the number of pairs `(a_i, b_j)` with `a_i + b_j >= S_target`, we use a greedy approach:\nIterate `a_i` from smallest to largest. For each `a_i`, try to pair it with the smallest available `b_j` such that `a_i + b_j >= S_target`.\nThis is exactly what the two-pointer approach does:\n`a` sorted ascending, `b` sorted ascending.\n`count = 0`\n`j = n-1` (pointer for `b` from largest)\nFor `i` from `0` to `n-1` (pointer for `a` from smallest):\n  While `j >= 0` and `a[i] + b[j] >= S_target`:\n    `j--`\n  // Now `j` points to the largest `b` such that `a[i] + b[j] < S_target`, or `j=-1`.\n  // If we want to maximize the number of pairs `>= S_target`, we should pair `a[i]` with a `b` that is large enough.\n  // The current two-pointer logic for `max_valid_pairs`:\n  // Sort `a` asc, `b` desc.\n  // `i=0, j=0, count=0`\n  // While `i<n` and `j<n`:\n  //   If `a[i] + b[j] >= x`: `count++, i++, j++`\n  //   Else (`a[i] + b[j] < x`): `i++` (a[i] is too small for b[j], and thus for any b[k] where k>j)\n  // This counts the maximum number of pairs that sum to *at least x*.\n  // This is `max_valid_pairs`.\n\nThe example output `1 5` for the second case implies that the maximum number of participants who can achieve a score `S_P >= S_V` (where `S_V` is Vasya's score, and `S_V >= x`) is 5.\nMy two-pointer approach yielded 6. The difference is subtle.\nMy two-pointer approach finds the maximum number of participants who can score *at least x*. Let this be `K`.\nThe problem asks for the maximum `k` such that Vasya can be ranked `k`. This means there is a pairing where Vasya gets `S_V >= x`, and `k-1` other participants get `S_P >= S_V`.\nSo we want to maximize `k = 1 + (# of others with S_P >= S_V)`.\n\nConsider the `n` pairs `(a_i, b_{n-1-i})` after sorting `a` ascending and `b` descending.\n`a_0+b_{n-1}, a_1+b_{n-2}, ..., a_{n-1}+b_0`.\nLet's call this the \"anti-sorted pairing\". The sums `a_i + b_{n-1-i}` are not necessarily sorted.\nThe strategy for worst rank is to find a pairing `M` and a Vasya pair `(a_v, b_v) \\in M` such that `a_v + b_v \\ge x`, and the number of pairs `(a_p, b_q) \\in M` satisfying `a_p + b_q \\ge a_v + b_v` is maximized.\n\nThis is a known problem pattern that can be solved with a \"min-max\" or \"max-min\" argument.\nThe worst rank is the maximum `k` such that there exists a pairing where `k` participants (including Vasya) all achieve a score `S >= S_V` (Vasya's score) and Vasya's score `S_V >= x`.\nThe value `S_V` is not fixed, it depends on the pairing.\n\nLet's sort `a` and `b` both in ascending order.\n`a = [a_0, a_1, ..., a_{n-1}]`\n`b = [b_0, b_1, ..., b_{n-1}]`\n\nWe want to find a permutation `p` of `(0, ..., n-1)` such that if we form pairs `(a_i, b_{p_i})`, then for some `k` where `a_k + b_{p_k} >= x`, the number of `j` for which `a_j + b_{p_j} >= a_k + b_{p_k}` is maximized.\n\nThis is equivalent to finding the largest `k` such that there exist `k` pairs `(a_{i_1}, b_{j_1}), ..., (a_{i_k}, b_{j_k})` which are formed from `k` distinct elements of `a` and `k` distinct elements of `b`, AND there exists a target sum `S_target` such that for all these `k` pairs, `a_{i_m} + b_{j_m} >= S_target`, AND at least one of these pairs `(a_{i_m}, b_{j_m})` is Vasya's, meaning `a_{i_m} + b_{j_m} >= x`.\nThe condition `a_{i_m} + b_{j_m} >= S_target` for all `m` means `S_target` must be less than or equal to the minimum of these `k` sums.\nAnd for Vasya's score `S_V`, we must have `S_V >= x`. So `S_target` must be at least `x`.\n\nSo we're looking for the maximum `k` such that we can pick `k` `a` values and `k` `b` values, pair them up, and find a `S_target >= x` such that all `k` pairs sum to at least `S_target`.\n\nThis is the standard maximum matching problem where edge weights are `a_i + b_j`, and we want to find a matching `M` of size `k` such that all `(u,v) \\in M` have `w(u,v) \\ge S_{target}` and `S_{target} \\ge x`.\nThe maximum `k` is the answer.\n\nHow to find the maximum `k` for a given `S_target`?\nSort `a` ascending, `b` ascending.\nUse a two-pointer approach:\n`count = 0`\n`j = n-1` (pointer for `b` from largest)\nFor `i` from `0` to `n-1` (pointer for `a` from smallest):\n  While `j >= 0` and `a[i] + b[j] >= S_target`:\n    `j--`\n  // Now `j` points to the largest `b` such that `a[i] + b[j] < S_target`.\n  // All `b` values from `j+1` to `n-1` are candidates to be paired with `a[i]` to form a sum `>= S_target`.\n  // To maximize the number of pairs, we should use the largest `b` values with the smallest `a` values.\n  // This is the correct logic for `max_valid_pairs_for_target(S_target)`:\n  `a_copy = sorted(a)`\n  `b_copy = sorted(b)`\n  `count = 0`\n  `b_ptr = n-1` // Pointer for `b_copy` (largest elements)\n  For `a_ptr` from `0` to `n-1`: // Iterate through `a_copy` (smallest elements)\n    While `b_ptr >= 0` and `a_copy[a_ptr] + b_copy[b_ptr] >= S_target`:\n      `b_ptr--`\n    // Now `b_ptr` is either -1 or points to the largest `b` that is too small for `a_copy[a_ptr]`.\n    // This means `b_copy[b_ptr+1]` (if it exists) is the smallest `b` that works with `a_copy[a_ptr]`\n    // to reach `S_target`.\n    // This is not correct for maximum matching. The greedy choice is to pair smallest `a` with largest `b`\n    // that satisfy the condition.\n    // Correct greedy for max pairs >= S_target:\n    `a_sorted = sorted(a)`\n    `b_sorted = sorted(b)`\n    `count = 0`\n    `b_idx = 0`\n    For `a_idx` from `0` to `n-1`:\n      While `b_idx < n` and `a_sorted[a_idx] + b_sorted[b_idx] < S_target`:\n        `b_idx++`\n      If `b_idx < n`: // Found a `b_idx` such that `a_sorted[a_idx] + b_sorted[b_idx] >= S_target`\n        `count++`\n        `b_idx++` // Use this `b_idx` and move to the next `b`\n    Return `count`\n\nLet's test this `max_pairs_for_target(S_target)` function with Example 2, `x=7`.\n`a = [3, 4, 4, 4, 5, 6]`\n`b = [0, 3, 4, 4, 6, 8]`\n\nWhat are the possible `S_target` values? The problem says \"Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\"\nHere Vasya's score `S_V = 4+3 = 7`. So `S_target = 7`.\nLet's run `max_pairs_for_target(7)`:\n`a_sorted = [3, 4, 4, 4, 5, 6]`\n`b_sorted = [0, 3, 4, 4, 6, 8]`\n`count = 0`\n`b_idx = 0`\n\n`a_idx=0 (a[0]=3)`:\n  `b_idx=0 (b[0]=0)`: `3+0=3 < 7`. `b_idx=1`.\n  `b_idx=1 (b[1]=3)`: `3+3=6 < 7`. `b_idx=2`.\n  `b_idx=2 (b[2]=4)`: `3+4=7 >= 7`. Yes. `count=1`. `b_idx=3`. (Pair (3,4))\n`a_idx=1 (a[1]=4)`:\n  `b_idx=3 (b[3]=4)`: `4+4=8 >= 7`. Yes. `count=2`. `b_idx=4`. (Pair (4,4))\n`a_idx=2 (a[2]=4)`:\n  `b_idx=4 (b[4]=6)`: `4+6=10 >= 7`. Yes. `count=3`. `b_idx=5`. (Pair (4,6))\n`a_idx=3 (a[3]=4)`:\n  `b_idx=5 (b[5]=8)`: `4+8=12 >= 7`. Yes. `count=4`. `b_idx=6`. (Pair (4,8))\n`a_idx=4 (a[4]=5)`:\n  `b_idx=6`. `b_idx` is out of bounds. No more `b` values.\n`a_idx=5 (a[5]=6)`:\n  `b_idx=6`. `b_idx` is out of bounds. No more `b` values.\n\nResult `count = 4`.\nThis means we can form at most 4 pairs that sum to at least 7.\nThe example output for worst case is 5. My `max_pairs_for_target` is not giving 5 for `S_target=7`.\nThe example pairing for worst case `{(4:8), (4:6), (6:4), (5:4), (4:3), (3:0)}` results in 5 pairs `>= 7`.\nThe `a` values used for these 5 pairs are `4,4,6,5,4`. (These are distinct `a` values from the input).\nThe `b` values used are `8,6,4,4,3`. (These are distinct `b` values from the input).\nThis means the `max_pairs_for_target` function is incorrect.\n\nThe correct way to find the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= S_target` is:\nSort `a` ascending. Sort `b` ascending.\n`count = 0`\n`j = n-1` (pointer for `b` from largest)\nFor `i` from `0` to `n-1` (pointer for `a` from smallest):\n  While `j >= 0` and `a[i] + b[j] >= S_target`:\n    `j--`\n  // Now `j` points to the largest `b` such that `a[i] + b[j] < S_target`.\n  // This means `b[j+1], ..., b[n-1]` are all `b` values that can form a sum `>= S_target` with `a[i]`.\n  // To maximize the count, we should pair `a[i]` with the smallest possible `b` from `b[j+1]` to `b[n-1]`.\n  // This is also wrong. The problem is a bipartite matching problem.\n\nThe problem states: \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\nThis means if Vasya has `S_V` points, and `k` other people also have `S_V` points, Vasya's rank can be `1 + (# people with > S_V) + k`. This is effectively `(# people with >= S_V)`.\n\nThe worst rank for Vasya is the maximum `k` such that there exists a pairing `M` of `A` and `B` and a pair `(a_v, b_v) \\in M` (Vasya's scores) with `a_v + b_v \\ge x`, AND `k` pairs `(a_i, b_j) \\in M` satisfy `a_i + b_j \\ge a_v + b_v`.\n\nThis looks like a binary search on the answer `k`.\nFor a given `k`, can we find a pairing `M` and a Vasya's score `S_V >= x` such that `k` participants in `M` have scores `>= S_V`?\nIf we fix `k`, we want to find the largest possible `S_V` such that `k` participants can score at least `S_V`. This is `S_k = a_{i_0} + b_{j_0}` where `(a_{i_0}, b_{j_0})` is the `k`-th highest score in the matching.\nTo maximize this `S_k`, we should pair the `k` largest `a` values with the `k` largest `b` values.\nSort `a` ascending, `b` ascending.\nConsider the `k` largest `a` values: `a_{n-k}, ..., a_{n-1}`.\nConsider the `k` largest `b` values: `b_{n-k}, ..., b_{n-1}`.\nTo make sure all `k` pairs sum up to at least some `S_V`, we should pair `a_{n-k+i}` with `b_i` for `i=0, ..., k-1` (or some other combination).\nThe minimum sum among these `k` pairs is maximized if we sort both `a` and `b` descending and pair `a_i` with `b_i`.\nSo, sort `a` descending and `b` descending.\n`a_desc = [a_n-1, ..., a_0]`\n`b_desc = [b_n-1, ..., b_0]`\nThe `k` largest sums are formed by pairing `a_desc[i]` with `b_desc[i]` for `i=0, ..., k-1`.\nThe `k`-th largest sum will be `a_desc[k-1] + b_desc[k-1]`.\nSo, if we want to ensure `k` people score at least `S_V`, we can set `S_V = a_desc[k-1] + b_desc[k-1]`.\nWe need to check if this `S_V >= x`.\nIf `a_desc[k-1] + b_desc[k-1] >= x`, then it's possible to have `k` people (including Vasya) score at least `a_desc[k-1] + b_desc[k-1]`, and Vasya's score is `>= x`.\nSo, the worst rank is the maximum `k` such that `a_desc[k-1] + b_desc[k-1] >= x`.\n\nLet's test this hypothesis for Example 2:\n`a = [4, 3, 5, 6, 4, 4]`\n`b = [8, 6, 0, 4, 3, 4]`\nSorted `a` descending: `[6, 5, 4, 4, 4, 3]`\nSorted `b` descending: `[8, 6, 4, 4, 4, 3]`\n`x = 7`\n\n`k=1`: `a_desc[0]+b_desc[0] = 6+8 = 14`. `14 >= 7`. Possible.\n`k=2`: `a_desc[1]+b_desc[1] = 5+6 = 11`. `11 >= 7`. Possible.\n`k=3`: `a_desc[2]+b_desc[2] = 4+4 = 8`. `8 >= 7`. Possible.\n`k=4`: `a_desc[3]+b_desc[3] = 4+4 = 8`. `8 >= 7`. Possible.\n`k=5`: `a_desc[4]+b_desc[4] = 4+4 = 8`. `8 >= 7`. Possible.\n`k=6`: `a_desc[5]+b_desc[5] = 3+3 = 6`. `6 < 7`. Not possible.\n\nSo the maximum `k` for which `a_desc[k-1] + b_desc[k-1] >= x` is 5.\nThis matches the example output!\n\nThis strategy for the worst rank makes sense:\n1.  Sort `a` in descending order.\n2.  Sort `b` in descending order.\n3.  Form pairs `(a_i, b_i)` for `i = 0, ..., n-1`. This pairing maximizes the individual scores and generally leads to a few very high scores and a few lower scores.\n4.  The `k`-th participant in this pairing (when sorted by score) will have score `a_{k-1} + b_{k-1}`.\n5.  We want to find the largest `k` such that Vasya *could* be this `k`-th person, and his score `a_{k-1} + b_{k-1}` is still `>= x`.\n6.  If `a_{k-1} + b_{k-1} >= x`, then it's possible for Vasya to be one of the top `k` people in this pairing, all of whom score at least `a_{k-1} + b_{k-1}`. The jury can then place Vasya at rank `k`.\n\nThis logic seems solid for the worst rank.\nThe `a_desc` and `b_desc` lists represent the scores available for pairing. If we pair `a_i` with `b_i`, we are essentially forming `n` participants.\nThe scores of these participants would be `a_0+b_0, a_1+b_1, ..., a_{n-1}+b_{n-1}`.\nThese sums are not necessarily sorted.\nHowever, it is a known rearrangement inequality result that if `a` and `b` are sorted in the same order (both ascending or both descending), then `sum(a_i * b_i)` is maximized. If they are sorted in opposite orders, `sum(a_i * b_i)` is minimized.\nFor sums `a_i + b_i`, sorting both descending and pairing `a_i` with `b_i` tends to produce large sums.\nMore specifically, if we want to find the maximum `k` such that the `k`-th highest score in a pairing is at least `S_V`, and `S_V >= x`:\nThe pairing `(a_i, b_i)` where both `a` and `b` are sorted in descending order yields the `i`-th largest `a_i` paired with the `i`-th largest `b_i`. This maximizes the minimum of the first `k` sums, for any `k`.\nSo, `min_{j=0..k-1} (a_j + b_j)` (where `a,b` are sorted descending) is the maximum possible value for the `k`-th score if we consider the `k` highest scores.\nWe need this value to be `>= x`.\nWe can use binary search to find the largest `k`.\nThe range for `k` is `[1, n]`.\n`low = 1`, `high = n`, `ans = 1`\nWhile `low <= high`:\n  `mid = low + (high - low) // 2`\n  If `a_desc[mid-1] + b_desc[mid-1] >= x`:\n    `ans = mid`\n    `low = mid + 1`\n  Else:\n    `high = mid - 1`\nThe final `ans` is the worst rank.\n\n**Final Algorithm:**\n1.  **Best Rank:** Always 1. Vasya can take the highest `a_i` and `b_j`, score `a_max + b_max`, which will be the highest possible score any participant can get. Since `a_max + b_max >= x` (guaranteed), Vasya can be rank 1.\n2.  **Worst Rank:**\n    a.  Sort array `a` in descending order.\n    b.  Sort array `b` in descending order.\n    c.  Use binary search to find the largest `k` (from 1 to `n`) such that `a[k-1] + b[k-1] >= x`.\n        This `k` represents the maximum number of participants who can achieve a score of at least `x` (by pairing the `k` largest `a`s with the `k` largest `b`s). In this scenario, Vasya can be one of these `k` participants, and the jury can assign him the `k`-th place among them.\n\nThis solution is efficient:\n- Sorting: `O(N log N)`\n- Binary search: `O(log N)` iterations, each `O(1)` check.\nTotal time complexity: `O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays (or `O(1)` if sorting in-place and input arrays can be modified).\n\nLet's quickly check constraints: `N = 10^5`, `2 * 10^5` max score. `O(N log N)` is perfectly fine.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best rank is always 1.\n    # Vasya can be assigned the highest score from list 'a' and highest score from list 'b'.\n    # This sum (max(a) + max(b)) will be the maximum possible score any participant can achieve.\n    # The problem guarantees that there exists a pair (ai, bj) such that ai + bj >= x.\n    # If max(a) + max(b) < x, this would contradict the guarantee, as no other pair could achieve x.\n    # Thus, max(a) + max(b) >= x.\n    # Vasya takes these scores, and since he has the highest possible score, he can be ranked 1st.\n    best_rank = 1\n\n    # Worst rank calculation\n    # To find the worst rank, we want to maximize the number of participants\n    # who score at least as much as Vasya, given that Vasya's score is >= x.\n    # A strategy to maximize the number of participants who achieve a high score\n    # is to sort both lists in descending order and pair corresponding elements.\n    # For example, if a = [10, 5, 1] and b = [8, 4, 2], pairing (10,8), (5,4), (1,2)\n    # gives sums [18, 9, 3].\n    # The k-th participant (in terms of highest score) would have a score of a[k-1] + b[k-1]\n    # after sorting both a and b in descending order.\n    # We want to find the largest k such that this k-th highest score is still >= x.\n    # This k will be Vasya's worst possible rank, as the jury can place him last among these k participants.\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n\n    # Binary search for the largest k\n    low = 1\n    high = n\n    worst_rank = 1 # At least 1 participant (Vasya) can score >= x\n\n    while low <= high:\n        mid = low + (high - low) // 2\n        # Check if the mid-th highest score (when pairing a_desc[i] with b_desc[i]) is >= x\n        # The mid-th highest score is a[mid-1] + b[mid-1]\n        if a[mid-1] + b[mid-1] >= x:\n            worst_rank = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best rank is always 1.\n    # Vasya can be assigned the highest score from list 'a' and highest score from list 'b'.\n    # This sum (max(a) + max(b)) will be the maximum possible score any participant can achieve.\n    # The problem guarantees that there exists a pair (ai, bj) such that ai + bj >= x.\n    # If max(a) + max(b) < x, this would contradict the guarantee, as no other pair could achieve x.\n    # Thus, max(a) + max(b) >= x.\n    # Vasya takes these scores, and since he has the highest possible score, he can be ranked 1st.\n    best_rank = 1\n\n    # Worst rank calculation\n    # To find the worst rank, we want to maximize the number of participants\n    # who score at least as much as Vasya, given that Vasya's score is >= x.\n    # A strategy to maximize the number of participants who achieve a high score\n    # is to sort both lists in descending order and pair corresponding elements.\n    # For example, if a = [10, 5, 1] and b = [8, 4, 2], pairing (10,8), (5,4), (1,2)\n    # gives sums [18, 9, 3].\n    # The k-th participant (in terms of highest score) would have a score of a[k-1] + b[k-1]\n    # after sorting both a and b in descending order.\n    # We want to find the largest k such that this k-th highest score is still >= x.\n    # This k will be Vasya's worst possible rank, as the jury can place him last among these k participants.\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n\n    # Binary search for the largest k\n    low = 1\n    high = n\n    worst_rank = 1 # At least 1 participant (Vasya) can score >= x\n\n    while low <= high:\n        mid = low + (high - low) // 2\n        # Check if the mid-th highest score (when pairing a_desc[i] with b_desc[i]) is >= x\n        # The mid-th highest score is a[mid-1] + b[mid-1]\n        if a[mid-1] + b[mid-1] >= x:\n            worst_rank = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 12311,
        "thoughts_token_count": 740
    }
}