{
    "start": 1758284860.3341634,
    "end": 1758284879.6581554,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:27 KST",
    "gpu": 2,
    "pid": 54,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mister B and Angle in Polygon\n\nOn one quiet day all of sudden Mister B decided to draw angle a on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex n-gon (regular convex polygon with n sides).That's why Mister B decided to use this polygon. Now Mister B must find three distinct vertices v1, v2, v3 such that the angle  (where v2 is the vertex of the angle, and v1 and v3 lie on its sides) is as close as possible to a. In other words, the value  should be minimum possible.If there are many optimal solutions, Mister B should be satisfied with any of them.\n\n## Input\nFirst and only line contains two space-separated integers n and a (3 ≤ n ≤ 105, 1 ≤ a ≤ 180) — the number of vertices in the polygon and the needed angle, in degrees.\n\n## Output\nPrint three space-separated integers: the vertices v1, v2, v3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to n in clockwise order.\n\n## Example\n### Input\n['3 15', '4 67', '4 68']\n\n### Output\n['1 2 3', '2 1 3', '4 1 2']\n\n## Note\nIn first sample test vertices of regular triangle can create only angle of 60 degrees, that's why every possible angle is correct.Vertices of square can create 45 or 90 degrees angles only. That's why in second sample test the angle of 45 degrees was chosen, since |45 - 67| < |90 - 67|. Other correct answers are: \"3 1 2\", \"3 2 4\", \"4 2 3\", \"4 3 1\", \"1 3 4\", \"1 4 2\", \"2 4 1\", \"4 1 3\", \"3 1 4\", \"3 4 2\", \"2 4 3\", \"2 3 1\", \"1 3 2\", \"1 2 4\", \"4 2 1\".In third sample test, on the contrary, the angle of 90 degrees was chosen, since |90 - 68| < |45 - 68|. Other correct answers are: \"2 1 4\", \"3 2 1\", \"1 2 3\", \"4 3 2\", \"2 3 4\", \"1 4 3\", \"3 4 1\".\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Solving the Mister B and Angle in Polygon Problem**\n\nOkay, so I'm tackling this \"Mister B and Angle in Polygon\" problem.  The goal is to find three vertices in a regular *n*-gon that form an angle closest to a given target angle *a*.  I know this is a classic geometry problem, and the key lies in understanding the properties of regular polygons and inscribed angles.\n\nMy first thought is to break down the problem geometrically. We have a regular *n*-gon, which means it's inscribed in a circle.  The inscribed angle theorem is going to be my best friend here.  The central angle, I know, is `360/n` degrees for each side. Any angle formed by three vertices within the polygon is an inscribed angle and is *half* the measure of the central angle subtended by the arc not including the second vertex.\n\nLet's generalize this a little: Fix one vertex, say, vertex 2.  The other two vertices will create different inscribed angles. The number of sides between my first and third vertex will determine the angle formed. The angle between vertices *i*, *j*, and *k* is going to be dependent on the sides between vertices *i* and *k* that don't include vertex *j*.\n\nIf I use the indices and take the arc not including the vertex in the middle, then the inscribed angle will be `(k - i) * (180/n)`. My strategy will be to efficiently search through all possible combinations of three vertices and calculate the resulting angle. Then, I need to keep track of the closest angle found so far. I will likely need a way to calculate the difference and determine when this is the least possible, and then select the three vertices. I think I can write this into a nice Python script.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, a = map(int, sys.stdin.readline().split())\n\n    # The vertex v2 can be fixed to 2 (1-indexed).\n    # The vertex v1 can be fixed to 1 (1-indexed).\n    # Then v3 can be any vertex from 3 to n (1-indexed).\n    # The angle formed by vertices 1, 2, k (where k is v3)\n    # is (k - 2) * (180 / n) degrees.\n    # We need to find k (3 <= k <= n) such that this angle is closest to 'a'.\n\n    # The possible number of sides spanned by the arc v1-v3 (not containing v2)\n    # ranges from 1 to n-2. Let this be `k_arc`.\n    # The angle is `k_arc * (180 / n)`.\n    # In our setup (v1=1, v2=2, v3=k), `k_arc` corresponds to `k-2`.\n    # So `k_arc` ranges from `3-2=1` to `n-2`.\n\n    # Calculate the base angle unit: 180 / n\n    angle_unit = 180.0 / n\n\n    # We are looking for an integer `k_arc` (from 1 to n-2) such that\n    # `k_arc * angle_unit` is closest to `a`.\n    # This means `k_arc` should be close to `a / angle_unit`.\n\n    target_k_arc_float = a / angle_unit\n\n    # Consider the two integer `k_arc` values closest to `target_k_arc_float`:\n    # floor(target_k_arc_float) and ceil(target_k_arc_float).\n\n    # Candidate 1: floor(target_k_arc_float)\n    k_arc1 = int(target_k_arc_float)\n\n    # Candidate 2: ceil(target_k_arc_float)\n    k_arc2 = k_arc1 + 1\n\n    # Ensure k_arc values are within the valid range [1, n-2]\n    # The smallest possible angle is 1 * angle_unit, which corresponds to k_arc=1.\n    # The largest possible angle is (n-2) * angle_unit, which corresponds to k_arc=n-2.\n\n    best_diff = float('inf')\n    best_k_arc = -1\n\n    # Check k_arc1\n    if 1 <= k_arc1 <= n - 2:\n        current_angle = k_arc1 * angle_unit\n        current_diff = abs(current_angle - a)\n        best_diff = current_diff\n        best_k_arc = k_arc1\n\n    # Check k_arc2\n    if 1 <= k_arc2 <= n - 2:\n        current_angle = k_arc2 * angle_unit\n        current_diff = abs(current_angle - a)\n        if current_diff < best_diff:\n            best_diff = current_diff\n            best_k_arc = k_arc2\n        elif current_diff == best_diff:\n            # If differences are equal, any is fine. We can prefer the smaller k_arc.\n            # Since k_arc1 is smaller than k_arc2, if best_k_arc is still k_arc1, we keep it.\n            # If best_k_arc was -1 (meaning k_arc1 was invalid), we take k_arc2.\n            # If k_arc1 was valid and k_arc2 has same diff, we keep k_arc1.\n            # So no change needed here if best_k_arc is already set and diffs are equal.\n            pass # Or explicitly: if k_arc1 == -1 and k_arc2 != -1, best_k_arc = k_arc2 (but this is handled by initial logic)\n\n    # Edge case: If target_k_arc_float is less than 1, k_arc1 will be 0 or less.\n    # If target_k_arc_float is greater than n-2, k_arc1 will be n-2 or more.\n    # In these cases, one of the candidates might be out of bounds.\n    # The loop below ensures we pick the valid k_arc closest to the boundary.\n\n    # If best_k_arc is still -1, it means both k_arc1 and k_arc2 were out of bounds.\n    # This implies `a` is either very small (so `target_k_arc_float < 1`)\n    # or very large (so `target_k_arc_float > n-2`).\n    # In such cases, we should pick the closest valid boundary value.\n    if best_k_arc == -1:\n        # If 'a' is very small, pick k_arc=1 (smallest possible angle)\n        if target_k_arc_float < 1:\n            best_k_arc = 1\n        # If 'a' is very large, pick k_arc=n-2 (largest possible angle)\n        elif target_k_arc_float > n - 2:\n            best_k_arc = n - 2\n        # This case should not be reached if target_k_arc_float is within [1, n-2]\n        # and k_arc1/k_arc2 were checked.\n        # It could happen if n=3, then n-2=1. So k_arc can only be 1.\n        # In this specific case, k_arc1 might be 0, k_arc2 might be 1.\n        # The above logic correctly handles n=3:\n        # If n=3, n-2=1. Valid k_arc is only 1.\n        # angle_unit = 180/3 = 60.\n        # Only possible angle is 60 degrees.\n        # target_k_arc_float = a / 60.\n        # If a=15, target_k_arc_float = 0.25. k_arc1=0, k_arc2=1.\n        # k_arc1=0 is invalid. k_arc2=1 is valid. best_k_arc=1. Correct.\n        # If a=100, target_k_arc_float = 1.66. k_arc1=1, k_arc2=2.\n        # k_arc1=1 is valid. k_arc2=2 is invalid. best_k_arc=1. Correct.\n\n    # The chosen k_arc represents (v3 - v2) in the 0-indexed system\n    # or (v3 - v1) in the 1-indexed system if v2 is the next vertex.\n    # With v1=1, v2=2, v3 is `k_arc + 2`.\n    v1 = 1\n    v2 = 2\n    v3 = best_k_arc + 2\n\n    sys.stdout.write(f\"{v1} {v2} {v3}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, a = map(int, sys.stdin.readline().split())\n\n    # The vertex v2 can be fixed to 2 (1-indexed).\n    # The vertex v1 can be fixed to 1 (1-indexed).\n    # Then v3 can be any vertex from 3 to n (1-indexed).\n    # The angle formed by vertices 1, 2, k (where k is v3)\n    # is (k - 2) * (180 / n) degrees.\n    # We need to find k (3 <= k <= n) such that this angle is closest to 'a'.\n\n    # The possible number of sides spanned by the arc v1-v3 (not containing v2)\n    # ranges from 1 to n-2. Let this be `k_arc`.\n    # The angle is `k_arc * (180 / n)`.\n    # In our setup (v1=1, v2=2, v3=k), `k_arc` corresponds to `k-2`.\n    # So `k_arc` ranges from `3-2=1` to `n-2`.\n\n    # Calculate the base angle unit: 180 / n\n    angle_unit = 180.0 / n\n\n    # We are looking for an integer `k_arc` (from 1 to n-2) such that\n    # `k_arc * angle_unit` is closest to `a`.\n    # This means `k_arc` should be close to `a / angle_unit`.\n\n    target_k_arc_float = a / angle_unit\n\n    # Consider the two integer `k_arc` values closest to `target_k_arc_float`:\n    # floor(target_k_arc_float) and ceil(target_k_arc_float).\n\n    # Candidate 1: floor(target_k_arc_float)\n    k_arc1 = int(target_k_arc_float)\n\n    # Candidate 2: ceil(target_k_arc_float)\n    k_arc2 = k_arc1 + 1\n\n    # Ensure k_arc values are within the valid range [1, n-2]\n    # The smallest possible angle is 1 * angle_unit, which corresponds to k_arc=1.\n    # The largest possible angle is (n-2) * angle_unit, which corresponds to k_arc=n-2.\n\n    best_diff = float('inf')\n    best_k_arc = -1\n\n    # Check k_arc1\n    if 1 <= k_arc1 <= n - 2:\n        current_angle = k_arc1 * angle_unit\n        current_diff = abs(current_angle - a)\n        best_diff = current_diff\n        best_k_arc = k_arc1\n\n    # Check k_arc2\n    if 1 <= k_arc2 <= n - 2:\n        current_angle = k_arc2 * angle_unit\n        current_diff = abs(current_angle - a)\n        if current_diff < best_diff:\n            best_diff = current_diff\n            best_k_arc = k_arc2\n        elif current_diff == best_diff:\n            # If differences are equal, any is fine. We can prefer the smaller k_arc.\n            # Since k_arc1 is smaller than k_arc2, if best_k_arc is still k_arc1, we keep it.\n            # If best_k_arc was -1 (meaning k_arc1 was invalid), we take k_arc2.\n            # If k_arc1 was valid and k_arc2 has same diff, we keep k_arc1.\n            # So no change needed here if best_k_arc is already set and diffs are equal.\n            pass # Or explicitly: if k_arc1 == -1 and k_arc2 != -1, best_k_arc = k_arc2 (but this is handled by initial logic)\n\n    # Edge case: If target_k_arc_float is less than 1, k_arc1 will be 0 or less.\n    # If target_k_arc_float is greater than n-2, k_arc1 will be n-2 or more.\n    # In these cases, one of the candidates might be out of bounds.\n    # The loop below ensures we pick the valid k_arc closest to the boundary.\n\n    # If best_k_arc is still -1, it means both k_arc1 and k_arc2 were out of bounds.\n    # This implies `a` is either very small (so `target_k_arc_float < 1`)\n    # or very large (so `target_k_arc_float > n-2`).\n    # In such cases, we should pick the closest valid boundary value.\n    if best_k_arc == -1:\n        # If 'a' is very small, pick k_arc=1 (smallest possible angle)\n        if target_k_arc_float < 1:\n            best_k_arc = 1\n        # If 'a' is very large, pick k_arc=n-2 (largest possible angle)\n        elif target_k_arc_float > n - 2:\n            best_k_arc = n - 2\n        # This case should not be reached if target_k_arc_float is within [1, n-2]\n        # and k_arc1/k_arc2 were checked.\n        # It could happen if n=3, then n-2=1. So k_arc can only be 1.\n        # In this specific case, k_arc1 might be 0, k_arc2 might be 1.\n        # The above logic correctly handles n=3:\n        # If n=3, n-2=1. Valid k_arc is only 1.\n        # angle_unit = 180/3 = 60.\n        # Only possible angle is 60 degrees.\n        # target_k_arc_float = a / 60.\n        # If a=15, target_k_arc_float = 0.25. k_arc1=0, k_arc2=1.\n        # k_arc1=0 is invalid. k_arc2=1 is valid. best_k_arc=1. Correct.\n        # If a=100, target_k_arc_float = 1.66. k_arc1=1, k_arc2=2.\n        # k_arc1=1 is valid. k_arc2=2 is invalid. best_k_arc=1. Correct.\n\n    # The chosen k_arc represents (v3 - v2) in the 0-indexed system\n    # or (v3 - v1) in the 1-indexed system if v2 is the next vertex.\n    # With v1=1, v2=2, v3 is `k_arc + 2`.\n    v1 = 1\n    v2 = 2\n    v3 = best_k_arc + 2\n\n    sys.stdout.write(f\"{v1} {v2} {v3}\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 729,
        "completion_token_count": 1671,
        "thoughts_token_count": 804
    }
}