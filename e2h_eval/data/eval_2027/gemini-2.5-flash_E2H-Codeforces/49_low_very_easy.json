{
    "start": 1758284946.2549508,
    "end": 1758285063.8016706,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:31 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**The Mushroom Strife: A Graph-Based Constraint Satisfaction Problem**\n\nOkay, so I need to write a Python script for this \"Mushroom Strife\" problem.  The core of it is understanding the constraints and finding a valid assignment of mushroom counts to lawns.  We're given a graph where nodes are lawns and edges represent roads with GCD and LCM information.  The goal is to find mushroom counts for each lawn, all integers between 1 and 10^6, that satisfy these GCD/LCM constraints on connected lawns. If no valid assignment exists, we need to report that.\n\nFirst, I need to make sure I *understand* the core math: the relationship between GCD, LCM, and the mushroom counts.  The key is realizing that `GCD(a, b) * LCM(a, b) = a * b`.  This, coupled with the fact that `GCD(a,b)` divides both a and b, and both a and b divide `LCM(a, b)`, gives me the fundamental tools.  This also mean that if `l % g != 0`, then no solution exist.\n\nGiven `g` (GCD) and `l` (LCM) for an edge, I can deduce that the product of the two lawn values must be `g * l`.  I can write the lawn values as `g*x` and `g*y`, and then I can deduce that `x*y = l/g`.  This reduces the problem to finding coprime integers `x` and `y` that multiply to `l/g`.  If I find these `x` and `y`, then I can calculate the values for the connected lawns.  The check for invalid solutions is that the values must be between 1 and 10^6. This suggests that I will have to find the prime factors of the `l/g`.\n\nNow, representing this as a graph problem is clear.  Each edge imposes a constraint between the mushroom counts of its connected lawns.  I'm thinking I can use this prime factorization idea to efficiently manage these constraints, and somehow use the graph structure to propagate assignments and handle conflicts.  The key is to leverage the prime factorizations to break down the GCD/LCM relationship into manageable components. Specifically, I can represent each value as a product of prime powers and see how the GCD and LCM influence the exponents of those primes.  I'm also considering backtracking to handle the case when I encounter invalid choices.  I'll start building the script focusing on the prime factorization logic and the constraint checking.\n",
    "response": "The problem asks us to assign a number of mushrooms (an integer between 1 and 10^6) to each of `n` lawns, given `m` roads. For each road connecting two lawns, we are given the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on those two lawns. We need to find any valid assignment or report if none exists.\n\n**Key Properties of GCD and LCM:**\nFor any two positive integers `a` and `b`, the following properties hold:\n1. `GCD(a, b) * LCM(a, b) = a * b`\n2. `GCD(a, b)` must divide both `a` and `b`.\n3. `a` must divide `LCM(a, b)`, and `b` must divide `LCM(a, b)`.\n\nFrom property 1, if we are given `g = GCD(a, b)` and `l = LCM(a, b)`, then `a * b = g * l`.\nAlso, it must be true that `l` is divisible by `g`. If `l % g != 0` for any road, then no such `a, b` exist, and we can immediately report \"NO\".\n\nLet `a = g * x` and `b = g * y` for some integers `x` and `y`. For `g` to be the *greatest* common divisor, `x` and `y` must be coprime (i.e., `GCD(x, y) = 1`).\nSubstituting these into `a * b = g * l`:\n`(g * x) * (g * y) = g * l`\n`g^2 * x * y = g * l`\n`g * x * y = l`\n`x * y = l / g`\n\nLet `P = l / g`. So, for each road `(u, v)` with given `g` and `l`, we need to find `v_u` and `v_v` such that:\n1. `v_u = g * x`\n2. `v_v = g * y`\n3. `x * y = P`\n4. `GCD(x, y) = 1`\n5. `1 <= v_u, v_v <= 10^6`\n\n**Strategy: Iterative Assignment and Constraint Propagation**\n\n1.  **Initial Checks:**\n    *   For each road `(u, v, g, l)`:\n        *   If `l % g != 0`, output \"NO\" and exit.\n        *   If `g > 10^6` or `l > 10^6`, output \"NO\" and exit (since `g <= a, b <= l`, this implies `a, b` would be out of range).\n    *   Initialize `ans[i]` for all lawns `i` to 0 (meaning unknown).\n    *   Initialize `adj[i]` as a list of `(neighbor, g, l)` for each lawn `i`.\n\n2.  **Handle Isolated Lawns:**\n    *   If `n > 0` and `m = 0` (no roads), any valid assignment will do, e.g., `ans[i] = 1` for all `i`. Output \"YES\" and `1 1 ... 1`.\n\n3.  **Queue for Processing:**\n    *   Use a queue (`q`) to store lawns whose mushroom count has been determined and needs to propagate constraints to neighbors.\n    *   For each lawn `i` that is connected to at least one road:\n        *   Initialize `ans[i]` to `1`. This is a valid starting value (it's the smallest possible, and will be updated if necessary). Add `i` to `q`.\n    *   If `n > 0` and there are lawns not connected to any road (i.e., `m > 0` but some lawns have degree 0), initialize their `ans[i]` to `1`.\n\n4.  **Breadth-First Search (BFS) / Propagation:**\n    *   While `q` is not empty:\n        *   Dequeue `u`. Let `val_u = ans[u]`.\n        *   For each neighbor `v` connected by a road with `g_uv` and `l_uv`:\n            *   If `ans[v]` is 0 (meaning `v` is unassigned or its value is not yet stable based on `u`):\n                *   Calculate `P = l_uv / g_uv`.\n                *   We know `val_u = g_uv * x` and `val_v = g_uv * y` where `x * y = P` and `GCD(x, y) = 1`.\n                *   This implies `val_u` must be a multiple of `g_uv`. If `val_u % g_uv != 0`, this is an inconsistency. The current `ans[u]` is invalid.\n                *   Also, `val_u` must divide `l_uv`. If `l_uv % val_u != 0`, this is an inconsistency.\n                *   From `val_u = g_uv * x`, we get `x = val_u / g_uv`.\n                *   Then `y = P / x = (l_uv / g_uv) / (val_u / g_uv) = l_uv / val_u`.\n                *   Calculate `new_val_v = g_uv * y = g_uv * (l_uv / val_u)`.\n                *   **Consistency Check:**\n                    *   `new_val_v` must be between 1 and 10^6. If not, output \"NO\".\n                    *   `GCD(x, y)` must be 1. That is, `GCD(val_u / g_uv, new_val_v / g_uv)` must be 1. If not, output \"NO\".\n                *   Assign `ans[v] = new_val_v`. Enqueue `v`.\n            *   If `ans[v]` is not 0 (meaning `v` is already assigned):\n                *   This means we have two values for `v` derived from different paths, or `u` is propagating an update to an already processed `v`.\n                *   We must check for consistency: `GCD(val_u, ans[v])` must be `g_uv` and `LCM(val_u, ans[v])` must be `l_uv`.\n                *   If `GCD(val_u, ans[v]) != g_uv` or `(val_u * ans[v]) // GCD(val_u, ans[v]) != l_uv`, output \"NO\" and exit.\n\n5.  **Final Check and Output:**\n    *   After the BFS, all lawns should have an assigned value. If any `ans[i]` is still 0, it means that lawn was not reachable from any initial assignment (e.g., if `n > 0` and `m=0`, but we only put `1` in queue for connected nodes - this case should be covered by step 2). For such lawns, assign `ans[i] = 1`.\n    *   Output \"YES\".\n    *   Print `ans[0], ans[1], ..., ans[n-1]`.\n\n**Optimization for GCD and LCM Calculation:**\nThe `math.gcd` function is efficient. For LCM, `lcm(a, b) = (a * b) // gcd(a, b)`. Be careful with potential overflow if `a * b` exceeds standard integer limits before division, but here `a, b <= 10^6`, so `a * b` can be up to `10^12`, which fits in Python's arbitrary precision integers.\n\n**Example Walkthrough (from problem description):**\nInput:\n`3 2`\n`3 2 1 2`\n`3 1 1 10`\n\n1.  `n=3, m=2`.\n2.  Road 1: `u=2, v=1, g=1, l=2`. `l%g == 0`.\n3.  Road 2: `u=2, v=0, g=1, l=10`. `l%g == 0`. (Note: problem uses 1-indexed, convert to 0-indexed for array)\n    `adj = [[] for _ in range(n)]`\n    `adj[2].append((1, 1, 2))`\n    `adj[1].append((2, 1, 2))`\n    `adj[2].append((0, 1, 10))`\n    `adj[0].append((2, 1, 10))`\n4.  `ans = [0, 0, 0]`\n5.  `q = collections.deque()`\n    Lawns 0, 1, 2 are all connected.\n    Set `ans[0]=1`, `q.append(0)`.\n    (We could pick any connected node to start. Let's use 0 as an example.)\n\nIteration 1:\n    `u = 0`, `val_u = ans[0] = 1`.\n    Neighbor `v = 2` (edge `(0, 2, g=1, l=10)`):\n        `ans[2]` is 0.\n        `P = l/g = 10/1 = 10`.\n        `val_u = 1`. `g_u2 = 1`. `x = val_u / g_u2 = 1/1 = 1`.\n        `y = P / x = 10 / 1 = 10`.\n        `new_val_2 = g_u2 * y = 1 * 10 = 10`.\n        `1 <= 10 <= 10^6`. Valid.\n        `GCD(x, y) = GCD(1, 10) = 1`. Valid.\n        `ans[2] = 10`. `q.append(2)`.\n    `ans` is now `[1, 0, 10]`. `q` is `deque([2])`.\n\nIteration 2:\n    `u = 2`, `val_u = ans[2] = 10`.\n    Neighbor `v = 1` (edge `(2, 1, g=1, l=2)`):\n        `ans[1]` is 0.\n        `P = l/g = 2/1 = 2`.\n        `val_u = 10`. `g_21 = 1`. `x = val_u / g_21 = 10/1 = 10`.\n        `y = P / x = 2 / 10`. This is not an integer! `val_u % g_21` is 0, but `l_21 % val_u` is not 0 (`2 % 10 != 0`). This indicates an inconsistency.\n        The current `ans[0]=1` leads to an invalid assignment for `ans[2]` and `ans[1]`.\n        So, our initial guess `ans[0]=1` was not good. We need to handle this.\n\n**Revised Strategy for Initial Guess and Inconsistency:**\nThe initial guess `ans[i]=1` for any connected node might be too restrictive.\nA better approach is to consider that `v_u` must be a multiple of `g_uv` and `v_v` must be a multiple of `g_uv`.\nAlso, `l_uv` must be a multiple of `v_u` and `v_v`.\n\nThis means for any node `u`, its value `v_u` must be:\n1. A multiple of `g_ui` for all neighbors `i`.\n2. A divisor of `l_ui` for all neighbors `i`.\n\nSo, `v_u` must be a multiple of `LCM(g_u1, g_u2, ...)` and a divisor of `GCD(l_u1, l_u2, ...)`.\nLet `min_mult_u = LCM(g_u1, g_u2, ...)` and `max_div_u = GCD(l_u1, l_u2, ...)`.\nThen `v_u` must be of the form `k * min_mult_u` and `k * min_mult_u` must divide `max_div_u`.\nThis implies `min_mult_u` must divide `max_div_u`. If not, output \"NO\".\nThe smallest possible value for `v_u` is `min_mult_u`. The largest is `max_div_u`.\nIf `min_mult_u` is greater than `max_div_u`, output \"NO\".\n\nLet's refine the initialization:\n1.  **Pre-calculate bounds for each node:**\n    *   For each node `i`, initialize `lower_bound[i] = 1` and `upper_bound[i] = 10^6`.\n    *   For each road `(u, v, g, l)`:\n        *   If `l % g != 0`, output \"NO\".\n        *   `lower_bound[u] = LCM(lower_bound[u], g)`\n        *   `upper_bound[u] = GCD(upper_bound[u], l)`\n        *   Do the same for `v`.\n        *   If at any point `lower_bound[i] > upper_bound[i]`, output \"NO\".\n        *   If `lower_bound[i] > 10^6` or `upper_bound[i] < 1`, output \"NO\". (Upper bound being < 1 is impossible if it starts at 10^6 and takes GCD with values >= 1).\n    *   This gives us a range `[lower_bound[i], upper_bound[i]]` for each `ans[i]`.\n    *   Initialize `ans[i]` to `lower_bound[i]`. Add all `i` to `q`.\n\n2.  **BFS Propagation (with refined consistency check):**\n    *   While `q` is not empty:\n        *   Dequeue `u`. Let `val_u = ans[u]`.\n        *   For each neighbor `v` connected by `(u, v, g_uv, l_uv)`:\n            *   Expected `ans[v]` based on `val_u`: `expected_val_v = l_uv // val_u * g_uv`.\n            *   **Consistency Checks for `val_u`:**\n                *   `val_u % g_uv != 0` OR `l_uv % val_u != 0` OR `(l_uv // val_u * g_uv) % g_uv != 0` (this is always true if `l_uv % val_u == 0`) -> output \"NO\".\n                *   `GCD(val_u // g_uv, expected_val_v // g_uv) != 1` -> output \"NO\".\n                *   `expected_val_v > 10^6` or `expected_val_v < 1` -> output \"NO\".\n            *   **Update `ans[v]`:**\n                *   If `ans[v]` is different from `expected_val_v`:\n                    *   If `ans[v]` is 0 (uninitialized): `ans[v] = expected_val_v`. Enqueue `v`.\n                    *   If `ans[v]` is not 0 but `ans[v] != expected_val_v`: This is a conflict. Output \"NO\". (This should ideally not happen if initial bounds were calculated correctly and we always propagate the \"correct\" value, but it's a safety check).\n\nThis refined strategy seems more robust. The initial `ans[i] = lower_bound[i]` sets a concrete value, and then we check if this value is consistent with all neighbors. If `ans[i]` needs to change, it means the initial `lower_bound[i]` was too small, or there's a conflict.\n\nLet's re-trace the example with the refined strategy:\n`3 2`\n`3 2 1 2` (0-indexed: `2 1 1 2`)\n`3 1 1 10` (0-indexed: `2 0 1 10`)\n\n1.  `ans = [0, 0, 0]`.\n    `lower_bound = [1, 1, 1]`\n    `upper_bound = [10^6, 10^6, 10^6]`\n    `adj = [ [(2, 1, 10)], [(2, 1, 2)], [(1, 1, 2), (0, 1, 10)] ]`\n\n2.  Process roads to update bounds:\n    *   Edge `(2, 1, g=1, l=2)`:\n        `lower_bound[2] = LCM(1, 1) = 1`. `upper_bound[2] = GCD(10^6, 2) = 2`.\n        `lower_bound[1] = LCM(1, 1) = 1`. `upper_bound[1] = GCD(10^6, 2) = 2`.\n    *   Edge `(2, 0, g=1, l=10)`:\n        `lower_bound[2] = LCM(lower_bound[2]=1, 1) = 1`. `upper_bound[2] = GCD(upper_bound[2]=2, 10) = 2`.\n        `lower_bound[0] = LCM(lower_bound[0]=1, 1) = 1`. `upper_bound[0] = GCD(upper_bound[0]=10^6, 10) = 10`.\n\n    Current bounds:\n    `lower_bound = [1, 1, 1]`\n    `upper_bound = [10, 2, 2]`\n    All `lower_bound[i] <= upper_bound[i]`. All within `[1, 10^6]`.\n\n3.  Initialize `ans` with `lower_bound` and `q`:\n    `ans = [1, 1, 1]`\n    `q = deque([0, 1, 2])`\n\nIteration 1:\n    `u = 0`, `val_u = ans[0] = 1`.\n    Neighbor `v = 2` (edge `(0, 2, g=1, l=10)`):\n        `expected_val_2 = l_02 // val_u * g_02 = 10 // 1 * 1 = 10`.\n        Checks:\n            `val_u % g_02 == 1 % 1 == 0`. OK.\n            `l_02 % val_u == 10 % 1 == 0`. OK.\n            `GCD(val_u // g_02, expected_val_2 // g_02) = GCD(1//1, 10//1) = GCD(1, 10) = 1`. OK.\n            `1 <= 10 <= 10^6`. OK.\n        `ans[2]` is `1`. `expected_val_2` is `10`. They are different.\n        This is a conflict. Output \"NO\".\n\nThe example output for this case is `YES\\n5 1 2`. My logic led to \"NO\". What went wrong?\nThe `lower_bound` calculation `LCM(g_u1, g_u2, ...)` and `upper_bound` calculation `GCD(l_u1, l_u2, ...)` only constrain the value `v_u` to be *some* multiple of `g` and *some* divisor of `l`. They don't guarantee that the `x, y` pair for each edge will be coprime.\n\nThe issue is that `ans[i]` is not necessarily `lower_bound[i]`. `ans[i]` can be any valid value in `[lower_bound[i], upper_bound[i]]` that satisfies all constraints.\nIf `ans[i]` is fixed, then `ans[j]` for a neighbor `j` is uniquely determined: `ans[j] = (l_ij * g_ij) / ans[i]`. (Using `a*b = g*l` and `a=ans[i]`).\nThe problem is that `ans[i]` might not have a unique value. We need to find *any* valid assignment.\n\nThe problem states \"restore any one\". This suggests we might need to try different values.\nHowever, `a, b` values are `g*x` and `g*y` where `x*y = l/g` and `GCD(x,y)=1`.\nThis means `a` and `b` must be of the form `g * p_1^{e_1} * p_2^{e_2} ...` where `p_i` are prime factors of `l/g`.\nThe exponents `e_i` are distributed between `x` and `y`.\n\nLet's consider the prime factorization of `P = l/g`. `P = p_1^{a_1} * p_2^{a_2} * ... * p_k^{a_k}`.\nThen `x` must be `p_1^{b_1} * ... * p_k^{b_k}` and `y` must be `p_1^{c_1} * ... * p_k^{c_k}`.\nFor `x * y = P`, we need `b_j + c_j = a_j` for all `j`.\nFor `GCD(x, y) = 1`, we need `min(b_j, c_j) = 0` for all `j`.\nThis means for each prime factor `p_j`, either `x` gets all of `p_j^{a_j}` (i.e., `b_j = a_j, c_j = 0`) or `y` gets all of `p_j^{a_j}` (i.e., `b_j = 0, c_j = a_j`).\nSo, `x` must be a product of some `p_j^{a_j}` factors, and `y` must be the product of the remaining `p_j^{a_j}` factors.\nThis means `x` must be a divisor of `P` such that `GCD(x, P/x) = 1`.\nSuch divisors are called \"unitary divisors\" or \"coprime divisors\".\nThere are `2^k` such divisors `x` if `P` has `k` distinct prime factors.\n\nFor each edge `(u, v)` with `g, l`, `P = l/g`. The possible values for `v_u` are `g * x` where `x` is a coprime divisor of `P`.\nThis means `v_u` must be of the form `g * (product of some prime powers of P)`.\nAnd `v_v` will be `g * (product of the remaining prime powers of P)`.\n\nThis looks like a 2-coloring problem on the prime factors. For each distinct prime factor `p_j^{a_j}` of `P`, it must either go entirely to `x` or entirely to `y`.\n\nThis is still complex. Let's reconsider the example `YES\\n5 1 2` for the input `3 2 \\n3 2 1 2 \\n3 1 1 10`.\n(0-indexed: `v_2, v_1` has `g=1, l=2`. `v_2, v_0` has `g=1, l=10`.)\nOutput: `v_0=5, v_1=1, v_2=2`.\nLet's check this:\n*   Edge `(2, 1)`: `v_2=2, v_1=1`. `GCD(2, 1)=1`. `LCM(2, 1)=2`. Matches `g=1, l=2`.\n*   Edge `(2, 0)`: `v_2=2, v_0=5`. `GCD(2, 5)=1`. `LCM(2, 5)=10`. Matches `g=1, l=10`.\nAll checks pass. All values are within `[1, 10^6]`.\n\nMy previous logic produced `NO` because it tried to start with `ans[0]=1` (from `lower_bound[0]=1`), which forced `ans[2]=10`.\nBut `ans[2]=10` is inconsistent with `(2, 1, g=1, l=2)` because `l_21=2` is not a multiple of `ans[2]=10`.\nThe correct `ans[0]=5` leads to `ans[2]=2` (`l_02 // ans[0] * g_02 = 10 // 5 * 1 = 2`).\nAnd `ans[2]=2` leads to `ans[1]=1` (`l_21 // ans[2] * g_21 = 2 // 2 * 1 = 1`).\nThis means the initial value for a node cannot be arbitrarily picked from its range. It must be consistent with all neighbors.\n\nWhat if we don't initialize `ans[i]` to `lower_bound[i]`? What if we initialize it to 0 and only assign when uniquely determined?\nThe issue is that `ans[i]` is not always uniquely determined.\n\nThis problem looks like a 2-SAT problem where each prime factor of `l/g` for an edge `(u, v)` has to be assigned to either `u` or `v`.\nLet `v_i = G_i * X_i` where `G_i` is the product of all `g` values for edges connected to `i`, and `X_i` is the remaining part.\nThis is getting complicated. \"Very easy question\" implies a simpler approach.\n\nA simpler approach:\nWhat if we assign `ans[i] = 1` to *all* nodes initially? This is a valid value for all nodes individually.\nThen, for each edge `(u, v, g, l)`:\nWe know `ans[u] * ans[v]` must be `g * l`.\nIf `ans[u]` and `ans[v]` are `1`, then `1 * 1 = 1`. If `g * l != 1`, we need to change them.\nThis is a standard constraint propagation problem.\n\nLet `ans[i]` be the current value for lawn `i`.\nWhen we process an edge `(u, v, g, l)`:\n1.  Check `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`.\n2.  If not, we need to adjust. How to adjust?\n    This is the tricky part. If `ans[u]` is changed, it affects all its neighbors.\n\nConsider the values of `a` and `b` in terms of prime factors.\n`a = product(p_k^{alpha_k})`, `b = product(p_k^{beta_k})`.\n`g = product(p_k^{min(alpha_k, beta_k)})`, `l = product(p_k^{max(alpha_k, beta_k)})`.\nFor each prime `p_k`:\n`min(alpha_k, beta_k)` must be the exponent of `p_k` in `g`.\n`max(alpha_k, beta_k)` must be the exponent of `p_k` in `l`.\n\nThis means for each prime `p_k`, we know exactly `alpha_k` and `beta_k` if `p_k` is a factor of `g` or `l`.\nIf `p_k` is a factor of `g`, then `min(alpha_k, beta_k) = exp_g(p_k)`.\nIf `p_k` is a factor of `l`, then `max(alpha_k, beta_k) = exp_l(p_k)`.\nIf `p_k` is a factor of both `g` and `l`, then `exp_g(p_k) <= exp_l(p_k)` must hold.\nIf `p_k` is a factor of `g` but not `l`, impossible (since `g` divides `l`).\nIf `p_k` is a factor of `l` but not `g`, then `exp_g(p_k) = 0`. So `min(alpha_k, beta_k) = 0`.\nThis means one of `alpha_k` or `beta_k` is 0, and the other is `exp_l(p_k)`.\n\nThis leads to a system of equations for exponents for each prime factor.\nFor each prime `p` that appears in any `g` or `l`:\nLet `exp[i][p]` be the exponent of `p` in `ans[i]`.\nFor an edge `(u, v, g, l)`:\n`min(exp[u][p], exp[v][p]) = exp_g(p)`\n`max(exp[u][p], exp[v][p]) = exp_l(p)`\nwhere `exp_g(p)` is the exponent of `p` in `g`, and `exp_l(p)` is the exponent of `p` in `l`.\n\nThis is a system of equations for `exp[i][p]` for each prime `p`.\nFor a fixed `p`:\nFor each edge `(u, v)`:\n`exp_u + exp_v = exp_g(p) + exp_l(p)` (since `a*b = g*l`)\n`exp_u` and `exp_v` must be `exp_g(p)` and `exp_l(p)` in some order, or `exp_g(p)` and `exp_l(p)` are not unique values for `min/max`.\nActually, `exp_u` and `exp_v` must be `exp_g(p)` and `exp_l(p)` only if `exp_g(p) != exp_l(p)`.\nIf `exp_g(p) == exp_l(p)`, then `exp_u = exp_v = exp_g(p)`. This is a fixed value.\n\nIf `exp_g(p) < exp_l(p)`:\nThen `exp[u][p]` and `exp[v][p]` must be `exp_g(p)` and `exp_l(p)` in some order.\nThis is a 2-coloring problem. For each prime `p`, and for each connected component of the graph:\nIf `exp_g(p) == exp_l(p)` for all edges in the component, then all nodes in the component have `exp[i][p] = exp_g(p)`.\nIf there's an edge `(u, v)` where `exp_g(p) < exp_l(p)`:\nThen one of `exp[u][p], exp[v][p]` must be `exp_g(p)` and the other `exp_l(p)`.\nThis sets up a relative constraint. If `exp[u][p]` is `exp_g(p)`, then `exp[v][p]` must be `exp_l(p)`. If `exp[u][p]` is `exp_l(p)`, then `exp[v][p]` must be `exp_g(p)`.\nThis is like assigning a \"parity\" to each node for each prime `p`.\nLet `diff_p = exp_l(p) - exp_g(p)`.\nWe can assign `exp[i][p] = exp_g(p) + offset[i][p] * diff_p`, where `offset[i][p]` is either 0 or 1.\nFor an edge `(u, v)` where `exp_g(p) < exp_l(p)`, we must have `offset[u][p] != offset[v][p]`.\nThis means all nodes in a connected component will alternate their `offset` values. This is a bipartite graph coloring problem.\nWe can pick an arbitrary node `s` in a component, set `offset[s][p] = 0`. Then run BFS/DFS to determine `offset` for all other nodes in the component.\nIf we find a conflict (e.g., an edge `(x, y)` where `exp_g(p) < exp_l(p)` but `offset[x][p]` and `offset[y][p]` are forced to be the same), then output \"NO\".\n\n**Algorithm using Prime Factorization and BFS:**\n\n1.  **Preprocessing Primes:**\n    *   Find all primes up to `sqrt(10^6) = 1000`. This is for factorizing numbers up to `10^6`.\n    *   For numbers `X` up to `10^6`, `get_prime_factors(X)` returns a dictionary `p -> exponent`.\n\n2.  **Initialize `ans` array:** `ans = [1] * n`. (This will store the final mushroom counts).\n    `final_exponents = [defaultdict(int) for _ in range(n)]`. This will store `p -> exponent` for each `ans[i]`.\n\n3.  **Process each edge `(u, v, g, l)`:**\n    *   If `l % g != 0`, print \"NO\", exit.\n    *   Factorize `g` and `l` into prime exponent maps: `factors_g`, `factors_l`.\n    *   For each prime `p` in `factors_g` or `factors_l`:\n        *   `exp_g_p = factors_g.get(p, 0)`\n        *   `exp_l_p = factors_l.get(p, 0)`\n        *   If `exp_g_p > exp_l_p`, print \"NO\", exit (GCD cannot have higher power than LCM).\n        *   Store these `(exp_g_p, exp_l_p)` requirements for `(u, v)` and `p`.\n        *   `constraints[u][v][p] = (exp_g_p, exp_l_p)`\n        *   `constraints[v][u][p] = (exp_g_p, exp_l_p)`\n\n4.  **Solve for each prime `p` independently:**\n    *   Create a list of all unique primes `all_primes` that appear in any `g` or `l`.\n    *   For each `p` in `all_primes`:\n        *   `current_exponents_for_p = [-1] * n` (stores `exp[i][p]`, -1 means unassigned).\n        *   `q = collections.deque()`\n        *   `visited = [False] * n`\n        *   Iterate `i` from `0` to `n-1`:\n            *   If `not visited[i]`:\n                *   If `i` has no edges involving `p` (i.e. `p` is not a factor of `g` or `l` for any edge connected to `i`), then `current_exponents_for_p[i] = 0`.\n                *   Else (node `i` is part of a component with constraints on `p`):\n                    *   Pick `i` as a starting node. Arbitrarily assign `current_exponents_for_p[i] = exp_g_p` (if `exp_g_p != exp_l_p` for *some* edge, otherwise it's fixed).\n                    *   A better way: Use a `fixed_val_for_p[i]` if `exp_g_p == exp_l_p` for all edges connected to `i`.\n                    *   **Correct approach for each prime `p`:**\n                        *   `state[node]` stores `(value, assigned_from_node_idx)`\n                        *   `q = deque()`\n                        *   `exp_i_p = [-1] * n` (exponent of `p` for node `i`)\n                        *   For `i` from `0` to `n-1`:\n                            *   If `exp_i_p[i] == -1` (unassigned):\n                                *   Start a BFS/DFS from `i`.\n                                *   `q.append(i)`\n                                *   `exp_i_p[i] = 0` (arbitrary choice for relative assignment). This means `ans[i]` contributes `p^0` to the `diff_p` part.\n                                *   While `q` is not empty:\n                                    *   `u = q.popleft()`\n                                    *   For each neighbor `v` of `u`:\n                                        *   If `p` is not a factor in `g_uv` or `l_uv`, continue (no constraint on `p` for this edge).\n                                        *   `g_exp, l_exp = constraints[u][v][p]`\n                                        *   If `g_exp == l_exp`:\n                                            *   If `exp_i_p[u] != g_exp`: (This means `exp_i_p[u]` was set to something other than `g_exp` by relative assignment. This is an absolute value check).\n                                                *   This is tricky. `exp_i_p[u]` is supposed to be the *offset* from `g_exp`.\n                                                *   The `exp[i][p]` values must be `g_exp` and `l_exp`.\n                                                *   Let's use `value[node]` for `exp[node][p]`.\n                                                *   `value = [-1] * n`\n                                                *   `q = deque()`\n                                                *   For `i` from `0` to `n-1`:\n                                                    *   If `value[i] == -1`:\n                                                        *   `value[i] = exp_g(p)` (initial guess, could be `exp_l(p)`).\n                                                        *   `q.append(i)`\n                                                        *   While `q` not empty:\n                                                            *   `u = q.popleft()`\n                                                            *   For each neighbor `v` of `u` with `(g_uv, l_uv)`:\n                                                                *   `g_exp, l_exp = constraints[u][v][p]`\n                                                                *   If `g_exp == l_exp`:\n                                                                    *   If `value[u] != g_exp`: print \"NO\", exit.\n                                                                    *   If `value[v] == -1`: `value[v] = g_exp`, `q.append(v)`.\n                                                                    *   Else if `value[v] != g_exp`: print \"NO\", exit.\n                                                                *   Else (`g_exp < l_exp`):\n                                                                    *   If `value[u]` is not `g_exp` or `l_exp`: print \"NO\", exit.\n                                                                    *   `expected_v_val = g_exp + l_exp - value[u]`\n                                                                    *   If `value[v] == -1`: `value[v] = expected_v_val`, `q.append(v)`.\n                                                                    *   Else if `value[v] != expected_v_val`: print \"NO\", exit.\n                                                                *   Finally, check if `value[u]` and `value[v]` are within `[0, MAX_EXPONENT]`.\n                                                                    `MAX_EXPONENT` is about `log2(10^6)` which is `~20`.\n\n5.  **Construct `ans` values:**\n    *   For each node `i`:\n        *   `ans[i] = 1`\n        *   For each prime `p` in `all_primes`:\n            *   `ans[i] *= (p ** value[i][p])`\n            *   If `ans[i] > 10^6`, print \"NO\", exit.\n\n6.  **Final check:**\n    *   For each edge `(u, v, g, l)`:\n        *   If `GCD(ans[u], ans[v]) != g` or `LCM(ans[u], ans[v]) != l`, print \"NO\", exit.\n\n7.  **Output:** Print \"YES\" and `ans` array.\n\nThis revised approach using prime factorization and BFS/DFS for each prime seems more robust.\nThe maximum value of any number is `10^6`. The maximum prime factor is `10^6`.\nThe number of distinct prime factors for numbers up to `10^6` is small (e.g., `2 * 3 * 5 * 7 * 11 * 13 * 17 = 510510`).\nThe number of primes up to `10^6` is `~78498`. We only care about primes that are factors of `g` or `l`.\nThe maximum exponent for a prime `p` in `10^6` is `log_p(10^6)`. For `p=2`, `2^19 = 524288`, `2^20 = 1048576`. So max exponent is around 19-20.\n\n**Helper `get_prime_factors(n)`:**\n```python\ndef get_prime_factors(n):\n    factors = {}\n    d = 2\n    temp = n\n    while d * d <= temp:\n        while temp % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp //= d\n        d += 1\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    return factors\n```\n\n**Complexity:**\n*   `get_prime_factors`: `sqrt(MAX_VAL)` per call. Max `2*M` calls. `2 * 10^5 * 1000 = 2 * 10^8` (too slow).\n    We need to factorize `g` and `l` for each edge. Total `2m` numbers. Max `10^6`.\n    Instead of re-factorizing, precompute primes up to `10^6` and use smallest prime factor (SPF) sieve.\n    Sieve up to `10^6` takes `O(MAX_VAL log log MAX_VAL)`.\n    Then factorizing any number `X` takes `O(log X)`.\n    So, `O(MAX_VAL log log MAX_VAL + M log MAX_VAL)`. This is feasible.\n\n*   `all_primes`: Max `~78498` primes up to `10^6`.\n*   For each prime `p`: BFS/DFS on `N` nodes and `M` edges. `O(N+M)`.\n*   Total for prime loops: `Num_Primes * (N+M)`. `78498 * (10^5 + 10^5) = 78498 * 2 * 10^5 = 1.5 * 10^{10}` (too slow).\n\nThe number of primes involved is not `all_primes` up to `10^6`. It's only primes that are factors of *any* `g` or `l`.\nThe maximum number of distinct prime factors for a number up to `10^6` is `~7` (for `2*3*5*7*11*13*17`).\nThe total number of distinct prime factors across all `2M` numbers `g, l` could be larger, but still much less than `78498`.\nThe sum of `omega(N)` (number of distinct prime factors) for `N <= 10^6` is `~10^6 * log log 10^6`.\nThe number of distinct primes `P_distinct` across all `2M` numbers is at most `2M * max_omega(10^6)`.\n`2 * 10^5 * 7 = 1.4 * 10^6`. Still too large.\n\nThe sum of `log(X)` for all `X` is `M log MAX_VAL`.\nThe total number of prime factors (with multiplicity) across all `2M` numbers is `sum(log(X))` which is `M * log(MAX_VAL)`.\nThe actual number of distinct primes that appear in any `g` or `l` is `P_total_distinct`. This can be at most `~78498`.\nThe critical observation must be that the graph for each prime `p` is *sparse*. We only need to run BFS for nodes connected by an edge where `p` is a factor of `g` or `l`.\nThe sum of `(N_p + M_p)` over all `p`, where `N_p` and `M_p` are nodes/edges relevant to `p`.\n`sum_p (N_p + M_p)` can be bounded by `sum_edges (num_distinct_factors(g_uv) + num_distinct_factors(l_uv))`.\nThis is `M * max_omega(10^6)`. `10^5 * 7 = 7 * 10^5`. This is feasible.\n\n**Revised Algorithm for Prime Factorization and BFS:**\n\n1.  **Sieve for SPF:** Precompute `spf[i]` (smallest prime factor of `i`) up to `10^6`.\n    `O(MAX_VAL log log MAX_VAL)`.\n2.  **`get_prime_factors(n)` using SPF:** `O(log n)`.\n3.  **Data Structures:**\n    *   `adj[u]` stores `(v, g, l)` tuples for edges.\n    *   `prime_to_edges` maps `p` to a list of `(u, v, g_val, l_val, edge_idx)` tuples.\n    *   `edge_constraints[edge_idx][p]` stores `(exp_g_p, exp_l_p)`.\n    *   `all_primes_set`: a set of all unique primes encountered.\n    *   `ans = [1] * n`\n    *   `final_exponents[i][p]` stores the exponent of `p` in `ans[i]`.\n\n4.  **Process edges to populate `edge_constraints` and `all_primes_set`:**\n    *   For each edge `(u, v, g, l)` (0-indexed, `edge_idx`):\n        *   If `l % g != 0`, print \"NO\", exit.\n        *   `factors_g = get_prime_factors(g)`\n        *   `factors_l = get_prime_factors(l)`\n        *   `current_edge_primes = set()`\n        *   For `p, exp_g_p` in `factors_g.items()`:\n            `exp_l_p = factors_l.get(p, 0)`\n            If `exp_g_p > exp_l_p`, print \"NO\", exit.\n            `edge_constraints[edge_idx][p] = (exp_g_p, exp_l_p)`\n            `all_primes_set.add(p)`\n            `current_edge_primes.add(p)`\n        For `p, exp_l_p` in `factors_l.items()`:\n            If `p` not in `current_edge_primes`:\n                `exp_g_p = factors_g.get(p, 0)`\n                `edge_constraints[edge_idx][p] = (exp_g_p, exp_l_p)`\n                `all_primes_set.add(p)`\n        `adj[u].append((v, edge_idx))`\n        `adj[v].append((u, edge_idx))`\n\n5.  **Solve for exponents for each prime `p`:**\n    *   For `p` in `all_primes_set`:\n        *   `node_p_exponent = [-1] * n` (exponent of `p` for each node, -1 means unassigned)\n        *   `q = collections.deque()`\n        *   For `start_node` from `0` to `n-1`:\n            *   If `node_p_exponent[start_node] == -1`: (start a new component for this prime)\n                *   `node_p_exponent[start_node] = 0` (arbitrary choice for relative assignment to `exp_g(p)` or `exp_l(p)`)\n                *   `q.append(start_node)`\n                *   While `q` not empty:\n                    *   `u = q.popleft()`\n                    *   For `v, edge_idx` in `adj[u]`:\n                        *   If `p` not in `edge_constraints[edge_idx]`: continue (this edge doesn't constrain `p`)\n                        *   `g_exp, l_exp = edge_constraints[edge_idx][p]`\n                        *   If `g_exp == l_exp`:\n                            *   If `node_p_exponent[u] != g_exp`: print \"NO\", exit. (Conflict with absolute value)\n                            *   If `node_p_exponent[v] == -1`: `node_p_exponent[v] = g_exp`, `q.append(v)`.\n                            *   Else if `node_p_exponent[v] != g_exp`: print \"NO\", exit.\n                        *   Else (`g_exp < l_exp`):\n                            *   `val_u = node_p_exponent[u]`\n                            *   `expected_v_val = g_exp + l_exp - val_u`\n                            *   If `val_u != g_exp` and `val_u != l_exp`: print \"NO\", exit. (Conflict with required values)\n                            *   If `expected_v_val != g_exp` and `expected_v_val != l_exp`: print \"NO\", exit. (Should not happen if `val_u` is valid)\n                            *   If `node_p_exponent[v] == -1`: `node_p_exponent[v] = expected_v_val`, `q.append(v)`.\n                            *   Else if `node_p_exponent[v] != expected_v_val`: print \"NO\", exit.\n                *   After BFS for component: For `i` in component, `final_exponents[i][p] = node_p_exponent[i]`.\n                *   Check `final_exponents[i][p] > 19` (max exponent for `2` is `19` for `10^6`). If so, `ans[i]` will exceed `10^6`, print \"NO\", exit.\n\n6.  **Construct `ans` values:**\n    *   For `i` from `0` to `n-1`:\n        *   `current_val = 1`\n        *   For `p, exp` in `final_exponents[i].items()`:\n            `current_val *= (p ** exp)`\n            If `current_val > 10^6`: print \"NO\", exit.\n        `ans[i] = current_val`\n\n7.  **Final Check (Optional but good for safety):**\n    *   For each edge `(u, v, g_orig, l_orig)`:\n        *   If `math.gcd(ans[u], ans[v]) != g_orig` or `(ans[u] * ans[v]) // math.gcd(ans[u], ans[v]) != l_orig`: print \"NO\", exit.\n\n8.  **Output:** Print \"YES\" and `ans` array.\n\nThis detailed plan seems correct and handles all constraints. The `node_p_exponent` initial value `0` (or `exp_g(p)`) is crucial. If `exp_g(p) < exp_l(p)` for an edge, then `node_p_exponent[u]` and `node_p_exponent[v]` must be `exp_g(p)` and `exp_l(p)` in some order. If we fix `node_p_exponent[start_node] = exp_g(p)`, then neighbors are fixed. If this leads to a contradiction, it means `start_node` should have been `exp_l(p)`. If both lead to contradiction, then \"NO\".\nThe problem states \"any one\", so if there are multiple choices for `start_node` (e.g., `exp_g(p)` vs `exp_l(p)`), we can just pick one. If it leads to \"NO\", we should try the other. But this would be backtracking. A simpler way is to make `node_p_exponent[i]` store the *absolute* exponent value, not an offset.\n\nLet's refine step 5 for `node_p_exponent`:\n*   `node_p_exponent = [-1] * n`\n*   `q = collections.deque()`\n*   For `start_node` from `0` to `n-1`:\n    *   If `node_p_exponent[start_node] == -1`: (unassigned, start a new component)\n        *   `possible_values = set()`\n        *   For `v, edge_idx` in `adj[start_node]`:\n            If `p` in `edge_constraints[edge_idx]`:\n                `g_exp, l_exp = edge_constraints[edge_idx][p]`\n                if `g_exp == l_exp`:\n                    `possible_values.add(g_exp)`\n                else: # `g_exp < l_exp`\n                    `possible_values.add(g_exp)`\n                    `possible_values.add(l_exp)`\n        If `len(possible_values) == 0`:\n            `node_p_exponent[start_node] = 0` (node is isolated for prime `p`, exponent 0)\n            `q.append(start_node)`\n        Else:\n            `initial_val = min(possible_values)` (try smallest possible value)\n            `node_p_exponent[start_node] = initial_val`\n            `q.append(start_node)`\n            `# Store component nodes to potentially retry if this path fails`\n            `component_nodes = []`\n\n        *   BFS loop:\n            *   `u = q.popleft()`\n            *   `component_nodes.append(u)`\n            *   For `v, edge_idx` in `adj[u]`:\n                *   If `p` not in `edge_constraints[edge_idx]`: continue\n                *   `g_exp, l_exp = edge_constraints[edge_idx][p]`\n                *   `val_u = node_p_exponent[u]`\n                *   If `g_exp == l_exp`:\n                    *   If `val_u != g_exp`: print \"NO\", exit.\n                    *   `expected_v_val = g_exp`\n                Else (`g_exp < l_exp`):\n                    *   If `val_u != g_exp` and `val_u != l_exp`: print \"NO\", exit.\n                    *   `expected_v_val = g_exp + l_exp - val_u`\n                *   If `node_p_exponent[v] == -1`:\n                    `node_p_exponent[v] = expected_v_val`\n                    `q.append(v)`\n                Else if `node_p_exponent[v] != expected_v_val`:\n                    print \"NO\", exit.\n                *   If `node_p_exponent[v] > 19` (or `log_2(10^6)`): print \"NO\", exit.\n\nThis BFS needs to be careful. If `node_p_exponent[start_node]` is chosen, and it leads to a contradiction, we should try the other option (`max(possible_values)`). This means we need to save the state of `node_p_exponent` for the component, or use a DFS with backtracking. Since \"any one\" is okay, we can just try one, and if it fails, the whole problem fails. This is because if a valid solution exists, there must be *some* valid choice for `start_node`. If our choice leads to \"NO\", it means either no solution exists, or our choice was wrong. But if the problem guarantees a solution if one exists, then one choice should be sufficient. The example `5 1 2` shows that the \"smallest possible\" value for a node might not be the correct one.\n\nLet's assume the \"smallest possible value\" strategy for `start_node` is sufficient.\nFor `p` in `all_primes_set`:\n    `node_p_exponent = [-1] * n`\n    `q = collections.deque()`\n    `component_nodes = []` # To reset if a choice leads to conflict\n    `component_root = -1` # To keep track of the root of the current component for `p`\n\n    For `i` from `0` to `n-1`:\n        If `node_p_exponent[i] == -1`: # Start a new component for this prime\n            `component_root = i`\n            `component_nodes = []`\n            `q.append(i)`\n            \n            `# Determine initial value for component_root`\n            `possible_vals_for_root = set()`\n            `constrained_by_edges = False`\n            For `v_neighbor, edge_idx` in `adj[i]`:\n                If `p` in `edge_constraints[edge_idx]`:\n                    `constrained_by_edges = True`\n                    `g_exp, l_exp = edge_constraints[edge_idx][p]`\n                    `possible_vals_for_root.add(g_exp)`\n                    `possible_vals_for_root.add(l_exp)`\n            \n            `initial_root_val_candidates = []`\n            If `not constrained_by_edges`:\n                `initial_root_val_candidates.append(0)` # Isolated node for prime p\n            Else:\n                `initial_root_val_candidates = sorted(list(possible_vals_for_root))`\n\n            `found_solution_for_component = False`\n            For `initial_val in initial_root_val_candidates`:\n                `temp_node_p_exponent = list(node_p_exponent)` # Copy current state\n                `temp_q = deque([i])`\n                `temp_node_p_exponent[i] = initial_val`\n                `current_component_nodes_in_bfs = [i]`\n                `component_valid = True`\n\n                While `temp_q`:\n                    `u = temp_q.popleft()`\n                    For `v, edge_idx` in `adj[u]`:\n                        If `p` not in `edge_constraints[edge_idx]`: continue\n                        `g_exp, l_exp = edge_constraints[edge_idx][p]`\n                        `val_u = temp_node_p_exponent[u]`\n\n                        `expected_v_val = -1`\n                        If `g_exp == l_exp`:\n                            If `val_u != g_exp`:\n                                `component_valid = False`\n                                break\n                            `expected_v_val = g_exp`\n                        Else: # `g_exp < l_exp`\n                            If `val_u != g_exp` and `val_u != l_exp`:\n                                `component_valid = False`\n                                break\n                            `expected_v_val = g_exp + l_exp - val_u`\n                        \n                        If `expected_v_val > 19`: # Max exponent for 2 in 10^6\n                            `component_valid = False`\n                            break\n\n                        If `temp_node_p_exponent[v] == -1`:\n                            `temp_node_p_exponent[v] = expected_v_val`\n                            `temp_q.append(v)`\n                            `current_component_nodes_in_bfs.append(v)`\n                        Else if `temp_node_p_exponent[v] != expected_v_val`:\n                            `component_valid = False`\n                            break\n                    If `not component_valid`: break\n                \n                If `component_valid`:\n                    `found_solution_for_component = True`\n                    For node in `current_component_nodes_in_bfs`:\n                        `node_p_exponent[node] = temp_node_p_exponent[node]`\n                        `final_exponents[node][p] = temp_node_p_exponent[node]`\n                    break # Found a valid assignment for this component\n            \n            If `not found_solution_for_component`:\n                print(\"NO\")\n                return # Exit the function\n\nThis looks much better. The backtracking on `initial_val` for component roots is necessary if there are multiple choices.\n\nFinal check on `MAX_EXPONENT`: `2^19 = 524288`, `2^20 = 1048576`. So max exponent is 19. If `p=3`, `3^12 = 531441`, `3^13 = 1594323`. So max exponent is 12. Using 19 as a general upper bound for `log_p(10^6)` is fine.\n\n```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\n# Constants\nMAX_VAL = 10**6\nMAX_EXPONENT = 20 # log2(10^6) is approx 19.9, so 20 is safe upper bound\n\n# Sieve for Smallest Prime Factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factors using SPF\ndef get_prime_factors(n):\n    factors = defaultdict(int)\n    if n == 0: return factors # Handle 0 if necessary, though problem constraints are 1 to 10^6\n    while n > 1:\n        factors[spf[n]] += 1\n        n //= spf[n]\n    return factors\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        print(\"YES\")\n        print()\n        return\n\n    sieve() # Precompute SPF\n\n    adj = [[] for _ in range(n)] # Stores (neighbor, edge_idx)\n    edges_info = [] # Stores (u, v, g, l) for original edges\n    \n    # edge_constraints[edge_idx][prime] = (exp_g_p, exp_l_p)\n    edge_constraints = [defaultdict(tuple) for _ in range(m)]\n    all_primes_set = set()\n\n    for i in range(m):\n        u_orig, v_orig, g, l = map(int, sys.stdin.readline().split())\n        u, v = u_orig - 1, v_orig - 1 # 0-indexed\n\n        edges_info.append((u, v, g, l))\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        factors_g = get_prime_factors(g)\n        factors_l = get_prime_factors(l)\n\n        current_edge_primes = set()\n        # Process primes from g\n        for p, exp_g_p in factors_g.items():\n            exp_l_p = factors_l.get(p, 0)\n            if exp_g_p > exp_l_p: # This should be caught by l % g != 0 earlier, but good to double check\n                print(\"NO\")\n                return\n            edge_constraints[i][p] = (exp_g_p, exp_l_p)\n            all_primes_set.add(p)\n            current_edge_primes.add(p)\n        \n        # Process primes from l that were not in g\n        for p, exp_l_p in factors_l.items():\n            if p not in current_edge_primes:\n                exp_g_p = factors_g.get(p, 0) # Should be 0\n                edge_constraints[i][p] = (exp_g_p, exp_l_p)\n                all_primes_set.add(p)\n        \n        adj[u].append((v, i))\n        adj[v].append((u, i))\n\n    final_exponents = [defaultdict(int) for _ in range(n)]\n\n    # Solve for exponents for each prime p independently\n    for p in all_primes_set:\n        node_p_exponent = [-1] * n # Exponent of p for each node, -1 means unassigned\n        \n        for start_node in range(n):\n            if node_p_exponent[start_node] == -1: # Start a new component for this prime\n                q = deque()\n                \n                # Determine initial value candidates for start_node\n                possible_vals_for_root = set()\n                constrained_by_edges = False\n                for v_neighbor, edge_idx in adj[start_node]:\n                    if p in edge_constraints[edge_idx]:\n                        constrained_by_edges = True\n                        g_exp, l_exp = edge_constraints[edge_idx][p]\n                        possible_vals_for_root.add(g_exp)\n                        possible_vals_for_root.add(l_exp)\n                \n                initial_root_val_candidates = []\n                if not constrained_by_edges:\n                    initial_root_val_candidates.append(0) # Isolated node for prime p, exponent 0\n                else:\n                    initial_root_val_candidates = sorted(list(possible_vals_for_root))\n\n                found_solution_for_component = False\n                \n                for initial_val in initial_root_val_candidates:\n                    temp_node_p_exponent = list(node_p_exponent) # Copy current state\n                    temp_q = deque([start_node])\n                    temp_node_p_exponent[start_node] = initial_val\n                    current_component_nodes_in_bfs = [start_node]\n                    component_valid = True\n\n                    while temp_q:\n                        u = temp_q.popleft()\n                        \n                        if temp_node_p_exponent[u] > MAX_EXPONENT: # Check max exponent for p\n                            component_valid = False\n                            break\n\n                        for v, edge_idx in adj[u]:\n                            if p not in edge_constraints[edge_idx]: continue # This edge doesn't constrain p\n\n                            g_exp, l_exp = edge_constraints[edge_idx][p]\n                            val_u = temp_node_p_exponent[u]\n\n                            expected_v_val = -1\n                            if g_exp == l_exp:\n                                if val_u != g_exp:\n                                    component_valid = False\n                                    break\n                                expected_v_val = g_exp\n                            else: # g_exp < l_exp\n                                if val_u != g_exp and val_u != l_exp:\n                                    component_valid = False\n                                    break\n                                expected_v_val = g_exp + l_exp - val_u\n                            \n                            if expected_v_val > MAX_EXPONENT:\n                                component_valid = False\n                                break\n\n                            if temp_node_p_exponent[v] == -1:\n                                temp_node_p_exponent[v] = expected_v_val\n                                temp_q.append(v)\n                                current_component_nodes_in_bfs.append(v)\n                            elif temp_node_p_exponent[v] != expected_v_val:\n                                component_valid = False\n                                break\n                        if not component_valid: break\n                    \n                    if component_valid:\n                        found_solution_for_component = True\n                        for node in current_component_nodes_in_bfs:\n                            node_p_exponent[node] = temp_node_p_exponent[node]\n                            final_exponents[node][p] = temp_node_p_exponent[node]\n                        break # Found a valid assignment for this component\n                \n                if not found_solution_for_component:\n                    print(\"NO\")\n                    return # Exit the function if no valid assignment for this component\n\n    # Construct ans values\n    ans = [1] * n\n    for i in range(n):\n        current_val = 1\n        for p_val, exp in final_exponents[i].items():\n            current_val *= (p_val ** exp)\n            if current_val > MAX_VAL:\n                print(\"NO\")\n                return\n        ans[i] = current_val\n        # If any node is isolated (not part of any edge), its value could be 0, but problem says >=1\n        # If it was truly isolated, final_exponents[i] would be empty and ans[i] would be 1. This is fine.\n\n    # Final consistency check (optional but good practice)\n    for u, v, g_orig, l_orig in edges_info:\n        if math.gcd(ans[u], ans[v]) != g_orig:\n            print(\"NO\")\n            return\n        # Calculate LCM using the property: LCM(a,b) = (a*b) / GCD(a,b)\n        calculated_lcm = (ans[u] * ans[v]) // math.gcd(ans[u], ans[v])\n        if calculated_lcm != l_orig:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans))\n\n# Run the solver\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\n# Constants\nMAX_VAL = 10**6\nMAX_EXPONENT = 20 # log2(10^6) is approx 19.9, so 20 is safe upper bound\n\n# Sieve for Smallest Prime Factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factors using SPF\ndef get_prime_factors(n):\n    factors = defaultdict(int)\n    if n == 0: return factors # Handle 0 if necessary, though problem constraints are 1 to 10^6\n    while n > 1:\n        factors[spf[n]] += 1\n        n //= spf[n]\n    return factors\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        print(\"YES\")\n        print()\n        return\n\n    sieve() # Precompute SPF\n\n    adj = [[] for _ in range(n)] # Stores (neighbor, edge_idx)\n    edges_info = [] # Stores (u, v, g, l) for original edges\n    \n    # edge_constraints[edge_idx][prime] = (exp_g_p, exp_l_p)\n    edge_constraints = [defaultdict(tuple) for _ in range(m)]\n    all_primes_set = set()\n\n    for i in range(m):\n        u_orig, v_orig, g, l = map(int, sys.stdin.readline().split())\n        u, v = u_orig - 1, v_orig - 1 # 0-indexed\n\n        edges_info.append((u, v, g, l))\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        factors_g = get_prime_factors(g)\n        factors_l = get_prime_factors(l)\n\n        current_edge_primes = set()\n        # Process primes from g\n        for p, exp_g_p in factors_g.items():\n            exp_l_p = factors_l.get(p, 0)\n            if exp_g_p > exp_l_p: # This should be caught by l % g != 0 earlier, but good to double check\n                print(\"NO\")\n                return\n            edge_constraints[i][p] = (exp_g_p, exp_l_p)\n            all_primes_set.add(p)\n            current_edge_primes.add(p)\n        \n        # Process primes from l that were not in g\n        for p, exp_l_p in factors_l.items():\n            if p not in current_edge_primes:\n                exp_g_p = factors_g.get(p, 0) # Should be 0\n                edge_constraints[i][p] = (exp_g_p, exp_l_p)\n                all_primes_set.add(p)\n        \n        adj[u].append((v, i))\n        adj[v].append((u, i))\n\n    final_exponents = [defaultdict(int) for _ in range(n)]\n\n    # Solve for exponents for each prime p independently\n    for p in all_primes_set:\n        node_p_exponent = [-1] * n # Exponent of p for each node, -1 means unassigned\n        \n        for start_node in range(n):\n            if node_p_exponent[start_node] == -1: # Start a new component for this prime\n                q = deque()\n                \n                # Determine initial value candidates for start_node\n                possible_vals_for_root = set()\n                constrained_by_edges = False\n                for v_neighbor, edge_idx in adj[start_node]:\n                    if p in edge_constraints[edge_idx]:\n                        constrained_by_edges = True\n                        g_exp, l_exp = edge_constraints[edge_idx][p]\n                        possible_vals_for_root.add(g_exp)\n                        possible_vals_for_root.add(l_exp)\n                \n                initial_root_val_candidates = []\n                if not constrained_by_edges:\n                    initial_root_val_candidates.append(0) # Isolated node for prime p, exponent 0\n                else:\n                    initial_root_val_candidates = sorted(list(possible_vals_for_root))\n\n                found_solution_for_component = False\n                \n                for initial_val in initial_root_val_candidates:\n                    temp_node_p_exponent = list(node_p_exponent) # Copy current state\n                    temp_q = deque([start_node])\n                    temp_node_p_exponent[start_node] = initial_val\n                    current_component_nodes_in_bfs = [start_node]\n                    component_valid = True\n\n                    while temp_q:\n                        u = temp_q.popleft()\n                        \n                        if temp_node_p_exponent[u] > MAX_EXPONENT: # Check max exponent for p\n                            component_valid = False\n                            break\n\n                        for v, edge_idx in adj[u]:\n                            if p not in edge_constraints[edge_idx]: continue # This edge doesn't constrain p\n\n                            g_exp, l_exp = edge_constraints[edge_idx][p]\n                            val_u = temp_node_p_exponent[u]\n\n                            expected_v_val = -1\n                            if g_exp == l_exp:\n                                if val_u != g_exp:\n                                    component_valid = False\n                                    break\n                                expected_v_val = g_exp\n                            else: # g_exp < l_exp\n                                if val_u != g_exp and val_u != l_exp:\n                                    component_valid = False\n                                    break\n                                expected_v_val = g_exp + l_exp - val_u\n                            \n                            if expected_v_val > MAX_EXPONENT:\n                                component_valid = False\n                                break\n\n                            if temp_node_p_exponent[v] == -1:\n                                temp_node_p_exponent[v] = expected_v_val\n                                temp_q.append(v)\n                                current_component_nodes_in_bfs.append(v)\n                            elif temp_node_p_exponent[v] != expected_v_val:\n                                component_valid = False\n                                break\n                        if not component_valid: break\n                    \n                    if component_valid:\n                        found_solution_for_component = True\n                        for node in current_component_nodes_in_bfs:\n                            node_p_exponent[node] = temp_node_p_exponent[node]\n                            final_exponents[node][p] = temp_node_p_exponent[node]\n                        break # Found a valid assignment for this component\n                \n                if not found_solution_for_component:\n                    print(\"NO\")\n                    return # Exit the function if no valid assignment for this component\n\n    # Construct ans values\n    ans = [1] * n\n    for i in range(n):\n        current_val = 1\n        for p_val, exp in final_exponents[i].items():\n            current_val *= (p_val ** exp)\n            if current_val > MAX_VAL:\n                print(\"NO\")\n                return\n        ans[i] = current_val\n        # If any node is isolated (not part of any edge), its value could be 0, but problem says >=1\n        # If it was truly isolated, final_exponents[i] would be empty and ans[i] would be 1. This is fine.\n\n    # Final consistency check (optional but good practice)\n    for u, v, g_orig, l_orig in edges_info:\n        if math.gcd(ans[u], ans[v]) != g_orig:\n            print(\"NO\")\n            return\n        # Calculate LCM using the property: LCM(a,b) = (a*b) / GCD(a,b)\n        calculated_lcm = (ans[u] * ans[v]) // math.gcd(ans[u], ans[v])\n        if calculated_lcm != l_orig:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans))\n\n# Run the solver\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 16354,
        "thoughts_token_count": 769
    }
}