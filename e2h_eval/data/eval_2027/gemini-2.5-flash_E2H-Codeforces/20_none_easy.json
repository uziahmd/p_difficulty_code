{
    "start": 1758011888.017294,
    "end": 1758012077.3954766,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:41 KST",
    "gpu": 2,
    "pid": 20,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Multiset of Strings\n\nYou are given three integers $$$n$$$, $$$k$$$ and $$$f$$$.Consider all binary strings (i. e. all strings consisting of characters $$$0$$$ and/or $$$1$$$) of length from $$$1$$$ to $$$n$$$. For every such string $$$s$$$, you need to choose an integer $$$c_s$$$ from $$$0$$$ to $$$k$$$.A multiset of binary strings of length exactly $$$n$$$ is considered beautiful if for every binary string $$$s$$$ with length from $$$1$$$ to $$$n$$$, the number of strings in the multiset such that $$$s$$$ is their prefix is not exceeding $$$c_s$$$.For example, let $$$n = 2$$$, $$$c_{0} = 3$$$, $$$c_{00} = 1$$$, $$$c_{01} = 2$$$, $$$c_{1} = 1$$$, $$$c_{10} = 2$$$, and $$$c_{11} = 3$$$. The multiset of strings $$$\\{11, 01, 00, 01\\}$$$ is beautiful, since:  for the string $$$0$$$, there are $$$3$$$ strings in the multiset such that $$$0$$$ is their prefix, and $$$3 \\le c_0$$$;  for the string $$$00$$$, there is one string in the multiset such that $$$00$$$ is its prefix, and $$$1 \\le c_{00}$$$;  for the string $$$01$$$, there are $$$2$$$ strings in the multiset such that $$$01$$$ is their prefix, and $$$2 \\le c_{01}$$$;  for the string $$$1$$$, there is one string in the multiset such that $$$1$$$ is its prefix, and $$$1 \\le c_1$$$;  for the string $$$10$$$, there are $$$0$$$ strings in the multiset such that $$$10$$$ is their prefix, and $$$0 \\le c_{10}$$$;  for the string $$$11$$$, there is one string in the multiset such that $$$11$$$ is its prefix, and $$$1 \\le c_{11}$$$. Now, for the problem itself. You have to calculate the number of ways to choose the integer $$$c_s$$$ for every binary string $$$s$$$ of length from $$$1$$$ to $$$n$$$ in such a way that the maximum possible size of a beautiful multiset is exactly $$$f$$$.\n\n## Input\nThe only line of input contains three integers $$$n$$$, $$$k$$$ and $$$f$$$ ($$$1 \\le n \\le 15$$$; $$$1 \\le k, f \\le 2 \\cdot 10^5$$$).\n\n## Output\nPrint one integer — the number of ways to choose the integer $$$c_s$$$ for every binary string $$$s$$$ of length from $$$1$$$ to $$$n$$$ in such a way that the maximum possible size of a beautiful multiset is exactly $$$f$$$. Since it can be huge, print it modulo $$$998244353$$$.\n\n## Example\n### Input\n['1 42 2', '2 37 13', '4 1252 325', '6 153 23699', '15 200000 198756']\n\n### Output\n['3', '36871576', '861735572', '0', '612404746']\n\n## Note\nIn the first example, the three ways to choose the integers $$$c_s$$$ are:  $$$c_0 = 0$$$, $$$c_1 = 2$$$, then the maximum beautiful multiset is $$$\\{1, 1\\}$$$;  $$$c_0 = 1$$$, $$$c_1 = 1$$$, then the maximum beautiful multiset is $$$\\{0, 1\\}$$$;  $$$c_0 = 2$$$, $$$c_1 = 0$$$, then the maximum beautiful multiset is $$$\\{0, 0\\}$$$. \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\nMOD = 998244353\n\ndef solve():\n    n, k, f = map(int, sys.stdin.readline().split())\n\n    max_possible_size = k * (1 << (n - 1))\n\n    if f > max_possible_size:\n        print(0)\n        return\n\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(f + 1):\n            # Case 1: The current level (length i) has 0 strings.\n            # This means c_s for all strings s of length i is 0.\n            # The count of strings at length i-1 is also 0.\n            # So, dp[i][j] += dp[i-1][j]\n            dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n\n            # Case 2: The current level (length i) has some strings.\n            # The number of strings with prefix s (length i-1) is c_s.\n            # The number of strings with prefix s0 is c_s0, and s1 is c_s1.\n            # c_s = c_s0 + c_s1.\n            # The total count of strings at length i is sum(c_s for |s|=i).\n            # This is equivalent to sum(c_s for |s|=i-1).\n            # So, if we add 'x' strings at level i, it means the sum of\n            # c_s for |s|=i-1 increased by x.\n            # The total number of ways to choose c_s values for length i\n            # such that the sum is x is (x + 2^i - 1) choose (2^i - 1).\n            # This is not how it works. The problem is about total size of multiset.\n\n    # Let's re-evaluate the DP state.\n    # dp[i][j] = number of ways to choose c_s for strings of length 1 to i\n    # such that the maximum possible size of a beautiful multiset\n    # considering only prefixes of length <= i is j.\n    # This is still not quite right.\n\n    # The maximum possible size of a beautiful multiset is the sum of\n    # c_s values for strings of length n.\n    # That is, if we have a multiset M, then for any string s of length n,\n    # the count of s in M must be <= c_s.\n    # To maximize the size, we should choose count(s) = c_s for all s of length n.\n    # So the total size is sum_{|s|=n} c_s.\n\n    # Let S_L be the set of all binary strings of length L.\n    # For any s in S_L, c_s is chosen.\n    # The condition is: for any s' in S_L, count(s' is prefix) <= c_s'.\n    # This implies that for any s in S_L, c_s >= c_{s0} + c_{s1}.\n    # And for s in S_n, c_s >= count(s in multiset).\n    # To maximize multiset size, we want sum_{s in S_n} count(s) to be max.\n    # So, we choose count(s) = c_s for s in S_n.\n    # This means the maximum size is sum_{s in S_n} c_s.\n\n    # Let X_i be the sum of c_s for all strings s of length i.\n    # The conditions are:\n    # 1. 0 <= c_s <= k for all s.\n    # 2. For s of length < n, c_s >= c_{s0} + c_{s1}.\n    # The maximum multiset size is X_n.\n    # We want X_n = f.\n\n    # The condition c_s >= c_{s0} + c_{s1} can be thought of as\n    # distributing c_s items into c_{s0} and c_{s1}.\n    # If we define d_s = c_s - (c_{s0} + c_{s1}) for |s| < n, then d_s >= 0.\n    # For |s| = n, c_s is the final count.\n    # The total sum X_n = sum_{|s|=n} c_s.\n    # Let's consider the structure as a binary tree.\n    # The root is the empty string.\n    # For a node s, its children are s0 and s1.\n    # We choose a value c_s for each node.\n    # Conditions: 0 <= c_s <= k.\n    #             c_s >= c_{s0} + c_{s1} for internal nodes.\n    # We want sum of c_s at depth n to be exactly f.\n\n    # This is a dynamic programming problem on the tree structure.\n    # Since n is small (up to 15), we can use DP with states related to depth.\n    # Let dp[i][j] be the number of ways to assign c_s values for all strings\n    # of length >= i such that the sum of c_s values for strings of length i\n    # is j, and all conditions for subtrees rooted at length i are satisfied.\n    # This seems like it would be dp[i][j] = number of ways to assign c_s\n    # for all nodes in the subtree rooted at a *specific* node s of length i-1,\n    # such that c_s = j. This is not for all strings of length i.\n\n    # The problem asks for the sum of c_s at length n to be f.\n    # The number of strings of length L is 2^L.\n    # Total number of strings is 2^(n+1) - 2.\n    #\n    # Let dp[i][j] be the number of ways to assign c_s values for all strings\n    # of length from 1 to i, such that the sum of c_s values for strings of length i is j.\n    #\n    # Base case: i = 0 (empty string level, not really part of the problem)\n    # Or, i = 1: strings \"0\", \"1\".\n    # We choose c_0, c_1. 0 <= c_0, c_1 <= k.\n    # Sum c_0 + c_1 = j.\n    # Number of ways to choose c_0, c_1 such that c_0+c_1 = j is j+1 if 0<=j<=k.\n    # No, it's min(j, k) + 1 if j <= 2k.\n    # It's (j+1) for j <= k.\n    # It's (2k - j + 1) for k < j <= 2k.\n    # This is for a single pair of children.\n    #\n    # This is a standard problem: counting paths in a grid.\n    # The constraints c_s >= c_{s0} + c_{s1} mean that the sum of values\n    # at level i must be >= sum of values at level i+1.\n    # Let X_i = sum_{|s|=i} c_s.\n    # Then X_i >= X_{i+1}.\n    # Also, X_i <= 2^i * k.\n    # And X_0 = c_empty, which is not defined.\n    # Let's consider X_1 = c_0 + c_1.\n    # X_2 = c_00 + c_01 + c_10 + c_11.\n    # We have c_0 >= c_00 + c_01, c_1 >= c_10 + c_11.\n    # Summing these: c_0 + c_1 >= (c_00 + c_01) + (c_10 + c_11).\n    # So X_1 >= X_2.\n    # In general, X_i >= X_{i+1} for i from 1 to n-1.\n    # Also, 0 <= c_s <= k.\n    # This implies 0 <= X_i <= 2^i * k.\n    #\n    # We want to find the number of sequences X_1, X_2, ..., X_n such that:\n    # 1. X_n = f\n    # 2. X_i >= X_{i+1} for 1 <= i < n\n    # 3. 0 <= X_i <= 2^i * k\n    # 4. For each X_i, the number of ways to choose individual c_s values\n    #    such that their sum is X_i and 0 <= c_s <= k, and\n    #    c_s >= c_{s0} + c_{s1} for |s|=i-1.\n\n    # The problem can be rephrased:\n    # For each string s of length < n, we choose c_s.\n    # For each string s of length n, we choose c_s.\n    # The total sum of c_s for length n must be f.\n    #\n    # The crucial observation might be related to the maximum possible size.\n    # The maximum possible size of a beautiful multiset is the sum of c_s for all strings s of length n.\n    # Let S_i be the sum of c_s for strings of length i.\n    # Then S_i >= S_{i+1} for i < n.\n    # Also, 0 <= c_s <= k.\n    # So 0 <= S_i <= k * 2^i.\n    # We need to find the number of ways to choose c_s such that S_n = f.\n\n    # This is equivalent to choosing values for d_s = c_s - (c_{s0} + c_{s1}) for |s| < n,\n    # and c_s for |s|=n.\n    # d_s >= 0.\n    # c_s <= k.\n    # sum_{|s|=n} c_s = f.\n    #\n    # Let's consider the maximum value of c_s. It is k.\n    # The maximum possible sum for S_n is k * 2^n.\n    # The constraints are c_s <= k for all s.\n    # And c_s >= c_{s0} + c_{s1} for |s| < n.\n\n    # Let's use DP on the levels.\n    # dp[i][j] = number of ways to choose c_s for strings of length `i` to `n`\n    # such that `j` is the sum of `c_s` for strings of length `i`.\n    # And all constraints `c_s >= c_{s0} + c_{s1}` are satisfied downwards.\n    #\n    # Base case: dp[n][j]\n    # For strings of length `n`, we choose `c_s`. There are `2^n` such strings.\n    # We need `sum_{|s|=n} c_s = j`.\n    # Each `c_s` must be between `0` and `k`.\n    # This is a stars and bars problem with upper bound.\n    # The number of ways to choose `c_s` for `2^n` strings such that `sum c_s = j`\n    # and `0 <= c_s <= k` is `C(j + 2^n - 1, 2^n - 1)` if `j <= k`.\n    # More generally, it's `coeff of x^j in (1 + x + ... + x^k)^(2^n)`.\n    # Let `N_i = 2^i`.\n    # `dp[n][j]` is the coefficient of `x^j` in `(sum_{p=0 to k} x^p)^(N_n)`.\n    # `(sum_{p=0 to k} x^p) = (1 - x^(k+1)) / (1 - x)`.\n    # So `dp[n][j]` is `coeff of x^j in ((1 - x^(k+1)) / (1 - x))^(N_n)`.\n    # `((1 - x^(k+1)) / (1 - x))^(N_n) = (sum_{m=0 to N_n} C(N_n, m) (-1)^m x^(m(k+1))) * (sum_{p=0 to inf} C(N_n+p-1, p) x^p)`.\n    #\n    # `dp[i][j]` is the number of ways to assign values to `c_s` for all strings `s` of length `i` through `n`,\n    # such that `sum_{|s|=i} c_s = j`, and all constraints `c_s >= c_{s0} + c_{s1}` are satisfied for `|s| >= i`.\n    #\n    # For `i < n`:\n    # `dp[i][j] = sum_{j' = 0 to j} (dp[i+1][j'] * ways_to_split(j, j', N_i))`.\n    # `ways_to_split(j, j', N_i)`:\n    # This is the number of ways to choose `c_s` for `N_i` strings of length `i`,\n    # such that `sum_{|s|=i} c_s = j`, and for each `s`, `c_s >= c_{s0} + c_{s1}`,\n    # and `sum_{|s|=i+1} c_s = j'`.\n    # This means `sum_{|s|=i} (c_s - (c_{s0} + c_{s1})) = j - j'`.\n    # Let `d_s = c_s - (c_{s0} + c_{s1})`. We need `d_s >= 0`.\n    # And `c_s <= k`.\n    #\n    # The structure of the problem is:\n    # We choose `c_s` for all strings `s`.\n    # The number of ways to choose `c_s` for a *single* string `s` of length `i`\n    # such that `c_s >= c_{s0} + c_{s1}` and `c_s <= k`, and `sum_{|s'|=i+1} c_{s'} = X_{i+1}`.\n    #\n    # This is a bit complicated. Let's simplify.\n    # The values `c_s` for `|s| = n` determine the final sum `f`.\n    # The values `c_s` for `|s| < n` act as upper bounds for the sum of their children.\n    # `c_s >= c_{s0} + c_{s1}`.\n    #\n    # Consider the problem as choosing a path in a grid.\n    # Let `dp[i][current_sum]` be the number of ways to choose `c_s` values for\n    # strings of length `1` to `i`, such that `sum_{|s|=i} c_s = current_sum`.\n    #\n    # `dp[i][current_sum]`\n    # We iterate `prev_sum` for `dp[i-1][prev_sum]`.\n    # For each `prev_sum`, we need to choose `c_s` for strings of length `i-1`\n    # and `c_s'` for strings of length `i`.\n    # The constraint `c_s >= c_{s0} + c_{s1}` must hold for all `s` of length `i-1`.\n    # This means `prev_sum >= current_sum`.\n    #\n    # This means we are counting sequences `X_1, X_2, ..., X_n` such that:\n    # 1. `X_n = f`\n    # 2. `X_i >= X_{i+1}` for `1 <= i < n`\n    # 3. `0 <= X_i <= k * 2^i`\n    # 4. For each `X_i`, we need to count the number of ways to choose `c_s` for `|s|=i`\n    #    such that `sum_{|s|=i} c_s = X_i`, and `0 <= c_s <= k`.\n    #    Let `ways(L, S, K)` be the number of ways to choose `L` non-negative integers\n    #    `x_1, ..., x_L` such that `sum x_j = S` and `x_j <= K`.\n    #    This is `coeff of x^S in (1+x+...+x^K)^L`.\n    #\n    # So, `dp[i][X_i]` would be `ways(2^i, X_i, k)`.\n    # No, this is not correct. The conditions `c_s >= c_{s0} + c_{s1}` are local.\n    #\n    # Let's consider the problem from the perspective of the total sum `f`.\n    # `f = sum_{|s|=n} c_s`.\n    # For each `s` of length `n-1`, `c_s >= c_{s0} + c_{s1}`.\n    # For each `s` of length `n-2`, `c_s >= c_{s0} + c_{s1}`.\n    # ...\n    # For each `s` of length `1`, `c_s >= c_{s0} + c_{s1}`.\n    # And `0 <= c_s <= k` for all `s`.\n\n    # This is a known problem structure. It's about paths on a grid, but with values.\n    # The maximum value of `f` is `k * 2^n`.\n    # `n` is up to 15. `2^15` is `32768`.\n    # `k` is up to `2 * 10^5`.\n    # `f` is up to `2 * 10^5`.\n    # `k * 2^n` can be `2 * 10^5 * 32768` which is very large.\n    # But `f` is small.\n\n    # The maximum possible sum `f` is `k * 2^n`.\n    # But `f` itself is up to `2 * 10^5`.\n    # This means `f` is much smaller than `k * 2^n` in most cases.\n    # This suggests that `c_s` values are usually small, or many are zero.\n\n    # Let's define `dp[i][j]` as the number of ways to assign `c_s` values\n    # for all strings of length `i` to `n`, such that the sum of `c_s` values\n    # for strings of length `i` is `j`.\n    #\n    # `dp[n][j]` is the number of ways to choose `c_s` for `2^n` strings of length `n`,\n    # such that `sum c_s = j` and `0 <= c_s <= k`.\n    # This is `coeff of x^j in (1 + x + ... + x^k)^(2^n)`.\n    # Since `f` is small, `j` will be small.\n    # `2^n` can be large.\n    #\n    # Let `N_i = 2^i`.\n    # `dp[i][j]` is the number of ways to choose `c_s` for `N_i` nodes at level `i`\n    # and all their descendants, such that their sum is `j`.\n    #\n    # Transition: `dp[i][j]` from `dp[i+1][j']`.\n    # For each `s` of length `i`, we choose `c_s`.\n    # For its children `s0, s1`, we have already chosen values such that `c_{s0} + c_{s1} = child_sum_s`.\n    # The total `sum_{|s|=i+1} c_s = j'`.\n    # We need `c_s >= child_sum_s`.\n    #\n    # This is equivalent to `N_i` independent subproblems, each for a string `s` of length `i`.\n    # For a specific `s` of length `i`, we need to choose `c_s` and values for its descendants.\n    # Let `g[len][sum_val]` be the number of ways to assign `c_s` values in the subtree\n    # rooted at a generic string of length `len`, such that `c_s` (for that root string) is `sum_val`.\n    #\n    # `g[n][val]` = 1 if `0 <= val <= k`, else 0. (Base case for leaf nodes)\n    #\n    # For `g[len][val]` where `len < n`:\n    # `g[len][val] = sum_{val0=0 to val} sum_{val1=0 to val-val0} (g[len+1][val0] * g[len+1][val1])`\n    # This is for `0 <= val <= k`.\n    # `g[len][val] = sum_{child_sum=0 to val} (ways_to_split_val_into_two_children(child_sum) * g[len+1][child_sum]^2)`\n    # This is not correct. It's `sum_{val0=0 to k} sum_{val1=0 to k} (g[len+1][val0] * g[len+1][val1])`\n    # such that `val0 + val1 <= val`.\n    #\n    # Let `h[len][s]` be the number of ways to assign `c_s` values for a *single* subtree rooted at length `len`,\n    # such that the value `c_root` is `s`.\n    #\n    # Base case: `h[n][s] = 1` if `0 <= s <= k`, else `0`.\n    #\n    # For `len` from `n-1` down to `1`:\n    # `h[len][s]` for `0 <= s <= k`:\n    #   `h[len][s] = sum_{s0=0 to k} sum_{s1=0 to k} (h[len+1][s0] * h[len+1][s1])`\n    #   such that `s0 + s1 <= s`.\n    #   This is a convolution. Let `P_{len+1}(x) = sum_{j=0 to k} h[len+1][j] x^j`.\n    #   Then we need `sum_{s0=0 to k} sum_{s1=0 to k} h[len+1][s0] h[len+1][s1]` for `s0+s1 <= s`.\n    #   Let `Q_{len+1}(x) = P_{len+1}(x)^2 = sum_{j=0 to 2k} C_j x^j`.\n    #   Then `h[len][s] = sum_{j=0 to s} C_j`. This is prefix sums of `Q_{len+1}(x)`.\n    #   The upper bound `s` for `s0+s1` is important.\n    #   Also, `s0` and `s1` can be at most `k`.\n    #   The maximum possible value for `s0+s1` is `2k`.\n    #   So `h[len][s]` for `s > 2k` is the same as `h[len][2k]`.\n    #   We only care about `s <= k`.\n    #   So `h[len][s] = sum_{j=0 to s} C_j` for `s <= k`.\n    #   `h[len][s]` is `sum_{j=0 to s} (coeff of x^j in P_{len+1}(x)^2)`.\n    #   This is `sum_{s0=0 to k} sum_{s1=0 to k, s0+s1 <= s} h[len+1][s0] * h[len+1][s1]`.\n    #   This is a prefix sum of a convolution.\n    #   `P_{len+1}(x)` is a polynomial of degree `k`. `P_{len+1}(x)^2` is degree `2k`.\n    #   We need to compute `h[len][s]` for `s` from `0` to `k`.\n    #   The maximum value of `k` is `2 * 10^5`.\n    #   This convolution is `O(k log k)` using FFT, or `O(k^2)` directly.\n    #   `n` iterations. `n * k^2` is too slow. `n * k log k` is feasible.\n    #   `15 * 2 * 10^5 * log(2 * 10^5)` is `15 * 2 * 10^5 * 18` approx `5.4 * 10^7`.\n    #   This might be too slow for `MOD` arithmetic (NTT).\n    #   `k` is `2 * 10^5`. `2k` is `4 * 10^5`.\n    #   Need to compute `h[len][s]` for `s` up to `k`.\n    #\n    #   Let `A[j] = h[len+1][j]`. We need to compute `B[s] = sum_{j=0 to s} (A * A)[j]`.\n    #   `A` has length `k+1`. `A*A` has length `2k+1`.\n    #   The NTT approach is possible.\n\n    # Precompute factorials and inverse factorials for combinations.\n    # `dp[n][j]` calculation for `(sum_{p=0 to k} x^p)^(2^n)` is not needed if we use `h[n][s]`.\n    #\n    # The final answer is `sum_{j=0 to k} (h[1][j] * num_ways_to_distribute(j, f))`.\n    # This is `h[1][f]` if `f <= k`.\n    # No, this is `h[1][j]` for a single root string.\n    # The problem is about `sum_{|s|=n} c_s = f`.\n    #\n    # Let `g[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    # such that `sum_{|s|=i} c_s = j`.\n    # This is exactly what we need.\n    #\n    # Base case: `g[n][j]`\n    # This is the number of ways to choose `2^n` integers `c_s` such that `0 <= c_s <= k` and `sum c_s = j`.\n    # Let `N_n = 2^n`.\n    # `g[n][j] = coeff of x^j in (1 + x + ... + x^k)^(N_n)`.\n    # This can be computed using generating functions.\n    # `(1 - x^(k+1))^(N_n) * (1 - x)^(-N_n)`\n    # `(sum_{m=0 to N_n} C(N_n, m) (-1)^m x^(m(k+1))) * (sum_{p=0 to inf} C(N_n+p-1, p) x^p)`\n    # `g[n][j] = sum_{m=0 to N_n, m(k+1) <= j} C(N_n, m) (-1)^m * C(N_n + (j - m(k+1)) - 1, (j - m(k+1)))`.\n    # This is for `j` up to `f`. `f` is up to `2 * 10^5`.\n    # `N_n` can be up to `2^15 = 32768`.\n    # This sum takes `O(f / k)` terms. Max `f / k` is `2 * 10^5 / 1 = 2 * 10^5`.\n    # Max `N_n` is `32768`.\n    # This sum is `O(min(N_n, f / (k+1)))`. Max `min(32768, 2 * 10^5 / 1) = 32768`.\n    # So `g[n][j]` can be computed in `O(min(N_n, f/k))` for each `j`.\n    # Total for `g[n]` is `O(f * min(N_n, f/k))`. This is too slow.\n    # `2 * 10^5 * 32768` is too large.\n    #\n    # We need to compute `g[n][j]` for all `j` from `0` to `f`.\n    # This is a polynomial multiplication. `(1+x+...+x^k)^(N_n)`.\n    # If `N_n` is large, we can use binary exponentiation for polynomials.\n    # `O(k log(N_n) log k)` using NTT.\n    # `k log(2^n) log k = k * n * log k`.\n    # `2 * 10^5 * 15 * log(2 * 10^5)` is `2 * 10^5 * 15 * 18` approx `5.4 * 10^7`.\n    # This is feasible for `g[n][j]` for `j` up to `f`.\n    # The degree of the polynomial is `k * N_n`. We only need up to `f`.\n    # So `k` in `k log k` should be `f`.\n    # `f * n * log f`. `2 * 10^5 * 15 * log(2 * 10^5)` approx `5.4 * 10^7`. This is okay.\n    # So `g[n][j]` for `j=0..f` can be computed.\n\n    # Transition for `g[i][j]` from `g[i+1][j']`:\n    # `g[i][j] = sum_{j'=0 to j} (g[i+1][j'] * num_ways_to_choose_c_s_at_level_i(j, j'))`.\n    # `num_ways_to_choose_c_s_at_level_i(j, j')`:\n    # This is the number of ways to choose `N_i = 2^i` values `c_s` (for `|s|=i`)\n    # such that `sum c_s = j`, and for each `s`, `0 <= c_s <= k`, and\n    # `c_s >= child_sum_s`.\n    # The `child_sum_s` values sum up to `j'`.\n    # This is equivalent to choosing `d_s = c_s - child_sum_s >= 0`.\n    # `sum d_s = j - j'`.\n    # And `c_s <= k` implies `d_s <= k - child_sum_s`.\n    #\n    # This is still not quite right.\n    # The `g[i][j]` definition implies that the values `c_s` for `|s|=i` are chosen,\n    # and for each `s` of length `i`, `c_s` serves as the `val` in `h[i][val]`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`,\n    # such that the sum of `c_s` for strings of length `i` is `j`.\n    #\n    # `dp[n][j]` is `coeff of x^j in (sum_{p=0 to k} x^p)^(2^n)`.\n    # Let `P_i(x) = sum_{j=0}^{k \\cdot 2^i} dp[i][j] x^j`.\n    #\n    # For `i` from `n-1` down to `1`:\n    # We want to compute `dp[i][j]`.\n    # For each string `s` of length `i`, we choose `c_s`. `0 <= c_s <= k`.\n    # For its children `s0, s1`, they will have values `c_{s0}, c_{s1}`.\n    # We know `dp[i+1][j']` counts ways to assign values for `2^{i+1}` strings of length `i+1` and their descendants,\n    # such that their sum is `j'`.\n    #\n    # For a string `s` of length `i`, we need to choose `c_s`.\n    # We also need to choose `c_{s0}, c_{s1}` and their descendants such that `c_s >= c_{s0} + c_{s1}`.\n    # The values `c_{s0}, c_{s1}` are chosen from `dp[i+1]` effectively.\n    #\n    # Let `h[len][val]` be the number of ways to assign `c_s` values for a *single* subtree rooted at length `len`,\n    # such that the value `c_root` is `val`.\n    #\n    # Base case: `h[n][val] = 1` if `0 <= val <= k`, else `0`.\n    #\n    # For `len` from `n-1` down to `1`:\n    # `h[len][val]` for `0 <= val <= k`:\n    #   `h[len][val] = sum_{s0=0 to k} sum_{s1=0 to k} (h[len+1][s0] * h[len+1][s1])`\n    #   such that `s0 + s1 <= val`.\n    #\n    # Let `P_L(x) = sum_{s=0}^k h[L][s] x^s`.\n    # Then `P_{L-1}(x)` can be computed from `P_L(x)`.\n    # `P_L(x)^2 = sum_{j=0}^{2k} C_j x^j`.\n    # `h[L-1][s] = sum_{j=0}^s C_j` for `s` from `0` to `k`.\n    #\n    # This can be computed iteratively.\n    # `h[n]` is `[1, 1, ..., 1]` (k+1 ones).\n    # `h[n-1]` involves `h[n]^2`.\n    # `h[n-1][s] = sum_{s0=0 to k} sum_{s1=0 to k, s0+s1 <= s} 1 * 1`.\n    # `h[n-1][s] = sum_{s0=0 to k} (s - s0 + 1)` (if `s - s0 >= 0`).\n    # No, `h[n-1][s] = sum_{s0=0 to min(s, k)} (min(s - s0, k) + 1)`.\n    # Example: `k=1`. `h[n] = [1, 1]`.\n    # `h[n-1][0]`: `s0+s1 <= 0` => `s0=0, s1=0`. `1*1=1`.\n    # `h[n-1][1]`: `s0+s1 <= 1`.\n    #   `s0=0, s1=0`: `1*1=1`\n    #   `s0=0, s1=1`: `1*1=1`\n    #   `s0=1, s1=0`: `1*1=1`\n    #   Total `3`.\n    # `h[n-1] = [1, 3]`.\n    #\n    # Example: `k=2`. `h[n] = [1, 1, 1]`.\n    # `h[n-1][0]`: `s0=0, s1=0`. `1`.\n    # `h[n-1][1]`: `s0+s1 <= 1`. `(0,0), (0,1), (1,0)`. `3`.\n    # `h[n-1][2]`: `s0+s1 <= 2`. `(0,0), (0,1), (0,2), (1,0), (1,1), (2,0)`. `6`.\n    # `h[n-1] = [1, 3, 6]`.\n    #\n    # This is a prefix sum of a prefix sum.\n    # Let `A_L[j] = h[L][j]`.\n    # Let `B_L[s] = sum_{s0=0}^k sum_{s1=0}^k A_L[s0] A_L[s1]` for `s0+s1=s`. (Convolution `A_L * A_L`)\n    # Let `C_L[s] = sum_{p=0}^s B_L[p]`. (Prefix sum of convolution)\n    # Then `A_{L-1}[s] = C_L[s]` for `s <= k`.\n    #\n    # This computation `A_L * A_L` takes `O(k^2)`. `n` iterations. `n * k^2` is too slow.\n    # `n * k log k` with NTT. Max `k` for `h` is `k`.\n    # Max degree `2k`. So `2k log(2k)` per step.\n    # `n * (2k) log(2k)` is `15 * 4 * 10^5 * 19` approx `1.1 * 10^8`. This might be too slow.\n    # But `k` is up to `2*10^5`, `f` is up to `2*10^5`.\n    # The actual `k` for `h[len][s]` is `min(k, f)`.\n    # No, `k` is the maximum value for `c_s`. `f` is the target sum.\n    # So `h[len][s]` for `s` up to `k`.\n\n    # The maximum value for `s` in `h[len][s]` is `k`.\n    # `P_L(x)` has degree `k`. `P_L(x)^2` has degree `2k`.\n    # We need `h[L-1][s]` for `s` up to `k`.\n    # So we need `C_L[s]` for `s` up to `k`.\n    # We can compute `P_L(x)^2` up to degree `2k`.\n    # This is `O(k log k)` using NTT.\n    # Then compute prefix sums `C_L[s]` up to `k`. `O(k)`.\n    # Total `n * (k log k)`. This is `15 * 2 * 10^5 * 18` approx `5.4 * 10^7`.\n    # This is feasible.\n\n    # After computing `h[1][s]` for `s` from `0` to `k`.\n    # `h[1][s]` is the number of ways to choose `c_s` for the entire tree\n    # rooted at '0' or '1' such that `c_0 = s` (or `c_1 = s`).\n    #\n    # The problem asks for the total number of ways to choose `c_s` for all strings\n    # of length `1` to `n` such that `sum_{|s|=n} c_s = f`.\n    #\n    # Let `H_L` be the polynomial `P_L(x)`.\n    # `H_n(x) = sum_{s=0}^k 1 * x^s`.\n    # `H_{L-1}(x) = sum_{s=0}^k (sum_{j=0}^s coeff(H_L(x)^2, j)) x^s`.\n    # We compute `H_1(x)`. This `H_1(x)` is for a single subtree rooted at length 1.\n    # There are two such subtrees: one for '0' and one for '1'.\n    # Let `h_1[s]` be the coefficients of `H_1(x)`.\n    # We need to choose `c_0` and `c_1` such that `c_0 + c_1` is some value.\n    # And `sum_{|s|=n} c_s = f`.\n    #\n    # The definition of `h[len][val]` is the number of ways to assign `c_s` values\n    # for all descendants of a *single* node `s` of length `len-1`, such that `c_s = val`.\n    # The final sum `f` is `sum_{s \\in S_n} c_s`.\n    # This means `f` is the sum of `c_s` for all leaf nodes.\n    #\n    # The sum `sum_{s \\in S_n} c_s` is actually determined by `c_s` values for `|s|=1`.\n    # `sum_{s \\in S_n} c_s = sum_{s \\in S_{n-1}} (c_{s0} + c_{s1})`.\n    # And `c_s >= c_{s0} + c_{s1}`.\n    # So `sum_{s \\in S_n} c_s <= sum_{s \\in S_{n-1}} c_s`.\n    # `f <= X_{n-1} <= X_{n-2} <= ... <= X_1`.\n    # And `X_1 = c_0 + c_1`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`,\n    # such that `sum_{|s|=i} c_s = j`.\n    # This is exactly what `h[i][j]` is for a *single* node.\n    #\n    # The number of strings of length `i` is `2^i`.\n    # The total number of ways is `sum_{j=0 to f} (dp[1][j] * ways_to_get_f_from_j_at_level_1)`.\n    # This implies that `dp[1][j]` should be the number of ways to pick `c_s` for *all* strings of length 1.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings of length `i` to `n`,\n    # such that `sum_{|s|=i} c_s = j`.\n    #\n    # Base case: `dp[n][j]` is the number of ways to choose `2^n` integers `c_s` (for `|s|=n`)\n    # such that `0 <= c_s <= k` and `sum c_s = j`.\n    # This is `coeff of x^j in (1 + x + ... + x^k)^(2^n)`.\n    # This is `coeff of x^j in ((1-x^(k+1))/(1-x))^(2^n)`.\n    # We need to compute this for `j` from `0` to `f`.\n    # This is `O(f * min(2^n, f/(k+1)))` if done naively.\n    # Using NTT for polynomial exponentiation `(P(x))^{2^n}` is `O(f * n * log f)`.\n    # No, it's `O(f log(2^n) log f)` is `O(f * n * log f)`.\n    # This polynomial `Q(x) = (1+x+...+x^k)` has degree `k`.\n    # `Q(x)^{2^n}` has degree `k * 2^n`.\n    # We only need coefficients up to `f`.\n    # So, we compute `Q(x)^{2^n}` modulo `x^{f+1}`.\n    # This can be done by `log_mod_x_power_m` and `exp_mod_x_power_m` (polynomial exponentiation).\n    # `P(x)^E = exp(E * log(P(x))) mod x^m`.\n    # `E` is `2^n`. `m` is `f+1`.\n    # This takes `O(m log m)`.\n    # So `O(f log f)`. This is `2 * 10^5 * 18` approx `3.6 * 10^6`. This is feasible.\n    #\n    # Let `P_i(x) = sum_{j=0}^{f} dp[i][j] x^j`.\n    #\n    # For `i` from `n-1` down to `1`:\n    # `P_i(x)` from `P_{i+1}(x)`.\n    # `dp[i][j]` is the number of ways to choose `c_s` for `2^i` nodes at level `i`,\n    # such that `sum c_s = j`.\n    # For each node `s` at level `i`, `c_s` is chosen. `0 <= c_s <= k`.\n    # The descendants of `s` (rooted at `s0` and `s1`) must satisfy `c_s >= c_{s0} + c_{s1}`.\n    # The total sum for `s0, s1` and their descendants is counted in `P_{i+1}(x)`.\n    #\n    # This is where the `h[len][val]` definition comes in.\n    # `h[len][val]` is the number of ways to assign `c_s` values for a *single* subtree rooted at length `len`,\n    # such that `c_root = val`, and `sum_{leaf_descendants} c_leaf = val`.\n    # No, this is not true. `sum_{leaf_descendants} c_leaf` can be smaller than `val`.\n    #\n    # The condition `c_s >= c_{s0} + c_{s1}` means `c_s` is an upper bound for the sum of its children's `c` values.\n    # The sum `f` is `sum_{|s|=n} c_s`.\n    #\n    # Let `g[i][val]` be the number of ways to choose `c_s` for strings `s'` in the subtree rooted at a *single* string `s` of length `i-1`, such that `c_s = val`.\n    # Base case: `g[n][val] = 1` for `0 <= val <= k`, else `0`.\n    # For `i` from `n` down to `2`:\n    # `g[i-1][val]` for `0 <= val <= k`:\n    #   `g[i-1][val] = sum_{v0=0 to k} sum_{v1=0 to k} (g[i][v0] * g[i][v1])`\n    #   such that `v0 + v1 <= val`.\n    # This means `g[i-1][val]` is the `val`-th prefix sum of the convolution `(G_i(x))^2`, where `G_i(x) = sum g[i][j] x^j`.\n    # We compute `G_i(x)^2` up to degree `2k`. Then take prefix sums up to `k`.\n    # This takes `O(k log k)` per level. `n` levels. Total `O(n k log k)`.\n    # After computing `g[1][val]` for `val` from `0` to `k`.\n    # `g[1][val]` is the number of ways to assign `c_s` values for a *single* string of length 0 (empty string)\n    # such that `c_empty = val`.\n    # The problem asks for `sum_{|s|=n} c_s = f`.\n    #\n    # The root of the tree is an implicit empty string. Let's call its value `c_root`.\n    # `c_root >= c_0 + c_1`.\n    # `c_0 >= c_{00} + c_{01}`.\n    # ...\n    # `c_s >= c_{s0} + c_{s1}`.\n    # We need `sum_{|s|=n} c_s = f`.\n    #\n    # The calculation of `g[i][val]` is correct.\n    # Let `P_i(x) = sum_{val=0}^k g[i][val] x^{val}`.\n    # `P_n(x) = sum_{val=0}^k x^{val}`.\n    # For `i = n-1` down to `1`:\n    # `Q(x) = P_{i+1}(x)^2`. Compute `Q(x)` up to degree `2k`.\n    # `g[i][val] = sum_{j=0}^val coeff(Q(x), j)` for `val` from `0` to `k`.\n    #\n    # After computing `g[1][val]` for `val` from `0` to `k`.\n    # This `g[1][val]` is the number of ways to choose `c_s` for all strings `s` of length `1` to `n`\n    # such that `c_0 + c_1 = val`.\n    # This is because `g[1][val]` is defined for a single string of length 1.\n    # There are two strings of length 1: \"0\" and \"1\".\n    # So for `c_0`, we can pick `val0` ways from `g[1][val0]`.\n    # For `c_1`, we can pick `val1` ways from `g[1][val1]`.\n    # The total sum `f` is `sum_{|s|=n} c_s`.\n    #\n    # The maximum possible sum `f` for a subtree rooted at `len` with `c_root = val` is `val`.\n    # `f = sum_{|s|=n} c_s`.\n    # `sum_{|s|=n} c_s <= sum_{|s|=n-1} c_s <= ... <= sum_{|s|=1} c_s`.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`,\n    # such that `sum_{|s|=i} c_s = j`.\n    #\n    # Base case: `dp[n][j]` is the number of ways to choose `2^n` integers `c_s` (for `|s|=n`)\n    # such that `0 <= c_s <= k` and `sum c_s = j`.\n    # This is `coeff of x^j in (sum_{p=0 to k} x^p)^(2^n)`.\n    # Let `P_n(x) = (sum_{p=0 to k} x^p)^(2^n)`. We need to compute `P_n(x)` up to `x^f`.\n    # This takes `O(f log f)` using polynomial exponentiation.\n    #\n    # For `i` from `n-1` down to `1`:\n    # `dp[i][j]` is the number of ways to choose `c_s` for `2^i` nodes at level `i`\n    # such that `sum c_s = j`.\n    # And for each `s` at level `i`, `c_s` must be `0 <= c_s <= k`,\n    # and `c_s >= c_{s0} + c_{s1}`.\n    # The values `c_{s0}, c_{s1}` and their descendants are already accounted for in `dp[i+1]`.\n    #\n    # This is the tricky part. `dp[i+1][j']` is the sum over all `2^{i+1}` nodes.\n    # It's not about a single node's children.\n    #\n    # The structure of the problem is a bit like:\n    # `f = sum_{leaf} c_leaf`.\n    # Each `c_node` is `0..k`.\n    # `c_node >= c_left_child + c_right_child`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose values for all `c_s` where `s` is of length `i` or greater,\n    # such that `sum_{|s|=i} c_s = j`.\n    #\n    # `dp[n][j]` is computed using polynomial exponentiation `(1+x+...+x^k)^{2^n}` up to `x^f`.\n    #\n    # For `i` from `n-1` down to `1`:\n    # We want to compute `dp[i][j]` for `j` from `0` to `f`.\n    # `dp[i][j] = sum_{j_prev=0 to f} (dp[i+1][j_prev] * ways_to_choose_current_level(j, j_prev, i))`.\n    # `ways_to_choose_current_level(j, j_prev, i)`:\n    # This is the number of ways to choose `2^i` values `c_s` (for `|s|=i`)\n    # such that `sum c_s = j`, and `0 <= c_s <= k`.\n    # And for each `s`, `c_s >= c_{s0} + c_{s1}`.\n    # The `c_{s0}, c_{s1}` values for all `2^{i+1}` children sum to `j_prev`.\n    #\n    # This is a known problem pattern: the values `c_s` at level `i` are \"containers\" for the values at level `i+1`.\n    # The total number of items at level `i+1` is `j_prev`.\n    # We need to distribute these `j_prev` items into `2^i` pairs of children.\n    # Let `c_{s0} + c_{s1} = child_sum_s`.\n    # Then `sum_{s} child_sum_s = j_prev`.\n    # We need to choose `c_s` for each `s` such that `c_s >= child_sum_s` and `0 <= c_s <= k`.\n    #\n    # This is a convolution.\n    # Let `A_i[j]` be the `dp[i][j]` values.\n    # `A_i[j] = sum_{j_child=0 to j} (A_{i+1}[j_child] * ways_to_choose_parent_values(j, j_child, i))`.\n    # `ways_to_choose_parent_values(j, j_child, i)` is the number of ways to choose `2^i` values `c_s`\n    # such that `sum c_s = j`, `0 <= c_s <= k`, and for each `s`, `c_s >= child_sum_s`.\n    # And `sum child_sum_s = j_child`.\n    #\n    # This is equivalent to choosing `d_s = c_s - child_sum_s >= 0`.\n    # `sum d_s = j - j_child`.\n    # `d_s <= k - child_sum_s`.\n    #\n    # This means we need `dp[i][j]` where `j` is the sum of `c_s` for `2^i` nodes.\n    # `dp[i][j]` is computed from `dp[i+1][j']`.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`,\n    # such that `sum_{s \\text{ of length } i} c_s = j`.\n    #\n    # `dp[n][j]` is `coeff of x^j in (sum_{p=0 to k} x^p)^{2^n}`. Compute this for `j` up to `f`.\n    # This is `O(f log f)` using polynomial exponentiation (NTT).\n    #\n    # For `i = n-1` down to `1`:\n    # `dp[i][j]` is the number of ways to choose `c_s` for `2^i` strings of length `i` and their descendants.\n    # The sum of `c_s` for these `2^i` strings is `j`.\n    # For each string `s` of length `i`, we choose `c_s`.\n    # And for its children `s0, s1`, and their descendants, we choose values such that `c_s >= c_{s0} + c_{s1}`.\n    #\n    # This is the `h[len][val]` approach.\n    # `h[len][val]` is the number of ways to assign `c_s` values in a *single* subtree rooted at length `len`,\n    # such that the value `c_root` is `val`.\n    # The final answer is `h[1][f]` if `f <= k`.\n    #\n    # The `f` value is `sum_{|s|=n} c_s`.\n    # If `h[len][val]` represents the number of ways to assign `c_s` values in a subtree,\n    # such that `c_root = val`, and *also* `sum_{leaves in subtree} c_leaf = val`?\n    # No, this is not true.\n    # `c_s >= c_{s0} + c_{s1}`.\n    # `sum_{leaves} c_leaf <= c_root`.\n    # So if `f` is the sum of leaves, `f <= c_root`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for strings `s` of length `i` to `n`\n    # in a *single* subtree rooted at length `i-1`, such that `sum_{|s|=n, s \\text{ in subtree}} c_s = j`.\n    # And `c_{root_of_subtree} <= k`.\n    #\n    # Base case: `dp[n][j]` is for a subtree rooted at length `n-1`.\n    # It has two children `s0, s1` of length `n`.\n    # We choose `c_{s0}, c_{s1}` such that `c_{s0} + c_{s1} = j`.\n    # `0 <= c_{s0}, c_{s1} <= k`.\n    # The number of ways is `min(j, k) - max(0, j-k) + 1`. This is `max(0, k - |j-k| + 1)`.\n    # This is `j+1` for `j <= k`. And `2k-j+1` for `k < j <= 2k`.\n    # This is `coeff of x^j in (1+x+...+x^k)^2`.\n    # Let `P_i(x) = sum_{j=0}^{k \\cdot 2^{n-i+1}} dp[i][j] x^j`.\n    #\n    # For `i` from `n` down to `1`:\n    # `P_i(x)` is a polynomial where `dp[i][j]` is the number of ways to assign `c_s` values\n    # for a subtree rooted at length `i-1`, such that `sum_{leaves in subtree} c_leaf = j`.\n    # The maximum sum of leaves for a subtree rooted at `len` is `k * 2^(n-len)`.\n    #\n    # Let `dp[len][current_f]` be the number of ways to choose `c_s` values for a *single* subtree\n    # rooted at length `len`, such that `sum_{leaves in subtree} c_leaf = current_f`.\n    #\n    # Base case: `dp[n][current_f] = 1` if `0 <= current_f <= k`, else `0`. (For a single leaf node).\n    #\n    # For `len` from `n-1` down to `1`:\n    # We want to compute `dp[len][current_f]` for `current_f` from `0` to `f`.\n    # For a node `s` at length `len`, we need to choose `c_s`. `0 <= c_s <= k`.\n    # And `c_s >= c_{s0} + c_{s1}`.\n    # `dp[len][current_f] = sum_{c_s=0 to k} (sum_{f0=0 to current_f} sum_{f1=0 to current_f-f0} (dp[len+1][f0] * dp[len+1][f1]))`\n    # such that `c_s >= f0 + f1`.\n    #\n    # This is the correct DP formulation.\n    # Let `P_{len+1}(x) = sum_{j=0}^f dp[len+1][j] x^j`.\n    # We need `Q(x) = P_{len+1}(x)^2 = sum_{j=0}^{2f} C_j x^j`. (Convolution up to `2f`).\n    #\n    # `dp[len][current_f] = sum_{j=0}^{current_f} C_j * (k - j + 1)` (if `j <= k`).\n    # If `j > k`, then `k - j + 1` is `0`.\n    #\n    # `dp[len][current_f] = sum_{j=0}^{min(current_f, k)} C_j * (k - j + 1)`.\n    # This is `sum_{j=0}^{min(current_f, k)} C_j * (k+1) - sum_{j=0}^{min(current_f, k)} C_j * j`.\n    # This is a prefix sum of `C_j` and a prefix sum of `j * C_j`.\n    #\n    # Compute `Q(x) = P_{len+1}(x)^2` using NTT. This takes `O(f log f)`.\n    # Compute prefix sums `S_0[p] = sum_{j=0}^p C_j`.\n    # Compute prefix sums `S_1[p] = sum_{j=0}^p j * C_j`.\n    # Then `dp[len][current_f] = (S_0[min(current_f, k)] * (k+1) - S_1[min(current_f, k)]) % MOD`.\n    # This takes `O(f)` after `O(f log f)` convolution.\n    # Total `n` levels. `O(n * f log f)`.\n    # `15 * 2 * 10^5 * 18` approx `5.4 * 10^7`. This is feasible.\n\n    # After computing `dp[1][current_f]` for `current_f` from `0` to `f`.\n    # `dp[1][current_f]` is the number of ways to assign `c_s` values for a single subtree\n    # rooted at length 1, such that `sum_{leaves in subtree} c_leaf = current_f`.\n    #\n    # The problem has a global root (empty string).\n    # The two children are '0' and '1'.\n    # For '0' subtree, `sum_{leaves} c_leaf = f_0`.\n    # For '1' subtree, `sum_{leaves} c_leaf = f_1`.\n    # We need `f_0 + f_1 = f`.\n    # The number of ways for '0' subtree is `dp[1][f_0]`.\n    # The number of ways for '1' subtree is `dp[1][f_1]`.\n    # The value `c_0` must be `0 <= c_0 <= k` and `c_0 >= sum_{leaves in 0 subtree} c_leaf`.\n    # This means `c_0 >= f_0`.\n    # Similarly `c_1 >= f_1`.\n    #\n    # So the total answer is `sum_{f0=0 to f} (dp[1][f0] * dp[1][f-f0])`.\n    # This is the `f`-th coefficient of `P_1(x)^2`.\n    # Where `P_1(x) = sum_{j=0}^f dp[1][j] x^j`.\n    #\n    # This looks like the correct approach.\n\n    # Max `f` is `2 * 10^5`.\n    # Max `k` is `2 * 10^5`.\n    # `dp` array size `f+1`.\n    #\n    # Need NTT for polynomial multiplication.\n    # Need `comb` for `nCr`.\n    # `nCr(n, r)` function.\n\n    # --- NTT implementation (from competitive programming template) ---\n    PRIMITIVE_ROOT = 3\n    \n    def power(a, b):\n        res = 1\n        a %= MOD\n        while b > 0:\n            if b % 2 == 1:\n                res = (res * a) % MOD\n            a = (a * a) % MOD\n            b //= 2\n        return res\n\n    def inv(n):\n        return power(n, MOD - 2)\n\n    def ntt(a, invert):\n        n = len(a)\n        j = 0\n        for i in range(1, n):\n            bit = n >> 1\n            while j >= bit:\n                j -= bit\n                bit >>= 1\n            j += bit\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n\n        for length in range(2, n + 1, length):\n            wlen = power(PRIMITIVE_ROOT, (MOD - 1) // length)\n            if invert:\n                wlen = inv(wlen)\n            \n            for i in range(0, n, length):\n                w = 1\n                for k_val in range(length // 2):\n                    u = a[i + k_val]\n                    v = (a[i + k_val + length // 2] * w) % MOD\n                    a[i + k_val] = (u + v) % MOD\n                    a[i + k_val + length // 2] = (u - v + MOD) % MOD\n                    w = (w * wlen) % MOD\n        \n        if invert:\n            n_inv = inv(n)\n            for i in range(n):\n                a[i] = (a[i] * n_inv) % MOD\n    \n    def multiply(a, b):\n        len_a = len(a)\n        len_b = len(b)\n        result_len = len_a + len_b - 1\n        \n        n_fft = 1\n        while n_fft < result_len:\n            n_fft <<= 1\n        \n        fa = list(a) + [0] * (n_fft - len_a)\n        fb = list(b) + [0] * (n_fft - len_b)\n        \n        ntt(fa, False)\n        ntt(fb, False)\n        \n        for i in range(n_fft):\n            fa[i] = (fa[i] * fb[i]) % MOD\n        \n        ntt(fa, True)\n        \n        return fa[:result_len]\n\n    # --- End NTT implementation ---\n\n    # `dp[len]` will store the polynomial coefficients for `dp[len][current_f]`\n    # `dp[n]` is the base case. `dp[n][current_f] = 1` for `0 <= current_f <= k`.\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n\n    # Initialize dp[n] (base case for leaves)\n    # For a single leaf node, the sum of leaves in its subtree is just its own value.\n    # So dp[n][current_f] = 1 if 0 <= current_f <= k.\n    # We only care about current_f up to f.\n    for current_f_val in range(min(k, f) + 1):\n        dp[n][current_f_val] = 1\n\n    # Iterate from n-1 down to 1\n    for length in range(n - 1, 0, -1):\n        # P_{len+1}(x) is represented by dp[length+1]\n        # We need Q(x) = P_{len+1}(x)^2\n        # Use NTT to compute convolution.\n        \n        # Trim dp[length+1] to `f+1` elements for multiplication\n        # The actual length of the polynomial is `f+1` if we only care up to `f`.\n        # However, P_{len+1}(x)^2 can have degree up to `2f`.\n        # So we need to compute convolution up to `2f`.\n        \n        poly_next_level = dp[length + 1]\n        \n        # Perform convolution: poly_next_level * poly_next_level\n        # The result of convolution will have degree up to 2f.\n        conv_result = multiply(poly_next_level, poly_next_level)\n        \n        # Ensure conv_result has enough elements (up to 2f)\n        # If f is small, conv_result might be shorter than 2f+1. Pad with zeros.\n        conv_coeffs = [0] * (2 * f + 1)\n        for i in range(min(len(conv_result), 2 * f + 1)):\n            conv_coeffs[i] = conv_result[i]\n        \n        # Compute prefix sums S_0[p] = sum_{j=0}^p C_j\n        # And S_1[p] = sum_{j=0}^p j * C_j\n        S0 = [0] * (2 * f + 1)\n        S1 = [0] * (2 * f + 1)\n        \n        S0[0] = conv_coeffs[0]\n        S1[0] = 0 # 0 * C_0\n        \n        for p in range(1, 2 * f + 1):\n            S0[p] = (S0[p-1] + conv_coeffs[p]) % MOD\n            S1[p] = (S1[p-1] + (p * conv_coeffs[p]) % MOD) % MOD\n        \n        # Compute dp[length][current_f] for current_f from 0 to f\n        for current_f_val in range(f + 1):\n            # dp[len][current_f] = sum_{j=0}^{min(current_f, k)} C_j * (k - j + 1)\n            limit_j = min(current_f_val, k)\n            if limit_j < 0:\n                dp[length][current_f_val] = 0\n                continue\n            \n            term1 = (S0[limit_j] * (k + 1)) % MOD\n            term2 = S1[limit_j]\n            \n            dp[length][current_f_val] = (term1 - term2 + MOD) % MOD\n\n    # Final answer: sum_{f0=0 to f} (dp[1][f0] * dp[1][f-f0])\n    # This is the f-th coefficient of P_1(x)^2.\n    \n    final_poly = dp[1]\n    \n    # Perform convolution: final_poly * final_poly\n    final_conv_result = multiply(final_poly, final_poly)\n    \n    if f < len(final_conv_result):\n        print(final_conv_result[f])\n    else:\n        print(0)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 998244353\n\ndef solve():\n    n, k, f = map(int, sys.stdin.readline().split())\n\n    max_possible_size = k * (1 << (n - 1))\n\n    if f > max_possible_size:\n        print(0)\n        return\n\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(f + 1):\n            # Case 1: The current level (length i) has 0 strings.\n            # This means c_s for all strings s of length i is 0.\n            # The count of strings at length i-1 is also 0.\n            # So, dp[i][j] += dp[i-1][j]\n            dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n\n            # Case 2: The current level (length i) has some strings.\n            # The number of strings with prefix s (length i-1) is c_s.\n            # The number of strings with prefix s0 is c_s0, and s1 is c_s1.\n            # c_s = c_s0 + c_s1.\n            # The total count of strings at length i is sum(c_s for |s|=i).\n            # This is equivalent to sum(c_s for |s|=i-1).\n            # So, if we add 'x' strings at level i, it means the sum of\n            # c_s for |s|=i-1 increased by x.\n            # The total number of ways to choose c_s values for length i\n            # such that the sum is x is (x + 2^i - 1) choose (2^i - 1).\n            # This is not how it works. The problem is about total size of multiset.\n\n    # Let's re-evaluate the DP state.\n    # dp[i][j] = number of ways to choose c_s for strings of length 1 to i\n    # such that the maximum possible size of a beautiful multiset\n    # considering only prefixes of length <= i is j.\n    # This is still not quite right.\n\n    # The maximum possible size of a beautiful multiset is the sum of\n    # c_s values for strings of length n.\n    # That is, if we have a multiset M, then for any string s of length n,\n    # the count of s in M must be <= c_s.\n    # To maximize the size, we should choose count(s) = c_s for all s of length n.\n    # So the total size is sum_{|s|=n} c_s.\n\n    # Let S_L be the set of all binary strings of length L.\n    # For any s in S_L, c_s is chosen.\n    # The condition is: for any s' in S_L, count(s' is prefix) <= c_s'.\n    # This implies that for any s in S_L, c_s >= c_{s0} + c_{s1}.\n    # And for s in S_n, c_s >= count(s in multiset).\n    # To maximize multiset size, we want sum_{s in S_n} count(s) to be max.\n    # So, we choose count(s) = c_s for s in S_n.\n    # This means the maximum size is sum_{s in S_n} c_s.\n\n    # Let X_i be the sum of c_s for all strings s of length i.\n    # The conditions are:\n    # 1. 0 <= c_s <= k for all s.\n    # 2. For s of length < n, c_s >= c_{s0} + c_{s1}.\n    # The maximum multiset size is X_n.\n    # We want X_n = f.\n\n    # The condition c_s >= c_{s0} + c_{s1} can be thought of as\n    # distributing c_s items into c_{s0} and c_{s1}.\n    # If we define d_s = c_s - (c_{s0} + c_{s1}) for |s| < n, then d_s >= 0.\n    # For |s| = n, c_s is the final count.\n    # The total sum X_n = sum_{|s|=n} c_s.\n    # Let's consider the structure as a binary tree.\n    # The root is the empty string.\n    # For a node s, its children are s0 and s1.\n    # We choose a value c_s for each node.\n    # Conditions: 0 <= c_s <= k.\n    #             c_s >= c_{s0} + c_{s1} for internal nodes.\n    # We want sum of c_s at depth n to be exactly f.\n\n    # This is a dynamic programming problem on the tree structure.\n    # Since n is small (up to 15), we can use DP with states related to depth.\n    # Let dp[i][j] be the number of ways to assign c_s values for all strings\n    # of length >= i such that the sum of c_s values for strings of length i\n    # is j, and all conditions for subtrees rooted at length i are satisfied.\n    # This seems like it would be dp[i][j] = number of ways to assign c_s\n    # for all nodes in the subtree rooted at a *specific* node s of length i-1,\n    # such that c_s = j. This is not for all strings of length i.\n\n    # The problem asks for the sum of c_s at length n to be f.\n    # The number of strings of length L is 2^L.\n    # Total number of strings is 2^(n+1) - 2.\n    #\n    # Let dp[i][j] be the number of ways to assign c_s values for all strings\n    # of length from 1 to i, such that the sum of c_s values for strings of length i is j.\n    #\n    # Base case: i = 0 (empty string level, not really part of the problem)\n    # Or, i = 1: strings \"0\", \"1\".\n    # We choose c_0, c_1. 0 <= c_0, c_1 <= k.\n    # Sum c_0 + c_1 = j.\n    # Number of ways to choose c_0, c_1 such that c_0+c_1 = j is j+1 if 0<=j<=k.\n    # No, it's min(j, k) + 1 if j <= 2k.\n    # It's (j+1) for j <= k.\n    # It's (2k - j + 1) for k < j <= 2k.\n    # This is for a single pair of children.\n    #\n    # This is a standard problem: counting paths in a grid.\n    # The constraints c_s >= c_{s0} + c_{s1} mean that the sum of values\n    # at level i must be >= sum of values at level i+1.\n    # Let X_i = sum_{|s|=i} c_s.\n    # Then X_i >= X_{i+1}.\n    # Also, X_i <= 2^i * k.\n    # And X_0 = c_empty, which is not defined.\n    # Let's consider X_1 = c_0 + c_1.\n    # X_2 = c_00 + c_01 + c_10 + c_11.\n    # We have c_0 >= c_00 + c_01, c_1 >= c_10 + c_11.\n    # Summing these: c_0 + c_1 >= (c_00 + c_01) + (c_10 + c_11).\n    # So X_1 >= X_2.\n    # In general, X_i >= X_{i+1} for i from 1 to n-1.\n    # Also, 0 <= c_s <= k.\n    # This implies 0 <= X_i <= 2^i * k.\n    #\n    # We want to find the number of sequences X_1, X_2, ..., X_n such that:\n    # 1. X_n = f\n    # 2. X_i >= X_{i+1} for 1 <= i < n\n    # 3. 0 <= X_i <= 2^i * k\n    # 4. For each X_i, the number of ways to choose individual c_s values\n    #    such that their sum is X_i and 0 <= c_s <= k, and\n    #    c_s >= c_{s0} + c_{s1} for |s|=i-1.\n\n    # The problem can be rephrased:\n    # For each string s of length < n, we choose c_s.\n    # For each string s of length n, we choose c_s.\n    # The total sum of c_s for length n must be f.\n    #\n    # The crucial observation might be related to the maximum possible size.\n    # The maximum possible size of a beautiful multiset is the sum of c_s for all strings s of length n.\n    # Let S_i be the sum of c_s for strings of length i.\n    # Then S_i >= S_{i+1} for i < n.\n    # Also, 0 <= c_s <= k.\n    # So 0 <= S_i <= k * 2^i.\n    # We need to find the number of ways to choose c_s such that S_n = f.\n\n    # This is equivalent to choosing values for d_s = c_s - (c_{s0} + c_{s1}) for |s| < n,\n    # and c_s for |s|=n.\n    # d_s >= 0.\n    # c_s <= k.\n    # sum_{|s|=n} c_s = f.\n    #\n    # Let's consider the maximum value of c_s. It is k.\n    # The maximum possible sum for S_n is k * 2^n.\n    # The constraints are c_s <= k for all s.\n    # And c_s >= c_{s0} + c_{s1} for |s| < n.\n\n    # Let's use DP on the levels.\n    # dp[i][j] = number of ways to choose c_s for strings of length `i` to `n`\n    # such that `j` is the sum of `c_s` for strings of length `i`.\n    # And all constraints `c_s >= c_{s0} + c_{s1}` are satisfied downwards.\n    #\n    # Base case: dp[n][j]\n    # For strings of length `n`, we choose `c_s`. There are `2^n` such strings.\n    # We need `sum_{|s|=n} c_s = j`.\n    # Each `c_s` must be between `0` and `k`.\n    # This is a stars and bars problem with upper bound.\n    # The number of ways to choose `c_s` for `2^n` strings such that `sum c_s = j`\n    # and `0 <= c_s <= k` is `C(j + 2^n - 1, 2^n - 1)` if `j <= k`.\n    # More generally, it's `coeff of x^j in (1 + x + ... + x^k)^(2^n)`.\n    # Let `N_i = 2^i`.\n    # `dp[n][j]` is the coefficient of `x^j` in `(sum_{p=0 to k} x^p)^(N_n)`.\n    # `(sum_{p=0 to k} x^p) = (1 - x^(k+1)) / (1 - x)`.\n    # So `dp[n][j]` is `coeff of x^j in ((1 - x^(k+1)) / (1 - x))^(N_n)`.\n    # `((1 - x^(k+1)) / (1 - x))^(N_n) = (sum_{m=0 to N_n} C(N_n, m) (-1)^m x^(m(k+1))) * (sum_{p=0 to inf} C(N_n+p-1, p) x^p)`.\n    #\n    # `dp[i][j]` is the number of ways to assign values to `c_s` for all strings `s` of length `i` through `n`,\n    # such that `sum_{|s|=i} c_s = j`, and all constraints `c_s >= c_{s0} + c_{s1}` are satisfied for `|s| >= i`.\n    #\n    # For `i < n`:\n    # `dp[i][j] = sum_{j' = 0 to j} (dp[i+1][j'] * ways_to_split(j, j', N_i))`.\n    # `ways_to_split(j, j', N_i)`:\n    # This is the number of ways to choose `c_s` for `N_i` strings of length `i`,\n    # such that `sum_{|s|=i} c_s = j`, and for each `s`, `c_s >= c_{s0} + c_{s1}`,\n    # and `sum_{|s|=i+1} c_s = j'`.\n    # This means `sum_{|s|=i} (c_s - (c_{s0} + c_{s1})) = j - j'`.\n    # Let `d_s = c_s - (c_{s0} + c_{s1})`. We need `d_s >= 0`.\n    # And `c_s <= k`.\n    #\n    # The structure of the problem is:\n    # We choose `c_s` for all strings `s`.\n    # The number of ways to choose `c_s` for a *single* string `s` of length `i`\n    # such that `c_s >= c_{s0} + c_{s1}` and `c_s <= k`, and `sum_{|s'|=i+1} c_{s'} = X_{i+1}`.\n    #\n    # This is a bit complicated. Let's simplify.\n    # The values `c_s` for `|s| = n` determine the final sum `f`.\n    # The values `c_s` for `|s| < n` act as upper bounds for the sum of their children.\n    # `c_s >= c_{s0} + c_{s1}`.\n    #\n    # Consider the problem as choosing a path in a grid.\n    # Let `dp[i][current_sum]` be the number of ways to choose `c_s` values for\n    # strings of length `1` to `i`, such that `sum_{|s|=i} c_s = current_sum`.\n    #\n    # `dp[i][current_sum]`\n    # We iterate `prev_sum` for `dp[i-1][prev_sum]`.\n    # For each `prev_sum`, we need to choose `c_s` for strings of length `i-1`\n    # and `c_s'` for strings of length `i`.\n    # The constraint `c_s >= c_{s0} + c_{s1}` must hold for all `s` of length `i-1`.\n    # This means `prev_sum >= current_sum`.\n    #\n    # This means we are counting sequences `X_1, X_2, ..., X_n` such that:\n    # 1. `X_n = f`\n    # 2. `X_i >= X_{i+1}` for `1 <= i < n`\n    # 3. `0 <= X_i <= k * 2^i`\n    # 4. For each `X_i`, we need to count the number of ways to choose `c_s` for `|s|=i`\n    #    such that `sum_{|s|=i} c_s = X_i`, and `0 <= c_s <= k`.\n    #    Let `ways(L, S, K)` be the number of ways to choose `L` non-negative integers\n    #    `x_1, ..., x_L` such that `sum x_j = S` and `x_j <= K`.\n    #    This is `coeff of x^S in (1+x+...+x^K)^L`.\n    #\n    # So, `dp[i][X_i]` would be `ways(2^i, X_i, k)`.\n    # No, this is not correct. The conditions `c_s >= c_{s0} + c_{s1}` are local.\n    #\n    # Let's consider the problem from the perspective of the total sum `f`.\n    # `f = sum_{|s|=n} c_s`.\n    # For each `s` of length `n-1`, `c_s >= c_{s0} + c_{s1}`.\n    # For each `s` of length `n-2`, `c_s >= c_{s0} + c_{s1}`.\n    # ...\n    # For each `s` of length `1`, `c_s >= c_{s0} + c_{s1}`.\n    # And `0 <= c_s <= k` for all `s`.\n\n    # This is a known problem structure. It's about paths on a grid, but with values.\n    # The maximum value of `f` is `k * 2^n`.\n    # `n` is up to 15. `2^15` is `32768`.\n    # `k` is up to `2 * 10^5`.\n    # `f` is up to `2 * 10^5`.\n    # `k * 2^n` can be `2 * 10^5 * 32768` which is very large.\n    # But `f` is small.\n\n    # The maximum possible sum `f` is `k * 2^n`.\n    # But `f` itself is up to `2 * 10^5`.\n    # This means `f` is much smaller than `k * 2^n` in most cases.\n    # This suggests that `c_s` values are usually small, or many are zero.\n\n    # Let's define `dp[i][j]` as the number of ways to assign `c_s` values\n    # for all strings of length `i` to `n`, such that the sum of `c_s` values\n    # for strings of length `i` is `j`.\n    #\n    # `dp[n][j]` is the number of ways to choose `c_s` for `2^n` strings of length `n`,\n    # such that `sum c_s = j` and `0 <= c_s <= k`.\n    # This is `coeff of x^j in (1 + x + ... + x^k)^(2^n)`.\n    # Since `f` is small, `j` will be small.\n    # `2^n` can be large.\n    #\n    # Let `N_i = 2^i`.\n    # `dp[i][j]` is the number of ways to choose `c_s` for `N_i` nodes at level `i`\n    # and all their descendants, such that their sum is `j`.\n    #\n    # Transition: `dp[i][j]` from `dp[i+1][j']`.\n    # For each `s` of length `i`, we choose `c_s`.\n    # For its children `s0, s1`, we have already chosen values such that `c_{s0} + c_{s1} = child_sum_s`.\n    # The total `sum_{|s|=i+1} c_s = j'`.\n    # We need `c_s >= child_sum_s`.\n    #\n    # This is equivalent to `N_i` independent subproblems, each for a string `s` of length `i`.\n    # For a specific `s` of length `i`, we need to choose `c_s` and values for its descendants.\n    # Let `g[len][sum_val]` be the number of ways to assign `c_s` values in the subtree\n    # rooted at a generic string of length `len`, such that `c_s` (for that root string) is `sum_val`.\n    #\n    # `g[n][val]` = 1 if `0 <= val <= k`, else 0. (Base case for leaf nodes)\n    #\n    # For `g[len][val]` where `len < n`:\n    # `g[len][val] = sum_{val0=0 to val} sum_{val1=0 to val-val0} (g[len+1][val0] * g[len+1][val1])`\n    # This is for `0 <= val <= k`.\n    # `g[len][val] = sum_{child_sum=0 to val} (ways_to_split_val_into_two_children(child_sum) * g[len+1][child_sum]^2)`\n    # This is not correct. It's `sum_{val0=0 to k} sum_{val1=0 to k} (g[len+1][val0] * g[len+1][val1])`\n    # such that `val0 + val1 <= val`.\n    #\n    # Let `h[len][s]` be the number of ways to assign `c_s` values for a *single* subtree rooted at length `len`,\n    # such that the value `c_root` is `s`.\n    #\n    # Base case: `h[n][s] = 1` if `0 <= s <= k`, else `0`.\n    #\n    # For `len` from `n-1` down to `1`:\n    # `h[len][s]` for `0 <= s <= k`:\n    #   `h[len][s] = sum_{s0=0 to k} sum_{s1=0 to k} (h[len+1][s0] * h[len+1][s1])`\n    #   such that `s0 + s1 <= s`.\n    #   This is a convolution. Let `P_{len+1}(x) = sum_{j=0 to k} h[len+1][j] x^j`.\n    #   Then we need `sum_{s0=0 to k} sum_{s1=0 to k} h[len+1][s0] h[len+1][s1]` for `s0+s1 <= s`.\n    #   Let `Q_{len+1}(x) = P_{len+1}(x)^2 = sum_{j=0 to 2k} C_j x^j`.\n    #   Then `h[len][s] = sum_{j=0 to s} C_j`. This is prefix sums of `Q_{len+1}(x)`.\n    #   The upper bound `s` for `s0+s1` is important.\n    #   Also, `s0` and `s1` can be at most `k`.\n    #   The maximum possible value for `s0+s1` is `2k`.\n    #   So `h[len][s]` for `s > 2k` is the same as `h[len][2k]`.\n    #   We only care about `s <= k`.\n    #   So `h[len][s] = sum_{j=0 to s} C_j` for `s <= k`.\n    #   `h[len][s]` is `sum_{j=0 to s} (coeff of x^j in P_{len+1}(x)^2)`.\n    #   This is `sum_{s0=0 to k} sum_{s1=0 to k, s0+s1 <= s} h[len+1][s0] * h[len+1][s1]`.\n    #   This is a prefix sum of a convolution.\n    #   `P_{len+1}(x)` is a polynomial of degree `k`. `P_{len+1}(x)^2` is degree `2k`.\n    #   We need to compute `h[len][s]` for `s` from `0` to `k`.\n    #   The maximum value of `k` is `2 * 10^5`.\n    #   This convolution is `O(k log k)` using FFT, or `O(k^2)` directly.\n    #   `n` iterations. `n * k^2` is too slow. `n * k log k` is feasible.\n    #   `15 * 2 * 10^5 * log(2 * 10^5)` is `15 * 2 * 10^5 * 18` approx `5.4 * 10^7`.\n    #   This might be too slow for `MOD` arithmetic (NTT).\n    #   `k` is `2 * 10^5`. `2k` is `4 * 10^5`.\n    #   Need to compute `h[len][s]` for `s` up to `k`.\n    #\n    #   Let `A[j] = h[len+1][j]`. We need to compute `B[s] = sum_{j=0 to s} (A * A)[j]`.\n    #   `A` has length `k+1`. `A*A` has length `2k+1`.\n    #   The NTT approach is possible.\n\n    # Precompute factorials and inverse factorials for combinations.\n    # `dp[n][j]` calculation for `(sum_{p=0 to k} x^p)^(2^n)` is not needed if we use `h[n][s]`.\n    #\n    # The final answer is `sum_{j=0 to k} (h[1][j] * num_ways_to_distribute(j, f))`.\n    # This is `h[1][f]` if `f <= k`.\n    # No, this is `h[1][j]` for a single root string.\n    # The problem is about `sum_{|s|=n} c_s = f`.\n    #\n    # Let `g[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    # such that `sum_{|s|=i} c_s = j`.\n    # This is exactly what we need.\n    #\n    # Base case: `g[n][j]`\n    # This is the number of ways to choose `2^n` integers `c_s` such that `0 <= c_s <= k` and `sum c_s = j`.\n    # Let `N_n = 2^n`.\n    # `g[n][j] = coeff of x^j in (1 + x + ... + x^k)^(N_n)`.\n    # This can be computed using generating functions.\n    # `(1 - x^(k+1))^(N_n) * (1 - x)^(-N_n)`\n    # `(sum_{m=0 to N_n} C(N_n, m) (-1)^m x^(m(k+1))) * (sum_{p=0 to inf} C(N_n+p-1, p) x^p)`\n    # `g[n][j] = sum_{m=0 to N_n, m(k+1) <= j} C(N_n, m) (-1)^m * C(N_n + (j - m(k+1)) - 1, (j - m(k+1)))`.\n    # This is for `j` up to `f`. `f` is up to `2 * 10^5`.\n    # `N_n` can be up to `2^15 = 32768`.\n    # This sum takes `O(f / k)` terms. Max `f / k` is `2 * 10^5 / 1 = 2 * 10^5`.\n    # Max `N_n` is `32768`.\n    # This sum is `O(min(N_n, f / (k+1)))`. Max `min(32768, 2 * 10^5 / 1) = 32768`.\n    # So `g[n][j]` can be computed in `O(min(N_n, f/k))` for each `j`.\n    # Total for `g[n]` is `O(f * min(N_n, f/k))`. This is too slow.\n    # `2 * 10^5 * 32768` is too large.\n    #\n    # We need to compute `g[n][j]` for all `j` from `0` to `f`.\n    # This is a polynomial multiplication. `(1+x+...+x^k)^(N_n)`.\n    # If `N_n` is large, we can use binary exponentiation for polynomials.\n    # `O(k log(N_n) log k)` using NTT.\n    # `k log(2^n) log k = k * n * log k`.\n    # `2 * 10^5 * 15 * log(2 * 10^5)` is `2 * 10^5 * 15 * 18` approx `5.4 * 10^7`.\n    # This is feasible for `g[n][j]` for `j` up to `f`.\n    # The degree of the polynomial is `k * N_n`. We only need up to `f`.\n    # So `k` in `k log k` should be `f`.\n    # `f * n * log f`. `2 * 10^5 * 15 * log(2 * 10^5)` approx `5.4 * 10^7`. This is okay.\n    # So `g[n][j]` for `j=0..f` can be computed.\n\n    # Transition for `g[i][j]` from `g[i+1][j']`:\n    # `g[i][j] = sum_{j'=0 to j} (g[i+1][j'] * num_ways_to_choose_c_s_at_level_i(j, j'))`.\n    # `num_ways_to_choose_c_s_at_level_i(j, j')`:\n    # This is the number of ways to choose `N_i = 2^i` values `c_s` (for `|s|=i`)\n    # such that `sum c_s = j`, and for each `s`, `0 <= c_s <= k`, and\n    # `c_s >= child_sum_s`.\n    # The `child_sum_s` values sum up to `j'`.\n    # This is equivalent to choosing `d_s = c_s - child_sum_s >= 0`.\n    # `sum d_s = j - j'`.\n    # And `c_s <= k` implies `d_s <= k - child_sum_s`.\n    #\n    # This is still not quite right.\n    # The `g[i][j]` definition implies that the values `c_s` for `|s|=i` are chosen,\n    # and for each `s` of length `i`, `c_s` serves as the `val` in `h[i][val]`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`,\n    # such that the sum of `c_s` for strings of length `i` is `j`.\n    #\n    # `dp[n][j]` is `coeff of x^j in (sum_{p=0 to k} x^p)^(2^n)`.\n    # Let `P_i(x) = sum_{j=0}^{k \\cdot 2^i} dp[i][j] x^j`.\n    #\n    # For `i` from `n-1` down to `1`:\n    # We want to compute `dp[i][j]`.\n    # For each string `s` of length `i`, we choose `c_s`. `0 <= c_s <= k`.\n    # For its children `s0, s1`, they will have values `c_{s0}, c_{s1}`.\n    # We know `dp[i+1][j']` counts ways to assign values for `2^{i+1}` strings of length `i+1` and their descendants,\n    # such that their sum is `j'`.\n    #\n    # For a string `s` of length `i`, we need to choose `c_s`.\n    # We also need to choose `c_{s0}, c_{s1}` and their descendants such that `c_s >= c_{s0} + c_{s1}`.\n    # The values `c_{s0}, c_{s1}` are chosen from `dp[i+1]` effectively.\n    #\n    # Let `h[len][val]` be the number of ways to assign `c_s` values for a *single* subtree rooted at length `len`,\n    # such that the value `c_root` is `val`.\n    #\n    # Base case: `h[n][val] = 1` if `0 <= val <= k`, else `0`.\n    #\n    # For `len` from `n-1` down to `1`:\n    # `h[len][val]` for `0 <= val <= k`:\n    #   `h[len][val] = sum_{s0=0 to k} sum_{s1=0 to k} (h[len+1][s0] * h[len+1][s1])`\n    #   such that `s0 + s1 <= val`.\n    #\n    # Let `P_L(x) = sum_{s=0}^k h[L][s] x^s`.\n    # Then `P_{L-1}(x)` can be computed from `P_L(x)`.\n    # `P_L(x)^2 = sum_{j=0}^{2k} C_j x^j`.\n    # `h[L-1][s] = sum_{j=0}^s C_j` for `s` from `0` to `k`.\n    #\n    # This can be computed iteratively.\n    # `h[n]` is `[1, 1, ..., 1]` (k+1 ones).\n    # `h[n-1]` involves `h[n]^2`.\n    # `h[n-1][s] = sum_{s0=0 to k} sum_{s1=0 to k, s0+s1 <= s} 1 * 1`.\n    # `h[n-1][s] = sum_{s0=0 to k} (s - s0 + 1)` (if `s - s0 >= 0`).\n    # No, `h[n-1][s] = sum_{s0=0 to min(s, k)} (min(s - s0, k) + 1)`.\n    # Example: `k=1`. `h[n] = [1, 1]`.\n    # `h[n-1][0]`: `s0+s1 <= 0` => `s0=0, s1=0`. `1*1=1`.\n    # `h[n-1][1]`: `s0+s1 <= 1`.\n    #   `s0=0, s1=0`: `1*1=1`\n    #   `s0=0, s1=1`: `1*1=1`\n    #   `s0=1, s1=0`: `1*1=1`\n    #   Total `3`.\n    # `h[n-1] = [1, 3]`.\n    #\n    # Example: `k=2`. `h[n] = [1, 1, 1]`.\n    # `h[n-1][0]`: `s0=0, s1=0`. `1`.\n    # `h[n-1][1]`: `s0+s1 <= 1`. `(0,0), (0,1), (1,0)`. `3`.\n    # `h[n-1][2]`: `s0+s1 <= 2`. `(0,0), (0,1), (0,2), (1,0), (1,1), (2,0)`. `6`.\n    # `h[n-1] = [1, 3, 6]`.\n    #\n    # This is a prefix sum of a prefix sum.\n    # Let `A_L[j] = h[L][j]`.\n    # Let `B_L[s] = sum_{s0=0}^k sum_{s1=0}^k A_L[s0] A_L[s1]` for `s0+s1=s`. (Convolution `A_L * A_L`)\n    # Let `C_L[s] = sum_{p=0}^s B_L[p]`. (Prefix sum of convolution)\n    # Then `A_{L-1}[s] = C_L[s]` for `s <= k`.\n    #\n    # This computation `A_L * A_L` takes `O(k^2)`. `n` iterations. `n * k^2` is too slow.\n    # `n * k log k` with NTT. Max `k` for `h` is `k`.\n    # Max degree `2k`. So `2k log(2k)` per step.\n    # `n * (2k) log(2k)` is `15 * 4 * 10^5 * 19` approx `1.1 * 10^8`. This might be too slow.\n    # But `k` is up to `2*10^5`, `f` is up to `2*10^5`.\n    # The actual `k` for `h[len][s]` is `min(k, f)`.\n    # No, `k` is the maximum value for `c_s`. `f` is the target sum.\n    # So `h[len][s]` for `s` up to `k`.\n\n    # The maximum value for `s` in `h[len][s]` is `k`.\n    # `P_L(x)` has degree `k`. `P_L(x)^2` has degree `2k`.\n    # We need `h[L-1][s]` for `s` up to `k`.\n    # So we need `C_L[s]` for `s` up to `k`.\n    # We can compute `P_L(x)^2` up to degree `2k`.\n    # This is `O(k log k)` using NTT.\n    # Then compute prefix sums `C_L[s]` up to `k`. `O(k)`.\n    # Total `n * (k log k)`. This is `15 * 2 * 10^5 * 18` approx `5.4 * 10^7`.\n    # This is feasible.\n\n    # After computing `h[1][s]` for `s` from `0` to `k`.\n    # `h[1][s]` is the number of ways to choose `c_s` for the entire tree\n    # rooted at '0' or '1' such that `c_0 = s` (or `c_1 = s`).\n    #\n    # The problem asks for the total number of ways to choose `c_s` for all strings\n    # of length `1` to `n` such that `sum_{|s|=n} c_s = f`.\n    #\n    # Let `H_L` be the polynomial `P_L(x)`.\n    # `H_n(x) = sum_{s=0}^k 1 * x^s`.\n    # `H_{L-1}(x) = sum_{s=0}^k (sum_{j=0}^s coeff(H_L(x)^2, j)) x^s`.\n    # We compute `H_1(x)`. This `H_1(x)` is for a single subtree rooted at length 1.\n    # There are two such subtrees: one for '0' and one for '1'.\n    # Let `h_1[s]` be the coefficients of `H_1(x)`.\n    # We need to choose `c_0` and `c_1` such that `c_0 + c_1` is some value.\n    # And `sum_{|s|=n} c_s = f`.\n    #\n    # The definition of `h[len][val]` is the number of ways to assign `c_s` values\n    # for all descendants of a *single* node `s` of length `len-1`, such that `c_s = val`.\n    # The final sum `f` is `sum_{s \\in S_n} c_s`.\n    # This means `f` is the sum of `c_s` for all leaf nodes.\n    #\n    # The sum `sum_{s \\in S_n} c_s` is actually determined by `c_s` values for `|s|=1`.\n    # `sum_{s \\in S_n} c_s = sum_{s \\in S_{n-1}} (c_{s0} + c_{s1})`.\n    # And `c_s >= c_{s0} + c_{s1}`.\n    # So `sum_{s \\in S_n} c_s <= sum_{s \\in S_{n-1}} c_s`.\n    # `f <= X_{n-1} <= X_{n-2} <= ... <= X_1`.\n    # And `X_1 = c_0 + c_1`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`,\n    # such that `sum_{|s|=i} c_s = j`.\n    # This is exactly what `h[i][j]` is for a *single* node.\n    #\n    # The number of strings of length `i` is `2^i`.\n    # The total number of ways is `sum_{j=0 to f} (dp[1][j] * ways_to_get_f_from_j_at_level_1)`.\n    # This implies that `dp[1][j]` should be the number of ways to pick `c_s` for *all* strings of length 1.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings of length `i` to `n`,\n    # such that `sum_{|s|=i} c_s = j`.\n    #\n    # Base case: `dp[n][j]` is the number of ways to choose `2^n` integers `c_s` (for `|s|=n`)\n    # such that `0 <= c_s <= k` and `sum c_s = j`.\n    # This is `coeff of x^j in (1 + x + ... + x^k)^(2^n)`.\n    # This is `coeff of x^j in ((1-x^(k+1))/(1-x))^(2^n)`.\n    # We need to compute this for `j` from `0` to `f`.\n    # This is `O(f * min(2^n, f/(k+1)))` if done naively.\n    # Using NTT for polynomial exponentiation `(P(x))^{2^n}` is `O(f * n * log f)`.\n    # No, it's `O(f log(2^n) log f)` is `O(f * n * log f)`.\n    # This polynomial `Q(x) = (1+x+...+x^k)` has degree `k`.\n    # `Q(x)^{2^n}` has degree `k * 2^n`.\n    # We only need coefficients up to `f`.\n    # So, we compute `Q(x)^{2^n}` modulo `x^{f+1}`.\n    # This can be done by `log_mod_x_power_m` and `exp_mod_x_power_m` (polynomial exponentiation).\n    # `P(x)^E = exp(E * log(P(x))) mod x^m`.\n    # `E` is `2^n`. `m` is `f+1`.\n    # This takes `O(m log m)`.\n    # So `O(f log f)`. This is `2 * 10^5 * 18` approx `3.6 * 10^6`. This is feasible.\n    #\n    # Let `P_i(x) = sum_{j=0}^{f} dp[i][j] x^j`.\n    #\n    # For `i` from `n-1` down to `1`:\n    # `P_i(x)` from `P_{i+1}(x)`.\n    # `dp[i][j]` is the number of ways to choose `c_s` for `2^i` nodes at level `i`,\n    # such that `sum c_s = j`.\n    # For each node `s` at level `i`, `c_s` is chosen. `0 <= c_s <= k`.\n    # The descendants of `s` (rooted at `s0` and `s1`) must satisfy `c_s >= c_{s0} + c_{s1}`.\n    # The total sum for `s0, s1` and their descendants is counted in `P_{i+1}(x)`.\n    #\n    # This is where the `h[len][val]` definition comes in.\n    # `h[len][val]` is the number of ways to assign `c_s` values for a *single* subtree rooted at length `len`,\n    # such that `c_root = val`, and `sum_{leaf_descendants} c_leaf = val`.\n    # No, this is not true. `sum_{leaf_descendants} c_leaf` can be smaller than `val`.\n    #\n    # The condition `c_s >= c_{s0} + c_{s1}` means `c_s` is an upper bound for the sum of its children's `c` values.\n    # The sum `f` is `sum_{|s|=n} c_s`.\n    #\n    # Let `g[i][val]` be the number of ways to choose `c_s` for strings `s'` in the subtree rooted at a *single* string `s` of length `i-1`, such that `c_s = val`.\n    # Base case: `g[n][val] = 1` for `0 <= val <= k`, else `0`.\n    # For `i` from `n` down to `2`:\n    # `g[i-1][val]` for `0 <= val <= k`:\n    #   `g[i-1][val] = sum_{v0=0 to k} sum_{v1=0 to k} (g[i][v0] * g[i][v1])`\n    #   such that `v0 + v1 <= val`.\n    # This means `g[i-1][val]` is the `val`-th prefix sum of the convolution `(G_i(x))^2`, where `G_i(x) = sum g[i][j] x^j`.\n    # We compute `G_i(x)^2` up to degree `2k`. Then take prefix sums up to `k`.\n    # This takes `O(k log k)` per level. `n` levels. Total `O(n k log k)`.\n    # After computing `g[1][val]` for `val` from `0` to `k`.\n    # `g[1][val]` is the number of ways to assign `c_s` values for a *single* string of length 0 (empty string)\n    # such that `c_empty = val`.\n    # The problem asks for `sum_{|s|=n} c_s = f`.\n    #\n    # The root of the tree is an implicit empty string. Let's call its value `c_root`.\n    # `c_root >= c_0 + c_1`.\n    # `c_0 >= c_{00} + c_{01}`.\n    # ...\n    # `c_s >= c_{s0} + c_{s1}`.\n    # We need `sum_{|s|=n} c_s = f`.\n    #\n    # The calculation of `g[i][val]` is correct.\n    # Let `P_i(x) = sum_{val=0}^k g[i][val] x^{val}`.\n    # `P_n(x) = sum_{val=0}^k x^{val}`.\n    # For `i = n-1` down to `1`:\n    # `Q(x) = P_{i+1}(x)^2`. Compute `Q(x)` up to degree `2k`.\n    # `g[i][val] = sum_{j=0}^val coeff(Q(x), j)` for `val` from `0` to `k`.\n    #\n    # After computing `g[1][val]` for `val` from `0` to `k`.\n    # This `g[1][val]` is the number of ways to choose `c_s` for all strings `s` of length `1` to `n`\n    # such that `c_0 + c_1 = val`.\n    # This is because `g[1][val]` is defined for a single string of length 1.\n    # There are two strings of length 1: \"0\" and \"1\".\n    # So for `c_0`, we can pick `val0` ways from `g[1][val0]`.\n    # For `c_1`, we can pick `val1` ways from `g[1][val1]`.\n    # The total sum `f` is `sum_{|s|=n} c_s`.\n    #\n    # The maximum possible sum `f` for a subtree rooted at `len` with `c_root = val` is `val`.\n    # `f = sum_{|s|=n} c_s`.\n    # `sum_{|s|=n} c_s <= sum_{|s|=n-1} c_s <= ... <= sum_{|s|=1} c_s`.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`,\n    # such that `sum_{|s|=i} c_s = j`.\n    #\n    # Base case: `dp[n][j]` is the number of ways to choose `2^n` integers `c_s` (for `|s|=n`)\n    # such that `0 <= c_s <= k` and `sum c_s = j`.\n    # This is `coeff of x^j in (sum_{p=0 to k} x^p)^(2^n)`.\n    # Let `P_n(x) = (sum_{p=0 to k} x^p)^(2^n)`. We need to compute `P_n(x)` up to `x^f`.\n    # This takes `O(f log f)` using polynomial exponentiation.\n    #\n    # For `i` from `n-1` down to `1`:\n    # `dp[i][j]` is the number of ways to choose `c_s` for `2^i` nodes at level `i`\n    # such that `sum c_s = j`.\n    # And for each `s` at level `i`, `c_s` must be `0 <= c_s <= k`,\n    # and `c_s >= c_{s0} + c_{s1}`.\n    # The values `c_{s0}, c_{s1}` and their descendants are already accounted for in `dp[i+1]`.\n    #\n    # This is the tricky part. `dp[i+1][j']` is the sum over all `2^{i+1}` nodes.\n    # It's not about a single node's children.\n    #\n    # The structure of the problem is a bit like:\n    # `f = sum_{leaf} c_leaf`.\n    # Each `c_node` is `0..k`.\n    # `c_node >= c_left_child + c_right_child`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose values for all `c_s` where `s` is of length `i` or greater,\n    # such that `sum_{|s|=i} c_s = j`.\n    #\n    # `dp[n][j]` is computed using polynomial exponentiation `(1+x+...+x^k)^{2^n}` up to `x^f`.\n    #\n    # For `i` from `n-1` down to `1`:\n    # We want to compute `dp[i][j]` for `j` from `0` to `f`.\n    # `dp[i][j] = sum_{j_prev=0 to f} (dp[i+1][j_prev] * ways_to_choose_current_level(j, j_prev, i))`.\n    # `ways_to_choose_current_level(j, j_prev, i)`:\n    # This is the number of ways to choose `2^i` values `c_s` (for `|s|=i`)\n    # such that `sum c_s = j`, and `0 <= c_s <= k`.\n    # And for each `s`, `c_s >= c_{s0} + c_{s1}`.\n    # The `c_{s0}, c_{s1}` values for all `2^{i+1}` children sum to `j_prev`.\n    #\n    # This is a known problem pattern: the values `c_s` at level `i` are \"containers\" for the values at level `i+1`.\n    # The total number of items at level `i+1` is `j_prev`.\n    # We need to distribute these `j_prev` items into `2^i` pairs of children.\n    # Let `c_{s0} + c_{s1} = child_sum_s`.\n    # Then `sum_{s} child_sum_s = j_prev`.\n    # We need to choose `c_s` for each `s` such that `c_s >= child_sum_s` and `0 <= c_s <= k`.\n    #\n    # This is a convolution.\n    # Let `A_i[j]` be the `dp[i][j]` values.\n    # `A_i[j] = sum_{j_child=0 to j} (A_{i+1}[j_child] * ways_to_choose_parent_values(j, j_child, i))`.\n    # `ways_to_choose_parent_values(j, j_child, i)` is the number of ways to choose `2^i` values `c_s`\n    # such that `sum c_s = j`, `0 <= c_s <= k`, and for each `s`, `c_s >= child_sum_s`.\n    # And `sum child_sum_s = j_child`.\n    #\n    # This is equivalent to choosing `d_s = c_s - child_sum_s >= 0`.\n    # `sum d_s = j - j_child`.\n    # `d_s <= k - child_sum_s`.\n    #\n    # This means we need `dp[i][j]` where `j` is the sum of `c_s` for `2^i` nodes.\n    # `dp[i][j]` is computed from `dp[i+1][j']`.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`,\n    # such that `sum_{s \\text{ of length } i} c_s = j`.\n    #\n    # `dp[n][j]` is `coeff of x^j in (sum_{p=0 to k} x^p)^{2^n}`. Compute this for `j` up to `f`.\n    # This is `O(f log f)` using polynomial exponentiation (NTT).\n    #\n    # For `i = n-1` down to `1`:\n    # `dp[i][j]` is the number of ways to choose `c_s` for `2^i` strings of length `i` and their descendants.\n    # The sum of `c_s` for these `2^i` strings is `j`.\n    # For each string `s` of length `i`, we choose `c_s`.\n    # And for its children `s0, s1`, and their descendants, we choose values such that `c_s >= c_{s0} + c_{s1}`.\n    #\n    # This is the `h[len][val]` approach.\n    # `h[len][val]` is the number of ways to assign `c_s` values in a *single* subtree rooted at length `len`,\n    # such that the value `c_root` is `val`.\n    # The final answer is `h[1][f]` if `f <= k`.\n    #\n    # The `f` value is `sum_{|s|=n} c_s`.\n    # If `h[len][val]` represents the number of ways to assign `c_s` values in a subtree,\n    # such that `c_root = val`, and *also* `sum_{leaves in subtree} c_leaf = val`?\n    # No, this is not true.\n    # `c_s >= c_{s0} + c_{s1}`.\n    # `sum_{leaves} c_leaf <= c_root`.\n    # So if `f` is the sum of leaves, `f <= c_root`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for strings `s` of length `i` to `n`\n    # in a *single* subtree rooted at length `i-1`, such that `sum_{|s|=n, s \\text{ in subtree}} c_s = j`.\n    # And `c_{root_of_subtree} <= k`.\n    #\n    # Base case: `dp[n][j]` is for a subtree rooted at length `n-1`.\n    # It has two children `s0, s1` of length `n`.\n    # We choose `c_{s0}, c_{s1}` such that `c_{s0} + c_{s1} = j`.\n    # `0 <= c_{s0}, c_{s1} <= k`.\n    # The number of ways is `min(j, k) - max(0, j-k) + 1`. This is `max(0, k - |j-k| + 1)`.\n    # This is `j+1` for `j <= k`. And `2k-j+1` for `k < j <= 2k`.\n    # This is `coeff of x^j in (1+x+...+x^k)^2`.\n    # Let `P_i(x) = sum_{j=0}^{k \\cdot 2^{n-i+1}} dp[i][j] x^j`.\n    #\n    # For `i` from `n` down to `1`:\n    # `P_i(x)` is a polynomial where `dp[i][j]` is the number of ways to assign `c_s` values\n    # for a subtree rooted at length `i-1`, such that `sum_{leaves in subtree} c_leaf = j`.\n    # The maximum sum of leaves for a subtree rooted at `len` is `k * 2^(n-len)`.\n    #\n    # Let `dp[len][current_f]` be the number of ways to choose `c_s` values for a *single* subtree\n    # rooted at length `len`, such that `sum_{leaves in subtree} c_leaf = current_f`.\n    #\n    # Base case: `dp[n][current_f] = 1` if `0 <= current_f <= k`, else `0`. (For a single leaf node).\n    #\n    # For `len` from `n-1` down to `1`:\n    # We want to compute `dp[len][current_f]` for `current_f` from `0` to `f`.\n    # For a node `s` at length `len`, we need to choose `c_s`. `0 <= c_s <= k`.\n    # And `c_s >= c_{s0} + c_{s1}`.\n    # `dp[len][current_f] = sum_{c_s=0 to k} (sum_{f0=0 to current_f} sum_{f1=0 to current_f-f0} (dp[len+1][f0] * dp[len+1][f1]))`\n    # such that `c_s >= f0 + f1`.\n    #\n    # This is the correct DP formulation.\n    # Let `P_{len+1}(x) = sum_{j=0}^f dp[len+1][j] x^j`.\n    # We need `Q(x) = P_{len+1}(x)^2 = sum_{j=0}^{2f} C_j x^j`. (Convolution up to `2f`).\n    #\n    # `dp[len][current_f] = sum_{j=0}^{current_f} C_j * (k - j + 1)` (if `j <= k`).\n    # If `j > k`, then `k - j + 1` is `0`.\n    #\n    # `dp[len][current_f] = sum_{j=0}^{min(current_f, k)} C_j * (k - j + 1)`.\n    # This is `sum_{j=0}^{min(current_f, k)} C_j * (k+1) - sum_{j=0}^{min(current_f, k)} C_j * j`.\n    # This is a prefix sum of `C_j` and a prefix sum of `j * C_j`.\n    #\n    # Compute `Q(x) = P_{len+1}(x)^2` using NTT. This takes `O(f log f)`.\n    # Compute prefix sums `S_0[p] = sum_{j=0}^p C_j`.\n    # Compute prefix sums `S_1[p] = sum_{j=0}^p j * C_j`.\n    # Then `dp[len][current_f] = (S_0[min(current_f, k)] * (k+1) - S_1[min(current_f, k)]) % MOD`.\n    # This takes `O(f)` after `O(f log f)` convolution.\n    # Total `n` levels. `O(n * f log f)`.\n    # `15 * 2 * 10^5 * 18` approx `5.4 * 10^7`. This is feasible.\n\n    # After computing `dp[1][current_f]` for `current_f` from `0` to `f`.\n    # `dp[1][current_f]` is the number of ways to assign `c_s` values for a single subtree\n    # rooted at length 1, such that `sum_{leaves in subtree} c_leaf = current_f`.\n    #\n    # The problem has a global root (empty string).\n    # The two children are '0' and '1'.\n    # For '0' subtree, `sum_{leaves} c_leaf = f_0`.\n    # For '1' subtree, `sum_{leaves} c_leaf = f_1`.\n    # We need `f_0 + f_1 = f`.\n    # The number of ways for '0' subtree is `dp[1][f_0]`.\n    # The number of ways for '1' subtree is `dp[1][f_1]`.\n    # The value `c_0` must be `0 <= c_0 <= k` and `c_0 >= sum_{leaves in 0 subtree} c_leaf`.\n    # This means `c_0 >= f_0`.\n    # Similarly `c_1 >= f_1`.\n    #\n    # So the total answer is `sum_{f0=0 to f} (dp[1][f0] * dp[1][f-f0])`.\n    # This is the `f`-th coefficient of `P_1(x)^2`.\n    # Where `P_1(x) = sum_{j=0}^f dp[1][j] x^j`.\n    #\n    # This looks like the correct approach.\n\n    # Max `f` is `2 * 10^5`.\n    # Max `k` is `2 * 10^5`.\n    # `dp` array size `f+1`.\n    #\n    # Need NTT for polynomial multiplication.\n    # Need `comb` for `nCr`.\n    # `nCr(n, r)` function.\n\n    # --- NTT implementation (from competitive programming template) ---\n    PRIMITIVE_ROOT = 3\n    \n    def power(a, b):\n        res = 1\n        a %= MOD\n        while b > 0:\n            if b % 2 == 1:\n                res = (res * a) % MOD\n            a = (a * a) % MOD\n            b //= 2\n        return res\n\n    def inv(n):\n        return power(n, MOD - 2)\n\n    def ntt(a, invert):\n        n = len(a)\n        j = 0\n        for i in range(1, n):\n            bit = n >> 1\n            while j >= bit:\n                j -= bit\n                bit >>= 1\n            j += bit\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n\n        for length in range(2, n + 1, length):\n            wlen = power(PRIMITIVE_ROOT, (MOD - 1) // length)\n            if invert:\n                wlen = inv(wlen)\n            \n            for i in range(0, n, length):\n                w = 1\n                for k_val in range(length // 2):\n                    u = a[i + k_val]\n                    v = (a[i + k_val + length // 2] * w) % MOD\n                    a[i + k_val] = (u + v) % MOD\n                    a[i + k_val + length // 2] = (u - v + MOD) % MOD\n                    w = (w * wlen) % MOD\n        \n        if invert:\n            n_inv = inv(n)\n            for i in range(n):\n                a[i] = (a[i] * n_inv) % MOD\n    \n    def multiply(a, b):\n        len_a = len(a)\n        len_b = len(b)\n        result_len = len_a + len_b - 1\n        \n        n_fft = 1\n        while n_fft < result_len:\n            n_fft <<= 1\n        \n        fa = list(a) + [0] * (n_fft - len_a)\n        fb = list(b) + [0] * (n_fft - len_b)\n        \n        ntt(fa, False)\n        ntt(fb, False)\n        \n        for i in range(n_fft):\n            fa[i] = (fa[i] * fb[i]) % MOD\n        \n        ntt(fa, True)\n        \n        return fa[:result_len]\n\n    # --- End NTT implementation ---\n\n    # `dp[len]` will store the polynomial coefficients for `dp[len][current_f]`\n    # `dp[n]` is the base case. `dp[n][current_f] = 1` for `0 <= current_f <= k`.\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n\n    # Initialize dp[n] (base case for leaves)\n    # For a single leaf node, the sum of leaves in its subtree is just its own value.\n    # So dp[n][current_f] = 1 if 0 <= current_f <= k.\n    # We only care about current_f up to f.\n    for current_f_val in range(min(k, f) + 1):\n        dp[n][current_f_val] = 1\n\n    # Iterate from n-1 down to 1\n    for length in range(n - 1, 0, -1):\n        # P_{len+1}(x) is represented by dp[length+1]\n        # We need Q(x) = P_{len+1}(x)^2\n        # Use NTT to compute convolution.\n        \n        # Trim dp[length+1] to `f+1` elements for multiplication\n        # The actual length of the polynomial is `f+1` if we only care up to `f`.\n        # However, P_{len+1}(x)^2 can have degree up to `2f`.\n        # So we need to compute convolution up to `2f`.\n        \n        poly_next_level = dp[length + 1]\n        \n        # Perform convolution: poly_next_level * poly_next_level\n        # The result of convolution will have degree up to 2f.\n        conv_result = multiply(poly_next_level, poly_next_level)\n        \n        # Ensure conv_result has enough elements (up to 2f)\n        # If f is small, conv_result might be shorter than 2f+1. Pad with zeros.\n        conv_coeffs = [0] * (2 * f + 1)\n        for i in range(min(len(conv_result), 2 * f + 1)):\n            conv_coeffs[i] = conv_result[i]\n        \n        # Compute prefix sums S_0[p] = sum_{j=0}^p C_j\n        # And S_1[p] = sum_{j=0}^p j * C_j\n        S0 = [0] * (2 * f + 1)\n        S1 = [0] * (2 * f + 1)\n        \n        S0[0] = conv_coeffs[0]\n        S1[0] = 0 # 0 * C_0\n        \n        for p in range(1, 2 * f + 1):\n            S0[p] = (S0[p-1] + conv_coeffs[p]) % MOD\n            S1[p] = (S1[p-1] + (p * conv_coeffs[p]) % MOD) % MOD\n        \n        # Compute dp[length][current_f] for current_f from 0 to f\n        for current_f_val in range(f + 1):\n            # dp[len][current_f] = sum_{j=0}^{min(current_f, k)} C_j * (k - j + 1)\n            limit_j = min(current_f_val, k)\n            if limit_j < 0:\n                dp[length][current_f_val] = 0\n                continue\n            \n            term1 = (S0[limit_j] * (k + 1)) % MOD\n            term2 = S1[limit_j]\n            \n            dp[length][current_f_val] = (term1 - term2 + MOD) % MOD\n\n    # Final answer: sum_{f0=0 to f} (dp[1][f0] * dp[1][f-f0])\n    # This is the f-th coefficient of P_1(x)^2.\n    \n    final_poly = dp[1]\n    \n    # Perform convolution: final_poly * final_poly\n    final_conv_result = multiply(final_poly, final_poly)\n    \n    if f < len(final_conv_result):\n        print(final_conv_result[f])\n    else:\n        print(0)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 1042,
        "completion_token_count": 17276,
        "thoughts_token_count": 0
    }
}