{
    "start": 1758293710.9024222,
    "end": 1758293836.225352,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:57 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nMOD = 1000000007\nMAXN = 200005\n\nfact = [1] * MAXN\ninv_fact = [1] * MAXN\n\ndef precompute_factorials():\n    for i in range(1, MAXN):\n        fact[i] = (fact[i - 1] * i) % MOD\n    inv_fact[MAXN - 1] = pow(fact[MAXN - 1], MOD - 2, MOD)\n    for i in range(MAXN - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n - r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\nn, m, g = map(int, input().split())\n\nif n == 0:\n    if m == 1:\n        print(1 if g == 1 else 0)\n    else:\n        print(1 if g == 0 else 0)\n    exit()\n\nif m == 0:\n    print(1 if g == (n % 2) else 0)\n    exit()\n\nans = 0\n\nif g == 1:\n    # If g is 1, the final character must be 1.\n    # This means the number of 1s in the string must be odd,\n    # or the number of 0s must be even and the number of 1s must be even.\n    # The rule is: (final_char == 1) iff (num_ones_in_suffix == 1 and num_zeros_in_suffix == 0)\n    # OR (num_ones_in_suffix == 0 and num_zeros_in_suffix == 1)\n    # The final character is 1 if the number of 1s is odd.\n    # The final character is 0 if the number of 1s is even.\n    # This is equivalent to (count of 1s) % 2.\n    # So we need (m % 2) == 1.\n    # If m is odd, then the final character is 1.\n    # If m is even, then the final character is 0.\n    # Thus, if g == 1, we need m to be odd.\n    if m % 2 == 1:\n        for k in range(1, m + 1, 2): # k is the number of 1s. We need k to be odd.\n            # We place k ones and n zeros.\n            # The remaining m-k ones are placed with 0s.\n            # We need to choose k positions for 1s out of n+k positions, such that\n            # there are at least one 0 between any two 1s, and at least one 0 at the ends.\n            # This is equivalent to placing k ones and n zeros such that no two 1s are adjacent.\n            # This is a stars and bars problem.\n            # Consider n zeros as n \"slots\" or separators. _ 0 _ 0 _ ... _ 0 _\n            # There are n+1 possible places to put 1s.\n            # We need to choose k of these places.\n            # The number of ways to choose k places for 1s among n+1 slots is C(n+1, k).\n            # This is for the case where we have n zeros and k ones, and no two ones are adjacent.\n            # However, the problem statement is about the transformation rule.\n            # The transformation rule means that the final character is 1 if and only if the number of 1s in the string is odd.\n            # This simplifies the problem significantly.\n            # So, if g == 1, we need m to be odd.\n            # If m is odd, any string with n zeros and m ones will result in 1.\n            # The number of such strings is C(n+m, n).\n            # However, this is not true for all transformations.\n            # The rule is: replace two last characters.\n            # Let's analyze the parity of 1s.\n            # 00 -> 1 (parity changes: 0 -> 1)\n            # 01 -> 0 (parity changes: 1 -> 0)\n            # 10 -> 0 (parity changes: 1 -> 0)\n            # 11 -> 0 (parity changes: 0 -> 0)\n            # Let's denote the value of a string S as val(S).\n            # val(S + '00') = val(S + '1')\n            # val(S + '01') = val(S + '0')\n            # val(S + '10') = val(S + '0')\n            # val(S + '11') = val(S + '0')\n            # The key observation is that the value of the string is 1 if and only if the number of 1s is odd.\n            # This is because 00 -> 1, 01 -> 0, 10 -> 0, 11 -> 0.\n            # Let f(S) be the final character.\n            # f(S + x + y) = f(S + new_char(x, y))\n            # new_char(0,0) = 1\n            # new_char(0,1) = 0\n            # new_char(1,0) = 0\n            # new_char(1,1) = 0\n            # Let's track the parity of 1s.\n            # If we have a string with N_0 zeros and N_1 ones.\n            # The final character is 1 if N_1 is odd, and 0 if N_1 is even. This is the standard interpretation of XOR sum.\n            # However, the problem states \"replace two last characters\". This is crucial.\n            # Example: \"01010\" -> \"0100\" -> \"011\"\n            # \"01010\" has three 1s (odd). Final is 1.\n            # \"0100\" has one 1 (odd). Final is 1.\n            # \"011\" has two 1s (even). Final is 0.\n            # This contradicts the simple parity rule.\n            # The rule is: 00 -> 1, else -> 0.\n            # This means the result is 1 if and only if the last two characters were 00.\n            # Let's consider the state as (last_char, current_length).\n            # The value of the string is the value of the last character after all operations.\n            # Let's denote the \"value\" of a string as the character it reduces to.\n            # val(S + 'xy') = val(S + new_char(x,y))\n            # This means the operations are performed from right to left.\n            # Example: \"01010\"\n            # 010(10) -> 0100 (10 -> 0)\n            # 01(00) -> 011 (00 -> 1)\n            # 0(11) -> 00 (11 -> 0)\n            # (00) -> 1\n            # So \"01010\" reduces to 1.\n            # Number of 1s: 3 (odd).\n            # Example: \"0011\"\n            # 00(11) -> 000\n            # 0(00) -> 01\n            # (01) -> 0\n            # So \"0011\" reduces to 0.\n            # Number of 1s: 2 (even).\n            # Example: \"1100\"\n            # 11(00) -> 111\n            # 1(11) -> 10\n            # (10) -> 0\n            # So \"1100\" reduces to 0.\n            # Number of 1s: 2 (even).\n            # The final character is 1 iff the original string contains an odd number of 0s.\n            # This is a known property for this type of reduction:\n            # The final character is 1 if and only if the number of 0s is odd.\n            # And it is 0 if the number of 0s is even.\n            # This is because the operation is equivalent to XORing the values, but with 00 -> 1.\n            # Let's assign numerical values: 0 -> 0, 1 -> 1.\n            # The operation is: x, y -> (x + y + 1) % 2 if x=y=0, else (x+y)%2\n            # No, this is not it.\n            # The rule is: 00 -> 1, else -> 0.\n            # This is equivalent to saying the result is 1 if and only if the number of 0s is odd.\n            # Let's try to prove this.\n            # Let S be a string. Let N_0(S) be the count of 0s in S, and N_1(S) be the count of 1s in S.\n            # Let f(S) be the final character.\n            # Base cases:\n            # f(\"0\") = 0, N_0(\"0\")=1 (odd)\n            # f(\"1\") = 1, N_0(\"1\")=0 (even)\n            # f(\"00\") = 1, N_0(\"00\")=2 (even)\n            # f(\"01\") = 0, N_0(\"01\")=1 (odd)\n            # f(\"10\") = 0, N_0(\"10\")=1 (odd)\n            # f(\"11\") = 0, N_0(\"11\")=0 (even)\n            # This hypothesis (f(S) = (N_0(S) % 2)) is clearly wrong based on base cases.\n            #\n            # Let's reconsider the example \"01010\" -> 1. N_0 = 3 (odd).\n            # \"0011\" -> 0. N_0 = 2 (even).\n            # \"1100\" -> 0. N_0 = 2 (even).\n            # \"01\" -> 0. N_0 = 1 (odd).\n            # \"10\" -> 0. N_0 = 1 (odd).\n            # \"00\" -> 1. N_0 = 2 (even).\n            # \"11\" -> 0. N_0 = 0 (even).\n            #\n            # The actual rule is that the final character is 1 if and only if the string contains at least one 0, and the last 0 is followed by an even number of 1s.\n            # No, this is also complex.\n            #\n            # Let's consider the operations from left to right, or a stack-based approach.\n            # The operation replaces the *two last characters*. This means it's like a reduction.\n            # If we have S = s_1 s_2 ... s_k, then we replace s_{k-1}s_k with a new character.\n            # This means the operations are right-associative.\n            # Example: \"01010\"\n            # 010(10) -> 0100\n            # 01(00) -> 011\n            # 0(11) -> 00\n            # (00) -> 1\n            #\n            # Let's analyze the properties of the final character.\n            # It's known that for such operations, the final character depends on the counts of 0s and 1s, and possibly their positions.\n            #\n            # If we have a sequence of 1s: \"11...1\" (m ones).\n            # \"11\" -> 0\n            # \"111\" -> \"10\" -> 0\n            # \"1111\" -> \"101\" -> \"10\" -> 0\n            # Any sequence of 1s reduces to 0 if length >= 2.\n            #\n            # If we have a sequence of 0s: \"00...0\" (n zeros).\n            # \"00\" -> 1\n            # \"000\" -> \"01\" -> 0\n            # \"0000\" -> \"010\" -> \"00\" -> 1\n            # The final character is 1 if n is even, and 0 if n is odd (for n >= 2).\n            # For n=1, \"0\" -> 0.\n            # For n=0, \"\" is not allowed (n+m >= 1).\n            # So for n zeros: if n=1, result is 0. If n >= 2, result is 1 if n is even, 0 if n is odd.\n            # This is equivalent to (n % 2 == 0) for n >= 2, and 0 for n=1.\n            # Or simply: result is 0 if n is odd, 1 if n is even AND n >= 2.\n            # This can be summarized as: result is 1 if n is even and n >= 2. Otherwise 0.\n            #\n            # What if we have both 0s and 1s?\n            # Consider the number of 1s.\n            # If m >= 1:\n            # The operations are:\n            # x,y -> 1 if x=0,y=0\n            # x,y -> 0 otherwise\n            # This means that a '1' is generated only from '00'.\n            # Any '1' in the string (original or generated) can be part of '01', '10', '11' and will result in '0'.\n            # This implies that if there is at least one '1' in the string, and it's not the very last character,\n            # it tends to \"absorb\" other characters into 0s.\n            #\n            # Let's try a different perspective:\n            # What if we want the final character to be 1?\n            # This requires the last operation to be 00 -> 1.\n            # This means the string must reduce to \"S'00\" where S' is empty or reduces to nothing.\n            # For \"00\" to be the last operation, the string must effectively be \"00\".\n            #\n            # Consider the last character. If the string has length L.\n            # The L-th character and (L-1)-th character are combined.\n            # Then the (L-2)-th character and the new character are combined.\n            # This is essentially reducing from right to left.\n            #\n            # Let's define f(s) as the result of reduction.\n            # f(c) = c for c in {'0', '1'}\n            # f(s_1 ... s_k) = f(s_1 ... s_{k-2} + new_char(s_{k-1}, s_k))\n            # new_char(x,y) = 1 if x=0,y=0 else 0.\n            #\n            # Let's trace the effect of 1s.\n            # If a string contains '1', say S = A1B.\n            # If B is empty, S = A1. Then f(A1) = new_char(f(A), 1).\n            # If A reduces to 0: new_char(0,1) = 0.\n            # If A reduces to 1: new_char(1,1) = 0.\n            # So if the string ends with '1', and its length is >= 2, it reduces to 0.\n            # Unless it's just \"1\", which reduces to 1.\n            #\n            # Case 1: The string ends with '1'.\n            # If m=1, n=0, string \"1\", result 1. (This is the only case where a string ending in 1 yields 1)\n            # If m >= 1 and the string ends with '1' and length >= 2:\n            # S = S'x1. f(S) = new_char(f(S'x), 1). This is always 0.\n            # So if m >= 1 and (n+m > 1), and the string ends with '1', the result is 0.\n            #\n            # Case 2: The string ends with '0'.\n            # S = S'x0. f(S) = new_char(f(S'x), 0).\n            # If f(S'x) = 0, then new_char(0,0) = 1.\n            # If f(S'x) = 1, then new_char(1,0) = 0.\n            #\n            # This means the final character is 1 if and only if the prefix (excluding the last char) reduces to 0, AND the last char is 0.\n            # Let R(S) be the result of reducing S.\n            # R(S) = 1 iff (R(S_prefix) = 0 and last_char(S) = 0).\n            # R(S) = 0 iff (R(S_prefix) = 1 and last_char(S) = 0) or (last_char(S) = 1).\n            #\n            # Let's define P(S) = 1 if R(S) = 0, and P(S) = 0 if R(S) = 1. (Parity of R(S))\n            # R(S) = 1 means P(S) = 0.\n            # R(S) = 0 means P(S) = 1.\n            #\n            # R(S) = 1 iff (R(S_prefix) = 0 and last_char(S) = 0)\n            # This is equivalent to R(S) = 1 iff (P(S_prefix) = 1 and last_char(S) = 0).\n            #\n            # Let's trace the values:\n            # S = c_1 c_2 ... c_L\n            # v_L = c_L\n            # v_{L-1} = new_char(c_{L-1}, v_L)\n            # v_{L-2} = new_char(c_{L-2}, v_{L-1})\n            # ...\n            # v_1 = new_char(c_1, v_2)\n            # The final result is v_1.\n            #\n            # Consider the number of 1s in the string.\n            # If m = 0: string is \"00...0\" (n zeros).\n            # n=1: \"0\" -> 0.\n            # n=2: \"00\" -> 1.\n            # n=3: \"000\" -> \"01\" -> 0.\n            # n=4: \"0000\" -> \"010\" -> \"00\" -> 1.\n            # Pattern: 0, 1, 0, 1, ...\n            # So for \"0...0\", result is (n % 2 == 0) AND n >= 2.\n            # Or (n % 2 == 0 and n > 0) OR (n % 2 == 1 and n = 0).\n            # This is equivalent to: result is 1 if n is even and n >= 2. Otherwise 0.\n            # This is (n % 2 == 0 and n != 0).\n            #\n            # If m >= 1:\n            # Let's see what happens to a '1'.\n            # A '1' acts like a 'reset' or 'absorber'.\n            # If we have '...X1Y...', where X and Y are characters.\n            # Any operation involving '1' (01, 10, 11) results in '0'.\n            # So if a '1' is present, it can cause the value to become '0'.\n            #\n            # Let's try to count strings that reduce to '1'.\n            # A string reduces to '1' if and only if it reduces to \"00\" at some point, and then that \"00\" is the final operation.\n            # This means the string must be of the form S_prefix + \"00\".\n            # And S_prefix must reduce to '0'.\n            #\n            # The problem can be rephrased: what strings result in 1?\n            # A string S reduces to 1 iff it contains at least two 0s, and the first '1' (if any) is preceded by an odd number of 0s, and the last '1' (if any) is followed by an even number of 0s.\n            # This is too complicated.\n            #\n            # Let's use the property that a string S reduces to 1 iff the number of 0s in S is even AND S contains at least two 0s, AND S contains no 1s, OR\n            # S reduces to 1 iff the string has a 0 and it's the result of some specific pattern.\n            #\n            # The key is that 00 -> 1, and everything else -> 0.\n            # This means to get a 1, you MUST end up with a 00 as the last operation.\n            # So the string must reduce to '00'.\n            # Let f(S) be the character S reduces to.\n            # f(S) = 1 iff S reduces to '00'.\n            #\n            # Consider the sequence of reductions.\n            # S = c_1 c_2 ... c_L\n            # S_1 = c_1 ... c_{L-2} new_char(c_{L-1}, c_L)\n            # S_2 = c_1 ... c_{L-3} new_char(c_{L-2}, new_char(c_{L-1}, c_L))\n            # The final result is new_char(c_1, new_char(c_2, ... new_char(c_{L-1}, c_L)...)).\n            # This is a right-associative reduction.\n            #\n            # Let's define the value of a string S as v(S).\n            # v(c) = c\n            # v(S + c) = new_char(v(S), c)\n            #\n            # Example: \"01010\"\n            # v(\"0\") = 0\n            # v(\"01\") = new_char(0,1) = 0\n            # v(\"010\") = new_char(0,0) = 1\n            # v(\"0101\") = new_char(1,1) = 0\n            # v(\"01010\") = new_char(0,0) = 1\n            # This matches the example.\n            #\n            # Example: \"0011\"\n            # v(\"0\") = 0\n            # v(\"00\") = new_char(0,0) = 1\n            # v(\"001\") = new_char(1,1) = 0\n            # v(\"0011\") = new_char(0,1) = 0\n            # This matches the example.\n            #\n            # Example: \"1100\"\n            # v(\"1\") = 1\n            # v(\"11\") = new_char(1,1) = 0\n            # v(\"110\") = new_char(0,0) = 1\n            # v(\"1100\") = new_char(1,0) = 0\n            # This matches the example.\n            #\n            # So the rule is: f(S) = v(S).\n            # We want to count strings S with n zeros and m ones such that v(S) = g.\n            #\n            # Let dp[i][j][last_val] be the number of strings with i zeros and j ones such that the string reduces to last_val.\n            # This is too complex because the state depends on the actual sequence.\n            # The value v(S) only depends on v(S_prefix) and the last character.\n            # Let dp[i][j][val] be the number of strings with i zeros and j ones that reduce to 'val'.\n            #\n            # dp[i][j][0]: number of strings with i zeros and j ones that reduce to 0.\n            # dp[i][j][1]: number of strings with i zeros and j ones that reduce to 1.\n            #\n            # Base cases:\n            # dp[1][0][0] = 1 (string \"0\")\n            # dp[0][1][1] = 1 (string \"1\")\n            # All other dp[0][0][...] = 0.\n            #\n            # Transitions:\n            # To form a string with i zeros and j ones:\n            # 1. Append '0':\n            #    If previous string reduced to '0': new_char(0,0) = 1.\n            #    So, dp[i][j][1] += dp[i-1][j][0]\n            #    If previous string reduced to '1': new_char(1,0) = 0.\n            #    So, dp[i][j][0] += dp[i-1][j][1]\n            # 2. Append '1':\n            #    If previous string reduced to '0': new_char(0,1) = 0.\n            #    So, dp[i][j][0] += dp[i][j-1][0]\n            #    If previous string reduced to '1': new_char(1,1) = 0.\n            #    So, dp[i][j][0] += dp[i][j-1][1]\n            #\n            # This DP counts ordered strings.\n            # dp[i][j][0] = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # dp[i][j][1] = dp[i-1][j][0] % MOD\n            #\n            # Let's compute this DP.\n            # Max N, M = 10^5. Total length 2 * 10^5.\n            # This DP is O(N*M), too slow. N*M = 10^10.\n            #\n            # We need a combinatorial approach.\n            #\n            # The recurrence for dp[i][j][1] is very simple: dp[i][j][1] = dp[i-1][j][0].\n            # This means a string reduces to 1 if it ends in 0, and the prefix reduces to 0.\n            # dp[i][j][0] = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # Substitute dp[i-1][j][1] = dp[i-2][j][0] (if i-1 >= 1)\n            # dp[i][j][0] = (dp[i-2][j][0] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # This is still not simple enough.\n            #\n            # Let's analyze the conditions for v(S) = 1.\n            # v(S) = 1 iff S = S'0 and v(S') = 0.\n            # This means the string must end in '0'.\n            # And the prefix (of length N+M-1) must reduce to '0'.\n            #\n            # Let's count strings that reduce to '0'.\n            # Let Z(i,j) = dp[i][j][0] and O(i,j) = dp[i][j][1].\n            # Z(i,j) = O(i-1,j) + Z(i,j-1) + O(i,j-1)\n            # O(i,j) = Z(i-1,j)\n            #\n            # Substitute O:\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # This is a recurrence for Z(i,j).\n            #\n            # Base cases:\n            # Z(1,0) = 1 (string \"0\")\n            # O(0,1) = 1 (string \"1\")\n            # Z(0,1) = 0 (string \"1\" reduces to 1, not 0)\n            # O(1,0) = 0 (string \"0\" reduces to 0, not 1)\n            #\n            # Using the recurrences:\n            # Z(0,0) = 0, O(0,0) = 0 (empty string, not allowed)\n            #\n            # Z(1,0) = 1, O(1,0) = 0\n            # Z(0,1) = 0, O(0,1) = 1\n            #\n            # Z(2,0) = O(1,0) + Z(2,-1) + O(2,-1) = 0 + 0 + 0 = 0 (string \"00\" reduces to 1, so Z(2,0) should be 0)\n            # This is wrong.\n            # The base cases for the recurrence are tricky.\n            # The recurrence Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) is for i >= 2.\n            #\n            # Let's use the original DP:\n            # dp[i][j][0] = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # dp[i][j][1] = dp[i-1][j][0] % MOD\n            #\n            # Initialize dp table with 0s.\n            # dp[1][0][0] = 1 (for \"0\")\n            # dp[0][1][1] = 1 (for \"1\")\n            #\n            # Iterate i from 0 to n, j from 0 to m.\n            # If i=0, j=0, continue.\n            # If i=1, j=0: dp[1][0][0]=1, dp[1][0][1]=0.\n            # If i=0, j=1: dp[0][1][0]=0, dp[0][1][1]=1.\n            #\n            # For i > 0:\n            #   dp[i][j][1] = dp[i-1][j][0]\n            # For j > 0:\n            #   dp[i][j][0] = (dp[i][j][0] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # For i > 0: (This part is tricky, it depends on whether we consider previous state as (i-1, j) or (i, j-1))\n            #   dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][1]) % MOD\n            #\n            # Let's write it carefully:\n            # dp[i][j][0] and dp[i][j][1] are counts for strings of length i+j.\n            #\n            # for i from 0 to n:\n            #   for j from 0 to m:\n            #     if i == 0 and j == 0: continue\n            #     if i == 1 and j == 0:\n            #       dp[1][0][0] = 1\n            #       continue\n            #     if i == 0 and j == 1:\n            #       dp[0][1][1] = 1\n            #       continue\n            #\n            #     # If we add a '0'\n            #     if i > 0:\n            #       dp[i][j][1] = (dp[i][j][1] + dp[i-1][j][0]) % MOD # previous was 0, append 0 -> 1\n            #       dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][1]) % MOD # previous was 1, append 0 -> 0\n            #\n            #     # If we add a '1'\n            #     if j > 0:\n            #       dp[i][j][0] = (dp[i][j][0] + dp[i][j-1][0]) % MOD # previous was 0, append 1 -> 0\n            #       dp[i][j][0] = (dp[i][j][0] + dp[i][j-1][1]) % MOD # previous was 1, append 1 -> 0\n            #\n            # This is still O(NM).\n            #\n            # Let's find a pattern.\n            # O(i,j) = Z(i-1,j)\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            #\n            # What is Z(i,j) + O(i,j)? It's C(i+j, i), the total number of strings.\n            # Let T(i,j) = Z(i,j) + O(i,j) = C(i+j, i).\n            #\n            # Z(i,j) + O(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) + Z(i-1,j)\n            # T(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) + Z(i-1,j)\n            #\n            # This is not simplifying.\n            #\n            # The structure of the recurrence Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # is similar to path counting on a grid.\n            # (i,j) can be reached from (i-2,j) by adding '00'\n            # (i,j) can be reached from (i,j-1) by adding '1'\n            # (i,j) can be reached from (i-1,j-1) by adding '01' or '10' (if previous was 1, add 0; if previous was 0, add 1)\n            #\n            # The problem is that the state depends on the result of the prefix.\n            #\n            # Let's consider the number of 0s.\n            # If m > 0:\n            # The final character is 1 iff the string reduces to \"00\".\n            # This means the string must end in \"0\". Let S = S'0.\n            # And S' must reduce to \"0\".\n            # So, we are looking for strings S with n zeros and m ones such that v(S) = g.\n            #\n            # If g = 1: We need v(S) = 1.\n            # This means S must end with '0', and v(S_prefix) must be '0'.\n            # So, we need to count strings S'0 such that S' has n-1 zeros and m ones, and v(S') = 0.\n            # The count is Z(n-1, m).\n            #\n            # If g = 0: We need v(S) = 0.\n            # This means (S ends with '0' and v(S_prefix) = '1') OR (S ends with '1').\n            # So, we need to count strings S'0 such that S' has n-1 zeros and m ones, and v(S') = 1. (This is O(n-1,m))\n            # PLUS strings S'1 such that S' has n zeros and m-1 ones, and v(S') = 0 OR v(S') = 1. (This is T(n,m-1) = C(n+m-1, n))\n            # So, the count is O(n-1, m) + T(n, m-1) = O(n-1, m) + C(n+m-1, n).\n            #\n            # We need to compute Z(n-1, m) for g=1.\n            # We need to compute O(n-1, m) + C(n+m-1, n) for g=0.\n            #\n            # These are based on the assumption that n-1 >= 0 and m-1 >= 0.\n            #\n            # Edge cases for g=1:\n            # If n=0, then no string can end with '0'. So Z(-1,m) is 0. So ans=0.\n            # If n=1, m=0: string \"0\". v(\"0\")=0. So Z(0,0) is needed. But (0,0) is not allowed.\n            # Base cases:\n            # Z(1,0) = 1 (string \"0\")\n            # O(0,1) = 1 (string \"1\")\n            #\n            # Let's consider the problem with m > 0.\n            # If m > 0:\n            # The result is 1 iff the string reduces to \"00\".\n            # This means the string must end in '0'.\n            # The string must be S'0, where S' has n-1 zeros and m ones, and S' reduces to '0'.\n            # So we need Z(n-1, m).\n            #\n            # The value of Z(i,j) for m > 0:\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) for i >= 2, j >= 1.\n            #\n            # What if j=0? (m=0 case)\n            # Z(i,0) = Z(i-2,0) for i >= 2.\n            # Z(1,0) = 1 (\"0\")\n            # Z(2,0) = Z(0,0) = 0 (string \"00\" reduces to 1, so Z(2,0)=0)\n            # Z(3,0) = Z(1,0) = 1 (string \"000\" reduces to 0, so Z(3,0)=1)\n            # Z(4,0) = Z(2,0) = 0 (string \"0000\" reduces to 1, so Z(4,0)=0)\n            # This implies Z(i,0) is 1 if i is odd, 0 if i is even and i >= 2.\n            # This is consistent with the earlier finding for \"0...0\" strings.\n            #\n            # What if i=0? (n=0 case)\n            # Z(0,j) = Z(-2,j) + Z(0,j-1) + Z(-1,j-1)\n            # Z(0,j) = Z(0,j-1) for j >= 1.\n            # Base case: Z(0,1) = 0 (\"1\" reduces to 1).\n            # So Z(0,j) = 0 for all j >= 1.\n            # This is consistent: if no zeros, can't reduce to 0.\n            #\n            # What if i=1?\n            # Z(1,j) = Z(-1,j) + Z(1,j-1) + Z(0,j-1)\n            # Z(1,j) = Z(1,j-1) + Z(0,j-1) for j >= 1.\n            # We know Z(0,j-1) = 0 for j-1 >= 1.\n            # So Z(1,j) = Z(1,j-1) for j >= 2.\n            # Z(1,1) = Z(1,0) + Z(0,0) = 1 + 0 = 1 (string \"01\" reduces to 0, so Z(1,1)=1. This is correct.)\n            # Wait, Z(1,1) should be 1. \"01\" reduces to 0. So Z(1,1)=1.\n            # Z(1,0)=1.\n            # So Z(1,j) = 1 for all j >= 0.\n            # This means any string starting with '0' and having one '0' reduces to '0'.\n            # Example: \"011\" -> \"00\" -> 1. Z(1,2) should be 0.\n            # My definition of Z(i,j) is \"number of strings with i zeros and j ones that reduce to 0\".\n            # For \"011\", n=1, m=2. It reduces to 1. So it should not be counted in Z(1,2).\n            #\n            # This DP counts strings that reduce to a certain value.\n            #\n            # Let's re-evaluate the recurrences.\n            # Z(i,j) = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # O(i,j) = dp[i-1][j][0] % MOD\n            #\n            # Let's consider the total number of ways to arrange i zeros and j ones: C(i+j, i).\n            # T(i,j) = Z(i,j) + O(i,j) = C(i+j, i).\n            #\n            # For m > 0:\n            # Z(n,m) = (O(n-1,m) + Z(n,m-1) + O(n,m-1)) % MOD\n            # O(n,m) = Z(n-1,m) % MOD\n            #\n            # This is a system of linear recurrences.\n            # Z(n,m) = Z(n-2,m) + Z(n,m-1) + Z(n-1,m-1)\n            # O(n,m) = Z(n-1,m)\n            #\n            # We need to compute Z(n,m) and O(n,m).\n            # The maximum value of n+m is 2 * 10^5.\n            # This is a 2D DP.\n            #\n            # If n=0, m=1: \"1\" -> 1. Z(0,1)=0, O(0,1)=1.\n            # If n=1, m=0: \"0\" -> 0. Z(1,0)=1, O(1,0)=0.\n            #\n            # If m=0:\n            # Z(n,0) is 1 if n is odd, 0 if n is even (n>=1).\n            # O(n,0) is 0 if n is odd, 1 if n is even (n>=2). O(1,0)=0.\n            #\n            # If n=0:\n            # Z(0,m) = 0 for m>=1.\n            # O(0,m) = 1 for m>=1. (All \"1...1\" reduce to 0 except for \"1\" itself, which reduces to 1)\n            #\n            # Let's re-check the definition of v(S).\n            # v(\"1\") = 1.\n            # v(\"11\") = new_char(1,1) = 0.\n            # v(\"111\") = new_char(v(\"11\"), 1) = new_char(0,1) = 0.\n            # So O(0,1)=1, O(0,m)=0 for m>=2.\n            # Z(0,m)=0 for m>=1.\n            #\n            # Corrected base cases for (0,j) and (i,0):\n            # Z(1,0) = 1\n            # O(1,0) = 0\n            # Z(0,1) = 0\n            # O(0,1) = 1\n            # For i >= 2:\n            # Z(i,0) = 1 if i % 2 == 1 else 0\n            # O(i,0) = 0 if i % 2 == 1 else 1\n            # For j >= 2:\n            # Z(0,j) = 0\n            # O(0,j) = 0\n            #\n            # Let's compute Z(n,m) and O(n,m) using these corrected base cases.\n            #\n            # Let's try to find a pattern for Z(n,m) and O(n,m).\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # O(i,j) = Z(i-1,j)\n            #\n            # Consider the sum of all strings with n zeros and m ones that reduce to 0: Z(n,m).\n            # Consider the sum of all strings with n zeros and m ones that reduce to 1: O(n,m).\n            #\n            # The total number of strings is C(n+m, n).\n            #\n            # Let's analyze the properties of this reduction.\n            # The value of a string is 1 iff it ends with '0' and its prefix reduces to '0'.\n            # The value of a string is 0 iff (it ends with '0' and its prefix reduces to '1') OR (it ends with '1').\n            #\n            # This is related to paths on a grid.\n            # A string can be viewed as a path from (0,0) to (n,m) where '0' is a step right and '1' is a step up.\n            #\n            # The number of strings ending in '0' is C(n+m-1, n-1).\n            # The number of strings ending in '1' is C(n+m-1, n).\n            #\n            # Let's count strings that reduce to 1 (g=1).\n            # This requires the string to end in '0', and the prefix to reduce to '0'.\n            # So, we need Z(n-1, m). (assuming n >= 1)\n            #\n            # Let's count strings that reduce to 0 (g=0).\n            # This is C(n+m, n) - O(n,m).\n            # Or it is O(n-1, m) + C(n+m-1, n). (assuming n >= 1 and m >= 1)\n            #\n            # The problem is that the recurrences Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) are still for i >= 2, j >= 1.\n            #\n            # Let's consider the total count of strings.\n            # For g=1: We need O(n,m).\n            # For g=0: We need Z(n,m).\n            #\n            # O(n,m) = Z(n-1,m)\n            # So if g=1, we need Z(n-1,m).\n            #\n            # Z(n,m) = (O(n-1,m) + Z(n,m-1) + O(n,m-1))\n            # Z(n,m) = (Z(n-2,m) + Z(n,m-1) + Z(n-1,m-1))\n            #\n            # This recurrence for Z(n,m) looks like it can be computed efficiently.\n            #\n            # Consider the sum S_i = Z(i,j) + O(i,j) = C(i+j,i).\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # O(i,j) = Z(i-1,j)\n            #\n            # Let's define:\n            # S_0(i,j) = Z(i,j)\n            # S_1(i,j) = O(i,j)\n            #\n            # S_0(i,j) = S_1(i-1,j) + S_0(i,j-1) + S_1(i,j-1)\n            # S_1(i,j) = S_0(i-1,j)\n            #\n            # This is a system of linear recurrences.\n            # S_0(i,j) = S_0(i-2,j) + S_0(i,j-1) + S_0(i-1,j-1)\n            #\n            # This recurrence is for paths on a grid, where (i,j) -> (i+1,j) (add '0'), (i,j) -> (i,j+1) (add '1').\n            # The value of the string depends on the sequence.\n            #\n            # The actual insight for this type of problem is often that the state depends only on the parity of some counts.\n            # The crucial observation for this type of problem (00->1, else->0) is:\n            # The value of the string is 1 if and only if the number of 0s that are NOT immediately followed by a 1 is odd.\n            # This is too complex.\n            #\n            # Let's reconsider the example outputs.\n            # n=1, m=1, g=0: \"01\", \"10\". Ans=2.\n            # My DP:\n            # Z(1,0)=1, O(1,0)=0\n            # Z(0,1)=0, O(0,1)=1\n            #\n            # For (1,1):\n            # O(1,1) = Z(0,1) = 0. (String \"01\" reduces to 0, so O(1,1) should be 0. String \"10\" reduces to 0, so O(1,1) should be 0.)\n            # This means no strings with 1 zero and 1 one reduce to 1.\n            #\n            # Z(1,1) = (O(0,1) + Z(1,0) + O(1,0)) % MOD\n            # Z(1,1) = (1 + 1 + 0) % MOD = 2.\n            # This means 2 strings with 1 zero and 1 one reduce to 0.\n            # This matches the example (n=1, m=1, g=0, ans=2).\n            #\n            # n=2, m=2, g=0: Ans=4.\n            # Let's compute Z(2,2) and O(2,2).\n            #\n            # i=0, j=0:\n            # i=1, j=0: Z(1,0)=1, O(1,0)=0\n            # i=0, j=1: Z(0,1)=0, O(0,1)=1\n            #\n            # i=2, j=0:\n            # O(2,0) = Z(1,0) = 1. (String \"00\" reduces to 1. Correct.)\n            # Z(2,0) = (O(1,0) + Z(2,-1) + O(2,-1)) = (0 + 0 + 0) = 0. (String \"00\" reduces to 1, so Z(2,0) is 0. Correct.)\n            #\n            # i=0, j=2:\n            # O(0,2) = Z(-1,2) = 0. (String \"11\" reduces to 0. Correct.)\n            # Z(0,2) = (O(-1,2) + Z(0,1) + O(0,1)) = (0 + 0 + 1) = 1. (String \"11\" reduces to 0. Correct.)\n            #\n            # i=1, j=1: Z(1,1)=2, O(1,1)=0 (already computed)\n            #\n            # i=2, j=1:\n            # O(2,1) = Z(1,1) = 2. (Strings \"001\", \"010\", \"100\" with 2 zeros, 1 one.\n            # \"001\" -> \"01\" -> 0.\n            # \"010\" -> \"00\" -> 1.\n            # \"100\" -> \"11\" -> 0.\n            # So O(2,1) should be 1. My DP is wrong here.)\n            #\n            # Let's re-evaluate the recurrences for O(i,j) and Z(i,j).\n            #\n            # A string S of length L: s_1 s_2 ... s_L.\n            # v(S) = new_char(v(s_1 ... s_{L-1}), s_L).\n            #\n            # If s_L = 0:\n            #   v(S) = 1 if v(s_1 ... s_{L-1}) = 0.\n            #   v(S) = 0 if v(s_1 ... s_{L-1}) = 1.\n            # If s_L = 1:\n            #   v(S) = 0 if v(s_1 ... s_{L-1}) = 0.\n            #   v(S) = 0 if v(s_1 ... s_{L-1}) = 1.\n            #   So v(S) = 0 if s_L = 1.\n            #\n            # This is a critical simplification!\n            # If a string ends with '1', it always reduces to '0' (unless it's just \"1\").\n            #\n            # So, for m >= 1:\n            # If the string ends with '1':\n            #   It has n zeros and m-1 ones in prefix.\n            #   If m-1=0, n=0: string is \"1\". v(\"1\")=1.\n            #   Otherwise (n+m-1 >= 1): string S'1. v(S'1) = 0.\n            #\n            # If the string ends with '0':\n            #   It has n-1 zeros and m ones in prefix.\n            #   Let S_prefix be S'.\n            #   v(S'0) = 1 if v(S')=0.\n            #   v(S'0) = 0 if v(S')=1.\n            #\n            # This means:\n            # For O(n,m) (strings reducing to 1):\n            #   Must end in '0'.\n            #   So O(n,m) = Z(n-1,m) for n >= 1, m >= 1.\n            #   Special case: if n=0, m=1, string \"1\" reduces to 1. O(0,1)=1.\n            #   Special case: if n=0, m>=2, string ends in '1', reduces to 0. O(0,m)=0.\n            #\n            # For Z(n,m) (strings reducing to 0):\n            #   If string ends in '1': (n zeros, m-1 ones in prefix).\n            #     This contributes C(n+m-1, n) strings. All reduce to 0 (unless \"1\").\n            #     If n=0, m=1, this is \"1\", reduces to 1. So this C(0,0)=1 string is O(0,1).\n            #     If n=0, m>=2, all C(m-1,0)=1 string \"1...1\" reduces to 0.\n            #   If string ends in '0': (n-1 zeros, m ones in prefix).\n            #     This contributes O(n-1,m) strings.\n            #   So Z(n,m) = C(n+m-1, n) + O(n-1,m) for n >= 1, m >= 1.\n            #   Special case: If n=0, m=1, Z(0,1)=0.\n            #   Special case: If n=0, m>=2, Z(0,m)=C(m-1,0)=1.\n            #\n            # Summary for m >= 1:\n            # If n=0:\n            #   O(0,1) = 1 (string \"1\")\n            #   Z(0,1) = 0\n            #   For m >= 2: O(0,m) = 0 (string \"1...1\" reduces to 0)\n            #   For m >= 2: Z(0,m) = 1 (string \"1...1\" reduces to 0)\n            #\n            # If n >= 1:\n            #   O(n,m) = Z(n-1,m)\n            #   Z(n,m) = (C(n+m-1, n) + O(n-1,m)) % MOD\n            #\n            # This system of recurrences for Z(n,m) and O(n,m) is much simpler!\n            #\n            # Let's compute for n=1, m=1:\n            # O(1,1) = Z(0,1) = 0. (Correct for \"01\", \"10\" which reduce to 0)\n            # Z(1,1) = (C(1+1-1, 1) + O(0,1)) % MOD = (C(1,1) + 1) % MOD = (1 + 1) % MOD = 2. (Correct)\n            #\n            # Let's compute for n=2, m=2:\n            # First, we need values for (1,2) and (2,1).\n            #\n            # For (1,2):\n            # O(1,2) = Z(0,2) = 1.\n            # Z(1,2) = (C(1+2-1, 1) + O(0,2)) % MOD = (C(2,1) + 0) % MOD = (2 + 0) % MOD = 2.\n            #\n            # For (2,1):\n            # O(2,1) = Z(1,1) = 2.\n            # Z(2,1) = (C(2+1-1, 2) + O(1,1)) % MOD = (C(2,2) + 0) % MOD = (1 + 0) % MOD = 1.\n            #\n            # Now for (2,2):\n            # O(2,2) = Z(1,2) = 2.\n            # Z(2,2) = (C(2+2-1, 2) + O(1,2)) % MOD = (C(3,2) + 1) % MOD = (3 + 1) % MOD = 4.\n            #\n            # For n=2, m=2, g=0: Ans = Z(2,2) = 4. Matches example.\n            # For n=1, m=1, g=1: Ans = O(1,1) = 0. Matches example.\n            #\n            # This DP formulation seems correct!\n            #\n            # We need to compute Z(n,m) or O(n,m) depending on g.\n            # O(n,m) = Z(n-1,m) for n >= 1, m >= 1.\n            # Z(n,m) = C(n+m-1, n) + O(n-1,m) for n >= 1, m >= 1.\n            #\n            # This means we only need to compute Z(i,j) for all i,j.\n            # Z(i,j) = C(i+j-1, i) + Z(i-2,j) for i >= 2, j >= 1.\n            #\n            # Let's analyze Z(i,j) for j >= 1:\n            # Z(i,j) = C(i+j-1, i) + Z(i-2,j)\n            # Z(i-2,j) = C(i+j-3, i-2) + Z(i-4,j)\n            # ...\n            #\n            # If i is even: i = 2k\n            # Z(2k,j) = C(2k+j-1, 2k) + C(2k+j-3, 2k-2) + ... + C(j+1, 2) + Z(0,j)\n            # Z(0,j) = 1 for j >= 2, Z(0,1) = 0.\n            #\n            # If i is odd: i = 2k+1\n            # Z(2k+1,j) = C(2k+j, 2k+1) + C(2k+j-2, 2k-1) + ... + C(j+2, 3) + Z(1,j)\n            # Z(1,j) = C(j,1) + Z(-1,j) = C(j,1) = j.\n            # Let's re-check Z(1,j).\n            # Z(1,j) = C(1+j-1, 1) + O(0,j) = C(j,1) + O(0,j)\n            # If j=1: Z(1,1) = C(1,1) + O(0,1) = 1+1=2. Correct.\n            # If j>=2: Z(1,j) = C(j,1) + O(0,j) = j + 0 = j.\n            # So Z(1,j) = j if j >= 2, and Z(1,1) = 2.\n            # This can be written as Z(1,j) = j + (1 if j=1 else 0).\n            #\n            # So, for Z(i,j) with j >= 1:\n            # If i is even (i = 2k, k >= 1):\n            # Z(2k,j) = sum_{p=1 to k-1} C(2p+j-1, 2p) + Z(0,j) + C(2k+j-1, 2k)\n            # Z(2k,j) = sum_{p=1 to k} C(2p+j-1, 2p) + Z(0,j)\n            # where Z(0,j) is 1 if j >= 2, 0 if j=1.\n            #\n            # If i is odd (i = 2k+1, k >= 1):\n            # Z(2k+1,j) = sum_{p=1 to k-1} C(2p+j, 2p+1) + Z(1,j) + C(2k+j, 2k+1)\n            # Z(2k+1,j) = sum_{p=1 to k} C(2p+j, 2p+1) + Z(1,j)\n            # where Z(1,j) = j if j >= 2, Z(1,1) = 2.\n            #\n            # This sum is a \"hockey-stick identity\" like sum, but with alternating step sizes.\n            # sum_{k=r to n} C(k,r) = C(n+1, r+1)\n            # sum_{k=r to n} C(k,k-r) = C(n+1, n-r)\n            # This is not directly applicable.\n            #\n            # This is a sum of binomial coefficients of the form C(A+B*k, C+D*k).\n            # Sum_{p=0 to k} C(j+2p-1, 2p) for even i.\n            # Sum_{p=0 to k} C(j+2p, 2p+1) for odd i.\n            #\n            # Let's look at the \"total\" strings again.\n            # Total strings ending in '0': C(n+m-1, n-1)\n            # Total strings ending in '1': C(n+m-1, n)\n            #\n            # Let S_0(i,j) be the number of strings with i zeros and j ones reducing to 0.\n            # Let S_1(i,j) be the number of strings with i zeros and j ones reducing to 1.\n            #\n            # For m > 0:\n            # S_1(n,m) = S_0(n-1,m) (if n >= 1)\n            # S_0(n,m) = C(n+m-1, n) + S_0(n-1,m) - S_1(n-1,m)\n            # This is not right.\n            #\n            # S_0(n,m) = (strings ending in 1) + (strings ending in 0 and prefix reduces to 1)\n            # S_0(n,m) = C(n+m-1, n) + S_1(n-1,m) for n >= 1, m >= 1.\n            #\n            # Let's use the definition:\n            # S_0(n,m) = (number of strings with n zeros, m-1 ones, reducing to 0 or 1, then append 1) + (number of strings with n-1 zeros, m ones, reducing to 1, then append 0)\n            # S_0(n,m) = C(n+m-1, n) + S_1(n-1,m) for n >= 1, m >= 1.\n            # S_1(n,m) = S_0(n-1,m) for n >= 1, m >= 1.\n            #\n            # This is the system we used to get the correct example answers.\n            #\n            # We need to compute Z(n,m) or O(n,m).\n            # If g=1, ans = O(n,m).\n            # If g=0, ans = Z(n,m).\n            #\n            # Cases:\n            # 1. n=0, m=0: n+m >= 1, so this is not allowed.\n            # 2. n=0, m>=1:\n            #    If m=1: string \"1\". Reduces to 1.\n            #       If g=1, ans=1. If g=0, ans=0.\n            #    If m>=2: strings \"1...1\". Reduces to 0.\n            #       If g=1, ans=0. If g=0, ans=1.\n            #\n            # 3. m=0, n>=1:\n            #    Strings \"0...0\".\n            #    If n=1: string \"0\". Reduces to 0.\n            #       If g=1, ans=0. If g=0, ans=1.\n            #    If n>=2: Reduces to 1 if n is even, 0 if n is odd.\n            #       If g=1: ans = (1 if n%2==0 else 0).\n            #       If g=0: ans = (1 if n%2==1 else 0).\n            #\n            # These edge cases are handled by the initial if statements.\n            # The recurrences are for n>=1, m>=1.\n            #\n            # So, for n>=1, m>=1:\n            # O(n,m) = Z(n-1,m)\n            # Z(n,m) = C(n+m-1, n) + O(n-1,m) = C(n+m-1, n) + Z(n-2,m)\n            #\n            # Let's calculate Z(n,m) for n>=1, m>=1:\n            # Z(n,m) = C(n+m-1, n) + Z(n-2,m)\n            # This is a summation.\n            # If n is odd: n = 2k+1.\n            # Z(2k+1, m) = C(2k+m, 2k+1) + Z(2k-1, m)\n            # Z(2k+1, m) = C(2k+m, 2k+1) + C(2k+m-2, 2k-1) + ... + C(m+2, 3) + Z(1,m)\n            # Z(1,m) = C(m,1) + O(0,m)\n            # If m=1: Z(1,1) = C(1,1) + O(0,1) = 1+1=2.\n            # If m>=2: Z(1,m) = C(m,1) + O(0,m) = m + 0 = m.\n            #\n            # So, if n is odd (n=2k+1):\n            # ans_Z = sum_{p=0 to k-1} C(n+m-1-2p, n-2p) + Z(1,m)\n            # ans_Z = sum_{p=0 to k-1} C(m+2(k-p), 2(k-p)+1) + Z(1,m)\n            # Let q = k-p.\n            # ans_Z = sum_{q=1 to k} C(m+2q, 2q+1) + Z(1,m)\n            #\n            # If n is even: n = 2k.\n            # Z(2k, m) = C(2k+m-1, 2k) + Z(2k-2, m)\n            # Z(2k, m) = C(2k+m-1, 2k) + C(2k+m-3, 2k-2) + ... + C(m+1, 2) + Z(0,m)\n            # Z(0,m) = 0 if m=1, 1 if m>=2.\n            #\n            # So, if n is even (n=2k):\n            # ans_Z = sum_{p=0 to k-1} C(n+m-1-2p, n-2p) + Z(0,m)\n            # ans_Z = sum_{q=1 to k} C(m+2q-1, 2q) + Z(0,m)\n            #\n            # These sums can be computed in O(N/2) or O(M/2) time.\n            # Max N, M = 10^5. So N/2 = 5 * 10^4. This is feasible.\n            #\n            # Final plan:\n            # Handle n=0 or m=0 as special cases.\n            # For n>=1, m>=1:\n            #   Calculate Z(n,m) using the summation.\n            #   If g=0, print Z(n,m).\n            #   If g=1, print O(n,m) = Z(n-1,m).\n            #\n            # Calculate Z(N,M) for N >= 1, M >= 1:\n            # If N is odd (N=2k+1):\n            #   current_Z = Z(1,M)\n            #   if M==1: Z(1,M) = 2\n            #   else: Z(1,M) = M\n            #   For p from 1 to k:\n            #     current_Z = (current_Z + C(M+2p, 2p+1)) % MOD\n            #\n            # If N is even (N=2k):\n            #   current_Z = Z(0,M)\n            #   if M==1: Z(0,M) = 0\n            #   else: Z(0,M) = 1\n            #   For p from 1 to k:\n            #     current_Z = (current_Z + C(M+2p-1, 2p)) % MOD\n            #\n            # These sums are actually:\n            # If n is odd (n=2k+1):\n            # Z(n,m) = sum_{j=0 to k} C(m+n-1-2j, n-2j)\n            # Z(n,m) = C(m+n-1, n) + C(m+n-3, n-2) + ... + C(m+0, 1)\n            #\n            # If n is even (n=2k):\n            # Z(n,m) = sum_{j=0 to k-1} C(m+n-1-2j, n-2j) + Z(0,m)\n            # Z(n,m) = C(m+n-1, n) + C(m+n-3, n-2) + ... + C(m+1, 2) + Z(0,m)\n            # where Z(0,m) is 0 if m=1, 1 if m>=2.\n            #\n            # Let's re-verify the terms.\n            # Z(n,m) = C(n+m-1, n) + Z(n-2,m)\n            # Z(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + Z(n-4,m)\n            # ...\n            # If n is odd, n=2k+1:\n            # Z(2k+1,m) = C(2k+m, 2k+1) + C(2k+m-2, 2k-1) + ... + C(m+2, 3) + Z(1,m)\n            # Z(1,m) = C(m,1) + O(0,m)\n            # If m=1, O(0,1)=1. Z(1,1)=C(1,1)+1=2.\n            # If m>=2, O(0,m)=0. Z(1,m)=C(m,1)+0=m.\n            #\n            # If n is even, n=2k:\n            # Z(2k,m) = C(2k+m-1, 2k) + C(2k+m-3, 2k-2) + ... + C(m+1, 2) + Z(0,m)\n            # Z(0,m) = 0 if m=1, 1 if m>=2.\n            #\n            # These sums are correct.\n            #\n            # Function to calculate Z_val(N, M):\n            def calculate_Z(N_val, M_val):\n                if M_val == 0: # This case is handled separately\n                    return 1 if N_val % 2 == 1 else 0\n                if N_val == 0: # This case is handled separately\n                    return 0 if M_val == 1 else 1\n\n                current_Z = 0\n                if N_val % 2 == 1: # N_val is odd\n                    k = (N_val - 1) // 2\n                    # Z(1,M_val) term\n                    if M_val == 1:\n                        current_Z = 2\n                    else:\n                        current_Z = M_val\n                    # Sum C(M_val + 2p, 2p+1) for p from 1 to k\n                    for p in range(1, k + 1):\n                        current_Z = (current_Z + nCr_mod_p(M_val + 2 * p, 2 * p + 1)) % MOD\n                else: # N_val is even\n                    k = N_val // 2\n                    # Z(0,M_val) term\n                    if M_val == 1:\n                        current_Z = 0\n                    else:\n                        current_Z = 1\n                    # Sum C(M_val + 2p - 1, 2p) for p from 1 to k\n                    for p in range(1, k + 1):\n                        current_Z = (current_Z + nCr_mod_p(M_val + 2 * p - 1, 2 * p)) % MOD\n                return current_Z\n\n            if g == 0:\n                ans = calculate_Z(n, m)\n            else: # g == 1\n                if n == 0: # Already handled\n                    ans = 0 if m >= 2 else 1 # \"1\"->1, \"11...\"->0\n                else:\n                    ans = calculate_Z(n - 1, m)\n\n            print(ans)\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 1000000007\nMAXN = 200005\n\nfact = [1] * MAXN\ninv_fact = [1] * MAXN\n\ndef precompute_factorials():\n    for i in range(1, MAXN):\n        fact[i] = (fact[i - 1] * i) % MOD\n    inv_fact[MAXN - 1] = pow(fact[MAXN - 1], MOD - 2, MOD)\n    for i in range(MAXN - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n - r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\nn, m, g = map(int, input().split())\n\nif n == 0:\n    if m == 1:\n        print(1 if g == 1 else 0)\n    else:\n        print(1 if g == 0 else 0)\n    exit()\n\nif m == 0:\n    print(1 if g == (n % 2) else 0)\n    exit()\n\nans = 0\n\nif g == 1:\n    # If g is 1, the final character must be 1.\n    # This means the number of 1s in the string must be odd,\n    # or the number of 0s must be even and the number of 1s must be even.\n    # The rule is: (final_char == 1) iff (num_ones_in_suffix == 1 and num_zeros_in_suffix == 0)\n    # OR (num_ones_in_suffix == 0 and num_zeros_in_suffix == 1)\n    # The final character is 1 if the number of 1s is odd.\n    # The final character is 0 if the number of 1s is even.\n    # This is equivalent to (count of 1s) % 2.\n    # So we need (m % 2) == 1.\n    # If m is odd, then the final character is 1.\n    # If m is even, then the final character is 0.\n    # Thus, if g == 1, we need m to be odd.\n    if m % 2 == 1:\n        for k in range(1, m + 1, 2): # k is the number of 1s. We need k to be odd.\n            # We place k ones and n zeros.\n            # The remaining m-k ones are placed with 0s.\n            # We need to choose k positions for 1s out of n+k positions, such that\n            # there are at least one 0 between any two 1s, and at least one 0 at the ends.\n            # This is equivalent to placing k ones and n zeros such that no two 1s are adjacent.\n            # This is a stars and bars problem.\n            # Consider n zeros as n \"slots\" or separators. _ 0 _ 0 _ ... _ 0 _\n            # There are n+1 possible places to put 1s.\n            # We need to choose k of these places.\n            # The number of ways to choose k places for 1s among n+1 slots is C(n+1, k).\n            # This is for the case where we have n zeros and k ones, and no two ones are adjacent.\n            # However, the problem statement is about the transformation rule.\n            # The transformation rule means that the final character is 1 if and only if the number of 1s in the string is odd.\n            # This simplifies the problem significantly.\n            # So, if g == 1, we need m to be odd.\n            # If m is odd, any string with n zeros and m ones will result in 1.\n            # The number of such strings is C(n+m, n).\n            # However, this is not true for all transformations.\n            # The rule is: replace two last characters.\n            # Let's analyze the parity of 1s.\n            # 00 -> 1 (parity changes: 0 -> 1)\n            # 01 -> 0 (parity changes: 1 -> 0)\n            # 10 -> 0 (parity changes: 1 -> 0)\n            # 11 -> 0 (parity changes: 0 -> 0)\n            # Let's denote the value of a string S as val(S).\n            # val(S + '00') = val(S + '1')\n            # val(S + '01') = val(S + '0')\n            # val(S + '10') = val(S + '0')\n            # val(S + '11') = val(S + '0')\n            # The key observation is that the value of the string is 1 if and only if the number of 1s is odd.\n            # This is because 00 -> 1, 01 -> 0, 10 -> 0, 11 -> 0.\n            # Let f(S) be the final character.\n            # f(S + x + y) = f(S + new_char(x, y))\n            # new_char(0,0) = 1\n            # new_char(0,1) = 0\n            # new_char(1,0) = 0\n            # new_char(1,1) = 0\n            # Let's track the parity of 1s.\n            # If we have a string with N_0 zeros and N_1 ones.\n            # The final character is 1 if N_1 is odd, and 0 if N_1 is even. This is the standard interpretation of XOR sum.\n            # However, the problem states \"replace two last characters\". This is crucial.\n            # Example: \"01010\" -> \"0100\" -> \"011\"\n            # \"01010\" has three 1s (odd). Final is 1.\n            # \"0100\" has one 1 (odd). Final is 1.\n            # \"011\" has two 1s (even). Final is 0.\n            # This contradicts the simple parity rule.\n            # The rule is: 00 -> 1, else -> 0.\n            # This means the result is 1 if and only if the last two characters were 00.\n            # Let's consider the state as (last_char, current_length).\n            # The value of the string is the value of the last character after all operations.\n            # Let's denote the \"value\" of a string as the character it reduces to.\n            # val(S + 'xy') = val(S + new_char(x,y))\n            # This means the operations are performed from right to left.\n            # Example: \"01010\"\n            # 010(10) -> 0100 (10 -> 0)\n            # 01(00) -> 011 (00 -> 1)\n            # 0(11) -> 00 (11 -> 0)\n            # (00) -> 1\n            # So \"01010\" reduces to 1.\n            # Number of 1s: 3 (odd).\n            # Example: \"0011\"\n            # 00(11) -> 000\n            # 0(00) -> 01\n            # (01) -> 0\n            # So \"0011\" reduces to 0.\n            # Number of 1s: 2 (even).\n            # Example: \"1100\"\n            # 11(00) -> 111\n            # 1(11) -> 10\n            # (10) -> 0\n            # So \"1100\" reduces to 0.\n            # Number of 1s: 2 (even).\n            # The final character is 1 iff the original string contains an odd number of 0s.\n            # This is a known property for this type of reduction:\n            # The final character is 1 if and only if the number of 0s is odd.\n            # And it is 0 if the number of 0s is even.\n            # This is because the operation is equivalent to XORing the values, but with 00 -> 1.\n            # Let's assign numerical values: 0 -> 0, 1 -> 1.\n            # The operation is: x, y -> (x + y + 1) % 2 if x=y=0, else (x+y)%2\n            # No, this is not it.\n            # The rule is: 00 -> 1, else -> 0.\n            # This is equivalent to saying the result is 1 if and only if the number of 0s is odd.\n            # Let's try to prove this.\n            # Let S be a string. Let N_0(S) be the count of 0s in S, and N_1(S) be the count of 1s in S.\n            # Let f(S) be the final character.\n            # Base cases:\n            # f(\"0\") = 0, N_0(\"0\")=1 (odd)\n            # f(\"1\") = 1, N_0(\"1\")=0 (even)\n            # f(\"00\") = 1, N_0(\"00\")=2 (even)\n            # f(\"01\") = 0, N_0(\"01\")=1 (odd)\n            # f(\"10\") = 0, N_0(\"10\")=1 (odd)\n            # f(\"11\") = 0, N_0(\"11\")=0 (even)\n            # This hypothesis (f(S) = (N_0(S) % 2)) is clearly wrong based on base cases.\n            #\n            # Let's reconsider the example \"01010\" -> 1. N_0 = 3 (odd).\n            # \"0011\" -> 0. N_0 = 2 (even).\n            # \"1100\" -> 0. N_0 = 2 (even).\n            # \"01\" -> 0. N_0 = 1 (odd).\n            # \"10\" -> 0. N_0 = 1 (odd).\n            # \"00\" -> 1. N_0 = 2 (even).\n            # \"11\" -> 0. N_0 = 0 (even).\n            #\n            # The actual rule is that the final character is 1 if and only if the string contains at least one 0, and the last 0 is followed by an even number of 1s.\n            # No, this is also complex.\n            #\n            # Let's consider the operations from left to right, or a stack-based approach.\n            # The operation replaces the *two last characters*. This means it's like a reduction.\n            # If we have S = s_1 s_2 ... s_k, then we replace s_{k-1}s_k with a new character.\n            # This means the operations are right-associative.\n            # Example: \"01010\"\n            # 010(10) -> 0100\n            # 01(00) -> 011\n            # 0(11) -> 00\n            # (00) -> 1\n            #\n            # Let's analyze the properties of the final character.\n            # It's known that for such operations, the final character depends on the counts of 0s and 1s, and possibly their positions.\n            #\n            # If we have a sequence of 1s: \"11...1\" (m ones).\n            # \"11\" -> 0\n            # \"111\" -> \"10\" -> 0\n            # \"1111\" -> \"101\" -> \"10\" -> 0\n            # Any sequence of 1s reduces to 0 if length >= 2.\n            #\n            # If we have a sequence of 0s: \"00...0\" (n zeros).\n            # \"00\" -> 1\n            # \"000\" -> \"01\" -> 0\n            # \"0000\" -> \"010\" -> \"00\" -> 1\n            # The final character is 1 if n is even, and 0 if n is odd (for n >= 2).\n            # For n=1, \"0\" -> 0.\n            # For n=0, \"\" is not allowed (n+m >= 1).\n            # So for n zeros: if n=1, result is 0. If n >= 2, result is 1 if n is even, 0 if n is odd.\n            # This is equivalent to (n % 2 == 0) for n >= 2, and 0 for n=1.\n            # Or simply: result is 0 if n is odd, 1 if n is even AND n >= 2.\n            # This can be summarized as: result is 1 if n is even and n >= 2. Otherwise 0.\n            #\n            # What if we have both 0s and 1s?\n            # Consider the number of 1s.\n            # If m >= 1:\n            # The operations are:\n            # x,y -> 1 if x=0,y=0\n            # x,y -> 0 otherwise\n            # This means that a '1' is generated only from '00'.\n            # Any '1' in the string (original or generated) can be part of '01', '10', '11' and will result in '0'.\n            # This implies that if there is at least one '1' in the string, and it's not the very last character,\n            # it tends to \"absorb\" other characters into 0s.\n            #\n            # Let's try a different perspective:\n            # What if we want the final character to be 1?\n            # This requires the last operation to be 00 -> 1.\n            # This means the string must reduce to \"S'00\" where S' is empty or reduces to nothing.\n            # For \"00\" to be the last operation, the string must effectively be \"00\".\n            #\n            # Consider the last character. If the string has length L.\n            # The L-th character and (L-1)-th character are combined.\n            # Then the (L-2)-th character and the new character are combined.\n            # This is essentially reducing from right to left.\n            #\n            # Let's define f(s) as the result of reduction.\n            # f(c) = c for c in {'0', '1'}\n            # f(s_1 ... s_k) = f(s_1 ... s_{k-2} + new_char(s_{k-1}, s_k))\n            # new_char(x,y) = 1 if x=0,y=0 else 0.\n            #\n            # Let's trace the effect of 1s.\n            # If a string contains '1', say S = A1B.\n            # If B is empty, S = A1. Then f(A1) = new_char(f(A), 1).\n            # If A reduces to 0: new_char(0,1) = 0.\n            # If A reduces to 1: new_char(1,1) = 0.\n            # So if the string ends with '1', and its length is >= 2, it reduces to 0.\n            # Unless it's just \"1\", which reduces to 1.\n            #\n            # Case 1: The string ends with '1'.\n            # If m=1, n=0, string \"1\", result 1. (This is the only case where a string ending in 1 yields 1)\n            # If m >= 1 and the string ends with '1' and length >= 2:\n            # S = S'x1. f(S) = new_char(f(S'x), 1). This is always 0.\n            # So if m >= 1 and (n+m > 1), and the string ends with '1', the result is 0.\n            #\n            # Case 2: The string ends with '0'.\n            # S = S'x0. f(S) = new_char(f(S'x), 0).\n            # If f(S'x) = 0, then new_char(0,0) = 1.\n            # If f(S'x) = 1, then new_char(1,0) = 0.\n            #\n            # This means the final character is 1 if and only if the prefix (excluding the last char) reduces to 0, AND the last char is 0.\n            # Let R(S) be the result of reducing S.\n            # R(S) = 1 iff (R(S_prefix) = 0 and last_char(S) = 0).\n            # R(S) = 0 iff (R(S_prefix) = 1 and last_char(S) = 0) or (last_char(S) = 1).\n            #\n            # Let's define P(S) = 1 if R(S) = 0, and P(S) = 0 if R(S) = 1. (Parity of R(S))\n            # R(S) = 1 means P(S) = 0.\n            # R(S) = 0 means P(S) = 1.\n            #\n            # R(S) = 1 iff (R(S_prefix) = 0 and last_char(S) = 0)\n            # This is equivalent to R(S) = 1 iff (P(S_prefix) = 1 and last_char(S) = 0).\n            #\n            # Let's trace the values:\n            # S = c_1 c_2 ... c_L\n            # v_L = c_L\n            # v_{L-1} = new_char(c_{L-1}, v_L)\n            # v_{L-2} = new_char(c_{L-2}, v_{L-1})\n            # ...\n            # v_1 = new_char(c_1, v_2)\n            # The final result is v_1.\n            #\n            # Consider the number of 1s in the string.\n            # If m = 0: string is \"00...0\" (n zeros).\n            # n=1: \"0\" -> 0.\n            # n=2: \"00\" -> 1.\n            # n=3: \"000\" -> \"01\" -> 0.\n            # n=4: \"0000\" -> \"010\" -> \"00\" -> 1.\n            # Pattern: 0, 1, 0, 1, ...\n            # So for \"0...0\", result is (n % 2 == 0) AND n >= 2.\n            # Or (n % 2 == 0 and n > 0) OR (n % 2 == 1 and n = 0).\n            # This is equivalent to: result is 1 if n is even and n >= 2. Otherwise 0.\n            # This is (n % 2 == 0 and n != 0).\n            #\n            # If m >= 1:\n            # Let's see what happens to a '1'.\n            # A '1' acts like a 'reset' or 'absorber'.\n            # If we have '...X1Y...', where X and Y are characters.\n            # Any operation involving '1' (01, 10, 11) results in '0'.\n            # So if a '1' is present, it can cause the value to become '0'.\n            #\n            # Let's try to count strings that reduce to '1'.\n            # A string reduces to '1' if and only if it reduces to \"00\" at some point, and then that \"00\" is the final operation.\n            # This means the string must be of the form S_prefix + \"00\".\n            # And S_prefix must reduce to '0'.\n            #\n            # The problem can be rephrased: what strings result in 1?\n            # A string S reduces to 1 iff it contains at least two 0s, and the first '1' (if any) is preceded by an odd number of 0s, and the last '1' (if any) is followed by an even number of 0s.\n            # This is too complicated.\n            #\n            # Let's use the property that a string S reduces to 1 iff the number of 0s in S is even AND S contains at least two 0s, AND S contains no 1s, OR\n            # S reduces to 1 iff the string has a 0 and it's the result of some specific pattern.\n            #\n            # The key is that 00 -> 1, and everything else -> 0.\n            # This means to get a 1, you MUST end up with a 00 as the last operation.\n            # So the string must reduce to '00'.\n            # Let f(S) be the character S reduces to.\n            # f(S) = 1 iff S reduces to '00'.\n            #\n            # Consider the sequence of reductions.\n            # S = c_1 c_2 ... c_L\n            # S_1 = c_1 ... c_{L-2} new_char(c_{L-1}, c_L)\n            # S_2 = c_1 ... c_{L-3} new_char(c_{L-2}, new_char(c_{L-1}, c_L))\n            # The final result is new_char(c_1, new_char(c_2, ... new_char(c_{L-1}, c_L)...)).\n            # This is a right-associative reduction.\n            #\n            # Let's define the value of a string S as v(S).\n            # v(c) = c\n            # v(S + c) = new_char(v(S), c)\n            #\n            # Example: \"01010\"\n            # v(\"0\") = 0\n            # v(\"01\") = new_char(0,1) = 0\n            # v(\"010\") = new_char(0,0) = 1\n            # v(\"0101\") = new_char(1,1) = 0\n            # v(\"01010\") = new_char(0,0) = 1\n            # This matches the example.\n            #\n            # Example: \"0011\"\n            # v(\"0\") = 0\n            # v(\"00\") = new_char(0,0) = 1\n            # v(\"001\") = new_char(1,1) = 0\n            # v(\"0011\") = new_char(0,1) = 0\n            # This matches the example.\n            #\n            # Example: \"1100\"\n            # v(\"1\") = 1\n            # v(\"11\") = new_char(1,1) = 0\n            # v(\"110\") = new_char(0,0) = 1\n            # v(\"1100\") = new_char(1,0) = 0\n            # This matches the example.\n            #\n            # So the rule is: f(S) = v(S).\n            # We want to count strings S with n zeros and m ones such that v(S) = g.\n            #\n            # Let dp[i][j][last_val] be the number of strings with i zeros and j ones such that the string reduces to last_val.\n            # This is too complex because the state depends on the actual sequence.\n            # The value v(S) only depends on v(S_prefix) and the last character.\n            # Let dp[i][j][val] be the number of strings with i zeros and j ones that reduce to 'val'.\n            #\n            # dp[i][j][0]: number of strings with i zeros and j ones that reduce to 0.\n            # dp[i][j][1]: number of strings with i zeros and j ones that reduce to 1.\n            #\n            # Base cases:\n            # dp[1][0][0] = 1 (string \"0\")\n            # dp[0][1][1] = 1 (string \"1\")\n            # All other dp[0][0][...] = 0.\n            #\n            # Transitions:\n            # To form a string with i zeros and j ones:\n            # 1. Append '0':\n            #    If previous string reduced to '0': new_char(0,0) = 1.\n            #    So, dp[i][j][1] += dp[i-1][j][0]\n            #    If previous string reduced to '1': new_char(1,0) = 0.\n            #    So, dp[i][j][0] += dp[i-1][j][1]\n            # 2. Append '1':\n            #    If previous string reduced to '0': new_char(0,1) = 0.\n            #    So, dp[i][j][0] += dp[i][j-1][0]\n            #    If previous string reduced to '1': new_char(1,1) = 0.\n            #    So, dp[i][j][0] += dp[i][j-1][1]\n            #\n            # This DP counts ordered strings.\n            # dp[i][j][0] = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # dp[i][j][1] = dp[i-1][j][0] % MOD\n            #\n            # Let's compute this DP.\n            # Max N, M = 10^5. Total length 2 * 10^5.\n            # This DP is O(N*M), too slow. N*M = 10^10.\n            #\n            # We need a combinatorial approach.\n            #\n            # The recurrence for dp[i][j][1] is very simple: dp[i][j][1] = dp[i-1][j][0].\n            # This means a string reduces to 1 if it ends in 0, and the prefix reduces to 0.\n            # dp[i][j][0] = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # Substitute dp[i-1][j][1] = dp[i-2][j][0] (if i-1 >= 1)\n            # dp[i][j][0] = (dp[i-2][j][0] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # This is still not simple enough.\n            #\n            # Let's analyze the conditions for v(S) = 1.\n            # v(S) = 1 iff S = S'0 and v(S') = 0.\n            # This means the string must end in '0'.\n            # And the prefix (of length N+M-1) must reduce to '0'.\n            #\n            # Let's count strings that reduce to '0'.\n            # Let Z(i,j) = dp[i][j][0] and O(i,j) = dp[i][j][1].\n            # Z(i,j) = O(i-1,j) + Z(i,j-1) + O(i,j-1)\n            # O(i,j) = Z(i-1,j)\n            #\n            # Substitute O:\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # This is a recurrence for Z(i,j).\n            #\n            # Base cases:\n            # Z(1,0) = 1 (string \"0\")\n            # O(0,1) = 1 (string \"1\")\n            # Z(0,1) = 0 (string \"1\" reduces to 1, not 0)\n            # O(1,0) = 0 (string \"0\" reduces to 0, not 1)\n            #\n            # Using the recurrences:\n            # Z(0,0) = 0, O(0,0) = 0 (empty string, not allowed)\n            #\n            # Z(1,0) = 1, O(1,0) = 0\n            # Z(0,1) = 0, O(0,1) = 1\n            #\n            # Z(2,0) = O(1,0) + Z(2,-1) + O(2,-1) = 0 + 0 + 0 = 0 (string \"00\" reduces to 1, so Z(2,0) should be 0)\n            # This is wrong.\n            # The base cases for the recurrence are tricky.\n            # The recurrence Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) is for i >= 2.\n            #\n            # Let's use the original DP:\n            # dp[i][j][0] = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # dp[i][j][1] = dp[i-1][j][0] % MOD\n            #\n            # Initialize dp table with 0s.\n            # dp[1][0][0] = 1 (for \"0\")\n            # dp[0][1][1] = 1 (for \"1\")\n            #\n            # Iterate i from 0 to n, j from 0 to m.\n            # If i=0, j=0, continue.\n            # If i=1, j=0: dp[1][0][0]=1, dp[1][0][1]=0.\n            # If i=0, j=1: dp[0][1][0]=0, dp[0][1][1]=1.\n            #\n            # For i > 0:\n            #   dp[i][j][1] = dp[i-1][j][0]\n            # For j > 0:\n            #   dp[i][j][0] = (dp[i][j][0] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # For i > 0: (This part is tricky, it depends on whether we consider previous state as (i-1, j) or (i, j-1))\n            #   dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][1]) % MOD\n            #\n            # Let's write it carefully:\n            # dp[i][j][0] and dp[i][j][1] are counts for strings of length i+j.\n            #\n            # for i from 0 to n:\n            #   for j from 0 to m:\n            #     if i == 0 and j == 0: continue\n            #     if i == 1 and j == 0:\n            #       dp[1][0][0] = 1\n            #       continue\n            #     if i == 0 and j == 1:\n            #       dp[0][1][1] = 1\n            #       continue\n            #\n            #     # If we add a '0'\n            #     if i > 0:\n            #       dp[i][j][1] = (dp[i][j][1] + dp[i-1][j][0]) % MOD # previous was 0, append 0 -> 1\n            #       dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][1]) % MOD # previous was 1, append 0 -> 0\n            #\n            #     # If we add a '1'\n            #     if j > 0:\n            #       dp[i][j][0] = (dp[i][j][0] + dp[i][j-1][0]) % MOD # previous was 0, append 1 -> 0\n            #       dp[i][j][0] = (dp[i][j][0] + dp[i][j-1][1]) % MOD # previous was 1, append 1 -> 0\n            #\n            # This is still O(NM).\n            #\n            # Let's find a pattern.\n            # O(i,j) = Z(i-1,j)\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            #\n            # What is Z(i,j) + O(i,j)? It's C(i+j, i), the total number of strings.\n            # Let T(i,j) = Z(i,j) + O(i,j) = C(i+j, i).\n            #\n            # Z(i,j) + O(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) + Z(i-1,j)\n            # T(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) + Z(i-1,j)\n            #\n            # This is not simplifying.\n            #\n            # The structure of the recurrence Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # is similar to path counting on a grid.\n            # (i,j) can be reached from (i-2,j) by adding '00'\n            # (i,j) can be reached from (i,j-1) by adding '1'\n            # (i,j) can be reached from (i-1,j-1) by adding '01' or '10' (if previous was 1, add 0; if previous was 0, add 1)\n            #\n            # The problem is that the state depends on the result of the prefix.\n            #\n            # Let's consider the number of 0s.\n            # If m > 0:\n            # The final character is 1 iff the string reduces to \"00\".\n            # This means the string must end in \"0\". Let S = S'0.\n            # And S' must reduce to \"0\".\n            # So, we are looking for strings S with n zeros and m ones such that v(S) = g.\n            #\n            # If g = 1: We need v(S) = 1.\n            # This means S must end with '0', and v(S_prefix) must be '0'.\n            # So, we need to count strings S'0 such that S' has n-1 zeros and m ones, and v(S') = 0.\n            # The count is Z(n-1, m).\n            #\n            # If g = 0: We need v(S) = 0.\n            # This means (S ends with '0' and v(S_prefix) = '1') OR (S ends with '1').\n            # So, we need to count strings S'0 such that S' has n-1 zeros and m ones, and v(S') = 1. (This is O(n-1,m))\n            # PLUS strings S'1 such that S' has n zeros and m-1 ones, and v(S') = 0 OR v(S') = 1. (This is T(n,m-1) = C(n+m-1, n))\n            # So, the count is O(n-1, m) + T(n, m-1) = O(n-1, m) + C(n+m-1, n).\n            #\n            # We need to compute Z(n-1, m) for g=1.\n            # We need to compute O(n-1, m) + C(n+m-1, n) for g=0.\n            #\n            # These are based on the assumption that n-1 >= 0 and m-1 >= 0.\n            #\n            # Edge cases for g=1:\n            # If n=0, then no string can end with '0'. So Z(-1,m) is 0. So ans=0.\n            # If n=1, m=0: string \"0\". v(\"0\")=0. So Z(0,0) is needed. But (0,0) is not allowed.\n            # Base cases:\n            # Z(1,0) = 1 (string \"0\")\n            # O(0,1) = 1 (string \"1\")\n            #\n            # Let's consider the problem with m > 0.\n            # If m > 0:\n            # The result is 1 iff the string reduces to \"00\".\n            # This means the string must end in '0'.\n            # The string must be S'0, where S' has n-1 zeros and m ones, and S' reduces to '0'.\n            # So we need Z(n-1, m).\n            #\n            # The value of Z(i,j) for m > 0:\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) for i >= 2, j >= 1.\n            #\n            # What if j=0? (m=0 case)\n            # Z(i,0) = Z(i-2,0) for i >= 2.\n            # Z(1,0) = 1 (\"0\")\n            # Z(2,0) = Z(0,0) = 0 (string \"00\" reduces to 1, so Z(2,0)=0)\n            # Z(3,0) = Z(1,0) = 1 (string \"000\" reduces to 0, so Z(3,0)=1)\n            # Z(4,0) = Z(2,0) = 0 (string \"0000\" reduces to 1, so Z(4,0)=0)\n            # This implies Z(i,0) is 1 if i is odd, 0 if i is even and i >= 2.\n            # This is consistent with the earlier finding for \"0...0\" strings.\n            #\n            # What if i=0? (n=0 case)\n            # Z(0,j) = Z(-2,j) + Z(0,j-1) + Z(-1,j-1)\n            # Z(0,j) = Z(0,j-1) for j >= 1.\n            # Base case: Z(0,1) = 0 (\"1\" reduces to 1).\n            # So Z(0,j) = 0 for all j >= 1.\n            # This is consistent: if no zeros, can't reduce to 0.\n            #\n            # What if i=1?\n            # Z(1,j) = Z(-1,j) + Z(1,j-1) + Z(0,j-1)\n            # Z(1,j) = Z(1,j-1) + Z(0,j-1) for j >= 1.\n            # We know Z(0,j-1) = 0 for j-1 >= 1.\n            # So Z(1,j) = Z(1,j-1) for j >= 2.\n            # Z(1,1) = Z(1,0) + Z(0,0) = 1 + 0 = 1 (string \"01\" reduces to 0, so Z(1,1)=1. This is correct.)\n            # Wait, Z(1,1) should be 1. \"01\" reduces to 0. So Z(1,1)=1.\n            # Z(1,0)=1.\n            # So Z(1,j) = 1 for all j >= 0.\n            # This means any string starting with '0' and having one '0' reduces to '0'.\n            # Example: \"011\" -> \"00\" -> 1. Z(1,2) should be 0.\n            # My definition of Z(i,j) is \"number of strings with i zeros and j ones that reduce to 0\".\n            # For \"011\", n=1, m=2. It reduces to 1. So it should not be counted in Z(1,2).\n            #\n            # This DP counts strings that reduce to a certain value.\n            #\n            # Let's re-evaluate the recurrences.\n            # Z(i,j) = (dp[i-1][j][1] + dp[i][j-1][0] + dp[i][j-1][1]) % MOD\n            # O(i,j) = dp[i-1][j][0] % MOD\n            #\n            # Let's consider the total number of ways to arrange i zeros and j ones: C(i+j, i).\n            # T(i,j) = Z(i,j) + O(i,j) = C(i+j, i).\n            #\n            # For m > 0:\n            # Z(n,m) = (O(n-1,m) + Z(n,m-1) + O(n,m-1)) % MOD\n            # O(n,m) = Z(n-1,m) % MOD\n            #\n            # This is a system of linear recurrences.\n            # Z(n,m) = Z(n-2,m) + Z(n,m-1) + Z(n-1,m-1)\n            # O(n,m) = Z(n-1,m)\n            #\n            # We need to compute Z(n,m) and O(n,m).\n            # The maximum value of n+m is 2 * 10^5.\n            # This is a 2D DP.\n            #\n            # If n=0, m=1: \"1\" -> 1. Z(0,1)=0, O(0,1)=1.\n            # If n=1, m=0: \"0\" -> 0. Z(1,0)=1, O(1,0)=0.\n            #\n            # If m=0:\n            # Z(n,0) is 1 if n is odd, 0 if n is even (n>=1).\n            # O(n,0) is 0 if n is odd, 1 if n is even (n>=2). O(1,0)=0.\n            #\n            # If n=0:\n            # Z(0,m) = 0 for m>=1.\n            # O(0,m) = 1 for m>=1. (All \"1...1\" reduce to 0 except for \"1\" itself, which reduces to 1)\n            #\n            # Let's re-check the definition of v(S).\n            # v(\"1\") = 1.\n            # v(\"11\") = new_char(1,1) = 0.\n            # v(\"111\") = new_char(v(\"11\"), 1) = new_char(0,1) = 0.\n            # So O(0,1)=1, O(0,m)=0 for m>=2.\n            # Z(0,m)=0 for m>=1.\n            #\n            # Corrected base cases for (0,j) and (i,0):\n            # Z(1,0) = 1\n            # O(1,0) = 0\n            # Z(0,1) = 0\n            # O(0,1) = 1\n            # For i >= 2:\n            # Z(i,0) = 1 if i % 2 == 1 else 0\n            # O(i,0) = 0 if i % 2 == 1 else 1\n            # For j >= 2:\n            # Z(0,j) = 0\n            # O(0,j) = 0\n            #\n            # Let's compute Z(n,m) and O(n,m) using these corrected base cases.\n            #\n            # Let's try to find a pattern for Z(n,m) and O(n,m).\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # O(i,j) = Z(i-1,j)\n            #\n            # Consider the sum of all strings with n zeros and m ones that reduce to 0: Z(n,m).\n            # Consider the sum of all strings with n zeros and m ones that reduce to 1: O(n,m).\n            #\n            # The total number of strings is C(n+m, n).\n            #\n            # Let's analyze the properties of this reduction.\n            # The value of a string is 1 iff it ends with '0' and its prefix reduces to '0'.\n            # The value of a string is 0 iff (it ends with '0' and its prefix reduces to '1') OR (it ends with '1').\n            #\n            # This is related to paths on a grid.\n            # A string can be viewed as a path from (0,0) to (n,m) where '0' is a step right and '1' is a step up.\n            #\n            # The number of strings ending in '0' is C(n+m-1, n-1).\n            # The number of strings ending in '1' is C(n+m-1, n).\n            #\n            # Let's count strings that reduce to 1 (g=1).\n            # This requires the string to end in '0', and the prefix to reduce to '0'.\n            # So, we need Z(n-1, m). (assuming n >= 1)\n            #\n            # Let's count strings that reduce to 0 (g=0).\n            # This is C(n+m, n) - O(n,m).\n            # Or it is O(n-1, m) + C(n+m-1, n). (assuming n >= 1 and m >= 1)\n            #\n            # The problem is that the recurrences Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1) are still for i >= 2, j >= 1.\n            #\n            # Let's consider the total count of strings.\n            # For g=1: We need O(n,m).\n            # For g=0: We need Z(n,m).\n            #\n            # O(n,m) = Z(n-1,m)\n            # So if g=1, we need Z(n-1,m).\n            #\n            # Z(n,m) = (O(n-1,m) + Z(n,m-1) + O(n,m-1))\n            # Z(n,m) = (Z(n-2,m) + Z(n,m-1) + Z(n-1,m-1))\n            #\n            # This recurrence for Z(n,m) looks like it can be computed efficiently.\n            #\n            # Consider the sum S_i = Z(i,j) + O(i,j) = C(i+j,i).\n            # Z(i,j) = Z(i-2,j) + Z(i,j-1) + Z(i-1,j-1)\n            # O(i,j) = Z(i-1,j)\n            #\n            # Let's define:\n            # S_0(i,j) = Z(i,j)\n            # S_1(i,j) = O(i,j)\n            #\n            # S_0(i,j) = S_1(i-1,j) + S_0(i,j-1) + S_1(i,j-1)\n            # S_1(i,j) = S_0(i-1,j)\n            #\n            # This is a system of linear recurrences.\n            # S_0(i,j) = S_0(i-2,j) + S_0(i,j-1) + S_0(i-1,j-1)\n            #\n            # This recurrence is for paths on a grid, where (i,j) -> (i+1,j) (add '0'), (i,j) -> (i,j+1) (add '1').\n            # The value of the string depends on the sequence.\n            #\n            # The actual insight for this type of problem is often that the state depends only on the parity of some counts.\n            # The crucial observation for this type of problem (00->1, else->0) is:\n            # The value of the string is 1 if and only if the number of 0s that are NOT immediately followed by a 1 is odd.\n            # This is too complex.\n            #\n            # Let's reconsider the example outputs.\n            # n=1, m=1, g=0: \"01\", \"10\". Ans=2.\n            # My DP:\n            # Z(1,0)=1, O(1,0)=0\n            # Z(0,1)=0, O(0,1)=1\n            #\n            # For (1,1):\n            # O(1,1) = Z(0,1) = 0. (String \"01\" reduces to 0, so O(1,1) should be 0. String \"10\" reduces to 0, so O(1,1) should be 0.)\n            # This means no strings with 1 zero and 1 one reduce to 1.\n            #\n            # Z(1,1) = (O(0,1) + Z(1,0) + O(1,0)) % MOD\n            # Z(1,1) = (1 + 1 + 0) % MOD = 2.\n            # This means 2 strings with 1 zero and 1 one reduce to 0.\n            # This matches the example (n=1, m=1, g=0, ans=2).\n            #\n            # n=2, m=2, g=0: Ans=4.\n            # Let's compute Z(2,2) and O(2,2).\n            #\n            # i=0, j=0:\n            # i=1, j=0: Z(1,0)=1, O(1,0)=0\n            # i=0, j=1: Z(0,1)=0, O(0,1)=1\n            #\n            # i=2, j=0:\n            # O(2,0) = Z(1,0) = 1. (String \"00\" reduces to 1. Correct.)\n            # Z(2,0) = (O(1,0) + Z(2,-1) + O(2,-1)) = (0 + 0 + 0) = 0. (String \"00\" reduces to 1, so Z(2,0) is 0. Correct.)\n            #\n            # i=0, j=2:\n            # O(0,2) = Z(-1,2) = 0. (String \"11\" reduces to 0. Correct.)\n            # Z(0,2) = (O(-1,2) + Z(0,1) + O(0,1)) = (0 + 0 + 1) = 1. (String \"11\" reduces to 0. Correct.)\n            #\n            # i=1, j=1: Z(1,1)=2, O(1,1)=0 (already computed)\n            #\n            # i=2, j=1:\n            # O(2,1) = Z(1,1) = 2. (Strings \"001\", \"010\", \"100\" with 2 zeros, 1 one.\n            # \"001\" -> \"01\" -> 0.\n            # \"010\" -> \"00\" -> 1.\n            # \"100\" -> \"11\" -> 0.\n            # So O(2,1) should be 1. My DP is wrong here.)\n            #\n            # Let's re-evaluate the recurrences for O(i,j) and Z(i,j).\n            #\n            # A string S of length L: s_1 s_2 ... s_L.\n            # v(S) = new_char(v(s_1 ... s_{L-1}), s_L).\n            #\n            # If s_L = 0:\n            #   v(S) = 1 if v(s_1 ... s_{L-1}) = 0.\n            #   v(S) = 0 if v(s_1 ... s_{L-1}) = 1.\n            # If s_L = 1:\n            #   v(S) = 0 if v(s_1 ... s_{L-1}) = 0.\n            #   v(S) = 0 if v(s_1 ... s_{L-1}) = 1.\n            #   So v(S) = 0 if s_L = 1.\n            #\n            # This is a critical simplification!\n            # If a string ends with '1', it always reduces to '0' (unless it's just \"1\").\n            #\n            # So, for m >= 1:\n            # If the string ends with '1':\n            #   It has n zeros and m-1 ones in prefix.\n            #   If m-1=0, n=0: string is \"1\". v(\"1\")=1.\n            #   Otherwise (n+m-1 >= 1): string S'1. v(S'1) = 0.\n            #\n            # If the string ends with '0':\n            #   It has n-1 zeros and m ones in prefix.\n            #   Let S_prefix be S'.\n            #   v(S'0) = 1 if v(S')=0.\n            #   v(S'0) = 0 if v(S')=1.\n            #\n            # This means:\n            # For O(n,m) (strings reducing to 1):\n            #   Must end in '0'.\n            #   So O(n,m) = Z(n-1,m) for n >= 1, m >= 1.\n            #   Special case: if n=0, m=1, string \"1\" reduces to 1. O(0,1)=1.\n            #   Special case: if n=0, m>=2, string ends in '1', reduces to 0. O(0,m)=0.\n            #\n            # For Z(n,m) (strings reducing to 0):\n            #   If string ends in '1': (n zeros, m-1 ones in prefix).\n            #     This contributes C(n+m-1, n) strings. All reduce to 0 (unless \"1\").\n            #     If n=0, m=1, this is \"1\", reduces to 1. So this C(0,0)=1 string is O(0,1).\n            #     If n=0, m>=2, all C(m-1,0)=1 string \"1...1\" reduces to 0.\n            #   If string ends in '0': (n-1 zeros, m ones in prefix).\n            #     This contributes O(n-1,m) strings.\n            #   So Z(n,m) = C(n+m-1, n) + O(n-1,m) for n >= 1, m >= 1.\n            #   Special case: If n=0, m=1, Z(0,1)=0.\n            #   Special case: If n=0, m>=2, Z(0,m)=C(m-1,0)=1.\n            #\n            # Summary for m >= 1:\n            # If n=0:\n            #   O(0,1) = 1 (string \"1\")\n            #   Z(0,1) = 0\n            #   For m >= 2: O(0,m) = 0 (string \"1...1\" reduces to 0)\n            #   For m >= 2: Z(0,m) = 1 (string \"1...1\" reduces to 0)\n            #\n            # If n >= 1:\n            #   O(n,m) = Z(n-1,m)\n            #   Z(n,m) = (C(n+m-1, n) + O(n-1,m)) % MOD\n            #\n            # This system of recurrences for Z(n,m) and O(n,m) is much simpler!\n            #\n            # Let's compute for n=1, m=1:\n            # O(1,1) = Z(0,1) = 0. (Correct for \"01\", \"10\" which reduce to 0)\n            # Z(1,1) = (C(1+1-1, 1) + O(0,1)) % MOD = (C(1,1) + 1) % MOD = (1 + 1) % MOD = 2. (Correct)\n            #\n            # Let's compute for n=2, m=2:\n            # First, we need values for (1,2) and (2,1).\n            #\n            # For (1,2):\n            # O(1,2) = Z(0,2) = 1.\n            # Z(1,2) = (C(1+2-1, 1) + O(0,2)) % MOD = (C(2,1) + 0) % MOD = (2 + 0) % MOD = 2.\n            #\n            # For (2,1):\n            # O(2,1) = Z(1,1) = 2.\n            # Z(2,1) = (C(2+1-1, 2) + O(1,1)) % MOD = (C(2,2) + 0) % MOD = (1 + 0) % MOD = 1.\n            #\n            # Now for (2,2):\n            # O(2,2) = Z(1,2) = 2.\n            # Z(2,2) = (C(2+2-1, 2) + O(1,2)) % MOD = (C(3,2) + 1) % MOD = (3 + 1) % MOD = 4.\n            #\n            # For n=2, m=2, g=0: Ans = Z(2,2) = 4. Matches example.\n            # For n=1, m=1, g=1: Ans = O(1,1) = 0. Matches example.\n            #\n            # This DP formulation seems correct!\n            #\n            # We need to compute Z(n,m) or O(n,m) depending on g.\n            # O(n,m) = Z(n-1,m) for n >= 1, m >= 1.\n            # Z(n,m) = C(n+m-1, n) + O(n-1,m) for n >= 1, m >= 1.\n            #\n            # This means we only need to compute Z(i,j) for all i,j.\n            # Z(i,j) = C(i+j-1, i) + Z(i-2,j) for i >= 2, j >= 1.\n            #\n            # Let's analyze Z(i,j) for j >= 1:\n            # Z(i,j) = C(i+j-1, i) + Z(i-2,j)\n            # Z(i-2,j) = C(i+j-3, i-2) + Z(i-4,j)\n            # ...\n            #\n            # If i is even: i = 2k\n            # Z(2k,j) = C(2k+j-1, 2k) + C(2k+j-3, 2k-2) + ... + C(j+1, 2) + Z(0,j)\n            # Z(0,j) = 1 for j >= 2, Z(0,1) = 0.\n            #\n            # If i is odd: i = 2k+1\n            # Z(2k+1,j) = C(2k+j, 2k+1) + C(2k+j-2, 2k-1) + ... + C(j+2, 3) + Z(1,j)\n            # Z(1,j) = C(j,1) + Z(-1,j) = C(j,1) = j.\n            # Let's re-check Z(1,j).\n            # Z(1,j) = C(1+j-1, 1) + O(0,j) = C(j,1) + O(0,j)\n            # If j=1: Z(1,1) = C(1,1) + O(0,1) = 1+1=2. Correct.\n            # If j>=2: Z(1,j) = C(j,1) + O(0,j) = j + 0 = j.\n            # So Z(1,j) = j if j >= 2, and Z(1,1) = 2.\n            # This can be written as Z(1,j) = j + (1 if j=1 else 0).\n            #\n            # So, for Z(i,j) with j >= 1:\n            # If i is even (i = 2k, k >= 1):\n            # Z(2k,j) = sum_{p=1 to k-1} C(2p+j-1, 2p) + Z(0,j) + C(2k+j-1, 2k)\n            # Z(2k,j) = sum_{p=1 to k} C(2p+j-1, 2p) + Z(0,j)\n            # where Z(0,j) is 1 if j >= 2, 0 if j=1.\n            #\n            # If i is odd (i = 2k+1, k >= 1):\n            # Z(2k+1,j) = sum_{p=1 to k-1} C(2p+j, 2p+1) + Z(1,j) + C(2k+j, 2k+1)\n            # Z(2k+1,j) = sum_{p=1 to k} C(2p+j, 2p+1) + Z(1,j)\n            # where Z(1,j) = j if j >= 2, Z(1,1) = 2.\n            #\n            # This sum is a \"hockey-stick identity\" like sum, but with alternating step sizes.\n            # sum_{k=r to n} C(k,r) = C(n+1, r+1)\n            # sum_{k=r to n} C(k,k-r) = C(n+1, n-r)\n            # This is not directly applicable.\n            #\n            # This is a sum of binomial coefficients of the form C(A+B*k, C+D*k).\n            # Sum_{p=0 to k} C(j+2p-1, 2p) for even i.\n            # Sum_{p=0 to k} C(j+2p, 2p+1) for odd i.\n            #\n            # Let's look at the \"total\" strings again.\n            # Total strings ending in '0': C(n+m-1, n-1)\n            # Total strings ending in '1': C(n+m-1, n)\n            #\n            # Let S_0(i,j) be the number of strings with i zeros and j ones reducing to 0.\n            # Let S_1(i,j) be the number of strings with i zeros and j ones reducing to 1.\n            #\n            # For m > 0:\n            # S_1(n,m) = S_0(n-1,m) (if n >= 1)\n            # S_0(n,m) = C(n+m-1, n) + S_0(n-1,m) - S_1(n-1,m)\n            # This is not right.\n            #\n            # S_0(n,m) = (strings ending in 1) + (strings ending in 0 and prefix reduces to 1)\n            # S_0(n,m) = C(n+m-1, n) + S_1(n-1,m) for n >= 1, m >= 1.\n            #\n            # Let's use the definition:\n            # S_0(n,m) = (number of strings with n zeros, m-1 ones, reducing to 0 or 1, then append 1) + (number of strings with n-1 zeros, m ones, reducing to 1, then append 0)\n            # S_0(n,m) = C(n+m-1, n) + S_1(n-1,m) for n >= 1, m >= 1.\n            # S_1(n,m) = S_0(n-1,m) for n >= 1, m >= 1.\n            #\n            # This is the system we used to get the correct example answers.\n            #\n            # We need to compute Z(n,m) or O(n,m).\n            # If g=1, ans = O(n,m).\n            # If g=0, ans = Z(n,m).\n            #\n            # Cases:\n            # 1. n=0, m=0: n+m >= 1, so this is not allowed.\n            # 2. n=0, m>=1:\n            #    If m=1: string \"1\". Reduces to 1.\n            #       If g=1, ans=1. If g=0, ans=0.\n            #    If m>=2: strings \"1...1\". Reduces to 0.\n            #       If g=1, ans=0. If g=0, ans=1.\n            #\n            # 3. m=0, n>=1:\n            #    Strings \"0...0\".\n            #    If n=1: string \"0\". Reduces to 0.\n            #       If g=1, ans=0. If g=0, ans=1.\n            #    If n>=2: Reduces to 1 if n is even, 0 if n is odd.\n            #       If g=1: ans = (1 if n%2==0 else 0).\n            #       If g=0: ans = (1 if n%2==1 else 0).\n            #\n            # These edge cases are handled by the initial if statements.\n            # The recurrences are for n>=1, m>=1.\n            #\n            # So, for n>=1, m>=1:\n            # O(n,m) = Z(n-1,m)\n            # Z(n,m) = C(n+m-1, n) + O(n-1,m) = C(n+m-1, n) + Z(n-2,m)\n            #\n            # Let's calculate Z(n,m) for n>=1, m>=1:\n            # Z(n,m) = C(n+m-1, n) + Z(n-2,m)\n            # This is a summation.\n            # If n is odd: n = 2k+1.\n            # Z(2k+1, m) = C(2k+m, 2k+1) + Z(2k-1, m)\n            # Z(2k+1, m) = C(2k+m, 2k+1) + C(2k+m-2, 2k-1) + ... + C(m+2, 3) + Z(1,m)\n            # Z(1,m) = C(m,1) + O(0,m)\n            # If m=1: Z(1,1) = C(1,1) + O(0,1) = 1+1=2.\n            # If m>=2: Z(1,m) = C(m,1) + O(0,m) = m + 0 = m.\n            #\n            # So, if n is odd (n=2k+1):\n            # ans_Z = sum_{p=0 to k-1} C(n+m-1-2p, n-2p) + Z(1,m)\n            # ans_Z = sum_{p=0 to k-1} C(m+2(k-p), 2(k-p)+1) + Z(1,m)\n            # Let q = k-p.\n            # ans_Z = sum_{q=1 to k} C(m+2q, 2q+1) + Z(1,m)\n            #\n            # If n is even: n = 2k.\n            # Z(2k, m) = C(2k+m-1, 2k) + Z(2k-2, m)\n            # Z(2k, m) = C(2k+m-1, 2k) + C(2k+m-3, 2k-2) + ... + C(m+1, 2) + Z(0,m)\n            # Z(0,m) = 0 if m=1, 1 if m>=2.\n            #\n            # So, if n is even (n=2k):\n            # ans_Z = sum_{p=0 to k-1} C(n+m-1-2p, n-2p) + Z(0,m)\n            # ans_Z = sum_{q=1 to k} C(m+2q-1, 2q) + Z(0,m)\n            #\n            # These sums can be computed in O(N/2) or O(M/2) time.\n            # Max N, M = 10^5. So N/2 = 5 * 10^4. This is feasible.\n            #\n            # Final plan:\n            # Handle n=0 or m=0 as special cases.\n            # For n>=1, m>=1:\n            #   Calculate Z(n,m) using the summation.\n            #   If g=0, print Z(n,m).\n            #   If g=1, print O(n,m) = Z(n-1,m).\n            #\n            # Calculate Z(N,M) for N >= 1, M >= 1:\n            # If N is odd (N=2k+1):\n            #   current_Z = Z(1,M)\n            #   if M==1: Z(1,M) = 2\n            #   else: Z(1,M) = M\n            #   For p from 1 to k:\n            #     current_Z = (current_Z + C(M+2p, 2p+1)) % MOD\n            #\n            # If N is even (N=2k):\n            #   current_Z = Z(0,M)\n            #   if M==1: Z(0,M) = 0\n            #   else: Z(0,M) = 1\n            #   For p from 1 to k:\n            #     current_Z = (current_Z + C(M+2p-1, 2p)) % MOD\n            #\n            # These sums are actually:\n            # If n is odd (n=2k+1):\n            # Z(n,m) = sum_{j=0 to k} C(m+n-1-2j, n-2j)\n            # Z(n,m) = C(m+n-1, n) + C(m+n-3, n-2) + ... + C(m+0, 1)\n            #\n            # If n is even (n=2k):\n            # Z(n,m) = sum_{j=0 to k-1} C(m+n-1-2j, n-2j) + Z(0,m)\n            # Z(n,m) = C(m+n-1, n) + C(m+n-3, n-2) + ... + C(m+1, 2) + Z(0,m)\n            # where Z(0,m) is 0 if m=1, 1 if m>=2.\n            #\n            # Let's re-verify the terms.\n            # Z(n,m) = C(n+m-1, n) + Z(n-2,m)\n            # Z(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + Z(n-4,m)\n            # ...\n            # If n is odd, n=2k+1:\n            # Z(2k+1,m) = C(2k+m, 2k+1) + C(2k+m-2, 2k-1) + ... + C(m+2, 3) + Z(1,m)\n            # Z(1,m) = C(m,1) + O(0,m)\n            # If m=1, O(0,1)=1. Z(1,1)=C(1,1)+1=2.\n            # If m>=2, O(0,m)=0. Z(1,m)=C(m,1)+0=m.\n            #\n            # If n is even, n=2k:\n            # Z(2k,m) = C(2k+m-1, 2k) + C(2k+m-3, 2k-2) + ... + C(m+1, 2) + Z(0,m)\n            # Z(0,m) = 0 if m=1, 1 if m>=2.\n            #\n            # These sums are correct.\n            #\n            # Function to calculate Z_val(N, M):\n            def calculate_Z(N_val, M_val):\n                if M_val == 0: # This case is handled separately\n                    return 1 if N_val % 2 == 1 else 0\n                if N_val == 0: # This case is handled separately\n                    return 0 if M_val == 1 else 1\n\n                current_Z = 0\n                if N_val % 2 == 1: # N_val is odd\n                    k = (N_val - 1) // 2\n                    # Z(1,M_val) term\n                    if M_val == 1:\n                        current_Z = 2\n                    else:\n                        current_Z = M_val\n                    # Sum C(M_val + 2p, 2p+1) for p from 1 to k\n                    for p in range(1, k + 1):\n                        current_Z = (current_Z + nCr_mod_p(M_val + 2 * p, 2 * p + 1)) % MOD\n                else: # N_val is even\n                    k = N_val // 2\n                    # Z(0,M_val) term\n                    if M_val == 1:\n                        current_Z = 0\n                    else:\n                        current_Z = 1\n                    # Sum C(M_val + 2p - 1, 2p) for p from 1 to k\n                    for p in range(1, k + 1):\n                        current_Z = (current_Z + nCr_mod_p(M_val + 2 * p - 1, 2 * p)) % MOD\n                return current_Z\n\n            if g == 0:\n                ans = calculate_Z(n, m)\n            else: # g == 1\n                if n == 0: # Already handled\n                    ans = 0 if m >= 2 else 1 # \"1\"->1, \"11...\"->0\n                else:\n                    ans = calculate_Z(n - 1, m)\n\n            print(ans)",
    "score": -1,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 18399,
        "thoughts_token_count": 0
    }
}