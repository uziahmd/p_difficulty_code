{
    "start": 1758293698.0442894,
    "end": 1758293742.7823105,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 37,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Gluttony\n\nYou are given an array a with n distinct integers. Construct an array b by permuting a such that for every non-empty subset of indices S = {x1, x2, ..., xk} (1 ≤ xi ≤ n, 0 < k < n) the sums of elements on that positions in a and b are different, i. e. \n\n## Input\nThe first line contains one integer n (1 ≤ n ≤ 22) — the size of the array.The second line contains n space-separated distinct integers a1, a2, ..., an (0 ≤ ai ≤ 109) — the elements of the array.\n\n## Output\nIf there is no such array b, print -1.Otherwise in the only line print n space-separated integers b1, b2, ..., bn. Note that b must be a permutation of a.If there are multiple answers, print any of them.\n\n## Example\n### Input\n['2\\n1 2', '4\\n1000 100 10 1']\n\n### Output\n['2 1', '100 1 1000 10']\n\n## Note\nAn array x is a permutation of y, if we can shuffle elements of y such that it will coincide with x.Note that the empty subset and the subset containing all indices are not counted.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    if n == 1:\n        print(-1)\n        return\n\n    # Sort the array a to simplify the problem\n    # The condition is equivalent to saying that for any non-empty proper subset S,\n    # sum(a[i] for i in S) != sum(b[i] for i in S).\n    # If we sort a, say a_1 < a_2 < ... < a_n.\n    # A common strategy for this type of problem is to try a cyclic shift.\n    # Let b be a cyclic shift of a.\n    # For example, if a = [a_1, a_2, ..., a_n], let b = [a_2, a_3, ..., a_n, a_1].\n    # So b_i = a_{i+1} for i < n, and b_n = a_1.\n    # This is a permutation.\n    # Let's check the condition.\n    # Sum_S a[i] != Sum_S b[i]\n    # Sum_S a[i] != Sum_S a[idx_map[i]]\n    # This is equivalent to Sum_S (a[i] - b[i]) != 0.\n    # In our cyclic shift case, a[i] - b[i] = a[i] - a[i+1] for i < n, and a[n] - a[1] for i = n.\n    # Let d_i = a[i] - b[i].\n    # We want sum_{i in S} d_i != 0 for all non-empty proper subsets S.\n\n    # Let's try sorting 'a' first.\n    # This simplifies the problem because if we find a solution for sorted 'a',\n    # we can use the same permutation logic on the original 'a'.\n    # However, the problem asks for a permutation of the given 'a', not a sorted version.\n    # The problem implies that we should find a permutation b of the *given* a.\n    # The example output for n=2, a=[1, 2] is b=[2, 1].\n    # For n=4, a=[1000, 100, 10, 1] is b=[100, 1, 1000, 10].\n    # This looks like sorting 'a' and then performing a cyclic shift.\n\n    # Let's verify this hypothesis.\n    # Sort 'a' to get 'sorted_a'.\n    # Let sorted_a = [s_1, s_2, ..., s_n].\n    # Construct 'sorted_b' by cyclic shift: [s_2, s_3, ..., s_n, s_1].\n    # Now, we need to map this back to the original 'a'.\n    # We need to find the original indices.\n    # Create pairs (value, original_index) and sort them.\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n    \n    indexed_a.sort() # Now indexed_a[k] = (s_{k+1}, original_index_of_s_{k+1})\n\n    # sorted_a values are indexed_a[k][0]\n    # sorted_b values are indexed_a[(k+1)%n][0]\n    \n    # We want to construct b such that b[original_index_of_s_{k+1}] = s_{(k+1)%n + 1}\n    # No, this is not quite right.\n    # Let's define the permutation P such that a_i = s_{P[i]}.\n    # We want b_i such that sum_{j in S} a_j != sum_{j in S} b_j.\n    # The strategy is to find a permutation `p` of `0...n-1` such that `b[i] = a[p[i]]`.\n    # And then check the condition.\n\n    # A simpler approach:\n    # 1. Sort the input array `a` to get `sorted_a`.\n    # 2. Create `sorted_b` by cyclically shifting `sorted_a`: `sorted_b[i] = sorted_a[(i+1)%n]`.\n    # 3. Now we need to map `sorted_b` values back to the original positions of `a`.\n    #    This means if `a[j]` was the k-th smallest element `sorted_a[k]`,\n    #    then `b[j]` should be `sorted_b[k]`.\n\n    # Example: a = [1000, 100, 10, 1]\n    # Indexed_a: [(1, 3), (10, 2), (100, 1), (1000, 0)]  (value, original_index)\n    # Let's call these (val, orig_idx) pairs.\n    # sorted_a values: s_0=1, s_1=10, s_2=100, s_3=1000\n    # sorted_b values: b'_0=10, b'_1=100, b'_2=1000, b'_3=1\n\n    # We need to construct the output array `result_b` of size `n`.\n    # `result_b[indexed_a[k][1]] = indexed_a[(k+1)%n][0]`\n    # This means:\n    # The element at original index `indexed_a[k][1]` (which is `indexed_a[k][0]`)\n    # should be replaced by `indexed_a[(k+1)%n][0]`.\n\n    result_b = [0] * n\n    for k in range(n):\n        original_index_of_ak = indexed_a[k][1] # This is the index `j` in `a` where `a[j]` is `sorted_a[k]`\n        value_to_place = indexed_a[(k + 1) % n][0] # This is `sorted_a[(k+1)%n]`\n        result_b[original_index_of_ak] = value_to_place\n\n    # Let's verify this construction for the example:\n    # a = [1000, 100, 10, 1]\n    # indexed_a = [(1, 3), (10, 2), (100, 1), (1000, 0)]\n    # k=0: original_index_of_ak = 3 (a[3] is 1). value_to_place = indexed_a[1][0] = 10. result_b[3] = 10.\n    # k=1: original_index_of_ak = 2 (a[2] is 10). value_to_place = indexed_a[2][0] = 100. result_b[2] = 100.\n    # k=2: original_index_of_ak = 1 (a[1] is 100). value_to_place = indexed_a[3][0] = 1000. result_b[1] = 1000.\n    # k=3: original_index_of_ak = 0 (a[0] is 1000). value_to_place = indexed_a[0][0] = 1. result_b[0] = 1.\n    # Result: b = [1, 1000, 100, 10].\n    # The example output is [100, 1, 1000, 10]. This is different.\n    # My construction is a cyclic shift of the sorted array, then mapping back.\n    # The example output seems to be a cyclic shift of the sorted array, but applied to the original indices in a different way.\n\n    # Let's re-examine the example output:\n    # a = [1000, 100, 10, 1]\n    # b = [100, 1, 1000, 10]\n    # This means:\n    # a[0]=1000 -> b[0]=100\n    # a[1]=100 -> b[1]=1\n    # a[2]=10 -> b[2]=1000\n    # a[3]=1 -> b[3]=10\n    #\n    # Let's sort 'a': s_0=1, s_1=10, s_2=100, s_3=1000\n    # Original indices:\n    # s_0=1 (orig_idx 3)\n    # s_1=10 (orig_idx 2)\n    # s_2=100 (orig_idx 1)\n    # s_3=1000 (orig_idx 0)\n    #\n    # The output b is:\n    # b[0]=100 (which is s_2)\n    # b[1]=1 (which is s_0)\n    # b[2]=1000 (which is s_3)\n    # b[3]=10 (which is s_1)\n    #\n    # So the mapping from original a[i] to b[i] is:\n    # a[0]=s_3 maps to b[0]=s_2\n    # a[1]=s_2 maps to b[1]=s_0\n    # a[2]=s_1 maps to b[2]=s_3\n    # a[3]=s_0 maps to b[3]=s_1\n    #\n    # This means the element s_k (at original index `idx_k`) is mapped to s_{(k-1+n)%n}.\n    # So `b[idx_k] = s_{(k-1+n)%n}`.\n    # This is a cyclic shift of the sorted values, but \"backwards\".\n    #\n    # Let `p_k` be the original index of `s_k`. So `a[p_k] = s_k`.\n    # We want `b[p_k] = s_{(k-1+n)%n}`.\n\n    # Let's re-implement based on this observation:\n    # indexed_a = [(value, original_index), ...] sorted by value.\n    # indexed_a[k] = (s_k, p_k)\n    # We want `result_b[p_k] = s_{(k-1+n)%n}`.\n\n    result_b = [0] * n\n    for k in range(n):\n        current_val = indexed_a[k][0] # s_k\n        original_idx = indexed_a[k][1] # p_k\n        \n        # The value that `s_k` should be replaced by is `s_{(k-1+n)%n}`.\n        # This value is `indexed_a[(k-1+n)%n][0]`.\n        value_to_assign = indexed_a[(k - 1 + n) % n][0]\n        result_b[original_idx] = value_to_assign\n\n    # Check for example: a = [1000, 100, 10, 1]\n    # indexed_a = [(1, 3), (10, 2), (100, 1), (1000, 0)]\n    # k=0: (s_0=1, p_0=3). value_to_assign = indexed_a[(0-1+4)%4][0] = indexed_a[3][0] = 1000. result_b[3] = 1000.\n    # k=1: (s_1=10, p_1=2). value_to_assign = indexed_a[(1-1+4)%4][0] = indexed_a[0][0] = 1. result_b[2] = 1.\n    # k=2: (s_2=100, p_2=1). value_to_assign = indexed_a[(2-1+4)%4][0] = indexed_a[1][0] = 10. result_b[1] = 10.\n    # k=3: (s_3=1000, p_3=0). value_to_assign = indexed_a[(3-1+4)%4][0] = indexed_a[2][0] = 100. result_b[0] = 100.\n    # Result: b = [100, 10, 1, 1000]. This is still not the example output.\n    # The example output was [100, 1, 1000, 10].\n    # My result: [100, 10, 1, 1000]\n    # This means my mapping is:\n    # a[0]=1000 -> b[0]=100\n    # a[1]=100 -> b[1]=10\n    # a[2]=10 -> b[2]=1\n    # a[3]=1 -> b[3]=1000\n    #\n    # This is also a valid cyclic shift. The problem says \"If there are multiple answers, print any of them.\"\n    # The condition is that for any non-empty proper subset S, sum(a[i] for i in S) != sum(b[i] for i in S).\n    # Let d_i = a[i] - b[i]. We need sum_{i in S} d_i != 0.\n    #\n    # With `b[p_k] = s_{(k-1+n)%n}`:\n    # a[p_k] - b[p_k] = s_k - s_{(k-1+n)%n}.\n    # Let's call this `diff_k`.\n    #\n    # For a sorted array `s_0 < s_1 < ... < s_{n-1}`.\n    # The differences `s_k - s_{(k-1+n)%n}` are:\n    # For k=0: s_0 - s_{n-1} (negative)\n    # For k=1: s_1 - s_0 (positive)\n    # ...\n    # For k=n-1: s_{n-1} - s_{n-2} (positive)\n    #\n    # The sum of all these differences is:\n    # (s_0 - s_{n-1}) + (s_1 - s_0) + ... + (s_{n-1} - s_{n-2})\n    # This is a telescoping sum: (s_0 - s_0) + (s_1 - s_1) + ... + (s_{n-1} - s_{n-1}) = 0.\n    # So sum_{i=0}^{n-1} d_i = 0.\n    # This is why the condition explicitly excludes the empty subset and the subset containing all indices.\n    #\n    # For any proper non-empty subset S, we need sum_{i in S} d_i != 0.\n    # This is a known property of cyclic shifts of sorted arrays.\n    # If `a` is sorted and `b` is a cyclic shift, then `a_i - b_i` are non-zero,\n    # and their sum is zero. Any proper non-empty subset sum will be non-zero\n    # because the elements `a_i` are distinct and ordered.\n    # Specifically, if `a_0 < a_1 < ... < a_{n-1}`, and `b_i = a_{(i+1)%n}`.\n    # Then `d_i = a_i - a_{(i+1)%n}`.\n    # `d_0 = a_0 - a_1 < 0`\n    # `d_1 = a_1 - a_2 < 0`\n    # ...\n    # `d_{n-2} = a_{n-2} - a_{n-1} < 0`\n    # `d_{n-1} = a_{n-1} - a_0 > 0`\n    #\n    # The sum of all `d_i` is 0.\n    # If S is a proper non-empty subset, then it must either contain `n-1` or not.\n    # If it contains `n-1`, and not all other elements, then the sum is `(a_{n-1}-a_0) + sum_{i in S'} (a_i - a_{i+1})`.\n    # The sum of `k` negative numbers `a_i - a_{i+1}` will be negative.\n    # The sum `a_{n-1}-a_0` is positive.\n    # It is not immediately obvious that this sum is always non-zero.\n    # However, this construction (cyclic shift of sorted array) is a standard solution for this problem.\n    # Let's assume it works. The specific cyclic shift direction (forward or backward) shouldn't matter.\n\n    # Let's re-verify the example output [100, 1, 1000, 10]\n    # a = [1000, 100, 10, 1]\n    # b = [100, 1, 1000, 10]\n    #\n    # The example output corresponds to the following mapping:\n    # Original values and their indices:\n    # a[0]=1000\n    # a[1]=100\n    # a[2]=10\n    # a[3]=1\n    #\n    # Output b values:\n    # b[0]=100\n    # b[1]=1\n    # b[2]=1000\n    # b[3]=10\n    #\n    # This means:\n    # The element originally at index 0 (value 1000) is replaced by 100.\n    # The element originally at index 1 (value 100) is replaced by 1.\n    # The element originally at index 2 (value 10) is replaced by 1000.\n    # The element originally at index 3 (value 1) is replaced by 10.\n    #\n    # Let's map original indices to sorted indices:\n    # a[3] = 1 (s_0)\n    # a[2] = 10 (s_1)\n    # a[1] = 100 (s_2)\n    # a[0] = 1000 (s_3)\n    #\n    # The output b can be described as:\n    # b[3] = 10 (s_1)\n    # b[2] = 1000 (s_3)\n    # b[1] = 1 (s_0)\n    # b[0] = 100 (s_2)\n    #\n    # So, `a[idx_k]` (which is `s_k`) is mapped to `b[idx_k]`.\n    # For `s_0` (value 1, original index 3): `b[3]` is 10 (which is `s_1`). So `s_0 -> s_1`.\n    # For `s_1` (value 10, original index 2): `b[2]` is 1000 (which is `s_3`). So `s_1 -> s_3`.\n    # For `s_2` (value 100, original index 1): `b[1]` is 1 (which is `s_0`). So `s_2 -> s_0`.\n    # For `s_3` (value 1000, original index 0): `b[0]` is 100 (which is `s_2`). So `s_3 -> s_2`.\n    #\n    # This is NOT a simple cyclic shift of the sorted values.\n    # s_0 -> s_1\n    # s_1 -> s_3\n    # s_2 -> s_0\n    # s_3 -> s_2\n    # This is a permutation of the sorted values, but not a simple cyclic shift.\n    # This is confusing.\n\n    # Let's re-read the problem statement carefully:\n    # \"Construct an array b by permuting a such that for every non-empty subset of indices S ... the sums of elements on that positions in a and b are different\"\n    # This means `b` must be a permutation of the original `a`.\n    #\n    # The construction `result_b[original_idx_of_sk] = s_{(k-1+n)%n}` is a valid permutation.\n    # Let's check the values.\n    # The values `s_0, s_1, ..., s_{n-1}` are distinct.\n    # The values `s_{(0-1+n)%n}, s_{(1-1+n)%n}, ..., s_{((n-1)-1+n)%n}` are also just a cyclic shift of `s_0, ..., s_{n-1}`, so they are also distinct and cover all values.\n    # The `original_idx_of_sk` are `p_0, p_1, ..., p_{n-1}`, which are a permutation of `0, ..., n-1`.\n    # So, we are assigning each `b[j]` a unique value from `a`. This indeed makes `b` a permutation of `a`.\n    #\n    # The specific choice of `s_{(k-1+n)%n}` vs `s_{(k+1)%n}` doesn't matter, as long as it's a cyclic shift.\n    # The proof for why this works for any non-empty proper subset is usually done by contradiction.\n    # Assume sum_{i in S} (a_i - b_i) = 0.\n    # Let `a_0 < a_1 < ... < a_{n-1}` be the sorted array.\n    # Let `b_i = a_{(i+1)%n}` (this is for `a` being sorted).\n    # Then `d_i = a_i - b_i = a_i - a_{(i+1)%n}`.\n    # `d_i < 0` for `i=0, ..., n-2`.\n    # `d_{n-1} = a_{n-1} - a_0 > 0`.\n    # `sum d_i = 0`.\n    #\n    # If `sum_{i in S} d_i = 0` for a proper non-empty subset `S`.\n    # If `n-1` is not in `S`, then all `d_i` for `i in S` are negative. Their sum must be negative, so it cannot be 0.\n    # If `n-1` is in `S`, then `d_{n-1} = a_{n-1} - a_0 > 0`.\n    # For the sum to be 0, there must be at least one `i in S` such that `d_i < 0`.\n    # This means `S` must contain `n-1` and at least one other index `j < n-1`.\n    #\n    # Consider `n=2`, `a=[1, 2]`. Sorted `a=[1, 2]`.\n    # `indexed_a = [(1, orig_idx_of_1), (2, orig_idx_of_2)]`.\n    # If original `a=[1, 2]`, then `indexed_a = [(1, 0), (2, 1)]`.\n    # My proposed solution: `b[p_k] = s_{(k-1+n)%n}`.\n    # k=0: `s_0=1, p_0=0`. `b[0] = s_{(0-1+2)%2} = s_1 = 2`.\n    # k=1: `s_1=2, p_1=1`. `b[1] = s_{(1-1+2)%2} = s_0 = 1`.\n    # Result `b = [2, 1]`. This matches the example.\n    #\n    # Consider `n=4`, `a=[1000, 100, 10, 1]`.\n    # `indexed_a = [(1, 3), (10, 2), (100, 1), (1000, 0)]`\n    # My proposed solution: `b[p_k] = s_{(k-1+n)%n}`.\n    # k=0: `s_0=1, p_0=3`. `b[3] = s_{(0-1+4)%4} = s_3 = 1000`.\n    # k=1: `s_1=10, p_1=2`. `b[2] = s_{(1-1+4)%4} = s_0 = 1`.\n    # k=2: `s_2=100, p_2=1`. `b[1] = s_{(2-1+4)%4} = s_1 = 10`.\n    # k=3: `s_3=1000, p_3=0`. `b[0] = s_{(3-1+4)%4} = s_2 = 100`.\n    # Result `b = [100, 10, 1, 1000]`.\n    # This is different from the example output `[100, 1, 1000, 10]`, but should be valid.\n    # The problem says \"If there are multiple answers, print any of them.\"\n    # So this construction should be acceptable.\n\n    # Let's confirm the logic for the cyclic shift being valid.\n    # Let `s_0 < s_1 < ... < s_{n-1}` be the sorted distinct elements.\n    # Let `b_i = s_{(i+1)%n}`.\n    # The differences are `d_i = s_i - s_{(i+1)%n}`.\n    # `d_i < 0` for `i = 0, ..., n-2`.\n    # `d_{n-1} = s_{n-1} - s_0 > 0`.\n    # `sum_{i=0}^{n-1} d_i = 0`.\n    #\n    # We need to show that for any non-empty proper subset `S`, `sum_{i in S} d_i != 0`.\n    # Case 1: `n-1` is not in `S`.\n    # Then all `d_i` for `i in S` are negative. So `sum_{i in S} d_i < 0`. Thus `sum != 0`.\n    # Case 2: `n-1` is in `S`.\n    # Since `S` is a proper subset, there is at least one index `j` not in `S`.\n    # If `S = {n-1}`, then `sum_{i in S} d_i = d_{n-1} = s_{n-1} - s_0 > 0`. Thus `sum != 0`.\n    # If `S` contains `n-1` and other indices `j < n-1`.\n    # `sum_{i in S} d_i = d_{n-1} + sum_{j in S, j < n-1} d_j`.\n    # Let `P = d_{n-1} = s_{n-1} - s_0`. This is positive.\n    # Let `N = sum_{j in S, j < n-1} d_j`. This is a sum of one or more negative numbers, so `N < 0`.\n    # We need to show `P + N != 0`.\n    #\n    # The maximum possible value for `|N|` is when `S` contains all `j < n-1`.\n    # `N_max = sum_{j=0}^{n-2} (s_j - s_{j+1}) = (s_0 - s_1) + (s_1 - s_2) + ... + (s_{n-2} - s_{n-1}) = s_0 - s_{n-1}`.\n    # In this case, `P + N_max = (s_{n-1} - s_0) + (s_0 - s_{n-1}) = 0`.\n    # However, this sum corresponds to `S = {0, 1, ..., n-1}`, which is the entire set of indices, which is excluded.\n    # So if `S` is a proper subset containing `n-1`, it must be that `S` does not contain at least one `j < n-1`.\n    # This means `N` is a sum of *fewer* negative terms than `N_max`.\n    # So `N > N_max = s_0 - s_{n-1}`.\n    # Thus `P + N > P + (s_0 - s_{n-1}) = (s_{n-1} - s_0) + (s_0 - s_{n-1}) = 0`.\n    # So `P + N > 0`. Therefore `P + N != 0`.\n    #\n    # This proves that the cyclic shift strategy works.\n    # The logic is sound.\n\n    # Final check on implementation:\n    # `indexed_a` stores `(value, original_index)`.\n    # `indexed_a.sort()` sorts these pairs based on `value`.\n    # So `indexed_a[k]` is `(s_k, p_k)`.\n    # We want `result_b[p_k] = s_{(k-1+n)%n}`.\n    # `p_k` is `indexed_a[k][1]`.\n    # `s_{(k-1+n)%n}` is `indexed_a[(k-1+n)%n][0]`.\n    # This is exactly what the code does.\n\n    print(*(result_b))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    if n == 1:\n        print(-1)\n        return\n\n    # Sort the array a to simplify the problem\n    # The condition is equivalent to saying that for any non-empty proper subset S,\n    # sum(a[i] for i in S) != sum(b[i] for i in S).\n    # If we sort a, say a_1 < a_2 < ... < a_n.\n    # A common strategy for this type of problem is to try a cyclic shift.\n    # Let b be a cyclic shift of a.\n    # For example, if a = [a_1, a_2, ..., a_n], let b = [a_2, a_3, ..., a_n, a_1].\n    # So b_i = a_{i+1} for i < n, and b_n = a_1.\n    # This is a permutation.\n    # Let's check the condition.\n    # Sum_S a[i] != Sum_S b[i]\n    # Sum_S a[i] != Sum_S a[idx_map[i]]\n    # This is equivalent to Sum_S (a[i] - b[i]) != 0.\n    # In our cyclic shift case, a[i] - b[i] = a[i] - a[i+1] for i < n, and a[n] - a[1] for i = n.\n    # Let d_i = a[i] - b[i].\n    # We want sum_{i in S} d_i != 0 for all non-empty proper subsets S.\n\n    # Let's try sorting 'a' first.\n    # This simplifies the problem because if we find a solution for sorted 'a',\n    # we can use the same permutation logic on the original 'a'.\n    # However, the problem asks for a permutation of the given 'a', not a sorted version.\n    # The problem implies that we should find a permutation b of the *given* a.\n    # The example output for n=2, a=[1, 2] is b=[2, 1].\n    # For n=4, a=[1000, 100, 10, 1] is b=[100, 1, 1000, 10].\n    # This looks like sorting 'a' and then performing a cyclic shift.\n\n    # Let's verify this hypothesis.\n    # Sort 'a' to get 'sorted_a'.\n    # Let sorted_a = [s_1, s_2, ..., s_n].\n    # Construct 'sorted_b' by cyclic shift: [s_2, s_3, ..., s_n, s_1].\n    # Now, we need to map this back to the original 'a'.\n    # We need to find the original indices.\n    # Create pairs (value, original_index) and sort them.\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n    \n    indexed_a.sort() # Now indexed_a[k] = (s_{k+1}, original_index_of_s_{k+1})\n\n    # sorted_a values are indexed_a[k][0]\n    # sorted_b values are indexed_a[(k+1)%n][0]\n    \n    # We want to construct b such that b[original_index_of_s_{k+1}] = s_{(k+1)%n + 1}\n    # No, this is not quite right.\n    # Let's define the permutation P such that a_i = s_{P[i]}.\n    # We want b_i such that sum_{j in S} a_j != sum_{j in S} b_j.\n    # The strategy is to find a permutation `p` of `0...n-1` such that `b[i] = a[p[i]]`.\n    # And then check the condition.\n\n    # A simpler approach:\n    # 1. Sort the input array `a` to get `sorted_a`.\n    # 2. Create `sorted_b` by cyclically shifting `sorted_a`: `sorted_b[i] = sorted_a[(i+1)%n]`.\n    # 3. Now we need to map `sorted_b` values back to the original positions of `a`.\n    #    This means if `a[j]` was the k-th smallest element `sorted_a[k]`,\n    #    then `b[j]` should be `sorted_b[k]`.\n\n    # Example: a = [1000, 100, 10, 1]\n    # Indexed_a: [(1, 3), (10, 2), (100, 1), (1000, 0)]  (value, original_index)\n    # Let's call these (val, orig_idx) pairs.\n    # sorted_a values: s_0=1, s_1=10, s_2=100, s_3=1000\n    # sorted_b values: b'_0=10, b'_1=100, b'_2=1000, b'_3=1\n\n    # We need to construct the output array `result_b` of size `n`.\n    # `result_b[indexed_a[k][1]] = indexed_a[(k+1)%n][0]`\n    # This means:\n    # The element at original index `indexed_a[k][1]` (which is `indexed_a[k][0]`)\n    # should be replaced by `indexed_a[(k+1)%n][0]`.\n\n    result_b = [0] * n\n    for k in range(n):\n        original_index_of_ak = indexed_a[k][1] # This is the index `j` in `a` where `a[j]` is `sorted_a[k]`\n        value_to_place = indexed_a[(k + 1) % n][0] # This is `sorted_a[(k+1)%n]`\n        result_b[original_index_of_ak] = value_to_place\n\n    # Let's verify this construction for the example:\n    # a = [1000, 100, 10, 1]\n    # indexed_a = [(1, 3), (10, 2), (100, 1), (1000, 0)]\n    # k=0: original_index_of_ak = 3 (a[3] is 1). value_to_place = indexed_a[1][0] = 10. result_b[3] = 10.\n    # k=1: original_index_of_ak = 2 (a[2] is 10). value_to_place = indexed_a[2][0] = 100. result_b[2] = 100.\n    # k=2: original_index_of_ak = 1 (a[1] is 100). value_to_place = indexed_a[3][0] = 1000. result_b[1] = 1000.\n    # k=3: original_index_of_ak = 0 (a[0] is 1000). value_to_place = indexed_a[0][0] = 1. result_b[0] = 1.\n    # Result: b = [1, 1000, 100, 10].\n    # The example output is [100, 1, 1000, 10]. This is different.\n    # My construction is a cyclic shift of the sorted array, then mapping back.\n    # The example output seems to be a cyclic shift of the sorted array, but applied to the original indices in a different way.\n\n    # Let's re-examine the example output:\n    # a = [1000, 100, 10, 1]\n    # b = [100, 1, 1000, 10]\n    # This means:\n    # a[0]=1000 -> b[0]=100\n    # a[1]=100 -> b[1]=1\n    # a[2]=10 -> b[2]=1000\n    # a[3]=1 -> b[3]=10\n    #\n    # Let's sort 'a': s_0=1, s_1=10, s_2=100, s_3=1000\n    # Original indices:\n    # s_0=1 (orig_idx 3)\n    # s_1=10 (orig_idx 2)\n    # s_2=100 (orig_idx 1)\n    # s_3=1000 (orig_idx 0)\n    #\n    # The output b is:\n    # b[0]=100 (which is s_2)\n    # b[1]=1 (which is s_0)\n    # b[2]=1000 (which is s_3)\n    # b[3]=10 (which is s_1)\n    #\n    # So the mapping from original a[i] to b[i] is:\n    # a[0]=s_3 maps to b[0]=s_2\n    # a[1]=s_2 maps to b[1]=s_0\n    # a[2]=s_1 maps to b[2]=s_3\n    # a[3]=s_0 maps to b[3]=s_1\n    #\n    # This means the element s_k (at original index `idx_k`) is mapped to s_{(k-1+n)%n}.\n    # So `b[idx_k] = s_{(k-1+n)%n}`.\n    # This is a cyclic shift of the sorted values, but \"backwards\".\n    #\n    # Let `p_k` be the original index of `s_k`. So `a[p_k] = s_k`.\n    # We want `b[p_k] = s_{(k-1+n)%n}`.\n\n    # Let's re-implement based on this observation:\n    # indexed_a = [(value, original_index), ...] sorted by value.\n    # indexed_a[k] = (s_k, p_k)\n    # We want `result_b[p_k] = s_{(k-1+n)%n}`.\n\n    result_b = [0] * n\n    for k in range(n):\n        current_val = indexed_a[k][0] # s_k\n        original_idx = indexed_a[k][1] # p_k\n        \n        # The value that `s_k` should be replaced by is `s_{(k-1+n)%n}`.\n        # This value is `indexed_a[(k-1+n)%n][0]`.\n        value_to_assign = indexed_a[(k - 1 + n) % n][0]\n        result_b[original_idx] = value_to_assign\n\n    # Check for example: a = [1000, 100, 10, 1]\n    # indexed_a = [(1, 3), (10, 2), (100, 1), (1000, 0)]\n    # k=0: (s_0=1, p_0=3). value_to_assign = indexed_a[(0-1+4)%4][0] = indexed_a[3][0] = 1000. result_b[3] = 1000.\n    # k=1: (s_1=10, p_1=2). value_to_assign = indexed_a[(1-1+4)%4][0] = indexed_a[0][0] = 1. result_b[2] = 1.\n    # k=2: (s_2=100, p_2=1). value_to_assign = indexed_a[(2-1+4)%4][0] = indexed_a[1][0] = 10. result_b[1] = 10.\n    # k=3: (s_3=1000, p_3=0). value_to_assign = indexed_a[(3-1+4)%4][0] = indexed_a[2][0] = 100. result_b[0] = 100.\n    # Result: b = [100, 10, 1, 1000]. This is still not the example output.\n    # The example output was [100, 1, 1000, 10].\n    # My result: [100, 10, 1, 1000]\n    # This means my mapping is:\n    # a[0]=1000 -> b[0]=100\n    # a[1]=100 -> b[1]=10\n    # a[2]=10 -> b[2]=1\n    # a[3]=1 -> b[3]=1000\n    #\n    # This is also a valid cyclic shift. The problem says \"If there are multiple answers, print any of them.\"\n    # The condition is that for any non-empty proper subset S, sum(a[i] for i in S) != sum(b[i] for i in S).\n    # Let d_i = a[i] - b[i]. We need sum_{i in S} d_i != 0.\n    #\n    # With `b[p_k] = s_{(k-1+n)%n}`:\n    # a[p_k] - b[p_k] = s_k - s_{(k-1+n)%n}.\n    # Let's call this `diff_k`.\n    #\n    # For a sorted array `s_0 < s_1 < ... < s_{n-1}`.\n    # The differences `s_k - s_{(k-1+n)%n}` are:\n    # For k=0: s_0 - s_{n-1} (negative)\n    # For k=1: s_1 - s_0 (positive)\n    # ...\n    # For k=n-1: s_{n-1} - s_{n-2} (positive)\n    #\n    # The sum of all these differences is:\n    # (s_0 - s_{n-1}) + (s_1 - s_0) + ... + (s_{n-1} - s_{n-2})\n    # This is a telescoping sum: (s_0 - s_0) + (s_1 - s_1) + ... + (s_{n-1} - s_{n-1}) = 0.\n    # So sum_{i=0}^{n-1} d_i = 0.\n    # This is why the condition explicitly excludes the empty subset and the subset containing all indices.\n    #\n    # For any proper non-empty subset S, we need sum_{i in S} d_i != 0.\n    # This is a known property of cyclic shifts of sorted arrays.\n    # If `a` is sorted and `b` is a cyclic shift, then `a_i - b_i` are non-zero,\n    # and their sum is zero. Any proper non-empty subset sum will be non-zero\n    # because the elements `a_i` are distinct and ordered.\n    # Specifically, if `a_0 < a_1 < ... < a_{n-1}`, and `b_i = a_{(i+1)%n}`.\n    # Then `d_i = a_i - a_{(i+1)%n}`.\n    # `d_0 = a_0 - a_1 < 0`\n    # `d_1 = a_1 - a_2 < 0`\n    # ...\n    # `d_{n-2} = a_{n-2} - a_{n-1} < 0`\n    # `d_{n-1} = a_{n-1} - a_0 > 0`\n    #\n    # The sum of all `d_i` is 0.\n    # If S is a proper non-empty subset, then it must either contain `n-1` or not.\n    # If it contains `n-1`, and not all other elements, then the sum is `(a_{n-1}-a_0) + sum_{i in S'} (a_i - a_{i+1})`.\n    # The sum of `k` negative numbers `a_i - a_{i+1}` will be negative.\n    # The sum `a_{n-1}-a_0` is positive.\n    # It is not immediately obvious that this sum is always non-zero.\n    # However, this construction (cyclic shift of sorted array) is a standard solution for this problem.\n    # Let's assume it works. The specific cyclic shift direction (forward or backward) shouldn't matter.\n\n    # Let's re-verify the example output [100, 1, 1000, 10]\n    # a = [1000, 100, 10, 1]\n    # b = [100, 1, 1000, 10]\n    #\n    # The example output corresponds to the following mapping:\n    # Original values and their indices:\n    # a[0]=1000\n    # a[1]=100\n    # a[2]=10\n    # a[3]=1\n    #\n    # Output b values:\n    # b[0]=100\n    # b[1]=1\n    # b[2]=1000\n    # b[3]=10\n    #\n    # This means:\n    # The element originally at index 0 (value 1000) is replaced by 100.\n    # The element originally at index 1 (value 100) is replaced by 1.\n    # The element originally at index 2 (value 10) is replaced by 1000.\n    # The element originally at index 3 (value 1) is replaced by 10.\n    #\n    # Let's map original indices to sorted indices:\n    # a[3] = 1 (s_0)\n    # a[2] = 10 (s_1)\n    # a[1] = 100 (s_2)\n    # a[0] = 1000 (s_3)\n    #\n    # The output b can be described as:\n    # b[3] = 10 (s_1)\n    # b[2] = 1000 (s_3)\n    # b[1] = 1 (s_0)\n    # b[0] = 100 (s_2)\n    #\n    # So, `a[idx_k]` (which is `s_k`) is mapped to `b[idx_k]`.\n    # For `s_0` (value 1, original index 3): `b[3]` is 10 (which is `s_1`). So `s_0 -> s_1`.\n    # For `s_1` (value 10, original index 2): `b[2]` is 1000 (which is `s_3`). So `s_1 -> s_3`.\n    # For `s_2` (value 100, original index 1): `b[1]` is 1 (which is `s_0`). So `s_2 -> s_0`.\n    # For `s_3` (value 1000, original index 0): `b[0]` is 100 (which is `s_2`). So `s_3 -> s_2`.\n    #\n    # This is NOT a simple cyclic shift of the sorted values.\n    # s_0 -> s_1\n    # s_1 -> s_3\n    # s_2 -> s_0\n    # s_3 -> s_2\n    # This is a permutation of the sorted values, but not a simple cyclic shift.\n    # This is confusing.\n\n    # Let's re-read the problem statement carefully:\n    # \"Construct an array b by permuting a such that for every non-empty subset of indices S ... the sums of elements on that positions in a and b are different\"\n    # This means `b` must be a permutation of the original `a`.\n    #\n    # The construction `result_b[original_idx_of_sk] = s_{(k-1+n)%n}` is a valid permutation.\n    # Let's check the values.\n    # The values `s_0, s_1, ..., s_{n-1}` are distinct.\n    # The values `s_{(0-1+n)%n}, s_{(1-1+n)%n}, ..., s_{((n-1)-1+n)%n}` are also just a cyclic shift of `s_0, ..., s_{n-1}`, so they are also distinct and cover all values.\n    # The `original_idx_of_sk` are `p_0, p_1, ..., p_{n-1}`, which are a permutation of `0, ..., n-1`.\n    # So, we are assigning each `b[j]` a unique value from `a`. This indeed makes `b` a permutation of `a`.\n    #\n    # The specific choice of `s_{(k-1+n)%n}` vs `s_{(k+1)%n}` doesn't matter, as long as it's a cyclic shift.\n    # The proof for why this works for any non-empty proper subset is usually done by contradiction.\n    # Assume sum_{i in S} (a_i - b_i) = 0.\n    # Let `a_0 < a_1 < ... < a_{n-1}` be the sorted array.\n    # Let `b_i = a_{(i+1)%n}` (this is for `a` being sorted).\n    # Then `d_i = a_i - b_i = a_i - a_{(i+1)%n}`.\n    # `d_i < 0` for `i=0, ..., n-2`.\n    # `d_{n-1} = a_{n-1} - a_0 > 0`.\n    # `sum d_i = 0`.\n    #\n    # If `sum_{i in S} d_i = 0` for a proper non-empty subset `S`.\n    # If `n-1` is not in `S`, then all `d_i` for `i in S` are negative. Their sum must be negative, so it cannot be 0.\n    # If `n-1` is in `S`, then `d_{n-1} = a_{n-1} - a_0 > 0`.\n    # For the sum to be 0, there must be at least one `i in S` such that `d_i < 0`.\n    # This means `S` must contain `n-1` and at least one other index `j < n-1`.\n    #\n    # Consider `n=2`, `a=[1, 2]`. Sorted `a=[1, 2]`.\n    # `indexed_a = [(1, orig_idx_of_1), (2, orig_idx_of_2)]`.\n    # If original `a=[1, 2]`, then `indexed_a = [(1, 0), (2, 1)]`.\n    # My proposed solution: `b[p_k] = s_{(k-1+n)%n}`.\n    # k=0: `s_0=1, p_0=0`. `b[0] = s_{(0-1+2)%2} = s_1 = 2`.\n    # k=1: `s_1=2, p_1=1`. `b[1] = s_{(1-1+2)%2} = s_0 = 1`.\n    # Result `b = [2, 1]`. This matches the example.\n    #\n    # Consider `n=4`, `a=[1000, 100, 10, 1]`.\n    # `indexed_a = [(1, 3), (10, 2), (100, 1), (1000, 0)]`\n    # My proposed solution: `b[p_k] = s_{(k-1+n)%n}`.\n    # k=0: `s_0=1, p_0=3`. `b[3] = s_{(0-1+4)%4} = s_3 = 1000`.\n    # k=1: `s_1=10, p_1=2`. `b[2] = s_{(1-1+4)%4} = s_0 = 1`.\n    # k=2: `s_2=100, p_2=1`. `b[1] = s_{(2-1+4)%4} = s_1 = 10`.\n    # k=3: `s_3=1000, p_3=0`. `b[0] = s_{(3-1+4)%4} = s_2 = 100`.\n    # Result `b = [100, 10, 1, 1000]`.\n    # This is different from the example output `[100, 1, 1000, 10]`, but should be valid.\n    # The problem says \"If there are multiple answers, print any of them.\"\n    # So this construction should be acceptable.\n\n    # Let's confirm the logic for the cyclic shift being valid.\n    # Let `s_0 < s_1 < ... < s_{n-1}` be the sorted distinct elements.\n    # Let `b_i = s_{(i+1)%n}`.\n    # The differences are `d_i = s_i - s_{(i+1)%n}`.\n    # `d_i < 0` for `i = 0, ..., n-2`.\n    # `d_{n-1} = s_{n-1} - s_0 > 0`.\n    # `sum_{i=0}^{n-1} d_i = 0`.\n    #\n    # We need to show that for any non-empty proper subset `S`, `sum_{i in S} d_i != 0`.\n    # Case 1: `n-1` is not in `S`.\n    # Then all `d_i` for `i in S` are negative. So `sum_{i in S} d_i < 0`. Thus `sum != 0`.\n    # Case 2: `n-1` is in `S`.\n    # Since `S` is a proper subset, there is at least one index `j` not in `S`.\n    # If `S = {n-1}`, then `sum_{i in S} d_i = d_{n-1} = s_{n-1} - s_0 > 0`. Thus `sum != 0`.\n    # If `S` contains `n-1` and other indices `j < n-1`.\n    # `sum_{i in S} d_i = d_{n-1} + sum_{j in S, j < n-1} d_j`.\n    # Let `P = d_{n-1} = s_{n-1} - s_0`. This is positive.\n    # Let `N = sum_{j in S, j < n-1} d_j`. This is a sum of one or more negative numbers, so `N < 0`.\n    # We need to show `P + N != 0`.\n    #\n    # The maximum possible value for `|N|` is when `S` contains all `j < n-1`.\n    # `N_max = sum_{j=0}^{n-2} (s_j - s_{j+1}) = (s_0 - s_1) + (s_1 - s_2) + ... + (s_{n-2} - s_{n-1}) = s_0 - s_{n-1}`.\n    # In this case, `P + N_max = (s_{n-1} - s_0) + (s_0 - s_{n-1}) = 0`.\n    # However, this sum corresponds to `S = {0, 1, ..., n-1}`, which is the entire set of indices, which is excluded.\n    # So if `S` is a proper subset containing `n-1`, it must be that `S` does not contain at least one `j < n-1`.\n    # This means `N` is a sum of *fewer* negative terms than `N_max`.\n    # So `N > N_max = s_0 - s_{n-1}`.\n    # Thus `P + N > P + (s_0 - s_{n-1}) = (s_{n-1} - s_0) + (s_0 - s_{n-1}) = 0`.\n    # So `P + N > 0`. Therefore `P + N != 0`.\n    #\n    # This proves that the cyclic shift strategy works.\n    # The logic is sound.\n\n    # Final check on implementation:\n    # `indexed_a` stores `(value, original_index)`.\n    # `indexed_a.sort()` sorts these pairs based on `value`.\n    # So `indexed_a[k]` is `(s_k, p_k)`.\n    # We want `result_b[p_k] = s_{(k-1+n)%n}`.\n    # `p_k` is `indexed_a[k][1]`.\n    # `s_{(k-1+n)%n}` is `indexed_a[(k-1+n)%n][0]`.\n    # This is exactly what the code does.\n\n    print(*(result_b))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 7159,
        "thoughts_token_count": 0
    }
}