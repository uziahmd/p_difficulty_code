{
    "start": 1758294847.2151256,
    "end": 1758294905.6851797,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Here's how I'm thinking about this problem, and my current strategy:**\n\nOkay, so I need to tackle this competitive programming problem. The goal is to figure out two things: first, what's the smallest number of nodes I need to create a special type of graph, a \"p-reachable\" one. Second, among all those smallest graphs, what's the most \"one-way\" pairs of connections I can have. Let me break down the definitions to make sure I understand.\n\n*   **Reachability:** Simple enough, one node can get to another. \"Reachability from each other\" means they're effectively in a group, a strongly connected component (SCC).\n\n*   **P-Reachable Graph:** This is the key. It's all about ordered pairs of nodes (u, v) where u is smaller than v, and u and v can reach each other.  Each pair in an SCC counts for exactly one (u, v) or (v, u) depending on which satisfies u < v. This count needs to equal exactly 'p'.\n\n*   **Unidirectional Pair:** This is the \"one-way\" connection. There's a path from 'u' to 'v', but not from 'v' back to 'u'. This means 'u' and 'v' are in separate SCCs, and we're looking at connections *between* them.\n\nMy first thought is that the *p*-reachable condition is driving the minimum size of the graph.  If I have an SCC with *k* nodes, I can make *k*(k-1)/2 pairs that satisfy the *p*-reachable condition.  If I can find the right sizes of SCCs that meet 'p', I can find the smallest graph!\n\nI'm thinking a *greedy* strategy here. I should make the biggest possible SCCs first, because that will give me the most connections for a given number of nodes. So, I need to figure out what's the largest *k* where *k*(k-1)/2 is less than or equal to *p*.  If it's equal, great. If not, I'll subtract that from *p* and repeat the process with the remainder. That will get me the minimum number of nodes to meet 'p'! This seems efficient because *k*(k-1)/2 grows quite fast, and this should give me relatively few SCCs.\n\nIf *p* is 0, then the number of nodes is one as defined, otherwise I need to figure out the right *k* values using a loop.  Now, the calculation of *n*, the number of nodes, comes down to the sum of the SCC sizes.\n\nNow comes the \"one-way\" connections: how to get the maximum unidirectional pairs. To get the maximum number of those pairs, I need the SCCs connected linearly. If I lay them out as SCC1 -> SCC2 -> SCC3, then every node in SCC1 can reach every node in SCC2 and SCC3, but not the other way around.  I'm basically maximizing the inter-SCC connectivity. Now I need to minimize the number of nodes!\n\nWith that structure, the count of one-way pairs becomes much simpler to compute:  I can just take the total size of the graph squared minus the sum of the squares of the SCC sizes and divide by 2.\n\n*   Finding the SCC sizes (s1, s2, ...) is key!\n\n*   n = sum(si)\n\n*   Total Unidirectional Pairs = (n\\*n - sum(si\\*si)) / 2\n\nOkay, now let's think about the actual implementation. I'm going to need a loop to find those SCC sizes and then a way to calculate the maximum number of unidirectional pairs.  This looks like a pretty efficient algorithm. Now, I have to be careful with the floating-point stuff and special cases.",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. Among all such `p`-reachable directed graphs with the minimum number of nodes, the maximum number of unidirectional pairs of nodes.\n\nLet's define the terms:\n- **Reachable from each other:** Two distinct nodes `u` and `v` are reachable from each other if there's a path `u -> v` and a path `v -> u`. This means `u` and `v` belong to the same strongly connected component (SCC).\n- **`p`-reachable graph:** A graph is `p`-reachable if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n- **Unidirectional pair:** An ordered pair `(u, v)` is unidirectional if `u != v`, there's a path `u -> v`, and no path `v -> u`. This means `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC in the condensation graph (DAG of SCCs).\n\n**Part 1: Minimum number of nodes `n`**\n\nLet's analyze the `p`-reachable condition. If an SCC has `k` nodes, any two distinct nodes `u, v` within this SCC are reachable from each other. The number of such pairs `(u, v)` with `u < v` is `k * (k - 1) / 2`.\nTo achieve a total of `p` such pairs, we need to partition `p` into sums of `k_i * (k_i - 1) / 2` for various SCCs of sizes `k_i`. That is, `p = sum(k_i * (k_i - 1) / 2)`. The total number of nodes `n` would be `sum(k_i)`.\nTo minimize `n` for a given `p`, we should use the largest possible SCCs. This is a greedy approach:\n1. Find the largest integer `k` such that `k * (k - 1) / 2 <= p`.\n2. Include an SCC of size `k`. Add `k` to `n_total`.\n3. Subtract `k * (k - 1) / 2` from `p`.\n4. Repeat until `p` becomes 0.\n\nThe function `f(k) = k * (k - 1) / 2` is convex, so using larger `k` values is more efficient in producing pairs for fewer nodes.\nThe value of `k` can be found by solving `k^2 - k - 2p <= 0`, which gives `k <= (1 + sqrt(1 + 8p)) / 2`. So, `k = floor((1 + sqrt(1 + 8p)) / 2)`. We must be careful with floating point precision or use binary search to find `k`. Given `p <= 2 * 10^5`, `k` will be at most `633`, so binary search is efficient enough.\n\n**Edge case for `p=0`:**\nIf `p=0`, the loop described above won't add any nodes if `k` is chosen such that `k*(k-1)/2` is always `0`. If `k=1`, `f(1)=0`. If `k=0`, `f(0)=0`. However, a graph must have nodes. The minimum number of nodes for `p=0` is `1`. A single node graph has no pairs `(u,v)` with `u<v` and `u,v` reachable from each other, so it's `0`-reachable. The problem example for `p=0` shows `0 0`. This implies `n=0` is allowed if `p=0`. If `n=0` is allowed, then `n=0` is the minimum for `p=0`. We will follow the example.\n\n**Algorithm for `n`:**\n- If `p == 0`, `n = 0`.\n- Otherwise:\n  - Initialize `n = 0`.\n  - Initialize an empty list `s_values` to store the sizes of SCCs.\n  - While `p > 0`:\n    - Find the largest `k` such that `k * (k - 1) / 2 <= p`. This can be done with binary search for `k` in range `[1, 700]` (since max `k` for `p=2*10^5` is `633`).\n    - Add `k` to `n`.\n    - Add `k` to `s_values`.\n    - Subtract `k * (k - 1) / 2` from `p`.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nLet `n` be the minimum number of nodes found, and `s_1, s_2, ..., s_m` be the sizes of the SCCs determined by the greedy strategy.\nA unidirectional pair `(u, v)` exists if `u` is in `SCC_A`, `v` is in `SCC_B`, `SCC_A` can reach `SCC_B`, and `SCC_B` cannot reach `SCC_A`.\nTo maximize such pairs, we should arrange the SCCs in a linear chain: `C_1 -> C_2 -> ... -> C_m`. This means we add an edge from some node in `C_i` to some node in `C_{i+1}` for each `i`, and no edges `C_j -> C_i` for `j > i`.\nIn this configuration, for any `u` in `C_i` and `v` in `C_j` with `i < j`, there is a path `u -> v` but no path `v -> u`. All `s_i * s_j` such pairs are unidirectional.\nThe total number of unidirectional pairs is `sum_{1 <= i < j <= m} (s_i * s_j)`.\nThis sum can be computed using the identity:\n`(sum s_i)^2 = sum(s_i^2) + 2 * sum_{i<j} (s_i * s_j)`\nSo, `sum_{i<j} (s_i * s_j) = ((sum s_i)^2 - sum(s_i^2)) / 2`.\nSince `sum s_i = n`, the number of unidirectional pairs is `(n^2 - sum(s_i^2)) / 2`.\n\n**Algorithm for unidirectional pairs:**\n- Calculate `sum_s_squared = sum(s_i * s_i for s_i in s_values)`.\n- The maximum number of unidirectional pairs is `(n * n - sum_s_squared) // 2`.\n- If `p == 0`, `n=0`, `s_values` is empty. `sum_s_squared` would be `0`. Unidirectional pairs `(0*0 - 0) // 2 = 0`. This matches the example.\n\n**Example Walkthroughs:**\n\n**`p = 3`:**\n1. **Find `n`:**\n   - `p = 3`.\n   - Binary search for `k`: `k=3` gives `3*(3-1)/2 = 3`.\n   - `n = 3`. `s_values = [3]`. `p = 3 - 3 = 0`.\n   - Loop ends. `n = 3`.\n2. **Unidirectional pairs:**\n   - `sum_s_squared = 3*3 = 9`.\n   - Unidirectional pairs = `(3*3 - 9) // 2 = (9 - 9) // 2 = 0`.\nOutput: `3 0`. Matches example.\n\n**`p = 4`:**\n1. **Find `n`:**\n   - `p = 4`.\n   - Binary search for `k`: `k=3` gives `3*(3-1)/2 = 3`.\n   - `n = 3`. `s_values = [3]`. `p = 4 - 3 = 1`.\n   - `p = 1`.\n   - Binary search for `k`: `k=2` gives `2*(2-1)/2 = 1`.\n   - `n = 3 + 2 = 5`. `s_values = [3, 2]`. `p = 1 - 1 = 0`.\n   - Loop ends. `n = 5`.\n2. **Unidirectional pairs:**\n   - `sum_s_squared = 3*3 + 2*2 = 9 + 4 = 13`.\n   - Unidirectional pairs = `(5*5 - 13) // 2 = (25 - 13) // 2 = 12 // 2 = 6`.\nOutput: `5 6`. Matches example.\n\n**Final check for `p=0`:**\n- `p = 0`.\n- `n = 0`.\n- `s_values = []`. `sum_s_squared = 0`.\n- Unidirectional pairs = `(0*0 - 0) // 2 = 0`.\nOutput: `0 0`. Matches example.\n\nThe solution seems robust.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    s_values = []\n    current_p = p\n\n    # Calculate minimum number of nodes (n) and the sizes of SCCs (s_values)\n    while current_p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= current_p\n        # Using binary search for robustness against floating point issues\n        k = 0\n        low = 1\n        # Max k for p = 2*10^5 is 633, so 700 is a safe upper bound\n        high = 700 \n        \n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= current_p:\n                k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        min_nodes += k\n        s_values.append(k)\n        current_p -= k * (k - 1) // 2\n\n    # Calculate the maximum number of unidirectional pairs\n    # This is (n^2 - sum(s_i^2)) / 2\n    sum_s_squared = 0\n    for s_i in s_values:\n        sum_s_squared += s_i * s_i\n    \n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_s_squared) // 2\n\n    print(f\"{min_nodes} {max_unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    s_values = []\n    current_p = p\n\n    # Calculate minimum number of nodes (n) and the sizes of SCCs (s_values)\n    while current_p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= current_p\n        # Using binary search for robustness against floating point issues\n        k = 0\n        low = 1\n        # Max k for p = 2*10^5 is 633, so 700 is a safe upper bound\n        high = 700 \n        \n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= current_p:\n                k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        min_nodes += k\n        s_values.append(k)\n        current_p -= k * (k - 1) // 2\n\n    # Calculate the maximum number of unidirectional pairs\n    # This is (n^2 - sum(s_i^2)) / 2\n    sum_s_squared = 0\n    for s_i in s_values:\n        sum_s_squared += s_i * s_i\n    \n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_s_squared) // 2\n\n    print(f\"{min_nodes} {max_unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 473,
        "completion_token_count": 2558,
        "thoughts_token_count": 5706
    }
}