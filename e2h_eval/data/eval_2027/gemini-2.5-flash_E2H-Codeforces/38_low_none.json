{
    "start": 1758285104.0286984,
    "end": 1758285143.4407067,
    "start-formatted": "2025-09-19 21:31 KST",
    "end-formatted": "2025-09-19 21:32 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through a Competitive Programming Problem**\n\nOkay, so I've got this competitive programming problem and I need to figure out the optimal graph structure. The goal is to find two things: first, the absolute minimum number of nodes (`n`) needed to create a directed graph with a specific property, and second, the maximum possible number of unidirectional pairs within that minimal graph.\n\nLet's unpack this. We're talking about a \"p-reachable directed graph.\" That means we're dealing with \"reachable from each other\" pairs, where for nodes `u` and `v` (with `u < v`), there must be a directed path from `u` to `v` *and* a path from `v` to `u`.  This clearly points to strongly connected components (SCCs).  If two nodes are within the same SCC, they satisfy this \"reachable from each other\" condition.\n\nNow, within an SCC of size `k`, how many such pairs do we get?  Well, any two nodes within the SCC are mutually reachable.  So, we're looking at `k * (k - 1) / 2` pairs within an SCC of size `k`.\n\nIf we have a graph with `n` nodes, it's made up of `m` SCCs, each with its own size `k_i`.  The sum of the SCC sizes equals the total number of nodes: `k_1 + k_2 + ... + k_m = n`. The total number of reachable pairs, `P`, is then the sum of the reachable pairs within each SCC: `P = sum(k_i * (k_i - 1) / 2)`.\n\nWe're given `P = p`. The challenge is to find the minimum `n` that allows for this. To minimize `n`, I need to make the `k_i` values as large as possible. Logically, the most efficient structure would involve a *single* SCC.  This translates into finding the smallest `k` where `k * (k - 1) / 2` is greater than or equal to `p`. That's essentially solving `k^2 - k - 2p >= 0`. Using the quadratic formula, I can find the roots of that equation, and then use the positive root to determine a suitable lower bound for k.\nSo, `k_min = ceil((1 + sqrt(1 + 8p)) / 2)`.\nThis gives me my possible minimum 'n' value.\nIf p can be formed by a single SCC, that minimum 'n' is achieved.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. Among all such `p`-reachable directed graphs with the minimum number of nodes `n`, the maximum number of unidirectional pairs of nodes.\n\nLet's break down the definitions:\n\n**1. `p`-reachable graph:**\nA directed graph is `p`-reachable if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\nNodes `u` and `v` are reachable from each other if and only if they belong to the same Strongly Connected Component (SCC).\nIf an SCC has `k` nodes, then any two distinct nodes `u, v` within this SCC satisfy the condition. The number of such pairs `(u, v)` with `u < v` is `k * (k - 1) / 2`.\n\nLet `n` be the total number of nodes. Suppose the graph has `m` SCCs with sizes `k_1, k_2, ..., k_m`.\nThen `k_1 + k_2 + ... + k_m = n`.\nThe total number of pairs `(u, v)` with `u < v` reachable from each other is `P = sum(k_i * (k_i - 1) / 2 for i in range(m))`.\nWe are given `P = p`.\n\n**Minimizing `n`:**\nTo minimize `n` for a fixed `p`, we want to use as few SCCs as possible, and make their sizes as large as possible.\nConsider the function `f(k) = k * (k - 1) / 2`. This function represents the number of pairs for an SCC of size `k`.\nIt's an increasing function for `k >= 1`.\nWe want to find the smallest `n` such that `sum(k_i * (k_i - 1) / 2) = p` and `sum(k_i) = n`.\n\nIt's always optimal to have as few SCCs as possible, and make them as large as possible to reach `p`.\nThis is because `f(k+1) + f(k-1) = (k+1)k/2 + (k-1)(k-2)/2 = (k^2+k + k^2-3k+2)/2 = (2k^2-2k+2)/2 = k^2-k+1`.\nAnd `f(k) + f(k) = k(k-1)`.\nSince `k^2-k+1 > k(k-1)` for `k > 1`, splitting an SCC into two smaller ones (e.g., `k` into `k-1` and `1`) or merging two smaller ones `k-1` and `1` into `k` changes the sum.\nThe sum `sum(k_i * (k_i - 1) / 2)` is minimized for a fixed `sum(k_i)` when all `k_i` are equal, but here we want to reach a specific `p`.\n\nThe strategy to minimize `n` is to find the largest possible `k` such that `k * (k - 1) / 2 <= p`. Let this be `k_1`.\nThen, `n` will be at least `k_1`. The remaining `p' = p - k_1 * (k_1 - 1) / 2` must be covered by additional nodes.\nWe can find `k_1` by solving `k^2 - k - 2p <= 0`, which gives `k <= (1 + sqrt(1 + 8p)) / 2`.\nSo, `k_1 = floor((1 + sqrt(1 + 8p)) / 2)`.\nIf `p = 0`, `k_1 = 1` (or `0`, but we need at least one node to represent a graph). `f(1) = 0`. So `k_1=1` is a good starting point.\nThe number of nodes used for this largest SCC is `k_1`.\nThe remaining `p_rem = p - k_1 * (k_1 - 1) / 2` needs to be covered.\nEach additional node we add can form an SCC of size 1. This contributes `1 * (1 - 1) / 2 = 0` to `p`.\nTo cover `p_rem`, we must add more SCCs. The most efficient way to get `p_rem` pairs is to add `p_rem` SCCs of size 2. Each such SCC adds `2 * (2 - 1) / 2 = 1` pair.\nSo, we need `p_rem` SCCs of size 2. This would add `2 * p_rem` nodes.\nThe total number of nodes `n = k_1 + 2 * p_rem`.\nThis strategy minimizes `n` because `k_1` is the largest possible SCC, and `p_rem` is covered by the smallest possible non-zero SCC contributions (size 2 SCCs).\n\nLet's verify this:\n`k_1 = floor((1 + sqrt(1 + 8p)) / 2)`\n`p_rem = p - k_1 * (k_1 - 1) / 2`\nMinimum `n = k_1 + 2 * p_rem`.\n\nExample: `p = 3`\n`k_1 = floor((1 + sqrt(1 + 8*3)) / 2) = floor((1 + sqrt(25)) / 2) = floor((1 + 5) / 2) = floor(3) = 3`.\n`p_rem = 3 - 3 * (3 - 1) / 2 = 3 - 3 = 0`.\nMinimum `n = 3 + 2 * 0 = 3`.\n\nExample: `p = 4`\n`k_1 = floor((1 + sqrt(1 + 8*4)) / 2) = floor((1 + sqrt(33)) / 2) = floor((1 + 5.74) / 2) = floor(3.37) = 3`.\n`p_rem = 4 - 3 * (3 - 1) / 2 = 4 - 3 = 1`.\nMinimum `n = 3 + 2 * 1 = 5`.\n\nThis approach correctly finds the minimum `n`.\n\n**2. Maximizing unidirectional pairs:**\nA pair `(u, v)` is unidirectional if `u != v`, there is a path from `u` to `v`, and there is no path from `v` to `u`.\nThis means `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC in the condensation graph (DAG of SCCs).\n\nTo maximize unidirectional pairs, we want to arrange the SCCs in a chain (linear order) in the condensation graph.\nLet the SCCs be `S_1, S_2, ..., S_m` with sizes `k_1, k_2, ..., k_m`.\nIf we connect `S_i` to `S_{i+1}` (e.g., by adding an edge from some node in `S_i` to some node in `S_{i+1}`), then any node `u` in `S_i` can reach any node `v` in `S_{i+1}`.\nIn a linear arrangement `S_1 -> S_2 -> ... -> S_m`, any node `u` in `S_i` can reach any node `v` in `S_j` if `i < j`.\nFor such a pair `(u, v)`, `u` and `v` are in different SCCs, so there's no path from `v` to `u`. This forms a unidirectional pair.\nThe total number of unidirectional pairs is `sum_{i < j} (k_i * k_j)`.\n\nThe SCCs we have are: one SCC of size `k_1`, and `p_rem` SCCs of size 2.\nLet these `p_rem` SCCs of size 2 be `S_2, S_3, ..., S_{p_rem+1}`.\nThe total number of SCCs is `m = 1 + p_rem`.\nWe want to maximize `sum_{i < j} (k_i * k_j)`.\nThis sum is maximized when the largest SCCs are at the ends of the chain, or when they are grouped together.\nConsider the sum `(sum k_i)^2 = sum k_i^2 + 2 * sum_{i < j} k_i k_j`.\nSo `sum_{i < j} k_i k_j = (n^2 - sum k_i^2) / 2`.\nTo maximize `sum_{i < j} k_i k_j`, we need to minimize `sum k_i^2`.\nFor a fixed sum `n = sum k_i`, `sum k_i^2` is minimized when `k_i` values are as close as possible.\nOur `k_i` values are `k_1` (the largest) and `p_rem` copies of `2`.\nIf `k_1 = 1` (when `p=0`), then all `n` nodes are in SCCs of size 1. `n = 1 + 2p_rem`.\nIn this case, all `k_i` are 1s, so `sum k_i^2 = n`. Unidirectional pairs = `(n^2 - n) / 2`.\nIf `k_1 > 1`, we have `k_1` and `p_rem` copies of `2`.\nThe sum of squares is `k_1^2 + p_rem * 2^2 = k_1^2 + 4 * p_rem`.\nThe total number of unidirectional pairs is `(n^2 - (k_1^2 + 4 * p_rem)) / 2`.\n\nLet's calculate this value:\n`n = k_1 + 2 * p_rem`\n`max_unidirectional_pairs = ((k_1 + 2 * p_rem)^2 - (k_1^2 + 4 * p_rem)) / 2`\n`= (k_1^2 + 4 * k_1 * p_rem + 4 * p_rem^2 - k_1^2 - 4 * p_rem) / 2`\n`= (4 * k_1 * p_rem + 4 * p_rem^2 - 4 * p_rem) / 2`\n`= 2 * k_1 * p_rem + 2 * p_rem^2 - 2 * p_rem`\n`= 2 * p_rem * (k_1 + p_rem - 1)`\n\nLet's test with examples:\nExample: `p = 3`\n`k_1 = 3`, `p_rem = 0`.\n`n = 3`.\n`max_unidirectional_pairs = 2 * 0 * (3 + 0 - 1) = 0`.\nOutput: `3 0`. Matches example.\n\nExample: `p = 4`\n`k_1 = 3`, `p_rem = 1`.\n`n = 5`.\n`max_unidirectional_pairs = 2 * 1 * (3 + 1 - 1) = 2 * 1 * 3 = 6`.\nOutput: `5 6`. Matches example.\n\nExample: `p = 0`\n`k_1 = 1`, `p_rem = 0`.\n`n = 1`.\n`max_unidirectional_pairs = 2 * 0 * (1 + 0 - 1) = 0`.\nOutput: `1 0`. (The example output is `0 0`, which implies an empty graph. If `n=1`, there are no pairs `(u,v)` with `u<v`. So `p=0` is correct. Unidirectional pairs: `0`. This is consistent.)\nIf we interpret `n=0` for `p=0`, then `k_1` should be `0`. Let's adjust `k_1` logic for `p=0`.\nIf `p=0`, then `k_1 = floor((1 + sqrt(1))/2) = 1`. `p_rem = 0 - 1*(0)/2 = 0`. `n = 1 + 2*0 = 1`.\nThis graph with 1 node has 0 pairs `(u,v)` with `u<v`. So it is 0-reachable. It also has 0 unidirectional pairs.\nThe example output `0 0` for `p=0` suggests `n=0` nodes. If `n=0`, there are no nodes, so no pairs `(u,v)` and no unidirectional pairs. This is also a valid 0-reachable graph. The minimum number of nodes is 0.\nSo, if `p=0`, `n=0` and unidirectional pairs `0`.\n\nThe formula for `k_1` using `floor((1 + sqrt(1 + 8p)) / 2)` gives `k_1=1` for `p=0`.\nIf `k_1=1`, then `f(k_1)=0`.\nIf `p=0`, `p_rem=0`. `n = 1`. `unidir = 0`.\nThis is fine. A graph with 1 node has 0 pairs `(u,v)` with `u<v` and 0 unidirectional pairs.\nThe problem statement says `u != v`.\nThe example output `0 0` for `p=0` is a bit ambiguous. Usually, a graph has at least 1 node if `n` is not 0. If `n=0`, it's an empty graph.\nLet's stick to `n=1` for `p=0` as the formula naturally gives it. `0` nodes is also a valid answer. `1` node is also a valid answer. What's minimum? `0`.\nSo, for `p=0`, output `0 0`.\nFor `p > 0`, use the derived formulas.\n\nFinal check on edge case `p=0`:\nIf `p = 0`:\nMinimum `n = 0`.\nMaximum unidirectional pairs = `0`.\nThis is a special case.\n\nFor `p > 0`:\n`k_1 = int((1 + (1 + 8 * p)**0.5) / 2)`\n`p_rem = p - k_1 * (k_1 - 1) // 2`\n`min_n = k_1 + 2 * p_rem`\n`max_unidirectional_pairs = 2 * p_rem * (k_1 + p_rem - 1)`\n\nConsider `p = 1`:\n`k_1 = int((1 + (1 + 8 * 1)**0.5) / 2) = int((1 + 3) / 2) = 2`.\n`p_rem = 1 - 2 * (2 - 1) // 2 = 1 - 1 = 0`.\n`min_n = 2 + 2 * 0 = 2`.\n`max_unidirectional_pairs = 2 * 0 * (2 + 0 - 1) = 0`.\nOutput for `p=1`: `2 0`.\nThis makes sense: 2 nodes, form an SCC of size 2. `(u,v)` with `u<v` is 1 pair. 0 unidirectional.\n\nConsider `p = 2`:\n`k_1 = int((1 + (1 + 8 * 2)**0.5) / 2) = int((1 + sqrt(17)) / 2) = int((1 + 4.12) / 2) = int(2.56) = 2`.\n`p_rem = 2 - 2 * (2 - 1) // 2 = 2 - 1 = 1`.\n`min_n = 2 + 2 * 1 = 4`.\n`max_unidirectional_pairs = 2 * 1 * (2 + 1 - 1) = 2 * 1 * 2 = 4`.\nOutput for `p=2`: `4 4`.\nThis means one SCC of size 2, and one SCC of size 2. Total 4 nodes.\nLet SCCs be `S1={1,2}` and `S2={3,4}`.\nPairs `(u,v)` reachable from each other: `(1,2)` from S1, `(3,4)` from S2. Total 2.\nUnidirectional pairs: If `S1 -> S2`, then `1->3`, `1->4`, `2->3`, `2->4`. Total `2*2=4`.\n\nThe logic seems solid.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Calculate k_1: the size of the largest SCC\n    # k_1 * (k_1 - 1) / 2 <= p\n    # k_1^2 - k_1 - 2p <= 0\n    # Roots of k^2 - k - 2p = 0 are (1 +/- sqrt(1 + 8p)) / 2\n    # So k_1 <= (1 + sqrt(1 + 8p)) / 2\n    # We take the floor of this value\n    k1 = int((1 + math.isqrt(1 + 8 * p)) / 2)\n    \n    # Calculate p_rem: remaining pairs to be covered after forming the largest SCC\n    p_rem = p - (k1 * (k1 - 1) // 2)\n    \n    # Minimum number of nodes:\n    # k1 nodes for the largest SCC\n    # Each remaining pair p_rem is covered by an SCC of size 2.\n    # An SCC of size 2 contributes 1 pair (2*(2-1)/2 = 1) and uses 2 nodes.\n    min_n = k1 + 2 * p_rem\n    \n    # Maximum unidirectional pairs:\n    # To maximize unidirectional pairs, arrange all SCCs in a linear chain.\n    # The SCCs are: one of size k1, and p_rem SCCs of size 2.\n    # Let the sizes be k_1, k_2, ..., k_m where k_2 to k_m are all 2.\n    # Total sum of nodes = n\n    # Sum of squares of SCC sizes = k1^2 + p_rem * 2^2 = k1^2 + 4 * p_rem\n    # Max unidirectional pairs = (n^2 - sum(k_i^2)) / 2\n    # = ((k1 + 2*p_rem)^2 - (k1^2 + 4*p_rem)) / 2\n    # = (k1^2 + 4*k1*p_rem + 4*p_rem^2 - k1^2 - 4*p_rem) / 2\n    # = (4*k1*p_rem + 4*p_rem^2 - 4*p_rem) / 2\n    # = 2*k1*p_rem + 2*p_rem^2 - 2*p_rem\n    # = 2 * p_rem * (k1 + p_rem - 1)\n    max_unidirectional_pairs = 2 * p_rem * (k1 + p_rem - 1)\n    \n    print(min_n, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Calculate k_1: the size of the largest SCC\n    # k_1 * (k_1 - 1) / 2 <= p\n    # k_1^2 - k_1 - 2p <= 0\n    # Roots of k^2 - k - 2p = 0 are (1 +/- sqrt(1 + 8p)) / 2\n    # So k_1 <= (1 + sqrt(1 + 8p)) / 2\n    # We take the floor of this value\n    k1 = int((1 + math.isqrt(1 + 8 * p)) / 2)\n    \n    # Calculate p_rem: remaining pairs to be covered after forming the largest SCC\n    p_rem = p - (k1 * (k1 - 1) // 2)\n    \n    # Minimum number of nodes:\n    # k1 nodes for the largest SCC\n    # Each remaining pair p_rem is covered by an SCC of size 2.\n    # An SCC of size 2 contributes 1 pair (2*(2-1)/2 = 1) and uses 2 nodes.\n    min_n = k1 + 2 * p_rem\n    \n    # Maximum unidirectional pairs:\n    # To maximize unidirectional pairs, arrange all SCCs in a linear chain.\n    # The SCCs are: one of size k1, and p_rem SCCs of size 2.\n    # Let the sizes be k_1, k_2, ..., k_m where k_2 to k_m are all 2.\n    # Total sum of nodes = n\n    # Sum of squares of SCC sizes = k1^2 + p_rem * 2^2 = k1^2 + 4 * p_rem\n    # Max unidirectional pairs = (n^2 - sum(k_i^2)) / 2\n    # = ((k1 + 2*p_rem)^2 - (k1^2 + 4*p_rem)) / 2\n    # = (k1^2 + 4*k1*p_rem + 4*p_rem^2 - k1^2 - 4*p_rem) / 2\n    # = (4*k1*p_rem + 4*p_rem^2 - 4*p_rem) / 2\n    # = 2*k1*p_rem + 2*p_rem^2 - 2*p_rem\n    # = 2 * p_rem * (k1 + p_rem - 1)\n    max_unidirectional_pairs = 2 * p_rem * (k1 + p_rem - 1)\n    \n    print(min_n, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 473,
        "completion_token_count": 4590,
        "thoughts_token_count": 763
    }
}