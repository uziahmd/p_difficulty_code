{
    "start": 1758284917.749323,
    "end": 1758284970.334857,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Breaking Down the Mushroom Strife Problem**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem, and my first instinct is to build a Python solution. The core is assigning mushroom counts to lawns (represented as vertices) in a graph, given the GCD and LCM of mushroom counts for connected lawns (edges). The goal is to find a *valid* assignment, or determine that one doesn't exist.\n\nMy understanding is that the crucial relationship here is  `GCD(a, b) * LCM(a, b) = a * b`. That's the key to unlocking this, I think.  For a given edge between lawns `u` and `v`, with `g = GCD(a_u, a_v)` and `l = LCM(a_u, a_v)`, I can see that:\n\n1.  `g` divides both `a_u` and `a_v`.\n2.  `a_u` and `a_v` divide `l`.\n3.  `g * l = a_u * a_v`.\n\nFrom the first point, I can express `a_u` as `g * x` and `a_v` as `g * y`, where `x` and `y` are integers.  Then, since `GCD(a_u, a_v) = g`, the GCD of `x` and `y` must be 1 (they're coprime).\n\nSubstituting this into `g * l = a_u * a_v`, I get `g * l = g^2 * x * y`, which simplifies to `l = g * x * y`.  This means `l / g = x * y`. Let's call this value `P`.\n\nTherefore, for each edge, I need to find two coprime factors, `x` and `y`, of `P = l / g`. This will determine the mushroom counts `a_u = g * x` and `a_v = g * y` for the connected lawns.  Also, it's immediately obvious that if `l % g != 0` for *any* edge, then there's no solution – `P` needs to be an integer.\n\nThe constraints are pretty tight: `1 <= a_i, g, l <= 10^6`. This means `g * x` and `g * y` need to fall within that range.  Since `g` is at least 1, this also limits the values of `x` and `y`.\n\nSo, the problem boils down to a graph with constraints on vertex values. I'll need a way to assign values that satisfy all edge conditions, taking into account the coprime factor constraint. Now, how to formulate that in Python? I have a few ideas on efficient factorization and how to propagate these constraints across the graph, which I will get to next.\n",
    "response": "```python\nimport sys\nfrom collections import deque\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Should not happen based on constraints (n >= 1)\n        sys.stdout.write(\"YES\\n\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)] # 1-indexed for lawns\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    # Initialize values array, 0 means unassigned\n    values = [0] * (n + 1)\n    \n    # Store potential factors for each node\n    # Each node can have multiple constraints on its value from different edges.\n    # We use a list of (prime_factor, exponent) tuples for each node,\n    # representing the required prime factorization of its value.\n    # Example: {2: 3, 3: 1} for 2^3 * 3^1 = 24\n    # We use a dictionary for easier updates.\n    node_factors = [{} for _ in range(n + 1)]\n\n    # Check initial conditions and derive prime factors for P = l/g\n    for u, v, g, l in edges_data:\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n        \n        # All a_i must be multiples of g.\n        # This implies a_u and a_v must be multiples of g.\n        # This is implicitly handled by the factor propagation.\n        # If a node's value is determined, it must be a multiple of g for all incident edges.\n        # We will check this later.\n\n    # Precompute primes up to sqrt(10^6) = 1000\n    # For factorization, we need primes up to max_val (10^6) or sqrt(max_val) if using trial division.\n    # Since P can be up to 10^6, we need primes up to 10^6.\n    # However, we only need to factorize P. If P has a prime factor > sqrt(P), it can have at most one such factor.\n    # So, primes up to sqrt(10^6) = 1000 are sufficient for trial division.\n    \n    max_val_limit = 10**6\n    sieve_limit = int(math.sqrt(max_val_limit)) + 1 # Max possible P is 10^6\n    is_prime = [True] * (sieve_limit + 1)\n    primes = []\n    for p in range(2, sieve_limit + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p * p, sieve_limit + 1, p):\n                is_prime[multiple] = False\n\n    # Function to get prime factorization of a number\n    # Returns a dict {prime: exponent}\n    def get_prime_factorization(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num:\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1: # Remaining factor is a prime\n            factors[temp_num] = 1\n        return factors\n\n    # Main BFS/DFS loop to assign values\n    for start_node in range(1, n + 1):\n        if values[start_node] == 0: # If node not yet processed\n            \n            # Start a BFS from this node\n            q = deque()\n            \n            # For the first node in a component, we can arbitrarily assign 1 to its 'x' part\n            # Or, more generally, we can say its value is 1 * its 'g' part from an arbitrary edge.\n            # Let's try to determine its full value based on its prime factors.\n            \n            # Initialize factors for start_node.\n            # An arbitrary choice for an unvisited component:\n            # For the first node 'u' encountered, we can try to set its value to 'g'\n            # (which means its x-part is 1) for one of its incident edges.\n            # Or we can just set its factors to be empty (meaning its value is 1, if no other constraints apply).\n            # The current approach is to try to derive factors for all node_factors[u] based on edges.\n            # If node_factors[u] remains empty, it means its value could be 1.\n            \n            # Let's use a queue for nodes whose 'node_factors' have been updated and need to propagate.\n            # We will put nodes into the queue if their factors are *fixed* or *partially fixed*\n            # and need to be used to constrain neighbors.\n            \n            # A more robust approach:\n            # For each connected component, pick an arbitrary node `u`.\n            # Assign `node_factors[u]` to be empty (representing `a_u = 1` initially, before 'g' constraints).\n            # Then propagate.\n            \n            # Reset values for the current component's processing\n            component_values = [0] * (n + 1)\n            \n            # Initialize node_factors for start_node to an empty dict, representing an 'x' part of 1.\n            # We will later multiply by 'g' for each edge.\n            node_factors[start_node] = {} \n            q.append(start_node)\n            \n            # Keep track of visited nodes in the current component\n            component_visited = [False] * (n + 1)\n            component_visited[start_node] = True\n\n            q_bfs_nodes = deque([start_node]) # Queue for standard BFS traversal\n            \n            while q_bfs_nodes:\n                u = q_bfs_nodes.popleft()\n\n                for v, g_uv, l_uv in adj[u]:\n                    if not component_visited[v]:\n                        component_visited[v] = True\n                        q_bfs_nodes.append(v)\n                        \n                        # If node_factors[u] is set, we can derive node_factors[v]\n                        # P_uv = l_uv / g_uv\n                        # x_u * x_v = P_uv / (product of common factors of g_uv and x_u, x_v)\n                        # No, it's simpler: x_u * x_v = P_uv, where x_u = a_u/g_uv, x_v = a_v/g_uv\n                        # And GCD(x_u, x_v) = 1.\n                        \n                        # To find x_v, we need x_u.\n                        # The problem is we don't know the final values yet, only factors.\n                        # This means we need to propagate factor information.\n\n            # The above BFS only finds component. Let's restart the propagation logic.\n            # We need to find the specific prime factorization for each node.\n            # We can use `node_factors[u]` to store the required prime factorization of `a_u`.\n            # For each edge (u, v, g, l):\n            # 1. `g` must divide `a_u` and `a_v`.\n            # 2. `l` must be a multiple of `a_u` and `a_v`.\n            # 3. `a_u * a_v = g * l`.\n            # Let `P = g * l`.\n            # For each prime `p`, `v_p(a_u) + v_p(a_v) = v_p(P)`.\n            # Also, `min(v_p(a_u), v_p(a_v)) = v_p(g)`.\n            # So, `max(v_p(a_u), v_p(a_v)) = v_p(l)`.\n\n            # This system of equations is what we need to solve.\n            # We can iterate through all primes. For each prime `p`:\n            # For each edge (u, v, g, l):\n            #   Let `gp = v_p(g)` and `lp = v_p(l)`.\n            #   We need `v_p(a_u) + v_p(a_v) = gp + lp`\n            #   And `min(v_p(a_u), v_p(a_v)) = gp`\n            # This implies `max(v_p(a_u), v_p(a_v)) = lp`.\n            # So, for each prime `p`, we need to assign `v_p(a_u)` and `v_p(a_v)` such that:\n            #   `v_p(a_u) >= gp`\n            #   `v_p(a_v) >= gp`\n            #   `v_p(a_u) + v_p(a_v) = gp + lp`\n            #   `max(v_p(a_u), v_p(a_v)) = lp`\n            # This means one of them must be `gp` and the other must be `lp`.\n            # (Unless `gp == lp`, in which case both must be `gp`).\n            # Specifically, if `gp == lp`, then `v_p(a_u) = gp` and `v_p(a_v) = gp`.\n            # If `gp < lp`, then one of `v_p(a_u), v_p(a_v)` is `gp` and the other is `lp`.\n\n            # So, for each prime `p`:\n            #   Initialize `v_p_a[node]` to -1 (unknown) for all nodes in the component.\n            #   Pick an arbitrary node `u` in the component. Set `v_p_a[u] = gp_first_edge` or `lp_first_edge`.\n            #   Then propagate using BFS.\n\n            # This is a bit complex. Let's use the simpler `a_u = g * x` and `a_v = g * y` with `x*y = l/g` and `GCD(x,y)=1`.\n            # We need to find `x_i` for each node `i` such that `a_i = x_i`.\n            # Then for each edge (u,v,g,l), it must be `GCD(a_u, a_v) = g` and `LCM(a_u, a_v) = l`.\n\n            # Let's try to assign values directly using BFS/DFS.\n            # `values[i]` stores the current candidate value for `a_i`.\n            # Once `values[u]` is determined, for each neighbor `v` via (u,v,g,l):\n            # We know `a_u * a_v = g * l`. So `a_v = (g * l) // a_u`.\n            # We can calculate a candidate `a_v_cand = (g * l) // values[u]`.\n            # Then we check if `a_v_cand` is valid:\n            # 1. `a_v_cand` must be an integer (already guaranteed if `(g*l)` is divisible by `values[u]`).\n            # 2. `GCD(values[u], a_v_cand)` must be `g`.\n            # 3. `LCM(values[u], a_v_cand)` must be `l`.\n            # 4. `1 <= a_v_cand <= 10^6`.\n\n            # If `values[v]` is 0 (unassigned), assign `a_v_cand` to `values[v]` and add `v` to queue.\n            # If `values[v]` is non-zero, check if `values[v] == a_v_cand`. If not, conflict -> NO solution.\n\n            # Iterate through all nodes to handle disconnected components\n            for i in range(1, n + 1):\n                if values[i] == 0: # Node 'i' is not yet part of any processed component\n                    \n                    # For a new component, we need a starting value.\n                    # Pick node 'i'. If it has no edges, its value can be 1.\n                    if not adj[i]:\n                        values[i] = 1\n                        continue\n\n                    # If it has edges, we need to pick a value for 'i' that satisfies one of its edges.\n                    # For an edge (i, v, g, l), we know a_i * a_v = g * l.\n                    # Also, g divides a_i and a_v.\n                    # We can try to set a_i = g for some edge (i, v, g, l).\n                    # This implies a_v = l.\n                    # This is just one possibility. A better way is to iterate through all factors of l/g.\n                    \n                    # Instead of guessing a value for a_i, let's use the prime factorization approach.\n                    # For each prime `p` and for each node `u`, we need to determine `v_p(a_u)`.\n                    # Let `v_p_val[u]` store `v_p(a_u)`. Initialize to -1 (unknown).\n                    # `v_p_val_lower_bound[u]` and `v_p_val_upper_bound[u]` can also be used.\n                    \n                    # This is a 2-SAT like problem for each prime factor.\n                    # For each edge (u, v, g, l) and prime p:\n                    # Let `gp = v_p(g)` and `lp = v_p(l)`.\n                    # We know `v_p(a_u) >= gp`, `v_p(a_v) >= gp`.\n                    # And `v_p(a_u) + v_p(a_v) = gp + lp`.\n                    # And `max(v_p(a_u), v_p(a_v)) = lp`.\n                    # This implies `min(v_p(a_u), v_p(a_v)) = gp`.\n                    # So, if `gp == lp`, then `v_p(a_u) = gp` and `v_p(a_v) = gp`.\n                    # If `gp < lp`, then one of `v_p(a_u), v_p(a_v)` must be `gp` and the other `lp`.\n                    # We can model this as: for each edge, for each prime p,\n                    # either `v_p(a_u) = gp` AND `v_p(a_v) = lp`\n                    # OR `v_p(a_u) = lp` AND `v_p(a_v) = gp`.\n                    # This is exactly a 2-SAT problem for each prime factor.\n                    # For each node `u` and prime `p`, let `X_u_p` be a boolean variable.\n                    # `X_u_p = True` if `v_p(a_u) = lp` (for some edge, relative to that edge's `lp`).\n                    # `X_u_p = False` if `v_p(a_u) = gp`.\n                    # This is tricky because `gp` and `lp` are specific to an edge.\n                    # The `v_p(a_u)` must be consistent across all edges incident to `u`.\n\n                    # A simpler approach:\n                    # For each node `u`, `a_u` must be a multiple of `g` for every incident edge (u,v,g,l).\n                    # So `a_u` must be a multiple of `LCM(g_1, g_2, ...)` for all `g` on incident edges.\n                    # Also, `a_u` must divide `l` for every incident edge.\n                    # So `a_u` must divide `GCD(l_1, l_2, ...)` for all `l` on incident edges.\n                    # This gives us a lower bound `L_u` and an upper bound `U_u` for `a_u`.\n                    # `L_u = LCM(all g on edges incident to u)`\n                    # `U_u = GCD(all l on edges incident to u)`\n                    # If `L_u > U_u` or `U_u % L_u != 0`, then NO.\n                    # If `L_u == U_u`, then `a_u` is fixed.\n                    # Otherwise, `a_u` can be `L_u * k` where `k` is a factor of `U_u / L_u`.\n\n                    # Let's compute `L_u` and `U_u` for all nodes.\n                    node_lcm_g = [1] * (n + 1) # Stores LCM of all g's for incident edges\n                    node_gcd_l = [0] * (n + 1) # Stores GCD of all l's for incident edges\n\n                    def my_lcm(a, b):\n                        if a == 0 or b == 0: return 0\n                        return (a * b) // math.gcd(a, b)\n\n                    for u in range(1, n + 1):\n                        if not adj[u]: # Isolated node, value can be 1\n                            values[u] = 1\n                            continue\n\n                        # Initialize node_gcd_l with the first l, then take GCD with others\n                        node_gcd_l[u] = adj[u][0][2] \n                        \n                        for v, g_uv, l_uv in adj[u]:\n                            node_lcm_g[u] = my_lcm(node_lcm_g[u], g_uv)\n                            node_gcd_l[u] = math.gcd(node_gcd_l[u], l_uv)\n                            \n                            # Check bounds early\n                            if node_lcm_g[u] > max_val_limit or node_gcd_l[u] == 0: # GCD can become 0 if one of l_uv is 0, but l_uv >= 1\n                                sys.stdout.write(\"NO\\n\")\n                                return\n\n                    for u in range(1, n + 1):\n                        if values[u] != 0: continue # Already handled isolated node\n                        \n                        if node_lcm_g[u] > node_gcd_l[u] or node_gcd_l[u] % node_lcm_g[u] != 0:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        # Now we know a_u must be of the form node_lcm_g[u] * k, where k divides node_gcd_l[u] / node_lcm_g[u].\n                        # The simplest choice for k is 1, so a_u = node_lcm_g[u].\n                        # This forms the basis of our BFS.\n                        # We will try to assign a_u = node_lcm_g[u] for the first unassigned node in a component.\n                        # This is a valid choice that satisfies the `g` and `l` divisibility constraints for `u`.\n                        # Then propagate this choice.\n\n                        q = deque()\n                        \n                        # If values[u] is not 0, it means it's an isolated node handled above.\n                        # If node_lcm_g[u] == 0, it means the node has no edges (handled above).\n                        # If node_lcm_g[u] is 1, it means all g's are 1.\n                        \n                        # Initialize for this component\n                        values[u] = node_lcm_g[u]\n                        if values[u] > max_val_limit or values[u] == 0: # 0 indicates problem with LCM calc or g=0\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        q.append(u)\n\n                        while q:\n                            curr_u = q.popleft()\n\n                            for curr_v, g_uv, l_uv in adj[curr_u]:\n                                # If curr_u's value is fixed, try to fix curr_v's value\n                                if values[curr_u] != 0:\n                                    \n                                    # Check consistency for curr_u itself\n                                    if values[curr_u] % g_uv != 0 or l_uv % values[curr_u] != 0:\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n\n                                    # Calculate candidate value for curr_v\n                                    # a_v_cand = (g_uv * l_uv) // values[curr_u]\n                                    # This is based on a_u * a_v = g * l\n                                    # But we must ensure g_uv * l_uv is divisible by values[curr_u].\n                                    # This is guaranteed if l_uv is divisible by values[curr_u], as checked above.\n                                    \n                                    # Check for potential overflow before multiplication\n                                    if g_uv > max_val_limit or l_uv > max_val_limit: # Should not happen based on constraints\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n                                    \n                                    if values[curr_u] == 0: # Should not happen if values[curr_u] is fixed\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n\n                                    a_v_cand = (g_uv // values[curr_u]) * l_uv if l_uv % values[curr_u] != 0 else (g_uv * l_uv) // values[curr_u]\n                                    \n                                    # The correct way to calculate a_v_cand:\n                                    # Let a_u = values[curr_u].\n                                    # We need a_v such that GCD(a_u, a_v) = g_uv and LCM(a_u, a_v) = l_uv.\n                                    # From a_u * a_v = g_uv * l_uv, we get a_v = (g_uv * l_uv) // a_u.\n                                    # We need to check if this a_v satisfies GCD and LCM conditions.\n                                    \n                                    # To avoid overflow with g_uv * l_uv, we can divide first:\n                                    # a_v = (g_uv // math.gcd(a_u, g_uv)) * (l_uv // (a_u // math.gcd(a_u, g_uv)))\n                                    # This is complex. The original (g*l)/a_u is fine if a_u divides (g*l).\n                                    # Since a_u must be a multiple of g_uv, let a_u = k * g_uv.\n                                    # Then a_v = l_uv / k.\n                                    # This requires k = a_u / g_uv.\n                                    # So a_v = l_uv / (a_u / g_uv) = (l_uv * g_uv) / a_u.\n                                    # This is the standard formula.\n                                    \n                                    # Check for overflow before multiplication\n                                    # Max value of g_uv * l_uv is 10^6 * 10^6 = 10^12, which fits in Python int.\n                                    # Max value of a_v_cand is 10^6.\n                                    # If values[curr_u] is 1, a_v_cand can be 10^12.\n                                    # So we must check intermediate results.\n                                    \n                                    # The issue is that values[curr_u] could be large, leading to (g*l)/values[curr_u] being small.\n                                    # Or values[curr_u] could be small, leading to (g*l)/values[curr_u] being large.\n                                    \n                                    # The `a_u * a_v = g * l` property is only true if `a_u` and `a_v` are the actual values.\n                                    # We must ensure `g` divides `a_u` and `a_v`, and `a_u`, `a_v` divide `l`.\n                                    # Let `temp_a_v = (g_uv * l_uv) // values[curr_u]`.\n                                    # We need to check if `(g_uv * l_uv) % values[curr_u] == 0`.\n                                    # This is guaranteed by `values[curr_u] % g_uv == 0` and `l_uv % values[curr_u] == 0`\n                                    # if we use `a_u = g * x` and `a_v = g * y` where `x*y = l/g`.\n                                    # From `l_uv % values[curr_u] == 0`, it means `values[curr_u]` is a factor of `l_uv`.\n                                    # So `(g_uv * l_uv) / values[curr_u]` will always be an integer.\n\n                                    a_v_cand = (g_uv * l_uv) // values[curr_u]\n                                    \n                                    if not (1 <= a_v_cand <= max_val_limit):\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n\n                                    if values[curr_v] == 0: # curr_v is unassigned\n                                        values[curr_v] = a_v_cand\n                                        q.append(curr_v)\n                                    elif values[curr_v] != a_v_cand: # Conflict\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n                                    \n                                    # If values[curr_v] == a_v_cand, it's consistent. No action needed.\n\n            # After BFS/DFS for all components, verify all edges\n            for u, v, g_uv, l_uv in edges_data:\n                if values[u] == 0 or values[v] == 0: # Should not happen if all components are processed\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                # Check GCD and LCM conditions\n                actual_gcd = math.gcd(values[u], values[v])\n                actual_lcm = (values[u] * values[v]) // actual_gcd # Use this to avoid overflow with my_lcm if values[u]*values[v] is too big\n\n                if actual_gcd != g_uv or actual_lcm != l_uv:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # All checks passed\n            sys.stdout.write(\"YES\\n\")\n            sys.stdout.write(\" \".join(map(str, values[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Should not happen based on constraints (n >= 1)\n        sys.stdout.write(\"YES\\n\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)] # 1-indexed for lawns\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    # Initialize values array, 0 means unassigned\n    values = [0] * (n + 1)\n    \n    # Store potential factors for each node\n    # Each node can have multiple constraints on its value from different edges.\n    # We use a list of (prime_factor, exponent) tuples for each node,\n    # representing the required prime factorization of its value.\n    # Example: {2: 3, 3: 1} for 2^3 * 3^1 = 24\n    # We use a dictionary for easier updates.\n    node_factors = [{} for _ in range(n + 1)]\n\n    # Check initial conditions and derive prime factors for P = l/g\n    for u, v, g, l in edges_data:\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n        \n        # All a_i must be multiples of g.\n        # This implies a_u and a_v must be multiples of g.\n        # This is implicitly handled by the factor propagation.\n        # If a node's value is determined, it must be a multiple of g for all incident edges.\n        # We will check this later.\n\n    # Precompute primes up to sqrt(10^6) = 1000\n    # For factorization, we need primes up to max_val (10^6) or sqrt(max_val) if using trial division.\n    # Since P can be up to 10^6, we need primes up to 10^6.\n    # However, we only need to factorize P. If P has a prime factor > sqrt(P), it can have at most one such factor.\n    # So, primes up to sqrt(10^6) = 1000 are sufficient for trial division.\n    \n    max_val_limit = 10**6\n    sieve_limit = int(math.sqrt(max_val_limit)) + 1 # Max possible P is 10^6\n    is_prime = [True] * (sieve_limit + 1)\n    primes = []\n    for p in range(2, sieve_limit + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p * p, sieve_limit + 1, p):\n                is_prime[multiple] = False\n\n    # Function to get prime factorization of a number\n    # Returns a dict {prime: exponent}\n    def get_prime_factorization(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num:\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1: # Remaining factor is a prime\n            factors[temp_num] = 1\n        return factors\n\n    # Main BFS/DFS loop to assign values\n    for start_node in range(1, n + 1):\n        if values[start_node] == 0: # If node not yet processed\n            \n            # Start a BFS from this node\n            q = deque()\n            \n            # For the first node in a component, we can arbitrarily assign 1 to its 'x' part\n            # Or, more generally, we can say its value is 1 * its 'g' part from an arbitrary edge.\n            # Let's try to determine its full value based on its prime factors.\n            \n            # Initialize factors for start_node.\n            # An arbitrary choice for an unvisited component:\n            # For the first node 'u' encountered, we can try to set its value to 'g'\n            # (which means its x-part is 1) for one of its incident edges.\n            # Or we can just set its factors to be empty (meaning its value is 1, if no other constraints apply).\n            # The current approach is to try to derive factors for all node_factors[u] based on edges.\n            # If node_factors[u] remains empty, it means its value could be 1.\n            \n            # Let's use a queue for nodes whose 'node_factors' have been updated and need to propagate.\n            # We will put nodes into the queue if their factors are *fixed* or *partially fixed*\n            # and need to be used to constrain neighbors.\n            \n            # A more robust approach:\n            # For each connected component, pick an arbitrary node `u`.\n            # Assign `node_factors[u]` to be empty (representing `a_u = 1` initially, before 'g' constraints).\n            # Then propagate.\n            \n            # Reset values for the current component's processing\n            component_values = [0] * (n + 1)\n            \n            # Initialize node_factors for start_node to an empty dict, representing an 'x' part of 1.\n            # We will later multiply by 'g' for each edge.\n            node_factors[start_node] = {} \n            q.append(start_node)\n            \n            # Keep track of visited nodes in the current component\n            component_visited = [False] * (n + 1)\n            component_visited[start_node] = True\n\n            q_bfs_nodes = deque([start_node]) # Queue for standard BFS traversal\n            \n            while q_bfs_nodes:\n                u = q_bfs_nodes.popleft()\n\n                for v, g_uv, l_uv in adj[u]:\n                    if not component_visited[v]:\n                        component_visited[v] = True\n                        q_bfs_nodes.append(v)\n                        \n                        # If node_factors[u] is set, we can derive node_factors[v]\n                        # P_uv = l_uv / g_uv\n                        # x_u * x_v = P_uv / (product of common factors of g_uv and x_u, x_v)\n                        # No, it's simpler: x_u * x_v = P_uv, where x_u = a_u/g_uv, x_v = a_v/g_uv\n                        # And GCD(x_u, x_v) = 1.\n                        \n                        # To find x_v, we need x_u.\n                        # The problem is we don't know the final values yet, only factors.\n                        # This means we need to propagate factor information.\n\n            # The above BFS only finds component. Let's restart the propagation logic.\n            # We need to find the specific prime factorization for each node.\n            # We can use `node_factors[u]` to store the required prime factorization of `a_u`.\n            # For each edge (u, v, g, l):\n            # 1. `g` must divide `a_u` and `a_v`.\n            # 2. `l` must be a multiple of `a_u` and `a_v`.\n            # 3. `a_u * a_v = g * l`.\n            # Let `P = g * l`.\n            # For each prime `p`, `v_p(a_u) + v_p(a_v) = v_p(P)`.\n            # Also, `min(v_p(a_u), v_p(a_v)) = v_p(g)`.\n            # So, `max(v_p(a_u), v_p(a_v)) = v_p(l)`.\n\n            # This system of equations is what we need to solve.\n            # We can iterate through all primes. For each prime `p`:\n            # For each edge (u, v, g, l):\n            #   Let `gp = v_p(g)` and `lp = v_p(l)`.\n            #   We need `v_p(a_u) + v_p(a_v) = gp + lp`\n            #   And `min(v_p(a_u), v_p(a_v)) = gp`\n            # This implies `max(v_p(a_u), v_p(a_v)) = lp`.\n            # So, for each prime `p`, we need to assign `v_p(a_u)` and `v_p(a_v)` such that:\n            #   `v_p(a_u) >= gp`\n            #   `v_p(a_v) >= gp`\n            #   `v_p(a_u) + v_p(a_v) = gp + lp`\n            #   `max(v_p(a_u), v_p(a_v)) = lp`\n            # This means one of them must be `gp` and the other must be `lp`.\n            # (Unless `gp == lp`, in which case both must be `gp`).\n            # Specifically, if `gp == lp`, then `v_p(a_u) = gp` and `v_p(a_v) = gp`.\n            # If `gp < lp`, then one of `v_p(a_u), v_p(a_v)` is `gp` and the other is `lp`.\n\n            # So, for each prime `p`:\n            #   Initialize `v_p_a[node]` to -1 (unknown) for all nodes in the component.\n            #   Pick an arbitrary node `u` in the component. Set `v_p_a[u] = gp_first_edge` or `lp_first_edge`.\n            #   Then propagate using BFS.\n\n            # This is a bit complex. Let's use the simpler `a_u = g * x` and `a_v = g * y` with `x*y = l/g` and `GCD(x,y)=1`.\n            # We need to find `x_i` for each node `i` such that `a_i = x_i`.\n            # Then for each edge (u,v,g,l), it must be `GCD(a_u, a_v) = g` and `LCM(a_u, a_v) = l`.\n\n            # Let's try to assign values directly using BFS/DFS.\n            # `values[i]` stores the current candidate value for `a_i`.\n            # Once `values[u]` is determined, for each neighbor `v` via (u,v,g,l):\n            # We know `a_u * a_v = g * l`. So `a_v = (g * l) // a_u`.\n            # We can calculate a candidate `a_v_cand = (g * l) // values[u]`.\n            # Then we check if `a_v_cand` is valid:\n            # 1. `a_v_cand` must be an integer (already guaranteed if `(g*l)` is divisible by `values[u]`).\n            # 2. `GCD(values[u], a_v_cand)` must be `g`.\n            # 3. `LCM(values[u], a_v_cand)` must be `l`.\n            # 4. `1 <= a_v_cand <= 10^6`.\n\n            # If `values[v]` is 0 (unassigned), assign `a_v_cand` to `values[v]` and add `v` to queue.\n            # If `values[v]` is non-zero, check if `values[v] == a_v_cand`. If not, conflict -> NO solution.\n\n            # Iterate through all nodes to handle disconnected components\n            for i in range(1, n + 1):\n                if values[i] == 0: # Node 'i' is not yet part of any processed component\n                    \n                    # For a new component, we need a starting value.\n                    # Pick node 'i'. If it has no edges, its value can be 1.\n                    if not adj[i]:\n                        values[i] = 1\n                        continue\n\n                    # If it has edges, we need to pick a value for 'i' that satisfies one of its edges.\n                    # For an edge (i, v, g, l), we know a_i * a_v = g * l.\n                    # Also, g divides a_i and a_v.\n                    # We can try to set a_i = g for some edge (i, v, g, l).\n                    # This implies a_v = l.\n                    # This is just one possibility. A better way is to iterate through all factors of l/g.\n                    \n                    # Instead of guessing a value for a_i, let's use the prime factorization approach.\n                    # For each prime `p` and for each node `u`, we need to determine `v_p(a_u)`.\n                    # Let `v_p_val[u]` store `v_p(a_u)`. Initialize to -1 (unknown).\n                    # `v_p_val_lower_bound[u]` and `v_p_val_upper_bound[u]` can also be used.\n                    \n                    # This is a 2-SAT like problem for each prime factor.\n                    # For each edge (u, v, g, l) and prime p:\n                    # Let `gp = v_p(g)` and `lp = v_p(l)`.\n                    # We know `v_p(a_u) >= gp`, `v_p(a_v) >= gp`.\n                    # And `v_p(a_u) + v_p(a_v) = gp + lp`.\n                    # And `max(v_p(a_u), v_p(a_v)) = lp`.\n                    # This implies `min(v_p(a_u), v_p(a_v)) = gp`.\n                    # So, if `gp == lp`, then `v_p(a_u) = gp` and `v_p(a_v) = gp`.\n                    # If `gp < lp`, then one of `v_p(a_u), v_p(a_v)` must be `gp` and the other `lp`.\n                    # We can model this as: for each edge, for each prime p,\n                    # either `v_p(a_u) = gp` AND `v_p(a_v) = lp`\n                    # OR `v_p(a_u) = lp` AND `v_p(a_v) = gp`.\n                    # This is exactly a 2-SAT problem for each prime factor.\n                    # For each node `u` and prime `p`, let `X_u_p` be a boolean variable.\n                    # `X_u_p = True` if `v_p(a_u) = lp` (for some edge, relative to that edge's `lp`).\n                    # `X_u_p = False` if `v_p(a_u) = gp`.\n                    # This is tricky because `gp` and `lp` are specific to an edge.\n                    # The `v_p(a_u)` must be consistent across all edges incident to `u`.\n\n                    # A simpler approach:\n                    # For each node `u`, `a_u` must be a multiple of `g` for every incident edge (u,v,g,l).\n                    # So `a_u` must be a multiple of `LCM(g_1, g_2, ...)` for all `g` on incident edges.\n                    # Also, `a_u` must divide `l` for every incident edge.\n                    # So `a_u` must divide `GCD(l_1, l_2, ...)` for all `l` on incident edges.\n                    # This gives us a lower bound `L_u` and an upper bound `U_u` for `a_u`.\n                    # `L_u = LCM(all g on edges incident to u)`\n                    # `U_u = GCD(all l on edges incident to u)`\n                    # If `L_u > U_u` or `U_u % L_u != 0`, then NO.\n                    # If `L_u == U_u`, then `a_u` is fixed.\n                    # Otherwise, `a_u` can be `L_u * k` where `k` is a factor of `U_u / L_u`.\n\n                    # Let's compute `L_u` and `U_u` for all nodes.\n                    node_lcm_g = [1] * (n + 1) # Stores LCM of all g's for incident edges\n                    node_gcd_l = [0] * (n + 1) # Stores GCD of all l's for incident edges\n\n                    def my_lcm(a, b):\n                        if a == 0 or b == 0: return 0\n                        return (a * b) // math.gcd(a, b)\n\n                    for u in range(1, n + 1):\n                        if not adj[u]: # Isolated node, value can be 1\n                            values[u] = 1\n                            continue\n\n                        # Initialize node_gcd_l with the first l, then take GCD with others\n                        node_gcd_l[u] = adj[u][0][2] \n                        \n                        for v, g_uv, l_uv in adj[u]:\n                            node_lcm_g[u] = my_lcm(node_lcm_g[u], g_uv)\n                            node_gcd_l[u] = math.gcd(node_gcd_l[u], l_uv)\n                            \n                            # Check bounds early\n                            if node_lcm_g[u] > max_val_limit or node_gcd_l[u] == 0: # GCD can become 0 if one of l_uv is 0, but l_uv >= 1\n                                sys.stdout.write(\"NO\\n\")\n                                return\n\n                    for u in range(1, n + 1):\n                        if values[u] != 0: continue # Already handled isolated node\n                        \n                        if node_lcm_g[u] > node_gcd_l[u] or node_gcd_l[u] % node_lcm_g[u] != 0:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        # Now we know a_u must be of the form node_lcm_g[u] * k, where k divides node_gcd_l[u] / node_lcm_g[u].\n                        # The simplest choice for k is 1, so a_u = node_lcm_g[u].\n                        # This forms the basis of our BFS.\n                        # We will try to assign a_u = node_lcm_g[u] for the first unassigned node in a component.\n                        # This is a valid choice that satisfies the `g` and `l` divisibility constraints for `u`.\n                        # Then propagate this choice.\n\n                        q = deque()\n                        \n                        # If values[u] is not 0, it means it's an isolated node handled above.\n                        # If node_lcm_g[u] == 0, it means the node has no edges (handled above).\n                        # If node_lcm_g[u] is 1, it means all g's are 1.\n                        \n                        # Initialize for this component\n                        values[u] = node_lcm_g[u]\n                        if values[u] > max_val_limit or values[u] == 0: # 0 indicates problem with LCM calc or g=0\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        q.append(u)\n\n                        while q:\n                            curr_u = q.popleft()\n\n                            for curr_v, g_uv, l_uv in adj[curr_u]:\n                                # If curr_u's value is fixed, try to fix curr_v's value\n                                if values[curr_u] != 0:\n                                    \n                                    # Check consistency for curr_u itself\n                                    if values[curr_u] % g_uv != 0 or l_uv % values[curr_u] != 0:\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n\n                                    # Calculate candidate value for curr_v\n                                    # a_v_cand = (g_uv * l_uv) // values[curr_u]\n                                    # This is based on a_u * a_v = g * l\n                                    # But we must ensure g_uv * l_uv is divisible by values[curr_u].\n                                    # This is guaranteed if l_uv is divisible by values[curr_u], as checked above.\n                                    \n                                    # Check for potential overflow before multiplication\n                                    if g_uv > max_val_limit or l_uv > max_val_limit: # Should not happen based on constraints\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n                                    \n                                    if values[curr_u] == 0: # Should not happen if values[curr_u] is fixed\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n\n                                    a_v_cand = (g_uv // values[curr_u]) * l_uv if l_uv % values[curr_u] != 0 else (g_uv * l_uv) // values[curr_u]\n                                    \n                                    # The correct way to calculate a_v_cand:\n                                    # Let a_u = values[curr_u].\n                                    # We need a_v such that GCD(a_u, a_v) = g_uv and LCM(a_u, a_v) = l_uv.\n                                    # From a_u * a_v = g_uv * l_uv, we get a_v = (g_uv * l_uv) // a_u.\n                                    # We need to check if this a_v satisfies GCD and LCM conditions.\n                                    \n                                    # To avoid overflow with g_uv * l_uv, we can divide first:\n                                    # a_v = (g_uv // math.gcd(a_u, g_uv)) * (l_uv // (a_u // math.gcd(a_u, g_uv)))\n                                    # This is complex. The original (g*l)/a_u is fine if a_u divides (g*l).\n                                    # Since a_u must be a multiple of g_uv, let a_u = k * g_uv.\n                                    # Then a_v = l_uv / k.\n                                    # This requires k = a_u / g_uv.\n                                    # So a_v = l_uv / (a_u / g_uv) = (l_uv * g_uv) / a_u.\n                                    # This is the standard formula.\n                                    \n                                    # Check for overflow before multiplication\n                                    # Max value of g_uv * l_uv is 10^6 * 10^6 = 10^12, which fits in Python int.\n                                    # Max value of a_v_cand is 10^6.\n                                    # If values[curr_u] is 1, a_v_cand can be 10^12.\n                                    # So we must check intermediate results.\n                                    \n                                    # The issue is that values[curr_u] could be large, leading to (g*l)/values[curr_u] being small.\n                                    # Or values[curr_u] could be small, leading to (g*l)/values[curr_u] being large.\n                                    \n                                    # The `a_u * a_v = g * l` property is only true if `a_u` and `a_v` are the actual values.\n                                    # We must ensure `g` divides `a_u` and `a_v`, and `a_u`, `a_v` divide `l`.\n                                    # Let `temp_a_v = (g_uv * l_uv) // values[curr_u]`.\n                                    # We need to check if `(g_uv * l_uv) % values[curr_u] == 0`.\n                                    # This is guaranteed by `values[curr_u] % g_uv == 0` and `l_uv % values[curr_u] == 0`\n                                    # if we use `a_u = g * x` and `a_v = g * y` where `x*y = l/g`.\n                                    # From `l_uv % values[curr_u] == 0`, it means `values[curr_u]` is a factor of `l_uv`.\n                                    # So `(g_uv * l_uv) / values[curr_u]` will always be an integer.\n\n                                    a_v_cand = (g_uv * l_uv) // values[curr_u]\n                                    \n                                    if not (1 <= a_v_cand <= max_val_limit):\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n\n                                    if values[curr_v] == 0: # curr_v is unassigned\n                                        values[curr_v] = a_v_cand\n                                        q.append(curr_v)\n                                    elif values[curr_v] != a_v_cand: # Conflict\n                                        sys.stdout.write(\"NO\\n\")\n                                        return\n                                    \n                                    # If values[curr_v] == a_v_cand, it's consistent. No action needed.\n\n            # After BFS/DFS for all components, verify all edges\n            for u, v, g_uv, l_uv in edges_data:\n                if values[u] == 0 or values[v] == 0: # Should not happen if all components are processed\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                # Check GCD and LCM conditions\n                actual_gcd = math.gcd(values[u], values[v])\n                actual_lcm = (values[u] * values[v]) // actual_gcd # Use this to avoid overflow with my_lcm if values[u]*values[v] is too big\n\n                if actual_gcd != g_uv or actual_lcm != l_uv:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # All checks passed\n            sys.stdout.write(\"YES\\n\")\n            sys.stdout.write(\" \".join(map(str, values[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 6368,
        "thoughts_token_count": 709
    }
}