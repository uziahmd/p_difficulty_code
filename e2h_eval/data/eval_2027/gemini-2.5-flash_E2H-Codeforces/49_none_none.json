{
    "start": 1758293722.087891,
    "end": 1758293753.0491855,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    \n    def get_prime_factors(num):\n        factors = {}\n        d = 2\n        temp = num\n        while d * d <= temp:\n            while temp % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] = factors.get(temp, 0) + 1\n        return factors\n\n    all_primes = set()\n    for _, _, g, l in edges:\n        for p in get_prime_factors(g):\n            all_primes.add(p)\n        for p in get_prime_factors(l):\n            all_primes.add(p)\n\n    def check_valid(current_ans):\n        for u, v, g, l in edges:\n            if current_ans[u] == 0 or current_ans[v] == 0:\n                continue\n            \n            # Check GCD\n            if current_ans[u] % g != 0 or current_ans[v] % g != 0:\n                return False\n            \n            if current_ans[u] * current_ans[v] != g * l:\n                return False\n            \n            # Re-calculate GCD and LCM to be sure\n            actual_gcd = 0\n            if current_ans[u] == 0 or current_ans[v] == 0: # Should not happen if current_ans[u/v] are non-zero\n                pass\n            else:\n                a, b = current_ans[u], current_ans[v]\n                while b:\n                    a, b = b, a % b\n                actual_gcd = a\n            \n            if actual_gcd != g:\n                return False\n            \n            actual_lcm = (current_ans[u] * current_ans[v]) // actual_gcd\n            if actual_lcm != l:\n                return False\n        return True\n\n    def dfs(u, p):\n        nonlocal ans\n        \n        for v, g, l in adj[u]:\n            if ans[v] != 0:\n                continue\n\n            if ans[u] == 0: # Should not happen if u is the starting node with a value\n                continue\n            \n            # We know ans[u], g, l. We need to find ans[v].\n            # ans[u] * ans[v] = g * l\n            # ans[v] = (g * l) / ans[u]\n            \n            # Check divisibility first\n            if (g * l) % ans[u] != 0:\n                return False # Impossible\n            \n            potential_v = (g * l) // ans[u]\n            \n            # Check GCD(ans[u], potential_v) == g\n            a, b = ans[u], potential_v\n            while b:\n                a, b = b, a % b\n            actual_gcd = a\n\n            if actual_gcd != g:\n                return False # Impossible\n            \n            ans[v] = potential_v\n            if not dfs(v, u):\n                return False\n        return True\n\n    # Iterate through all possible starting values for node 1\n    # A starting value must be a divisor of some LCM\n    \n    # Collect all numbers that are GCDs or LCMs\n    potential_start_values = set()\n    for _, _, g, l in edges:\n        divisors_g = set()\n        for i in range(1, int(g**0.5) + 1):\n            if g % i == 0:\n                divisors_g.add(i)\n                divisors_g.add(g // i)\n        \n        divisors_l = set()\n        for i in range(1, int(l**0.5) + 1):\n            if l % i == 0:\n                divisors_l.add(i)\n                divisors_l.add(l // i)\n        \n        potential_start_values.update(divisors_g)\n        potential_start_values.update(divisors_l)\n\n    # If there are no edges, any 1 is valid\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    # To optimize, we can try to find a value for node 1 that is a divisor of some LCM or a multiple of some GCD.\n    # A better approach: for each prime factor p, determine its exponent for each ans[i].\n    \n    # For each prime p that appears in any G or L\n    # For each node i, we need to find v_i_p such that ans[i] = product(p^v_i_p)\n    # For an edge (u, v, G, L):\n    # min(v_u_p, v_v_p) = exp_G_p\n    # max(v_u_p, v_v_p) = exp_L_p\n    \n    # This implies that {v_u_p, v_v_p} = {exp_G_p, exp_L_p}\n    # And exp_G_p <= exp_L_p\n    \n    # We can solve this for each prime independently.\n    \n    ans_prime_exponents = {} # ans_prime_exponents[node_idx][prime] = exponent\n    \n    for p in all_primes:\n        # For each prime, we have a separate graph problem\n        # Each node i needs to be assigned an exponent exp_i_p\n        # For each edge (u, v, G, L):\n        # min(exp_u_p, exp_v_p) = exp_G_p\n        # max(exp_u_p, exp_v_p) = exp_L_p\n        \n        # This implies that {exp_u_p, exp_v_p} must be {exp_G_p, exp_L_p}\n        # where exp_G_p is the exponent of p in G, and exp_L_p is the exponent of p in L.\n        \n        # If exp_G_p > exp_L_p for any edge, then it's impossible.\n        for u, v, g, l in edges:\n            exp_g_p = get_prime_factors(g).get(p, 0)\n            exp_l_p = get_prime_factors(l).get(p, 0)\n            if exp_g_p > exp_l_p:\n                sys.stdout.write(\"NO\\n\")\n                return\n\n        current_prime_exponents = [-1] * (n + 1) # -1 means unassigned\n        \n        q = [] # (node, exponent)\n        \n        # Try to assign an exponent to node 1 for this prime\n        # The possible exponents for node 1 are exp_G_p or exp_L_p from any edge connected to node 1.\n        # Or it could be something else if node 1 is isolated, but we can't determine it.\n        # If node 1 is connected to an edge (1, v, G, L), then exp_1_p must be exp_G_p or exp_L_p.\n        \n        # Find a connected component and start with one node\n        \n        visited_nodes_for_prime = [False] * (n + 1)\n        \n        for start_node in range(1, n + 1):\n            if visited_nodes_for_prime[start_node]:\n                continue\n\n            # Find an edge involving start_node\n            found_edge = False\n            for v_neighbor, g_val, l_val in adj[start_node]:\n                exp_g_p = get_prime_factors(g_val).get(p, 0)\n                exp_l_p = get_prime_factors(l_val).get(p, 0)\n                \n                # Try assigning exp_g_p to start_node\n                temp_current_prime_exponents = [-1] * (n + 1)\n                temp_q = [(start_node, exp_g_p)]\n                temp_current_prime_exponents[start_node] = exp_g_p\n                \n                possible = True\n                temp_visited = [False] * (n + 1)\n                temp_visited[start_node] = True\n                \n                head = 0\n                while head < len(temp_q):\n                    u, u_exp = temp_q[head]\n                    head += 1\n                    \n                    for v, g_val_edge, l_val_edge in adj[u]:\n                        exp_g_p_edge = get_prime_factors(g_val_edge).get(p, 0)\n                        exp_l_p_edge = get_prime_factors(l_val_edge).get(p, 0)\n                        \n                        # We know u_exp. We need to find v_exp.\n                        # {u_exp, v_exp} must be {exp_g_p_edge, exp_l_p_edge}\n                        \n                        # If u_exp is not one of these, it's impossible.\n                        if u_exp != exp_g_p_edge and u_exp != exp_l_p_edge:\n                            possible = False\n                            break\n                        \n                        v_exp = -1\n                        if u_exp == exp_g_p_edge:\n                            v_exp = exp_l_p_edge\n                        else: # u_exp == exp_l_p_edge\n                            v_exp = exp_g_p_edge\n                        \n                        if temp_current_prime_exponents[v] == -1:\n                            temp_current_prime_exponents[v] = v_exp\n                            temp_q.append((v, v_exp))\n                            temp_visited[v] = True\n                        elif temp_current_prime_exponents[v] != v_exp:\n                            possible = False\n                            break\n                    if not possible:\n                        break\n                \n                if possible:\n                    # Check consistency for all edges in this component\n                    for u_check in range(1, n + 1):\n                        if not temp_visited[u_check]:\n                            continue\n                        for v_check, g_val_check, l_val_check in adj[u_check]:\n                            if not temp_visited[v_check]:\n                                continue\n                            \n                            exp_g_p_check = get_prime_factors(g_val_check).get(p, 0)\n                            exp_l_p_check = get_prime_factors(l_val_check).get(p, 0)\n                            \n                            if min(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_g_p_check or \\\n                               max(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_l_p_check:\n                                possible = False\n                                break\n                        if not possible:\n                            break\n                \n                if possible:\n                    for i in range(1, n + 1):\n                        if temp_visited[i]:\n                            current_prime_exponents[i] = temp_current_prime_exponents[i]\n                            visited_nodes_for_prime[i] = True\n                    found_edge = True\n                    break # Found a valid assignment for this component\n                \n                # Try assigning exp_l_p to start_node\n                if exp_g_p != exp_l_p: # Only try if it's different\n                    temp_current_prime_exponents = [-1] * (n + 1)\n                    temp_q = [(start_node, exp_l_p)]\n                    temp_current_prime_exponents[start_node] = exp_l_p\n                    \n                    possible = True\n                    temp_visited = [False] * (n + 1)\n                    temp_visited[start_node] = True\n                    \n                    head = 0\n                    while head < len(temp_q):\n                        u, u_exp = temp_q[head]\n                        head += 1\n                        \n                        for v, g_val_edge, l_val_edge in adj[u]:\n                            exp_g_p_edge = get_prime_factors(g_val_edge).get(p, 0)\n                            exp_l_p_edge = get_prime_factors(l_val_edge).get(p, 0)\n                            \n                            if u_exp != exp_g_p_edge and u_exp != exp_l_p_edge:\n                                possible = False\n                                break\n                            \n                            v_exp = -1\n                            if u_exp == exp_g_p_edge:\n                                v_exp = exp_l_p_edge\n                            else:\n                                v_exp = exp_g_p_edge\n                            \n                            if temp_current_prime_exponents[v] == -1:\n                                temp_current_prime_exponents[v] = v_exp\n                                temp_q.append((v, v_exp))\n                                temp_visited[v] = True\n                            elif temp_current_prime_exponents[v] != v_exp:\n                                possible = False\n                                break\n                        if not possible:\n                            break\n                    \n                    if possible:\n                        for u_check in range(1, n + 1):\n                            if not temp_visited[u_check]:\n                                continue\n                            for v_check, g_val_check, l_val_check in adj[u_check]:\n                                if not temp_visited[v_check]:\n                                    continue\n                                \n                                exp_g_p_check = get_prime_factors(g_val_check).get(p, 0)\n                                exp_l_p_check = get_prime_factors(l_val_check).get(p, 0)\n                                \n                                if min(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_g_p_check or \\\n                                   max(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_l_p_check:\n                                    possible = False\n                                    break\n                            if not possible:\n                                break\n                    \n                    if possible:\n                        for i in range(1, n + 1):\n                            if temp_visited[i]:\n                                current_prime_exponents[i] = temp_current_prime_exponents[i]\n                                visited_nodes_for_prime[i] = True\n                        found_edge = True\n                        break # Found a valid assignment for this component\n            \n            if not found_edge: # This node is isolated in this component (no edges or not yet processed)\n                # If a node is not connected to any edge, its exponent for p can be anything. We can pick 0.\n                if not visited_nodes_for_prime[start_node]:\n                    q_isolated = [start_node]\n                    current_prime_exponents[start_node] = 0 # Default to 0 for isolated nodes\n                    visited_nodes_for_prime[start_node] = True\n                    head_isolated = 0\n                    while head_isolated < len(q_isolated):\n                        u_iso = q_isolated[head_isolated]\n                        head_isolated += 1\n                        for v_iso, _, _ in adj[u_iso]:\n                            if not visited_nodes_for_prime[v_iso]:\n                                current_prime_exponents[v_iso] = 0\n                                visited_nodes_for_prime[v_iso] = True\n                                q_isolated.append(v_iso)\n                \n        # After processing all components for prime p, check if all nodes have an exponent\n        for i in range(1, n + 1):\n            if current_prime_exponents[i] == -1:\n                # This node is part of a component that could not be assigned, or is truly isolated\n                # A truly isolated node can have any value. We default to 1 (exponent 0).\n                current_prime_exponents[i] = 0\n        \n        for i in range(1, n + 1):\n            if i not in ans_prime_exponents:\n                ans_prime_exponents[i] = {}\n            ans_prime_exponents[i][p] = current_prime_exponents[i]\n            \n    # Reconstruct the numbers\n    final_ans = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in all_primes:\n            final_ans[i] *= (p ** ans_prime_exponents[i].get(p, 0))\n\n    # Check the final answer\n    for u, v, g, l in edges:\n        a = final_ans[u]\n        b = final_ans[v]\n        \n        if a == 0 or b == 0: # Should not happen if initial values are 1\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        current_gcd = 0\n        temp_a, temp_b = a, b\n        while temp_b:\n            temp_a, temp_b = temp_b, temp_a % temp_b\n        current_gcd = temp_a\n\n        if current_gcd != g:\n            sys.stdout.write(\"NO\\n\")\n            return\n        \n        if (a * b) // current_gcd != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, final_ans[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    \n    def get_prime_factors(num):\n        factors = {}\n        d = 2\n        temp = num\n        while d * d <= temp:\n            while temp % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] = factors.get(temp, 0) + 1\n        return factors\n\n    all_primes = set()\n    for _, _, g, l in edges:\n        for p in get_prime_factors(g):\n            all_primes.add(p)\n        for p in get_prime_factors(l):\n            all_primes.add(p)\n\n    def check_valid(current_ans):\n        for u, v, g, l in edges:\n            if current_ans[u] == 0 or current_ans[v] == 0:\n                continue\n            \n            # Check GCD\n            if current_ans[u] % g != 0 or current_ans[v] % g != 0:\n                return False\n            \n            if current_ans[u] * current_ans[v] != g * l:\n                return False\n            \n            # Re-calculate GCD and LCM to be sure\n            actual_gcd = 0\n            if current_ans[u] == 0 or current_ans[v] == 0: # Should not happen if current_ans[u/v] are non-zero\n                pass\n            else:\n                a, b = current_ans[u], current_ans[v]\n                while b:\n                    a, b = b, a % b\n                actual_gcd = a\n            \n            if actual_gcd != g:\n                return False\n            \n            actual_lcm = (current_ans[u] * current_ans[v]) // actual_gcd\n            if actual_lcm != l:\n                return False\n        return True\n\n    def dfs(u, p):\n        nonlocal ans\n        \n        for v, g, l in adj[u]:\n            if ans[v] != 0:\n                continue\n\n            if ans[u] == 0: # Should not happen if u is the starting node with a value\n                continue\n            \n            # We know ans[u], g, l. We need to find ans[v].\n            # ans[u] * ans[v] = g * l\n            # ans[v] = (g * l) / ans[u]\n            \n            # Check divisibility first\n            if (g * l) % ans[u] != 0:\n                return False # Impossible\n            \n            potential_v = (g * l) // ans[u]\n            \n            # Check GCD(ans[u], potential_v) == g\n            a, b = ans[u], potential_v\n            while b:\n                a, b = b, a % b\n            actual_gcd = a\n\n            if actual_gcd != g:\n                return False # Impossible\n            \n            ans[v] = potential_v\n            if not dfs(v, u):\n                return False\n        return True\n\n    # Iterate through all possible starting values for node 1\n    # A starting value must be a divisor of some LCM\n    \n    # Collect all numbers that are GCDs or LCMs\n    potential_start_values = set()\n    for _, _, g, l in edges:\n        divisors_g = set()\n        for i in range(1, int(g**0.5) + 1):\n            if g % i == 0:\n                divisors_g.add(i)\n                divisors_g.add(g // i)\n        \n        divisors_l = set()\n        for i in range(1, int(l**0.5) + 1):\n            if l % i == 0:\n                divisors_l.add(i)\n                divisors_l.add(l // i)\n        \n        potential_start_values.update(divisors_g)\n        potential_start_values.update(divisors_l)\n\n    # If there are no edges, any 1 is valid\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    # To optimize, we can try to find a value for node 1 that is a divisor of some LCM or a multiple of some GCD.\n    # A better approach: for each prime factor p, determine its exponent for each ans[i].\n    \n    # For each prime p that appears in any G or L\n    # For each node i, we need to find v_i_p such that ans[i] = product(p^v_i_p)\n    # For an edge (u, v, G, L):\n    # min(v_u_p, v_v_p) = exp_G_p\n    # max(v_u_p, v_v_p) = exp_L_p\n    \n    # This implies that {v_u_p, v_v_p} = {exp_G_p, exp_L_p}\n    # And exp_G_p <= exp_L_p\n    \n    # We can solve this for each prime independently.\n    \n    ans_prime_exponents = {} # ans_prime_exponents[node_idx][prime] = exponent\n    \n    for p in all_primes:\n        # For each prime, we have a separate graph problem\n        # Each node i needs to be assigned an exponent exp_i_p\n        # For each edge (u, v, G, L):\n        # min(exp_u_p, exp_v_p) = exp_G_p\n        # max(exp_u_p, exp_v_p) = exp_L_p\n        \n        # This implies that {exp_u_p, exp_v_p} must be {exp_G_p, exp_L_p}\n        # where exp_G_p is the exponent of p in G, and exp_L_p is the exponent of p in L.\n        \n        # If exp_G_p > exp_L_p for any edge, then it's impossible.\n        for u, v, g, l in edges:\n            exp_g_p = get_prime_factors(g).get(p, 0)\n            exp_l_p = get_prime_factors(l).get(p, 0)\n            if exp_g_p > exp_l_p:\n                sys.stdout.write(\"NO\\n\")\n                return\n\n        current_prime_exponents = [-1] * (n + 1) # -1 means unassigned\n        \n        q = [] # (node, exponent)\n        \n        # Try to assign an exponent to node 1 for this prime\n        # The possible exponents for node 1 are exp_G_p or exp_L_p from any edge connected to node 1.\n        # Or it could be something else if node 1 is isolated, but we can't determine it.\n        # If node 1 is connected to an edge (1, v, G, L), then exp_1_p must be exp_G_p or exp_L_p.\n        \n        # Find a connected component and start with one node\n        \n        visited_nodes_for_prime = [False] * (n + 1)\n        \n        for start_node in range(1, n + 1):\n            if visited_nodes_for_prime[start_node]:\n                continue\n\n            # Find an edge involving start_node\n            found_edge = False\n            for v_neighbor, g_val, l_val in adj[start_node]:\n                exp_g_p = get_prime_factors(g_val).get(p, 0)\n                exp_l_p = get_prime_factors(l_val).get(p, 0)\n                \n                # Try assigning exp_g_p to start_node\n                temp_current_prime_exponents = [-1] * (n + 1)\n                temp_q = [(start_node, exp_g_p)]\n                temp_current_prime_exponents[start_node] = exp_g_p\n                \n                possible = True\n                temp_visited = [False] * (n + 1)\n                temp_visited[start_node] = True\n                \n                head = 0\n                while head < len(temp_q):\n                    u, u_exp = temp_q[head]\n                    head += 1\n                    \n                    for v, g_val_edge, l_val_edge in adj[u]:\n                        exp_g_p_edge = get_prime_factors(g_val_edge).get(p, 0)\n                        exp_l_p_edge = get_prime_factors(l_val_edge).get(p, 0)\n                        \n                        # We know u_exp. We need to find v_exp.\n                        # {u_exp, v_exp} must be {exp_g_p_edge, exp_l_p_edge}\n                        \n                        # If u_exp is not one of these, it's impossible.\n                        if u_exp != exp_g_p_edge and u_exp != exp_l_p_edge:\n                            possible = False\n                            break\n                        \n                        v_exp = -1\n                        if u_exp == exp_g_p_edge:\n                            v_exp = exp_l_p_edge\n                        else: # u_exp == exp_l_p_edge\n                            v_exp = exp_g_p_edge\n                        \n                        if temp_current_prime_exponents[v] == -1:\n                            temp_current_prime_exponents[v] = v_exp\n                            temp_q.append((v, v_exp))\n                            temp_visited[v] = True\n                        elif temp_current_prime_exponents[v] != v_exp:\n                            possible = False\n                            break\n                    if not possible:\n                        break\n                \n                if possible:\n                    # Check consistency for all edges in this component\n                    for u_check in range(1, n + 1):\n                        if not temp_visited[u_check]:\n                            continue\n                        for v_check, g_val_check, l_val_check in adj[u_check]:\n                            if not temp_visited[v_check]:\n                                continue\n                            \n                            exp_g_p_check = get_prime_factors(g_val_check).get(p, 0)\n                            exp_l_p_check = get_prime_factors(l_val_check).get(p, 0)\n                            \n                            if min(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_g_p_check or \\\n                               max(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_l_p_check:\n                                possible = False\n                                break\n                        if not possible:\n                            break\n                \n                if possible:\n                    for i in range(1, n + 1):\n                        if temp_visited[i]:\n                            current_prime_exponents[i] = temp_current_prime_exponents[i]\n                            visited_nodes_for_prime[i] = True\n                    found_edge = True\n                    break # Found a valid assignment for this component\n                \n                # Try assigning exp_l_p to start_node\n                if exp_g_p != exp_l_p: # Only try if it's different\n                    temp_current_prime_exponents = [-1] * (n + 1)\n                    temp_q = [(start_node, exp_l_p)]\n                    temp_current_prime_exponents[start_node] = exp_l_p\n                    \n                    possible = True\n                    temp_visited = [False] * (n + 1)\n                    temp_visited[start_node] = True\n                    \n                    head = 0\n                    while head < len(temp_q):\n                        u, u_exp = temp_q[head]\n                        head += 1\n                        \n                        for v, g_val_edge, l_val_edge in adj[u]:\n                            exp_g_p_edge = get_prime_factors(g_val_edge).get(p, 0)\n                            exp_l_p_edge = get_prime_factors(l_val_edge).get(p, 0)\n                            \n                            if u_exp != exp_g_p_edge and u_exp != exp_l_p_edge:\n                                possible = False\n                                break\n                            \n                            v_exp = -1\n                            if u_exp == exp_g_p_edge:\n                                v_exp = exp_l_p_edge\n                            else:\n                                v_exp = exp_g_p_edge\n                            \n                            if temp_current_prime_exponents[v] == -1:\n                                temp_current_prime_exponents[v] = v_exp\n                                temp_q.append((v, v_exp))\n                                temp_visited[v] = True\n                            elif temp_current_prime_exponents[v] != v_exp:\n                                possible = False\n                                break\n                        if not possible:\n                            break\n                    \n                    if possible:\n                        for u_check in range(1, n + 1):\n                            if not temp_visited[u_check]:\n                                continue\n                            for v_check, g_val_check, l_val_check in adj[u_check]:\n                                if not temp_visited[v_check]:\n                                    continue\n                                \n                                exp_g_p_check = get_prime_factors(g_val_check).get(p, 0)\n                                exp_l_p_check = get_prime_factors(l_val_check).get(p, 0)\n                                \n                                if min(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_g_p_check or \\\n                                   max(temp_current_prime_exponents[u_check], temp_current_prime_exponents[v_check]) != exp_l_p_check:\n                                    possible = False\n                                    break\n                            if not possible:\n                                break\n                    \n                    if possible:\n                        for i in range(1, n + 1):\n                            if temp_visited[i]:\n                                current_prime_exponents[i] = temp_current_prime_exponents[i]\n                                visited_nodes_for_prime[i] = True\n                        found_edge = True\n                        break # Found a valid assignment for this component\n            \n            if not found_edge: # This node is isolated in this component (no edges or not yet processed)\n                # If a node is not connected to any edge, its exponent for p can be anything. We can pick 0.\n                if not visited_nodes_for_prime[start_node]:\n                    q_isolated = [start_node]\n                    current_prime_exponents[start_node] = 0 # Default to 0 for isolated nodes\n                    visited_nodes_for_prime[start_node] = True\n                    head_isolated = 0\n                    while head_isolated < len(q_isolated):\n                        u_iso = q_isolated[head_isolated]\n                        head_isolated += 1\n                        for v_iso, _, _ in adj[u_iso]:\n                            if not visited_nodes_for_prime[v_iso]:\n                                current_prime_exponents[v_iso] = 0\n                                visited_nodes_for_prime[v_iso] = True\n                                q_isolated.append(v_iso)\n                \n        # After processing all components for prime p, check if all nodes have an exponent\n        for i in range(1, n + 1):\n            if current_prime_exponents[i] == -1:\n                # This node is part of a component that could not be assigned, or is truly isolated\n                # A truly isolated node can have any value. We default to 1 (exponent 0).\n                current_prime_exponents[i] = 0\n        \n        for i in range(1, n + 1):\n            if i not in ans_prime_exponents:\n                ans_prime_exponents[i] = {}\n            ans_prime_exponents[i][p] = current_prime_exponents[i]\n            \n    # Reconstruct the numbers\n    final_ans = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in all_primes:\n            final_ans[i] *= (p ** ans_prime_exponents[i].get(p, 0))\n\n    # Check the final answer\n    for u, v, g, l in edges:\n        a = final_ans[u]\n        b = final_ans[v]\n        \n        if a == 0 or b == 0: # Should not happen if initial values are 1\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        current_gcd = 0\n        temp_a, temp_b = a, b\n        while temp_b:\n            temp_a, temp_b = temp_b, temp_a % temp_b\n        current_gcd = temp_a\n\n        if current_gcd != g:\n            sys.stdout.write(\"NO\\n\")\n            return\n        \n        if (a * b) // current_gcd != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, final_ans[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 4364,
        "thoughts_token_count": 0
    }
}