{
    "start": 1758293724.1461608,
    "end": 1758293743.9498057,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    primes = []\n    is_prime = [True] * (1000001)\n    for i in range(2, 1000001):\n        if is_prime[i]:\n            primes.append(i)\n            for multiple in range(i * i, 1000001, i):\n                is_prime[multiple] = False\n\n    def get_prime_factors(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num:\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1:\n            factors[temp_num] = factors.get(temp_num, 0) + 1\n        return factors\n\n    def dfs(u, current_prime_factors):\n        visited[u] = True\n        \n        for v, g, l in adj[u]:\n            if not visited[v]:\n                v_prime_factors = {}\n                \n                # For each prime p, we need to determine its exponent in ans[v]\n                # Let ans[u] = p1^a1 * p2^a2 * ...\n                # Let ans[v] = p1^b1 * p2^b2 * ...\n                # gcd(ans[u], ans[v]) = p1^min(a1,b1) * p2^min(a2,b2) * ...\n                # lcm(ans[u], ans[v]) = p1^max(a1,b1) * p2^max(a2,b2) * ...\n                # So, min(a_p, b_p) = exp_p(g) and max(a_p, b_p) = exp_p(l)\n                # This means {a_p, b_p} = {exp_p(g), exp_p(l)}\n                \n                g_factors = get_prime_factors(g)\n                l_factors = get_prime_factors(l)\n\n                all_primes_in_edge = set(g_factors.keys()).union(l_factors.keys())\n\n                for p in all_primes_in_edge:\n                    exp_g = g_factors.get(p, 0)\n                    exp_l = l_factors.get(p, 0)\n                    exp_u = current_prime_factors.get(p, 0)\n\n                    if not (min(exp_u, exp_g) == exp_g and max(exp_u, exp_l) == exp_l):\n                        # This condition checks if there exists a valid exp_v for this prime\n                        # given exp_u, exp_g, exp_l.\n                        # If exp_u is not one of exp_g or exp_l, or if it violates the min/max property,\n                        # then it's impossible.\n                        # The only possibilities for exp_u and exp_v are {exp_g, exp_l}.\n                        # So, if exp_u is not exp_g AND exp_u is not exp_l, then it's impossible.\n                        # More precisely, if exp_u < exp_g or exp_u > exp_l, it's impossible.\n                        # Also, if exp_u != exp_g and exp_u != exp_l, it's impossible.\n                        \n                        # Let's simplify: we know {exp_u, exp_v} must be {exp_g, exp_l}.\n                        # If exp_u == exp_g, then exp_v must be exp_l.\n                        # If exp_u == exp_l, then exp_v must be exp_g.\n                        # If exp_u is neither, then it's impossible.\n                        \n                        # This check is done after ans[u] is fixed.\n                        # If ans[u] is fixed to current_prime_factors, then for each prime p:\n                        # If current_prime_factors.get(p,0) == exp_g, then v_prime_factors[p] must be exp_l.\n                        # If current_prime_factors.get(p,0) == exp_l, then v_prime_factors[p] must be exp_g.\n                        # Otherwise, it's an invalid assignment for ans[u].\n                        # This means we need to ensure this during the initial assignment of ans[u].\n                        # For now, let's assume current_prime_factors is valid for u.\n                        \n                        # If exp_u is fixed, then exp_v is determined:\n                        if exp_u == exp_g:\n                            v_prime_factors[p] = exp_l\n                        elif exp_u == exp_l:\n                            v_prime_factors[p] = exp_g\n                        else:\n                            # This should not happen if current_prime_factors for u is consistent\n                            # with the edge (u,v,g,l).\n                            # This implies that the initial choice of ans[u] was wrong,\n                            # or the graph is inconsistent.\n                            return False # Inconsistent state\n                \n                # After determining v_prime_factors for all primes, calculate ans[v]\n                val_v = 1\n                for p, exp in v_prime_factors.items():\n                    val_v *= (p ** exp)\n                \n                if ans[v] == 0:\n                    ans[v] = val_v\n                    if not dfs(v, v_prime_factors):\n                        return False\n                elif ans[v] != val_v:\n                    return False # Conflict\n        return True\n\n    # Try to assign a value to an unvisited node and run DFS\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not adj[i]: # Isolated node\n                ans[i] = 1\n                visited[i] = True\n                continue\n\n            # For connected components, we need to find a starting value.\n            # A good candidate for ans[u] is one of the GCDs or LCMs.\n            # Let's try to assign ans[i] = g or ans[i] = l for one of its edges.\n            # Or, more generally, ans[i] must be a divisor of LCM and a multiple of GCD.\n            # And for each prime p, exp_p(ans[i]) must be between exp_p(g) and exp_p(l).\n            # Also, {exp_p(ans[i]), exp_p(ans[v])} = {exp_p(g), exp_p(l)}.\n            \n            # The simplest starting point is to try ans[i] = g or ans[i] = l\n            # for an arbitrary edge (i, v, g, l).\n            # Let's pick the first edge for node i.\n            \n            u_start = i\n            first_edge_found = False\n            for v_neighbor, g_val, l_val in adj[u_start]:\n                # Try ans[u_start] = g_val\n                ans[u_start] = g_val\n                if dfs(u_start, get_prime_factors(g_val)):\n                    first_edge_found = True\n                    break\n                \n                # Reset visited and ans for a retry\n                for k in range(1, n + 1):\n                    visited[k] = False\n                    if k != u_start:\n                        ans[k] = 0\n                \n                # Try ans[u_start] = l_val\n                ans[u_start] = l_val\n                if dfs(u_start, get_prime_factors(l_val)):\n                    first_edge_found = True\n                    break\n                \n                # Reset visited and ans for a retry\n                for k in range(1, n + 1):\n                    visited[k] = False\n                    if k != u_start:\n                        ans[k] = 0\n                \n                # If neither g_val nor l_val worked as initial assignment for u_start,\n                # then this component cannot be satisfied starting from u_start.\n                # This implies the overall graph is inconsistent.\n                # However, there might be other valid initial values for ans[u_start].\n                # The problem statement implies we need to find *any* valid assignment.\n                # The range of values is 1 to 10^6.\n                # A more robust approach would be to iterate through all divisors of l_val\n                # that are multiples of g_val.\n                \n                # Let's use a more structured approach for the initial value.\n                # For any edge (u, v, g, l), we know that ans[u] * ans[v] = g * l.\n                # Also, ans[u] must be a multiple of g and a divisor of l.\n                # Let k = l / g. We need to find x, y such that gcd(x, y) = g and lcm(x, y) = l.\n                # This means x = g * x' and y = g * y' where gcd(x', y') = 1 and x' * y' = k.\n                # So we need to find a pair of coprime factors (x', y') of k.\n                \n                # For a starting node u_start, we can pick any edge (u_start, v, g, l).\n                # We can iterate through all x' that are factors of k = l/g.\n                # If gcd(x', k/x') == 1, then ans[u_start] = g * x' is a candidate.\n                \n                k_val = l_val // g_val\n                k_factors = get_prime_factors(k_val)\n                \n                # Generate all divisors of k_val\n                divs = [1]\n                for p, exp in k_factors.items():\n                    new_divs = []\n                    for d in divs:\n                        for i_exp in range(exp + 1):\n                            new_divs.append(d * (p ** i_exp))\n                    divs = new_divs\n                \n                possible_u_vals = []\n                for x_prime in divs:\n                    y_prime = k_val // x_prime\n                    if gcd(x_prime, y_prime) == 1:\n                        possible_u_vals.append(g_val * x_prime)\n                \n                for potential_ans_u_start in possible_u_vals:\n                    ans[u_start] = potential_ans_u_start\n                    if dfs(u_start, get_prime_factors(potential_ans_u_start)):\n                        first_edge_found = True\n                        break\n                    \n                    # Reset visited and ans for a retry\n                    for k_reset in range(1, n + 1):\n                        visited[k_reset] = False\n                        if k_reset != u_start:\n                            ans[k_reset] = 0\n                \n                if first_edge_found:\n                    break\n            \n            if not first_edge_found:\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    # Final verification\n    for u, v, g, l in edges_data:\n        if gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    primes = []\n    is_prime = [True] * (1000001)\n    for i in range(2, 1000001):\n        if is_prime[i]:\n            primes.append(i)\n            for multiple in range(i * i, 1000001, i):\n                is_prime[multiple] = False\n\n    def get_prime_factors(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num:\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1:\n            factors[temp_num] = factors.get(temp_num, 0) + 1\n        return factors\n\n    def dfs(u, current_prime_factors):\n        visited[u] = True\n        \n        for v, g, l in adj[u]:\n            if not visited[v]:\n                v_prime_factors = {}\n                \n                # For each prime p, we need to determine its exponent in ans[v]\n                # Let ans[u] = p1^a1 * p2^a2 * ...\n                # Let ans[v] = p1^b1 * p2^b2 * ...\n                # gcd(ans[u], ans[v]) = p1^min(a1,b1) * p2^min(a2,b2) * ...\n                # lcm(ans[u], ans[v]) = p1^max(a1,b1) * p2^max(a2,b2) * ...\n                # So, min(a_p, b_p) = exp_p(g) and max(a_p, b_p) = exp_p(l)\n                # This means {a_p, b_p} = {exp_p(g), exp_p(l)}\n                \n                g_factors = get_prime_factors(g)\n                l_factors = get_prime_factors(l)\n\n                all_primes_in_edge = set(g_factors.keys()).union(l_factors.keys())\n\n                for p in all_primes_in_edge:\n                    exp_g = g_factors.get(p, 0)\n                    exp_l = l_factors.get(p, 0)\n                    exp_u = current_prime_factors.get(p, 0)\n\n                    if not (min(exp_u, exp_g) == exp_g and max(exp_u, exp_l) == exp_l):\n                        # This condition checks if there exists a valid exp_v for this prime\n                        # given exp_u, exp_g, exp_l.\n                        # If exp_u is not one of exp_g or exp_l, or if it violates the min/max property,\n                        # then it's impossible.\n                        # The only possibilities for exp_u and exp_v are {exp_g, exp_l}.\n                        # So, if exp_u is not exp_g AND exp_u is not exp_l, then it's impossible.\n                        # More precisely, if exp_u < exp_g or exp_u > exp_l, it's impossible.\n                        # Also, if exp_u != exp_g and exp_u != exp_l, it's impossible.\n                        \n                        # Let's simplify: we know {exp_u, exp_v} must be {exp_g, exp_l}.\n                        # If exp_u == exp_g, then exp_v must be exp_l.\n                        # If exp_u == exp_l, then exp_v must be exp_g.\n                        # If exp_u is neither, then it's impossible.\n                        \n                        # This check is done after ans[u] is fixed.\n                        # If ans[u] is fixed to current_prime_factors, then for each prime p:\n                        # If current_prime_factors.get(p,0) == exp_g, then v_prime_factors[p] must be exp_l.\n                        # If current_prime_factors.get(p,0) == exp_l, then v_prime_factors[p] must be exp_g.\n                        # Otherwise, it's an invalid assignment for ans[u].\n                        # This means we need to ensure this during the initial assignment of ans[u].\n                        # For now, let's assume current_prime_factors is valid for u.\n                        \n                        # If exp_u is fixed, then exp_v is determined:\n                        if exp_u == exp_g:\n                            v_prime_factors[p] = exp_l\n                        elif exp_u == exp_l:\n                            v_prime_factors[p] = exp_g\n                        else:\n                            # This should not happen if current_prime_factors for u is consistent\n                            # with the edge (u,v,g,l).\n                            # This implies that the initial choice of ans[u] was wrong,\n                            # or the graph is inconsistent.\n                            return False # Inconsistent state\n                \n                # After determining v_prime_factors for all primes, calculate ans[v]\n                val_v = 1\n                for p, exp in v_prime_factors.items():\n                    val_v *= (p ** exp)\n                \n                if ans[v] == 0:\n                    ans[v] = val_v\n                    if not dfs(v, v_prime_factors):\n                        return False\n                elif ans[v] != val_v:\n                    return False # Conflict\n        return True\n\n    # Try to assign a value to an unvisited node and run DFS\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not adj[i]: # Isolated node\n                ans[i] = 1\n                visited[i] = True\n                continue\n\n            # For connected components, we need to find a starting value.\n            # A good candidate for ans[u] is one of the GCDs or LCMs.\n            # Let's try to assign ans[i] = g or ans[i] = l for one of its edges.\n            # Or, more generally, ans[i] must be a divisor of LCM and a multiple of GCD.\n            # And for each prime p, exp_p(ans[i]) must be between exp_p(g) and exp_p(l).\n            # Also, {exp_p(ans[i]), exp_p(ans[v])} = {exp_p(g), exp_p(l)}.\n            \n            # The simplest starting point is to try ans[i] = g or ans[i] = l\n            # for an arbitrary edge (i, v, g, l).\n            # Let's pick the first edge for node i.\n            \n            u_start = i\n            first_edge_found = False\n            for v_neighbor, g_val, l_val in adj[u_start]:\n                # Try ans[u_start] = g_val\n                ans[u_start] = g_val\n                if dfs(u_start, get_prime_factors(g_val)):\n                    first_edge_found = True\n                    break\n                \n                # Reset visited and ans for a retry\n                for k in range(1, n + 1):\n                    visited[k] = False\n                    if k != u_start:\n                        ans[k] = 0\n                \n                # Try ans[u_start] = l_val\n                ans[u_start] = l_val\n                if dfs(u_start, get_prime_factors(l_val)):\n                    first_edge_found = True\n                    break\n                \n                # Reset visited and ans for a retry\n                for k in range(1, n + 1):\n                    visited[k] = False\n                    if k != u_start:\n                        ans[k] = 0\n                \n                # If neither g_val nor l_val worked as initial assignment for u_start,\n                # then this component cannot be satisfied starting from u_start.\n                # This implies the overall graph is inconsistent.\n                # However, there might be other valid initial values for ans[u_start].\n                # The problem statement implies we need to find *any* valid assignment.\n                # The range of values is 1 to 10^6.\n                # A more robust approach would be to iterate through all divisors of l_val\n                # that are multiples of g_val.\n                \n                # Let's use a more structured approach for the initial value.\n                # For any edge (u, v, g, l), we know that ans[u] * ans[v] = g * l.\n                # Also, ans[u] must be a multiple of g and a divisor of l.\n                # Let k = l / g. We need to find x, y such that gcd(x, y) = g and lcm(x, y) = l.\n                # This means x = g * x' and y = g * y' where gcd(x', y') = 1 and x' * y' = k.\n                # So we need to find a pair of coprime factors (x', y') of k.\n                \n                # For a starting node u_start, we can pick any edge (u_start, v, g, l).\n                # We can iterate through all x' that are factors of k = l/g.\n                # If gcd(x', k/x') == 1, then ans[u_start] = g * x' is a candidate.\n                \n                k_val = l_val // g_val\n                k_factors = get_prime_factors(k_val)\n                \n                # Generate all divisors of k_val\n                divs = [1]\n                for p, exp in k_factors.items():\n                    new_divs = []\n                    for d in divs:\n                        for i_exp in range(exp + 1):\n                            new_divs.append(d * (p ** i_exp))\n                    divs = new_divs\n                \n                possible_u_vals = []\n                for x_prime in divs:\n                    y_prime = k_val // x_prime\n                    if gcd(x_prime, y_prime) == 1:\n                        possible_u_vals.append(g_val * x_prime)\n                \n                for potential_ans_u_start in possible_u_vals:\n                    ans[u_start] = potential_ans_u_start\n                    if dfs(u_start, get_prime_factors(potential_ans_u_start)):\n                        first_edge_found = True\n                        break\n                    \n                    # Reset visited and ans for a retry\n                    for k_reset in range(1, n + 1):\n                        visited[k_reset] = False\n                        if k_reset != u_start:\n                            ans[k_reset] = 0\n                \n                if first_edge_found:\n                    break\n            \n            if not first_edge_found:\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    # Final verification\n    for u, v, g, l in edges_data:\n        if gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 3012,
        "thoughts_token_count": 0
    }
}