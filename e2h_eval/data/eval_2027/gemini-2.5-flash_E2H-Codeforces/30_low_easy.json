{
    "start": 1758285251.4862738,
    "end": 1758285284.903962,
    "start-formatted": "2025-09-19 21:34 KST",
    "end-formatted": "2025-09-19 21:34 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**My Approach to the TV Game Problem**\n\nOkay, so I'm tackling this \"TV Game\" problem.  The goal is to determine the optimal strategy for Homer and Marge, maximizing their combined score. It's essentially a number construction game with a specific digit-taking rule.\n\n**Understanding the Core Mechanics:**\n\nI have `2n` digits in the number `A`, and each player gets `n` moves. They take digits from the left of `A` and append them to their own numbers. The aim is to maximize the sum of the resulting numbers.  The example provided clarifies the dynamics - appending to the right creates a larger left-hand digit significance.\n\n**Initial Exploration:**\n\nI walked through several scenarios with the example `n=2` and `A=\"1234\"` to get a feel for the problem. I manually calculated totals for a few move sequences like `HHMM`, `HMHM`, and so on. This helped me grasp the impact of the order in which digits are taken. I noticed that `HHMM` and `MMHH` seem to lead to the highest score in this example.\n\n**Key Insight:**\n\nThe most important takeaway is that the order of the digits *matters*. Appending earlier digits to the beginning means they hold more numerical significance.  This suggests that players need to prioritize larger digits earlier in their sequence, or strategically position smaller numbers to be used in conjunction with them.\n\n**Next Steps:**\n\nNow, I need to design an algorithm or strategy. I'm thinking of a greedy approach. Maybe I sort the digits somehow and then assign them to either H or M in a way that maximizes the sum at each step.  I want a Python script, of course! So, I'll start with how to represent the problem state, the player choices, the effect of player choices, and eventually, the method to find the solution.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # The total number of digits is 2n.\n    # Each player makes n moves.\n    # To maximize S1 + S2, we want to maximize the sum of the values of the digits\n    # multiplied by their positional weights.\n    # A digit taken at turn `k` (0-indexed) will be at position `n - 1 - moves_made_by_this_player`\n    # in the player's final number.\n    # The value of a digit `d` at position `p` (0-indexed from right) is `d * (10^p)`.\n    # So, a digit taken earliest by a player gets the highest positional weight.\n\n    # Let's consider the digits from left to right in A.\n    # For each digit a_i (at original index i in A_str), it will be taken at turn i.\n    # If Homer takes it, it becomes the (H_count)-th digit of S1.\n    # If Marge takes it, it becomes the (M_count)-th digit of S2.\n    # H_count and M_count are 0-indexed.\n\n    # The final number S1 will be formed by n digits.\n    # The first digit Homer takes will be S1[0], second S1[1], ..., n-th S1[n-1].\n    # Similarly for S2.\n    # The value of S1 is sum(digit_h_j * 10^(n-1-j)) for j=0 to n-1.\n    # The value of S2 is sum(digit_m_j * 10^(n-1-j)) for j=0 to n-1.\n    # Total sum = sum(digit_h_j * 10^(n-1-j)) + sum(digit_m_j * 10^(n-1-j)).\n\n    # Let's rephrase:\n    # Each digit `d` from `A` is taken.\n    # If it's taken by Homer as his `k`-th digit (0-indexed), it contributes `d * 10^(n-1-k)` to the total sum.\n    # If it's taken by Marge as her `k`-th digit (0-indexed), it contributes `d * 10^(n-1-k)` to the total sum.\n\n    # To maximize the total sum, for each digit `d`, we want it to be multiplied by the largest possible power of 10.\n    # The largest power of 10 is 10^(n-1). This occurs when a player takes a digit as their first move (k=0).\n    # The second largest is 10^(n-2) (k=1), and so on.\n\n    # This means we should assign the largest digits from A to be taken early by *either* Homer or Marge.\n    # Since the contribution `d * 10^(n-1-k)` is the same regardless of who takes it (Homer or Marge),\n    # as long as it's their `k`-th move, the choice of player doesn't matter for the *value* of the contribution,\n    # only for which player's `k`-th move it is.\n\n    # The problem asks for *any* sequence of moves.\n    # This simplifies things greatly. We just need to ensure that Homer makes n moves and Marge makes n moves.\n    # The choice of which player makes which move does not affect the total sum if we consider the set of digits\n    # assigned to each \"slot\" (e.g., \"first digit taken by a player\", \"second digit taken by a player\", etc.).\n    # The digits are taken sequentially from A.\n    # So, the first digit of A will always be the first digit taken by *some* player.\n    # The second digit of A will always be the second digit taken by *some* player.\n    # And so on.\n\n    # The first digit taken from A becomes the 0-th digit for whichever player takes it.\n    # The second digit taken from A becomes the 1-st digit for whichever player takes it.\n    # ...\n    # The n-th digit taken from A becomes the (n-1)-th digit for whichever player takes it.\n    # The (n+1)-th digit taken from A becomes the 0-th digit for the *other* player.\n    # ...\n    # The 2n-th digit taken from A becomes the (n-1)-th digit for the *other* player.\n\n    # This interpretation is incorrect.\n    # Let's re-read carefully:\n    # \"On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si.\"\n    # \"After that this leftmost digit is erased from A.\"\n    # \"Initially the numbers of both players (S1 and S2) are «empty».\"\n\n    # Example: n=2, A=\"1234\"\n    # Total 4 moves. Homer 2, Marge 2.\n    #\n    # Sequence HHMM:\n    # 1. H takes '1'. S1=\"1\". H_moves=1.\n    # 2. H takes '2'. S1=\"12\". H_moves=2.\n    # 3. M takes '3'. S2=\"3\". M_moves=1.\n    # 4. M takes '4'. S2=\"34\". M_moves=2.\n    # Result: S1=12, S2=34. Total=46.\n    #\n    # Sequence HMHM:\n    # 1. H takes '1'. S1=\"1\". H_moves=1.\n    # 2. M takes '2'. S2=\"2\". M_moves=1.\n    # 3. H takes '3'. S1=\"13\". H_moves=2.\n    # 4. M takes '4'. S2=\"24\". M_moves=2.\n    # Result: S1=13, S2=24. Total=37.\n\n    # The actual contribution of a digit `d` taken at original index `i` (0-indexed) depends on:\n    # 1. Which player takes it.\n    # 2. How many digits that player has already taken.\n\n    # Let `h_taken` be the count of digits Homer has taken so far.\n    # Let `m_taken` be the count of digits Marge has taken so far.\n\n    # If Homer takes digit `d`: it becomes `S1[h_taken]`. Its value is `d * 10^(n - 1 - h_taken)`.\n    # If Marge takes digit `d`: it becomes `S2[m_taken]`. Its value is `d * 10^(n - 1 - m_taken)`.\n\n    # We want to maximize the sum of these contributions.\n    # The digits `a_str[0]`, `a_str[1]`, ..., `a_str[2n-1]` are processed in order.\n    # For each `a_str[k]`, we decide whether Homer takes it or Marge takes it.\n    # This is a dynamic programming problem or a greedy problem.\n    # Given n <= 18, 2n <= 36. A DP state like `dp(k, h_count, m_count)` representing max sum\n    # processing `a_str[k:]` with `h_count` moves for Homer and `m_count` for Marge already made.\n    # `k` goes from `0` to `2n`. `h_count` from `0` to `n`. `m_count` from `0` to `n`.\n    # State space: `2n * n * n` which is `36 * 18 * 18` = `11664`.\n    # Each state takes O(1) to compute. Total time: `O(2n * n^2)`.\n    # This is feasible.\n\n    # Let `dp[k][h_c][m_c]` be the maximum total prize considering digits `a_str[k:]`\n    # given that Homer has already made `h_c` moves and Marge has made `m_c` moves.\n    # The base case: `dp[2n][n][n] = 0`. All other `dp[2n][...][...] = -infinity`.\n    # We need to store the path as well, so we can reconstruct the sequence.\n    # `path[k][h_c][m_c]` stores 'H' or 'M'.\n\n    # Initialize DP table with -1 (or some indicator for uncomputed/invalid state)\n    dp = {} # Using a dictionary for memoization, or a 3D array if indices are dense.\n    # Max h_c, m_c is n. Max k is 2n.\n    # dp_table[k][h_c][m_c]\n    dp_table = [[[-1 for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(2 * n + 1)]\n    path_table = [[['' for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(2 * n + 1)]\n\n    # Powers of 10 for calculating digit values\n    # `pow10[p]` stores `10^p`.\n    # `pow10[n-1-k]` is the multiplier for the k-th digit taken by a player.\n    pow10 = [1] * n\n    for i in range(1, n):\n        pow10[i] = pow10[i-1] * 10\n\n    def calculate_max_prize(k, h_c, m_c):\n        # k: current digit index in a_str (0 to 2n-1)\n        # h_c: number of moves Homer has made so far\n        # m_c: number of moves Marge has made so far\n\n        if h_c > n or m_c > n:\n            return -1 # Invalid state (too many moves for a player)\n\n        if k == 2 * n: # All digits processed\n            if h_c == n and m_c == n:\n                return 0\n            else:\n                return -1 # Invalid state (not enough moves for a player)\n\n        if dp_table[k][h_c][m_c] != -1:\n            return dp_table[k][h_c][m_c]\n\n        current_digit_val = int(a_str[k])\n        max_prize = -1\n        best_choice = ''\n\n        # Option 1: Homer takes the current digit\n        if h_c < n:\n            # Value contributed by this digit: current_digit_val * 10^(n - 1 - h_c)\n            # This is the (h_c)-th digit Homer takes (0-indexed).\n            contribution = current_digit_val * pow10[n - 1 - h_c]\n            \n            remaining_prize = calculate_max_prize(k + 1, h_c + 1, m_c)\n            if remaining_prize != -1:\n                current_total_prize = contribution + remaining_prize\n                if current_total_prize > max_prize:\n                    max_prize = current_total_prize\n                    best_choice = 'H'\n\n        # Option 2: Marge takes the current digit\n        if m_c < n:\n            # Value contributed by this digit: current_digit_val * 10^(n - 1 - m_c)\n            # This is the (m_c)-th digit Marge takes (0-indexed).\n            contribution = current_digit_val * pow10[n - 1 - m_c]\n            \n            remaining_prize = calculate_max_prize(k + 1, h_c, m_c + 1)\n            if remaining_prize != -1:\n                current_total_prize = contribution + remaining_prize\n                if current_total_prize > max_prize:\n                    # If equal, we can take either. Problem says \"any of them\".\n                    # So, if current_total_prize == max_prize, we can still update\n                    # to 'M' if we want, or keep 'H'. Let's update to 'M' to be consistent\n                    # with the example output for n=2, A=\"9911\" -> HMHM.\n                    # This means if 'H' and 'M' give the same max_prize, 'M' is preferred\n                    # by this condition. The problem says \"any of them\", so it doesn't matter.\n                    # Let's just pick the first one we find that maximizes.\n                    if current_total_prize > max_prize:\n                        max_prize = current_total_prize\n                        best_choice = 'M'\n                    elif current_total_prize == max_prize and best_choice == '': # If only Marge could play, or Marge is better\n                        max_prize = current_total_prize\n                        best_choice = 'M'\n\n\n        dp_table[k][h_c][m_c] = max_prize\n        path_table[k][h_c][m_c] = best_choice\n        return max_prize\n\n    # Start DP calculation from the beginning\n    calculate_max_prize(0, 0, 0)\n\n    # Reconstruct the path\n    result_sequence = []\n    k, h_c, m_c = 0, 0, 0\n    while k < 2 * n:\n        choice = path_table[k][h_c][m_c]\n        result_sequence.append(choice)\n        if choice == 'H':\n            h_c += 1\n        else: # choice == 'M'\n            m_c += 1\n        k += 1\n    \n    sys.stdout.write(\"\".join(result_sequence) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # The total number of digits is 2n.\n    # Each player makes n moves.\n    # To maximize S1 + S2, we want to maximize the sum of the values of the digits\n    # multiplied by their positional weights.\n    # A digit taken at turn `k` (0-indexed) will be at position `n - 1 - moves_made_by_this_player`\n    # in the player's final number.\n    # The value of a digit `d` at position `p` (0-indexed from right) is `d * (10^p)`.\n    # So, a digit taken earliest by a player gets the highest positional weight.\n\n    # Let's consider the digits from left to right in A.\n    # For each digit a_i (at original index i in A_str), it will be taken at turn i.\n    # If Homer takes it, it becomes the (H_count)-th digit of S1.\n    # If Marge takes it, it becomes the (M_count)-th digit of S2.\n    # H_count and M_count are 0-indexed.\n\n    # The final number S1 will be formed by n digits.\n    # The first digit Homer takes will be S1[0], second S1[1], ..., n-th S1[n-1].\n    # Similarly for S2.\n    # The value of S1 is sum(digit_h_j * 10^(n-1-j)) for j=0 to n-1.\n    # The value of S2 is sum(digit_m_j * 10^(n-1-j)) for j=0 to n-1.\n    # Total sum = sum(digit_h_j * 10^(n-1-j)) + sum(digit_m_j * 10^(n-1-j)).\n\n    # Let's rephrase:\n    # Each digit `d` from `A` is taken.\n    # If it's taken by Homer as his `k`-th digit (0-indexed), it contributes `d * 10^(n-1-k)` to the total sum.\n    # If it's taken by Marge as her `k`-th digit (0-indexed), it contributes `d * 10^(n-1-k)` to the total sum.\n\n    # To maximize the total sum, for each digit `d`, we want it to be multiplied by the largest possible power of 10.\n    # The largest power of 10 is 10^(n-1). This occurs when a player takes a digit as their first move (k=0).\n    # The second largest is 10^(n-2) (k=1), and so on.\n\n    # This means we should assign the largest digits from A to be taken early by *either* Homer or Marge.\n    # Since the contribution `d * 10^(n-1-k)` is the same regardless of who takes it (Homer or Marge),\n    # as long as it's their `k`-th move, the choice of player doesn't matter for the *value* of the contribution,\n    # only for which player's `k`-th move it is.\n\n    # The problem asks for *any* sequence of moves.\n    # This simplifies things greatly. We just need to ensure that Homer makes n moves and Marge makes n moves.\n    # The choice of which player makes which move does not affect the total sum if we consider the set of digits\n    # assigned to each \"slot\" (e.g., \"first digit taken by a player\", \"second digit taken by a player\", etc.).\n    # The digits are taken sequentially from A.\n    # So, the first digit of A will always be the first digit taken by *some* player.\n    # The second digit of A will always be the second digit taken by *some* player.\n    # And so on.\n\n    # The first digit taken from A becomes the 0-th digit for whichever player takes it.\n    # The second digit taken from A becomes the 1-st digit for whichever player takes it.\n    # ...\n    # The n-th digit taken from A becomes the (n-1)-th digit for whichever player takes it.\n    # The (n+1)-th digit taken from A becomes the 0-th digit for the *other* player.\n    # ...\n    # The 2n-th digit taken from A becomes the (n-1)-th digit for the *other* player.\n\n    # This interpretation is incorrect.\n    # Let's re-read carefully:\n    # \"On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si.\"\n    # \"After that this leftmost digit is erased from A.\"\n    # \"Initially the numbers of both players (S1 and S2) are «empty».\"\n\n    # Example: n=2, A=\"1234\"\n    # Total 4 moves. Homer 2, Marge 2.\n    #\n    # Sequence HHMM:\n    # 1. H takes '1'. S1=\"1\". H_moves=1.\n    # 2. H takes '2'. S1=\"12\". H_moves=2.\n    # 3. M takes '3'. S2=\"3\". M_moves=1.\n    # 4. M takes '4'. S2=\"34\". M_moves=2.\n    # Result: S1=12, S2=34. Total=46.\n    #\n    # Sequence HMHM:\n    # 1. H takes '1'. S1=\"1\". H_moves=1.\n    # 2. M takes '2'. S2=\"2\". M_moves=1.\n    # 3. H takes '3'. S1=\"13\". H_moves=2.\n    # 4. M takes '4'. S2=\"24\". M_moves=2.\n    # Result: S1=13, S2=24. Total=37.\n\n    # The actual contribution of a digit `d` taken at original index `i` (0-indexed) depends on:\n    # 1. Which player takes it.\n    # 2. How many digits that player has already taken.\n\n    # Let `h_taken` be the count of digits Homer has taken so far.\n    # Let `m_taken` be the count of digits Marge has taken so far.\n\n    # If Homer takes digit `d`: it becomes `S1[h_taken]`. Its value is `d * 10^(n - 1 - h_taken)`.\n    # If Marge takes digit `d`: it becomes `S2[m_taken]`. Its value is `d * 10^(n - 1 - m_taken)`.\n\n    # We want to maximize the sum of these contributions.\n    # The digits `a_str[0]`, `a_str[1]`, ..., `a_str[2n-1]` are processed in order.\n    # For each `a_str[k]`, we decide whether Homer takes it or Marge takes it.\n    # This is a dynamic programming problem or a greedy problem.\n    # Given n <= 18, 2n <= 36. A DP state like `dp(k, h_count, m_count)` representing max sum\n    # processing `a_str[k:]` with `h_count` moves for Homer and `m_count` for Marge already made.\n    # `k` goes from `0` to `2n`. `h_count` from `0` to `n`. `m_count` from `0` to `n`.\n    # State space: `2n * n * n` which is `36 * 18 * 18` = `11664`.\n    # Each state takes O(1) to compute. Total time: `O(2n * n^2)`.\n    # This is feasible.\n\n    # Let `dp[k][h_c][m_c]` be the maximum total prize considering digits `a_str[k:]`\n    # given that Homer has already made `h_c` moves and Marge has made `m_c` moves.\n    # The base case: `dp[2n][n][n] = 0`. All other `dp[2n][...][...] = -infinity`.\n    # We need to store the path as well, so we can reconstruct the sequence.\n    # `path[k][h_c][m_c]` stores 'H' or 'M'.\n\n    # Initialize DP table with -1 (or some indicator for uncomputed/invalid state)\n    dp = {} # Using a dictionary for memoization, or a 3D array if indices are dense.\n    # Max h_c, m_c is n. Max k is 2n.\n    # dp_table[k][h_c][m_c]\n    dp_table = [[[-1 for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(2 * n + 1)]\n    path_table = [[['' for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(2 * n + 1)]\n\n    # Powers of 10 for calculating digit values\n    # `pow10[p]` stores `10^p`.\n    # `pow10[n-1-k]` is the multiplier for the k-th digit taken by a player.\n    pow10 = [1] * n\n    for i in range(1, n):\n        pow10[i] = pow10[i-1] * 10\n\n    def calculate_max_prize(k, h_c, m_c):\n        # k: current digit index in a_str (0 to 2n-1)\n        # h_c: number of moves Homer has made so far\n        # m_c: number of moves Marge has made so far\n\n        if h_c > n or m_c > n:\n            return -1 # Invalid state (too many moves for a player)\n\n        if k == 2 * n: # All digits processed\n            if h_c == n and m_c == n:\n                return 0\n            else:\n                return -1 # Invalid state (not enough moves for a player)\n\n        if dp_table[k][h_c][m_c] != -1:\n            return dp_table[k][h_c][m_c]\n\n        current_digit_val = int(a_str[k])\n        max_prize = -1\n        best_choice = ''\n\n        # Option 1: Homer takes the current digit\n        if h_c < n:\n            # Value contributed by this digit: current_digit_val * 10^(n - 1 - h_c)\n            # This is the (h_c)-th digit Homer takes (0-indexed).\n            contribution = current_digit_val * pow10[n - 1 - h_c]\n            \n            remaining_prize = calculate_max_prize(k + 1, h_c + 1, m_c)\n            if remaining_prize != -1:\n                current_total_prize = contribution + remaining_prize\n                if current_total_prize > max_prize:\n                    max_prize = current_total_prize\n                    best_choice = 'H'\n\n        # Option 2: Marge takes the current digit\n        if m_c < n:\n            # Value contributed by this digit: current_digit_val * 10^(n - 1 - m_c)\n            # This is the (m_c)-th digit Marge takes (0-indexed).\n            contribution = current_digit_val * pow10[n - 1 - m_c]\n            \n            remaining_prize = calculate_max_prize(k + 1, h_c, m_c + 1)\n            if remaining_prize != -1:\n                current_total_prize = contribution + remaining_prize\n                if current_total_prize > max_prize:\n                    # If equal, we can take either. Problem says \"any of them\".\n                    # So, if current_total_prize == max_prize, we can still update\n                    # to 'M' if we want, or keep 'H'. Let's update to 'M' to be consistent\n                    # with the example output for n=2, A=\"9911\" -> HMHM.\n                    # This means if 'H' and 'M' give the same max_prize, 'M' is preferred\n                    # by this condition. The problem says \"any of them\", so it doesn't matter.\n                    # Let's just pick the first one we find that maximizes.\n                    if current_total_prize > max_prize:\n                        max_prize = current_total_prize\n                        best_choice = 'M'\n                    elif current_total_prize == max_prize and best_choice == '': # If only Marge could play, or Marge is better\n                        max_prize = current_total_prize\n                        best_choice = 'M'\n\n\n        dp_table[k][h_c][m_c] = max_prize\n        path_table[k][h_c][m_c] = best_choice\n        return max_prize\n\n    # Start DP calculation from the beginning\n    calculate_max_prize(0, 0, 0)\n\n    # Reconstruct the path\n    result_sequence = []\n    k, h_c, m_c = 0, 0, 0\n    while k < 2 * n:\n        choice = path_table[k][h_c][m_c]\n        result_sequence.append(choice)\n        if choice == 'H':\n            h_c += 1\n        else: # choice == 'M'\n            m_c += 1\n        k += 1\n    \n    sys.stdout.write(\"\".join(result_sequence) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 431,
        "completion_token_count": 3284,
        "thoughts_token_count": 790
    }
}