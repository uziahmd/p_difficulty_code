{
    "start": 1758009281.2472734,
    "end": 1758009323.109254,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Problem Decomposition and Strategic Thinking**\n\nOkay, so I've got this competitive programming problem and I need a Python script to solve it.  The core of the problem is finding two disjoint vouchers whose durations sum to a target value (`x`) while minimizing their combined cost.  A naive O(N^2) approach is out of the question given the constraints, so I need to be smarter about this.\n\nFirst, I break down the problem into manageable pieces. I've got the input format: number of vouchers, target duration, and voucher details (start, end, and cost).  The conditions for a valid pair are critical: distinct vouchers, disjoint intervals, and the correct total duration.\n\nThe constraints are a big hint. `n` and `x` are up to 200,000, so I'm thinking O(N log N) or O(N) is the target complexity. The bounds on the end dates also suggest I could potentially use arrays indexed by days.\n\nNow, my strategy is starting to crystallize. I need to iterate through the vouchers efficiently, fixing one voucher at a time and then finding a suitable companion.  The disjoint condition is a key factor here. Let's say I fix voucher `i`. I need to find voucher `j` such that `j` doesn't overlap with `i`, their durations add up to `x`, and the combined cost is minimized. If I sort the vouchers according to their start days, I can simplify the disjunction condition.\n\nThe duration calculation is straightforward, and the condition becomes finding a `j` with the correct duration and cost, which could be done using a dictionary/hashmap.  If the duration sum is more than `x`, then I can skip this combination.\n\nSo, for each voucher, I need to look up a corresponding voucher with the appropriate duration and minimal cost. I'll need to store the data and index it somehow to search efficiently. I might be able to use a dictionary or a custom data structure that can handle disjoint intervals.\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations `(r_i - l_i + 1) + (r_j - l_j + 1)` is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet `D_k = r_k - l_k + 1` be the duration of voucher `k`.\nThe conditions are:\n1.  `D_i + D_j = x`\n2.  Vouchers `i` and `j` are non-overlapping: `r_i < l_j` or `r_j < l_i`.\n3.  Minimize `cost_i + cost_j`.\n\nThe constraints `N, x, max_day` are up to `2 * 10^5`. An `O(N^2)` approach is too slow. We need something closer to `O(N log N)` or `O(N)`.\n\nWe can iterate through each voucher `i` and try to find a suitable voucher `j`. To do this efficiently, we need to quickly query for the minimum cost of a voucher `j` that satisfies the duration and non-overlapping conditions.\n\nLet's categorize vouchers by their durations. We can use a list of lists (or a dictionary mapping duration to a list of vouchers) to store vouchers. For example, `vouchers_by_duration[d]` would store all vouchers with duration `d`.\n\nThe maximum possible day is `MAX_COORD = 2 * 10^5`. This suggests using arrays indexed by day.\n\nWe can process vouchers in two passes (or one pass with careful state management). Let's consider sorting the vouchers. Sorting by `l_i` or `r_i` might be helpful.\n\n**Algorithm Idea:**\n\n1.  **Data Structure for Vouchers:**\n    Store vouchers as `(l, r, cost, duration)`.\n    We need to efficiently find minimum cost vouchers that end by a certain day or start after a certain day.\n\n2.  **Pre-computation / Iteration Strategy:**\n    Let's iterate through all possible `r` values from `1` to `MAX_COORD`.\n    For each `r`, we want to consider vouchers that *end* on day `r`.\n    When we are at day `r`, we can maintain information about the best vouchers that *start after* day `r`.\n\n    Let `min_cost_ending_at_day[d]` be the minimum cost of a voucher that ends on day `d` and has duration `d_val`. This is not quite right, as `d_val` could be anything.\n    Instead, let `min_cost_for_duration_after_day[duration][day]` be the minimum cost of a voucher with `duration` that starts *after* `day`. This would be a 2D array, too large.\n\n    A better approach:\n    We need to find `cost_i + cost_j` where `D_i + D_j = x`.\n    This means `D_j = x - D_i`.\n    Let's iterate through all vouchers `i`. For each voucher `i`, calculate its duration `D_i = r_i - l_i + 1`.\n    The required duration for voucher `j` is `D_j = x - D_i`.\n    If `D_j <= 0`, then `i` cannot be part of a valid pair.\n    Otherwise, we need to find a voucher `j` with duration `D_j` such that `r_i < l_j` or `r_j < l_i`, and `cost_j` is minimized.\n\n    The condition `r_i < l_j` (voucher `j` starts after voucher `i` ends) is easier to handle if we process vouchers in order.\n\n    Let's store vouchers by their start day `l_i`.\n    `vouchers_starting_on_day[l]` will be a list of `(r, cost, duration)` for all vouchers that start on day `l`.\n\n    We can maintain an array `min_cost_for_duration_ending_before[duration_val]` which stores the minimum cost of a voucher with duration `duration_val` that has already been processed (i.e., its `r_k < current_l`).\n\n    **Detailed Algorithm:**\n\n    1.  Initialize `min_total_cost = infinity`.\n    2.  Create a data structure, e.g., `vouchers_by_start_day`, where `vouchers_by_start_day[l]` is a list of `(r, cost)` for all vouchers starting on day `l`. The maximum day is `MAX_COORD = 2 * 10^5`.\n    3.  Create an array `min_cost_for_duration_ending_at_or_before_day[MAX_COORD + 1]`. This will store the minimum cost for a voucher that *ends* on or before a specific day, for a specific duration.\n        Initialize `min_cost_for_duration_ending_at_or_before_day[d]` to infinity for all `d`.\n        This array needs to be able to store minimum costs for all possible durations. A `MAX_COORD x MAX_COORD` array is too large.\n        Instead, we can use a `min_costs_for_durations` array which is of size `x` (or `MAX_COORD`), where `min_costs_for_durations[d]` stores the minimum cost found so far for a voucher of duration `d`.\n        Initialize `min_costs_for_durations = [infinity] * (MAX_COORD + 1)`.\n\n    4.  Iterate `current_day` from `1` to `MAX_COORD`.\n        a.  **Update `min_costs_for_durations` with vouchers ending on `current_day - 1`:**\n            When we move from `current_day - 1` to `current_day`, any voucher that ends on `current_day - 1` can now be considered as a potential first voucher in a pair where the second voucher starts on or after `current_day`.\n            To do this, we need to process vouchers that end on `current_day - 1`.\n            Let `vouchers_ending_on_day[r]` be a list of `(l, cost, duration)` for all vouchers ending on day `r`.\n            For each voucher `(l, cost, duration)` in `vouchers_ending_on_day[current_day - 1]`:\n                `min_costs_for_durations[duration] = min(min_costs_for_durations[duration], cost)`\n\n        b.  **Process vouchers starting on `current_day`:**\n            For each voucher `(r, cost)` in `vouchers_by_start_day[current_day]`:\n                Let `D_i = r - current_day + 1`.\n                Let `D_j = x - D_i`.\n                If `1 <= D_j <= MAX_COORD`: // `D_j` must be a valid duration\n                    If `min_costs_for_durations[D_j]` is not infinity:\n                        `min_total_cost = min(min_total_cost, cost + min_costs_for_durations[D_j])`\n\n    This approach correctly handles the `r_k < l_j` condition. When we process vouchers starting on `current_day`, `min_costs_for_durations[D_j]` contains the minimum cost of a voucher with duration `D_j` that *ends before* `current_day`. This ensures `r_k < current_day <= l_j`.\n\n    **Refined Algorithm (using events):**\n\n    1.  Initialize `min_total_cost = infinity`.\n    2.  Create `events` list. For each voucher `(l_i, r_i, cost_i)`:\n        *   Add a \"start event\": `(l_i, 'start', r_i, cost_i)`\n        *   Add an \"end event\": `(r_i, 'end', l_i, cost_i)`\n    3.  Sort `events` by day. If days are equal, process 'end' events before 'start' events (to ensure `r_k < l_j` is strict).\n    4.  Initialize `min_cost_for_duration = [infinity] * (MAX_COORD + 1)`. This array will store the minimum cost of a voucher *encountered so far* that has a particular duration.\n    5.  Iterate through the sorted `events`:\n        a.  If `event = (day, 'end', l, cost)`:\n            Let `duration = day - l + 1`.\n            `min_cost_for_duration[duration] = min(min_cost_for_duration[duration], cost)`.\n        b.  If `event = (day, 'start', r, cost)`:\n            Let `D_i = r - day + 1`.\n            Let `D_j = x - D_i`.\n            If `1 <= D_j <= MAX_COORD`:\n                If `min_cost_for_duration[D_j]` is not infinity:\n                    `min_total_cost = min(min_total_cost, cost + min_cost_for_duration[D_j])`.\n\n    This refined algorithm processes events chronologically. When an 'end' event for voucher `k` occurs, it means voucher `k` has finished, and it can now be considered as the first voucher in a pair. Its cost is updated in `min_cost_for_duration[D_k]`. When a 'start' event for voucher `i` occurs, we look for a `j` that has already finished (i.e., its 'end' event has already been processed), and has the required duration `D_j`. This ensures `r_j < l_i`.\n\n    The maximum duration can be `MAX_COORD`. So `min_cost_for_duration` array size should be `MAX_COORD + 1`.\n\n    **Example Walkthrough:**\n    Vouchers: (1,3,4,D=3), (1,2,5,D=2), (5,6,1,D=2), (1,2,4,D=2). x=5.\n    MAX_COORD = 6.\n    `min_cost_for_duration = [inf] * 7`\n    `min_total_cost = inf`\n\n    Events:\n    (1, 'start', 3, 4) D=3\n    (1, 'start', 2, 5) D=2\n    (1, 'start', 2, 4) D=2\n    (2, 'end', 1, 5) D=2\n    (2, 'end', 1, 4) D=2\n    (3, 'end', 1, 4) D=3\n    (5, 'start', 6, 1) D=2\n    (6, 'end', 5, 1) D=2\n\n    Sorted Events (day, type, ...):\n    1.  (1, 'start', 2, 4) D=2. `D_j = 5-2=3`. `min_cost_for_duration[3]` is inf. No update.\n    2.  (1, 'start', 2, 5) D=2. `D_j = 5-2=3`. `min_cost_for_duration[3]` is inf. No update.\n    3.  (1, 'start', 3, 4) D=3. `D_j = 5-3=2`. `min_cost_for_duration[2]` is inf. No update.\n    4.  (2, 'end', 1, 4) D=2. `min_cost_for_duration[2] = min(inf, 4) = 4`.\n    5.  (2, 'end', 1, 5) D=2. `min_cost_for_duration[2] = min(4, 5) = 4`.\n    6.  (3, 'end', 1, 4) D=3. `min_cost_for_duration[3] = min(inf, 4) = 4`.\n    7.  (5, 'start', 6, 1) D=2. `D_i=2`. `D_j = 5-2=3`.\n        `min_cost_for_duration[3]` is 4.\n        `min_total_cost = min(inf, 1 + 4) = 5`.\n    8.  (6, 'end', 5, 1) D=2. `min_cost_for_duration[2] = min(4, 1) = 1`.\n\n    Final `min_total_cost = 5`. Correct for example 1.\n\n    **Complexity:**\n    *   Creating events: O(N)\n    *   Sorting events: O(N log N) (at most 2N events)\n    *   Iterating events: O(N) operations. Each operation is O(1) array access.\n    *   Space: O(N) for events, O(MAX_COORD) for `min_cost_for_duration`. `MAX_COORD` is `2 * 10^5`, which is acceptable.\n\n    Total time complexity: O(N log N + MAX_COORD).\n    Total space complexity: O(N + MAX_COORD).\n\n    This fits within typical competitive programming limits.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n    \n    # min_cost_for_duration[d] stores the minimum cost of a voucher \n    # with duration 'd' that has *already ended*.\n    # Initialized to a very large value (infinity)\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # List to store events. Each event is (day, type, r_or_l, cost).\n    # 'type' can be 0 for 'end' event, 1 for 'start' event.\n    # We sort by day, then by type (end events before start events for same day).\n    events = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        # Add 'start' event: (l, 1, r, cost)\n        events.append((l, 1, r, cost, duration))\n        # Add 'end' event: (r, 0, l, cost)\n        events.append((r, 0, l, cost, duration))\n\n    # Sort events:\n    # Primary sort key: day\n    # Secondary sort key: type (0 for 'end' comes before 1 for 'start')\n    # This ensures that when we process vouchers starting on 'day', \n    # all vouchers ending on 'day' or earlier have already updated min_cost_for_duration.\n    events.sort()\n\n    min_total_cost = float('inf')\n\n    for day, event_type, other_coord, cost, duration_val in events:\n        if event_type == 0:  # This is an 'end' event (r_k, 0, l_k, cost_k, D_k)\n            # A voucher ending on 'day' (which is r_k) becomes available.\n            # Update the minimum cost for its duration.\n            min_cost_for_duration[duration_val] = min(min_cost_for_duration[duration_val], cost)\n        else:  # This is a 'start' event (l_i, 1, r_i, cost_i, D_i)\n            # We are considering voucher 'i' starting on 'day' (which is l_i).\n            # We need to find a voucher 'j' such that:\n            # 1. D_j = x - D_i\n            # 2. r_j < l_i (voucher j ends before voucher i starts)\n            # The min_cost_for_duration array already stores costs for vouchers that have ended.\n            \n            required_duration_for_j = x - duration_val\n            \n            # Check if required_duration_for_j is valid (positive and within bounds)\n            if 1 <= required_duration_for_j <= MAX_COORD:\n                # If a voucher 'j' with required_duration_for_j has been found\n                # (i.e., its 'end' event was processed), its cost would be in the array.\n                if min_cost_for_duration[required_duration_for_j] != float('inf'):\n                    current_pair_cost = cost + min_cost_for_duration[required_duration_for_j]\n                    min_total_cost = min(min_total_cost, current_pair_cost)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(f\"{min_total_cost}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n    \n    # min_cost_for_duration[d] stores the minimum cost of a voucher \n    # with duration 'd' that has *already ended*.\n    # Initialized to a very large value (infinity)\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # List to store events. Each event is (day, type, r_or_l, cost).\n    # 'type' can be 0 for 'end' event, 1 for 'start' event.\n    # We sort by day, then by type (end events before start events for same day).\n    events = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        # Add 'start' event: (l, 1, r, cost)\n        events.append((l, 1, r, cost, duration))\n        # Add 'end' event: (r, 0, l, cost)\n        events.append((r, 0, l, cost, duration))\n\n    # Sort events:\n    # Primary sort key: day\n    # Secondary sort key: type (0 for 'end' comes before 1 for 'start')\n    # This ensures that when we process vouchers starting on 'day', \n    # all vouchers ending on 'day' or earlier have already updated min_cost_for_duration.\n    events.sort()\n\n    min_total_cost = float('inf')\n\n    for day, event_type, other_coord, cost, duration_val in events:\n        if event_type == 0:  # This is an 'end' event (r_k, 0, l_k, cost_k, D_k)\n            # A voucher ending on 'day' (which is r_k) becomes available.\n            # Update the minimum cost for its duration.\n            min_cost_for_duration[duration_val] = min(min_cost_for_duration[duration_val], cost)\n        else:  # This is a 'start' event (l_i, 1, r_i, cost_i, D_i)\n            # We are considering voucher 'i' starting on 'day' (which is l_i).\n            # We need to find a voucher 'j' such that:\n            # 1. D_j = x - D_i\n            # 2. r_j < l_i (voucher j ends before voucher i starts)\n            # The min_cost_for_duration array already stores costs for vouchers that have ended.\n            \n            required_duration_for_j = x - duration_val\n            \n            # Check if required_duration_for_j is valid (positive and within bounds)\n            if 1 <= required_duration_for_j <= MAX_COORD:\n                # If a voucher 'j' with required_duration_for_j has been found\n                # (i.e., its 'end' event was processed), its cost would be in the array.\n                if min_cost_for_duration[required_duration_for_j] != float('inf'):\n                    current_pair_cost = cost + min_cost_for_duration[required_duration_for_j]\n                    min_total_cost = min(min_total_cost, current_pair_cost)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(f\"{min_total_cost}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 3998,
        "thoughts_token_count": 713
    }
}