{
    "start": 1758293721.9504013,
    "end": 1758293737.25595,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He takes the highest available a_i and highest available b_j.\n    # To maximize his rank, other people should get low scores.\n    # The best rank is 1 if Vasya can achieve a score that is strictly greater than or equal to\n    # all other possible (n-1) pairings.\n    # This is always 1 because Vasya can pick the largest a_i and largest b_j such that a_i + b_j >= x.\n    # The problem statement guarantees Vasya was present and can achieve at least x points.\n    # The maximum possible score any participant can get is max(a) + max(b). Vasya can achieve this.\n    # If he achieves this, no one can get a higher score. So his best rank is always 1.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but still >= x.\n    # Other participants want to maximize their scores.\n    # We want to find a pairing of a and b such that Vasya gets a score >= x,\n    # and as many other people as possible get scores >= Vasya's score.\n\n    # To find the worst rank, we want to maximize the number of people who can score\n    # higher than or equal to Vasya's score.\n    # Vasya's score is some a_i + b_j >= x.\n    # The other n-1 participants are paired from the remaining n-1 'a' scores and n-1 'b' scores.\n\n    # We can use a two-pointer approach or sort and count.\n    # Let's sort array `a` in ascending order and `b` in descending order.\n    # This way, if we pair a[i] with b[i], we are trying to maximize the sum for each person\n    # if we were to pair them greedily.\n\n    # Let's count how many people can get a score >= S for a given S.\n    # If Vasya gets score S, his rank will be (1 + count_people_with_score_greater_than_S + count_people_with_score_equal_to_S_and_jury_puts_them_ahead_of_Vasya).\n    # To find the worst rank, we assume the jury puts all participants with the same score as Vasya ahead of him.\n    # So, the worst rank is 1 + (number of participants with score > Vasya's score) + (number of participants with score == Vasya's score).\n\n    # Consider all possible pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Vasya takes one such pair. The remaining n-1 'a's and n-1 'b's are paired up.\n    # We want to find a Vasya's pair (a_v, b_v) such that the number of other participants\n    # whose scores are >= (a_v + b_v) is maximized.\n\n    # This is equivalent to finding the minimum possible score Vasya could have gotten\n    # while still satisfying a_i + b_j >= x, and then counting how many other people\n    # can achieve a score greater than or equal to that minimum Vasya score.\n\n    # Let's try to match participants greedily to maximize the number of pairs that sum up to >= x.\n    # Sort `a` in ascending order and `b` in ascending order.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This is a standard problem. Sort one array (say `a` ascending) and the other (`b` descending).\n    # Then iterate through `a`. For each `a_i`, find the smallest `b_j` such that `a_i + b_j >= x`.\n    # This is not quite right. We need to find the number of pairs (a_i, b_j) from the *two* sets\n    # such that a_i + b_j >= x, where each a_i and b_j is used exactly once.\n\n    # This can be solved by sorting `a` and `b` and using a two-pointer approach.\n    # Sort `a` in ascending order.\n    # Sort `b` in ascending order.\n\n    # Let's count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= x.\n    # We want to find the maximum number of such pairs, say `k`.\n    # If `k` pairs can be formed, then Vasya could be one of these `k` participants.\n    # The worst rank for Vasya would be `n - k + 1`.\n    # Why? Because if `k` pairs can achieve >= x, Vasya is one of them.\n    # The remaining `n-k` pairs will have scores < x.\n    # If Vasya is one of the `k` participants, and the jury puts him last among them,\n    # his rank would be `k`.\n    # But this assumes we are trying to maximize the number of people who get >= x.\n\n    # Let's re-think.\n    # We need to find the maximum number of people who can achieve a score S such that S >= x.\n    # Let `a` be sorted ascending. Let `b` be sorted ascending.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x,\n    # where each a_i and b_j is used at most once. This is a maximum bipartite matching problem,\n    # but with a specific sum condition.\n    # A greedy approach works:\n    # Sort `a` ascending. Sort `b` descending.\n    # Use two pointers, `i` for `a` (from left) and `j` for `b` (from left).\n    # If `a[i] + b[j] >= x`, then we can form a pair. Increment count, `i++`, `j++`.\n    # If `a[i] + b[j] < x`, then `a[i]` is too small to pair with `b[j]`.\n    # Since `b` is sorted descending, `b[j]` is the largest available `b`.\n    # If `a[i]` cannot form a pair with `b[j]`, it cannot form a pair with any `b_k` where `k > j`.\n    # So `a[i]` cannot be part of any pair that sums to >= x with the remaining `b`s.\n    # Therefore, we must discard `a[i]` and try `a[i+1]`. So `i++`.\n    # This greedy approach counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n\n    # Let's apply this:\n    # `a` is already sorted ascending.\n    b.sort(reverse=True) # Sort b descending.\n\n    count_valid_pairs = 0\n    i = 0 # pointer for a\n    j = 0 # pointer for b\n\n    while i < n and j < n:\n        if a[i] + b[j] >= x:\n            count_valid_pairs += 1\n            i += 1\n            j += 1\n        else:\n            # a[i] is too small to pair with b[j] (the largest remaining b).\n            # It cannot pair with any other remaining b's either.\n            # So, a[i] cannot be part of a valid pair.\n            i += 1\n\n    # `count_valid_pairs` is the maximum number of participants who can achieve a score >= x.\n    # Vasya is guaranteed to be one of them (as per problem statement).\n    # In the worst case, all `count_valid_pairs - 1` other participants who also scored >= x\n    # are placed ahead of Vasya.\n    # So Vasya's worst rank would be `count_valid_pairs`.\n    worst_rank = count_valid_pairs\n\n    print(best_rank, worst_rank)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He takes the highest available a_i and highest available b_j.\n    # To maximize his rank, other people should get low scores.\n    # The best rank is 1 if Vasya can achieve a score that is strictly greater than or equal to\n    # all other possible (n-1) pairings.\n    # This is always 1 because Vasya can pick the largest a_i and largest b_j such that a_i + b_j >= x.\n    # The problem statement guarantees Vasya was present and can achieve at least x points.\n    # The maximum possible score any participant can get is max(a) + max(b). Vasya can achieve this.\n    # If he achieves this, no one can get a higher score. So his best rank is always 1.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but still >= x.\n    # Other participants want to maximize their scores.\n    # We want to find a pairing of a and b such that Vasya gets a score >= x,\n    # and as many other people as possible get scores >= Vasya's score.\n\n    # To find the worst rank, we want to maximize the number of people who can score\n    # higher than or equal to Vasya's score.\n    # Vasya's score is some a_i + b_j >= x.\n    # The other n-1 participants are paired from the remaining n-1 'a' scores and n-1 'b' scores.\n\n    # We can use a two-pointer approach or sort and count.\n    # Let's sort array `a` in ascending order and `b` in descending order.\n    # This way, if we pair a[i] with b[i], we are trying to maximize the sum for each person\n    # if we were to pair them greedily.\n\n    # Let's count how many people can get a score >= S for a given S.\n    # If Vasya gets score S, his rank will be (1 + count_people_with_score_greater_than_S + count_people_with_score_equal_to_S_and_jury_puts_them_ahead_of_Vasya).\n    # To find the worst rank, we assume the jury puts all participants with the same score as Vasya ahead of him.\n    # So, the worst rank is 1 + (number of participants with score > Vasya's score) + (number of participants with score == Vasya's score).\n\n    # Consider all possible pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Vasya takes one such pair. The remaining n-1 'a's and n-1 'b's are paired up.\n    # We want to find a Vasya's pair (a_v, b_v) such that the number of other participants\n    # whose scores are >= (a_v + b_v) is maximized.\n\n    # This is equivalent to finding the minimum possible score Vasya could have gotten\n    # while still satisfying a_i + b_j >= x, and then counting how many other people\n    # can achieve a score greater than or equal to that minimum Vasya score.\n\n    # Let's try to match participants greedily to maximize the number of pairs that sum up to >= x.\n    # Sort `a` in ascending order and `b` in ascending order.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This is a standard problem. Sort one array (say `a` ascending) and the other (`b` descending).\n    # Then iterate through `a`. For each `a_i`, find the smallest `b_j` such that `a_i + b_j >= x`.\n    # This is not quite right. We need to find the number of pairs (a_i, b_j) from the *two* sets\n    # such that a_i + b_j >= x, where each a_i and b_j is used exactly once.\n\n    # This can be solved by sorting `a` and `b` and using a two-pointer approach.\n    # Sort `a` in ascending order.\n    # Sort `b` in ascending order.\n\n    # Let's count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= x.\n    # We want to find the maximum number of such pairs, say `k`.\n    # If `k` pairs can be formed, then Vasya could be one of these `k` participants.\n    # The worst rank for Vasya would be `n - k + 1`.\n    # Why? Because if `k` pairs can achieve >= x, Vasya is one of them.\n    # The remaining `n-k` pairs will have scores < x.\n    # If Vasya is one of the `k` participants, and the jury puts him last among them,\n    # his rank would be `k`.\n    # But this assumes we are trying to maximize the number of people who get >= x.\n\n    # Let's re-think.\n    # We need to find the maximum number of people who can achieve a score S such that S >= x.\n    # Let `a` be sorted ascending. Let `b` be sorted ascending.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x,\n    # where each a_i and b_j is used at most once. This is a maximum bipartite matching problem,\n    # but with a specific sum condition.\n    # A greedy approach works:\n    # Sort `a` ascending. Sort `b` descending.\n    # Use two pointers, `i` for `a` (from left) and `j` for `b` (from left).\n    # If `a[i] + b[j] >= x`, then we can form a pair. Increment count, `i++`, `j++`.\n    # If `a[i] + b[j] < x`, then `a[i]` is too small to pair with `b[j]`.\n    # Since `b` is sorted descending, `b[j]` is the largest available `b`.\n    # If `a[i]` cannot form a pair with `b[j]`, it cannot form a pair with any `b_k` where `k > j`.\n    # So `a[i]` cannot be part of any pair that sums to >= x with the remaining `b`s.\n    # Therefore, we must discard `a[i]` and try `a[i+1]`. So `i++`.\n    # This greedy approach counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n\n    # Let's apply this:\n    # `a` is already sorted ascending.\n    b.sort(reverse=True) # Sort b descending.\n\n    count_valid_pairs = 0\n    i = 0 # pointer for a\n    j = 0 # pointer for b\n\n    while i < n and j < n:\n        if a[i] + b[j] >= x:\n            count_valid_pairs += 1\n            i += 1\n            j += 1\n        else:\n            # a[i] is too small to pair with b[j] (the largest remaining b).\n            # It cannot pair with any other remaining b's either.\n            # So, a[i] cannot be part of a valid pair.\n            i += 1\n\n    # `count_valid_pairs` is the maximum number of participants who can achieve a score >= x.\n    # Vasya is guaranteed to be one of them (as per problem statement).\n    # In the worst case, all `count_valid_pairs - 1` other participants who also scored >= x\n    # are placed ahead of Vasya.\n    # So Vasya's worst rank would be `count_valid_pairs`.\n    worst_rank = count_valid_pairs\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 863,
        "completion_token_count": 1944,
        "thoughts_token_count": 0
    }
}