{
    "start": 1758294884.2626147,
    "end": 1758294953.007511,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Challenge of Directed Graphs and Reachability**\n\nOkay, so I'm tackling this competitive programming problem involving directed graphs. The core challenge is this: given a target number of \"reachable pairs\" (`p`), I need to figure out the absolute *minimum* number of nodes (`n`) needed to construct a directed graph that meets this reachability requirement. Furthermore, among all graphs with this minimal node count, I need to pinpoint the structure that gives the *maximum* number of unidirectional pairs.\n\nLet's break down the concepts. \"Reachability\" has a special meaning here: two nodes are \"mutually reachable\" if there's a path from one to the other and back, essentially forming a strongly connected component (SCC). The \"p-reachable\" constraint means the graph must contain *exactly* `p` such ordered pairs of mutually reachable nodes, but crucially, only pairs `(u, v)` where `u` comes before `v` in node order count.\n\nTo minimize `n`, I've realized it's all about SCC sizes. Within an SCC of size `k`, there are `k * (k - 1) / 2` reachable pairs. This grows quadratically, so the goal is to make these SCCs as large as possible. If I can, making a single, large SCC is much more efficient at \"achieving\" pairs per node.\n\nMy thought process led to the formula `f(k) = k * (k - 1) / 2`, which describes the number of pairs an SCC of size `k` contains. I need to get the sum of `f(k_i)` to be equal to `p`, with each `k_i` representing an SCC size.\n\nTo find the minimum `n`, I'm employing a greedy strategy. Starting with the largest possible SCC size that fits within the given value of `p`, then subtracting this from `p` and repeat, I'm building this minimal configuration. For example, if `p=3`, I put `f(3)=3` in and `n=3`. If I have `p=4`, I pick `f(3)=3` first and then `f(2)=1` second, thus `n=3+2=5`.\n\nCalculating `k` for the `f(k)` which gets closest to `p` means solving the quadratic equation and, in short, `k = floor((1 + sqrt(1 + 8 * current_p)) / 2)`.\n\nNow, to maximize unidirectional pairs, I have to consider the arrangement of SCCs. For maximum unidirectionality, these SCCs need to form a straight line. If SCCs are ordered as `A -> B -> C`, a node in `A` can reach a node in `B` or `C`, but it cannot return from `C` to `A`, for example. The unidirectional pairs between the SCCs, and maximizing their amount, is all that matters here.\n\nThis gives a pattern: for SCCs ordered as `C_1 -> C_2 -> ... -> C_m`, a node in `C_i` can reach all nodes in SCCs after it (`C_{i+1}`, `C_{i+2}`, etc.). Thus, total unidirectional pairs is `sum_{i=1}^{m-1} k_i * (sum_{j=i+1}^m k_j)`.\n\nThe final `U_max` calculation sums `k * current_sum_of_nodes` (where `k` is an SCC size and `current_sum_of_nodes` are the number of nodes in SCCs that can be reached from that `k`), iterating from the SCC at the back of the chain. This gives the optimal solution.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n_min` required to create a directed graph with exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n2. Among all such graphs with `n_min` nodes, the maximum possible number of unidirectional pairs. An ordered pair `(u, v)` is unidirectional if `u \\neq v`, there is a path from `u` to `v`, and there is no path from `v` to `u`.\n\nLet's break down the concepts:\n\n**Reachability and `p`-reachable pairs:**\nTwo nodes `u` and `v` are reachable from each other if and only if they belong to the same strongly connected component (SCC). If an SCC has `k` nodes, any two distinct nodes `u, v` within this SCC are mutually reachable. The number of such unordered pairs `{u, v}` is `k * (k - 1) / 2`. Each such unordered pair corresponds to exactly one ordered pair `(u, v)` with `u < v` that satisfies the condition.\nTherefore, if a graph has SCCs of sizes `k_1, k_2, ..., k_m`, the total number of `p`-reachable pairs `(u, v)` with `u < v` is `P = \\sum_{i=1}^m \\frac{k_i(k_i-1)}{2}`. The total number of nodes in the graph is `N = \\sum_{i=1}^m k_i`.\n\n**Goal 1: Minimum number of nodes `n_min` for a given `p`.**\nWe want to minimize `N = \\sum k_i` subject to `P = \\sum \\frac{k_i(k_i-1)}{2} = p`.\nLet `f(k) = k(k-1)/2`. This function represents the number of `p`-reachable pairs contributed by an SCC of size `k`.\nThe ratio `f(k)/k = (k-1)/2` is an increasing function for `k \\ge 1`. This means that larger SCCs are more \"efficient\" in terms of pairs generated per node. For example, an SCC of size 4 generates `4(3)/2 = 6` pairs using 4 nodes, while two SCCs of size 2 generate `2 * (2(1)/2) = 2` pairs using 4 nodes.\nThis property suggests a greedy approach: to minimize the total number of nodes for a given `p`, we should use the largest possible SCC sizes at each step.\n\nAlgorithm for `n_min`:\n1. Initialize `n_min = 0` and `current_p = p`.\n2. Initialize an empty list `scc_sizes` to store the sizes of SCCs chosen.\n3. While `current_p > 0`:\n    a. Find the largest integer `k \\ge 2` such that `k(k-1)/2 \\le current_p`. We need `k \\ge 2` because `f(0)=f(1)=0`, so SCCs of size 0 or 1 don't contribute any pairs.\n    b. The value of `k` can be found by solving the quadratic inequality `k^2 - k - 2 * current_p \\le 0`. The positive root of `k^2 - k - 2 * current_p = 0` is `(1 + \\sqrt{1 + 8 * current_p}) / 2`. So, `k = \\lfloor (1 + \\sqrt{1 + 8 * current_p}) / 2 \\rfloor`.\n    c. If `k < 2` (which can happen if `current_p` is 0 or 1), we should ensure `k` is at least 2 if `current_p > 0`. However, the loop condition `current_p > 0` and the formula for `k` will naturally yield `k \\ge 2` if `current_p \\ge 1`. If `current_p = 0`, the loop terminates. If `current_p = 1`, `k = \\lfloor (1 + \\sqrt{9}) / 2 \\rfloor = 2`.\n    d. Subtract `f(k)` from `current_p`: `current_p -= k(k-1)/2`.\n    e. Add `k` to `n_min`: `n_min += k`.\n    f. Add `k` to `scc_sizes`.\n\n**Goal 2: Maximum number of unidirectional pairs `U_max` with `n_min` nodes.**\nA pair `(u, v)` is unidirectional if `u` can reach `v` but `v` cannot reach `u`. This means `u` and `v` must be in different SCCs, say `u \\in C_A` and `v \\in C_B`, and there is a path from `C_A` to `C_B` in the condensation graph (DAG of SCCs), but no path from `C_B` to `C_A`.\nTo maximize unidirectional pairs, we should arrange the SCCs in a linear chain, for example, `C_1 \\to C_2 \\to \\dots \\to C_m`. This can be achieved by adding a single edge from an arbitrary node in `C_i` to an arbitrary node in `C_{i+1}` for all `i = 1, \\dots, m-1`.\nIn this configuration, any node in `C_i` can reach any node in `C_j` if `i < j`. The number of unidirectional pairs for such a structure is `\\sum_{1 \\le i < j \\le m} k_i k_j`.\nThis sum can be computed efficiently. Let the list of SCC sizes be `[k_1, k_2, \\dots, k_m]`.\n`U_max = k_1(k_2 + \\dots + k_m) + k_2(k_3 + \\dots + k_m) + \\dots + k_{m-1}k_m`.\nWe can calculate this by iterating through `scc_sizes` (obtained from the previous step) in reverse:\n1. Initialize `U_max = 0` and `current_sum_of_nodes_for_unidirectional = 0`.\n2. For each `k_val` in `scc_sizes` (iterating from the last element to the first):\n    a. `U_max += k_val * current_sum_of_nodes_for_unidirectional`.\n    b. `current_sum_of_nodes_for_unidirectional += k_val`.\n\n**Example Walkthrough:**\nLet `p = 4`.\n**1. Calculate `n_min`:**\n   - `current_p = 4`, `n_min = 0`, `scc_sizes = []`.\n   - Loop 1:\n     - `k = \\lfloor (1 + \\sqrt{1 + 8 \\cdot 4}) / 2 \\rfloor = \\lfloor (1 + \\sqrt{33}) / 2 \\rfloor = \\lfloor (1 + 5.74) / 2 \\rfloor = \\lfloor 3.37 \\rfloor = 3`.\n     - `f(3) = 3(2)/2 = 3`.\n     - `current_p = 4 - 3 = 1`.\n     - `n_min = 0 + 3 = 3`.\n     - `scc_sizes = [3]`.\n   - Loop 2:\n     - `current_p = 1`.\n     - `k = \\lfloor (1 + \\sqrt{1 + 8 \\cdot 1}) / 2 \\rfloor = \\lfloor (1 + \\sqrt{9}) / 2 \\rfloor = \\lfloor (1 + 3) / 2 \\rfloor = 2`.\n     - `f(2) = 2(1)/2 = 1`.\n     - `current_p = 1 - 1 = 0`.\n     - `n_min = 3 + 2 = 5`.\n     - `scc_sizes = [3, 2]`.\n   - Loop terminates as `current_p = 0`.\n   - So, `n_min = 5`.\n\n**2. Calculate `U_max`:**\n   - `scc_sizes = [3, 2]`.\n   - `U_max = 0`, `current_sum_of_nodes_for_unidirectional = 0`.\n   - Iterate `k_val` in `reversed([3, 2])`, so `k_val` will be `2` then `3`.\n   - `k_val = 2`:\n     - `U_max += 2 * 0 = 0`.\n     - `current_sum_of_nodes_for_unidirectional = 0 + 2 = 2`.\n   - `k_val = 3`:\n     - `U_max += 3 * 2 = 6`.\n     - `current_sum_of_nodes_for_unidirectional = 2 + 3 = 5`.\n   - Final `U_max = 6`.\n\nOutput for `p=4` is `5 6`, which matches the example.\n\n**Constraints:**\n`p` up to `2 \\cdot 10^5`.\n`1 + 8 \\cdot p` can be up to `1 + 8 \\cdot 2 \\cdot 10^5 = 1.6 \\cdot 10^6 + 1`.\n`\\sqrt{1.6 \\cdot 10^6}` is approximately `1265`. So `k` will be at most around `633`.\nThe number of iterations in the `n_min` calculation loop is small (at most `p` if `k` is always 2, but `k` grows as `\\sqrt{p}`, so it's much faster, roughly `O(\\sqrt{p})` or `O(\\log p)`).\nThe `scc_sizes` list will have at most `p` elements (when `k` is always 2).\nThe `U_max` calculation loop runs `len(scc_sizes)` times.\nThe maximum `n_min` can be `2p` (when `k` is always 2, e.g., for `p=2 \\cdot 10^5`, `n_min = 4 \\cdot 10^5`).\nThe maximum `U_max` can be `2p(p-1)` (when `k` is always 2), which is roughly `2(2 \\cdot 10^5)^2 = 8 \\cdot 10^{10}`. This fits in standard integer types in Python.\n\nThe solution is efficient enough.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    n_min = 0\n    scc_sizes = []\n    current_p = p\n\n    while current_p > 0:\n        # Find the largest integer k >= 2 such that k*(k-1)/2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Roots of k^2 - k - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We need k <= (1 + sqrt(1 + 8*current_p)) / 2\n        k = int((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        \n        # Ensure k is at least 2, as f(0)=f(1)=0 and we need to reduce current_p\n        # For current_p >= 1, the formula yields k >= 2.\n        # If current_p = 0, the loop condition handles it.\n        # If current_p = 1, k = int((1 + sqrt(9))/2) = 2.\n        # So k will always be >= 2 here if current_p > 0.\n\n        f_k = k * (k - 1) // 2\n        current_p -= f_k\n        n_min += k\n        scc_sizes.append(k)\n\n    U_max = 0\n    # To maximize unidirectional pairs, arrange SCCs in a linear chain: C_1 -> C_2 -> ... -> C_m\n    # The number of unidirectional pairs is sum_{1 <= i < j <= m} k_i * k_j\n    # This can be calculated efficiently by iterating through scc_sizes in reverse.\n    # If scc_sizes = [k_1, k_2, ..., k_m], iterating in reverse means processing k_m, then k_{m-1}, etc.\n    # current_sum_of_nodes_for_unidirectional will accumulate sum from the \"right\" of the chain.\n    # E.g., for [k_1, k_2, k_3]:\n    # k_3: U_max += k_3 * 0; current_sum = k_3\n    # k_2: U_max += k_2 * k_3; current_sum = k_2 + k_3\n    # k_1: U_max += k_1 * (k_2 + k_3); current_sum = k_1 + k_2 + k_3\n    # Total U_max = k_2*k_3 + k_1*(k_2+k_3) = k_1*k_2 + k_1*k_3 + k_2*k_3. This is correct.\n    \n    current_sum_of_nodes_for_unidirectional = 0\n    for k_val in reversed(scc_sizes):\n        U_max += k_val * current_sum_of_nodes_for_unidirectional\n        current_sum_of_nodes_for_unidirectional += k_val\n\n    print(n_min, U_max)\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    n_min = 0\n    scc_sizes = []\n    current_p = p\n\n    while current_p > 0:\n        # Find the largest integer k >= 2 such that k*(k-1)/2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Roots of k^2 - k - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We need k <= (1 + sqrt(1 + 8*current_p)) / 2\n        k = int((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        \n        # Ensure k is at least 2, as f(0)=f(1)=0 and we need to reduce current_p\n        # For current_p >= 1, the formula yields k >= 2.\n        # If current_p = 0, the loop condition handles it.\n        # If current_p = 1, k = int((1 + sqrt(9))/2) = 2.\n        # So k will always be >= 2 here if current_p > 0.\n\n        f_k = k * (k - 1) // 2\n        current_p -= f_k\n        n_min += k\n        scc_sizes.append(k)\n\n    U_max = 0\n    # To maximize unidirectional pairs, arrange SCCs in a linear chain: C_1 -> C_2 -> ... -> C_m\n    # The number of unidirectional pairs is sum_{1 <= i < j <= m} k_i * k_j\n    # This can be calculated efficiently by iterating through scc_sizes in reverse.\n    # If scc_sizes = [k_1, k_2, ..., k_m], iterating in reverse means processing k_m, then k_{m-1}, etc.\n    # current_sum_of_nodes_for_unidirectional will accumulate sum from the \"right\" of the chain.\n    # E.g., for [k_1, k_2, k_3]:\n    # k_3: U_max += k_3 * 0; current_sum = k_3\n    # k_2: U_max += k_2 * k_3; current_sum = k_2 + k_3\n    # k_1: U_max += k_1 * (k_2 + k_3); current_sum = k_1 + k_2 + k_3\n    # Total U_max = k_2*k_3 + k_1*(k_2+k_3) = k_1*k_2 + k_1*k_3 + k_2*k_3. This is correct.\n    \n    current_sum_of_nodes_for_unidirectional = 0\n    for k_val in reversed(scc_sizes):\n        U_max += k_val * current_sum_of_nodes_for_unidirectional\n        current_sum_of_nodes_for_unidirectional += k_val\n\n    print(n_min, U_max)\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 3227,
        "thoughts_token_count": 7058
    }
}