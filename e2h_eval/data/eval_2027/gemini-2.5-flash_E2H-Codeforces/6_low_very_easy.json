{
    "start": 1758009285.5188677,
    "end": 1758009311.5463176,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**My Approach to the Voucher Problem**\n\nOkay, so I've got this competitive programming problem on my hands, and it's asking me to find a specific pair of vouchers. The goal is to identify two distinct, \"disjoint\" vouchers, let's call them `i` and `j`, whose durations add up precisely to a given value, `x`.  But here's the kicker: I need to minimize the combined cost of these two vouchers, `cost_i + cost_j`. If no such pair exists, I need to report -1.\n\nMy initial thoughts are, let's break this down. There are several key conditions: two vouchers, `i` and `j` where i≠j, they need to be disjoint, which means their time ranges can't overlap, and their durations must sum to x. Also, the sum of their costs has to be minimal. The constraints are `n, x <= 2 * 10^5`, `l_i, r_i <= 2 * 10^5`, and `cost_i <= 10^9`.\n\nA brute-force approach, checking every possible pair, would be a disastrous O(N^2) operation. That's a no-go with this input size. I need something more efficient, aiming for O(N log N) or ideally O(N).\n\nThe critical aspect here is the disjoint condition.  Fixing one voucher, say `i`, I can then focus on finding a suitable `j` that satisfies the criteria. It needs to have a duration of `x - duration_i`, be disjoint from `i`, and, among all such `j`s, have the lowest cost.\n \nI'm thinking sorting might be helpful. If I sort the vouchers based on their start (`l_i`) or end (`r_i`) times, that could provide a more structured way to check for disjointness and efficiently search for matching durations. Let's call the duration of voucher `k`, `D_k`. We require `D_i + D_j = x`.\n\nLet's assume the maximum coordinate is `MAX_COORD = 2 * 10^5`. The duration, `D_k`, can vary from 1 up to `MAX_COORD`.\n\nMy main thought is to pre-process the vouchers. For each possible duration, `d`, between 1 and x-1, I want to find the minimal cost voucher that has that duration and its time interval either starts after a certain point or ends before another.\nI can try iterating through possible `r_i` values. For each `r_i`, I am looking for a `j` where `l_j > r_i` and the duration `D_j = x - D_i` with minimum cost.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    # Sort vouchers by their start time (l_i) for the first pass\n    # and by their end time (r_i) for the second pass.\n    # It's easier to just store them and process.\n\n    # Max coordinate value for l_i or r_i is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # min_cost_for_duration_ending_at[d][end_day] stores the minimum cost\n    # of a voucher with duration 'd' that ends on 'end_day'.\n    # We only need to store the minimum cost for each duration at each end_day.\n    # However, we're looking for min cost for a duration up to a certain end_day,\n    # or starting after a certain start_day.\n\n    # Let's group vouchers by their start day and end day.\n    # vouchers_by_start[s_day] will contain a list of (r, duration, cost) for vouchers starting on s_day.\n    # vouchers_by_end[e_day] will contain a list of (l, duration, cost) for vouchers ending on e_day.\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration < x: # Only consider durations less than x\n            vouchers_by_start[l].append((r, duration, cost))\n            vouchers_by_end[r].append((l, duration, cost))\n\n    # Initialize minimum cost to a very large value\n    min_total_cost = float('inf')\n\n    # This array will store the minimum cost for a voucher of a specific duration\n    # that ends *up to* the current day being processed.\n    # min_cost_duration_ending_before[d] = min_cost for a voucher of duration d\n    # that ends at or before current_day.\n    # Initialize with infinity\n    min_cost_duration_ending_before = [float('inf')] * (x + 1)\n\n    # Iterate through days from 1 to MAX_COORD\n    # In this loop, 'd' represents the current day.\n    # We are processing vouchers that end on 'd' (for future use)\n    # and vouchers that start on 'd' (to find a pair with previously processed vouchers).\n    for current_day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that *end* on `current_day`.\n        # These vouchers become available for pairing with vouchers that start *after* `current_day`.\n        # We update `min_cost_duration_ending_before` for these.\n        # For each voucher (l, r, cost) where r == current_day:\n        #   duration = r - l + 1\n        #   min_cost_duration_ending_before[duration] = min(min_cost_duration_ending_before[duration], cost)\n        # Note: This is not quite right. `min_cost_duration_ending_before` should be cumulative.\n        # It should store the minimum cost for a voucher of a specific duration seen so far (ending <= current_day).\n        # To make it cumulative, we update it *after* processing `current_day`'s start vouchers.\n\n        # Let's use `min_cost_for_duration[d]` to store the minimum cost of a voucher\n        # that has duration `d` and has *already ended* (i.e., `r < current_day`).\n        # This will be updated for vouchers ending on `current_day - 1`.\n        # We need to consider vouchers ending on `current_day - 1` to pair with vouchers starting on `current_day`.\n        # So, the `min_cost_for_duration` array should reflect the state *before* `current_day`.\n\n        # Let's rethink. We want to find a pair (i, j) such that r_i < l_j.\n        # Iterate `l_j` from 1 to MAX_COORD.\n        # When processing `l_j`, we need to find a voucher `i` such that `r_i < l_j`.\n        # The `min_cost_for_duration[d]` array should store the minimum cost of a voucher\n        # with duration `d` that has `r_i < l_j`.\n\n        # Let's use `min_cost_for_prev_duration[duration]` to store the minimum cost\n        # of a voucher of `duration` that has ended *before* `current_day`.\n        # This array will be updated as `current_day` increments.\n        \n        # `min_cost_for_prev_duration[d]` will store the minimum cost of a voucher\n        # with duration `d` that satisfies `r < current_day`.\n        # Initialize with infinity.\n        min_cost_for_prev_duration = [float('inf')] * (x + 1)\n\n        # Iterate `current_day` from 1 to MAX_COORD\n        for current_day in range(1, MAX_COORD + 1):\n            # First, consider vouchers that *start* on `current_day`.\n            # For each such voucher `j` = (l_j, r_j, cost_j):\n            #   duration_j = r_j - l_j + 1\n            #   required_duration_i = x - duration_j\n            #   If `required_duration_i` is valid (1 <= `required_duration_i` < x):\n            #     We need to find a voucher `i` that ended before `current_day` (i.e., `r_i < current_day`)\n            #     and has `duration_i = required_duration_i`.\n            #     The minimum cost for such a voucher `i` is stored in `min_cost_for_prev_duration[required_duration_i]`.\n            #     If `min_cost_for_prev_duration[required_duration_i]` is not infinity,\n            #     we can form a pair with total cost `cost_j + min_cost_for_prev_duration[required_duration_i]`.\n            #     Update `min_total_cost`.\n            for r_j, duration_j, cost_j in vouchers_by_start[current_day]:\n                required_duration_i = x - duration_j\n                if 1 <= required_duration_i < x:\n                    if min_cost_for_prev_duration[required_duration_i] != float('inf'):\n                        min_total_cost = min(min_total_cost, cost_j + min_cost_for_prev_duration[required_duration_i])\n\n            # Second, consider vouchers that *end* on `current_day`.\n            # These vouchers become available for pairing with vouchers that start *after* `current_day`.\n            # Update `min_cost_for_prev_duration` for the next iteration (current_day + 1).\n            # For each voucher `i` = (l_i, r_i, cost_i) where `r_i == current_day`:\n            #   duration_i = r_i - l_i + 1\n            #   Update `min_cost_for_prev_duration[duration_i]` with `cost_i`.\n            #   This means for any future `current_day'` > `current_day`,\n            #   we can find a voucher of `duration_i` with `cost_i` that ends before `current_day'`.\n            for l_i, duration_i, cost_i in vouchers_by_end[current_day]:\n                min_cost_for_prev_duration[duration_i] = min(min_cost_for_prev_duration[duration_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    # Sort vouchers by their start time (l_i) for the first pass\n    # and by their end time (r_i) for the second pass.\n    # It's easier to just store them and process.\n\n    # Max coordinate value for l_i or r_i is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # min_cost_for_duration_ending_at[d][end_day] stores the minimum cost\n    # of a voucher with duration 'd' that ends on 'end_day'.\n    # We only need to store the minimum cost for each duration at each end_day.\n    # However, we're looking for min cost for a duration up to a certain end_day,\n    # or starting after a certain start_day.\n\n    # Let's group vouchers by their start day and end day.\n    # vouchers_by_start[s_day] will contain a list of (r, duration, cost) for vouchers starting on s_day.\n    # vouchers_by_end[e_day] will contain a list of (l, duration, cost) for vouchers ending on e_day.\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration < x: # Only consider durations less than x\n            vouchers_by_start[l].append((r, duration, cost))\n            vouchers_by_end[r].append((l, duration, cost))\n\n    # Initialize minimum cost to a very large value\n    min_total_cost = float('inf')\n\n    # This array will store the minimum cost for a voucher of a specific duration\n    # that ends *up to* the current day being processed.\n    # min_cost_duration_ending_before[d] = min_cost for a voucher of duration d\n    # that ends at or before current_day.\n    # Initialize with infinity\n    min_cost_duration_ending_before = [float('inf')] * (x + 1)\n\n    # Iterate through days from 1 to MAX_COORD\n    # In this loop, 'd' represents the current day.\n    # We are processing vouchers that end on 'd' (for future use)\n    # and vouchers that start on 'd' (to find a pair with previously processed vouchers).\n    for current_day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that *end* on `current_day`.\n        # These vouchers become available for pairing with vouchers that start *after* `current_day`.\n        # We update `min_cost_duration_ending_before` for these.\n        # For each voucher (l, r, cost) where r == current_day:\n        #   duration = r - l + 1\n        #   min_cost_duration_ending_before[duration] = min(min_cost_duration_ending_before[duration], cost)\n        # Note: This is not quite right. `min_cost_duration_ending_before` should be cumulative.\n        # It should store the minimum cost for a voucher of a specific duration seen so far (ending <= current_day).\n        # To make it cumulative, we update it *after* processing `current_day`'s start vouchers.\n\n        # Let's use `min_cost_for_duration[d]` to store the minimum cost of a voucher\n        # that has duration `d` and has *already ended* (i.e., `r < current_day`).\n        # This will be updated for vouchers ending on `current_day - 1`.\n        # We need to consider vouchers ending on `current_day - 1` to pair with vouchers starting on `current_day`.\n        # So, the `min_cost_for_duration` array should reflect the state *before* `current_day`.\n\n        # Let's rethink. We want to find a pair (i, j) such that r_i < l_j.\n        # Iterate `l_j` from 1 to MAX_COORD.\n        # When processing `l_j`, we need to find a voucher `i` such that `r_i < l_j`.\n        # The `min_cost_for_duration[d]` array should store the minimum cost of a voucher\n        # with duration `d` that has `r_i < l_j`.\n\n        # Let's use `min_cost_for_prev_duration[duration]` to store the minimum cost\n        # of a voucher of `duration` that has ended *before* `current_day`.\n        # This array will be updated as `current_day` increments.\n        \n        # `min_cost_for_prev_duration[d]` will store the minimum cost of a voucher\n        # with duration `d` that satisfies `r < current_day`.\n        # Initialize with infinity.\n        min_cost_for_prev_duration = [float('inf')] * (x + 1)\n\n        # Iterate `current_day` from 1 to MAX_COORD\n        for current_day in range(1, MAX_COORD + 1):\n            # First, consider vouchers that *start* on `current_day`.\n            # For each such voucher `j` = (l_j, r_j, cost_j):\n            #   duration_j = r_j - l_j + 1\n            #   required_duration_i = x - duration_j\n            #   If `required_duration_i` is valid (1 <= `required_duration_i` < x):\n            #     We need to find a voucher `i` that ended before `current_day` (i.e., `r_i < current_day`)\n            #     and has `duration_i = required_duration_i`.\n            #     The minimum cost for such a voucher `i` is stored in `min_cost_for_prev_duration[required_duration_i]`.\n            #     If `min_cost_for_prev_duration[required_duration_i]` is not infinity,\n            #     we can form a pair with total cost `cost_j + min_cost_for_prev_duration[required_duration_i]`.\n            #     Update `min_total_cost`.\n            for r_j, duration_j, cost_j in vouchers_by_start[current_day]:\n                required_duration_i = x - duration_j\n                if 1 <= required_duration_i < x:\n                    if min_cost_for_prev_duration[required_duration_i] != float('inf'):\n                        min_total_cost = min(min_total_cost, cost_j + min_cost_for_prev_duration[required_duration_i])\n\n            # Second, consider vouchers that *end* on `current_day`.\n            # These vouchers become available for pairing with vouchers that start *after* `current_day`.\n            # Update `min_cost_for_prev_duration` for the next iteration (current_day + 1).\n            # For each voucher `i` = (l_i, r_i, cost_i) where `r_i == current_day`:\n            #   duration_i = r_i - l_i + 1\n            #   Update `min_cost_for_prev_duration[duration_i]` with `cost_i`.\n            #   This means for any future `current_day'` > `current_day`,\n            #   we can find a voucher of `duration_i` with `cost_i` that ends before `current_day'`.\n            for l_i, duration_i, cost_i in vouchers_by_end[current_day]:\n                min_cost_for_prev_duration[duration_i] = min(min_cost_for_prev_duration[duration_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 1967,
        "thoughts_token_count": 814
    }
}