{
    "start": 1758294938.352449,
    "end": 1758295002.8078682,
    "start-formatted": "2025-09-20 00:15 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Okay, let's break down this competitive programming problem and my thought process.**  The core challenge is finding the smallest number of nodes (N) needed in a directed graph to have a specific number (p) of reachable node pairs, where a pair (u, v) is counted if u < v and u and v are reachable from each other.  Additionally, among all graphs with this minimal N, we need to maximize the number of *unidirectional* node pairs (u, v) where there's a path from u to v, but NOT from v to u.\n\nMy first thought is around the concept of Strongly Connected Components (SCCs). Nodes within an SCC are all mutually reachable. The number of reachable pairs is directly related to the sizes of these SCCs. A single SCC of size 's' contributes s * (s - 1) / 2 reachable pairs.  To minimize the total number of nodes (N) while achieving 'p' reachable pairs, I want to use the *largest* possible SCCs.  Since the function s * (s - 1) / 2 is convex. If I split an SCC, I end up with smaller contribution to p. So making SCCs as large as possible is node-efficient.\n\nSo, I formulated an algorithm: iteratively build SCCs by finding the largest SCC size 'k' such that k * (k - 1) / 2 is <= the remaining 'p' pairs.  I can solve for 'k' using the quadratic formula to get k <= (1 + sqrt(1 + 8p)) / 2.  This gives me the nodes required in that SCC.  I then subtract the pairs covered by this SCC (k * (k - 1) / 2) from 'p' and repeat this greedy approach until 'p' becomes zero. This will give me a set of SCC sizes whose sum is 'N', the minimum number of nodes.\n\nNow, to maximize unidirectional pairs.  If I have SCCs with sizes `s_1, s_2, ..., s_m`, the most unidirectional pairs result from a chain-like structure where there are paths from SCC `i` to SCC `j` only if i < j.  In this structure, the number of unidirectional pairs is sum_{i < j} (s_i * s_j). The best approach is to minimize the sum of squares of s_i. The structure of the greedy solution I got already makes it difficult.\n\nThis calculation is simplified by the math - (N^2 - sum(s_i^2)) / 2. Since N is fixed by the earlier algorithm to find the min nodes needed, maximizing the number of unidirectional pairs is equivalent to minimizing the sum of the squares of SCC sizes. While the greedy method prioritizes making SCCs as large as possible, it does not guarantee perfectly uniform SCCs. But given that N and the SCC sizes are fixed by my earlier node count optimization, calculating the unidirectional pairs involves summing these s_i * s_j terms.\n\nThe algorithm to calculate N is efficient because the 'k' value decreases quickly and it takes O(sqrt(p)) time. In general for any p up to 2*10^5, this should take a very small constant number of loops.\n\nIn summary, I'll calculate the minimum N and a decomposition into SCCs using my greedy approach, and then I can calculate the maximum unidirectional pairs based on this fixed decomposition.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `N` required to create a directed graph that has exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n2. Among all such graphs with the minimum `N`, the maximum number of unidirectional pairs of nodes. An ordered pair `(u, v)` is unidirectional if `u \\neq v`, there is a path from `u` to `v`, and no path from `v` to `u`.\n\nLet's break down the concepts:\n\n**Reachability and `p`-reachable graphs:**\nTwo nodes `u` and `v` are mutually reachable if they belong to the same Strongly Connected Component (SCC). If an SCC has `s` nodes, then any two distinct nodes `u, v` within this SCC are mutually reachable. The number of ordered pairs `(u, v)` with `u < v` within an SCC of size `s` is `s * (s - 1) / 2`.\nIf a graph has SCCs of sizes `s_1, s_2, ..., s_m`, the total number of `p`-reachable pairs (as defined in the problem) is `P = sum(s_i * (s_i - 1) / 2)` for `i=1` to `m`.\nThe total number of nodes in the graph is `N = sum(s_i)`.\n\n**Minimizing `N` for a given `p`:**\nTo minimize `N` for a target `p`, we should use SCCs that are as large as possible. This is because the function `f(s) = s * (s - 1) / 2` grows quadratically, meaning larger SCCs are more \"node-efficient\" at generating `p`-reachable pairs. For example, 3 nodes in one SCC generate 3 pairs, while 3 nodes split into a 2-node SCC and a 1-node SCC generate only 1 pair.\nWe can use a greedy strategy:\n1. Initialize `min_N = 0` and `s_values = []` (to store the sizes of SCCs).\n2. While the remaining `p` (let's call it `current_p`) is greater than 0:\n   a. Find the largest integer `k` such that `k * (k - 1) / 2 <= current_p`. This `k` represents the size of the next SCC we will form.\n      The inequality `k * (k - 1) / 2 <= current_p` can be rewritten as `k^2 - k - 2 * current_p <= 0`.\n      Solving `k^2 - k - 2 * current_p = 0` for `k` using the quadratic formula gives `k = (1 +/- sqrt(1 + 8 * current_p)) / 2`. Since `k > 0`, we take the positive root.\n      So, `k = floor((1 + sqrt(1 + 8 * current_p)) / 2)`.\n   b. Add `k` to `min_N`.\n   c. Add `k` to `s_values`.\n   d. Subtract `k * (k - 1) / 2` from `current_p`.\nThis greedy approach ensures that we use the fewest nodes possible to achieve `p`.\n\n**Maximizing unidirectional pairs:**\nA unidirectional pair `(u, v)` means `u` and `v` are in different SCCs, there's a path `u -> v`, but no path `v -> u`.\nTo maximize such pairs, we should arrange the SCCs in a linear chain (a topological sort). For example, if we have SCCs `C_1, C_2, ..., C_m` with sizes `s_1, s_2, ..., s_m`, we can add edges such that there is a path from any node in `C_i` to any node in `C_j` if and only if `i < j`. This can be achieved by adding a single edge from an arbitrary node in `C_i` to an arbitrary node in `C_{i+1}` for all `i=1, ..., m-1`.\nIn this configuration, for any `u` in `C_i` and `v` in `C_j` where `i < j`:\n- There are `s_i` choices for `u` and `s_j` choices for `v`.\n- There is a path `u -> v`.\n- There is no path `v -> u`.\nThus, all `s_i * s_j` such pairs `(u, v)` are unidirectional.\nThe total number of unidirectional pairs is `sum_{1 <= i < j <= m} (s_i * s_j)`.\n\nWe know that `(sum(s_i))^2 = sum(s_i^2) + 2 * sum_{i < j} (s_i * s_j)`.\nSince `sum(s_i) = min_N`, we have `min_N^2 = sum(s_i^2) + 2 * max_unidirectional`.\nTherefore, `max_unidirectional = (min_N^2 - sum(s_i^2)) / 2`.\nThe `s_i` values are determined by the greedy algorithm for `min_N`. We just need to calculate `sum(s_i^2)` from the `s_values` list.\n\n**Example for `p=4`:**\n1. **Find `min_N`:**\n   - `current_p = 4`.\n   - `k = floor((1 + sqrt(1 + 8*4)) / 2) = floor((1 + sqrt(33)) / 2) = floor((1 + 5.74) / 2) = floor(3.37) = 3`.\n   - `min_N = 3`, `s_values = [3]`.\n   - `current_p = 4 - (3 * 2 / 2) = 4 - 3 = 1`.\n   - `current_p = 1`.\n   - `k = floor((1 + sqrt(1 + 8*1)) / 2) = floor((1 + sqrt(9)) / 2) = floor((1 + 3) / 2) = floor(2) = 2`.\n   - `min_N = 3 + 2 = 5`, `s_values = [3, 2]`.\n   - `current_p = 1 - (2 * 1 / 2) = 1 - 1 = 0`.\n   - Loop ends. `min_N = 5`.\n\n2. **Find `max_unidirectional`:**\n   - `s_values = [3, 2]`.\n   - `sum_s_sq = 3^2 + 2^2 = 9 + 4 = 13`.\n   - `max_unidirectional = (min_N^2 - sum_s_sq) / 2 = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\n\nOutput for `p=4` is `5 6`.\n\n**Edge case `p=0`:**\n- `min_N = 0`, `s_values = []`.\n- Loop `while current_p > 0` is not entered.\n- `min_N = 0`.\n- `sum_s_sq = 0`.\n- `max_unidirectional = (0^2 - 0) / 2 = 0`.\nOutput for `p=0` is `0 0`.\n\nThe maximum value of `p` is `2 * 10^5`. The calculations involve square roots and sums of squares, all fitting within standard integer types (Python handles large integers automatically). The number of iterations in the greedy loop is very small (logarithmic with respect to `p`).\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    s_values = []\n    current_p = p\n\n    while current_p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Using quadratic formula for k^2 - k - 2*current_p = 0:\n        # k = (1 + sqrt(1 + 8*current_p)) / 2\n        k = int((1 + math.isqrt(1 + 8 * current_p)) / 2)\n        \n        # In case of floating point inaccuracies or if k*(k-1)/2 slightly exceeds current_p,\n        # ensure k is valid. math.isqrt is for integer square root, which is safer.\n        # However, the formula gives floor, so k*(k-1)/2 should be <= current_p.\n        # A check if k*(k-1)/2 > current_p would reduce k by 1, but it seems not needed with isqrt.\n        # Let's verify k*(k-1)/2 <= current_p\n        if k * (k - 1) // 2 > current_p:\n             k -= 1 # This should not happen with math.isqrt if the formula is correct for floor.\n\n        min_nodes += k\n        s_values.append(k)\n        current_p -= k * (k - 1) // 2\n\n    sum_s_sq = sum(s * s for s in s_values)\n    \n    # max_unidirectional = (min_nodes^2 - sum(s_i^2)) / 2\n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_s_sq) // 2\n\n    print(min_nodes, max_unidirectional_pairs)\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    s_values = []\n    current_p = p\n\n    while current_p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Using quadratic formula for k^2 - k - 2*current_p = 0:\n        # k = (1 + sqrt(1 + 8*current_p)) / 2\n        k = int((1 + math.isqrt(1 + 8 * current_p)) / 2)\n        \n        # In case of floating point inaccuracies or if k*(k-1)/2 slightly exceeds current_p,\n        # ensure k is valid. math.isqrt is for integer square root, which is safer.\n        # However, the formula gives floor, so k*(k-1)/2 should be <= current_p.\n        # A check if k*(k-1)/2 > current_p would reduce k by 1, but it seems not needed with isqrt.\n        # Let's verify k*(k-1)/2 <= current_p\n        if k * (k - 1) // 2 > current_p:\n             k -= 1 # This should not happen with math.isqrt if the formula is correct for floor.\n\n        min_nodes += k\n        s_values.append(k)\n        current_p -= k * (k - 1) // 2\n\n    sum_s_sq = sum(s * s for s in s_values)\n    \n    # max_unidirectional = (min_nodes^2 - sum(s_i^2)) / 2\n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_s_sq) // 2\n\n    print(min_nodes, max_unidirectional_pairs)\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 2309,
        "thoughts_token_count": 6807
    }
}