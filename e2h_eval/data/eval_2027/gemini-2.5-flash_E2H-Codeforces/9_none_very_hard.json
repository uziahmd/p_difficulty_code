{
    "start": 1758011322.6385531,
    "end": 1758011404.4083495,
    "start-formatted": "2025-09-16 17:28 KST",
    "end-formatted": "2025-09-16 17:30 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, m = map(int, input().split())\n\n    items_by_weight = {1: [], 2: [], 3: []}\n    for _ in range(n):\n        w, c = map(int, input().split())\n        items_by_weight[w].append(c)\n\n    for w in items_by_weight:\n        items_by_weight[w].sort(reverse=True)\n\n    prefix_sums = {\n        1: [0] * (len(items_by_weight[1]) + 1),\n        2: [0] * (len(items_by_weight[2]) + 1),\n        3: [0] * (len(items_by_weight[3]) + 1)\n    }\n\n    for w in items_by_weight:\n        for i in range(len(items_by_weight[w])):\n            prefix_sums[w][i+1] = prefix_sums[w][i] + items_by_weight[w][i]\n\n    max_cost = 0\n\n    for count3 in range(len(items_by_weight[3]) + 1):\n        weight3 = count3 * 3\n        cost3 = prefix_sums[3][count3]\n\n        if weight3 > m:\n            break\n\n        remaining_weight = m - weight3\n        current_cost = cost3\n\n        # Option 1: Try to fill remaining_weight with items of weight 1 and 2\n        # Iterate over count2 for items of weight 2\n        best_cost_for_remaining = 0\n        \n        # Calculate max_count2 based on remaining_weight\n        max_count2_possible = min(len(items_by_weight[2]), remaining_weight // 2)\n\n        # We can use a sliding window approach or precompute values for 1s and 2s\n        # For each count2, we want to find the best count1\n        # The number of 1s we can take is (remaining_weight - count2 * 2)\n        # We can iterate through count2 and for each count2, calculate the max_count1\n        \n        # This is the tricky part. We need to efficiently find the best combination of 1s and 2s.\n        # Let's precompute values for combinations of 1s and 2s.\n        # Create a list of (weight, cost) for 1s and 2s\n        \n        # We can iterate on the number of 2-weight items.\n        # For each `j` (number of 2-weight items), we calculate the remaining capacity\n        # and take as many 1-weight items as possible.\n        \n        current_cost_1_2 = 0\n        count1_taken = 0\n        \n        # Initialize two pointers for 1s and 2s\n        # We are trying to find max(cost1 + cost2) such that 1*num1 + 2*num2 <= remaining_weight\n        \n        # This is a standard approach: fix one type, then greedily take the other.\n        # Iterate through all possible numbers of 2-weight items.\n        \n        # Optimization: the best way to fill remaining_weight with 1s and 2s\n        # is to iterate over the number of 2-weight items, say `j`.\n        # For each `j`, the weight used by 2-weight items is `2*j`.\n        # The remaining capacity for 1-weight items is `remaining_weight - 2*j`.\n        # We take as many 1-weight items as possible, up to `len(items_by_weight[1])`.\n        \n        current_max_cost_1_2 = 0\n        \n        # This can be optimized. Instead of iterating through all count2,\n        # we can use the \"merge\" idea or two pointers if we consider items of weight 1 and 2 together.\n        # But since we have prefix sums, we can directly calculate.\n        \n        # Let's iterate `count2` from 0 up to `max_count2_possible`.\n        # For each `count2`:\n        #   `current_weight_2 = count2 * 2`\n        #   `current_cost_2 = prefix_sums[2][count2]`\n        #   `remaining_for_1 = remaining_weight - current_weight_2`\n        #   `count1_to_take = min(len(items_by_weight[1]), remaining_for_1)`\n        #   `current_cost_1 = prefix_sums[1][count1_to_take]`\n        #   `current_max_cost_1_2 = max(current_max_cost_1_2, current_cost_1 + current_cost_2)`\n        \n        # This is O(M) or O(N) depending on which is smaller.\n        # Given N=100000, M=300000, this loop can be up to M/2 iterations.\n        # Total complexity would be (M/3) * (M/2) which is too slow.\n        \n        # The key insight for the 1s and 2s part is that we can combine them.\n        # Let's consider items of weight 1 and 2.\n        # We can iterate on the number of items of weight 1, `i`.\n        # For each `i`, we use `i` items of weight 1, total weight `i`, total cost `prefix_sums[1][i]`.\n        # Remaining capacity for 2-weight items is `remaining_weight - i`.\n        # Number of 2-weight items we can take is `(remaining_weight - i) // 2`.\n        # Let this be `k`. We take `k` items of weight 2, total cost `prefix_sums[2][k]`.\n        # This is `O(len(items_by_weight[1]))`.\n        \n        # So, the outer loop is `count3`.\n        # Inside, we have a loop for `count1` (or `count2`).\n        \n        # Let's iterate `count1` for items of weight 1.\n        # This is `O(len(items_by_weight[1]))`.\n        \n        current_max_cost_1_2 = 0\n        \n        # We can iterate `count1` from 0 up to `len(items_by_weight[1])`.\n        # This is `O(N)`.\n        # The outer loop is `count3`, which is `O(N)`.\n        # Total `O(N^2)` still too slow.\n        \n        # The maximum weight is M = 300000.\n        # The number of items of weight 1 can be up to M.\n        # The number of items of weight 2 can be up to M/2.\n        # The number of items of weight 3 can be up to M/3.\n        \n        # The total number of items N is 100000.\n        # The number of items of weight 1 can be at most N.\n        # The number of items of weight 2 can be at most N.\n        # The number of items of weight 3 can be at most N.\n        \n        # The total number of 1-weight items is `n1`.\n        # The total number of 2-weight items is `n2`.\n        # The total number of 3-weight items is `n3`.\n        \n        # We are iterating over `count3` (number of 3-weight items).\n        # This loop runs `min(n3, M/3) + 1` times.\n        # Inside this loop, we need to find the best combination of 1-weight and 2-weight items.\n        # Let `rem_w = m - count3 * 3`.\n        # We want to maximize `sum_c1 + sum_c2` such that `count1 * 1 + count2 * 2 <= rem_w`.\n        \n        # This subproblem is a variation of knapsack.\n        # Since weights are small (1 and 2), we can optimize.\n        # We can iterate on `count2` (number of 2-weight items).\n        # `count2` goes from 0 to `min(n2, rem_w // 2)`.\n        # For each `count2`, we take `prefix_sums[2][count2]`.\n        # The remaining weight for 1-weight items is `rem_w - count2 * 2`.\n        # We take `min(n1, rem_w - count2 * 2)` items of weight 1.\n        # This costs `prefix_sums[1][min(n1, rem_w - count2 * 2)]`.\n        # This inner loop is `O(min(n2, M))`.\n        \n        # Total complexity: `O(min(n3, M)) * O(min(n2, M))`. This is `O(M^2)` in worst case, too slow.\n        # e.g., n1=0, n2=0, n3=N, M=300000 => O(M)\n        # e.g., n1=N, n2=N, n3=N, M=300000. If all items are weight 1, N=100000.\n        # If N=100000, M=300000, all weights are 1. Outer loop `count3` is 0.\n        # Inner loop `count2` is 0. Then `count1` takes `min(n1, M)`. O(N+M) for prefix sums.\n        \n        # The problem is when all items are weight 2, and all items are weight 3.\n        # Or when there are many 2s and 3s.\n        \n        # Let's re-evaluate the inner loop for 1s and 2s.\n        # We have `rem_w` capacity. We want to maximize `cost1 + cost2`.\n        # `cost1 = prefix_sums[1][c1]`, `cost2 = prefix_sums[2][c2]`.\n        # `c1 * 1 + c2 * 2 <= rem_w`.\n        \n        # This is a classic \"two pointers\" or \"meet-in-the-middle\" style optimization.\n        # Let's iterate `c2` from 0 to `min(len(items_by_weight[2]), rem_w // 2)`.\n        # For each `c2`, we calculate `current_cost_2 = prefix_sums[2][c2]`.\n        # The remaining capacity for 1s is `rem_w - 2 * c2`.\n        # We want to take `c1` 1s such that `c1 <= rem_w - 2 * c2`.\n        # And `c1 <= len(items_by_weight[1])`.\n        # So `c1 = min(len(items_by_weight[1]), rem_w - 2 * c2)`.\n        # `current_cost_1 = prefix_sums[1][c1]`.\n        # `current_total_cost_1_2 = current_cost_1 + current_cost_2`.\n        # We need to maximize this `current_total_cost_1_2`.\n        \n        # The number of iterations for `c2` is `min(len(items_by_weight[2]), rem_w // 2) + 1`.\n        # This can be up to `min(N, M/2)`.\n        # The outer loop for `count3` is `min(len(items_by_weight[3]), M/3) + 1`.\n        # So total complexity `O(min(N, M/3) * min(N, M/2))`. This is `O(N^2)` or `O(M^2)`.\n        # This is too slow for N=100000, M=300000.\n        \n        # The constraint N <= 100000 and M <= 300000 suggests a solution closer to O(N log N), O(M log M), O(N+M).\n        \n        # What if we iterate on the number of items of weight 1?\n        # Let `count1` be the number of 1-weight items.\n        # `count1` from 0 to `min(len(items_by_weight[1]), rem_w)`.\n        # `current_cost_1 = prefix_sums[1][count1]`.\n        # `remaining_for_2 = rem_w - count1`.\n        # `count2_to_take = min(len(items_by_weight[2]), remaining_for_2 // 2)`.\n        # `current_cost_2 = prefix_sums[2][count2_to_take]`.\n        # This is also `O(min(N, M))`.\n        \n        # So the nested loop structure is:\n        # for `count3` (up to `min(N, M/3)` iterations)\n        #   for `count1` (up to `min(N, M)` iterations)\n        #     calculate `count2`\n        # Total `O(min(N, M/3) * min(N, M))`. Still too slow.\n        \n        # Key observation: The number of items of weight 3 is at most `M/3`.\n        # The number of items of weight 2 is at most `M/2`.\n        # The number of items of weight 1 is at most `M`.\n        # However, the total number of items is `N`.\n        \n        # What if `N` is small, e.g., `N=1000`? Then `O(N^2)` is fine.\n        # But `N=100000`.\n        \n        # The solution must be linear or N log N in N and M.\n        \n        # Let's fix the number of items of weight 3, say `k3`.\n        # Cost is `prefix_sums[3][k3]`. Remaining weight `rem_w = m - k3 * 3`.\n        \n        # Now we need to select items of weight 1 and 2 to fill `rem_w`.\n        # This is a subproblem: given capacity `C`, maximize `sum(c1) + sum(c2)`\n        # such that `sum(w1) + sum(w2) <= C`.\n        \n        # This subproblem can be solved efficiently.\n        # We can combine the items of weight 1 and 2 into a single list of (weight, cost) pairs.\n        # (1, c) for each c in items_by_weight[1]\n        # (2, c) for each c in items_by_weight[2]\n        # Sort them by cost/weight ratio? No, knapsack is not greedy.\n        \n        # The specific structure of weights (1 and 2) allows for optimization.\n        # Create a list of all possible (weight, cost) pairs for items of weight 1 and 2.\n        # Let `dp[w]` be the maximum cost for weight `w` using only items of weight 1 and 2.\n        # This is a knapsack problem.\n        # `dp[w] = max(dp[w-1] + cost_of_best_1, dp[w-2] + cost_of_best_2)`\n        # This is not quite right. It's more like:\n        # `dp[w] = max(dp[w-1] + cost_of_a_1, dp[w-2] + cost_of_a_2)`\n        # This implies using one item at a time.\n        # But we have multiple items of the same weight.\n        \n        # Since we have sorted costs and prefix sums, we can use a two-pointer approach for the 1s and 2s.\n        # Let `k1` be the number of 1-weight items, `k2` be the number of 2-weight items.\n        # We want to maximize `prefix_sums[1][k1] + prefix_sums[2][k2]`\n        # subject to `k1 + 2*k2 <= rem_w`, `k1 <= len(items_by_weight[1])`, `k2 <= len(items_by_weight[2])`.\n        \n        # Iterate `k2` from `min(len(items_by_weight[2]), rem_w // 2)` down to 0.\n        # Maintain `max_cost_1_2` found so far.\n        # For each `k2`:\n        #   `current_cost_2 = prefix_sums[2][k2]`\n        #   `remaining_capacity_for_1 = rem_w - 2 * k2`\n        #   `k1_to_take = min(len(items_by_weight[1]), remaining_capacity_for_1)`\n        #   `current_cost_1 = prefix_sums[1][k1_to_take]`\n        #   `max_cost_1_2 = max(max_cost_1_2, current_cost_1 + current_cost_2)`\n        \n        # This is `O(min(N, M/2))` for the inner loop.\n        # Total `O(min(N, M/3) * min(N, M/2))`. Still too slow.\n        \n        # The maximum number of 1-weight items is `N1`. Max number of 2-weight items is `N2`.\n        # Max number of 3-weight items is `N3`.\n        # `N1 + N2 + N3 = N`.\n        \n        # The total number of items of weight 1 and 2 combined is `N1 + N2`.\n        # The maximum weight `M` is 300000.\n        \n        # What if we iterate on `k1` from 0 to `len(items_by_weight[1])`?\n        # `k1` can be up to `N` or `M`.\n        # `k2` can be up to `N` or `M/2`.\n        \n        # Let's consider the combined problem for items of weight 1 and 2.\n        # We want to find `max(prefix_sums[1][i] + prefix_sums[2][j])` such that `i + 2j <= W`.\n        # This is a standard problem that can be solved in `O(W)` or `O(N)` where N is total items of weight 1 and 2.\n        # Create an array `best_cost_for_1_2[w]` = max cost for weight `w` using only 1s and 2s.\n        # `best_cost_for_1_2[w]` can be computed by iterating `j` (number of 2s) from 0 to `W/2`.\n        # `best_cost_for_1_2[w] = max(best_cost_for_1_2[w], prefix_sums[2][j] + prefix_sums[1][min(len(items_by_weight[1]), w - 2*j)])`.\n        # This takes `O(W)` time.\n        \n        # So, the plan is:\n        # 1. Precompute `best_cost_for_1_2[w]` for `w` from 0 to `M`.\n        #    This takes `O(M * min(N, M/2))` if we iterate `j` for each `w`.\n        #    No, this can be done in `O(M)` or `O(N+M)`.\n        #    Let `max_val_1_2[w]` be the maximum value for capacity `w` using only items of weight 1 and 2.\n        #    `max_val_1_2` array of size `M+1`.\n        #    Iterate `j` (number of 2-weight items) from 0 to `min(len(items_by_weight[2]), M//2)`.\n        #    `cost_2 = prefix_sums[2][j]`.\n        #    `weight_2 = j * 2`.\n        #    For each `j`, we have `cost_2` at `weight_2`.\n        #    We can then add 1-weight items.\n        #    For a fixed `j`, the remaining capacity `W' = W - weight_2`.\n        #    We take `min(len(items_by_weight[1]), W')` items of weight 1.\n        #    This is `prefix_sums[1][min(len(items_by_weight[1]), W')]`.\n        #    So, `max_val_1_2[W] = max(max_val_1_2[W], cost_2 + prefix_sums[1][min(len(items_by_weight[1]), W - weight_2)])`.\n        #    This calculation for `max_val_1_2` takes `O(M * min(N, M/2))` if we compute for each `W` independently.\n        \n        # To compute `max_val_1_2` efficiently:\n        # Iterate `j` from 0 to `len(items_by_weight[2])`.\n        #   `current_cost_2 = prefix_sums[2][j]`\n        #   `current_weight_2 = j * 2`\n        #   We want to find `max(current_cost_2 + prefix_sums[1][k1])` such that `k1 + current_weight_2 <= rem_w`.\n        #   This is what we need to compute for `rem_w`.\n        \n        # Let's create `dp_1_2[w]` = max cost for capacity `w` using only 1-weight and 2-weight items.\n        # `dp_1_2` array of size `M+1`.\n        # Initialize `dp_1_2` with 0s.\n        \n        # Iterate `j` (number of 2-weight items) from 0 to `len(items_by_weight[2])`.\n        #   `cost_2 = prefix_sums[2][j]`\n        #   `weight_2 = j * 2`\n        #   If `weight_2 > M`, break.\n        #   `remaining_capacity_for_1s = M - weight_2`.\n        #   We want to fill `k1` 1-weight items.\n        #   `k1_limit = min(len(items_by_weight[1]), remaining_capacity_for_1s)`.\n        #   `dp_1_2_current_j_cost = cost_2 + prefix_sums[1][k1_limit]`.\n        #   This `dp_1_2_current_j_cost` is the max cost for `M` capacity IF we take exactly `j` 2-weight items.\n        #   This is not what we want. We need `dp_1_2[w]` for ALL `w`.\n        \n        # Correct computation for `dp_1_2[w]`:\n        # `dp_1_2` array of size `M+1`.\n        # Iterate `i` (number of 1-weight items) from 0 to `len(items_by_weight[1])`.\n        #   `cost_1 = prefix_sums[1][i]`\n        #   `weight_1 = i * 1`\n        #   If `weight_1 > M`, break.\n        #   `remaining_capacity = M - weight_1`.\n        #   `j_limit = min(len(items_by_weight[2]), remaining_capacity // 2)`.\n        #   `cost_2 = prefix_sums[2][j_limit]`.\n        #   `dp_1_2[weight_1 + j_limit * 2]` could be `cost_1 + cost_2`.\n        #   This is not how it works. `dp_1_2[w]` is max cost for weight `w`.\n        \n        # Let's re-think `dp_1_2[w]`.\n        # `dp_1_2[w]` stores the maximum cost for exactly weight `w` using items of weight 1 and 2.\n        # This is not what we need. We need maximum cost for AT MOST weight `w`.\n        # Let `max_cost_up_to_w[w]` be the maximum cost for capacity `w`.\n        \n        # The efficient way to compute `max_cost_up_to_w[w]` for 1s and 2s:\n        # `max_cost_up_to_w` array of size `M+1`.\n        # `max_cost_up_to_w[0] = 0`.\n        # Iterate `i` (number of 1-weight items) from 0 to `len(items_by_weight[1])`.\n        #   `current_weight_1 = i * 1`.\n        #   `current_cost_1 = prefix_sums[1][i]`.\n        #   If `current_weight_1 > M`, break.\n        #   `max_cost_up_to_w[current_weight_1] = max(max_cost_up_to_w[current_weight_1], current_cost_1)`.\n        #   (This is not correct, we need to consider 2s as well)\n        \n        # The correct way to precompute `max_cost_for_1_2[w]` (max cost for weight `w` using only 1s and 2s):\n        # `max_cost_for_1_2 = [0] * (M + 1)`\n        # `j` is the number of 2-weight items.\n        # `k` is the number of 1-weight items.\n        # Iterate `j` from 0 to `len(items_by_weight[2])`.\n        #   `cost_j = prefix_sums[2][j]`\n        #   `weight_j = j * 2`\n        #   If `weight_j > M`, break.\n        #   Iterate `k` from 0 to `len(items_by_weight[1])`.\n        #     `cost_k = prefix_sums[1][k]`\n        #     `weight_k = k * 1`\n        #     `total_weight = weight_j + weight_k`\n        #     If `total_weight > M`, break.\n        #     `max_cost_for_1_2[total_weight] = max(max_cost_for_1_2[total_weight], cost_j + cost_k)`\n        # This is `O(N^2)` or `O(M^2)` again.\n        \n        # The problem is that the `k` loop for 1-weight items depends on `j` (number of 2-weight items).\n        # We need to compute `max_cost_for_1_2[rem_w]` efficiently.\n        # Let's define `best_1_2_values[rem_w]` = max cost using 1s and 2s for capacity `rem_w`.\n        # `best_1_2_values = [0] * (M + 1)`\n        # `j` goes from 0 to `len(items_by_weight[2])`.\n        #   `cost_j = prefix_sums[2][j]`.\n        #   `weight_j = j * 2`.\n        #   If `weight_j > M`, continue.\n        #   `remaining_capacity = M - weight_j`.\n        #   `k_limit = min(len(items_by_weight[1]), remaining_capacity)`.\n        #   `current_total_cost = cost_j + prefix_sums[1][k_limit]`.\n        #   This `current_total_cost` is the maximum possible if we use exactly `j` 2-weight items\n        #   and fill the rest with 1-weight items.\n        #   This is `max_cost_for_1_2[weight_j + k_limit]` (if we take exactly `k_limit` 1-weight items).\n        #   This is not `max_cost_for_1_2[rem_w]`.\n        \n        # Let's define `best_cost_for_1s_and_2s[w]` as the maximum cost for a total weight of `w` using only items of weight 1 and 2.\n        # This can be computed in `O(M)` or `O(N+M)` time.\n        # `best_cost_for_1s_and_2s = [0] * (M + 1)`\n        # `idx_1 = len(items_by_weight[1])`\n        # For `w` from 0 to `M`:\n        #   While `idx_1 > 0` and `idx_1 > w`:\n        #     `idx_1 -= 1`\n        #   `best_cost_for_1s_and_2s[w] = prefix_sums[1][idx_1]` (max cost using only 1s for weight w)\n        \n        # This is for \"at most w\". Let's compute `max_cost_for_1_2[w]` as the maximum cost for exactly weight `w`.\n        # No, it's always \"at most\".\n        \n        # Let's compute `max_cost_up_to_W[w]` for 1s and 2s.\n        # `max_cost_up_to_W = [0] * (M + 1)`\n        # `ptr1 = len(items_by_weight[1])`\n        # `current_cost_1 = 0`\n        # For `w` from 0 to `M`:\n        #   `max_cost_up_to_W[w] = max_cost_up_to_W[w-1]` if `w > 0`.\n        #   While `ptr1 > 0` and `items_by_weight[1][ptr1-1]` is a candidate for `w`:\n        #     `current_cost_1 += items_by_weight[1][ptr1-1]`\n        #     `ptr1 -= 1`\n        #   This is not going to work.\n        \n        # The correct approach for `max_cost_for_1_2[w]` (max cost for AT MOST `w` using 1s and 2s):\n        # Initialize `max_cost_for_1_2 = [0] * (M + 1)`.\n        # `j` (number of 2-weight items) from 0 to `len(items_by_weight[2])`.\n        #   `cost_2 = prefix_sums[2][j]`.\n        #   `weight_2 = j * 2`.\n        #   If `weight_2 > M`, break.\n        #   `remaining_capacity_for_1s = M - weight_2`.\n        #   `k_limit = min(len(items_by_weight[1]), remaining_capacity_for_1s)`.\n        #   `current_total_cost = cost_2 + prefix_sums[1][k_limit]`.\n        #   This `current_total_cost` is a candidate for `max_cost_for_1_2[M]`.\n        #   But we need it for `rem_w`.\n        \n        # Let's precompute `max_cost_for_1s_up_to_w[w]` and `max_cost_for_2s_up_to_w[w]`.\n        # `max_cost_for_1s_up_to_w = [0] * (M + 1)`\n        # For `i` from 1 to `M`:\n        #   `num_1s = min(i, len(items_by_weight[1]))`\n        #   `max_cost_for_1s_up_to_w[i] = prefix_sums[1][num_1s]`\n        \n        # `max_cost_for_2s_up_to_w = [0] * (M + 1)`\n        # For `i` from 1 to `M`:\n        #   `num_2s = min(i // 2, len(items_by_weight[2]))`\n        #   `max_cost_for_2s_up_to_w[i] = prefix_sums[2][num_2s]`\n        \n        # This is for only 1s or only 2s. We need combinations.\n        \n        # The standard approach for small weights is DP.\n        # `dp[w]` = max cost for weight `w`.\n        # For item `(wi, ci)`:\n        #   For `w` from `M` down to `wi`:\n        #     `dp[w] = max(dp[w], dp[w-wi] + ci)`\n        # This is `O(N*M)` for general knapsack.\n        # Here, `wi` is small.\n        # We have multiple items of same weight.\n        \n        # Let's fix `count3`.\n        # Remaining weight `rem_w = m - count3 * 3`.\n        # We need to maximize `prefix_sums[1][k1] + prefix_sums[2][k2]` such that `k1 + 2*k2 <= rem_w`.\n        # `k1 <= len(items_by_weight[1])`, `k2 <= len(items_by_weight[2])`.\n        \n        # This subproblem (max value for capacity `rem_w` using 1s and 2s) can be solved with a sliding window/two pointers.\n        # `current_max_cost_1_2 = 0`\n        # `k1 = min(len(items_by_weight[1]), rem_w)`\n        # `current_cost_1 = prefix_sums[1][k1]`\n        # For `k2` from 0 to `min(len(items_by_weight[2]), rem_w // 2)`:\n        #   While `k1 > 0` and `k1 + 2*k2 > rem_w`:\n        #     `k1 -= 1`\n        #     `current_cost_1 -= items_by_weight[1][k1]` (if `k1` was not 0)\n        #   `current_max_cost_1_2 = max(current_max_cost_1_2, current_cost_1 + prefix_sums[2][k2])`\n        \n        # This is the correct approach for the inner loop.\n        # The `k1` pointer only moves left, so it's amortized `O(len(items_by_weight[1]))`.\n        # The `k2` loop runs `O(len(items_by_weight[2]))` times.\n        # So the inner loop is `O(len(items_by_weight[1]) + len(items_by_weight[2])) = O(N)`.\n        \n        # The outer loop for `count3` runs `O(len(items_by_weight[3]))` times.\n        # Total complexity `O(len(items_by_weight[3]) * (len(items_by_weight[1]) + len(items_by_weight[2])))`.\n        # In worst case, `len(items_by_weight[3])` is `N`. `len(items_by_weight[1]) + len(items_by_weight[2])` is `N`.\n        # Still `O(N^2)`.\n        \n        # The number of items of weight 3 can be at most `M/3`.\n        # The number of items of weight 1 and 2 can be at most `N`.\n        # So it's `O(min(N, M/3) * N)`. Still potentially `O(N^2)`.\n        \n        # Example: N=100000, M=300000. All items are weight 3.\n        # `count3` loop runs `N` times. Inner loop (1s and 2s) is `O(1)`. Total `O(N)`.\n        \n        # Example: N=100000, M=300000. All items are weight 1.\n        # `count3` loop runs 1 time (`count3=0`). Inner loop is `O(N)`. Total `O(N)`.\n        \n        # Example: N=100000, M=300000. N/3 items of weight 1, N/3 items of weight 2, N/3 items of weight 3.\n        # `count3` loop runs `N/3` times. Inner loop `O(N/3 + N/3) = O(N)`.\n        # Total `O(N * N) = O(N^2)`. This is the problematic case.\n        \n        # Max N is 10^5, Max M is 3*10^5.\n        # N^2 is 10^10, too slow.\n        \n        # The solution must be `O(M + N)` or `O(M + N log N)`.\n        \n        # Let's re-examine the subproblem: maximize `sum_c1 + sum_c2` for `k1 + 2*k2 <= rem_w`.\n        # This subproblem can be solved in `O(rem_w)` time by DP if `rem_w` is small.\n        # `dp[w]` = max cost for weight `w` using 1s and 2s.\n        # `dp[w] = max(dp[w-1] + cost_of_next_1, dp[w-2] + cost_of_next_2)`\n        # This is not right. This is for 0/1 knapsack with multiple items of same type.\n        \n        # It's a variation of unbounded knapsack.\n        # `dp[w] = max(dp[w-1] + current_best_1_cost, dp[w-2] + current_best_2_cost)`\n        # We have limited quantities of items.\n        \n        # The `best_cost_for_1_2[w]` array should be precomputed.\n        # `best_cost_for_1_2 = [0] * (M + 1)`\n        # `ptr1 = len(items_by_weight[1]) - 1`\n        # `current_cost_1 = 0`\n        # For `w_1_only` from 0 to `M`:\n        #   If `ptr1 >= 0` and `w_1_only > 0`:\n        #     `current_cost_1 += items_by_weight[1][ptr1]`\n        #     `ptr1 -= 1`\n        #   `best_cost_for_1_2[w_1_only] = current_cost_1` (This is just for 1s)\n        \n        # To compute `best_cost_for_1_2[w]` for all `w` up to `M`:\n        # `best_cost_for_1_2 = [0] * (M + 1)`\n        # `idx_1 = 0` (index for items_by_weight[1])\n        # `current_sum_1 = 0`\n        # `max_val_1_2_for_w = 0`\n        \n        # Iterate `w` from 0 to `M`:\n        #   `max_val_1_2_for_w` should be the max cost for capacity `w`.\n        #   This is what we need.\n        #   The values `prefix_sums[1][k1]` are non-decreasing.\n        #   The values `prefix_sums[2][k2]` are non-decreasing.\n        \n        # Let's consider the items of weight 1 and 2 together.\n        # `combined_items = []`\n        # For `c` in `items_by_weight[1]`: `combined_items.append((1, c))`\n        # For `c` in `items_by_weight[2]`: `combined_items.append((2, c))`\n        # Sort `combined_items` by cost/weight ratio? No.\n        \n        # The solution for the 1s and 2s subproblem is:\n        # `max_cost_1_2_memo = [0] * (M + 1)`\n        # `k1_ptr = len(items_by_weight[1])`\n        # `current_cost_1 = prefix_sums[1][k1_ptr]`\n        # For `k2` from 0 to `len(items_by_weight[2])`:\n        #   `current_weight_2 = k2 * 2`\n        #   `cost_2 = prefix_sums[2][k2]`\n        #   While `k1_ptr > 0` and `k1_ptr + current_weight_2 > M`:\n        #     `k1_ptr -= 1`\n        #     `current_cost_1 = prefix_sums[1][k1_ptr]`\n        #   If `k1_ptr + current_weight_2 <= M`:\n        #     `max_cost_1_2_memo[k1_ptr + current_weight_2] = max(max_cost_1_2_memo[k1_ptr + current_weight_2], current_cost_1 + cost_2)`\n        # This fills specific weights. We need \"up to\".\n        \n        # Let's define `best_cost_for_1_2_up_to_w[w]` as the maximum cost for capacity `w` using only items of weight 1 and 2.\n        # `best_cost_for_1_2_up_to_w = [0] * (M + 1)`\n        # `k1 = len(items_by_weight[1])`\n        # `current_sum_1 = prefix_sums[1][k1]`\n        # For `k2` from 0 to `len(items_by_weight[2])`:\n        #   `current_sum_2 = prefix_sums[2][k2]`\n        #   `current_weight_2 = k2 * 2`\n        #   `max_allowed_weight_for_1 = M - current_weight_2`\n        #   While `k1 > 0` and `k1 > max_allowed_weight_for_1`:\n        #     `k1 -= 1`\n        #     `current_sum_1 = prefix_sums[1][k1]`\n        #   If `k1 + current_weight_2 <= M`:\n        #     `best_cost_for_1_2_up_to_w[k1 + current_weight_2] = max(best_cost_for_1_2_up_to_w[k1 + current_weight_2], current_sum_1 + current_sum_2)`\n        \n        # After this loop, `best_cost_for_1_2_up_to_w` contains maximum costs for specific total weights.\n        # We need to make it \"up to\".\n        # For `w` from 1 to `M`: `best_cost_for_1_2_up_to_w[w] = max(best_cost_for_1_2_up_to_w[w], best_cost_for_1_2_up_to_w[w-1])`.\n        \n        # This computation for `best_cost_for_1_2_up_to_w` takes `O(len(items_by_weight[1]) + len(items_by_weight[2]) + M)`.\n        # `len(items_by_weight[1]) + len(items_by_weight[2]) <= N`.\n        # So `O(N + M)`.\n        \n        # This is the breakthrough!\n        # Precompute `best_cost_for_1_2_up_to_w` once in `O(N+M)` time.\n        \n        # Then, the main loop:\n        # `max_total_cost = 0`\n        # For `count3` from 0 to `len(items_by_weight[3])`:\n        #   `weight3 = count3 * 3`\n        #   `cost3 = prefix_sums[3][count3]`\n        #   If `weight3 > m`: break\n        #   `remaining_weight = m - weight3`\n        #   `cost_1_2 = best_cost_for_1_2_up_to_w[remaining_weight]`\n        #   `max_total_cost = max(max_total_cost, cost3 + cost_1_2)`\n        \n        # This loop runs `O(len(items_by_weight[3]))` times.\n        # `len(items_by_weight[3]) <= N`.\n        # So this loop is `O(N)`.\n        \n        # Total complexity: `O(N + M)`. This is efficient enough!\n        \n        # Let's implement the precomputation of `best_cost_for_1_2_up_to_w`.\n        \n    best_cost_for_1_2_up_to_w = [0] * (m + 1)\n    \n    # Initialize `k1_ptr` to the maximum number of 1-weight items that can fit into `m`\n    k1_ptr = len(items_by_weight[1])\n    current_sum_1 = prefix_sums[1][k1_ptr]\n\n    # Iterate `k2` (number of 2-weight items)\n    for k2 in range(len(items_by_weight[2]) + 1):\n        current_sum_2 = prefix_sums[2][k2]\n        current_weight_2 = k2 * 2\n\n        if current_weight_2 > m:\n            break\n\n        # Max capacity remaining for 1-weight items\n        max_allowed_weight_for_1 = m - current_weight_2\n\n        # Adjust k1_ptr so that k1_ptr * 1 <= max_allowed_weight_for_1\n        # and k1_ptr <= len(items_by_weight[1])\n        # We need to find the largest k1_ptr such that k1_ptr <= max_allowed_weight_for_1.\n        # Since k1_ptr is decreasing, this is efficient.\n        while k1_ptr > 0 and k1_ptr > max_allowed_weight_for_1:\n            k1_ptr -= 1\n            current_sum_1 = prefix_sums[1][k1_ptr]\n        \n        # If k1_ptr is 0, current_sum_1 is 0.\n        # If k1_ptr * 1 + current_weight_2 <= m, then we have a valid combination.\n        # The total weight for this combination is `k1_ptr + current_weight_2`.\n        # The total cost is `current_sum_1 + current_sum_2`.\n        \n        # We store this cost at the exact weight `k1_ptr + current_weight_2`.\n        # Note: `k1_ptr` is already `min(len(items_by_weight[1]), max_allowed_weight_for_1)`.\n        # So `k1_ptr + current_weight_2` is the actual weight used.\n        actual_total_weight = k1_ptr + current_weight_2\n        \n        if actual_total_weight <= m:\n            best_cost_for_1_2_up_to_w[actual_total_weight] = max(best_cost_for_1_2_up_to_w[actual_total_weight], current_sum_1 + current_sum_2)\n\n    # Now, convert `best_cost_for_1_2_up_to_w` to store maximum cost for *up to* a given weight.\n    for w in range(1, m + 1):\n        best_cost_for_1_2_up_to_w[w] = max(best_cost_for_1_2_up_to_w[w], best_cost_for_1_2_up_to_w[w-1])\n\n    max_total_cost = 0\n\n    # Iterate `count3` (number of 3-weight items)\n    for count3 in range(len(items_by_weight[3]) + 1):\n        weight3 = count3 * 3\n        cost3 = prefix_sums[3][count3]\n\n        if weight3 > m:\n            break\n\n        remaining_weight = m - weight3\n        \n        # Look up the precomputed max cost for 1s and 2s for the remaining_weight\n        cost_1_2 = best_cost_for_1_2_up_to_w[remaining_weight]\n        \n        max_total_cost = max(max_total_cost, cost3 + cost_1_2)\n\n    print(max_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, m = map(int, input().split())\n\n    items_by_weight = {1: [], 2: [], 3: []}\n    for _ in range(n):\n        w, c = map(int, input().split())\n        items_by_weight[w].append(c)\n\n    for w in items_by_weight:\n        items_by_weight[w].sort(reverse=True)\n\n    prefix_sums = {\n        1: [0] * (len(items_by_weight[1]) + 1),\n        2: [0] * (len(items_by_weight[2]) + 1),\n        3: [0] * (len(items_by_weight[3]) + 1)\n    }\n\n    for w in items_by_weight:\n        for i in range(len(items_by_weight[w])):\n            prefix_sums[w][i+1] = prefix_sums[w][i] + items_by_weight[w][i]\n\n    max_cost = 0\n\n    for count3 in range(len(items_by_weight[3]) + 1):\n        weight3 = count3 * 3\n        cost3 = prefix_sums[3][count3]\n\n        if weight3 > m:\n            break\n\n        remaining_weight = m - weight3\n        current_cost = cost3\n\n        # Option 1: Try to fill remaining_weight with items of weight 1 and 2\n        # Iterate over count2 for items of weight 2\n        best_cost_for_remaining = 0\n        \n        # Calculate max_count2 based on remaining_weight\n        max_count2_possible = min(len(items_by_weight[2]), remaining_weight // 2)\n\n        # We can use a sliding window approach or precompute values for 1s and 2s\n        # For each count2, we want to find the best count1\n        # The number of 1s we can take is (remaining_weight - count2 * 2)\n        # We can iterate through count2 and for each count2, calculate the max_count1\n        \n        # This is the tricky part. We need to efficiently find the best combination of 1s and 2s.\n        # Let's precompute values for combinations of 1s and 2s.\n        # Create a list of (weight, cost) for 1s and 2s\n        \n        # We can iterate on the number of 2-weight items.\n        # For each `j` (number of 2-weight items), we calculate the remaining capacity\n        # and take as many 1-weight items as possible.\n        \n        current_cost_1_2 = 0\n        count1_taken = 0\n        \n        # Initialize two pointers for 1s and 2s\n        # We are trying to find max(cost1 + cost2) such that 1*num1 + 2*num2 <= remaining_weight\n        \n        # This is a standard approach: fix one type, then greedily take the other.\n        # Iterate through all possible numbers of 2-weight items.\n        \n        # Optimization: the best way to fill remaining_weight with 1s and 2s\n        # is to iterate over the number of 2-weight items, say `j`.\n        # For each `j`, the weight used by 2-weight items is `2*j`.\n        # The remaining capacity for 1-weight items is `remaining_weight - 2*j`.\n        # We take as many 1-weight items as possible, up to `len(items_by_weight[1])`.\n        \n        current_max_cost_1_2 = 0\n        \n        # This can be optimized. Instead of iterating through all count2,\n        # we can use the \"merge\" idea or two pointers if we consider items of weight 1 and 2 together.\n        # But since we have prefix sums, we can directly calculate.\n        \n        # Let's iterate `count2` from 0 up to `max_count2_possible`.\n        # For each `count2`:\n        #   `current_weight_2 = count2 * 2`\n        #   `current_cost_2 = prefix_sums[2][count2]`\n        #   `remaining_for_1 = remaining_weight - current_weight_2`\n        #   `count1_to_take = min(len(items_by_weight[1]), remaining_for_1)`\n        #   `current_cost_1 = prefix_sums[1][count1_to_take]`\n        #   `current_max_cost_1_2 = max(current_max_cost_1_2, current_cost_1 + current_cost_2)`\n        \n        # This is O(M) or O(N) depending on which is smaller.\n        # Given N=100000, M=300000, this loop can be up to M/2 iterations.\n        # Total complexity would be (M/3) * (M/2) which is too slow.\n        \n        # The key insight for the 1s and 2s part is that we can combine them.\n        # Let's consider items of weight 1 and 2.\n        # We can iterate on the number of items of weight 1, `i`.\n        # For each `i`, we use `i` items of weight 1, total weight `i`, total cost `prefix_sums[1][i]`.\n        # Remaining capacity for 2-weight items is `remaining_weight - i`.\n        # Number of 2-weight items we can take is `(remaining_weight - i) // 2`.\n        # Let this be `k`. We take `k` items of weight 2, total cost `prefix_sums[2][k]`.\n        # This is `O(len(items_by_weight[1]))`.\n        \n        # So, the outer loop is `count3`.\n        # Inside, we have a loop for `count1` (or `count2`).\n        \n        # Let's iterate `count1` for items of weight 1.\n        # This is `O(len(items_by_weight[1]))`.\n        \n        current_max_cost_1_2 = 0\n        \n        # We can iterate `count1` from 0 up to `len(items_by_weight[1])`.\n        # This is `O(N)`.\n        # The outer loop is `count3`, which is `O(N)`.\n        # Total `O(N^2)` still too slow.\n        \n        # The maximum weight is M = 300000.\n        # The number of items of weight 1 can be up to M.\n        # The number of items of weight 2 can be up to M/2.\n        # The number of items of weight 3 can be up to M/3.\n        \n        # The total number of items N is 100000.\n        # The number of items of weight 1 can be at most N.\n        # The number of items of weight 2 can be at most N.\n        # The number of items of weight 3 can be at most N.\n        \n        # The total number of 1-weight items is `n1`.\n        # The total number of 2-weight items is `n2`.\n        # The total number of 3-weight items is `n3`.\n        \n        # We are iterating over `count3` (number of 3-weight items).\n        # This loop runs `min(n3, M/3) + 1` times.\n        # Inside this loop, we need to find the best combination of 1-weight and 2-weight items.\n        # Let `rem_w = m - count3 * 3`.\n        # We want to maximize `sum_c1 + sum_c2` such that `count1 * 1 + count2 * 2 <= rem_w`.\n        \n        # This subproblem is a variation of knapsack.\n        # Since weights are small (1 and 2), we can optimize.\n        # We can iterate on `count2` (number of 2-weight items).\n        # `count2` goes from 0 to `min(n2, rem_w // 2)`.\n        # For each `count2`, we take `prefix_sums[2][count2]`.\n        # The remaining weight for 1-weight items is `rem_w - count2 * 2`.\n        # We take `min(n1, rem_w - count2 * 2)` items of weight 1.\n        # This costs `prefix_sums[1][min(n1, rem_w - count2 * 2)]`.\n        # This inner loop is `O(min(n2, M))`.\n        \n        # Total complexity: `O(min(n3, M)) * O(min(n2, M))`. This is `O(M^2)` in worst case, too slow.\n        # e.g., n1=0, n2=0, n3=N, M=300000 => O(M)\n        # e.g., n1=N, n2=N, n3=N, M=300000. If all items are weight 1, N=100000.\n        # If N=100000, M=300000, all weights are 1. Outer loop `count3` is 0.\n        # Inner loop `count2` is 0. Then `count1` takes `min(n1, M)`. O(N+M) for prefix sums.\n        \n        # The problem is when all items are weight 2, and all items are weight 3.\n        # Or when there are many 2s and 3s.\n        \n        # Let's re-evaluate the inner loop for 1s and 2s.\n        # We have `rem_w` capacity. We want to maximize `cost1 + cost2`.\n        # `cost1 = prefix_sums[1][c1]`, `cost2 = prefix_sums[2][c2]`.\n        # `c1 * 1 + c2 * 2 <= rem_w`.\n        \n        # This is a classic \"two pointers\" or \"meet-in-the-middle\" style optimization.\n        # Let's iterate `c2` from 0 to `min(len(items_by_weight[2]), rem_w // 2)`.\n        # For each `c2`, we calculate `current_cost_2 = prefix_sums[2][c2]`.\n        # The remaining capacity for 1s is `rem_w - 2 * c2`.\n        # We want to take `c1` 1s such that `c1 <= rem_w - 2 * c2`.\n        # And `c1 <= len(items_by_weight[1])`.\n        # So `c1 = min(len(items_by_weight[1]), rem_w - 2 * c2)`.\n        # `current_cost_1 = prefix_sums[1][c1]`.\n        # `current_total_cost_1_2 = current_cost_1 + current_cost_2`.\n        # We need to maximize this `current_total_cost_1_2`.\n        \n        # The number of iterations for `c2` is `min(len(items_by_weight[2]), rem_w // 2) + 1`.\n        # This can be up to `min(N, M/2)`.\n        # The outer loop for `count3` is `min(len(items_by_weight[3]), M/3) + 1`.\n        # So total complexity `O(min(N, M/3) * min(N, M/2))`. This is `O(N^2)` or `O(M^2)`.\n        # This is too slow for N=100000, M=300000.\n        \n        # The constraint N <= 100000 and M <= 300000 suggests a solution closer to O(N log N), O(M log M), O(N+M).\n        \n        # What if we iterate on the number of items of weight 1?\n        # Let `count1` be the number of 1-weight items.\n        # `count1` from 0 to `min(len(items_by_weight[1]), rem_w)`.\n        # `current_cost_1 = prefix_sums[1][count1]`.\n        # `remaining_for_2 = rem_w - count1`.\n        # `count2_to_take = min(len(items_by_weight[2]), remaining_for_2 // 2)`.\n        # `current_cost_2 = prefix_sums[2][count2_to_take]`.\n        # This is also `O(min(N, M))`.\n        \n        # So the nested loop structure is:\n        # for `count3` (up to `min(N, M/3)` iterations)\n        #   for `count1` (up to `min(N, M)` iterations)\n        #     calculate `count2`\n        # Total `O(min(N, M/3) * min(N, M))`. Still too slow.\n        \n        # Key observation: The number of items of weight 3 is at most `M/3`.\n        # The number of items of weight 2 is at most `M/2`.\n        # The number of items of weight 1 is at most `M`.\n        # However, the total number of items is `N`.\n        \n        # What if `N` is small, e.g., `N=1000`? Then `O(N^2)` is fine.\n        # But `N=100000`.\n        \n        # The solution must be linear or N log N in N and M.\n        \n        # Let's fix the number of items of weight 3, say `k3`.\n        # Cost is `prefix_sums[3][k3]`. Remaining weight `rem_w = m - k3 * 3`.\n        \n        # Now we need to select items of weight 1 and 2 to fill `rem_w`.\n        # This is a subproblem: given capacity `C`, maximize `sum(c1) + sum(c2)`\n        # such that `sum(w1) + sum(w2) <= C`.\n        \n        # This subproblem can be solved efficiently.\n        # We can combine the items of weight 1 and 2 into a single list of (weight, cost) pairs.\n        # (1, c) for each c in items_by_weight[1]\n        # (2, c) for each c in items_by_weight[2]\n        # Sort them by cost/weight ratio? No, knapsack is not greedy.\n        \n        # The specific structure of weights (1 and 2) allows for optimization.\n        # Create a list of all possible (weight, cost) pairs for items of weight 1 and 2.\n        # Let `dp[w]` be the maximum cost for weight `w` using only items of weight 1 and 2.\n        # This is a knapsack problem.\n        # `dp[w] = max(dp[w-1] + cost_of_best_1, dp[w-2] + cost_of_best_2)`\n        # This is not quite right. It's more like:\n        # `dp[w] = max(dp[w-1] + cost_of_a_1, dp[w-2] + cost_of_a_2)`\n        # This implies using one item at a time.\n        # But we have multiple items of the same weight.\n        \n        # Since we have sorted costs and prefix sums, we can use a two-pointer approach for the 1s and 2s.\n        # Let `k1` be the number of 1-weight items, `k2` be the number of 2-weight items.\n        # We want to maximize `prefix_sums[1][k1] + prefix_sums[2][k2]`\n        # subject to `k1 + 2*k2 <= rem_w`, `k1 <= len(items_by_weight[1])`, `k2 <= len(items_by_weight[2])`.\n        \n        # Iterate `k2` from `min(len(items_by_weight[2]), rem_w // 2)` down to 0.\n        # Maintain `max_cost_1_2` found so far.\n        # For each `k2`:\n        #   `current_cost_2 = prefix_sums[2][k2]`\n        #   `remaining_capacity_for_1 = rem_w - 2 * k2`\n        #   `k1_to_take = min(len(items_by_weight[1]), remaining_capacity_for_1)`\n        #   `current_cost_1 = prefix_sums[1][k1_to_take]`\n        #   `max_cost_1_2 = max(max_cost_1_2, current_cost_1 + current_cost_2)`\n        \n        # This is `O(min(N, M/2))` for the inner loop.\n        # Total `O(min(N, M/3) * min(N, M/2))`. Still too slow.\n        \n        # The maximum number of 1-weight items is `N1`. Max number of 2-weight items is `N2`.\n        # Max number of 3-weight items is `N3`.\n        # `N1 + N2 + N3 = N`.\n        \n        # The total number of items of weight 1 and 2 combined is `N1 + N2`.\n        # The maximum weight `M` is 300000.\n        \n        # What if we iterate on `k1` from 0 to `len(items_by_weight[1])`?\n        # `k1` can be up to `N` or `M`.\n        # `k2` can be up to `N` or `M/2`.\n        \n        # Let's consider the combined problem for items of weight 1 and 2.\n        # We want to find `max(prefix_sums[1][i] + prefix_sums[2][j])` such that `i + 2j <= W`.\n        # This is a standard problem that can be solved in `O(W)` or `O(N)` where N is total items of weight 1 and 2.\n        # Create an array `best_cost_for_1_2[w]` = max cost for weight `w` using only 1s and 2s.\n        # `best_cost_for_1_2[w]` can be computed by iterating `j` (number of 2s) from 0 to `W/2`.\n        # `best_cost_for_1_2[w] = max(best_cost_for_1_2[w], prefix_sums[2][j] + prefix_sums[1][min(len(items_by_weight[1]), w - 2*j)])`.\n        # This takes `O(W)` time.\n        \n        # So, the plan is:\n        # 1. Precompute `best_cost_for_1_2[w]` for `w` from 0 to `M`.\n        #    This takes `O(M * min(N, M/2))` if we iterate `j` for each `w`.\n        #    No, this can be done in `O(M)` or `O(N+M)`.\n        #    Let `max_val_1_2[w]` be the maximum value for capacity `w` using only items of weight 1 and 2.\n        #    `max_val_1_2` array of size `M+1`.\n        #    Iterate `j` (number of 2-weight items) from 0 to `min(len(items_by_weight[2]), M//2)`.\n        #    `cost_2 = prefix_sums[2][j]`.\n        #    `weight_2 = j * 2`.\n        #    For each `j`, we have `cost_2` at `weight_2`.\n        #    We can then add 1-weight items.\n        #    For a fixed `j`, the remaining capacity `W' = W - weight_2`.\n        #    We take `min(len(items_by_weight[1]), W')` items of weight 1.\n        #    This is `prefix_sums[1][min(len(items_by_weight[1]), W')]`.\n        #    So, `max_val_1_2[W] = max(max_val_1_2[W], cost_2 + prefix_sums[1][min(len(items_by_weight[1]), W - weight_2)])`.\n        #    This calculation for `max_val_1_2` takes `O(M * min(N, M/2))` if we compute for each `W` independently.\n        \n        # To compute `max_val_1_2` efficiently:\n        # Iterate `j` from 0 to `len(items_by_weight[2])`.\n        #   `current_cost_2 = prefix_sums[2][j]`\n        #   `current_weight_2 = j * 2`\n        #   We want to find `max(current_cost_2 + prefix_sums[1][k1])` such that `k1 + current_weight_2 <= rem_w`.\n        #   This is what we need to compute for `rem_w`.\n        \n        # Let's create `dp_1_2[w]` = max cost for capacity `w` using only 1-weight and 2-weight items.\n        # `dp_1_2` array of size `M+1`.\n        # Initialize `dp_1_2` with 0s.\n        \n        # Iterate `j` (number of 2-weight items) from 0 to `len(items_by_weight[2])`.\n        #   `cost_2 = prefix_sums[2][j]`\n        #   `weight_2 = j * 2`\n        #   If `weight_2 > M`, break.\n        #   `remaining_capacity_for_1s = M - weight_2`.\n        #   We want to fill `k1` 1-weight items.\n        #   `k1_limit = min(len(items_by_weight[1]), remaining_capacity_for_1s)`.\n        #   `dp_1_2_current_j_cost = cost_2 + prefix_sums[1][k1_limit]`.\n        #   This `dp_1_2_current_j_cost` is the max cost for `M` capacity IF we take exactly `j` 2-weight items.\n        #   This is not what we want. We need `dp_1_2[w]` for ALL `w`.\n        \n        # Correct computation for `dp_1_2[w]`:\n        # `dp_1_2` array of size `M+1`.\n        # Iterate `i` (number of 1-weight items) from 0 to `len(items_by_weight[1])`.\n        #   `cost_1 = prefix_sums[1][i]`\n        #   `weight_1 = i * 1`\n        #   If `weight_1 > M`, break.\n        #   `remaining_capacity = M - weight_1`.\n        #   `j_limit = min(len(items_by_weight[2]), remaining_capacity // 2)`.\n        #   `cost_2 = prefix_sums[2][j_limit]`.\n        #   `dp_1_2[weight_1 + j_limit * 2]` could be `cost_1 + cost_2`.\n        #   This is not how it works. `dp_1_2[w]` is max cost for weight `w`.\n        \n        # Let's re-think `dp_1_2[w]`.\n        # `dp_1_2[w]` stores the maximum cost for exactly weight `w` using items of weight 1 and 2.\n        # This is not what we need. We need maximum cost for AT MOST weight `w`.\n        # Let `max_cost_up_to_w[w]` be the maximum cost for capacity `w`.\n        \n        # The efficient way to compute `max_cost_up_to_w[w]` for 1s and 2s:\n        # `max_cost_up_to_w` array of size `M+1`.\n        # `max_cost_up_to_w[0] = 0`.\n        # Iterate `i` (number of 1-weight items) from 0 to `len(items_by_weight[1])`.\n        #   `current_weight_1 = i * 1`.\n        #   `current_cost_1 = prefix_sums[1][i]`.\n        #   If `current_weight_1 > M`, break.\n        #   `max_cost_up_to_w[current_weight_1] = max(max_cost_up_to_w[current_weight_1], current_cost_1)`.\n        #   (This is not correct, we need to consider 2s as well)\n        \n        # The correct way to precompute `max_cost_for_1_2[w]` (max cost for weight `w` using only 1s and 2s):\n        # `max_cost_for_1_2 = [0] * (M + 1)`\n        # `j` is the number of 2-weight items.\n        # `k` is the number of 1-weight items.\n        # Iterate `j` from 0 to `len(items_by_weight[2])`.\n        #   `cost_j = prefix_sums[2][j]`\n        #   `weight_j = j * 2`\n        #   If `weight_j > M`, break.\n        #   Iterate `k` from 0 to `len(items_by_weight[1])`.\n        #     `cost_k = prefix_sums[1][k]`\n        #     `weight_k = k * 1`\n        #     `total_weight = weight_j + weight_k`\n        #     If `total_weight > M`, break.\n        #     `max_cost_for_1_2[total_weight] = max(max_cost_for_1_2[total_weight], cost_j + cost_k)`\n        # This is `O(N^2)` or `O(M^2)` again.\n        \n        # The problem is that the `k` loop for 1-weight items depends on `j` (number of 2-weight items).\n        # We need to compute `max_cost_for_1_2[rem_w]` efficiently.\n        # Let's define `best_1_2_values[rem_w]` = max cost using 1s and 2s for capacity `rem_w`.\n        # `best_1_2_values = [0] * (M + 1)`\n        # `j` goes from 0 to `len(items_by_weight[2])`.\n        #   `cost_j = prefix_sums[2][j]`.\n        #   `weight_j = j * 2`.\n        #   If `weight_j > M`, continue.\n        #   `remaining_capacity = M - weight_j`.\n        #   `k_limit = min(len(items_by_weight[1]), remaining_capacity)`.\n        #   `current_total_cost = cost_j + prefix_sums[1][k_limit]`.\n        #   This `current_total_cost` is the maximum possible if we use exactly `j` 2-weight items\n        #   and fill the rest with 1-weight items.\n        #   This is `max_cost_for_1_2[weight_j + k_limit]` (if we take exactly `k_limit` 1-weight items).\n        #   This is not `max_cost_for_1_2[rem_w]`.\n        \n        # Let's define `best_cost_for_1s_and_2s[w]` as the maximum cost for a total weight of `w` using only items of weight 1 and 2.\n        # This can be computed in `O(M)` or `O(N+M)` time.\n        # `best_cost_for_1s_and_2s = [0] * (M + 1)`\n        # `idx_1 = len(items_by_weight[1])`\n        # For `w` from 0 to `M`:\n        #   While `idx_1 > 0` and `idx_1 > w`:\n        #     `idx_1 -= 1`\n        #   `best_cost_for_1s_and_2s[w] = prefix_sums[1][idx_1]` (max cost using only 1s for weight w)\n        \n        # This is for \"at most w\". Let's compute `max_cost_for_1_2[w]` as the maximum cost for exactly weight `w`.\n        # No, it's always \"at most\".\n        \n        # Let's compute `max_cost_up_to_W[w]` for 1s and 2s.\n        # `max_cost_up_to_W = [0] * (M + 1)`\n        # `ptr1 = len(items_by_weight[1])`\n        # `current_cost_1 = 0`\n        # For `w` from 0 to `M`:\n        #   `max_cost_up_to_W[w] = max_cost_up_to_W[w-1]` if `w > 0`.\n        #   While `ptr1 > 0` and `items_by_weight[1][ptr1-1]` is a candidate for `w`:\n        #     `current_cost_1 += items_by_weight[1][ptr1-1]`\n        #     `ptr1 -= 1`\n        #   This is not going to work.\n        \n        # The correct approach for `max_cost_for_1_2[w]` (max cost for AT MOST `w` using 1s and 2s):\n        # Initialize `max_cost_for_1_2 = [0] * (M + 1)`.\n        # `j` (number of 2-weight items) from 0 to `len(items_by_weight[2])`.\n        #   `cost_2 = prefix_sums[2][j]`.\n        #   `weight_2 = j * 2`.\n        #   If `weight_2 > M`, break.\n        #   `remaining_capacity_for_1s = M - weight_2`.\n        #   `k_limit = min(len(items_by_weight[1]), remaining_capacity_for_1s)`.\n        #   `current_total_cost = cost_2 + prefix_sums[1][k_limit]`.\n        #   This `current_total_cost` is a candidate for `max_cost_for_1_2[M]`.\n        #   But we need it for `rem_w`.\n        \n        # Let's precompute `max_cost_for_1s_up_to_w[w]` and `max_cost_for_2s_up_to_w[w]`.\n        # `max_cost_for_1s_up_to_w = [0] * (M + 1)`\n        # For `i` from 1 to `M`:\n        #   `num_1s = min(i, len(items_by_weight[1]))`\n        #   `max_cost_for_1s_up_to_w[i] = prefix_sums[1][num_1s]`\n        \n        # `max_cost_for_2s_up_to_w = [0] * (M + 1)`\n        # For `i` from 1 to `M`:\n        #   `num_2s = min(i // 2, len(items_by_weight[2]))`\n        #   `max_cost_for_2s_up_to_w[i] = prefix_sums[2][num_2s]`\n        \n        # This is for only 1s or only 2s. We need combinations.\n        \n        # The standard approach for small weights is DP.\n        # `dp[w]` = max cost for weight `w`.\n        # For item `(wi, ci)`:\n        #   For `w` from `M` down to `wi`:\n        #     `dp[w] = max(dp[w], dp[w-wi] + ci)`\n        # This is `O(N*M)` for general knapsack.\n        # Here, `wi` is small.\n        # We have multiple items of same weight.\n        \n        # Let's fix `count3`.\n        # Remaining weight `rem_w = m - count3 * 3`.\n        # We need to maximize `prefix_sums[1][k1] + prefix_sums[2][k2]` such that `k1 + 2*k2 <= rem_w`.\n        # `k1 <= len(items_by_weight[1])`, `k2 <= len(items_by_weight[2])`.\n        \n        # This subproblem (max value for capacity `rem_w` using 1s and 2s) can be solved with a sliding window/two pointers.\n        # `current_max_cost_1_2 = 0`\n        # `k1 = min(len(items_by_weight[1]), rem_w)`\n        # `current_cost_1 = prefix_sums[1][k1]`\n        # For `k2` from 0 to `min(len(items_by_weight[2]), rem_w // 2)`:\n        #   While `k1 > 0` and `k1 + 2*k2 > rem_w`:\n        #     `k1 -= 1`\n        #     `current_cost_1 -= items_by_weight[1][k1]` (if `k1` was not 0)\n        #   `current_max_cost_1_2 = max(current_max_cost_1_2, current_cost_1 + prefix_sums[2][k2])`\n        \n        # This is the correct approach for the inner loop.\n        # The `k1` pointer only moves left, so it's amortized `O(len(items_by_weight[1]))`.\n        # The `k2` loop runs `O(len(items_by_weight[2]))` times.\n        # So the inner loop is `O(len(items_by_weight[1]) + len(items_by_weight[2])) = O(N)`.\n        \n        # The outer loop for `count3` runs `O(len(items_by_weight[3]))` times.\n        # Total complexity `O(len(items_by_weight[3]) * (len(items_by_weight[1]) + len(items_by_weight[2])))`.\n        # In worst case, `len(items_by_weight[3])` is `N`. `len(items_by_weight[1]) + len(items_by_weight[2])` is `N`.\n        # Still `O(N^2)`.\n        \n        # The number of items of weight 3 can be at most `M/3`.\n        # The number of items of weight 1 and 2 can be at most `N`.\n        # So it's `O(min(N, M/3) * N)`. Still potentially `O(N^2)`.\n        \n        # Example: N=100000, M=300000. All items are weight 3.\n        # `count3` loop runs `N` times. Inner loop (1s and 2s) is `O(1)`. Total `O(N)`.\n        \n        # Example: N=100000, M=300000. All items are weight 1.\n        # `count3` loop runs 1 time (`count3=0`). Inner loop is `O(N)`. Total `O(N)`.\n        \n        # Example: N=100000, M=300000. N/3 items of weight 1, N/3 items of weight 2, N/3 items of weight 3.\n        # `count3` loop runs `N/3` times. Inner loop `O(N/3 + N/3) = O(N)`.\n        # Total `O(N * N) = O(N^2)`. This is the problematic case.\n        \n        # Max N is 10^5, Max M is 3*10^5.\n        # N^2 is 10^10, too slow.\n        \n        # The solution must be `O(M + N)` or `O(M + N log N)`.\n        \n        # Let's re-examine the subproblem: maximize `sum_c1 + sum_c2` for `k1 + 2*k2 <= rem_w`.\n        # This subproblem can be solved in `O(rem_w)` time by DP if `rem_w` is small.\n        # `dp[w]` = max cost for weight `w` using 1s and 2s.\n        # `dp[w] = max(dp[w-1] + cost_of_next_1, dp[w-2] + cost_of_next_2)`\n        # This is not right. This is for 0/1 knapsack with multiple items of same type.\n        \n        # It's a variation of unbounded knapsack.\n        # `dp[w] = max(dp[w-1] + current_best_1_cost, dp[w-2] + current_best_2_cost)`\n        # We have limited quantities of items.\n        \n        # The `best_cost_for_1_2[w]` array should be precomputed.\n        # `best_cost_for_1_2 = [0] * (M + 1)`\n        # `ptr1 = len(items_by_weight[1]) - 1`\n        # `current_cost_1 = 0`\n        # For `w_1_only` from 0 to `M`:\n        #   If `ptr1 >= 0` and `w_1_only > 0`:\n        #     `current_cost_1 += items_by_weight[1][ptr1]`\n        #     `ptr1 -= 1`\n        #   `best_cost_for_1_2[w_1_only] = current_cost_1` (This is just for 1s)\n        \n        # To compute `best_cost_for_1_2[w]` for all `w` up to `M`:\n        # `best_cost_for_1_2 = [0] * (M + 1)`\n        # `idx_1 = 0` (index for items_by_weight[1])\n        # `current_sum_1 = 0`\n        # `max_val_1_2_for_w = 0`\n        \n        # Iterate `w` from 0 to `M`:\n        #   `max_val_1_2_for_w` should be the max cost for capacity `w`.\n        #   This is what we need.\n        #   The values `prefix_sums[1][k1]` are non-decreasing.\n        #   The values `prefix_sums[2][k2]` are non-decreasing.\n        \n        # Let's consider the items of weight 1 and 2 together.\n        # `combined_items = []`\n        # For `c` in `items_by_weight[1]`: `combined_items.append((1, c))`\n        # For `c` in `items_by_weight[2]`: `combined_items.append((2, c))`\n        # Sort `combined_items` by cost/weight ratio? No.\n        \n        # The solution for the 1s and 2s subproblem is:\n        # `max_cost_1_2_memo = [0] * (M + 1)`\n        # `k1_ptr = len(items_by_weight[1])`\n        # `current_cost_1 = prefix_sums[1][k1_ptr]`\n        # For `k2` from 0 to `len(items_by_weight[2])`:\n        #   `current_weight_2 = k2 * 2`\n        #   `cost_2 = prefix_sums[2][k2]`\n        #   While `k1_ptr > 0` and `k1_ptr + current_weight_2 > M`:\n        #     `k1_ptr -= 1`\n        #     `current_cost_1 = prefix_sums[1][k1_ptr]`\n        #   If `k1_ptr + current_weight_2 <= M`:\n        #     `max_cost_1_2_memo[k1_ptr + current_weight_2] = max(max_cost_1_2_memo[k1_ptr + current_weight_2], current_cost_1 + cost_2)`\n        # This fills specific weights. We need \"up to\".\n        \n        # Let's define `best_cost_for_1_2_up_to_w[w]` as the maximum cost for capacity `w` using only items of weight 1 and 2.\n        # `best_cost_for_1_2_up_to_w = [0] * (M + 1)`\n        # `k1 = len(items_by_weight[1])`\n        # `current_sum_1 = prefix_sums[1][k1]`\n        # For `k2` from 0 to `len(items_by_weight[2])`:\n        #   `current_sum_2 = prefix_sums[2][k2]`\n        #   `current_weight_2 = k2 * 2`\n        #   `max_allowed_weight_for_1 = M - current_weight_2`\n        #   While `k1 > 0` and `k1 > max_allowed_weight_for_1`:\n        #     `k1 -= 1`\n        #     `current_sum_1 = prefix_sums[1][k1]`\n        #   If `k1 + current_weight_2 <= M`:\n        #     `best_cost_for_1_2_up_to_w[k1 + current_weight_2] = max(best_cost_for_1_2_up_to_w[k1 + current_weight_2], current_sum_1 + current_sum_2)`\n        \n        # After this loop, `best_cost_for_1_2_up_to_w` contains maximum costs for specific total weights.\n        # We need to make it \"up to\".\n        # For `w` from 1 to `M`: `best_cost_for_1_2_up_to_w[w] = max(best_cost_for_1_2_up_to_w[w], best_cost_for_1_2_up_to_w[w-1])`.\n        \n        # This computation for `best_cost_for_1_2_up_to_w` takes `O(len(items_by_weight[1]) + len(items_by_weight[2]) + M)`.\n        # `len(items_by_weight[1]) + len(items_by_weight[2]) <= N`.\n        # So `O(N + M)`.\n        \n        # This is the breakthrough!\n        # Precompute `best_cost_for_1_2_up_to_w` once in `O(N+M)` time.\n        \n        # Then, the main loop:\n        # `max_total_cost = 0`\n        # For `count3` from 0 to `len(items_by_weight[3])`:\n        #   `weight3 = count3 * 3`\n        #   `cost3 = prefix_sums[3][count3]`\n        #   If `weight3 > m`: break\n        #   `remaining_weight = m - weight3`\n        #   `cost_1_2 = best_cost_for_1_2_up_to_w[remaining_weight]`\n        #   `max_total_cost = max(max_total_cost, cost3 + cost_1_2)`\n        \n        # This loop runs `O(len(items_by_weight[3]))` times.\n        # `len(items_by_weight[3]) <= N`.\n        # So this loop is `O(N)`.\n        \n        # Total complexity: `O(N + M)`. This is efficient enough!\n        \n        # Let's implement the precomputation of `best_cost_for_1_2_up_to_w`.\n        \n    best_cost_for_1_2_up_to_w = [0] * (m + 1)\n    \n    # Initialize `k1_ptr` to the maximum number of 1-weight items that can fit into `m`\n    k1_ptr = len(items_by_weight[1])\n    current_sum_1 = prefix_sums[1][k1_ptr]\n\n    # Iterate `k2` (number of 2-weight items)\n    for k2 in range(len(items_by_weight[2]) + 1):\n        current_sum_2 = prefix_sums[2][k2]\n        current_weight_2 = k2 * 2\n\n        if current_weight_2 > m:\n            break\n\n        # Max capacity remaining for 1-weight items\n        max_allowed_weight_for_1 = m - current_weight_2\n\n        # Adjust k1_ptr so that k1_ptr * 1 <= max_allowed_weight_for_1\n        # and k1_ptr <= len(items_by_weight[1])\n        # We need to find the largest k1_ptr such that k1_ptr <= max_allowed_weight_for_1.\n        # Since k1_ptr is decreasing, this is efficient.\n        while k1_ptr > 0 and k1_ptr > max_allowed_weight_for_1:\n            k1_ptr -= 1\n            current_sum_1 = prefix_sums[1][k1_ptr]\n        \n        # If k1_ptr is 0, current_sum_1 is 0.\n        # If k1_ptr * 1 + current_weight_2 <= m, then we have a valid combination.\n        # The total weight for this combination is `k1_ptr + current_weight_2`.\n        # The total cost is `current_sum_1 + current_sum_2`.\n        \n        # We store this cost at the exact weight `k1_ptr + current_weight_2`.\n        # Note: `k1_ptr` is already `min(len(items_by_weight[1]), max_allowed_weight_for_1)`.\n        # So `k1_ptr + current_weight_2` is the actual weight used.\n        actual_total_weight = k1_ptr + current_weight_2\n        \n        if actual_total_weight <= m:\n            best_cost_for_1_2_up_to_w[actual_total_weight] = max(best_cost_for_1_2_up_to_w[actual_total_weight], current_sum_1 + current_sum_2)\n\n    # Now, convert `best_cost_for_1_2_up_to_w` to store maximum cost for *up to* a given weight.\n    for w in range(1, m + 1):\n        best_cost_for_1_2_up_to_w[w] = max(best_cost_for_1_2_up_to_w[w], best_cost_for_1_2_up_to_w[w-1])\n\n    max_total_cost = 0\n\n    # Iterate `count3` (number of 3-weight items)\n    for count3 in range(len(items_by_weight[3]) + 1):\n        weight3 = count3 * 3\n        cost3 = prefix_sums[3][count3]\n\n        if weight3 > m:\n            break\n\n        remaining_weight = m - weight3\n        \n        # Look up the precomputed max cost for 1s and 2s for the remaining_weight\n        cost_1_2 = best_cost_for_1_2_up_to_w[remaining_weight]\n        \n        max_total_cost = max(max_total_cost, cost3 + cost_1_2)\n\n    print(max_total_cost)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 497,
        "completion_token_count": 11634,
        "thoughts_token_count": 0
    }
}