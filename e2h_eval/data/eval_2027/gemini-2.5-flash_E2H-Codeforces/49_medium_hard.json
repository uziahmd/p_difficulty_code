{
    "start": 1758294878.8797078,
    "end": 1758294969.2965906,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Okay, let's break this down.** The problem, \"Mushroom Strife,\" is a graph problem where we need to figure out the number of mushrooms on each lawn, given GCD and LCM constraints on the edges.  My first thought is that the number of lawns (`n`) and roads (`m`) are up to 100,000, and the mushroom counts are from 1 to 10^6, including GCD and LCM values.\n\n**Understanding the Constraints:** The core constraint is `gcd(x_u, x_v) = g` and `lcm(x_u, x_v) = l` for an edge between lawns `u` and `v`. There's this handy relationship `x_u * x_v = g * l`. Crucially, `l` must be divisible by `g`; otherwise, it's an immediate \"NO\" solution.\n\n**Initial Approach – Try one mushroom count and propagate:** If I knew the number of mushrooms on one lawn, let's say `x_u`, I could calculate `x_v` as `(g * l) / x_u`. Then, I'd have to check if the `gcd(x_u, x_v)` equals `g`. This sounded like a Breadth-First Search (BFS) or Depth-First Search (DFS) would work, starting with a guess and seeing if it checks out.  But, which node to start with, and what mushroom count to choose?  A bit too many possibilities.\n\n**The Prime Factorization Idea:** I realized the GCD and LCM have strong ties to prime factors.  Let's say `x_u` is a product of primes `p` with exponents `e_u`, and `x_v` similarly with exponents `e_v`.  The GCD's exponent for a prime is the *minimum* of `e_u` and `e_v`, while the LCM's exponent is the *maximum*. So, for a given prime `p`, the exponents of `p` in `x_u` and `x_v` must either be `(min, max)` or `(max, min)`.  This became a key insight.\n\n**Making it 2-Colorable:**  This is where things started getting cleaner. Now for *each* prime `p`, the exponents of that prime for two connected nodes have to be *either* `g_p` and `l_p` (from GCD and LCM) on each edge. If `g_p` and `l_p` are the same, both must be. If they're different, one node gets `g_p` and the other gets `l_p`. This is like a 2-coloring problem for each prime! This makes a \"2-SAT\" type constraint, a neat visualization!\n\n**The Plan: Graph + 2-Coloring Per Prime:** I decided to build a graph-like structure. For each prime, iterate through the nodes. Each node initially has an unknown value. Using a modified BFS (or DFS), I'd try to assign exponents, making sure that if `g_p == l_p` for an edge, both nodes get the same exponent. If, during this process, I find a conflict (like a node needing different exponents for the same prime), then \"NO\" solution.  After all the BFS runs per prime, I'd calculate `x_i` for each node by multiplying the powers of the assigned primes (like `p^exponent_p`). There are lots of computations and some initial checks to do:\n\n1.  **Precompute**: Need Sieve of Eratosthenes to get prime factorization and a Smallest Prime Factor array up to 10^6.\n2.  **Parse and initial checks**: Store the edge info.  If `l` isn't divisible by `g`, that's an early \"NO\". Also, need to collect all primes used in the input values.\n3.  **Calculate**: Iterating the nodes to run prime-based BFS and calculate node values.\n4.  **Verification**: After calculations, I should verify again with each edge to make sure `gcd` and `lcm` are consistent, and check if any value exceeded the limit of 10^6.\n\n**Performance Woes**  Problem is my first algorithm has the time complexity issues in the prime factorization step with a large `|P_set|`. That's not efficient.\n\n**Revising to Per-Edge Approach** Now to improve: instead of iterating over the primes, I thought:  \"how about processing the edges?\" For *each* edge, I can factorize the GCD and LCM values, then for each prime `p` factorizing `G` and `L",
    "response": "The problem asks us to restore the number of mushrooms `x_i` on `n` lawns (vertices) given `m` roads (edges). For each road connecting lawns `u` and `v`, we are given `g = gcd(x_u, x_v)` and `l = lcm(x_u, x_v)`. We need to output any valid assignment of `x_i` values (1 to 10^6) or report if no such assignment exists.\n\n**Key Properties:**\n1.  `gcd(a, b) * lcm(a, b) = a * b`. So for an edge `(u, v)` with `g, l`, we must have `x_u * x_v = g * l`.\n2.  `l` must be divisible by `g`. If `l % g != 0` for any edge, no solution exists.\n3.  Prime factorization: Let `p` be a prime. Let `e_{val,p}` be the exponent of `p` in the prime factorization of `val`.\n    Then `e_{g,p} = min(e_{x_u,p}, e_{x_v,p})` and `e_{l,p} = max(e_{x_u,p}, e_{x_v,p})`.\n    This implies that for any prime `p`, the set `{e_{x_u,p}, e_{x_v,p}}` must be equal to `{e_{g,p}, e_{l,p}}`.\n\n**Algorithm Idea:**\nThe problem can be decomposed by prime factors. For each prime `p`, we need to assign an exponent `e_{i,p}` to each lawn `i`. The final `x_i` will be the product of `p^{e_{i,p}}` over all relevant primes `p`.\n\nFor a fixed prime `p` and an edge `(u, v)` with given `g, l`:\nLet `g_p = e_{g,p}` and `l_p = e_{l,p}`.\n1.  If `g_p == l_p`: Then `e_{x_u,p}` must be `g_p` and `e_{x_v,p}` must be `g_p`.\n2.  If `g_p < l_p`: Then `e_{x_u,p}` and `e_{x_v,p}` must be `g_p` and `l_p` in some order. That is, `e_{x_u,p} \\ne e_{x_v,p}`.\n\nThis structure for each prime `p` defines a 2-coloring problem on the graph. For each node `i` and prime `p`, `e_{i,p}` can be one of two values (or one value if `g_p = l_p` for all adjacent edges).\n\n**The Challenge:**\nThe maximum value of `g` or `l` is 10^6. The number of primes up to 10^6 is `pi(10^6) approx 78498`. Running a graph traversal (BFS/DFS) for each prime would be `O(pi(MAX_VAL) * (N + M))`, which is too slow (`7.8 * 10^4 * 2 * 10^5 = 1.5 * 10^{10}`).\n\n**Optimized Approach (Iterating over Edges/Nodes, not Primes):**\n\nInstead of iterating over primes, we iterate over nodes and edges. For each node `i` and each prime `p` that appears in any `g` or `l` value related to `i`, we need to determine `e_{i,p}`.\n\n1.  **Precomputation (Sieve):**\n    Generate `spf` (smallest prime factor) array up to `MAX_VAL = 10^6` using a sieve. This allows efficient prime factorization of any number up to `MAX_VAL`.\n\n2.  **Initial Checks & Data Structures:**\n    -   Store edges: `adj[u]` will store a list of `(v, g, l)` tuples.\n    -   `ans[i]` (for `i=1..n`): Initialize `ans[i] = 1`. This will store the final mushroom counts.\n    -   `node_prime_status[node_idx][prime_factor]`: A dictionary to store information about the exponent for a specific node and prime.\n        -   `0`: Exponent is `g_p` (from some reference edge).\n        -   `1`: Exponent is `l_p`.\n        -   `-1`: Not yet determined.\n    -   `node_prime_values[node_idx][prime_factor]`: A dictionary to store the actual `(g_p, l_p)` pair for a specific prime `p` relevant to node `node_idx`. This is needed because `g_p` and `l_p` can vary across edges.\n    -   `visited_node_prime[node_idx][prime_factor]`: Boolean to track if `(node_idx, prime_factor)` pair has been visited in a BFS.\n\n3.  **Process Edges:**\n    For each input edge `(u, v, g, l)`:\n    -   If `l % g != 0`, print \"NO\" and exit.\n    -   Factorize `g` and `l` using `spf` array.\n    -   For each unique prime `p` that divides `g` or `l`:\n        -   `g_p = e_{g,p}`\n        -   `l_p = e_{l,p}`\n        -   If `(u, p)` not in `node_prime_values`: `node_prime_values[u][p] = (g_p, l_p)`.\n        -   Else if `(g_p, l_p)` is not `node_prime_values[u][p]` AND `(l_p, g_p)` is not `node_prime_values[u][p]`: Conflict! Print \"NO\" and exit.\n        -   Similarly for `(v, p)`.\n        -   If `g_p == l_p`:\n            -   If `node_prime_status[u][p]` is `-1`, set it to `0` (meaning `e_{u,p} = g_p`).\n            -   Else if `node_prime_status[u][p]` is `1` (meaning `e_{u,p} = l_p`), conflict! Print \"NO\" and exit.\n            -   Similarly for `v`.\n\n4.  **BFS for each (node, prime) component:**\n    Iterate `i` from `1` to `n`.\n    For each `p` in `node_prime_values[i]` (primes relevant to node `i`):\n        If `visited_node_prime[i][p]` is false:\n            Start a BFS from `(i, p)`:\n            -   `q = deque([(i, p)])`\n            -   `visited_node_prime[i][p] = True`\n            -   If `node_prime_status[i][p]` is `-1`, set it to `0` (arbitrary initial choice for this component).\n            -   While `q` is not empty:\n                -   `curr_node, curr_p = q.popleft()`\n                -   `curr_status = node_prime_status[curr_node][curr_p]`\n                -   `curr_g_p, curr_l_p = node_prime_values[curr_node][curr_p]`\n                -   `actual_exp_curr_node = curr_g_p if curr_status == 0 else curr_l_p`\n                -   For each neighbor `next_node` of `curr_node` (from `adj[curr_node]`):\n                    -   Let `g_edge, l_edge` be the GCD/LCM for `(curr_node, next_node)`.\n                    -   `next_g_p = e_{g_edge, curr_p}`\n                    -   `next_l_p = e_{l_edge, curr_p}`\n                    -   If `next_g_p == next_l_p`:\n                        -   If `actual_exp_curr_node != next_g_p`: Conflict! Print \"NO\" and exit.\n                        -   If `node_prime_status[next_node][curr_p]` is `-1`:\n                            `node_prime_status[next_node][curr_p] = 0` (meaning `e_{next_node,curr_p} = next_g_p`)\n                            `q.append((next_node, curr_p))`\n                        -   Else if `node_prime_status[next_node][curr_p]` implies `e_{next_node,curr_p} != next_g_p`: Conflict! Print \"NO\" and exit.\n                    -   Else (`next_g_p < next_l_p`):\n                        -   `expected_next_exp = next_g_p if actual_exp_curr_node == next_l_p else next_l_p`\n                        -   If `node_prime_status[next_node][curr_p]` is `-1`:\n                            `node_prime_status[next_node][curr_p] = 0 if expected_next_exp == next_g_p else 1`\n                            `q.append((next_node, curr_p))`\n                        -   Else if `node_prime_status[next_node][curr_p]` implies `e_{next_node,curr_p} != expected_next_exp`: Conflict! Print \"NO\" and exit.\n                    -   Mark `(next_node, curr_p)` as visited.\n\n5.  **Construct `x_i` and Final Verification:**\n    -   For each `i` from `1` to `n`:\n        -   For each `p` in `node_prime_values[i]`:\n            -   `g_p, l_p = node_prime_values[i][p]`\n            -   `exp = g_p if node_prime_status[i][p] == 0 else l_p`\n            -   `ans[i] *= (p ** exp)`\n            -   If `ans[i] > 10^6`: Print \"NO\" and exit.\n    -   For each original edge `(u, v, g, l)`:\n        -   Verify `gcd(ans[u], ans[v]) == g` and `lcm(ans[u], ans[v]) == l`. If not, print \"NO\" and exit.\n\n6.  **Output:** Print \"YES\" and `ans[1] ... ans[n]`.\n\n**Complexity:**\n-   **Sieve:** `O(MAX_VAL log log MAX_VAL)`.\n-   **Processing edges:** Each `g, l` is factorized. A number up to 10^6 has at most `log MAX_VAL` prime factors (e.g., `2^19 < 10^6`). So `m * log MAX_VAL`.\n-   **BFS:** Each `(node, prime)` pair is visited at most once. The total number of such pairs is `N * (max_distinct_prime_factors_per_node)`. A node `i` is involved in `deg(i)` edges. Each edge `(i,j)` contributes `log MAX_VAL` distinct primes. So, total `(node, prime)` pairs is `sum(deg(i) * log MAX_VAL)` over all `i`, which is `M * log MAX_VAL`. Each BFS step involves iterating over neighbors. Total work for all BFSs is `O(M * log MAX_VAL * (degree_of_node_in_prime_graph))`.\n    The crucial part is that `node_prime_values` and `node_prime_status` are dictionaries (hash maps). So operations on them are `O(1)` on average.\n    The total number of `(node, prime)` pairs across all nodes is `O(M * log MAX_VAL)`. Each such pair is pushed onto the queue once. When processing a `(curr_node, curr_p)` pair, we iterate over `deg(curr_node)` neighbors. Each such iteration involves a constant number of dictionary lookups/updates. So total BFS complexity is `O(M * log MAX_VAL)`.\n-   **Construct `x_i` and Final Verification:** `O(M * log MAX_VAL)` for construction, `O(M * log MAX_VAL)` for verification (GCD/LCM calculation).\n\nOverall complexity: `O(MAX_VAL log log MAX_VAL + M log MAX_VAL)`. Given `N, M <= 10^5` and `MAX_VAL = 10^6`, this is efficient enough. `10^6 * log log 10^6` is about `4 * 10^6`. `10^5 * log 10^6` is about `2 * 10^6`.\n\n```python\nimport sys\nfrom collections import deque\n\n# Max value for GCD/LCM\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization as a dictionary {prime: exponent}\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\n# Function to get exponent of a prime in a number\ndef get_exponent(p, n):\n    count = 0\n    if n == 0: return 0 # Should not happen with problem constraints (values >= 1)\n    while n > 1 and spf[n] == p:\n        count += 1\n        n //= p\n    return count\n\n# GCD and LCM for final verification\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    sieve()\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store original edge info for final verification\n\n    # node_prime_values[node_idx][prime_factor] = (g_p, l_p)\n    # This stores the expected (min_exp, max_exp) for (node_idx, prime_factor)\n    # based on its adjacent edges.\n    node_prime_values = [{} for _ in range(n + 1)]\n\n    # node_prime_status[node_idx][prime_factor] = 0 (means exp = g_p) or 1 (means exp = l_p)\n    # -1 means not determined yet.\n    node_prime_status = [{} for _ in range(n + 1)]\n\n    # visited_node_prime[node_idx][prime_factor] = True if (node_idx, prime_factor) has been visited in BFS\n    visited_node_prime = [{} for _ in range(n + 1)]\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, g, l))\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n\n        # Collect all primes involved in this edge\n        all_primes_in_edge = set(g_factors.keys()).union(l_factors.keys())\n\n        for p in all_primes_in_edge:\n            g_p = g_factors.get(p, 0)\n            l_p = l_factors.get(p, 0)\n\n            # Update node_prime_values for u\n            if p not in node_prime_values[u]:\n                node_prime_values[u][p] = (g_p, l_p)\n            else:\n                current_g_p, current_l_p = node_prime_values[u][p]\n                # If current (g_p, l_p) is different from new (g_p, l_p) and (l_p, g_p), then conflict\n                if not ((current_g_p == g_p and current_l_p == l_p) or \\\n                        (current_g_p == l_p and current_l_p == g_p)):\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # If g_p == l_p, then the exponent is fixed for this prime for both nodes\n            if g_p == l_p:\n                if p not in node_prime_status[u]:\n                    node_prime_status[u][p] = 0 # 0 means use g_p\n                elif node_prime_status[u][p] == 1: # Already set to l_p, but g_p == l_p\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # Update node_prime_values for v\n            if p not in node_prime_values[v]:\n                node_prime_values[v][p] = (g_p, l_p)\n            else:\n                current_g_p, current_l_p = node_prime_values[v][p]\n                if not ((current_g_p == g_p and current_l_p == l_p) or \\\n                        (current_g_p == l_p and current_l_p == g_p)):\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            if g_p == l_p:\n                if p not in node_prime_status[v]:\n                    node_prime_status[v][p] = 0\n                elif node_prime_status[v][p] == 1:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n    \n    # BFS to propagate exponent choices\n    q = deque()\n\n    for i in range(1, n + 1):\n        for p in node_prime_values[i]:\n            if p not in visited_node_prime[i]:\n                # Start a new BFS component for (i, p)\n                q.append((i, p))\n                visited_node_prime[i][p] = True\n                \n                if p not in node_prime_status[i]:\n                    node_prime_status[i][p] = 0 # Arbitrarily set to g_p for the first node in component\n\n                while q:\n                    curr_node, curr_p = q.popleft()\n                    \n                    curr_status = node_prime_status[curr_node][curr_p]\n                    curr_g_p, curr_l_p = node_prime_values[curr_node][curr_p]\n                    \n                    actual_exp_curr_node = curr_g_p if curr_status == 0 else curr_l_p\n\n                    for next_node, g_edge, l_edge in adj[curr_node]:\n                        # Check if this prime is relevant for this edge\n                        # If not, it means g_p and l_p are both 0 for this edge\n                        # and actual_exp_curr_node must also be 0.\n                        # If actual_exp_curr_node is not 0, then conflict.\n                        # If actual_exp_curr_node is 0, then next_node's exp for this prime must also be 0.\n                        \n                        next_g_p_edge = get_exponent(curr_p, g_edge)\n                        next_l_p_edge = get_exponent(curr_p, l_edge)\n\n                        if next_g_p_edge == next_l_p_edge: # Exponents must be equal\n                            if actual_exp_curr_node != next_g_p_edge:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                            \n                            if curr_p not in node_prime_status[next_node]:\n                                node_prime_status[next_node][curr_p] = 0 # Use g_p\n                            elif node_prime_status[next_node][curr_p] == 1: # Should be g_p, but it's l_p\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                        else: # Exponents must be different\n                            # If curr_node has g_p, next_node must have l_p\n                            # If curr_node has l_p, next_node must have g_p\n                            expected_next_exp = next_g_p_edge if actual_exp_curr_node == next_l_p_edge else next_l_p_edge\n                            \n                            if curr_p not in node_prime_status[next_node]:\n                                node_prime_status[next_node][curr_p] = 0 if expected_next_exp == next_g_p_edge else 1\n                            else:\n                                next_node_current_exp = node_prime_values[next_node][curr_p][0] if node_prime_status[next_node][curr_p] == 0 else node_prime_values[next_node][curr_p][1]\n                                if next_node_current_exp != expected_next_exp:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                        \n                        if curr_p not in visited_node_prime[next_node]:\n                            visited_node_prime[next_node][curr_p] = True\n                            q.append((next_node, curr_p))\n    \n    # Construct final answers\n    ans = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in node_prime_values[i]:\n            g_p, l_p = node_prime_values[i][p]\n            exp = g_p if node_prime_status[i][p] == 0 else l_p\n            \n            # Check for overflow early\n            if ans[i] > MAX_VAL // (p ** exp) and (p ** exp) > 0: # Avoid division by zero and check for potential overflow\n                 sys.stdout.write(\"NO\\n\")\n                 return\n            \n            ans[i] *= (p ** exp)\n            \n            if ans[i] > MAX_VAL:\n                sys.stdout.write(\"NO\\n\")\n                return\n    \n    # Final verification\n    for u, v, g_orig, l_orig in edges_info:\n        if gcd(ans[u], ans[v]) != g_orig or lcm(ans[u], ans[v]) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n    \n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\n# Max value for GCD/LCM\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization as a dictionary {prime: exponent}\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\n# Function to get exponent of a prime in a number\ndef get_exponent(p, n):\n    count = 0\n    if n == 0: return 0 # Should not happen with problem constraints (values >= 1)\n    while n > 1 and spf[n] == p:\n        count += 1\n        n //= p\n    return count\n\n# GCD and LCM for final verification\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    sieve()\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store original edge info for final verification\n\n    # node_prime_values[node_idx][prime_factor] = (g_p, l_p)\n    # This stores the expected (min_exp, max_exp) for (node_idx, prime_factor)\n    # based on its adjacent edges.\n    node_prime_values = [{} for _ in range(n + 1)]\n\n    # node_prime_status[node_idx][prime_factor] = 0 (means exp = g_p) or 1 (means exp = l_p)\n    # -1 means not determined yet.\n    node_prime_status = [{} for _ in range(n + 1)]\n\n    # visited_node_prime[node_idx][prime_factor] = True if (node_idx, prime_factor) has been visited in BFS\n    visited_node_prime = [{} for _ in range(n + 1)]\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, g, l))\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n\n        # Collect all primes involved in this edge\n        all_primes_in_edge = set(g_factors.keys()).union(l_factors.keys())\n\n        for p in all_primes_in_edge:\n            g_p = g_factors.get(p, 0)\n            l_p = l_factors.get(p, 0)\n\n            # Update node_prime_values for u\n            if p not in node_prime_values[u]:\n                node_prime_values[u][p] = (g_p, l_p)\n            else:\n                current_g_p, current_l_p = node_prime_values[u][p]\n                # If current (g_p, l_p) is different from new (g_p, l_p) and (l_p, g_p), then conflict\n                if not ((current_g_p == g_p and current_l_p == l_p) or \\\n                        (current_g_p == l_p and current_l_p == g_p)):\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # If g_p == l_p, then the exponent is fixed for this prime for both nodes\n            if g_p == l_p:\n                if p not in node_prime_status[u]:\n                    node_prime_status[u][p] = 0 # 0 means use g_p\n                elif node_prime_status[u][p] == 1: # Already set to l_p, but g_p == l_p\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # Update node_prime_values for v\n            if p not in node_prime_values[v]:\n                node_prime_values[v][p] = (g_p, l_p)\n            else:\n                current_g_p, current_l_p = node_prime_values[v][p]\n                if not ((current_g_p == g_p and current_l_p == l_p) or \\\n                        (current_g_p == l_p and current_l_p == g_p)):\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            if g_p == l_p:\n                if p not in node_prime_status[v]:\n                    node_prime_status[v][p] = 0\n                elif node_prime_status[v][p] == 1:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n    \n    # BFS to propagate exponent choices\n    q = deque()\n\n    for i in range(1, n + 1):\n        for p in node_prime_values[i]:\n            if p not in visited_node_prime[i]:\n                # Start a new BFS component for (i, p)\n                q.append((i, p))\n                visited_node_prime[i][p] = True\n                \n                if p not in node_prime_status[i]:\n                    node_prime_status[i][p] = 0 # Arbitrarily set to g_p for the first node in component\n\n                while q:\n                    curr_node, curr_p = q.popleft()\n                    \n                    curr_status = node_prime_status[curr_node][curr_p]\n                    curr_g_p, curr_l_p = node_prime_values[curr_node][curr_p]\n                    \n                    actual_exp_curr_node = curr_g_p if curr_status == 0 else curr_l_p\n\n                    for next_node, g_edge, l_edge in adj[curr_node]:\n                        # Check if this prime is relevant for this edge\n                        # If not, it means g_p and l_p are both 0 for this edge\n                        # and actual_exp_curr_node must also be 0.\n                        # If actual_exp_curr_node is not 0, then conflict.\n                        # If actual_exp_curr_node is 0, then next_node's exp for this prime must also be 0.\n                        \n                        next_g_p_edge = get_exponent(curr_p, g_edge)\n                        next_l_p_edge = get_exponent(curr_p, l_edge)\n\n                        if next_g_p_edge == next_l_p_edge: # Exponents must be equal\n                            if actual_exp_curr_node != next_g_p_edge:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                            \n                            if curr_p not in node_prime_status[next_node]:\n                                node_prime_status[next_node][curr_p] = 0 # Use g_p\n                            elif node_prime_status[next_node][curr_p] == 1: # Should be g_p, but it's l_p\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                        else: # Exponents must be different\n                            # If curr_node has g_p, next_node must have l_p\n                            # If curr_node has l_p, next_node must have g_p\n                            expected_next_exp = next_g_p_edge if actual_exp_curr_node == next_l_p_edge else next_l_p_edge\n                            \n                            if curr_p not in node_prime_status[next_node]:\n                                node_prime_status[next_node][curr_p] = 0 if expected_next_exp == next_g_p_edge else 1\n                            else:\n                                next_node_current_exp = node_prime_values[next_node][curr_p][0] if node_prime_status[next_node][curr_p] == 0 else node_prime_values[next_node][curr_p][1]\n                                if next_node_current_exp != expected_next_exp:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                        \n                        if curr_p not in visited_node_prime[next_node]:\n                            visited_node_prime[next_node][curr_p] = True\n                            q.append((next_node, curr_p))\n    \n    # Construct final answers\n    ans = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in node_prime_values[i]:\n            g_p, l_p = node_prime_values[i][p]\n            exp = g_p if node_prime_status[i][p] == 0 else l_p\n            \n            # Check for overflow early\n            if ans[i] > MAX_VAL // (p ** exp) and (p ** exp) > 0: # Avoid division by zero and check for potential overflow\n                 sys.stdout.write(\"NO\\n\")\n                 return\n            \n            ans[i] *= (p ** exp)\n            \n            if ans[i] > MAX_VAL:\n                sys.stdout.write(\"NO\\n\")\n                return\n    \n    # Final verification\n    for u, v, g_orig, l_orig in edges_info:\n        if gcd(ans[u], ans[v]) != g_orig or lcm(ans[u], ans[v]) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n    \n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 5585,
        "thoughts_token_count": 6795
    }
}