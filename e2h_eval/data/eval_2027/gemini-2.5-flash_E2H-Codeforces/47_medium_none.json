{
    "start": 1758294748.5456796,
    "end": 1758294815.2328107,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**The Neko's Math Problem-Solving Odyssey**\n\nAlright, let's break this down. The core is finding the smallest non-negative integer 'k' that minimizes the least common multiple (lcm) of (a+k) and (b+k).  The user, a programming expert, has identified the crucial relationship:  `lcm(x, y) = (x * y) / gcd(x, y)`.  The user also recognizes that by setting  `x = a+k` and `y = b+k`, and setting `d = b-a`. We have `d >=0`. If `a = b` then `k=0`.\n\nThe key insight is to iterate through divisors `g` of `d`. The user understands `g` must be `gcd(a+k, b-a)`, and  `a+k = X_g`, the smallest multiple of g that is greater or equal to `a`, and this multiple must satisfy a coprime condition. If `d` has only 1 as a divisor, then `b = a`.\n\nThe user initially proposes an iterative approach and recognizes the need to find the smallest  'k' such that  `gcd((a+k)/g, (b-a)/g) = 1` for each `g`. The issue with the iterative approach is that the `g` value can be large and the iterations could potentially take a long time, thus the user then looks to find a direct formula.\n\nThe user then proceeds to look at bounds to see if they can reduce the search. The search continues to analyze bounds, but a more direct approach is needed for the solution. The user then notices a bound on how large the number of divisors can be at the largest values of `a` and `b`. The user also notes how small the primes will be so they are working at the smallest value.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If there are multiple `k` values that yield the same minimum LCM, we choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\nAlso, `y - x = (b+k) - (a+k) = b - a`.\nWithout loss of generality, assume `a <= b`. If `a > b`, we can swap `a` and `b` because `lcm` is symmetric. The resulting `k` will be the same.\nLet `D = b - a`. If `D = 0` (i.e., `a = b`), then `lcm(a+k, a+k) = a+k`. To minimize this, we choose the smallest non-negative `k`, which is `k=0`. So, if `a=b`, the answer is `0`.\n\nNow, assume `a < b`, so `D > 0`.\nLet `g = gcd(x, y) = gcd(a+k, b+k)`.\nWe know `gcd(x, y) = gcd(x, y-x) = gcd(a+k, D)`.\nSo `g` must be a divisor of `D`.\nWe can write `x = g * X'` and `y = g * Y'` for some integers `X'` and `Y'` such that `gcd(X', Y') = 1`.\nSubstituting these into the LCM formula:\n`lcm(x, y) = (g * X' * g * Y') / g = g * X' * Y'`.\n\nFrom `y - x = D`, we have `g * Y' - g * X' = D`, which implies `g * (Y' - X') = D`.\nLet `N = D/g`. Then `Y' - X' = N`.\nSince `gcd(X', Y') = 1`, and `Y' = X' + N`, it must be that `gcd(X', X'+N) = 1`.\nThis simplifies to `gcd(X', N) = 1`.\n\nSo, for each divisor `g` of `D`:\n1. Calculate `N = D/g`.\n2. We need to find the smallest `X'` such that:\n   a. `X' * g >= a` (because `x = a+k` and `k >= 0`). This means `X' >= a/g`.\n      The smallest integer `X'` satisfying this is `m_0 = ceil(a/g) = (a + g - 1) // g`.\n   b. `gcd(X', N) = 1`.\n\nTo find the smallest `X'` that satisfies both conditions, we start checking from `m_0`.\nWe iterate `X' = m_0, m_0+1, m_0+2, ...` and for each `X'`, we check if `gcd(X', N) = 1`. The first `X'` that satisfies this is our candidate `X'_g`.\nOnce we find `X'_g`, we calculate the corresponding `k_g = X'_g * g - a`.\nThe LCM value for this `k_g` is `L_g = g * X'_g * (X'_g + N)`.\nWe keep track of the minimum `L_g` found so far and the smallest `k_g` that achieves it.\n\nThe maximum value of `D = b-a` can be `10^9`. The number of divisors of `D` can be up to `1344` (for `D=735134400`).\nFor each divisor `g`, `N = D/g` can also be up to `10^9`.\nIf we iterate `X'` starting from `m_0` indefinitely, it could be too slow.\nHowever, the function `f(X') = X' * (X'*g + D)` is monotonically increasing for `X' > 0`. This means we truly want the smallest `X'` satisfying the conditions.\n\nThe key observation regarding the search for `X'` is that `N` can have at most about 10 distinct prime factors (e.g., `2*3*5*7*11*13*17*19*23` is already `2.2 * 10^8`).\nLet `P_N` be the set of distinct prime factors of `N`. We need `X'` not to be divisible by any prime in `P_N`.\nWe can use a recursive function or a small loop to find the smallest `X'`.\nFor `N <= 10^9`, the number of distinct prime factors is small. Let `p_1, ..., p_s` be the distinct prime factors of `N`. We need `X' \\not\\equiv 0 \\pmod{p_j}` for all `j`.\nThe smallest `X'` can be found by iterating `X'` from `m_0` upwards.\nHow many values of `X'` do we need to check?\nThe maximum number of distinct prime factors for `N <= 10^9` is 9 (e.g., `2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 \\cdot 19 \\cdot 23 = 223092870`, next prime `29` makes it `6.4 \\cdot 10^9`).\nIf `N` is prime, we check at most 2 values (`m_0` and `m_0+1`).\nIf `N` is composite, we might need to check more.\nThe number of integers `X'` to check is bounded by roughly the product of the first few primes. For example, if `N = 2 \\cdot 3 \\cdot 5 \\cdot 7 = 210`, we might need to check up to 210 values.\nThe maximum value of `m_0` can be `10^9`.\nThe maximum `k` value we need to consider is not excessively large. If `k` is very large, `a+k` and `b+k` are very large, and `lcm(a+k, b+k)` will generally be large unless `gcd(a+k, b-a)` is also very large.\nThe `k` values generated by our method are `X'_g * g - a`. `X'_g` is roughly `a/g`. So `k` is roughly `a - a = 0`. Or `X'_g` could be `a/g + \\delta`. `k` is roughly `\\delta * g`.\nIf `\\delta` is small (e.g., up to `2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 = 510510`), then `k` can be up to `510510 * 10^9 \\approx 5 \\cdot 10^{14}`. This `k` is too large for `a+k` to fit in standard integer types.\nHowever, `a+k = X'_g * g`. `X'_g` is roughly `m_0`. Max `m_0` is `10^9`. Max `g` is `10^9`. `X'_g * g` can be `10^{18}`. This is fine for Python's arbitrary precision integers.\n\nThe maximum number of distinct prime factors `s` is small (at most 9 for `N <= 10^9`).\nThe product of the first `s` primes can be used as a bound for the search range of `X'`.\nThe product of the first 9 primes (`2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 \\cdot 19 \\cdot 23`) is `223092870`.\nThis means that within any range of length `223092870` there must be an `X'` coprime to `N` if `N` uses only these primes.\nThe maximum number of consecutive integers that are NOT coprime to `N` is less than `2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 = 510510` (if `N` is highly composite).\nSo, we need to check at most `~5 \\cdot 10^5` values of `X'` for each `g`.\n`1344` divisors * `5 \\cdot 10^5` checks * `log(N)` for `gcd` is too slow.\n\nA more precise bound for the search for `X'` is related to `rad(N) = \\prod_{p|N} p`.\nWe need to check `X'` in the range `[m_0, m_0 + \\text{some_bound}]`.\nThe maximum value of `rad(N)` for `N <= 10^9` is `2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 \\cdot 19 \\cdot 23 = 223092870`.\nThis is the maximum number of values we might need to check in the worst case. This is still too large.\n\nLet's re-evaluate the complexity.\nThe number of distinct prime factors of `N` is small. Let them be `p_1, ..., p_s`.\nWe need `X' \\not\\equiv 0 \\pmod{p_j}` for all `j`.\nWe can iterate `X'` from `m_0` upwards. For each `X'`, check `gcd(X', N)`.\nA `gcd` operation takes `O(log(N))`.\nIf we check `C` values of `X'`, the total time is `NumDivisors(D) * C * log(N)`.\n`NumDivisors(D)` is max `1344`. `log(N)` is max `log(10^9) \\approx 30`.\nSo `C` must be small. `C` up to `1000` is probably acceptable.\n\nWhat is the maximum `C` needed?\nThe maximum gap between consecutive numbers coprime to `N` can be large.\nFor `N = 2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 = 510510`, the maximum gap is `14`.\nFor `N = 2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 \\cdot 19 = 9699690`, the maximum gap is `18`.\nFor `N = 2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 \\cdot 19 \\cdot 23 = 223092870`, the maximum gap is `22`.\nThese are small gaps. The number `C` of `X'` values to check is very small.\nSo, the iteration `X' = m_0, m_0+1, ...` checking `gcd(X', N)` will be fast enough.\n\nAlgorithm:\n1. Read `a, b`.\n2. If `a > b`, swap `a, b`.\n3. If `a == b`, print `0` and exit.\n4. Calculate `D = b - a`.\n5. Initialize `min_lcm = infinity`, `min_k = 0`.\n6. Find all divisors `g` of `D`.\n   (Iterate `i` from `1` to `sqrt(D)`. If `i` divides `D`, then `i` and `D/i` are divisors.)\n7. For each divisor `g` (both `i` and `D/i`):\n   a. Calculate `N = D/g`.\n   b. Calculate `m_0 = (a + g - 1) // g`.\n   c. Iterate `X_prime` starting from `m_0`.\n      i. If `gcd(X_prime, N) == 1`:\n         This `X_prime` is the smallest valid one for this `g`.\n         Calculate `current_k = X_prime * g - a`.\n         Calculate `current_lcm = X_prime * (X_prime * g + D)`.\n         If `current_lcm < min_lcm`:\n            `min_lcm = current_lcm`\n            `min_k = current_k`\n         Else if `current_lcm == min_lcm`:\n            `min_k = min(min_k, current_k)` (to choose smallest `k`)\n         Break from this inner `X_prime` loop and go to the next `g`.\n      ii. Increment `X_prime`.\n         The number of increments will be very small (at most around 20-30 in practice for `N <= 10^9`).\n8. Print `min_k`.\n\nExample `a=6, b=10`:\n`D = 4`.\nDivisors of `4`: `1, 2, 4`.\n\n`g = 1`:\n  `N = 4/1 = 4`.\n  `m_0 = (6+1-1)//1 = 6`.\n  `X_prime = 6`: `gcd(6,4)=2 != 1`.\n  `X_prime = 7`: `gcd(7,4)=1`. Yes.\n  `k = 7*1 - 6 = 1`. `lcm = 7 * (7*1 + 4) = 7 * 11 = 77`.\n  `min_lcm = 77`, `min_k = 1`.\n\n`g = 2`:\n  `N = 4/2 = 2`.\n  `m_0 = (6+2-1)//2 = 3`.\n  `X_prime = 3`: `gcd(3,2)=1`. Yes.\n  `k = 3*2 - 6 = 0`. `lcm = 3 * (3*2 + 4) = 3 * 10 = 30`.\n  `min_lcm = 30`, `min_k = 0`.\n\n`g = 4`:\n  `N = 4/4 = 1`.\n  `m_0 = (6+4-1)//4 = 2`.\n  `X_prime = 2`: `gcd(2,1)=1`. Yes.\n  `k = 2*4 - 6 = 2`. `lcm = 2 * (2*4 + 4) = 2 * 12 = 24`.\n  `min_lcm = 24`, `min_k = 2`.\n\nFinal result: `min_k = 2`.\n\nPython's `math.gcd` is efficient. Python integers handle arbitrary size, so `10^{18}` for LCM is fine.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a <= b\n    if a > b:\n        a, b = b, a\n\n    D = b - a\n\n    min_lcm = float('inf')\n    min_k = 0\n\n    # Find all divisors of D\n    divisors = set()\n    for i in range(1, int(math.sqrt(D)) + 1):\n        if D % i == 0:\n            divisors.add(i)\n            divisors.add(D // i)\n\n    for g in sorted(list(divisors)): # Sort divisors to ensure smaller k is preferred if LCM is same\n        N = D // g\n        \n        # Smallest X' such that X' * g >= a\n        # This is ceil(a / g)\n        m_0 = (a + g - 1) // g\n\n        X_prime = m_0\n        # We need to find the smallest X_prime >= m_0 such that gcd(X_prime, N) == 1\n        # The number of iterations here is very small in practice (max around 20-30)\n        while True:\n            if math.gcd(X_prime, N) == 1:\n                break\n            X_prime += 1\n        \n        current_k = X_prime * g - a\n        current_lcm = X_prime * (X_prime * g + D) # Simplified: lcm = X' * Y' * g = X' * (X'+N) * g.\n                                                    # No, lcm = X' * g * (X'+N) = X' * (X'g + Ng) = X' * (X'g + D)\n                                                    # This is (a+k) * (b+k) / g, where a+k = X'g.\n                                                    # (X'g * (X'g + D)) / g = X' * (X'g + D)\n        \n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            min_k = current_k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            min_k = min(min_k, current_k)\n\n    print(min_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a <= b\n    if a > b:\n        a, b = b, a\n\n    D = b - a\n\n    min_lcm = float('inf')\n    min_k = 0\n\n    # Find all divisors of D\n    divisors = set()\n    for i in range(1, int(math.sqrt(D)) + 1):\n        if D % i == 0:\n            divisors.add(i)\n            divisors.add(D // i)\n\n    for g in sorted(list(divisors)): # Sort divisors to ensure smaller k is preferred if LCM is same\n        N = D // g\n        \n        # Smallest X' such that X' * g >= a\n        # This is ceil(a / g)\n        m_0 = (a + g - 1) // g\n\n        X_prime = m_0\n        # We need to find the smallest X_prime >= m_0 such that gcd(X_prime, N) == 1\n        # The number of iterations here is very small in practice (max around 20-30)\n        while True:\n            if math.gcd(X_prime, N) == 1:\n                break\n            X_prime += 1\n        \n        current_k = X_prime * g - a\n        current_lcm = X_prime * (X_prime * g + D) # Simplified: lcm = X' * Y' * g = X' * (X'+N) * g.\n                                                    # No, lcm = X' * g * (X'+N) = X' * (X'g + Ng) = X' * (X'g + D)\n                                                    # This is (a+k) * (b+k) / g, where a+k = X'g.\n                                                    # (X'g * (X'g + D)) / g = X' * (X'g + D)\n        \n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            min_k = current_k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            min_k = min(min_k, current_k)\n\n    print(min_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 412,
        "completion_token_count": 4099,
        "thoughts_token_count": 6193
    }
}