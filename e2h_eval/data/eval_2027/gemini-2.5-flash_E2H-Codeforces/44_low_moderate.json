{
    "start": 1758284901.0170867,
    "end": 1758284962.9552236,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Thinking Through \"Polycarp's Practice\"**\n\nOkay, so I've got this \"Polycarp's Practice\" problem, and I need to come up with a Python solution. The core of it seems pretty straightforward: given a list of problem difficulties and a number of days, I want to split those problems across the days to maximize the total \"profit,\" which is the sum of the maximum difficulty achieved each day.\n\nMy initial thought is that to maximize the overall profit, I should try to make the daily maximums as large as possible. If I can control which problems contribute to each day's maximum, that's the key.\n\nLet's break this down further. I need to consider all possible ways to split the `n` problems into `k` contiguous segments. The \"profit\" for each segment is simply the highest difficulty within that segment. The overall profit is the sum of these daily maximum difficulties.\n\nNow, a key insight pops out: to maximize the sum of these `k` maximums, I should focus on the largest values in the input array. It makes intuitive sense - if I can ensure the largest difficulties contribute to the sum, I'm already on the right track.\n\nThe key is in efficiently selecting these segment boundaries, and my current thinking leads me to this algorithm:\n1.  **Identify the `k` largest values:** Pick the `k` largest difficulties in the array. This sounds like an initial, promising strategy.\n2.  **Ensure each is the maximum:** Arrange the segments such that each one of these largest values becomes the maximum for one of the `k` days.\n\nIt seems achievable, if I am able to construct these segments correctly. This way, the total profit would simply be the sum of these `k` largest values.  It seems that this approach also works with duplicates of the largest numbers.\n\nIn short, I'm pretty confident that if I can successfully partition the input array to make each of the `k` largest difficulties be the maximum of one of the `k` days, I'll have the optimal solution. Now I just need to figure out the most efficient way to achieve this segmentation in Python.\n",
    "response": "The problem asks us to partition `n` problems into `k` contiguous segments (days), such that the sum of the maximum difficulties in each segment is maximized. We also need to output the number of problems solved each day.\n\n**Strategy:**\n\nTo maximize the sum of `k` daily profits, we should try to make each daily profit as large as possible. The optimal strategy is to identify the `k` largest problem difficulties in the entire list `a`. Let these `k` largest difficulties be `v_1, v_2, \\dots, v_k`. The maximum possible total profit will be the sum `v_1 + v_2 + \\dots + v_k`.\n\nWhy? Suppose we achieve a total profit `P`. This `P` is the sum of `k` daily maximums. Each daily maximum `m_j` must be one of the `a_i` values. If we sort all `a_i` values in descending order, say `a'_1 \\ge a'_2 \\ge \\dots \\ge a'_n`, then the sum of any `k` values chosen from `a` cannot exceed `a'_1 + a'_2 + \\dots + a'_k`. Since we can always make these `k` largest values the maximums of their respective days, this sum is achievable.\n\n**Implementation Steps:**\n\n1.  **Find the `k` largest values and their original indices:**\n    *   Create pairs `(difficulty, index)` for each problem.\n    *   Sort these pairs in descending order based on difficulty.\n    *   Take the top `k` pairs. These represent the `k` largest difficulties.\n    *   The sum of these `k` difficulties is our maximum total profit.\n\n2.  **Determine the daily partitions:**\n    *   Collect the original indices of these `k` largest difficulties. Let these be `idx_1, idx_2, \\dots, idx_k`.\n    *   Sort these indices in ascending order. These sorted indices will mark the *end* of each day's problems (except possibly the last day).\n    *   The first day will end at `idx_1`. The second day will end at `idx_2`, and so on, up to `idx_{k-1}`. The last day will contain all problems from `idx_{k-1} + 1` to `n`.\n    *   The number of problems for the first day `t_1` is `idx_1 + 1` (since indices are 0-based).\n    *   For subsequent days `j` from 2 to `k-1`, `t_j` is `idx_j - idx_{j-1}`.\n    *   For the last day `t_k`, it's `n - (idx_{k-1} + 1) + 1 = n - idx_{k-1}`.\n    *   A simpler way to calculate `t_j` values:\n        *   Initialize `current_index = -1`.\n        *   For each sorted `idx_j` (where `j` goes from 0 to `k-2` for 0-based indexing of sorted indices):\n            *   `t_{j+1} = idx_j - current_index`.\n            *   `current_index = idx_j`.\n        *   The last `t_k` is `n - 1 - current_index`.\n\n**Example:** `n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Pairs (difficulty, index):**\n    `[(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\n\n2.  **Sort by difficulty (descending), take top k=3:**\n    `[(9,6), (6,3), (5,0)]` (or `(5,4)` instead of `(5,0)` if `(5,0)` is tied for 3rd, either is fine).\n    Let's pick `(9,6), (6,3), (5,0)`.\n    Maximum total profit: `9 + 6 + 5 = 20`.\n\n3.  **Original indices of these top difficulties:**\n    `[6, 3, 0]`\n\n4.  **Sort indices:**\n    `[0, 3, 6]`\n\n5.  **Calculate `t_j` values:**\n    *   `current_index = -1`\n    *   `idx_0 = 0`: `t_1 = 0 - (-1) = 1`. `current_index = 0`.\n    *   `idx_1 = 3`: `t_2 = 3 - 0 = 3`. `current_index = 3`.\n    *   `idx_2 = 6`: `t_3 = 6 - 3 = 3`. `current_index = 6`.\n    *   This gives `t = [1, 3, 3]`. This is not `3 2 3`. The issue is that `idx_j` is the index of the *maximum element* in a segment, not necessarily the *end* of the segment.\n\n**Revised Partition Logic:**\n\nThe `k` largest elements must each be the maximum of one day. To ensure this, each of these `k` elements *must be included* in a day. We can use their positions to define the *breakpoints* between days.\n\n1.  **Find `k` largest values and their indices:**\n    *   `a_indexed = [(a[i], i) for i in range(n)]`\n    *   Sort `a_indexed` by difficulty descending: `sorted_a = sorted(a_indexed, key=lambda x: x[0], reverse=True)`\n    *   Take the first `k` elements: `top_k_elements = sorted_a[:k]`\n    *   Calculate `max_profit = sum(x[0] for x in top_k_elements)`\n    *   Get their original indices: `top_k_indices = sorted([x[1] for x in top_k_elements])`\n\n2.  **Construct `t_j`:**\n    *   `t = []`\n    *   `current_start_index = 0`\n    *   Iterate through `top_k_indices` (which are sorted):\n        *   For the first `k-1` indices in `top_k_indices`:\n            *   The current day ends at `top_k_indices[i]`.\n            *   The number of problems for this day is `top_k_indices[i] - current_start_index + 1`.\n            *   Add this to `t`.\n            *   Set `current_start_index = top_k_indices[i] + 1` for the next day.\n        *   The last day takes all remaining problems: `n - current_start_index`.\n            *   Add this to `t`.\n            *   This logic needs to be careful for the last day.\n\n**Correct Partition Logic (simpler):**\n\nThe `k` largest values define `k-1` breakpoints.\nLet `top_k_indices` be the sorted 0-based indices of the `k` largest problems.\nFor `k=1`, there are no breakpoints. `t = [n]`.\nFor `k > 1`:\nThe first `k-1` values in `top_k_indices` (i.e., `top_k_indices[0]` to `top_k_indices[k-2]`) are the indices where we *must* make a cut.\nThe problems `a[0]` to `a[top_k_indices[0]]` form the first day.\nThe problems `a[top_k_indices[0]+1]` to `a[top_k_indices[1]]` form the second day.\n...\nThe problems `a[top_k_indices[k-2]+1]` to `a[n-1]` form the last day.\n\nLet's re-trace `n=8, k=3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n`top_k_elements = [(9,6), (6,3), (5,0)]` (using indices 6, 3, 0)\n`max_profit = 20`\n`top_k_indices = sorted([6, 3, 0]) = [0, 3, 6]`\n\n`t = []`\n`current_start = 0`\nFor `i` from `0` to `k-2` (i.e., `0` to `1`):\n  `breakpoint_index = top_k_indices[i]`\n  `problems_this_day = breakpoint_index - current_start + 1`\n  `t.append(problems_this_day)`\n  `current_start = breakpoint_index + 1`\n\n*   `i = 0`: `breakpoint_index = top_k_indices[0] = 0`\n    `problems_this_day = 0 - 0 + 1 = 1`\n    `t = [1]`\n    `current_start = 0 + 1 = 1`\n\n*   `i = 1`: `breakpoint_index = top_k_indices[1] = 3`\n    `problems_this_day = 3 - 1 + 1 = 3`\n    `t = [1, 3]`\n    `current_start = 3 + 1 = 4`\n\nAfter the loop (for `k-1` days), the remaining problems form the last day:\n`problems_last_day = n - current_start`\n`t.append(problems_last_day)`\n`t = [1, 3, 8 - 4 = 4]` -> `[1, 3, 4]`. Sum `1+3+4 = 8`. This is a valid split.\nProfit for `[5]`, `[4,2,6]`, `[5,1,9,2]` is `5 + 6 + 9 = 20`. This is correct.\n\nThe example output `3 2 3` is also a valid split with profit 20.\n`[5, 4, 2]` (max 5)\n`[6, 5]` (max 6)\n`[1, 9, 2]` (max 9)\nThis implies that the choice of `k` largest values (if there are ties) can affect the `t_j` values, but not the total profit. The problem states \"If there are many possible answers, you may print any of them.\" So my approach is valid.\n\nLet's check the example output `3 2 3`.\nThe breakpoints are after 3 problems, then after 2 problems.\nIndices are `0,1,2 | 3,4 | 5,6,7`.\nThe maximums are `a[0]=5`, `a[3]=6`, `a[6]=9`. These are indeed the same 3 maximum values (`5, 6, 9`).\n\nMy current logic for `t_j` produces `[1, 3, 4]`.\nThis is based on using `a[0]` as the maximum for day 1, `a[3]` for day 2, `a[6]` for day 3.\nThe example output uses `a[2]` as max for day 1, `a[3]` for day 2, `a[6]` for day 3.\n`a[0]=5, a[1]=4, a[2]=2`. Max is `5`.\n`a[3]=6, a[4]=5`. Max is `6`.\n`a[5]=1, a[6]=9, a[7]=2`. Max is `9`.\nThis means the indices chosen for the `k` maximums could be different.\nThe original `a = [5, 4, 2, 6, 5, 1, 9, 2]`\nThe values `5, 6, 9` are the top 3.\nThere are two `5`s: `a[0]=5` and `a[4]=5`.\nIf we choose `(9,6), (6,3), (5,4)` (i.e. indices `6,3,4`), then sorted indices are `[3,4,6]`.\n`current_start = 0`\n`i = 0`: `breakpoint_index = 3`. `t_1 = 3 - 0 + 1 = 4`. `t = [4]`. `current_start = 4`.\n`i = 1`: `breakpoint_index = 4`. `t_2 = 4 - 4 + 1 = 1`. `t = [4, 1]`. `current_start = 5`.\nLast day: `t_3 = 8 - 5 = 3`. `t = [4, 1, 3]`.\nProfit for `[5,4,2,6]`, `[5]`, `[1,9,2]` is `6 + 5 + 9 = 20`. This is also valid.\n\nThe key is that the `k` largest values *must* be chosen. Their specific indices determine the breakpoints.\nThe problem statement example for `[5, 4, 2], [6, 5], [1, 9, 2]` uses `a[0]=5` as the max for day 1, `a[3]=6` for day 2, `a[6]=9` for day 3.\nThe indices of these maximums are `0, 3, 6`.\nIf we sort these indices: `[0, 3, 6]`.\nDay 1 ends at `index 0 + (number of problems - 1)`.\nThis means the breakpoint is *after* the problem at `top_k_indices[i]`.\nThe `k-1` breakpoints are at `top_k_indices[0]`, `top_k_indices[1]`, ..., `top_k_indices[k-2]`.\n\nLet's use the example output's choice of indices: `0, 3, 6`.\n`top_k_indices = [0, 3, 6]`\n`t = []`\n`prev_breakpoint = -1` (conceptually, problems start before index 0)\nFor `i` from `0` to `k-2`:\n  `current_breakpoint = top_k_indices[i]`\n  `t.append(current_breakpoint - prev_breakpoint)`\n  `prev_breakpoint = current_breakpoint`\n`t.append(n - 1 - prev_breakpoint)` (problems from `prev_breakpoint + 1` to `n-1`)\n\nLet's try this logic:\n`top_k_indices = [0, 3, 6]`\n`prev_breakpoint = -1`\n`i = 0`: `current_breakpoint = 0`. `t.append(0 - (-1)) = 1`. `t = [1]`. `prev_breakpoint = 0`.\n`i = 1`: `current_breakpoint = 3`. `t.append(3 - 0) = 3`. `t = [1, 3]`. `prev_breakpoint = 3`.\nLoop ends.\nLast day: `t.append(n - 1 - prev_breakpoint) = 8 - 1 - 3 = 4`. `t = [1, 3, 4]`.\nThis is still `[1, 3, 4]`.\n\nThe example output `3 2 3` implies that the breakpoints are not necessarily at the exact indices of the maximums.\nThe breakpoints are *between* problems.\nDay 1: `[5, 4, 2]` (3 problems). Max is `5` at index `0`.\nDay 2: `[6, 5]` (2 problems). Max is `6` at index `3`.\nDay 3: `[1, 9, 2]` (3 problems). Max is `9` at index `6`.\nThe indices of the chosen maximums are `0, 3, 6`.\nThe *cuts* are after index `2` and after index `4`.\n`t_1 = 3` (problems `0, 1, 2`)\n`t_2 = 2` (problems `3, 4`)\n`t_3 = 3` (problems `5, 6, 7`)\n\nThis means the `k-1` cuts are placed such that each of the `k` selected maximums falls into its own segment.\nThe `k` selected maximums are `a[0]=5`, `a[3]=6`, `a[6]=9`. Their indices are `0, 3, 6`.\nWe need to make `k-1` cuts. The cuts must be placed *after* the problem `a_i` and *before* `a_{i+1}`.\nThe first cut must be somewhere between `a[0]` and `a[3]`.\nThe second cut must be somewhere between `a[3]` and `a[6]`.\nThe most straightforward way to ensure each maximum is in its own segment and to make the segments as balanced as possible (which often leads to simpler construction) is to place the cuts *just before* the `k` largest elements (except the first one).\n\nLet's use `top_k_indices = [0, 3, 6]`\nThe cuts are at:\n1.  After `top_k_indices[0]` (problem `a[0]`) but before `top_k_indices[1]` (problem `a[3]`).\n2.  After `top_k_indices[1]` (problem `a[3]`) but before `top_k_indices[2]` (problem `a[6]`).\n\nThis means the `k-1` cut points are `top_k_indices[0]`, `top_k_indices[1]`, ..., `top_k_indices[k-2]`.\nThese are the indices *after which* we make a cut.\nThe problem is that the problem statement for `3 2 3` has cuts at index 2 and index 4. These are not the indices of the max elements.\n\nThe simplest way to satisfy the conditions is:\n1.  Find the `k` largest values and their indices.\n2.  Sum these `k` values for the total profit.\n3.  Sort the indices of these `k` values: `idx_1, idx_2, \\dots, idx_k`.\n4.  The `k-1` cut points will be at `idx_1, idx_2, \\dots, idx_{k-1}`.\n    This means the first day ends at `idx_1`.\n    The second day ends at `idx_2`.\n    ...\n    The `(k-1)`-th day ends at `idx_{k-1}`.\n    The `k`-th day ends at `n-1`.\n\nLet's try this with `top_k_indices = [0, 3, 6]` for `n=8, k=3`.\nThe `k-1=2` cut points are `0` and `3`.\n`t = []`\n`current_start = 0`\nFor `i` from `0` to `k-2`:\n  `cut_at_index = top_k_indices[i]`\n  `t.append(cut_at_index - current_start + 1)`\n  `current_start = cut_at_index + 1`\nFinally, `t.append(n - current_start)`\n\n*   `i = 0`: `cut_at_index = top_k_indices[0] = 0`.\n    `t.append(0 - 0 + 1) = 1`. `t = [1]`.\n    `current_start = 0 + 1 = 1`.\n*   `i = 1`: `cut_at_index = top_k_indices[1] = 3`.\n    `t.append(3 - 1 + 1) = 3`. `t = [1, 3]`.\n    `current_start = 3 + 1 = 4`.\nLoop ends.\n`t.append(8 - 4) = 4`. `t = [1, 3, 4]`.\nThis is exactly what I got before, and it works. The profit is 20.\n\nThe example output `3 2 3` is just *one* possible distribution. My `[1, 3, 4]` is another. Both yield 20 profit.\nMy strategy is simpler and guaranteed to work: Pick the `k` largest values. Their sum is the max profit. Use their indices as breakpoints. The `i`-th breakpoint is after `top_k_indices[i]` (for `i` from `0` to `k-2`). The last segment takes everything remaining.\n\nLet's consider edge cases:\n*   `k = 1`: `top_k_indices` will have one element. The loop for `k-2` will not run. `current_start` remains `0`. `t.append(n - 0) = n`. Correct.\n*   `k = n`: Each problem is a day. `top_k_indices` will contain `0, 1, ..., n-1`.\n    `current_start = 0`.\n    For `i` from `0` to `n-2`:\n        `cut_at_index = i`.\n        `t.append(i - current_start + 1)`.\n        `current_start = i + 1`.\n        This will append `1` for each day. `t = [1, 1, ..., 1]` (n-1 times).\n    Last day: `t.append(n - current_start) = n - (n-1) = 1`.\n    So `t = [1, 1, ..., 1]` (n times). Correct.\n\nThe logic seems solid.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Find the k largest values and their original indices\n    # Create pairs of (difficulty, original_index)\n    indexed_problems = []\n    for i in range(n):\n        indexed_problems.append((a[i], i))\n\n    # Sort problems by difficulty in descending order\n    # If difficulties are equal, the order of indices doesn't matter for profit,\n    # but it might change the specific partition.\n    indexed_problems.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k problems\n    top_k_problems = indexed_problems[:k]\n\n    # Calculate the maximum total profit\n    max_total_profit = sum(p[0] for p in top_k_problems)\n\n    # Step 2: Determine the daily partitions\n    # Get the original indices of these top k problems\n    top_k_indices = []\n    for p in top_k_problems:\n        top_k_indices.append(p[1])\n\n    # Sort these indices to define breakpoints in increasing order\n    top_k_indices.sort()\n\n    # The t_j values (number of problems per day)\n    t_values = []\n    current_start_index = 0 # 0-based index for the start of the current day's problems\n\n    # We need k-1 breakpoints. The i-th breakpoint is after problem top_k_indices[i].\n    # This ensures that top_k_indices[i] is included in day i+1.\n    # The last day takes all remaining problems.\n    for i in range(k - 1):\n        # The current day (day i+1) will end at top_k_indices[i]\n        # Number of problems for this day: (end_index - start_index + 1)\n        problems_this_day = top_k_indices[i] - current_start_index + 1\n        t_values.append(problems_this_day)\n        # The next day starts right after this one ends\n        current_start_index = top_k_indices[i] + 1\n    \n    # The last day takes all problems from current_start_index to n-1\n    problems_last_day = n - current_start_index\n    t_values.append(problems_last_day)\n\n    # Print the results\n    sys.stdout.write(str(max_total_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, t_values)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Find the k largest values and their original indices\n    # Create pairs of (difficulty, original_index)\n    indexed_problems = []\n    for i in range(n):\n        indexed_problems.append((a[i], i))\n\n    # Sort problems by difficulty in descending order\n    # If difficulties are equal, the order of indices doesn't matter for profit,\n    # but it might change the specific partition.\n    indexed_problems.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k problems\n    top_k_problems = indexed_problems[:k]\n\n    # Calculate the maximum total profit\n    max_total_profit = sum(p[0] for p in top_k_problems)\n\n    # Step 2: Determine the daily partitions\n    # Get the original indices of these top k problems\n    top_k_indices = []\n    for p in top_k_problems:\n        top_k_indices.append(p[1])\n\n    # Sort these indices to define breakpoints in increasing order\n    top_k_indices.sort()\n\n    # The t_j values (number of problems per day)\n    t_values = []\n    current_start_index = 0 # 0-based index for the start of the current day's problems\n\n    # We need k-1 breakpoints. The i-th breakpoint is after problem top_k_indices[i].\n    # This ensures that top_k_indices[i] is included in day i+1.\n    # The last day takes all remaining problems.\n    for i in range(k - 1):\n        # The current day (day i+1) will end at top_k_indices[i]\n        # Number of problems for this day: (end_index - start_index + 1)\n        problems_this_day = top_k_indices[i] - current_start_index + 1\n        t_values.append(problems_this_day)\n        # The next day starts right after this one ends\n        current_start_index = top_k_indices[i] + 1\n    \n    # The last day takes all problems from current_start_index to n-1\n    problems_last_day = n - current_start_index\n    t_values.append(problems_last_day)\n\n    # Print the results\n    sys.stdout.write(str(max_total_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, t_values)) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 973,
        "completion_token_count": 5743,
        "thoughts_token_count": 766
    }
}