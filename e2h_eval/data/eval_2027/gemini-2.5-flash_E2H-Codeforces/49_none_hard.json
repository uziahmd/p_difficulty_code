{
    "start": 1758293741.4984288,
    "end": 1758293784.1385086,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    \n    # Precompute primes up to sqrt(10^6) = 1000\n    MAX_VAL = 10**6\n    primes = []\n    is_prime = [True] * (1001)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, 1001):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p * p, 1001, p):\n                is_prime[multiple] = False\n\n    def get_prime_factors(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num:\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1:\n            factors[temp_num] = factors.get(temp_num, 0) + 1\n        return factors\n\n    # Store prime factorizations for all numbers from 1 to 10^6\n    # For each number x, factors_list[x] is a dictionary {p: count}\n    factors_list = [None] * (MAX_VAL + 1)\n    for i in range(1, MAX_VAL + 1):\n        factors_list[i] = get_prime_factors(i)\n\n    def check_consistency(u_val, v_val, g, l):\n        if g == 0 or l == 0: return False # Should not happen based on constraints 1 <= g, l\n        if (u_val * v_val) % (g * l) != 0: return False\n        if u_val % g != 0 or v_val % g != 0: return False\n        if l % u_val != 0 or l % v_val != 0: return False\n\n        # Check prime factor powers\n        u_factors = factors_list[u_val]\n        v_factors = factors_list[v_val]\n        g_factors = factors_list[g]\n        l_factors = factors_list[l]\n\n        all_primes = set()\n        all_primes.update(u_factors.keys())\n        all_primes.update(v_factors.keys())\n        all_primes.update(g_factors.keys())\n        all_primes.update(l_factors.keys())\n\n        for p in all_primes:\n            u_exp = u_factors.get(p, 0)\n            v_exp = v_factors.get(p, 0)\n            g_exp = g_factors.get(p, 0)\n            l_exp = l_factors.get(p, 0)\n\n            if min(u_exp, v_exp) != g_exp:\n                return False\n            if max(u_exp, v_exp) != l_exp:\n                return False\n        return True\n\n    # Try to assign a value to an unassigned node\n    # Use BFS/DFS to propagate values\n    q = []\n    \n    # Find a node with at least one edge to start\n    start_node = -1\n    for i in range(1, n + 1):\n        if adj[i]:\n            start_node = i\n            break\n    \n    if start_node == -1: # No edges, all nodes can be 1\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    # Start with an arbitrary value for the first node in the first edge\n    # The possible values for a node x connected to y with (g, l) are divisors of l\n    # and multiples of g. Specifically, x must be of the form (g * l) / y.\n    # We can pick any value for one node, say u, that is a divisor of l and a multiple of g.\n    # The number of mushrooms on a lawn 'x' must be a divisor of LCM for any edge connected to 'x'.\n    # It must also be a multiple of GCD for any edge connected to 'x'.\n    # So, for a node 'u', its value 'ans[u]' must divide LCM and be a multiple of GCD for all its edges.\n    # Let's find the product of all unique prime factors of all L's. This might be too large.\n    \n    # A better approach: for each node, determine the minimum possible value (min_val)\n    # and maximum possible value (max_val) based on all connected edges.\n    # min_val = LCM of all GCDs for edges connected to node u\n    # max_val = GCD of all LCMs for edges connected to node u\n    \n    # This is not quite right. For an edge (u, v, g, l), u must be a divisor of l, v must be a divisor of l.\n    # Also, u must be a multiple of g, v must be a multiple of g.\n    # And (u * v) == (g * l). So v = (g * l) / u.\n    \n    # We can try to assign a value to node 1.\n    # The possible values for node 1 are divisors of LCMs it's connected to.\n    # Let's find the smallest LCM it's connected to.\n    \n    # For each node, find the product of all GCDs and LCMs it's involved in.\n    # The actual value must be a divisor of all LCMs and a multiple of all GCDs.\n    \n    # Let's try to fix a value for the first node encountered in the input that has an edge.\n    # For node `u` in an edge `(u, v, g, l)`, `u` must be a divisor of `l`.\n    # `u` must also be a multiple of `g`.\n    # And `u * v = g * l`.\n    # So `v = (g * l) / u`.\n    \n    # Let's pick the first edge (u0, v0, g0, l0).\n    # We need to assign ans[u0] and ans[v0].\n    # Possible values for ans[u0] are divisors of l0 that are multiples of g0.\n    # For each such possible ans[u0], calculate ans[v0] = (g0 * l0) / ans[u0].\n    # Then check if ans[u0] and ans[v0] are consistent with g0, l0.\n    # If they are, then we can start a BFS/DFS from u0 and v0.\n    \n    # A crucial observation: For any edge (u, v, g, l), the value of u must be a divisor of l.\n    # Also, the value of u must be a multiple of g.\n    # So, u must be of the form `g * k` where `k` is a divisor of `l/g`.\n    # And `v = (g * l) / u`.\n    \n    # The values can be up to 10^6. A node can have many divisors.\n    # The number of divisors of 720720 (max number of divisors up to 10^6) is 240.\n    # Trying all divisors for one node might be too slow if we have to do it for many nodes.\n    \n    # The problem is that the values are not unique. We need to find *any* solution.\n    # This suggests that there might be a \"canonical\" way to assign values, or a way to simplify the search.\n    \n    # For each prime factor p, let u_exp be its exponent in ans[u] and v_exp in ans[v].\n    # Then min(u_exp, v_exp) = g_exp and max(u_exp, v_exp) = l_exp.\n    # This means for each prime p, the pair (u_exp, v_exp) must be either (g_exp, l_exp) or (l_exp, g_exp).\n    # This gives 2 choices for each prime factor.\n    # If l/g has many prime factors, this can lead to 2^k choices.\n    # E.g., if l/g = 2*3*5*7*11*13 (6 distinct prime factors), then 2^6 = 64 choices for u_val.\n    # Max distinct prime factors for a number <= 10^6 is 7 (e.g., 2*3*5*7*11*13*17 = 510510).\n    # So 2^7 = 128 choices for a single node's value. This is manageable.\n\n    # Let's try to assign values based on prime factor exponents.\n    # For each node `i`, `ans[i]` will be constructed by determining the exponent of each prime `p`.\n    # `node_prime_exponents[i][p]` will store the exponent of `p` in `ans[i]`.\n    \n    node_prime_exponents = [{} for _ in range(n + 1)]\n    \n    # Keep track of which nodes have fixed prime exponents\n    # `fixed_prime_exponents[i][p]` is True if exponent of p for node i is determined.\n    fixed_prime_exponents = [{} for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS-like propagation\n    # Queue stores (node_id, prime, exponent)\n    q_exponents = []\n\n    # Initialize all nodes to 1 (all prime exponents are 0)\n    for i in range(1, n + 1):\n        ans[i] = 1\n\n    # For each edge (u, v, g, l):\n    # For each prime p in factors_list[g] or factors_list[l]:\n    #   g_exp = factors_list[g].get(p, 0)\n    #   l_exp = factors_list[l].get(p, 0)\n    #   This means (u_exp, v_exp) must be (g_exp, l_exp) or (l_exp, g_exp).\n    #   If g_exp == l_exp, then u_exp = v_exp = g_exp. This fixes exponents for p for u and v.\n    #   Add (u, p, g_exp) and (v, p, g_exp) to queue.\n    \n    # The problem is that if g_exp != l_exp, we have two choices.\n    # We need to make a choice for one node and propagate.\n    \n    # Let's use a standard BFS/DFS approach to assign values.\n    # `ans[i]` will store the final value for node `i`.\n    # `visited` array to track if a node's value has been determined.\n    \n    # `node_prime_info[node_id][prime]` will store the determined exponent for `prime` in `ans[node_id]`.\n    # If an exponent is not determined, it won't be in the dictionary.\n    \n    # We need to process connected components.\n    visited_nodes = [False] * (n + 1)\n    \n    for start_node_comp in range(1, n + 1):\n        if visited_nodes[start_node_comp]:\n            continue\n\n        if not adj[start_node_comp] and ans[start_node_comp] == 0:\n            ans[start_node_comp] = 1 # Isolated node, assign 1\n            visited_nodes[start_node_comp] = True\n            continue\n\n        if ans[start_node_comp] != 0: # Already processed as part of another component\n            continue\n\n        # For each connected component, pick an arbitrary node to start assigning values.\n        # Pick the first node in the component that has an edge.\n        q_bfs = [(start_node_comp, None)] # (node_id, parent_id)\n        component_nodes = []\n        q_bfs_comp = [start_node_comp]\n        visited_bfs_comp = [False] * (n + 1)\n        visited_bfs_comp[start_node_comp] = True\n        \n        head = 0\n        while head < len(q_bfs_comp):\n            curr_node = q_bfs_comp[head]\n            head += 1\n            component_nodes.append(curr_node)\n            for neighbor, _, _ in adj[curr_node]:\n                if not visited_bfs_comp[neighbor]:\n                    visited_bfs_comp[neighbor] = True\n                    q_bfs_comp.append(neighbor)\n        \n        # Now we have all nodes in the current connected component in `component_nodes`.\n        # We need to assign values for them.\n        # This is the tricky part. We need to try different combinations.\n        \n        # Let's try to assign values by fixing prime exponents.\n        # `node_prime_exponents[node_id][prime]` stores the exponent.\n        # `node_prime_exponents_fixed[node_id][prime]` is True if fixed.\n        \n        # For each prime factor p that appears in any g or l in this component:\n        # We need to determine for each node in the component, the exponent of p.\n        # Let `p_exponents[node_id]` be the exponent of `p` in `ans[node_id]`.\n        # For an edge (u, v, g, l), let g_exp = factors_list[g].get(p, 0) and l_exp = factors_list[l].get(p, 0).\n        # Then `min(p_exponents[u], p_exponents[v]) = g_exp`\n        # and `max(p_exponents[u], p_exponents[v]) = l_exp`.\n        \n        # This is a 2-coloring type problem for each prime.\n        # If g_exp == l_exp, then p_exponents[u] = p_exponents[v] = g_exp.\n        # If g_exp != l_exp, then {p_exponents[u], p_exponents[v]} = {g_exp, l_exp}.\n        \n        # Create a graph for each prime p.\n        # Nodes are component_nodes. Edges represent constraints.\n        \n        # Collect all relevant primes for this component\n        relevant_primes = set()\n        for node_id in component_nodes:\n            for neighbor, g, l in adj[node_id]:\n                relevant_primes.update(factors_list[g].keys())\n                relevant_primes.update(factors_list[l].keys())\n        \n        # For each relevant prime p:\n        #   `p_exponents_comp[node_id]` stores the exponent for `p` for nodes in this component.\n        #   `p_exponents_comp_fixed[node_id]` is True if fixed.\n        p_exponents_comp = {} # Maps node_id -> exponent for current prime\n        p_exponents_comp_fixed = {} # Maps node_id -> bool\n        \n        # `q_prime_bfs` for current prime p: (node_id, exponent)\n        q_prime_bfs = []\n        \n        for p in relevant_primes:\n            # Reset for current prime\n            p_exponents_comp.clear()\n            p_exponents_comp_fixed.clear()\n            q_prime_bfs.clear()\n            \n            # For each node in the component, initialize its exponent for p\n            for node_id in component_nodes:\n                p_exponents_comp[node_id] = -1 # -1 means not determined\n                p_exponents_comp_fixed[node_id] = False\n            \n            # Find an unassigned node in the component to start for this prime\n            start_node_prime = -1\n            for node_id in component_nodes:\n                if not p_exponents_comp_fixed[node_id]:\n                    start_node_prime = node_id\n                    break\n            \n            if start_node_prime == -1: # All exponents for this prime are already fixed (e.g., from other components)\n                continue\n\n            # This is where we need to make a choice if g_exp != l_exp.\n            # We can try to assign the smaller exponent (g_exp) to the start_node_prime.\n            # Or, we can find an edge for start_node_prime.\n            \n            # Let's iterate through edges to find fixed values or initial choices.\n            # We need to handle disconnected subgraphs for a specific prime.\n            \n            # Use a DFS-like approach for each prime within the component\n            \n            # `current_component_prime_nodes` stores nodes that are part of the current connected\n            # subgraph for the prime `p` (i.e., not yet visited for `p`).\n            \n            # The structure of the problem for each prime p is:\n            # For each edge (u, v, g, l):\n            #   g_exp = factors_list[g].get(p, 0)\n            #   l_exp = factors_list[l].get(p, 0)\n            #   If g_exp == l_exp: u_exp = v_exp = g_exp. This is fixed.\n            #   If g_exp != l_exp: {u_exp, v_exp} = {g_exp, l_exp}.\n            #       This implies u_exp != v_exp.\n            #       This can be modeled as a 2-coloring problem.\n            #       Assign one of them to u_exp, the other to v_exp.\n            #       If we fix u_exp = g_exp, then v_exp = l_exp.\n            #       If we fix u_exp = l_exp, then v_exp = g_exp.\n            \n            # We can use a 2-coloring approach. For each prime `p`:\n            #   `prime_color[node_id]` stores 0 or 1.\n            #   `prime_val_map[node_id][0]` = g_exp, `prime_val_map[node_id][1]` = l_exp (if g_exp != l_exp)\n            #   Or simpler: `prime_val_options[node_id]` = {g_exp, l_exp}\n            \n            # For each prime `p`:\n            #   `p_exponents[node_id]` = actual exponent for node_id.\n            #   `p_visited[node_id]` = True if node_id visited for this prime.\n            #   `p_q` = queue for BFS.\n            \n            p_exponents = {}\n            p_visited = {}\n            for node_id in component_nodes:\n                p_exponents[node_id] = -1\n                p_visited[node_id] = False\n            \n            for node_id in component_nodes:\n                if p_visited[node_id]:\n                    continue\n                \n                # Start a new BFS for this prime from an unvisited node\n                q_prime_bfs = []\n                \n                # Find an edge for this node to determine initial options\n                initial_exp_set = set()\n                initial_g_exp = -1\n                initial_l_exp = -1\n                \n                # Check if any neighbor already has a fixed exponent for p\n                fixed_from_neighbor = False\n                for neighbor, g_val, l_val in adj[node_id]:\n                    if ans[neighbor] != 0: # Neighbor's value is already determined\n                        neighbor_p_exp = factors_list[ans[neighbor]].get(p, 0)\n                        g_exp = factors_list[g_val].get(p, 0)\n                        l_exp = factors_list[l_val].get(p, 0)\n                        \n                        if min(p_exponents.get(node_id, -1), neighbor_p_exp) == g_exp and \\\n                           max(p_exponents.get(node_id, -1), neighbor_p_exp) == l_exp:\n                           # If current node's exponent for p is already determined, check consistency\n                           # This implies p_exponents[node_id] is not -1\n                           pass\n                        else:\n                            # Try to deduce p_exponents[node_id]\n                            # If neighbor_p_exp == g_exp, then p_exponents[node_id] must be l_exp\n                            # If neighbor_p_exp == l_exp, then p_exponents[node_id] must be g_exp\n                            # If neighbor_p_exp is neither g_exp nor l_exp, then inconsistent\n                            \n                            if neighbor_p_exp == g_exp:\n                                if p_exponents[node_id] == -1:\n                                    p_exponents[node_id] = l_exp\n                                elif p_exponents[node_id] != l_exp:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                            elif neighbor_p_exp == l_exp:\n                                if p_exponents[node_id] == -1:\n                                    p_exponents[node_id] = g_exp\n                                elif p_exponents[node_id] != g_exp:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                            else: # neighbor_p_exp is not g_exp or l_exp, impossible\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                            \n                            fixed_from_neighbor = True\n                            q_prime_bfs.append(node_id)\n                            p_visited[node_id] = True\n                            break # Found a fixed value for node_id from a neighbor, start BFS\n\n                if not fixed_from_neighbor:\n                    # If no fixed value from neighbors, we need to make an arbitrary choice\n                    # for an edge (node_id, v_prime, g_prime, l_prime)\n                    # We have two options for (p_exponents[node_id], p_exponents[v_prime]):\n                    # (g_prime_exp, l_prime_exp) or (l_prime_exp, g_prime_exp)\n                    # Pick one of them and propagate. If it fails, backtrack and try the other.\n                    # This is effectively trying 2^k possibilities for k connected components for this prime.\n                    # Since we only need *any* solution, we can just pick one.\n                    \n                    # For current node_id, find an edge.\n                    # If node_id has no edges, its value for p can be 0.\n                    if not adj[node_id]:\n                        p_exponents[node_id] = 0\n                        q_prime_bfs.append(node_id)\n                        p_visited[node_id] = True\n                    else:\n                        # Take the first edge (node_id, v_prime, g_prime, l_prime)\n                        v_prime, g_val, l_val = adj[node_id][0]\n                        g_exp = factors_list[g_val].get(p, 0)\n                        l_exp = factors_list[l_val].get(p, 0)\n                        \n                        # Try assigning g_exp to node_id\n                        p_exponents[node_id] = g_exp\n                        q_prime_bfs.append(node_id)\n                        p_visited[node_id] = True\n                        \n                # BFS for current prime `p`\n                head_prime = 0\n                while head_prime < len(q_prime_bfs):\n                    curr_node = q_prime_bfs[head_prime]\n                    head_prime += 1\n                    \n                    curr_exp = p_exponents[curr_node]\n                    \n                    for neighbor, g_val, l_val in adj[curr_node]:\n                        g_exp = factors_list[g_val].get(p, 0)\n                        l_exp = factors_list[l_val].get(p, 0)\n                        \n                        target_exp = -1\n                        if min(curr_exp, target_exp) == g_exp and max(curr_exp, target_exp) == l_exp:\n                            # This implies target_exp must be l_exp if curr_exp == g_exp\n                            # or target_exp must be g_exp if curr_exp == l_exp\n                            if curr_exp == g_exp:\n                                target_exp = l_exp\n                            elif curr_exp == l_exp:\n                                target_exp = g_exp\n                            else: # curr_exp is neither g_exp nor l_exp, impossible\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                        else: # curr_exp is not one of g_exp or l_exp\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                        if p_exponents[neighbor] == -1: # Not yet determined\n                            p_exponents[neighbor] = target_exp\n                            p_visited[neighbor] = True\n                            q_prime_bfs.append(neighbor)\n                        elif p_exponents[neighbor] != target_exp: # Inconsistent assignment\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        # Else: p_exponents[neighbor] == target_exp, consistent, no action needed\n            \n            # After BFS for prime p, all p_exponents for this component are determined\n            for node_id in component_nodes:\n                if p_exponents[node_id] == -1: # Should not happen if graph is connected\n                    # This means the node was isolated for this prime, assign 0 exponent\n                    p_exponents[node_id] = 0 \n                ans[node_id] *= (p ** p_exponents[node_id])\n                if ans[node_id] > MAX_VAL:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # Mark all nodes in component as visited for overall BFS\n            for node_id in component_nodes:\n                visited_nodes[node_id] = True\n\n    # After assigning all values, verify all edges\n    for u, v, g, l in edges_data:\n        if not check_consistency(ans[u], ans[v], g, l):\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    \n    # Precompute primes up to sqrt(10^6) = 1000\n    MAX_VAL = 10**6\n    primes = []\n    is_prime = [True] * (1001)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, 1001):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p * p, 1001, p):\n                is_prime[multiple] = False\n\n    def get_prime_factors(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num:\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1:\n            factors[temp_num] = factors.get(temp_num, 0) + 1\n        return factors\n\n    # Store prime factorizations for all numbers from 1 to 10^6\n    # For each number x, factors_list[x] is a dictionary {p: count}\n    factors_list = [None] * (MAX_VAL + 1)\n    for i in range(1, MAX_VAL + 1):\n        factors_list[i] = get_prime_factors(i)\n\n    def check_consistency(u_val, v_val, g, l):\n        if g == 0 or l == 0: return False # Should not happen based on constraints 1 <= g, l\n        if (u_val * v_val) % (g * l) != 0: return False\n        if u_val % g != 0 or v_val % g != 0: return False\n        if l % u_val != 0 or l % v_val != 0: return False\n\n        # Check prime factor powers\n        u_factors = factors_list[u_val]\n        v_factors = factors_list[v_val]\n        g_factors = factors_list[g]\n        l_factors = factors_list[l]\n\n        all_primes = set()\n        all_primes.update(u_factors.keys())\n        all_primes.update(v_factors.keys())\n        all_primes.update(g_factors.keys())\n        all_primes.update(l_factors.keys())\n\n        for p in all_primes:\n            u_exp = u_factors.get(p, 0)\n            v_exp = v_factors.get(p, 0)\n            g_exp = g_factors.get(p, 0)\n            l_exp = l_factors.get(p, 0)\n\n            if min(u_exp, v_exp) != g_exp:\n                return False\n            if max(u_exp, v_exp) != l_exp:\n                return False\n        return True\n\n    # Try to assign a value to an unassigned node\n    # Use BFS/DFS to propagate values\n    q = []\n    \n    # Find a node with at least one edge to start\n    start_node = -1\n    for i in range(1, n + 1):\n        if adj[i]:\n            start_node = i\n            break\n    \n    if start_node == -1: # No edges, all nodes can be 1\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"1 \" * n + \"\\n\")\n        return\n\n    # Start with an arbitrary value for the first node in the first edge\n    # The possible values for a node x connected to y with (g, l) are divisors of l\n    # and multiples of g. Specifically, x must be of the form (g * l) / y.\n    # We can pick any value for one node, say u, that is a divisor of l and a multiple of g.\n    # The number of mushrooms on a lawn 'x' must be a divisor of LCM for any edge connected to 'x'.\n    # It must also be a multiple of GCD for any edge connected to 'x'.\n    # So, for a node 'u', its value 'ans[u]' must divide LCM and be a multiple of GCD for all its edges.\n    # Let's find the product of all unique prime factors of all L's. This might be too large.\n    \n    # A better approach: for each node, determine the minimum possible value (min_val)\n    # and maximum possible value (max_val) based on all connected edges.\n    # min_val = LCM of all GCDs for edges connected to node u\n    # max_val = GCD of all LCMs for edges connected to node u\n    \n    # This is not quite right. For an edge (u, v, g, l), u must be a divisor of l, v must be a divisor of l.\n    # Also, u must be a multiple of g, v must be a multiple of g.\n    # And (u * v) == (g * l). So v = (g * l) / u.\n    \n    # We can try to assign a value to node 1.\n    # The possible values for node 1 are divisors of LCMs it's connected to.\n    # Let's find the smallest LCM it's connected to.\n    \n    # For each node, find the product of all GCDs and LCMs it's involved in.\n    # The actual value must be a divisor of all LCMs and a multiple of all GCDs.\n    \n    # Let's try to fix a value for the first node encountered in the input that has an edge.\n    # For node `u` in an edge `(u, v, g, l)`, `u` must be a divisor of `l`.\n    # `u` must also be a multiple of `g`.\n    # And `u * v = g * l`.\n    # So `v = (g * l) / u`.\n    \n    # Let's pick the first edge (u0, v0, g0, l0).\n    # We need to assign ans[u0] and ans[v0].\n    # Possible values for ans[u0] are divisors of l0 that are multiples of g0.\n    # For each such possible ans[u0], calculate ans[v0] = (g0 * l0) / ans[u0].\n    # Then check if ans[u0] and ans[v0] are consistent with g0, l0.\n    # If they are, then we can start a BFS/DFS from u0 and v0.\n    \n    # A crucial observation: For any edge (u, v, g, l), the value of u must be a divisor of l.\n    # Also, the value of u must be a multiple of g.\n    # So, u must be of the form `g * k` where `k` is a divisor of `l/g`.\n    # And `v = (g * l) / u`.\n    \n    # The values can be up to 10^6. A node can have many divisors.\n    # The number of divisors of 720720 (max number of divisors up to 10^6) is 240.\n    # Trying all divisors for one node might be too slow if we have to do it for many nodes.\n    \n    # The problem is that the values are not unique. We need to find *any* solution.\n    # This suggests that there might be a \"canonical\" way to assign values, or a way to simplify the search.\n    \n    # For each prime factor p, let u_exp be its exponent in ans[u] and v_exp in ans[v].\n    # Then min(u_exp, v_exp) = g_exp and max(u_exp, v_exp) = l_exp.\n    # This means for each prime p, the pair (u_exp, v_exp) must be either (g_exp, l_exp) or (l_exp, g_exp).\n    # This gives 2 choices for each prime factor.\n    # If l/g has many prime factors, this can lead to 2^k choices.\n    # E.g., if l/g = 2*3*5*7*11*13 (6 distinct prime factors), then 2^6 = 64 choices for u_val.\n    # Max distinct prime factors for a number <= 10^6 is 7 (e.g., 2*3*5*7*11*13*17 = 510510).\n    # So 2^7 = 128 choices for a single node's value. This is manageable.\n\n    # Let's try to assign values based on prime factor exponents.\n    # For each node `i`, `ans[i]` will be constructed by determining the exponent of each prime `p`.\n    # `node_prime_exponents[i][p]` will store the exponent of `p` in `ans[i]`.\n    \n    node_prime_exponents = [{} for _ in range(n + 1)]\n    \n    # Keep track of which nodes have fixed prime exponents\n    # `fixed_prime_exponents[i][p]` is True if exponent of p for node i is determined.\n    fixed_prime_exponents = [{} for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS-like propagation\n    # Queue stores (node_id, prime, exponent)\n    q_exponents = []\n\n    # Initialize all nodes to 1 (all prime exponents are 0)\n    for i in range(1, n + 1):\n        ans[i] = 1\n\n    # For each edge (u, v, g, l):\n    # For each prime p in factors_list[g] or factors_list[l]:\n    #   g_exp = factors_list[g].get(p, 0)\n    #   l_exp = factors_list[l].get(p, 0)\n    #   This means (u_exp, v_exp) must be (g_exp, l_exp) or (l_exp, g_exp).\n    #   If g_exp == l_exp, then u_exp = v_exp = g_exp. This fixes exponents for p for u and v.\n    #   Add (u, p, g_exp) and (v, p, g_exp) to queue.\n    \n    # The problem is that if g_exp != l_exp, we have two choices.\n    # We need to make a choice for one node and propagate.\n    \n    # Let's use a standard BFS/DFS approach to assign values.\n    # `ans[i]` will store the final value for node `i`.\n    # `visited` array to track if a node's value has been determined.\n    \n    # `node_prime_info[node_id][prime]` will store the determined exponent for `prime` in `ans[node_id]`.\n    # If an exponent is not determined, it won't be in the dictionary.\n    \n    # We need to process connected components.\n    visited_nodes = [False] * (n + 1)\n    \n    for start_node_comp in range(1, n + 1):\n        if visited_nodes[start_node_comp]:\n            continue\n\n        if not adj[start_node_comp] and ans[start_node_comp] == 0:\n            ans[start_node_comp] = 1 # Isolated node, assign 1\n            visited_nodes[start_node_comp] = True\n            continue\n\n        if ans[start_node_comp] != 0: # Already processed as part of another component\n            continue\n\n        # For each connected component, pick an arbitrary node to start assigning values.\n        # Pick the first node in the component that has an edge.\n        q_bfs = [(start_node_comp, None)] # (node_id, parent_id)\n        component_nodes = []\n        q_bfs_comp = [start_node_comp]\n        visited_bfs_comp = [False] * (n + 1)\n        visited_bfs_comp[start_node_comp] = True\n        \n        head = 0\n        while head < len(q_bfs_comp):\n            curr_node = q_bfs_comp[head]\n            head += 1\n            component_nodes.append(curr_node)\n            for neighbor, _, _ in adj[curr_node]:\n                if not visited_bfs_comp[neighbor]:\n                    visited_bfs_comp[neighbor] = True\n                    q_bfs_comp.append(neighbor)\n        \n        # Now we have all nodes in the current connected component in `component_nodes`.\n        # We need to assign values for them.\n        # This is the tricky part. We need to try different combinations.\n        \n        # Let's try to assign values by fixing prime exponents.\n        # `node_prime_exponents[node_id][prime]` stores the exponent.\n        # `node_prime_exponents_fixed[node_id][prime]` is True if fixed.\n        \n        # For each prime factor p that appears in any g or l in this component:\n        # We need to determine for each node in the component, the exponent of p.\n        # Let `p_exponents[node_id]` be the exponent of `p` in `ans[node_id]`.\n        # For an edge (u, v, g, l), let g_exp = factors_list[g].get(p, 0) and l_exp = factors_list[l].get(p, 0).\n        # Then `min(p_exponents[u], p_exponents[v]) = g_exp`\n        # and `max(p_exponents[u], p_exponents[v]) = l_exp`.\n        \n        # This is a 2-coloring type problem for each prime.\n        # If g_exp == l_exp, then p_exponents[u] = p_exponents[v] = g_exp.\n        # If g_exp != l_exp, then {p_exponents[u], p_exponents[v]} = {g_exp, l_exp}.\n        \n        # Create a graph for each prime p.\n        # Nodes are component_nodes. Edges represent constraints.\n        \n        # Collect all relevant primes for this component\n        relevant_primes = set()\n        for node_id in component_nodes:\n            for neighbor, g, l in adj[node_id]:\n                relevant_primes.update(factors_list[g].keys())\n                relevant_primes.update(factors_list[l].keys())\n        \n        # For each relevant prime p:\n        #   `p_exponents_comp[node_id]` stores the exponent for `p` for nodes in this component.\n        #   `p_exponents_comp_fixed[node_id]` is True if fixed.\n        p_exponents_comp = {} # Maps node_id -> exponent for current prime\n        p_exponents_comp_fixed = {} # Maps node_id -> bool\n        \n        # `q_prime_bfs` for current prime p: (node_id, exponent)\n        q_prime_bfs = []\n        \n        for p in relevant_primes:\n            # Reset for current prime\n            p_exponents_comp.clear()\n            p_exponents_comp_fixed.clear()\n            q_prime_bfs.clear()\n            \n            # For each node in the component, initialize its exponent for p\n            for node_id in component_nodes:\n                p_exponents_comp[node_id] = -1 # -1 means not determined\n                p_exponents_comp_fixed[node_id] = False\n            \n            # Find an unassigned node in the component to start for this prime\n            start_node_prime = -1\n            for node_id in component_nodes:\n                if not p_exponents_comp_fixed[node_id]:\n                    start_node_prime = node_id\n                    break\n            \n            if start_node_prime == -1: # All exponents for this prime are already fixed (e.g., from other components)\n                continue\n\n            # This is where we need to make a choice if g_exp != l_exp.\n            # We can try to assign the smaller exponent (g_exp) to the start_node_prime.\n            # Or, we can find an edge for start_node_prime.\n            \n            # Let's iterate through edges to find fixed values or initial choices.\n            # We need to handle disconnected subgraphs for a specific prime.\n            \n            # Use a DFS-like approach for each prime within the component\n            \n            # `current_component_prime_nodes` stores nodes that are part of the current connected\n            # subgraph for the prime `p` (i.e., not yet visited for `p`).\n            \n            # The structure of the problem for each prime p is:\n            # For each edge (u, v, g, l):\n            #   g_exp = factors_list[g].get(p, 0)\n            #   l_exp = factors_list[l].get(p, 0)\n            #   If g_exp == l_exp: u_exp = v_exp = g_exp. This is fixed.\n            #   If g_exp != l_exp: {u_exp, v_exp} = {g_exp, l_exp}.\n            #       This implies u_exp != v_exp.\n            #       This can be modeled as a 2-coloring problem.\n            #       Assign one of them to u_exp, the other to v_exp.\n            #       If we fix u_exp = g_exp, then v_exp = l_exp.\n            #       If we fix u_exp = l_exp, then v_exp = g_exp.\n            \n            # We can use a 2-coloring approach. For each prime `p`:\n            #   `prime_color[node_id]` stores 0 or 1.\n            #   `prime_val_map[node_id][0]` = g_exp, `prime_val_map[node_id][1]` = l_exp (if g_exp != l_exp)\n            #   Or simpler: `prime_val_options[node_id]` = {g_exp, l_exp}\n            \n            # For each prime `p`:\n            #   `p_exponents[node_id]` = actual exponent for node_id.\n            #   `p_visited[node_id]` = True if node_id visited for this prime.\n            #   `p_q` = queue for BFS.\n            \n            p_exponents = {}\n            p_visited = {}\n            for node_id in component_nodes:\n                p_exponents[node_id] = -1\n                p_visited[node_id] = False\n            \n            for node_id in component_nodes:\n                if p_visited[node_id]:\n                    continue\n                \n                # Start a new BFS for this prime from an unvisited node\n                q_prime_bfs = []\n                \n                # Find an edge for this node to determine initial options\n                initial_exp_set = set()\n                initial_g_exp = -1\n                initial_l_exp = -1\n                \n                # Check if any neighbor already has a fixed exponent for p\n                fixed_from_neighbor = False\n                for neighbor, g_val, l_val in adj[node_id]:\n                    if ans[neighbor] != 0: # Neighbor's value is already determined\n                        neighbor_p_exp = factors_list[ans[neighbor]].get(p, 0)\n                        g_exp = factors_list[g_val].get(p, 0)\n                        l_exp = factors_list[l_val].get(p, 0)\n                        \n                        if min(p_exponents.get(node_id, -1), neighbor_p_exp) == g_exp and \\\n                           max(p_exponents.get(node_id, -1), neighbor_p_exp) == l_exp:\n                           # If current node's exponent for p is already determined, check consistency\n                           # This implies p_exponents[node_id] is not -1\n                           pass\n                        else:\n                            # Try to deduce p_exponents[node_id]\n                            # If neighbor_p_exp == g_exp, then p_exponents[node_id] must be l_exp\n                            # If neighbor_p_exp == l_exp, then p_exponents[node_id] must be g_exp\n                            # If neighbor_p_exp is neither g_exp nor l_exp, then inconsistent\n                            \n                            if neighbor_p_exp == g_exp:\n                                if p_exponents[node_id] == -1:\n                                    p_exponents[node_id] = l_exp\n                                elif p_exponents[node_id] != l_exp:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                            elif neighbor_p_exp == l_exp:\n                                if p_exponents[node_id] == -1:\n                                    p_exponents[node_id] = g_exp\n                                elif p_exponents[node_id] != g_exp:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                            else: # neighbor_p_exp is not g_exp or l_exp, impossible\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                            \n                            fixed_from_neighbor = True\n                            q_prime_bfs.append(node_id)\n                            p_visited[node_id] = True\n                            break # Found a fixed value for node_id from a neighbor, start BFS\n\n                if not fixed_from_neighbor:\n                    # If no fixed value from neighbors, we need to make an arbitrary choice\n                    # for an edge (node_id, v_prime, g_prime, l_prime)\n                    # We have two options for (p_exponents[node_id], p_exponents[v_prime]):\n                    # (g_prime_exp, l_prime_exp) or (l_prime_exp, g_prime_exp)\n                    # Pick one of them and propagate. If it fails, backtrack and try the other.\n                    # This is effectively trying 2^k possibilities for k connected components for this prime.\n                    # Since we only need *any* solution, we can just pick one.\n                    \n                    # For current node_id, find an edge.\n                    # If node_id has no edges, its value for p can be 0.\n                    if not adj[node_id]:\n                        p_exponents[node_id] = 0\n                        q_prime_bfs.append(node_id)\n                        p_visited[node_id] = True\n                    else:\n                        # Take the first edge (node_id, v_prime, g_prime, l_prime)\n                        v_prime, g_val, l_val = adj[node_id][0]\n                        g_exp = factors_list[g_val].get(p, 0)\n                        l_exp = factors_list[l_val].get(p, 0)\n                        \n                        # Try assigning g_exp to node_id\n                        p_exponents[node_id] = g_exp\n                        q_prime_bfs.append(node_id)\n                        p_visited[node_id] = True\n                        \n                # BFS for current prime `p`\n                head_prime = 0\n                while head_prime < len(q_prime_bfs):\n                    curr_node = q_prime_bfs[head_prime]\n                    head_prime += 1\n                    \n                    curr_exp = p_exponents[curr_node]\n                    \n                    for neighbor, g_val, l_val in adj[curr_node]:\n                        g_exp = factors_list[g_val].get(p, 0)\n                        l_exp = factors_list[l_val].get(p, 0)\n                        \n                        target_exp = -1\n                        if min(curr_exp, target_exp) == g_exp and max(curr_exp, target_exp) == l_exp:\n                            # This implies target_exp must be l_exp if curr_exp == g_exp\n                            # or target_exp must be g_exp if curr_exp == l_exp\n                            if curr_exp == g_exp:\n                                target_exp = l_exp\n                            elif curr_exp == l_exp:\n                                target_exp = g_exp\n                            else: # curr_exp is neither g_exp nor l_exp, impossible\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                        else: # curr_exp is not one of g_exp or l_exp\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                        if p_exponents[neighbor] == -1: # Not yet determined\n                            p_exponents[neighbor] = target_exp\n                            p_visited[neighbor] = True\n                            q_prime_bfs.append(neighbor)\n                        elif p_exponents[neighbor] != target_exp: # Inconsistent assignment\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        # Else: p_exponents[neighbor] == target_exp, consistent, no action needed\n            \n            # After BFS for prime p, all p_exponents for this component are determined\n            for node_id in component_nodes:\n                if p_exponents[node_id] == -1: # Should not happen if graph is connected\n                    # This means the node was isolated for this prime, assign 0 exponent\n                    p_exponents[node_id] = 0 \n                ans[node_id] *= (p ** p_exponents[node_id])\n                if ans[node_id] > MAX_VAL:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            \n            # Mark all nodes in component as visited for overall BFS\n            for node_id in component_nodes:\n                visited_nodes[node_id] = True\n\n    # After assigning all values, verify all edges\n    for u, v, g, l in edges_data:\n        if not check_consistency(ans[u], ans[v], g, l):\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 6417,
        "thoughts_token_count": 0
    }
}