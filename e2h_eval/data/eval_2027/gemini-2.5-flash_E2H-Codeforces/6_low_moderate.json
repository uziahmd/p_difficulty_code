{
    "start": 1758009283.3983111,
    "end": 1758009319.2517092,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Problem-Solving Approach for a Competitive Programming Challenge**\n\nOkay, so I've got this competitive programming problem that needs a Python script. It's about finding two vouchers with specific duration and cost constraints. The goal is to select two disjoint vouchers whose durations sum to exactly `x` while minimizing their combined cost. If no such pair exists, I need to output -1.\n\nLet's break down the requirements. I need two distinct vouchers, `i` and `j`, that don't overlap. Their durations have to add up to `x`, and the total cost should be as small as possible. The constraints indicate that a brute-force approach (O(N^2)) would be too slow.  I need to find a more efficient solution, probably O(N log N) or O(N).\n\nI'm thinking that the \"disjoint\" condition suggests I should look at interval-based approaches or sorting. Specifically, the disjoint condition means the vouchers' time intervals can't overlap. To minimize the cost, I'll need to somehow efficiently find the matching voucher.\n\nThe duration constraint makes me think of fixing one voucher and then looking for a suitable matching voucher. So, let's fix voucher `i`. I need to find `j` such that `r_i < l_j` (or vice versa), the duration of `j` is `x - d_i`, and the cost of `j` is minimized.  Sorting the vouchers by start or end times seems like a promising strategy.  Let's say I sort them by their start times (`l_i`).  Then I can iterate through the sorted list, treating each voucher as my fixed `v_i`. For each fixed `v_i`, I'll search for a `v_j` that satisfies all the conditions.\n",
    "response": "The problem asks us to find two distinct, non-overlapping vouchers `i` and `j` such that the sum of their durations `(r_i - l_i + 1) + (r_j - l_j + 1)` is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet `d_k = r_k - l_k + 1` be the duration of voucher `k`.\nThe conditions are:\n1.  `d_i + d_j = x`\n2.  Vouchers `i` and `j` are disjoint: `r_i < l_j` or `r_j < l_i`.\n3.  Minimize `cost_i + cost_j`.\n\nA naive O(N^2) approach by checking all pairs is too slow for N up to 2 * 10^5. We need a more efficient approach, likely O(N log N) or O(N).\n\nLet's rephrase the disjointness condition. Without loss of generality, assume `r_i < l_j`. This means voucher `i` finishes before voucher `j` starts.\n\nWe can iterate through all possible vouchers `v_i` and for each `v_i`, try to find the best `v_j`.\nFor a fixed `v_i` with duration `d_i`, we need `v_j` such that `d_j = x - d_i`. Let `target_duration = x - d_i`.\nWe also need `r_i < l_j`. Among all vouchers `v_j` satisfying these two conditions, we want the one with the minimum `cost_j`.\n\nTo efficiently find such `v_j`, we can process vouchers in a specific order.\nLet's sort all vouchers by their start times (`l_k`). If `l_k` are equal, sort by `r_k`.\n\nWe can use a sweep-line approach. Iterate through all possible end times `R` from `1` to `MAX_COORD` (which is `2 * 10^5`).\nAt each `R`, we consider two types of events:\n1.  Vouchers ending at `R`: These vouchers become candidates for `v_i` (the first voucher in a pair `(v_i, v_j)` where `r_i < l_j`).\n2.  Vouchers starting at `R`: These vouchers become candidates for `v_j` (the second voucher in a pair `(v_i, v_j)` where `r_i < l_j`).\n\nLet's maintain a data structure that, for any required duration `D`, can query the minimum cost of a voucher that has duration `D` and has already ended.\n\nA more concrete sweep-line approach:\n1.  Group vouchers by their start times `l_k`.\n    `vouchers_by_start[l]` will be a list of `(r, cost, duration)` for all vouchers starting at `l`.\n2.  Group vouchers by their end times `r_k`.\n    `vouchers_by_end[r]` will be a list of `(l, cost, duration)` for all vouchers ending at `r`.\n\nWe can iterate through all possible days `current_day` from `1` to `MAX_COORD`.\nWe'll maintain an array `min_cost_for_duration[d]`, which stores the minimum cost of a voucher that *has already ended by `current_day - 1`* and has duration `d`. Initialize `min_cost_for_duration` with infinity.\n\nThe overall minimum total cost found will be `min_total_cost`. Initialize it to infinity.\n\nAlgorithm:\n1.  Initialize `min_total_cost = infinity`.\n2.  Create `vouchers_by_start` and `vouchers_by_end` lists of lists (or dictionaries mapping day to list of vouchers). The maximum coordinate is `MAX_COORD = 2 * 10^5`.\n    `vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]`\n    `vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]`\n    For each voucher `(l, r, cost)`:\n    `duration = r - l + 1`\n    `vouchers_by_start[l].append((r, cost, duration))`\n    `vouchers_by_end[r].append((l, cost, duration))`\n\n3.  Initialize `min_cost_for_duration = [infinity] * (x + 1)`. (We only care about durations up to `x` because `d_i + d_j = x`).\n\n4.  Iterate `current_day` from `1` to `MAX_COORD`:\n    a.  **Process vouchers starting at `current_day`**: These are potential `v_j` vouchers.\n        For each voucher `(r_j, cost_j, d_j)` in `vouchers_by_start[current_day]`:\n        If `d_j < x`: // `d_j` must be less than `x` for `x - d_j` to be a positive duration\n            `required_duration_i = x - d_j`\n            If `required_duration_i > 0` and `required_duration_i <= x`:\n                `min_cost_i = min_cost_for_duration[required_duration_i]`\n                If `min_cost_i != infinity`:\n                    `min_total_cost = min(min_total_cost, min_cost_i + cost_j)`\n\n    b.  **Process vouchers ending at `current_day`**: These are potential `v_i` vouchers.\n        For each voucher `(l_i, cost_i, d_i)` in `vouchers_by_end[current_day]`:\n        If `d_i < x`: // `d_i` must be less than `x` for `x - d_i` to be a positive duration\n            `min_cost_for_duration[d_i] = min(min_cost_for_duration[d_i], cost_i)`\n\n5.  After the loop, if `min_total_cost` is still infinity, it's impossible to find such a pair, so print -1. Otherwise, print `min_total_cost`.\n\nThe maximum duration is `MAX_COORD`. The `min_cost_for_duration` array needs to store costs for durations up to `x`. The size of this array is `x+1`.\nThe loop runs `MAX_COORD` times. Inside the loop, we iterate through vouchers starting/ending on that day. In total, each voucher is processed twice (once as an ending voucher, once as a starting voucher).\nUpdating `min_cost_for_duration` and querying it takes O(1) time.\nTotal time complexity: O(MAX_COORD + N).\nSpace complexity: O(MAX_COORD + N) for storing vouchers and `min_cost_for_duration`.\nGiven `MAX_COORD = 2 * 10^5` and `N = 2 * 10^5`, this is efficient enough.\n\nExample Walkthrough (First Sample):\nN=4, x=5\nVouchers: (1,3,4), (1,2,5), (5,6,1), (1,2,4)\n\n1.  `min_total_cost = infinity`\n2.  `vouchers_by_start`:\n    `[1]: [(3,4,3), (2,5,2), (2,4,2)]`\n    `[5]: [(6,1,2)]`\n    `vouchers_by_end`:\n    `[2]: [(1,5,2), (1,4,2)]`\n    `[3]: [(1,4,3)]`\n    `[6]: [(5,1,2)]`\n3.  `min_cost_for_duration = [inf, inf, inf, inf, inf, inf]` (size `x+1 = 6`)\n\n4.  Loop `current_day` from 1 to 6:\n    *   `current_day = 1`:\n        a.  Start: `vouchers_by_start[1]` is `[(3,4,3), (2,5,2), (2,4,2)]`.\n            - `(r=3, cost=4, d=3)`: `req_d = 5-3=2`. `min_cost_for_duration[2]` is `inf`. No update.\n            - `(r=2, cost=5, d=2)`: `req_d = 5-2=3`. `min_cost_for_duration[3]` is `inf`. No update.\n            - `(r=2, cost=4, d=2)`: `req_d = 5-2=3`. `min_cost_for_duration[3]` is `inf`. No update.\n        b.  End: `vouchers_by_end[1]` is empty.\n    *   `current_day = 2`:\n        a.  Start: `vouchers_by_start[2]` is empty.\n        b.  End: `vouchers_by_end[2]` is `[(1,5,2), (1,4,2)]`.\n            - `(l=1, cost=5, d=2)`: `min_cost_for_duration[2] = min(inf, 5) = 5`.\n            - `(l=1, cost=4, d=2)`: `min_cost_for_duration[2] = min(5, 4) = 4`.\n            (`min_cost_for_duration` is now `[inf, inf, 4, inf, inf, inf]`)\n    *   `current_day = 3`:\n        a.  Start: `vouchers_by_start[3]` is empty.\n        b.  End: `vouchers_by_end[3]` is `[(1,4,3)]`.\n            - `(l=1, cost=4, d=3)`: `min_cost_for_duration[3] = min(inf, 4) = 4`.\n            (`min_cost_for_duration` is now `[inf, inf, 4, 4, inf, inf]`)\n    *   `current_day = 4`:\n        a.  Start: `vouchers_by_start[4]` is empty.\n        b.  End: `vouchers_by_end[4]` is empty.\n    *   `current_day = 5`:\n        a.  Start: `vouchers_by_start[5]` is `[(6,1,2)]`.\n            - `(r=6, cost=1, d=2)`: `req_d = 5-2=3`. `min_cost_for_duration[3]` is `4`.\n                `min_total_cost = min(inf, 4 + 1) = 5`.\n        b.  End: `vouchers_by_end[5]` is empty.\n    *   `current_day = 6`:\n        a.  Start: `vouchers_by_start[6]` is empty.\n        b.  End: `vouchers_by_end[6]` is `[(5,1,2)]`.\n            - `(l=5, cost=1, d=2)`: `min_cost_for_duration[2] = min(4, 1) = 1`.\n            (`min_cost_for_duration` is now `[inf, inf, 1, 4, inf, inf]`)\n\n5.  Loop ends. `min_total_cost = 5`. Print 5.\n\nThis matches the example output.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n    \n    # vouchers_by_start[l] stores list of (r, cost, duration) for vouchers starting at l\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[r] stores list of (l, cost, duration) for vouchers ending at r\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start[l].append((r, cost, duration))\n        vouchers_by_end[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # that has duration d and has already ended by current_day - 1.\n    # We only need to store durations up to x.\n    # Initialize with a very large value (infinity)\n    min_cost_for_duration = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep through all possible days\n    for current_day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers starting at current_day\n        # These are potential v_j vouchers.\n        # We look for a v_i that ended before current_day and has the required duration.\n        for r_j, cost_j, d_j in vouchers_by_start[current_day]:\n            # If d_j is already x or more, it cannot be paired with another voucher\n            # to sum up to exactly x (since durations are positive).\n            if d_j < x:\n                required_duration_i = x - d_j\n                # required_duration_i must be positive\n                if required_duration_i > 0 and required_duration_i <= x:\n                    cost_i_candidate = min_cost_for_duration[required_duration_i]\n                    if cost_i_candidate != float('inf'):\n                        min_total_cost = min(min_total_cost, cost_i_candidate + cost_j)\n        \n        # Phase 2: Process vouchers ending at current_day\n        # These are potential v_i vouchers.\n        # Update min_cost_for_duration for their respective durations.\n        for l_i, cost_i, d_i in vouchers_by_end[current_day]:\n            # We only care about durations up to x for the min_cost_for_duration array\n            if d_i <= x:\n                min_cost_for_duration[d_i] = min(min_cost_for_duration[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(int(min_total_cost)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n    \n    # vouchers_by_start[l] stores list of (r, cost, duration) for vouchers starting at l\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[r] stores list of (l, cost, duration) for vouchers ending at r\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start[l].append((r, cost, duration))\n        vouchers_by_end[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # that has duration d and has already ended by current_day - 1.\n    # We only need to store durations up to x.\n    # Initialize with a very large value (infinity)\n    min_cost_for_duration = [float('inf')] * (x + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep through all possible days\n    for current_day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers starting at current_day\n        # These are potential v_j vouchers.\n        # We look for a v_i that ended before current_day and has the required duration.\n        for r_j, cost_j, d_j in vouchers_by_start[current_day]:\n            # If d_j is already x or more, it cannot be paired with another voucher\n            # to sum up to exactly x (since durations are positive).\n            if d_j < x:\n                required_duration_i = x - d_j\n                # required_duration_i must be positive\n                if required_duration_i > 0 and required_duration_i <= x:\n                    cost_i_candidate = min_cost_for_duration[required_duration_i]\n                    if cost_i_candidate != float('inf'):\n                        min_total_cost = min(min_total_cost, cost_i_candidate + cost_j)\n        \n        # Phase 2: Process vouchers ending at current_day\n        # These are potential v_i vouchers.\n        # Update min_cost_for_duration for their respective durations.\n        for l_i, cost_i, d_i in vouchers_by_end[current_day]:\n            # We only care about durations up to x for the min_cost_for_duration array\n            if d_i <= x:\n                min_cost_for_duration[d_i] = min(min_cost_for_duration[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(int(min_total_cost)) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 3480,
        "thoughts_token_count": 750
    }
}