{
    "start": 1758285060.6226635,
    "end": 1758285084.9827154,
    "start-formatted": "2025-09-19 21:31 KST",
    "end-formatted": "2025-09-19 21:31 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**My Approach to the TV Game Problem**\n\nOkay, so I'm looking at this \"TV Game\" problem, and the goal is to maximize the sum of two numbers formed by two players, Homer and Marge, taking turns from a pool of digits. The input is an integer with `2n` digits, and each player gets to make `n` moves.  It's pretty clear that a brute-force approach, trying every possible sequence of moves, is completely out of the question, especially with `n` potentially reaching 18.  That's a combinatorial explosion!\n\nThe key here is understanding how the numbers `S1` and `S2` are *formed*.  They're essentially digit strings.  When we convert them to integers, the position of each digit drastically affects its value due to the powers of 10.  So, I need to focus on how to strategically distribute the *higher-value* digits.\n\nEssentially, I want to create the largest possible sum `S1 + S2`. The highest place value digit is crucial in determining the final result of the sum. So, how can I maximize the sum of the most significant digits between the two numbers? Looking at the example, it becomes clear that there must be an optimal way to assign digits to players.\n\nThe problem seems to boil down to finding a pattern or rule for digit assignment. I suspect there's a greedy element here, but I need to figure out what that greedy strategy *is*.  I'm thinking about the example cases and how the position of the digits impacts the final sum. If I can nail down the core principle behind maximizing the sum of the higher-value digits, I'll have the algorithm I need to write the Python script. It seems like the solution should be based on a pattern from picking digits alternatively.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # dp[mask][k] will store the maximum sum (S1 + S2) achievable\n    # when the digits represented by 'mask' have been taken,\n    # and 'k' moves have been made by Homer.\n    # The 'mask' is a bitmask where the i-th bit is 1 if the i-th digit\n    # of the original string 'A' (from right to left) has been taken.\n    # We iterate from right to left for convenience with powers of 10.\n\n    # The maximum value for n is 18, so 2n is 36.\n    # A mask of 36 bits is too large for standard DP (2^36 states).\n    # The key observation is that only the *count* of moves made by each player\n    # and the *current index* in the original string A matter.\n\n    # Let dp[h_moves][m_moves] be a tuple (max_sum, sequence_string)\n    # where h_moves is the number of moves Homer has made,\n    # and m_moves is the number of moves Marge has made.\n    # The current index in A is implicitly (h_moves + m_moves).\n\n    # dp state: dp[h_count][m_count]\n    # h_count: number of moves Homer has made\n    # m_count: number of moves Marge has made\n    # Value: (max_total_value, path_string)\n    # The max_total_value is a list of 2n integers, representing the sum\n    # of digits at each position (from most significant to least significant).\n    # E.g., [d_sum_0, d_sum_1, ..., d_sum_{2n-1}]\n    # This is because numbers can be very large (up to 36 digits).\n    # path_string: The sequence of 'H' and 'M' characters.\n\n    # Initialize DP table\n    # dp[h][m] stores (max_sum_digits_array, path_string)\n    # max_sum_digits_array is a list of 2n integers,\n    # where max_sum_digits_array[k] is the sum of digits at position k\n    # (0-indexed from the most significant digit).\n    # Initialize with a very small value (e.g., an array of -1s)\n    # For comparison, we need a custom comparator.\n    \n    # max_val_digits will be initialized to an array of -1s\n    max_val_digits = [-1] * (2 * n)\n    # path_string will be initialized to an empty string\n\n    # dp[h_count][m_count]\n    dp = [[(max_val_digits, \"\") for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Base case: no moves made\n    dp[0][0] = ([0] * (2 * n), \"\")\n\n    # Iterate through all possible total number of moves\n    for total_moves in range(2 * n):\n        # Iterate through possible Homer moves for current total_moves\n        for h_count in range(min(total_moves + 1, n + 1)):\n            m_count = total_moves - h_count\n            if m_count < 0 or m_count > n:\n                continue\n\n            current_max_sum_digits, current_path = dp[h_count][m_count]\n\n            # If this state is unreachable, skip\n            if current_max_sum_digits[0] == -1: # Check if it's the initial -1 value\n                continue\n\n            # Current digit to be taken from A\n            digit_char = a_str[total_moves]\n            digit_val = int(digit_char)\n\n            # Position of this digit in S1/S2 (0-indexed from MSB)\n            # This is (n - 1) - (h_count or m_count)\n            # If Homer takes it, it's (n - 1 - h_count) for S1.\n            # If Marge takes it, it's (n - 1 - m_count) for S2.\n            \n            # Option 1: Homer takes the digit\n            if h_count < n:\n                next_h_count = h_count + 1\n                next_m_count = m_count\n                \n                # Create a new sum_digits array for Homer's move\n                next_sum_digits_H = list(current_max_sum_digits)\n                s1_pos = n - 1 - h_count # Position in S1 (0-indexed from MSB)\n                next_sum_digits_H[s1_pos] += digit_val # Add to S1's position\n\n                next_path_H = current_path + 'H'\n\n                # Compare with existing value in dp[next_h_count][next_m_count]\n                existing_sum_digits, _ = dp[next_h_count][next_m_count]\n                \n                # Custom comparison for list of digits\n                # Iterate from MSB to LSB\n                is_better = False\n                if existing_sum_digits[0] == -1: # If existing is initial -1, new is always better\n                    is_better = True\n                else:\n                    for i in range(2 * n):\n                        if next_sum_digits_H[i] > existing_sum_digits[i]:\n                            is_better = True\n                            break\n                        elif next_sum_digits_H[i] < existing_sum_digits[i]:\n                            is_better = False\n                            break\n                    # If all digits are equal, path length is already equal (total_moves+1)\n                    # Any path is fine if values are equal, so no need to update if not strictly better\n\n                if is_better:\n                    dp[next_h_count][next_m_count] = (next_sum_digits_H, next_path_H)\n\n            # Option 2: Marge takes the digit\n            if m_count < n:\n                next_h_count = h_count\n                next_m_count = m_count + 1\n\n                # Create a new sum_digits array for Marge's move\n                next_sum_digits_M = list(current_max_sum_digits)\n                s2_pos = n + (n - 1 - m_count) # Position in S2 (0-indexed from MSB, relative to S1)\n                next_sum_digits_M[s2_pos] += digit_val # Add to S2's position\n\n                next_path_M = current_path + 'M'\n\n                # Compare with existing value in dp[next_h_count][next_m_count]\n                existing_sum_digits, _ = dp[next_h_count][next_m_count]\n\n                is_better = False\n                if existing_sum_digits[0] == -1:\n                    is_better = True\n                else:\n                    for i in range(2 * n):\n                        if next_sum_digits_M[i] > existing_sum_digits[i]:\n                            is_better = True\n                            break\n                        elif next_sum_digits_M[i] < existing_sum_digits[i]:\n                            is_better = False\n                            break\n                \n                if is_better:\n                    dp[next_h_count][next_m_count] = (next_sum_digits_M, next_path_M)\n\n    # The final answer is in dp[n][n]\n    final_sum_digits, final_path = dp[n][n]\n    sys.stdout.write(final_path + '\\n')\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # dp[mask][k] will store the maximum sum (S1 + S2) achievable\n    # when the digits represented by 'mask' have been taken,\n    # and 'k' moves have been made by Homer.\n    # The 'mask' is a bitmask where the i-th bit is 1 if the i-th digit\n    # of the original string 'A' (from right to left) has been taken.\n    # We iterate from right to left for convenience with powers of 10.\n\n    # The maximum value for n is 18, so 2n is 36.\n    # A mask of 36 bits is too large for standard DP (2^36 states).\n    # The key observation is that only the *count* of moves made by each player\n    # and the *current index* in the original string A matter.\n\n    # Let dp[h_moves][m_moves] be a tuple (max_sum, sequence_string)\n    # where h_moves is the number of moves Homer has made,\n    # and m_moves is the number of moves Marge has made.\n    # The current index in A is implicitly (h_moves + m_moves).\n\n    # dp state: dp[h_count][m_count]\n    # h_count: number of moves Homer has made\n    # m_count: number of moves Marge has made\n    # Value: (max_total_value, path_string)\n    # The max_total_value is a list of 2n integers, representing the sum\n    # of digits at each position (from most significant to least significant).\n    # E.g., [d_sum_0, d_sum_1, ..., d_sum_{2n-1}]\n    # This is because numbers can be very large (up to 36 digits).\n    # path_string: The sequence of 'H' and 'M' characters.\n\n    # Initialize DP table\n    # dp[h][m] stores (max_sum_digits_array, path_string)\n    # max_sum_digits_array is a list of 2n integers,\n    # where max_sum_digits_array[k] is the sum of digits at position k\n    # (0-indexed from the most significant digit).\n    # Initialize with a very small value (e.g., an array of -1s)\n    # For comparison, we need a custom comparator.\n    \n    # max_val_digits will be initialized to an array of -1s\n    max_val_digits = [-1] * (2 * n)\n    # path_string will be initialized to an empty string\n\n    # dp[h_count][m_count]\n    dp = [[(max_val_digits, \"\") for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Base case: no moves made\n    dp[0][0] = ([0] * (2 * n), \"\")\n\n    # Iterate through all possible total number of moves\n    for total_moves in range(2 * n):\n        # Iterate through possible Homer moves for current total_moves\n        for h_count in range(min(total_moves + 1, n + 1)):\n            m_count = total_moves - h_count\n            if m_count < 0 or m_count > n:\n                continue\n\n            current_max_sum_digits, current_path = dp[h_count][m_count]\n\n            # If this state is unreachable, skip\n            if current_max_sum_digits[0] == -1: # Check if it's the initial -1 value\n                continue\n\n            # Current digit to be taken from A\n            digit_char = a_str[total_moves]\n            digit_val = int(digit_char)\n\n            # Position of this digit in S1/S2 (0-indexed from MSB)\n            # This is (n - 1) - (h_count or m_count)\n            # If Homer takes it, it's (n - 1 - h_count) for S1.\n            # If Marge takes it, it's (n - 1 - m_count) for S2.\n            \n            # Option 1: Homer takes the digit\n            if h_count < n:\n                next_h_count = h_count + 1\n                next_m_count = m_count\n                \n                # Create a new sum_digits array for Homer's move\n                next_sum_digits_H = list(current_max_sum_digits)\n                s1_pos = n - 1 - h_count # Position in S1 (0-indexed from MSB)\n                next_sum_digits_H[s1_pos] += digit_val # Add to S1's position\n\n                next_path_H = current_path + 'H'\n\n                # Compare with existing value in dp[next_h_count][next_m_count]\n                existing_sum_digits, _ = dp[next_h_count][next_m_count]\n                \n                # Custom comparison for list of digits\n                # Iterate from MSB to LSB\n                is_better = False\n                if existing_sum_digits[0] == -1: # If existing is initial -1, new is always better\n                    is_better = True\n                else:\n                    for i in range(2 * n):\n                        if next_sum_digits_H[i] > existing_sum_digits[i]:\n                            is_better = True\n                            break\n                        elif next_sum_digits_H[i] < existing_sum_digits[i]:\n                            is_better = False\n                            break\n                    # If all digits are equal, path length is already equal (total_moves+1)\n                    # Any path is fine if values are equal, so no need to update if not strictly better\n\n                if is_better:\n                    dp[next_h_count][next_m_count] = (next_sum_digits_H, next_path_H)\n\n            # Option 2: Marge takes the digit\n            if m_count < n:\n                next_h_count = h_count\n                next_m_count = m_count + 1\n\n                # Create a new sum_digits array for Marge's move\n                next_sum_digits_M = list(current_max_sum_digits)\n                s2_pos = n + (n - 1 - m_count) # Position in S2 (0-indexed from MSB, relative to S1)\n                next_sum_digits_M[s2_pos] += digit_val # Add to S2's position\n\n                next_path_M = current_path + 'M'\n\n                # Compare with existing value in dp[next_h_count][next_m_count]\n                existing_sum_digits, _ = dp[next_h_count][next_m_count]\n\n                is_better = False\n                if existing_sum_digits[0] == -1:\n                    is_better = True\n                else:\n                    for i in range(2 * n):\n                        if next_sum_digits_M[i] > existing_sum_digits[i]:\n                            is_better = True\n                            break\n                        elif next_sum_digits_M[i] < existing_sum_digits[i]:\n                            is_better = False\n                            break\n                \n                if is_better:\n                    dp[next_h_count][next_m_count] = (next_sum_digits_M, next_path_M)\n\n    # The final answer is in dp[n][n]\n    final_sum_digits, final_path = dp[n][n]\n    sys.stdout.write(final_path + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 1828,
        "thoughts_token_count": 792
    }
}