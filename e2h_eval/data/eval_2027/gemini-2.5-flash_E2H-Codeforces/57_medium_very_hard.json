{
    "start": 1758294765.616481,
    "end": 1758294847.0255725,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:14 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**The Olympiad Ranking Conundrum**\n\nAlright, let's break this down. We're given a problem where we need to figure out the best and worst possible ranks Vasya could achieve in this Olympiad, given his minimum total score, the scores from two rounds, and the number of participants. The crucial thing is, we only know the scores, not who got what in each round.\n\nMy initial thought is to brute-force it, looking at every possible pairing of scores. But that's a recipe for a time-out, especially with a large number of participants. So, we need a smarter approach.\n\nThe ranking rules are simple: sort by total score, and ties go to the jury (which is a significant detail for the worst-case scenario). The \"Vasya got at least x points\" clause means there's *some* combination of his scores from the two rounds that sum up to at least *x*. We don't know which, so we have to consider all possibilities.\n\n**Best Rank: Always First?**\n\nTo find the best rank, I want to make Vasya's score as high as possible. The maximum any participant can score is the sum of the highest score from the first round and the highest score from the second round. Because of the guarantee, Vasya *can* get at least *x*. Therefore, Vasya can score that maximum possible score, and since ties can be arbitrarily broken, he gets first place every time.\n\n**Worst Rank: Maximizing the Competition**\n\nNow, the worst rank is trickier. Vasya wants to be as low as possible, meaning we need to maximize the number of people who score *at least* what he does, and the jury's role matters in this tie-breaking situation.\n\nMy initial strategy here is to minimize Vasya's score. He must get at least *x* total points. But it is not a good strategy.\n\nI have come to think that the jury can arbitrarily set pairing so all the scores are made in a way to maximize the scores higher than Vasya's score. So I can iterate through all scores that are >=x. Then, in the worst case, Vasya will pick some b value so it makes a score. And, the jury will arrange the other participants so the count >= Vasya's score as much as possible. It is to find the minimum of maximum number of participants >= a given score.\n\nWith some thought and sorting, I think I've cracked it. We need to find the *minimum* score Vasya can achieve, subject to the constraint that his total is at least *x*. Then, we need to maximize the number of other participants who score at least that much. To do that, we use the pairing such that we can pair the greatest a_i to a b_j which sums to a high score.\n\nWe can achieve a solution in O(N log N).  First, sort the scores in ascending order. Then, find the minimum possible score Vasya can get by pairing scores from A and B in such a way that their sum is >=x, using bisect to get the lowest B that can make the sum >=x . Then maximize the number of participants' score by the sorted and paired A and B. That's the key. This pairing strategy is known to maximize the number of pairs that sum to at least *S*.\n\nSo, the worst rank is based on the *minimum* possible score Vasya can get, and how the other participants' scores are *at least* that high, to have the worst possible place.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could have achieved in an Olympiad. We are given the number of participants `n`, a minimum total score `x` Vasya got, and two lists of `n` scores each, `a` for the first tour and `b` for the second tour. The key challenge is that we don't know which `a_i` belongs to which `b_j`, and we don't know which pair of scores belongs to Vasya, other than that his total score must be at least `x`.\n\nThe ranking rules are:\n1. Participants are sorted by the sum of points (total score) in decreasing order.\n2. If two or more participants have the same total score, the jury can assign places arbitrarily among them.\n\n**Best Possible Rank for Vasya:**\n\nTo achieve the best possible rank, Vasya wants to maximize his own score. The highest possible score any participant can get is `max(a) + max(b)`. Let's call this `S_max`.\nThe problem guarantees that \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\". This means Vasya *can* achieve a total score of at least `x`.\nIf Vasya chooses the `a_i` and `b_j` that correspond to `max(a)` and `max(b)` respectively, and if `max(a) + max(b) >= x` (which must be true given the problem guarantee, as explained below), then Vasya achieves `S_max`. No other participant can achieve a score strictly greater than `S_max`. If other participants also achieve `S_max`, the jury can place Vasya first among them due to the arbitrary tie-breaking rule. Therefore, Vasya's best possible rank is **1**.\n\nLet's prove `max(a) + max(b) >= x`. Suppose for contradiction that `max(a) + max(b) < x`. This implies that for *any* `a_i` and *any* `b_j`, `a_i <= max(a)` and `b_j <= max(b)`, so `a_i + b_j <= max(a) + max(b) < x`. This means no pair `(a_i, b_j)` can sum to `x` or more, which contradicts the problem guarantee that Vasya got at least `x` points. Thus, `max(a) + max(b)` must be at least `x`, and Vasya can achieve this maximum possible score.\n\n**Worst Possible Rank for Vasya:**\n\nTo achieve the worst possible rank, Vasya wants to:\n1. Choose his scores `a_i` and `b_j` such that `a_i + b_j >= x` and his total score `S_V` is as small as possible. This minimizes his score while still satisfying the condition.\n2. The jury then pairs up the remaining `n-1` participants (and potentially even Vasya's scores) in such a way that as many participants as possible score *at least* `S_V`. This is because participants with scores greater than `S_V` will definitely be ranked higher, and participants with scores equal to `S_V` can also be placed higher than Vasya by the jury's choice.\n\nLet's find the minimum possible score Vasya can get, `S_V_min`, such that `S_V_min >= x`.\nFirst, sort both lists `a` and `b` in ascending order.\n`a_sorted = [a_0, a_1, ..., a_{n-1}]`\n`b_sorted = [b_0, b_1, ..., b_{n-1}]`\n\nWe can find `S_V_min` using a two-pointer approach. Initialize `S_V_min = infinity`.\nUse a pointer `ptr_a` for `a_sorted` starting from `0`, and `ptr_b` for `b_sorted` starting from `n-1`.\nIterate `ptr_a` from `0` to `n-1`:\n  For the current `a_sorted[ptr_a]`, we need to find the smallest `b_sorted[k]` such that `a_sorted[ptr_a] + b_sorted[k] >= x`.\n  Since `b_sorted` is sorted, `x - a_sorted[ptr_a]` is the minimum `b` value needed.\n  We can use `ptr_b` to efficiently find such `b_sorted[k]`. While `ptr_b >= 0` and `a_sorted[ptr_a] + b_sorted[ptr_b] >= x`:\n    `S_V_min = min(S_V_min, a_sorted[ptr_a] + b_sorted[ptr_b])`\n    `ptr_b -= 1`\nThis process will find the smallest possible sum `a_i + b_j` that is at least `x`. This takes `O(N)` time after sorting.\n\nOnce `S_V_min` is determined, we need to find the maximum number of participants (including Vasya) who can achieve a score of at least `S_V_min`. This is the worst rank for Vasya.\nTo maximize this count, the jury will pair the `n` scores `a_i` and `b_j` to maximize the number of pairs `(a_p, b_q)` such that `a_p + b_q >= S_V_min`.\nThis is a standard greedy problem. Sort `a` in ascending order and `b` in descending order.\n`a_sorted_asc = [a_0, a_1, ..., a_{n-1}]`\n`b_sorted_desc = [b'_{n-1}, b'_{n-2}, ..., b'_0]` (where `b'` is the original `b` sorted ascending, then reversed)\nUse a two-pointer approach:\nInitialize `count = 0`.\n`ptr_a = 0` (smallest `a`)\n`ptr_b = 0` (largest `b` from `b_sorted_desc`)\nWhile `ptr_a < n` and `ptr_b < n`:\n  If `a_sorted_asc[ptr_a] + b_sorted_desc[ptr_b] >= S_V_min`:\n    This pair can achieve `S_V_min`. We use them.\n    `count += 1`\n    `ptr_a += 1`\n    `ptr_b += 1`\n  Else (`a_sorted_asc[ptr_a] + b_sorted_desc[ptr_b] < S_V_min`):\n    The current `a_sorted_asc[ptr_a]` is too small to combine with `b_sorted_desc[ptr_b]` (the largest available `b`) to reach `S_V_min`.\n    Since `a_sorted_asc` is ascending, `a_sorted_asc[ptr_a]` is the smallest available `a`. If it cannot form a sum `>= S_V_min` with `b_sorted_desc[ptr_b]`, it cannot form such a sum with any smaller `b` either.\n    So, we must use `a_sorted_asc[ptr_a]` with some other `b` (which would be smaller than `b_sorted_desc[ptr_b]`, making the sum even smaller) or discard it from consideration for sums `>= S_V_min`. In this greedy strategy, we effectively discard `a_sorted_asc[ptr_a]` from forming a \"successful\" pair and try the next smallest `a`.\n    `ptr_a += 1`\nThe final `count` will be the maximum number of participants who can score at least `S_V_min`. This `count` is Vasya's worst rank. This also takes `O(N)` time after sorting.\n\nTotal time complexity: `O(N log N)` for sorting, `O(N)` for two-pointer traversals. Overall `O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays.\n\n**Example Walkthrough (Second Sample):**\n`n=6, x=7`\n`a = [4,3,5,6,4,4]`\n`b = [8,6,0,4,3,4]`\n\n1. **Sort `a` and `b` ascending:**\n   `a_sorted = [3,4,4,4,5,6]`\n   `b_sorted = [0,3,4,4,6,8]`\n\n2. **Find `S_V_min`:**\n   `S_V_min = infinity`\n   `ptr_b = 5` (points to `b_sorted[5] = 8`)\n   `ptr_a = 0` (`a_sorted[0] = 3`):\n     `3 + 8 = 11 >= 7`. `S_V_min = min(inf, 11) = 11`. `ptr_b = 4` (points to `6`).\n     `3 + 6 = 9 >= 7`. `S_V_min = min(11, 9) = 9`. `ptr_b = 3` (points to `4`).\n     `3 + 4 = 7 >= 7`. `S_V_min = min(9, 7) = 7`. `ptr_b = 2` (points to `4`).\n     `3 + 4 = 7 >= 7`. `S_V_min = min(7, 7) = 7`. `ptr_b = 1` (points to `3`).\n     `3 + 3 = 6 < 7`. Stop for `a_sorted[0]`.\n   `ptr_a = 1` (`a_sorted[1] = 4`):\n     `ptr_b` is `1`. `4 + 3 = 7 >= 7`. `S_V_min = min(7, 7) = 7`. `ptr_b = 0` (points to `0`).\n     `4 + 0 = 4 < 7`. Stop for `a_sorted[1]`.\n   ... (continue for `ptr_a = 2,3,4,5`, but `S_V_min` won't get smaller than 7)\n   So, `S_V_min = 7`.\n\n3. **Find worst rank using `S_V_min = 7`:**\n   `a_sorted_asc = [3,4,4,4,5,6]`\n   `b_sorted_desc = [8,6,4,4,3,0]` (reversed `b_sorted`)\n   `count = 0`\n   `ptr_a = 0` (`a_sorted_asc[0] = 3`)\n   `ptr_b = 0` (`b_sorted_desc[0] = 8`)\n   - `3 + 8 = 11 >= 7`. `count = 1`. `ptr_a = 1`, `ptr_b = 1`.\n   - `4 + 6 = 10 >= 7`. `count = 2`. `ptr_a = 2`, `ptr_b = 2`.\n   - `4 + 4 = 8 >= 7`. `count = 3`. `ptr_a = 3`, `ptr_b = 3`.\n   - `4 + 4 = 8 >= 7`. `count = 4`. `ptr_a = 4`, `ptr_b = 4`.\n   - `5 + 3 = 8 >= 7`. `count = 5`. `ptr_a = 5`, `ptr_b = 5`.\n   - `6 + 0 = 6 < 7`. `ptr_a = 6`. Loop ends because `ptr_a == n`.\n   The `count` is 5. So, the worst rank is **5**.\n\nOutput: `1 5`\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank is always 1.\n    # Vasya can choose the highest score from A and highest score from B.\n    # The problem guarantees that there exist a_i, b_j such that a_i + b_j >= x.\n    # If max(a) + max(b) < x, it would contradict the guarantee, because any a_k + b_l\n    # would be <= max(a) + max(b) < x.\n    # So, max(a) + max(b) >= x. Vasya can achieve this maximum possible score.\n    # With the highest possible score, and jury's choice for ties, Vasya can be rank 1.\n    best_rank = 1\n\n    # Worst possible rank\n    # 1. Vasya wants to minimize his score S_V, such that S_V >= x.\n    # 2. The jury then pairs the other participants (and Vasya's scores) to maximize\n    #    the number of people who score >= S_V.\n\n    # Sort both arrays in ascending order to find S_V_min efficiently.\n    a.sort()\n    b.sort()\n\n    # Find S_V_min: the minimum possible score Vasya can get while >= x.\n    s_v_min = float('inf')\n    ptr_b_for_s_v_min = n - 1\n    for i in range(n):\n        # For current a[i], find smallest b[k] such that a[i] + b[k] >= x\n        # Since b is sorted, we can use a two-pointer approach.\n        # While a[i] + b[ptr_b_for_s_v_min] is >= x, it's a candidate for S_V_min.\n        # We want the smallest such sum, so we decrement ptr_b_for_s_v_min to try smaller b's.\n        while ptr_b_for_s_v_min >= 0 and a[i] + b[ptr_b_for_s_v_min] >= x:\n            s_v_min = min(s_v_min, a[i] + b[ptr_b_for_s_v_min])\n            ptr_b_for_s_v_min -= 1\n        # If ptr_b_for_s_v_min becomes negative, it means a[i] is too large to pair with any b\n        # to get a sum >= x, or all b's have been checked.\n        # If a[i] + b[0] < x, then a[i] cannot form a sum >= x with any b.\n        # Since a is sorted, further a[j] (j > i) will be larger, so they might be able to.\n        # But we are finding the MINIMUM possible S_V, so we need to continue checking all a[i].\n        # The loop structure ensures this.\n\n    # Now, find the maximum number of participants who can score >= S_V_min.\n    # This is the worst rank.\n    # To maximize this count, we sort `a` ascending and `b` descending, then use two pointers.\n    # `a` is already sorted ascending.\n    # `b` needs to be considered in descending order for this part.\n    b_desc = sorted(b, reverse=True) # Or just b.reverse() if we don't need original b\n\n    worst_rank_count = 0\n    ptr_a = 0\n    ptr_b_desc = 0\n    while ptr_a < n and ptr_b_desc < n:\n        if a[ptr_a] + b_desc[ptr_b_desc] >= s_v_min:\n            # This pair (a[ptr_a], b_desc[ptr_b_desc]) can achieve S_V_min.\n            worst_rank_count += 1\n            ptr_a += 1\n            ptr_b_desc += 1\n        else:\n            # a[ptr_a] is too small to combine with b_desc[ptr_b_desc] (largest available b)\n            # to reach S_V_min. It cannot form a successful pair with any smaller b either.\n            # So, we increment ptr_a to try the next smallest a.\n            ptr_a += 1\n    \n    worst_rank = worst_rank_count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank is always 1.\n    # Vasya can choose the highest score from A and highest score from B.\n    # The problem guarantees that there exist a_i, b_j such that a_i + b_j >= x.\n    # If max(a) + max(b) < x, it would contradict the guarantee, because any a_k + b_l\n    # would be <= max(a) + max(b) < x.\n    # So, max(a) + max(b) >= x. Vasya can achieve this maximum possible score.\n    # With the highest possible score, and jury's choice for ties, Vasya can be rank 1.\n    best_rank = 1\n\n    # Worst possible rank\n    # 1. Vasya wants to minimize his score S_V, such that S_V >= x.\n    # 2. The jury then pairs the other participants (and Vasya's scores) to maximize\n    #    the number of people who score >= S_V.\n\n    # Sort both arrays in ascending order to find S_V_min efficiently.\n    a.sort()\n    b.sort()\n\n    # Find S_V_min: the minimum possible score Vasya can get while >= x.\n    s_v_min = float('inf')\n    ptr_b_for_s_v_min = n - 1\n    for i in range(n):\n        # For current a[i], find smallest b[k] such that a[i] + b[k] >= x\n        # Since b is sorted, we can use a two-pointer approach.\n        # While a[i] + b[ptr_b_for_s_v_min] is >= x, it's a candidate for S_V_min.\n        # We want the smallest such sum, so we decrement ptr_b_for_s_v_min to try smaller b's.\n        while ptr_b_for_s_v_min >= 0 and a[i] + b[ptr_b_for_s_v_min] >= x:\n            s_v_min = min(s_v_min, a[i] + b[ptr_b_for_s_v_min])\n            ptr_b_for_s_v_min -= 1\n        # If ptr_b_for_s_v_min becomes negative, it means a[i] is too large to pair with any b\n        # to get a sum >= x, or all b's have been checked.\n        # If a[i] + b[0] < x, then a[i] cannot form a sum >= x with any b.\n        # Since a is sorted, further a[j] (j > i) will be larger, so they might be able to.\n        # But we are finding the MINIMUM possible S_V, so we need to continue checking all a[i].\n        # The loop structure ensures this.\n\n    # Now, find the maximum number of participants who can score >= S_V_min.\n    # This is the worst rank.\n    # To maximize this count, we sort `a` ascending and `b` descending, then use two pointers.\n    # `a` is already sorted ascending.\n    # `b` needs to be considered in descending order for this part.\n    b_desc = sorted(b, reverse=True) # Or just b.reverse() if we don't need original b\n\n    worst_rank_count = 0\n    ptr_a = 0\n    ptr_b_desc = 0\n    while ptr_a < n and ptr_b_desc < n:\n        if a[ptr_a] + b_desc[ptr_b_desc] >= s_v_min:\n            # This pair (a[ptr_a], b_desc[ptr_b_desc]) can achieve S_V_min.\n            worst_rank_count += 1\n            ptr_a += 1\n            ptr_b_desc += 1\n        else:\n            # a[ptr_a] is too small to combine with b_desc[ptr_b_desc] (largest available b)\n            # to reach S_V_min. It cannot form a successful pair with any smaller b either.\n            # So, we increment ptr_a to try the next smallest a.\n            ptr_a += 1\n    \n    worst_rank = worst_rank_count\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 3847,
        "thoughts_token_count": 7073
    }
}