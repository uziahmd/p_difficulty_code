{
    "start": 1758293743.6028433,
    "end": 1758293751.8840995,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    s = input()\n    n = len(s)\n\n    count_ones = s.count('1')\n    \n    # Extract characters other than '1'\n    other_chars = []\n    for char in s:\n        if char != '1':\n            other_chars.append(char)\n    \n    # Find the first '2' in the string of other_chars\n    first_two_idx_in_other = -1\n    for i in range(len(other_chars)):\n        if other_chars[i] == '2':\n            first_two_idx_in_other = i\n            break\n            \n    result = []\n    if first_two_idx_in_other == -1:\n        # No '2's in the string. All '0's and '1's.\n        # We can move all '0's to the left of all '1's.\n        # The result will be all '0's followed by all '1's.\n        result.extend(['0'] * s.count('0'))\n        result.extend(['1'] * count_ones)\n    else:\n        # There are '2's. We can move all '0's to the left of the first '2'.\n        # We can move all '1's to be adjacent to each other.\n        # '0's can move past '1's, '1's can move past '2's.\n        # '0's cannot move past '2's.\n        # This means all '0's must appear before all '2's.\n        # '1's can be moved anywhere relative to '0's and '2's,\n        # but they cannot cross a '0' and a '2' if the '0' is before the '2'.\n        # The optimal strategy is to put all '0's first, then all '1's, then all '2's.\n        # However, '0's cannot move past '2's.\n        # So, any '0' that appears after a '2' in the original string (and thus in the other_chars string)\n        # cannot move to the left of that '2'.\n        # The '1's can be moved anywhere relative to '0's and '2's, as long as they don't\n        # cause a '0' to be forced to the right of a '2' or vice versa.\n        # Since '1's can swap with '0's and '2's, they effectively act as a \"pass-through\"\n        # for '0's and '2's.\n        # '0's can move past '1's to the left.\n        # '1's can move past '2's to the left.\n        # This means all '0's can be moved to the very beginning of the string,\n        # and all '2's can be moved to the very end of the string,\n        # but only as long as no '0' crosses a '2'.\n        # The relative order of '0's and '2's is preserved.\n        # The '1's can be placed anywhere. To make the string lexicographically smallest,\n        # we want '0's first, then '1's, then '2's.\n        # The '1's should be placed after all '0's and before all '2's.\n        # If there are no '2's, all '0's then all '1's. (Handled above)\n        # If there are '2's, then the '1's must be placed *before* the first '2' encountered\n        # in the sequence of '0's and '2's.\n        # Consider the string with '1's removed. Let this be S'.\n        # S' consists only of '0's and '2's. The relative order of characters in S' cannot change.\n        # We want to insert all '1's into S' to make the string lexicographically smallest.\n        # To do this, we should insert all '1's at the earliest possible position.\n        # The earliest possible position for '1's is right after all '0's that appear before the first '2'.\n        # More precisely, all '0's should come first. Then all '1's. Then all '2's.\n        # But since '0's cannot swap with '2's, the relative order of '0's and '2's is fixed.\n        # Example: \"20\" -> \"20\". '1's would go between '2' and '0'.\n        # Example: \"02\" -> \"02\". '1's would go between '0' and '2'.\n        # So, we iterate through the 'other_chars' string.\n        # Print all '0's.\n        # When we encounter the first '2', that's where we insert all the '1's.\n        # Then print the rest of the 'other_chars' (which will be '2's and any '0's that appeared after the first '2').\n        \n        for i in range(len(other_chars)):\n            if other_chars[i] == '0':\n                result.append('0')\n            elif other_chars[i] == '2':\n                # This is the first '2' we encounter in the sequence of '0's and '2's.\n                # All '1's should be placed here.\n                result.extend(['1'] * count_ones)\n                result.append('2')\n                # After placing '1's, append the rest of the 'other_chars'\n                result.extend(other_chars[i+1:])\n                break\n                \n    print(\"\".join(result))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    s = input()\n    n = len(s)\n\n    count_ones = s.count('1')\n    \n    # Extract characters other than '1'\n    other_chars = []\n    for char in s:\n        if char != '1':\n            other_chars.append(char)\n    \n    # Find the first '2' in the string of other_chars\n    first_two_idx_in_other = -1\n    for i in range(len(other_chars)):\n        if other_chars[i] == '2':\n            first_two_idx_in_other = i\n            break\n            \n    result = []\n    if first_two_idx_in_other == -1:\n        # No '2's in the string. All '0's and '1's.\n        # We can move all '0's to the left of all '1's.\n        # The result will be all '0's followed by all '1's.\n        result.extend(['0'] * s.count('0'))\n        result.extend(['1'] * count_ones)\n    else:\n        # There are '2's. We can move all '0's to the left of the first '2'.\n        # We can move all '1's to be adjacent to each other.\n        # '0's can move past '1's, '1's can move past '2's.\n        # '0's cannot move past '2's.\n        # This means all '0's must appear before all '2's.\n        # '1's can be moved anywhere relative to '0's and '2's,\n        # but they cannot cross a '0' and a '2' if the '0' is before the '2'.\n        # The optimal strategy is to put all '0's first, then all '1's, then all '2's.\n        # However, '0's cannot move past '2's.\n        # So, any '0' that appears after a '2' in the original string (and thus in the other_chars string)\n        # cannot move to the left of that '2'.\n        # The '1's can be moved anywhere relative to '0's and '2's, as long as they don't\n        # cause a '0' to be forced to the right of a '2' or vice versa.\n        # Since '1's can swap with '0's and '2's, they effectively act as a \"pass-through\"\n        # for '0's and '2's.\n        # '0's can move past '1's to the left.\n        # '1's can move past '2's to the left.\n        # This means all '0's can be moved to the very beginning of the string,\n        # and all '2's can be moved to the very end of the string,\n        # but only as long as no '0' crosses a '2'.\n        # The relative order of '0's and '2's is preserved.\n        # The '1's can be placed anywhere. To make the string lexicographically smallest,\n        # we want '0's first, then '1's, then '2's.\n        # The '1's should be placed after all '0's and before all '2's.\n        # If there are no '2's, all '0's then all '1's. (Handled above)\n        # If there are '2's, then the '1's must be placed *before* the first '2' encountered\n        # in the sequence of '0's and '2's.\n        # Consider the string with '1's removed. Let this be S'.\n        # S' consists only of '0's and '2's. The relative order of characters in S' cannot change.\n        # We want to insert all '1's into S' to make the string lexicographically smallest.\n        # To do this, we should insert all '1's at the earliest possible position.\n        # The earliest possible position for '1's is right after all '0's that appear before the first '2'.\n        # More precisely, all '0's should come first. Then all '1's. Then all '2's.\n        # But since '0's cannot swap with '2's, the relative order of '0's and '2's is fixed.\n        # Example: \"20\" -> \"20\". '1's would go between '2' and '0'.\n        # Example: \"02\" -> \"02\". '1's would go between '0' and '2'.\n        # So, we iterate through the 'other_chars' string.\n        # Print all '0's.\n        # When we encounter the first '2', that's where we insert all the '1's.\n        # Then print the rest of the 'other_chars' (which will be '2's and any '0's that appeared after the first '2').\n        \n        for i in range(len(other_chars)):\n            if other_chars[i] == '0':\n                result.append('0')\n            elif other_chars[i] == '2':\n                # This is the first '2' we encounter in the sequence of '0's and '2's.\n                # All '1's should be placed here.\n                result.extend(['1'] * count_ones)\n                result.append('2')\n                # After placing '1's, append the rest of the 'other_chars'\n                result.extend(other_chars[i+1:])\n                break\n                \n    print(\"\".join(result))\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 612,
        "completion_token_count": 1356,
        "thoughts_token_count": 0
    }
}