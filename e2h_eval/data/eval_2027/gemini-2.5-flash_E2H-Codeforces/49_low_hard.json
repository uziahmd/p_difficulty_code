{
    "start": 1758284910.0272489,
    "end": 1758284942.2861006,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Thinking Through Mushroom Strife**\n\nOkay, so I'm tackling this \"Mushroom Strife\" problem. The core is about restoring the number of mushrooms on each lawn, given GCD and LCM relationships between connected lawns. The constraints are pretty manageable: up to 100 lawns and a decent number of roads.  I need a \"YES\" or \"NO\" answer and potentially the mushroom count for each lawn.\n\nMy initial thought is to dive into the core mathematical property: `GCD(a, b) * LCM(a, b) = a * b`. That's the key.  If I know the GCD (`g`) and LCM (`l`) for two lawns (`u` and `v`), I can deduce that `x_u * x_v = g * l`. That alone is not enough, but it provides a starting point.\n\nHere's how I'm thinking about breaking down the constraints on these values: If `x_u` and `x_v` have a GCD of `g`, then both `x_u` and `x_v` *must* be multiples of `g`.  Let's say `x_u = g * a_u` and `x_v = g * a_v`.  The LCM relation then tells me `l = g * a_u * a_v`, and crucially, since the GCD of `x_u` and `x_v` is `g`, then `GCD(a_u, a_v)` must be 1.  This creates a specific relationship: `a_u * a_v = l / g`.\n\nSo, for any valid edge, `l` has to be divisible by `g`. That's a sanity check.  Then I can define a value `P = l / g`.  Now, I'm looking for a pair of integers, `a_u` and `a_v`, that are coprime (their GCD is 1) and their product equals `P`. This is the crux. `a_u` and `a_v` effectively give me the *ratio* relationship between the two mushroom counts.\n\nMy approach will be to analyze each edge. For each edge (`u`, `v`, `g`, `l`), I calculate `P = l / g`. I'll need a way to find a pair of coprime factors of `P`. I'm thinking of prime factorization as one way to do it. The prime factors of `P` will dictate my possible values for `a_u` and `a_v`, and finding the pairings such that their GCD is 1 will be key. Then I’ll need to figure out how to assign these values to create a consistent solution across all the edges. It seems like a form of constraint satisfaction problem, so maybe graph traversal could come into play.\n",
    "response": "```python\nimport sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Edge case not explicitly mentioned, but good to handle.\n        sys.stdout.write(\"YES\\n\\n\")\n        return\n\n    # Store information for each node and edge\n    # node_values[i]: current assigned value for lawn i+1. None if not assigned.\n    node_values = [None] * n\n    \n    # node_candidates[i]: set of possible values for lawn i+1 based on all incident edges.\n    # An empty set means no valid values, indicating impossibility.\n    # If a value is assigned (node_values[i] is not None), this set is effectively {node_values[i]}.\n    node_candidates = [set() for _ in range(n)]\n\n    # Store edges as (u, v, g, l)\n    edges = []\n\n    # Process each edge\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1  # Adjust to 0-indexed\n        v -= 1  # Adjust to 0-indexed\n        \n        # Check basic condition: l must be divisible by g\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n        \n        P = l // g # P = (x_u / g) * (x_v / g)\n        \n        # Find all valid (A, B) pairs such that A*B = P and GCD(A, B) = 1\n        # For each such pair, g*A is a candidate for x_u and g*B for x_v (or vice versa)\n        \n        # Find prime factors of P\n        prime_factors_P = set()\n        temp_P = P\n        d = 2\n        while d * d <= temp_P:\n            if temp_P % d == 0:\n                prime_factors_P.add(d)\n                while temp_P % d == 0:\n                    temp_P //= d\n            d += 1\n        if temp_P > 1:\n            prime_factors_P.add(temp_P)\n            \n        # Generate all divisors of P\n        divisors_P = set()\n        for i in range(1, int(math.sqrt(P)) + 1):\n            if P % i == 0:\n                divisors_P.add(i)\n                divisors_P.add(P // i)\n        \n        # Determine candidates for x_u and x_v\n        # A candidate value for x_u must be g * A, where A is a divisor of P\n        # and GCD(A, P/A) = 1.\n        \n        edge_u_candidates = set()\n        edge_v_candidates = set()\n        \n        for A in divisors_P:\n            B = P // A\n            \n            # Check GCD(A, B) = 1.\n            # This is equivalent to checking that A and B share no common prime factors.\n            # Since A*B=P, this means A must be formed by a subset of prime factors of P,\n            # and B by the remaining prime factors.\n            \n            # A simpler way to check GCD(A, B) == 1 for A*B=P:\n            # Iterate through prime factors of P. For each prime factor `p`,\n            # either `p` divides `A` or `p` divides `B`, but not both.\n            # If `p` divides `A` and `B`, then `p` divides `GCD(A, B)`.\n            # If `GCD(A, B) > 1`, then there's a common prime factor.\n            # If `GCD(A, B) == 1`, then there's no common prime factor.\n            \n            # The condition GCD(A, B) = 1 is crucial.\n            # If A and B share a prime factor, say 'p', then p divides A and p divides B.\n            # So p*g divides x_u and p*g divides x_v, meaning GCD(x_u, x_v) >= p*g > g.\n            # This violates GCD(x_u, x_v) = g.\n            \n            # So we must have GCD(A, B) = 1.\n            \n            # Check if A and B are coprime\n            is_coprime = True\n            for p_factor in prime_factors_P:\n                if A % p_factor == 0 and B % p_factor == 0:\n                    is_coprime = False\n                    break\n            \n            if is_coprime:\n                edge_u_candidates.add(g * A)\n                edge_v_candidates.add(g * B)\n        \n        # Store edge and its candidates for later processing\n        edges.append((u, v, g, l, edge_u_candidates, edge_v_candidates))\n\n        # Update global candidate sets for u and v\n        if not node_candidates[u]: # First edge for u\n            node_candidates[u].update(edge_u_candidates)\n        else: # Intersect with existing candidates\n            node_candidates[u].intersection_update(edge_u_candidates)\n            \n        if not node_candidates[v]: # First edge for v\n            node_candidates[v].update(edge_v_candidates)\n        else: # Intersect with existing candidates\n            node_candidates[v].intersection_update(edge_v_candidates)\n            \n        # If any node has no candidates, it's impossible\n        if not node_candidates[u] or not node_candidates[v]:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # If m = 0, any valid values (e.g., all 1s) work.\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join([\"1\"] * n) + \"\\n\")\n        return\n\n    # Propagation phase: Iterate and try to assign values\n    # We use a queue for nodes that have been assigned a value or whose candidate set has changed significantly.\n    q = []\n    for i in range(n):\n        if len(node_candidates[i]) == 1:\n            val = next(iter(node_candidates[i]))\n            if node_values[i] is None: # Only add to queue if not already assigned\n                node_values[i] = val\n                q.append(i)\n        elif not node_candidates[i]: # No candidates, impossible\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # BFS-like propagation\n    while q:\n        curr_node_idx = q.pop(0)\n        curr_val = node_values[curr_node_idx]\n\n        # Check all edges that involve curr_node_idx\n        for u, v, g, l, u_edge_candidates, v_edge_candidates in edges:\n            other_node_idx = -1\n            if u == curr_node_idx:\n                other_node_idx = v\n                # Check if curr_val is a valid candidate for u in this specific edge\n                if curr_val not in u_edge_candidates:\n                    sys.stdout.write(\"NO\\n\") # Current assignment invalid for an edge\n                    return\n                \n                # Derive candidates for the other node (v) based on curr_val for u\n                new_other_node_candidates = set()\n                P = l // g\n                # Find A such that curr_val = g * A\n                A = curr_val // g\n                # B = P / A\n                B = P // A\n                # The only valid value for x_v is g * B\n                new_other_node_candidates.add(g * B)\n                \n            elif v == curr_node_idx:\n                other_node_idx = u\n                # Check if curr_val is a valid candidate for v in this specific edge\n                if curr_val not in v_edge_candidates:\n                    sys.stdout.write(\"NO\\n\") # Current assignment invalid for an edge\n                    return\n                \n                # Derive candidates for the other node (u) based on curr_val for v\n                new_other_node_candidates = set()\n                P = l // g\n                # Find B such that curr_val = g * B\n                B = curr_val // g\n                # A = P / B\n                A = P // B\n                # The only valid value for x_u is g * A\n                new_other_node_candidates.add(g * A)\n            \n            if other_node_idx != -1: # If this edge involves curr_node_idx\n                # Intersect with the global candidates for other_node_idx\n                old_candidates_size = len(node_candidates[other_node_idx])\n                node_candidates[other_node_idx].intersection_update(new_other_node_candidates)\n                \n                if not node_candidates[other_node_idx]: # No candidates left for other node\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                # If other_node_idx is not yet assigned and its candidates reduced to 1\n                if node_values[other_node_idx] is None and len(node_candidates[other_node_idx]) == 1:\n                    val = next(iter(node_candidates[other_node_idx]))\n                    node_values[other_node_idx] = val\n                    q.append(other_node_idx) # Add to queue for further propagation\n                # If other_node_idx is already assigned, check consistency\n                elif node_values[other_node_idx] is not None:\n                    if node_values[other_node_idx] not in node_candidates[other_node_idx]:\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n    # After propagation, if some nodes are still unassigned, pick an arbitrary valid candidate\n    # and continue propagation. This handles disconnected components or cases where\n    # values aren't uniquely determined initially.\n    \n    # This part is crucial for finding *any* solution.\n    # We iterate through nodes. If a node is unassigned, pick its smallest candidate value,\n    # assign it, and propagate its effect.\n    for i in range(n):\n        if node_values[i] is None:\n            if not node_candidates[i]:\n                sys.stdout.write(\"NO\\n\") # Should have been caught earlier, but safety check\n                return\n            \n            # Pick the smallest candidate value to ensure deterministic output if multiple solutions exist\n            # and to minimize values (though not strictly required by problem).\n            # Any candidate would work for finding *a* solution.\n            val_to_assign = min(node_candidates[i]) \n            node_values[i] = val_to_assign\n            q.append(i) # Add to queue to propagate this choice\n\n            while q:\n                curr_node_idx = q.pop(0)\n                curr_val = node_values[curr_node_idx]\n                \n                # Check all edges again for this newly assigned value\n                for u, v, g, l, u_edge_candidates, v_edge_candidates in edges:\n                    other_node_idx = -1\n                    if u == curr_node_idx:\n                        other_node_idx = v\n                        if curr_val not in u_edge_candidates:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        P = l // g\n                        A = curr_val // g\n                        B = P // A\n                        expected_other_val = g * B\n                        \n                    elif v == curr_node_idx:\n                        other_node_idx = u\n                        if curr_val not in v_edge_candidates:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        P = l // g\n                        B = curr_val // g\n                        A = P // B\n                        expected_other_val = g * A\n                    \n                    if other_node_idx != -1:\n                        # If the other node is unassigned, assign it the derived value\n                        if node_values[other_node_idx] is None:\n                            # Check if derived value is in its current candidates\n                            if expected_other_val not in node_candidates[other_node_idx]:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                            node_values[other_node_idx] = expected_other_val\n                            q.append(other_node_idx)\n                        # If the other node is already assigned, check for consistency\n                        elif node_values[other_node_idx] != expected_other_val:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n    # Final verification of all edges\n    for u, v, g, l, _, _ in edges:\n        val_u = node_values[u]\n        val_v = node_values[v]\n        \n        if val_u is None or val_v is None: # Should not happen if all nodes processed\n             sys.stdout.write(\"NO\\n\")\n             return\n\n        if math.gcd(val_u, val_v) != g or (val_u * val_v) // math.gcd(val_u, val_v) != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # If all checks pass, print YES and the values\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, node_values)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Edge case not explicitly mentioned, but good to handle.\n        sys.stdout.write(\"YES\\n\\n\")\n        return\n\n    # Store information for each node and edge\n    # node_values[i]: current assigned value for lawn i+1. None if not assigned.\n    node_values = [None] * n\n    \n    # node_candidates[i]: set of possible values for lawn i+1 based on all incident edges.\n    # An empty set means no valid values, indicating impossibility.\n    # If a value is assigned (node_values[i] is not None), this set is effectively {node_values[i]}.\n    node_candidates = [set() for _ in range(n)]\n\n    # Store edges as (u, v, g, l)\n    edges = []\n\n    # Process each edge\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1  # Adjust to 0-indexed\n        v -= 1  # Adjust to 0-indexed\n        \n        # Check basic condition: l must be divisible by g\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n        \n        P = l // g # P = (x_u / g) * (x_v / g)\n        \n        # Find all valid (A, B) pairs such that A*B = P and GCD(A, B) = 1\n        # For each such pair, g*A is a candidate for x_u and g*B for x_v (or vice versa)\n        \n        # Find prime factors of P\n        prime_factors_P = set()\n        temp_P = P\n        d = 2\n        while d * d <= temp_P:\n            if temp_P % d == 0:\n                prime_factors_P.add(d)\n                while temp_P % d == 0:\n                    temp_P //= d\n            d += 1\n        if temp_P > 1:\n            prime_factors_P.add(temp_P)\n            \n        # Generate all divisors of P\n        divisors_P = set()\n        for i in range(1, int(math.sqrt(P)) + 1):\n            if P % i == 0:\n                divisors_P.add(i)\n                divisors_P.add(P // i)\n        \n        # Determine candidates for x_u and x_v\n        # A candidate value for x_u must be g * A, where A is a divisor of P\n        # and GCD(A, P/A) = 1.\n        \n        edge_u_candidates = set()\n        edge_v_candidates = set()\n        \n        for A in divisors_P:\n            B = P // A\n            \n            # Check GCD(A, B) = 1.\n            # This is equivalent to checking that A and B share no common prime factors.\n            # Since A*B=P, this means A must be formed by a subset of prime factors of P,\n            # and B by the remaining prime factors.\n            \n            # A simpler way to check GCD(A, B) == 1 for A*B=P:\n            # Iterate through prime factors of P. For each prime factor `p`,\n            # either `p` divides `A` or `p` divides `B`, but not both.\n            # If `p` divides `A` and `B`, then `p` divides `GCD(A, B)`.\n            # If `GCD(A, B) > 1`, then there's a common prime factor.\n            # If `GCD(A, B) == 1`, then there's no common prime factor.\n            \n            # The condition GCD(A, B) = 1 is crucial.\n            # If A and B share a prime factor, say 'p', then p divides A and p divides B.\n            # So p*g divides x_u and p*g divides x_v, meaning GCD(x_u, x_v) >= p*g > g.\n            # This violates GCD(x_u, x_v) = g.\n            \n            # So we must have GCD(A, B) = 1.\n            \n            # Check if A and B are coprime\n            is_coprime = True\n            for p_factor in prime_factors_P:\n                if A % p_factor == 0 and B % p_factor == 0:\n                    is_coprime = False\n                    break\n            \n            if is_coprime:\n                edge_u_candidates.add(g * A)\n                edge_v_candidates.add(g * B)\n        \n        # Store edge and its candidates for later processing\n        edges.append((u, v, g, l, edge_u_candidates, edge_v_candidates))\n\n        # Update global candidate sets for u and v\n        if not node_candidates[u]: # First edge for u\n            node_candidates[u].update(edge_u_candidates)\n        else: # Intersect with existing candidates\n            node_candidates[u].intersection_update(edge_u_candidates)\n            \n        if not node_candidates[v]: # First edge for v\n            node_candidates[v].update(edge_v_candidates)\n        else: # Intersect with existing candidates\n            node_candidates[v].intersection_update(edge_v_candidates)\n            \n        # If any node has no candidates, it's impossible\n        if not node_candidates[u] or not node_candidates[v]:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # If m = 0, any valid values (e.g., all 1s) work.\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join([\"1\"] * n) + \"\\n\")\n        return\n\n    # Propagation phase: Iterate and try to assign values\n    # We use a queue for nodes that have been assigned a value or whose candidate set has changed significantly.\n    q = []\n    for i in range(n):\n        if len(node_candidates[i]) == 1:\n            val = next(iter(node_candidates[i]))\n            if node_values[i] is None: # Only add to queue if not already assigned\n                node_values[i] = val\n                q.append(i)\n        elif not node_candidates[i]: # No candidates, impossible\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # BFS-like propagation\n    while q:\n        curr_node_idx = q.pop(0)\n        curr_val = node_values[curr_node_idx]\n\n        # Check all edges that involve curr_node_idx\n        for u, v, g, l, u_edge_candidates, v_edge_candidates in edges:\n            other_node_idx = -1\n            if u == curr_node_idx:\n                other_node_idx = v\n                # Check if curr_val is a valid candidate for u in this specific edge\n                if curr_val not in u_edge_candidates:\n                    sys.stdout.write(\"NO\\n\") # Current assignment invalid for an edge\n                    return\n                \n                # Derive candidates for the other node (v) based on curr_val for u\n                new_other_node_candidates = set()\n                P = l // g\n                # Find A such that curr_val = g * A\n                A = curr_val // g\n                # B = P / A\n                B = P // A\n                # The only valid value for x_v is g * B\n                new_other_node_candidates.add(g * B)\n                \n            elif v == curr_node_idx:\n                other_node_idx = u\n                # Check if curr_val is a valid candidate for v in this specific edge\n                if curr_val not in v_edge_candidates:\n                    sys.stdout.write(\"NO\\n\") # Current assignment invalid for an edge\n                    return\n                \n                # Derive candidates for the other node (u) based on curr_val for v\n                new_other_node_candidates = set()\n                P = l // g\n                # Find B such that curr_val = g * B\n                B = curr_val // g\n                # A = P / B\n                A = P // B\n                # The only valid value for x_u is g * A\n                new_other_node_candidates.add(g * A)\n            \n            if other_node_idx != -1: # If this edge involves curr_node_idx\n                # Intersect with the global candidates for other_node_idx\n                old_candidates_size = len(node_candidates[other_node_idx])\n                node_candidates[other_node_idx].intersection_update(new_other_node_candidates)\n                \n                if not node_candidates[other_node_idx]: # No candidates left for other node\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                # If other_node_idx is not yet assigned and its candidates reduced to 1\n                if node_values[other_node_idx] is None and len(node_candidates[other_node_idx]) == 1:\n                    val = next(iter(node_candidates[other_node_idx]))\n                    node_values[other_node_idx] = val\n                    q.append(other_node_idx) # Add to queue for further propagation\n                # If other_node_idx is already assigned, check consistency\n                elif node_values[other_node_idx] is not None:\n                    if node_values[other_node_idx] not in node_candidates[other_node_idx]:\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n    # After propagation, if some nodes are still unassigned, pick an arbitrary valid candidate\n    # and continue propagation. This handles disconnected components or cases where\n    # values aren't uniquely determined initially.\n    \n    # This part is crucial for finding *any* solution.\n    # We iterate through nodes. If a node is unassigned, pick its smallest candidate value,\n    # assign it, and propagate its effect.\n    for i in range(n):\n        if node_values[i] is None:\n            if not node_candidates[i]:\n                sys.stdout.write(\"NO\\n\") # Should have been caught earlier, but safety check\n                return\n            \n            # Pick the smallest candidate value to ensure deterministic output if multiple solutions exist\n            # and to minimize values (though not strictly required by problem).\n            # Any candidate would work for finding *a* solution.\n            val_to_assign = min(node_candidates[i]) \n            node_values[i] = val_to_assign\n            q.append(i) # Add to queue to propagate this choice\n\n            while q:\n                curr_node_idx = q.pop(0)\n                curr_val = node_values[curr_node_idx]\n                \n                # Check all edges again for this newly assigned value\n                for u, v, g, l, u_edge_candidates, v_edge_candidates in edges:\n                    other_node_idx = -1\n                    if u == curr_node_idx:\n                        other_node_idx = v\n                        if curr_val not in u_edge_candidates:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        P = l // g\n                        A = curr_val // g\n                        B = P // A\n                        expected_other_val = g * B\n                        \n                    elif v == curr_node_idx:\n                        other_node_idx = u\n                        if curr_val not in v_edge_candidates:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        P = l // g\n                        B = curr_val // g\n                        A = P // B\n                        expected_other_val = g * A\n                    \n                    if other_node_idx != -1:\n                        # If the other node is unassigned, assign it the derived value\n                        if node_values[other_node_idx] is None:\n                            # Check if derived value is in its current candidates\n                            if expected_other_val not in node_candidates[other_node_idx]:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n                            node_values[other_node_idx] = expected_other_val\n                            q.append(other_node_idx)\n                        # If the other node is already assigned, check for consistency\n                        elif node_values[other_node_idx] != expected_other_val:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n    # Final verification of all edges\n    for u, v, g, l, _, _ in edges:\n        val_u = node_values[u]\n        val_v = node_values[v]\n        \n        if val_u is None or val_v is None: # Should not happen if all nodes processed\n             sys.stdout.write(\"NO\\n\")\n             return\n\n        if math.gcd(val_u, val_v) != g or (val_u * val_v) // math.gcd(val_u, val_v) != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # If all checks pass, print YES and the values\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, node_values)) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 3189,
        "thoughts_token_count": 778
    }
}