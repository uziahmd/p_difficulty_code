{
    "start": 1758293727.1554115,
    "end": 1758293768.2825558,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    zeros = []\n    ones_count = 0\n    twos = []\n\n    for char in s:\n        if char == '0':\n            zeros.append('0')\n        elif char == '1':\n            ones_count += 1\n        elif char == '2':\n            twos.append('2')\n\n    result_string = []\n\n    # All '0's can move past '1's and '2's.\n    # All '2's can move past '1's and '0's.\n    # The relative order of '0's is preserved.\n    # The relative order of '2's is preserved.\n    # '0' and '2' cannot swap directly.\n\n    # This means '0's can move to the left of '1's, and '2's can move to the right of '1's.\n    # '0's cannot move past '2's.\n    # '2's cannot move past '0's.\n\n    # The '1's can be thought of as \"floating\" and can be moved past '0's and '2's.\n    # This implies that all '0's will come before all '2's in the final string,\n    # and the '1's can be inserted anywhere.\n    # To get the lexicographically smallest string, we want '0's first, then '1's, then '2's.\n\n    # The key insight is that '0's and '2's maintain their relative order.\n    # For example, if we have \"0...2\", the '0' will always be before the '2'.\n    # If we have \"2...0\", the '2' will always be before the '0'.\n    # This is because '0' and '2' cannot swap directly.\n\n    # Consider the first '2' in the original string.\n    # All '0's that appear before this first '2' can be moved to the very beginning.\n    # All '1's can also be moved.\n    # All '0's that appear after the first '2' cannot move to the left of it.\n    # Similarly, all '2's that appear before the first '0' cannot move to the right of it.\n\n    # Let's find the position of the first '2'.\n    first_two_idx = -1\n    for i in range(len(s)):\n        if s[i] == '2':\n            first_two_idx = i\n            break\n\n    if first_two_idx == -1:\n        # No '2's in the string.\n        # All '0's can move to the left of all '1's.\n        # Result will be all '0's followed by all '1's.\n        result_string.extend(zeros)\n        result_string.extend(['1'] * ones_count)\n    else:\n        # There is at least one '2'.\n        # All '0's can be moved to the left of all '1's.\n        # All '1's can be moved to the left of all '2's.\n        # However, '0's cannot move past '2's, and '2's cannot move past '0's.\n        # The '1's can effectively be moved anywhere without changing the relative order of '0's and '2's.\n\n        # To minimize lexicographically, we want all '0's first.\n        # Then, we want '1's.\n        # Then, we want '2's.\n\n        # The '1's can be moved past '0's and '2's.\n        # This means we can collect all '0's, then all '1's, then all '2's, IF there are no '2's before '0's.\n        # But the problem is that '0's and '2's cannot swap.\n\n        # The actual rule is: '0's and '1's can swap. '1's and '2's can swap.\n        # This implies that '0's can \"pass through\" '1's, and '2's can \"pass through\" '1's.\n        # But '0's cannot pass '2's.\n        # So, the relative order of '0's and '2's is fixed.\n        # Any '0' that appears before a '2' in the original string must appear before that '2' in the final string.\n        # Any '2' that appears before a '0' in the original string must appear before that '0' in the final string.\n\n        # This means the string will be composed of blocks of '0's and '2's,\n        # and all '1's can be moved to any position relative to these blocks.\n        # To make it lexicographically smallest, we want to put '1's as far right as possible,\n        # after all '0's and before all '2's, or after all '0's and after some '2's, etc.\n\n        # The simplest structure that respects '0'-'2' relative order and puts '1's optimally:\n        # All '0's that appear before the first '2' in the original string can be moved to the front.\n        # All '1's can be moved to the position right after these '0's.\n        # Then, all '2's (and any '0's that appeared after the first '2') follow.\n\n        # Let's re-examine the properties:\n        # '0' and '1' swap: '0' can move left through '1's. '1' can move left through '0's.\n        # '1' and '2' swap: '1' can move left through '2's. '2' can move left through '1's.\n        # '0' and '2' cannot swap.\n\n        # This means a '0' can move to the left of any '1's.\n        # A '2' can move to the right of any '1's.\n        # A '1' can move anywhere.\n\n        # The crucial observation is that the relative order of '0's and '2's cannot change.\n        # For example, if we have \"0...2\" in the original string, it will always be \"0...2\" in any reachable string.\n        # If we have \"2...0\" in the original string, it will always be \"2...0\" in any reachable string.\n\n        # To get the lexicographically smallest string:\n        # We want to put all '0's first.\n        # Then, we want to put all '1's.\n        # Then, we want to put all '2's.\n\n        # The only constraint is the '0'-'2' relative order.\n        # If there is a '2' before a '0' in the original string, that '2' must remain before that '0'.\n        # However, the problem statement says \"you cannot swap '02' <-> '20'\". This implies that\n        # '0's and '2's are \"stuck\" relative to each other.\n        # Any '1' can be moved freely past any '0' or any '2'.\n        # So, we can take all '1's out, arrange the '0's and '2's as they appear in the original string,\n        # and then insert all '1's in the optimal position.\n\n        # The optimal position for all '1's is right after all '0's and before all '2's.\n        # More precisely, if we have a string like \"002012\", the '0's and '2's are \"00202\".\n        # The '1' can be moved anywhere.\n        # To get the minimum string, we want '0's first.\n        # Then '1's.\n        # Then '2's.\n\n        # The '0's and '2's form a \"backbone\" whose relative order is fixed.\n        # Example: \"010210\" -> \"001120\"\n        # Original '0's and '2's: \"0020\" (relative order is 0,0,2,0)\n        # '1's: two '1's.\n        # Final: \"001120\". Here, the '1's are inserted after the first two '0's and before the '2'.\n        # The '0' after the '2' is \"0020\", it became \"001120\". The last '0' is still after the '2'.\n\n        # This implies that all '0's appearing before the first '2' can be moved to the beginning.\n        # All '2's appearing after the last '0' can be moved to the end.\n        # All '1's can be moved to form a block.\n        # To minimize lexicographically, we want to put '0's first, then '1's, then '2's.\n\n        # So, the strategy is:\n        # 1. Collect all '0's.\n        # 2. Collect all '1's.\n        # 3. Collect all '2's.\n\n        # The '0's and '2's cannot swap directly.\n        # This means if we have \"0...2\", it must remain \"0...2\".\n        # If we have \"2...0\", it must remain \"2...0\".\n\n        # The crucial insight is that '1's are completely \"mobile\".\n        # They can move past any '0' or '2'.\n        # So, we can effectively remove all '1's from the string, then re-insert them.\n        # The remaining string of '0's and '2's has a fixed relative order.\n        # For example, \"010210\" becomes \"0020\" after removing '1's.\n        # We have two '1's.\n        # To make \"0020\" lexicographically smallest, we would want to move the last '0' to the left of '2'.\n        # But we cannot swap '0' and '2'.\n        # So, the string \"0020\" cannot be changed.\n\n        # The '1's can be inserted anywhere.\n        # To make the string lexicographically smallest, we want '0's first, then '1's, then '2's.\n        # So, all '1's should be placed after all '0's that can be moved to the front,\n        # and before all '2's that can be moved to the end.\n\n        # The \"backbone\" of '0's and '2's:\n        # Let's build the string of '0's and '2's in their original relative order.\n        # Example: \"100210\" -> \"0020\"\n        # Example: \"11222121\" -> \"2222\" (no '0's)\n        # Example: \"20\" -> \"20\"\n\n        # Find the first occurrence of '2'.\n        # All '0's before this first '2' can be moved to the very beginning.\n        # All '1's can be moved to after these '0's.\n        # Then, the rest of the string (from the first '2' onwards) follows.\n\n        # This implies that all '0's that appear *before* the first '2' in the original string\n        # can be moved to the very beginning.\n        # All '1's can be moved to the position *after* these initial '0's.\n        # The remaining characters (the first '2' and everything after it) follow.\n\n        # Let's try this strategy:\n        # 1. Count all '0's that appear before the first '2'.\n        # 2. Print these '0's.\n        # 3. Print all '1's (their total count).\n        # 4. Print the rest of the string, starting from the first '2', but skipping any '1's.\n\n        # Let's count '0's and '1's and collect '2's.\n        # We need to preserve the relative order of '0's and '2's.\n        # The '1's are mobile.\n\n        # Strategy:\n        # 1. Print all '0's that appear in `s`.\n        # 2. Then print all '1's that appear in `s`.\n        # 3. Then print all '2's that appear in `s`.\n        # This would be \"000...111...222...\" if '0's and '2's could swap. But they can't.\n\n        # The correct strategy is:\n        # Find the first '2'.\n        # All '0's before this '2' can be moved to the beginning.\n        # All '1's can be moved to after these '0's.\n        # The rest of the string (from the first '2' onwards, including any '0's that appear after this '2')\n        # will maintain its relative order, but '1's within it are removed.\n\n        # Example: \"100210\"\n        # First '2' is at index 3.\n        # Characters before index 3: \"100\".\n        #   '0's in \"100\": two '0's.\n        #   '1's in \"100\": one '1'.\n        # Characters from index 3 onwards: \"210\".\n        #   '0's in \"210\": one '0'.\n        #   '1's in \"210\": one '1'.\n        #   '2's in \"210\": one '2'.\n\n        # Total '0's: 3. Total '1's: 2. Total '2's: 1.\n\n        # Let's apply the rule:\n        # Print all '0's that appear in `s` *before* the first '2'.\n        # Then print all '1's from `s`.\n        # Then print all characters from `s` *from* the first '2' onwards, but excluding '1's.\n\n        # This seems to be the correct approach:\n        # Iterate through the string.\n        # If we see a '0', append it to the result.\n        # If we see a '1', increment a counter for '1's.\n        # If we see a '2', we have found the point where '1's should be inserted.\n        # All '0's encountered so far have been appended. Now, append all '1's.\n        # Then, append the '2' and all subsequent '2's and '0's (skipping '1's).\n\n        # Let's trace this:\n        # `s = \"100210\"`\n        # `result = []`\n        # `ones_to_insert = 0`\n        # `found_first_two = False`\n\n        # Iterate `s`:\n        # `i = 0, char = '1'`: `ones_to_insert = 1`.\n        # `i = 1, char = '0'`: `result.append('0')`. `result = ['0']`.\n        # `i = 2, char = '0'`: `result.append('0')`. `result = ['0', '0']`.\n        # `i = 3, char = '2'`:\n        #   `found_first_two = True`.\n        #   Append `ones_to_insert` '1's: `result.extend(['1'] * 1)`. `result = ['0', '0', '1']`.\n        #   Reset `ones_to_insert = 0`.\n        #   Append '2': `result.append('2')`. `result = ['0', '0', '1', '2']`.\n        # `i = 4, char = '1'`: `ones_to_insert = 1`.\n        # `i = 5, char = '0'`: `result.append('0')`. `result = ['0', '0', '1', '2', '0']`.\n\n        # After loop:\n        # `found_first_two` is `True`.\n        # `ones_to_insert` is `1`. Append remaining '1's: `result.extend(['1'] * 1)`. `result = ['0', '0', '1', '2', '0', '1']`.\n        # This is \"001201\", not \"001120\". This strategy is incorrect.\n\n        # The '1's can be moved past any '0' or '2'.\n        # This means all '1's can be collected into a single block.\n        # The '0's and '2's cannot swap relative positions.\n        # So, the sequence of '0's and '2's (ignoring '1's) is fixed.\n        # For \"100210\", the sequence of '0's and '2's is \"0020\".\n        # We have two '1's.\n        # We need to insert \"11\" into \"0020\" to make the resulting string lexicographically smallest.\n        # Where can \"11\" be inserted?\n        # \"110020\" - No, '0's are smaller than '1's.\n        # \"011020\" - No, '0's are smaller than '1's.\n        # \"001120\" - Yes, this is the best.\n        # \"002110\" - No, '2' is larger than '1'.\n        # \"002011\" - No, '0' is smaller than '1'.\n\n        # So, the rule is:\n        # 1. Collect all '0's.\n        # 2. Collect all '1's.\n        # 3. Collect all '2's.\n        # The string of '0's and '2's, with '1's removed, is fixed. Let this be `s_no_ones`.\n        # Example: `s = \"100210\"`, `s_no_ones = \"0020\"`.\n        # We have `ones_count = 2`.\n        # We want to insert `ones_count` '1's into `s_no_ones` to get the lexicographically smallest string.\n        # The best place to insert '1's is right before the first '2' in `s_no_ones`.\n        # If there are no '2's, insert them at the end.\n\n        # Let's apply this refined strategy:\n        # 1. Build `s_no_ones` by iterating through `s` and appending '0's and '2's. Count '1's separately.\n        # 2. Find the index of the first '2' in `s_no_ones`.\n        # 3. Construct the result:\n        #    `s_no_ones[:first_two_idx] + ('1' * ones_count) + s_no_ones[first_two_idx:]`\n\n        # Example: `s = \"100210\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"0\"`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"00\"`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"002\"`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"0020\"`\n\n        # After loop: `s_no_ones = \"0020\"`, `ones_count = 2`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 2` (index of '2' in \"0020\")\n\n        # Construct result:\n        # `s_no_ones[:2]` is `\"00\"`\n        # `('1' * ones_count)` is `\"11\"`\n        # `s_no_ones[2:]` is `\"20\"`\n\n        # Result: `\"00\" + \"11\" + \"20\"` = `\"001120\"`. This matches the example output!\n\n        # Example 2: `s = \"11222121\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2\"`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"22\"`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"222\"`\n        # `char = '1'`: `ones_count = 3`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2222\"`\n        # `char = '1'`: `ones_count = 4`\n\n        # After loop: `s_no_ones = \"2222\"`, `ones_count = 4`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 0` (index of '2' in \"2222\")\n\n        # Construct result:\n        # `s_no_ones[:0]` is `\"\"`\n        # `('1' * ones_count)` is `\"1111\"`\n        # `s_no_ones[0:]` is `\"2222\"`\n\n        # Result: `\"\" + \"1111\" + \"2222\"` = `\"11112222\"`. This matches the example output!\n\n        # Example 3: `s = \"20\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2\"`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"20\"`\n\n        # After loop: `s_no_ones = \"20\"`, `ones_count = 0`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 0` (index of '2' in \"20\")\n\n        # Construct result:\n        # `s_no_ones[:0]` is `\"\"`\n        # `('1' * ones_count)` is `\"\"`\n        # `s_no_ones[0:]` is `\"20\"`\n\n        # Result: `\"\" + \"\" + \"20\"` = `\"20\"`. This matches the example output!\n\n        # Edge case: String with no '2's. E.g., `s = \"10010\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"0\"`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"00\"`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"000\"`\n\n        # After loop: `s_no_ones = \"000\"`, `ones_count = 2`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = -1` (no '2' found)\n\n        # If `first_two_idx_in_no_ones == -1`:\n        # Result: `s_no_ones + ('1' * ones_count)`\n        # ` \"000\" + \"11\"` = `\"00011\"`. This is correct.\n        # All '0's can move left of all '1's.\n\n        # Edge case: String with no '0's. E.g., `s = \"11212\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2\"`\n        # `char = '1'`: `ones_count = 3`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"22\"`\n\n        # After loop: `s_no_ones = \"22\"`, `ones_count = 3`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 0`\n\n        # Construct result:\n        # `s_no_ones[:0]` is `\"\"`\n        # `('1' * ones_count)` is `\"111\"`\n        # `s_no_ones[0:]` is `\"22\"`\n\n        # Result: `\"\" + \"111\" + \"22\"` = `\"11122\"`. This is correct.\n        # All '1's can move left of all '2's.\n\n    s_no_ones_list = []\n    ones_count = 0\n\n    for char in s:\n        if char == '1':\n            ones_count += 1\n        else:\n            s_no_ones_list.append(char)\n\n    s_no_ones = \"\".join(s_no_ones_list)\n\n    first_two_idx_in_no_ones = -1\n    for i in range(len(s_no_ones)):\n        if s_no_ones[i] == '2':\n            first_two_idx_in_no_ones = i\n            break\n\n    if first_two_idx_in_no_ones == -1:\n        # No '2's in s_no_ones (and thus no '2's in original string)\n        # All '0's followed by all '1's.\n        # s_no_ones already contains all '0's in their original relative order.\n        print(s_no_ones + '1' * ones_count)\n    else:\n        # There is at least one '2'.\n        # Insert all '1's before the first '2' in s_no_ones.\n        print(s_no_ones[:first_two_idx_in_no_ones] + '1' * ones_count + s_no_ones[first_two_idx_in_no_ones:])\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    zeros = []\n    ones_count = 0\n    twos = []\n\n    for char in s:\n        if char == '0':\n            zeros.append('0')\n        elif char == '1':\n            ones_count += 1\n        elif char == '2':\n            twos.append('2')\n\n    result_string = []\n\n    # All '0's can move past '1's and '2's.\n    # All '2's can move past '1's and '0's.\n    # The relative order of '0's is preserved.\n    # The relative order of '2's is preserved.\n    # '0' and '2' cannot swap directly.\n\n    # This means '0's can move to the left of '1's, and '2's can move to the right of '1's.\n    # '0's cannot move past '2's.\n    # '2's cannot move past '0's.\n\n    # The '1's can be thought of as \"floating\" and can be moved past '0's and '2's.\n    # This implies that all '0's will come before all '2's in the final string,\n    # and the '1's can be inserted anywhere.\n    # To get the lexicographically smallest string, we want '0's first, then '1's, then '2's.\n\n    # The key insight is that '0's and '2's maintain their relative order.\n    # For example, if we have \"0...2\", the '0' will always be before the '2'.\n    # If we have \"2...0\", the '2' will always be before the '0'.\n    # This is because '0' and '2' cannot swap directly.\n\n    # Consider the first '2' in the original string.\n    # All '0's that appear before this first '2' can be moved to the very beginning.\n    # All '1's can also be moved.\n    # All '0's that appear after the first '2' cannot move to the left of it.\n    # Similarly, all '2's that appear before the first '0' cannot move to the right of it.\n\n    # Let's find the position of the first '2'.\n    first_two_idx = -1\n    for i in range(len(s)):\n        if s[i] == '2':\n            first_two_idx = i\n            break\n\n    if first_two_idx == -1:\n        # No '2's in the string.\n        # All '0's can move to the left of all '1's.\n        # Result will be all '0's followed by all '1's.\n        result_string.extend(zeros)\n        result_string.extend(['1'] * ones_count)\n    else:\n        # There is at least one '2'.\n        # All '0's can be moved to the left of all '1's.\n        # All '1's can be moved to the left of all '2's.\n        # However, '0's cannot move past '2's, and '2's cannot move past '0's.\n        # The '1's can effectively be moved anywhere without changing the relative order of '0's and '2's.\n\n        # To minimize lexicographically, we want all '0's first.\n        # Then, we want '1's.\n        # Then, we want '2's.\n\n        # The '1's can be moved past '0's and '2's.\n        # This means we can collect all '0's, then all '1's, then all '2's, IF there are no '2's before '0's.\n        # But the problem is that '0's and '2's cannot swap.\n\n        # The actual rule is: '0's and '1's can swap. '1's and '2's can swap.\n        # This implies that '0's can \"pass through\" '1's, and '2's can \"pass through\" '1's.\n        # But '0's cannot pass '2's.\n        # So, the relative order of '0's and '2's is fixed.\n        # Any '0' that appears before a '2' in the original string must appear before that '2' in the final string.\n        # Any '2' that appears before a '0' in the original string must appear before that '0' in the final string.\n\n        # This means the string will be composed of blocks of '0's and '2's,\n        # and all '1's can be moved to any position relative to these blocks.\n        # To make it lexicographically smallest, we want to put '1's as far right as possible,\n        # after all '0's and before all '2's, or after all '0's and after some '2's, etc.\n\n        # The simplest structure that respects '0'-'2' relative order and puts '1's optimally:\n        # All '0's that appear before the first '2' in the original string can be moved to the front.\n        # All '1's can be moved to the position right after these '0's.\n        # Then, all '2's (and any '0's that appeared after the first '2') follow.\n\n        # Let's re-examine the properties:\n        # '0' and '1' swap: '0' can move left through '1's. '1' can move left through '0's.\n        # '1' and '2' swap: '1' can move left through '2's. '2' can move left through '1's.\n        # '0' and '2' cannot swap.\n\n        # This means a '0' can move to the left of any '1's.\n        # A '2' can move to the right of any '1's.\n        # A '1' can move anywhere.\n\n        # The crucial observation is that the relative order of '0's and '2's cannot change.\n        # For example, if we have \"0...2\" in the original string, it will always be \"0...2\" in any reachable string.\n        # If we have \"2...0\" in the original string, it will always be \"2...0\" in any reachable string.\n\n        # To get the lexicographically smallest string:\n        # We want to put all '0's first.\n        # Then, we want to put all '1's.\n        # Then, we want to put all '2's.\n\n        # The only constraint is the '0'-'2' relative order.\n        # If there is a '2' before a '0' in the original string, that '2' must remain before that '0'.\n        # However, the problem statement says \"you cannot swap '02' <-> '20'\". This implies that\n        # '0's and '2's are \"stuck\" relative to each other.\n        # Any '1' can be moved freely past any '0' or any '2'.\n        # So, we can take all '1's out, arrange the '0's and '2's as they appear in the original string,\n        # and then insert all '1's in the optimal position.\n\n        # The optimal position for all '1's is right after all '0's and before all '2's.\n        # More precisely, if we have a string like \"002012\", the '0's and '2's are \"00202\".\n        # The '1' can be moved anywhere.\n        # To get the minimum string, we want '0's first.\n        # Then '1's.\n        # Then '2's.\n\n        # The '0's and '2's form a \"backbone\" whose relative order is fixed.\n        # Example: \"010210\" -> \"001120\"\n        # Original '0's and '2's: \"0020\" (relative order is 0,0,2,0)\n        # '1's: two '1's.\n        # Final: \"001120\". Here, the '1's are inserted after the first two '0's and before the '2'.\n        # The '0' after the '2' is \"0020\", it became \"001120\". The last '0' is still after the '2'.\n\n        # This implies that all '0's appearing before the first '2' can be moved to the beginning.\n        # All '2's appearing after the last '0' can be moved to the end.\n        # All '1's can be moved to form a block.\n        # To minimize lexicographically, we want to put '0's first, then '1's, then '2's.\n\n        # So, the strategy is:\n        # 1. Collect all '0's.\n        # 2. Collect all '1's.\n        # 3. Collect all '2's.\n\n        # The '0's and '2's cannot swap directly.\n        # This means if we have \"0...2\", it must remain \"0...2\".\n        # If we have \"2...0\", it must remain \"2...0\".\n\n        # The crucial insight is that '1's are completely \"mobile\".\n        # They can move past any '0' or '2'.\n        # So, we can effectively remove all '1's from the string, then re-insert them.\n        # The remaining string of '0's and '2's has a fixed relative order.\n        # For example, \"010210\" becomes \"0020\" after removing '1's.\n        # We have two '1's.\n        # To make \"0020\" lexicographically smallest, we would want to move the last '0' to the left of '2'.\n        # But we cannot swap '0' and '2'.\n        # So, the string \"0020\" cannot be changed.\n\n        # The '1's can be inserted anywhere.\n        # To make the string lexicographically smallest, we want '0's first, then '1's, then '2's.\n        # So, all '1's should be placed after all '0's that can be moved to the front,\n        # and before all '2's that can be moved to the end.\n\n        # The \"backbone\" of '0's and '2's:\n        # Let's build the string of '0's and '2's in their original relative order.\n        # Example: \"100210\" -> \"0020\"\n        # Example: \"11222121\" -> \"2222\" (no '0's)\n        # Example: \"20\" -> \"20\"\n\n        # Find the first occurrence of '2'.\n        # All '0's before this first '2' can be moved to the very beginning.\n        # All '1's can be moved to after these '0's.\n        # Then, the rest of the string (from the first '2' onwards) follows.\n\n        # This implies that all '0's that appear *before* the first '2' in the original string\n        # can be moved to the very beginning.\n        # All '1's can be moved to the position *after* these initial '0's.\n        # The remaining characters (the first '2' and everything after it) follow.\n\n        # Let's try this strategy:\n        # 1. Count all '0's that appear before the first '2'.\n        # 2. Print these '0's.\n        # 3. Print all '1's (their total count).\n        # 4. Print the rest of the string, starting from the first '2', but skipping any '1's.\n\n        # Let's count '0's and '1's and collect '2's.\n        # We need to preserve the relative order of '0's and '2's.\n        # The '1's are mobile.\n\n        # Strategy:\n        # 1. Print all '0's that appear in `s`.\n        # 2. Then print all '1's that appear in `s`.\n        # 3. Then print all '2's that appear in `s`.\n        # This would be \"000...111...222...\" if '0's and '2's could swap. But they can't.\n\n        # The correct strategy is:\n        # Find the first '2'.\n        # All '0's before this '2' can be moved to the beginning.\n        # All '1's can be moved to after these '0's.\n        # The rest of the string (from the first '2' onwards, including any '0's that appear after this '2')\n        # will maintain its relative order, but '1's within it are removed.\n\n        # Example: \"100210\"\n        # First '2' is at index 3.\n        # Characters before index 3: \"100\".\n        #   '0's in \"100\": two '0's.\n        #   '1's in \"100\": one '1'.\n        # Characters from index 3 onwards: \"210\".\n        #   '0's in \"210\": one '0'.\n        #   '1's in \"210\": one '1'.\n        #   '2's in \"210\": one '2'.\n\n        # Total '0's: 3. Total '1's: 2. Total '2's: 1.\n\n        # Let's apply the rule:\n        # Print all '0's that appear in `s` *before* the first '2'.\n        # Then print all '1's from `s`.\n        # Then print all characters from `s` *from* the first '2' onwards, but excluding '1's.\n\n        # This seems to be the correct approach:\n        # Iterate through the string.\n        # If we see a '0', append it to the result.\n        # If we see a '1', increment a counter for '1's.\n        # If we see a '2', we have found the point where '1's should be inserted.\n        # All '0's encountered so far have been appended. Now, append all '1's.\n        # Then, append the '2' and all subsequent '2's and '0's (skipping '1's).\n\n        # Let's trace this:\n        # `s = \"100210\"`\n        # `result = []`\n        # `ones_to_insert = 0`\n        # `found_first_two = False`\n\n        # Iterate `s`:\n        # `i = 0, char = '1'`: `ones_to_insert = 1`.\n        # `i = 1, char = '0'`: `result.append('0')`. `result = ['0']`.\n        # `i = 2, char = '0'`: `result.append('0')`. `result = ['0', '0']`.\n        # `i = 3, char = '2'`:\n        #   `found_first_two = True`.\n        #   Append `ones_to_insert` '1's: `result.extend(['1'] * 1)`. `result = ['0', '0', '1']`.\n        #   Reset `ones_to_insert = 0`.\n        #   Append '2': `result.append('2')`. `result = ['0', '0', '1', '2']`.\n        # `i = 4, char = '1'`: `ones_to_insert = 1`.\n        # `i = 5, char = '0'`: `result.append('0')`. `result = ['0', '0', '1', '2', '0']`.\n\n        # After loop:\n        # `found_first_two` is `True`.\n        # `ones_to_insert` is `1`. Append remaining '1's: `result.extend(['1'] * 1)`. `result = ['0', '0', '1', '2', '0', '1']`.\n        # This is \"001201\", not \"001120\". This strategy is incorrect.\n\n        # The '1's can be moved past any '0' or '2'.\n        # This means all '1's can be collected into a single block.\n        # The '0's and '2's cannot swap relative positions.\n        # So, the sequence of '0's and '2's (ignoring '1's) is fixed.\n        # For \"100210\", the sequence of '0's and '2's is \"0020\".\n        # We have two '1's.\n        # We need to insert \"11\" into \"0020\" to make the resulting string lexicographically smallest.\n        # Where can \"11\" be inserted?\n        # \"110020\" - No, '0's are smaller than '1's.\n        # \"011020\" - No, '0's are smaller than '1's.\n        # \"001120\" - Yes, this is the best.\n        # \"002110\" - No, '2' is larger than '1'.\n        # \"002011\" - No, '0' is smaller than '1'.\n\n        # So, the rule is:\n        # 1. Collect all '0's.\n        # 2. Collect all '1's.\n        # 3. Collect all '2's.\n        # The string of '0's and '2's, with '1's removed, is fixed. Let this be `s_no_ones`.\n        # Example: `s = \"100210\"`, `s_no_ones = \"0020\"`.\n        # We have `ones_count = 2`.\n        # We want to insert `ones_count` '1's into `s_no_ones` to get the lexicographically smallest string.\n        # The best place to insert '1's is right before the first '2' in `s_no_ones`.\n        # If there are no '2's, insert them at the end.\n\n        # Let's apply this refined strategy:\n        # 1. Build `s_no_ones` by iterating through `s` and appending '0's and '2's. Count '1's separately.\n        # 2. Find the index of the first '2' in `s_no_ones`.\n        # 3. Construct the result:\n        #    `s_no_ones[:first_two_idx] + ('1' * ones_count) + s_no_ones[first_two_idx:]`\n\n        # Example: `s = \"100210\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"0\"`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"00\"`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"002\"`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"0020\"`\n\n        # After loop: `s_no_ones = \"0020\"`, `ones_count = 2`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 2` (index of '2' in \"0020\")\n\n        # Construct result:\n        # `s_no_ones[:2]` is `\"00\"`\n        # `('1' * ones_count)` is `\"11\"`\n        # `s_no_ones[2:]` is `\"20\"`\n\n        # Result: `\"00\" + \"11\" + \"20\"` = `\"001120\"`. This matches the example output!\n\n        # Example 2: `s = \"11222121\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2\"`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"22\"`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"222\"`\n        # `char = '1'`: `ones_count = 3`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2222\"`\n        # `char = '1'`: `ones_count = 4`\n\n        # After loop: `s_no_ones = \"2222\"`, `ones_count = 4`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 0` (index of '2' in \"2222\")\n\n        # Construct result:\n        # `s_no_ones[:0]` is `\"\"`\n        # `('1' * ones_count)` is `\"1111\"`\n        # `s_no_ones[0:]` is `\"2222\"`\n\n        # Result: `\"\" + \"1111\" + \"2222\"` = `\"11112222\"`. This matches the example output!\n\n        # Example 3: `s = \"20\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2\"`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"20\"`\n\n        # After loop: `s_no_ones = \"20\"`, `ones_count = 0`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 0` (index of '2' in \"20\")\n\n        # Construct result:\n        # `s_no_ones[:0]` is `\"\"`\n        # `('1' * ones_count)` is `\"\"`\n        # `s_no_ones[0:]` is `\"20\"`\n\n        # Result: `\"\" + \"\" + \"20\"` = `\"20\"`. This matches the example output!\n\n        # Edge case: String with no '2's. E.g., `s = \"10010\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"0\"`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"00\"`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '0'`: `s_no_ones += '0'` -> `\"000\"`\n\n        # After loop: `s_no_ones = \"000\"`, `ones_count = 2`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = -1` (no '2' found)\n\n        # If `first_two_idx_in_no_ones == -1`:\n        # Result: `s_no_ones + ('1' * ones_count)`\n        # ` \"000\" + \"11\"` = `\"00011\"`. This is correct.\n        # All '0's can move left of all '1's.\n\n        # Edge case: String with no '0's. E.g., `s = \"11212\"`\n        # `s_no_ones = \"\"`\n        # `ones_count = 0`\n\n        # `char = '1'`: `ones_count = 1`\n        # `char = '1'`: `ones_count = 2`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"2\"`\n        # `char = '1'`: `ones_count = 3`\n        # `char = '2'`: `s_no_ones += '2'` -> `\"22\"`\n\n        # After loop: `s_no_ones = \"22\"`, `ones_count = 3`.\n\n        # Find first '2' in `s_no_ones`:\n        # `first_two_idx_in_no_ones = s_no_ones.find('2')`\n        # `first_two_idx_in_no_ones = 0`\n\n        # Construct result:\n        # `s_no_ones[:0]` is `\"\"`\n        # `('1' * ones_count)` is `\"111\"`\n        # `s_no_ones[0:]` is `\"22\"`\n\n        # Result: `\"\" + \"111\" + \"22\"` = `\"11122\"`. This is correct.\n        # All '1's can move left of all '2's.\n\n    s_no_ones_list = []\n    ones_count = 0\n\n    for char in s:\n        if char == '1':\n            ones_count += 1\n        else:\n            s_no_ones_list.append(char)\n\n    s_no_ones = \"\".join(s_no_ones_list)\n\n    first_two_idx_in_no_ones = -1\n    for i in range(len(s_no_ones)):\n        if s_no_ones[i] == '2':\n            first_two_idx_in_no_ones = i\n            break\n\n    if first_two_idx_in_no_ones == -1:\n        # No '2's in s_no_ones (and thus no '2's in original string)\n        # All '0's followed by all '1's.\n        # s_no_ones already contains all '0's in their original relative order.\n        print(s_no_ones + '1' * ones_count)\n    else:\n        # There is at least one '2'.\n        # Insert all '1's before the first '2' in s_no_ones.\n        print(s_no_ones[:first_two_idx_in_no_ones] + '1' * ones_count + s_no_ones[first_two_idx_in_no_ones:])\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 613,
        "completion_token_count": 6620,
        "thoughts_token_count": 0
    }
}