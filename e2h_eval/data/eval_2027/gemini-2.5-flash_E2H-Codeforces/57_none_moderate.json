{
    "start": 1758293707.9683886,
    "end": 1758293742.7349124,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    # Sort arrays for efficient matching\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # To maximize Vasya's score, he takes the highest possible 'a' and 'b' such that a_i + b_j >= x.\n    # To minimize other people's scores, we want to pair the remaining highest 'a' with lowest 'b'.\n    # This is a bit complex. A simpler approach for best rank:\n    # Vasya can achieve the highest possible score by taking the maximum a_i and maximum b_j.\n    # The best rank means Vasya gets the highest possible score, and others get the lowest possible scores.\n    # Vasya's best score is max(a) + max(b).\n    # But this is not necessarily true. Vasya just needs to achieve *a* score that is higher than as many people as possible.\n    # The best rank is 1 if Vasya can achieve a score that is strictly greater than all other (n-1) participants.\n    # Or, if Vasya achieves the highest possible score among all participants, and the jury assigns him 1st place.\n    # The guarantee `ai + bj >= x` means Vasya *can* achieve at least x.\n    # For best rank, Vasya wants to maximize his score. He takes the largest `a_i` and `b_j` available.\n    # Let Vasya's score be `S_V`.\n    # To get the best rank, Vasya tries to get the highest possible sum, and we assume the jury gives him 1st place\n    # if he ties for the highest sum.\n    # What's the highest sum Vasya can get? max(a) + max(b).\n    # What's the highest sum anyone else can get?\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S_V.\n    # If Vasya gets the highest possible score, he can get 1st place.\n    # This happens if there exists a pair (a_i, b_j) for Vasya such that a_i + b_j is maximum.\n    # The maximum possible sum is a[n-1] + b[n-1].\n    # If Vasya can achieve this sum (which he can, by taking a[n-1] and b[n-1]), and this sum is >= x,\n    # then he can be 1st.\n    # So the best rank is always 1. The problem statement implies this: \"the first place has the participant who has got the most points\".\n    # And \"If two or more participants have got the same number of points, it's up to the jury to assign places to them\".\n    # So if Vasya can achieve the maximum possible sum, he can get 1st place.\n    # The maximum possible sum is max(a) + max(b). Vasya can take max(a) and max(b).\n    # So best rank is 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # To maximize Vasya's rank (i.e., get the largest number), we want to:\n    # 1. Minimize Vasya's score, but still satisfying a_i + b_j >= x.\n    # 2. Maximize other people's scores.\n    # 3. If Vasya ties with others, the jury assigns him the worst possible place.\n\n    # This is a matching problem. We want to find a matching of 'a' and 'b' such that:\n    # 1. Each a_i is used exactly once, each b_j is used exactly once.\n    # 2. For one pair (a_vasya, b_vasya), a_vasya + b_vasya >= x.\n    # 3. We want to maximize the number of pairs (a_k, b_l) such that a_k + b_l > a_vasya + b_vasya.\n    # 4. We want to maximize the number of pairs (a_k, b_l) such that a_k + b_l == a_vasya + b_vasya.\n\n    # This is a classic two-pointer approach or greedy matching.\n    # To maximize Vasya's rank, we want to maximize the number of people who score *more* than Vasya,\n    # and then maximize the number of people who score *equal* to Vasya.\n\n    # Let's fix Vasya's score to be S_V.\n    # We need to find the number of people who can score >= S_V.\n    # The smallest possible score Vasya can get is x. But this is not guaranteed.\n    # Vasya's score is a_i + b_j.\n    # The worst rank occurs when Vasya takes a pair (a_i, b_j) such that a_i + b_j >= x,\n    # and this sum is as small as possible, AND the remaining participants are paired up\n    # to maximize their scores relative to Vasya's score.\n\n    # Consider all possible sums S_k = a_i + b_j.\n    # For a fixed Vasya score S_V, we need to count how many other participants can score >= S_V.\n    # The problem is, we don't know which a_i and b_j Vasya takes.\n    # There are N! ways to pair. This is too much.\n\n    # Let's rephrase: we need to find a pairing of (a, b) such that Vasya is one of the pairs,\n    # Vasya's score is >= x, and his rank is maximized.\n    # This means we want to maximize the number of participants whose scores are strictly greater than Vasya's,\n    # and among those with scores equal to Vasya's, we want to assume they are ranked better.\n\n    # Consider the scores a_i + b_j.\n    # We want to find a permutation of 'b' such that when paired with 'a',\n    # the number of participants with score >= some S_V (where S_V >= x) is maximized.\n    # And Vasya is one of those participants.\n\n    # Let's try to count how many participants can score *at least* a certain value K.\n    # This is a standard greedy matching problem.\n    # Sort 'a' in ascending order, 'b' in descending order.\n    # Iterate through 'a'. For each a_i, find the largest b_j such that a_i + b_j >= K.\n    # Or, more efficiently:\n    # Sort 'a' ascending. Sort 'b' ascending.\n    # Use two pointers. `left_a` for 'a', `left_b` for 'b'.\n    # `count_ge_K(K)`:\n    # Initialize `count = 0`. `j = n - 1` (pointer for `b`).\n    # For `i` from `0` to `n - 1` (pointer for `a`):\n    #   While `j >= 0` and `a[i] + b[j] >= K`:\n    #     `j -= 1`\n    #   If `j < n - 1 - i`: (meaning we found a match for a[i] from b[j+1]...b[n-1] that hasn't been used)\n    #     `count += 1`\n    # This is not quite right. This is for finding maximum number of pairs.\n\n    # A better approach for `count_ge_K(K)`:\n    # Sort `a` and `b` in ascending order.\n    # Use two pointers: `ptr_a` for `a` and `ptr_b` for `b`.\n    # `count = 0`\n    # `ptr_b = n - 1` (start `b` from largest)\n    # For `ptr_a` from `0` to `n-1`:\n    #   While `ptr_b >= 0` and `a[ptr_a] + b[ptr_b] >= K`:\n    #     `ptr_b -= 1`\n    #   If `ptr_b < n - 1 - ptr_a`: (This condition means we found a `b` that can be paired with `a[ptr_a]`)\n    #     `count += 1`\n    #     The `b` we used is `b[ptr_b + 1]`.\n    # This is also tricky. This is for finding the max number of pairs.\n\n    # Let's use a simpler greedy approach for `count_ge_K(K)`:\n    # Sort `a` and `b` in ascending order.\n    # `count = 0`\n    # `j = 0` (pointer for `b`)\n    # For `i` from `0` to `n-1` (pointer for `a`):\n    #   While `j < n` and `a[i] + b[j] < K`:\n    #     `j += 1`\n    #   If `j < n`: # Found a `b[j]` such that `a[i] + b[j] >= K`\n    #     `count += 1`\n    #     `j += 1` # Use this `b[j]` and move to the next one\n    # This counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= K.\n    # This is the \"max number of people who can score at least K\".\n\n    # Now, for the worst rank:\n    # Vasya's score must be `S_V >= x`.\n    # We want to find a score `S_V` for Vasya, and a corresponding pairing for everyone else,\n    # such that the number of people scoring `> S_V` is maximized,\n    # and the number of people scoring `== S_V` is maximized (and jury ranks them better).\n\n    # The maximum number of participants who can score at least `K` can be found using the `count_ge_K` function.\n    # Let `scores = []`\n    # For `i` from `0` to `n-1`:\n    #   For `j` from `0` to `n-1`:\n    #     `scores.append(a[i] + b[j])`\n    # This is N^2 possible scores.\n    # The possible scores range from 0 to 2*10^5.\n    # We can iterate through all possible scores `S` from `x` to `2 * 10^5`.\n    # For each `S`, calculate `count_ge_S(S)`. This is the number of participants who can score at least `S`.\n    # This `count_ge_S(S)` will be Vasya's potential rank if he scores `S` and everyone else scores as high as possible.\n\n    # `count_ge_K(K)` function:\n    # `a` and `b` are already sorted.\n    # `count = 0`\n    # `ptr_b = n - 1` # Pointer for `b`, starting from largest\n    # For `ptr_a` from `0` to `n - 1`: # Iterate through `a` from smallest\n    #   While `ptr_b >= 0` and `a[ptr_a] + b[ptr_b] >= K`:\n    #     `ptr_b -= 1`\n    #   # At this point, `b[ptr_b+1]` (if it exists) is the smallest `b` that can make `a[ptr_a] + b >= K`.\n    #   # But we need to make sure `b` is available.\n    #   # This greedy approach is for finding the maximum number of pairs (a_i, b_j)\n    #   # such that a_i + b_j >= K.\n    #   # We use `a` in increasing order and try to match it with the smallest `b` that satisfies the condition.\n    #   # Or, use `a` in increasing order and try to match it with largest `b` that satisfies the condition.\n    #   # This is a standard matching problem.\n    #   # Sort `a` ascending. Sort `b` ascending.\n    #   # `count = 0`\n    #   # `j = 0` (pointer for `b`)\n    #   # For `i` from `0` to `n-1` (pointer for `a`):\n    #   #   While `j < n` and `a[i] + b[j] < K`:\n    #   #     `j += 1`\n    #   #   If `j < n`: # Found a `b[j]` such that `a[i] + b[j] >= K`\n    #   #     `count += 1`\n    #   #     `j += 1` # Use this `b[j]` and move to the next one\n    #   # This correctly counts the maximum number of pairs that sum to at least K.\n\n    def count_ge_K(K_val):\n        count = 0\n        j = 0 # Pointer for b\n        for i in range(n): # Pointer for a\n            # Find the smallest b[j] such that a[i] + b[j] >= K_val\n            while j < n and a[i] + b[j] < K_val:\n                j += 1\n            if j < n: # Found a valid b[j]\n                count += 1\n                j += 1 # This b[j] is now \"used\", move to the next b\n        return count\n\n    # Worst rank:\n    # Vasya wants to minimize his score (but >= x) and maximize others' scores.\n    # The worst rank for Vasya is when he gets the smallest possible score S_V (>= x)\n    # and the maximum number of other people score >= S_V.\n    # So we iterate through all possible scores S_V that Vasya *could* get.\n    # The possible scores for Vasya are any a_i + b_j that is >= x.\n    # But we don't know which a_i and b_j Vasya actually gets.\n    # The problem asks for the worst rank Vasya *could* have won.\n    # This implies we can choose a specific a_i and b_j for Vasya, as long as a_i + b_j >= x.\n    # And then we pair up the remaining n-1 participants to maximize their scores.\n\n    # The maximum possible rank Vasya can get is `n`.\n    # We want to find the largest `k` such that there exists a pairing where Vasya is ranked `k`.\n    # This means there are `k-1` people who score strictly more than Vasya,\n    # or `k-1` people who score at least Vasya's score and are ranked better.\n\n    # Let's consider a specific score `S` that Vasya could achieve (i.e., `S = a[i] + b[j]` for some `i, j`, and `S >= x`).\n    # If Vasya gets score `S`, what is his rank?\n    # His rank is `1 + (number of people with score > S) + (number of people with score == S, who are ranked better)`.\n    # To maximize his rank, we assume all people with score > S are ranked better, and all people with score == S are ranked better.\n    # So his rank is `count_ge_K(S)`.\n\n    # We need to find the maximum `count_ge_K(S)` for all `S` such that Vasya can achieve `S` and `S >= x`.\n    # The possible values of `S` can be `a[i] + b[j]`.\n    # The range of `a[i] + b[j]` is from `0` to `2 * 10^5`.\n    # Let's iterate `S` from `x` up to `2 * 10^5`.\n    # For each `S`, we calculate `count_ge_K(S)`.\n    # This `count_ge_K(S)` is the number of participants who *can* achieve a score of at least `S`.\n    # If Vasya achieves score `S`, then his rank is at least `count_ge_K(S)`.\n    # We need to find the maximum `count_ge_K(S)` over all `S >= x`.\n\n    # Why maximum `count_ge_K(S)` over all `S >= x`?\n    # Because Vasya *could* have scored `S`. If he scores `S`, and `S >= x`,\n    # then his rank is at least `count_ge_K(S)`.\n    # We want the *worst* possible rank. So we want to maximize this `count_ge_K(S)`.\n    # The `count_ge_K(S)` function is monotonically non-increasing as `S` increases.\n    # So we want to pick the smallest `S` that Vasya can achieve, which is `x`.\n    # If Vasya scores `x`, then `count_ge_K(x)` is the number of people who can score at least `x`.\n    # This is the largest possible value of `count_ge_K(S)` for `S >= x`.\n    # So the worst rank is `count_ge_K(x)`.\n\n    worst_rank = count_ge_K(x)\n\n    print(best_rank, worst_rank)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    # Sort arrays for efficient matching\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # To maximize Vasya's score, he takes the highest possible 'a' and 'b' such that a_i + b_j >= x.\n    # To minimize other people's scores, we want to pair the remaining highest 'a' with lowest 'b'.\n    # This is a bit complex. A simpler approach for best rank:\n    # Vasya can achieve the highest possible score by taking the maximum a_i and maximum b_j.\n    # The best rank means Vasya gets the highest possible score, and others get the lowest possible scores.\n    # Vasya's best score is max(a) + max(b).\n    # But this is not necessarily true. Vasya just needs to achieve *a* score that is higher than as many people as possible.\n    # The best rank is 1 if Vasya can achieve a score that is strictly greater than all other (n-1) participants.\n    # Or, if Vasya achieves the highest possible score among all participants, and the jury assigns him 1st place.\n    # The guarantee `ai + bj >= x` means Vasya *can* achieve at least x.\n    # For best rank, Vasya wants to maximize his score. He takes the largest `a_i` and `b_j` available.\n    # Let Vasya's score be `S_V`.\n    # To get the best rank, Vasya tries to get the highest possible sum, and we assume the jury gives him 1st place\n    # if he ties for the highest sum.\n    # What's the highest sum Vasya can get? max(a) + max(b).\n    # What's the highest sum anyone else can get?\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S_V.\n    # If Vasya gets the highest possible score, he can get 1st place.\n    # This happens if there exists a pair (a_i, b_j) for Vasya such that a_i + b_j is maximum.\n    # The maximum possible sum is a[n-1] + b[n-1].\n    # If Vasya can achieve this sum (which he can, by taking a[n-1] and b[n-1]), and this sum is >= x,\n    # then he can be 1st.\n    # So the best rank is always 1. The problem statement implies this: \"the first place has the participant who has got the most points\".\n    # And \"If two or more participants have got the same number of points, it's up to the jury to assign places to them\".\n    # So if Vasya can achieve the maximum possible sum, he can get 1st place.\n    # The maximum possible sum is max(a) + max(b). Vasya can take max(a) and max(b).\n    # So best rank is 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # To maximize Vasya's rank (i.e., get the largest number), we want to:\n    # 1. Minimize Vasya's score, but still satisfying a_i + b_j >= x.\n    # 2. Maximize other people's scores.\n    # 3. If Vasya ties with others, the jury assigns him the worst possible place.\n\n    # This is a matching problem. We want to find a matching of 'a' and 'b' such that:\n    # 1. Each a_i is used exactly once, each b_j is used exactly once.\n    # 2. For one pair (a_vasya, b_vasya), a_vasya + b_vasya >= x.\n    # 3. We want to maximize the number of pairs (a_k, b_l) such that a_k + b_l > a_vasya + b_vasya.\n    # 4. We want to maximize the number of pairs (a_k, b_l) such that a_k + b_l == a_vasya + b_vasya.\n\n    # This is a classic two-pointer approach or greedy matching.\n    # To maximize Vasya's rank, we want to maximize the number of people who score *more* than Vasya,\n    # and then maximize the number of people who score *equal* to Vasya.\n\n    # Let's fix Vasya's score to be S_V.\n    # We need to find the number of people who can score >= S_V.\n    # The smallest possible score Vasya can get is x. But this is not guaranteed.\n    # Vasya's score is a_i + b_j.\n    # The worst rank occurs when Vasya takes a pair (a_i, b_j) such that a_i + b_j >= x,\n    # and this sum is as small as possible, AND the remaining participants are paired up\n    # to maximize their scores relative to Vasya's score.\n\n    # Consider all possible sums S_k = a_i + b_j.\n    # For a fixed Vasya score S_V, we need to count how many other participants can score >= S_V.\n    # The problem is, we don't know which a_i and b_j Vasya takes.\n    # There are N! ways to pair. This is too much.\n\n    # Let's rephrase: we need to find a pairing of (a, b) such that Vasya is one of the pairs,\n    # Vasya's score is >= x, and his rank is maximized.\n    # This means we want to maximize the number of participants whose scores are strictly greater than Vasya's,\n    # and among those with scores equal to Vasya's, we want to assume they are ranked better.\n\n    # Consider the scores a_i + b_j.\n    # We want to find a permutation of 'b' such that when paired with 'a',\n    # the number of participants with score >= some S_V (where S_V >= x) is maximized.\n    # And Vasya is one of those participants.\n\n    # Let's try to count how many participants can score *at least* a certain value K.\n    # This is a standard greedy matching problem.\n    # Sort 'a' in ascending order, 'b' in descending order.\n    # Iterate through 'a'. For each a_i, find the largest b_j such that a_i + b_j >= K.\n    # Or, more efficiently:\n    # Sort 'a' ascending. Sort 'b' ascending.\n    # Use two pointers. `left_a` for 'a', `left_b` for 'b'.\n    # `count_ge_K(K)`:\n    # Initialize `count = 0`. `j = n - 1` (pointer for `b`).\n    # For `i` from `0` to `n - 1` (pointer for `a`):\n    #   While `j >= 0` and `a[i] + b[j] >= K`:\n    #     `j -= 1`\n    #   If `j < n - 1 - i`: (meaning we found a match for a[i] from b[j+1]...b[n-1] that hasn't been used)\n    #     `count += 1`\n    # This is not quite right. This is for finding maximum number of pairs.\n\n    # A better approach for `count_ge_K(K)`:\n    # Sort `a` and `b` in ascending order.\n    # Use two pointers: `ptr_a` for `a` and `ptr_b` for `b`.\n    # `count = 0`\n    # `ptr_b = n - 1` (start `b` from largest)\n    # For `ptr_a` from `0` to `n-1`:\n    #   While `ptr_b >= 0` and `a[ptr_a] + b[ptr_b] >= K`:\n    #     `ptr_b -= 1`\n    #   If `ptr_b < n - 1 - ptr_a`: (This condition means we found a `b` that can be paired with `a[ptr_a]`)\n    #     `count += 1`\n    #     The `b` we used is `b[ptr_b + 1]`.\n    # This is also tricky. This is for finding the max number of pairs.\n\n    # Let's use a simpler greedy approach for `count_ge_K(K)`:\n    # Sort `a` and `b` in ascending order.\n    # `count = 0`\n    # `j = 0` (pointer for `b`)\n    # For `i` from `0` to `n-1` (pointer for `a`):\n    #   While `j < n` and `a[i] + b[j] < K`:\n    #     `j += 1`\n    #   If `j < n`: # Found a `b[j]` such that `a[i] + b[j] >= K`\n    #     `count += 1`\n    #     `j += 1` # Use this `b[j]` and move to the next one\n    # This counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= K.\n    # This is the \"max number of people who can score at least K\".\n\n    # Now, for the worst rank:\n    # Vasya's score must be `S_V >= x`.\n    # We want to find a score `S_V` for Vasya, and a corresponding pairing for everyone else,\n    # such that the number of people scoring `> S_V` is maximized,\n    # and the number of people scoring `== S_V` is maximized (and jury ranks them better).\n\n    # The maximum number of participants who can score at least `K` can be found using the `count_ge_K` function.\n    # Let `scores = []`\n    # For `i` from `0` to `n-1`:\n    #   For `j` from `0` to `n-1`:\n    #     `scores.append(a[i] + b[j])`\n    # This is N^2 possible scores.\n    # The possible scores range from 0 to 2*10^5.\n    # We can iterate through all possible scores `S` from `x` to `2 * 10^5`.\n    # For each `S`, calculate `count_ge_S(S)`. This is the number of participants who can score at least `S`.\n    # This `count_ge_S(S)` will be Vasya's potential rank if he scores `S` and everyone else scores as high as possible.\n\n    # `count_ge_K(K)` function:\n    # `a` and `b` are already sorted.\n    # `count = 0`\n    # `ptr_b = n - 1` # Pointer for `b`, starting from largest\n    # For `ptr_a` from `0` to `n - 1`: # Iterate through `a` from smallest\n    #   While `ptr_b >= 0` and `a[ptr_a] + b[ptr_b] >= K`:\n    #     `ptr_b -= 1`\n    #   # At this point, `b[ptr_b+1]` (if it exists) is the smallest `b` that can make `a[ptr_a] + b >= K`.\n    #   # But we need to make sure `b` is available.\n    #   # This greedy approach is for finding the maximum number of pairs (a_i, b_j)\n    #   # such that a_i + b_j >= K.\n    #   # We use `a` in increasing order and try to match it with the smallest `b` that satisfies the condition.\n    #   # Or, use `a` in increasing order and try to match it with largest `b` that satisfies the condition.\n    #   # This is a standard matching problem.\n    #   # Sort `a` ascending. Sort `b` ascending.\n    #   # `count = 0`\n    #   # `j = 0` (pointer for `b`)\n    #   # For `i` from `0` to `n-1` (pointer for `a`):\n    #   #   While `j < n` and `a[i] + b[j] < K`:\n    #   #     `j += 1`\n    #   #   If `j < n`: # Found a `b[j]` such that `a[i] + b[j] >= K`\n    #   #     `count += 1`\n    #   #     `j += 1` # Use this `b[j]` and move to the next one\n    #   # This correctly counts the maximum number of pairs that sum to at least K.\n\n    def count_ge_K(K_val):\n        count = 0\n        j = 0 # Pointer for b\n        for i in range(n): # Pointer for a\n            # Find the smallest b[j] such that a[i] + b[j] >= K_val\n            while j < n and a[i] + b[j] < K_val:\n                j += 1\n            if j < n: # Found a valid b[j]\n                count += 1\n                j += 1 # This b[j] is now \"used\", move to the next b\n        return count\n\n    # Worst rank:\n    # Vasya wants to minimize his score (but >= x) and maximize others' scores.\n    # The worst rank for Vasya is when he gets the smallest possible score S_V (>= x)\n    # and the maximum number of other people score >= S_V.\n    # So we iterate through all possible scores S_V that Vasya *could* get.\n    # The possible scores for Vasya are any a_i + b_j that is >= x.\n    # But we don't know which a_i and b_j Vasya actually gets.\n    # The problem asks for the worst rank Vasya *could* have won.\n    # This implies we can choose a specific a_i and b_j for Vasya, as long as a_i + b_j >= x.\n    # And then we pair up the remaining n-1 participants to maximize their scores.\n\n    # The maximum possible rank Vasya can get is `n`.\n    # We want to find the largest `k` such that there exists a pairing where Vasya is ranked `k`.\n    # This means there are `k-1` people who score strictly more than Vasya,\n    # or `k-1` people who score at least Vasya's score and are ranked better.\n\n    # Let's consider a specific score `S` that Vasya could achieve (i.e., `S = a[i] + b[j]` for some `i, j`, and `S >= x`).\n    # If Vasya gets score `S`, what is his rank?\n    # His rank is `1 + (number of people with score > S) + (number of people with score == S, who are ranked better)`.\n    # To maximize his rank, we assume all people with score > S are ranked better, and all people with score == S are ranked better.\n    # So his rank is `count_ge_K(S)`.\n\n    # We need to find the maximum `count_ge_K(S)` for all `S` such that Vasya can achieve `S` and `S >= x`.\n    # The possible values of `S` can be `a[i] + b[j]`.\n    # The range of `a[i] + b[j]` is from `0` to `2 * 10^5`.\n    # Let's iterate `S` from `x` up to `2 * 10^5`.\n    # For each `S`, we calculate `count_ge_K(S)`.\n    # This `count_ge_K(S)` is the number of participants who *can* achieve a score of at least `S`.\n    # If Vasya achieves score `S`, then his rank is at least `count_ge_K(S)`.\n    # We need to find the maximum `count_ge_K(S)` over all `S >= x`.\n\n    # Why maximum `count_ge_K(S)` over all `S >= x`?\n    # Because Vasya *could* have scored `S`. If he scores `S`, and `S >= x`,\n    # then his rank is at least `count_ge_K(S)`.\n    # We want the *worst* possible rank. So we want to maximize this `count_ge_K(S)`.\n    # The `count_ge_K(S)` function is monotonically non-increasing as `S` increases.\n    # So we want to pick the smallest `S` that Vasya can achieve, which is `x`.\n    # If Vasya scores `x`, then `count_ge_K(x)` is the number of people who can score at least `x`.\n    # This is the largest possible value of `count_ge_K(S)` for `S >= x`.\n    # So the worst rank is `count_ge_K(x)`.\n\n    worst_rank = count_ge_K(x)\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 4115,
        "thoughts_token_count": 0
    }
}