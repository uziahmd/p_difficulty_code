{
    "start": 1758011918.179796,
    "end": 1758012017.806122,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Initial Thoughts and Problem Decomposition**\n\nAlright, let's dive into this \"Flawed Flow\" problem. It's essentially about directing flow in an undirected graph while adhering to some flow conservation and acyclicity rules.  The goal is to provide directions for the given flow values `ci` of each edge `(ai, bi)` in the input.\n\n**Key Requirements and Strategy**\n\nWe're dealing with a graph where we need to figure out which direction each edge should point.  The tricky part is satisfying flow conservation at intermediate vertices and ensuring the final directed graph is acyclic.  Since the graph is undirected, we're basically choosing between `ai -> bi` or `bi -> ai` for each edge.\n\n**Analyzing Flow Conservation and Topological Ordering**\n\nFlow conservation states that for every intermediate vertex (not the source or sink), the sum of incoming flow must equal the sum of outgoing flow.  The acyclicity constraint strongly suggests a topological sort will be involved.  In a directed acyclic graph (DAG), flow typically moves from source to sink in a way that aligns with the topological order of vertices.\n\n**Balancing the Flow**\n\nI'm thinking about \"balance\" for each vertex. If we arbitrarily direct all edges, we'll see a net \"inflow\" or \"outflow\" at each vertex.  My initial thought is to try to adjust the directions of edges to get this balance to zero (for intermediate vertices), positive (for the source), and negative (for the sink).  This should also help with the acyclicity constraint.\n\n**Handling Source and Sink**\n\nThe problem explicitly states that vertex 1 has no incoming edges. This simplifies things! All edges connected to vertex 1 *must* go outward.  Similarly, we can expect that flow will only come into vertex 'n'.\n\n**Iterative Approach and Potential-Based Method**\n\nI'm considering an iterative approach where we start with an arbitrary direction and then flip edges as needed to satisfy the conservation and acyclicity conditions.  Another thought is to calculate a desired \"potential\" or \"balance\" for each vertex.\n\n**Developing the Algorithm**\n\nThe core is ensuring that each intermediate vertex has equal incoming and outgoing flow (or net flow equals zero).  For the source vertex, the net outgoing flow must equal the total flow from source, and the sink vertex must be the destination of the total flow.\n\n**Let's try: 'Balance' and an 'edge direction' array**\n\n-   For vertex v, calculate the sum of flows on all adjacent edges (degree\\_sum\\[v\\]).\n-   If `1 < v < n`, then half of `degree_sum[v]` must be incoming and outgoing.\n-   Vertex 1 has all edges going out (it must produce a 'deficit' of total flow).\n-   Vertex n has all edges going in (it has to absorb a surplus or 'deficit').\n\nNow, the plan is to maintain an array of current balance and edge directions. A queue to process and balance.\n",
    "response": "The problem asks us to direct the flow for each edge in a given undirected graph such that several conditions are met:\n1.  For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph is acyclic.\n4.  The resulting flow is a correct maximum flow (this implies vertex `n` is the sink and has no outgoing edges).\n\nWe are given the flow volume `c_i` for each edge. A solution is guaranteed to exist.\n\nLet's analyze the conditions:\n\n*   **Condition 2 (Source):** Vertex 1 has no incoming edges. This means all edges incident to vertex 1 must be directed *out* of vertex 1.\n*   **Condition 4 (Sink):** Although not explicitly stated, the context of max-flow implies vertex `n` is the sink. A sink usually has no outgoing edges. So, all edges incident to vertex `n` must be directed *into* vertex `n`.\n*   **Condition 1 (Intermediate Vertices):** For `1 < v < n`, the net flow at `v` must be zero (incoming flow = outgoing flow).\n\nCombining these, we can define a \"target net flow\" for each vertex:\nLet `total_incident_flow[v]` be the sum of flow volumes `c_i` for all edges incident to `v`.\n*   For `v = 1`: The target net outgoing flow is `total_incident_flow[1]`. (All flow must go out).\n*   For `v = n`: The target net outgoing flow is `-total_incident_flow[n]`. (All flow must come in).\n*   For `1 < v < n`: The target net outgoing flow is `0`. (Flow conservation).\n\nLet `current_net_flow[v]` be the actual net outgoing flow from vertex `v` based on the directions we've chosen so far. Initially, `current_net_flow[v] = 0` for all `v`.\n\nWe can use a queue-based approach to determine directions. The key idea is to process vertices whose \"flow balance\" is determined or can be made determined.\n\n**Algorithm:**\n\n1.  **Initialization:**\n    *   Create an adjacency list `adj` where `adj[u]` stores `(v, flow_c, edge_index, original_u, original_v)` for each edge `(u, v)` with flow `c` and its original input index. `original_u` and `original_v` are stored to easily determine the direction output (0 or 1).\n    *   Initialize `current_net_flow[v] = 0` for all `v` from 1 to `n`.\n    *   Initialize `ans` array of size `m` with -1 (indicating undetermined direction).\n    *   Initialize `undirected_degree[v]` for all `v` to be the total number of edges incident to `v`. This counts how many incident edges are yet to be directed.\n\n2.  **Queue `Q`:**\n    *   Add vertex `1` to `Q`.\n    *   For any vertex `v` (1 < `v` < `n`), if `total_incident_flow[v]` is odd, this is an impossible scenario for flow conservation (since incoming = outgoing, `2 * incoming = total_incident_flow`), but the problem guarantees a solution, so `total_incident_flow[v]` must be even for intermediate nodes.\n    *   The `target_net_flow[v]` for `1 < v < n` is `0`. This means `current_net_flow[v]` must eventually become `0`.\n\n3.  **Processing the Queue:**\n    While `Q` is not empty:\n    *   Dequeue a vertex `u`.\n    *   Iterate through all neighbors `v` of `u` via an edge `(u, v)` with flow `c` and `edge_idx`:\n        *   If `ans[edge_idx]` is already determined, continue to the next neighbor.\n        *   **Direction Decision:**\n            *   If `u == 1`: The edge must go `1 -> v`.\n            *   If `v == n`: The edge must go `u -> n`.\n            *   If `u` is an intermediate vertex (1 < `u` < `n`) and `v` is also an intermediate vertex (1 < `v` < `n`):\n                We need to decide based on the current balance and the `undirected_degree`.\n                The most robust way to ensure acyclicity and satisfy conservation is to use the topological order implicitly. We process nodes that are \"ready\" to push flow.\n                A node `u` is \"ready\" to push flow *out* if its `current_net_flow[u]` is less than its `target_net_flow[u]` (which is `0` for intermediate nodes).\n                A node `u` is \"ready\" to receive flow *in* if its `current_net_flow[u]` is greater than its `target_net_flow[u]`.\n\n                A simpler observation: For an intermediate node `u`, if `current_net_flow[u]` is not 0, and `u` has only one undirected edge left, then the direction of that edge is forced.\n                *   If `current_net_flow[u] > 0`: `u` has pushed too much flow out. The last edge `(u, v)` must be directed `v -> u` to bring `current_net_flow[u]` closer to 0.\n                *   If `current_net_flow[u] < 0`: `u` has received too much flow in. The last edge `(u, v)` must be directed `u -> v` to bring `current_net_flow[u]` closer to 0.\n\n                This \"last edge\" logic is the key. We can add vertices to the queue when their `undirected_degree` drops to 1, and their `current_net_flow` is not yet balanced to 0.\n\n        Let's refine the queue logic:\n        The queue `Q` will contain vertices `u` that need to have their incident edges directed, specifically when they have `undirected_degree[u] = 1`.\n\n        **Revised Algorithm:**\n\n        1.  **Initialization:**\n            *   `adj`: `adj[u]` stores `(v, flow_c, edge_index, original_u, original_v)`.\n            *   `current_net_flow[v] = 0` for all `v`.\n            *   `ans` array of size `m` with -1.\n            *   `undirected_degree[v]` for all `v` initialized to `len(adj[v])`.\n            *   `Q = collections.deque()`\n\n        2.  **Populate Initial Queue:**\n            *   For `v` from 1 to `n`:\n                *   If `v == 1` or `v == n`: Add `v` to `Q`. (Source and sink have fixed directions for their edges, so they are good starting points).\n                *   If `undirected_degree[v] == 1`: Add `v` to `Q`. (A node with only one undirected edge left might have its direction forced).\n            *   Use a `visited` set/array for `Q` to avoid adding same vertex multiple times.\n\n        3.  **Process Queue:**\n            While `Q` is not empty:\n                `u = Q.popleft()`\n\n                Iterate through `(v, c, edge_idx, original_u_val, original_v_val)` in `adj[u]`:\n                    If `ans[edge_idx]` is not -1 (edge already directed), continue.\n\n                    `direction = -1`\n                    `flow_out_of_u = False`\n\n                    If `u == 1`: // Source: flow must go out\n                        `flow_out_of_u = True`\n                    Else if `v == n`: // Sink: flow must go into n\n                        `flow_out_of_u = True`\n                    Else if `undirected_degree[u] == 1`: // Last edge for u, direction is forced\n                        if `current_net_flow[u] < 0`: // u needs to push flow out\n                            `flow_out_of_u = True`\n                        else: // u needs to receive flow in\n                            `flow_out_of_u = False`\n                    Else if `undirected_degree[v] == 1`: // Last edge for v, direction is forced\n                        if `current_net_flow[v] < 0`: // v needs to push flow out (so u->v)\n                            `flow_out_of_u = True`\n                        else: // v needs to receive flow in (so v->u)\n                            `flow_out_of_u = False`\n                    else:\n                        # This case should ideally not be reached if the problem guarantees a solution and\n                        # the graph can be fully directed by the above rules.\n                        # It might imply that we need to prioritize specific directions.\n                        # For competitive programming, if a solution is guaranteed,\n                        # and these rules don't cover all cases, there might be a simpler\n                        # implicit rule. The most common rule is to process nodes with degree 1.\n                        # However, the problem states \"no cycles\", which suggests topological sort.\n                        # The \"last edge\" rule implicitly builds a topological sort by reducing degrees.\n                        # If a node has multiple undirected edges, and neither is source/sink,\n                        # we can't decide its direction yet. We should only decide if degree is 1.\n                        # So, if we reach here, it means both u and v have >1 undirected edges.\n                        # This implies we should NOT decide the direction yet.\n                        # This means we should only process edges where one of the endpoints is 'special' (1, n, or undirected_degree=1).\n                        # Let's re-think: The queue should only contain nodes whose *incident edges* can be decided.\n                        # A node `u` is added to `Q` if `u=1`, `u=n`, or `undirected_degree[u]=1`.\n                        # When `u` is processed, it tries to direct its incident edges.\n                        # If an edge `(u,v)` is directed, `undirected_degree[u]` and `undirected_degree[v]` decrease.\n                        # If `undirected_degree[v]` becomes 1, then `v` should be added to `Q`.\n\n                        # Let's strictly follow the \"degree 1\" rule for intermediate nodes.\n                        # If `u` is neither source nor sink, and `undirected_degree[u] > 1`,\n                        # we cannot necessarily determine the direction of `(u,v)` yet unless `v` is special.\n                        # This means the current `u` might not be able to direct this specific edge.\n                        # We must ensure that we only direct an edge if one of its endpoints *forces* the direction.\n\n                        # The logic should be: if `u` is source/sink, or `u` is an intermediate node with `undirected_degree[u] == 1`,\n                        # then `u` determines the direction of its *undirected* edges.\n                        # If `undirected_degree[u] > 1` and `u` is intermediate, we can't determine direction from `u`'s state alone.\n                        # But what if `v` (the neighbor) is special?\n                        # This suggests we should check both endpoints of an edge.\n\n                        # A better approach for the loop:\n                        # When processing `u` from `Q`, we only direct edges `(u, v)` if `u` *forces* the direction.\n                        # The direction is forced if:\n                        #   1. `u == 1` (source) -> `u -> v`\n                        #   2. `v == n` (sink) -> `u -> v`\n                        #   3. `u` is intermediate and `undirected_degree[u] == 1` -> direction determined by `current_net_flow[u]`\n                        #   4. `v` is intermediate and `undirected_degree[v] == 1` -> direction determined by `current_net_flow[v]`\n                        # Notice that (3) and (4) are symmetric. If `undirected_degree[u] == 1`, `u` forces direction.\n                        # If `undirected_degree[v] == 1`, `v` forces direction.\n                        # If both are 1, it doesn't matter which one \"forces\" it, they should agree.\n\n                        # Let's simplify:\n                        # For an edge `(u, v)` with flow `c`, `edge_idx`:\n                        # If `ans[edge_idx]` is not -1, skip.\n                        # If `u == 1` OR `v == n`:\n                        #   Direction `u -> v`.\n                        # Else if `undirected_degree[u] == 1`:\n                        #   If `current_net_flow[u] < 0`: Direction `u -> v`.\n                        #   Else: Direction `v -> u`.\n                        # Else if `undirected_degree[v] == 1`:\n                        #   If `current_net_flow[v] < 0`: Direction `v -> u`. (This means `u -> v`).\n                        #   Else: Direction `u -> v`. (This means `v -> u`).\n                        # Else:\n                        #   Cannot decide this edge yet from `u`'s perspective. Skip this edge for now.\n                        #   This edge might be decided when `v` is processed from the queue, or when `undirected_degree` of `u` or `v` drops to 1.\n\n                        # This means we might iterate through `adj[u]` multiple times for the same edge.\n                        # Better to just process one edge at a time that *can* be determined.\n\n                        # A simpler queue strategy for \"degree 1\" nodes:\n                        # 1. Initialize `current_net_flow`, `ans`, `undirected_degree`.\n                        # 2. `Q` contains all `v` such that `undirected_degree[v] == 1` OR `v == 1` OR `v == n`.\n                        # 3. Use `in_q` array to avoid duplicates in `Q`.\n                        # 4. While `Q` is not empty:\n                        #    `u = Q.popleft()`, `in_q[u] = False`.\n                        #    For each `(v, c, edge_idx, original_u_val, original_v_val)` in `adj[u]`:\n                        #        If `ans[edge_idx]` is not -1, continue.\n                        #\n                        #        Determine `flow_out_of_u`:\n                        #        If `u == 1`: `flow_out_of_u = True`.\n                        #        Else if `v == n`: `flow_out_of_u = True`.\n                        #        Else if `undirected_degree[u] == 1`:\n                        #            `flow_out_of_u = (current_net_flow[u] < 0)`.\n                        #        Else if `undirected_degree[v] == 1`: // Check neighbor's state if u can't decide\n                        #            `flow_out_of_u = (current_net_flow[v] >= 0)`.\n                        #        Else: // Neither u nor v forces the direction. This edge cannot be decided NOW.\n                        #            Continue. (This is important, don't direct it).\n                        #\n                        #        // If we reached here, `flow_out_of_u` is determined.\n                        #        If `flow_out_of_u`:\n                        #            `current_net_flow[u] += c`\n                        #            `current_net_flow[v] -= c`\n                        #            If `original_u_val == u`: `ans[edge_idx] = 0`\n                        #            Else: `ans[edge_idx] = 1`\n                        #        Else: // `flow_in_to_u`\n                        #            `current_net_flow[u] -= c`\n                        #            `current_net_flow[v] += c`\n                        #            If `original_u_val == u`: `ans[edge_idx] = 1`\n                        #            Else: `ans[edge_idx] = 0`\n                        #\n                        #        `undirected_degree[u] -= 1`\n                        #        `undirected_degree[v] -= 1`\n                        #\n                        #        If `undirected_degree[u] == 1` and not `in_q[u]`:\n                        #            `Q.append(u)`, `in_q[u] = True`\n                        #        If `undirected_degree[v] == 1` and not `in_q[v]`:\n                        #            `Q.append(v)`, `in_q[v] = True`\n\nThis refined algorithm correctly handles the cases. The guarantee that a solution exists implies that all edges will eventually be directed. The \"degree 1\" rule (or source/sink rule) ensures that we only make forced decisions, which maintains acyclicity and flow conservation.\n\n**Example Walkthrough (First Example):**\n`n=3, m=3`\nEdges:\n1. `(3, 2, 10)`\n2. `(1, 2, 10)`\n3. `(3, 1, 5)`\n\n`adj` (simplified, storing only neighbor, flow, edge_idx, original_u, original_v):\n`adj[1] = [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]`\n`adj[2] = [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]`\n`adj[3] = [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]`\n(Note: edge_idx 0 is (3,2,10), 1 is (1,2,10), 2 is (3,1,5) - using 0-indexed for array `ans`)\n\n`current_net_flow = [0, 0, 0, 0]` (index 0 unused)\n`ans = [-1, -1, -1]`\n`undirected_degree = [0, 2, 2, 2]` (index 0 unused)\n`in_q = [False] * 4`\n\n**Initial Q population:**\n`v=1`: `undirected_degree[1]=2`. Add 1 to `Q`. `in_q[1]=True`.\n`v=2`: `undirected_degree[2]=2`.\n`v=3`: `undirected_degree[3]=2`. Add 3 to `Q`. `in_q[3]=True`.\n`Q = deque([1, 3])`\n\n**Iteration 1:**\n`u = Q.popleft()` (u=1). `in_q[1]=False`.\nEdges incident to 1:\n1. `(1, 2, 10, edge_idx=1, original_u=1, original_v=2)`:\n   `ans[1]` is -1.\n   `u==1` (source). `flow_out_of_u = True`.\n   `current_net_flow[1] += 10` (becomes 10)\n   `current_net_flow[2] -= 10` (becomes -10)\n   `ans[1] = 0` (1 -> 2)\n   `undirected_degree[1] -= 1` (becomes 1)\n   `undirected_degree[2] -= 1` (becomes 1)\n   `undirected_degree[1]==1` and not `in_q[1]`: `Q.append(1)`, `in_q[1]=True`.\n   `undirected_degree[2]==1` and not `in_q[2]`: `Q.append(2)`, `in_q[2]=True`.\n2. `(3, 1, 5, edge_idx=2, original_u=3, original_v=1)`: (Stored as `(1,3)` in `adj[1]`)\n   `ans[2]` is -1.\n   `u==1` (source). `flow_out_of_u = True`.\n   `current_net_flow[1] += 5` (becomes 15)\n   `current_net_flow[3] -= 5` (becomes -5)\n   `ans[2] = 1` (3 -> 1, so original_u=3, original_v=1, flow is v->u, so 1)\n   `undirected_degree[1] -= 1` (becomes 0)\n   `undirected_degree[3] -= 1` (becomes 1)\n   `undirected_degree[1]==0`. Not added to Q.\n   `undirected_degree[3]==1` and not `in_q[3]`: `Q.append(3)`, `in_q[3]=True`.\n`Q = deque([3, 1, 2, 3])` (Note: `3` is added twice, but `in_q[3]` prevents this. `in_q[3]` is already true from initial population. So it's `Q = deque([3, 1, 2])` if `in_q` is properly handled.) Let's assume `in_q` works. `Q = deque([3, 1, 2])`.\n\n**Iteration 2:**\n`u = Q.popleft()` (u=3). `in_q[3]=False`.\nEdges incident to 3:\n1. `(3, 2, 10, edge_idx=0, original_u=3, original_v=2)`:\n   `ans[0]` is -1.\n   `u=3` is `n` (sink). `flow_out_of_u = False` (flow must go INTO 3).\n   `current_net_flow[3] -= 10` (becomes -15)\n   `current_net_flow[2] += 10` (becomes 0)\n   `ans[0] = 0` (3 -> 2, so original_u=3, original_v=2, flow is u->v, so 0)\n   `undirected_degree[3] -= 1` (becomes 0)\n   `undirected_degree[2] -= 1` (becomes 0)\n   `undirected_degree[3]==0`. Not added to Q.\n   `undirected_degree[2]==0`. Not added to Q.\n2. `(3, 1, 5, edge_idx=2, original_u=3, original_v=1)`:\n   `ans[2]` is 1. Already directed. Continue.\n`Q = deque([1, 2])`\n\n**Iteration 3:**\n`u = Q.popleft()` (u=1). `in_q[1]=False`.\nEdges incident to 1:\n1. `(1, 2, 10, edge_idx=1)`: `ans[1]` is 0. Already directed.\n2. `(3, 1, 5, edge_idx=2)`: `ans[2]` is 1. Already directed.\n`Q = deque([2])`\n\n**Iteration 4:**\n`u = Q.popleft()` (u=2). `in_q[2]=False`.\nEdges incident to 2:\n1. `(3, 2, 10, edge_idx=0)`: `ans[0]` is 0. Already directed.\n2. `(1, 2, 10, edge_idx=1)`: `ans[1]` is 0. Already directed.\n`Q = deque([])`\n\nQueue is empty. All edges directed.\n`ans = [0, 0, 1]`\nOutput:\n`0` (for edge (3,2,10))\n`0` (for edge (1,2,10))\n`1` (for edge (3,1,5))\n\nWait, example output is `1\\n0\\n1`. My `ans[0]` is 0, example is 1.\nMy `ans[0]=0` means `3 -> 2`. This makes `current_net_flow[3]` -15.\nLet's check the logic for `u=3` (sink).\nIf `u=3` (sink), then `flow_out_of_u = False` means flow goes *into* `u`.\nFor edge `(3, 2, 10)` (original `(3,2)`), if flow goes into `3`, it must be `2 -> 3`.\nIf `original_u_val == u` (which is 3), and `flow_out_of_u` is `False`, then `ans[edge_idx]` should be `1`.\nMy code:\n`If original_u_val == u: ans[edge_idx] = 1`\n`Else: ans[edge_idx] = 0`\nThis is correct. So for `(3,2,10)`, `original_u_val=3`, `u=3`, `flow_out_of_u=False`. So `ans[0]=1`.\nThis makes `current_net_flow[3]` `(-5) - 10 = -15`.\n`current_net_flow[2]` `(-10) + 10 = 0`.\n\nLet's retrace with the corrected `ans[0]` logic:\n`current_net_flow = [0, 0, 0, 0]`\n`ans = [-1, -1, -1]`\n`undirected_degree = [0, 2, 2, 2]`\n`in_q = [False] * 4`\n`Q = deque([1, 3])`\n\n**Iteration 1 (u=1):**\n1. `(1, 2, 10, edge_idx=1, original_u=1, original_v=2)`:\n   `u==1` (source). `flow_out_of_u = True`.\n   `current_net_flow[1] += 10` (10)\n   `current_net_flow[2] -= 10` (-10)\n   `ans[1] = 0` (1 -> 2)\n   `undirected_degree[1] = 1`, `undirected_degree[2] = 1`.\n   `Q.append(1)`, `Q.append(2)`.\n2. `(3, 1, 5, edge_idx=2, original_u=3, original_v=1)`:\n   `u==1` (source). `flow_out_of_u = True`.\n   `current_net_flow[1] += 5` (15)\n   `current_net_flow[3] -= 5` (-5)\n   `ans[2] = 1` (3 -> 1, so flow is 1 -> 3, which is `original_v -> original_u`, so 1)\n   `undirected_degree[1] = 0`, `undirected_degree[3] = 1`.\n   `Q.append(3)` (if not already in `Q`)\n`Q = deque([3, 1, 2])` (assuming `in_q` prevents duplicates for 3)\n\n**Iteration 2 (u=3):**\n1. `(3, 2, 10, edge_idx=0, original_u=3, original_v=2)`:\n   `ans[0]` is -1.\n   `u=3` (sink). `flow_out_of_u = False` (flow must go INTO 3).\n   `current_net_flow[3] -= 10` (-15)\n   `current_net_flow[2] += 10` (0)\n   `ans[0] = 1` (3 -> 2, flow is 2 -> 3, so `original_v -> original_u`, so 1)\n   `undirected_degree[3] = 0`, `undirected_degree[2] = 0`.\n   No new additions to `Q`.\n2. `(3, 1, 5, edge_idx=2)`: `ans[2]` is 1. Already directed.\n`Q = deque([1, 2])`\n\n**Iteration 3 (u=1):** All edges already directed.\n`Q = deque([2])`\n\n**Iteration 4 (u=2):** All edges already directed.\n`Q = deque([])`\n\nFinal `ans = [1, 0, 1]`. This matches the example output!\nThe logic seems correct.\n\nFinal check on acyclicity:\nThe approach directs edges based on \"source/sink\" property or if an intermediate node has only one undirected edge left. This is a greedy approach.\nA source node (1) only pushes flow out. A sink node (n) only receives flow. Intermediate nodes `v` with `undirected_degree[v] = 1` are forced to balance their `current_net_flow[v]`. If `current_net_flow[v] < 0`, it needs to push flow out, so `v -> neighbor`. If `current_net_flow[v] > 0`, it needs to receive flow, so `neighbor -> v`.\nThis process effectively \"peels off\" nodes whose flow balance becomes determined. This is a topological sort in reverse. Nodes whose `undirected_degree` becomes 0 are \"removed\" from the graph for further consideration. The \"degree 1\" rule ensures that we don't make arbitrary choices that could lead to cycles. A cycle would require all nodes in the cycle to have `undirected_degree >= 2` until the very end, and then somehow resolve simultaneously, which is prevented by this step-by-step resolution.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # adj[u] will store (v, flow_c, edge_idx, original_u, original_v)\n    # original_u and original_v are stored to correctly determine the output direction (0 or 1)\n    adj = [[] for _ in range(n + 1)]\n    edges_input_order = [] # To store (u, v, c) in input order for easy reference\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        edges_input_order.append((u, v, c))\n\n    # current_net_flow[v]: sum of flows out of v minus sum of flows into v\n    current_net_flow = [0] * (n + 1)\n    \n    # ans[i]: 0 if flow is original_u -> original_v, 1 if original_v -> original_u\n    ans = [-1] * m \n\n    # undirected_degree[v]: number of incident edges to v that are not yet directed\n    undirected_degree = [len(adj[v]) for v in range(n + 1)]\n\n    Q = collections.deque()\n    in_q = [False] * (n + 1) # To prevent adding the same vertex multiple times to Q\n\n    # Initialize Q with source (1), sink (n), and any nodes with undirected_degree 1\n    for v in range(1, n + 1):\n        if v == 1 or v == n or undirected_degree[v] == 1:\n            Q.append(v)\n            in_q[v] = True\n\n    while Q:\n        u = Q.popleft()\n        in_q[u] = False\n\n        # Iterate through neighbors of u\n        for v, c, edge_idx, original_u_val, original_v_val in adj[u]:\n            if ans[edge_idx] != -1: # If edge already directed, skip\n                continue\n\n            flow_out_of_u = False # Flag to determine if flow goes u -> v\n\n            # Rule 1: Source (1) pushes flow out\n            if u == 1:\n                flow_out_of_u = True\n            # Rule 2: Sink (n) receives flow in (so flow u -> n)\n            elif v == n:\n                flow_out_of_u = True\n            # Rule 3: Intermediate node u with only one undirected edge left\n            elif undirected_degree[u] == 1:\n                # If current_net_flow[u] is negative, u needs to push flow out to balance to 0\n                flow_out_of_u = (current_net_flow[u] < 0)\n            # Rule 4: Intermediate node v with only one undirected edge left\n            elif undirected_degree[v] == 1:\n                # If current_net_flow[v] is negative, v needs to push flow out (so v -> u, meaning u <- v)\n                # If current_net_flow[v] is non-negative, v needs to receive flow in (so u -> v)\n                flow_out_of_u = (current_net_flow[v] >= 0)\n            else:\n                # Cannot determine direction for this edge yet. Skip for now.\n                # This edge will be processed when u or v becomes a \"degree 1\" node or source/sink.\n                continue\n\n            # Apply the determined direction\n            if flow_out_of_u:\n                current_net_flow[u] += c\n                current_net_flow[v] -= c\n                if original_u_val == u:\n                    ans[edge_idx] = 0 # Flow u -> v, matches original_u -> original_v\n                else:\n                    ans[edge_idx] = 1 # Flow u -> v, but u was original_v, so original_v -> original_u\n            else: # Flow v -> u\n                current_net_flow[u] -= c\n                current_net_flow[v] += c\n                if original_u_val == u:\n                    ans[edge_idx] = 1 # Flow v -> u, but u was original_u, so original_v -> original_u\n                else:\n                    ans[edge_idx] = 0 # Flow v -> u, but u was original_v, so original_u -> original_v\n\n            # Update undirected degrees\n            undirected_degree[u] -= 1\n            undirected_degree[v] -= 1\n\n            # If a node's undirected_degree becomes 1, or it's source/sink, add to Q\n            # Source/sink are always \"special\", but their degree might drop to 0.\n            # We only care if it can potentially determine another edge.\n            if undirected_degree[u] == 1 and not in_q[u] and u != 1 and u != n:\n                Q.append(u)\n                in_q[u] = True\n            if undirected_degree[v] == 1 and not in_q[v] and v != 1 and v != n:\n                Q.append(v)\n                in_q[v] = True\n            \n            # Special case for source/sink, they are always in Q if they have undirected edges left\n            # But they are added initially. The logic for undirected_degree[u] == 1 is for intermediate nodes.\n            # If source/sink have their last edge directed, their degree becomes 0, they won't be added back.\n            # The initial population of Q is enough for source/sink.\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # adj[u] will store (v, flow_c, edge_idx, original_u, original_v)\n    # original_u and original_v are stored to correctly determine the output direction (0 or 1)\n    adj = [[] for _ in range(n + 1)]\n    edges_input_order = [] # To store (u, v, c) in input order for easy reference\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        edges_input_order.append((u, v, c))\n\n    # current_net_flow[v]: sum of flows out of v minus sum of flows into v\n    current_net_flow = [0] * (n + 1)\n    \n    # ans[i]: 0 if flow is original_u -> original_v, 1 if original_v -> original_u\n    ans = [-1] * m \n\n    # undirected_degree[v]: number of incident edges to v that are not yet directed\n    undirected_degree = [len(adj[v]) for v in range(n + 1)]\n\n    Q = collections.deque()\n    in_q = [False] * (n + 1) # To prevent adding the same vertex multiple times to Q\n\n    # Initialize Q with source (1), sink (n), and any nodes with undirected_degree 1\n    for v in range(1, n + 1):\n        if v == 1 or v == n or undirected_degree[v] == 1:\n            Q.append(v)\n            in_q[v] = True\n\n    while Q:\n        u = Q.popleft()\n        in_q[u] = False\n\n        # Iterate through neighbors of u\n        for v, c, edge_idx, original_u_val, original_v_val in adj[u]:\n            if ans[edge_idx] != -1: # If edge already directed, skip\n                continue\n\n            flow_out_of_u = False # Flag to determine if flow goes u -> v\n\n            # Rule 1: Source (1) pushes flow out\n            if u == 1:\n                flow_out_of_u = True\n            # Rule 2: Sink (n) receives flow in (so flow u -> n)\n            elif v == n:\n                flow_out_of_u = True\n            # Rule 3: Intermediate node u with only one undirected edge left\n            elif undirected_degree[u] == 1:\n                # If current_net_flow[u] is negative, u needs to push flow out to balance to 0\n                flow_out_of_u = (current_net_flow[u] < 0)\n            # Rule 4: Intermediate node v with only one undirected edge left\n            elif undirected_degree[v] == 1:\n                # If current_net_flow[v] is negative, v needs to push flow out (so v -> u, meaning u <- v)\n                # If current_net_flow[v] is non-negative, v needs to receive flow in (so u -> v)\n                flow_out_of_u = (current_net_flow[v] >= 0)\n            else:\n                # Cannot determine direction for this edge yet. Skip for now.\n                # This edge will be processed when u or v becomes a \"degree 1\" node or source/sink.\n                continue\n\n            # Apply the determined direction\n            if flow_out_of_u:\n                current_net_flow[u] += c\n                current_net_flow[v] -= c\n                if original_u_val == u:\n                    ans[edge_idx] = 0 # Flow u -> v, matches original_u -> original_v\n                else:\n                    ans[edge_idx] = 1 # Flow u -> v, but u was original_v, so original_v -> original_u\n            else: # Flow v -> u\n                current_net_flow[u] -= c\n                current_net_flow[v] += c\n                if original_u_val == u:\n                    ans[edge_idx] = 1 # Flow v -> u, but u was original_u, so original_v -> original_u\n                else:\n                    ans[edge_idx] = 0 # Flow v -> u, but u was original_v, so original_u -> original_v\n\n            # Update undirected degrees\n            undirected_degree[u] -= 1\n            undirected_degree[v] -= 1\n\n            # If a node's undirected_degree becomes 1, or it's source/sink, add to Q\n            # Source/sink are always \"special\", but their degree might drop to 0.\n            # We only care if it can potentially determine another edge.\n            if undirected_degree[u] == 1 and not in_q[u] and u != 1 and u != n:\n                Q.append(u)\n                in_q[u] = True\n            if undirected_degree[v] == 1 and not in_q[v] and v != 1 and v != n:\n                Q.append(v)\n                in_q[v] = True\n            \n            # Special case for source/sink, they are always in Q if they have undirected edges left\n            # But they are added initially. The logic for undirected_degree[u] == 1 is for intermediate nodes.\n            # If source/sink have their last edge directed, their degree becomes 0, they won't be added back.\n            # The initial population of Q is enough for source/sink.\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 8414,
        "thoughts_token_count": 4686
    }
}