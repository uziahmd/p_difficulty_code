{
    "start": 1758012066.4713142,
    "end": 1758012208.8870215,
    "start-formatted": "2025-09-16 17:41 KST",
    "end-formatted": "2025-09-16 17:43 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**My Analysis and Approach to the Selling Souvenirs Problem**\n\nAlright, let's break this down. The problem's essentially a variation of the knapsack problem, where we're given items with weights 1, 2, or 3, and need to maximize their cost within a weight limit `m`. The standard dynamic programming approach (0/1 knapsack) is a non-starter here due to the constraints.  We're looking at potentially very large values of n and m.\n\nSince the weights are limited to small integer values, it's clear this calls for a different strategy. My first instinct is to categorize the items based on their weight and sort the cost lists in descending order.  I'd create lists, `items_w1`, `items_w2`, and `items_w3`. To calculate the cost efficiently I'd use prefix sums.\n\nThe goal is to determine how many items to pick from each weight category, let's call it `k1`, `k2`, and `k3`.  My initial thought was to iterate through all combinations of `k1`, `k2`, and `k3` that satisfy the weight constraint (`1*k1 + 2*k2 + 3*k3 <= m`). However, that quickly becomes computationally expensive.\n\nSince weight is a small integer, I thought about using dynamic programming. I defined `dp[w]` as the maximum cost for a total weight `w`. The size of the dp would be `m + 1`.\n\nThe solution would be to try all combinations. Let `k3` from `0` to `m/3`. Then, we should iterate over number of `w2` in the remaining capacity. For each combination, we calculate the remaining number of `w1`.\n\nI tried to compute the \"subproblem\" of using items of weight 1 and 2 within the remaining weight capacity (`m_prime`). The initial DP approach, with individual item processing, was too slow with complexity of O(n*m). Then I considered a \"meet-in-the-middle\" approach, but it was still too slow.\n\nThen, I focused on calculating the maximum cost using weights 1 and 2 for all capacities `0` through `m`.  I defined the cost to fill each weight with items of weights 1 and 2.  Then, I tried to calculate the `max_cost_w12`, but was unable to optimize it to `O(m)`. Finally, I realized to achieve O(m) run time, the maximum cost achievable for weight should be stored to optimize it.\n\nThe key is to combine dynamic programming with a fixed number of items.\n",
    "response": "The problem asks us to select a subset of `n` souvenirs, each with a weight `w_i` and cost `c_i`, such that their total weight does not exceed `m` and their total cost is maximized. The key constraint is that `w_i` can only be 1, 2, or 3.\n\nGiven the constraints `n <= 100000` and `m <= 300000`, a standard 0/1 knapsack DP solution (which is `O(n*m)`) would be too slow. However, the limited range of weights (`1 <= w_i <= 3`) allows for a more efficient approach.\n\n**Strategy:**\n\n1.  **Categorize and Sort:** First, separate the souvenirs into three lists based on their weights: `items_w1`, `items_w2`, and `items_w3`. To maximize cost, we should always pick the most expensive items first within each weight category. Therefore, sort each of these lists in descending order of cost.\n\n2.  **Precompute Prefix Sums:** To quickly calculate the sum of costs for the top `k` items in any category, compute prefix sums for each sorted list.\n    *   `prefix_sum_w1[k]` will store the sum of costs of the `k` most expensive items of weight 1.\n    *   `prefix_sum_w2[k]` will store the sum of costs of the `k` most expensive items of weight 2.\n    *   `prefix_sum_w3[k]` will store the sum of costs of the `k` most expensive items of weight 3.\n    These can be computed in `O(N)` total time.\n\n3.  **Dynamic Programming for Weights 1 and 2:**\n    Let `dp_w12[w]` be the maximum cost achievable for a total weight `w` using *only* items of weight 1 and 2. We can compute this array for `w` from `0` to `m`.\n    `dp_w12[w] = max_{k2} (prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), w - 2*k2)])`\n    where `k2` is the number of weight 2 items chosen, such that `2*k2 <= w`.\n\n    To compute `dp_w12` efficiently for all `w` from `0` to `m`:\n    Initialize `dp_w12 = [0] * (m + 1)`.\n    Iterate `k2` (number of weight 2 items) from `0` up to `len(items_w2)`:\n    Let `cost_w2 = prefix_sum_w2[k2]` and `weight_w2 = 2 * k2`.\n    If `weight_w2 > m`, break (cannot take more weight 2 items).\n    Now, for each `k2`, we have `m - weight_w2` remaining capacity. We need to fill this with items of weight 1.\n    The crucial observation here is that for a fixed `k2`, as `W_rem` (remaining capacity for weight 1 items) increases, we can take more weight 1 items.\n    The function `prefix_sum_w1[x]` is a concave function (first differences are non-increasing).\n    The expression `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), W_rem)]` needs to be maximized.\n    This can be done by iterating `k2` and then iterating `k1` (number of weight 1 items) for each `k2`. However, this would be `O(m^2)`.\n\n    A more efficient way to compute `dp_w12[w]` for all `w`:\n    `dp_w12 = [-1] * (m + 1)` (use -1 to indicate not reachable, or 0 if 0 cost is always an option)\n    `dp_w12[0] = 0`\n    `current_cost_w1 = 0`\n    `ptr_w1 = 0`\n    For `w` from `1` to `m`:\n        `dp_w12[w] = dp_w12[w-1]` (option to not take any item for this weight)\n        If `ptr_w1 < len(items_w1)` and `items_w1[ptr_w1]` is positive (we want to take it):\n            `current_cost_w1 += items_w1[ptr_w1]`\n            `ptr_w1 += 1`\n            `dp_w12[w] = max(dp_w12[w], current_cost_w1)`\n    This approach is wrong. The `dp_w12[w]` should consider items of weight 2 as well.\n\n    The correct DP for `dp_w12[w]` (max cost for weight `w` using items of weight 1 and 2):\n    `dp_w12 = [0] * (m + 1)`\n    `for w in range(1, m + 1):`\n        `# Option 1: Don't take an item for this weight slot, inherit from w-1`\n        `dp_w12[w] = dp_w12[w-1] + (items_w1[w-1] if w-1 < len(items_w1) else 0)`\n        `# This is still not quite right. This is like unbounded knapsack.`\n        `# We need to iterate over *all* items.`\n\n    The most efficient way to compute `dp_w12[w]` for all `w` is as follows:\n    `dp_w12 = [0] * (m + 1)`\n    `for w in range(m + 1):`\n        `# Consider taking k2 items of weight 2, and fill remaining with weight 1 items`\n        `# Iterate k2 from 0 up to min(len(items_w2), w//2)`\n        `# This inner loop is too slow if done naively for each w.`\n        `# We need to compute this for all w in O(m).`\n        `# The values prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), w - 2*k2)]`\n        `# can be viewed as maximizing f(x) + g(w - 2x).`\n        `# This is a standard optimization problem. Since prefix_sum functions are concave,`\n        `# this maximum for each w can be found in O(1) amortized time using a sliding window maximum (deque) or similar technique.`\n        `# However, a simpler approach given the small weights might be sufficient.`\n\n    Let's refine the `dp_w12` calculation to be `O(m)`:\n    `dp_w12 = [0] * (m + 1)`\n    `# Fill dp_w12 considering only items of weight 1`\n    `current_cost = 0`\n    `for i in range(min(m + 1, len(items_w1) + 1)):`\n        `if i > 0: current_cost += items_w1[i-1]`\n        `dp_w12[i] = current_cost`\n    `for i in range(len(items_w1) + 1, m + 1):` # For capacities beyond available w1 items\n        `dp_w12[i] = dp_w12[len(items_w1)]`\n\n    `# Now incorporate items of weight 2`\n    `# For each possible number of weight 2 items (k2), update dp_w12`\n    `# We iterate k2 from 1 to len(items_w2) because k2=0 is already covered.`\n    `for k2 in range(1, len(items_w2) + 1):`\n        `cost_w2 = prefix_sum_w2[k2]`\n        `weight_w2 = 2 * k2`\n        `if weight_w2 > m: break`\n        `# For each possible total weight W from m down to weight_w2:`\n        `# W = weight_w2 + remaining_weight_for_w1`\n        `# The remaining_weight_for_w1 is W - weight_w2`\n        `# We want to maximize cost_w2 + (cost from weight 1 items for W - weight_w2)`\n        `for W in range(m, weight_w2 - 1, -1):`\n            `dp_w12[W] = max(dp_w12[W], cost_w2 + prefix_sum_w1[min(len(items_w1), W - weight_w2)])`\n    This is `O(len(items_w2) * m)`, which is `O(m^2)`. This is still too slow.\n\n    The correct `O(m)` DP for `dp_w12` (max cost for weight `w` using items of weight 1 and 2):\n    `dp_w12 = [0] * (m + 1)`\n    `# Initialize dp_w12 considering only items of weight 1`\n    `current_cost_w1 = 0`\n    `for w in range(m + 1):`\n        `if w > 0 and w - 1 < len(items_w1):`\n            `current_cost_w1 += items_w1[w-1]`\n        `dp_w12[w] = current_cost_w1`\n\n    `# Now, for each possible total weight W, consider taking k2 items of weight 2.`\n    `# For each W, iterate k2 from 0 up to W/2.`\n    `# This is still O(m^2).`\n\n    The actual `O(m)` approach for `dp_w12`:\n    `dp_w12 = [0] * (m + 1)`\n    `# Initialize dp_w12 with only weight 1 items`\n    `current_cost = 0`\n    `for w in range(m + 1):`\n        `if w > 0 and w - 1 < len(items_w1):`\n            `current_cost += items_w1[w-1]`\n        `dp_w12[w] = current_cost`\n\n    `# Iterate through items of weight 2`\n    `for k2 in range(len(items_w2)):`\n        `cost_of_this_w2_item = items_w2[k2]`\n        `# Update dp_w12 by considering adding this (k2+1)-th most expensive weight 2 item`\n        `# Iterate W from m down to 2 (weight of item 2)`\n        `for W in range(m, 1, -1):`\n            `if W >= 2:`\n                `dp_w12[W] = max(dp_w12[W], dp_w12[W - 2] + cost_of_this_w2_item)`\n    This is `O(len(items_w2) * m)`, which is still `O(m^2)`.\n\n    The problem is that each item is unique. The standard DP `dp[W] = max(dp[W], dp[W-w_i] + c_i)` assumes we can use the same item multiple times if we iterate `W` upwards, or it's 0/1 if `W` iterates downwards. Here, `items_w1`, `items_w2`, `items_w3` are lists of *distinct* items. So we must use the 0/1 knapsack DP form.\n\n    The `O(m)` DP for `dp_w12[w]` can be done as follows:\n    `dp_w12 = [0] * (m + 1)`\n    `# For each possible number of weight 2 items (k2)`\n    `for k2 in range(len(prefix_sum_w2)):`\n        `cost_for_k2_w2 = prefix_sum_w2[k2]`\n        `weight_for_k2_w2 = 2 * k2`\n        `if weight_for_k2_w2 > m: break`\n        `# The remaining capacity for weight 1 items is W_rem = w - weight_for_k2_w2`\n        `# We can take min(len(items_w1), W_rem) items of weight 1.`\n        `# The total cost for this k2 is cost_for_k2_w2 + prefix_sum_w1[min(len(items_w1), W_rem)]`\n        `# We need to maximize this for each W.`\n        `# This is a \"meet-in-the-middle\" style approach for two types of items.`\n\n        `# Let's iterate over the number of weight 1 items (k1)`\n        `# For each k1, calculate cost_w1 = prefix_sum_w1[k1]`\n        `# And weight_w1 = k1`\n        `# Then we have m - k1 capacity for weight 2 items.`\n        `# We need to find the best k2 for that capacity.`\n        `# This is also O(m^2).`\n\n    The solution must be `O(m)` or `O(m log m)` or `O(N)` or `O(N log N)`.\n    Since `w_i` is small, the maximum number of items of weight 2 and 3 that we can take *together* is still `m/2 + m/3`, which is `O(m)`.\n    The sum `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), W - 2*k2)]` has a specific structure.\n    Let `f(k2) = prefix_sum_w2[k2]` and `g(k1) = prefix_sum_w1[k1]`. We want to maximize `f(k2) + g(W - 2*k2)`.\n    Both `f` and `g` are concave. The sum of a concave function and a \"shifted and scaled\" concave function is also concave.\n    We can compute `dp_w12[w]` for all `w` in `O(m)` using a specific optimization.\n    For each `w`, we want to find `k2` that maximizes `prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), w - 2*k2)]`.\n    The maximum `k2` is `w // 2`.\n    The values `w - 2*k2` range from `w` down to `0` (or `1`).\n    This is equivalent to finding `max_{0 <= k2 <= w//2} (prefix_sum_w2[k2] + prefix_sum_w1[w - 2*k2])`.\n    This can be done with a sliding window maximum using a deque.\n    Let `h(k) = prefix_sum_w2[k]`. We want `max_{k2} (h(k2) + prefix_sum_w1[w - 2*k2])`.\n    This is essentially `max_{k2} (h(k2) + g_prime(w - 2*k2))`.\n    The crucial observation for `O(m)` is that we can compute `dp_w12[w]` for all `w` by iterating `w` from `0` to `m`, and for each `w`, considering adding a weight-1 item or a weight-2 item.\n    `dp_w12[w] = max(dp_w12[w-1] + (items_w1[count_w1] if count_w1 < len(items_w1) else 0), dp_w12[w-2] + (items_w2[count_w2] if count_w2 < len(items_w2) else 0))`\n    This is not correct either because `count_w1` and `count_w2` are not fixed.\n\n    The correct `O(M)` DP for `dp_w12` is:\n    `dp_w12 = [0] * (m + 1)`\n    `# Fill with only weight 1 items`\n    `current_cost = 0`\n    `for w in range(m + 1):`\n        `if w > 0 and w - 1 < len(items_w1):`\n            `current_cost += items_w1[w-1]`\n        `dp_w12[w] = current_cost`\n\n    `# Now, for each possible total weight W, consider taking some number of weight 2 items.`\n    `# We can iterate over the number of weight 2 items, say k2.`\n    `# For each k2, we have cost prefix_sum_w2[k2] and weight 2*k2.`\n    `# The remaining capacity is W - 2*k2, which we fill with weight 1 items.`\n    `# This is the O(M) solution for two item types:`\n    `# For each W from 0 to M:`\n    `#   dp_w12[W] = max_{0 <= k2 <= W/2} (prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), W - 2*k2)])`\n    `# This can be calculated in O(M) total time by iterating W and maintaining the best k2.`\n    `# Let's try to implement this correctly.`\n\n    `max_cost_w12 = [0] * (m + 1)`\n    `# Iterate over the number of items of weight 2 we take (k2)`\n    `for k2 in range(len(prefix_sum_w2)):`\n        `cost_from_w2 = prefix_sum_w2[k2]`\n        `weight_from_w2 = 2 * k2`\n        `if weight_from_w2 > m: break`\n\n        `# Now, for the remaining capacity `rem_m = m - weight_from_w2`, we add weight 1 items.`\n        `# We need to maximize `cost_from_w2 + prefix_sum_w1[k1]` for `k1` up to `rem_m`.`\n        `# This means `max_cost_w12[weight_from_w2 + k1]` for all valid `k1`.`\n        `# This part is the tricky one.`\n\n        `# Instead, let's iterate over `W` (total weight capacity) and update `max_cost_w12[W]`\n        `# For each W, we can potentially form it with `k2` items of weight 2 and `W - 2*k2` items of weight 1.`\n        `# The values `prefix_sum_w2[k2] + prefix_sum_w1[W - 2*k2]` need to be maximized.`\n        `# This is a standard deque optimization problem for sums of concave functions.`\n\n        `# A simpler approach, perhaps what the problem expects for \"very easy\":`\n        `# The number of items of weight 2 and 3 is at most N. If N is small, this is easy.`\n        `# But N is large. The number of items of weight 2 and 3 can be up to M/2 and M/3.`\n\n    The most common trick for `w_i <= 3` is to iterate over the items of weight 3, and for the remaining capacity, solve the subproblem with items of weight 1 and 2.\n    `max_total_cost = 0`\n    `for k3 in range(len(prefix_sum_w3)):`\n        `cost_w3 = prefix_sum_w3[k3]`\n        `weight_w3 = 3 * k3`\n        `if weight_w3 > m: break`\n        `remaining_m = m - weight_w3`\n\n        `# Now solve for remaining_m using items of weight 1 and 2.`\n        `# We need to find max_{k2} (prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2)])`\n        `# This part needs to be O(1) or O(log M) per k3 iteration for the overall solution to be efficient.`\n        `# The maximum value for `f(x) = prefix_sum_w2[x] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*x)]`\n        `# can be found efficiently because `f(x)` is concave. A ternary search can find the maximum in `O(log M)` time.`\n\n        `# Ternary search for k2:`\n        `low = 0`\n        `high = min(len(items_w2), remaining_m // 2)`\n        `best_cost_w12 = 0`\n\n        `while high - low >= 3:`\n            `m1 = low + (high - low) // 3`\n            `m2 = high - (high - low) // 3`\n\n            `cost1 = prefix_sum_w2[m1] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*m1)]`\n            `cost2 = prefix_sum_w2[m2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*m2)]`\n\n            `if cost1 < cost2:`\n                `low = m1`\n            `else:`\n                `high = m2`\n\n        `# After ternary search, check the remaining small range`\n        `for k2_val in range(low, high + 1):`\n            `if k2_val * 2 <= remaining_m:`\n                `current_cost_w12 = prefix_sum_w2[k2_val] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2_val)]`\n                `best_cost_w12 = max(best_cost_w12, current_cost_w12)`\n        `max_total_cost = max(max_total_cost, cost_w3 + best_cost_w12)`\n\n    The outer loop runs `O(m)` times. The inner ternary search is `O(log m)`. The small range check is `O(1)`.\n    So, total time complexity: `O(N log N)` (for sorting) + `O(M log M)` (for the main loop).\n    `N=10^5, M=3*10^5`. `3*10^5 * log(3*10^5)` is roughly `3*10^5 * 18 = 5.4 * 10^6`, which is acceptable.\n\nLet's trace the ternary search approach.\n\n**Detailed Algorithm:**\n\n1.  Read `n` and `m`.\n2.  Create three lists: `items_w1`, `items_w2`, `items_w3`.\n3.  Read `n` souvenirs: for each `(w, c)`, append `c` to the corresponding list.\n4.  Sort `items_w1`, `items_w2`, `items_w3` in descending order.\n5.  Compute prefix sums for each list: `prefix_sum_w1`, `prefix_sum_w2`, `prefix_sum_w3`. (Remember `prefix_sum[0] = 0`).\n6.  Initialize `max_overall_cost = 0`.\n7.  Iterate `k3` (number of weight 3 items) from `0` to `len(items_w3)`:\n    a.  Calculate `cost_w3 = prefix_sum_w3[k3]`.\n    b.  Calculate `weight_w3 = 3 * k3`.\n    c.  If `weight_w3 > m`, break the loop (cannot take more weight 3 items).\n    d.  Calculate `remaining_m = m - weight_w3`.\n    e.  Initialize `best_cost_w12 = 0`.\n    f.  Perform ternary search to find the optimal `k2` (number of weight 2 items) for `remaining_m`:\n        i.   `low = 0`, `high = min(len(items_w2), remaining_m // 2)`.\n        ii.  While `high - low >= 3`:\n            *   `m1 = low + (high - low) // 3`\n            *   `m2 = high - (high - low) // 3`\n            *   `val1 = prefix_sum_w2[m1] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*m1)]`\n            *   `val2 = prefix_sum_w2[m2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*m2)]`\n            *   If `val1 < val2`, set `low = m1`. Else, set `high = m2`.\n        iii. After the loop, iterate `k2_val` from `low` to `high` (inclusive):\n            *   If `k2_val * 2 <= remaining_m`:\n                *   `current_cost_w12 = prefix_sum_w2[k2_val] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2_val)]`\n                *   `best_cost_w12 = max(best_cost_w12, current_cost_w12)`\n    g.  Update `max_overall_cost = max(max_overall_cost, cost_w3 + best_cost_w12)`.\n8.  Print `max_overall_cost`.\n\n**Edge Cases:**\n*   `m=0`: `max_overall_cost` will remain 0, which is correct.\n*   No items of a certain weight: `len(items_wX)` will be 0, `prefix_sum_wX` will be `[0]`. The loops and `min` calls handle this gracefully.\n*   All items too heavy: `max_overall_cost` will remain 0.\n\nThis approach seems robust and efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else: # w == 3\n            items_w3.append(c)\n\n    # Sort items by cost in descending order\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    # Precompute prefix sums for quick sum calculation\n    # prefix_sum_wX[k] will store the sum of costs of the k most expensive items\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_overall_cost = 0\n\n    # Iterate over the number of items of weight 3 (k3)\n    # The maximum k3 is m // 3\n    for k3 in range(len(prefix_sum_w3)):\n        cost_w3 = prefix_sum_w3[k3]\n        weight_w3 = 3 * k3\n\n        if weight_w3 > m:\n            break\n\n        remaining_m = m - weight_w3\n        \n        # Now, for the remaining_m capacity, we need to find the maximum cost\n        # using items of weight 1 and 2.\n        # This subproblem is: max_{k2} (prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2)])\n        # The function f(k2) = prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2)] is concave.\n        # We can use ternary search to find its maximum.\n\n        low = 0\n        high = min(len(items_w2), remaining_m // 2)\n        \n        best_cost_w12 = 0\n        if low <= high: # Ensure valid range for ternary search\n            # Ternary search to find optimal k2\n            while high - low >= 3:\n                m1 = low + (high - low) // 3\n                m2 = high - (high - low) // 3\n\n                val1_k1_count = min(len(items_w1), remaining_m - 2 * m1)\n                val1 = prefix_sum_w2[m1] + prefix_sum_w1[val1_k1_count]\n\n                val2_k1_count = min(len(items_w1), remaining_m - 2 * m2)\n                val2 = prefix_sum_w2[m2] + prefix_sum_w1[val2_k1_count]\n\n                if val1 < val2:\n                    low = m1\n                else:\n                    high = m2\n            \n            # Check the small remaining range (low to high)\n            for k2_val in range(low, high + 1):\n                if k2_val * 2 <= remaining_m:\n                    current_cost_w12 = prefix_sum_w2[k2_val] + prefix_sum_w1[min(len(items_w1), remaining_m - 2 * k2_val)]\n                    best_cost_w12 = max(best_cost_w12, current_cost_w12)\n\n        max_overall_cost = max(max_overall_cost, cost_w3 + best_cost_w12)\n\n    sys.stdout.write(str(max_overall_cost) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else: # w == 3\n            items_w3.append(c)\n\n    # Sort items by cost in descending order\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    # Precompute prefix sums for quick sum calculation\n    # prefix_sum_wX[k] will store the sum of costs of the k most expensive items\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_overall_cost = 0\n\n    # Iterate over the number of items of weight 3 (k3)\n    # The maximum k3 is m // 3\n    for k3 in range(len(prefix_sum_w3)):\n        cost_w3 = prefix_sum_w3[k3]\n        weight_w3 = 3 * k3\n\n        if weight_w3 > m:\n            break\n\n        remaining_m = m - weight_w3\n        \n        # Now, for the remaining_m capacity, we need to find the maximum cost\n        # using items of weight 1 and 2.\n        # This subproblem is: max_{k2} (prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2)])\n        # The function f(k2) = prefix_sum_w2[k2] + prefix_sum_w1[min(len(items_w1), remaining_m - 2*k2)] is concave.\n        # We can use ternary search to find its maximum.\n\n        low = 0\n        high = min(len(items_w2), remaining_m // 2)\n        \n        best_cost_w12 = 0\n        if low <= high: # Ensure valid range for ternary search\n            # Ternary search to find optimal k2\n            while high - low >= 3:\n                m1 = low + (high - low) // 3\n                m2 = high - (high - low) // 3\n\n                val1_k1_count = min(len(items_w1), remaining_m - 2 * m1)\n                val1 = prefix_sum_w2[m1] + prefix_sum_w1[val1_k1_count]\n\n                val2_k1_count = min(len(items_w1), remaining_m - 2 * m2)\n                val2 = prefix_sum_w2[m2] + prefix_sum_w1[val2_k1_count]\n\n                if val1 < val2:\n                    low = m1\n                else:\n                    high = m2\n            \n            # Check the small remaining range (low to high)\n            for k2_val in range(low, high + 1):\n                if k2_val * 2 <= remaining_m:\n                    current_cost_w12 = prefix_sum_w2[k2_val] + prefix_sum_w1[min(len(items_w1), remaining_m - 2 * k2_val)]\n                    best_cost_w12 = max(best_cost_w12, current_cost_w12)\n\n        max_overall_cost = max(max_overall_cost, cost_w3 + best_cost_w12)\n\n    sys.stdout.write(str(max_overall_cost) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 497,
        "completion_token_count": 7366,
        "thoughts_token_count": 5850
    }
}