{
    "start": 1758293708.8763392,
    "end": 1758293735.4239874,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score and minimize others' scores,\n    # or rather, minimize the number of people with strictly higher scores.\n    # To maximize Vasya's score, he takes the highest possible 'a' and highest possible 'b'\n    # such that a_i + b_j >= x.\n    # To minimize others' scores, we pair the remaining highest 'a' with lowest 'b', etc.\n    # But the problem is about Vasya's rank, not specific pairings.\n    # For the best rank, Vasya wants to achieve the highest possible score.\n    # The highest possible score Vasya can achieve is max(a_i + b_j) where a_i + b_j >= x.\n    # Since we can pick any a_i and any b_j, Vasya can achieve a score of a[n-1] + b[n-1].\n    # Then we count how many other people could possibly score higher than this.\n    # No one can score higher than a[n-1] + b[n-1].\n    # So if Vasya gets a[n-1] + b[n-1], his best rank is 1.\n    # This is true because the problem statement says \"If two or more participants have got the same number of points,\n    # it's up to the jury to assign places to them according to their choice.\"\n    # So if Vasya has the maximum possible score, he can always be assigned 1st place.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score (but still >= x)\n    # and maximize others' scores, or rather, maximize the number of people\n    # who could have a score greater than or equal to Vasya's chosen score.\n    # This is a matching problem. We need to find a pairing of (a_i, b_j) for all participants\n    # such that Vasya gets the worst possible rank.\n    # Vasya's chosen score (a_i + b_j) must be >= x.\n    # To maximize Vasya's rank (make it worse), we want to maximize the number of people\n    # who can achieve a score greater than or equal to Vasya's score.\n    # This means we should try to pair up all other n-1 participants such that they get high scores,\n    # and Vasya gets a relatively low score (but still >= x).\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This is a greedy approach. Sort 'a' in ascending order and 'b' in descending order.\n    # For each a_i, we want to find a b_j such that a_i + b_j >= x.\n    # If we use a two-pointer approach:\n    # Sort 'a' in ascending order.\n    # Sort 'b' in ascending order.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Let's use two pointers, `left` for `a` and `right` for `b`.\n    # `left` starts at 0, `right` starts at `n-1`.\n    # If `a[left] + b[right] >= x`, then we can form a pair.\n    # This pair is counted. We increment `left` and decrement `right`.\n    # If `a[left] + b[right] < x`, then `a[left]` cannot be paired with any remaining `b` (since `b` is sorted,\n    # and `b[right]` is the largest available). So `a[left]` cannot form a pair with any `b_j` such that `a[left] + b_j >= x`.\n    # This logic is flawed. We are counting the number of participants who can achieve a score >= x.\n    # This is not about pairing. It's about how many distinct a_i and b_j exist such that they can be paired to sum >= x.\n    # No, it's about finding *one specific pairing* of all n participants (a_i, b_j) such that Vasya gets the worst rank.\n    # This means Vasya is one of these (a_i, b_j) pairs.\n    # We want to count how many other participants could have a total score greater than or equal to Vasya's score.\n\n    # Let's consider the number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This can be found using a two-pointer approach after sorting `a` and `b`.\n    # Sort `a` in ascending order.\n    # Sort `b` in ascending order.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Let `count_ge_x` be this number.\n    # Initialize `count_ge_x = 0`.\n    # `ptr_b = n - 1` (points to largest element in `b`).\n    # For `a_i` from `0` to `n-1`:\n    #   While `ptr_b >= 0` and `a[i] + b[ptr_b] >= x`:\n    #     `ptr_b -= 1`\n    #   The number of elements `b_j` such that `a[i] + b_j >= x` is `n - 1 - ptr_b`.\n    #   This is not what we want. We need to find a unique pairing.\n\n    # This is a maximum bipartite matching type of problem.\n    # However, the problem statement says \"It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\"\n    # This means there are 'n' scores for tour 1 and 'n' scores for tour 2. We need to form 'n' pairs.\n    # We want to find a permutation `p` of `0..n-1` such that `a[i] + b[p[i]]` are the scores.\n    # Vasya is one of these pairs.\n    # To find the worst rank, we want to maximize the number of people who score >= Vasya's score.\n    # This means we want to find a pairing such that as many people as possible get a score >= x.\n    # And Vasya's score is as low as possible (but >= x).\n    # The crucial insight for this type of problem is often to fix Vasya's score.\n    # But Vasya's score is not fixed. He can be any a_i and any b_j.\n\n    # Let's re-read carefully: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we consider all possible ways to assign 'a' scores to 'b' scores to form 'n' total scores.\n    # And for each such assignment, Vasya is one of the participants.\n    # We need to find the minimum possible rank Vasya could achieve across all assignments,\n    # and the maximum possible rank Vasya could achieve across all assignments.\n\n    # For the worst rank:\n    # We want to maximize the number of participants whose score is >= Vasya's score.\n    # Consider a fixed score S that Vasya gets. S = a_i + b_j >= x.\n    # How many other participants can also get a score >= S?\n    # This is tricky because the scores are from *different* lists.\n    # We have n scores a1...an and n scores b1...bn.\n    # We need to form n pairs (a_k, b_p[k]) for some permutation p.\n    #\n    # Let's use the standard greedy approach for maximum number of pairs (a_i, b_j) where a_i + b_j >= X.\n    # Sort `a` in ascending order.\n    # Sort `b` in ascending order.\n    # Use two pointers: `ptr_a` for `a` (starts at 0), `ptr_b` for `b` (starts at `n-1`).\n    # `count = 0`\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= x`:\n    #     `count += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < x`):\n    #     This `a[ptr_a]` cannot be paired with `b[ptr_b]` to reach `x`.\n    #     Since `b` is sorted ascending, `b[ptr_b]` is the largest available `b`.\n    #     So `a[ptr_a]` cannot be paired with any `b_k` (where `k <= ptr_b`) to reach `x`.\n    #     Therefore, we must discard `a[ptr_a]` as a candidate for a pair that sums to `x`.\n    #     No, this is wrong. `a[ptr_a]` might be paired with some `b_k` if `b_k` was smaller, but we are looking for a pair >= x.\n    #     If `a[ptr_a] + b[ptr_b] < x`, then `a[ptr_a]` cannot be paired with `b[ptr_b]` to reach `x`.\n    #     This means `a[ptr_a]` also cannot be paired with any `b_k` where `k < ptr_b` to reach `x`.\n    #     So, `a[ptr_a]` cannot form a pair that sums to `x` with any of the remaining `b`s.\n    #     Thus, we must move to the next `a`: `ptr_a += 1`.\n    # This logic is correct for finding the maximum number of pairs that sum to >= x.\n    # This `count` is the maximum number of people who can achieve a score >= x.\n    # If Vasya is one of these `count` people, and he gets the lowest score among them,\n    # and the jury assigns him the worst rank among those with equal scores,\n    # then his rank would be `n - count + 1`.\n    # This is because `count` people achieve >= x. The remaining `n - count` people achieve < x.\n    # The `count` people are ranked higher than the `n - count` people.\n    # Among the `count` people, Vasya can be ranked last. So his rank is `n - count + 1`.\n\n    count_ge_x = 0\n    ptr_a = 0\n    ptr_b = n - 1\n    \n    # Create copies to avoid modifying original lists for other calculations if needed\n    a_copy = sorted(a)\n    b_copy = sorted(b)\n\n    while ptr_a < n and ptr_b >= 0:\n        if a_copy[ptr_a] + b_copy[ptr_b] >= x:\n            count_ge_x += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # If a_copy[ptr_a] + b_copy[ptr_b] < x, then a_copy[ptr_a] cannot be paired with b_copy[ptr_b]\n            # or any smaller b_k to reach sum >= x.\n            # So, we must try to pair a_copy[ptr_a] with a larger b.\n            # But we are using ptr_b from largest to smallest.\n            # This means a_copy[ptr_a] cannot be paired with any of the remaining b's (b_copy[0]...b_copy[ptr_b])\n            # to achieve a sum >= x. So, a_copy[ptr_a] must be paired with some b_k that is already \"used\"\n            # or it simply cannot achieve a sum >= x.\n            # In the context of \"maximum number of pairs (a_i, b_j) such that a_i + b_j >= x\",\n            # if a_copy[ptr_a] + b_copy[ptr_b] < x, it means that a_copy[ptr_a] is too small\n            # to be paired with even the largest available b_copy[ptr_b] to meet the condition.\n            # So, a_copy[ptr_a] cannot be used to form a pair that sums to >= x. We discard it.\n            ptr_a += 1\n\n    worst_rank = n - count_ge_x + 1\n\n    print(best_rank, worst_rank)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score and minimize others' scores,\n    # or rather, minimize the number of people with strictly higher scores.\n    # To maximize Vasya's score, he takes the highest possible 'a' and highest possible 'b'\n    # such that a_i + b_j >= x.\n    # To minimize others' scores, we pair the remaining highest 'a' with lowest 'b', etc.\n    # But the problem is about Vasya's rank, not specific pairings.\n    # For the best rank, Vasya wants to achieve the highest possible score.\n    # The highest possible score Vasya can achieve is max(a_i + b_j) where a_i + b_j >= x.\n    # Since we can pick any a_i and any b_j, Vasya can achieve a score of a[n-1] + b[n-1].\n    # Then we count how many other people could possibly score higher than this.\n    # No one can score higher than a[n-1] + b[n-1].\n    # So if Vasya gets a[n-1] + b[n-1], his best rank is 1.\n    # This is true because the problem statement says \"If two or more participants have got the same number of points,\n    # it's up to the jury to assign places to them according to their choice.\"\n    # So if Vasya has the maximum possible score, he can always be assigned 1st place.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score (but still >= x)\n    # and maximize others' scores, or rather, maximize the number of people\n    # who could have a score greater than or equal to Vasya's chosen score.\n    # This is a matching problem. We need to find a pairing of (a_i, b_j) for all participants\n    # such that Vasya gets the worst possible rank.\n    # Vasya's chosen score (a_i + b_j) must be >= x.\n    # To maximize Vasya's rank (make it worse), we want to maximize the number of people\n    # who can achieve a score greater than or equal to Vasya's score.\n    # This means we should try to pair up all other n-1 participants such that they get high scores,\n    # and Vasya gets a relatively low score (but still >= x).\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This is a greedy approach. Sort 'a' in ascending order and 'b' in descending order.\n    # For each a_i, we want to find a b_j such that a_i + b_j >= x.\n    # If we use a two-pointer approach:\n    # Sort 'a' in ascending order.\n    # Sort 'b' in ascending order.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Let's use two pointers, `left` for `a` and `right` for `b`.\n    # `left` starts at 0, `right` starts at `n-1`.\n    # If `a[left] + b[right] >= x`, then we can form a pair.\n    # This pair is counted. We increment `left` and decrement `right`.\n    # If `a[left] + b[right] < x`, then `a[left]` cannot be paired with any remaining `b` (since `b` is sorted,\n    # and `b[right]` is the largest available). So `a[left]` cannot form a pair with any `b_j` such that `a[left] + b_j >= x`.\n    # This logic is flawed. We are counting the number of participants who can achieve a score >= x.\n    # This is not about pairing. It's about how many distinct a_i and b_j exist such that they can be paired to sum >= x.\n    # No, it's about finding *one specific pairing* of all n participants (a_i, b_j) such that Vasya gets the worst rank.\n    # This means Vasya is one of these (a_i, b_j) pairs.\n    # We want to count how many other participants could have a total score greater than or equal to Vasya's score.\n\n    # Let's consider the number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This can be found using a two-pointer approach after sorting `a` and `b`.\n    # Sort `a` in ascending order.\n    # Sort `b` in ascending order.\n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Let `count_ge_x` be this number.\n    # Initialize `count_ge_x = 0`.\n    # `ptr_b = n - 1` (points to largest element in `b`).\n    # For `a_i` from `0` to `n-1`:\n    #   While `ptr_b >= 0` and `a[i] + b[ptr_b] >= x`:\n    #     `ptr_b -= 1`\n    #   The number of elements `b_j` such that `a[i] + b_j >= x` is `n - 1 - ptr_b`.\n    #   This is not what we want. We need to find a unique pairing.\n\n    # This is a maximum bipartite matching type of problem.\n    # However, the problem statement says \"It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\"\n    # This means there are 'n' scores for tour 1 and 'n' scores for tour 2. We need to form 'n' pairs.\n    # We want to find a permutation `p` of `0..n-1` such that `a[i] + b[p[i]]` are the scores.\n    # Vasya is one of these pairs.\n    # To find the worst rank, we want to maximize the number of people who score >= Vasya's score.\n    # This means we want to find a pairing such that as many people as possible get a score >= x.\n    # And Vasya's score is as low as possible (but >= x).\n    # The crucial insight for this type of problem is often to fix Vasya's score.\n    # But Vasya's score is not fixed. He can be any a_i and any b_j.\n\n    # Let's re-read carefully: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we consider all possible ways to assign 'a' scores to 'b' scores to form 'n' total scores.\n    # And for each such assignment, Vasya is one of the participants.\n    # We need to find the minimum possible rank Vasya could achieve across all assignments,\n    # and the maximum possible rank Vasya could achieve across all assignments.\n\n    # For the worst rank:\n    # We want to maximize the number of participants whose score is >= Vasya's score.\n    # Consider a fixed score S that Vasya gets. S = a_i + b_j >= x.\n    # How many other participants can also get a score >= S?\n    # This is tricky because the scores are from *different* lists.\n    # We have n scores a1...an and n scores b1...bn.\n    # We need to form n pairs (a_k, b_p[k]) for some permutation p.\n    #\n    # Let's use the standard greedy approach for maximum number of pairs (a_i, b_j) where a_i + b_j >= X.\n    # Sort `a` in ascending order.\n    # Sort `b` in ascending order.\n    # Use two pointers: `ptr_a` for `a` (starts at 0), `ptr_b` for `b` (starts at `n-1`).\n    # `count = 0`\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= x`:\n    #     `count += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < x`):\n    #     This `a[ptr_a]` cannot be paired with `b[ptr_b]` to reach `x`.\n    #     Since `b` is sorted ascending, `b[ptr_b]` is the largest available `b`.\n    #     So `a[ptr_a]` cannot be paired with any `b_k` (where `k <= ptr_b`) to reach `x`.\n    #     Therefore, we must discard `a[ptr_a]` as a candidate for a pair that sums to `x`.\n    #     No, this is wrong. `a[ptr_a]` might be paired with some `b_k` if `b_k` was smaller, but we are looking for a pair >= x.\n    #     If `a[ptr_a] + b[ptr_b] < x`, then `a[ptr_a]` cannot be paired with `b[ptr_b]` to reach `x`.\n    #     This means `a[ptr_a]` also cannot be paired with any `b_k` where `k < ptr_b` to reach `x`.\n    #     So, `a[ptr_a]` cannot form a pair that sums to `x` with any of the remaining `b`s.\n    #     Thus, we must move to the next `a`: `ptr_a += 1`.\n    # This logic is correct for finding the maximum number of pairs that sum to >= x.\n    # This `count` is the maximum number of people who can achieve a score >= x.\n    # If Vasya is one of these `count` people, and he gets the lowest score among them,\n    # and the jury assigns him the worst rank among those with equal scores,\n    # then his rank would be `n - count + 1`.\n    # This is because `count` people achieve >= x. The remaining `n - count` people achieve < x.\n    # The `count` people are ranked higher than the `n - count` people.\n    # Among the `count` people, Vasya can be ranked last. So his rank is `n - count + 1`.\n\n    count_ge_x = 0\n    ptr_a = 0\n    ptr_b = n - 1\n    \n    # Create copies to avoid modifying original lists for other calculations if needed\n    a_copy = sorted(a)\n    b_copy = sorted(b)\n\n    while ptr_a < n and ptr_b >= 0:\n        if a_copy[ptr_a] + b_copy[ptr_b] >= x:\n            count_ge_x += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # If a_copy[ptr_a] + b_copy[ptr_b] < x, then a_copy[ptr_a] cannot be paired with b_copy[ptr_b]\n            # or any smaller b_k to reach sum >= x.\n            # So, we must try to pair a_copy[ptr_a] with a larger b.\n            # But we are using ptr_b from largest to smallest.\n            # This means a_copy[ptr_a] cannot be paired with any of the remaining b's (b_copy[0]...b_copy[ptr_b])\n            # to achieve a sum >= x. So, a_copy[ptr_a] must be paired with some b_k that is already \"used\"\n            # or it simply cannot achieve a sum >= x.\n            # In the context of \"maximum number of pairs (a_i, b_j) such that a_i + b_j >= x\",\n            # if a_copy[ptr_a] + b_copy[ptr_b] < x, it means that a_copy[ptr_a] is too small\n            # to be paired with even the largest available b_copy[ptr_b] to meet the condition.\n            # So, a_copy[ptr_a] cannot be used to form a pair that sums to >= x. We discard it.\n            ptr_a += 1\n\n    worst_rank = n - count_ge_x + 1\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 3016,
        "thoughts_token_count": 0
    }
}