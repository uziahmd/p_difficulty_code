{
    "start": 1758009307.618708,
    "end": 1758009360.2982345,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Understanding the Snowflake Problem**\n\nOkay, so I need to solve this \"Rudolf and Snowflakes\" problem – the hard version, no less. Let me think this through. The core seems to be understanding the construction rules of this snowflake.  It starts with a single \"center\" vertex.  Then, in the first step, we add `k` vertices directly connected to this center. So far, so good. That gives us `1 + k` vertices.\n\nThe tricky part is the recursive step. It says that any vertex connected to only *one* other vertex then branches out to connect to another `k` vertices.  This step has to happen at least once.  Let's call the number of times we apply this rule `d`.\n\nIf `d` is 1, those initial `k` vertices each sprout another `k`, creating a layer of `k^2` new vertices. The total is now `1 + k + k^2`.  If that's the final step, then the `k^2` vertices are the \"leaves.\"\n\nIf we apply the rule again (d = 2), each of those `k^2` vertices in the second layer sprouts out another `k` vertices, adding `k^3` new vertices.  The total is now `1 + k + k^2 + k^3`.  This continues for `d` times.\n\nThe crucial observation is that this forms a geometric series.  If we apply the branching step `d` times, the total number of vertices `n` can be expressed as the sum of a geometric series: `n = 1 + k + k^2 + ... + k^(d+1)`.  The problem states that d>=1.  The largest power of k is d+1. I can simplify this using the formula for the sum of a geometric series, so `n = (k^(d+2) - 1) / (k - 1)`. That's the key.  Now, I need to figure out how to use that equation to solve the actual problem. This looks like a number theory problem in disguise.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1.  Starts with 1 central vertex.\n2.  The central vertex is connected to `k` new vertices (`k > 1`). Total vertices: `1 + k`.\n3.  This step is repeated at least once: Each vertex connected to only one other vertex is connected to `k` more new vertices.\n\nLet `d` be the number of times step 3 is performed. Since it must be done at least once, `d >= 1`.\n\nLet's trace the number of vertices:\n*   Initial vertex: 1\n*   After step 2: `k` new vertices are added. Total: `1 + k`. These `k` vertices are connected to only one other vertex.\n*   After the 1st application of step 3 (`d=1`): Each of the `k` vertices connects to `k` new vertices. Total `k * k = k^2` new vertices. Total: `1 + k + k^2`.\n*   After the 2nd application of step 3 (`d=2`): Each of the `k^2` outermost vertices connects to `k` new vertices. Total `k^2 * k = k^3` new vertices. Total: `1 + k + k^2 + k^3`.\n*   ...\n*   After the `d`-th application of step 3: `k^(d+1)` new vertices are added.\n    The total number of vertices `n` is `1 + k + k^2 + ... + k^(d+1)`.\n\nThis is a geometric series sum, which can be expressed as `n = (k^(d+2) - 1) / (k - 1)`.\nHere, `k > 1` and `d >= 1`.\nLet `m = d+1`. Since `d >= 1`, we have `m >= 2`.\nSo, `n = 1 + k + k^2 + ... + k^m`, where `m >= 2`.\nThis means `n` must be a sum of at least 3 terms (`1 + k + k^2` is the minimum).\nThe smallest possible `n` occurs for `k=2, m=2`, which is `1 + 2 + 2^2 = 7`.\nThus, `n` must be at least 7. If `n < 7`, the answer is \"NO\".\n\nWe need to check if there exist integers `k > 1` and `m >= 2` such that `n = 1 + k + ... + k^m`.\n\n**Case 1: `m = 2`**\nIn this case, `n = 1 + k + k^2`.\nRearranging, `k^2 + k + (1 - n) = 0`.\nThis is a quadratic equation for `k`. Using the quadratic formula:\n`k = (-1 ± sqrt(1 - 4 * 1 * (1 - n))) / (2 * 1)`\n`k = (-1 ± sqrt(1 - 4 + 4n)) / 2`\n`k = (-1 ± sqrt(4n - 3)) / 2`\nFor `k` to be a positive integer, `4n - 3` must be a perfect square, and `(-1 + sqrt(4n - 3))` must be an even positive number.\nLet `sqrt(4n - 3) = S`. Then `S` must be an integer.\n`k = (S - 1) / 2`.\nSince `k > 1`, `(S - 1) / 2 > 1`, which implies `S - 1 > 2`, so `S > 3`.\nWe can iterate through possible values of `n`, calculate `4n - 3`, check if it's a perfect square `S^2`, and then check if `(S - 1)` is positive and even. If so, `k = (S - 1) / 2` is a valid `k`.\n\n**Case 2: `m >= 3`**\nIn this case, `n = 1 + k + ... + k^m`.\nSince `k > 1`, we have:\n`n = 1 + k + ... + k^m > k^m`\nAlso, `n = 1 + k + ... + k^m < 1 + k + k^2 + ... + k^m + k^(m+1) + ...` (an infinite geometric series sum for `k > 1`)\n`n < sum_{i=0 to inf} k^i = 1 / (1 - k)` (This is incorrect for `k > 1`. The sum diverges.)\nA tighter bound:\n`n = 1 + k + ... + k^m`\n`n = (k^(m+1) - 1) / (k - 1)`\nSince `k >= 2`:\n`n >= 1 + 2 + 2^2 + ... + 2^m = 2^(m+1) - 1`.\nSo, `n + 1 >= 2^(m+1)`. This implies `log2(n + 1) >= m + 1`, or `m <= log2(n + 1) - 1`.\nSince `n <= 10^18`, `log2(10^18 + 1) - 1` is approximately `18 * log2(10) - 1 = 18 * 3.32 - 1 = 59.79 - 1 = 58.79`.\nSo `m` can be at most around 58.\nWe also know `n > k^m`, so `k < n^(1/m)`.\nFor `m=3`, `k < n^(1/3)`. For `n=10^18`, `k < (10^18)^(1/3) = 10^6`.\nFor `m=58`, `k < n^(1/58)`. For `n=10^18`, `k < (10^18)^(1/58) approx (10^3)^(1/58) approx 10^(3/58) approx 1.2`. This means for large `m`, `k` must be small.\nSpecifically, for `m >= 60`, `k` must be `1`, which is not allowed.\nSo, `m` ranges from `3` up to about `58`.\n\nFor each `m` in this range (`3 <= m <= 58`):\nWe need to find if there exists an integer `k > 1` such that `1 + k + ... + k^m = n`.\nThis is equivalent to solving `(k^(m+1) - 1) / (k - 1) = n` for `k`.\nThis is a polynomial equation in `k`. For a fixed `m`, `f(k) = 1 + k + ... + k^m` is a strictly increasing function for `k > 1`.\nWe can use binary search to find `k`.\nThe range for `k` is `[2, N^(1/m) + 2]`. A loose upper bound is `k < n^(1/m) + 2`.\nFor `m=3`, `k` can go up to `10^6`.\nFor `m=58`, `k` can only be `2`.\nThe binary search range for `k` can be `[2, 10^9]` (a safe upper bound, since `2^59` is already greater than `10^18`, so `k` cannot be too large if `m` is large). A tighter upper bound for `k` is `n^(1/m)`. For `m=3`, `k` can be up to `10^6`. For `m=2`, `k` can be up to `10^9`.\n\n**Algorithm:**\n\n1.  Read `n`.\n2.  **Base Case:** If `n < 7`, print \"NO\". (Because minimum snowflake is `1+2+2^2 = 7`).\n3.  **Check `m = 2`:**\n    *   Calculate `val = 4 * n - 3`.\n    *   Find `S = int(val**0.5)`.\n    *   If `S * S == val` (meaning `val` is a perfect square) AND `(S - 1)` is positive and even (i.e., `S > 1` and `S % 2 == 1`), then `k = (S - 1) / 2` is an integer `k > 1`. In this case, print \"YES\" and return.\n4.  **Check `m >= 3`:**\n    *   Iterate `m` from `3` up to `58` (inclusive).\n        *   For each `m`, perform a binary search for `k` in the range `[2, 2 * 10^9]` (a safe upper bound for `k` given `n <= 10^18` and `m >= 3`).\n        *   `low = 2`, `high = 2 * 10^9` (or `n^(1/m) + C` for a small constant `C`).\n        *   Inside binary search:\n            *   `mid = (low + high) // 2`.\n            *   Calculate `current_n = 1 + mid + mid^2 + ... + mid^m`.\n                *   Be careful with overflow: `mid^m` can exceed `10^18` quickly.\n                *   A safe way to calculate `current_n` is to sum terms iteratively, stopping if `current_n` exceeds `n` or if `mid^i` exceeds `n` (or `n/mid` for the next term) during calculation.\n            *   If `current_n == n`, then we found a valid `k` and `m`. Print \"YES\" and return.\n            *   If `current_n < n`, then `k` is too small, so `low = mid + 1`.\n            *   If `current_n > n`, then `k` is too large, so `high = mid - 1`.\n    *   If the loop finishes without finding a solution, print \"NO\".\n\n**Implementation Details for `current_n` calculation:**\n```python\ndef calculate_sum(k_val, m_val, target_n):\n    current_sum = 1\n    term = 1\n    for _ in range(m_val): # Iterate m times to get terms up to k^m\n        # Check for overflow before multiplying\n        if target_n // k_val < term: # term * k_val would exceed target_n\n            return target_n + 1 # Indicate sum is too large\n        term *= k_val\n        if target_n - current_sum < term: # current_sum + term would exceed target_n\n            return target_n + 1 # Indicate sum is too large\n        current_sum += term\n    return current_sum\n```\nThis `calculate_sum` function safely computes `1 + k + ... + k^m` and returns a value larger than `target_n` if overflow would occur or if the sum exceeds `target_n`.\n\n**Max value for `m`:**\n`2^m <= n`. For `n=10^18`, `2^m <= 10^18`.\n`m * log(2) <= 18 * log(10)`\n`m <= 18 * log(10) / log(2) = 18 * 3.3219... = 59.79...`\nSo `m` can go up to `59`.\nIf `m=59`, `k` must be `2`. `1 + 2 + ... + 2^59 = 2^60 - 1`. This is `1.15 * 10^18`.\nSo iterating `m` from `3` to `59` is sufficient.\n\nLet's refine binary search range for `k`:\n`k^m < n`. So `k < n^(1/m)`.\nFor `m=3`, `k < (10^18)^(1/3) = 10^6`.\nFor `m=59`, `k < (10^18)^(1/59)`. `2^59 approx 5.76 * 10^17`. `2^60 approx 1.15 * 10^18`.\nSo for `m=59`, `k` can only be `2`.\nThe upper bound for `k` can be `2 * 10^6` (a bit more than `10^6` for `m=3` to be safe). This is small enough.\n\nFinal check on edge cases:\n`n=1,2,3,4,5,6`: \"NO\" (handled by `n < 7` check)\n`n=7`: `4*7-3 = 25`. `S=5`. `(5-1)/2 = 2`. `k=2`. \"YES\".\n`n=13`: `4*13-3 = 49`. `S=7`. `(7-1)/2 = 3`. `k=3`. \"YES\".\n`n=15`: `m=3`. `1+k+k^2+k^3 = 15`. Try `k=2`. `1+2+4+8 = 15`. \"YES\".\nThis covers the example cases.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Minimum snowflake is 1 + 2 + 2^2 = 7\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s_sqrt = int(val**0.5)\n    \n    if s_sqrt * s_sqrt == val:\n        # Check if k is a positive integer > 1\n        if (s_sqrt - 1) % 2 == 0:\n            k_val = (s_sqrt - 1) // 2\n            if k_val > 1:\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Max m is around 59 for n=10^18 and k=2\n    # k^m < n => k < n^(1/m)\n    # For m=3, k < (10^18)^(1/3) = 10^6\n    # For m=59, k < (10^18)^(1/59) approx 2\n    # So k can be up to 10^6. A safe upper bound for k for binary search is 2 * 10^6.\n    \n    # Helper function to calculate 1 + k + ... + k^m safely\n    def calculate_sum_geometric(k, m, target_n):\n        current_sum = 1\n        term = 1\n        for _ in range(m): # Loop m times to add terms k^1 to k^m\n            # Check for overflow before multiplying term by k\n            # If term * k > target_n, then current_sum + term * k will definitely be > target_n\n            # This check is equivalent to term > target_n // k\n            if k == 1: # k must be > 1, but for safety\n                return target_n + 1\n            if term > target_n // k: \n                return target_n + 1 # Sum will exceed target_n\n            term *= k\n            \n            # Check for overflow before adding term to current_sum\n            if current_sum > target_n - term:\n                return target_n + 1 # Sum will exceed target_n\n            current_sum += term\n        return current_sum\n\n    # Iterate m from 3 to 59 (inclusive)\n    for m in range(3, 60): # m upper bound is 59 for n=10^18, k=2\n        low = 2\n        # Max possible k for given m. k^m < n => k < n^(1/m).\n        # A slightly generous upper bound for k is n^(1/m) + 2.\n        # For m=3, k_upper_bound = (10^18)^(1/3) = 10^6.\n        # For m=59, k_upper_bound = (10^18)^(1/59) is approx 2.\n        # So a fixed high value like 2*10^6 is sufficient for binary search.\n        high = 2 * 10**6 \n        \n        # If n is small, high can be smaller.\n        # E.g., if n=15, m=3, k is 2. (15)^(1/3) approx 2.4. So high should be at least 2.\n        # A safe upper bound for k is min(2*10^6, int(n**(1/m)) + 5)\n        # But 2*10^6 is fine. For small n, the loop will terminate quickly.\n        \n        found_k_for_m = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = calculate_sum_geometric(mid_k, m, n)\n            \n            if current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n\n                high = mid_k - 1\n                \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Minimum snowflake is 1 + 2 + 2^2 = 7\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s_sqrt = int(val**0.5)\n    \n    if s_sqrt * s_sqrt == val:\n        # Check if k is a positive integer > 1\n        if (s_sqrt - 1) % 2 == 0:\n            k_val = (s_sqrt - 1) // 2\n            if k_val > 1:\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Max m is around 59 for n=10^18 and k=2\n    # k^m < n => k < n^(1/m)\n    # For m=3, k < (10^18)^(1/3) = 10^6\n    # For m=59, k < (10^18)^(1/59) approx 2\n    # So k can be up to 10^6. A safe upper bound for k for binary search is 2 * 10^6.\n    \n    # Helper function to calculate 1 + k + ... + k^m safely\n    def calculate_sum_geometric(k, m, target_n):\n        current_sum = 1\n        term = 1\n        for _ in range(m): # Loop m times to add terms k^1 to k^m\n            # Check for overflow before multiplying term by k\n            # If term * k > target_n, then current_sum + term * k will definitely be > target_n\n            # This check is equivalent to term > target_n // k\n            if k == 1: # k must be > 1, but for safety\n                return target_n + 1\n            if term > target_n // k: \n                return target_n + 1 # Sum will exceed target_n\n            term *= k\n            \n            # Check for overflow before adding term to current_sum\n            if current_sum > target_n - term:\n                return target_n + 1 # Sum will exceed target_n\n            current_sum += term\n        return current_sum\n\n    # Iterate m from 3 to 59 (inclusive)\n    for m in range(3, 60): # m upper bound is 59 for n=10^18, k=2\n        low = 2\n        # Max possible k for given m. k^m < n => k < n^(1/m).\n        # A slightly generous upper bound for k is n^(1/m) + 2.\n        # For m=3, k_upper_bound = (10^18)^(1/3) = 10^6.\n        # For m=59, k_upper_bound = (10^18)^(1/59) is approx 2.\n        # So a fixed high value like 2*10^6 is sufficient for binary search.\n        high = 2 * 10**6 \n        \n        # If n is small, high can be smaller.\n        # E.g., if n=15, m=3, k is 2. (15)^(1/3) approx 2.4. So high should be at least 2.\n        # A safe upper bound for k is min(2*10^6, int(n**(1/m)) + 5)\n        # But 2*10^6 is fine. For small n, the loop will terminate quickly.\n        \n        found_k_for_m = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = calculate_sum_geometric(mid_k, m, n)\n            \n            if current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n\n                high = mid_k - 1\n                \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 4322,
        "thoughts_token_count": 784
    }
}