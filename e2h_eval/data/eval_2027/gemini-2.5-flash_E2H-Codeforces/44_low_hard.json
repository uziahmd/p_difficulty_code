{
    "start": 1758284905.9712858,
    "end": 1758284955.6294255,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Let's Tackle Polycarp's Practice!**\n\nAlright, I've got the problem: we need to divide `n` problems into `k` days to maximize the total profit. The profit of a day is simply the maximum difficulty of the problems solved on that day. My gut tells me this is a classic greedy problem.\n\nFirst, I need to fully understand the constraints. We have `n` problems, solved over `k` days, with each day tackling a contiguous set of problems. The goal is to maximize the sum of the maximum difficulty problems solved each day, and there's a limit of `2000` for both `n` and problem difficulties.\n\nLooking at the example, it makes sense. The total profit is the sum of the maximum difficulty problems solved each day. This hints at picking the biggest \"chunks\" possible.\n\nMy key insight is this: to maximize the total profit, we absolutely need to incorporate the `k` largest values from the problem array into the daily profits. If we can make each of the `k` largest difficulties the maximum for a given day, we'll get the absolute best total profit.\n\nSo, the optimal strategy would involve finding the `k` largest problem difficulties, let's say they're `M_1`, `M_2`, ..., `M_k` in descending order, and making sure that each of these values contributes to a daily profit. We can do this because all `n` problems need to be solved. If a problem is one of these `k` largest values, then it must form part of one day's contiguous problem set.\n\nThis leads to the formal solution:\n1.  Sort the problem difficulties in descending order.\n2.  The `k` largest values will be the profits for our days.\n3.  The maximum total profit is simply the sum of these `k` largest values.\n4.  But, how to divide the problems into those sets? I need to track the indices of the maximum values in the original input, because the order of the original input is important.\n\nI need a Python solution that does this efficiently. Time to write some code!\n",
    "response": "The problem asks us to distribute `n` problems, given as a list of difficulties `a_1, ..., a_n`, into `k` contiguous segments (days). Each day must solve at least one problem, and all `n` problems must be solved. The profit for a day is the maximum difficulty among problems solved that day. We want to maximize the total profit, which is the sum of daily profits. We need to output the maximum total profit and the number of problems solved each day.\n\n**Key Insight:**\nTo maximize the sum of `k` daily maximums, we should choose the `k` largest problem difficulties from the entire list `a`. Let these `k` largest difficulties be `M_1, M_2, ..., M_k`. The maximum possible total profit will be the sum `M_1 + M_2 + ... + M_k`.\n\nWhy is this true?\n1.  Each of the `k` largest difficulties `M_j` must be solved on some day.\n2.  When `M_j` is solved on a particular day, the profit for that day will be at least `M_j` (since `M_j` is one of the problems solved on that day).\n3.  Therefore, the total profit will be at least `sum(M_j for j=1 to k)`.\n4.  Can we achieve exactly `sum(M_j for j=1 to k)`? Yes, if we can arrange the segments such that each of `M_1, ..., M_k` is the *maximum* difficulty within its respective day's segment, and each `M_j` is assigned to a *different* day.\n\n**Construction Strategy:**\n1.  **Identify the `k` largest difficulties:**\n    Create a list of tuples `(difficulty, original_index)` for all problems. Sort this list in descending order of difficulty. Take the first `k` elements. These are the `k` largest difficulties.\n2.  **Calculate the maximum total profit:**\n    Sum the difficulties of these `k` problems. This is our maximum total profit.\n3.  **Determine the segment boundaries:**\n    The `k` problems identified in step 1 are crucial. Their original indices will define the \"split points\" for our `k` days.\n    Let the original indices of these `k` problems be `idx_1, idx_2, ..., idx_k`. Sort these indices in ascending order: `sorted_idx_1 < sorted_idx_2 < ... < sorted_idx_k`.\n    These indices represent the positions of the `k` largest elements in the original array. We can make sure each of these elements becomes the maximum for one day by making it the *last* problem solved on its day, or simply ensuring it's part of a segment where it's the maximum.\n    A simple way to achieve this is to make each of these `k` problems the *last problem* of a day's segment, except for the very last problem of the last day.\n    \n    Specifically, the `k-1` smallest indices among `sorted_idx_1, ..., sorted_idx_k` will be our split points.\n    *   Day 1 ends at `sorted_idx_1`.\n    *   Day 2 ends at `sorted_idx_2`.\n    *   ...\n    *   Day `k-1` ends at `sorted_idx_{k-1}`.\n    *   Day `k` ends at `n-1` (the last problem).\n\n    The number of problems for each day `t_j` can then be calculated:\n    *   `t_1 = sorted_idx_1 + 1` (problems from index 0 to `sorted_idx_1`)\n    *   `t_2 = sorted_idx_2 - sorted_idx_1` (problems from `sorted_idx_1 + 1` to `sorted_idx_2`)\n    *   ...\n    *   `t_{k-1} = sorted_idx_{k-1} - sorted_idx_{k-2}` (problems from `sorted_idx_{k-2} + 1` to `sorted_idx_{k-1}`)\n    *   `t_k = n - sorted_idx_{k-1}` (problems from `sorted_idx_{k-1} + 1` to `n-1`)\n\n    This strategy ensures that each of the `k` largest problems `a[sorted_idx_j]` is included in a segment. Since these are the overall `k` largest problems, and we are splitting *around* them, it is highly likely they will be the maximums in their respective segments. Even if a segment contains a larger value (which is impossible if we picked the `k` largest), or another of the `k` largest values, the sum of maximums will still be maximized. The key is that the sum of the `k` largest values is an upper bound, and this construction achieves it.\n\n**Example Walkthrough:**\n`n = 8, k = 3`\n`a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Problems with indices:**\n    `[(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\n\n2.  **Sort by difficulty (descending) and take top `k=3`:**\n    `[(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)]`\n    Top 3 are `(9,6), (6,3), (5,0)`.\n    Maximum total profit = `9 + 6 + 5 = 20`.\n\n3.  **Original indices of these top 3:**\n    `6, 3, 0`\n\n4.  **Sort these indices:**\n    `0, 3, 6`\n    These are `sorted_idx_1=0`, `sorted_idx_2=3`, `sorted_idx_3=6`.\n\n5.  **Calculate daily problem counts `t_j`:**\n    We need `k-1 = 2` split points. These are `sorted_idx_1` and `sorted_idx_2`.\n    *   `t_1`: problems from index 0 up to `sorted_idx_1` (inclusive).\n        `t_1 = sorted_idx_1 + 1 = 0 + 1 = 1`.\n        Problems: `[5]` (index 0). Max profit: 5.\n    *   `t_2`: problems from `sorted_idx_1 + 1` up to `sorted_idx_2` (inclusive).\n        `t_2 = sorted_idx_2 - sorted_idx_1 = 3 - 0 = 3`.\n        Problems: `[4, 2, 6]` (indices 1, 2, 3). Max profit: 6.\n    *   `t_3`: problems from `sorted_idx_2 + 1` up to `n-1` (inclusive).\n        `t_3 = n - (sorted_idx_2 + 1) = 8 - (3 + 1) = 4`.\n        Problems: `[5, 1, 9, 2]` (indices 4, 5, 6, 7). Max profit: 9.\n\n    Resulting `t` values: `[1, 3, 4]`.\n    Total profit: `5 + 6 + 9 = 20`.\n\n    The example output was `3 2 3`. My derived `t` values are `1 3 4`. Both yield 20. This shows there can be multiple valid distributions. The problem statement says \"If there are many possible answers, you may print any of them.\"\n\n    Let's refine the split points. Instead of `sorted_idx_j` being the *last* problem of day `j`, let's just use them as general split points to divide the problems into `k` groups. The `k-1` smallest indices among `sorted_idx_1, ..., sorted_idx_k` will be the actual split points.\n    \n    Indices of top k values: `0, 3, 6`.\n    We need `k-1 = 2` split points. The first `k-1` sorted indices are `0, 3`.\n    The split points are `0` and `3`. This means day 1 ends at index `0`, day 2 ends at index `3`, and day 3 ends at index `7` (the end of the array).\n    \n    *   Day 1: problems `a[0]` to `a[0]`. Count: `0 - (-1) = 1`. (`t_1 = indices[0] - (-1)`)\n    *   Day 2: problems `a[1]` to `a[3]`. Count: `3 - 0 = 3`. (`t_2 = indices[1] - indices[0]`)\n    *   Day 3: problems `a[4]` to `a[7]`. Count: `7 - 3 = 4`. (`t_3 = n-1 - indices[1]`)\n    \n    This gives `[1, 3, 4]`. This is still different from the example.\n    \n    The example output `3 2 3` implies splits after indices `2` and `4`.\n    `[5, 4, 2]` (max 5) - index 2\n    `[6, 5]` (max 6) - index 4\n    `[1, 9, 2]` (max 9) - index 7\n    The problems `a[2]=2`, `a[4]=5`, `a[7]=2` are the last problems of each segment. The *profit* values are `a[0]=5`, `a[3]=6`, `a[6]=9`.\n    The example's split points (indices where segments end) are `2, 4, 7`.\n    The *indices of the maximums* for each day are `0, 3, 6`.\n    \n    The crucial observation is that the `k` largest values *must* be the daily maximums. We just need to ensure each of these `k` values is the maximum in its *own* segment.\n    \n    Let's use the indices of the `k` largest problems `(val, original_idx)`.\n    `[(9,6), (6,3), (5,0)]`. The indices are `0, 3, 6`.\n    Sort these indices: `[0, 3, 6]`.\n    \n    These `k` values must each be the maximum of a day. The simplest way to achieve this is to make cuts *after* each of the first `k-1` sorted indices, and the last cut after the `n-1` problem.\n    \n    `split_indices = sorted([idx for val, idx in top_k_problems])`\n    `split_indices = [0, 3, 6]`\n    \n    The cuts will be at `split_indices[0]`, `split_indices[1]`, ..., `split_indices[k-2]`. The last day will take everything from `split_indices[k-1]` to `n-1`.\n    \n    Let `prev_idx = -1`.\n    `t_values = []`\n    For `j` from `0` to `k-2`:\n        `current_idx = split_indices[j]`\n        `t_j = current_idx - prev_idx`\n        `t_values.append(t_j)`\n        `prev_idx = current_idx`\n    \n    The last day: `t_k = n - (prev_idx + 1)`. Wait, this logic is incorrect for the last day.\n    \n    Better logic for `t_j`:\n    `split_indices = sorted([idx for val, idx in top_k_problems])`\n    `t_values = []`\n    `last_end_idx = -1`\n    For `j` from `0` to `k-2`:\n        `current_end_idx = split_indices[j]`\n        `t_j = current_end_idx - last_end_idx`\n        `t_values.append(t_j)`\n        `last_end_idx = current_end_idx`\n    \n    `t_k = n - (last_end_idx + 1)`\n    This calculates the number of problems from `last_end_idx + 1` to `n-1`.\n    \n    Let's re-run for `n=8, k=3`, `a = [5, 4, 2, 6, 5, 1, 9, 2]`\n    `top_k_problems = [(9,6), (6,3), (5,0)]`\n    `split_indices = sorted([6, 3, 0]) = [0, 3, 6]`\n    \n    `last_end_idx = -1`\n    `t_values = []`\n    \n    `j=0`: `current_end_idx = split_indices[0] = 0`\n        `t_0 = 0 - (-1) = 1`. `t_values = [1]`. `last_end_idx = 0`.\n    `j=1`: `current_end_idx = split_indices[1] = 3`\n        `t_1 = 3 - 0 = 3`. `t_values = [1, 3]`. `last_end_idx = 3`.\n        \n    (Loop ends as `j` goes from `0` to `k-2 = 1`)\n    \n    `t_k = n - (last_end_idx + 1)`. This is `t_2` in 0-indexed terms.\n    `t_2 = 8 - (3 + 1) = 4`. `t_values = [1, 3, 4]`.\n    \n    This still gives `[1, 3, 4]`. The example `[3, 2, 3]` uses different split points.\n    The example's split points are at indices `2, 4, 7`.\n    The crucial part is that the `k` largest elements `a[0]=5, a[3]=6, a[6]=9` are indeed the maximums in their respective segments.\n    \n    The strategy:\n    1.  Find the `k` largest values and their original indices.\n    2.  Sum these values for the total profit.\n    3.  Sort the *indices* of these `k` largest values.\n    4.  These sorted indices (let's call them `p_0, p_1, ..., p_{k-1}`) define `k` segments.\n        The first `k-1` segments end at `p_0, p_1, ..., p_{k-2}`.\n        The `k`-th segment ends at `n-1`.\n        \n        The number of problems for day `j` (0-indexed):\n        `t_0 = p_0 + 1`\n        `t_1 = p_1 - p_0`\n        ...\n        `t_{k-2} = p_{k-2} - p_{k-3}`\n        `t_{k-1} = n - 1 - p_{k-2}` (this is the number of problems from `p_{k-2}+1` to `n-1`)\n        \n        This strategy ensures that each of the `k` largest problems is the *last problem* of one of the first `k-1` segments, or part of the last segment. This is not quite right.\n        \n        The correct way to use the `k` sorted indices `p_0, p_1, ..., p_{k-1}`:\n        These are the indices of the problems that contribute to the profit. We need to make sure each of these problems is the maximum in its day's segment.\n        The simplest way to do this is to make cuts *after* `k-1` of these problems.\n        \n        Let `P = sorted([idx for val, idx in top_k_problems])`.\n        `P = [0, 3, 6]` for the example.\n        \n        The splits should be after `P[0]`, `P[1]`, ..., `P[k-2]`.\n        \n        `prev_idx = -1`\n        `ans_t = []`\n        For `i` from `0` to `k-2`:\n            `current_idx = P[i]`\n            `ans_t.append(current_idx - prev_idx)`\n            `prev_idx = current_idx`\n        \n        The last day: `ans_t.append(n - 1 - prev_idx)`\n        \n        Let's try this for `n=8, k=3`, `a = [5, 4, 2, 6, 5, 1, 9, 2]`\n        `P = [0, 3, 6]`\n        `prev_idx = -1`\n        `ans_t = []`\n        \n        `i=0`: `current_idx = P[0] = 0`\n            `ans_t.append(0 - (-1)) = 1`. `ans_t = [1]`. `prev_idx = 0`.\n        `i=1`: `current_idx = P[1] = 3`\n            `ans_t.append(3 - 0) = 3`. `ans_t = [1, 3]`. `prev_idx = 3`.\n            \n        Loop ends. `k-2 = 1`.\n        \n        Last day: `ans_t.append(n - 1 - prev_idx) = ans_t.append(8 - 1 - 3) = ans_t.append(4)`.\n        `ans_t = [1, 3, 4]`.\n        \n        This is a valid distribution that yields the maximum profit. The problem states \"If there are many possible answers, you may print any of them.\" So `[1, 3, 4]` is a perfectly fine answer.\n\n**Algorithm Steps:**\n1.  Read `n` and `k`.\n2.  Read the list of difficulties `a`.\n3.  Create a list of tuples `(difficulty, index)` for each problem: `problems = [(a[i], i) for i in range(n)]`.\n4.  Sort `problems` in descending order based on difficulty.\n5.  Take the first `k` elements from the sorted list. These represent the `k` largest problems.\n6.  Calculate the `total_profit` by summing the difficulties of these `k` problems.\n7.  Extract the original indices of these `k` problems and store them in a list `split_indices`.\n8.  Sort `split_indices` in ascending order.\n9.  Initialize `t_values = []` and `last_end_idx = -1`.\n10. Iterate from `j = 0` to `k-2`:\n    a.  `current_end_idx = split_indices[j]`\n    b.  `t_values.append(current_end_idx - last_end_idx)`\n    c.  `last_end_idx = current_end_idx`\n11. For the last day, append `n - 1 - last_end_idx` to `t_values`.\n12. Print `total_profit`.\n13. Print `t_values` separated by spaces.\n\n**Constraints Check:**\n*   `n, k <= 2000`: Sorting `n` elements takes `O(n log n)`. Extracting `k` elements and sorting `k` indices takes `O(k log k)`. All operations are well within time limits. `2000 * log(2000)` is roughly `2000 * 11 = 22000`, which is very fast.\n*   `a_i <= 2000`: Sum of difficulties `k * 2000` could be `2000 * 2000 = 4 * 10^6`, fits in standard integer types.\n\nLet's double-check the example `4 2 \\n 1 2000 2000 2`.\n`n=4, k=2`, `a = [1, 2000, 2000, 2]`\n1.  `problems = [(1,0), (2000,1), (2000,2), (2,3)]`\n2.  Sorted by difficulty (descending): `[(2000,1), (2000,2), (2,3), (1,0)]`\n3.  Top `k=2` problems: `[(2000,1), (2000,2)]`\n4.  `total_profit = 2000 + 2000 = 4000`.\n5.  Original indices: `[1, 2]`\n6.  `split_indices = sorted([1, 2]) = [1, 2]`\n7.  `last_end_idx = -1`, `t_values = []`\n8.  Loop `j=0` to `k-2 = 0`:\n    `j=0`: `current_end_idx = split_indices[0] = 1`\n        `t_values.append(1 - (-1)) = 2`. `t_values = [2]`. `last_end_idx = 1`.\n9.  Last day: `t_values.append(n - 1 - last_end_idx) = t_values.append(4 - 1 - 1) = t_values.append(2)`.\n    `t_values = [2, 2]`.\n10. Output:\n    `4000`\n    `2 2`\nThis matches the example output. The logic seems correct.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create a list of (difficulty, original_index) tuples\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # Step 2: Sort problems by difficulty in descending order\n    # If difficulties are equal, the order of indices doesn't matter for profit,\n    # but sorting by index might provide a consistent split.\n    # Python's sort is stable, so if difficulties are equal, original order is preserved.\n    # To ensure consistent behavior and potentially earlier splits for larger values,\n    # we can explicitly sort by difficulty (desc) then index (asc).\n    problems_with_indices.sort(key=lambda x: (-x[0], x[1]))\n\n    # Step 3: Select the top k problems\n    top_k_problems = problems_with_indices[:k]\n\n    # Step 4: Calculate the total profit\n    total_profit = sum(p[0] for p in top_k_problems)\n\n    # Step 5: Get the original indices of these top k problems and sort them\n    split_indices = sorted([p[1] for p in top_k_problems])\n\n    # Step 6: Determine the number of problems for each day\n    # The split_indices define the points AFTER which a day's problems end.\n    # For example, if split_indices = [0, 3, 6] for k=3:\n    # Day 1 ends at index 0. Problems: a[0]. Count = 1.\n    # Day 2 ends at index 3. Problems: a[1]...a[3]. Count = 3.\n    # Day 3 ends at index n-1. Problems: a[4]...a[n-1]. Count = n-1-3 = n-4.\n    \n    t_values = []\n    last_end_idx = -1 # Represents the index of the last problem solved on the previous day\n\n    # The first k-1 split_indices define the end points for the first k-1 days\n    for i in range(k - 1):\n        current_end_idx = split_indices[i]\n        problems_count = current_end_idx - last_end_idx\n        t_values.append(problems_count)\n        last_end_idx = current_end_idx\n\n    # The last day takes all remaining problems\n    # It starts from last_end_idx + 1 and goes up to n-1\n    problems_count = n - 1 - last_end_idx\n    t_values.append(problems_count)\n\n    # Print the results\n    sys.stdout.write(str(total_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, t_values)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create a list of (difficulty, original_index) tuples\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # Step 2: Sort problems by difficulty in descending order\n    # If difficulties are equal, the order of indices doesn't matter for profit,\n    # but sorting by index might provide a consistent split.\n    # Python's sort is stable, so if difficulties are equal, original order is preserved.\n    # To ensure consistent behavior and potentially earlier splits for larger values,\n    # we can explicitly sort by difficulty (desc) then index (asc).\n    problems_with_indices.sort(key=lambda x: (-x[0], x[1]))\n\n    # Step 3: Select the top k problems\n    top_k_problems = problems_with_indices[:k]\n\n    # Step 4: Calculate the total profit\n    total_profit = sum(p[0] for p in top_k_problems)\n\n    # Step 5: Get the original indices of these top k problems and sort them\n    split_indices = sorted([p[1] for p in top_k_problems])\n\n    # Step 6: Determine the number of problems for each day\n    # The split_indices define the points AFTER which a day's problems end.\n    # For example, if split_indices = [0, 3, 6] for k=3:\n    # Day 1 ends at index 0. Problems: a[0]. Count = 1.\n    # Day 2 ends at index 3. Problems: a[1]...a[3]. Count = 3.\n    # Day 3 ends at index n-1. Problems: a[4]...a[n-1]. Count = n-1-3 = n-4.\n    \n    t_values = []\n    last_end_idx = -1 # Represents the index of the last problem solved on the previous day\n\n    # The first k-1 split_indices define the end points for the first k-1 days\n    for i in range(k - 1):\n        current_end_idx = split_indices[i]\n        problems_count = current_end_idx - last_end_idx\n        t_values.append(problems_count)\n        last_end_idx = current_end_idx\n\n    # The last day takes all remaining problems\n    # It starts from last_end_idx + 1 and goes up to n-1\n    problems_count = n - 1 - last_end_idx\n    t_values.append(problems_count)\n\n    # Print the results\n    sys.stdout.write(str(total_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, t_values)) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 972,
        "completion_token_count": 5827,
        "thoughts_token_count": 760
    }
}