{
    "start": 1758009311.5470006,
    "end": 1758009371.655371,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**My Approach to the Rudolf and Snowflakes Problem**\n\nOkay, so I'm tackling the \"Rudolf and Snowflakes (hard version)\" problem. The core of this seems to be understanding the structure and evolution of these snowflakes. Let's break it down.\n\nFirst, we start with a central vertex. Then, we connect it to `k` new vertices, where `k` has to be greater than 1. So, at this point, we have a total of `1 + k` vertices.\n\nThe crucial part is the next rule: \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices.\" This has to happen *at least* once. This feels like the recursive step of building the snowflake.\n\nI'm thinking, let's track the number of vertices after applying this \"subsequent step\" `d` times.\n\nIf we apply it zero times, we are just at the first step `1 + k`. But the problem says \"This step should be done at least once,\" so this is our base case for the formula.\n\nAt depth 1 (one application of the step), we add `k` new vertices connected to the initial `k` leaves, giving us `1 + k + k^2` vertices. Continuing the pattern, for depth `d`, we'll have `1 + k + k^2 + ... + k^d` vertices. This is a geometric series! The sum simplifies to `(k^(d+1) - 1) / (k - 1)`.\n\nSo, the problem boils down to checking if a given number `n` can be expressed in this form. We know that `k > 1` and `d >= 1`. The constraint `n <= 10^18` is important for choosing an efficient algorithm. I'll need to figure out how to efficiently check if an `n` fits this formula. Now the task is designing an elegant and performant Python script.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" structure. A snowflake is defined by a central vertex, which is connected to `k` new vertices (`k > 1`). Then, each vertex that is connected to only one other vertex (i.e., a leaf) is connected to `k` more new vertices. This last step must be done at least once.\n\nLet's analyze the structure of a snowflake:\n1.  **Initial vertex:** 1 central vertex.\n2.  **First layer:** The central vertex connects to `k` new vertices. Total vertices: `1 + k`. These `k` vertices are leaves.\n3.  **Second layer (first application of the \"subsequent step\"):** Each of the `k` leaves from the first layer connects to `k` new vertices. This adds `k * k = k^2` new vertices. Total vertices: `1 + k + k^2`. These `k^2` vertices are now leaves.\n4.  **Third layer (second application of the \"subsequent step\"):** Each of the `k^2` leaves from the second layer connects to `k` new vertices. This adds `k^2 * k = k^3` new vertices. Total vertices: `1 + k + k^2 + k^3`. These `k^3` vertices are now leaves.\n\nIf this \"subsequent step\" (connecting `k` new vertices to each leaf) is applied `d` times, the total number of vertices will be `1 + k + k^2 + ... + k^(d+1)`.\nThis is a geometric series sum, which can be written as `(k^(d+2) - 1) / (k - 1)`.\n\nThe problem states \"This step should be done at least once.\" This means `d` must be at least 1. So, the number of terms in the sum `1 + k + ... + k^(d+1)` must be at least 3 (1 center + 1st layer + 2nd layer).\nLet `D = d+1`. Then `D >= 2`.\nThe total number of vertices `n` must be of the form `1 + k + k^2 + ... + k^D` where `k > 1` and `D >= 2`.\nThis sum is equal to `(k^(D+1) - 1) / (k - 1)`.\n\nWe need to check if a given `n` (`1 <= n <= 10^18`) can be represented in this form.\n\n**Case 1: `D = 2`**\n`n = 1 + k + k^2`.\nThis is a quadratic equation: `k^2 + k + (1 - n) = 0`.\nWe can solve for `k` using the quadratic formula: `k = (-1 +/- sqrt(1 - 4 * (1 - n))) / 2`.\n`k = (-1 +/- sqrt(1 - 4 + 4n)) / 2 = (-1 +/- sqrt(4n - 3)) / 2`.\nFor `k` to be a positive integer, `4n - 3` must be a perfect square, and `sqrt(4n - 3)` must be of the form `2m + 1` for some integer `m >= 1` (since `k > 1`).\nSo, we can check if `4n - 3` is a perfect square. Let `s = int(sqrt(4n - 3))`. If `s * s == 4n - 3` and `s >= 3` (to ensure `k >= 1` and `s` is odd), then `k = (s - 1) / 2` will be an integer `k >= 1`.\nSince `k > 1`, we need `(s-1)/2 > 1`, which means `s-1 > 2`, so `s > 3`.\nIf `s=3`, `k=1`, which is not allowed. So `s` must be at least 5.\nThis condition covers the `D=2` case.\n\n**Case 2: `D >= 3`**\n`n = 1 + k + k^2 + ... + k^D`.\nSince `k > 1`, `k` must be at least 2.\nIf `k = 2`, `n = 1 + 2 + 2^2 + ... + 2^D = 2^(D+1) - 1`.\nWe can check if `n+1` is a power of 2. If `n+1` is a power of 2, say `2^X`, then `D+1 = X`, so `D = X-1`. If `D >= 3`, then `X-1 >= 3`, so `X >= 4`. This means `n+1` must be `2^X` for `X >= 4`.\n\nIf `k >= 2` and `D >= 3`:\n`n = 1 + k + ... + k^D`.\nWe know `k^D < n`. So `k < n^(1/D)`.\nSince `D >= 3`, `k < n^(1/3)`.\nFor `n = 10^18`, `n^(1/3) = (10^18)^(1/3) = 10^6`.\nSo, `k` can range from `2` up to `10^6`.\nWe can iterate `k` from `2` up to `10^6`. For each `k`, we need to find if there's a `D >= 3` such that `n = (k^(D+1) - 1) / (k - 1)`.\nThis is equivalent to `n * (k - 1) + 1 = k^(D+1)`.\nLet `target = n * (k - 1) + 1`. We need to check if `target` is a perfect power of `k`, specifically `k^(D+1)` where `D+1 >= 4` (since `D >= 3`).\nWe can use binary search or `pow(target, 1.0/(D+1))` to find `k`.\nHowever, it's simpler to iterate `k` and for each `k`, compute powers of `k`: `1, k, k^2, k^3, ...` and sum them up until the sum exceeds `n` or equals `n`.\n`current_sum = 1`\n`current_power_of_k = 1`\n`D_count = 0` (represents the exponent of k, starting from k^0)\nLoop:\n  `current_power_of_k *= k`\n  `current_sum += current_power_of_k`\n  `D_count += 1`\n  If `current_sum == n` and `D_count >= 2` (equivalent to `D >= 2` in the formula `1 + k + ... + k^D`), then `n` is a snowflake number.\n  If `current_sum > n`, break the loop.\n  Careful with overflow: `current_power_of_k` or `current_sum` can exceed `10^18`. We must check for overflow before addition/multiplication.\n  `current_power_of_k > n` would mean `current_sum` will definitely be `> n` after adding.\n  `current_power_of_k > n / k` implies `current_power_of_k * k` would overflow `n`.\n  `current_sum > n - current_power_of_k` implies `current_sum + current_power_of_k` would overflow `n`.\n\n**Optimization for `D >= 3`:**\nInstead of iterating `k` and then `D`, we can iterate `D` and for each `D`, find `k`.\nFor `n = 1 + k + ... + k^D`, we know `k^D < n`. So `k < n^(1/D)`.\nAlso, `n = 1 + k + ... + k^D > k^D`.\nAnd `n = 1 + k + ... + k^D < 1 + k + ... + k^D + k^(D+1) + ... = k^(D+1) / (k-1)`.\nSo `k^D < n < k^(D+1) / (k-1)`.\nFor `k=2`, `n < 2^(D+1)`. So `D+1 > log2(n)`, `D > log2(n) - 1`.\nFor `n = 10^18`, `log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79`.\nSo `D` can go up to about 60.\nWe can iterate `D` from `3` up to `60`. For each `D`, we need to find an integer `k > 1` such that `n = (k^(D+1) - 1) / (k - 1)`.\nThis means `n(k-1) = k^(D+1) - 1`.\nThis equation `k^(D+1) - n*k + (n-1) = 0` can be solved for `k` using binary search.\nFor a fixed `D`, we are looking for `k` in the range `[2, floor(n^(1/D))]`.\nLet `f(k) = 1 + k + ... + k^D`. This function is monotonically increasing for `k > 1`.\nWe can binary search for `k` in the range `[2, 10^6]` (the maximum possible `k` for `D=3`).\nFor `D=3`, `k` up to `10^6`.\nFor `D=4`, `k` up to `(10^18)^(1/4) = 10^(4.5) approx 31622`.\nFor `D=59`, `k` up to `(10^18)^(1/59) approx 2`.\nThe maximum `k` decreases rapidly as `D` increases. The upper bound for `k` is `n^(1/D)`.\nThe maximum `D` is `log2(n)` approximately 60.\nSo, we can iterate `D` from `3` to `60`. For each `D`, binary search for `k` in the range `[2, floor(n^(1/D)) + 2]`. The `+2` is a safe upper bound. `n^(1/D)` can be computed as `round(n**(1/D))`.\n\n**Algorithm:**\n1.  Handle `n=1, 2, 3, 4, 5, 6` manually or check edge cases.\n    *   `n=1,2,3,4,5,6`: NO. (Smallest snowflake `1+k+k^2` for `k=2` is `1+2+4=7`).\n2.  **Check `D=2` case:**\n    *   Calculate `val = 4n - 3`.\n    *   If `val < 0`, no solution.\n    *   Calculate `s = int(val**0.5)`.\n    *   If `s * s == val` and `s > 3` (to ensure `k > 1`), then `n` is a snowflake number. Output \"YES\".\n3.  **Check `D >= 3` cases:**\n    *   Iterate `D` from `3` up to `60` (or `64` to be safe, `log2(10^18)` is about 59.79).\n    *   For each `D`, perform a binary search for `k` in the range `[2, floor(n**(1/D)) + 2]`. Let `low = 2`, `high = min(int(n**(1.0/D)) + 2, 10**6 + 7)`. The `10^6+7` is a conservative upper bound for `k` when `D=3`.\n    *   Inside the binary search:\n        *   `mid = (low + high) // 2`.\n        *   Calculate `current_sum = 1 + mid + mid^2 + ... + mid^D`.\n        *   Be careful with overflow while calculating `current_sum`.\n            *   Initialize `current_sum = 1`.\n            *   Initialize `term = 1`.\n            *   Loop `i` from `1` to `D`:\n                *   If `term > n / mid` (potential overflow for `term * mid`), break and set `current_sum = n + 1` (to signify overflow).\n                *   `term *= mid`.\n                *   If `current_sum > n - term` (potential overflow for `current_sum + term`), break and set `current_sum = n + 1`.\n                *   `current_sum += term`.\n        *   If `current_sum == n`, then `n` is a snowflake number. Output \"YES\" and return.\n        *   If `current_sum < n`, then `k` is too small, so `low = mid + 1`.\n        *   If `current_sum > n`, then `k` is too large, so `high = mid - 1`.\n4.  If after all checks, `n` is not found, output \"NO\".\n\n**Example walkthrough for `n = 13`:**\n1.  `D=2` check: `4*13 - 3 = 52 - 3 = 49`. `sqrt(49) = 7`. `s = 7`. `s*s == 49` is true. `s > 3` is true.\n    `k = (7 - 1) / 2 = 3`.\n    Since `k=3 > 1`, `n=13` is a snowflake number (`1 + 3 + 3^2 = 1 + 3 + 9 = 13`). Output \"YES\".\n\n**Example walkthrough for `n = 255`:**\n1.  `D=2` check: `4*255 - 3 = 1020 - 3 = 1017`. `sqrt(1017)` is not an integer (`31^2=961, 32^2=1024`). So `D=2` fails.\n2.  `D >= 3` check:\n    Try `D=3`: Binary search `k` in `[2, floor(255^(1/3)) + 2] = [2, 6+2] = [2, 8]`.\n        `low=2, high=8`.\n        `mid=5`. `1+5+5^2+5^3 = 1+5+25+125 = 156`. `156 < 255`. `low = 6`.\n        `low=6, high=8`.\n        `mid=7`. `1+7+7^2+7^3 = 1+7+49+343 = 400`. `400 > 255`. `high = 6`.\n        `low=6, high=6`.\n        `mid=6`. `1+6+6^2+6^3 = 1+6+36+216 = 259`. `259 > 255`. `high = 5`.\n        `low=6, high=5`. Loop terminates. No `k` for `D=3`.\n    Try `D=4`: Binary search `k` in `[2, floor(255^(1/4)) + 2] = [2, 3+2] = [2, 5]`.\n        `low=2, high=5`.\n        `mid=3`. `1+3+3^2+3^3+3^4 = 1+3+9+27+81 = 121`. `121 < 255`. `low = 4`.\n        `low=4, high=5`.\n        `mid=4`. `1+4+4^2+4^3+4^4 = 1+4+16+64+256 = 341`. `341 > 255`. `high = 3`.\n        `low=4, high=3`. Loop terminates. No `k` for `D=4`.\n    Try `D=5`: Binary search `k` in `[2, floor(255^(1/5)) + 2] = [2, 3+2] = [2, 5]`.\n        `low=2, high=5`.\n        `mid=3`. `1+3+...+3^5 = 121 + 3^5 = 121+243 = 364`. `364 > 255`. `high = 2`.\n        `low=2, high=2`.\n        `mid=2`. `1+2+2^2+2^3+2^4+2^5 = 1+2+4+8+16+32 = 63`. `63 < 255`. `low = 3`.\n        `low=3, high=2`. Loop terminates. No `k` for `D=5`.\n    ...\n    Wait, `n = 255` is `2^8 - 1`.\n    So `n+1 = 256 = 2^8`. This means `D+1 = 8`, so `D=7` for `k=2`.\n    Let's recheck the binary search for `D=7`:\n    `n = 1 + k + ... + k^7`.\n    Binary search `k` in `[2, floor(255^(1/7)) + 2] = [2, 2+2] = [2, 4]`.\n        `low=2, high=4`.\n        `mid=3`. `1+3+...+3^7`. `3^7 = 2187`. Sum will be very large. `current_sum > n`. `high = 2`.\n        `low=2, high=2`.\n        `mid=2`. `1+2+2^2+...+2^7 = 2^8 - 1 = 256 - 1 = 255`. `current_sum == n`. Output \"YES\".\n\nThis approach covers all cases. The maximum value of `D` is small (around 60), and for each `D`, the binary search range for `k` is also small (`10^6` at most for `D=3`, and decreases quickly). The calculation of `current_sum` inside the binary search is `O(D)`. So, total time complexity is roughly `D_max * log(k_max) * D_max`, which is `60 * log(10^6) * 60` or `60 * 20 * 60` which is efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: n = 1 + k + k^2 (D=2, where D is the max exponent of k)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    # Check if 4n - 3 is a perfect square\n    val = 4 * n - 3\n    if val >= 0:\n        s = int(val**0.5)\n        if s * s == val:\n            # For k to be an integer, s must be odd.\n            # If s is odd, s-1 is even, so (s-1)/2 is an integer.\n            # k > 1 implies (s-1)/2 > 1, so s-1 > 2, s > 3.\n            if s > 3 and (s - 1) % 2 == 0:\n                print(\"YES\")\n                return\n\n    # Case 2: n = 1 + k + k^2 + ... + k^D where D >= 3\n    # k must be at least 2.\n    # Maximum D: For k=2, n = 2^(D+1) - 1.\n    # n <= 10^18, so 2^(D+1) - 1 <= 10^18 => 2^(D+1) <= 10^18 + 1\n    # D+1 <= log2(10^18 + 1) approx 59.79. So D+1 max ~59. D max ~58.\n    # Let's use D from 3 to 60 for safety.\n    \n    # Iterate D (exponent)\n    for D in range(3, 61): # D is the max exponent, so sum has D+1 terms\n        # Binary search for k\n        # k must be at least 2.\n        # k^D < n => k < n^(1/D)\n        # Upper bound for k: n^(1/D) + a small constant.\n        # Max k for D=3: (10^18)^(1/3) = 10^6.\n        low = 2\n        high = int(n**(1.0/D)) + 2 # Add a small buffer, e.g. 2\n        \n        # Cap high to prevent excessively large numbers, max k is 10^6 for D=3\n        high = min(high, 10**6 + 7) \n\n        while low <= high:\n            k = (low + high) // 2\n            if k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            current_term = 1\n            \n            # Calculate sum = 1 + k + k^2 + ... + k^D\n            # Check for overflow at each step\n            overflow = False\n            for _ in range(D): # D iterations to get up to k^D\n                if current_term > n // k: # Check if current_term * k would overflow n\n                    overflow = True\n                    break\n                current_term *= k\n                if current_sum > n - current_term: # Check if current_sum + current_term would overflow n\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow:\n                # If sum overflows or is too large, this k is too big\n                high = k - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                # k is too small, try larger k\n                low = k + 1\n            else: # current_sum > n\n                # k is too large, try smaller k\n                high = k - 1\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: n = 1 + k + k^2 (D=2, where D is the max exponent of k)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    # Check if 4n - 3 is a perfect square\n    val = 4 * n - 3\n    if val >= 0:\n        s = int(val**0.5)\n        if s * s == val:\n            # For k to be an integer, s must be odd.\n            # If s is odd, s-1 is even, so (s-1)/2 is an integer.\n            # k > 1 implies (s-1)/2 > 1, so s-1 > 2, s > 3.\n            if s > 3 and (s - 1) % 2 == 0:\n                print(\"YES\")\n                return\n\n    # Case 2: n = 1 + k + k^2 + ... + k^D where D >= 3\n    # k must be at least 2.\n    # Maximum D: For k=2, n = 2^(D+1) - 1.\n    # n <= 10^18, so 2^(D+1) - 1 <= 10^18 => 2^(D+1) <= 10^18 + 1\n    # D+1 <= log2(10^18 + 1) approx 59.79. So D+1 max ~59. D max ~58.\n    # Let's use D from 3 to 60 for safety.\n    \n    # Iterate D (exponent)\n    for D in range(3, 61): # D is the max exponent, so sum has D+1 terms\n        # Binary search for k\n        # k must be at least 2.\n        # k^D < n => k < n^(1/D)\n        # Upper bound for k: n^(1/D) + a small constant.\n        # Max k for D=3: (10^18)^(1/3) = 10^6.\n        low = 2\n        high = int(n**(1.0/D)) + 2 # Add a small buffer, e.g. 2\n        \n        # Cap high to prevent excessively large numbers, max k is 10^6 for D=3\n        high = min(high, 10**6 + 7) \n\n        while low <= high:\n            k = (low + high) // 2\n            if k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            current_term = 1\n            \n            # Calculate sum = 1 + k + k^2 + ... + k^D\n            # Check for overflow at each step\n            overflow = False\n            for _ in range(D): # D iterations to get up to k^D\n                if current_term > n // k: # Check if current_term * k would overflow n\n                    overflow = True\n                    break\n                current_term *= k\n                if current_sum > n - current_term: # Check if current_sum + current_term would overflow n\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow:\n                # If sum overflows or is too large, this k is too big\n                high = k - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                # k is too small, try larger k\n                low = k + 1\n            else: # current_sum > n\n                # k is too large, try smaller k\n                high = k - 1\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 5422,
        "thoughts_token_count": 788
    }
}