{
    "start": 1758294853.6152089,
    "end": 1758294961.6149156,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Algorithm Refinement for Mushroom Strife Problem**\n\nOkay, so I've been really digging into this \"Mushroom Strife\" problem. My initial instinct was to brute-force a solution, but the constraints made it clear I needed something more clever. Let's break down my thought process, focusing on the refined algorithm.\n\nFirst off, the fundamental concept linking GCD and LCM is key: `a * b = g * l`. And I knew that `l` has to be a multiple of `g`, and both `a` and `b` have to be integers within a defined range. I modeled the problem as a graph where each lawn is a node and each road is an edge with GCD and LCM constraints. That seemed obvious.\n\nThe constructive approach looked promising: if I knew the mushroom count on one lawn, the GCD/LCM info for an edge would help me calculate the other lawn's mushroom count. But that's where things got tricky. I realized that my initial guess for the number of mushrooms at any given lawn might lead to conflicting results when I tried to satisfy the GCD and LCM properties along different edges.\n\nThen came the idea of prime factorization. Representing mushroom counts using their prime exponents seemed to bring structure to the problem. The core idea is that, for each prime `p`, the exponents `e_u` and `e_v` must sum to `g_p + l_p` for the linked nodes and exponents have to be within a specific range, based on `g` and `l`. This led me to a system of equations for each prime.\n\nAnd then I realized this system of equations actually forms a graph of its own! For each prime, I can visualize a new graph. The edges on this graph mean that nodes' exponents sum to a value, related to GCD and LCM. This, I thought, is going to lead me to the answer, or the proof that it doesn't exist.\n\nSo the new approach, is this: Break it into primes, and address each prime `p` independently:\n\n1.  **Prime Factorization:** Pre-compute the prime factorizations (exponents) for all GCD and LCM values using prime sieve to optimize the decomposition.\n2.  **Iterate Nodes**: Iterate nodes and, if not visited, start a BFS/DFS.\n3.  **Bipartite Check**: Determine whether, given `E_u + E_v = S_{uv}` for an edge `(u,v)`, and given range conditions for `E_u` and `E_v`, the graph is consistent or not. If a contradiction, return \"NO\". This is the 2-Coloring step.\n4.  **Edge Equations**: For an edge `(u, v)` where `E_u` and `E_v` are exponents for prime `p`, form the equation `E_u + E_v = S_{uv}`. Make this consistent.\n\nIf I can assign valid exponents for all primes, I can reconstruct the actual mushroom counts, which is the final answer. If a contradiction arises during the assignment (due to inconsistent sums or bounds), then there's no valid solution, and I'll report \"NO\". This structure seems solid, but requires careful implementation to be efficient.\n\nOkay, let's get coding!\n",
    "response": "The problem asks us to assign a positive integer `a_i` (number of mushrooms) to each lawn `i` (vertex) such that for every given road (edge) `(u, v)` with specified `GCD(a_u, a_v) = g` and `LCM(a_u, a_v) = l`, these conditions are met. If a solution exists, print \"YES\" and any valid assignment; otherwise, print \"NO\". The values `a_i`, `g`, `l` are between 1 and 10^6.\n\n**Key Property of GCD and LCM:**\nFor any two positive integers `a` and `b`, `GCD(a, b) * LCM(a, b) = a * b`.\nThis implies that for an edge `(u, v)` with given `g` and `l`, we must have `a_u * a_v = g * l`.\nAlso, `l` must be divisible by `g`. If `l % g != 0` for any edge, no solution exists.\n\n**Prime Factorization Approach:**\nLet `v_p(x)` denote the exponent of prime `p` in the prime factorization of `x`.\nThe properties of GCD and LCM translate to exponents as follows:\n1. `v_p(GCD(a, b)) = min(v_p(a), v_p(b))`\n2. `v_p(LCM(a, b)) = max(v_p(a), v_p(b))`\nCombining these with `a * b = GCD(a, b) * LCM(a, b)`:\n`v_p(a) + v_p(b) = v_p(GCD(a, b)) + v_p(LCM(a, b))` for any prime `p`.\n\nLet `e_{u,p} = v_p(a_u)`. For an edge `(u, v)` with `g, l`:\nLet `g_p = v_p(g)` and `l_p = v_p(l)`.\nThe conditions become:\n1. `e_{u,p} + e_{v,p} = g_p + l_p`\n2. `min(e_{u,p}, e_{v,p}) = g_p`\n3. `max(e_{u,p}, e_{v,p}) = l_p`\n\nFrom `min(x,y) + max(x,y) = x+y`, conditions 2 and 3 imply condition 1.\nConditions 2 and 3 also imply `g_p <= e_{u,p} <= l_p` and `g_p <= e_{v,p} <= l_p`.\nAnd `g_p <= l_p` must hold. If `g_p > l_p` for any prime `p` and any edge, then no solution exists.\n\nThe crucial observation is that the problem decomposes into independent subproblems for each prime `p`. For each prime `p`, we need to find non-negative integer exponents `e_{u,p}` for each node `u` such that the conditions hold.\n\n**Algorithm for a fixed prime `p`:**\nFor each node `u`, we need to determine `e_{u,p}`.\nLet `exp[u]` store `e_{u,p}`. Initialize `exp[u]` to -1 (unknown) for all `u`.\n`adj[u]` stores `(v, g_p, l_p)` for edges.\nWe can use a Breadth-First Search (BFS) or Depth-First Search (DFS) for each connected component in the graph.\n\n1. **Initialization:**\n   - Create an adjacency list `adj_p` for each prime `p`. `adj_p[u]` stores `(v, g_p, l_p)`.\n   - `exp[u]` initialized to -1 for all `u`.\n   - `final_ans[u]` initialized to 1 for all `u` (since `a_i` are positive).\n\n2. **Precomputation (Prime Factorization):**\n   - Sieve primes up to `10^6`.\n   - For each number `x` from 1 to `10^6`, compute its prime factorization and store `v_p(x)` for each prime `p`. A simple way is to use `spf` (smallest prime factor) array.\n   - Collect all unique primes encountered in the `g` and `l` values. Let this set be `Primes_involved`.\n\n3. **Main Loop (Iterate over primes):**\n   For each prime `p` in `Primes_involved`:\n     - Initialize `exp_p[u]` to -1 for all `u` (temporary storage for current prime `p`).\n     - For each node `u` from 1 to `n`:\n       If `exp_p[u]` is -1 (node `u` hasn't been processed for this prime `p`):\n         - Start a BFS from `u`.\n         - Set `exp_p[u] = g_p_min_incident_to_u` for some `u`. A safe initial guess for `exp_p[u]` is needed.\n         - The crucial part: `e_{u,p} + e_{v,p} = g_p + l_p`.\n           This means `e_{v,p} = (g_p + l_p) - e_{u,p}`.\n           Also, `e_{u,p}` must be in `[g_p, l_p]`.\n           This structure implies that if we fix `e_{u,p}` for one node `u`, all other `e_{v,p}` in the same connected component are determined relative to `e_{u,p}`.\n           More specifically, `e_{v,p}` will be of the form `C + (-1)^k * e_{u,p}` where `k` is the parity of the distance from `u` to `v`.\n           If the graph is bipartite, we can assign `e_{u,p} = g_p` for all `u` in one partition and `e_{u,p} = l_p` for all `u` in the other partition, and then check consistency.\n           But a simpler approach:\n           For a connected component, pick an arbitrary starting node `s`.\n           Set `exp_p[s] = 0` (this is an initial guess, which can be adjusted).\n           `q = deque([(s, 0)])`\n           While `q` is not empty:\n             `curr_u, curr_exp = q.popleft()`\n             If `curr_exp < 0`: return \"NO\" (exponents must be non-negative)\n             For each `(v, g_val, l_val)` in `adj_p[curr_u]`:\n               `target_exp_sum = g_val + l_val`\n               `expected_v_exp = target_exp_sum - curr_exp`\n               If `expected_v_exp < g_val` or `expected_v_exp > l_val`:\n                 This means `curr_exp` is too large or too small.\n                 If `curr_exp < g_val` or `curr_exp > l_val`, this is also an issue.\n                 This is not quite right. The `exp_p[u]` values must satisfy `g_p <= exp_p[u] <= l_p` for *all* incident edges.\n\nRevised approach for fixed prime `p`:\nFor each `u`, `exp_p[u]` is the exponent of `p` in `a_u`.\n`exp_p[u]` can be `0` initially.\n`fixed_value[u]` stores the determined value for `exp_p[u]`. Initialize to -1.\n`offset[u]` stores `exp_p[u] - exp_p[root]`.\n`visited[u]` stores `(color, offset_val)`. Color is 0 or 1 for bipartite.\n`q = deque()`\n\nFor each node `u` from 1 to `n`:\n  If `fixed_value[u]` is -1: // Start a new component\n    `min_val = 0`, `max_val = infinity` (or `MAX_LOG_VAL` which is `log2(10^6) approx 19`)\n    For `(v, g_val, l_val)` in `adj_p[u]`:\n      If `g_val > l_val`: return \"NO\"\n      `min_val = max(min_val, g_val)`\n      `max_val = min(max_val, l_val)`\n    If `min_val > max_val`: return \"NO\"\n    \n    // Perform a BFS to determine relative exponents and find cycles\n    `q.clear()`\n    `q.append((u, 0, 0))` // (node, color, relative_exp_to_root)\n    `visited = {}` // To store (color, relative_exp) for nodes in current component\n    `visited[u] = (0, 0)`\n    `fixed_value[u] = 0` // Temporarily fix root to 0 to determine relative values\n    \n    `nodes_in_component = [u]`\n    `min_x_val = 0`\n    `max_x_val = float('inf')`\n    \n    while `q`:\n      `curr_u, curr_color, curr_offset = q.popleft()`\n      \n      For `(v, g_val, l_val)` in `adj_p[curr_u]`:\n        `target_sum = g_val + l_val`\n        `next_color = 1 - curr_color`\n        `next_offset = target_sum - curr_offset` // `exp_p[v] = target_sum - exp_p[curr_u]`\n                                                  // `(exp_p[v] - exp_p[root]) = (target_sum - (exp_p[curr_u] - exp_p[root])) - exp_p[root]`\n                                                  // `exp_p[v] - exp_p[root] = target_sum - (curr_offset + exp_p[root]) - exp_p[root]`\n                                                  // `exp_p[v] - exp_p[root] = target_sum - curr_offset - 2 * exp_p[root]`\n\n        // The relative exponent is `exp_p[v] - exp_p[u]` if `u` is the root.\n        // Let `exp_p[root] = x`.\n        // `exp_p[u] = x + offset[u]`\n        // `exp_p[v] = x + offset[v]`\n        // `(x + offset[u]) + (x + offset[v]) = target_sum`\n        // `2x + offset[u] + offset[v] = target_sum`\n        // `offset[v] = target_sum - offset[u] - 2x` (this is wrong, `offset[v]` should be `target_sum - offset[u]` if `x` is 0)\n        // Let's use `exp_p[u]` as the actual value.\n        // When we start BFS, `exp_p[u]` is unknown.\n        // Let's use `value[u]` for `e_{u,p}`.\n        // `value[u]` is unknown.\n        // `value[u] + value[v] = S_{uv}`.\n        // `value[u] >= g_p`, `value[u] <= l_p`.\n        \n        // Let `value[u] = x` for some `u`. Then `value[v] = S_{uv} - x`.\n        // `value[w] = S_{vw} - value[v] = S_{vw} - (S_{uv} - x) = S_{vw} - S_{uv} + x`.\n        // So values alternate between `C + x` and `C - x`.\n        // `e_{u,p} = base_u + parity_u * x`\n        // `e_{v,p} = base_v + parity_v * x`\n        // `base_u + parity_u * x + base_v + parity_v * x = g_p + l_p`\n        // `(base_u + base_v) + (parity_u + parity_v) * x = g_p + l_p`\n        // If `parity_u == parity_v`: `2x = (g_p + l_p) - (base_u + base_v)`. Determines `x`.\n        // If `parity_u != parity_v`: `base_u + base_v = g_p + l_p`. Consistency check.\n\nLet's use a standard BFS for 2-coloring a graph and propagating values.\n`exp_vals[u]` will store the actual exponent `e_{u,p}`. Initialize to -1.\n`relative_exp[u]` stores `e_{u,p} - e_{root,p}`.\n`parity[u]` stores 0 if `e_{u,p} = e_{root,p} + relative_exp[u]`, 1 if `e_{u,p} = e_{root,p} - relative_exp[u]`.\n\nFor each prime `p`:\n  `exp_vals = [-1] * (n + 1)`\n  For `u` from 1 to `n`:\n    If `exp_vals[u]` is -1: // Not yet processed for this prime\n      `q = deque()`\n      `q.append(u)`\n      `exp_vals[u] = 0` // Temporarily assign 0 to root of component\n      `nodes_in_component = []`\n      `nodes_in_component.append(u)`\n\n      while `q`:\n        `curr_u = q.popleft()`\n        For `(v, g_val, l_val)` in `adj_p[curr_u]`:\n          If `g_val > l_val`: return \"NO\" // Constraint check\n          \n          If `exp_vals[v]` == -1: // `v` is unvisited\n            `exp_vals[v] = (g_val + l_val) - exp_vals[curr_u]`\n            `nodes_in_component.append(v)`\n            `q.append(v)`\n          Else: // `v` is visited, check consistency\n            If `exp_vals[curr_u] + exp_vals[v] != g_val + l_val`:\n              // Inconsistency detected. This means our initial choice of `exp_vals[u]=0` was wrong,\n              // or the relative assignments are inconsistent.\n              // This happens if there's an odd cycle, and the sum of `g_p+l_p` values around it\n              // forces a non-integer or inconsistent `x`.\n              // For an odd cycle, `2*x = Sum(S_ij * (-1)^k)`. If `Sum` is odd, `x` is not integer.\n              // For an even cycle, `0 = Sum(S_ij * (-1)^k)`. If `Sum` is non-zero, inconsistency.\n              // So, if `exp_vals[curr_u] + exp_vals[v] != g_val + l_val`, it's an immediate \"NO\".\n              return \"NO\"\n      \n      // After BFS, `exp_vals` contains relative exponents based on `exp_vals[u]=0`.\n      // Now, find the actual `x = e_{root,p}` for this component.\n      // For each node `j` in `nodes_in_component`:\n      //   `e_{j,p} = exp_vals[j] + C * x` where `C` is 0 or 1 depending on parity.\n      //   More simply, `e_{j,p}` must be in range `[g_val, l_val]` for all incident edges.\n      //   `exp_vals[j]` represents `e_{j,p}` if `e_{root,p}=0`.\n      //   If `e_{root,p}=x`, then `e_{j,p}' = exp_vals[j] + x` (if `j` has same parity as root)\n      //   or `e_{j,p}' = exp_vals[j] - x` (if `j` has different parity as root).\n      //   This is equivalent to `e_{j,p}' = exp_vals[j] + sign_j * x`.\n      //   We need to find `x` such that `g_val <= exp_vals[j] + sign_j * x <= l_val` for all `j` and incident edges.\n      //   This is a system of linear inequalities for `x`.\n      //   `g_val - exp_vals[j] <= sign_j * x <= l_val - exp_vals[j]`.\n      //   If `sign_j` is 1: `g_val - exp_vals[j] <= x <= l_val - exp_vals[j]`.\n      //   If `sign_j` is -1: `-(l_val - exp_vals[j]) <= x <= -(g_val - exp_vals[j])`.\n      //   So, `exp_vals[j] - l_val <= x <= exp_vals[j] - g_val`.\n      //   Combine all these to find a valid range `[L, R]` for `x`.\n      //   If `L > R`, no solution. Pick `x = L`.\n\n      // Let's refine the BFS:\n      // `exp_p[u]` stores `e_{u,p}`. Initialize to -1.\n      // `parity[u]` stores 0 or 1, indicating `e_{u,p} = base_u + (-1)^{parity[u]} * X`.\n      // `base[u]` stores the constant part.\n      // `X` is the value of `e_{root,p}`.\n      \n      `base_exp = [-1] * (n + 1)`\n      `parity = [-1] * (n + 1)`\n      `q = deque()`\n      `q.append(u)`\n      `base_exp[u] = 0`\n      `parity[u] = 0` // `e_{u,p} = X`\n      \n      `current_component_nodes = []`\n      `current_component_nodes.append(u)`\n      \n      `min_X_bound = 0`\n      `max_X_bound = float('inf')`\n      \n      while `q`:\n        `curr_u = q.popleft()`\n        \n        // Apply bounds from incident edges for `curr_u`\n        For `(v, g_val, l_val)` in `adj_p[curr_u]`:\n          If `parity[curr_u] == 0`: // `e_{curr_u,p} = base_exp[curr_u] + X`\n            `min_X_bound = max(min_X_bound, g_val - base_exp[curr_u])`\n            `max_X_bound = min(max_X_bound, l_val - base_exp[curr_u])`\n          Else: // `e_{curr_u,p} = base_exp[curr_u] - X`\n            `min_X_bound = max(min_X_bound, base_exp[curr_u] - l_val)`\n            `max_X_bound = min(max_X_bound, base_exp[curr_u] - g_val)`\n        \n        For `(v, g_val, l_val)` in `adj_p[curr_u]`:\n          If `base_exp[v]` == -1: // `v` is unvisited\n            `base_exp[v] = (g_val + l_val) - base_exp[curr_u]`\n            `parity[v] = 1 - parity[curr_u]`\n            `current_component_nodes.append(v)`\n            `q.append(v)`\n          Else: // `v` is visited, check consistency\n            // `e_{curr_u,p} + e_{v,p} = g_val + l_val`\n            // `(base_exp[curr_u] + (-1)^{parity[curr_u]} * X) + (base_exp[v] + (-1)^{parity[v]} * X) = g_val + l_val`\n            If `parity[curr_u] == parity[v]`: // `base_exp[curr_u] + base_exp[v] + 2X = g_val + l_val`\n              // This implies `2X = (g_val + l_val) - (base_exp[curr_u] + base_exp[v])`.\n              // This determines `X`. If it conflicts with `min_X_bound/max_X_bound` or is not integer, return \"NO\".\n              `required_2X = (g_val + l_val) - (base_exp[curr_u] + base_exp[v])`\n              If `required_2X % 2 != 0`: return \"NO\"\n              `X_val = required_2X // 2`\n              `min_X_bound = max(min_X_bound, X_val)`\n              `max_X_bound = min(max_X_bound, X_val)`\n            Else: // `parity[curr_u] != parity[v]`: `base_exp[curr_u] + base_exp[v] = g_val + l_val`\n              // This is a consistency check, `X` cancels out.\n              If `base_exp[curr_u] + base_exp[v] != g_val + l_val`: return \"NO\"\n      \n      If `min_X_bound > max_X_bound`: return \"NO\"\n      \n      // Choose `X`. Since any solution is fine, pick `X = min_X_bound`.\n      `chosen_X = min_X_bound`\n      \n      // Apply chosen `X` to all nodes in the component\n      For `node_idx` in `current_component_nodes`:\n        If `parity[node_idx] == 0`:\n          `exp_vals[node_idx] = base_exp[node_idx] + chosen_X`\n        Else:\n          `exp_vals[node_idx] = base_exp[node_idx] - chosen_X`\n        \n        // Final check on bounds\n        For `(v, g_val, l_val)` in `adj_p[node_idx]`:\n          If not (`g_val <= exp_vals[node_idx] <= l_val`): return \"NO\"\n        \n        // Update `final_ans`\n        `final_ans[node_idx] *= (p ** exp_vals[node_idx])`\n        If `final_ans[node_idx] > 10**6`: return \"NO\"\n\n4. **Final Output:**\n   If no \"NO\" was returned, print \"YES\" and `final_ans`.\n\n**Edge Cases and Constraints:**\n- `n=1, m=0`: `final_ans = [1]` is valid.\n- `a_i` must be between 1 and 10^6. This is handled by `final_ans[node_idx] > 10**6` check.\n- `g, l` up to `10^6`. Sieve needs to go up to `10^6`.\n- `g_p > l_p` check is important.\n- `min_X_bound` can be negative, `max_X_bound` can be very large. `chosen_X` must be non-negative.\n  If `min_X_bound < 0`, we must choose `max(0, min_X_bound)`.\n  So `chosen_X = max(0, min_X_bound)`. Then re-check `chosen_X <= max_X_bound`.\n\n**Complexity:**\n- Sieve: `O(MAX_VAL log log MAX_VAL)`.\n- Prime factorization for all `g, l`: `O(M * log(MAX_VAL))` (each factorization takes `log X` time with `spf`).\n- For each prime `p`: BFS on graph `O(N+M)`. Number of primes up to `10^6` is around 78k.\n  However, we only need to iterate over primes that are factors of any `g` or `l`.\n  The total number of prime factors across all `g, l` values is `M * log(MAX_VAL)`.\n  The sum of `(N_p + M_p)` over all primes `p` is `O(P_total + M * log(MAX_VAL))` where `P_total` is sum of nodes involved.\n  Each edge `(u,v)` with `g,l` contributes to `log(g)` and `log(l)` primes.\n  Total time for BFS part: `Sum_{p} (N + M_p)` where `M_p` is number of edges where `p` is a factor of `g` or `l`.\n  This is roughly `O(N * num_primes_involved + M * log(MAX_VAL))`.\n  `num_primes_involved` can be up to `78k`. `N * 78k` is too slow if N is `10^5`.\n  \n  The `adj_p` list for each prime `p` is sparse. An edge `(u, v)` with `g, l` only contributes to `adj_p` if `p` divides `g` or `l`.\n  So the total sum of `(N + M_p)` over all `p` is `O(N * (number of distinct primes) + M * (average number of distinct prime factors per g/l))`.\n  This is `O(N * 78k + M * log(MAX_VAL))`, still too slow.\n\nWait, `nodes_in_component` is for nodes in the *current* component. `exp_vals` is reset for each prime.\nThe BFS for each prime `p` only visits nodes that are part of an edge where `p` is a factor of `g` or `l`.\nSo the sum over all primes `p` of `(Nodes_p + Edges_p)` is `O(N_distinct_primes + M * log(MAX_VAL))`.\n`N_distinct_primes` is not `N * 78k`. It's `N` times the number of distinct primes that are factors of *any* `a_i`.\nThis is actually `O(N + M * log(MAX_VAL))` because each node is visited at most once per prime, and each edge is processed at most once per prime.\nThe total number of `(u, p)` pairs for which `e_{u,p}` is non-zero is `N * log(MAX_VAL)`.\nThe total number of `(edge, p)` pairs for which `g_p, l_p` are non-zero is `M * log(MAX_VAL)`.\nSo the complexity is fine.\n\n```python\nimport sys\nfrom collections import deque\nimport math\n\n# Fast I/O\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\nMAX_VAL = 10**6\nMAX_LOG_VAL = 20 # log2(10^6) is approx 19.9, so max exponent is 19 or less\n\n# Sieve to find smallest prime factor (spf) for numbers up to MAX_VAL\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization of a number\n# Returns a dictionary {prime: exponent}\ndef get_prime_factorization(n_val):\n    factors = {}\n    if n_val == 0: return factors # Should not happen with 1 <= g, l <= 10^6\n    \n    temp_n = n_val\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            temp_n //= p\n            count += 1\n        factors[p] = count\n    return factors\n\ndef solve():\n    n, m = map(int, input().split())\n\n    if m == 0:\n        print(\"YES\\n\")\n        print(\" \".join([\"1\"] * n) + \"\\n\")\n        return\n\n    # Store edges: (u, v, g, l)\n    edges_raw = []\n    # Adjacency list for the overall graph\n    adj = [[] for _ in range(n + 1)]\n\n    # Collect all unique primes involved from g and l values\n    all_involved_primes = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        edges_raw.append((u, v, g, l))\n\n        # Check initial condition: l must be divisible by g\n        if l % g != 0:\n            print(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l)) # Graph is undirected\n\n        # Get primes for g and l\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n        all_involved_primes.update(g_factors.keys())\n        all_involved_primes.update(l_factors.keys())\n        \n        # Check v_p(g) <= v_p(l) for all primes\n        for p, exp_g in g_factors.items():\n            exp_l = l_factors.get(p, 0)\n            if exp_g > exp_l:\n                print(\"NO\\n\")\n                return\n        for p, exp_l in l_factors.items():\n            exp_g = g_factors.get(p, 0)\n            if exp_g > exp_l: # Redundant, but for completeness\n                print(\"NO\\n\")\n                return\n\n    # Final answer array for a_i\n    final_ans = [1] * (n + 1)\n\n    # Process each prime independently\n    for p in all_involved_primes:\n        # For each prime p, create a subgraph containing only edges\n        # where p is a factor of g or l\n        p_adj = [[] for _ in range(n + 1)]\n        nodes_with_p_factor = set()\n\n        for u, v, g, l in edges_raw:\n            g_factors = get_prime_factorization(g)\n            l_factors = get_prime_factorization(l)\n            \n            g_p = g_factors.get(p, 0)\n            l_p = l_factors.get(p, 0)\n\n            if g_p > 0 or l_p > 0: # If p is involved in this edge\n                p_adj[u].append((v, g_p, l_p))\n                p_adj[v].append((u, g_p, l_p))\n                nodes_with_p_factor.add(u)\n                nodes_with_p_factor.add(v)\n\n        # Arrays for current prime p\n        # base_exp[u]: the constant part of e_{u,p} (when X=0)\n        # parity[u]: 0 if e_{u,p} = base_exp[u] + X, 1 if e_{u,p} = base_exp[u] - X\n        base_exp = [-1] * (n + 1)\n        parity = [-1] * (n + 1)\n\n        # Iterate through nodes to find unvisited components for this prime\n        for start_node in nodes_with_p_factor:\n            if base_exp[start_node] == -1: # Unvisited component\n                q = deque()\n                q.append(start_node)\n                base_exp[start_node] = 0\n                parity[start_node] = 0 # e_{start_node,p} = 0 + X\n                \n                component_nodes = []\n                component_nodes.append(start_node)\n\n                min_X_bound = 0 # X >= 0\n                max_X_bound = float('inf')\n\n                head = 0\n                while head < len(q): # Manual queue for slightly better performance with lists\n                    curr_u = q[head]\n                    head += 1\n\n                    # Apply bounds from incident edges for curr_u\n                    for v_adj, g_val, l_val in p_adj[curr_u]:\n                        if parity[curr_u] == 0: # e_{curr_u,p} = base_exp[curr_u] + X\n                            min_X_bound = max(min_X_bound, g_val - base_exp[curr_u])\n                            max_X_bound = min(max_X_bound, l_val - base_exp[curr_u])\n                        else: # e_{curr_u,p} = base_exp[curr_u] - X\n                            min_X_bound = max(min_X_bound, base_exp[curr_u] - l_val)\n                            max_X_bound = min(max_X_bound, base_exp[curr_u] - g_val)\n                        \n                        # Check if bounds are already inconsistent\n                        if min_X_bound > max_X_bound:\n                            print(\"NO\\n\")\n                            return\n\n                    for v_adj, g_val, l_val in p_adj[curr_u]:\n                        if base_exp[v_adj] == -1: # v_adj is unvisited\n                            base_exp[v_adj] = (g_val + l_val) - base_exp[curr_u]\n                            parity[v_adj] = 1 - parity[curr_u]\n                            component_nodes.append(v_adj)\n                            q.append(v_adj)\n                        else: # v_adj is visited, check consistency\n                            # e_{curr_u,p} + e_{v_adj,p} = g_val + l_val\n                            # (base_exp[curr_u] + (-1)^{parity[curr_u]} * X) + (base_exp[v_adj] + (-1)^{parity[v_adj]} * X) = g_val + l_val\n                            if parity[curr_u] == parity[v_adj]: # X terms add up to 2X or -2X\n                                # base_exp[curr_u] + base_exp[v_adj] + 2X = g_val + l_val  (if parity is 0)\n                                # base_exp[curr_u] + base_exp[v_adj] - 2X = g_val + l_val  (if parity is 1)\n                                # This means 2X = (g_val + l_val) - (base_exp[curr_u] + base_exp[v_adj]) OR\n                                # 2X = (base_exp[curr_u] + base_exp[v_adj]) - (g_val + l_val)\n                                \n                                required_2X = (g_val + l_val) - (base_exp[curr_u] + base_exp[v_adj])\n                                if parity[curr_u] == 1: # Both parities are 1, so e_u = base_u - X, e_v = base_v - X\n                                    required_2X = -required_2X # (base_u - X) + (base_v - X) = S => base_u + base_v - 2X = S => 2X = base_u + base_v - S\n                                \n                                if required_2X % 2 != 0:\n                                    print(\"NO\\n\")\n                                    return\n                                X_val = required_2X // 2\n                                min_X_bound = max(min_X_bound, X_val)\n                                max_X_bound = min(max_X_bound, X_val)\n                            else: # X terms cancel out\n                                # base_exp[curr_u] + base_exp[v_adj] = g_val + l_val\n                                if base_exp[curr_u] + base_exp[v_adj] != g_val + l_val:\n                                    print(\"NO\\n\")\n                                    return\n                        \n                        # Check if bounds are already inconsistent\n                        if min_X_bound > max_X_bound:\n                            print(\"NO\\n\")\n                            return\n\n                if min_X_bound > max_X_bound: # After full component traversal\n                    print(\"NO\\n\")\n                    return\n                \n                # Choose X. Any valid X is fine, so pick the smallest non-negative.\n                chosen_X = max(0, min_X_bound)\n                \n                if chosen_X > max_X_bound: # Must be within bounds\n                    print(\"NO\\n\")\n                    return\n\n                # Apply chosen_X to all nodes in the component\n                for node_idx in component_nodes:\n                    actual_exp_val = 0\n                    if parity[node_idx] == 0:\n                        actual_exp_val = base_exp[node_idx] + chosen_X\n                    else:\n                        actual_exp_val = base_exp[node_idx] - chosen_X\n                    \n                    # Final check for non-negativity of exponents\n                    if actual_exp_val < 0:\n                        print(\"NO\\n\")\n                        return\n\n                    # Update final_ans. Check for overflow (max 10^6).\n                    # Using math.pow and int() to handle large powers\n                    # and ensure result is integer.\n                    try:\n                        factor = int(math.pow(p, actual_exp_val))\n                        if final_ans[node_idx] > MAX_VAL // factor: # Check for overflow before multiplication\n                            print(\"NO\\n\")\n                            return\n                        final_ans[node_idx] *= factor\n                    except OverflowError: # Should be caught by the check above, but for safety\n                        print(\"NO\\n\")\n                        return\n                    \n                    if final_ans[node_idx] > MAX_VAL: # Check after multiplication\n                        print(\"NO\\n\")\n                        return\n\n    # If all primes processed without issues, print YES and the result\n    print(\"YES\\n\")\n    print(\" \".join(map(str, final_ans[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\nimport math\n\n# Fast I/O\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\nMAX_VAL = 10**6\nMAX_LOG_VAL = 20 # log2(10^6) is approx 19.9, so max exponent is 19 or less\n\n# Sieve to find smallest prime factor (spf) for numbers up to MAX_VAL\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization of a number\n# Returns a dictionary {prime: exponent}\ndef get_prime_factorization(n_val):\n    factors = {}\n    if n_val == 0: return factors # Should not happen with 1 <= g, l <= 10^6\n    \n    temp_n = n_val\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            temp_n //= p\n            count += 1\n        factors[p] = count\n    return factors\n\ndef solve():\n    n, m = map(int, input().split())\n\n    if m == 0:\n        print(\"YES\\n\")\n        print(\" \".join([\"1\"] * n) + \"\\n\")\n        return\n\n    # Store edges: (u, v, g, l)\n    edges_raw = []\n    # Adjacency list for the overall graph\n    adj = [[] for _ in range(n + 1)]\n\n    # Collect all unique primes involved from g and l values\n    all_involved_primes = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        edges_raw.append((u, v, g, l))\n\n        # Check initial condition: l must be divisible by g\n        if l % g != 0:\n            print(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l)) # Graph is undirected\n\n        # Get primes for g and l\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n        all_involved_primes.update(g_factors.keys())\n        all_involved_primes.update(l_factors.keys())\n        \n        # Check v_p(g) <= v_p(l) for all primes\n        for p, exp_g in g_factors.items():\n            exp_l = l_factors.get(p, 0)\n            if exp_g > exp_l:\n                print(\"NO\\n\")\n                return\n        for p, exp_l in l_factors.items():\n            exp_g = g_factors.get(p, 0)\n            if exp_g > exp_l: # Redundant, but for completeness\n                print(\"NO\\n\")\n                return\n\n    # Final answer array for a_i\n    final_ans = [1] * (n + 1)\n\n    # Process each prime independently\n    for p in all_involved_primes:\n        # For each prime p, create a subgraph containing only edges\n        # where p is a factor of g or l\n        p_adj = [[] for _ in range(n + 1)]\n        nodes_with_p_factor = set()\n\n        for u, v, g, l in edges_raw:\n            g_factors = get_prime_factorization(g)\n            l_factors = get_prime_factorization(l)\n            \n            g_p = g_factors.get(p, 0)\n            l_p = l_factors.get(p, 0)\n\n            if g_p > 0 or l_p > 0: # If p is involved in this edge\n                p_adj[u].append((v, g_p, l_p))\n                p_adj[v].append((u, g_p, l_p))\n                nodes_with_p_factor.add(u)\n                nodes_with_p_factor.add(v)\n\n        # Arrays for current prime p\n        # base_exp[u]: the constant part of e_{u,p} (when X=0)\n        # parity[u]: 0 if e_{u,p} = base_exp[u] + X, 1 if e_{u,p} = base_exp[u] - X\n        base_exp = [-1] * (n + 1)\n        parity = [-1] * (n + 1)\n\n        # Iterate through nodes to find unvisited components for this prime\n        for start_node in nodes_with_p_factor:\n            if base_exp[start_node] == -1: # Unvisited component\n                q = deque()\n                q.append(start_node)\n                base_exp[start_node] = 0\n                parity[start_node] = 0 # e_{start_node,p} = 0 + X\n                \n                component_nodes = []\n                component_nodes.append(start_node)\n\n                min_X_bound = 0 # X >= 0\n                max_X_bound = float('inf')\n\n                head = 0\n                while head < len(q): # Manual queue for slightly better performance with lists\n                    curr_u = q[head]\n                    head += 1\n\n                    # Apply bounds from incident edges for curr_u\n                    for v_adj, g_val, l_val in p_adj[curr_u]:\n                        if parity[curr_u] == 0: # e_{curr_u,p} = base_exp[curr_u] + X\n                            min_X_bound = max(min_X_bound, g_val - base_exp[curr_u])\n                            max_X_bound = min(max_X_bound, l_val - base_exp[curr_u])\n                        else: # e_{curr_u,p} = base_exp[curr_u] - X\n                            min_X_bound = max(min_X_bound, base_exp[curr_u] - l_val)\n                            max_X_bound = min(max_X_bound, base_exp[curr_u] - g_val)\n                        \n                        # Check if bounds are already inconsistent\n                        if min_X_bound > max_X_bound:\n                            print(\"NO\\n\")\n                            return\n\n                    for v_adj, g_val, l_val in p_adj[curr_u]:\n                        if base_exp[v_adj] == -1: # v_adj is unvisited\n                            base_exp[v_adj] = (g_val + l_val) - base_exp[curr_u]\n                            parity[v_adj] = 1 - parity[curr_u]\n                            component_nodes.append(v_adj)\n                            q.append(v_adj)\n                        else: # v_adj is visited, check consistency\n                            # e_{curr_u,p} + e_{v_adj,p} = g_val + l_val\n                            # (base_exp[curr_u] + (-1)^{parity[curr_u]} * X) + (base_exp[v_adj] + (-1)^{parity[v_adj]} * X) = g_val + l_val\n                            if parity[curr_u] == parity[v_adj]: # X terms add up to 2X or -2X\n                                # base_exp[curr_u] + base_exp[v_adj] + 2X = g_val + l_val  (if parity is 0)\n                                # base_exp[curr_u] + base_exp[v_adj] - 2X = g_val + l_val  (if parity is 1)\n                                # This means 2X = (g_val + l_val) - (base_exp[curr_u] + base_exp[v_adj]) OR\n                                # 2X = (base_exp[curr_u] + base_exp[v_adj]) - (g_val + l_val)\n                                \n                                required_2X = (g_val + l_val) - (base_exp[curr_u] + base_exp[v_adj])\n                                if parity[curr_u] == 1: # Both parities are 1, so e_u = base_u - X, e_v = base_v - X\n                                    required_2X = -required_2X # (base_u - X) + (base_v - X) = S => base_u + base_v - 2X = S => 2X = base_u + base_v - S\n                                \n                                if required_2X % 2 != 0:\n                                    print(\"NO\\n\")\n                                    return\n                                X_val = required_2X // 2\n                                min_X_bound = max(min_X_bound, X_val)\n                                max_X_bound = min(max_X_bound, X_val)\n                            else: # X terms cancel out\n                                # base_exp[curr_u] + base_exp[v_adj] = g_val + l_val\n                                if base_exp[curr_u] + base_exp[v_adj] != g_val + l_val:\n                                    print(\"NO\\n\")\n                                    return\n                        \n                        # Check if bounds are already inconsistent\n                        if min_X_bound > max_X_bound:\n                            print(\"NO\\n\")\n                            return\n\n                if min_X_bound > max_X_bound: # After full component traversal\n                    print(\"NO\\n\")\n                    return\n                \n                # Choose X. Any valid X is fine, so pick the smallest non-negative.\n                chosen_X = max(0, min_X_bound)\n                \n                if chosen_X > max_X_bound: # Must be within bounds\n                    print(\"NO\\n\")\n                    return\n\n                # Apply chosen_X to all nodes in the component\n                for node_idx in component_nodes:\n                    actual_exp_val = 0\n                    if parity[node_idx] == 0:\n                        actual_exp_val = base_exp[node_idx] + chosen_X\n                    else:\n                        actual_exp_val = base_exp[node_idx] - chosen_X\n                    \n                    # Final check for non-negativity of exponents\n                    if actual_exp_val < 0:\n                        print(\"NO\\n\")\n                        return\n\n                    # Update final_ans. Check for overflow (max 10^6).\n                    # Using math.pow and int() to handle large powers\n                    # and ensure result is integer.\n                    try:\n                        factor = int(math.pow(p, actual_exp_val))\n                        if final_ans[node_idx] > MAX_VAL // factor: # Check for overflow before multiplication\n                            print(\"NO\\n\")\n                            return\n                        final_ans[node_idx] *= factor\n                    except OverflowError: # Should be caught by the check above, but for safety\n                        print(\"NO\\n\")\n                        return\n                    \n                    if final_ans[node_idx] > MAX_VAL: # Check after multiplication\n                        print(\"NO\\n\")\n                        return\n\n    # If all primes processed without issues, print YES and the result\n    print(\"YES\\n\")\n    print(\" \".join(map(str, final_ans[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 9139,
        "thoughts_token_count": 6217
    }
}