{
    "start": 1758293740.3201723,
    "end": 1758293763.61091,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = -1\n    max_unidirectional_pairs = -1\n\n    # Case 1: All nodes form a single SCC\n    # Number of reachable-from-each-other pairs (u,v) with u < v is n * (n-1) / 2\n    # We need this to be equal to p.\n    # n * (n-1) / 2 = p\n    # n^2 - n - 2p = 0\n    # n = (1 + sqrt(1 + 8p)) / 2\n    # We are looking for the smallest integer n such that n * (n-1) / 2 >= p\n    # Let's find n_scc such that n_scc * (n_scc - 1) / 2 >= p\n    # n_scc is the smallest integer such that n_scc * (n_scc - 1) >= 2p\n    n_scc_candidate = math.ceil((1 + math.sqrt(1 + 8 * p)) / 2)\n    if n_scc_candidate * (n_scc_candidate - 1) // 2 == p:\n        min_nodes = n_scc_candidate\n        # If all nodes are in one SCC, there are no unidirectional pairs.\n        max_unidirectional_pairs = 0\n\n    # Case 2: Nodes are split into k SCCs, arranged in a path-like structure\n    # Let n be the total number of nodes.\n    # We want to minimize n.\n    # Let k be the number of SCCs.\n    # Let s_1, s_2, ..., s_k be the sizes of the SCCs.\n    # Total nodes n = s_1 + s_2 + ... + s_k.\n    # For any two nodes u, v in the same SCC_i, they are reachable from each other.\n    # Number of such pairs (u,v) with u < v is sum(s_i * (s_i - 1) / 2) for i=1 to k.\n    # This sum must be equal to p.\n    # To minimize n, we want to use as few SCCs as possible, and make them as large as possible.\n    # If we have k SCCs, and they are arranged in a path-like structure (e.g., edges from SCC_i to SCC_{i+1}),\n    # then for any u in SCC_i and v in SCC_j with i < j, u can reach v.\n    # But v cannot reach u. These are unidirectional pairs.\n    # The problem statement says \"u < v\" and \"u and v are reachable from each other\".\n    # This implies that the 'p' pairs are symmetric in reachability.\n    # This means 'p' counts pairs (u,v) such that u and v are in the same SCC.\n\n    # We need to find the minimum n such that there exist s_1, ..., s_k >= 1\n    # with sum(s_i * (s_i - 1) / 2) = p and sum(s_i) = n.\n    # To minimize n, we want to make s_i as large as possible.\n    # This means we should try to use as few SCCs as possible.\n    # We can use dynamic programming or a greedy approach.\n    # dp[current_p] = minimum number of nodes to achieve 'current_p' reachable-from-each-other pairs.\n    # dp[0] = 0.\n    # dp[x] = min(dp[x - i*(i-1)/2] + i) for i >= 1 such that i*(i-1)/2 <= x.\n    # The maximum value for i*(i-1)/2 is p.\n    # The maximum i such that i*(i-1)/2 <= 2e5 is when i^2 approx 4e5, i approx 632.\n    # This DP approach would be O(p * sqrt(p)), which is too slow (2e5 * 632).\n\n    # Let's consider the structure of the graph.\n    # The p pairs must come from nodes within the same SCCs.\n    # Let the sizes of the SCCs be s_1, s_2, ..., s_k.\n    # We have sum(s_i * (s_i - 1) / 2) = p.\n    # We want to minimize N = sum(s_i).\n    # To minimize sum(s_i) for a fixed sum(s_i * (s_i - 1) / 2), we should make the s_i values as large as possible.\n    # This is a known result: to minimize the sum of elements given a sum of a convex function of elements,\n    # make the elements as large as possible (i.e., use fewer elements).\n    # So we should try to use one large SCC, or a few large SCCs.\n\n    # Iterate through possible number of nodes n.\n    # For a given n, what is the maximum number of reachable-from-each-other pairs (p_max)\n    # and minimum number of reachable-from-each-other pairs (p_min)?\n    # p_min occurs when all s_i = 1, so p_min = 0.\n    # p_max occurs when one SCC has size n, so p_max = n * (n-1) / 2.\n    # We are looking for the smallest n such that it's possible to achieve p.\n\n    # Let's precompute the values of k * (k-1) / 2.\n    # max_val = 2 * 10^5\n    # Max k for k*(k-1)/2 <= 2e5 is k approx sqrt(4e5) approx 632.\n    scc_pairs = [0] * 635\n    for i in range(1, 635):\n        scc_pairs[i] = i * (i - 1) // 2\n\n    # min_nodes_for_p[val] = minimum nodes to get 'val' reachable-from-each-other pairs\n    min_nodes_for_p = [float('inf')] * (p + 1)\n    min_nodes_for_p[0] = 0\n\n    for current_p_val in range(p + 1):\n        if min_nodes_for_p[current_p_val] == float('inf'):\n            continue\n        for scc_size in range(1, 635):\n            pairs_from_scc = scc_pairs[scc_size]\n            if current_p_val + pairs_from_scc <= p:\n                new_nodes = min_nodes_for_p[current_p_val] + scc_size\n                if new_nodes < min_nodes_for_p[current_p_val + pairs_from_scc]:\n                    min_nodes_for_p[current_p_val + pairs_from_scc] = new_nodes\n            else:\n                # Optimization: if current_p_val + pairs_from_scc > p,\n                # we don't need to consider larger scc_sizes for this current_p_val\n                # because pairs_from_scc only increases with scc_size.\n                # However, this is not entirely correct. We need to iterate over all possible scc_size\n                # to build up the min_nodes_for_p table.\n                pass # The check `if current_p_val + pairs_from_scc <= p` handles this.\n\n    min_nodes = min_nodes_for_p[p]\n\n    # Now we have min_nodes. We need to find the max_unidirectional_pairs.\n    # This means we have 'min_nodes' nodes in total.\n    # Some of them are used in SCCs to get 'p' reachable-from-each-other pairs.\n    # Let these nodes be s_1, s_2, ..., s_k such that sum(s_i) = N_scc_used and sum(s_i * (s_i - 1) / 2) = p.\n    # The remaining nodes are N_remaining = min_nodes - N_scc_used.\n    # To maximize unidirectional pairs, we want to arrange these SCCs and remaining nodes.\n    # The most effective way to create unidirectional pairs is to have a linear chain of SCCs/nodes.\n    # If we have k SCCs of sizes s_1, ..., s_k, and m isolated nodes (s_i=1),\n    # and we arrange them in a chain (e.g., s_1 -> s_2 -> ... -> s_k -> 1 -> 1 -> ... -> 1),\n    # the number of unidirectional pairs is (sum of nodes in first j SCCs) * (sum of nodes in remaining SCCs)\n    # for all j.\n    # More simply, if we have N_total nodes, and these are partitioned into components C_1, C_2, ..., C_M\n    # where each C_i is either an SCC or a single node (which is an SCC of size 1).\n    # If we arrange these M components in a linear order, say C_1 -> C_2 -> ... -> C_M,\n    # then for any u in C_i and v in C_j with i < j, u can reach v but v cannot reach u.\n    # The number of unidirectional pairs is sum_{i=1 to M-1} (size(C_i) * sum_{j=i+1 to M} size(C_j)).\n    # This is equivalent to sum_{i=1 to M-1} (size(C_i) * (N_total - sum_{l=1 to i} size(C_l))).\n    # This is maximized when the components are arranged such that larger components are at the ends\n    # or when they are arranged such that the \"middle\" components are small.\n    # A simpler way to count this: total possible pairs (u,v) with u != v is N_total * (N_total - 1).\n    # Pairs within the same SCC are 2 * p.\n    # So the remaining pairs are N_total * (N_total - 1) - 2 * p.\n    # These remaining pairs are either unidirectional or non-reachable.\n    # If we arrange all SCCs and individual nodes in a single line, then all pairs (u,v) with u in C_i, v in C_j, i < j\n    # are unidirectional. All pairs (u,v) with u in C_j, v in C_i, i < j are also unidirectional.\n    # So the total number of unidirectional pairs is N_total * (N_total - 1) - 2 * p.\n    # This is the maximum possible number of unidirectional pairs.\n    # This strategy works: create a path where each node is either an SCC or a single node.\n    # For example, if we have SCCs of sizes s_1, ..., s_k and N_rem isolated nodes.\n    # We can arrange them as s_1 -> s_2 -> ... -> s_k -> 1 -> 1 -> ... -> 1.\n    # All pairs (u,v) with u in C_i and v in C_j (i != j) will be unidirectional.\n    # The total number of pairs (u,v) with u != v is N_total * (N_total - 1).\n    # The number of pairs (u,v) where u and v are in the same SCC is 2 * p.\n    # The remaining N_total * (N_total - 1) - 2 * p pairs must be unidirectional.\n    # This is because in a path-like structure of SCCs, if u and v are in different SCCs,\n    # say u in SCC_i and v in SCC_j, then either i < j (u can reach v, v cannot reach u)\n    # or j < i (v can reach u, u cannot reach v). In both cases, (u,v) is unidirectional.\n    # So, the maximum number of unidirectional pairs is min_nodes * (min_nodes - 1) - 2 * p.\n    max_unidirectional_pairs = min_nodes * (min_nodes - 1) - 2 * p\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = -1\n    max_unidirectional_pairs = -1\n\n    # Case 1: All nodes form a single SCC\n    # Number of reachable-from-each-other pairs (u,v) with u < v is n * (n-1) / 2\n    # We need this to be equal to p.\n    # n * (n-1) / 2 = p\n    # n^2 - n - 2p = 0\n    # n = (1 + sqrt(1 + 8p)) / 2\n    # We are looking for the smallest integer n such that n * (n-1) / 2 >= p\n    # Let's find n_scc such that n_scc * (n_scc - 1) / 2 >= p\n    # n_scc is the smallest integer such that n_scc * (n_scc - 1) >= 2p\n    n_scc_candidate = math.ceil((1 + math.sqrt(1 + 8 * p)) / 2)\n    if n_scc_candidate * (n_scc_candidate - 1) // 2 == p:\n        min_nodes = n_scc_candidate\n        # If all nodes are in one SCC, there are no unidirectional pairs.\n        max_unidirectional_pairs = 0\n\n    # Case 2: Nodes are split into k SCCs, arranged in a path-like structure\n    # Let n be the total number of nodes.\n    # We want to minimize n.\n    # Let k be the number of SCCs.\n    # Let s_1, s_2, ..., s_k be the sizes of the SCCs.\n    # Total nodes n = s_1 + s_2 + ... + s_k.\n    # For any two nodes u, v in the same SCC_i, they are reachable from each other.\n    # Number of such pairs (u,v) with u < v is sum(s_i * (s_i - 1) / 2) for i=1 to k.\n    # This sum must be equal to p.\n    # To minimize n, we want to use as few SCCs as possible, and make them as large as possible.\n    # If we have k SCCs, and they are arranged in a path-like structure (e.g., edges from SCC_i to SCC_{i+1}),\n    # then for any u in SCC_i and v in SCC_j with i < j, u can reach v.\n    # But v cannot reach u. These are unidirectional pairs.\n    # The problem statement says \"u < v\" and \"u and v are reachable from each other\".\n    # This implies that the 'p' pairs are symmetric in reachability.\n    # This means 'p' counts pairs (u,v) such that u and v are in the same SCC.\n\n    # We need to find the minimum n such that there exist s_1, ..., s_k >= 1\n    # with sum(s_i * (s_i - 1) / 2) = p and sum(s_i) = n.\n    # To minimize n, we want to make s_i as large as possible.\n    # This means we should try to use as few SCCs as possible.\n    # We can use dynamic programming or a greedy approach.\n    # dp[current_p] = minimum number of nodes to achieve 'current_p' reachable-from-each-other pairs.\n    # dp[0] = 0.\n    # dp[x] = min(dp[x - i*(i-1)/2] + i) for i >= 1 such that i*(i-1)/2 <= x.\n    # The maximum value for i*(i-1)/2 is p.\n    # The maximum i such that i*(i-1)/2 <= 2e5 is when i^2 approx 4e5, i approx 632.\n    # This DP approach would be O(p * sqrt(p)), which is too slow (2e5 * 632).\n\n    # Let's consider the structure of the graph.\n    # The p pairs must come from nodes within the same SCCs.\n    # Let the sizes of the SCCs be s_1, s_2, ..., s_k.\n    # We have sum(s_i * (s_i - 1) / 2) = p.\n    # We want to minimize N = sum(s_i).\n    # To minimize sum(s_i) for a fixed sum(s_i * (s_i - 1) / 2), we should make the s_i values as large as possible.\n    # This is a known result: to minimize the sum of elements given a sum of a convex function of elements,\n    # make the elements as large as possible (i.e., use fewer elements).\n    # So we should try to use one large SCC, or a few large SCCs.\n\n    # Iterate through possible number of nodes n.\n    # For a given n, what is the maximum number of reachable-from-each-other pairs (p_max)\n    # and minimum number of reachable-from-each-other pairs (p_min)?\n    # p_min occurs when all s_i = 1, so p_min = 0.\n    # p_max occurs when one SCC has size n, so p_max = n * (n-1) / 2.\n    # We are looking for the smallest n such that it's possible to achieve p.\n\n    # Let's precompute the values of k * (k-1) / 2.\n    # max_val = 2 * 10^5\n    # Max k for k*(k-1)/2 <= 2e5 is k approx sqrt(4e5) approx 632.\n    scc_pairs = [0] * 635\n    for i in range(1, 635):\n        scc_pairs[i] = i * (i - 1) // 2\n\n    # min_nodes_for_p[val] = minimum nodes to get 'val' reachable-from-each-other pairs\n    min_nodes_for_p = [float('inf')] * (p + 1)\n    min_nodes_for_p[0] = 0\n\n    for current_p_val in range(p + 1):\n        if min_nodes_for_p[current_p_val] == float('inf'):\n            continue\n        for scc_size in range(1, 635):\n            pairs_from_scc = scc_pairs[scc_size]\n            if current_p_val + pairs_from_scc <= p:\n                new_nodes = min_nodes_for_p[current_p_val] + scc_size\n                if new_nodes < min_nodes_for_p[current_p_val + pairs_from_scc]:\n                    min_nodes_for_p[current_p_val + pairs_from_scc] = new_nodes\n            else:\n                # Optimization: if current_p_val + pairs_from_scc > p,\n                # we don't need to consider larger scc_sizes for this current_p_val\n                # because pairs_from_scc only increases with scc_size.\n                # However, this is not entirely correct. We need to iterate over all possible scc_size\n                # to build up the min_nodes_for_p table.\n                pass # The check `if current_p_val + pairs_from_scc <= p` handles this.\n\n    min_nodes = min_nodes_for_p[p]\n\n    # Now we have min_nodes. We need to find the max_unidirectional_pairs.\n    # This means we have 'min_nodes' nodes in total.\n    # Some of them are used in SCCs to get 'p' reachable-from-each-other pairs.\n    # Let these nodes be s_1, s_2, ..., s_k such that sum(s_i) = N_scc_used and sum(s_i * (s_i - 1) / 2) = p.\n    # The remaining nodes are N_remaining = min_nodes - N_scc_used.\n    # To maximize unidirectional pairs, we want to arrange these SCCs and remaining nodes.\n    # The most effective way to create unidirectional pairs is to have a linear chain of SCCs/nodes.\n    # If we have k SCCs of sizes s_1, ..., s_k, and m isolated nodes (s_i=1),\n    # and we arrange them in a chain (e.g., s_1 -> s_2 -> ... -> s_k -> 1 -> 1 -> ... -> 1),\n    # the number of unidirectional pairs is (sum of nodes in first j SCCs) * (sum of nodes in remaining SCCs)\n    # for all j.\n    # More simply, if we have N_total nodes, and these are partitioned into components C_1, C_2, ..., C_M\n    # where each C_i is either an SCC or a single node (which is an SCC of size 1).\n    # If we arrange these M components in a linear order, say C_1 -> C_2 -> ... -> C_M,\n    # then for any u in C_i and v in C_j with i < j, u can reach v but v cannot reach u.\n    # The number of unidirectional pairs is sum_{i=1 to M-1} (size(C_i) * sum_{j=i+1 to M} size(C_j)).\n    # This is equivalent to sum_{i=1 to M-1} (size(C_i) * (N_total - sum_{l=1 to i} size(C_l))).\n    # This is maximized when the components are arranged such that larger components are at the ends\n    # or when they are arranged such that the \"middle\" components are small.\n    # A simpler way to count this: total possible pairs (u,v) with u != v is N_total * (N_total - 1).\n    # Pairs within the same SCC are 2 * p.\n    # So the remaining pairs are N_total * (N_total - 1) - 2 * p.\n    # These remaining pairs are either unidirectional or non-reachable.\n    # If we arrange all SCCs and individual nodes in a single line, then all pairs (u,v) with u in C_i, v in C_j, i < j\n    # are unidirectional. All pairs (u,v) with u in C_j, v in C_i, i < j are also unidirectional.\n    # So the total number of unidirectional pairs is N_total * (N_total - 1) - 2 * p.\n    # This is the maximum possible number of unidirectional pairs.\n    # This strategy works: create a path where each node is either an SCC or a single node.\n    # For example, if we have SCCs of sizes s_1, ..., s_k and N_rem isolated nodes.\n    # We can arrange them as s_1 -> s_2 -> ... -> s_k -> 1 -> 1 -> ... -> 1.\n    # All pairs (u,v) with u in C_i and v in C_j (i != j) will be unidirectional.\n    # The total number of pairs (u,v) with u != v is N_total * (N_total - 1).\n    # The number of pairs (u,v) where u and v are in the same SCC is 2 * p.\n    # The remaining N_total * (N_total - 1) - 2 * p pairs must be unidirectional.\n    # This is because in a path-like structure of SCCs, if u and v are in different SCCs,\n    # say u in SCC_i and v in SCC_j, then either i < j (u can reach v, v cannot reach u)\n    # or j < i (v can reach u, u cannot reach v). In both cases, (u,v) is unidirectional.\n    # So, the maximum number of unidirectional pairs is min_nodes * (min_nodes - 1) - 2 * p.\n    max_unidirectional_pairs = min_nodes * (min_nodes - 1) - 2 * p\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 2911,
        "thoughts_token_count": 0
    }
}