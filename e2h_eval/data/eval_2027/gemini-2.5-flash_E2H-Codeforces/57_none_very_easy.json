{
    "start": 1758293682.6914854,
    "end": 1758293705.0550792,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He can pick the largest available 'a' and largest available 'b'.\n    # To find his best rank, we need to find the minimum number of participants who *could* have a higher score than Vasya's maximum possible score.\n    # Vasya's maximum possible score is a[n-1] + b[n-1].\n    # However, the problem states Vasya got at least x points.\n    # For the best rank, Vasya wants to achieve the highest possible score, say A_vasya + B_vasya.\n    # The other participants will be assigned scores such that as few as possible exceed Vasya's score.\n    # This means other participants should be assigned minimum possible scores.\n    # The best rank is 1. This is always achievable because Vasya can pick a_i and b_j such that a_i + b_j is maximized, and this maximum sum is guaranteed to be at least x.\n    # If there are other participants with the same maximum sum, Vasya can still be assigned 1st place by the jury.\n    # So, the best rank is always 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but it must be at least x.\n    # The other participants want to maximize their scores to push Vasya down.\n    # To find the worst rank, we need to count how many participants *could* have a score strictly greater than Vasya's score.\n    # Vasya's score (A_vasya + B_vasya) must be >= x.\n    # We want to find the minimum possible value for A_vasya + B_vasya such that it's >= x.\n    # Let's say Vasya got a_i and b_j such that a_i + b_j >= x.\n    # To make his rank as bad as possible, we want to make his score as small as possible, while satisfying a_i + b_j >= x.\n    # And we want to assign other participants scores such that as many as possible are strictly greater than Vasya's score.\n\n    # This is a matching problem. We want to find a permutation of b that, when added to a,\n    # maximizes the number of pairs (a_k, b_p) such that a_k + b_p > Vasya's score.\n    # Vasya's score is (a_i + b_j) for some i, j such that a_i + b_j >= x.\n    # And we want to pick i, j such that this (a_i + b_j) is minimized.\n\n    # Let's rephrase: we need to find the maximum number of participants who can achieve a score strictly greater than some S,\n    # where S is a possible score for Vasya (S >= x).\n    # To maximize Vasya's rank (i.e., get a lower number), we assume Vasya gets the highest possible score.\n    # To minimize Vasya's rank (i.e., get a higher number), we assume Vasya gets the lowest possible score (but still >= x).\n\n    # Consider the worst case for Vasya.\n    # Vasya will be assigned some (a_i, b_j) such that a_i + b_j >= x.\n    # To make his rank as bad as possible, we want to find the maximum number of people who can score *strictly more* than him.\n    # This means Vasya should be assigned the lowest possible score S (where S >= x).\n    # And then, we try to form as many pairs (a_k, b_p) such that a_k + b_p > S.\n    # And then, among those who score S, Vasya is assigned the worst possible tie-breaking position.\n\n    # Let's count how many pairs (a_k, b_p) can sum up to at least X.\n    # We can use a two-pointer approach for this.\n    # Sort 'a' in ascending order and 'b' in descending order.\n    # Iterate through 'a'. For each a[i], find how many b[j] satisfy a[i] + b[j] >= x.\n    # This count gives us the number of participants who *could* score at least x.\n    # This is not directly for worst rank.\n\n    # Let's think about the worst rank directly.\n    # We need to find a pairing of (a, b) such that Vasya's score is minimized (but >= x),\n    # and the number of people with a strictly higher score is maximized.\n    # Then, if there are ties with Vasya's score, Vasya gets the worst position among them.\n\n    # To maximize the number of people with score > S, we should pair large 'a's with large 'b's.\n    # But we also need to account for Vasya's specific score.\n\n    # This is a classic matching problem.\n    # For a given score S, how many pairs (a_i, b_j) can be formed such that a_i + b_j > S?\n    # We can use a greedy approach. Sort 'a' in ascending order. Sort 'b' in descending order.\n    # For each a_i, we try to match it with the largest possible b_j such that a_i + b_j > S.\n    # This is not quite right because we need to form n distinct pairs.\n\n    # Let's count the number of participants who can score *at least* S.\n    # Sort 'a' and 'b' in ascending order.\n    # Use two pointers: `ptr_a` for 'a' and `ptr_b` for 'b'.\n    # `ptr_a` starts at 0, `ptr_b` starts at n-1.\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= x`:\n    #     This pair `(a[ptr_a], b[ptr_b])` can achieve at least x. We use `b[ptr_b]` and move to the next smaller `b`.\n    #     `count_ge_x += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < x`):\n    #     `a[ptr_a]` is too small to combine with `b[ptr_b]` to reach `x`. We need a larger `a`.\n    #     `ptr_a += 1`\n    # This `count_ge_x` is the maximum number of people who *can* score at least `x`.\n    # This is exactly the worst rank.\n    # Why?\n    # Suppose `k` is this count.\n    # This means we can form `k` pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\n    # And for the remaining `n-k` pairs, their sum will be less than `x`.\n    # In the worst case, Vasya is one of these `k` people.\n    # The jury can arrange the scores such that Vasya gets the lowest possible score among these `k` people (but still >= x).\n    # And all `k-1` other people are assigned scores that are greater than or equal to Vasya's score.\n    # If all `k` people get scores `S_1, S_2, ..., S_k` where all `S_m >= x`,\n    # and the remaining `n-k` people get scores `S_{k+1}, ..., S_n` where all `S_m < x`.\n    # Then Vasya's rank will be at worst `k` (if he gets the lowest score among the `k` people, and all `k` people are tied, he gets the last position among them).\n    # The `n-k` people who scored less than `x` will definitely be ranked below Vasya.\n\n    # Let's formalize the worst rank calculation.\n    # We want to find the maximum number of people who can achieve a score >= x.\n    # Let this count be `k`.\n    # If we can find `k` pairs (a_i, b_j) such that a_i + b_j >= x,\n    # and the remaining `n-k` pairs have a sum < x.\n    # Then Vasya's worst rank is `k`.\n    # Example: a = [1,1,1,1,1], b = [1,1,1,1,1], x = 2, n = 5\n    # a.sort() -> [1,1,1,1,1]\n    # b.sort() -> [1,1,1,1,1]\n    # ptr_a = 0, ptr_b = 4\n    # a[0]+b[4] = 1+1 = 2 >= x. count_ge_x = 1. ptr_a = 1, ptr_b = 3\n    # a[1]+b[3] = 1+1 = 2 >= x. count_ge_x = 2. ptr_a = 2, ptr_b = 2\n    # a[2]+b[2] = 1+1 = 2 >= x. count_ge_x = 3. ptr_a = 3, ptr_b = 1\n    # a[3]+b[1] = 1+1 = 2 >= x. count_ge_x = 4. ptr_a = 4, ptr_b = 0\n    # a[4]+b[0] = 1+1 = 2 >= x. count_ge_x = 5. ptr_a = 5, ptr_b = -1\n    # Loop ends. worst_rank = 5. This matches example output.\n\n    # Example 2: n=6, x=7\n    # a = [4, 3, 5, 6, 4, 4] -> sorted a = [3, 4, 4, 4, 5, 6]\n    # b = [8, 6, 0, 4, 3, 4] -> sorted b = [0, 3, 4, 4, 6, 8]\n\n    # ptr_a = 0 (val 3), ptr_b = 5 (val 8)\n    # a[0]+b[5] = 3+8 = 11 >= 7. count_ge_x = 1. ptr_a = 1, ptr_b = 4\n    # ptr_a = 1 (val 4), ptr_b = 4 (val 6)\n    # a[1]+b[4] = 4+6 = 10 >= 7. count_ge_x = 2. ptr_a = 2, ptr_b = 3\n    # ptr_a = 2 (val 4), ptr_b = 3 (val 4)\n    # a[2]+b[3] = 4+4 = 8 >= 7. count_ge_x = 3. ptr_a = 3, ptr_b = 2\n    # ptr_a = 3 (val 4), ptr_b = 2 (val 4)\n    # a[3]+b[2] = 4+4 = 8 >= 7. count_ge_x = 4. ptr_a = 4, ptr_b = 1\n    # ptr_a = 4 (val 5), ptr_b = 1 (val 3)\n    # a[4]+b[1] = 5+3 = 8 >= 7. count_ge_x = 5. ptr_a = 5, ptr_b = 0\n    # ptr_a = 5 (val 6), ptr_b = 0 (val 0)\n    # a[5]+b[0] = 6+0 = 6 < 7. Need larger a. ptr_a = 6.\n    # Loop ends. ptr_a = 6.\n    # worst_rank = 5. This matches example output.\n\n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            worst_rank += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # If a[ptr_a] + b[ptr_b] < x, then a[ptr_a] is too small to make x even with the current b[ptr_b].\n            # Since a is sorted ascending, any a[k] with k < ptr_a will also be too small.\n            # So we must try a larger a[ptr_a].\n            ptr_a += 1\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He can pick the largest available 'a' and largest available 'b'.\n    # To find his best rank, we need to find the minimum number of participants who *could* have a higher score than Vasya's maximum possible score.\n    # Vasya's maximum possible score is a[n-1] + b[n-1].\n    # However, the problem states Vasya got at least x points.\n    # For the best rank, Vasya wants to achieve the highest possible score, say A_vasya + B_vasya.\n    # The other participants will be assigned scores such that as few as possible exceed Vasya's score.\n    # This means other participants should be assigned minimum possible scores.\n    # The best rank is 1. This is always achievable because Vasya can pick a_i and b_j such that a_i + b_j is maximized, and this maximum sum is guaranteed to be at least x.\n    # If there are other participants with the same maximum sum, Vasya can still be assigned 1st place by the jury.\n    # So, the best rank is always 1.\n\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but it must be at least x.\n    # The other participants want to maximize their scores to push Vasya down.\n    # To find the worst rank, we need to count how many participants *could* have a score strictly greater than Vasya's score.\n    # Vasya's score (A_vasya + B_vasya) must be >= x.\n    # We want to find the minimum possible value for A_vasya + B_vasya such that it's >= x.\n    # Let's say Vasya got a_i and b_j such that a_i + b_j >= x.\n    # To make his rank as bad as possible, we want to make his score as small as possible, while satisfying a_i + b_j >= x.\n    # And we want to assign other participants scores such that as many as possible are strictly greater than Vasya's score.\n\n    # This is a matching problem. We want to find a permutation of b that, when added to a,\n    # maximizes the number of pairs (a_k, b_p) such that a_k + b_p > Vasya's score.\n    # Vasya's score is (a_i + b_j) for some i, j such that a_i + b_j >= x.\n    # And we want to pick i, j such that this (a_i + b_j) is minimized.\n\n    # Let's rephrase: we need to find the maximum number of participants who can achieve a score strictly greater than some S,\n    # where S is a possible score for Vasya (S >= x).\n    # To maximize Vasya's rank (i.e., get a lower number), we assume Vasya gets the highest possible score.\n    # To minimize Vasya's rank (i.e., get a higher number), we assume Vasya gets the lowest possible score (but still >= x).\n\n    # Consider the worst case for Vasya.\n    # Vasya will be assigned some (a_i, b_j) such that a_i + b_j >= x.\n    # To make his rank as bad as possible, we want to find the maximum number of people who can score *strictly more* than him.\n    # This means Vasya should be assigned the lowest possible score S (where S >= x).\n    # And then, we try to form as many pairs (a_k, b_p) such that a_k + b_p > S.\n    # And then, among those who score S, Vasya is assigned the worst possible tie-breaking position.\n\n    # Let's count how many pairs (a_k, b_p) can sum up to at least X.\n    # We can use a two-pointer approach for this.\n    # Sort 'a' in ascending order and 'b' in descending order.\n    # Iterate through 'a'. For each a[i], find how many b[j] satisfy a[i] + b[j] >= x.\n    # This count gives us the number of participants who *could* score at least x.\n    # This is not directly for worst rank.\n\n    # Let's think about the worst rank directly.\n    # We need to find a pairing of (a, b) such that Vasya's score is minimized (but >= x),\n    # and the number of people with a strictly higher score is maximized.\n    # Then, if there are ties with Vasya's score, Vasya gets the worst position among them.\n\n    # To maximize the number of people with score > S, we should pair large 'a's with large 'b's.\n    # But we also need to account for Vasya's specific score.\n\n    # This is a classic matching problem.\n    # For a given score S, how many pairs (a_i, b_j) can be formed such that a_i + b_j > S?\n    # We can use a greedy approach. Sort 'a' in ascending order. Sort 'b' in descending order.\n    # For each a_i, we try to match it with the largest possible b_j such that a_i + b_j > S.\n    # This is not quite right because we need to form n distinct pairs.\n\n    # Let's count the number of participants who can score *at least* S.\n    # Sort 'a' and 'b' in ascending order.\n    # Use two pointers: `ptr_a` for 'a' and `ptr_b` for 'b'.\n    # `ptr_a` starts at 0, `ptr_b` starts at n-1.\n    # While `ptr_a < n` and `ptr_b >= 0`:\n    #   If `a[ptr_a] + b[ptr_b] >= x`:\n    #     This pair `(a[ptr_a], b[ptr_b])` can achieve at least x. We use `b[ptr_b]` and move to the next smaller `b`.\n    #     `count_ge_x += 1`\n    #     `ptr_a += 1`\n    #     `ptr_b -= 1`\n    #   Else (`a[ptr_a] + b[ptr_b] < x`):\n    #     `a[ptr_a]` is too small to combine with `b[ptr_b]` to reach `x`. We need a larger `a`.\n    #     `ptr_a += 1`\n    # This `count_ge_x` is the maximum number of people who *can* score at least `x`.\n    # This is exactly the worst rank.\n    # Why?\n    # Suppose `k` is this count.\n    # This means we can form `k` pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\n    # And for the remaining `n-k` pairs, their sum will be less than `x`.\n    # In the worst case, Vasya is one of these `k` people.\n    # The jury can arrange the scores such that Vasya gets the lowest possible score among these `k` people (but still >= x).\n    # And all `k-1` other people are assigned scores that are greater than or equal to Vasya's score.\n    # If all `k` people get scores `S_1, S_2, ..., S_k` where all `S_m >= x`,\n    # and the remaining `n-k` people get scores `S_{k+1}, ..., S_n` where all `S_m < x`.\n    # Then Vasya's rank will be at worst `k` (if he gets the lowest score among the `k` people, and all `k` people are tied, he gets the last position among them).\n    # The `n-k` people who scored less than `x` will definitely be ranked below Vasya.\n\n    # Let's formalize the worst rank calculation.\n    # We want to find the maximum number of people who can achieve a score >= x.\n    # Let this count be `k`.\n    # If we can find `k` pairs (a_i, b_j) such that a_i + b_j >= x,\n    # and the remaining `n-k` pairs have a sum < x.\n    # Then Vasya's worst rank is `k`.\n    # Example: a = [1,1,1,1,1], b = [1,1,1,1,1], x = 2, n = 5\n    # a.sort() -> [1,1,1,1,1]\n    # b.sort() -> [1,1,1,1,1]\n    # ptr_a = 0, ptr_b = 4\n    # a[0]+b[4] = 1+1 = 2 >= x. count_ge_x = 1. ptr_a = 1, ptr_b = 3\n    # a[1]+b[3] = 1+1 = 2 >= x. count_ge_x = 2. ptr_a = 2, ptr_b = 2\n    # a[2]+b[2] = 1+1 = 2 >= x. count_ge_x = 3. ptr_a = 3, ptr_b = 1\n    # a[3]+b[1] = 1+1 = 2 >= x. count_ge_x = 4. ptr_a = 4, ptr_b = 0\n    # a[4]+b[0] = 1+1 = 2 >= x. count_ge_x = 5. ptr_a = 5, ptr_b = -1\n    # Loop ends. worst_rank = 5. This matches example output.\n\n    # Example 2: n=6, x=7\n    # a = [4, 3, 5, 6, 4, 4] -> sorted a = [3, 4, 4, 4, 5, 6]\n    # b = [8, 6, 0, 4, 3, 4] -> sorted b = [0, 3, 4, 4, 6, 8]\n\n    # ptr_a = 0 (val 3), ptr_b = 5 (val 8)\n    # a[0]+b[5] = 3+8 = 11 >= 7. count_ge_x = 1. ptr_a = 1, ptr_b = 4\n    # ptr_a = 1 (val 4), ptr_b = 4 (val 6)\n    # a[1]+b[4] = 4+6 = 10 >= 7. count_ge_x = 2. ptr_a = 2, ptr_b = 3\n    # ptr_a = 2 (val 4), ptr_b = 3 (val 4)\n    # a[2]+b[3] = 4+4 = 8 >= 7. count_ge_x = 3. ptr_a = 3, ptr_b = 2\n    # ptr_a = 3 (val 4), ptr_b = 2 (val 4)\n    # a[3]+b[2] = 4+4 = 8 >= 7. count_ge_x = 4. ptr_a = 4, ptr_b = 1\n    # ptr_a = 4 (val 5), ptr_b = 1 (val 3)\n    # a[4]+b[1] = 5+3 = 8 >= 7. count_ge_x = 5. ptr_a = 5, ptr_b = 0\n    # ptr_a = 5 (val 6), ptr_b = 0 (val 0)\n    # a[5]+b[0] = 6+0 = 6 < 7. Need larger a. ptr_a = 6.\n    # Loop ends. ptr_a = 6.\n    # worst_rank = 5. This matches example output.\n\n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            worst_rank += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # If a[ptr_a] + b[ptr_b] < x, then a[ptr_a] is too small to make x even with the current b[ptr_b].\n            # Since a is sorted ascending, any a[k] with k < ptr_a will also be too small.\n            # So we must try a larger a[ptr_a].\n            ptr_a += 1\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 3120,
        "thoughts_token_count": 0
    }
}