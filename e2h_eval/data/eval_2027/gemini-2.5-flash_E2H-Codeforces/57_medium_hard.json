{
    "start": 1758294749.0216005,
    "end": 1758294840.791825,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:14 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**My approach to this competitive programming problem is as follows:**\n\nI'm tasked with determining the best and worst possible ranks Vasya could achieve in an Olympiad, given his minimum total score and the scores of all participants across two tours. The core challenge lies in understanding how to distribute the scores optimally, since we don't know the pairings beforehand.\n\nFirst, I need to understand the constraints and scoring rules. The ranks depend on the total points, and ties are handled arbitrarily. Vasya's total score must be at least 'x', and there's a guaranteed one-to-one mapping between the tour scores, even though we don't know the pairings. This means my primary job is to find the right score distribution for Vasya's *best* and *worst* possible rank.\n\nTo find the *best* rank, the goal is to maximize Vasya's score and minimize the scores of others.  I've reasoned that the best rank should always be 1 because, while other participants' scores and scores' pairings are unknown, since Vasya's possible scores depend on *some* pairings which will have `ai+bj >= x`, Vasya can simply choose the largest combination possible, thereby achieving a rank of 1 since he would always get the highest score.\n\nFor the *worst* rank, I have to minimize Vasya's score (while still meeting the 'x' threshold) and maximize the scores of other participants. It's a game of strategic allocation. I'm considering using two pointers, pairing sorted scores to maximize others' scores, making it harder for Vasya to achieve a good rank.\n\nI need to iterate through all possible tour 1 scores for Vasya, find the minimum paired tour 2 score needed to meet the score floor, and then analyze the remaining scores to establish how many participants can score higher than Vasya. By doing this I have to find the `x` value with the lowest score possible, but which can still lead to the worst rank possible. This is where the strategy is key to my solution.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given the scores of all `n` participants in two tours. We are given `n` scores for the first tour (`a`) and `n` scores for the second tour (`b`), but without names. This means we can match any `a_i` with any `b_j` to form a participant's total score. Vasya's total score `S_V` must be at least `x`. We are guaranteed that such a pair `(a_i, b_j)` exists.\n\nThe ranking rules are:\n1. Participants are sorted by total points in decreasing order.\n2. If two or more participants have the same total points, the jury can assign places arbitrarily.\n\nLet `S_P` be a participant's total score.\nA participant's rank is `1 + (number of people with strictly more points) + (number of people with same points if they are ranked before this participant)`.\n\n**1. Best Possible Rank for Vasya**\n\nTo achieve the best possible rank, Vasya wants to:\n*   Maximize his own total score.\n*   Minimize the scores of all other participants.\n\nThe maximum possible total score any participant can achieve is `max(a) + max(b)`. Let `A_max = max(a)` and `B_max = max(b)`.\nSince we are guaranteed that there exist `a_i, b_j` such that `a_i + b_j >= x`, and `A_max + B_max` is the largest possible sum, it must be that `A_max + B_max >= x`.\nTherefore, Vasya can claim `A_max` as his Tour 1 score and `B_max` as his Tour 2 score, resulting in `S_V = A_max + B_max`. This is the highest possible score any participant can get.\n\nIf Vasya has the highest possible score, no one can score strictly more than him. If other participants also score `S_V`, the jury can choose to place Vasya first among them. Thus, Vasya can always achieve **Rank 1**.\n\n**2. Worst Possible Rank for Vasya**\n\nTo achieve the worst possible rank, Vasya wants to:\n*   Minimize his own total score `S_V`, subject to `S_V >= x`.\n*   Maximize the scores of other participants, especially those who score higher than or equal to `S_V`.\n\nThis means we need to find a pairing of all `n` scores `(a_k, b_l)` such that one pair `(a_V, b_V)` is Vasya's, `a_V + b_V >= x`, and the number of participants `P` (including Vasya) whose score `S_P >= S_V` is maximized. This count `C` will be Vasya's worst rank (if he is placed last among those with score `S_V`).\n\nLet's sort both `a` and `b` in ascending order: `a_sorted` and `b_sorted`.\n\nConsider a specific pair `(a_i, b_j)` that Vasya could take. His score would be `S_V = a_i + b_j`. We need `S_V >= x`.\nThe remaining `n-1` scores from `a` (excluding `a_i`) and `n-1` scores from `b` (excluding `b_j`) must be paired among the other `n-1` participants. To maximize the number of people who score `S_P >= S_V`, we should pair the remaining scores in a way that generates as many high scores as possible. The strategy for this is to pair the largest remaining `a` with the largest remaining `b`, the second largest with the second largest, and so on.\n\nThis approach of trying every `(a_i, b_j)` for Vasya is `O(N^2)`, which is too slow for `N=10^5`.\n\nA more efficient approach for the worst rank:\nThe number of people who score at least `T` points can be found efficiently. Let `a_sorted` be sorted ascending and `b_sorted` be sorted ascending. To maximize the number of pairs `(a_p, b_q)` such that `a_p + b_q >= T`:\nUse a two-pointer approach:\nInitialize `count = 0`.\n`ptr_a = 0` (points to smallest `a_p`)\n`ptr_b = n-1` (points to largest `b_q`)\nWhile `ptr_a < n` and `ptr_b >= 0`:\n  If `a_sorted[ptr_a] + b_sorted[ptr_b] >= T`:\n    We can form a pair `(a_sorted[ptr_a], b_sorted[ptr_b])` that meets the threshold. Increment `count`, move `ptr_a` forward, move `ptr_b` backward.\n  Else (`a_sorted[ptr_a] + b_sorted[ptr_b] < T`):\n    `a_sorted[ptr_a]` is too small to form a pair with `b_sorted[ptr_b]` (the largest available `b`). It won't form a pair with any smaller `b` either. So, `a_sorted[ptr_a]` cannot be part of a pair that meets the threshold `T` using `b_sorted[ptr_b]` or smaller `b`s. We must use a larger `a_p`. Move `ptr_a` forward.\nThis greedy strategy works because if `a_sorted[ptr_a]` can form a pair with `b_sorted[ptr_b]`, forming this pair is optimal. If it cannot, `a_sorted[ptr_a]` must be discarded (or used in a pair below `T`), so we move to `a_sorted[ptr_a+1]`.\n\nNow, we need to find Vasya's worst rank. This means we need to find a configuration (Vasya's scores and others' scores) that maximizes `1 + (number of others with score >= Vasya's score)`.\nLet `a_sorted = sorted(a)` and `b_sorted = sorted(b)`.\nWe are looking for the maximum possible count `C` such that there exists a pairing of `n` scores `(a_p, b_q)` where `C` of these pairs sum to at least `T_min`, and `T_min >= x`. We want to maximize `C`.\n\nThis is equivalent to finding the maximum `k` such that we can form `k` pairs `(a_p, b_q)` where `a_p + b_q >= x`.\nLet `a_sorted` be sorted ascending, and `b_sorted` be sorted descending.\n`a_asc = sorted(a)`\n`b_desc = sorted(b, reverse=True)`\n\nWe can use a two-pointer approach to find the maximum number of people who can score at least `x` points.\nLet `count = 0`.\n`ptr_a = 0` (points to smallest `a_asc`)\n`ptr_b = 0` (points to largest `b_desc`)\nWhile `ptr_a < n` and `ptr_b < n`:\n  If `a_asc[ptr_a] + b_desc[ptr_b] >= x`:\n    We can form a pair `(a_asc[ptr_a], b_desc[ptr_b])` that scores at least `x`. This pair contributes to the count of participants who score at least `x`.\n    Increment `count`.\n    Move `ptr_a` forward (`ptr_a++`).\n    Move `ptr_b` forward (`ptr_b++`).\n  Else (`a_asc[ptr_a] + b_desc[ptr_b] < x`):\n    `a_asc[ptr_a]` is too small to form a pair with `b_desc[ptr_b]` (the largest available `b`) to reach `x`. To reach `x`, we need a larger `a` score for `a_asc[ptr_a]`. But we are pairing `a_asc` with `b_desc`. So, `a_asc[ptr_a]` cannot form a pair `>= x` with any of the remaining `b_desc` values if it can't with `b_desc[ptr_b]`. Therefore, `a_asc[ptr_a]` must be paired with some `b_desc[j]` such that `a_asc[ptr_a] + b_desc[j] < x`. This `a_asc[ptr_a]` cannot contribute to the count of people scoring `>= x`. We effectively \"discard\" `a_asc[ptr_a]` from consideration for forming a `>=x` pair.\n    Move `ptr_a` forward (`ptr_a++`).\n\nThe `count` obtained from this two-pointer approach is the maximum number of participants (including Vasya) who can achieve a score of at least `x`.\nSince we want Vasya's *worst* rank, the jury can place him last among all participants who score at least `x`. So, his worst rank will be this `count`.\n\nLet's trace this for the examples:\n\n**Example 1:**\n`n=5, x=2`\n`a = [1, 1, 1, 1, 1]`\n`b = [1, 1, 1, 1, 1]`\n\n`a_asc = [1, 1, 1, 1, 1]`\n`b_desc = [1, 1, 1, 1, 1]`\n\n`ptr_a = 0, ptr_b = 0, count = 0`\n1. `a_asc[0] + b_desc[0] = 1 + 1 = 2`. `2 >= x` (2). Yes.\n   `count = 1`, `ptr_a = 1`, `ptr_b = 1`.\n2. `a_asc[1] + b_desc[1] = 1 + 1 = 2`. `2 >= x` (2). Yes.\n   `count = 2`, `ptr_a = 2`, `ptr_b = 2`.\n3. `a_asc[2] + b_desc[2] = 1 + 1 = 2`. `2 >= x` (2). Yes.\n   `count = 3`, `ptr_a = 3`, `ptr_b = 3`.\n4. `a_asc[3] + b_desc[3] = 1 + 1 = 2`. `2 >= x` (2). Yes.\n   `count = 4`, `ptr_a = 4`, `ptr_b = 4`.\n5. `a_asc[4] + b_desc[4] = 1 + 1 = 2`. `2 >= x` (2). Yes.\n   `count = 5`, `ptr_a = 5`, `ptr_b = 5`.\nLoop ends. `count = 5`.\nWorst rank = 5.\nOutput: `1 5`. Matches.\n\n**Example 2:**\n`n=6, x=7`\n`a = [4, 3, 5, 6, 4, 4]`\n`b = [8, 6, 0, 4, 3, 4]`\n\n`a_asc = sorted(a) = [3, 4, 4, 4, 5, 6]`\n`b_desc = sorted(b, reverse=True) = [8, 6, 4, 4, 3, 0]`\n\n`ptr_a = 0, ptr_b = 0, count = 0`\n1. `a_asc[0] + b_desc[0] = 3 + 8 = 11`. `11 >= x` (7). Yes.\n   `count = 1`, `ptr_a = 1`, `ptr_b = 1`.\n2. `a_asc[1] + b_desc[1] = 4 + 6 = 10`. `10 >= x` (7). Yes.\n   `count = 2`, `ptr_a = 2`, `ptr_b = 2`.\n3. `a_asc[2] + b_desc[2] = 4 + 4 = 8`. `8 >= x` (7). Yes.\n   `count = 3`, `ptr_a = 3`, `ptr_b = 3`.\n4. `a_asc[3] + b_desc[3] = 4 + 4 = 8`. `8 >= x` (7). Yes.\n   `count = 4`, `ptr_a = 4`, `ptr_b = 4`.\n5. `a_asc[4] + b_desc[4] = 5 + 3 = 8`. `8 >= x` (7). Yes.\n   `count = 5`, `ptr_a = 5`, `ptr_b = 5`.\n6. `a_asc[5] + b_desc[5] = 6 + 0 = 6`. `6 >= x` (7). No.\n   `ptr_a = 6`.\nLoop ends because `ptr_a == n`. `count = 5`.\nWorst rank = 5.\nOutput: `1 5`. Matches.\n\nThis logic holds. The best rank is always 1. The worst rank is the maximum number of participants (including Vasya) that can achieve a score of at least `x`, determined by pairing the smallest available `a` scores with the largest available `b` scores.\n\n**Complexity:**\n*   Sorting `a`: `O(N log N)`\n*   Sorting `b`: `O(N log N)`\n*   Two-pointer scan: `O(N)`\nTotal time complexity: `O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays.\nThis is efficient enough for `N=10^5`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya\n    # Vasya can always choose the highest score from tour 1 and the highest score from tour 2.\n    # Let these be a_max and b_max. His score would be a_max + b_max.\n    # Since it's guaranteed that some a_i + b_j >= x, then a_max + b_max must also be >= x.\n    # With the highest possible score, no one can score strictly more than Vasya.\n    # If others score the same, the jury can place Vasya first among them.\n    # So, Vasya's best rank is always 1.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # To find the worst rank, we want to maximize the number of people (including Vasya)\n    # who score at least x points.\n    # Vasya's rank will be this count, as the jury can place him last among those with >= x points.\n\n    # Sort 'a' in ascending order.\n    a.sort()\n    # Sort 'b' in descending order.\n    b.sort(reverse=True)\n\n    count_at_least_x = 0\n    ptr_a = 0\n    ptr_b = 0\n\n    # Use a two-pointer approach to find the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= x.\n    # We pair the smallest available 'a' with the largest available 'b'.\n    # If their sum >= x, we count it as a successful pair and move both pointers.\n    # If their sum < x, the current smallest 'a' cannot form a pair >= x with the current largest 'b'\n    # (or any smaller 'b's). So, this 'a' cannot contribute to a sum >= x with any remaining 'b'.\n    # We must discard this 'a' and try the next smallest 'a'.\n    while ptr_a < n and ptr_b < n:\n        if a[ptr_a] + b[ptr_b] >= x:\n            count_at_least_x += 1\n            ptr_a += 1\n            ptr_b += 1\n        else:\n            # a[ptr_a] is too small to reach x even with b[ptr_b] (the current largest available b).\n            # So, a[ptr_a] cannot form a sum >= x with any of the remaining b's.\n            # We must try a larger a score.\n            ptr_a += 1\n    \n    worst_rank = count_at_least_x\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya\n    # Vasya can always choose the highest score from tour 1 and the highest score from tour 2.\n    # Let these be a_max and b_max. His score would be a_max + b_max.\n    # Since it's guaranteed that some a_i + b_j >= x, then a_max + b_max must also be >= x.\n    # With the highest possible score, no one can score strictly more than Vasya.\n    # If others score the same, the jury can place Vasya first among them.\n    # So, Vasya's best rank is always 1.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # To find the worst rank, we want to maximize the number of people (including Vasya)\n    # who score at least x points.\n    # Vasya's rank will be this count, as the jury can place him last among those with >= x points.\n\n    # Sort 'a' in ascending order.\n    a.sort()\n    # Sort 'b' in descending order.\n    b.sort(reverse=True)\n\n    count_at_least_x = 0\n    ptr_a = 0\n    ptr_b = 0\n\n    # Use a two-pointer approach to find the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= x.\n    # We pair the smallest available 'a' with the largest available 'b'.\n    # If their sum >= x, we count it as a successful pair and move both pointers.\n    # If their sum < x, the current smallest 'a' cannot form a pair >= x with the current largest 'b'\n    # (or any smaller 'b's). So, this 'a' cannot contribute to a sum >= x with any remaining 'b'.\n    # We must discard this 'a' and try the next smallest 'a'.\n    while ptr_a < n and ptr_b < n:\n        if a[ptr_a] + b[ptr_b] >= x:\n            count_at_least_x += 1\n            ptr_a += 1\n            ptr_b += 1\n        else:\n            # a[ptr_a] is too small to reach x even with b[ptr_b] (the current largest available b).\n            # So, a[ptr_a] cannot form a sum >= x with any of the remaining b's.\n            # We must try a larger a score.\n            ptr_a += 1\n    \n    worst_rank = count_at_least_x\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 3899,
        "thoughts_token_count": 7378
    }
}