{
    "start": 1758011279.721078,
    "end": 1758011301.1940334,
    "start-formatted": "2025-09-16 17:27 KST",
    "end-formatted": "2025-09-16 17:28 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n\n    # Store minimum cost for a given duration ending at a specific day\n    # min_cost_for_duration_ending_at[duration][end_day] = min_cost\n    # This approach is too memory intensive.\n    # Instead, let's process vouchers by their start day.\n\n    # We need to find two vouchers (i, j) such that:\n    # 1. duration_i + duration_j = x\n    # 2. They don't intersect (r_i < l_j or r_j < l_i)\n    # 3. cost_i + cost_j is minimized\n\n    # Max possible coordinate for l or r\n    MAX_COORD = 2 * 10**5\n\n    # min_cost_for_duration[duration][end_day] stores the minimum cost of a voucher\n    # with 'duration' that ends at 'end_day'.\n    # This structure is still too large.\n\n    # Let's group vouchers by their start day.\n    # vouchers_by_start_day[start_day] = [(r, cost, duration), ...]\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n\n    # This array will store the minimum cost for a voucher with a given duration\n    # that has *already been processed* (i.e., its start day is <= current_l).\n    # min_cost_for_duration_ending_at[duration] = min_cost_of_voucher\n    # This stores the minimum cost for a voucher of a specific duration,\n    # considering all vouchers processed so far that could potentially be the *first* voucher.\n    # The key insight is that we need to update this structure efficiently.\n\n    # Instead, let's use an array to store the minimum cost for a voucher\n    # that *ends* at a specific day, for a specific duration.\n    # min_cost_for_duration_ending_at_day[end_day][duration] = min_cost\n    # Still too large.\n\n    # We need to iterate through vouchers. For each voucher (l_i, r_i, cost_i, dur_i):\n    # We want to find a second voucher (l_j, r_j, cost_j, dur_j) such that:\n    # 1. dur_j = x - dur_i\n    # 2. r_i < l_j OR r_j < l_i\n\n    # Let's iterate through all possible start days from 1 to MAX_COORD.\n    # When we are at start_day `s`:\n    # We consider all vouchers that start at `s`. These are potential \"second\" vouchers.\n    # For each such voucher (r, cost, duration) starting at `s`:\n    #   Let its duration be `d`.\n    #   We need to find a first voucher with duration `x - d`.\n    #   This first voucher must end before `s` (r_first < s).\n    #   We need the minimum cost for such a first voucher.\n\n    # To do this efficiently, we maintain an array `min_cost_for_duration_ending_before_day[duration]`.\n    # This array stores the minimum cost of a voucher with `duration` that ends *before* the current `start_day`.\n    # This array needs to be updated as we sweep through `start_day`.\n\n    # min_cost_ending_at_day[end_day] = min_cost of voucher ending at end_day, for any duration\n    # This is not enough, we need to know the duration.\n\n    # Let's use an array `min_cost_for_duration[duration]`\n    # This array will store the minimum cost of a voucher with `duration` that has been processed so far.\n    # This is useful if we process vouchers in some order.\n\n    # A common technique for \"non-intersecting\" problems is to sort by start/end points.\n    # Let's sort all vouchers by their start day `l`.\n    # When processing voucher `v_i = (l_i, r_i, cost_i, dur_i)`:\n    # We want to find a `v_j = (l_j, r_j, cost_j, dur_j)` such that:\n    # 1. `dur_j = x - dur_i`\n    # 2. `r_j < l_i` OR `r_i < l_j`\n\n    # Let's try iterating through all possible end days `d` from 1 to MAX_COORD.\n    # `min_cost_for_duration_ending_at_day[end_day][duration]` is too much.\n\n    # Let's consider `min_cost_for_duration_that_ends_before_or_at[duration][day]`.\n    # This is the minimum cost of a voucher with `duration` that ends at or before `day`.\n    # This can be computed by iterating `day` from 1 to MAX_COORD and `duration` from 1 to `x`.\n    # `min_cost_for_duration_that_ends_before_or_at[d][day] = min(min_cost_for_duration_that_ends_before_or_at[d][day-1], cost_of_voucher_ending_at_day[d][day])`\n    # This is a DP approach, but still needs `cost_of_voucher_ending_at_day[d][day]`.\n\n    # Let's use `min_cost_for_duration_ending_at_specific_day[end_day]`\n    # This stores a dictionary or list of (duration, cost) for vouchers ending at `end_day`.\n    # `min_cost_for_duration_ending_at_specific_day[day]` could be a list of `(duration, cost)` pairs.\n    # Or, it could be `min_cost_for_duration_ending_at_specific_day[day][duration] = min_cost`.\n    # This structure needs to be sparse.\n\n    # Let's use a sweep-line approach.\n    # Iterate `current_day` from 1 to MAX_COORD.\n    # We maintain `min_cost_for_duration[duration]` = minimum cost of a voucher with `duration`\n    # that *ends at or before* `current_day - 1`.\n    # This `min_cost_for_duration` array should be initialized to infinity.\n\n    # `min_cost_for_duration_ending_at_day[duration]`\n    # This array stores the minimum cost of a voucher with `duration` that has an end_day <= `current_day - 1`.\n    # `min_cost_for_duration_ending_at_day[d]` = min cost of voucher with duration `d`\n    #                                           and `r < current_day`.\n    # This array needs to be updated.\n\n    # Let's define `min_cost_ending_at_day[end_day]` as a list of `(duration, cost)` for vouchers ending on `end_day`.\n    # vouchers_ending_at = [[] for _ in range(MAX_COORD + 1)]\n    # for l, r, cost in vouchers:\n    #     duration = r - l + 1\n    #     vouchers_ending_at[r].append((l, cost, duration))\n\n    # Let's define `min_cost_starting_at_day[start_day]` as a list of `(duration, cost)` for vouchers starting on `start_day`.\n    # vouchers_starting_at = [[] for _ in range(MAX_COORD + 1)]\n    # for l, r, cost in vouchers:\n    #     duration = r - l + 1\n    #     vouchers_starting_at[l].append((r, cost, duration))\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that duration\n    # that has been encountered so far, and whose `r` is less than `current_day`.\n    # Initialize `min_cost_for_duration` array with infinity.\n    min_cost_for_duration = [float('inf')] * (x + 1) # duration can be up to x\n\n    overall_min_cost = float('inf')\n\n    # Group vouchers by their start day\n    vouchers_by_start_day_map = [[] for _ in range(MAX_COORD + 2)] # Use MAX_COORD + 1 for indices\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_start_day_map[l].append((r, cost, duration))\n\n    # Group vouchers by their end day\n    vouchers_by_end_day_map = [[] for _ in range(MAX_COORD + 2)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_end_day_map[r].append((l, cost, duration))\n\n    # Sweep line from day 1 to MAX_COORD\n    # `current_min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that *ends at or before* `current_day - 1`.\n    # This means `r < current_day`.\n    current_min_cost_for_duration = [float('inf')] * (x + 1)\n\n    for day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that *end* at `day - 1`.\n        # These vouchers are now \"available\" to be the first voucher in a pair.\n        # Their `r` value is `day - 1`.\n        # So, for any voucher starting at `day`, it can be paired with these.\n        for l_prev, cost_prev, duration_prev in vouchers_by_end_day_map[day - 1]:\n            if duration_prev <= x:\n                current_min_cost_for_duration[duration_prev] = min(\n                    current_min_cost_for_duration[duration_prev], cost_prev\n                )\n\n        # 2. Process vouchers that *start* at `day`.\n        # These are potential \"second\" vouchers.\n        for r_curr, cost_curr, duration_curr in vouchers_by_start_day_map[day]:\n            if duration_curr < x: # duration_curr cannot be x or more, because x-duration_curr would be 0 or negative\n                needed_duration = x - duration_curr\n                if needed_duration > 0 and needed_duration <= x:\n                    if current_min_cost_for_duration[needed_duration] != float('inf'):\n                        overall_min_cost = min(overall_min_cost, cost_curr + current_min_cost_for_duration[needed_duration])\n\n    if overall_min_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(overall_min_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n\n    # Store minimum cost for a given duration ending at a specific day\n    # min_cost_for_duration_ending_at[duration][end_day] = min_cost\n    # This approach is too memory intensive.\n    # Instead, let's process vouchers by their start day.\n\n    # We need to find two vouchers (i, j) such that:\n    # 1. duration_i + duration_j = x\n    # 2. They don't intersect (r_i < l_j or r_j < l_i)\n    # 3. cost_i + cost_j is minimized\n\n    # Max possible coordinate for l or r\n    MAX_COORD = 2 * 10**5\n\n    # min_cost_for_duration[duration][end_day] stores the minimum cost of a voucher\n    # with 'duration' that ends at 'end_day'.\n    # This structure is still too large.\n\n    # Let's group vouchers by their start day.\n    # vouchers_by_start_day[start_day] = [(r, cost, duration), ...]\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n\n    # This array will store the minimum cost for a voucher with a given duration\n    # that has *already been processed* (i.e., its start day is <= current_l).\n    # min_cost_for_duration_ending_at[duration] = min_cost_of_voucher\n    # This stores the minimum cost for a voucher of a specific duration,\n    # considering all vouchers processed so far that could potentially be the *first* voucher.\n    # The key insight is that we need to update this structure efficiently.\n\n    # Instead, let's use an array to store the minimum cost for a voucher\n    # that *ends* at a specific day, for a specific duration.\n    # min_cost_for_duration_ending_at_day[end_day][duration] = min_cost\n    # Still too large.\n\n    # We need to iterate through vouchers. For each voucher (l_i, r_i, cost_i, dur_i):\n    # We want to find a second voucher (l_j, r_j, cost_j, dur_j) such that:\n    # 1. dur_j = x - dur_i\n    # 2. r_i < l_j OR r_j < l_i\n\n    # Let's iterate through all possible start days from 1 to MAX_COORD.\n    # When we are at start_day `s`:\n    # We consider all vouchers that start at `s`. These are potential \"second\" vouchers.\n    # For each such voucher (r, cost, duration) starting at `s`:\n    #   Let its duration be `d`.\n    #   We need to find a first voucher with duration `x - d`.\n    #   This first voucher must end before `s` (r_first < s).\n    #   We need the minimum cost for such a first voucher.\n\n    # To do this efficiently, we maintain an array `min_cost_for_duration_ending_before_day[duration]`.\n    # This array stores the minimum cost of a voucher with `duration` that ends *before* the current `start_day`.\n    # This array needs to be updated as we sweep through `start_day`.\n\n    # min_cost_ending_at_day[end_day] = min_cost of voucher ending at end_day, for any duration\n    # This is not enough, we need to know the duration.\n\n    # Let's use an array `min_cost_for_duration[duration]`\n    # This array will store the minimum cost of a voucher with `duration` that has been processed so far.\n    # This is useful if we process vouchers in some order.\n\n    # A common technique for \"non-intersecting\" problems is to sort by start/end points.\n    # Let's sort all vouchers by their start day `l`.\n    # When processing voucher `v_i = (l_i, r_i, cost_i, dur_i)`:\n    # We want to find a `v_j = (l_j, r_j, cost_j, dur_j)` such that:\n    # 1. `dur_j = x - dur_i`\n    # 2. `r_j < l_i` OR `r_i < l_j`\n\n    # Let's try iterating through all possible end days `d` from 1 to MAX_COORD.\n    # `min_cost_for_duration_ending_at_day[end_day][duration]` is too much.\n\n    # Let's consider `min_cost_for_duration_that_ends_before_or_at[duration][day]`.\n    # This is the minimum cost of a voucher with `duration` that ends at or before `day`.\n    # This can be computed by iterating `day` from 1 to MAX_COORD and `duration` from 1 to `x`.\n    # `min_cost_for_duration_that_ends_before_or_at[d][day] = min(min_cost_for_duration_that_ends_before_or_at[d][day-1], cost_of_voucher_ending_at_day[d][day])`\n    # This is a DP approach, but still needs `cost_of_voucher_ending_at_day[d][day]`.\n\n    # Let's use `min_cost_for_duration_ending_at_specific_day[end_day]`\n    # This stores a dictionary or list of (duration, cost) for vouchers ending at `end_day`.\n    # `min_cost_for_duration_ending_at_specific_day[day]` could be a list of `(duration, cost)` pairs.\n    # Or, it could be `min_cost_for_duration_ending_at_specific_day[day][duration] = min_cost`.\n    # This structure needs to be sparse.\n\n    # Let's use a sweep-line approach.\n    # Iterate `current_day` from 1 to MAX_COORD.\n    # We maintain `min_cost_for_duration[duration]` = minimum cost of a voucher with `duration`\n    # that *ends at or before* `current_day - 1`.\n    # This `min_cost_for_duration` array should be initialized to infinity.\n\n    # `min_cost_for_duration_ending_at_day[duration]`\n    # This array stores the minimum cost of a voucher with `duration` that has an end_day <= `current_day - 1`.\n    # `min_cost_for_duration_ending_at_day[d]` = min cost of voucher with duration `d`\n    #                                           and `r < current_day`.\n    # This array needs to be updated.\n\n    # Let's define `min_cost_ending_at_day[end_day]` as a list of `(duration, cost)` for vouchers ending on `end_day`.\n    # vouchers_ending_at = [[] for _ in range(MAX_COORD + 1)]\n    # for l, r, cost in vouchers:\n    #     duration = r - l + 1\n    #     vouchers_ending_at[r].append((l, cost, duration))\n\n    # Let's define `min_cost_starting_at_day[start_day]` as a list of `(duration, cost)` for vouchers starting on `start_day`.\n    # vouchers_starting_at = [[] for _ in range(MAX_COORD + 1)]\n    # for l, r, cost in vouchers:\n    #     duration = r - l + 1\n    #     vouchers_starting_at[l].append((r, cost, duration))\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that duration\n    # that has been encountered so far, and whose `r` is less than `current_day`.\n    # Initialize `min_cost_for_duration` array with infinity.\n    min_cost_for_duration = [float('inf')] * (x + 1) # duration can be up to x\n\n    overall_min_cost = float('inf')\n\n    # Group vouchers by their start day\n    vouchers_by_start_day_map = [[] for _ in range(MAX_COORD + 2)] # Use MAX_COORD + 1 for indices\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_start_day_map[l].append((r, cost, duration))\n\n    # Group vouchers by their end day\n    vouchers_by_end_day_map = [[] for _ in range(MAX_COORD + 2)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_end_day_map[r].append((l, cost, duration))\n\n    # Sweep line from day 1 to MAX_COORD\n    # `current_min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that *ends at or before* `current_day - 1`.\n    # This means `r < current_day`.\n    current_min_cost_for_duration = [float('inf')] * (x + 1)\n\n    for day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that *end* at `day - 1`.\n        # These vouchers are now \"available\" to be the first voucher in a pair.\n        # Their `r` value is `day - 1`.\n        # So, for any voucher starting at `day`, it can be paired with these.\n        for l_prev, cost_prev, duration_prev in vouchers_by_end_day_map[day - 1]:\n            if duration_prev <= x:\n                current_min_cost_for_duration[duration_prev] = min(\n                    current_min_cost_for_duration[duration_prev], cost_prev\n                )\n\n        # 2. Process vouchers that *start* at `day`.\n        # These are potential \"second\" vouchers.\n        for r_curr, cost_curr, duration_curr in vouchers_by_start_day_map[day]:\n            if duration_curr < x: # duration_curr cannot be x or more, because x-duration_curr would be 0 or negative\n                needed_duration = x - duration_curr\n                if needed_duration > 0 and needed_duration <= x:\n                    if current_min_cost_for_duration[needed_duration] != float('inf'):\n                        overall_min_cost = min(overall_min_cost, cost_curr + current_min_cost_for_duration[needed_duration])\n\n    if overall_min_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(overall_min_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 2697,
        "thoughts_token_count": 0
    }
}