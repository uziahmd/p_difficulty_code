{
    "start": 1758294771.7017276,
    "end": 1758294833.2832084,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Problem-Solving Approach for Minimizing LCM(a+k, b+k)**\n\nAlright, so I've got this competitive programming problem where the aim is to find a non-negative integer 'k' that minimizes the least common multiple of (a+k) and (b+k).  The kicker is, if multiple 'k' values give the same minimum LCM, I have to pick the smallest one.  My immediate thought is to start with some algebraic manipulation, specifically, let x = a+k and y = b+k. I know that LCM(x, y) = (x * y) / GCD(x, y).  Now, I see a way forward: since y-x = b-a, the greatest common divisor of x and y must also divide the difference, b-a.\n\nThis is the key insight! This tells me that the greatest common divisor of (a+k) and (b+k) has to be a divisor of the absolute difference between 'a' and 'b'. Let's call this difference 'diff'.\n\nIf a equals b, then diff is zero and k=0 is the answer.\n\nBut if 'a' and 'b' are different, the situation becomes more interesting. I can now iterate through all the divisors of 'diff'. For each divisor 'd', I need to find the smallest non-negative 'k' where (a+k) is a multiple of 'd'. Let's find a more efficient means of calculating such 'k'. 'k' is going to be (-a) modulo 'd'. This will guarantee that a+k is always a multiple of 'd'.\n\nFor each divisor 'd', compute 'k'. Then calculate (a+k) and (b+k). After that, compute the LCM and keep track of the smallest LCM found so far, along with its associated 'k' value. If I find a smaller LCM, update my best 'k'. If I find an LCM equal to the current minimum, then I choose the smaller 'k'.\n\nAfter looping through every divisor, the best 'k' I've computed becomes the answer.\n\nThis seems like a solid plan. Now it's just a matter of coding it up!\n",
    "response": "The problem asks us to find a non-negative integer `k` that minimizes `lcm(a+k, b+k)`. If multiple `k` values yield the same minimum `lcm`, we must choose the smallest such `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know the relationship `lcm(x, y) = (x * y) / gcd(x, y)`.\nAn important property of the greatest common divisor (GCD) is that `gcd(x, y)` must divide `|y - x|`.\nIn our case, `y - x = (b+k) - (a+k) = b - a`.\nSo, `gcd(a+k, b+k)` must be a divisor of `|b - a|`.\n\nLet `diff = abs(b - a)`.\n\n**Special Case: `a = b`**\nIf `a = b`, then `diff = 0`. In this situation, `gcd(a+k, b+k) = gcd(a+k, a+k) = a+k`.\nThe `lcm(a+k, a+k) = a+k`. To minimize `a+k`, we should choose the smallest non-negative `k`, which is `k=0`. So if `a=b`, the answer is `0`.\n\n**General Case: `a != b`**\nIf `a != b`, then `diff > 0`.\nWe iterate through all possible divisors `d` of `diff`. For each `d`, we consider the possibility that `gcd(a+k, b+k)` is a multiple of `d`. More specifically, we are looking for `k` such that `a+k` is a multiple of `d`. This ensures that `a+k` is a multiple of `d`, and since `b+k = (a+k) + diff`, and `diff` is a multiple of `d`, `b+k` will also be a multiple of `d`. Thus, `gcd(a+k, b+k)` will be at least `d`.\n\nFor a given divisor `d` of `diff`:\n1. We need to find the smallest non-negative `k` such that `a+k` is a multiple of `d`.\n   This is equivalent to finding the smallest non-negative `k` such that `a+k \\equiv 0 \\pmod d`, or `k \\equiv -a \\pmod d`.\n   In Python, `k_d = (-a) % d` correctly computes this smallest non-negative `k`.\n2. With this `k_d`, we calculate `X = a + k_d` and `Y = b + k_d`.\n3. Then, we compute `current_lcm = (X * Y) // math.gcd(X, Y)`.\n4. We compare `current_lcm` with the `min_lcm_val` found so far:\n   - If `current_lcm < min_lcm_val`, we update `min_lcm_val = current_lcm` and `ans_k = k_d`.\n   - If `current_lcm == min_lcm_val`, we update `ans_k = min(ans_k, k_d)` to ensure we pick the smallest `k` for a tie.\n\n**Algorithm Steps:**\n1. Read integers `a` and `b`.\n2. If `a == b`, print `0` and exit.\n3. Calculate `diff = abs(b - a)`.\n4. Initialize `min_lcm_val = (a * b) // math.gcd(a, b)` and `ans_k = 0`. This handles the `k=0` case, which corresponds to `d=1` and is always a candidate.\n5. Find all divisors of `diff`. This can be done efficiently by iterating from `1` up to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff // i` are divisors.\n6. For each divisor `d` in the list of `diff`'s divisors:\n   a. Calculate `k_d = (-a) % d`.\n   b. Calculate `X = a + k_d` and `Y = b + k_d`.\n   c. Calculate `current_lcm = (X * Y) // math.gcd(X, Y)`. Python's integers handle arbitrary size, so `X*Y` won't overflow.\n   d. Update `min_lcm_val` and `ans_k` based on the comparison rules described above.\n7. Print `ans_k`.\n\n**Complexity:**\n- Finding divisors: `O(sqrt(diff))`. `diff` can be up to `10^9`, so `sqrt(10^9)` is about `31622`.\n- Number of divisors: For numbers up to `10^9`, the maximum number of divisors is relatively small (e.g., `735134400` has `1344` divisors).\n- For each divisor: `math.gcd` takes `O(log(max(X, Y)))` time. `X, Y` are up to `2 * 10^9`. `log(2 * 10^9)` is approximately `31`.\n- Total time complexity: `O(sqrt(diff) + num_divisors * log(max_val))`, which is efficient enough for the given constraints.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Special case: if a equals b, k=0 gives lcm(a,a) = a, which is minimal.\n    if a == b:\n        print(0)\n        return\n\n    # Calculate the absolute difference between a and b.\n    # gcd(a+k, b+k) must be a divisor of |(b+k) - (a+k)| = |b - a|.\n    diff = abs(b - a)\n\n    # Initialize the minimum LCM value and the corresponding k.\n    # We can start with k=0, which is always a valid candidate.\n    # For k=0, X = a, Y = b.\n    min_lcm_val = (a * b) // math.gcd(a, b)\n    ans_k = 0\n\n    # Find all divisors of 'diff'.\n    divisors = []\n    # Iterate from 1 up to the square root of diff.\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.append(i)\n            # If i*i != diff, then diff/i is another distinct divisor.\n            if i * i != diff:\n                divisors.append(diff // i)\n\n    # Iterate through each divisor 'd' of 'diff'.\n    # We are looking for k such that (a+k) is a multiple of 'd'.\n    for d in divisors:\n        # Calculate the smallest non-negative k_d such that (a + k_d) is a multiple of d.\n        # In Python, (-a) % d correctly computes this value.\n        k_d = (-a) % d\n        \n        X = a + k_d\n        Y = b + k_d\n        \n        # Calculate the LCM for the current X and Y.\n        # Use integer division // as X*Y might be very large, but Python handles large integers.\n        current_lcm = (X * Y) // math.gcd(X, Y)\n\n        # Update min_lcm_val and ans_k based on the current LCM.\n        if current_lcm < min_lcm_val:\n            min_lcm_val = current_lcm\n            ans_k = k_d\n        elif current_lcm == min_lcm_val:\n            # If LCMs are equal, choose the smallest k.\n            ans_k = min(ans_k, k_d)\n            \n    print(ans_k)\n\n# Call the solve function to process the input.\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Special case: if a equals b, k=0 gives lcm(a,a) = a, which is minimal.\n    if a == b:\n        print(0)\n        return\n\n    # Calculate the absolute difference between a and b.\n    # gcd(a+k, b+k) must be a divisor of |(b+k) - (a+k)| = |b - a|.\n    diff = abs(b - a)\n\n    # Initialize the minimum LCM value and the corresponding k.\n    # We can start with k=0, which is always a valid candidate.\n    # For k=0, X = a, Y = b.\n    min_lcm_val = (a * b) // math.gcd(a, b)\n    ans_k = 0\n\n    # Find all divisors of 'diff'.\n    divisors = []\n    # Iterate from 1 up to the square root of diff.\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.append(i)\n            # If i*i != diff, then diff/i is another distinct divisor.\n            if i * i != diff:\n                divisors.append(diff // i)\n\n    # Iterate through each divisor 'd' of 'diff'.\n    # We are looking for k such that (a+k) is a multiple of 'd'.\n    for d in divisors:\n        # Calculate the smallest non-negative k_d such that (a + k_d) is a multiple of d.\n        # In Python, (-a) % d correctly computes this value.\n        k_d = (-a) % d\n        \n        X = a + k_d\n        Y = b + k_d\n        \n        # Calculate the LCM for the current X and Y.\n        # Use integer division // as X*Y might be very large, but Python handles large integers.\n        current_lcm = (X * Y) // math.gcd(X, Y)\n\n        # Update min_lcm_val and ans_k based on the current LCM.\n        if current_lcm < min_lcm_val:\n            min_lcm_val = current_lcm\n            ans_k = k_d\n        elif current_lcm == min_lcm_val:\n            # If LCMs are equal, choose the smallest k.\n            ans_k = min(ans_k, k_d)\n            \n    print(ans_k)\n\n# Call the solve function to process the input.\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 1869,
        "thoughts_token_count": 8191
    }
}