{
    "start": 1758285123.425505,
    "end": 1758285142.201581,
    "start-formatted": "2025-09-19 21:32 KST",
    "end-formatted": "2025-09-19 21:32 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**My Approach to the TV Game Problem**\n\nOkay, so I'm tackling this \"TV Game\" problem. The core is a number `A` with an even number of digits, split between two players, Homer and Marge. Each player needs to construct their own number by repeatedly taking the leftmost digit from `A`. The ultimate goal is to maximize the sum of their resulting numbers.\n\nI've got the constraints clear: number of digits is `2n`, and `n` is up to 18. This likely limits the search space to something manageable. I need a sequence of 'H' and 'M' to show the moves.\n\nInitially, I'm trying to wrap my head around the core logic. Since all the digits are used, the sum is fixed regardless of how they are distributed. The challenge is the positional value of the digits.\n\nI'm thinking, let's look at the contribution of each digit to the final sum `S1 + S2`. If I know which position a digit ends up in, I know its weight. But that position depends on *when* it's taken relative to the other digits of the same player. This is getting tricky, fast.\n\nI need a cleaner way to express this. The positions are crucial, and they're relative to the choices the players are making. Let's make it formal - Homer gets `h_j` in its turn and Marge gets `m_j`. I'm basically constructing two numbers `S1` and `S2` based on the digits. `S1` is the sum of `h_j` times its positional value from the right, and `S2` is the same but with `m_j`.\n\nNow, the main idea is that the order in which the players choose these digits dictates their positional contribution. The key is in tracking the *order* in which these digits are taken, since the digits in S1 and S2 depend on the order each player picked its digits.\n\nI'm starting to see that I'll probably need some sort of search strategy to find the optimal move sequence. Maybe dynamic programming with memoization to avoid redundant computations, since n is relatively small. I need to figure out what the \"state\" should be. Should I consider the remaining digits in A? The number of moves left for each player? I need to think this through carefully.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n    \n    # Convert digits to integers\n    a = [int(d) for d in a_str]\n\n    # dp[k][h_count][m_count] stores the maximum total sum S1+S2\n    # when k digits have been processed from A, Homer has taken h_count digits,\n    # and Marge has taken m_count digits.\n    # The state also needs to store the path (sequence of moves).\n    # Since we only need to maximize, and the value is large, we store it as a tuple\n    # (value_H, value_M) to avoid large integer overflow if we combine them too early.\n    # However, Python handles large integers automatically.\n    # The actual sum is (value_H * 10^n + value_M * 10^n) - this is not right.\n    # The sum is (value_H + value_M).\n    # The values are calculated as if they were already shifted by 10^(n-k_taken_by_player).\n    # Let's refine: dp[k][h_count][m_count] stores the maximum (S1_current_prefix, S2_current_prefix)\n    # where S1_current_prefix is the number formed by Homer's h_count digits\n    # and S2_current_prefix is the number formed by Marge's m_count digits.\n    # The values are actual numerical values, not just sums of digits.\n\n    # dp state: dp[h_count][m_count] stores (max_S1_val, max_S2_val)\n    # for the current k-th digit being processed.\n    # We use two layers for DP: current and previous to save memory.\n    \n    # dp_prev[h_c][m_c] = (S1_val, S2_val, path_str)\n    # S1_val and S2_val are the numeric values of the prefixes built so far.\n    # path_str is the sequence of moves ('H' or 'M') that led to this state.\n    \n    # Initialize dp_prev for k=0 (before any digits are processed)\n    # Only one state: (0, 0) digits taken by H and M, values 0, empty path.\n    # We use a dictionary for sparse DP states.\n    dp_prev = {(0, 0): (0, 0, \"\")} \n\n    # Iterate through each digit in A\n    for k in range(2 * n): # k is the index of the digit being processed (0 to 2n-1)\n        current_digit = a[k]\n        dp_curr = {}\n\n        for (h_count, m_count), (s1_val_prev, s2_val_prev, path_prev) in dp_prev.items():\n            # Option 1: Homer takes the current digit\n            if h_count < n: # Homer can still make a move\n                h_count_new = h_count + 1\n                m_count_new = m_count\n                \n                # Append current_digit to Homer's number\n                # Shift S1_val_prev by 10 and add current_digit\n                s1_val_new = s1_val_prev * 10 + current_digit\n                s2_val_new = s2_val_prev # Marge's number remains unchanged\n                path_new = path_prev + 'H'\n\n                # Check if this state already exists in dp_curr\n                # If it exists, compare total sums (s1_val_new + s2_val_new)\n                # We want to maximize S1 + S2.\n                if (h_count_new, m_count_new) not in dp_curr or \\\n                   (s1_val_new + s2_val_new) > (dp_curr[(h_count_new, m_count_new)][0] + dp_curr[(h_count_new, m_count_new)][1]):\n                    dp_curr[(h_count_new, m_count_new)] = (s1_val_new, s2_val_new, path_new)\n            \n            # Option 2: Marge takes the current digit\n            if m_count < n: # Marge can still make a move\n                h_count_new = h_count\n                m_count_new = m_count + 1\n\n                s1_val_new = s1_val_prev # Homer's number remains unchanged\n                # Append current_digit to Marge's number\n                # Shift S2_val_prev by 10 and add current_digit\n                s2_val_new = s2_val_prev * 10 + current_digit\n                path_new = path_prev + 'M'\n\n                # Check if this state already exists in dp_curr\n                if (h_count_new, m_count_new) not in dp_curr or \\\n                   (s1_val_new + s2_val_new) > (dp_curr[(h_count_new, m_count_new)][0] + dp_curr[(h_count_new, m_count_new)][1]):\n                    dp_curr[(h_count_new, m_count_new)] = (s1_val_new, s2_val_new, path_new)\n        \n        dp_prev = dp_curr # Move to the next iteration\n\n    # After processing all 2n digits, the final state must be (n, n)\n    # This state will contain the maximum S1+S2 and the corresponding path.\n    final_s1, final_s2, final_path = dp_prev[(n, n)]\n    \n    sys.stdout.write(final_path + '\\n')\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n    \n    # Convert digits to integers\n    a = [int(d) for d in a_str]\n\n    # dp[k][h_count][m_count] stores the maximum total sum S1+S2\n    # when k digits have been processed from A, Homer has taken h_count digits,\n    # and Marge has taken m_count digits.\n    # The state also needs to store the path (sequence of moves).\n    # Since we only need to maximize, and the value is large, we store it as a tuple\n    # (value_H, value_M) to avoid large integer overflow if we combine them too early.\n    # However, Python handles large integers automatically.\n    # The actual sum is (value_H * 10^n + value_M * 10^n) - this is not right.\n    # The sum is (value_H + value_M).\n    # The values are calculated as if they were already shifted by 10^(n-k_taken_by_player).\n    # Let's refine: dp[k][h_count][m_count] stores the maximum (S1_current_prefix, S2_current_prefix)\n    # where S1_current_prefix is the number formed by Homer's h_count digits\n    # and S2_current_prefix is the number formed by Marge's m_count digits.\n    # The values are actual numerical values, not just sums of digits.\n\n    # dp state: dp[h_count][m_count] stores (max_S1_val, max_S2_val)\n    # for the current k-th digit being processed.\n    # We use two layers for DP: current and previous to save memory.\n    \n    # dp_prev[h_c][m_c] = (S1_val, S2_val, path_str)\n    # S1_val and S2_val are the numeric values of the prefixes built so far.\n    # path_str is the sequence of moves ('H' or 'M') that led to this state.\n    \n    # Initialize dp_prev for k=0 (before any digits are processed)\n    # Only one state: (0, 0) digits taken by H and M, values 0, empty path.\n    # We use a dictionary for sparse DP states.\n    dp_prev = {(0, 0): (0, 0, \"\")} \n\n    # Iterate through each digit in A\n    for k in range(2 * n): # k is the index of the digit being processed (0 to 2n-1)\n        current_digit = a[k]\n        dp_curr = {}\n\n        for (h_count, m_count), (s1_val_prev, s2_val_prev, path_prev) in dp_prev.items():\n            # Option 1: Homer takes the current digit\n            if h_count < n: # Homer can still make a move\n                h_count_new = h_count + 1\n                m_count_new = m_count\n                \n                # Append current_digit to Homer's number\n                # Shift S1_val_prev by 10 and add current_digit\n                s1_val_new = s1_val_prev * 10 + current_digit\n                s2_val_new = s2_val_prev # Marge's number remains unchanged\n                path_new = path_prev + 'H'\n\n                # Check if this state already exists in dp_curr\n                # If it exists, compare total sums (s1_val_new + s2_val_new)\n                # We want to maximize S1 + S2.\n                if (h_count_new, m_count_new) not in dp_curr or \\\n                   (s1_val_new + s2_val_new) > (dp_curr[(h_count_new, m_count_new)][0] + dp_curr[(h_count_new, m_count_new)][1]):\n                    dp_curr[(h_count_new, m_count_new)] = (s1_val_new, s2_val_new, path_new)\n            \n            # Option 2: Marge takes the current digit\n            if m_count < n: # Marge can still make a move\n                h_count_new = h_count\n                m_count_new = m_count + 1\n\n                s1_val_new = s1_val_prev # Homer's number remains unchanged\n                # Append current_digit to Marge's number\n                # Shift S2_val_prev by 10 and add current_digit\n                s2_val_new = s2_val_prev * 10 + current_digit\n                path_new = path_prev + 'M'\n\n                # Check if this state already exists in dp_curr\n                if (h_count_new, m_count_new) not in dp_curr or \\\n                   (s1_val_new + s2_val_new) > (dp_curr[(h_count_new, m_count_new)][0] + dp_curr[(h_count_new, m_count_new)][1]):\n                    dp_curr[(h_count_new, m_count_new)] = (s1_val_new, s2_val_new, path_new)\n        \n        dp_prev = dp_curr # Move to the next iteration\n\n    # After processing all 2n digits, the final state must be (n, n)\n    # This state will contain the maximum S1+S2 and the corresponding path.\n    final_s1, final_s2, final_path = dp_prev[(n, n)]\n    \n    sys.stdout.write(final_path + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 431,
        "completion_token_count": 1377,
        "thoughts_token_count": 828
    }
}