{
    "start": 1758009389.231849,
    "end": 1758009457.8804867,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:57 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Thinking Through \"Flawed Flow\"**\n\nOkay, so I've got this \"Flawed Flow\" problem in front of me.  Essentially, I need to take an undirected graph and turn it into a directed one, satisfying these key conditions.  First, for every vertex except the source and sink, the incoming flow must equal the outgoing flow – standard flow conservation.  The source has no incoming edges, and the resulting directed graph needs to be acyclic. The crucial bit is that the flow values, which are provided as edge capacities, correspond to a maximum flow solution.\n\nThe constraints are pretty generous, so I should be able to whip up something efficient.  `n` and `m` can be up to 200,000, so I need to avoid anything quadratic.\n\nThe \"no cycles\" part really jumps out. That screams Directed Acyclic Graph, or DAG, to me. If I can somehow enforce a topological order on the vertices, flow will naturally go from \"smaller\" ranked vertices to \"larger\" ranked ones. This should keep things acyclic.\n\nI need to figure out how to direct the edges.  The source node (vertex 1) is a good starting point.  No incoming edges, so any edge connected to it must point *away* from it. This fixes the direction of a few edges right off the bat.\n\nThinking about flow conservation, for a vertex `v` that's not the source or sink, the incoming flow needs to equal the outgoing flow. So for each edge connected to `v`, either I direct it towards `v` or away from `v`. The maximum flow guarantee is key here. It means the given flow values are consistent, and a valid solution exists.\n\nThis feels like a greedy approach might work, or maybe a DFS or BFS-based graph traversal. Let's see if I can build a topological sort. If I can, that would be ideal! I'm thinking I should start with the edges connected to the source and see if I can propagate that logic throughout the graph. The goal is to build a DAG that maintains flow conservation and gives the max flow. Let's see if I can get this Python script rolling...\n",
    "response": "The problem asks us to direct edges of an undirected graph, given their flow volumes, such that standard flow conservation rules hold for intermediate vertices, the source (vertex 1) has no incoming edges, and the resulting directed graph is acyclic. We are guaranteed that a solution always exists and that the given flows correspond to a maximum flow.\n\nThe key conditions are:\n1.  **Source (vertex 1) has no incoming edges:** All edges connected to vertex 1 must be directed away from it.\n2.  **Flow conservation for intermediate vertices (1 < v < n):** Sum of incoming flow equals sum of outgoing flow.\n3.  **No cycles:** The resulting directed graph must be a Directed Acyclic Graph (DAG).\n\nThe \"no cycles\" condition is very strong. If a solution exists as a DAG, then there must be a topological ordering of the vertices. This implies that flow generally moves from \"earlier\" vertices in the topological order to \"later\" ones.\n\nLet's consider the flow conservation at an intermediate vertex `v`. For each edge `(u, v)` with flow `c`, either `u -> v` (incoming) or `v -> u` (outgoing). We need `sum(incoming_flow) = sum(outgoing_flow)`.\nThis can be rephrased: `sum(flow_on_edges_directed_into_v) - sum(flow_on_edges_directed_out_of_v) = 0`.\n\nConsider the sum of all flow volumes connected to a vertex `v`. Let this be `total_flow_v`. If we direct an edge `(u, v)` as `u -> v`, it contributes `c` to `in_v` and `0` to `out_v`. If `v -> u`, it contributes `0` to `in_v` and `c` to `out_v`.\nFor an intermediate vertex `v`, we need `in_v = out_v`. This implies `in_v + out_v = 2 * in_v`. Since `in_v + out_v` is simply the sum of all flow values `c_i` for edges incident to `v`, this sum must be an even number. This is a property of flow conservation.\n\nA common technique for problems involving balancing incoming/outgoing values on a graph, especially with a \"no cycles\" constraint, is to use a Depth First Search (DFS) or a similar traversal.\n\nLet's try a DFS approach starting from the source (vertex 1).\nWhen we traverse an edge `(u, v)` from `u` to `v` during DFS, we can tentatively direct it `u -> v`. This choice needs to be validated later.\n\nA more robust approach exploits the \"no cycles\" condition. If we have a DAG, we can think about the \"net flow\" into a vertex.\nFor vertex `v`:\nLet `balance[v]` be the current net flow into `v`. Initially, `balance[v] = 0` for all `v`.\nWhen we direct an edge `u -> v` with flow `c`:\n`balance[v] += c`\n`balance[u] -= c`\n\nFor `1 < v < n`, we need `balance[v]` to be `0` at the end.\nFor `v = 1`, we need `balance[1] <= 0` (no incoming edges, so all edges must be outgoing or 0).\nFor `v = n`, `balance[n]` will be the total max flow.\n\nConsider a DFS starting from vertex 1. When we visit a vertex `u`, we try to direct its incident edges.\nThe crucial insight comes from the problem constraints and guarantees: a solution always exists, and the graph is connected. The \"no cycles\" condition implies that the graph can be topologically sorted.\n\nLet's define a \"net flow requirement\" for each vertex `v`. For `1 < v < n`, the net flow into `v` must be 0.\nFor vertex 1, all edges must be outgoing.\nFor vertex `n`, it's the sink, so it can accumulate flow.\n\nWe can use a DFS from the source (vertex 1) to determine directions.\nWhen we are at a vertex `u` and explore an edge `(u, v)` (which we haven't directed yet):\n1. If `v` has already been visited and determined to be \"earlier\" in the topological order than `u`, then the edge must be `v -> u`. This is a \"back edge\" in DFS terms, but in a DAG, it implies `v` is an ancestor of `u`.\n2. If `v` has not been visited, we can tentatively direct `u -> v` and recurse.\n\nThis approach is tricky because `balance[v]` needs to be `0` for intermediate `v`.\n\nA simpler approach often works for these types of problems:\nInitialize `current_flow[v] = 0` for all `v`. This `current_flow[v]` will track the *net outgoing flow* from `v` that needs to be balanced.\nStart a DFS from vertex 1.\nWhen we are at vertex `u` and traverse an edge `(u, v)` (which is the `i`-th edge in input, with flow `c_i`):\n*   If `v` has already been visited: This means `v` is an ancestor of `u` in the DFS tree (or `u` and `v` are in different subtrees but `v` was visited and finished earlier). Since we need a DAG, this edge must be directed `v -> u`. We update `current_flow[v] -= c_i` and `current_flow[u] += c_i`. Store `dir_i = 1` (meaning `b_i -> a_i`).\n*   If `v` has not been visited: We tentatively direct `u -> v`. We recursively call DFS on `v`. After the recursive call returns, `current_flow[v]` will contain the net flow that needs to be *removed* from `v` (i.e., `sum(outgoing) - sum(incoming)` within `v`'s subtree, considering only edges fully processed in `v`'s subtree).\n    We need `current_flow[v]` to be 0 for `1 < v < n`. If `current_flow[v]` is non-zero after returning from `DFS(v)`, it means `v` needs to send this amount of flow out. This flow must go through the edge `(u, v)` that brought us to `v`.\n    So, if `current_flow[v] > 0`, we must direct `v -> u`. We update `current_flow[u] += current_flow[v]`. Store `dir_i = 1`.\n    If `current_flow[v] <= 0`, we must direct `u -> v`. We update `current_flow[u] += current_flow[v]` (which means `u` effectively receives `abs(current_flow[v])` flow). Store `dir_i = 0`.\n\nThis logic for `current_flow[v]` is a bit confusing. Let's refine it.\nLet `flow_balance[v]` be the sum of flow on edges *directed into* `v` minus the sum of flow on edges *directed out of* `v`. We want `flow_balance[v] = 0` for `1 < v < n`.\nInitialize `flow_balance[v] = 0` for all `v`.\nWe perform a DFS. `visited[v]` tracks if `v` has been visited. `dfs_stack[v]` tracks if `v` is currently in the recursion stack (to detect cycles).\n`ans[edge_idx]` stores the direction.\n\n```python\nadj = [[] for _ in range(n + 1)] # Stores (neighbor, flow, edge_idx)\nans = [0] * m\nflow_balance = [0] * (n + 1)\nvisited = [False] * (n + 1)\n\ndef dfs(u):\n    visited[u] = True\n    \n    for v, c, edge_idx in adj[u]:\n        if not visited[v]:\n            # Tentatively direct u -> v\n            # Recurse on v\n            dfs(v)\n            \n            # After dfs(v) returns, flow_balance[v] holds the net flow\n            # that v needs to send out (if positive) or receive (if negative)\n            # to satisfy its conservation.\n            # This flow must be resolved through the edge (u, v).\n            \n            if flow_balance[v] > 0: # v needs to send flow out\n                # So, direct v -> u\n                ans[edge_idx] = 1 # b_i -> a_i (if u=a_i, v=b_i)\n                flow_balance[u] += flow_balance[v] # u receives flow from v\n                flow_balance[v] = 0 # v is now balanced\n            else: # v needs to receive flow OR is already balanced\n                # So, direct u -> v\n                ans[edge_idx] = 0 # a_i -> b_i (if u=a_i, v=b_i)\n                flow_balance[u] += flow_balance[v] # u sends flow to v (if balance[v] is negative, u sends less)\n                flow_balance[v] = 0 # v is now balanced\n        else: # v is already visited. This is a back-edge or cross-edge.\n              # To maintain DAG property, the flow must go from the \"older\" vertex to \"newer\" vertex.\n              # In a DFS tree, a back-edge means v is an ancestor of u.\n              # So, flow must be v -> u.\n            pass # We don't direct it here. It will be directed when dfs(v) processes it.\n                 # Wait, this is wrong. If v is visited, it means the edge (u,v) is not a tree edge.\n                 # We must direct it now.\n                 # The problem states \"vertex with number 1 has no incoming edges\".\n                 # This implies flow direction for edges incident to 1.\n                 # The \"no cycles\" condition is key.\n                 # If we are in DFS(u) and see a visited v, then v must be an ancestor of u.\n                 # To avoid a cycle (u -> v -> ... -> u), the edge must be v -> u.\n                 # This means flow_balance[u] increases by c_i and flow_balance[v] decreases by c_i.\n                 # However, this doesn't fit the structure of the `flow_balance` update.\n```\n\nThe standard approach for this kind of problem is to use a DFS and accumulate flow.\nLet `balance[v]` track the *net flow leaving* vertex `v` through edges *already processed* within its DFS subtree.\nWhen `DFS(u)` is called:\n1. Mark `u` as visited.\n2. For each neighbor `v` of `u` connected by edge `(u, v)` with flow `c` (edge index `idx`):\n    a. If `v` is not visited:\n        i. Recursively call `DFS(v)`.\n        ii. After `DFS(v)` returns, `balance[v]` contains the net flow that *must leave* `v` to satisfy conservation within its subtree.\n        iii. If `balance[v] > 0`: This flow must leave `v` via `(u, v)`. So, direct `v -> u`. Set `ans[idx] = 1`. Add `c` to `balance[u]` (as `u` receives flow `c`).\n        iv. If `balance[v] <= 0`: This flow must enter `v` via `(u, v)`. So, direct `u -> v`. Set `ans[idx] = 0`. Add `c` to `balance[u]` (as `u` sends flow `c`).\n           *Correction*: If `balance[v]` is negative, it means `v` *needs* to receive `abs(balance[v])` flow. If `balance[v]` is zero, `v` is balanced. In both cases, we can direct `u -> v`. The `balance[u]` should reflect the net flow *leaving* `u`. So if `u -> v`, `u` sends `c`. If `v -> u`, `u` receives `c`.\n           So, if `balance[v] > 0`, `v -> u`, `balance[u] += c`.\n           If `balance[v] <= 0`, `u -> v`, `balance[u] -= c`.\n    b. If `v` is visited: This is a back-edge or cross-edge. To maintain DAG, `v` must be an ancestor of `u` (or `v` was visited and finished before `u`). In a max-flow DAG, flow must go from \"earlier\" nodes to \"later\" nodes. So, `v -> u`. Set `ans[idx] = 1`. Add `c` to `balance[u]`.\n3. If `u` is not the source (vertex 1) and not the sink (vertex `n`), its `balance[u]` must be 0.\n   This means after processing all its children in the DFS tree, `balance[u]` must be 0.\n   But `balance[u]` accumulates flow from its children.\n   The `balance[u]` should be the *net flow that needs to leave `u` via its parent edge*.\n\nLet's use `current_flow[v]` to track the sum of flow values of edges incident to `v` that have been directed *out* of `v` minus the sum of flow values of edges incident to `v` that have been directed *into* `v`.\nWe want `current_flow[v] = 0` for `1 < v < n`.\nStart DFS from `u=1`.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 50) # Increased recursion limit\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)] # Stores (neighbor, flow, original_edge_idx, is_a_i_b_i)\n                                     # is_a_i_b_i is 0 if edge was (a_i, b_i), 1 if (b_i, a_i)\n    edges_info = [] # Store original (a_i, b_i, c_i) to map back to output index\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, 0)) # 0 means u is a_i, v is b_i\n        adj[v].append((u, c, i, 1)) # 1 means v is a_i, u is b_i (for output mapping)\n        edges_info.append((u, v, c))\n\n    ans = [0] * m # 0 for a_i -> b_i, 1 for b_i -> a_i\n\n    # flow_balance[v] will store the net flow that needs to be 'resolved'\n    # through the edge connecting v to its parent in the DFS tree.\n    # A positive value means v needs to send flow out.\n    # A negative value means v needs to receive flow.\n    flow_balance = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    # The DFS function returns the net flow for the subtree rooted at u\n    # that needs to be resolved through the edge connecting u to its parent.\n    def dfs(u, parent_edge_idx=-1):\n        visited[u] = True\n\n        for v, c, edge_idx, is_reverse_original in adj[u]:\n            if not visited[v]:\n                # This is a tree edge. Recurse on v.\n                dfs(v, edge_idx)\n\n                # After dfs(v) returns, flow_balance[v] contains the net flow\n                # that v needs to send (if positive) or receive (if negative)\n                # to satisfy conservation within its subtree.\n                # This flow must pass through the edge (u, v).\n\n                if flow_balance[v] > 0:\n                    # v needs to send flow out. So, direct v -> u.\n                    # This means if original was (a_i, b_i), and u is b_i, v is a_i, then direction is a_i -> b_i (0)\n                    # if original was (a_i, b_i), and u is a_i, v is b_i, then direction is b_i -> a_i (1)\n                    if is_reverse_original == 0: # u was a_i, v was b_i\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    else: # u was b_i, v was a_i\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    \n                    # u receives c flow from v\n                    flow_balance[u] += c \n                else:\n                    # v needs to receive flow OR is already balanced (flow_balance[v] <= 0).\n                    # So, direct u -> v.\n                    if is_reverse_original == 0: # u was a_i, v was b_i\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else: # u was b_i, v was a_i\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    \n                    # u sends c flow to v\n                    flow_balance[u] -= c \n            else:\n                # v is already visited. This is a back-edge or cross-edge.\n                # To maintain the DAG property and flow conservation,\n                # flow must go from the \"older\" vertex to the \"newer\" vertex in the topological sort.\n                # In a DFS, if v is visited and not the parent of u, then v must be an ancestor or in another processed subtree.\n                # To guarantee no cycles, we must direct v -> u.\n                # This is because the problem guarantees a solution (a DAG) exists.\n                # If this edge is directed u -> v, it would form a cycle.\n                # So, v -> u.\n                \n                # We need to make sure we only process each edge once for direction.\n                # If edge_idx is smaller than parent_edge_idx, it means this edge was already processed by a previous DFS call.\n                # This check ensures that we only direct an edge once.\n                # The condition `edge_idx > parent_edge_idx` ensures that we only process edges that haven't been processed\n                # by an earlier DFS call that traversed the same edge from the other direction.\n                # However, this is not quite right. `parent_edge_idx` is the edge leading to `u`.\n                # We need to check if `ans[edge_idx]` is already set. If it is, skip.\n                if ans[edge_idx] != 0 and ans[edge_idx] != 1: # Check if not set\n                    if is_reverse_original == 0: # u was a_i, v was b_i\n                        ans[edge_idx] = 1 # b_i -> a_i (v -> u)\n                    else: # u was b_i, v was a_i\n                        ans[edge_idx] = 0 # a_i -> b_i (v -> u)\n                    \n                    # u receives c flow from v\n                    flow_balance[u] += c\n                # If ans[edge_idx] is already set, it means this edge was directed when DFS(v) processed it.\n                # We don't need to do anything here, as the balance for u and v would have been updated then.\n                # This is the tricky part. The logic for visited nodes needs to be clean.\n\n    # Corrected DFS logic:\n    # `flow_balance[v]` will store the net flow *leaving* vertex `v` through its parent edge.\n    # Positive `flow_balance[v]` means `v` needs to send flow `out` to its parent.\n    # Negative `flow_balance[v]` means `v` needs to receive flow `in` from its parent.\n    def dfs_final(u):\n        visited[u] = True\n        \n        # Iterate over neighbors\n        for v, c, edge_idx, is_u_a_i in adj[u]:\n            if not visited[v]:\n                # Tree edge: u is parent of v\n                dfs_final(v) # Recurse on child v\n                \n                # After child v's subtree is processed:\n                # flow_balance[v] holds the net flow from v's subtree that needs to pass through (u,v).\n                if flow_balance[v] > 0: # v needs to send flow out (to u)\n                    # So, direct v -> u\n                    if is_u_a_i == 0: # Original edge was (u, v), so it's (a_i, b_i)\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    else: # Original edge was (v, u), so it's (b_i, a_i)\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    flow_balance[u] += c # u receives flow c\n                else: # v needs to receive flow (from u) or is balanced (flow_balance[v] <= 0)\n                    # So, direct u -> v\n                    if is_u_a_i == 0: # Original edge was (u, v)\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else: # Original edge was (v, u)\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    flow_balance[u] -= c # u sends flow c\n\n            # If v is visited, it's a back-edge or cross-edge.\n            # To avoid cycles and satisfy flow conservation, flow must go from v to u.\n            # This direction is determined when v calls DFS on its children or when v is processed.\n            # We must only direct each edge once. The `ans` array is initialized with some non-0/1 value\n            # or we check if it's unset. Let's initialize with -1 to signify unset.\n            elif ans[edge_idx] == -1: # This edge hasn't been directed yet\n                # Direction must be v -> u\n                if is_u_a_i == 0: # Original edge was (u, v)\n                    ans[edge_idx] = 1 # b_i -> a_i\n                else: # Original edge was (v, u)\n                    ans[edge_idx] = 0 # a_i -> b_i\n                flow_balance[u] += c # u receives flow c\n\n\n    # Initialize ans with -1 to indicate unset\n    ans = [-1] * m\n    dfs_final(1) # Start DFS from source (vertex 1)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 50) # Increased recursion limit\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)] # Stores (neighbor, flow, original_edge_idx, is_a_i_b_i)\n                                     # is_a_i_b_i is 0 if edge was (a_i, b_i), 1 if (b_i, a_i)\n    edges_info = [] # Store original (a_i, b_i, c_i) to map back to output index\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, 0)) # 0 means u is a_i, v is b_i\n        adj[v].append((u, c, i, 1)) # 1 means v is a_i, u is b_i (for output mapping)\n        edges_info.append((u, v, c))\n\n    ans = [0] * m # 0 for a_i -> b_i, 1 for b_i -> a_i\n\n    # flow_balance[v] will store the net flow that needs to be 'resolved'\n    # through the edge connecting v to its parent in the DFS tree.\n    # A positive value means v needs to send flow out.\n    # A negative value means v needs to receive flow.\n    flow_balance = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    # The DFS function returns the net flow for the subtree rooted at u\n    # that needs to be resolved through the edge connecting u to its parent.\n    def dfs(u, parent_edge_idx=-1):\n        visited[u] = True\n\n        for v, c, edge_idx, is_reverse_original in adj[u]:\n            if not visited[v]:\n                # This is a tree edge. Recurse on v.\n                dfs(v, edge_idx)\n\n                # After dfs(v) returns, flow_balance[v] contains the net flow\n                # that v needs to send (if positive) or receive (if negative)\n                # to satisfy conservation within its subtree.\n                # This flow must pass through the edge (u, v).\n\n                if flow_balance[v] > 0:\n                    # v needs to send flow out. So, direct v -> u.\n                    # This means if original was (a_i, b_i), and u is b_i, v is a_i, then direction is a_i -> b_i (0)\n                    # if original was (a_i, b_i), and u is a_i, v is b_i, then direction is b_i -> a_i (1)\n                    if is_reverse_original == 0: # u was a_i, v was b_i\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    else: # u was b_i, v was a_i\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    \n                    # u receives c flow from v\n                    flow_balance[u] += c \n                else:\n                    # v needs to receive flow OR is already balanced (flow_balance[v] <= 0).\n                    # So, direct u -> v.\n                    if is_reverse_original == 0: # u was a_i, v was b_i\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else: # u was b_i, v was a_i\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    \n                    # u sends c flow to v\n                    flow_balance[u] -= c \n            else:\n                # v is already visited. This is a back-edge or cross-edge.\n                # To maintain the DAG property and flow conservation,\n                # flow must go from the \"older\" vertex to the \"newer\" vertex in the topological sort.\n                # In a DFS, if v is visited and not the parent of u, then v must be an ancestor or in another processed subtree.\n                # To guarantee no cycles, we must direct v -> u.\n                # This is because the problem guarantees a solution (a DAG) exists.\n                # If this edge is directed u -> v, it would form a cycle.\n                # So, v -> u.\n                \n                # We need to make sure we only process each edge once for direction.\n                # If edge_idx is smaller than parent_edge_idx, it means this edge was already processed by a previous DFS call.\n                # This check ensures that we only direct an edge once.\n                # The condition `edge_idx > parent_edge_idx` ensures that we only process edges that haven't been processed\n                # by an earlier DFS call that traversed the same edge from the other direction.\n                # However, this is not quite right. `parent_edge_idx` is the edge leading to `u`.\n                # We need to check if `ans[edge_idx]` is already set. If it is, skip.\n                if ans[edge_idx] != 0 and ans[edge_idx] != 1: # Check if not set\n                    if is_reverse_original == 0: # u was a_i, v was b_i\n                        ans[edge_idx] = 1 # b_i -> a_i (v -> u)\n                    else: # u was b_i, v was a_i\n                        ans[edge_idx] = 0 # a_i -> b_i (v -> u)\n                    \n                    # u receives c flow from v\n                    flow_balance[u] += c\n                # If ans[edge_idx] is already set, it means this edge was directed when DFS(v) processed it.\n                # We don't need to do anything here, as the balance for u and v would have been updated then.\n                # This is the tricky part. The logic for visited nodes needs to be clean.\n\n    # Corrected DFS logic:\n    # `flow_balance[v]` will store the net flow *leaving* vertex `v` through its parent edge.\n    # Positive `flow_balance[v]` means `v` needs to send flow `out` to its parent.\n    # Negative `flow_balance[v]` means `v` needs to receive flow `in` from its parent.\n    def dfs_final(u):\n        visited[u] = True\n        \n        # Iterate over neighbors\n        for v, c, edge_idx, is_u_a_i in adj[u]:\n            if not visited[v]:\n                # Tree edge: u is parent of v\n                dfs_final(v) # Recurse on child v\n                \n                # After child v's subtree is processed:\n                # flow_balance[v] holds the net flow from v's subtree that needs to pass through (u,v).\n                if flow_balance[v] > 0: # v needs to send flow out (to u)\n                    # So, direct v -> u\n                    if is_u_a_i == 0: # Original edge was (u, v), so it's (a_i, b_i)\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    else: # Original edge was (v, u), so it's (b_i, a_i)\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    flow_balance[u] += c # u receives flow c\n                else: # v needs to receive flow (from u) or is balanced (flow_balance[v] <= 0)\n                    # So, direct u -> v\n                    if is_u_a_i == 0: # Original edge was (u, v)\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else: # Original edge was (v, u)\n                        ans[edge_idx] = 1 # b_i -> a_i\n                    flow_balance[u] -= c # u sends flow c\n\n            # If v is visited, it's a back-edge or cross-edge.\n            # To avoid cycles and satisfy flow conservation, flow must go from v to u.\n            # This direction is determined when v calls DFS on its children or when v is processed.\n            # We must only direct each edge once. The `ans` array is initialized with some non-0/1 value\n            # or we check if it's unset. Let's initialize with -1 to signify unset.\n            elif ans[edge_idx] == -1: # This edge hasn't been directed yet\n                # Direction must be v -> u\n                if is_u_a_i == 0: # Original edge was (u, v)\n                    ans[edge_idx] = 1 # b_i -> a_i\n                else: # Original edge was (v, u)\n                    ans[edge_idx] = 0 # a_i -> b_i\n                flow_balance[u] += c # u receives flow c\n\n\n    # Initialize ans with -1 to indicate unset\n    ans = [-1] * m\n    dfs_final(1) # Start DFS from source (vertex 1)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 5369,
        "thoughts_token_count": 779
    }
}