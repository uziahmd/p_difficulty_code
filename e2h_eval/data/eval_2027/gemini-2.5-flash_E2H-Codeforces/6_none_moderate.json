{
    "start": 1758011282.8185098,
    "end": 1758011314.5009394,
    "start-formatted": "2025-09-16 17:28 KST",
    "end-formatted": "2025-09-16 17:28 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    max_coord = 2 * 10**5\n    min_cost_at_end_day = [float('inf')] * (max_coord + 2)\n\n    ans = float('inf')\n\n    for i in range(n):\n        l1, r1, cost1 = vouchers[i]\n        duration1 = r1 - l1 + 1\n\n        if duration1 < x:\n            remaining_duration = x - duration1\n            \n            # Check for voucher j such that r_j < l_1\n            # We need a voucher j with duration `remaining_duration` and r_j < l_1\n            # The earliest possible start day for such a voucher j is 1\n            # The latest possible end day for such a voucher j is l_1 - 1 - (remaining_duration - 1)\n            # which simplifies to l_1 - remaining_duration\n            \n            # We need to find min_cost_at_end_day[r_j] for r_j in [1, l_1 - 1]\n            # such that r_j - l_j + 1 = remaining_duration\n            \n            # The `min_cost_at_end_day` array stores the minimum cost of a voucher ending on a specific day,\n            # for a given duration. We need to iterate through vouchers and update this array.\n            # This requires a different approach.\n\n            # Let's group vouchers by duration.\n            # A dictionary where keys are durations and values are lists of (end_day, cost)\n            \n            # Instead of a single min_cost_at_end_day, we need to consider durations.\n            # This suggests iterating through vouchers in a specific order.\n\n            # Let's re-sort by start day.\n            # We will process vouchers sorted by their start day.\n            # For each voucher (l1, r1, cost1), we want to find a second voucher (l2, r2, cost2)\n            # such that r2 < l1 or r1 < l2.\n            # And (r1 - l1 + 1) + (r2 - l2 + 1) = x.\n\n    # Re-approach: Store minimum costs for vouchers ending on a specific day with a specific duration.\n    # This is too much memory.\n\n    # The problem has a constraint on coordinates up to 2 * 10^5.\n    # This suggests an O(N log N) or O(N * max_coord) solution.\n\n    # Let's create a list of vouchers grouped by their start day.\n    # vouchers_by_start_day[s] will contain a list of (r, cost) for vouchers starting on day s.\n    vouchers_by_start_day = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_start_day[l].append((r, cost))\n\n    # min_cost_for_duration_ending_on_day[d][end_day] = min_cost\n    # This is still too much memory if d can be large.\n\n    # Let's use a data structure that can query minimum cost for a specific duration.\n    # Or, iterate through possible split points.\n\n    # Consider processing vouchers in increasing order of their end day `r`.\n    # When we are at voucher `(l1, r1, cost1)`, we want to find a voucher `(l2, r2, cost2)`\n    # such that `r2 < l1` and `(r1 - l1 + 1) + (r2 - l2 + 1) = x`.\n    # This means `r2 - l2 + 1 = x - (r1 - l1 + 1)`. Let `duration2 = x - (r1 - l1 + 1)`.\n    # We need to find a voucher `(l2, r2, cost2)` such that `r2 < l1`, `r2 - l2 + 1 = duration2`,\n    # and `cost2` is minimal.\n\n    # This can be done by maintaining, for each possible duration `d`,\n    # the minimum cost of a voucher with duration `d` that has ended by the current day.\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that duration.\n    # When we process vouchers sorted by `r`, we can update this array.\n\n    # `min_cost_ending_before[day][duration]`\n    # `min_cost_ending_before[day]` is an array/map of (duration -> min_cost)\n\n    # Let's try to iterate through all possible `l1` values.\n    # For each `l1`, we want to find a `(r1, cost1)` and a `(l2, r2, cost2)`.\n\n    # Let's use a `min_cost_for_duration_ending_at_or_before[day][duration]` array.\n    # This is still too much.\n\n    # The key is that `duration = r - l + 1`.\n    # So `l = r - duration + 1`.\n\n    # Let's use a single array `min_cost_for_duration[duration]` that stores the minimum cost\n    # of a voucher with that duration *that has already been processed*.\n\n    # Sort vouchers by their end day `r`.\n    vouchers.sort(key=lambda x: x[1])\n\n    # `min_cost_ending_on_day[d]` stores the minimum cost of a voucher with duration `d`\n    # that ends on or before the current day.\n    # We can use a segment tree or similar structure to query this efficiently,\n    # but a simple array can work if we update it carefully.\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that duration.\n    # This is not enough, because we need `r2 < l1`.\n\n    # We need to find the minimum cost of a voucher `(l2, r2, cost2)` such that `r2 < l1`\n    # and `r2 - l2 + 1 = duration2`.\n\n    # Let's try iterating through the vouchers.\n    # For each voucher `v1 = (l1, r1, cost1)`:\n    #   Calculate its duration `d1 = r1 - l1 + 1`.\n    #   Calculate the required duration for the second voucher `d2 = x - d1`.\n    #   If `d2 <= 0`, continue.\n\n    #   We need to find a voucher `v2 = (l2, r2, cost2)` such that:\n    #     1. `r2 - l2 + 1 = d2`\n    #     2. `r2 < l1` (or `r1 < l2`)\n\n    #   Case 1: `r2 < l1`.\n    #     We need to find the minimum `cost2` among vouchers `v2` such that `r2 < l1` and `r2 - l2 + 1 = d2`.\n    #     This means `l2 = r2 - d2 + 1`.\n    #     We need to query for `min(cost2)` for vouchers ending at `r2` where `r2` is in `[1, l1 - 1]`.\n    #     This is a range minimum query on `cost2` for a specific duration `d2`.\n\n    # Let's use a list of lists, `min_cost_by_duration_and_end_day`.\n    # `min_cost_by_duration_and_end_day[duration]` will store a list of `(end_day, cost)` pairs,\n    # sorted by `end_day`. This is still too much.\n\n    # The maximum value for `r` is `2 * 10^5`.\n    # The maximum duration is `2 * 10^5`.\n\n    # `min_cost_for_duration_ending_at_day[duration][day]` = min cost of a voucher with `duration` ending on `day`.\n    # This is a 2D array, `2e5 * 2e5` elements, too big.\n\n    # The maximum coordinate is `2 * 10^5`.\n    # We can use an array `min_cost_for_duration_ending_before[day]`\n    # where `min_cost_for_duration_ending_before[day]` is a dictionary mapping `duration` to `min_cost`.\n    # Still too much.\n\n    # Let's consider the structure of the problem. We need two vouchers.\n    # This suggests a sweep-line approach or processing events.\n\n    # Events: voucher starts, voucher ends.\n    # Or, we can iterate through all possible `l1` values from `1` to `max_coord`.\n    # For each `l1`, we consider vouchers starting at `l1`.\n    # And we need to query for vouchers that end before `l1`.\n\n    # Let `min_cost_for_len[duration]` store the minimum cost of a voucher with `duration`.\n    # This array will be updated as we sweep.\n    # `min_cost_for_len` will be `max_coord + 1` size. Initialize with infinity.\n\n    # We need to process vouchers in increasing order of `r`.\n    # For each voucher `(l, r, cost)`:\n    #   `duration = r - l + 1`.\n    #   If `duration < x`:\n    #     `needed_duration = x - duration`.\n    #     If `needed_duration > 0` and `needed_duration <= max_coord`:\n    #       We need to find a voucher `(l_prev, r_prev, cost_prev)` such that `r_prev < l`\n    #       and `r_prev - l_prev + 1 = needed_duration`.\n    #       If such a voucher exists, `cost_prev` should be minimal.\n    #       `min_cost_for_len[needed_duration]` stores the minimum cost of any voucher with `needed_duration`\n    #       that has been processed *so far* (i.e., its `r_prev` is less than or equal to the current `r`).\n    #       This is not quite `r_prev < l`.\n\n    # Let's use an array `min_cost_for_duration_up_to_day[duration]`\n    # This will be `max_coord + 1` size.\n    # `min_cost_for_duration_up_to_day[duration]` will store the minimum cost of a voucher\n    # with `duration` that ends on or before the current sweep day.\n\n    # Let's sort vouchers by `l`.\n    vouchers.sort()\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with `duration`\n    # that has already been considered for the *first* part of the pair.\n    # This is not quite right.\n\n    # Let's create a list of events.\n    # Events are `(coordinate, type, data)`.\n    # Type 1: `(r, 'end', (duration, cost))` - a voucher ends.\n    # Type 2: `(l, 'start', (duration, cost))` - a voucher starts.\n    # We need to process these events.\n\n    # Max coordinate value.\n    MAX_COORD = 2 * 10**5\n\n    # `min_cost_for_duration_ending_at[duration]`\n    # This needs to be able to query min cost for a duration given an end day constraint.\n    # This is a segment tree or similar.\n    # `min_cost_by_duration[d]` stores the minimum cost of a voucher with duration `d`.\n    # This array will be updated as we iterate through days.\n\n    # `min_cost_by_duration[d]` = min cost of a voucher with duration `d` that has `r < current_l`.\n    # Initialize `min_cost_by_duration` with infinity.\n    min_cost_by_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # Sort vouchers by their start day `l`.\n    vouchers.sort()\n\n    ans = float('inf')\n\n    # We need to iterate through possible `l` values.\n    # For each `l`, we want to consider vouchers that start at `l` as the first voucher `v1`.\n    # And we want to find a second voucher `v2` such that `r2 < l`.\n\n    # To do this efficiently, we can use a sweep-line approach.\n    # We iterate `current_day` from 1 to `MAX_COORD`.\n    # At each `current_day`:\n    # 1. Update `min_cost_by_duration` with vouchers that end at `current_day - 1`.\n    #    (i.e., these vouchers are now available to be the `v2` for any `v1` starting at `current_day` or later).\n    # 2. For all vouchers `(l, r, cost)` that start at `current_day`:\n    #    Let this be `v1`. `d1 = r - l + 1`.\n    #    `d2 = x - d1`.\n    #    If `d2 > 0` and `d2 <= MAX_COORD`:\n    #      If `min_cost_by_duration[d2]` is not infinity, then we found a pair.\n    #      `ans = min(ans, cost + min_cost_by_duration[d2])`.\n\n    # This approach is almost correct. The `min_cost_by_duration` needs to be\n    # the minimum cost of a voucher of that duration that *ends strictly before* `current_day`.\n\n    # Let's use `vouchers_by_end_day[r]` = list of `(l, cost)` for vouchers ending on day `r`.\n    # `vouchers_by_start_day[l]` = list of `(r, cost)` for vouchers starting on day `l`.\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for l, r, cost in vouchers:\n        vouchers_by_end_day[r].append((l, cost))\n        vouchers_by_start_day[l].append((r, cost))\n\n    # `min_cost_for_duration_ending_before_today[duration]`\n    # Stores the minimum cost of a voucher with `duration` that has `r < current_day`.\n    min_cost_for_duration_ending_before_today = [float('inf')] * (MAX_COORD + 1)\n\n    ans = float('inf')\n\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that start at `current_day`.\n        # These are potential `v1` vouchers.\n        # For each `v1 = (current_day, r1, cost1)`:\n        #   `d1 = r1 - current_day + 1`.\n        #   `d2 = x - d1`.\n        #   If `d2 > 0` and `d2 <= MAX_COORD`:\n        #     If `min_cost_for_duration_ending_before_today[d2]` is not infinity:\n        #       `ans = min(ans, cost1 + min_cost_for_duration_ending_before_today[d2])`.\n\n        for r1, cost1 in vouchers_by_start_day[current_day]:\n            d1 = r1 - current_day + 1\n            if d1 >= x: # If d1 itself is x or more, it can't be part of a pair summing to x with d2 > 0\n                continue\n            d2 = x - d1\n            if d2 > 0 and d2 <= MAX_COORD:\n                if min_cost_for_duration_ending_before_today[d2] != float('inf'):\n                    ans = min(ans, cost1 + min_cost_for_duration_ending_before_today[d2])\n\n        # Step 2: Update `min_cost_for_duration_ending_before_today` with vouchers that end at `current_day`.\n        # These vouchers are now available to be `v2` for future `v1`s (those starting at `current_day + 1` or later).\n        for l_end, cost_end in vouchers_by_end_day[current_day]:\n            d_end = current_day - l_end + 1\n            if d_end <= MAX_COORD:\n                min_cost_for_duration_ending_before_today[d_end] = min(\n                    min_cost_for_duration_ending_before_today[d_end],\n                    cost_end\n                )\n\n    if ans == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(ans) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    max_coord = 2 * 10**5\n    min_cost_at_end_day = [float('inf')] * (max_coord + 2)\n\n    ans = float('inf')\n\n    for i in range(n):\n        l1, r1, cost1 = vouchers[i]\n        duration1 = r1 - l1 + 1\n\n        if duration1 < x:\n            remaining_duration = x - duration1\n            \n            # Check for voucher j such that r_j < l_1\n            # We need a voucher j with duration `remaining_duration` and r_j < l_1\n            # The earliest possible start day for such a voucher j is 1\n            # The latest possible end day for such a voucher j is l_1 - 1 - (remaining_duration - 1)\n            # which simplifies to l_1 - remaining_duration\n            \n            # We need to find min_cost_at_end_day[r_j] for r_j in [1, l_1 - 1]\n            # such that r_j - l_j + 1 = remaining_duration\n            \n            # The `min_cost_at_end_day` array stores the minimum cost of a voucher ending on a specific day,\n            # for a given duration. We need to iterate through vouchers and update this array.\n            # This requires a different approach.\n\n            # Let's group vouchers by duration.\n            # A dictionary where keys are durations and values are lists of (end_day, cost)\n            \n            # Instead of a single min_cost_at_end_day, we need to consider durations.\n            # This suggests iterating through vouchers in a specific order.\n\n            # Let's re-sort by start day.\n            # We will process vouchers sorted by their start day.\n            # For each voucher (l1, r1, cost1), we want to find a second voucher (l2, r2, cost2)\n            # such that r2 < l1 or r1 < l2.\n            # And (r1 - l1 + 1) + (r2 - l2 + 1) = x.\n\n    # Re-approach: Store minimum costs for vouchers ending on a specific day with a specific duration.\n    # This is too much memory.\n\n    # The problem has a constraint on coordinates up to 2 * 10^5.\n    # This suggests an O(N log N) or O(N * max_coord) solution.\n\n    # Let's create a list of vouchers grouped by their start day.\n    # vouchers_by_start_day[s] will contain a list of (r, cost) for vouchers starting on day s.\n    vouchers_by_start_day = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_start_day[l].append((r, cost))\n\n    # min_cost_for_duration_ending_on_day[d][end_day] = min_cost\n    # This is still too much memory if d can be large.\n\n    # Let's use a data structure that can query minimum cost for a specific duration.\n    # Or, iterate through possible split points.\n\n    # Consider processing vouchers in increasing order of their end day `r`.\n    # When we are at voucher `(l1, r1, cost1)`, we want to find a voucher `(l2, r2, cost2)`\n    # such that `r2 < l1` and `(r1 - l1 + 1) + (r2 - l2 + 1) = x`.\n    # This means `r2 - l2 + 1 = x - (r1 - l1 + 1)`. Let `duration2 = x - (r1 - l1 + 1)`.\n    # We need to find a voucher `(l2, r2, cost2)` such that `r2 < l1`, `r2 - l2 + 1 = duration2`,\n    # and `cost2` is minimal.\n\n    # This can be done by maintaining, for each possible duration `d`,\n    # the minimum cost of a voucher with duration `d` that has ended by the current day.\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that duration.\n    # When we process vouchers sorted by `r`, we can update this array.\n\n    # `min_cost_ending_before[day][duration]`\n    # `min_cost_ending_before[day]` is an array/map of (duration -> min_cost)\n\n    # Let's try to iterate through all possible `l1` values.\n    # For each `l1`, we want to find a `(r1, cost1)` and a `(l2, r2, cost2)`.\n\n    # Let's use a `min_cost_for_duration_ending_at_or_before[day][duration]` array.\n    # This is still too much.\n\n    # The key is that `duration = r - l + 1`.\n    # So `l = r - duration + 1`.\n\n    # Let's use a single array `min_cost_for_duration[duration]` that stores the minimum cost\n    # of a voucher with that duration *that has already been processed*.\n\n    # Sort vouchers by their end day `r`.\n    vouchers.sort(key=lambda x: x[1])\n\n    # `min_cost_ending_on_day[d]` stores the minimum cost of a voucher with duration `d`\n    # that ends on or before the current day.\n    # We can use a segment tree or similar structure to query this efficiently,\n    # but a simple array can work if we update it carefully.\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with that duration.\n    # This is not enough, because we need `r2 < l1`.\n\n    # We need to find the minimum cost of a voucher `(l2, r2, cost2)` such that `r2 < l1`\n    # and `r2 - l2 + 1 = duration2`.\n\n    # Let's try iterating through the vouchers.\n    # For each voucher `v1 = (l1, r1, cost1)`:\n    #   Calculate its duration `d1 = r1 - l1 + 1`.\n    #   Calculate the required duration for the second voucher `d2 = x - d1`.\n    #   If `d2 <= 0`, continue.\n\n    #   We need to find a voucher `v2 = (l2, r2, cost2)` such that:\n    #     1. `r2 - l2 + 1 = d2`\n    #     2. `r2 < l1` (or `r1 < l2`)\n\n    #   Case 1: `r2 < l1`.\n    #     We need to find the minimum `cost2` among vouchers `v2` such that `r2 < l1` and `r2 - l2 + 1 = d2`.\n    #     This means `l2 = r2 - d2 + 1`.\n    #     We need to query for `min(cost2)` for vouchers ending at `r2` where `r2` is in `[1, l1 - 1]`.\n    #     This is a range minimum query on `cost2` for a specific duration `d2`.\n\n    # Let's use a list of lists, `min_cost_by_duration_and_end_day`.\n    # `min_cost_by_duration_and_end_day[duration]` will store a list of `(end_day, cost)` pairs,\n    # sorted by `end_day`. This is still too much.\n\n    # The maximum value for `r` is `2 * 10^5`.\n    # The maximum duration is `2 * 10^5`.\n\n    # `min_cost_for_duration_ending_at_day[duration][day]` = min cost of a voucher with `duration` ending on `day`.\n    # This is a 2D array, `2e5 * 2e5` elements, too big.\n\n    # The maximum coordinate is `2 * 10^5`.\n    # We can use an array `min_cost_for_duration_ending_before[day]`\n    # where `min_cost_for_duration_ending_before[day]` is a dictionary mapping `duration` to `min_cost`.\n    # Still too much.\n\n    # Let's consider the structure of the problem. We need two vouchers.\n    # This suggests a sweep-line approach or processing events.\n\n    # Events: voucher starts, voucher ends.\n    # Or, we can iterate through all possible `l1` values from `1` to `max_coord`.\n    # For each `l1`, we consider vouchers starting at `l1`.\n    # And we need to query for vouchers that end before `l1`.\n\n    # Let `min_cost_for_len[duration]` store the minimum cost of a voucher with `duration`.\n    # This array will be updated as we sweep.\n    # `min_cost_for_len` will be `max_coord + 1` size. Initialize with infinity.\n\n    # We need to process vouchers in increasing order of `r`.\n    # For each voucher `(l, r, cost)`:\n    #   `duration = r - l + 1`.\n    #   If `duration < x`:\n    #     `needed_duration = x - duration`.\n    #     If `needed_duration > 0` and `needed_duration <= max_coord`:\n    #       We need to find a voucher `(l_prev, r_prev, cost_prev)` such that `r_prev < l`\n    #       and `r_prev - l_prev + 1 = needed_duration`.\n    #       If such a voucher exists, `cost_prev` should be minimal.\n    #       `min_cost_for_len[needed_duration]` stores the minimum cost of any voucher with `needed_duration`\n    #       that has been processed *so far* (i.e., its `r_prev` is less than or equal to the current `r`).\n    #       This is not quite `r_prev < l`.\n\n    # Let's use an array `min_cost_for_duration_up_to_day[duration]`\n    # This will be `max_coord + 1` size.\n    # `min_cost_for_duration_up_to_day[duration]` will store the minimum cost of a voucher\n    # with `duration` that ends on or before the current sweep day.\n\n    # Let's sort vouchers by `l`.\n    vouchers.sort()\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher with `duration`\n    # that has already been considered for the *first* part of the pair.\n    # This is not quite right.\n\n    # Let's create a list of events.\n    # Events are `(coordinate, type, data)`.\n    # Type 1: `(r, 'end', (duration, cost))` - a voucher ends.\n    # Type 2: `(l, 'start', (duration, cost))` - a voucher starts.\n    # We need to process these events.\n\n    # Max coordinate value.\n    MAX_COORD = 2 * 10**5\n\n    # `min_cost_for_duration_ending_at[duration]`\n    # This needs to be able to query min cost for a duration given an end day constraint.\n    # This is a segment tree or similar.\n    # `min_cost_by_duration[d]` stores the minimum cost of a voucher with duration `d`.\n    # This array will be updated as we iterate through days.\n\n    # `min_cost_by_duration[d]` = min cost of a voucher with duration `d` that has `r < current_l`.\n    # Initialize `min_cost_by_duration` with infinity.\n    min_cost_by_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # Sort vouchers by their start day `l`.\n    vouchers.sort()\n\n    ans = float('inf')\n\n    # We need to iterate through possible `l` values.\n    # For each `l`, we want to consider vouchers that start at `l` as the first voucher `v1`.\n    # And we want to find a second voucher `v2` such that `r2 < l`.\n\n    # To do this efficiently, we can use a sweep-line approach.\n    # We iterate `current_day` from 1 to `MAX_COORD`.\n    # At each `current_day`:\n    # 1. Update `min_cost_by_duration` with vouchers that end at `current_day - 1`.\n    #    (i.e., these vouchers are now available to be the `v2` for any `v1` starting at `current_day` or later).\n    # 2. For all vouchers `(l, r, cost)` that start at `current_day`:\n    #    Let this be `v1`. `d1 = r - l + 1`.\n    #    `d2 = x - d1`.\n    #    If `d2 > 0` and `d2 <= MAX_COORD`:\n    #      If `min_cost_by_duration[d2]` is not infinity, then we found a pair.\n    #      `ans = min(ans, cost + min_cost_by_duration[d2])`.\n\n    # This approach is almost correct. The `min_cost_by_duration` needs to be\n    # the minimum cost of a voucher of that duration that *ends strictly before* `current_day`.\n\n    # Let's use `vouchers_by_end_day[r]` = list of `(l, cost)` for vouchers ending on day `r`.\n    # `vouchers_by_start_day[l]` = list of `(r, cost)` for vouchers starting on day `l`.\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for l, r, cost in vouchers:\n        vouchers_by_end_day[r].append((l, cost))\n        vouchers_by_start_day[l].append((r, cost))\n\n    # `min_cost_for_duration_ending_before_today[duration]`\n    # Stores the minimum cost of a voucher with `duration` that has `r < current_day`.\n    min_cost_for_duration_ending_before_today = [float('inf')] * (MAX_COORD + 1)\n\n    ans = float('inf')\n\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that start at `current_day`.\n        # These are potential `v1` vouchers.\n        # For each `v1 = (current_day, r1, cost1)`:\n        #   `d1 = r1 - current_day + 1`.\n        #   `d2 = x - d1`.\n        #   If `d2 > 0` and `d2 <= MAX_COORD`:\n        #     If `min_cost_for_duration_ending_before_today[d2]` is not infinity:\n        #       `ans = min(ans, cost1 + min_cost_for_duration_ending_before_today[d2])`.\n\n        for r1, cost1 in vouchers_by_start_day[current_day]:\n            d1 = r1 - current_day + 1\n            if d1 >= x: # If d1 itself is x or more, it can't be part of a pair summing to x with d2 > 0\n                continue\n            d2 = x - d1\n            if d2 > 0 and d2 <= MAX_COORD:\n                if min_cost_for_duration_ending_before_today[d2] != float('inf'):\n                    ans = min(ans, cost1 + min_cost_for_duration_ending_before_today[d2])\n\n        # Step 2: Update `min_cost_for_duration_ending_before_today` with vouchers that end at `current_day`.\n        # These vouchers are now available to be `v2` for future `v1`s (those starting at `current_day + 1` or later).\n        for l_end, cost_end in vouchers_by_end_day[current_day]:\n            d_end = current_day - l_end + 1\n            if d_end <= MAX_COORD:\n                min_cost_for_duration_ending_before_today[d_end] = min(\n                    min_cost_for_duration_ending_before_today[d_end],\n                    cost_end\n                )\n\n    if ans == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(ans) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 4065,
        "thoughts_token_count": 0
    }
}