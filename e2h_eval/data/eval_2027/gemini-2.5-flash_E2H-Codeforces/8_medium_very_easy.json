{
    "start": 1758011945.677537,
    "end": 1758012066.4700916,
    "start-formatted": "2025-09-16 17:39 KST",
    "end-formatted": "2025-09-16 17:41 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**The Path to Directed Flow**\n\nOkay, here's what I'm thinking about this \"Flawed Flow\" problem. We're given an undirected graph with flow volumes on each edge, and our job is to direct those edges such that we get a directed acyclic graph (DAG) with flow conservation at all intermediate nodes and no incoming flow at the source.\n\nThe crux of the matter is the \"no cycles\" constraint.  This hints at a topological sort, which guarantees a valid ordering. The source (vertex 1) has no incoming flow, and flow conservation is the golden rule for intermediate vertices.  We also know, thanks to the problem statement, that 1 must be a source, and n the sink, even though it's not explicitly stated that `n` has no outgoing edges.  If 1 is a true source and flow is conserved, then everything must eventually reach n. This problem screams max-flow and trying to ensure that it has all of the constraints needed.\n\nI'm starting by visualizing the total flow, F, leaving vertex 1 and entering vertex n. The flow can't magically appear or disappear. Intermediate nodes must have an equal amount of incoming and outgoing flow (balance rule).  So, for `1 < v < n`, flow in equals flow out.\n\nThe direction of edges should be determined by a topological order, but we don't have this explicitly, so we need to find it by using all the constraints of the problem.\n\nMy initial thought is to analyze flow balance at each vertex: the difference between incoming and outgoing flow (deficit). Intermediate nodes should have a zero deficit.  Vertex 1 has a negative deficit equal to the total flow. The sink `n` has a positive deficit (equal to `F`).\n\nThe edges connected to vertex 1 have a single possibility to fix their direction to maintain these constraints. Then we work on the other nodes in a methodical way.\n\nLet's maintain `current_flow_in` and `current_flow_out` for each node, along with a deficit value for each node.  We can process the nodes in an iterative fashion, making sure all balances get solved in the end. It's like finding a valid flow assignment within the graph that matches all node's constraints.\n",
    "response": "The problem asks us to direct each edge `(a_i, b_i)` with a given flow volume `c_i` such that three conditions are met:\n1.  **Flow Conservation:** For every intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  **Source Constraint:** Vertex 1 has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph contains no cycles.\n\nLet's denote the total flow from source 1 to sink `n` as `F`.\nFrom condition 2, all edges connected to vertex 1 must be directed away from 1. This means `F` is simply the sum of all `c_i` for edges connected to vertex 1.\nFor any intermediate vertex `v` (1 < `v` < `n`), flow conservation means that `sum(incoming flow to v) = sum(outgoing flow from v)`.\nThe \"no cycles\" condition is very strong. It implies that there exists a topological ordering of the vertices. If we can find such an ordering, we can direct edges `u -> v` if `u` comes before `v` in the ordering, ensuring acyclicity.\n\nConsider the \"net flow deficit\" for each vertex `v`, defined as `sum(incoming flow to v) - sum(outgoing flow from v)`.\n*   For `1 < v < n`, the net flow deficit must be 0 (due to flow conservation).\n*   For `v = 1` (source), since it has no incoming edges and `F` units of flow exit it, its net flow deficit must be `-F`.\n*   For `v = n` (sink), since `F` units of flow enter it and it must eventually absorb all flow (otherwise flow would go elsewhere or cycle), its net flow deficit must be `F`.\n\nLet `total_incident_flow[v]` be the sum of `c_i` for all edges connected to vertex `v`.\nFor any vertex `v`, `sum(incoming flow to v) + sum(outgoing flow from v) = total_incident_flow[v]`.\nLet `in_v` be `sum(incoming flow to v)` and `out_v` be `sum(outgoing flow from v)`.\nWe have:\n1.  `in_v - out_v = target_deficit_v`\n2.  `in_v + out_v = total_incident_flow[v]`\n\nAdding these two equations: `2 * in_v = target_deficit_v + total_incident_flow[v]`.\nSubtracting the first from the second: `2 * out_v = total_incident_flow[v] - target_deficit_v`.\n\nSo, we can determine the *required* `in_v` and `out_v` for each vertex:\n*   `F = total_incident_flow[1]`.\n*   For `1 < v < n`: `target_deficit_v = 0`.\n    `required_in_v = total_incident_flow[v] / 2`\n    `required_out_v = total_incident_flow[v] / 2`\n*   For `v = 1`: `target_deficit_1 = -F`.\n    `required_in_1 = (total_incident_flow[1] - F) / 2 = (F - F) / 2 = 0`\n    `required_out_1 = (total_incident_flow[1] + F) / 2 = (F + F) / 2 = F`\n*   For `v = n`: `target_deficit_n = F`.\n    `required_in_n = (total_incident_flow[n] + F) / 2`\n    `required_out_n = (total_incident_flow[n] - F) / 2`\n\nThese `required_in_v` and `required_out_v` values must be non-negative integers. This implies certain parity conditions on `total_incident_flow[v]` and `F`. The problem guarantees a solution exists, so we don't need to worry about these parities.\n\nNow we need to direct the edges such that these requirements are met and no cycles are formed.\nA Breadth-First Search (BFS) starting from vertex `n` (the sink) can help. We want to \"push\" flow towards `n`.\nLet `current_incoming_flow[v]` be the sum of flow on edges already directed into `v`, and `current_outgoing_flow[v]` be the sum of flow on edges already directed out of `v`.\nWe use a queue `q` to process vertices. Initially, add `n` to the queue.\nFor each vertex `u` popped from the queue:\nIterate through its undirected neighbors `v` via an edge `(u, v)` with flow `c`.\nIf this edge has not been directed yet:\n  We need to decide if it's `u -> v` or `v -> u`.\n  Since we are processing from `n` backwards (conceptually), we prefer to direct flow towards `u` if `u` still needs incoming flow, or away from `u` if `u` has excess outgoing flow.\n  More concretely, we want to satisfy `required_in_u` and `required_out_u`.\n  If `current_incoming_flow[u]` is less than `required_in_u`, it means `u` still needs incoming flow. So, we direct `v -> u`.\n  If `current_outgoing_flow[u]` is less than `required_out_u`, it means `u` still needs to send flow out. So, we direct `u -> v`.\n\nThis specific strategy might lead to cycles if not careful. A simpler approach that guarantees acyclicity is to use the fact that vertex 1 has no incoming edges. This means all edges `(1, x)` must be directed `1 -> x`. This establishes an initial set of directed edges.\n\nLet's maintain `current_balance[v] = sum(incoming flow) - sum(outgoing flow)` for each vertex `v`.\nInitialize `current_balance[v] = 0` for all `v`.\nInitialize `ans[idx] = -1` for all edge indices.\n`edges_adj_list[v]` stores `(neighbor, flow, original_idx)` for all edges connected to `v`.\n`initial_edges[idx]` stores `(u, v, c)` for the original edge.\n\nWe can use a queue to process vertices whose `current_balance` is not yet zero (for intermediate nodes) or not yet at its target (for `1` and `n`).\nThe \"no cycles\" condition combined with \"vertex 1 has no incoming edges\" means we can process vertices in a topological manner *starting from vertex 1*.\n\nLet's refine the approach:\n1.  Calculate `total_incident_flow[v]` for all `v`.\n2.  Calculate `F = total_incident_flow[1]`.\n3.  Calculate `target_in_flow[v]` and `target_out_flow[v]` for all `v` as derived above.\n    `target_in_flow[1] = 0`, `target_out_flow[1] = F`.\n    For `1 < v < n`: `target_in_flow[v] = total_incident_flow[v] / 2`, `target_out_flow[v] = total_incident_flow[v] / 2`.\n    `target_in_flow[n] = (total_incident_flow[n] + F) / 2`, `target_out_flow[n] = (total_incident_flow[n] - F) / 2`.\n4.  Initialize `current_in_flow[v] = 0`, `current_out_flow[v] = 0` for all `v`.\n5.  Initialize `ans = [-1] * m`.\n6.  Create an adjacency list `adj` where `adj[u]` stores `(v, c, edge_idx)` for all neighbors `v`.\n7.  Use a `deque` `q` for a BFS-like traversal. Add vertex 1 to `q`.\n8.  Maintain `visited_edge[edge_idx]` to avoid processing edges multiple times.\n\nNow, the core logic:\nWhile `q` is not empty:\n  Pop `u` from `q`.\n  Iterate through `(v, flow, edge_idx)` in `adj[u]`:\n    If `ans[edge_idx]` is still `-1` (edge not directed yet):\n      Let `original_u, original_v, _ = initial_edges[edge_idx]`.\n      We need to decide `original_u -> original_v` (ans=0) or `original_v -> original_u` (ans=1).\n      The strategy is to satisfy `required_out_flow[u]` first.\n      If `current_out_flow[u] < target_out_flow[u]`:\n        This means `u` still needs to send `target_out_flow[u] - current_out_flow[u]` flow out.\n        Direct `u -> v` (if `u` is `original_u`, `ans[edge_idx]=0`; if `u` is `original_v`, `ans[edge_idx]=1`).\n        Update `current_out_flow[u] += flow`.\n        Update `current_in_flow[v] += flow`.\n        If `v != 1` and `v != n` and `current_in_flow[v] == target_in_flow[v]` and `current_out_flow[v] == target_out_flow[v]`:\n          `v` is balanced. No need to add to queue.\n        If `v != 1` and `v != n` and `current_in_flow[v] > target_in_flow[v]` (or `current_out_flow[v] > target_out_flow[v]`):\n          This should not happen if a solution exists and we direct edges correctly.\n        If `v != n` and `current_out_flow[v] < target_out_flow[v]`: (i.e., `v` needs to send more flow out)\n          Add `v` to `q`.\n      Else (`current_out_flow[u] == target_out_flow[u]`):\n        This means `u` has already sent out all its required flow. So this edge must be `v -> u`.\n        Direct `v -> u` (if `u` is `original_u`, `ans[edge_idx]=1`; if `u` is `original_v`, `ans[edge_idx]=0`).\n        Update `current_in_flow[u] += flow`.\n        Update `current_out_flow[v] += flow`.\n        If `v != n` and `current_out_flow[v] < target_out_flow[v]`:\n          Add `v` to `q`.\n      Set `ans[edge_idx]` and `visited_edge[edge_idx] = True`.\n\nThe \"no cycles\" condition is implicitly handled by this BFS-like approach. We are essentially building a directed graph layer by layer, starting from the source and pushing flow, or from the sink and pulling flow. Since we only push flow from nodes that have an outgoing flow deficit and pull flow to nodes that have an incoming flow deficit, and we try to satisfy outgoing flow first, this tends to direct edges away from the source and towards the sink.\n\nLet's use a simpler logic for directing edges based on the `current_balance` (which is `in - out`).\nA vertex `u` is \"satisfied\" if `current_balance[u]` equals its `target_balance[u]` (which is `target_in_flow[u] - target_out_flow[u]`).\nInitially, add `n` to the queue.\nWhile `q` is not empty:\n  Pop `u` from `q`.\n  If `u == 1`, continue (source has special rules, it's handled by its neighbors).\n  For each neighbor `v` of `u` with edge `(original_u, original_v, c)` at `edge_idx`:\n    If `ans[edge_idx]` is `-1` (edge not directed yet):\n      Determine if `u` is `original_u` or `original_v`.\n      If `current_balance[u] < target_balance[u]`: (meaning `u` needs more incoming flow or less outgoing flow)\n        Direct `v -> u`.\n        If `u` was `original_u`, `ans[edge_idx] = 1`.\n        If `u` was `original_v`, `ans[edge_idx] = 0`.\n        `current_balance[u] += c`.\n        `current_balance[v] -= c`.\n        If `v != 1` and `current_balance[v] != target_balance[v]`: add `v` to `q`.\n      Else (`current_balance[u] > target_balance[u]`): (meaning `u` needs more outgoing flow or less incoming flow)\n        Direct `u -> v`.\n        If `u` was `original_u`, `ans[edge_idx] = 0`.\n        If `u` was `original_v`, `ans[edge_idx] = 1`.\n        `current_balance[u] -= c`.\n        `current_balance[v] += c`.\n        If `v != 1` and `current_balance[v] != target_balance[v]`: add `v` to `q`.\n      Set `ans[edge_idx]` and mark edge as visited.\n\nThis strategy starts from `n` and tries to balance its flow. If `n` needs more incoming flow, it tries to direct edges `v -> n`. If `n` has too much incoming flow, it tries `n -> v`. This is problematic because `n` is the sink, it should not have outgoing flow if `total_incident_flow[n] - F` is 0.\n\nThe problem states \"vertex with number 1 has no incoming edges\". This is the strongest constraint.\nLet's use a BFS starting from vertex 1.\n`q = deque()`\n`q.append(1)`\n`current_balance = [0] * (n + 1)` # `in - out`\n`ans = [-1] * m`\n`visited_edge = [False] * m`\n\nWhile `q`:\n  `u = q.popleft()`\n  For `(v, flow, edge_idx)` in `adj[u]`:\n    If `not visited_edge[edge_idx]`:\n      `orig_u, orig_v, _ = initial_edges[edge_idx]`\n      # If u is the source (1), it must send flow out.\n      # For other nodes, we try to balance.\n      # We want current_balance[u] to eventually be target_balance[u]\n      # target_balance[1] = -F\n      # target_balance[n] = F\n      # target_balance[v] = 0 for 1 < v < n\n\n      # If u is the original_u of the edge, then direction u -> v means ans[edge_idx]=0\n      # If u is the original_v of the edge, then direction u -> v means ans[edge_idx]=1\n      \n      # Decision logic:\n      # If u is 1, it must send flow out. So 1 -> v.\n      # If v is 1, it must send flow out. So 1 -> u. (This edge is already processed when 1 is popped).\n      # If u is not 1 and not n:\n      #   If current_balance[u] + flow <= target_balance[u] (allowing flow from v to u):\n      #     Direct v -> u.\n      #     This increases current_balance[u] by flow.\n      #     This decreases current_balance[v] by flow.\n      #   Else (must send flow u -> v):\n      #     Direct u -> v.\n      #     This decreases current_balance[u] by flow.\n      #     This increases current_balance[v] by flow.\n      # This decision is tricky, as it might add flow to v, which might then become unbalanced.\n\nA simpler approach that guarantees acyclicity is to use the `target_out_flow` for each node.\nWe can use a modified BFS/DFS.\nStart from vertex 1. All its neighbors must receive flow from 1.\n`current_out_flow[v]` tracks how much flow `v` has sent out.\n`current_in_flow[v]` tracks how much flow `v` has received.\n`ans = [-1] * m`\n`q = deque()`\n`q.append(1)`\n`visited_edge = [False] * m`\n\nWhile `q`:\n  `u = q.popleft()`\n  For `(v, flow, edge_idx)` in `adj[u]`:\n    If `not visited_edge[edge_idx]`:\n      `orig_u, orig_v, _ = initial_edges[edge_idx]`\n      \n      # Always direct flow from u to v if u has an outgoing flow deficit\n      # and v is not 1.\n      # This ensures we are always trying to push flow \"forward\".\n      \n      # If u is 1, it MUST direct flow out.\n      # If v is 1, it MUST direct flow out (meaning u -> 1 is impossible).\n      # So, for any edge involving 1, flow must be 1 -> other_node.\n      if u == 1:\n          # Edge is (1, v). Flow must be 1 -> v.\n          if orig_u == 1: ans[edge_idx] = 0 # 1 -> v\n          else: ans[edge_idx] = 1 # v -> 1, but orig_v is 1, so 1 -> v\n          \n          current_out_flow[1] += flow\n          current_in_flow[v] += flow\n          visited_edge[edge_idx] = True\n          if v != n and (current_in_flow[v] < target_in_flow[v] or current_out_flow[v] < target_out_flow[v]):\n              q.append(v)\n      elif v == 1: # u is not 1, v is 1. This edge must be 1 -> u. This means it should have been processed when 1 was popped.\n                   # This case should not be reached if 1 is processed first and all its edges are marked visited.\n                   # If it is reached, it implies a cycle, but problem guarantees no cycles with a valid solution.\n                   # So we can assume this edge was already directed 1 -> u.\n          pass # Already handled when 1 was popped\n      else: # Neither u nor v is 1.\n          # We need to decide u -> v or v -> u.\n          # We prioritize satisfying u's outgoing flow (pushing flow forward).\n          # If u still needs to send flow out, direct u -> v.\n          if current_out_flow[u] < target_out_flow[u]:\n              if orig_u == u: ans[edge_idx] = 0 # u -> v\n              else: ans[edge_idx] = 1 # v -> u, but we want u -> v, so this means orig_v == u\n              \n              current_out_flow[u] += flow\n              current_in_flow[v] += flow\n              visited_edge[edge_idx] = True\n              if v != n and (current_in_flow[v] < target_in_flow[v] or current_out_flow[v] < target_out_flow[v]):\n                  q.append(v)\n          # If u has already sent all its required flow out, then this edge must be incoming to u.\n          # This means v -> u.\n          else:\n              if orig_u == u: ans[edge_idx] = 1 # v -> u\n              else: ans[edge_idx] = 0 # u -> v, but we want v -> u, so this means orig_v == u\n              \n              current_in_flow[u] += flow\n              current_out_flow[v] += flow\n              visited_edge[edge_idx] = True\n              if v != n and (current_in_flow[v] < target_in_flow[v] or current_out_flow[v] < target_out_flow[v]):\n                  q.append(v)\n\nThis BFS-based approach, prioritizing outgoing flow, ensures that flow generally moves away from the source. Because we only add `v` to the queue if it's not `n` and still needs balancing, and `n` is the sink, this process should terminate and correctly direct all edges without forming cycles.\n\nLet's simplify the `target_in_flow` and `target_out_flow` calculations.\nWe only need to track the `current_balance[v] = in_flow - out_flow`.\nAnd `target_balance[v]`.\n`target_balance[1] = -F`\n`target_balance[n] = F`\n`target_balance[v] = 0` for `1 < v < n`.\n\nRevised BFS:\n1.  Precompute `total_incident_flow[v]` for all `v`.\n2.  `F = total_incident_flow[1]`.\n3.  `target_balance = [0] * (n + 1)`\n    `target_balance[1] = -F`\n    `target_balance[n] = F`\n4.  `current_balance = [0] * (n + 1)`\n5.  `ans = [-1] * m`\n6.  `adj` list: `adj[u]` contains `(v, c, edge_idx)`\n7.  `q = deque()`\n8.  Add vertex `1` to `q`.\n9.  `visited_edge = [False] * m`\n\nWhile `q`:\n  `u = q.popleft()`\n  For `(v, flow, edge_idx)` in `adj[u]`:\n    If `not visited_edge[edge_idx]`:\n      `orig_u, orig_v, _ = initial_edges[edge_idx]`\n      \n      # Decide direction: `u -> v` or `v -> u`\n      # If `u` needs to send more flow out (its `current_balance` is not yet low enough):\n      #   Direct `u -> v`. This decreases `current_balance[u]`.\n      # Else (`u` has already sent enough flow out, or needs to receive flow):\n      #   Direct `v -> u`. This increases `current_balance[u]`.\n      \n      # If u is 1, it must send flow out.\n      # If v is 1, u must send flow out (1 -> u). This means the edge is (u,1) and flow is 1->u.\n      # So, for any edge involving 1, it must be 1 -> other_node.\n      # This means `current_balance[1]` must decrease by `flow`.\n      \n      # If `u` is `1`:\n      #   Direct `1 -> v`.\n      #   If `orig_u == 1`, `ans[edge_idx] = 0`.\n      #   Else (`orig_v == 1`), `ans[edge_idx] = 1`.\n      #   `current_balance[1] -= flow`.\n      #   `current_balance[v] += flow`.\n      #   `visited_edge[edge_idx] = True`.\n      #   If `v != n` and `current_balance[v] != target_balance[v]`: `q.append(v)`.\n      # Else (`u` is not `1`):\n      #   If `v` is `1`: (This edge should have been processed when 1 was popped. If not, it means we have a cycle or issue)\n      #     This case implies `1 -> u` was decided. So `current_balance[u]` should have increased.\n      #     This path shouldn't be taken.\n      #   Else (`v` is not `1`):\n      #     # Prioritize making `u` send flow out if it's not balanced yet and can send more out.\n      #     # `current_balance[u]` is `in - out`. To send flow out, `current_balance[u]` must decrease.\n      #     # So, if `current_balance[u] > target_balance[u]`: this means `u` has too much `in` or too little `out`.\n      #     # We direct `u -> v` to reduce `current_balance[u]`.\n      #     # This pushes flow away from `u`.\n      #     if current_balance[u] > target_balance[u]:\n      #         # Direct `u -> v`.\n      #         if `orig_u == u`: `ans[edge_idx] = 0`.\n      #         else: `ans[edge_idx] = 1`.\n      #         `current_balance[u] -= flow`.\n      #         `current_balance[v] += flow`.\n      #         `visited_edge[edge_idx] = True`.\n      #         If `v != n` and `current_balance[v] != target_balance[v]`: `q.append(v)`.\n      #     Else (`current_balance[u] < target_balance[u]`):\n      #         # This means `u` needs more incoming flow.\n      #         # Direct `v -> u`.\n      #         if `orig_u == u`: `ans[edge_idx] = 1`.\n      #         else: `ans[edge_idx] = 0`.\n      #         `current_balance[u] += flow`.\n      #         `current_balance[v] -= flow`.\n      #         `visited_edge[edge_idx] = True`.\n      #         If `v != n` and `current_balance[v] != target_balance[v]`: `q.append(v)`.\n      #     # What if current_balance[u] == target_balance[u]?\n      #     # This means u is balanced. It should not initiate or receive flow from an undirected edge.\n      #     # This implies this edge must have been decided by v.\n      #     # This case should not be reached if the graph is processed correctly.\n\nThe problem guarantees a solution exists. The simplest way to ensure acyclicity is to process nodes in an order that naturally forms a DAG. Starting from 1 and always trying to push flow forward (away from 1) is a good strategy.\n\nLet's try a single BFS pass starting from 1.\nWhen we process `u`, we iterate its neighbors `v`.\nIf `v` is `n`, we can direct `u -> n` if `u` needs to send flow out, or `n -> u` if `u` needs to receive flow.\nIf `v` is `1`, this edge must be `1 -> u`.\nFor `1 < v < n`, we need `in_v = out_v`.\nThe strategy is to direct edges such that `u` sends `target_out_flow[u]` and receives `target_in_flow[u]`.\nThe total flow `F` is `total_incident_flow[1]`.\nFor each `v` (1 < `v` < `n`), `target_out_flow[v] = total_incident_flow[v] / 2`.\nFor `v = 1`, `target_out_flow[1] = F`.\n\nFinal refined strategy:\n1.  Read input, store edges `(u, v, c, idx)` in `initial_edges`. Build adjacency list `adj[vertex]` -> list of `(neighbor, flow, edge_idx)`.\n2.  Calculate `total_incident_flow[v]` for all `v`.\n3.  Calculate `F = total_incident_flow[1]`.\n4.  Initialize `current_out_flow[v] = 0` for all `v`. This tracks how much flow `v` has sent out *so far*.\n5.  Initialize `ans = [-1] * m`.\n6.  `q = deque()`\n7.  Add `1` to `q`.\n8.  `visited_edge = [False] * m`.\n\nWhile `q`:\n  `u = q.popleft()`\n  For `(v, flow, edge_idx)` in `adj[u]`:\n    If `not visited_edge[edge_idx]`:\n      `orig_u, orig_v, _ = initial_edges[edge_idx]`\n      \n      # Determine `target_out_u_needed`:\n      `target_out_u_needed = 0`\n      if u == 1:\n        target_out_u_needed = F\n      elif u == n:\n        target_out_u_needed = (total_incident_flow[n] - F) // 2\n      else: # 1 < u < n\n        target_out_u_needed = total_incident_flow[u] // 2\n      \n      # Decide direction based on whether `u` still needs to send flow out.\n      if `current_out_flow[u] < target_out_u_needed`:\n        # `u` needs to send more flow out. Direct `u -> v`.\n        if `orig_u == u`: `ans[edge_idx] = 0`\n        else: `ans[edge_idx] = 1` # `orig_v == u`, so `u -> orig_u`\n        `current_out_flow[u] += flow`\n        \n        # Add `v` to queue if it's not `n` and not yet processed.\n        # We only add to queue if `v` itself is not fully balanced yet.\n        # This is a bit tricky. A simpler way is to just add it if `v` is not `n`.\n        # Since it's a DAG, a node `v` will eventually be processed if it's not `n`.\n        if `v != n`: `q.append(v)`\n      else:\n        # `u` has already sent enough flow out. This edge must be `v -> u`.\n        if `orig_u == u`: `ans[edge_idx] = 1` # `v -> u`\n        else: `ans[edge_idx] = 0` # `u -> v`, but `orig_v == u`, so `v -> orig_v`\n        # `current_out_flow[v]` (for neighbor `v`) will be implicitly updated when `v` is popped.\n        # No change to `current_out_flow[u]` as flow is incoming.\n        \n        # `v` is the source of this flow. It might need to send more flow out.\n        if `v != n`: `q.append(v)`\n      \n      `visited_edge[edge_idx] = True`\n\nThis strategy still has a flaw: `current_out_flow[v]` is not updated when flow is `v -> u`.\nWe need to track `current_balance` for each node.\n`current_balance[v]` = `sum(in) - sum(out)`.\n`target_balance[1] = -F`.\n`target_balance[n] = F`.\n`target_balance[v] = 0` for `1 < v < n`.\n\nLet's use the `current_balance` and `target_balance` directly.\n1.  Read input, store edges `(u, v, c, idx)` in `initial_edges`. Build adjacency list `adj[vertex]` -> list of `(neighbor, flow, edge_idx)`.\n2.  Calculate `total_incident_flow[v]` for all `v`.\n3.  Calculate `F = total_incident_flow[1]`.\n4.  Initialize `target_balance = [0] * (n + 1)`.\n    `target_balance[1] = -F`.\n    `target_balance[n] = F`.\n5.  Initialize `current_balance = [0] * (n + 1)`.\n6.  `ans = [-1] * m`.\n7.  `q = deque()`.\n8.  Add `1` to `q`.\n9.  `visited_edge = [False] * m`.\n\nWhile `q`:\n  `u = q.popleft()`\n  For `(v, flow, edge_idx)` in `adj[u]`:\n    If `not visited_edge[edge_idx]`:\n      `orig_u, orig_v, _ = initial_edges[edge_idx]`\n      \n      # Decision logic:\n      # If `u` needs to send flow out (i.e., `current_balance[u]` is too high, needs to decrease):\n      #   Direct `u -> v`.\n      # Else (`u` needs to receive flow, i.e., `current_balance[u]` is too low, needs to increase):\n      #   Direct `v -> u`.\n      \n      # Exception: If `u` is `1`, it MUST send flow out.\n      # If `v` is `1`, it MUST send flow out (meaning `1 -> u`).\n      # So, for any edge involving `1`, the direction is `1 -> other_node`.\n      \n      is_directed_u_to_v = False\n      if u == 1:\n          is_directed_u_to_v = True\n      elif v == 1: # This means the edge is (u,1). It must be 1 -> u. So u is receiving flow.\n          is_directed_u_to_v = False\n      elif current_balance[u] > target_balance[u]: # `u` has excess `in` or deficit `out`. Needs to send flow out.\n          is_directed_u_to_v = True\n      else: # `u` has deficit `in` or excess `out`. Needs to receive flow.\n          is_directed_u_to_v = False\n\n      if is_directed_u_to_v:\n          # Flow is u -> v\n          if orig_u == u: ans[edge_idx] = 0\n          else: ans[edge_idx] = 1 # orig_v == u\n          current_balance[u] -= flow\n          current_balance[v] += flow\n      else:\n          # Flow is v -> u\n          if orig_u == u: ans[edge_idx] = 1\n          else: ans[edge_idx] = 0 # orig_v == u\n          current_balance[u] += flow\n          current_balance[v] -= flow\n      \n      visited_edge[edge_idx] = True\n      \n      # If `v` is not `n` and `v` is not balanced yet, add `v` to queue.\n      # If `v` is `1`, it will be processed when it's popped.\n      if v != n and current_balance[v] != target_balance[v]:\n          q.append(v)\n\nThis BFS approach should work. It essentially processes nodes in a topological order (or close to it) implied by the flow direction. Each edge is directed once, and the conditions are met.\n\nExample 1 dry run:\n3 3\n(3,2,10,0) (1,2,10,1) (3,1,5,2)\nN=3, M=3\n\ninitial_edges = [(3,2,10), (1,2,10), (3,1,5)]\nadj:\n1: [(2,10,1), (3,5,2)]\n2: [(3,10,0), (1,10,1)]\n3: [(2,10,0), (1,5,2)]\n\ntotal_incident_flow:\n1: 10+5 = 15\n2: 10+10 = 20\n3: 10+5 = 15\n\nF = total_incident_flow[1] = 15\n\ntarget_balance:\n1: -F = -15\n2: 0 (1 < 2 < 3)\n3: F = 15\n\ncurrent_balance = [0,0,0,0]\nans = [-1,-1,-1]\nq = deque([1])\nvisited_edge = [F,F,F]\n\nPop u=1.\nEdges from 1: (2,10,1), (3,5,2)\n\n1. Process (2,10,1): orig_u=1, orig_v=2, flow=10, edge_idx=1\n   u=1, so `is_directed_u_to_v = True`. Flow is 1 -> 2.\n   `orig_u==1`, so `ans[1]=0`.\n   `current_balance[1] -= 10` -> -10.\n   `current_balance[2] += 10` -> 10.\n   `visited_edge[1] = True`.\n   `v=2` is not `n=3`, `current_balance[2]=10` != `target_balance[2]=0`. So `q.append(2)`. `q = deque([2])`.\n\n2. Process (3,5,2): orig_u=3, orig_v=1, flow=5, edge_idx=2 (note: this is (3,1,5) from input, so u=1 is orig_v)\n   u=1, so `is_directed_u_to_v = True`. Flow is 1 -> 3.\n   `orig_u=3` (which is not `u=1`), so `ans[2]=1`. (Means `orig_v -> orig_u` is `1 -> 3`).\n   `current_balance[1] -= 5` -> -10-5 = -15.\n   `current_balance[3] += 5` -> 5.\n   `visited_edge[2] = True`.\n   `v=3` is `n=3`. Not added to queue. `q = deque([2])`.\n\nPop u=2.\nEdges from 2: (3,10,0), (1,10,1)\n\n1. Process (3,10,0): orig_u=3, orig_v=2, flow=10, edge_idx=0\n   `visited_edge[0]` is `False`.\n   `u=2` is not `1`. `v=3` is not `1`.\n   `current_balance[2]=10`, `target_balance[2]=0`. `current_balance[2] > target_balance[2]`.\n   So `is_directed_u_to_v = True`. Flow is 2 -> 3.\n   `orig_u=3` (not `u=2`), so `ans[0]=1`. (Means `orig_v -> orig_u` is `2 -> 3`).\n   `current_balance[2] -= 10` -> 10-10 = 0.\n   `current_balance[3] += 10` -> 5+10 = 15.\n   `visited_edge[0] = True`.\n   `v=3` is `n=3`. Not added to queue. `q = deque([])`.\n\n2. Process (1,10,1): orig_u=1, orig_v=2, flow=10, edge_idx=1\n   `visited_edge[1]` is `True`. Skip.\n\nQueue is empty. Loop ends.\n\nFinal `ans`:\n`ans[0] = 1` (edge (3,2,10) is 2 -> 3)\n`ans[1] = 0` (edge (1,2,10) is 1 -> 2)\n`ans[2] = 1` (edge (3,1,5) is 1 -> 3)\n\nOutput:\n1\n0\n1\nThis matches the example output.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    initial_edges = []\n    adj = [[] for _ in range(n + 1)]\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        initial_edges.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    total_incident_flow = [0] * (n + 1)\n    for u, v, c in initial_edges:\n        total_incident_flow[u] += c\n        total_incident_flow[v] += c\n\n    F = total_incident_flow[1]\n\n    target_balance = [0] * (n + 1)\n    target_balance[1] = -F\n    target_balance[n] = F\n\n    current_balance = [0] * (n + 1)\n    ans = [-1] * m\n    visited_edge = [False] * m\n\n    q = deque()\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n\n        for v, flow, edge_idx in adj[u]:\n            if not visited_edge[edge_idx]:\n                orig_u, orig_v, _ = initial_edges[edge_idx]\n                \n                is_directed_u_to_v = False\n                \n                if u == 1:\n                    # Vertex 1 must send flow out.\n                    is_directed_u_to_v = True\n                elif v == 1:\n                    # This edge is (u,1). Vertex 1 must send flow out, so 1 -> u.\n                    # This means u receives flow.\n                    is_directed_u_to_v = False\n                elif current_balance[u] > target_balance[u]:\n                    # u has a positive balance (more incoming than outgoing, or needs more outgoing).\n                    # To reduce its balance (send flow out), direct u -> v.\n                    is_directed_u_to_v = True\n                else:\n                    # u has a negative balance (more outgoing than incoming, or needs more incoming).\n                    # To increase its balance (receive flow), direct v -> u.\n                    is_directed_u_to_v = False\n\n                if is_directed_u_to_v:\n                    # Flow is u -> v\n                    if orig_u == u:\n                        ans[edge_idx] = 0  # a_i -> b_i\n                    else:  # orig_v == u\n                        ans[edge_idx] = 1  # b_i -> a_i (which is u -> orig_u)\n                    current_balance[u] -= flow\n                    current_balance[v] += flow\n                else:\n                    # Flow is v -> u\n                    if orig_u == u:\n                        ans[edge_idx] = 1  # b_i -> a_i (which is v -> u)\n                    else:  # orig_v == u\n                        ans[edge_idx] = 0  # a_i -> b_i (which is v -> u)\n                    current_balance[u] += flow\n                    current_balance[v] -= flow\n                \n                visited_edge[edge_idx] = True\n                \n                # If v is not the sink and its balance is not yet at target, add to queue.\n                # If v is 1, it will be processed when it's popped.\n                if v != n and current_balance[v] != target_balance[v]:\n                    q.append(v)\n    \n    for res in ans:\n        sys.stdout.write(str(res) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    initial_edges = []\n    adj = [[] for _ in range(n + 1)]\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        initial_edges.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    total_incident_flow = [0] * (n + 1)\n    for u, v, c in initial_edges:\n        total_incident_flow[u] += c\n        total_incident_flow[v] += c\n\n    F = total_incident_flow[1]\n\n    target_balance = [0] * (n + 1)\n    target_balance[1] = -F\n    target_balance[n] = F\n\n    current_balance = [0] * (n + 1)\n    ans = [-1] * m\n    visited_edge = [False] * m\n\n    q = deque()\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n\n        for v, flow, edge_idx in adj[u]:\n            if not visited_edge[edge_idx]:\n                orig_u, orig_v, _ = initial_edges[edge_idx]\n                \n                is_directed_u_to_v = False\n                \n                if u == 1:\n                    # Vertex 1 must send flow out.\n                    is_directed_u_to_v = True\n                elif v == 1:\n                    # This edge is (u,1). Vertex 1 must send flow out, so 1 -> u.\n                    # This means u receives flow.\n                    is_directed_u_to_v = False\n                elif current_balance[u] > target_balance[u]:\n                    # u has a positive balance (more incoming than outgoing, or needs more outgoing).\n                    # To reduce its balance (send flow out), direct u -> v.\n                    is_directed_u_to_v = True\n                else:\n                    # u has a negative balance (more outgoing than incoming, or needs more incoming).\n                    # To increase its balance (receive flow), direct v -> u.\n                    is_directed_u_to_v = False\n\n                if is_directed_u_to_v:\n                    # Flow is u -> v\n                    if orig_u == u:\n                        ans[edge_idx] = 0  # a_i -> b_i\n                    else:  # orig_v == u\n                        ans[edge_idx] = 1  # b_i -> a_i (which is u -> orig_u)\n                    current_balance[u] -= flow\n                    current_balance[v] += flow\n                else:\n                    # Flow is v -> u\n                    if orig_u == u:\n                        ans[edge_idx] = 1  # b_i -> a_i (which is v -> u)\n                    else:  # orig_v == u\n                        ans[edge_idx] = 0  # a_i -> b_i (which is v -> u)\n                    current_balance[u] += flow\n                    current_balance[v] -= flow\n                \n                visited_edge[edge_idx] = True\n                \n                # If v is not the sink and its balance is not yet at target, add to queue.\n                # If v is 1, it will be processed when it's popped.\n                if v != n and current_balance[v] != target_balance[v]:\n                    q.append(v)\n    \n    for res in ans:\n        sys.stdout.write(str(res) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 10194,
        "thoughts_token_count": 6221
    }
}