{
    "start": 1758009323.1101134,
    "end": 1758009378.664004,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Thinking Through the Snowflake Problem**\n\nOkay, so I'm tackling the \"Rudolf and Snowflakes (hard version)\" problem. It's about figuring out if a given number of vertices (`n`) can form a snowflake structure based on these expansion rules.\n\nMy immediate thought is to break down the problem by understanding how the snowflake grows.  It starts with a central vertex, then expands outwards in layers. The crucial part is that each leaf vertex in a layer connects to `k` new vertices in the next layer. We're also told `k` must be greater than 1, and the initial expansion must be followed by at least one more expansion.\n\nI'm starting to formalize the vertex count.  The first layer adds `k` vertices, so `1 + k` total.  Then the subsequent expansion step kicks in. Each of those `k` leaves expands to `k` more, adding `k^2` vertices.  We continue this for a total of `d` expansions after the initial `k` expansion from the center.\n\nNow, if we have `m = d + 1` layers (counting the initial one), the total number of vertices is a geometric series: `n = 1 + k + k^2 + ... + k^m`.  This sums up to `n = (k^(m+1) - 1) / (k - 1)`.\n\nEssentially, I need to check if there exist integers `k > 1` and `m >= 2` that satisfy this equation for the given `n`. The problem explicitly stated the minimum number of expansions is one (at least one expansion after the initial one, `d >=1`), which gives us `m >= 2`.\n\nIt's clear that certain small values of `n` won't work. For example, `n` can't be 1, 2, or 3. Let's see if those are all the initial checks I need.\n\nSo, I need an algorithm to find if there are such `k` and `m`. I think I will start by iterating through different values of `k` and trying to solve for `m`, starting at `m = 2`. The values for `m` can grow until the result of the formula exceeds `n`. I will need to use a smart way to find `m` to avoid inefficiently checking all the values of `m`. The constraints will guide me a lot here, especially the upper bound on `n`. The key will be efficiently checking if the equation holds for some `k` and `m`.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is defined by a central vertex, connected to `k` new vertices (`k > 1`). Then, this step (connecting `k` new vertices to each leaf) is repeated at least once.\n\nLet's analyze the number of vertices:\n1.  Start with 1 central vertex.\n2.  Connect the central vertex to `k` new vertices. Total vertices: `1 + k`.\n3.  The rule \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices\" must be done *at least once*.\n    *   After step 2, there are `k` vertices connected to only one other vertex (the leaves).\n    *   Applying the rule once: Each of these `k` leaves is connected to `k` new vertices. This adds `k * k = k^2` new vertices. Total vertices: `1 + k + k^2`.\n    *   Applying the rule a second time: There are now `k^2` new leaves. Each is connected to `k` new vertices. This adds `k^2 * k = k^3` new vertices. Total vertices: `1 + k + k^2 + k^3`.\n\nIn general, if the rule is applied `d` times (meaning there are `d+1` layers of vertices after the center), the total number of vertices `n` will be:\n`n = 1 + k + k^2 + ... + k^(d+1)`\n\nLet `m = d+1`. Since `d >= 1`, we must have `m >= 2`.\nSo, `n` must be a sum of a geometric series: `n = sum_{i=0}^{m} k^i`, where `k > 1` and `m >= 2`.\n\nThis sum can be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if, for a given `n` (`1 <= n <= 10^18`), there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\n**Case 1: `m = 2`**\nIf `m = 2`, then `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 +/- sqrt(1 - 4 * (1 - n))) / 2 = (-1 +/- sqrt(4n - 3)) / 2`.\nFor `k` to be a positive integer, `4n - 3` must be a perfect square, say `S^2`, and `(-1 + S)` must be an even positive integer.\n`S = sqrt(4n - 3)`. We need `S` to be an integer.\nThen `k = (S - 1) / 2`. We need `S > 1` (so `k > 0`) and `S` must be odd (so `S - 1` is even).\nIf `S^2 = 4n - 3`, then `S^2` is odd, which implies `S` is odd. So `S - 1` is always even.\nWe just need to check if `4n - 3` is a perfect square and if `k = (sqrt(4n - 3) - 1) / 2 > 1`.\n`k > 1` implies `(sqrt(4n - 3) - 1) / 2 > 1` => `sqrt(4n - 3) - 1 > 2` => `sqrt(4n - 3) > 3` => `4n - 3 > 9` => `4n > 12` => `n > 3`.\nSo, for `n > 3`, we can check if `4n - 3` is a perfect square. If it is, then `n` is a valid snowflake number.\n\n**Case 2: `m >= 3`**\nIn this case, `n = 1 + k + k^2 + ... + k^m`.\nSince `k > 1` and `m >= 3`:\n`k^m < n` and `n < sum_{i=0}^{m} k^i < sum_{i=0}^{m} k^m = (m+1)k^m`.\nAlso, `n = (k^(m+1) - 1) / (k - 1)`.\nFor `k=2`, `n = 2^(m+1) - 1`.\nFor `k=3`, `n = (3^(m+1) - 1) / 2`.\nFor larger `k`, `k^(m+1)` grows very fast.\nSince `n <= 10^18`:\n*   If `m=3`, `n = 1 + k + k^2 + k^3`. `k^3 < 10^18` implies `k < (10^18)^(1/3) = 10^6`.\n*   If `m=4`, `n = 1 + k + k^2 + k^3 + k^4`. `k^4 < 10^18` implies `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\n*   If `m=5`, `k^5 < 10^18` implies `k < (10^18)^(1/5) = 10^(3.6) approx 3981`.\n*   If `m=60`, `k^60 < 10^18` implies `k < (10^18)^(1/60) = 10^(0.3) approx 1.99`. So `k` must be 2.\n    `2^60` is already `(2^10)^6 approx (10^3)^6 = 10^18`.\n    If `m+1 > 60` (i.e., `m > 59`), then `k` must be 1, which is not allowed.\n    So, `m` can go up to at most `59`.\n    The maximum value for `m` is `59` (for `k=2`, `2^60 - 1` is the largest possible `n`).\n    The minimum value for `m` is `3`.\n\nWe can iterate through possible values of `m` from `3` up to `59`. For each `m`, we need to find `k` such that `k^m < n < (m+1)k^m`.\nSince `n approx k^m`, we can estimate `k approx n^(1/m)`.\nWe can use binary search or `pow(n, 1/m)` to find `k`.\nLet `k_lower = floor(n^(1/m))` and `k_upper = ceil(n^(1/m)) + 2`.\nA safer range for `k` could be `[2, (int)(n**(1/m)) + 2]`.\nA more precise range for `k` can be determined:\n`k^m < n` implies `k < n^(1/m)`.\n`n < (m+1)k^m` implies `k > (n/(m+1))^(1/m)`.\nSo `k` is roughly `n^(1/m)`. Since `n` is up to `10^18`, `k` can be up to `10^6` for `m=3`.\n\nFor each `m` from `3` to `59`:\nWe need to find an integer `k > 1` such that `1 + k + ... + k^m = n`.\nThis is equivalent to finding the root of `f(k) = sum_{i=0}^{m} k^i - n = 0`.\n`f(k)` is monotonically increasing for `k > 0`. We can use binary search for `k`.\nThe search range for `k` is `[2, 10^6 + 1]` (upper bound derived from `m=3`).\nFor a fixed `m`, perform binary search for `k`:\n  `low = 2`, `high = 10^6 + 1` (or `2 * int(n**(1/m))` as a tighter upper bound).\n  While `low <= high`:\n    `mid = low + (high - low) // 2`\n    Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n    Be careful with overflow: `current_sum` can exceed `10^18`.\n    If `mid` is large, `mid^m` can overflow. We can check `mid > n**(1/m)` to avoid overflow.\n    If `mid > (n / (m+1))**(1/m) + 1` (a rough estimate for `k` to be too large), then `mid` is too big.\n    A safer way to calculate `current_sum` and check for overflow:\n    `s = 0`\n    `term = 1`\n    For `i` from `0` to `m`:\n      `s += term`\n      If `i < m` and `term > n / mid` (to prevent `term * mid` from overflowing `n` if `mid` is large) or `s > n`:\n        `s = n + 1` (indicate overflow or too large)\n        break\n      `term *= mid`\n\n    If `s == n`, we found a valid `k` and `m`. Return \"YES\".\n    If `s < n`, `k` is too small. `low = mid + 1`.\n    If `s > n`, `k` is too large. `high = mid - 1`.\n\nIf after checking all `m` and performing binary search for `k`, no solution is found, return \"NO\".\n\n**Combining the cases:**\nThe `m=2` case can be handled separately as it's an `O(1)` check.\nThe `m >= 3` case requires iterating `m` and binary searching `k`.\nThe maximum value of `k` for `m=3` is around `10^6`.\nThe maximum value of `m` is `59`.\nSo, the complexity for the `m >= 3` case is roughly `59 * log(10^6) * m` (where `m` is for sum calculation), which is `59 * 20 * 59` which is feasible.\n\n**Edge Cases:**\n*   `n=1, 2, 3`: No. Smallest snowflake `1+k+k^2` for `k=2` is `1+2+4=7`.\n    The `4n-3` check for `n=1` gives `1`, `k=(1-1)/2=0` (not valid).\n    For `n=2` gives `5` (not perfect square).\n    For `n=3` gives `9`, `k=(3-1)/2=1` (not valid as `k>1`).\n    So the `m=2` check correctly handles these small `n` values as \"NO\".\n*   `n=13`:\n    `m=2`: `4*13-3 = 52-3 = 49 = 7^2`. `k=(7-1)/2=3`. `k=3 > 1` is valid. So \"YES\".\n*   `n=15`:\n    `m=2`: `4*15-3 = 60-3 = 57` (not perfect square).\n    `m=3`: Binary search for `k`. `1+k+k^2+k^3 = 15`.\n      `k=2`: `1+2+4+8 = 15`. Found! So \"YES\".\n*   `n=255`:\n    `m=2`: `4*255-3 = 1020-3 = 1017` (not perfect square).\n    `m=3`: `1+k+k^2+k^3 = 255`.\n      `k=5`: `1+5+25+125 = 156 < 255`.\n      `k=6`: `1+6+36+216 = 259 > 255`. No integer `k` for `m=3`.\n    `m=4`: `1+k+k^2+k^3+k^4 = 255`.\n      `k=3`: `1+3+9+27+81 = 121 < 255`.\n      `k=4`: `1+4+16+64+256 = 341 > 255`. No integer `k` for `m=4`.\n    `m=7`: `1+k+...+k^7 = 255`.\n      `k=2`: `1+2+4+8+16+32+64+128 = 255`. Found! So \"YES\".\n\n**Final Algorithm:**\n1.  Read `t`.\n2.  For each test case `n`:\n    a.  **Check `m=2` case:**\n        Calculate `val = 4n - 3`.\n        Find integer square root `s = isqrt(val)`.\n        If `s*s == val` and `(s - 1) % 2 == 0`:\n            `k = (s - 1) // 2`.\n            If `k > 1`, print \"YES\" and continue to next test case.\n    b.  **Check `m >= 3` case:**\n        Set `found = False`.\n        Iterate `m` from `3` to `59`:\n            Binary search for `k` in range `[2, 10^6 + 2]`. (Upper bound `10^6+2` is safe for `m=3`, for larger `m` it's too large but doesn't hurt correctnes, just efficiency slightly).\n            `low = 2`, `high = min(int(n**(1/m)) + 2, 10**6 + 2)` (tighter upper bound for `k`).\n            While `low <= high`:\n                `mid = low + (high - low) // 2`\n                `current_sum = 0`\n                `term = 1`\n                `overflow = False`\n                For `i` from `0` to `m`:\n                    `current_sum += term`\n                    If `i < m`:\n                        If `term > n // mid` (check for `term * mid` overflow) or `current_sum > n`:\n                            `overflow = True`\n                            break\n                        `term *= mid`\n                If `overflow` or `current_sum > n`:\n                    `high = mid - 1`\n                Else if `current_sum < n`:\n                    `low = mid + 1`\n                Else (`current_sum == n`):\n                    `found = True`\n                    break (from binary search)\n            If `found`, print \"YES\" and break (from `m` loop).\n        If not `found` after checking all `m`, print \"NO\".\n\nThe `isqrt` function can be implemented using `int(sqrt(x))` or `math.isqrt` in Python 3.8+. For competitive programming, `int(x**0.5)` is usually fine for `x` up to `10^18`.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # We need 4n - 3 to be a perfect square, and k > 1.\n    \n    val = 4 * n - 3\n    s_float = math.sqrt(val)\n    s = int(s_float)\n\n    if s * s == val:\n        # s must be odd for (s-1) to be even.\n        # If s*s = 4n-3, then s*s is odd, so s must be odd.\n        # Thus (s-1) is always even.\n        k_val = (s - 1) // 2\n        if k_val > 1:\n            print(\"YES\")\n            return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to ~59 (since 2^60 - 1 is approx 10^18)\n    # For each m, binary search for k.\n    # Max k for m=3 is around 10^6 (10^6)^3 = 10^18.\n    # Max k for m=59 is 2 (2^59 is small, 2^60-1 approx 10^18).\n\n    # Upper bound for m:\n    # If k=2, n = 2^(m+1) - 1. For n <= 10^18, 2^(m+1) <= 10^18 + 1.\n    # m+1 <= log2(10^18 + 1) approx 18 * log2(10) approx 18 * 3.32 = 59.79.\n    # So m+1 can be at most 59. m can be at most 58. (If m=59, m+1=60, 2^60-1 is valid)\n    # Let's use 60 as a safe upper bound for m.\n    \n    # Max k for m=3 is (10^18)^(1/3) = 10^6.\n    # Max k for m=59 is 2.\n    # We can use a maximum k_search_bound of 10^6 + 2.\n    \n    for m in range(3, 60): # m up to 59\n        low = 2\n        # A tighter upper bound for k can be calculated as n**(1/m)\n        # We add 2 to be safe for floating point inaccuracies.\n        # Also, k cannot exceed 10^6 for m=3.\n        high = min(int(n**(1/m)) + 2, 10**6 + 2) \n\n        while low <= high:\n            k = low + (high - low) // 2\n            \n            current_sum = 0\n            term = 1\n            overflow = False\n\n            for _ in range(m + 1): # Sum from k^0 to k^m\n                current_sum += term\n                if current_sum > n: # Check for sum overflow or exceeding n\n                    overflow = True\n                    break\n                \n                # Check for term * k overflow before multiplication\n                # This ensures term * k doesn't exceed max possible value before being added to sum\n                if _ < m: # Only multiply if not the last term\n                    if term > n // k: # If term * k would exceed n, it means k is too large\n                        overflow = True\n                        break\n                    term *= k\n            \n            if overflow or current_sum > n:\n                high = k - 1\n            elif current_sum < n:\n                low = k + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # We need 4n - 3 to be a perfect square, and k > 1.\n    \n    val = 4 * n - 3\n    s_float = math.sqrt(val)\n    s = int(s_float)\n\n    if s * s == val:\n        # s must be odd for (s-1) to be even.\n        # If s*s = 4n-3, then s*s is odd, so s must be odd.\n        # Thus (s-1) is always even.\n        k_val = (s - 1) // 2\n        if k_val > 1:\n            print(\"YES\")\n            return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to ~59 (since 2^60 - 1 is approx 10^18)\n    # For each m, binary search for k.\n    # Max k for m=3 is around 10^6 (10^6)^3 = 10^18.\n    # Max k for m=59 is 2 (2^59 is small, 2^60-1 approx 10^18).\n\n    # Upper bound for m:\n    # If k=2, n = 2^(m+1) - 1. For n <= 10^18, 2^(m+1) <= 10^18 + 1.\n    # m+1 <= log2(10^18 + 1) approx 18 * log2(10) approx 18 * 3.32 = 59.79.\n    # So m+1 can be at most 59. m can be at most 58. (If m=59, m+1=60, 2^60-1 is valid)\n    # Let's use 60 as a safe upper bound for m.\n    \n    # Max k for m=3 is (10^18)^(1/3) = 10^6.\n    # Max k for m=59 is 2.\n    # We can use a maximum k_search_bound of 10^6 + 2.\n    \n    for m in range(3, 60): # m up to 59\n        low = 2\n        # A tighter upper bound for k can be calculated as n**(1/m)\n        # We add 2 to be safe for floating point inaccuracies.\n        # Also, k cannot exceed 10^6 for m=3.\n        high = min(int(n**(1/m)) + 2, 10**6 + 2) \n\n        while low <= high:\n            k = low + (high - low) // 2\n            \n            current_sum = 0\n            term = 1\n            overflow = False\n\n            for _ in range(m + 1): # Sum from k^0 to k^m\n                current_sum += term\n                if current_sum > n: # Check for sum overflow or exceeding n\n                    overflow = True\n                    break\n                \n                # Check for term * k overflow before multiplication\n                # This ensures term * k doesn't exceed max possible value before being added to sum\n                if _ < m: # Only multiply if not the last term\n                    if term > n // k: # If term * k would exceed n, it means k is too large\n                        overflow = True\n                        break\n                    term *= k\n            \n            if overflow or current_sum > n:\n                high = k - 1\n            elif current_sum < n:\n                low = k + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 4664,
        "thoughts_token_count": 847
    }
}