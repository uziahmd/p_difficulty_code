{
    "start": 1758285014.9885135,
    "end": 1758285160.4745488,
    "start-formatted": "2025-09-19 21:30 KST",
    "end-formatted": "2025-09-19 21:32 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Thinking Through the \"Beautiful String\" Problem**\n\nOkay, so I need to count these \"beautiful strings\" - strings of '0's and '1's with specific modification rules. The core of this problem seems to be understanding the modification operation and its impact on the string's final state.\n\nFirst, let's break down the rules. A \"beautiful string\" has `n` zeros, `m` ones, and after repeated modifications, reduces to a single character `g`. The modification rule, which I'll denote as `f(c1, c2)`, takes the last two characters of a string and replaces them with a single character. If `c1c2` is \"00\", the result is '1'; otherwise, it's '0'.\n\nInitially, I tried to simplify this operation using modular arithmetic, hoping for a neat formula. I considered `f(c1, c2) = (c1 + c2 + 1) % 2`, but that didn't quite capture the behavior where `f(1, 1)` should equal `0`.\n\nI quickly realized the crucial aspect: the operation only yields '1' if *both* characters are '0'.  This led me to think about logical operators, initially considering NOT OR, which, with '0' as true and '1' as false wouldn't work, then to the idea of `NOT (c1 OR c2)`. Thinking about it, it is clearer to me that: if the two characters are `0`, the result is `1`. Otherwise, the result is `0`.\n\nNow, let's consider the string reduction process itself. It's essentially a right-associative operation. If my input string is `s = s_1 s_2 ... s_k`, then the final character I obtain is `s_1 op (s_2 op (... (s_{k-1} op s_k)...))`, where `op` represents `f(c1, c2)`. This reduction is happening step by step.\n\nI need a way to efficiently calculate this value, let's call it `V(s)`, given a string. I can implement the `op` operation directly:\n\n```python\ndef op(x, y):\n  return '1' if x == '0' and y == '0' else '0'\n```\n\nAnd then use this in a loop or recursion to reduce the string and count those that meet the criteria. That seems like the right path forward to finding the \"beautiful strings\". I need to figure out an efficient way to count these, considering that I have `n` zeros, `m` ones, and the target final value.\n",
    "response": "The problem asks us to count the number of binary strings containing exactly `n` zeros and `m` ones, such that if we repeatedly apply a specific reduction rule, the string reduces to a single character `g`. The reduction rule is: replace the two last characters `c1c2` with a new character `c`. This `c` is '1' if `c1c2` is \"00\", and '0' otherwise. This operation is applied until only one character remains.\n\nLet's analyze the reduction rule. Let `op(c1, c2)` denote the result of replacing `c1c2`.\n`op(0, 0) = 1`\n`op(0, 1) = 0`\n`op(1, 0) = 0`\n`op(1, 1) = 0`\n\nThis means `op(c1, c2)` is '1' if and only if both `c1` and `c2` are '0'. In all other cases, it's '0'.\nThe reduction process is right-associative: `s_1 s_2 ... s_k` reduces to `s_1 op (s_2 op (... op (s_{k-1} op s_k)...))`.\n\nLet's trace the value `v` of the single character result.\nIf `s_k = 1`, then `s_{k-1} op s_k = s_{k-1} op 1`.\n`op(0, 1) = 0`\n`op(1, 1) = 0`\nSo, if `s_k = 1`, the last operation always results in '0'. This '0' then propagates to the left.\n`s_1 op (... op (X op 0)...)`\n`op(0, 0) = 1`\n`op(1, 0) = 0`\nSo, if `s_k = 1`, the final result `v` depends on the character `s_1` and the value `v'` obtained from `s_2 ... s_{k-1}`.\nSpecifically, if `s_k=1`, the final character is `s_1 op (s_2 op (... op 0))`.\nIf any character `s_i` from `s_2` to `s_k` is '1', then the sub-expression `s_i op (... op s_k)` will evaluate to '0' (because `s_i op 1 = 0` and `s_i op 0` is either 0 or 1). This '0' will propagate to the left.\n`s_1 op (s_2 op (... op (s_i op (... op s_k))...))`\nIf `s_i = 1`, then `s_i op A = 0` for any `A`. So `s_i op (... op s_k)` becomes `0`.\nThe expression becomes `s_1 op (s_2 op (... op 0))`.\nThis means if there is any '1' in `s_2 ... s_k`, the entire suffix `s_2 ... s_k` reduces to '0'.\nThen the final result is `s_1 op 0`.\n`op(0, 0) = 1`\n`op(1, 0) = 0`\nSo, if there is any '1' in `s_2 ... s_k`, the final result is `1` if `s_1 = 0`, and `0` if `s_1 = 1`.\n\nWhat if all characters `s_2 ... s_k` are '0'?\nThen `s_2 op (... op s_k)` is `0 op (0 op (... op (0 op 0)...))`.\n`0 op 0 = 1`.\n`0 op (0 op 0) = 0 op 1 = 0`.\n`0 op (0 op (0 op 0)) = 0 op (0 op 1) = 0 op 0 = 1`.\nIt seems that `0 op (0 op (... op 0))` (with `k-1` zeros) evaluates to `1` if `k-1` is odd, and `0` if `k-1` is even.\nSo, if `s_2 ... s_k` are all '0's:\nThe suffix `s_2 ... s_k` reduces to '1' if `k-1` is odd (i.e., `k` is even).\nThe suffix `s_2 ... s_k` reduces to '0' if `k-1` is even (i.e., `k` is odd).\nThe final result is `s_1 op (\\text{result from } s_2 ... s_k)`.\n\nLet's summarize the final character `v`:\n\nCase 1: `g = 0`\nWe need the final character to be '0'.\nCondition A: There is at least one '1' in `s_2 ... s_k`, and `s_1 = 1`.\nCondition B: All characters `s_2 ... s_k` are '0's, `k` is odd, and `s_1 = 0`. (This would yield `0 op 0 = 1`, which is not `g=0`).\nCondition C: All characters `s_2 ... s_k` are '0's, `k` is even, and `s_1 = 1`. (This would yield `1 op 0 = 0`, which is `g=0`).\nCondition D: All characters `s_2 ... s_k` are '0's, `k` is even, and `s_1 = 0`. (This would yield `0 op 0 = 1`, which is not `g=0`).\n\nLet's re-evaluate more carefully.\nLet `val(s)` be the reduced value of string `s`.\n`val(s_1 ... s_k) = s_1 op val(s_2 ... s_k)`.\n`val(0) = 0`, `val(1) = 1`.\n\nIf `s_i = 1` for some `i > 1`:\nLet `j` be the largest index such that `s_j = 1` and `j > 1`.\nThen `s_j ... s_k` consists of `s_j = 1` followed by `k-j` zeros.\n`val(s_j ... s_k) = s_j op val(s_{j+1} ... s_k) = 1 op val(0...0)`.\n`val(0...0)` (length `L`) is `1` if `L` is odd, `0` if `L` is even.\nSo `val(s_j ... s_k) = 1 op (1 \\text{ if } k-j \\text{ odd else } 0) = 1 op (\\text{val from } k-j \\text{ zeros})`.\n`1 op 1 = 0`\n`1 op 0 = 0`\nSo, if there is any '1' at index `j > 1`, then `val(s_j ... s_k)` is always '0'.\nThis means `val(s_2 ... s_k)` is '0' if there is any '1' in `s_2 ... s_k`.\nIn this case, `val(s) = s_1 op 0`.\n`s_1 op 0 = 1` if `s_1 = 0`.\n`s_1 op 0 = 0` if `s_1 = 1`.\n\nIf all `s_2 ... s_k` are '0's:\nThen `val(s_2 ... s_k)` is `1` if `k-1` is odd (i.e., `k` is even).\nThen `val(s_2 ... s_k)` is `0` if `k-1` is even (i.e., `k` is odd).\nIn this case, `val(s) = s_1 op val(s_2 ... s_k)`.\n\nLet's define `Z` as the count of zeros and `M` as the count of ones. Total length `L = Z + M`.\n\nTarget `g=0`:\n1. `s_1 = 1` and there is at least one '1' in `s_2 ... s_L`.\n   This means `s_1=1`, and `M \\ge 1`. (If `s_1=1`, then `M \\ge 1` is automatically true).\n   The number of such strings is the number of strings with `n` zeros and `m` ones where `s_1=1`.\n   This is `C(n + m - 1, n)`. (Fix `s_1=1`, remaining `n` zeros and `m-1` ones can be arranged in `C(n+(m-1), n)` ways).\n2. `s_1 = 1` and all `s_2 ... s_L` are '0's. This means `m=1` (the `s_1` is the only '1').\n   In this case, `val(s_2 ... s_L)` is `val(0...0)` (length `L-1`).\n   `val(0...0)` is `1` if `L-1` is odd (i.e., `L` is even).\n   `val(0...0)` is `0` if `L-1` is even (i.e., `L` is odd).\n   So `val(s) = 1 op val(0...0)`.\n   If `L` is even, `val(0...0)` is `1`. `1 op 1 = 0`. This matches `g=0`.\n   If `L` is odd, `val(0...0)` is `0`. `1 op 0 = 0`. This matches `g=0`.\n   So, if `m=1` and `s_1=1`, the result is always `0`. This is `C(n, n) = 1` string (`100...0`).\n   This case is already covered by point 1, `C(n+m-1, n)` for `m=1` is `C(n,n)=1`.\n\n   So, for `g=0`, if `m \\ge 1`, all strings starting with '1' yield `0`. Count is `C(n+m-1, n)`.\n   What if `s_1 = 0`?\n   Then `val(s) = 0 op val(s_2 ... s_L)`.\n   If there is at least one '1' in `s_2 ... s_L`: `val(s_2 ... s_L) = 0`.\n   Then `val(s) = 0 op 0 = 1`. This does not match `g=0`.\n   So, if `s_1=0` and `m \\ge 1`, the result is `1`.\n   This means for `g=0`, `s_1` *must* be '1' if `m \\ge 1`.\n\n   What if `s_1 = 0` and all `s_2 ... s_L` are '0's? This means `m=0`.\n   Then `val(s) = 0 op val(0...0)` (length `L-1`).\n   `val(0...0)` is `1` if `L-1` is odd (i.e., `L` is even).\n   `val(0...0)` is `0` if `L-1` is even (i.e., `L` is odd).\n   `0 op 1 = 0`. This matches `g=0` if `L` is even.\n   `0 op 0 = 1`. This does not match `g=0` if `L` is odd.\n   So, if `m=0` (all zeros string), the result is `0` if `L` is even, `1` if `L` is odd.\n   For `g=0`, we need `m=0` and `L` to be even. This corresponds to `n` being even.\n   There is only 1 such string (`00...0`).\n\nSummary for `g=0`:\n- If `m=0`: String is `00...0`. Result is `0` if `n` is even, `1` if `n` is odd.\n  So if `m=0` and `n` is even, count is 1. Otherwise 0.\n- If `m \\ge 1`:\n  - If `s_1=1`: `val(s) = 1 op val(s_2 ... s_L)`.\n    If there's any '1' in `s_2 ... s_L` (i.e., `m-1 \\ge 1` or `m \\ge 2`), then `val(s_2 ... s_L) = 0`. `1 op 0 = 0`. This matches `g=0`.\n    If there are no '1's in `s_2 ... s_L` (i.e., `m-1 = 0` or `m=1`), then `s_2 ... s_L` are all zeros.\n    `val(s_2 ... s_L)` is `1` if `L-1` is odd (`L` even), `0` if `L-1` is even (`L` odd).\n    `1 op 1 = 0`. `1 op 0 = 0`. In both cases, `val(s)=0`. This matches `g=0`.\n    So, if `s_1=1`, the result is always `0` (when `m \\ge 1`).\n    Number of such strings: `C(n+m-1, n)`.\n  - If `s_1=0`: `val(s) = 0 op val(s_2 ... s_L)`.\n    Since `s_1=0`, all `m` ones must be in `s_2 ... s_L`. So there is at least one '1' in `s_2 ... s_L` (because `m \\ge 1`).\n    Thus `val(s_2 ... s_L) = 0`.\n    Then `val(s) = 0 op 0 = 1`. This does not match `g=0`.\n    So, if `s_1=0`, the result is `1`.\n  Conclusion for `g=0, m \\ge 1`: The count is `C(n+m-1, n)`.\n\nFinal summary for `g=0`:\n- If `m=0`: `1` if `n` is even, `0` if `n` is odd.\n- If `m \\ge 1`: `C(n+m-1, n)`.\n\nTarget `g=1`:\n1. `s_1 = 0` and there is at least one '1' in `s_2 ... s_L`.\n   This means `s_1=0`, and `m \\ge 1`.\n   `val(s_2 ... s_L) = 0`.\n   `val(s) = 0 op 0 = 1`. This matches `g=1`.\n   Number of such strings: `C(n+m-1, m)`. (Fix `s_1=0`, remaining `n-1` zeros and `m` ones).\n2. `s_1 = 0` and all `s_2 ... s_L` are '0's. This means `m=0`.\n   `val(s) = 0 op val(0...0)` (length `L-1`).\n   `val(0...0)` is `1` if `L-1` is odd (`L` even).\n   `val(0...0)` is `0` if `L-1` is even (`L` odd).\n   `0 op 1 = 0`. This does not match `g=1`.\n   `0 op 0 = 1`. This matches `g=1` if `L` is odd.\n   So if `m=0` and `L` is odd (i.e., `n` is odd), count is 1.\n3. `s_1 = 1` and there is at least one '1' in `s_2 ... s_L`.\n   `val(s_2 ... s_L) = 0`.\n   `val(s) = 1 op 0 = 0`. This does not match `g=1`.\n4. `s_1 = 1` and all `s_2 ... s_L` are '0's. This means `m=1`.\n   `val(s) = 1 op val(0...0)` (length `L-1`).\n   `1 op 1 = 0`. `1 op 0 = 0`. In both cases, `val(s)=0`. This does not match `g=1`.\n\nSummary for `g=1`:\n- If `m=0`: `1` if `n` is odd, `0` if `n` is even.\n- If `m \\ge 1`: `C(n+m-1, m)`.\n\nNote that `C(N, K) = C(N, N-K)`. So `C(n+m-1, n) = C(n+m-1, m-1)`.\nAnd `C(n+m-1, m) = C(n+m-1, n-1)`.\n\nEdge cases:\n`n=0, m=0`: Problem states `n+m \\ge 1`.\n`n=1, m=0, g=0`: `m=0`, `n=1` (odd). Count is 0. Correct.\n`n=1, m=0, g=1`: `m=0`, `n=1` (odd). Count is 1 (`0`). Correct.\n`n=0, m=1, g=0`: `m=1 \\ge 1`. `C(0+1-1, 0) = C(0,0) = 1`. String is `1`. `val(1)=1`. This is wrong.\nMy analysis for `m \\ge 1` implicitly assumed `L \\ge 2` for `s_2 ... s_L` to be meaningful.\nIf `L=1`, the string is either \"0\" or \"1\".\n`val(\"0\") = 0`. `val(\"1\") = 1`.\n\nSpecial handling for `L=1` (i.e., `n=1, m=0` or `n=0, m=1`):\n- If `n=1, m=0`: String is \"0\".\n  - If `g=0`: Count is 1.\n  - If `g=1`: Count is 0.\n- If `n=0, m=1`: String is \"1\".\n  - If `g=0`: Count is 0.\n  - If `g=1`: Count is 1.\n\nLet's refine the general formulas for `L \\ge 2`:\n\n`g=0`:\n- If `m=0`: `1` if `n` is even, `0` if `n` is odd.\n  (This is for `n \\ge 2` and even).\n- If `m \\ge 1`: `C(n+m-1, n)`.\n  (This is for `n+m \\ge 2`).\n\n`g=1`:\n- If `m=0`: `1` if `n` is odd, `0` if `n` is even.\n  (This is for `n \\ge 2` and odd).\n- If `m \\ge 1`: `C(n+m-1, m)`.\n  (This is for `n+m \\ge 2`).\n\nLet's test example cases:\n1. `n=1, m=1, g=0`:\n   `L=2`. `m=1 \\ge 1`. Use `C(n+m-1, n) = C(1+1-1, 1) = C(1,1) = 1`.\n   Strings are \"01\", \"10\".\n   `val(\"01\") = 0 op 1 = 0`. Matches `g=0`.\n   `val(\"10\") = 1 op 0 = 0`. Matches `g=0`.\n   Total should be 2. My formula gives 1. What went wrong?\n\nThe assumption `val(s_2 ... s_L) = 0` if there is any '1' in `s_2 ... s_L` is correct.\nThe assumption `val(s_2 ... s_L)` depends on parity of `L-1` if all are '0's is also correct.\n\nLet's re-examine `n=1, m=1, g=0`.\nStrings are \"01\", \"10\".\n`s=\"01\"`: `s_1=0, s_2=1`. `m=1`. `s_1=0`. `s_2` contains '1'. `val(\"01\") = 0 op val(\"1\") = 0 op 1 = 0`. Matches `g=0`.\n`s=\"10\"`: `s_1=1, s_2=0`. `m=1`. `s_1=1`. `s_2` contains no '1's. `val(\"10\") = 1 op val(\"0\") = 1 op 0 = 0`. Matches `g=0`.\nBoth strings yield `0`. So the answer is 2.\n\nMy formulas:\n`g=0, m \\ge 1`: `C(n+m-1, n)`. This counts strings starting with '1'.\n`g=1, m \\ge 1`: `C(n+m-1, m)`. This counts strings starting with '0'.\n\nThe issue is that the behavior of `s_1=0` depends on `val(s_2 ... s_L)` and the behavior of `s_1=1` depends on `val(s_2 ... s_L)`.\nLet `V_suffix = val(s_2 ... s_L)`.\nIf `s_1 = 0`, final result is `0 op V_suffix`. This is `1` if `V_suffix=0`, `0` if `V_suffix=1`.\nIf `s_1 = 1`, final result is `1 op V_suffix`. This is `0` if `V_suffix=0`, `0` if `V_suffix=1`.\n\nThis means if `s_1 = 1`, the result is *always* `0`.\nIf `s_1 = 0`, the result is `1` if `V_suffix=0`, `0` if `V_suffix=1`.\n\nLet's count:\nStrings starting with '1':\n  `s_1=1`. Remaining `n` zeros and `m-1` ones. Total `n+m-1` characters.\n  The final result is always `0`.\n  Number of such strings: `C(n+m-1, n)`. (Requires `m \\ge 1`).\n\nStrings starting with '0':\n  `s_1=0`. Remaining `n-1` zeros and `m` ones. Total `n+m-1` characters.\n  The final result is `1` if `V_suffix=0`, `0` if `V_suffix=1`.\n  `V_suffix=0` if there is any '1' in `s_2 ... s_L` (i.e., `m \\ge 1`).\n  `V_suffix=0` if all `s_2 ... s_L` are '0's (`m=0`) and `L-1` is even (i.e., `L` is odd).\n  `V_suffix=1` if all `s_2 ... s_L` are '0's (`m=0`) and `L-1` is odd (i.e., `L` is even).\n\nLet `N_0` be the number of strings starting with '0'.\nLet `N_1` be the number of strings starting with '1'.\n`N_0 = C(n+m-1, m)` (if `n \\ge 1`).\n`N_1 = C(n+m-1, n)` (if `m \\ge 1`).\n\nCase `g=0`:\n  Strings starting with '1' (if `m \\ge 1`) always yield `0`. Count `N_1`.\n  Strings starting with '0' (if `n \\ge 1`):\n    Yield `0` if `V_suffix=1`.\n    `V_suffix=1` only if `m=0` AND `L-1` is odd (i.e., `L` is even).\n    But if `s_1=0` and `m=0`, then all characters are `0`. This is the `00...0` string.\n    So, if `m=0` and `n` is even (`L` is even), `V_suffix` (from `n-1` zeros) is `0` if `n-1` is even (n odd), `1` if `n-1` is odd (n even).\n    So if `m=0` and `n` is even, `V_suffix` (from `n-1` zeros) is `1`.\n    Then `s_1=0` and `V_suffix=1` gives `0 op 1 = 0`.\n    This means if `m=0` and `n` is even, the string `00...0` (1 string) yields `0`.\n\n  Total for `g=0`:\n  - If `m=0`: `1` if `n` is even, `0` if `n` is odd. (This covers `n=0` too: `m=0, n=0` not allowed. `n=1, m=0` gives `0`. `n=2, m=0` gives `1`.)\n  - If `m \\ge 1`:\n    Strings starting with '1' yield `0`. Count `N_1 = C(n+m-1, n)`.\n    Strings starting with '0' yield `1` (because `m \\ge 1` means `V_suffix=0`, so `0 op 0 = 1`).\n    So for `g=0, m \\ge 1`, the answer is `C(n+m-1, n)`.\n\nCase `g=1`:\n  Strings starting with '1' (if `m \\ge 1`) always yield `0`. So they don't contribute to `g=1`.\n  Strings starting with '0' (if `n \\ge 1`):\n    Yield `1` if `V_suffix=0`.\n    `V_suffix=0` if there is any '1' in `s_2 ... s_L` (i.e., `m \\ge 1`).\n    `V_suffix=0` if all `s_2 ... s_L` are '0's (`m=0`) and `L-1` is even (i.e., `L` is odd).\n    So if `m \\ge 1` and `n \\ge 1`, strings starting with '0' yield `1`. Count `N_0 = C(n+m-1, m)`.\n    If `m=0` and `n` is odd (`L` is odd), string `00...0` yields `1`. Count 1.\n\n  Total for `g=1`:\n  - If `m=0`: `1` if `n` is odd, `0` if `n` is even.\n  - If `m \\ge 1`: `C(n+m-1, m)`.\n\nThis looks consistent with my previous derived formulas.\nLet's re-check `n=1, m=1, g=0`.\n`L=2`. `m=1 \\ge 1`. Formula: `C(1+1-1, 1) = C(1,1) = 1`. Still 1. But example output is 2.\nWhat is wrong?\nMy analysis `if s_1 = 1, the result is always 0` is correct.\nMy analysis `if s_1 = 0, the result is 1 if V_suffix=0, 0 if V_suffix=1` is correct.\nFor `n=1, m=1`:\n`s=\"01\"`: `s_1=0`. `V_suffix = val(\"1\") = 1`. Result `0 op 1 = 0`. Correct.\n`s=\"10\"`: `s_1=1`. `V_suffix = val(\"0\") = 0`. Result `1 op 0 = 0`. Correct.\nBoth yield 0. The count is 2.\n\nMy formulas count `C(n+m-1, n)` for strings starting with '1', and `C(n+m-1, m)` for strings starting with '0'. These are disjoint sets.\nFor `g=0`:\n  Strings starting with '1' always yield `0`. So add `C(n+m-1, n)`. (Requires `m \\ge 1`).\n  Strings starting with '0' yield `0` only if `V_suffix=1`.\n  When does `V_suffix=1` happen?\n  `V_suffix=1` iff (`m=0` AND `L-1` is odd (i.e., `n-1` is odd, `n` is even))\n  OR (`m \\ge 1` AND `V_suffix` is not 0). This means `val(s_2...s_L)` is not 0.\n  But `val(s_2...s_L)` is 0 if there is any '1' in `s_2...s_L` (i.e. `m \\ge 1`).\n  So if `m \\ge 1`, `V_suffix` from `s_2...s_L` is always `0`.\n  Therefore, if `m \\ge 1`, strings starting with '0' always yield `1` (`0 op 0 = 1`).\n  This means for `g=0, m \\ge 1`: only strings starting with '1' contribute. Count `C(n+m-1, n)`.\n  This is the source of the discrepancy.\n\nThe error is in the base case for `val(s_2...s_L)`.\n`val(s_2...s_L)` is computed for a string of length `L-1`.\nIf `L-1=0`, then `s_2...s_L` is empty. This happens if `L=1`.\nIf `L=1`, then `n=1, m=0` or `n=0, m=1`. These are base cases `val(\"0\")=0, val(\"1\")=1`.\nMy general formulas are for `L \\ge 2`.\n\nLet's re-state the conditions for `V_suffix = val(s_2...s_L)` where `s_2...s_L` has `n'` zeros and `m'` ones. (`n'=n` or `n-1`, `m'=m` or `m-1`).\nLength of suffix is `L' = n'+m' = L-1`.\nIf `m' \\ge 1`: `V_suffix = 0`. (This is because if `s_j=1` for `j > 1`, `1 op X = 0`).\nIf `m'=0`: `V_suffix = 1` if `n'` is odd, `0` if `n'` is even. (This is `val(0...0)`).\n\nLet's use this for `n=1, m=1, g=0`. `L=2`.\n1. String `01`: `s_1=0`. Suffix is \"1\". `n'=0, m'=1`. `m' \\ge 1` so `V_suffix=0`.\n   Result `0 op 0 = 1`. This does not match `g=0`.\n   My previous `val(\"1\")=1` was correct. `0 op 1 = 0`.\n   The `V_suffix=0` if `m' \\ge 1` rule is incorrect for `L'=1`.\n   If `L'=1`, `val(\"0\")=0`, `val(\"1\")=1`.\n\nCorrect `V_suffix` rules for `s_2...s_L` (length `L-1`):\nLet `n_s` be count of zeros in suffix, `m_s` be count of ones in suffix.\n- If `m_s = 0`: (all zeros suffix)\n  `V_suffix = 0` if `n_s` is even.\n  `V_suffix = 1` if `n_s` is odd.\n- If `m_s = 1`: (one '1' in suffix)\n  If suffix is `1`: `V_suffix = 1`.\n  If suffix is `0...01`: `V_suffix = 0 op (... op (0 op 1)...) = 0 op 0 = 1` if `n_s` is even, `0 op 1 = 0` if `n_s` is odd.\n  This is incorrect. If the suffix contains `1`, say `X1Y` where `Y` are all zeros.\n  `val(X1Y) = val(X) op val(1Y)`.\n  `val(1Y) = 1 op val(Y)`. `val(Y)` is from all zeros.\n  If `Y` has length `k_Y`: `val(Y)=1` if `k_Y` odd, `0` if `k_Y` even.\n  So `val(1Y)` is `1 op 1 = 0` if `k_Y` odd, `1 op 0 = 0` if `k_Y` even.\n  This means `val(1Y)` is always `0`.\n  So `val(X1Y) = val(X) op 0`.\n  `val(X) op 0 = 1` if `val(X)=0`.\n  `val(X) op 0 = 0` if `val(X)=1`.\n  This is `NOT val(X)`.\n\nThis is a key insight! If a string contains at least one '1', let `s_j` be the rightmost '1'.\nThen `s_j s_{j+1} ... s_k` is `1` followed by some zeros.\n`val(1 0...0)` (length `1+N_0`) where `N_0` is number of zeros after the '1'.\n`val(1 0...0) = 1 op val(0...0)`.\n`val(0...0)` is `1` if `N_0` is odd, `0` if `N_0` is even.\nSo `val(1 0...0)` is `1 op 1 = 0` if `N_0` is odd.\nSo `val(1 0...0)` is `1 op 0 = 0` if `N_0` is even.\nThis means `val(1 0...0)` is always `0`.\n\nSo, if `s_j` is the rightmost '1', and `j < L`, then `val(s_j ... s_L)` is `0`.\nThis means `val(s_i ... s_L)` for any `i \\le j` is `val(s_i ... s_{j-1}) op 0`.\nThis implies `val(s_i ... s_L)` is `1` if `val(s_i ... s_{j-1})=0`.\nThis implies `val(s_i ... s_L)` is `0` if `val(s_i ... s_{j-1})=1`.\nSo `val(s_i ... s_L) = NOT val(s_i ... s_{j-1})`.\n\nThis is for `j < L`. What if `j=L`? The rightmost '1' is `s_L`.\nThen `val(s_L) = 1`.\n`val(s_{L-1} s_L) = s_{L-1} op 1`. This is `0` for both `s_{L-1}=0` and `s_{L-1}=1`.\nThis means if `s_L=1`, then `val(s_{L-1} s_L)` is `0`.\nThis means `val(s_i ... s_L)` is `val(s_i ... s_{L-2}) op 0`.\nSo `val(s_i ... s_L) = NOT val(s_i ... s_{L-2})`.\n\nWhat does this mean?\nIf `m \\ge 1` (string contains at least one '1'):\n  If `s_L=1`: `val(s) = NOT val(s_1 ... s_{L-2})`.\n  If `s_L=0` (and `m \\ge 1`): Let `s_j` be the rightmost '1'. `j < L`.\n    `val(s) = NOT val(s_1 ... s_{j-1})`.\nThis means the final result `g` is `NOT` of the value of the prefix ending just before the rightmost '1' (if `s_L=0`) or before `s_{L-1}` (if `s_L=1`).\n\nThis is getting complicated. Let's simplify.\nThe operation `op(x,y)` is `1` iff `x=0, y=0`.\nThis is equivalent to `NOT(x OR y)` if `0=False, 1=True`.\n`op(x,y) = (1-x)(1-y)` if `0,1` are numbers.\nLet `S_k = s_1 op (s_2 op (... op s_k)...)`.\n`S_k = (1-s_1)(1-S_{k-1})`.\n`S_1 = s_1`. (This is the value of a single character string).\n`S_2 = (1-s_1)(1-s_2)`.\n`S_3 = (1-s_1)(1-S_2) = (1-s_1)(1-(1-s_2)(1-s_3))`.\nThis is an alternating behavior.\nIf `s_i=1` for any `i`, then `1-s_i=0`.\nIf `s_k=1`, then `S_k = (1-s_1)(1-S_{k-1})`.\n`S_k = (1-s_1)(1-(1-s_2)(1-S_{k-2})) = ...`\nLet's consider the number of '1's in the string.\nIf `m=0`: String is `00...0` (`n` zeros).\n`S_1 = 0`.\n`S_2 = (1-0)(1-0) = 1`.\n`S_3 = (1-0)(1-1) = 0`.\n`S_4 = (1-0)(1-0) = 1`.\nSo for `00...0` (length `n`), `S_n = 1` if `n` is even, `0` if `n` is odd.\n\nIf `m \\ge 1`: String has at least one '1'.\nLet `j` be the index of the last '1'. `s_j=1`.\nThen `s_{j+1}, ..., s_n` are all '0's.\n`S_j = (1-s_1)(1-S_{j-1})`.\n`S_{j+1} = (1-s_1)(1-S_j)`.\n`S_{j+2} = (1-s_1)(1-S_{j+1})`.\nThis is wrong. The formula `S_k = (1-s_1)(1-S_{k-1})` is not for `S_k = s_1 op (s_2 op ... op s_k)`.\nIt's `S_k = s_1 op S_{2...k}` where `S_{2...k} = s_2 op (s_3 op ... op s_k)`.\nLet `f(s)` be the final value.\n`f(s_1 ... s_k) = (1-s_1) * (1-f(s_2 ... s_k))` if we interpret `0,1` as numbers and `op` as multiplication.\n`op(x,y) = (1-x)(1-y)`.\n`f(s_1) = s_1`.\n`f(s_1 s_2) = (1-s_1)(1-s_2)`.\n`f(s_1 s_2 s_3) = (1-s_1)(1-f(s_2 s_3)) = (1-s_1)(1-(1-s_2)(1-s_3))`.\n\nLet `X_i = 1-s_i`.\n`f(s_1 ... s_k) = X_1 (1 - X_2 (1 - X_3 (... (1 - X_k)...)))`.\nThis expression is `1` iff `X_1=1` and `1-X_2(...)=1` => `X_2(...)=0`.\nAnd `0` otherwise.\n\nIf `m \\ge 1`, there is at least one `s_i=1`, so at least one `X_i=0`.\nIf `X_1 = 0` (i.e., `s_1 = 1`), then `f(s_1 ... s_k) = 0`.\nSo all strings starting with '1' always reduce to `0`.\nNumber of such strings: `C(n+m-1, n)` (if `m \\ge 1`).\n\nIf `X_1 = 1` (i.e., `s_1 = 0`), then `f(s_1 ... s_k) = 1 - X_2 (1 - X_3 (... (1 - X_k)...))`.\nSo `f(s_1 ... s_k) = 1 - f(s_2 ... s_k)`.\nThis means `f(0 S) = 1 - f(S)`.\nAnd `f(1 S) = 0`.\n\nThis is much cleaner!\nLet `f(s)` be the final value of string `s`.\n`f(0) = 0`. `f(1) = 1`.\n`f(0s') = 1 - f(s')`.\n`f(1s') = 0`.\n\nSo, for `g=0`:\n1. Strings starting with `1`: `f(1s') = 0`. This is always `0`.\n   Number of such strings: `C(n+m-1, n)` (if `m \\ge 1`).\n   This includes the case `n=0, m=1` (string \"1\"), where `C(0,0)=1` and `f(\"1\")=1`. This is wrong.\n   The formulas for `C(N,K)` assume `N, K \\ge 0`.\n   `C(n+m-1, n)` is for `m \\ge 1`. If `m=1, n=0`, then `C(0,0)=1`. String is \"1\". `f(\"1\")=1`. This yields `1`, not `0`.\n   So the rule `f(1s')=0` applies only if `s'` is non-empty.\n   If `s'` is empty, `f(1)` is `1`.\n\nLet's handle `L=1` separately:\n- `n=1, m=0`: String \"0\". `f(\"0\")=0`. So for `g=0` count is 1, for `g=1` count is 0.\n- `n=0, m=1`: String \"1\". `f(\"1\")=1`. So for `g=0` count is 0, for `g=1` count is 1.\n\nNow consider `L \\ge 2`:\nFor `g=0`:\n  1. Strings starting with `1` (i.e., `s_1=1`):\n     `f(1s') = 0`. This always yields `0`.\n     Number of such strings: `C(n+m-1, n)`. (Requires `m \\ge 1`).\n  2. Strings starting with `0` (i.e., `s_1=0`):\n     `f(0s') = 1 - f(s')`. We need this to be `0`, so `f(s')=1`.\n     `s'` has `n-1` zeros and `m` ones.\n     When does `f(s')=1`?\n     a. `s'` starts with `0`: `f(0s'') = 1 - f(s'')`. We need `1-f(s'')=1`, so `f(s'')=0`.\n     b. `s'` starts with `1`: `f(1s'') = 0`. We need `0=1`, impossible.\n     So if `s'` starts with `1`, then `f(s')=0`. Thus `f(0s')=1`.\n     So, strings `01...` yield `1`.\n     This means strings starting with `0` that yield `0` must be of the form `00...`.\n     This implies `f(s')=1`. `s'` must be `0s''` and `f(s'')=0`.\n     This means `f(s) = 0` iff `s_1=1` OR (`s_1=0` AND `f(s')=1`).\n     `f(s) = 1` iff `s_1=0` AND `f(s')=0`.\n\nLet's define `count(n, m, g)` as the number of beautiful strings.\n`count(n, m, g)`:\nIf `L=1`:\n  If `n=1, m=0`: `g=0` -> 1, `g=1` -> 0.\n  If `n=0, m=1`: `g=0` -> 0, `g=1` -> 1.\nIf `L \\ge 2`:\n  `ans = 0`.\n  Strings starting with `1`: `s_1=1`. `n` zeros, `m-1` ones for `s'`.\n    These always yield `0`.\n    If `g=0`: Add `C(n+m-1, n)`. (Requires `m \\ge 1`).\n  Strings starting with `0`: `s_1=0`. `n-1` zeros, `m` ones for `s'`.\n    These yield `1 - f(s')`.\n    If `g=0`: We need `1 - f(s') = 0`, so `f(s') = 1`.\n      This means we need to count strings `s'` with `n-1` zeros and `m` ones that yield `1`.\n      Add `count(n-1, m, 1)`. (Requires `n \\ge 1`).\n    If `g=1`: We need `1 - f(s') = 1`, so `f(s') = 0`.\n      This means we need to count strings `s'` with `n-1` zeros and `m` ones that yield `0`.\n      Add `count(n-1, m, 0)`. (Requires `n \\ge 1`).\n\nThis is a recursive definition. We need to find base cases for the recursion.\nThe recursion goes `(n, m, g)` -> `(n-1, m, 1-g)` or `(n, m-1, g)`.\nThe base cases are `L=1` strings.\n`count(n, m, g)`:\n  If `n+m == 0`: return 0 (not allowed by problem statement `n+m \\ge 1`).\n  If `n+m == 1`:\n    If `n=1, m=0`: return `1` if `g=0`, `0` if `g=1`.\n    If `n=0, m=1`: return `1` if `g=1`, `0` if `g=0`.\n  Memoization needed for `(n,m,g)`.\n\nLet `dp[n][m][g]` be the answer.\n`MOD = 1000000007`.\n\n`C(N, K)` function. Precompute factorials and inverse factorials.\n`N_max = 10^5`. `N+M` can be `2 * 10^5`.\n\n```python\nMOD = 1000000007\nMAX_NM = 200005 # Max n+m-1, so max N for C(N,K) is 2e5\n\nfact = [1] * MAX_NM\ninv_fact = [1] * MAX_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    inv_fact[MAX_NM - 1] = pow(fact[MAX_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\nmemo = {}\n\ndef solve(n, m, g):\n    if (n, m, g) in memo:\n        return memo[(n, m, g)]\n\n    # Base cases for L=1\n    if n == 0 and m == 1: # String \"1\"\n        result = 1 if g == 1 else 0\n        memo[(n, m, g)] = result\n        return result\n    if n == 1 and m == 0: # String \"0\"\n        result = 1 if g == 0 else 0\n        memo[(n, m, g)] = result\n        return result\n    \n    # If n+m < 1, not possible (problem says n+m >= 1)\n    # If n < 0 or m < 0, invalid state\n    if n < 0 or m < 0:\n        return 0\n\n    ans = 0\n\n    # Case 1: String starts with '1' (s_1 = 1)\n    # Requires m >= 1\n    if m >= 1:\n        # Remaining: n zeros, m-1 ones. Length n+m-1.\n        # f(1s') = 0.\n        if g == 0:\n            ans = (ans + nCr_mod_p(n + (m - 1), n)) % MOD\n\n    # Case 2: String starts with '0' (s_1 = 0)\n    # Requires n >= 1\n    if n >= 1:\n        # Remaining: n-1 zeros, m ones. Length n+m-1.\n        # f(0s') = 1 - f(s').\n        # If we need f(0s') = g, then we need 1 - f(s') = g.\n        # So we need f(s') = 1 - g.\n        ans = (ans + solve(n - 1, m, 1 - g)) % MOD\n    \n    memo[(n, m, g)] = ans\n    return ans\n\n# Read input\nn, m, g = map(int, input().split())\n\n# Handle the case n=0, m=0 explicitly, as n+m >= 1 constraint.\n# If n=0, m=0, the code would call solve(0,0,g) then solve(-1,0,1-g)\n# or nCr_mod_p(-1,0). This is not correct. But n+m >= 1, so this is not an issue.\n\nprint(solve(n, m, g))\n\n```\n\nLet's trace `n=1, m=1, g=0` with the recursive solution:\n`solve(1, 1, 0)`:\n  `L=2`.\n  `ans = 0`.\n  `m=1 >= 1`:\n    `g=0`. `ans = (0 + nCr(1+0, 1)) % MOD = nCr(1,1) = 1`.\n  `n=1 >= 1`:\n    `ans = (1 + solve(0, 1, 1-0)) % MOD = (1 + solve(0, 1, 1)) % MOD`.\n  `solve(0, 1, 1)`:\n    `L=1`. `n=0, m=1`. `g=1`.\n    `result = 1`.\n    `memo[(0,1,1)] = 1`.\n  Back to `solve(1,1,0)`:\n    `ans = (1 + 1) % MOD = 2`.\n  `memo[(1,1,0)] = 2`.\n  Return 2. This matches example 1.\n\nLet's trace `n=2, m=2, g=0`:\n`solve(2, 2, 0)`:\n  `L=4`.\n  `ans = 0`.\n  `m=2 >= 1`:\n    `g=0`. `ans = (0 + nCr(2+1, 2)) % MOD = nCr(3,2) = 3`.\n  `n=2 >= 1`:\n    `ans = (3 + solve(1, 2, 1)) % MOD`.\n  `solve(1, 2, 1)`:\n    `L=3`.\n    `ans = 0`.\n    `m=2 >= 1`:\n      `g=1`. Not added.\n    `n=1 >= 1`:\n      `ans = (0 + solve(0, 2, 0)) % MOD`.\n    `solve(0, 2, 0)`:\n      `L=2`.\n      `ans = 0`.\n      `m=2 >= 1`:\n        `g=0`. `ans = (0 + nCr(0+1, 0)) % MOD = nCr(1,0) = 1`.\n      `n=0`. Not added.\n      `memo[(0,2,0)] = 1`.\n      Return 1.\n    Back to `solve(1,2,1)`:\n      `ans = (0 + 1) % MOD = 1`.\n    `memo[(1,2,1)] = 1`.\n    Return 1.\n  Back to `solve(2,2,0)`:\n    `ans = (3 + 1) % MOD = 4`.\n  `memo[(2,2,0)] = 4`.\n  Return 4. This matches example 2.\n\nLet's trace `n=1, m=1, g=1`:\n`solve(1, 1, 1)`:\n  `L=2`.\n  `ans = 0`.\n  `m=1 >= 1`:\n    `g=1`. Not added.\n  `n=1 >= 1`:\n    `ans = (0 + solve(0, 1, 0)) % MOD`.\n  `solve(0, 1, 0)`:\n    `L=1`. `n=0, m=1`. `g=0`.\n    `result = 0`.\n    `memo[(0,1,0)] = 0`.\n  Back to `solve(1,1,1)`:\n    `ans = (0 + 0) % MOD = 0`.\n  `memo[(1,1,1)] = 0`.\n  Return 0. This matches example 3.\n\nThe recursive solution seems correct. The maximum values of `n` and `m` are `10^5`.\nThe state space for `(n, m, g)` is `(10^5+1) * (10^5+1) * 2`. This is too large for memoization.\n`n+m` goes from `1` to `2*10^5`.\nThe recursion only reduces `n` or `m`. Specifically, `n` becomes `n-1` or `m` becomes `m-1`.\nThe sum `n+m` reduces by `1` in each step.\nThe depth of recursion is `n+m`.\nThe actual states visited are `(n,m,g), (n-1,m,1-g), (n-2,m,g), ..., (0,m,g_final)` or `(n,m-1,g), (n,m-2,g), ..., (n,0,g_final)`.\nThe states are `(i, j, k)` where `i \\le n`, `j \\le m`.\nThis is still `O(N*M)` states, which is too much.\n\nWait, `nCr_mod_p(n + (m - 1), n)` is `C(N, K)`. `N` is `n+m-1`, `K` is `n`.\nThe number of '1's in the string is `m`.\nIf `s_1 = 1`, it consumes one '1'. The remaining string has `n` zeros and `m-1` ones.\nThe number of ways to arrange these is `C(n + (m-1), n)`. This is correct.\n\nThe problem is the state space of `(n, m, g)`.\nNotice that `solve(n, m, g)` calls `solve(n, m-1, g)` and `solve(n-1, m, 1-g)`.\nThe `g` parameter flips.\nLet `A(n,m) = solve(n,m,0)` and `B(n,m) = solve(n,m,1)`.\nFor `L \\ge 2`:\n`A(n,m) = (C(n+m-1, n) if m>=1 else 0) + (B(n-1,m) if n>=1 else 0)`\n`B(n,m) = (0 if m>=1 else 0) + (A(n-1,m) if n>=1 else 0)`\nThis simplifies:\n`A(n,m) = (C(n+m-1, n) if m>=1 else 0) + A(n-1,m)`.\n`B(n,m) = A(n-1,m)`.\n\nThis is for `L \\ge 2`.\nLet's check `B(n,m) = A(n-1,m)`.\nIf `n=1, m=1`:\n`A(1,1) = C(1,1) + B(0,1) = 1 + B(0,1)`.\n`B(1,1) = A(0,1)`.\nBase cases:\n`A(0,1) = 0` (string \"1\" -> 1).\n`B(0,1) = 1` (string \"1\" -> 1).\n`A(1,0) = 1` (string \"0\" -> 0).\n`B(1,0) = 0` (string \"0\" -> 0).\n\nSo:\n`A(1,1) = 1 + B(0,1) = 1 + 1 = 2`. Correct.\n`B(1,1) = A(0,1) = 0`. Correct.\n\nNow for `n=2, m=2`:\n`A(2,2) = C(3,2) + B(1,2) = 3 + B(1,2)`.\n`B(2,2) = A(1,2)`.\n\n`A(1,2) = C(1+2-1, 1) + B(0,2) = C(2,1) + B(0,2) = 2 + B(0,2)`.\n`B(1,2) = A(0,2)`.\n\n`A(0,2) = C(0+2-1, 0) + 0 = C(1,0) = 1`.\n`B(0,2) = 0`. (since `n=0`, `n-1` is not valid for `A(n-1,m)` term. `B(0,2)` is 0 because `n=0` so `s_1` must be '1'. `f(1s')=0`. So `g=1` is impossible.)\nWait, `B(n,m)` definition:\n`B(n,m) = (0 if m>=1 else 0) + (A(n-1,m) if n>=1 else 0)`\nThe `(0 if m>=1 else 0)` part is for strings starting with '1'. This means `f(1s')=0`. So they contribute `0` to `g=1`.\nThe `(A(n-1,m) if n>=1 else 0)` part is for strings starting with '0'. This means `f(0s')=1-f(s')`. We need `1-f(s')=1`, so `f(s')=0`. This is `A(n-1,m)`.\nSo `B(n,m) = A(n-1,m)` is correct for `n \\ge 1`.\nIf `n=0`: `B(0,m) = 0`. (String must start with '1', `f(1s')=0`, so `g=1` is impossible).\n\nLet's re-evaluate `A(0,2)` and `B(0,2)`:\n`A(0,2)`: `n=0, m=2, g=0`. String starts with '1'. `C(0+2-1, 0) = C(1,0) = 1`.\n`B(0,2)`: `n=0, m=2, g=1`. String starts with '1'. `f(1s')=0`. So `g=1` impossible. Result 0.\n\nSo:\n`A(0,2) = 1`.\n`B(0,2) = 0`.\n\nBack to `A(1,2)` and `B(1,2)`:\n`A(1,2) = C(2,1) + B(0,2) = 2 + 0 = 2`.\n`B(1,2) = A(0,2) = 1`.\n\nBack to `A(2,2)` and `B(2,2)`:\n`A(2,2) = C(3,2) + B(1,2) = 3 + 1 = 4`. Correct.\n`B(2,2) = A(1,2) = 2`.\n\nThis system of equations `A(n,m)` and `B(n,m)` reduces the state space to `O(N*M)` or `O(N+M)` states depending on how many `n` and `m` are reduced.\nThe `n` parameter reduces, `m` does not.\n`A(n,m) = C(n+m-1, n) + B(n-1,m)`\n`B(n,m) = A(n-1,m)`\nSubstitute `B`:\n`A(n,m) = C(n+m-1, n) + A(n-1,m)` for `n \\ge 1, m \\ge 1`.\nBase cases:\n`A(0,m) = C(m-1, 0) = 1` for `m \\ge 1` (string \"1...1\").\n`B(0,m) = 0` for `m \\ge 1`.\n`A(n,0)`: `C(n-1, n)` is 0. So `A(n,0) = B(n-1,0)`.\n`B(n,0) = A(n-1,0)`.\nThis means `A(n,0) = A(n-2,0)`.\n`A(n,0)` for string `0...0`: `1` if `n` is even, `0` if `n` is odd.\n`B(n,0)` for string `0...0`: `0` if `n` is even, `1` if `n` is odd.\n\nThis means we only need `A(n,m)` and `B(n,m)` for `m=0` and `m \\ge 1`.\nFor `m=0`:\n`A(n,0) = 1` if `n` even, `0` if `n` odd.\n`B(n,0) = 0` if `n` even, `1` if `n` odd.\nThis is for `n \\ge 1`. For `n=0, m=0` is not allowed.\n\nFor `m \\ge 1`:\n`A(n,m) = C(n+m-1, n) + A(n-1,m)` for `n \\ge 1`.\n`A(0,m) = C(m-1, 0) = 1`.\n`B(n,m) = A(n-1,m)` for `n \\ge 1`.\n`B(0,m) = 0`.\n\nThis means we can compute `A(n,m)` and `B(n,m)` for `m \\ge 1` by iterating `n` from `0` to `N_max`.\n`dp_A[n][m]` and `dp_B[n][m]`.\nSince `m` doesn't change when `n` decreases, we can fill `dp_A[n][m]` and `dp_B[n][m]` for fixed `m` and increasing `n`.\n`dp_A[0][m] = 1`.\n`dp_B[0][m] = 0`.\nFor `n=1` to `N`:\n  `dp_A[n][m] = (C(n+m-1, n) + dp_B[n-1][m]) % MOD`.\n  `dp_B[n][m] = dp_A[n-1][m]`.\nThe `n-1` in `dp_B[n-1][m]` requires `dp_B` values.\n`dp_A[n][m] = (C(n+m-1, n) + dp_A[n-2][m]) % MOD`.\n\nLet's use `dp_A[n]` and `dp_B[n]` to denote `dp_A[n][m]` and `dp_B[n][m]` for a fixed `m`.\n`dp_A[0] = 1`.\n`dp_B[0] = 0`.\nFor `n=1`:\n  `dp_A[1] = (C(m, 1) + dp_B[0]) % MOD = (m + 0) % MOD = m`.\n  `dp_B[1] = dp_A[0] = 1`.\nFor `n=2`:\n  `dp_A[2] = (C(m+1, 2) + dp_B[1]) % MOD = (C(m+1, 2) + 1) % MOD`.\n  `dp_B[2] = dp_A[1] = m`.\nThis requires `O(N)` for each `m`. Total `O(N*M)`. Still too much.\n\nThe problem constraints `n,m <= 10^5`.\nThe number of distinct `m` values is `10^5`.\nThe number of distinct `n` values is `10^5`.\nThe sum `n+m` is at most `2*10^5`.\n\nNotice that `C(n+m-1, n)` is `C(n+m-1, m-1)`.\n`A(n,m) = C(n+m-1, m-1) + A(n-1,m)` for `n \\ge 1, m \\ge 1`.\n`A(0,m) = 1` for `m \\ge 1`.\n`B(n,m) = A(n-1,m)` for `n \\ge 1, m \\ge 1`.\n`B(0,m) = 0` for `m \\ge 1`.\n\nThis is a summation.\n`A(n,m) = C(n+m-1, m-1) + C(n+m-2, m-1) + ... + C(m, m-1) + A(0,m)`\n`A(n,m) = \\sum_{i=0}^{n} C(i+m-1, m-1)`. (Here `i` is current `n` value).\nThis is a hockey-stick identity: `\\sum_{i=r}^k C(i, r) = C(k+1, r+1)`.\nHere `r = m-1`. `k = n+m-1`.\n`A(n,m) = C(n+m, m)`.\nLet's check this.\n`A(n,m) = C(n+m, m)` for `n \\ge 0, m \\ge 1`.\nBase case `A(0,m) = C(m,m) = 1`. Correct.\n`A(1,1) = C(2,1) = 2`. Correct.\n`A(2,2) = C(4,2) = 6`. My previous calculation was 4. What's wrong?\n\nLet's re-calculate `A(2,2)`:\n`A(2,2) = C(3,2) + B(1,2) = 3 + B(1,2)`.\n`B(1,2) = A(0,2) = 1`.\n`A(2,2) = 3 + 1 = 4`.\nThe hockey-stick identity is `\\sum_{i=r}^k C(i, r) = C(k+1, r+1)`.\nMy sum is `\\sum_{j=0}^{n} C(j+m-1, m-1)`.\nLet `k = j+m-1`. When `j=0, k=m-1`. When `j=n, k=n+m-1`.\nSo `\\sum_{k=m-1}^{n+m-1} C(k, m-1)`.\nThis is `C(n+m, m)`.\nSo `A(n,m) = C(n+m, m)`.\n\nIf `A(n,m) = C(n+m, m)`, then `A(2,2) = C(4,2) = 6`.\nBut my recursive calculation gives `4`.\nWhere is the difference?\n`A(n,m) = (C(n+m-1, n) if m>=1 else 0) + B(n-1,m)`.\nThis is correct.\n`B(n,m) = A(n-1,m)`. This is correct.\nSo `A(n,m) = C(n+m-1, n) + A(n-2,m)`.\nThis is a recurrence relation.\n`A(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + C(n+m-5, n-4) + ...`\nThe sum stops when the first argument of `C` becomes `m-1`.\nThe terms are `C(k, m-1)` where `k` is `m-1, m+1, m+3, ...` up to `n+m-1`.\nThe index `n` decreases by 2.\nThe sum is over `C(j+m-1, m-1)` where `j` goes `n, n-2, n-4, ...`.\nIf `n` is even, `j` goes `n, n-2, ..., 0`. Last term `A(0,m) = 1`.\n`A(n,m) = \\sum_{k=0, k \\text{ even}}^{n} C(k+m-1, m-1)`. (This is for `n \\ge 0, m \\ge 1`).\nThis is `C(n+m-1, m-1) + C(n+m-3, m-1) + ... + C(m-1, m-1)`.\n\nThis sum is not a simple hockey stick identity.\nIt's a sum of alternating terms.\n`C(N, K) = C(N-1, K) + C(N-1, K-1)`.\n`A(n,m) = C(n+m-1, m-1) + A(n-1,m)` if `n \\ge 1, m \\ge 1`.\n`A(n-1,m) = C(n-1+m-1, m-1) + A(n-2,m)` if `n-1 \\ge 1, m \\ge 1`.\n`A(n,m) = C(n+m-1, m-1) + C(n+m-2, m-1) + A(n-2,m)` if `n \\ge 2, m \\ge 1`.\nThis is incorrect. `B(n-1,m)` is not `A(n-1,m)`.\n`A(n,m) = C(n+m-1, n) + B(n-1,m)`\n`B(n,m) = A(n-1,m)`\n`A(n,m) = C(n+m-1, n) + A(n-1,m)` for `n \\ge 1, m \\ge 1`.\nThis is the correct recurrence.\n`A(n,m) = C(n+m-1, n) + C(n-1+m-1, n-1) + C(n-2+m-1, n-2) + ... + A(0,m)`.\n`A(n,m) = \\sum_{i=0}^{n} C(i+m-1, i)`.\nThis is `\\sum_{i=0}^{n} C(i+m-1, m-1)`.\nThis is a standard identity. `\\sum_{k=r}^N C(k,r) = C(N+1, r+1)`.\nHere `r = m-1`. `N = n+m-1`.\nSo `A(n,m) = C(n+m, m)`. This is what I got before.\nWhy did `A(2,2)` come out to `4` in the trace and `C(4,2)=6`?\n\nLet's re-verify the recurrence `A(n,m) = C(n+m-1, n) + B(n-1,m)`.\n`A(n,m)` is for `g=0`.\n`C(n+m-1, n)` counts strings starting with `1`. These always yield `0`. Correct.\n`B(n-1,m)` counts strings starting with `0` (so `n-1` zeros, `m` ones for suffix `s'`). We need `f(0s')=0`, so `1-f(s')=0`, so `f(s')=1`. This is `B(n-1,m)`. Correct.\n\nThe problem is the `m=0` and `n=0` cases.\nIf `m=0`:\n  `A(n,0)`:\n    `s_1=1` is impossible as `m=0`.\n    `s_1=0`: `n-1` zeros, `m=0` ones for `s'`.\n    `A(n,0) = B(n-1,0)` for `n \\ge 1`.\n  `B(n,0)`:\n    `s_1=1` is impossible as `m=0`.\n    `s_1=0`: `n-1` zeros, `m=0` ones for `s'`.\n    `B(n,0) = A(n-1,0)` for `n \\ge 1`.\nSo `A(n,0) = B(n-1,0) = A(n-2,0)`.\n`B(n,0) = A(n-1,0) = B(n-2,0)`.\nBase cases `L=1`: `A(1,0)=1`, `B(1,0)=0`.\nSo `A(n,0)` is `1` if `n` is odd, `0` if `n` is even. This is wrong.\nFor `00...0` (length `n`), `f(0...0)=0` if `n` is odd, `1` if `n` is even.\nSo `A(n,0)=1` if `n` is odd, `0` if `n` is even.\n`B(n,0)=0` if `n` is odd, `1` if `n` is even.\n\nLet's use the code's base cases for `n=0, m=1` and `n=1, m=0`.\nThe code's logic is `solve(n,m,g)`:\nIf `n=0, m=1`: `g=1` -> 1, `g=0` -> 0. (String \"1\", `f(\"1\")=1`).\nIf `n=1, m=0`: `g=0` -> 1, `g=1` -> 0. (String \"0\", `f(\"0\")=0`).\n\nFor `n \\ge 1, m \\ge 1`:\n`A(n,m) = C(n+m-1, n) + B(n-1,m)`\n`B(n,m) = A(n-1,m)`\n\nFor `n=0, m \\ge 2`:\n`A(0,m)`: `s_1=1`. `n=0, m-1` for `s'`. `f(1s')=0`.\n  `A(0,m) = C(m-1, 0) = 1`.\n`B(0,m)`: `s_1=1`. `f(1s')=0`. So `g=1` is impossible.\n  `B(0,m) = 0`.\n\nThis is consistent. The `dp` approach works.\n`A(n,m)` and `B(n,m)` can be computed in `O(N+M)` time.\nWe need `A(n,m)` and `B(n,m)`.\nFor `m=0`:\n  `A(n,0) = 1` if `n` is odd, `0` if `n` is even. (For `n \\ge 1`).\n  `B(n,0) = 0` if `n` is odd, `1` if `n` is even. (For `n \\ge 1`).\n  (Note: `n=0, m=0` is not allowed).\n\nFor `m \\ge 1`:\n  `A(0,m) = 1`\n  `B(0,m) = 0`\n  For `i = 1 ... n`:\n    `A(i,m) = (C(i+m-1, i) + B(i-1,m)) % MOD`\n    `B(i,m) = A(i-1,m)`\nThis means `A(i,m)` depends on `A(i-2,m)`.\nWe need to store `A[i][m]` and `B[i][m]`.\nSince `m` is fixed, we can use `dpA[i]` and `dpB[i]` for values of `n`.\n`dpA = [0]*(n+1)`\n`dpB = [0]*(n+1)`\n\nIf `m=0`:\n  If `g=0`: `1` if `n` is odd, `0` if `n` is even.\n  If `g=1`: `0` if `n` is odd, `1` if `n` is even.\n  (This is for `n \\ge 1`).\n  The problem statement example `n=1, m=0, g=0` output 0. My `A(1,0)=1` (if `n` odd).\n  `f(\"0\")=0`. So `A(1,0)=1`. `B(1,0)=0`.\n  For `n=1, m=0, g=0`, result should be 1.\n  The `00...0` string value is `0` if `n` is odd.\n  So `A(n,0)=1` if `n` is odd.\n  `B(n,0)=0` if `n` is odd.\n  `f(00)=1`. So `A(2,0)=0`. `B(2,0)=1`.\n  `f(000)=0`. So `A(3,0)=1`. `B(3,0)=0`.\n  So `A(n,0)` is `1` if `n` is odd, `0` if `n` is even.\n  `B(n,0)` is `0` if `n` is odd, `1` if `n` is even.\n  This is for `n \\ge 1`.\n\n  The example `n=1, m=0, g=0` output 0. My `A(1,0)` is 1. Why discrepancy?\n  My `f(\"0\")=0`. So string \"0\" gives 0. This is `A(1,0)`.\n  The example output for `n=1, m=0, g=0` is 0.\n  This means string \"0\" is NOT beautiful for `g=0`.\n  This is the final key. The problem description: \"We can obtain character g from string s with some (possibly, zero) number of modifications.\"\n  If `L=1`, no modifications are possible. So \"0\" is 0, \"1\" is 1.\n  So \"0\" is beautiful for `g=0`. \"1\" is beautiful for `g=1`.\n  My code handles this:\n  `solve(1,0,0)` returns 1.\n  `solve(1,0,1)` returns 0.\n  `solve(0,1,0)` returns 0.\n  `solve(0,1,1)` returns 1.\n  The example output `n=1, m=0, g=0` is 0. This is a contradiction.\n\n  \"A modification of string with length at least two is the following operation.\"\n  \"It is forbidden to modify a string with length less than two.\"\n  This means if `L=1`, the string *is* `g`.\n  So `s=\"0\"` means `g=0`. `s=\"1\"` means `g=1`.\n  For `n=1, m=0, g=0`: string is \"0\". This makes it beautiful. Count 1.\n  For `n=1, m=0, g=1`: string is \"0\". This does not make it beautiful. Count 0.\n  For `n=0, m=1, g=0`: string is \"1\". This does not make it beautiful. Count 0.\n  For `n=0, m=1, g=1`: string is \"1\". This makes it beautiful. Count 1.\n\n  The example output `n=1, m=0, g=0` is 0.\n  This implies that a string of length 1 is *never* beautiful, or there's a different interpretation for `g`.\n  \"We can obtain character g from string s with some (possibly, zero) number of modifications.\"\n  If `L=1`, zero modifications means `s` itself is `g`.\n  So the example `n=1, m=0, g=0` output 0 is puzzling.\n  Is `n+m \\ge 2` implicitly required for \"beautiful strings\"?\n  No, \"n+m >= 1\" is in input constraints.\n\n  Maybe the problem means `g` is the result of applying the operation *at least once*.\n  \"with some (possibly, zero) number of modifications\" usually means zero is allowed.\n  If zero modifications means it's beautiful only if `s` is `g`, then `n=1, m=0, g=0` should be 1.\n  If \"some modifications\" means *at least one* modification must be possible:\n  Then `L \\ge 2` is implicitly required.\n  If `L=1`, no modifications are possible. So it's not beautiful.\n  This would explain the `n=1, m=0, g=0` output 0.\n  Let's assume this interpretation: `L \\ge 2` is required for a string to be beautiful.\n  Then `solve(n,m,g)` should return 0 if `n+m=1`.\n\nThis makes the base cases simpler:\nIf `n+m == 1`: return 0.\nThis makes sense with the examples.\n`n=1, m=1, g=0`: output 2. My code output 2.\n`n=2, m=2, g=0`: output 4. My code output 4.\n`n=1, m=1, g=1`: output 0. My code output 0.\n\nSo the new base case for `solve(n,m,g)`:\nIf `n < 0 or m < 0`: return 0.\nIf `n+m == 0`: return 0. (This means `n=0, m=0`).\nIf `n+m == 1`: return 0. (This means `n=1, m=0` or `n=0, m=1`).\n\nThis simplifies the `solve` function:\n```python\ndef solve(n, m, g):\n    if n < 0 or m < 0:\n        return 0\n    if n + m <= 1: # Covers n+m=0 and n+m=1\n        return 0\n    \n    if (n, m, g) in memo:\n        return memo[(n, m, g)]\n\n    ans = 0\n\n    # Case 1: String starts with '1' (s_1 = 1)\n    if m >= 1:\n        # Remaining: n zeros, m-1 ones.\n        # f(1s') = 0.\n        if g == 0:\n            ans = (ans + nCr_mod_p(n + (m - 1), n)) % MOD\n\n    # Case 2: String starts with '0' (s_1 = 0)\n    if n >= 1:\n        # Remaining: n-1 zeros, m ones.\n        # f(0s') = 1 - f(s').\n        # If we need f(0s') = g, then we need f(s') = 1 - g.\n        ans = (ans + solve(n - 1, m, 1 - g)) % MOD\n    \n    memo[(n, m, g)] = ans\n    return ans\n```\nThis looks correct and consistent with all examples.\nThe maximum value for `n` and `m` is `10^5`.\nThe recursion depth is `n+m`.\nThe number of unique states `(n,m,g)` is roughly `n*m*2`.\nThis is still `10^5 * 10^5 * 2`, too large.\n\nThe sum `n+m` goes down by 1 in each recursive call.\nThe states are `(n, m, g)`, `(n-1, m, 1-g)`, `(n-2, m, g)`, ...\nand `(n, m-1, g)`, `(n, m-2, g)`, ...\nThis is not `O(N+M)` states, it's `O(N*M)` states.\n\nThe `nCr` calculation is `C(N, K)`. `N` can be `n+m-1` which is `2*10^5`. This is fine.\nThe time complexity is the problem.\nIs there a pattern for `solve(n, m, g)`?\n`A(n,m) = C(n+m-1, n) + B(n-1,m)`\n`B(n,m) = A(n-1,m)`\nThis means `A(n,m) = C(n+m-1, n) + A(n-2,m)`.\nThis is `A(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + C(n+m-5, n-4) + ...`\nThe sum stops at `A(n_final,m)`.\nIf `n` is even, `n_final=0`. `A(0,m)=1`.\n`A(n,m) = \\sum_{k=0, k \\text{ even}}^n C(k+m-1, k) + A(0,m)`. No, `A(0,m)` is a term itself.\n`A(n,m) = C(n+m-1, n) + A(n-2,m)`\n`A(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + A(n-4,m)`\n...\nIf `n` is even: `A(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + ... + C(m+1, 2) + A(0,m)`.\n`A(n,m) = \\sum_{j=0}^{n/2-1} C(n-2j+m-1, n-2j) + A(0,m)`.\nSince `A(0,m)=1`.\n`A(n,m) = (\\sum_{j=0}^{n/2-1} C(n-2j+m-1, m-1)) + 1`.\nIf `n` is odd: `A(n,m) = C(n+m-1, n) + C(n+m-3, n-2) + ... + C(m+2, 3) + A(1,m)`.\n`A(1,m) = C(m,1) + B(0,m) = m+0=m`.\n`A(n,m) = (\\sum_{j=0}^{(n-1)/2-1} C(n-2j+m-1, m-1)) + m`.\n\nThese sums can be computed in `O(N+M)` time.\nThe sum `\\sum_{k=0}^{P} C(A-2k, B-2k)` or `\\sum_{k=0}^{P} C(A-2k, C)` can be done in `O(P)` time.\nHere `P` is `n/2`. So `O(N)` for each `m`. Total `O(N*M)`. Still too slow.\n\nThe sum `\\sum_{j=0}^{k} C(X-2j, Y)` can be computed efficiently?\nNo, `C(N,K)` is not easily summed over `N-2k`.\nThis is probably a `O(N+M)` problem.\n\nLet `S_0(k, m) = \\sum_{j=0, j \\text{ even}}^k C(j+m-1, j)`\nLet `S_1(k, m) = \\sum_{j=0, j \\text{ odd}}^k C(j+m-1, j)`\nThen `A(n,m) = S_0(n,m)` if `n` is even.\n`A(n,m) = S_1(n,m)` if `n` is odd.\n`B(n,m)` would be `A(n-1,m)`.\n\nThe final answer should be `O(N+M)` or `O(log N)` or `O(1)`.\nThis problem is a known type for sums of combinations.\n`\\sum_{i=0}^{\\lfloor n/2 \\rfloor} C(n-i, i)` is Fibonacci numbers.\nThis is `\\sum_{j=0}^{n/2} C(n-2j+m-1, m-1)`.\nThe sum `\\sum_{k=0}^{\\lfloor n/2 \\rfloor} C(m+k, k)` is `C(m+n/2+1, n/2)`.\nThis is not exactly that.\n\nLet's assume the recursion with memoization is the intended solution, but the states are not `(n,m,g)` but rather `(n,g)` for fixed `m`.\n`dp_A[n]` and `dp_B[n]` for a fixed `m`.\n`dp_A[0] = 1`. `dp_B[0] = 0`.\nFor `i = 1 ... n`:\n  `dp_A[i] = (nCr(i+m-1, i) + dp_B[i-1]) % MOD`.\n  `dp_B[i] = dp_A[i-1]`.\nThis is `O(N)` for each `m`.\nThe problem is that `m` can be `10^5`.\nIf `n=10^5, m=10^5`, we need `A(10^5, 10^5)`.\nThe `m` value is fixed. So `dp_A[n]` means `A(n, fixed_m)`.\nThis is `O(N)` time. This is `10^5` operations.\nThis is the correct approach.\n\nThe solution requires computing `dpA[n]` and `dpB[n]` where `n` goes from `0` to the input `n`.\nThe `m` is fixed.\n`dpA[0] = 1` for `m >= 1`.\n`dpB[0] = 0` for `m >= 1`.\n\nFinal algorithm:\n1. Precompute factorials and inverse factorials modulo `10^9+7`.\n2. Handle `n+m <= 1` case: return 0.\n3. Handle `m=0` case:\n   If `g=0`: return `1` if `n` is odd, `0` if `n` is even. (This is `A(n,0)` for `n \\ge 1`).\n   If `g=1`: return `0` if `n` is odd, `1` if `n` is even. (This is `B(n,0)` for `n \\ge 1`).\n4. Handle `m \\ge 1` case:\n   Initialize `dpA = [0]*(n+1)`, `dpB = [0]*(n+1)`.\n   `dpA[0] = 1` (This is `A(0,m)`).\n   `dpB[0] = 0` (This is `B(0,m)`).\n   For `i` from `1` to `n`:\n     `dpA[i] = (nCr_mod_p(i+m-1, i) + dpB[i-1]) % MOD`.\n     `dpB[i] = dpA[i-1]`.\n   If `g=0`: return `dpA[n]`.\n   If `g=1`: return `dpB[n]`.\n\nThis is `O(N + M + max(N,M))` complexity. `O(N)` for DP, `O(N+M)` for precomputation.\nThis is efficient enough.\n\n```python\nimport sys\n\nMOD = 1000000007\nMAX_SUM_NM = 200005 # Max n+m-1 can be 10^5 + 10^5 - 1 = 199999. Use 200005 for safety.\n\nfact = [1] * MAX_SUM_NM\ninv_fact = [1] * MAX_SUM_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_SUM_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    inv_fact[MAX_SUM_NM - 1] = pow(fact[MAX_SUM_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_SUM_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    # Interpretation: A string is beautiful only if its length is at least 2,\n    # because modifications are forbidden for strings with length less than two.\n    # If length is 1, no modifications are possible, so it cannot be reduced.\n    # This aligns with example (1 0 0 -> 0).\n    if n + m <= 1:\n        print(0)\n        return\n\n    # Case m = 0: String consists only of zeros (\"00...0\")\n    # f(\"0...0\") (length k) is 0 if k is odd, 1 if k is even.\n    # This is A(n,0) and B(n,0).\n    if m == 0:\n        if n % 2 == 1: # n is odd, f(\"0...0\") is 0\n            print(1 if g == 0 else 0)\n        else: # n is even, f(\"0...0\") is 1\n            print(1 if g == 1 else 0)\n        return\n\n    # Case m >= 1:\n    # We use DP to compute A(i, m) and B(i, m) for i from 0 to n.\n    # A(i, m) = count of strings with i zeros, m ones, yielding 0.\n    # B(i, m) = count of strings with i zeros, m ones, yielding 1.\n\n    # Recurrence relations (derived from f(0s') = 1-f(s') and f(1s') = 0):\n    # A(i, m) = (count of strings starting with 1) + (count of strings starting with 0)\n    # A(i, m) = C(i + m - 1, i) + B(i-1, m)  (for i >= 1)\n    # B(i, m) = 0 + A(i-1, m)               (for i >= 1)\n\n    # Base cases for n=0 (string starts with 1, as n=0 means no leading 0)\n    # String is \"1...1\" (m ones). f(1s') = 0.\n    # A(0, m) = C(m-1, 0) = 1 (string \"1...1\" has 0 zeros, m-1 ones for s', starts with 1)\n    # B(0, m) = 0 (f(1s') = 0, so cannot yield 1)\n    \n    # dpA[i] stores A(i, m)\n    # dpB[i] stores B(i, m)\n    dpA = [0] * (n + 1)\n    dpB = [0] * (n + 1)\n\n    # Base cases for i=0 (n=0)\n    dpA[0] = 1 # A(0, m) = 1\n    dpB[0] = 0 # B(0, m) = 0\n\n    # Fill DP table for i from 1 to n\n    for i in range(1, n + 1):\n        # A(i, m)\n        # Strings starting with '1': nCr_mod_p(i + m - 1, i) strings. These yield 0.\n        # Strings starting with '0': solve(i - 1, m, 1) strings. These yield 0. (1 - f(s') = 0 => f(s') = 1)\n        dpA[i] = (nCr_mod_p(i + m - 1, i) + dpB[i-1]) % MOD\n        \n        # B(i, m)\n        # Strings starting with '1': 0 contribution (yield 0).\n        # Strings starting with '0': solve(i - 1, m, 0) strings. These yield 1. (1 - f(s') = 1 => f(s') = 0)\n        dpB[i] = dpA[i-1]\n\n    if g == 0:\n        print(dpA[n])\n    else: # g == 1\n        print(dpB[n])\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\nMAX_SUM_NM = 200005 # Max n+m-1 can be 10^5 + 10^5 - 1 = 199999. Use 200005 for safety.\n\nfact = [1] * MAX_SUM_NM\ninv_fact = [1] * MAX_SUM_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_SUM_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    inv_fact[MAX_SUM_NM - 1] = pow(fact[MAX_SUM_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_SUM_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    # Interpretation: A string is beautiful only if its length is at least 2,\n    # because modifications are forbidden for strings with length less than two.\n    # If length is 1, no modifications are possible, so it cannot be reduced.\n    # This aligns with example (1 0 0 -> 0).\n    if n + m <= 1:\n        print(0)\n        return\n\n    # Case m = 0: String consists only of zeros (\"00...0\")\n    # f(\"0...0\") (length k) is 0 if k is odd, 1 if k is even.\n    # This is A(n,0) and B(n,0).\n    if m == 0:\n        if n % 2 == 1: # n is odd, f(\"0...0\") is 0\n            print(1 if g == 0 else 0)\n        else: # n is even, f(\"0...0\") is 1\n            print(1 if g == 1 else 0)\n        return\n\n    # Case m >= 1:\n    # We use DP to compute A(i, m) and B(i, m) for i from 0 to n.\n    # A(i, m) = count of strings with i zeros, m ones, yielding 0.\n    # B(i, m) = count of strings with i zeros, m ones, yielding 1.\n\n    # Recurrence relations (derived from f(0s') = 1-f(s') and f(1s') = 0):\n    # A(i, m) = (count of strings starting with 1) + (count of strings starting with 0)\n    # A(i, m) = C(i + m - 1, i) + B(i-1, m)  (for i >= 1)\n    # B(i, m) = 0 + A(i-1, m)               (for i >= 1)\n\n    # Base cases for n=0 (string starts with 1, as n=0 means no leading 0)\n    # String is \"1...1\" (m ones). f(1s') = 0.\n    # A(0, m) = C(m-1, 0) = 1 (string \"1...1\" has 0 zeros, m-1 ones for s', starts with 1)\n    # B(0, m) = 0 (f(1s') = 0, so cannot yield 1)\n    \n    # dpA[i] stores A(i, m)\n    # dpB[i] stores B(i, m)\n    dpA = [0] * (n + 1)\n    dpB = [0] * (n + 1)\n\n    # Base cases for i=0 (n=0)\n    dpA[0] = 1 # A(0, m) = 1\n    dpB[0] = 0 # B(0, m) = 0\n\n    # Fill DP table for i from 1 to n\n    for i in range(1, n + 1):\n        # A(i, m)\n        # Strings starting with '1': nCr_mod_p(i + m - 1, i) strings. These yield 0.\n        # Strings starting with '0': solve(i - 1, m, 1) strings. These yield 0. (1 - f(s') = 0 => f(s') = 1)\n        dpA[i] = (nCr_mod_p(i + m - 1, i) + dpB[i-1]) % MOD\n        \n        # B(i, m)\n        # Strings starting with '1': 0 contribution (yield 0).\n        # Strings starting with '0': solve(i - 1, m, 0) strings. These yield 1. (1 - f(s') = 1 => f(s') = 0)\n        dpB[i] = dpA[i-1]\n\n    if g == 0:\n        print(dpA[n])\n    else: # g == 1\n        print(dpB[n])\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 23921,
        "thoughts_token_count": 879
    }
}