{
    "start": 1758294678.9398577,
    "end": 1758294739.7830205,
    "start-formatted": "2025-09-20 00:11 KST",
    "end-formatted": "2025-09-20 00:12 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Brute Force Solution for Non-Intersecting Segment Matching**\n\nOkay, so the challenge here is a \"Guard Duty\" problem, which boils down to finding a perfect matching between spaceships and bases such that the connection segments don't cross.  The key insight is the \"no intersection\" constraint, which demands a geometric solution. Given the constraint `R, B <= 10`, a brute-force approach seems feasible, despite the potential `N!` permutations.\n\nFirst, I'll check if `R == B`, because we can only have a perfect matching if that is true. Then, for each possible permutation of assigning bases to spaceships, I'll generate the set of line segments. Now, the core of the algorithm is the `segments_intersect` function, which determines whether any two segments intersect, relying on cross products and orientations. Since no three points are collinear, I don't need to account for special cases, making the intersection check relatively straightforward.\n\nI'm using the standard orientation check with the cross product. If, for any permutation, no segment pairs intersect, I'll output \"Yes\"; otherwise, it's \"No\". The orientation logic ensures I handle the intersection conditions correctly. I'll need to define a good `orientation` function that returns the orientation (clockwise, counter-clockwise, or collinear).\n\nThe brute-force check involves generating all permutations, which scales as `N!`. Then, for each permutation, I'll check `N * (N-1)/2` pairs of segments for intersections. I'll need to make sure the time complexity isn't too large because of the factorial term.\nI'm confident the logic and the calculations are correct, given no collinearity is guaranteed. The cross product calculations are using integer arithmetic, and it is correct in that case.\n",
    "response": "The problem asks us to determine if it's possible to assign `R` Rebel spaceships to `B` bases such that each spaceship guards exactly one base and each base is guarded by exactly one spaceship, with the additional constraint that the straight-line paths connecting assigned pairs do not intersect.\n\n**1. Perfect Matching Requirement:**\nFor a perfect matching to exist where every spaceship is assigned to a unique base and vice-versa, the number of spaceships `R` must be equal to the number of bases `B`. If `R != B`, it's impossible, so we can immediately output \"No\".\n\n**2. Non-Intersecting Paths:**\nThe core of the problem is the non-intersection constraint. Since `R` and `B` are very small (up to 10), we can use a brute-force approach.\nIf `R = B = N`, we need to find a permutation `P` of `(0, 1, ..., N-1)` such that if `Rebel_i` is connected to `Base_{P[i]}` for all `i`, no two segments `(Rebel_i, Base_{P[i]})` and `(Rebel_k, Base_{P[k]})` intersect.\n\n**Algorithm:**\n1.  **Read Input:** Read `R` and `B`. Store the coordinates of `R` Rebel spaceships in a list `rebels` and `B` bases in a list `bases`.\n2.  **Check `R == B`:** If `R != B`, print \"No\" and exit.\n3.  **Iterate Permutations:** Use `itertools.permutations` to generate all possible permutations of base indices `(0, 1, ..., N-1)`, where `N = R = B`. Each permutation `p` represents a potential matching: `Rebel_i` is matched with `Base_{p[i]}`.\n4.  **Check for Intersections:** For each permutation:\n    a.  Construct the `N` segments corresponding to this matching: `(rebels[i], bases[p[i]])` for `i` from `0` to `N-1`.\n    b.  Iterate through all unique pairs of these `N` segments. For each pair of segments `(s1, s2)`, check if they intersect.\n    c.  If any two segments intersect, this permutation is invalid. Move to the next permutation.\n    d.  If no intersections are found after checking all pairs, then this is a valid non-crossing perfect matching. Print \"Yes\" and terminate.\n5.  **No Solution Found:** If all permutations are checked and no valid matching is found, print \"No\".\n\n**Geometric Intersection Check:**\nTo check if two line segments `p1q1` and `p2q2` intersect, we use the concept of orientation (cross product).\nGiven three points `p=(x1, y1), q=(x2, y2), r=(x3, y3)`, the `orientation(p, q, r)` can be determined by the sign of the cross product of vectors `PQ` and `QR`: `(q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)`.\n*   If `val > 0`, `r` is counter-clockwise (left turn) from `pq`.\n*   If `val < 0`, `r` is clockwise (right turn) from `pq`.\n*   If `val == 0`, `p, q, r` are collinear.\n\nThe problem guarantees \"no three points are on the same line\", which simplifies the intersection check: we don't need to worry about collinear cases or endpoints lying on other segments. Two segments `p1q1` and `p2q2` strictly intersect if and only if:\n1.  `p1` and `q1` lie on opposite sides of the line `p2q2`.\n2.  `p2` and `q2` lie on opposite sides of the line `p1q1`.\n\nThis translates to:\n`orientation(p1, q1, p2)` and `orientation(p1, q1, q2)` must have different signs.\nAND\n`orientation(p2, q2, p1)` and `orientation(p2, q2, q1)` must have different signs.\nSince orientations will never be zero (due to the \"no three points collinear\" guarantee), we can simply check if `orientation(p1, q1, p2) != orientation(p1, q1, q2)` AND `orientation(p2, q2, p1) != orientation(p2, q2, q1)`.\n\n**Complexity:**\n*   `N` is at most 10.\n*   Number of permutations: `N!`. For `N=10`, `10! = 3,628,800`.\n*   For each permutation, we have `N` segments. We need to check `N * (N-1) / 2` pairs of segments. For `N=10`, this is `45` pairs.\n*   Each segment intersection check involves a few multiplications and additions (constant time).\n*   Total operations: `N! * N^2`, which is approximately `3.6 * 10^6 * 10^2 = 3.6 * 10^8`. This is on the higher side for a typical time limit, but often acceptable for Python if the constant factor is small. Python's arbitrary-precision integers handle coordinate values up to 10000 without overflow.\n\n```python\nimport sys\nimport itertools\n\n# Helper function to read point coordinates\ndef read_point():\n    x, y = map(int, sys.stdin.readline().split())\n    return (x, y)\n\n# Orientation of ordered triplet (p, q, r)\n# Returns 1 if r is counter-clockwise (left turn) from vector pq\n# Returns -1 if r is clockwise (right turn) from vector pq\n# Returns 0 if p, q, r are collinear (not expected due to problem constraints)\ndef orientation(p, q, r):\n    # Cross product (q-p) x (r-q)\n    # For points p=(x1, y1), q=(x2, y2), r=(x3, y3)\n    # val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else -1 # Counter-clockwise (positive) or Clockwise (negative)\n\n# Function to check if two segments p1q1 and p2q2 intersect\ndef segments_intersect(p1, q1, p2, q2):\n    # Find the four orientations needed\n    o1 = orientation(p1, q1, p2) # p2 relative to p1q1\n    o2 = orientation(p1, q1, q2) # q2 relative to p1q1\n    o3 = orientation(p2, q2, p1) # p1 relative to p2q2\n    o4 = orientation(p2, q2, q1) # q1 relative to p2q2\n\n    # General case for strict intersection:\n    # Segments intersect if p2 and q2 are on opposite sides of p1q1\n    # AND p1 and q1 are on opposite sides of p2q2.\n    # Since no three points are collinear (guaranteed by problem),\n    # o1, o2, o3, o4 will never be 0.\n    # So, we just check if the signs of orientations differ.\n    return (o1 != o2) and (o3 != o4)\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n\n    rebels = [read_point() for _ in range(R)]\n    bases = [read_point() for _ in range(B)]\n\n    # A perfect matching requires R spaceships to B bases, so R must equal B.\n    if R != B:\n        print(\"No\")\n        return\n\n    N = R # N is the number of spaceships/bases\n    \n    # Iterate through all permutations of base assignments.\n    # A permutation 'p' means rebel[i] is matched with bases[p[i]].\n    for p in itertools.permutations(range(N)):\n        current_segments = []\n        for i in range(N):\n            current_segments.append((rebels[i], bases[p[i]]))\n        \n        # Check for intersections among the current set of N segments.\n        has_intersection = False\n        # Iterate through all unique pairs of segments\n        for i in range(N):\n            for j in range(i + 1, N):\n                s1_p1, s1_q1 = current_segments[i]\n                s2_p1, s2_q1 = current_segments[j]\n                \n                if segments_intersect(s1_p1, s1_q1, s2_p1, s2_q1):\n                    has_intersection = True\n                    break # Found an intersection, this permutation is invalid\n            if has_intersection:\n                break # Break from outer loop too\n        \n        # If no intersections were found for this permutation, it's a valid matching.\n        if not has_intersection:\n            print(\"Yes\")\n            return # Found a solution, print Yes and exit.\n            \n    # If no valid permutation was found after checking all of them.\n    print(\"No\")\n\n# Call the solve function to run the program\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\n# Helper function to read point coordinates\ndef read_point():\n    x, y = map(int, sys.stdin.readline().split())\n    return (x, y)\n\n# Orientation of ordered triplet (p, q, r)\n# Returns 1 if r is counter-clockwise (left turn) from vector pq\n# Returns -1 if r is clockwise (right turn) from vector pq\n# Returns 0 if p, q, r are collinear (not expected due to problem constraints)\ndef orientation(p, q, r):\n    # Cross product (q-p) x (r-q)\n    # For points p=(x1, y1), q=(x2, y2), r=(x3, y3)\n    # val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else -1 # Counter-clockwise (positive) or Clockwise (negative)\n\n# Function to check if two segments p1q1 and p2q2 intersect\ndef segments_intersect(p1, q1, p2, q2):\n    # Find the four orientations needed\n    o1 = orientation(p1, q1, p2) # p2 relative to p1q1\n    o2 = orientation(p1, q1, q2) # q2 relative to p1q1\n    o3 = orientation(p2, q2, p1) # p1 relative to p2q2\n    o4 = orientation(p2, q2, q1) # q1 relative to p2q2\n\n    # General case for strict intersection:\n    # Segments intersect if p2 and q2 are on opposite sides of p1q1\n    # AND p1 and q1 are on opposite sides of p2q2.\n    # Since no three points are collinear (guaranteed by problem),\n    # o1, o2, o3, o4 will never be 0.\n    # So, we just check if the signs of orientations differ.\n    return (o1 != o2) and (o3 != o4)\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n\n    rebels = [read_point() for _ in range(R)]\n    bases = [read_point() for _ in range(B)]\n\n    # A perfect matching requires R spaceships to B bases, so R must equal B.\n    if R != B:\n        print(\"No\")\n        return\n\n    N = R # N is the number of spaceships/bases\n    \n    # Iterate through all permutations of base assignments.\n    # A permutation 'p' means rebel[i] is matched with bases[p[i]].\n    for p in itertools.permutations(range(N)):\n        current_segments = []\n        for i in range(N):\n            current_segments.append((rebels[i], bases[p[i]]))\n        \n        # Check for intersections among the current set of N segments.\n        has_intersection = False\n        # Iterate through all unique pairs of segments\n        for i in range(N):\n            for j in range(i + 1, N):\n                s1_p1, s1_q1 = current_segments[i]\n                s2_p1, s2_q1 = current_segments[j]\n                \n                if segments_intersect(s1_p1, s1_q1, s2_p1, s2_q1):\n                    has_intersection = True\n                    break # Found an intersection, this permutation is invalid\n            if has_intersection:\n                break # Break from outer loop too\n        \n        # If no intersections were found for this permutation, it's a valid matching.\n        if not has_intersection:\n            print(\"Yes\")\n            return # Found a solution, print Yes and exit.\n            \n    # If no valid permutation was found after checking all of them.\n    print(\"No\")\n\n# Call the solve function to run the program\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 512,
        "completion_token_count": 2252,
        "thoughts_token_count": 5806
    }
}