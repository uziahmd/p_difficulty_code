{
    "start": 1758009339.035534,
    "end": 1758009393.7793257,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Breaking Down the Snowflake Problem**\n\nOkay, so I'm tackling this \"Rudolf and Snowflakes (hard version)\" problem. It's about figuring out if a given number of vertices, 'n', can form a specific type of graph called a snowflake.  Let's see, a snowflake is built in steps: we start with a center vertex, connect it to 'k' other vertices (where 'k' is greater than 1), and then keep adding more vertices connected to the existing leaves.  The key here is that this leaf expansion must happen at least once.\n\nMy thinking is to analyze the structure and derive a vertex count formula.  I'm starting by tracing how vertices are added:\n\n*   **Step 1:** One central vertex.\n*   **Step 2:** The center connects to 'k' vertices, so now we have 1 + k vertices in total.\n*   **Step 3:** This is the iterative part.  Let's call the number of times we do it 'd' where d >= 1.  I'll start by looking at a couple of iterations to establish the pattern.\n\nIf d=1, the initial leaves from step 2 each connect to 'k' new vertices.  This means we add k\\*k = k^2 new vertices.  So, we now have 1 + k + k^2.\n\nIf d=2, the new leaves from d=1 each connect to 'k' new vertices. so we have k^2\\*k = k^3 new vertices. Total: 1+k+k^2+k^3\n\nSo, after 'd' iterations of step 3, it looks like the total number of vertices becomes: 1 + k + k^2 + ... + k^(d+1).  That's a geometric series!  The sum is (k^(d+2) - 1) / (k - 1).\n\nI'll call d+1 as D, where D >= 2.  Then the formula for the number of vertices, N, is (k^(D+1) - 1) / (k - 1).\n\nNow the task is to find a k>1 and D>=2 that fit for n.\n\nGiven the upper bound on 'n' (10^18), I'm thinking of how to approach this efficiently. I'll need to explore the potential values of 'k' and 'D'.  It makes sense to first consider the simplest case: D=2. In this case, the total number of vertices becomes 1 + k + k^2.  I can solve for 'k' using the quadratic formula: k = (-1 ± sqrt(4n - 3)) / 2. I'm focusing on the condition where 'k' must be an integer and greater than 1.  This means that the expression `4n - 3` has to be a perfect square.  This seems a good starting point for testing if a valid snowflake is possible.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1. Start with 1 vertex (the center).\n2. The center connects to `k` new vertices, where `k > 1`.\n3. Each vertex connected to only one other vertex (i.e., a leaf) is connected to `k` more new vertices. This step must be done at least once.\n\nLet's count the total number of vertices.\n- Initial vertex: 1\n- After step 2: `k` new vertices are added. Total: `1 + k`. These `k` vertices are leaves.\n- After step 3, first iteration: Each of the `k` leaves from step 2 connects to `k` new vertices. So, `k * k = k^2` new vertices are added. Total: `1 + k + k^2`. These `k^2` vertices are now leaves.\n- After step 3, second iteration: Each of the `k^2` leaves connects to `k` new vertices. So, `k^2 * k = k^3` new vertices are added. Total: `1 + k + k^2 + k^3`.\n- ...\n- If step 3 is performed `d` times (where `d >= 1`), the total number of vertices will be `N = 1 + k + k^2 + ... + k^(d+1)`.\n\nLet `D = d+1`. Since `d >= 1`, `D` must be at least 2.\nSo, we are looking for `n` such that `n = 1 + k + k^2 + ... + k^D` for some integers `k > 1` and `D >= 2`.\nThis is a geometric series sum, which can be written as `n = (k^(D+1) - 1) / (k - 1)`.\n\nWe need to check if a given `n` can be represented in this form.\n\n**Case 1: `D = 2`**\nIn this case, `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1. `4n - 3` must be a perfect square. Let `m = sqrt(4n - 3)`.\n2. `(-1 + m)` must be an even positive number. This means `m` must be odd and `m > 1`.\n   If `m` is odd, `m-1` is even. If `m > 1`, then `(m-1)/2 > 0`.\nSo, we check if `4n - 3` is a perfect square `m^2`, and if `m` is odd and `m > 1`. If these conditions hold, then `k = (m - 1) / 2` is a valid `k > 1`.\n\n**Case 2: `D >= 3`**\nIn this case, `n = 1 + k + k^2 + ... + k^D`.\nSince `k > 1`, `k^D < n`. This means `k < n^(1/D)`.\nAlso, `n = 1 + k + ... + k^D > k^D`.\nAnd `n = 1 + k + ... + k^D < k^D + k^D + ... + k^D` (D+1 times) if k is large, or more precisely, `n = (k^(D+1) - 1) / (k - 1)`.\nSince `k >= 2`, `k-1 >= 1`.\n`n = 1 + k + ... + k^D`.\nWe know that `k^D < n`. So `k < n^(1/D)`.\nAlso, `n = 1 + k + ... + k^D > k^D`.\nAnd `n = 1 + k + ... + k^D < k^D + k^D + ... + k^D = (D+1)k^D`. This is a loose upper bound.\nA tighter upper bound: `n = (k^(D+1) - 1) / (k - 1)`. For `k >= 2`, `k-1 >= 1`.\n`n < k^(D+1)`. So `k > n^(1/(D+1)) - epsilon`.\nCombining these, `n^(1/(D+1)) < k < n^(1/D)`.\n\nThe maximum value of `n` is `10^18`.\nIf `D = 3`, `k < (10^18)^(1/3) = 10^6`.\nIf `D = 4`, `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\nIf `D = 5`, `k < (10^18)^(1/5) = 10^(3.6) approx 3981`.\nIf `D = 60`, `k < (10^18)^(1/60) = (10^3)^(1/10) = 10^(0.3) approx 1.99`. This means `k` must be 1, but `k > 1`. So `D` cannot be as large as 60.\nThe smallest `k` is 2. If `k=2`, `n = 1 + 2 + ... + 2^D = 2^(D+1) - 1`.\nIf `n = 10^18`, then `2^(D+1) - 1 approx 10^18`. `2^(D+1) approx 10^18`.\n`D+1 approx log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79`. So `D+1` can be up to 59.\nThis means `D` can be up to 58.\n\nWe can iterate `D` from 3 up to `~58`. For each `D`, we need to find if there exists an integer `k > 1` such that `1 + k + ... + k^D = n`.\nSince `n^(1/(D+1)) < k < n^(1/D)`, we can use binary search to find `k` for a fixed `D`.\nThe range for `k` is `[2, floor(n^(1/D))]`.\nLet `f(k) = 1 + k + ... + k^D`. This function is strictly increasing for `k > 1`.\nBinary search for `k` in the range `[2, 10^9]` (since `D=3` gives `k < 10^6`, `D=2` gives `k < 10^9`).\nThe upper bound for `k` is `n^(1/2)` (from `D=2` case, `k^2 < n`). So `k` can be up to `sqrt(10^18) = 10^9`.\nSo, for `D` from 3 to `~58`, we binary search for `k` in `[2, 10^9]`.\n\n**Binary Search for `k`:**\nFor a fixed `D`:\n`low = 2`, `high = 10^9`.\nWhile `low <= high`:\n  `mid = (low + high) // 2`\n  Calculate `current_sum = 1 + mid + mid^2 + ... + mid^D`.\n  Be careful about overflow when calculating `mid^j`. If `mid^j` exceeds `n`, `current_sum` will also exceed `n`.\n  `current_sum = 0`\n  `term = 1`\n  `possible_overflow = False`\n  For `j` from 0 to `D`:\n    `current_sum += term`\n    If `j < D`:\n      If `term > n / mid`: (Check for `term * mid > n` to prevent overflow)\n        `possible_overflow = True`\n        break\n      `term *= mid`\n  \n  If `possible_overflow` or `current_sum > n`:\n    `high = mid - 1`\n  Else if `current_sum < n`:\n    `low = mid + 1`\n  Else (`current_sum == n`):\n    Return `True` (found a valid `k` and `D`)\nReturn `False` (no `k` found for this `D`)\n\n**Overall Algorithm:**\n1. Function `is_perfect_square(num)`: Checks if `num` is a perfect square. Returns `sqrt(num)` if it is, `None` otherwise.\n2. Function `check(n)`:\n   a. **Check `D=2` case:**\n      `val = 4 * n - 3`\n      `m = is_perfect_square(val)`\n      If `m` is not `None` and `m > 1` and `(m - 1) % 2 == 0`:\n         `k = (m - 1) // 2`\n         If `k > 1`, return \"YES\".\n   b. **Check `D >= 3` cases:**\n      Iterate `D` from 3 up to 58 (or a slightly higher safe bound like 60).\n      For each `D`:\n         `low = 2`, `high = min(int(n**(1/D)) + 2, 10**9 + 7)` (add some buffer for `n**(1/D)` precision and cap at `10^9`)\n         While `low <= high`:\n            `mid = (low + high) // 2`\n            `current_sum = 0`\n            `term = 1`\n            `overflow = False`\n            For `j` from 0 to `D`:\n               `current_sum += term`\n               If `current_sum > n`: # `current_sum` already exceeded `n`\n                   `overflow = True`\n                   break\n               If `j < D`: # Prepare for next term, check for `term * mid` overflow\n                   If `mid == 0`: # Should not happen since low=2\n                       `overflow = True`\n                       break\n                   If `term > n // mid`: # `term * mid` would exceed `n`\n                       `overflow = True`\n                       break\n                   `term *= mid`\n            \n            If `overflow` or `current_sum > n`:\n               `high = mid - 1`\n            Else if `current_sum < n`:\n               `low = mid + 1`\n            Else (`current_sum == n`):\n               Return \"YES\".\n   c. If no `k, D` found, return \"NO\".\n\n**Edge Cases:**\n- `n=1, 2, 3, 6`: These are small values.\n  - `n=1`: `1+k+k^2 = 1` implies `k+k^2=0`, `k(1+k)=0`, so `k=0` or `k=-1`. Not `k>1`. NO.\n  - `n=2`: `1+k+k^2 = 2` implies `k+k^2=1`. No integer `k>1`. NO.\n  - `n=3`: `1+k+k^2 = 3` implies `k+k^2=2`. No integer `k>1`. NO.\n  - `n=6`: `1+k+k^2 = 6` implies `k^2+k-5=0`. `4n-3 = 21`, not a perfect square. NO.\n  - `n=13`: `1+k+k^2 = 13` implies `k^2+k-12=0`. `(k+4)(k-3)=0`. `k=3`. `k>1` is satisfied. YES.\n  - `n=15`: `1+k+k^2 = 15` implies `k^2+k-14=0`. `4n-3 = 57`, not a perfect square.\n    Try `D=3`: `1+k+k^2+k^3 = 15`. If `k=2`, `1+2+4+8 = 15`. Yes, `k=2, D=3`. YES.\n\nThe binary search `high` limit `10**9 + 7` is a bit arbitrary. A more precise `high` could be `int(n**(1/D)) + 2` for `D >= 3`. For `D=2`, `k` can be up to `10^9`. So, `high` can be `10^9`.\nThe `min` with `10**9 + 7` handles both cases effectively.\n\n```python\nimport sys\n\ndef is_perfect_square(n):\n    if n < 0:\n        return None\n    if n == 0:\n        return 0\n    \n    # Use integer square root\n    x = int(n**0.5)\n    if x * x == n:\n        return x\n    if (x + 1) * (x + 1) == n: # Check x+1 due to floating point precision\n        return x + 1\n    if (x - 1) * (x - 1) == n: # Check x-1 due to floating point precision\n        return x - 1\n    return None\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: D = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    val = 4 * n - 3\n    m = is_perfect_square(val)\n    if m is not None:\n        if m > 1 and (m - 1) % 2 == 0: # Check m > 1 to ensure k > 0, (m-1)%2==0 ensures k is integer\n            k_val = (m - 1) // 2\n            if k_val > 1: # k must be > 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: D >= 3 (n = 1 + k + k^2 + ... + k^D)\n    # The maximum D occurs when k=2. n = 2^(D+1) - 1.\n    # For n = 10^18, 2^(D+1) approx 10^18. D+1 approx log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79.\n    # So D+1 can be up to 59, meaning D can be up to 58.\n    # We iterate D from 3 up to 58 (or 60 for safety).\n    for D in range(3, 60): # D can be up to 58. Max k is 10^9 for D=2\n        # For a fixed D, we need to find k such that 1 + k + ... + k^D = n.\n        # k^D < n, so k < n^(1/D).\n        # We can binary search for k.\n        # k must be > 1.\n        # Upper bound for k: n^(1/D) is a loose upper bound.\n        # For D=3, k < (10^18)^(1/3) = 10^6.\n        # For D=58, k < (10^18)^(1/58) approx 1.99. So k=1 or no solution.\n        # The true upper bound for k is min(int(n**(1/D)) + 2, 10**9).\n        # Since n = 1 + k + ... + k^D, and k >= 2,\n        # n = (k^(D+1) - 1) / (k-1)\n        # k^(D+1) - 1 = n * (k-1)\n        # k^(D+1) approx n * k\n        # k^D approx n\n        # k approx n^(1/D)\n        \n        low = 2\n        # A safe upper bound for k. For n=10^18, D=3, k can be up to 10^6.\n        # For D=2, k can be up to 10^9. The loop only considers D>=3.\n        # So, int(n**(1/D)) + 2 is a good upper bound.\n        # For D=3, n=10^18, n**(1/3) = 10^6. So high is around 10^6.\n        # Max value of k for D >= 3 is relatively small.\n        # For D=3, k_max ~ 10^6.\n        # For D=4, k_max ~ 31622.\n        # For D=5, k_max ~ 3981.\n        # For D=6, k_max ~ 1000.\n        high = int(n**(1/D)) + 2 # Add a small buffer due to floating point precision for n**(1/D)\n\n        # Cap high to prevent excessively large binary search range\n        # k cannot exceed 10^9 (from D=2 case).\n        # For D>=3, k will be much smaller than 10^9.\n        # Example: n=10^18, D=3, k_max is 10^6.\n        # So high can be capped at something like 2 * 10^6 or even 10^9 for safety.\n        # The current high = int(n**(1/D)) + 2 is fine and tight enough.\n\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == 1: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 0\n            term = 1\n            overflow = False\n\n            for j in range(D + 1):\n                current_sum += term\n                if current_sum > n: # Sum already exceeded n\n                    overflow = True\n                    break\n                \n                if j < D: # Prepare for next term, check for term * mid overflow\n                    if mid == 0: # Should not happen as low starts at 2\n                        overflow = True\n                        break\n                    if term > n // mid: # term * mid would exceed n\n                        overflow = True\n                        break\n                    term *= mid\n            \n            if overflow or current_sum > n:\n                high = mid - 1\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum == n\n                sys.stdout.write(\"YES\\n\")\n                return\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef is_perfect_square(n):\n    if n < 0:\n        return None\n    if n == 0:\n        return 0\n    \n    # Use integer square root\n    x = int(n**0.5)\n    if x * x == n:\n        return x\n    if (x + 1) * (x + 1) == n: # Check x+1 due to floating point precision\n        return x + 1\n    if (x - 1) * (x - 1) == n: # Check x-1 due to floating point precision\n        return x - 1\n    return None\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: D = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    val = 4 * n - 3\n    m = is_perfect_square(val)\n    if m is not None:\n        if m > 1 and (m - 1) % 2 == 0: # Check m > 1 to ensure k > 0, (m-1)%2==0 ensures k is integer\n            k_val = (m - 1) // 2\n            if k_val > 1: # k must be > 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: D >= 3 (n = 1 + k + k^2 + ... + k^D)\n    # The maximum D occurs when k=2. n = 2^(D+1) - 1.\n    # For n = 10^18, 2^(D+1) approx 10^18. D+1 approx log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79.\n    # So D+1 can be up to 59, meaning D can be up to 58.\n    # We iterate D from 3 up to 58 (or 60 for safety).\n    for D in range(3, 60): # D can be up to 58. Max k is 10^9 for D=2\n        # For a fixed D, we need to find k such that 1 + k + ... + k^D = n.\n        # k^D < n, so k < n^(1/D).\n        # We can binary search for k.\n        # k must be > 1.\n        # Upper bound for k: n^(1/D) is a loose upper bound.\n        # For D=3, k < (10^18)^(1/3) = 10^6.\n        # For D=58, k < (10^18)^(1/58) approx 1.99. So k=1 or no solution.\n        # The true upper bound for k is min(int(n**(1/D)) + 2, 10**9).\n        # Since n = 1 + k + ... + k^D, and k >= 2,\n        # n = (k^(D+1) - 1) / (k-1)\n        # k^(D+1) - 1 = n * (k-1)\n        # k^(D+1) approx n * k\n        # k^D approx n\n        # k approx n^(1/D)\n        \n        low = 2\n        # A safe upper bound for k. For n=10^18, D=3, k can be up to 10^6.\n        # For D=2, k can be up to 10^9. The loop only considers D>=3.\n        # So, int(n**(1/D)) + 2 is a good upper bound.\n        # For D=3, n=10^18, n**(1/3) = 10^6. So high is around 10^6.\n        # Max value of k for D >= 3 is relatively small.\n        # For D=3, k_max ~ 10^6.\n        # For D=4, k_max ~ 31622.\n        # For D=5, k_max ~ 3981.\n        # For D=6, k_max ~ 1000.\n        high = int(n**(1/D)) + 2 # Add a small buffer due to floating point precision for n**(1/D)\n\n        # Cap high to prevent excessively large binary search range\n        # k cannot exceed 10^9 (from D=2 case).\n        # For D>=3, k will be much smaller than 10^9.\n        # Example: n=10^18, D=3, k_max is 10^6.\n        # So high can be capped at something like 2 * 10^6 or even 10^9 for safety.\n        # The current high = int(n**(1/D)) + 2 is fine and tight enough.\n\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == 1: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 0\n            term = 1\n            overflow = False\n\n            for j in range(D + 1):\n                current_sum += term\n                if current_sum > n: # Sum already exceeded n\n                    overflow = True\n                    break\n                \n                if j < D: # Prepare for next term, check for term * mid overflow\n                    if mid == 0: # Should not happen as low starts at 2\n                        overflow = True\n                        break\n                    if term > n // mid: # term * mid would exceed n\n                        overflow = True\n                        break\n                    term *= mid\n            \n            if overflow or current_sum > n:\n                high = mid - 1\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum == n\n                sys.stdout.write(\"YES\\n\")\n                return\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 4574,
        "thoughts_token_count": 841
    }
}