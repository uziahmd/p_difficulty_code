{
    "start": 1758284904.121346,
    "end": 1758284932.4315257,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Breaking Down the Neko Maths Problem**\n\nOkay, so I'm tackling this \"Neko does Maths\" problem. The core of it is finding the smallest non-negative *k* that minimizes the least common multiple (LCM) of (a + k) and (b + k). My immediate thought is to try and simplify the LCM calculation.  I know that `lcm(x, y) = (x * y) / gcd(x, y)`, where `gcd` is the greatest common divisor. So, I want to minimize `((a + k) * (b + k)) / gcd(a + k, b + k)`.\n\nThe trick here, as I've seen in similar problems, is likely hidden within the GCD. I need to figure out how `gcd(a + k, b + k)` behaves.  A key property of GCDs pops into my head: `gcd(x, y) = gcd(x, y-x)` (assuming x < y). Applying this to my problem,  `gcd(a + k, b + k)` becomes `gcd(a + k, b - a)`.  I can assume, without loss of generality, that `a <= b`, just to make things cleaner. Let `d = b - a`.  Therefore, `gcd(a + k, b + k) = gcd(a + k, d)`.\n\nThis is significant! It means the GCD *must* be a divisor of `d`. Let's represent this divisor as *g*.  So, I have `gcd(a + k, d) = g`, where `g` divides `d`. This means `a + k` must be a multiple of `g`.\n\nNow, the problem boils down to finding a *k* such that `a + k` is a multiple of *g* which also minimizes `((a + k) * (b + k)) / g`.  The trivial case is when `a = b`. Here, `d = 0`, and the GCD becomes `a + k`. The LCM is minimized when `k = 0`, leading to an LCM of *a*.\n\nFor the non-trivial case (a != b), I need to iterate through the divisors *g* of *d*.  For a given *g*, I need to figure out the smallest non-negative *k* that satisfies `a + k` is divisible by *g*.  This can be done using modular arithmetic.  The smallest such `k` would be `(-a % g + g) % g`. Let's call this `k_g`. With this, I can efficiently calculate the LCM for each divisor *g*, and find the smallest one.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If multiple `k` values yield the same minimum LCM, we choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nA key property of the greatest common divisor (GCD) is `gcd(x, y) = gcd(x, y-x)`.\nApplying this property:\n`gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k))`\n`gcd(a+k, b+k) = gcd(a+k, b-a)`\n\nLet `diff = |b-a|`. Then `gcd(a+k, b+k) = gcd(a+k, diff)`.\nThis implies that `gcd(a+k, b+k)` must be a divisor of `diff`.\n\n**Case 1: `a = b`**\nIf `a = b`, then `diff = 0`.\n`gcd(a+k, a+k) = a+k`.\n`lcm(a+k, a+k) = (a+k)(a+k) / (a+k) = a+k`.\nTo minimize `a+k`, we should choose the smallest non-negative `k`, which is `k=0`.\nThe minimum LCM is `a`.\n\n**Case 2: `a != b`**\nLet `diff = |b-a|`.\nThe `gcd(a+k, b+k)` must be a divisor of `diff`.\nLet `g` be a divisor of `diff`. We are looking for `k` such that `gcd(a+k, b+k) = g`.\nFor this to happen, `a+k` must be a multiple of `g`.\nThis means `a+k \\equiv 0 \\pmod g`, or `k \\equiv -a \\pmod g`.\nThe smallest non-negative `k` that satisfies this condition for a given `g` is `k_g = (-a % g + g) % g`.\n(Note: in Python, `-a % g` already handles negative `a` values correctly if `g` is positive, but `(-a % g + g) % g` is a safer form to ensure non-negative results if `a` could be negative, though here `a >= 1`.)\nWith this `k_g`, `a+k_g` is the smallest multiple of `g` that is greater than or equal to `a`.\nLet `A_k = a+k_g` and `B_k = b+k_g`.\nThe LCM for this `k_g` would be `(A_k * B_k) / g`.\n\nWe need to iterate through all possible divisors `g` of `diff = |b-a|`.\nFor each divisor `g`:\n1. Calculate `k_g = (-a % g + g) % g`.\n2. Calculate `current_lcm = (a+k_g) * (b+k_g) // g`.\n3. Keep track of the minimum `current_lcm` found so far and the corresponding smallest `k_g`.\n\n**Algorithm:**\n1. If `a == b`, print `0` and exit.\n2. Calculate `diff = abs(b-a)`.\n3. Initialize `min_lcm = infinity` and `best_k = 0`.\n4. Find all divisors of `diff`. We can do this by iterating from `1` up to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff // i` are divisors.\n5. For each divisor `g` (both `i` and `diff // i`):\n   a. Calculate `k = (-a % g + g) % g`.\n   b. Calculate `current_lcm = (a+k) * (b+k) // g`.\n   c. If `current_lcm < min_lcm`:\n      `min_lcm = current_lcm`\n      `best_k = k`\n   d. Else if `current_lcm == min_lcm`:\n      `best_k = min(best_k, k)` (to choose the smallest `k`)\n6. Print `best_k`.\n\n**Example:** `a=6, b=10`\n`diff = |10-6| = 4`.\nDivisors of 4 are: 1, 2, 4.\n\n- For `g = 1`:\n  `k = (-6 % 1 + 1) % 1 = 0`.\n  `lcm(6+0, 10+0) = lcm(6, 10) = (6*10)/gcd(6,10) = 60/2 = 30`.\n  `min_lcm = 30`, `best_k = 0`.\n\n- For `g = 2`:\n  `k = (-6 % 2 + 2) % 2 = 0`. (Since 6 is a multiple of 2, 6+0 is a multiple of 2)\n  `lcm(6+0, 10+0) = lcm(6, 10) = 30`.\n  `current_lcm == min_lcm`, so `best_k = min(0, 0) = 0`.\n\n- For `g = 4`:\n  `k = (-6 % 4 + 4) % 4 = (-2 + 4) % 4 = 2`.\n  `lcm(6+2, 10+2) = lcm(8, 12) = (8*12)/gcd(8,12) = 96/4 = 24`.\n  `current_lcm = 24 < min_lcm = 30`.\n  `min_lcm = 24`, `best_k = 2`.\n\nFinal `best_k = 2`.\n\n**Constraints:** `1 <= a, b <= 10^9`.\n`diff` can be up to `10^9`. The number of divisors for a number up to `10^9` is relatively small (maximum around 1344 for `735134400`). Iterating through divisors is efficient.\n`a+k` and `b+k` can be up to `10^9 + diff` (approx `2*10^9`).\nTheir product `(a+k)*(b+k)` can be up to `(2*10^9)^2 = 4*10^{18}`. This fits within a 64-bit integer type (Python integers handle arbitrary size automatically).\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Iterate through divisors of diff\n    # We only need to check up to sqrt(diff)\n    # If i is a divisor, then diff // i is also a divisor\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors = [i]\n            if i * i != diff:\n                divisors.append(diff // i)\n            \n            for g in divisors:\n                # Calculate k such that (a+k) is a multiple of g\n                # k = (-a % g + g) % g\n                # This ensures a+k is the smallest multiple of g >= a\n                k = (g - (a % g)) % g\n                \n                current_A = a + k\n                current_B = b + k\n                \n                # Calculate lcm = (A * B) / g\n                # Since g is gcd(A, B) or a potential gcd, this is the formula.\n                # Specifically, g is a divisor of gcd(A, B)\n                # lcm(A, B) = (A * B) / gcd(A, B)\n                # We are iterating over possible values for gcd(A, B), which must be a divisor of diff.\n                # So g here is a candidate for gcd(a+k, b+k).\n                # The actual gcd is gcd(a+k, diff).\n                # The formula (a+k)*(b+k)//g is correct because g is gcd(a+k, b+k) by construction of k.\n                # Proof: By construction, a+k is a multiple of g.\n                # Since diff is a multiple of g, and b+k = a+k + diff, b+k is also a multiple of g.\n                # Thus, g is a common divisor of a+k and b+k.\n                # And gcd(a+k, b+k) must be a multiple of g.\n                # Also, gcd(a+k, b+k) must be a divisor of diff.\n                # So, g is gcd(a+k, b+k) if and only if gcd(a+k, diff) = g.\n                # Our goal is to minimize (a+k)(b+k)/gcd(a+k, b+k).\n                # Let's re-evaluate:\n                # For each divisor `g` of `diff`:\n                #   Find `k` such that `a+k` is a multiple of `g`. `k = (g - (a % g)) % g`.\n                #   Then `a+k` is a multiple of `g`.\n                #   Since `b+k = (a+k) + diff`, and `diff` is a multiple of `g`, `b+k` is also a multiple of `g`.\n                #   So, `g` is a common divisor of `a+k` and `b+k`.\n                #   Let `actual_gcd = math.gcd(a+k, b+k)`.\n                #   The `lcm = (a+k) * (b+k) // actual_gcd`.\n                #   This `actual_gcd` will be a multiple of `g` and a divisor of `diff`.\n                #   The value `(a+k)*(b+k)//g` is `lcm(a+k, b+k) * (actual_gcd / g)`.\n                #   This means we are considering values that are multiples of the actual LCM.\n                #   This approach is incorrect.\n                # Let's fix the logic for LCM calculation.\n                # We want to minimize (a+k)(b+k) / gcd(a+k, b+k).\n                # We know gcd(a+k, b+k) = gcd(a+k, diff).\n                # Let's iterate through all divisors `g` of `diff`.\n                # For each `g`, we want to find the smallest `k >= 0` such that `gcd(a+k, diff) = g`.\n                # This means `a+k` must be a multiple of `g`, AND `a+k` must NOT be a multiple of `g * p` for any prime `p` that divides `diff/g`.\n                # This is too complicated.\n\n                # Alternative perspective:\n                # We want `gcd(a+k, b+k)` to be as large as possible to make `lcm` small.\n                # The maximum possible value for `gcd(a+k, b+k)` is `diff`.\n                # If `gcd(a+k, b+k) = diff`, then `a+k` must be a multiple of `diff`.\n                # The smallest `k` for this is `k = (diff - (a % diff)) % diff`.\n                # Let's calculate the LCM for this `k`. This gives a candidate for `min_lcm`.\n                # What if `gcd(a+k, b+k)` is not `diff`? It must be some divisor `g` of `diff`.\n                # This means `a+k` must be a multiple of `g`.\n                # The smallest `k` such that `a+k` is a multiple of `g` is `k = (g - (a % g)) % g`.\n                # With this `k`, let `num1 = a+k` and `num2 = b+k`.\n                # The `lcm` is `(num1 * num2) // math.gcd(num1, num2)`.\n                # We iterate through all divisors `g` of `diff`. For each `g`, we calculate `k`, then `num1`, `num2`, then `lcm`.\n                # This is the correct approach.\n\n                # Recalculate k for the current divisor g:\n                # k is the smallest non-negative integer such that (a+k) is a multiple of g.\n                k = (g - (a % g)) % g\n                \n                num1 = a + k\n                num2 = b + k\n                \n                # Calculate the actual gcd for these num1 and num2\n                # math.gcd(num1, num2) is equivalent to math.gcd(num1, diff)\n                current_gcd = math.gcd(num1, num2)\n                \n                # Calculate the LCM\n                current_lcm = (num1 // current_gcd) * num2 # Avoid overflow by dividing first\n                \n                if current_lcm < min_lcm:\n                    min_lcm = current_lcm\n                    best_k = k\n                elif current_lcm == min_lcm:\n                    best_k = min(best_k, k)\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Iterate through divisors of diff\n    # We only need to check up to sqrt(diff)\n    # If i is a divisor, then diff // i is also a divisor\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors = [i]\n            if i * i != diff:\n                divisors.append(diff // i)\n            \n            for g in divisors:\n                # Calculate k such that (a+k) is a multiple of g\n                # k = (-a % g + g) % g\n                # This ensures a+k is the smallest multiple of g >= a\n                k = (g - (a % g)) % g\n                \n                current_A = a + k\n                current_B = b + k\n                \n                # Calculate lcm = (A * B) / g\n                # Since g is gcd(A, B) or a potential gcd, this is the formula.\n                # Specifically, g is a divisor of gcd(A, B)\n                # lcm(A, B) = (A * B) / gcd(A, B)\n                # We are iterating over possible values for gcd(A, B), which must be a divisor of diff.\n                # So g here is a candidate for gcd(a+k, b+k).\n                # The actual gcd is gcd(a+k, diff).\n                # The formula (a+k)*(b+k)//g is correct because g is gcd(a+k, b+k) by construction of k.\n                # Proof: By construction, a+k is a multiple of g.\n                # Since diff is a multiple of g, and b+k = a+k + diff, b+k is also a multiple of g.\n                # Thus, g is a common divisor of a+k and b+k.\n                # And gcd(a+k, b+k) must be a multiple of g.\n                # Also, gcd(a+k, b+k) must be a divisor of diff.\n                # So, g is gcd(a+k, b+k) if and only if gcd(a+k, diff) = g.\n                # Our goal is to minimize (a+k)(b+k)/gcd(a+k, b+k).\n                # Let's re-evaluate:\n                # For each divisor `g` of `diff`:\n                #   Find `k` such that `a+k` is a multiple of `g`. `k = (g - (a % g)) % g`.\n                #   Then `a+k` is a multiple of `g`.\n                #   Since `b+k = (a+k) + diff`, and `diff` is a multiple of `g`, `b+k` is also a multiple of `g`.\n                #   So, `g` is a common divisor of `a+k` and `b+k`.\n                #   Let `actual_gcd = math.gcd(a+k, b+k)`.\n                #   The `lcm = (a+k) * (b+k) // actual_gcd`.\n                #   This `actual_gcd` will be a multiple of `g` and a divisor of `diff`.\n                #   The value `(a+k)*(b+k)//g` is `lcm(a+k, b+k) * (actual_gcd / g)`.\n                #   This means we are considering values that are multiples of the actual LCM.\n                #   This approach is incorrect.\n                # Let's fix the logic for LCM calculation.\n                # We want to minimize (a+k)(b+k) / gcd(a+k, b+k).\n                # We know gcd(a+k, b+k) = gcd(a+k, diff).\n                # Let's iterate through all divisors `g` of `diff`.\n                # For each `g`, we want to find the smallest `k >= 0` such that `gcd(a+k, diff) = g`.\n                # This means `a+k` must be a multiple of `g`, AND `a+k` must NOT be a multiple of `g * p` for any prime `p` that divides `diff/g`.\n                # This is too complicated.\n\n                # Alternative perspective:\n                # We want `gcd(a+k, b+k)` to be as large as possible to make `lcm` small.\n                # The maximum possible value for `gcd(a+k, b+k)` is `diff`.\n                # If `gcd(a+k, b+k) = diff`, then `a+k` must be a multiple of `diff`.\n                # The smallest `k` for this is `k = (diff - (a % diff)) % diff`.\n                # Let's calculate the LCM for this `k`. This gives a candidate for `min_lcm`.\n                # What if `gcd(a+k, b+k)` is not `diff`? It must be some divisor `g` of `diff`.\n                # This means `a+k` must be a multiple of `g`.\n                # The smallest `k` such that `a+k` is a multiple of `g` is `k = (g - (a % g)) % g`.\n                # With this `k`, let `num1 = a+k` and `num2 = b+k`.\n                # The `lcm` is `(num1 * num2) // math.gcd(num1, num2)`.\n                # We iterate through all divisors `g` of `diff`. For each `g`, we calculate `k`, then `num1`, `num2`, then `lcm`.\n                # This is the correct approach.\n\n                # Recalculate k for the current divisor g:\n                # k is the smallest non-negative integer such that (a+k) is a multiple of g.\n                k = (g - (a % g)) % g\n                \n                num1 = a + k\n                num2 = b + k\n                \n                # Calculate the actual gcd for these num1 and num2\n                # math.gcd(num1, num2) is equivalent to math.gcd(num1, diff)\n                current_gcd = math.gcd(num1, num2)\n                \n                # Calculate the LCM\n                current_lcm = (num1 // current_gcd) * num2 # Avoid overflow by dividing first\n                \n                if current_lcm < min_lcm:\n                    min_lcm = current_lcm\n                    best_k = k\n                elif current_lcm == min_lcm:\n                    best_k = min(best_k, k)\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 3208,
        "thoughts_token_count": 848
    }
}