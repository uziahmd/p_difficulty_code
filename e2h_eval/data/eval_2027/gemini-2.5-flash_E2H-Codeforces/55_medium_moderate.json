{
    "start": 1758294874.2046697,
    "end": 1758294941.084548,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**The Lexicographically Smallest Ternary String**\n\nMy task is to find the lexicographically smallest ternary string given a set of allowable swaps: '0' with '1' and '1' with '2', but never '0' with '2'. This seemingly simple constraint has a profound impact. '0' can effectively \"bubble\" past '1's to the left and '2' can bubble past '1's to the right. The core realization is that the relative order of '0's and '2's within the original string is *fixed*. If a '0' appears before a '2' in the input, that order must be preserved in the output. This is the crucial invariant.\n\nThe strategy hinges on identifying and exploiting this fixed relative order.  I'll first remove the '1's, leaving me with a subsequence of '0's and '2's that represents the essential constraint. Where a '1' was matters. I count the '1's. Next, I find the first '2' in this subsequence, which effectively divides the fixed sequence. All '0's appearing before this '2' can be moved to the beginning of the string. Then I insert all the '1's (the \"mediators\") and finally, I append the remainder of the fixed sequence (the '2's and any '0's after the first '2'). This ensures that the invariant relative order is preserved and that the string is lexicographically smallest. The edge cases are handled elegantly by the placement of the '1's. The time complexity is linear and the space is also linear.\n",
    "response": "The problem asks us to find the lexicographically smallest string by performing a specific set of adjacent swaps: '0' with '1', and '1' with '2'. Swapping '0' with '2' is not allowed.\n\nLet's analyze the allowed swaps:\n1. `01 <-> 10`: A '0' can move left past a '1', and a '1' can move right past a '0'.\n2. `12 <-> 21`: A '1' can move left past a '2', and a '2' can move right past a '1'.\n\nThe crucial constraint is that `0` and `2` cannot swap directly. This implies that their relative order is fixed. If a '0' appears before a '2' in the original string, it must always appear before that '2' in any reachable string. Similarly, if a '2' appears before a '0', it must always remain before that '0'.\n\nThis means that if we consider only the '0's and '2's in the string (i.e., remove all '1's), their sequence is an invariant subsequence. For example, if `s = \"100210\"`, removing '1's gives `\"0020\"`. In any reachable string, there must be two '0's, then a '2', then another '0', in that specific relative order.\n\nThe '1's are special because they can interact with both '0's and '2's.\n- A '1' can move right past any '0'.\n- A '1' can move left past any '2'.\nThis implies that all '1's can effectively be grouped together into a single block. This block of '1's can then be positioned anywhere in the string, as long as it doesn't cause a '0' to cross a '2' (which is impossible anyway due to the fixed relative order of '0's and '2's).\n\nTo obtain the lexicographically smallest string, we want to place as many '0's as possible at the beginning, then '1's, then '2's.\nGiven the fixed relative order of '0's and '2's, the optimal strategy for placing the '1's is as follows:\n1. All '0's that appear before any '2' in the original string (or more precisely, before the *first* '2' in the `0`s-and-`2`s-only subsequence) can be moved to the very beginning of the string.\n2. All '1's should then be placed immediately after these initial '0's. This positions them as far left as possible without being before any '0's that could move left, and before any '2's.\n3. The remaining '2's (including the first one) and any '0's that originally appeared after a '2' must follow the block of '1's, maintaining their fixed relative order.\n\nThis leads to the following algorithm:\n1. Iterate through the input string `s`.\n2. Count the total number of '1's. Let this be `num_ones`.\n3. Construct a new string (or character list) `s_02` by taking all characters from `s` that are '0' or '2'.\n4. Find the index of the first occurrence of '2' in `s_02`. Let this be `first_two_idx`.\n   - If no '2' is found in `s_02` (meaning `s` only contains '0's and '1's): The result will be all '0's from `s_02` followed by all '1's.\n   - If no '0' is found in `s_02` (meaning `s` only contains '1's and '2's): The result will be all '1's followed by all '2's from `s_02`. (Note: this is a special case of the general rule below, where `s_02[0:first_two_idx]` would be empty).\n   - Otherwise (both '0's and '2's exist in `s_02`):\n     The resulting string will be formed by:\n     `s_02[0 : first_two_idx]` (all '0's that appear before the first '2')\n     + `num_ones` '1's\n     + `s_02[first_two_idx : ]` (the first '2' and all subsequent '0's and '2's).\n\nLet's trace with an example: `s = \"100210\"`\n1. `num_ones = 2` (from the '1' at index 0 and '1' at index 4).\n2. `s_02 = \"0020\"` (removing '1's from \"100210\").\n3. `first_two_idx` in `s_02` is 2 (the '2' is at index 2 in \"0020\").\n4. Construct the result:\n   - `s_02[0:2]` is `\"00\"`.\n   - `num_ones` '1's is `\"11\"`.\n   - `s_02[2:]` is `\"20\"`.\n   - Concatenating these gives `\"00\" + \"11\" + \"20\" = \"001120\"`.\n\nThis strategy ensures that:\n- All '0's that are not \"trapped\" by a preceding '2' are moved to the earliest possible positions.\n- All '1's are grouped and placed after these initial '0's, which is the lexicographically optimal position for them given the constraints.\n- The remaining '2's and '0's (whose relative order is fixed) are appended, preserving their structure.\n\nThe time complexity will be O(N) for iterating through the string, building `s_02`, finding the index of '2', and concatenating the final string. The space complexity will be O(N) for storing `s_02` and the result. Given N up to 10^5, this is efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    num_ones = 0\n    s_02_chars = [] # To store '0's and '2's in their original relative order\n\n    for char in s:\n        if char == '1':\n            num_ones += 1\n        else:\n            s_02_chars.append(char)\n    \n    s_02 = \"\".join(s_02_chars)\n\n    # Find the first occurrence of '2' in the s_02 string\n    # All '0's before this '2' can move to the very beginning.\n    # All '1's will be placed after these '0's.\n    # The '2' and any characters after it will follow the '1's.\n    \n    first_two_idx = -1\n    for i in range(len(s_02)):\n        if s_02[i] == '2':\n            first_two_idx = i\n            break\n    \n    result_parts = []\n    if first_two_idx == -1:\n        # No '2's in the string (only '0's and '1's).\n        # All '0's can move to the left of all '1's.\n        result_parts.append(s_02) # All '0's\n        result_parts.append('1' * num_ones)\n    else:\n        # '0's and '2's are present.\n        # '0's before the first '2' in s_02\n        result_parts.append(s_02[0:first_two_idx])\n        # All '1's\n        result_parts.append('1' * num_ones)\n        # The first '2' and all characters after it in s_02\n        result_parts.append(s_02[first_two_idx:])\n    \n    print(\"\".join(result_parts))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n\n    num_ones = 0\n    s_02_chars = [] # To store '0's and '2's in their original relative order\n\n    for char in s:\n        if char == '1':\n            num_ones += 1\n        else:\n            s_02_chars.append(char)\n    \n    s_02 = \"\".join(s_02_chars)\n\n    # Find the first occurrence of '2' in the s_02 string\n    # All '0's before this '2' can move to the very beginning.\n    # All '1's will be placed after these '0's.\n    # The '2' and any characters after it will follow the '1's.\n    \n    first_two_idx = -1\n    for i in range(len(s_02)):\n        if s_02[i] == '2':\n            first_two_idx = i\n            break\n    \n    result_parts = []\n    if first_two_idx == -1:\n        # No '2's in the string (only '0's and '1's).\n        # All '0's can move to the left of all '1's.\n        result_parts.append(s_02) # All '0's\n        result_parts.append('1' * num_ones)\n    else:\n        # '0's and '2's are present.\n        # '0's before the first '2' in s_02\n        result_parts.append(s_02[0:first_two_idx])\n        # All '1's\n        result_parts.append('1' * num_ones)\n        # The first '2' and all characters after it in s_02\n        result_parts.append(s_02[first_two_idx:])\n    \n    print(\"\".join(result_parts))\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 613,
        "completion_token_count": 1879,
        "thoughts_token_count": 8192
    }
}