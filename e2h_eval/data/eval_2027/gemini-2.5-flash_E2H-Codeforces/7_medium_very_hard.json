{
    "start": 1758011814.387828,
    "end": 1758011918.8495936,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Rudolf and the Snowflake Problem**\n\nOkay, so I'm tackling this \"Rudolf and Snowflakes\" problem. The core of it is figuring out if a number, `n`, can be the total number of vertices in a \"snowflake\" graph. A snowflake is built in a specific way using a parameter `k` which has to be greater than 1. The problem involves a root vertex, then connecting it to `k` new ones, and repeatedly attaching `k` new vertices to any vertex that's only connected to one other.\n\nHere's how I broke it down:\n\n*   **Understanding the Snowflake Structure:** The crucial thing is the geometric series that emerges. If you repeat the \"attach `k` new vertices\" step `d` times, you get `n = 1 + k + k^2 + ... + k^(d+1)`.  The first term is always 1 (the root), and it's the sum of a geometric progression, so `n = (k^(d+2) - 1) / (k - 1)`. I need to find if there exist whole numbers for `k` and `d` that make this equation true, given an input `n`.\n*   **Case Analysis:** I've separated this into two key scenarios:\n\n    *   **d = 0:** The problem requires it to happen at least once, so it's not a valid case.\n    *   **D = 2 (d=1):**  Then, `n = 1 + k + k^2`. I rearranged this into a quadratic in `k` and solved it using the quadratic formula. For `k` to be an integer, the discriminant (part under the square root) has to be a perfect square, and it needs to be greater than 3, so `k > 1` holds.\n    *   **D >= 3 (d>=2):** I know `n` can also be calculated as `n = (k^(D+1) - 1) / (k-1)`. When `k=2`, `n = 2^(D+1) - 1`. If `n+1` is a power of 2, I found a solution.\n\n*   **Bounds and Search:**\n    *   I realized the brute force approach is feasible because the maximum number of times you could repeat the attach process is limited by `n`. Basically `D < log(n) / log(k)`. If `k=2`, `D < 60`.\n    *   For each value of `D` from 3 up to around 60 (or fewer for larger `n` or small `k`), I need to check if there is a corresponding valid `k`. So, I'll be using binary search for each value of D.\n    *   Binary Search bounds: The smallest `k` can be is 2, and the largest `k` is roughly `n^(1/D)` (or fewer, because k has to create the number n as `(k^(D+1)-1)/(k-1)` which can also have overflow.\n\n*   **Efficient Calculation and Overflow Prevention:** Calculating `k^(D+1)` directly and `1 + k + k^2 + ... k^D` directly will likely cause integer overflow if numbers get too large. Instead, I am summing up each value, i.e., `k, k^2, ..., k^D` in a loop, checking that each value is no larger than n.\n\nSo, I wrote a Python script. It uses a loop for `D` going up to a maximum. For each `D`, it uses binary search for `k` to find out whether we can make that number of nodes for n. The code checks for integer overflow within the nested binary search, and it checks the discriminant is a perfect square. If it can find a valid k for either of the cases, I can return YES and if not, NO.\n",
    "response": "The problem asks us to determine if a given integer `n` ($1 \\le n \\le 10^{18}$) can be the total number of vertices in a snowflake graph. A snowflake is constructed with a parameter `k > 1` and a number of \"expansion\" steps `d >= 1`.\n\nLet's analyze the construction process to find the formula for `n`:\n1.  Start with 1 central vertex (the root).\n2.  Connect the root to `k` new vertices. Total vertices: `1 + k`.\n3.  This step is repeated `d` times (`d >= 1`): Each vertex connected to only one other vertex is connected to `k` more new vertices.\n\nLet's trace the number of vertices:\n*   After step 2: `1 + k` vertices. The `k` new vertices are leaves.\n*   If `d = 1`: Each of the `k` leaf vertices gets `k` new children. Total new vertices: `k * k = k^2`.\n    Total vertices `n = 1 + k + k^2`.\n*   If `d = 2`: Each of the `k^2` leaf vertices (from the previous step) gets `k` new children. Total new vertices: `k^2 * k = k^3`.\n    Total vertices `n = 1 + k + k^2 + k^3`.\n*   In general, if step 3 is performed `d` times, the total number of vertices `n` will be the sum of a geometric series:\n    `n = 1 + k + k^2 + ... + k^(d+1)`\n\nLet `D = d+1`. Since `d >= 1`, we have `D >= 2`.\nSo, `n = 1 + k + k^2 + ... + k^D` for some integers `k > 1` and `D >= 2`.\n\nThis sum can be expressed using the geometric series formula: `n = (k^(D+1) - 1) / (k - 1)`.\n\nWe need to check if for a given `n`, there exist `k > 1` and `D >= 2` satisfying this equation.\n\nThere are two main cases:\n\n**Case 1: D = 2**\nIn this case, `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nWe can solve for `k` using the quadratic formula: `k = (-1 +/- sqrt(1 - 4 * (1 - n))) / 2`.\nSimplifying, `k = (-1 +/- sqrt(4n - 3)) / 2`.\nFor `k` to be a positive integer, `4n - 3` must be a perfect square, say `s^2`.\nThen `k = (-1 + s) / 2` (since `k > 0`, we take the positive root).\nWe also require `k > 1`. So `(-1 + s) / 2 > 1` implies `s - 1 > 2`, which means `s > 3`.\nAdditionally, `s^2 = 4n - 3`. Since `4n` is even and `3` is odd, `4n - 3` is odd. If `s^2` is odd, `s` must be odd. This ensures `s-1` is even, so `k` is an integer.\nSo, for `D=2`, we check if `4n - 3` is a perfect square `s^2` such that `s > 3`.\n\n**Case 2: D >= 3**\nFor these cases, `n = 1 + k + k^2 + ... + k^D`.\nSince `k > 1`, the smallest `k` can be is 2.\nIf `k = 2`, then `n = 1 + 2 + 2^2 + ... + 2^D = 2^(D+1) - 1`.\nIn this situation, `n+1` must be a power of 2, i.e., `n+1 = 2^(D+1)`. We would then need `D+1 >= 4` (since `D >= 3`).\nThe maximum value of `n` is `10^{18}`.\nIf `k=2`, `2^D < n <= 10^{18}`. This implies `D < log2(10^{18}) \\approx 59.79`. So `D` can range from 3 up to 59.\nThis range of `D` is small enough to iterate through.\n\nFor each `D` from 3 to 59:\nWe need to find if there exists an integer `k > 1` such that `n = 1 + k + ... + k^D`.\nThe function `f(k) = 1 + k + ... + k^D` is strictly increasing for `k > 0`. This allows us to use binary search for `k`.\nThe lower bound for `k` is 2.\nThe upper bound for `k` can be estimated from `k^D < n`. So `k < n^(1/D)`.\nFor `D=3`, `k < (10^{18})^(1/3) = 10^6`.\nFor larger `D`, `n^(1/D)` will be smaller. For instance, for `D=59`, `k < (10^{18})^(1/59) \\approx 2`.\nSo, `k` will be in the range `[2, 10^6 + C]` (where `C` is a small constant for safety).\n\n**Binary Search Implementation for `k`:**\nInside the loop for `D`:\n1.  Initialize `low = 2`, `high = int(n**(1/D)) + 2`. (The `+2` is a small buffer for potential floating point inaccuracies and to ensure `high` is at least `low` if `n^(1/D)` is small).\n2.  While `low <= high`:\n    *   Calculate `mid_k = (low + high) // 2`.\n    *   If `mid_k < 2`, set `low = 2` and continue (should not happen with `low` initialized to 2).\n    *   Calculate `current_sum = 1 + mid_k + ... + mid_k^D`.\n        *   **Overflow prevention:** When calculating `term = mid_k^i` and `current_sum += term`, we must be careful not to exceed `n` or `10^18` (Python handles large integers automatically, but for competitive programming in other languages, this is crucial. In Python, we can just compare `current_sum` with `n`). If `current_sum` exceeds `n` at any point, we know `mid_k` is too large.\n        *   A safe way to compute `1 + k + ... + k^D` iteratively:\n            `current_sum = 1`\n            `term = 1`\n            For `i` from 1 to `D`:\n                If `term > n // mid_k` (i.e., `term * mid_k` would exceed `n`): `current_sum = n + 1` (mark as overflow) and break.\n                `term *= mid_k`\n                If `current_sum > n - term` (i.e., `current_sum + term` would exceed `n`): `current_sum = n + 1` (mark as overflow) and break.\n                `current_sum += term`\n    *   If `current_sum == n`, we found a valid `k` and `D`. Return `True`.\n    *   If `current_sum < n`, `mid_k` is too small. Set `low = mid_k + 1`.\n    *   If `current_sum > n`, `mid_k` is too large. Set `high = mid_k - 1`.\n3.  If the loops complete without finding a solution, return `False`.\n\n**Edge Cases and Constraints:**\n*   `n=1, 2, 3, 6`: These are too small to form a snowflake as per the rules (`k > 1`, `D >= 2`). The code should correctly return `NO`.\n    *   For `n=1`: `4n-3 = 1`, `s=1`, `s>3` is false. Loop for `D` will find `current_sum > n` for `k=2`.\n    *   For `n=2`: `4n-3 = 5`, not square. Loop for `D` will find `current_sum > n` for `k=2`.\n    *   For `n=3`: `4n-3 = 9`, `s=3`, `s>3` is false. Loop for `D` will find `current_sum > n` for `k=2`.\n    *   For `n=6`: `4n-3 = 21`, not square. Loop for `D` will find `current_sum > n` for `k=2`.\n*   `n=10^{18}`: `4n-3` ends in `7`, so not a perfect square (`D=2` fails). The `D` loop will iterate and binary search. The largest `k` can be `10^6` (for `D=3`). The largest `D` is `59` (for `k=2`). The number of iterations for `D` is about 57. The binary search takes `log(10^6)` steps, which is about 20. Total operations `57 * 20 * 59` (for sum calculation) which is feasible.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Case D = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # (2k+1)^2 = 4n - 3\n    \n    val_for_k2 = 4 * n - 3\n    s = int(math.isqrt(val_for_k2)) # Using math.isqrt for integer square root\n    \n    if s * s == val_for_k2:\n        # If it's a perfect square, check if k = (s - 1) / 2 is an integer > 1\n        # s must be odd because 4n-3 is odd. If s is odd, s-1 is even.\n        # So (s-1) is always even if s is an integer.\n        k_candidate = (s - 1) // 2\n        if k_candidate > 1:\n            print(\"YES\")\n            return\n\n    # Case D >= 3: n = 1 + k + ... + k^D\n    # Iterate D from 3 up to max_D\n    # Max D: for k=2, n = 2^(D+1) - 1. So 2^(D+1) = n+1.\n    # D+1 = log2(n+1). For n=10^18, D+1 approx log2(10^18) approx 59.79.\n    # So D+1 can be at most 59, meaning D can be at most 58.\n    # Let's use 60 as a safe upper bound for D.\n    \n    for D in range(3, 61): # D goes from 3 to 60\n        # Binary search for k\n        # k^D < n, so k < n^(1/D)\n        # Upper bound for k: n^(1/D). For D=3, k < (10^18)^(1/3) = 10^6.\n        # For D=60, k < (10^18)^(1/60) approx 2.\n        \n        low = 2\n        # Calculate a safe upper bound for k.\n        # min(int(n**(1/D)) + 2, 10**6 + 5) is a good upper bound.\n        # If n**(1/D) is very small (e.g., 1.x), int(n**(1/D)) will be 1. Add 2 to ensure high >= 2.\n        high = int(n**(1/D)) + 2 \n        # If n is very small, n**(1/D) could be 1. high could be 3.\n        # If n = 13, D = 4. 13^(1/4) approx 1.89. high = 1+2 = 3. Range [2,3].\n        \n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            # Calculate sum = 1 + mid_k + ... + mid_k^D\n            current_sum = 1\n            term = 1 # Represents mid_k^i\n            \n            # Use a loop to calculate the sum and check for overflow\n            # Python handles large integers, so explicit overflow checks are for efficiency\n            # and to mimic how it would be done in C++/Java.\n            # If current_sum exceeds n, then mid_k is too large.\n            \n            for _ in range(D): # This loop runs D times to add k^1, ..., k^D\n                # Check for potential overflow before multiplying term by mid_k\n                # If term * mid_k > n, then mid_k is too large.\n                # This is equivalent to term > n / mid_k.\n                # If term itself is already > n, then term * mid_k will definitely be > n.\n                if term > n // mid_k: \n                    current_sum = n + 1 # Indicate that sum would exceed n\n                    break\n                \n                term *= mid_k\n                \n                # Check for potential overflow before adding term to current_sum\n                # If current_sum + term > n, then mid_k is too large.\n                # This is equivalent to current_sum > n - term.\n                if current_sum > n - term:\n                    current_sum = n + 1 # Indicate that sum would exceed n\n                    break\n                \n                current_sum += term\n            \n            if current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n (or overflowed to n + 1)\n                high = mid_k - 1\n                \n    print(\"NO\")\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Case D = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # (2k+1)^2 = 4n - 3\n    \n    val_for_k2 = 4 * n - 3\n    s = int(math.isqrt(val_for_k2)) # Using math.isqrt for integer square root\n    \n    if s * s == val_for_k2:\n        # If it's a perfect square, check if k = (s - 1) / 2 is an integer > 1\n        # s must be odd because 4n-3 is odd. If s is odd, s-1 is even.\n        # So (s-1) is always even if s is an integer.\n        k_candidate = (s - 1) // 2\n        if k_candidate > 1:\n            print(\"YES\")\n            return\n\n    # Case D >= 3: n = 1 + k + ... + k^D\n    # Iterate D from 3 up to max_D\n    # Max D: for k=2, n = 2^(D+1) - 1. So 2^(D+1) = n+1.\n    # D+1 = log2(n+1). For n=10^18, D+1 approx log2(10^18) approx 59.79.\n    # So D+1 can be at most 59, meaning D can be at most 58.\n    # Let's use 60 as a safe upper bound for D.\n    \n    for D in range(3, 61): # D goes from 3 to 60\n        # Binary search for k\n        # k^D < n, so k < n^(1/D)\n        # Upper bound for k: n^(1/D). For D=3, k < (10^18)^(1/3) = 10^6.\n        # For D=60, k < (10^18)^(1/60) approx 2.\n        \n        low = 2\n        # Calculate a safe upper bound for k.\n        # min(int(n**(1/D)) + 2, 10**6 + 5) is a good upper bound.\n        # If n**(1/D) is very small (e.g., 1.x), int(n**(1/D)) will be 1. Add 2 to ensure high >= 2.\n        high = int(n**(1/D)) + 2 \n        # If n is very small, n**(1/D) could be 1. high could be 3.\n        # If n = 13, D = 4. 13^(1/4) approx 1.89. high = 1+2 = 3. Range [2,3].\n        \n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # k must be > 1\n                low = 2\n                continue\n            \n            # Calculate sum = 1 + mid_k + ... + mid_k^D\n            current_sum = 1\n            term = 1 # Represents mid_k^i\n            \n            # Use a loop to calculate the sum and check for overflow\n            # Python handles large integers, so explicit overflow checks are for efficiency\n            # and to mimic how it would be done in C++/Java.\n            # If current_sum exceeds n, then mid_k is too large.\n            \n            for _ in range(D): # This loop runs D times to add k^1, ..., k^D\n                # Check for potential overflow before multiplying term by mid_k\n                # If term * mid_k > n, then mid_k is too large.\n                # This is equivalent to term > n / mid_k.\n                # If term itself is already > n, then term * mid_k will definitely be > n.\n                if term > n // mid_k: \n                    current_sum = n + 1 # Indicate that sum would exceed n\n                    break\n                \n                term *= mid_k\n                \n                # Check for potential overflow before adding term to current_sum\n                # If current_sum + term > n, then mid_k is too large.\n                # This is equivalent to current_sum > n - term.\n                if current_sum > n - term:\n                    current_sum = n + 1 # Indicate that sum would exceed n\n                    break\n                \n                current_sum += term\n            \n            if current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n (or overflowed to n + 1)\n                high = mid_k - 1\n                \n    print(\"NO\")\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 3434,
        "thoughts_token_count": 6401
    }
}